```diff
diff --git a/androidx-studio-integration.sh b/androidx-studio-integration.sh
index 55b272447..5d72dad65 100755
--- a/androidx-studio-integration.sh
+++ b/androidx-studio-integration.sh
@@ -14,6 +14,14 @@ mkdir -p "$DIST_DIR"
 export OUT_DIR=out
 export DIST_DIR="$DIST_DIR"
 
+plat="linux"
+case "`uname`" in
+  Darwin* )
+    plat="darwin"
+    ;;
+esac
+export ANDROID_HOME="$(pwd)/prebuilts/fullsdk-$plat"
+
 JAVA_HOME="$(pwd)/prebuilts/studio/jdk/jbr-next/linux" tools/gradlew -p tools/ publishLocal --stacktrace
 
 # Depend on the generated version.properties file, as the version depends on
diff --git a/buildSrc/src/main/kotlin/com/android/tools/metalava/Ktfmt.kt b/buildSrc/src/main/kotlin/com/android/tools/metalava/Ktfmt.kt
index d58658408..d9723810e 100644
--- a/buildSrc/src/main/kotlin/com/android/tools/metalava/Ktfmt.kt
+++ b/buildSrc/src/main/kotlin/com/android/tools/metalava/Ktfmt.kt
@@ -39,7 +39,7 @@ import org.gradle.process.ExecOperations
 private fun Project.getKtfmtConfiguration(): Configuration {
     return configurations.findByName("ktfmt")
         ?: configurations.create("ktfmt") {
-            val dependency = project.dependencies.create("com.facebook:ktfmt:0.44")
+            val dependency = project.dependencies.create("com.facebook:ktfmt:0.50")
             it.dependencies.add(dependency)
         }
 }
diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index dfe205508..b36f801c1 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -1,9 +1,9 @@
 [versions]
 kotlin = "2.1.0"
-androidLint = "31.10.0-alpha06"
+androidLint = "31.11.0-alpha10"
 
 [libraries]
-androidGradlePlugin = { module = "com.android.tools.build:gradle", version = "8.10.0-alpha06" }
+androidGradlePlugin = { module = "com.android.tools.build:gradle", version = "8.11.0-alpha10" }
 androidLint = { module = "com.android.tools.lint:lint", version.ref = "androidLint" }
 androidLintApi = { module = "com.android.tools.lint:lint-api", version.ref = "androidLint" }
 androidLintChecks = { module = "com.android.tools.lint:lint-checks", version.ref = "androidLint" }
@@ -23,6 +23,7 @@ jacksonDataformatXml = { module = "com.fasterxml.jackson.dataformat:jackson-data
 jacksonModuleKotlin = { module = "com.fasterxml.jackson.module:jackson-module-kotlin", version = "2.15.0" }
 junit4 = { module = "junit:junit", version = "4.13.2" }
 kotlinGradlePlugin = { module = "org.jetbrains.kotlin:kotlin-gradle-plugin", version.ref = "kotlin" }
+kotlinMetadataJvm = { module = "org.jetbrains.kotlin:kotlin-metadata-jvm", version.ref = "kotlin" }
 kotlinStdlib = { module = "org.jetbrains.kotlin:kotlin-stdlib", version.ref = "kotlin" }
 kotlinTest = { module = "org.jetbrains.kotlin:kotlin-test", version.ref = "kotlin" }
 truth = { module = "com.google.truth:truth", version = "1.1.3" }
diff --git a/gradle/verification-metadata.xml b/gradle/verification-metadata.xml
index 87e494f0a..644c6a955 100644
--- a/gradle/verification-metadata.xml
+++ b/gradle/verification-metadata.xml
@@ -224,6 +224,7 @@
          <trusted-key id="EB1B3DE71713C9EC2E87CC26EE92349AD86DE446" group="com.google.j2objc"/>
          <trusted-key id="EE0CA873074092F806F59B65D364ABAA39A47320">
             <trusting group="com.google.errorprone"/>
+            <trusting group="com.google.googlejavaformat"/>
             <trusting group="com.google.turbine"/>
          </trusted-key>
          <trusted-key id="F1A51E051F527E0C8E24D54D4B1E11D5A4B91E89" group="com.google.protobuf"/>
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 0af0eb668..97871a74f 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,7 +1,7 @@
 #Tue May 30 13:39:24 PDT 2023
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-8.12-bin.zip
-distributionSha256Sum=7a00d51fb93147819aab76024feece20b6b84e420694101f276be952e08bef03
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.13-bin.zip
+distributionSha256Sum=20f1b1176237254a6fc204d8434196fa11a4cfb387567519c61556e8710aed78
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
diff --git a/metalava-model-psi/Android.bp b/metalava-model-psi/Android.bp
index d8aaa6a3e..5ed8b01c3 100644
--- a/metalava-model-psi/Android.bp
+++ b/metalava-model-psi/Android.bp
@@ -32,5 +32,6 @@ java_library_host {
         "metalava-tools-common-m2-deps",
         // Needed for guava stuff
         "metalava-gradle-plugin-deps",
+        "kotlin_metadata_jvm",
     ],
 }
diff --git a/metalava-model-psi/build.gradle.kts b/metalava-model-psi/build.gradle.kts
index 81a276389..ae1cab9d4 100644
--- a/metalava-model-psi/build.gradle.kts
+++ b/metalava-model-psi/build.gradle.kts
@@ -34,6 +34,7 @@ dependencies {
     implementation(libs.androidLintGradle)
     implementation(libs.androidLint)
     implementation(libs.androidToolsCommon)
+    implementation(libs.kotlinMetadataJvm)
 
     testImplementation(testFixtures(project(":metalava-model")))
     // Pick up the SourceModelSuiteRunner service to run the `metalava-model-testsuite`.
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/CodePrinter.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/CodePrinter.kt
deleted file mode 100644
index 8c8affa3f..000000000
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/CodePrinter.kt
+++ /dev/null
@@ -1,581 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.psi
-
-import com.android.SdkConstants.DOT_CLASS
-import com.android.tools.lint.detector.api.ConstantEvaluator
-import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.FilterPredicate
-import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.canonicalizeFloatingPointString
-import com.android.tools.metalava.model.javaEscapeString
-import com.android.tools.metalava.reporter.Issues
-import com.android.tools.metalava.reporter.Reporter
-import com.intellij.psi.PsiAnnotation
-import com.intellij.psi.PsiAnnotationMemberValue
-import com.intellij.psi.PsiArrayInitializerMemberValue
-import com.intellij.psi.PsiClass
-import com.intellij.psi.PsiClassObjectAccessExpression
-import com.intellij.psi.PsiElement
-import com.intellij.psi.PsiField
-import com.intellij.psi.PsiLiteral
-import com.intellij.psi.PsiReference
-import com.intellij.psi.PsiTypeCastExpression
-import com.intellij.psi.PsiVariable
-import org.jetbrains.kotlin.name.ClassId
-import org.jetbrains.kotlin.name.Name
-import org.jetbrains.uast.UAnnotation
-import org.jetbrains.uast.UBinaryExpression
-import org.jetbrains.uast.UBinaryExpressionWithType
-import org.jetbrains.uast.UBlockExpression
-import org.jetbrains.uast.UCallExpression
-import org.jetbrains.uast.UElement
-import org.jetbrains.uast.UExpression
-import org.jetbrains.uast.ULambdaExpression
-import org.jetbrains.uast.ULiteralExpression
-import org.jetbrains.uast.UReferenceExpression
-import org.jetbrains.uast.UUnaryExpression
-import org.jetbrains.uast.util.isArrayInitializer
-import org.jetbrains.uast.util.isConstructorCall
-import org.jetbrains.uast.util.isTypeCast
-
-/** Utility methods */
-class CodePrinter(
-    private val codebase: Codebase,
-    private val reporter: Reporter,
-    /**
-     * Whether we should inline the values of fields, e.g. instead of "Integer.MAX_VALUE" we'd emit
-     * "0x7fffffff"
-     */
-    private val inlineFieldValues: Boolean = true,
-    /** Whether we should inline constants when possible, e.g. instead of "2*20+2" we'd emit "42" */
-    private val inlineConstants: Boolean = true,
-    /**
-     * Whether we should drop unknown AST nodes instead of inserting the corresponding source text
-     * strings
-     */
-    private val skipUnknown: Boolean = false,
-    /** An optional filter to use to determine if we should emit a reference to an item */
-    private val filterReference: FilterPredicate? = null
-) {
-    private fun warning(message: String, psiElement: PsiElement? = null) {
-        reporter.report(Issues.INTERNAL_ERROR, psiElement, message)
-    }
-
-    private fun warning(message: String, uElement: UElement) {
-        warning(message, uElement.sourcePsi ?: uElement.javaPsi)
-    }
-
-    /** Given an annotation member value, returns the corresponding Java source expression */
-    internal fun toSourceExpression(value: PsiAnnotationMemberValue, owner: Item): String {
-        val sb = StringBuilder()
-        appendSourceExpression(value, sb, owner)
-        return sb.toString()
-    }
-
-    private fun appendSourceExpression(
-        value: PsiAnnotationMemberValue,
-        sb: StringBuilder,
-        owner: Item
-    ): Boolean {
-        if (value is PsiReference) {
-            val resolved = value.resolve()
-            if (resolved is PsiField) {
-                sb.append(resolved.containingClass?.qualifiedName).append('.').append(resolved.name)
-                return true
-            }
-        } else if (value is PsiLiteral) {
-            return appendSourceLiteral(value.value, sb, owner)
-        } else if (value is PsiClassObjectAccessExpression) {
-            sb.append(value.operand.type.canonicalText).append(DOT_CLASS)
-            return true
-        } else if (value is PsiArrayInitializerMemberValue) {
-            sb.append('{')
-            var first = true
-            val initialLength = sb.length
-            for (e in value.initializers) {
-                val length = sb.length
-                if (first) {
-                    first = false
-                } else {
-                    sb.append(", ")
-                }
-                val appended = appendSourceExpression(e, sb, owner)
-                if (!appended) {
-                    // trunk off comma if it bailed for some reason (e.g. constant
-                    // filtered out by API etc)
-                    sb.setLength(length)
-                    if (length == initialLength) {
-                        first = true
-                    }
-                }
-            }
-            sb.append('}')
-            return true
-        } else if (value is PsiAnnotation) {
-            sb.append('@').append(value.qualifiedName)
-            return true
-        } else {
-            if (value is PsiTypeCastExpression) {
-                val type = value.castType?.type
-                val operand = value.operand
-                if (type != null && operand is PsiAnnotationMemberValue) {
-                    sb.append('(')
-                    sb.append(type.canonicalText)
-                    sb.append(')')
-                    return appendSourceExpression(operand, sb, owner)
-                }
-            }
-            val constant = ConstantEvaluator.evaluate(null, value)
-            if (constant != null) {
-                return appendSourceLiteral(constant, sb, owner)
-            }
-        }
-        reporter.report(Issues.INTERNAL_ERROR, owner, "Unexpected annotation default value $value")
-        return false
-    }
-
-    private fun appendSourceLiteral(v: Any?, sb: StringBuilder, owner: Item): Boolean {
-        if (v == null) {
-            sb.append("null")
-            return true
-        }
-        when (v) {
-            is Int,
-            is Boolean,
-            is Byte,
-            is Short -> {
-                sb.append(v.toString())
-                return true
-            }
-            is Long -> {
-                sb.append(v.toString()).append('L')
-                return true
-            }
-            is String -> {
-                sb.append('"').append(javaEscapeString(v)).append('"')
-                return true
-            }
-            is Float -> {
-                return when {
-                    v == Float.POSITIVE_INFINITY -> {
-                        // This convention (displaying fractions) is inherited from doclava
-                        sb.append("(1.0f/0.0f)")
-                        true
-                    }
-                    v == Float.NEGATIVE_INFINITY -> {
-                        sb.append("(-1.0f/0.0f)")
-                        true
-                    }
-                    java.lang.Float.isNaN(v) -> {
-                        sb.append("(0.0f/0.0f)")
-                        true
-                    }
-                    else -> {
-                        sb.append(canonicalizeFloatingPointString(v.toString()) + "f")
-                        true
-                    }
-                }
-            }
-            is Double -> {
-                return when {
-                    v == Double.POSITIVE_INFINITY -> {
-                        // This convention (displaying fractions) is inherited from doclava
-                        sb.append("(1.0/0.0)")
-                        true
-                    }
-                    v == Double.NEGATIVE_INFINITY -> {
-                        sb.append("(-1.0/0.0)")
-                        true
-                    }
-                    java.lang.Double.isNaN(v) -> {
-                        sb.append("(0.0/0.0)")
-                        true
-                    }
-                    else -> {
-                        sb.append(canonicalizeFloatingPointString(v.toString()))
-                        true
-                    }
-                }
-            }
-            is Char -> {
-                sb.append('\'').append(javaEscapeString(v.toString())).append('\'')
-                return true
-            }
-            else -> {
-                reporter.report(Issues.INTERNAL_ERROR, owner, "Unexpected literal value $v")
-            }
-        }
-
-        return false
-    }
-
-    fun toSourceString(value: UExpression?): String? {
-        value ?: return null
-        val sb = StringBuilder()
-        return if (appendExpression(sb, value)) {
-            sb.toString()
-        } else {
-            null
-        }
-    }
-
-    private fun appendExpression(sb: StringBuilder, expression: UExpression): Boolean {
-        if (expression.isArrayInitializer()) {
-            val call = expression as UCallExpression
-            val initializers = call.valueArguments
-            sb.append('{')
-            var first = true
-            val initialLength = sb.length
-            for (e in initializers) {
-                val length = sb.length
-                if (first) {
-                    first = false
-                } else {
-                    sb.append(", ")
-                }
-                val appended = appendExpression(sb, e)
-                if (!appended) {
-                    // truncate trailing comma if it bailed for some reason (e.g. constant
-                    // filtered out by API etc)
-                    sb.setLength(length)
-                    if (length == initialLength) {
-                        first = true
-                    }
-                }
-            }
-            sb.append('}')
-            return sb.length != 2
-        } else if (expression is UReferenceExpression) {
-            when (val resolved = expression.resolve()) {
-                is PsiField -> {
-                    @Suppress("UnnecessaryVariable") val field = resolved
-                    if (!inlineFieldValues) {
-                        val value = field.computeConstantValue()
-                        if (appendLiteralValue(sb, value)) {
-                            return true
-                        }
-                    }
-
-                    val declaringClass = field.containingClass
-                    if (declaringClass == null) {
-                        warning("No containing class found for " + field.name, field)
-                        return false
-                    }
-                    val qualifiedName = declaringClass.qualifiedName
-                    val fieldName = field.name
-
-                    if (qualifiedName != null) {
-                        if (filterReference != null) {
-                            val cls = codebase.findClass(qualifiedName)
-                            val fld = cls?.findField(fieldName, true)
-                            if (fld == null || !filterReference.test(fld)) {
-                                // This field is not visible: remove from typedef
-                                if (fld != null) {
-                                    reporter.report(
-                                        Issues.HIDDEN_TYPEDEF_CONSTANT,
-                                        fld,
-                                        "Typedef class references hidden field $fld: removed from typedef metadata"
-                                    )
-                                }
-                                return false
-                            }
-                        }
-                        sb.append(qualifiedName)
-                        sb.append('.')
-                        sb.append(fieldName)
-                        return true
-                    }
-                    return if (skipUnknown) {
-                        false
-                    } else {
-                        sb.append(expression.asSourceString())
-                        true
-                    }
-                }
-                is PsiVariable -> {
-                    sb.append(resolved.name)
-                    return true
-                }
-                else -> {
-                    if (skipUnknown) {
-                        warning("Unexpected reference to $expression", expression)
-                        return false
-                    }
-                    sb.append(expression.asSourceString())
-                    return true
-                }
-            }
-        } else if (expression is ULiteralExpression) {
-            val literalValue = expression.value
-            if (appendLiteralValue(sb, literalValue)) {
-                return true
-            }
-        } else if (expression is UAnnotation) {
-            sb.append('@').append(expression.qualifiedName)
-            return true
-        } else if (expression is UBinaryExpressionWithType) {
-            if ((expression).isTypeCast()) {
-                sb.append('(').append(expression.type.canonicalText).append(')')
-                val operand = expression.operand
-                return appendExpression(sb, operand)
-            }
-            return false
-        } else if (expression is UBinaryExpression) {
-            if (inlineConstants) {
-                val constant = expression.evaluate()
-                if (constant != null) {
-                    sb.append(constantToSource(constant))
-                    return true
-                }
-            }
-
-            if (appendExpression(sb, expression.leftOperand)) {
-                sb.append(' ').append(expression.operator.text).append(' ')
-                if (appendExpression(sb, expression.rightOperand)) {
-                    return true
-                }
-            }
-        } else if (expression is UUnaryExpression) {
-            sb.append(expression.operator.text)
-            if (appendExpression(sb, expression.operand)) {
-                return true
-            }
-        } else if (expression is ULambdaExpression) {
-            sb.append("{ ")
-            val valueParameters = expression.valueParameters
-            if (valueParameters.isNotEmpty()) {
-                var first = true
-                for (parameter in valueParameters) {
-                    if (first) {
-                        first = false
-                    } else {
-                        sb.append(", ")
-                    }
-                    sb.append(parameter.name)
-                }
-                sb.append(" -> ")
-            }
-            val body = expression.body
-
-            if (body is UBlockExpression) {
-                var first = true
-                for (e in body.expressions) {
-                    if (first) {
-                        first = false
-                    } else {
-                        sb.append("; ")
-                    }
-                    if (!appendExpression(sb, e)) {
-                        return false
-                    }
-                }
-
-                // Special case: Turn empty lambda {  } into {}
-                if (sb.length > 2) {
-                    sb.append(' ')
-                } else {
-                    sb.setLength(1)
-                }
-                sb.append('}')
-                return true
-            } else {
-                if (appendExpression(sb, body)) {
-                    sb.append(" }")
-                    return true
-                }
-            }
-        } else if (expression is UBlockExpression) {
-            sb.append('{')
-            var first = true
-            for (e in expression.expressions) {
-                if (first) {
-                    first = false
-                } else {
-                    sb.append("; ")
-                }
-                if (!appendExpression(sb, e)) {
-                    return false
-                }
-            }
-            sb.append('}')
-            return true
-        } else if (expression.isConstructorCall()) {
-            val call = expression as UCallExpression
-            val resolved = call.classReference?.resolve()
-            if (resolved is PsiClass) {
-                sb.append(resolved.qualifiedName)
-            } else {
-                sb.append(call.classReference?.resolvedName)
-            }
-            sb.append('(')
-            var first = true
-            for (arg in call.valueArguments) {
-                if (first) {
-                    first = false
-                } else {
-                    sb.append(", ")
-                }
-                if (!appendExpression(sb, arg)) {
-                    return false
-                }
-            }
-            sb.append(')')
-            return true
-        } else {
-            sb.append(expression.asSourceString())
-            return true
-        }
-
-        // For example, binary expressions like 3 + 4
-        val literalValue = ConstantEvaluator.evaluate(null, expression)
-        if (literalValue != null) {
-            if (appendLiteralValue(sb, literalValue)) {
-                return true
-            }
-        }
-
-        warning(
-            "Unexpected annotation expression of type ${expression.javaClass} and is $expression",
-            expression
-        )
-
-        return false
-    }
-
-    companion object {
-        private fun appendLiteralValue(sb: StringBuilder, literalValue: Any?): Boolean {
-            if (literalValue == null) {
-                sb.append("null")
-                return true
-            } else if (literalValue is Number || literalValue is Boolean) {
-                sb.append(literalValue.toString())
-                return true
-            } else if (literalValue is String || literalValue is Char) {
-                sb.append('"')
-                sb.append(javaEscapeString(literalValue.toString()))
-                sb.append('"')
-                return true
-            }
-            return false
-        }
-
-        fun constantToSource(value: Any?): String {
-            if (value == null) {
-                return "null"
-            }
-
-            when (value) {
-                is Int -> {
-                    return value.toString()
-                }
-                is String -> {
-                    return "\"${javaEscapeString(value)}\""
-                }
-                is Long -> {
-                    return value.toString() + "L"
-                }
-                is Boolean -> {
-                    return value.toString()
-                }
-                is Byte -> {
-                    return value.toString()
-                }
-                is Short -> {
-                    return value.toString()
-                }
-                is Float -> {
-                    return when {
-                        value == Float.POSITIVE_INFINITY -> "(1.0f/0.0f)"
-                        value == Float.NEGATIVE_INFINITY -> "(-1.0f/0.0f)"
-                        java.lang.Float.isNaN(value) -> "(0.0f/0.0f)"
-                        else -> {
-                            canonicalizeFloatingPointString(value.toString()) + "f"
-                        }
-                    }
-                }
-                is Double -> {
-                    return when {
-                        value == Double.POSITIVE_INFINITY -> "(1.0/0.0)"
-                        value == Double.NEGATIVE_INFINITY -> "(-1.0/0.0)"
-                        java.lang.Double.isNaN(value) -> "(0.0/0.0)"
-                        else -> {
-                            canonicalizeFloatingPointString(value.toString())
-                        }
-                    }
-                }
-                is Char -> {
-                    return String.format("'%s'", javaEscapeString(value.toString()))
-                }
-                is Pair<*, *> -> {
-                    val first = value.first
-                    val second = value.second
-                    if (first is ClassId) {
-                        val qualifiedName =
-                            first.packageFqName.asString() +
-                                "." +
-                                first.relativeClassName.asString()
-                        return if (second is Name) {
-                            qualifiedName + "." + second.asString()
-                        } else {
-                            qualifiedName
-                        }
-                    }
-                }
-            }
-
-            return value.toString()
-        }
-
-        internal fun constantToExpression(constant: Any?): String? {
-            return when (constant) {
-                is Int -> "0x${Integer.toHexString(constant)}"
-                is String -> "\"${javaEscapeString(constant)}\""
-                is Long -> "${constant}L"
-                is Boolean -> constant.toString()
-                is Byte -> Integer.toHexString(constant.toInt())
-                is Short -> Integer.toHexString(constant.toInt())
-                is Float -> {
-                    when {
-                        constant == Float.POSITIVE_INFINITY -> "Float.POSITIVE_INFINITY"
-                        constant == Float.NEGATIVE_INFINITY -> "Float.NEGATIVE_INFINITY"
-                        java.lang.Float.isNaN(constant) -> "Float.NaN"
-                        else -> {
-                            "${canonicalizeFloatingPointString(constant.toString())}F"
-                        }
-                    }
-                }
-                is Double -> {
-                    when {
-                        constant == Double.POSITIVE_INFINITY -> "Double.POSITIVE_INFINITY"
-                        constant == Double.NEGATIVE_INFINITY -> "Double.NEGATIVE_INFINITY"
-                        java.lang.Double.isNaN(constant) -> "Double.NaN"
-                        else -> {
-                            canonicalizeFloatingPointString(constant.toString())
-                        }
-                    }
-                }
-                is Char -> {
-                    "'${javaEscapeString(constant.toString())}'"
-                }
-                else -> {
-                    null
-                }
-            }
-        }
-    }
-}
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/KotlinTypeInfo.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/KotlinTypeInfo.kt
index 41c9c9d09..f77b8716a 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/KotlinTypeInfo.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/KotlinTypeInfo.kt
@@ -55,6 +55,11 @@ private constructor(
      * encapsulated within [kaType].
      */
     val overrideTypeArguments: List<KotlinTypeInfo>? = null,
+    /**
+     * A [KaType] for a class contains information about the type parameters for all levels of outer
+     * class types. This represents which level to use (0 is the innermost class).
+     */
+    private val classLevelFromInnermost: Int = 0,
 ) {
     constructor(context: PsiElement) : this(null, null, context)
 
@@ -126,7 +131,15 @@ private constructor(
             analysisSession,
             analysisSession?.run {
                 when (kaType) {
-                    is KaClassType -> kaType.typeArguments.getOrNull(index)?.type
+                    is KaClassType -> {
+                        // Find which level of type qualifiers to use. The qualifiers are in order
+                        // from outermost to innermost class, and the [classLevelFromInnermost]
+                        // starts at 0 for the innermost class.
+                        val innermostClassIndex = kaType.qualifiers.lastIndex
+                        val thisClassIndex = innermostClassIndex - classLevelFromInnermost
+                        val thisClass = kaType.qualifiers.getOrNull(thisClassIndex)
+                        thisClass?.typeArguments?.getOrNull(index)?.type
+                    }
                     else -> null
                 }
             },
@@ -136,22 +149,22 @@ private constructor(
 
     /**
      * Creates [KotlinTypeInfo] for the outer class type of this [kaType], assuming it is a class.
+     *
+     * Uses the same [kaType], but increments the [classLevelFromInnermost].
      */
     fun forOuterClass(): KotlinTypeInfo {
         return KotlinTypeInfo(
             analysisSession,
-            analysisSession?.run {
-                (kaType as? KaClassType)?.classId?.outerClassId?.let { outerClassId ->
-                    buildClassType(outerClassId) {
-                        // Add the parameters of the class type with nullability information.
-                        kaType.qualifiers
-                            .firstOrNull { it.name == outerClassId.shortClassName }
-                            ?.typeArguments
-                            ?.forEach { argument(it) }
-                    }
-                }
+            // Only keep using the kaType if the outer class level exists.
+            kaType?.takeIf {
+                // If the kaType isn't a class, don't use it for an outer class.
+                val finalClassIndex =
+                    (kaType as? KaClassType)?.qualifiers?.lastIndex ?: return@takeIf false
+                // Don't take the kaType if class level is already at the last of the outer classes.
+                finalClassIndex > classLevelFromInnermost
             },
             context,
+            classLevelFromInnermost = classLevelFromInnermost + 1,
         )
     }
 
@@ -186,8 +199,7 @@ private constructor(
                         typeFromSyntheticElement(context)
                     }
                 }
-            }
-                ?: KotlinTypeInfo(context)
+            } ?: KotlinTypeInfo(context)
         }
 
         /**
@@ -207,8 +219,7 @@ private constructor(
                                 // delegate, if any.
                                 context is UField -> ktElement.delegateExpression?.expressionType
                                 else -> null
-                            }
-                                ?: ktElement.returnType
+                            } ?: ktElement.returnType
                         KotlinTypeInfo(this, ktType, ktElement)
                     }
                 }
@@ -294,7 +305,11 @@ private constructor(
                             val returnKtType = sourcePsi.returnType
                             syntheticContinuationParameter(sourcePsi, returnKtType)
                         }
-                    } else null
+                    } else {
+                        // Find the KtParameter with the same index as the UParameter to use as the
+                        // source psi.
+                        fromKtElement(sourcePsi.valueParameters[parameterIndex], context)
+                    }
                 }
                 is KtPropertyAccessor ->
                     analyze(sourcePsi) {
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiAnnotationItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiAnnotationItem.kt
index f01554e85..698268140 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiAnnotationItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiAnnotationItem.kt
@@ -16,361 +16,52 @@
 
 package com.android.tools.metalava.model.psi
 
-import com.android.tools.lint.detector.api.ConstantEvaluator
 import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
 import com.android.tools.metalava.model.AnnotationAttribute
-import com.android.tools.metalava.model.AnnotationAttributeValue
 import com.android.tools.metalava.model.AnnotationItem
-import com.android.tools.metalava.model.AnnotationTarget
-import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.DefaultAnnotationArrayAttributeValue
-import com.android.tools.metalava.model.DefaultAnnotationAttribute
-import com.android.tools.metalava.model.DefaultAnnotationItem
-import com.android.tools.metalava.model.DefaultAnnotationSingleAttributeValue
-import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.psi.CodePrinter.Companion.constantToExpression
-import com.android.tools.metalava.model.psi.CodePrinter.Companion.constantToSource
 import com.intellij.psi.PsiAnnotation
-import com.intellij.psi.PsiAnnotationMemberValue
-import com.intellij.psi.PsiAnnotationMethod
-import com.intellij.psi.PsiArrayInitializerMemberValue
-import com.intellij.psi.PsiBinaryExpression
-import com.intellij.psi.PsiClass
-import com.intellij.psi.PsiClassObjectAccessExpression
-import com.intellij.psi.PsiExpression
-import com.intellij.psi.PsiField
-import com.intellij.psi.PsiLiteral
-import com.intellij.psi.PsiReference
-import com.intellij.psi.impl.JavaConstantExpressionEvaluator
-import org.jetbrains.kotlin.asJava.elements.KtLightNullabilityAnnotation
 
-internal class PsiAnnotationItem
-private constructor(
-    override val annotationContext: PsiBasedCodebase,
-    val psiAnnotation: PsiAnnotation,
-    originalName: String,
-    qualifiedName: String,
-) :
-    DefaultAnnotationItem(
-        annotationContext = annotationContext,
-        fileLocation = PsiFileLocation.fromPsiElement(psiAnnotation),
-        originalName = originalName,
-        qualifiedName = qualifiedName,
-        attributesGetter = { getAnnotationAttributes(annotationContext, psiAnnotation) },
-    ) {
-
-    override fun toSource(target: AnnotationTarget, showDefaultAttrs: Boolean): String {
-        val sb = StringBuilder(60)
-        appendAnnotation(
-            annotationContext,
-            sb,
-            psiAnnotation,
-            qualifiedName,
-            target,
-            showDefaultAttrs
-        )
-        return sb.toString()
-    }
-
-    override fun snapshot(targetCodebase: Codebase) = this
-
-    override fun isNonNull(): Boolean {
-        if (psiAnnotation is KtLightNullabilityAnnotation<*> && originalName == "") {
-            // Hack/workaround: some UAST annotation nodes do not provide qualified name :=(
-            return true
-        }
-        return super.isNonNull()
-    }
-
-    companion object {
-        private fun getAnnotationAttributes(
-            codebase: PsiBasedCodebase,
-            psiAnnotation: PsiAnnotation
-        ): List<AnnotationAttribute> =
-            psiAnnotation.parameterList.attributes
-                .mapNotNull { attribute ->
-                    attribute.value?.let { value ->
-                        DefaultAnnotationAttribute(
-                            attribute.name ?: ANNOTATION_ATTR_VALUE,
-                            createValue(codebase, value),
-                        )
-                    }
-                }
-                .toList()
-
-        fun create(
-            codebase: PsiBasedCodebase,
-            psiAnnotation: PsiAnnotation,
-        ): AnnotationItem? {
-            // If the qualified name is a typealias, convert it to the aliased type because that is
-            // the version that will be present as a class in the codebase.
-            val originalName =
-                psiAnnotation.qualifiedName?.let {
-                    (codebase.findTypeAlias(it)?.aliasedType as? PsiClassTypeItem)?.qualifiedName
-                        ?: it
-                }
-                    ?: return null
-            val qualifiedName =
-                codebase.annotationManager.normalizeInputName(originalName) ?: return null
-            return PsiAnnotationItem(
-                annotationContext = codebase,
-                psiAnnotation = psiAnnotation,
-                originalName = originalName,
-                qualifiedName = qualifiedName,
-            )
-        }
-
-        private fun getAttributes(
-            annotation: PsiAnnotation,
-            showDefaultAttrs: Boolean
-        ): List<Pair<String?, PsiAnnotationMemberValue?>> {
-            val annotationClass = annotation.nameReferenceElement?.resolve() as? PsiClass
-            val list = mutableListOf<Pair<String?, PsiAnnotationMemberValue?>>()
-            if (annotationClass != null && showDefaultAttrs) {
-                for (method in annotationClass.methods) {
-                    if (method !is PsiAnnotationMethod) {
-                        continue
-                    }
-                    list.add(Pair(method.name, annotation.findAttributeValue(method.name)))
-                }
-            } else {
-                for (attr in annotation.parameterList.attributes) {
-                    list.add(Pair(attr.name, attr.value))
-                }
-            }
-            return list
-        }
-
-        private fun appendAnnotation(
-            codebase: PsiBasedCodebase,
-            sb: StringBuilder,
-            psiAnnotation: PsiAnnotation,
-            qualifiedName: String?,
-            target: AnnotationTarget,
-            showDefaultAttrs: Boolean
-        ) {
-            val alwaysInlineValues = qualifiedName == "android.annotation.FlaggedApi"
-            val outputName =
-                codebase.annotationManager.normalizeOutputName(qualifiedName, target) ?: return
-
-            val attributes = getAttributes(psiAnnotation, showDefaultAttrs)
-            if (attributes.isEmpty()) {
-                sb.append("@$outputName")
-                return
-            }
-
-            sb.append("@")
-            sb.append(outputName)
-            sb.append("(")
-            if (
-                attributes.size == 1 &&
-                    (attributes[0].first == null || attributes[0].first == ANNOTATION_ATTR_VALUE)
-            ) {
-                // Special case: omit "value" if it's the only attribute
-                appendValue(
-                    codebase,
-                    sb,
-                    attributes[0].second,
-                    target,
-                    showDefaultAttrs = showDefaultAttrs,
-                    alwaysInlineValues = alwaysInlineValues,
-                )
-            } else {
-                var first = true
-                for (attribute in attributes) {
-                    if (first) {
-                        first = false
-                    } else {
-                        sb.append(", ")
-                    }
-                    sb.append(attribute.first ?: ANNOTATION_ATTR_VALUE)
-                    sb.append('=')
-                    appendValue(
-                        codebase,
-                        sb,
-                        attribute.second,
-                        target,
-                        showDefaultAttrs = showDefaultAttrs,
-                        alwaysInlineValues = alwaysInlineValues,
+internal object PsiAnnotationItem {
+
+    private fun getAnnotationAttributes(
+        codebase: PsiBasedCodebase,
+        psiAnnotation: PsiAnnotation,
+    ): List<AnnotationAttribute> {
+        val annotationPsiClass = psiAnnotation.resolveAnnotationType()
+        return psiAnnotation.parameterList.attributes
+            .mapNotNull { attribute ->
+                attribute.value?.let { value ->
+                    val name = attribute.name ?: ANNOTATION_ATTR_VALUE
+
+                    AnnotationAttribute.createLazyAttribute(
+                        name,
+                        codebase.valueFactory.providerForAnnotationValue(
+                            annotationPsiClass,
+                            name,
+                            value,
+                        ),
                     )
                 }
             }
-            sb.append(")")
-        }
-
-        private fun appendValue(
-            codebase: PsiBasedCodebase,
-            sb: StringBuilder,
-            value: PsiAnnotationMemberValue?,
-            target: AnnotationTarget,
-            showDefaultAttrs: Boolean,
-            alwaysInlineValues: Boolean,
-        ) {
-            // Compute annotation string -- we don't just use value.text here
-            // because that may not use fully qualified names, e.g. the source may say
-            //  @RequiresPermission(Manifest.permission.ACCESS_COARSE_LOCATION)
-            // and we want to compute
-            //
-            // @androidx.annotation.RequiresPermission(android.Manifest.permission.ACCESS_COARSE_LOCATION)
-            when (value) {
-                null -> sb.append("null")
-                is PsiLiteral -> sb.append(constantToSource(value.value))
-                is PsiReference -> {
-                    when (val resolved = value.resolve()) {
-                        is PsiField -> {
-                            val containing = resolved.containingClass
-                            if (containing != null) {
-                                // If it's a field reference, see if it looks like the field is
-                                // hidden; if
-                                // so, inline the value
-                                val cls = codebase.findOrCreateClass(containing)
-                                val initializer = resolved.initializer
-                                if (initializer != null) {
-                                    val fieldItem = cls.findField(resolved.name)
-                                    if (
-                                        alwaysInlineValues ||
-                                            fieldItem == null ||
-                                            fieldItem.isHiddenOrRemoved() ||
-                                            !fieldItem.isPublic
-                                    ) {
-                                        // Use the literal value instead
-                                        val source = getConstantSource(initializer)
-                                        if (source != null) {
-                                            sb.append(source)
-                                            return
-                                        }
-                                    }
-                                }
-                                containing.qualifiedName?.let { sb.append(it).append('.') }
-                            }
-
-                            sb.append(resolved.name)
-                        }
-                        is PsiClass -> resolved.qualifiedName?.let { sb.append(it) }
-                        else -> {
-                            sb.append(value.text)
-                        }
-                    }
-                }
-                is PsiBinaryExpression -> {
-                    appendValue(
-                        codebase,
-                        sb,
-                        value.lOperand,
-                        target,
-                        showDefaultAttrs = showDefaultAttrs,
-                        alwaysInlineValues = alwaysInlineValues,
-                    )
-                    sb.append(' ')
-                    sb.append(value.operationSign.text)
-                    sb.append(' ')
-                    appendValue(
-                        codebase,
-                        sb,
-                        value.rOperand,
-                        target,
-                        showDefaultAttrs = showDefaultAttrs,
-                        alwaysInlineValues = alwaysInlineValues,
-                    )
-                }
-                is PsiArrayInitializerMemberValue -> {
-                    sb.append('{')
-                    var first = true
-                    for (initializer in value.initializers) {
-                        if (first) {
-                            first = false
-                        } else {
-                            sb.append(", ")
-                        }
-                        appendValue(
-                            codebase,
-                            sb,
-                            initializer,
-                            target,
-                            showDefaultAttrs = showDefaultAttrs,
-                            alwaysInlineValues = alwaysInlineValues,
-                        )
-                    }
-                    sb.append('}')
-                }
-                is PsiAnnotation -> {
-                    appendAnnotation(
-                        codebase,
-                        sb,
-                        value,
-                        // Normalize the input name of the annotation.
-                        codebase.annotationManager.normalizeInputName(value.qualifiedName),
-                        target,
-                        showDefaultAttrs
-                    )
-                }
-                else -> {
-                    if (value is PsiExpression) {
-                        val source = getConstantSource(value)
-                        if (source != null) {
-                            sb.append(source)
-                            return
-                        }
-                    }
-                    sb.append(value.text)
-                }
-            }
-        }
-
-        private fun getConstantSource(value: PsiExpression): String? {
-            val constant = JavaConstantExpressionEvaluator.computeConstantExpression(value, false)
-            return constantToExpression(constant)
-        }
-    }
-}
-
-private fun createValue(
-    codebase: PsiBasedCodebase,
-    value: PsiAnnotationMemberValue
-): AnnotationAttributeValue {
-    return if (value is PsiArrayInitializerMemberValue) {
-        DefaultAnnotationArrayAttributeValue(
-            { value.text },
-            { value.initializers.map { createValue(codebase, it) }.toList() }
-        )
-    } else {
-        PsiAnnotationSingleAttributeValue(codebase, value)
+            .toList()
     }
-}
-
-internal class PsiAnnotationSingleAttributeValue(
-    private val codebase: PsiBasedCodebase,
-    private val psiValue: PsiAnnotationMemberValue
-) : DefaultAnnotationSingleAttributeValue({ psiValue.text }, { getValue(psiValue) }) {
-
-    companion object {
-        private fun getValue(psiValue: PsiAnnotationMemberValue): Any {
-            if (psiValue is PsiLiteral) {
-                return psiValue.value ?: psiValue.text.removeSurrounding("\"")
-            }
 
-            val value = ConstantEvaluator.evaluate(null, psiValue)
-            if (value != null) {
-                return value
-            }
-
-            if (psiValue is PsiClassObjectAccessExpression) {
-                // The value of a class literal expression like String.class or String::class
-                // is the fully qualified name, java.lang.String
-                return psiValue.operand.type.canonicalText
-            }
-
-            return psiValue.text ?: psiValue.text.removeSurrounding("\"")
-        }
-    }
-
-    override fun resolve(): Item? {
-        if (psiValue is PsiReference) {
-            when (val resolved = psiValue.resolve()) {
-                is PsiField -> return codebase.findField(resolved)
-                is PsiClass -> return codebase.findOrCreateClass(resolved)
-            }
+    fun create(
+        codebase: PsiBasedCodebase,
+        psiAnnotation: PsiAnnotation,
+    ): AnnotationItem? {
+        // If the qualified name is a typealias, convert it to the aliased type because that is
+        // the version that will be present as a class in the codebase.
+        val originalName =
+            psiAnnotation.qualifiedName?.let {
+                (codebase.findTypeAlias(it)?.aliasedType as? PsiClassTypeItem)?.qualifiedName ?: it
+            } ?: return null
+        return AnnotationItem.createAttributesLazily(
+            annotationContext = codebase,
+            fileLocation = PsiFileLocation.fromPsiElement(psiAnnotation),
+            originalName = originalName,
+        ) {
+            getAnnotationAttributes(codebase, psiAnnotation)
         }
-        return null
     }
 }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedCodebase.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedCodebase.kt
index c673dfde2..ac6d1987f 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedCodebase.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedCodebase.kt
@@ -16,16 +16,19 @@
 
 package com.android.tools.metalava.model.psi
 
+import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassOrigin
 import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.annotation.AnnotationDefaults
 import com.android.tools.metalava.model.item.DefaultCodebase
+import com.android.tools.metalava.model.type.ContextNullability
+import com.android.tools.metalava.model.value.Value
+import com.android.tools.metalava.model.value.ValueProvider
 import com.intellij.openapi.project.Project
 import com.intellij.psi.PsiClass
-import com.intellij.psi.PsiField
 import com.intellij.psi.PsiMethod
 import java.io.File
 import org.jetbrains.uast.UMethod
@@ -68,12 +71,6 @@ internal class PsiBasedCodebase(
     internal val project: Project
         get() = psiAssembler.project
 
-    /**
-     * Printer which can convert PSI, UAST and constants into source code, with ability to filter
-     * out elements that are not part of a codebase etc
-     */
-    internal val printer = CodePrinter(this, reporter)
-
     /**
      * Map from classes to the set of callables for each (but only for classes where we've called
      * [findCallableByPsiMethod]
@@ -85,6 +82,10 @@ internal class PsiBasedCodebase(
     internal val globalTypeItemFactory
         get() = psiAssembler.globalTypeItemFactory
 
+    /** Creates [ValueProvider]s and [Value]s from Psi classes. */
+    internal val valueFactory by
+        lazy(LazyThreadSafetyMode.NONE) { PsiValueFactory(this, globalTypeItemFactory) }
+
     override fun dispose() {
         psiAssembler.dispose()
         super.dispose()
@@ -132,12 +133,6 @@ internal class PsiBasedCodebase(
         return methodItem
     }
 
-    internal fun findField(field: PsiField): FieldItem? {
-        val containingClass = field.containingClass ?: return null
-        val cls = findOrCreateClass(containingClass)
-        return cls.findField(field.name)
-    }
-
     private fun registerCallablesByPsiMethod(
         callables: List<CallableItem>,
         map: MutableMap<PsiMethod, PsiCallableItem>
@@ -159,4 +154,54 @@ internal class PsiBasedCodebase(
 
     override fun createAnnotation(source: String, context: Item?) =
         psiAssembler.createAnnotation(source, context)
+
+    /**
+     * Override to allow access to the [AnnotationDefaults] without having to resolve a [ClassItem]
+     * which can have side effects which can cause problems during [PsiBasedCodebase] construction.
+     *
+     * The side effects are encountered as follows:
+     * * There is an optimization in [PsiCodebaseAssembler] where it will not create inaccessible
+     *   classes.
+     * * An `internal` class may be accessible if it has a show annotation.
+     * * Computing the [AnnotationItem.showability] requires getting values for all an
+     *   [AnnotationItem]'s attributes, including default values.
+     * * Getting [AnnotationDefaults] using the default implementation of this will resolve the
+     *   [AnnotationItem]'s [ClassItem].
+     * * Resolving the [ClassItem] before it has itself been created and registered causes problems,
+     *   e.g. it has the wrong value for [ClassItem.emit].
+     */
+    override fun defaultsForAnnotationClass(qualifiedName: String): AnnotationDefaults {
+        // Use defaults from a class if it was already created.
+        findClass(qualifiedName)?.let {
+            return it.annotationClass.defaults
+        }
+
+        // Otherwise, find the `PsiClass` and compute the values from that instead. This does not
+        // cache the results as there are very few places outside tests where this is used.
+        psiAssembler.findPsiClass(qualifiedName)?.let { psiClass ->
+            if (psiClass.methods.isNotEmpty()) {
+                val defaultsByName =
+                    psiClass.methods
+                        .mapNotNull { psiMethod ->
+                            val psiReturnType = psiMethod.returnType ?: return@mapNotNull null
+                            val optionalTypeItem =
+                                globalTypeItemFactory.getType(
+                                    psiReturnType,
+                                    psiMethod,
+                                    ContextNullability.forceNonNull,
+                                )
+                            val valueProvider =
+                                psiMethod.defaultValueProvider(this, optionalTypeItem)
+                                    ?: return@mapNotNull null
+
+                            psiMethod.name to valueProvider.value
+                        }
+                        .toMap()
+
+                return AnnotationDefaults(defaultsByName)
+            }
+        }
+
+        return AnnotationDefaults.EMPTY
+    }
 }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCallableBody.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCallableBody.kt
index 92aaab2b8..3aa39fab7 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCallableBody.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCallableBody.kt
@@ -21,6 +21,7 @@ import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.CallableBody
 import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.value.FieldReferenceValue
 import com.android.tools.metalava.reporter.FileLocation
 import com.android.tools.metalava.reporter.Issues
 import com.intellij.psi.JavaRecursiveElementVisitor
@@ -32,19 +33,16 @@ import com.intellij.psi.PsiReferenceExpression
 import com.intellij.psi.PsiReturnStatement
 import com.intellij.psi.PsiSynchronizedStatement
 import com.intellij.psi.PsiThisExpression
-import org.jetbrains.uast.UAnnotation
 import org.jetbrains.uast.UCallExpression
 import org.jetbrains.uast.UClassLiteralExpression
 import org.jetbrains.uast.UElement
 import org.jetbrains.uast.UMethod
 import org.jetbrains.uast.UQualifiedReferenceExpression
-import org.jetbrains.uast.USimpleNameReferenceExpression
 import org.jetbrains.uast.UThisExpression
 import org.jetbrains.uast.UThrowExpression
 import org.jetbrains.uast.UTryExpression
 import org.jetbrains.uast.UastErrorType
 import org.jetbrains.uast.getParentOfType
-import org.jetbrains.uast.toUElement
 import org.jetbrains.uast.visitor.AbstractUastVisitor
 
 internal class PsiCallableBody(private val callable: PsiCallableItem) : CallableBody {
@@ -107,8 +105,7 @@ internal class PsiCallableBody(private val callable: PsiCallableItem) : Callable
                                 UTryExpression::class.java,
                                 true,
                                 UMethod::class.java
-                            )
-                                ?: return false
+                            ) ?: return false
 
                         for (catchClause in tryExpression.catchClauses) {
                             for (type in catchClause.types) {
@@ -185,7 +182,6 @@ internal class PsiCallableBody(private val callable: PsiCallableItem) : Callable
         typeDefAnnotation: AnnotationItem,
         typeDefClass: ClassItem,
     ) {
-        val uAnnotation = typeDefAnnotation.uAnnotation ?: return
         val body = psiMethod.body ?: return
 
         body.accept(
@@ -210,7 +206,7 @@ internal class PsiCallableBody(private val callable: PsiCallableItem) : Callable
                             val names =
                                 constants
                                     ?: run {
-                                        constants = computeValidConstantNames(uAnnotation)
+                                        constants = computeValidConstantNames(typeDefAnnotation)
                                         constants!!
                                     }
                             if (names.isNotEmpty() && !names.contains(name)) {
@@ -228,25 +224,8 @@ internal class PsiCallableBody(private val callable: PsiCallableItem) : Callable
         )
     }
 
-    private fun computeValidConstantNames(annotation: UAnnotation): List<String> {
-        val constants = annotation.findAttributeValue(ANNOTATION_ATTR_VALUE) ?: return emptyList()
-        if (constants is UCallExpression) {
-            return constants.valueArguments
-                .mapNotNull { (it as? USimpleNameReferenceExpression)?.identifier }
-                .toList()
-        }
-
-        return emptyList()
+    private fun computeValidConstantNames(annotation: AnnotationItem): List<String> {
+        val constants = annotation.findAttribute(ANNOTATION_ATTR_VALUE)?.value ?: return emptyList()
+        return constants.asFlatList().mapNotNull { (it as? FieldReferenceValue)?.fieldName }
     }
 }
-
-/** Public for use only in ExtractAnnotations */
-val AnnotationItem.uAnnotation: UAnnotation?
-    get() =
-        when (this) {
-            is UAnnotationItem -> uAnnotation
-            is PsiAnnotationItem ->
-                // Imported annotation
-                psiAnnotation.toUElement(UAnnotation::class.java)
-            else -> null
-        }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiClassItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiClassItem.kt
index 34fc38a62..2f56fc7f6 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiClassItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiClassItem.kt
@@ -26,6 +26,7 @@ import com.android.tools.metalava.model.ConstructorItem
 import com.android.tools.metalava.model.ItemDocumentationFactory
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.SourceFile
+import com.android.tools.metalava.model.TargetLanguageSet
 import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.model.VisibilityLevel
 import com.android.tools.metalava.model.item.DefaultClassItem
@@ -54,7 +55,8 @@ internal constructor(
     DefaultClassItem(
         codebase = codebase,
         fileLocation = PsiFileLocation.fromPsiElement(psiClass),
-        itemLanguage = psiClass.itemLanguage,
+        sourceLanguage = psiClass.sourceLanguage,
+        targetLanguages = TargetLanguageSet.ALL,
         modifiers = modifiers,
         documentationFactory = documentationFactory,
         variantSelectorsFactory = ApiVariantSelectors.MUTABLE_FACTORY,
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCodebaseAssembler.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCodebaseAssembler.kt
index 948e578a3..8131c58d0 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCodebaseAssembler.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCodebaseAssembler.kt
@@ -128,8 +128,12 @@ internal class PsiCodebaseAssembler(
      */
     private val deferredHeavyweightPsiClasses = mutableMapOf<String, PsiClass>()
 
+    /** If [PsiSourceParser.mergeFromJar] is used, this is the environment used to load the jar. */
+    var mergedJarEnvironment: UastEnvironment? = null
+
     fun dispose() {
         uastEnvironment.dispose()
+        mergedJarEnvironment?.dispose()
     }
 
     private fun getFactory() = JavaPsiFacade.getElementFactory(project)
@@ -409,8 +413,7 @@ internal class PsiCodebaseAssembler(
                         accessors = accessors[ktProperty] ?: emptyList(),
                         constructorParameter = null,
                         backingField = backingFields[ktProperty],
-                    )
-                        ?: continue
+                    ) ?: continue
                 classItem.addProperty(property)
             }
 
@@ -439,8 +442,7 @@ internal class PsiCodebaseAssembler(
                             accessors = accessors[ktParameter] ?: emptyList(),
                             constructorParameter = constructorParameters[ktParameter.name],
                             backingField = backingFields[ktParameter],
-                        )
-                            ?: continue
+                        ) ?: continue
                     classItem.addProperty(property)
                 }
             }
@@ -672,17 +674,23 @@ internal class PsiCodebaseAssembler(
             return it
         }
 
-        // Create the ClassItem from a heavyweight PsiClass, if available.
-        deferredHeavyweightPsiClasses.remove(qualifiedName)?.let {
-            return findOrCreateClass(it)
+        return findPsiClass(qualifiedName)?.let {
+            // Remove it, if it was a heavyweight PsiClass.
+            deferredHeavyweightPsiClasses.remove(qualifiedName)
+            findOrCreateClass(it)
+        }
+    }
+
+    internal fun findPsiClass(qualifiedName: String): PsiClass? {
+        // Return a heavyweight PsiClass, if available.
+        deferredHeavyweightPsiClasses[qualifiedName]?.let {
+            return it
         }
 
         // The following cannot find a class whose name does not correspond to the file name, e.g.
         // in Java a class that is a second top level class.
         val finder = JavaPsiFacade.getInstance(project)
-        val psiClass =
-            finder.findClass(qualifiedName, GlobalSearchScope.allScope(project)) ?: return null
-        return findOrCreateClass(psiClass)
+        return finder.findClass(qualifiedName, GlobalSearchScope.allScope(project))
     }
 
     /**
@@ -955,8 +963,7 @@ internal class PsiCodebaseAssembler(
                     psiClass,
                     // Sources always come from the command line.
                     ClassOrigin.COMMAND_LINE,
-                )
-                    ?: continue
+                ) ?: continue
             codebase.addTopLevelClassFromSource(classItem)
         }
     }
@@ -980,8 +987,7 @@ internal class PsiCodebaseAssembler(
     private fun topLevelDeclarations(fileFacadeClass: PsiClass): List<KtDeclaration> {
         return ((fileFacadeClass as? UClass)?.javaPsi as? KtLightClassForFacade)?.files?.flatMap {
             it.declarations
-        }
-            ?: emptyList()
+        } ?: emptyList()
     }
 
     /**
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiConstructorItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiConstructorItem.kt
index 7e74d7194..87d988cc1 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiConstructorItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiConstructorItem.kt
@@ -23,6 +23,8 @@ import com.android.tools.metalava.model.ClassTypeItem
 import com.android.tools.metalava.model.ExceptionTypeItem
 import com.android.tools.metalava.model.ItemDocumentation
 import com.android.tools.metalava.model.ItemDocumentationFactory
+import com.android.tools.metalava.model.TargetLanguage
+import com.android.tools.metalava.model.TargetLanguageSet
 import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.model.VisibilityLevel
 import com.android.tools.metalava.model.createImmutableModifiers
@@ -55,12 +57,14 @@ private constructor(
     typeParameterList: TypeParameterList,
     throwsTypes: List<ExceptionTypeItem>,
     implicitConstructor: Boolean = false,
-    isPrimary: Boolean = false
+    isPrimary: Boolean = false,
+    targetLanguages: Set<TargetLanguage>,
 ) :
     DefaultConstructorItem(
         codebase = codebase,
         fileLocation = fileLocation,
-        itemLanguage = psiMethod.itemLanguage,
+        sourceLanguage = psiMethod.sourceLanguage,
+        targetLanguages = targetLanguages,
         modifiers = modifiers,
         documentationFactory = documentationFactory,
         variantSelectorsFactory = ApiVariantSelectors.MUTABLE_FACTORY,
@@ -83,6 +87,7 @@ private constructor(
             psiMethod: PsiMethod,
             enclosingClassTypeItemFactory: PsiTypeItemFactory,
             psiParameters: List<PsiParameter> = psiMethod.psiParameters,
+            targetLanguages: Set<TargetLanguage> = TargetLanguageSet.ALL,
         ): PsiConstructorItem {
             assert(psiMethod.isConstructor)
             val name = psiMethod.name
@@ -132,6 +137,7 @@ private constructor(
                     throwsTypes = throwsTypes(psiMethod, constructorTypeItemFactory),
                     implicitConstructor = false,
                     isPrimary = (psiMethod as? UMethod)?.isPrimaryConstructor ?: false,
+                    targetLanguages = targetLanguages,
                 )
 
             // Undo setting of constructors with value class types to private (b/395472914).
@@ -189,6 +195,7 @@ private constructor(
                     typeParameterList = TypeParameterList.NONE,
                     throwsTypes = emptyList(),
                     implicitConstructor = true,
+                    targetLanguages = TargetLanguageSet.ALL,
                 )
             return item
         }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiFieldItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiFieldItem.kt
index c6e1b988a..01a89095f 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiFieldItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiFieldItem.kt
@@ -23,20 +23,22 @@ import com.android.tools.metalava.model.ClassKind
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.ItemDocumentationFactory
 import com.android.tools.metalava.model.PropertyItem
+import com.android.tools.metalava.model.SourceLanguage
+import com.android.tools.metalava.model.TargetLanguageSet
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeNullability
 import com.android.tools.metalava.model.VisibilityLevel
 import com.android.tools.metalava.model.isNonNullAnnotation
 import com.android.tools.metalava.model.item.DefaultFieldItem
-import com.android.tools.metalava.model.item.FieldValue
+import com.android.tools.metalava.model.value.OptionalValueProvider
+import com.android.tools.metalava.model.value.ValueUseSite
 import com.intellij.psi.PsiCallExpression
-import com.intellij.psi.PsiClassType
 import com.intellij.psi.PsiEnumConstant
 import com.intellij.psi.PsiField
 import com.intellij.psi.PsiModifierListOwner
-import com.intellij.psi.PsiPrimitiveType
 import com.intellij.psi.PsiReference
 import com.intellij.psi.impl.JavaConstantExpressionEvaluator
+import org.jetbrains.uast.UField
 
 internal class PsiFieldItem(
     override val codebase: PsiBasedCodebase,
@@ -47,12 +49,13 @@ internal class PsiFieldItem(
     containingClass: ClassItem,
     type: TypeItem,
     private val isEnumConstant: Boolean,
-    override val legacyFieldValue: FieldValue?,
+    constantValueProvider: OptionalValueProvider?,
 ) :
     DefaultFieldItem(
         codebase = codebase,
         fileLocation = PsiFileLocation(psiField),
-        itemLanguage = psiField.itemLanguage,
+        sourceLanguage = psiField.sourceLanguage,
+        targetLanguages = TargetLanguageSet.ALL,
         modifiers = modifiers,
         documentationFactory = documentationFactory,
         variantSelectorsFactory = ApiVariantSelectors.MUTABLE_FACTORY,
@@ -60,7 +63,7 @@ internal class PsiFieldItem(
         containingClass = containingClass,
         type = type,
         isEnumConstant = isEnumConstant,
-        legacyFieldValue = legacyFieldValue,
+        constantValueProvider = constantValueProvider,
     ),
     FieldItem,
     PsiItem {
@@ -96,9 +99,6 @@ internal class PsiFieldItem(
 
             val isEnumConstant = psiField is PsiEnumConstant
 
-            // Wrap the PsiField in a PsiFieldValue that can provide the field's initial value.
-            val fieldValue = PsiFieldValue(psiField)
-
             // Create a type for the field, taking into account the modifiers, whether it is an
             // enum constant and whether the field's initial value is non-null.
             val fieldType =
@@ -111,11 +111,27 @@ internal class PsiFieldItem(
                         // The initial value is non-null if the field initializer is a method that
                         // is annotated as being non-null so would produce a non-null value, or the
                         // value is a literal which is not null.
-                        psiField.isFieldInitializerNonNull() ||
-                            fieldValue.initialValue(false) != null
+                        psiField.isFieldInitializerNonNull()
                     },
                 )
 
+            // Check to see whether the field could have a constant value.
+            val couldHaveConstantValue =
+                when (psiField.sourceLanguage) {
+                    // In Kotlin the `const` modifier is what determines whether the field could
+                    // have a constant value.
+                    SourceLanguage.KOTLIN -> modifiers.isConst()
+                    // In Java fields have to be static and final in order for them to have a
+                    // constant value but that is not sufficient.
+                    else -> modifiers.isStatic() && modifiers.isFinal()
+                }
+
+            // Get a ValueProvider for the initializer, if possible.
+            val constantValueProvider =
+                if (couldHaveConstantValue)
+                    constantValueProviderForField(psiField, codebase, fieldType)
+                else null
+
             return PsiFieldItem(
                 codebase = codebase,
                 psiField = psiField,
@@ -125,9 +141,44 @@ internal class PsiFieldItem(
                 containingClass = containingClass,
                 type = fieldType,
                 isEnumConstant = isEnumConstant,
-                legacyFieldValue = fieldValue
+                constantValueProvider = constantValueProvider,
             )
         }
+
+        /**
+         * Get an [OptionalValueProvider] for the [psiField]'s constant value.
+         *
+         * This will return 'null' if the [psiField] has no initializer at all.
+         *
+         * The returned [OptionalValueProvider]'s [OptionalValueProvider.optionalValue] property
+         * will be `null` if the field is a Java field which does not have an initializer which is a
+         * constant expression.
+         */
+        private fun constantValueProviderForField(
+            psiField: PsiField,
+            codebase: PsiBasedCodebase,
+            fieldType: TypeItem
+        ) =
+            when (psiField) {
+                is UField -> {
+                    psiField.uastInitializer?.let { uastInitializer ->
+                        codebase.valueFactory.providerFor(
+                            fieldType,
+                            uastInitializer,
+                            ValueUseSite.FIELD,
+                        )
+                    }
+                }
+                else -> {
+                    psiField.initializer?.let { psiInitializer ->
+                        codebase.valueFactory.providerFor(
+                            fieldType,
+                            psiInitializer,
+                            ValueUseSite.FIELD,
+                        )
+                    }
+                }
+            }
     }
 }
 
@@ -136,52 +187,40 @@ internal class PsiFieldItem(
  * [TypeNullability] is known to be [TypeNullability.NONNULL].
  */
 private fun PsiField.isFieldInitializerNonNull(): Boolean {
+    // If no initializer was provided then it cannot be non-null.
+    val initializer = initializer ?: return false
+
     // If we're looking at a final field, look on the right hand side of the field to the
     // field initialization. If that right hand side for example represents a method call,
     // and the method we're calling is annotated with @NonNull, then the field (since it is
     // final) will always be @NonNull as well.
-    val resolved =
-        when (val initializer = initializer) {
-            is PsiReference -> {
-                initializer.resolve()
-            }
-            is PsiCallExpression -> {
-                initializer.resolveMethod()
-            }
-            else -> null
+    when (initializer) {
+        is PsiReference -> {
+            initializer.resolve()
         }
-            ?: return false
-
-    return resolved is PsiModifierListOwner &&
-        resolved.annotations.any { isNonNullAnnotation(it.qualifiedName ?: "") }
-}
-
-/**
- * Wrapper around a [PsiField] that will provide access to the initial value of the field, if
- * available, or `null` otherwise.
- */
-class PsiFieldValue(private val psiField: PsiField) : FieldValue {
-
-    override fun initialValue(requireConstant: Boolean): Any? {
-        val constant = psiField.computeConstantValue()
-        // Offset [ClsFieldImpl#computeConstantValue] for [TYPE] field in boxed primitive types.
-        // Those fields hold [Class] object, but the constant value should not be of [PsiType].
+        is PsiCallExpression -> {
+            initializer.resolveMethod()
+        }
+        else -> null
+    }?.let { resolved ->
         if (
-            constant is PsiPrimitiveType &&
-                psiField.name == "TYPE" &&
-                (psiField.type as? PsiClassType)?.computeQualifiedName() == "java.lang.Class"
+            resolved is PsiModifierListOwner &&
+                resolved.annotations.any { isNonNullAnnotation(it.qualifiedName ?: "") }
         ) {
-            return null
-        }
-        if (constant != null) {
-            return constant
+            return true
         }
+    }
 
-        return if (!requireConstant) {
-            val initializer = psiField.initializer ?: return null
-            JavaConstantExpressionEvaluator.computeConstantExpression(initializer, false)
-        } else {
-            null
-        }
+    // Try and compute a constant value.
+    computeConstantValue()?.let {
+        // If it was non-null then the field must be non-null.
+        return true
     }
+
+    JavaConstantExpressionEvaluator.computeConstantExpression(initializer, false)?.let {
+        // If it was non-null then the field must be non-null.
+        return true
+    }
+
+    return false
 }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiFileLocation.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiFileLocation.kt
index 4cac4d987..63a709dd9 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiFileLocation.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiFileLocation.kt
@@ -111,7 +111,8 @@ class PsiFileLocation(private val psiElement: PsiElement) : FileLocation() {
         val rangeElement =
             (sourceElement as? PsiNameIdentifierOwner)?.nameIdentifier
                 ?: (sourceElement as? KtModifierListOwner)?.modifierList
-                    ?: (sourceElement as? PsiModifierListOwner)?.modifierList ?: sourceElement
+                ?: (sourceElement as? PsiModifierListOwner)?.modifierList
+                ?: sourceElement
 
         val range = getTextRange(rangeElement)
 
@@ -213,9 +214,9 @@ class PsiFileLocation(private val psiElement: PsiElement) : FileLocation() {
                 is KtProperty -> {
                     val containingClass =
                         element.containingClass()?.let { getElementId(it) }
-                        // If there is no containing class, find the file facade class because that
-                        // will be the containing class in the Codebase.
-                        ?: element.containingKtFile.javaFileFacadeFqName.asString()
+                            // If there is no containing class, find the file facade class because
+                            // that will be the containing class in the Codebase.
+                            ?: element.containingKtFile.javaFileFacadeFqName.asString()
                     val name = element.nameAsSafeName.asString()
                     "$containingClass#$name"
                 }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiItem.kt
index 0ff3ba43a..b2b32e869 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiItem.kt
@@ -17,7 +17,7 @@
 package com.android.tools.metalava.model.psi
 
 import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.ItemLanguage
+import com.android.tools.metalava.model.SourceLanguage
 import com.intellij.psi.PsiElement
 import org.jetbrains.kotlin.idea.KotlinLanguage
 import org.jetbrains.uast.UElement
@@ -34,9 +34,9 @@ internal interface PsiItem : Item {
     fun psi(): PsiElement
 }
 
-/** Get the [ItemLanguage] for this [PsiElement]. */
-val PsiElement.itemLanguage
-    get() = if (isKotlin()) ItemLanguage.KOTLIN else ItemLanguage.JAVA
+/** Get the [SourceLanguage] for this [PsiElement]. */
+val PsiElement.sourceLanguage
+    get() = if (isKotlin()) SourceLanguage.KOTLIN else SourceLanguage.JAVA
 
 /** Check whether this [PsiElement] is Kotlin or not. */
 fun PsiElement.isKotlin(): Boolean {
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiItemDocumentation.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiItemDocumentation.kt
index 023456dcf..fb3b4df2f 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiItemDocumentation.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiItemDocumentation.kt
@@ -606,8 +606,8 @@ internal class PsiItemDocumentation(
                 // package from a `package-info.java` or `package.html` file. Make sure that they
                 // are included in the `ItemDocumentation`, otherwise package hiding will not work.
                 extraDocs?.toItemDocumentationFactory()
-                // Otherwise, there is no documentation to use.
-                ?: ItemDocumentation.NONE_FACTORY
+                    // Otherwise, there is no documentation to use.
+                    ?: ItemDocumentation.NONE_FACTORY
             }
 
         // Gets the javadoc of the current element
@@ -626,8 +626,7 @@ internal class PsiItemDocumentation(
                     return comments.firstNotNullOfOrNull {
                         val text = it.text
                         if (text.startsWith("/**")) text else null
-                    }
-                        ?: ""
+                    } ?: ""
                 } else {
                     // Temporary workaround: UAST seems to not return document nodes
                     // https://youtrack.jetbrains.com/issue/KT-22135
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiMethodItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiMethodItem.kt
index 2c7c9fe1e..3739ea9b7 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiMethodItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiMethodItem.kt
@@ -23,6 +23,7 @@ import com.android.tools.metalava.model.ClassKind
 import com.android.tools.metalava.model.ExceptionTypeItem
 import com.android.tools.metalava.model.ItemDocumentationFactory
 import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.TargetLanguage
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.model.VisibilityLevel
@@ -31,6 +32,9 @@ import com.android.tools.metalava.model.item.ParameterItemsFactory
 import com.android.tools.metalava.model.psi.PsiCallableItem.Companion.parameterList
 import com.android.tools.metalava.model.psi.PsiCallableItem.Companion.throwsTypes
 import com.android.tools.metalava.model.type.MethodFingerprint
+import com.android.tools.metalava.model.value.CombinedValueProvider
+import com.android.tools.metalava.model.value.OptionalValueProvider
+import com.android.tools.metalava.model.value.ValueUseSite
 import com.android.tools.metalava.reporter.FileLocation
 import com.intellij.psi.PsiAnnotationMethod
 import com.intellij.psi.PsiMethod
@@ -59,11 +63,14 @@ internal class PsiMethodItem(
     parameterItemsFactory: ParameterItemsFactory,
     typeParameterList: TypeParameterList,
     throwsTypes: List<ExceptionTypeItem>,
+    val defaultValueProvider: OptionalValueProvider?,
+    targetLanguages: Set<TargetLanguage>
 ) :
     DefaultMethodItem(
         codebase = codebase,
         fileLocation = fileLocation,
-        itemLanguage = psiMethod.itemLanguage,
+        sourceLanguage = psiMethod.sourceLanguage,
+        targetLanguages = targetLanguages,
         modifiers = modifiers,
         documentationFactory = documentationFactory,
         variantSelectorsFactory = ApiVariantSelectors.MUTABLE_FACTORY,
@@ -74,6 +81,7 @@ internal class PsiMethodItem(
         parameterItemsFactory = parameterItemsFactory,
         throwsTypes = throwsTypes,
         callableBodyFactory = { PsiCallableBody(it as PsiCallableItem) },
+        defaultValueProvider = defaultValueProvider,
     ),
     PsiCallableItem {
 
@@ -98,19 +106,6 @@ internal class PsiMethodItem(
                     (psiMethod.sourcePsi as KtParameter).hasValOrVar())
     }
 
-    override fun legacyDefaultValue(): String {
-        return when (psiMethod) {
-            is UAnnotationMethod -> {
-                psiMethod.uastDefaultValue?.let { codebase.printer.toSourceString(it) } ?: ""
-            }
-            is PsiAnnotationMethod -> {
-                psiMethod.defaultValue?.let { codebase.printer.toSourceExpression(it, this) }
-                    ?: super.legacyDefaultValue()
-            }
-            else -> super.legacyDefaultValue()
-        }
-    }
-
     override fun duplicate(targetContainingClass: ClassItem): PsiMethodItem {
         // If duplicating within the same codebase type then map the type variables, otherwise do
         // not. That is because this can end up substituting a `TypeItem` implementation of one
@@ -140,6 +135,8 @@ internal class PsiMethodItem(
                 },
                 typeParameterList,
                 throwsTypes(),
+                defaultValueProvider,
+                targetLanguages,
             )
             .also { duplicated ->
                 duplicated.inheritedFrom = containingClass()
@@ -173,6 +170,7 @@ internal class PsiMethodItem(
             psiMethod: PsiMethod,
             enclosingClassTypeItemFactory: PsiTypeItemFactory,
             psiParameters: List<PsiParameter> = psiMethod.psiParameters,
+            targetLanguages: Set<TargetLanguage> = containingClass.targetLanguages,
         ): PsiMethodItem {
             assert(!psiMethod.isConstructor)
             // UAST workaround: @JvmName for UMethod with fake LC PSI
@@ -193,8 +191,7 @@ internal class PsiMethodItem(
                             it.qualifiedName == JvmName::class.qualifiedName
                         }
                         ?.findAttributeValue("name")
-                        ?.evaluate() as? String
-                        ?: psiMethod.name
+                        ?.evaluate() as? String ?: psiMethod.name
                 } else {
                     psiMethod.name
                 }
@@ -236,14 +233,16 @@ internal class PsiMethodItem(
                     isAnnotationElement = isAnnotationElement,
                 )
 
+            val defaultValueProvider = psiMethod.defaultValueProvider(codebase, returnType)
+
             val method =
                 PsiMethodItem(
                     codebase = codebase,
                     psiMethod = psiMethod,
                     containingClass = containingClass,
                     name = name,
-                    documentationFactory = PsiItemDocumentation.factory(psiMethod, codebase),
                     modifiers = modifiers,
+                    documentationFactory = PsiItemDocumentation.factory(psiMethod, codebase),
                     returnType = returnType,
                     parameterItemsFactory = { containingCallable ->
                         parameterList(
@@ -256,9 +255,40 @@ internal class PsiMethodItem(
                     },
                     typeParameterList = typeParameterList,
                     throwsTypes = throwsTypes(psiMethod, methodTypeItemFactory),
+                    defaultValueProvider = defaultValueProvider,
+                    targetLanguages = targetLanguages,
                 )
 
             return method
         }
     }
 }
+
+internal fun PsiMethod.defaultValueProvider(
+    codebase: PsiBasedCodebase,
+    returnType: TypeItem
+): CombinedValueProvider? {
+    val defaultValueProvider =
+        when (this) {
+            is UAnnotationMethod -> {
+                uastDefaultValue?.let { uDefaultValue ->
+                    codebase.valueFactory.providerFor(
+                        returnType,
+                        uDefaultValue,
+                        ValueUseSite.ANNOTATION,
+                    )
+                }
+            }
+            is PsiAnnotationMethod -> {
+                defaultValue?.let { psiDefaultValue ->
+                    codebase.valueFactory.providerFor(
+                        returnType,
+                        psiDefaultValue,
+                        ValueUseSite.ANNOTATION,
+                    )
+                }
+            }
+            else -> null
+        }
+    return defaultValueProvider
+}
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiModifierItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiModifierItem.kt
index a68eebc9c..5492ca330 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiModifierItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiModifierItem.kt
@@ -16,7 +16,6 @@
 
 package com.android.tools.metalava.model.psi
 
-import com.android.tools.metalava.model.ANDROID_DEPRECATED_FOR_SDK
 import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.BaseModifierList
 import com.android.tools.metalava.model.JAVA_LANG_ANNOTATION_TARGET
@@ -84,8 +83,10 @@ import org.jetbrains.kotlin.psi.KtFunction
 import org.jetbrains.kotlin.psi.KtModifierList
 import org.jetbrains.kotlin.psi.KtModifierListOwner
 import org.jetbrains.kotlin.psi.KtNamedFunction
+import org.jetbrains.kotlin.psi.KtPrimaryConstructor
 import org.jetbrains.kotlin.psi.KtProperty
 import org.jetbrains.kotlin.psi.KtPropertyAccessor
+import org.jetbrains.kotlin.psi.psiUtil.containingClass
 import org.jetbrains.kotlin.psi.psiUtil.containingClassOrObject
 import org.jetbrains.kotlin.psi.psiUtil.isTopLevelKtOrJavaMember
 import org.jetbrains.kotlin.psi.psiUtil.visibilityModifier
@@ -188,10 +189,37 @@ internal object PsiModifierItem {
                 if (annotationItem !in modifiers.annotations()) {
                     modifiers.addAnnotation(annotationItem)
                 }
+
                 // Make sure static definitions are marked
                 if (annotationItem.qualifiedName == JVM_STATIC) {
                     modifiers.setStatic(true)
                 }
+
+                // Special case for RequiresOptIn-annotated annotations: when these are applied
+                // to a property, they are implicitly propagated to the getter and setter
+                // (if present) for Kotlin clients. Match Kotlin compiler behavior by propagating.
+                // Note that the AndroidX experimental lint check will not recognize usages of the
+                // accessors by Java clients as experimental. Because of this AndroidX bans defining
+                // public experimental properties in projects that target Java clients.
+                if (uAnnotation.resolve()?.hasAnnotation("kotlin.RequiresOptIn") == true) {
+                    if (getter != null) {
+                        // Manually setting a RequiresOptIn annotation on a getter causes a
+                        // compiler warning, but this can be suppressed with
+                        // @Suppress("OPT_IN_MARKER_ON_WRONG_TARGET"). Safely handle
+                        // such cases by only adding the annotation if it wasn't explicitly added.
+                        if (annotationItem !in getter.modifiers.annotations()) {
+                            getter.mutateModifiers { addAnnotation(annotationItem) }
+                        }
+                    }
+                    if (setter != null) {
+                        // Explicit RequiresOptIn annotations on setters are supported by the
+                        // compiler, so we should only add this annotation implicitly if it is not
+                        // already explicitly provided.
+                        if (annotationItem !in setter.modifiers.annotations()) {
+                            setter.mutateModifiers { addAnnotation(annotationItem) }
+                        }
+                    }
+                }
             }
         }
 
@@ -263,11 +291,7 @@ internal object PsiModifierItem {
 
     private fun isDeprecatedAnnotation(annotationItem: AnnotationItem): Boolean =
         annotationItem.qualifiedName.let { qualifiedName ->
-            qualifiedName == "Deprecated" ||
-                qualifiedName.endsWith(".Deprecated") ||
-                // DeprecatedForSdk that do not apply to this API surface have been filtered
-                // out so if any are left then treat it as a standard Deprecated annotation.
-                qualifiedName == ANDROID_DEPRECATED_FOR_SDK
+            qualifiedName == "Deprecated" || qualifiedName.endsWith(".Deprecated")
         }
 
     private fun isDeprecatedFromSourcePsi(element: PsiModifierListOwner): Boolean {
@@ -280,8 +304,7 @@ internal object PsiModifierItem {
         }
         return ((element as? UElement)?.sourcePsi as? KtAnnotated)?.annotationEntries?.any {
             it.shortName?.toString() == "Deprecated"
-        }
-            ?: false
+        } ?: false
     }
 
     private fun computeFlag(element: PsiModifierListOwner, modifierList: PsiModifierList): Int {
@@ -384,6 +407,22 @@ internal object PsiModifierItem {
                     }
                 }
             }
+
+            // With K2, the source psi of a data class copy method is the primary constructor, so
+            // that gets used to determine internal visibility above. That works if the data class
+            // is annotated with @ConsistentCopyVisibility (pre Kotlin 2.3), or is not annotated
+            // with @ExposedCopyVisibility (Kotlin 2.3 or later). Otherwise, the copy method should
+            // be public. If the copy method is supposed to be internal, it will get a mangled name
+            // (`copy$<module name>`), so if the name is just plain "copy", that means it should not
+            // be internal. Reset the visibility to public in that case.
+            if (
+                sourcePsi is KtPrimaryConstructor &&
+                    (element as? PsiMethod)?.name == "copy" &&
+                    sourcePsi.containingClass()?.hasModifier(KtTokens.DATA_KEYWORD) == true &&
+                    visibilityFlags == INTERNAL
+            ) {
+                visibilityFlags = PUBLIC
+            }
         }
 
         if (ktModifierList?.hasModifier(KtTokens.INLINE_KEYWORD) == true) {
@@ -573,8 +612,7 @@ internal object PsiModifierItem {
             ?.annotations
             ?.firstOrNull { it.hasQualifiedName(JAVA_LANG_ANNOTATION_TARGET) }
             ?.findAttributeValue("value")
-            ?.targets()
-            ?: emptyList()
+            ?.targets() ?: emptyList()
     }
 
     /**
@@ -643,7 +681,6 @@ internal object PsiModifierItem {
                     // Remove any type-use annotations that psi incorrectly applied to the item.
                     .filterIncorrectTypeUseAnnotations(element)
                     .mapNotNull { PsiAnnotationItem.create(codebase, it) }
-                    .filter { !it.isDeprecatedForSdk() }
             createMutableModifiers(flags, annotations)
         }
     }
@@ -659,7 +696,7 @@ internal object PsiModifierItem {
         val psiAnnotations =
             modifierList.annotations.takeIf { it.isNotEmpty() }
                 ?: (annotated.javaPsi as? PsiModifierListOwner)?.annotations
-                    ?: PsiAnnotation.EMPTY_ARRAY
+                ?: PsiAnnotation.EMPTY_ARRAY
 
         var flags = computeFlag(element, modifierList)
 
@@ -683,7 +720,6 @@ internal object PsiModifierItem {
                             !it.isKotlinNullabilityAnnotation
                     }
                     .mapNotNull { UAnnotationItem.create(codebase, it) }
-                    .filter { !it.isDeprecatedForSdk() }
 
             if (!isPrimitiveVariable) {
                 if (psiAnnotations.isNotEmpty() && annotations.none { it.isNullnessAnnotation() }) {
@@ -707,29 +743,9 @@ internal object PsiModifierItem {
         }
     }
 
-    /** Returns whether this is a `@DeprecatedForSdk` annotation **that should be skipped**. */
-    private fun AnnotationItem.isDeprecatedForSdk(): Boolean {
-        if (qualifiedName != ANDROID_DEPRECATED_FOR_SDK) {
-            return false
-        }
-
-        val allowIn = findAttribute(ATTR_ALLOW_IN) ?: return false
-
-        for (api in allowIn.leafValues()) {
-            val annotationName = api.value() as? String ?: continue
-            if (annotationContext.annotationManager.isShowAnnotationName(annotationName)) {
-                return true
-            }
-        }
-
-        return false
-    }
-
     private val NOT_NULL = NotNull::class.qualifiedName
     private val NULLABLE = Nullable::class.qualifiedName
 
     private val UAnnotation.isKotlinNullabilityAnnotation: Boolean
         get() = qualifiedName == NOT_NULL || qualifiedName == NULLABLE
 }
-
-private const val ATTR_ALLOW_IN = "allowIn"
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPackageItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPackageItem.kt
index 1647b279f..c0963bc77 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPackageItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPackageItem.kt
@@ -22,6 +22,7 @@ import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ItemDocumentation.Companion.toItemDocumentationFactory
 import com.android.tools.metalava.model.ItemDocumentationFactory
 import com.android.tools.metalava.model.PackageItem
+import com.android.tools.metalava.model.TargetLanguageSet
 import com.android.tools.metalava.model.VisibilityLevel
 import com.android.tools.metalava.model.item.DefaultPackageItem
 import com.android.tools.metalava.model.item.PackageDoc
@@ -43,7 +44,8 @@ internal constructor(
     DefaultPackageItem(
         codebase = codebase,
         fileLocation = fileLocation,
-        itemLanguage = psiPackage.itemLanguage,
+        sourceLanguage = psiPackage.sourceLanguage,
+        targetLanguages = TargetLanguageSet.ALL,
         modifiers = modifiers,
         documentationFactory = documentationFactory,
         variantSelectorsFactory = ApiVariantSelectors.MUTABLE_FACTORY,
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiParameterDefaultValue.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiParameterDefaultValue.kt
index 2f68f4a38..d4874c0c6 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiParameterDefaultValue.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiParameterDefaultValue.kt
@@ -24,9 +24,11 @@ import org.jetbrains.kotlin.analysis.api.symbols.KaFunctionSymbol
 import org.jetbrains.kotlin.analysis.api.symbols.KaNamedFunctionSymbol
 import org.jetbrains.kotlin.analysis.api.symbols.KaParameterSymbol
 import org.jetbrains.kotlin.analysis.api.symbols.KaValueParameterSymbol
+import org.jetbrains.kotlin.psi.KtClass
 import org.jetbrains.kotlin.psi.KtConstantExpression
 import org.jetbrains.kotlin.psi.KtFunction
 import org.jetbrains.kotlin.psi.KtParameter
+import org.jetbrains.kotlin.psi.KtPrimaryConstructor
 import org.jetbrains.kotlin.psi.psiUtil.hasActualModifier
 import org.jetbrains.uast.UExpression
 import org.jetbrains.uast.UMethod
@@ -51,9 +53,20 @@ internal class PsiParameterDefaultValue(private val item: PsiParameterItem) :
     private fun PsiParameterItem.computeHasDefaultValue(): Boolean {
         if (psiParameter.isKotlin()) {
             val psiCallableItem = item.containingCallable() as PsiCallableItem
-            val ktFunction =
-                ((psiCallableItem.psi() as? UMethod)?.sourcePsi as? KtFunction) ?: return false
+            val sourcePsi = (psiCallableItem.psi() as? UMethod)?.sourcePsi
+
+            // The compiler-generated data class copy method has all optional parameters. The source
+            // psi in this case is the constructor for K2, the class for K1 (for a copy method
+            // defined in source, the psi would not be the source method).
+            if (
+                containingClass().modifiers.isData() &&
+                    psiCallableItem.name() == "copy" &&
+                    (sourcePsi is KtPrimaryConstructor || sourcePsi is KtClass)
+            ) {
+                return true
+            }
 
+            val ktFunction = (sourcePsi as? KtFunction) ?: return false
             analyze(ktFunction) {
                 val function =
                     if (ktFunction.hasActualModifier()) {
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiParameterItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiParameterItem.kt
index 026424c5d..b98aa7bce 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiParameterItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiParameterItem.kt
@@ -49,7 +49,7 @@ internal constructor(
     DefaultParameterItem(
         codebase = codebase,
         fileLocation = PsiFileLocation.fromPsiElement(psiParameter),
-        itemLanguage = psiParameter.itemLanguage,
+        sourceLanguage = psiParameter.sourceLanguage,
         modifiers = modifiers,
         name = name,
         publicNameProvider = publicNameProvider,
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPropertyItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPropertyItem.kt
index 048b1187c..477fe5a52 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPropertyItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPropertyItem.kt
@@ -54,7 +54,7 @@ private constructor(
     DefaultPropertyItem(
         codebase = codebase,
         fileLocation = PsiFileLocation(ktDeclaration),
-        itemLanguage = ktDeclaration.itemLanguage,
+        sourceLanguage = ktDeclaration.sourceLanguage,
         modifiers = modifiers,
         documentationFactory = documentationFactory,
         variantSelectorsFactory = ApiVariantSelectors.MUTABLE_FACTORY,
@@ -130,7 +130,8 @@ private constructor(
 
             val type =
                 getter?.returnType()
-                    ?: typeItemFactory.getTypeForKtElement(ktDeclaration) ?: return null
+                    ?: typeItemFactory.getTypeForKtElement(ktDeclaration)
+                    ?: return null
             val modifiers =
                 PsiModifierItem.createForProperty(codebase, ktDeclaration, getter, setter)
             if (modifiers.isFinal() && containingClass.modifiers.isFinal()) {
@@ -181,13 +182,13 @@ private constructor(
                 allAccessors.singleOrNull {
                     it.parameters().singleOrNull()?.type() == propertyReceiverType
                 }
-                // Work around a psi bug where value class extension property accessors don't
-                // include the receiver (b/385148821). This strategy does not always work, which is
-                // why the one above is used in most cases: the getter for a property parameter's
-                // source element will be a KtParameter, and the getter for a simple property
-                // declaration with no custom getter declaration will be a KtProperty, not a
-                // KtPropertyAccessor.
-                ?: allAccessors.singleOrNull {
+                    // Work around a psi bug where value class extension property accessors don't
+                    // include the receiver (b/385148821). This strategy does not always work, which
+                    // is why the one above is used in most cases: the getter for a property
+                    // parameter's source element will be a KtParameter, and the getter for a simple
+                    // property declaration with no custom getter declaration will be a KtProperty,
+                    // not a KtPropertyAccessor.
+                    ?: allAccessors.singleOrNull {
                         (it.psiMethod.sourceElement as? KtPropertyAccessor)?.isGetter == true
                     }
             }
@@ -206,8 +207,8 @@ private constructor(
                 allAccessors.singleOrNull {
                     it.parameters().size == 2 && it.parameters()[0].type() == propertyReceiverType
                 }
-                // Work around a psi bug, see the equivalent [findGetter] case for details.
-                ?: allAccessors.singleOrNull {
+                    // Work around a psi bug, see the equivalent [findGetter] case for details.
+                    ?: allAccessors.singleOrNull {
                         (it.psiMethod.sourceElement as? KtPropertyAccessor)?.isSetter == true
                     }
             }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceFile.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceFile.kt
index a66348209..ea48fab2e 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceFile.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceFile.kt
@@ -124,8 +124,7 @@ internal class PsiSourceFile(
                                 resolved.name,
                                 includeSuperClasses = true,
                                 includeInterfaces = false
-                            )
-                                ?: continue
+                            ) ?: continue
                         if (predicate.test(fieldItem)) {
                             imports.add(Import(fieldItem))
                         }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceModelProvider.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceModelProvider.kt
index d56952de3..ea80c4114 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceModelProvider.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceModelProvider.kt
@@ -35,6 +35,7 @@ internal class PsiSourceModelProvider : SourceModelProvider {
             Capability.KOTLIN,
             Capability.METHOD_BODY,
             Capability.DOCUMENTATION,
+            Capability.JAR_WITH_SOURCES,
         )
 
     override val modelOptionsList: List<ModelOptions> =
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceParser.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceParser.kt
index 1416c5c4f..830edf011 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceParser.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceParser.kt
@@ -23,6 +23,7 @@ import com.android.tools.lint.detector.api.Project
 import com.android.tools.metalava.model.ClassResolver
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.PackageFilter
+import com.android.tools.metalava.model.psi.kotlin.KotlinBytecodeApis
 import com.android.tools.metalava.model.source.DEFAULT_JAVA_LANGUAGE_LEVEL
 import com.android.tools.metalava.model.source.SourceParser
 import com.android.tools.metalava.model.source.SourceSet
@@ -87,14 +88,20 @@ internal class PsiSourceParser(
         classPath: List<File>,
         apiPackages: PackageFilter?,
         projectDescription: File?,
+        compiledSourceJar: File?,
     ): Codebase {
-        return parseAbsoluteSources(
-            sourceSet.absoluteCopy().extractRoots(reporter),
-            description,
-            classPath.map { it.absoluteFile },
-            apiPackages,
-            projectDescription,
-        )
+        val codebase =
+            parseAbsoluteSources(
+                sourceSet.absoluteCopy().extractRoots(reporter),
+                description,
+                classPath.map { it.absoluteFile },
+                apiPackages,
+                projectDescription,
+            )
+        if (compiledSourceJar != null) {
+            mergeFromJar(codebase, compiledSourceJar)
+        }
+        return codebase
     }
 
     /** Returns a codebase initialized from the given set of absolute files. */
@@ -172,6 +179,14 @@ internal class PsiSourceParser(
         return codebase
     }
 
+    fun mergeFromJar(existingCodebase: PsiBasedCodebase, jarFile: File) {
+        val bytecodeApis = KotlinBytecodeApis(existingCodebase)
+        val rewrittenJar = bytecodeApis.rewriteJar(jarFile)
+        val jarEnvironment = loadUastFromJars(listOf(rewrittenJar))
+        bytecodeApis.loadPsiFromProject(jarEnvironment.ideaProject)
+        (existingCodebase.assembler as PsiCodebaseAssembler).mergedJarEnvironment = jarEnvironment
+    }
+
     /** Initializes a UAST environment using the [apiJars] as classpath roots. */
     private fun loadUastFromJars(apiJars: List<File>): UastEnvironment {
         val config = UastEnvironment.Configuration.create(useFirUast = useK2Uast)
@@ -195,7 +210,7 @@ internal class PsiSourceParser(
         // `referenceDir` is used to adjust `lib` dir accordingly if needed,
         // but we set `classpath` anyway below.
         val lintProject =
-            Project.create(lintClient, /* dir = */ rootDir, /* referenceDir = */ rootDir)
+            Project.create(lintClient, /* dir= */ rootDir, /* referenceDir= */ rootDir)
         lintProject.kotlinLanguageLevel = kotlinLanguageLevel
         lintProject.javaSourceFolders.addAll(sourceRoots)
         lintProject.javaLibraries.addAll(classpath)
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItemFactory.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItemFactory.kt
index a30118b69..6ef4b1224 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItemFactory.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItemFactory.kt
@@ -51,6 +51,7 @@ import org.jetbrains.kotlin.analysis.api.types.KaFunctionType
 import org.jetbrains.kotlin.analysis.api.types.KaTypeMappingMode
 import org.jetbrains.kotlin.psi.KtElement
 import org.jetbrains.kotlin.utils.addToStdlib.ifNotEmpty
+import org.jetbrains.uast.UParameter
 import org.jetbrains.uast.kotlin.isKotlin
 
 /**
@@ -103,18 +104,37 @@ internal class PsiTypeItemFactory(
         parameterIndex: Int,
         isVarArg: Boolean
     ): TypeItem {
-        // Workaround for b/388030457, b/388508139: when a vararg is used in kotlin for a parameter
-        // that isn't final, it should be a regular PsiArrayType, not a PsiEllipsisType, but psi
-        // gets it wrong in some cases.
+        val isFinalParameter = parameterIndex + 1 == fingerprint.parameterCount
         val fixedUnderlyingParameterType =
             if (
+                // Workaround for b/388030457, b/388508139: when a vararg is used in kotlin for a
+                // parameter that isn't final, it should be a regular PsiArrayType, not a
+                // PsiEllipsisType, but psi gets it wrong in some cases.
                 underlyingParameterType.context?.isKotlin() == true &&
                     underlyingParameterType.psiType is PsiEllipsisType &&
-                    parameterIndex + 1 != fingerprint.parameterCount
+                    !isFinalParameter
             ) {
                 underlyingParameterType.copy(
                     psiType = underlyingParameterType.psiType.toArrayType()
                 )
+            } else if (
+                // Part of the workaround for https://youtrack.jetbrains.com/issue/KT-57537: for
+                // expect/actual JvmOverloads methods, the overloads aren't present in UAST and are
+                // created by metalava. A non-final varargs parameter will not have a
+                // PsiEllipsisType, but if the varargs parameter becomes final in one of the
+                // overloads, it needs to be switched to a PsiEllipsisType.
+                isFinalParameter &&
+                    !isVarArg &&
+                    underlyingParameterType.psiType is PsiArrayType &&
+                    (underlyingParameterType.context as? UParameter).hasVarargModifier()
+            ) {
+                underlyingParameterType.copy(
+                    psiType =
+                        PsiEllipsisType(
+                            underlyingParameterType.psiType.componentType,
+                            underlyingParameterType.psiType.annotationProvider
+                        )
+                )
             } else {
                 underlyingParameterType
             }
@@ -128,6 +148,9 @@ internal class PsiTypeItemFactory(
         )
     }
 
+    private fun UParameter?.hasVarargModifier() =
+        this?.modifierList?.text?.contains("vararg") == true
+
     /**
      * Returns a [PsiTypeItem] representing the [psiType]. The [context] is used to get nullability
      * information for Kotlin types.
@@ -298,6 +321,22 @@ internal class PsiTypeItemFactory(
                             kotlinType = kotlinType,
                             contextNullability = contextNullability,
                         )
+                    } else if (psiType.className?.toIntOrNull() != null) {
+                        // Workaround for b/407632515: a synthetic delegate lambda method loaded
+                        // from a jar has a number as the class name and causes on error when
+                        // creating the outer class type. Reload the PsiType, updating the qualified
+                        // name to one which doesn't make a number appear a class type.
+                        // Replace `.`s before numbers with `$`s, like would be present in the
+                        // compiled type.
+                        val workaroundQualifiedName =
+                            psiType.computeQualifiedName().replace(Regex("\\.(\\d)"), "\\$$1")
+                        val workaroundPsiType = assembler.createPsiType(workaroundQualifiedName)
+                        return createTypeItem(
+                            workaroundPsiType,
+                            kotlinType,
+                            contextNullability,
+                            creatingClassTypeForClass
+                        )
                     } else {
                         val classType =
                             createClassTypeItem(
@@ -472,8 +511,7 @@ internal class PsiTypeItemFactory(
                     (ktType as? KaClassType)?.typeArguments?.ifNotEmpty {
                         fixUpPsiTypeMissingTypeArguments(psiType, kotlinType)
                     }
-                }
-                    ?: emptyList()
+                } ?: emptyList()
             }
 
         return psiParameters.mapIndexed { i, param ->
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterItem.kt
index 38d578ea5..d0c5bffdf 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterItem.kt
@@ -26,13 +26,13 @@ import org.jetbrains.kotlin.lexer.KtTokens
 import org.jetbrains.kotlin.psi.KtTypeParameter
 
 internal class PsiTypeParameterItem(
-    override val codebase: PsiBasedCodebase,
+    private val codebase: PsiBasedCodebase,
     private val psiTypeParameter: PsiTypeParameter,
     name: String,
     modifiers: BaseModifierList
 ) :
     DefaultTypeParameterItem(
-        codebase = codebase,
+        classResolver = codebase,
         modifiers = modifiers,
         name = name,
         isReified = isReified(psiTypeParameter),
@@ -90,7 +90,7 @@ internal class PsiTypeParameterItem(
             ktTypeParameter: KtTypeParameter
         ): DefaultTypeParameterItem {
             return DefaultTypeParameterItem(
-                codebase = codebase,
+                classResolver = codebase,
                 modifiers = PsiModifierItem.createForKtDeclaration(codebase, ktTypeParameter),
                 name = ktTypeParameter.name!!,
                 isReified = ktTypeParameter.text.startsWith(KtTokens.REIFIED_KEYWORD.value)
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiValueFactory.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiValueFactory.kt
new file mode 100644
index 000000000..74a2da5b2
--- /dev/null
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiValueFactory.kt
@@ -0,0 +1,861 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.psi
+
+import com.android.tools.lint.detector.api.ConstantEvaluator
+import com.android.tools.metalava.model.AnnotationAttribute
+import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.ArrayTypeItem
+import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.PrimitiveTypeItem.Primitive
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.VariableTypeItem
+import com.android.tools.metalava.model.type.ContextNullability
+import com.android.tools.metalava.model.type.DefaultPrimitiveTypeItem
+import com.android.tools.metalava.model.type.DefaultTypeModifiers
+import com.android.tools.metalava.model.value.AnnotationValue
+import com.android.tools.metalava.model.value.ArrayElementValue
+import com.android.tools.metalava.model.value.BaseCachingDeferredTypeValueProvider
+import com.android.tools.metalava.model.value.CachingValueProvider
+import com.android.tools.metalava.model.value.ClassObjectValue
+import com.android.tools.metalava.model.value.CombinedValueProvider
+import com.android.tools.metalava.model.value.ConstantValue
+import com.android.tools.metalava.model.value.FieldReferenceValue
+import com.android.tools.metalava.model.value.ImplementationValueToModelFactory
+import com.android.tools.metalava.model.value.LiteralValue
+import com.android.tools.metalava.model.value.Value
+import com.android.tools.metalava.model.value.ValueFactory
+import com.android.tools.metalava.model.value.ValueProvider
+import com.android.tools.metalava.model.value.ValueProviderException
+import com.android.tools.metalava.model.value.ValueUseSite
+import com.android.tools.metalava.reporter.FileLocation
+import com.intellij.psi.JavaPsiFacade
+import com.intellij.psi.PsiAnnotation
+import com.intellij.psi.PsiAnnotationMemberValue
+import com.intellij.psi.PsiArrayInitializerMemberValue
+import com.intellij.psi.PsiClass
+import com.intellij.psi.PsiClassObjectAccessExpression
+import com.intellij.psi.PsiElement
+import com.intellij.psi.PsiField
+import com.intellij.psi.PsiLiteral
+import com.intellij.psi.PsiLiteralExpression
+import com.intellij.psi.PsiMethod
+import com.intellij.psi.PsiNewExpression
+import com.intellij.psi.PsiReferenceExpression
+import com.intellij.psi.PsiTypes
+import org.jetbrains.kotlin.name.ClassId
+import org.jetbrains.kotlin.name.Name
+import org.jetbrains.uast.UCallExpression
+import org.jetbrains.uast.UClassLiteralExpression
+import org.jetbrains.uast.UExpression
+import org.jetbrains.uast.ULiteralExpression
+import org.jetbrains.uast.UPrefixExpression
+import org.jetbrains.uast.UQualifiedReferenceExpression
+import org.jetbrains.uast.UReferenceExpression
+import org.jetbrains.uast.UResolvable
+import org.jetbrains.uast.USimpleNameReferenceExpression
+import org.jetbrains.uast.UastCallKind
+import org.jetbrains.uast.UastPrefixOperator
+import org.jetbrains.uast.UastQualifiedExpressionAccessType
+import org.jetbrains.uast.getParameterForArgument
+
+/**
+ * Creates [ValueProvider]s that will delegate to [implementationValueToModelValue] to create
+ * [Value]s when requested.
+ *
+ * @param globalTypeItemFactory the global [PsiTypeItemFactory] used for creating [TypeItem]s for
+ *   [ClassObjectValue]s. It uses the global factory as the types will never be [VariableTypeItem]s
+ *   and so there is no need to use a factory that has access to the in scope type parameters.
+ */
+internal class PsiValueFactory(
+    private val codebase: PsiBasedCodebase,
+    private val globalTypeItemFactory: PsiTypeItemFactory,
+) : ValueFactory, ImplementationValueToModelFactory<Any> {
+    /**
+     * Get a [CombinedValueProvider] that will create (and cache) a [Value] of [optionalTypeItem]
+     * from [anyValue].
+     *
+     * @param optionalTypeItem the optional type for the value, e.g. [MethodItem.returnType] (for
+     *   attribute or attribute default values) or [FieldItem.type].
+     * @param anyValue the underlying Psi specific value. It is of type [Any] to avoid having to
+     *   duplicate everything for [UExpression] and [PsiAnnotationMemberValue].
+     * @param valueUseSite the [ValueUseSite] for which this will provide a [Value].
+     */
+    fun providerFor(
+        optionalTypeItem: TypeItem?,
+        anyValue: Any,
+        valueUseSite: ValueUseSite
+    ): CombinedValueProvider = CachingValueProvider(this, optionalTypeItem, anyValue, valueUseSite)
+
+    /**
+     * Get a [CombinedValueProvider] that will create (and cache) a [Value] for attribute
+     * [attributeName] of [annotationPsiClass] from [anyValue].
+     *
+     * @param annotationPsiClass the optional [PsiClass].
+     * @param attributeName the name of the attribute whose value it will provide.
+     * @param anyValue the underlying Psi specific value. It is of type [Any] to avoid having to
+     *   duplicate everything for [UExpression] and [PsiAnnotationMemberValue].
+     */
+    fun providerForAnnotationValue(
+        annotationPsiClass: PsiClass?,
+        attributeName: String,
+        anyValue: Any
+    ): CombinedValueProvider =
+        annotationPsiClass?.let {
+            PsiCachingAnnotationValueProvider(
+                this,
+                anyValue,
+                globalTypeItemFactory,
+                annotationPsiClass,
+                attributeName
+            )
+        } ?: providerFor(null, anyValue, ValueUseSite.ANNOTATION)
+
+    /**
+     * Create a [Value] of [optionalTypeItem] from [implementationValue].
+     *
+     * Uses [Any] to avoid having to duplicate everything for [UExpression] and
+     * [PsiAnnotationMemberValue].
+     */
+    override fun implementationValueToModelValue(
+        optionalTypeItem: TypeItem?,
+        implementationValue: Any,
+        valueUseSite: ValueUseSite,
+    ): Value? {
+        val value =
+            when (implementationValue) {
+                is UExpression -> {
+                    uExpressionToValue(optionalTypeItem, implementationValue)
+                }
+                is PsiAnnotationMemberValue -> {
+                    psiToValue(optionalTypeItem, implementationValue)
+                }
+                else -> null
+            }
+
+        // If no value could be created, and it is for an annotation attribute then fail as an
+        // annotation attribute MUST always have a value.
+        if (value == null && valueUseSite == ValueUseSite.ANNOTATION) {
+            unknownExpression(optionalTypeItem, implementationValue)
+        }
+
+        return value
+    }
+
+    /**
+     * An unknown [expression] of [optionalTypeItem] was found and it was not possible to return
+     * `null` so throw an exception.
+     */
+    private fun unknownExpression(optionalTypeItem: TypeItem?, expression: Any): Nothing {
+        throw ValueProviderException(
+            "Unknown value '$expression' of ${expression.javaClass} for type $optionalTypeItem"
+        )
+    }
+
+    /** Create a [Value] of [optionalTypeItem] from [uExpression]. */
+    private fun uExpressionToValue(
+        optionalTypeItem: TypeItem?,
+        uExpression: UExpression,
+    ): Value? {
+        if (
+            uExpression is UCallExpression &&
+                uExpression.kind == UastCallKind.NESTED_ARRAY_INITIALIZER
+        ) {
+            val arrayTypeItem = optionalTypeItem as? ArrayTypeItem
+            val elementType = arrayTypeItem?.componentType
+            val elements =
+                uExpression.valueArguments.map {
+                    uExpressionToArrayElementValue(elementType, it)
+                        ?: unknownExpression(elementType, it)
+                }
+            return createArrayValue(elements)
+        }
+
+        return if (optionalTypeItem is ArrayTypeItem) {
+            // The type is an array so this is an example of not having to add curly braces around a
+            // single value in an annotation attribute. Create a value for the component type and
+            // then wrap it in an ArrayValue.
+            uExpressionToArrayElementValue(optionalTypeItem.componentType, uExpression)?.let {
+                singleValue ->
+                createArrayValue(listOf(singleValue), wasUnwrappedInSource = true)
+            }
+        } else {
+            uExpressionToArrayElementValue(optionalTypeItem, uExpression)
+        }
+    }
+
+    /** Create an [ArrayElementValue] of [optionalTypeItem] from [uExpression]. */
+    private fun uExpressionToArrayElementValue(
+        optionalTypeItem: TypeItem?,
+        uExpression: UExpression
+    ): ArrayElementValue? {
+        when (uExpression) {
+            // Handle a qualified reference, i.e. one of the form <receiver>.<selector>.
+            is UQualifiedReferenceExpression -> {
+                // Check to see if it is a class literal and if so then create a ClassObjectValue
+                // and return it, otherwise drop through.
+                uReferenceExpressionToClassObjectValue(uExpression)?.let {
+                    return it
+                }
+
+                val receiver = uExpression.receiver
+
+                // Check to see if the receiver could be resolved to a class. If it could then pass
+                // it in below as it may affect the result.
+                val receiverPsiClass = (receiver as? UReferenceExpression)?.resolve() as? PsiClass
+
+                // Try and resolve it and convert to a value.
+                uResolvableToValue(optionalTypeItem, uExpression, receiverPsiClass)?.let {
+                    return it
+                }
+
+                // Ignore any other access type than a simple '.'.
+                if (uExpression.accessType == UastQualifiedExpressionAccessType.SIMPLE) {
+                    // The `receiver` is the qualifier and the `selector` is what is being
+                    // qualified.
+                    when (val selector = uExpression.selector) {
+                        is UCallExpression -> {
+                            // Nested annotations are represented as a call to an annotation class
+                            // constructor so check to see if that is the case.
+                            uCallExpressionToAnnotationValue(selector)?.let {
+                                return it
+                            }
+
+                            // Check to see whether the call is to a numeric conversion function.
+                            val explicitConversionTo = selector.isNumericConversionFunction()
+                            if (explicitConversionTo != null) {
+                                //  Deconstruct the call to if it is being called on a field
+                                //  reference. If it is then create a field reference for it. This
+                                // handles two cases, e.g.:
+                                //     qualified.FIELD.toLong()
+                                //     UNQUALIFIED.toLong()
+                                if (receiver is UReferenceExpression) {
+                                    // Try and resolve it and convert to a value.
+                                    uResolvableToValue(
+                                            optionalTypeItem,
+                                            receiver,
+                                            receiverPsiClass,
+                                            explicitConversionTo
+                                        )
+                                        ?.let {
+                                            return it
+                                        }
+                                }
+                            }
+                        }
+                        is USimpleNameReferenceExpression -> {
+                            // Handle an unknown, unresolvable field.
+                            val receiverText = receiver.asRenderString()
+                            val selectorText = selector.asRenderString()
+                            return createFieldReferenceValue(codebase, receiverText, selectorText)
+                        }
+                    }
+                }
+            }
+            // Handle an unqualified reference, i.e. one of the form <identifier>.
+            is USimpleNameReferenceExpression -> {
+                // Try and resolve it and convert to a value.
+                uResolvableToValue(optionalTypeItem, uExpression)?.let {
+                    return it
+                }
+
+                // Handle an unknown, unresolvable field.
+                return createFieldReferenceValue(codebase, "", uExpression.identifier)
+            }
+            is UClassLiteralExpression -> {
+                uClassLiteralExpressionToClassObjectValue(uExpression)?.let {
+                    return it
+                }
+            }
+            is UCallExpression -> {
+                // Nested annotations are represented as a call to an annotation class constructor
+                // so check to see if that is the case.
+                uCallExpressionToAnnotationValue(uExpression)?.let {
+                    return it
+                }
+            }
+        }
+
+        // All others drop through.
+        return uExpressionToConstant(optionalTypeItem, uExpression)
+    }
+
+    /**
+     * Checks to see if [uExpression] is of the form `<type>::class.java`, if not it returns null
+     * otherwise it creates a [ClassObjectValue] for it.
+     *
+     * In this case `<type>` can be either a primitive, a normal class, or an array (possibly
+     * multidimensional) of them.
+     */
+    private fun uReferenceExpressionToClassObjectValue(
+        uExpression: UQualifiedReferenceExpression
+    ): ClassObjectValue? {
+        // Check for the SIMPLE access type, i.e. ".", in `<class>::class.java`
+        if (uExpression.accessType != UastQualifiedExpressionAccessType.SIMPLE) return null
+
+        // Check for the `java` part.
+        val selector = uExpression.selector
+        // TODO(b/354633349): Support javaPrimitiveType and javaObjectType too?
+        if (selector !is USimpleNameReferenceExpression || selector.identifier != "java")
+            return null
+
+        // Check to make sure the receiver is the `<class>::class` part.
+        val receiver = uExpression.receiver as? UClassLiteralExpression ?: return null
+        return uClassLiteralExpressionToClassObjectValue(receiver)
+    }
+
+    /**
+     * Checks to see if [uExpression] is of the form `<type>::class`, if not it returns null
+     * otherwise it creates a [ClassObjectValue] for it.
+     *
+     * In this case `<type>` can be either a primitive, a normal class, or an array (possibly
+     * multidimensional) of them.
+     */
+    private fun uClassLiteralExpressionToClassObjectValue(
+        uExpression: UClassLiteralExpression
+    ): ClassObjectValue? {
+        // Make sure the type is present.
+        val type = uExpression.type ?: return null
+
+        // Get the type of the class literal. e.g. if the expression was `X::class` then this
+        // will be of type `X`, or if the expression was of type `Array<X>.class` then this will
+        // be of type `X[]`. `X` may be a primitive type.
+        val receiverTypeItem =
+            globalTypeItemFactory.getType(
+                type,
+                contextNullability = ContextNullability.forceNonNull,
+            )
+
+        val unboxedTypeItem = unboxTypeItemIfNeeded(receiverTypeItem, uExpression)
+
+        // If it is a ClassTypeItem then make sure it does not have any arguments. It is not
+        // necessary to check array components as Kotlin does not support class literals for arrays
+        // of generic classes, e.g. `Array<List<*>>::class`.
+        val classLiteralTypeItem =
+            if (unboxedTypeItem is ClassTypeItem)
+                unboxedTypeItem.substitute(arguments = emptyList())
+            else unboxedTypeItem
+
+        return createClassObjectValue(classLiteralTypeItem, uExpression.asSourceString())
+    }
+
+    /** Try and convert a [UResolvable] to an [ArrayElementValue]. */
+    private fun uResolvableToValue(
+        optionalTypeItem: TypeItem?,
+        uResolvable: UResolvable,
+        receiverPsiClass: PsiClass? = null,
+        explicitConversionTo: Primitive? = null,
+    ): ArrayElementValue? {
+        // Resolve it and convert it to a Value if possible.
+        val resolved = uResolvable.resolve()
+
+        // Try and convert the resolved PsiElement to a Value and return it if succeeded.
+        resolvedPsiElementToValue(
+                optionalTypeItem,
+                resolved,
+                receiverPsiClass,
+                explicitConversionTo
+            )
+            ?.let {
+                return it
+            }
+
+        return null
+    }
+
+    /**
+     * Both Kotlin "primitive" types and their corresponding Java wrapper class will use the wrapper
+     * class as their type, e.g. `Int::class.java` and `Integer::class.java` will both have a type
+     * `Class<Integer>`. So, use clues from the source [receiver] to choose the correct one.
+     */
+    private fun unboxTypeItemIfNeeded(
+        receiverTypeItem: PsiTypeItem,
+        receiver: UClassLiteralExpression
+    ): TypeItem {
+        if (receiverTypeItem !is ClassTypeItem) return receiverTypeItem
+        val expression =
+            receiver.expression as? USimpleNameReferenceExpression ?: return receiverTypeItem
+        val primitiveKind =
+            Primitive.forWrapperClassName(receiverTypeItem.qualifiedName) ?: return receiverTypeItem
+
+        if (expression.identifier != primitiveKind.kotlinName) return receiverTypeItem
+
+        val psiType =
+            when (primitiveKind) {
+                Primitive.BOOLEAN -> PsiTypes.booleanType()
+                Primitive.BYTE -> PsiTypes.byteType()
+                Primitive.CHAR -> PsiTypes.charType()
+                Primitive.DOUBLE -> PsiTypes.doubleType()
+                Primitive.FLOAT -> PsiTypes.floatType()
+                Primitive.INT -> PsiTypes.intType()
+                Primitive.LONG -> PsiTypes.longType()
+                Primitive.SHORT -> PsiTypes.shortType()
+                Primitive.VOID -> PsiTypes.voidType()
+            }
+
+        return globalTypeItemFactory.getType(
+            psiType,
+            contextNullability = ContextNullability.forceNonNull
+        )
+    }
+
+    /**
+     * Create an [AnnotationValue] from [uExpression] if possible, otherwise return `null`.
+     *
+     * @param uExpression a call to an annotation class's constructor.
+     */
+    private fun uCallExpressionToAnnotationValue(uExpression: UCallExpression): AnnotationValue? {
+        // Annotations are created using constructor calls.
+        if (uExpression.kind != UastCallKind.CONSTRUCTOR_CALL) return null
+
+        // Resolve the call to the constructor, return null if it cannot be resolved.
+        // The resolved element might be the constructor method or the class of the constructor.
+        // It will be the class when the annotation class is originally kotlin source but from the
+        // classpath, because annotation constructors are a kotlin feature only present in the
+        // kotlin metadata annotation for compiled code.
+        val resolved = uExpression.resolve() ?: uExpression.classReference?.resolve()
+        val psiClass =
+            when (resolved) {
+                is PsiMethod ->
+                    if (resolved.isConstructor) {
+                        resolved.containingClass
+                    } else {
+                        null
+                    }
+                is PsiClass -> resolved
+                else -> null
+            }
+
+        // Get the qualified name of the constructor class, return null if it is not available.
+        val qualifiedClassName = psiClass?.qualifiedName ?: return null
+
+        fun attributesProvider() =
+            // Iterate over the arguments as the order in which they are specified is important.
+            uExpression.valueArguments.mapNotNull { uArgument ->
+
+                // Get the parameter for this argument, if no parameter is provided then ignore the
+                // argument.
+                val psiParameter =
+                    uExpression.getParameterForArgument(uArgument) ?: return@mapNotNull null
+
+                // Get the name and type from the parameter.
+                val name = psiParameter.name
+                val typeItem = globalTypeItemFactory.getType(psiParameter.type)
+
+                // Create a value from the expression. This needs to be done immediately so that
+                // asAnnotationAttributeValue() call below can differentiate between an ArrayValue
+                // (which needs to be converted to an AnnotationArrayAttributeValue) and other
+                // values.
+                val value =
+                    uExpressionToArrayElementValue(typeItem, uArgument)
+                        ?: unknownExpression(typeItem, uArgument)
+                AnnotationAttribute.createAttribute(name, value)
+            }
+
+        val annotationItem =
+            AnnotationItem.createAttributesLazily(
+                codebase,
+                FileLocation.UNKNOWN,
+                qualifiedClassName,
+                ::attributesProvider,
+            )
+
+        return createAnnotationValue(annotationItem!!)
+    }
+
+    /**
+     * Check to see whether this [UCallExpression] is for a Kotlin numeric conversion function, e.g.
+     * `toLong()`.
+     */
+    private fun UCallExpression.isNumericConversionFunction(): Primitive? {
+        // Casts are represented as method calls.
+        if (kind != UastCallKind.METHOD_CALL) return null
+
+        // Cast methods have no arguments
+        if (valueArgumentCount != 0) return null
+
+        val methodName = methodName ?: return null
+        return Primitive.forKotlinNumericConversionFunctionName(methodName)
+    }
+
+    /** Create a [ConstantValue] of [optionalTypeItem] from [uExpression]. */
+    private fun uExpressionToConstant(
+        optionalTypeItem: TypeItem?,
+        uExpression: UExpression
+    ): ConstantValue? {
+        // If the type is supplied, and it's not a constant type then return immediately as this can
+        // never be treated as a constant value. If it is not supplied then drop through and check
+        // the actual value, if any.
+        if (optionalTypeItem != null && !optionalTypeItem.isConstantType()) {
+            return null
+        }
+
+        if (uExpression is ULiteralExpression) {
+            uExpression.value?.let { underlyingValue ->
+                // Get the original source value, undoing any int -> long conversions done by K2.
+                val originalSourceValue =
+                    when (underlyingValue) {
+                        // Byte and short always use an integer literal as there are no byte or
+                        // short literals in Kotlin. That is true whether they are signed or
+                        // unsigned.
+                        is Byte -> underlyingValue.toInt()
+                        is Short -> underlyingValue.toInt()
+                        is UByte -> underlyingValue.toInt()
+                        is UShort -> underlyingValue.toInt()
+                        is Long -> undoConversionOfSourceIntIfNeeded(underlyingValue, uExpression)
+                        else -> underlyingValue
+                    }
+
+                // TODO(b/420371817): Work around an issue in Psi which prevents the class of the
+                //   @setparam:Anno from being resolved which means that optionalTypeItem is null
+                //   even though the underlying Psi code knows the type and has cast the integer
+                //   literal to a `long`. The workaround synthesizes an optionalTypeItem of `long`
+                //   based on the fact that the `underlyingValue` is `long`. It does not handle the
+                //   other types as they are not needed at the moment.
+                val actualPrimitiveKind =
+                    if (optionalTypeItem == null && underlyingValue != originalSourceValue)
+                        when (underlyingValue) {
+                            is Byte -> Primitive.BYTE
+                            is Long -> Primitive.LONG
+                            is Short -> Primitive.SHORT
+                            else -> null
+                        }
+                    else null
+
+                val actualTypeItem =
+                    actualPrimitiveKind?.let { kind ->
+                        DefaultPrimitiveTypeItem(DefaultTypeModifiers.emptyNonNullModifiers, kind)
+                    } ?: optionalTypeItem
+
+                return uLiteralValue(actualTypeItem, originalSourceValue)
+            }
+        }
+
+        // All others expressions are evaluated to a literal, if possible and returned.
+        ConstantEvaluator.evaluate(null, uExpression)?.let { value ->
+            // Get the original source value, undoing any int -> long conversions done by K2. This
+            // is only done for unary minus expressions, i.e. of the form `-<expr>`.
+            val originalSourceValue =
+                if (
+                    uExpression is UPrefixExpression &&
+                        uExpression.operator == UastPrefixOperator.UNARY_MINUS &&
+                        value is Long
+                ) {
+                    undoConversionOfSourceIntIfNeeded(value, uExpression)
+                } else {
+                    value
+                }
+
+            return uLiteralValue(optionalTypeItem, originalSourceValue, nonLiteralInSource = true)
+        }
+
+        // An unknown expression was found so return null and the caller will handle as needed.
+        return null
+    }
+
+    /**
+     * Checks to see if the underlying value has been already been converted from the source literal
+     * type to a type appropriate for where it is being used; if it has then it undo the conversion
+     * to preserve the information about the source literal type.
+     *
+     * That is needed to enable consistent processing with legacy value handling which often uses
+     * the source type directly, e.g. when parsing `longValue = 1` it may write it as `longValue =
+     * 1` instead of the more consistent `longValue = 1L`.
+     *
+     * This generally only affects K2 as K1 does not bother casting to the correct type.
+     */
+    private fun undoConversionOfSourceIntIfNeeded(
+        underlyingValue: Long,
+        uExpression: UExpression,
+    ) =
+        uExpression.sourcePsi?.text?.let { text ->
+            // If the text ends with `L` or `l` then it was a long literal so keep it as
+            // such.
+            if (text.endsWith("L") || text.endsWith("l")) underlyingValue
+            else {
+                // Otherwise, try and see if it can be cast to an int without loss. If it
+                // can then use the int, otherwise keep the original value.
+                val asInt = underlyingValue.toInt()
+                if (asInt.toLong() == underlyingValue) asInt else underlyingValue
+            }
+        } ?: underlyingValue
+
+    /**
+     * Create a [LiteralValue] from a [value].
+     *
+     * Handles mapping Kotlin unsigned value to the equivalent Java signed value.
+     */
+    private fun uLiteralValue(
+        optionalTypeItem: TypeItem?,
+        value: Any,
+        nonLiteralInSource: Boolean = false,
+    ): LiteralValue<*> {
+        // Convert unsigned to signed values. It would be cleaner if these could just be treated
+        // like another Number class as then they could be handled as part of the normalization done
+        // by `createLiteralValue(...)` but unfortunately, the unsigned types are not Numbers.
+        val transformedValue =
+            when (value) {
+                is UByte -> value.toByte()
+                is UInt -> value.toInt()
+                is ULong -> value.toLong()
+                is UShort -> value.toShort()
+                else -> value
+            }
+
+        return createLiteralValue(optionalTypeItem, transformedValue, nonLiteralInSource)
+    }
+
+    /** Create a [Value] of [optionalTypeItem] from [psiValue]. */
+    private fun psiToValue(
+        optionalTypeItem: TypeItem?,
+        psiValue: PsiAnnotationMemberValue,
+    ) =
+        when (psiValue) {
+            // Array literal.
+            is PsiArrayInitializerMemberValue -> {
+                val arrayTypeItem = optionalTypeItem as? ArrayTypeItem
+                val elementType = arrayTypeItem?.componentType
+                val elements =
+                    psiValue.initializers.map {
+                        psiToArrayElementValue(elementType, it)
+                            ?: unknownExpression(elementType, it)
+                    }
+                createArrayValue(elements)
+            }
+            is PsiNewExpression -> {
+                // New expressions cannot be used with annotations (they use array literals) and if
+                // they are used with fields they always return a `null` value so just return
+                // immediately. This avoids issues when dealing with expressions like `field = new
+                // int[0]` which end up being evaluated in [psiToConstant] to an array or an Android
+                // Lint specific type.
+                null
+            }
+            else -> {
+                if (optionalTypeItem is ArrayTypeItem) {
+                    // The type is an array so this is an example of not having to add curly braces
+                    // around a single value in an annotation attribute. Create a value for the
+                    // component type and then wrap it in an ArrayValue.
+                    psiToArrayElementValue(optionalTypeItem.componentType, psiValue)?.let {
+                        singleValue ->
+                        createArrayValue(listOf(singleValue), wasUnwrappedInSource = true)
+                    }
+                } else {
+                    psiToArrayElementValue(optionalTypeItem, psiValue)
+                }
+            }
+        }
+
+    /** Create an [ArrayElementValue] of [optionalTypeItem] from [psiValue]. */
+    private fun psiToArrayElementValue(
+        optionalTypeItem: TypeItem?,
+        psiValue: PsiAnnotationMemberValue,
+    ): ArrayElementValue? {
+        when (psiValue) {
+            // Class literal, e.g. `SomeClass.class`.
+            is PsiClassObjectAccessExpression -> {
+                // Get the type of the class literal. e.g. if the expression was `X.class` then this
+                // will be of type `X`, or if the expression was of type `X[].class` then this will
+                // be of type `X[]`. `X` may be a primitive type.
+                val classLiteralTypeItem =
+                    globalTypeItemFactory.getType(
+                        psiValue.operand.type,
+                        contextNullability = ContextNullability.forceNonNull,
+                    )
+
+                return createClassObjectValue(
+                    classLiteralTypeItem,
+                    sourceExpression = psiValue.text,
+                )
+            }
+            // Field reference.
+            is PsiReferenceExpression -> {
+                val resolved = psiValue.resolve()
+                // Try and convert the resolved PsiElement to a Value and return it if succeeded.
+                resolvedPsiElementToValue(optionalTypeItem, resolved)?.let {
+                    return it
+                }
+
+                // Handle an unknown, unresolvable field.
+                val qualifierText = psiValue.qualifierExpression?.text ?: ""
+                val referenceName = psiValue.referenceName
+                if (referenceName != null) {
+                    return createFieldReferenceValue(codebase, qualifierText, referenceName)
+                }
+            }
+            is PsiLiteral -> {
+                val underlyingPsiValue = psiValue.value
+                if (underlyingPsiValue is Pair<*, *>) {
+                    // Needed for field reference in some special Kotlin annotations, e.g.
+                    // @file:RestrictTo(RestrictTo.Scope.LIBRARY).
+                    val (first, second) = underlyingPsiValue
+                    if (first is ClassId && second is Name) {
+                        val qualifiedClassName = first.asFqNameString()
+                        val fieldName = second.asString()
+
+                        return createFieldReferenceValueWithDeferredConstantValue(
+                            codebase,
+                            qualifiedClassName,
+                            fieldName,
+                            optionalTypeItem,
+                        )
+                    }
+                }
+            }
+            // An annotation value.
+            is PsiAnnotation -> {
+                PsiAnnotationItem.create(codebase, psiValue)?.let { annotationItem ->
+                    return createAnnotationValue(annotationItem)
+                }
+            }
+        }
+
+        // All others drop through.
+        return psiToConstant(optionalTypeItem, psiValue)
+    }
+
+    /** Create a [ConstantValue] of [optionalTypeItem] from [psiValue]. */
+    private fun psiToConstant(
+        optionalTypeItem: TypeItem?,
+        psiValue: PsiAnnotationMemberValue,
+    ): ConstantValue? {
+        // If the type is supplied, and it's not a constant type then return immediately as this can
+        // never be treated as a constant value. If it is not supplied then drop through and check
+        // the actual value, if any.
+        if (optionalTypeItem != null && !optionalTypeItem.isConstantType()) {
+            return null
+        }
+
+        // Literal primitive or String.
+        if (psiValue is PsiLiteralExpression) {
+            return psiValue.value?.let { underlyingValue ->
+                createLiteralValue(optionalTypeItem, underlyingValue)
+            }
+        }
+
+        // All others expressions are evaluated to a literal, if possible and returned.
+        ConstantEvaluator.evaluate(null, psiValue)?.let { value ->
+            return createLiteralValue(
+                optionalTypeItem,
+                value,
+                nonLiteralInSource = true,
+            )
+        }
+
+        // Temporarily fall through to use PsiConstantEvaluationHelper
+        // TODO(b/408445860): Remove once ConstantEvaluator can handle the necessary cases.
+        val javaPsiFacade = JavaPsiFacade.getInstance(codebase.project)
+        javaPsiFacade.constantEvaluationHelper.computeConstantExpression(psiValue)?.let { value ->
+            return createLiteralValue(
+                optionalTypeItem,
+                value,
+                nonLiteralInSource = true,
+            )
+        }
+
+        // An unknown expression was found so return null and the caller will handle as needed.
+        return null
+    }
+
+    /**
+     * Try and convert the [resolved] [PsiElement] to an [ArrayElementValue].
+     *
+     * If [resolved] is a [PsiField] and it is not an enum constant then it will call
+     * [FieldItem.constantValue] to find the [ConstantValue] for the [FieldReferenceValue].
+     */
+    private fun resolvedPsiElementToValue(
+        optionalTypeItem: TypeItem?,
+        resolved: PsiElement?,
+        receiverPsiClass: PsiClass? = null,
+        explicitConversionTo: Primitive? = null,
+    ): ArrayElementValue? {
+        if (resolved is PsiField) {
+            val qualifiedClassName = resolved.containingClass?.qualifiedName ?: ""
+            val fieldName = resolved.name
+
+            val kotlinCompanionClass =
+                if (receiverPsiClass !== resolved.containingClass)
+                    receiverPsiClass?.qualifiedNameIfCompanionClass()
+                else null
+
+            return createFieldReferenceValueWithDeferredConstantValue(
+                codebase,
+                qualifiedClassName,
+                fieldName,
+                optionalTypeItem,
+                kotlinCompanionClass,
+                explicitConversionTo,
+            )
+        }
+
+        return null
+    }
+
+    /**
+     * Returns [PsiClass.getQualifiedName] if this is a companion class.
+     *
+     * This must have been resolved from a [UQualifiedReferenceExpression.receiver].
+     */
+    private fun PsiClass.qualifiedNameIfCompanionClass(): String? =
+        if (isCompanion()) qualifiedName else null
+
+    /**
+     * Returns `true` if this is a companion class.
+     *
+     * This uses [PsiModifierItem.create] to avoid having to duplicate the code that deals with the
+     * Psi object model.
+     */
+    private fun PsiClass.isCompanion() = PsiModifierItem.create(codebase, this).isCompanion()
+}
+
+/**
+ * A [BaseCachingDeferredTypeValueProvider] that is used for annotation attribute values.
+ *
+ * It will attempt to find the [optionalTypeItem] by looking for the attribute method called
+ * [attributeName] in [annotationPsiClass] and if found, converting its return type to a [TypeItem]
+ * using [globalTypeItemFactory].
+ */
+private class PsiCachingAnnotationValueProvider(
+    factory: ImplementationValueToModelFactory<Any>,
+    implementationValue: Any,
+    private val globalTypeItemFactory: PsiTypeItemFactory,
+    private val annotationPsiClass: PsiClass,
+    private val attributeName: String,
+) :
+    BaseCachingDeferredTypeValueProvider<Any>(
+        factory,
+        implementationValue,
+        ValueUseSite.ANNOTATION,
+    ) {
+
+    override fun optionalTypeItem() =
+        annotationPsiClass
+            // Find the attribute method.
+            .methods
+            .firstOrNull { it.name == attributeName }
+            // If found then convert its return type to a TypeItem.
+            ?.let { psiMethod ->
+                psiMethod.returnType?.let { psiType ->
+                    globalTypeItemFactory.getType(
+                        psiType,
+                        psiMethod,
+                        ContextNullability.forceNonNull
+                    )
+                }
+            }
+}
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/UAnnotationItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/UAnnotationItem.kt
index 029feddcb..f13b979fc 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/UAnnotationItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/UAnnotationItem.kt
@@ -16,353 +16,48 @@
 
 package com.android.tools.metalava.model.psi
 
-import com.android.tools.lint.detector.api.ConstantEvaluator
 import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
 import com.android.tools.metalava.model.AnnotationAttribute
-import com.android.tools.metalava.model.AnnotationAttributeValue
 import com.android.tools.metalava.model.AnnotationItem
-import com.android.tools.metalava.model.AnnotationTarget
-import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.DefaultAnnotationArrayAttributeValue
-import com.android.tools.metalava.model.DefaultAnnotationAttribute
-import com.android.tools.metalava.model.DefaultAnnotationItem
-import com.android.tools.metalava.model.DefaultAnnotationSingleAttributeValue
-import com.android.tools.metalava.model.Item
-import com.intellij.psi.PsiAnnotationMethod
-import com.intellij.psi.PsiClass
-import com.intellij.psi.PsiExpression
-import com.intellij.psi.PsiField
-import com.intellij.psi.PsiLiteral
-import com.intellij.psi.impl.JavaConstantExpressionEvaluator
-import org.jetbrains.kotlin.asJava.elements.KtLightNullabilityAnnotation
 import org.jetbrains.uast.UAnnotation
-import org.jetbrains.uast.UBinaryExpression
-import org.jetbrains.uast.UCallExpression
-import org.jetbrains.uast.UClassLiteralExpression
-import org.jetbrains.uast.UElement
-import org.jetbrains.uast.UExpression
-import org.jetbrains.uast.ULiteralExpression
-import org.jetbrains.uast.UQualifiedReferenceExpression
-import org.jetbrains.uast.UReferenceExpression
-import org.jetbrains.uast.util.isArrayInitializer
 
-internal class UAnnotationItem
-private constructor(
-    override val annotationContext: PsiBasedCodebase,
-    val uAnnotation: UAnnotation,
-    originalName: String,
-    qualifiedName: String,
-) :
-    DefaultAnnotationItem(
-        annotationContext = annotationContext,
-        fileLocation = PsiFileLocation.fromPsiElement(uAnnotation.sourcePsi),
-        originalName = originalName,
-        qualifiedName = qualifiedName,
-        attributesGetter = { getAnnotationAttributes(annotationContext, uAnnotation) },
-    ) {
-
-    override fun toSource(target: AnnotationTarget, showDefaultAttrs: Boolean): String {
-        val sb = StringBuilder(60)
-        appendAnnotation(
-            annotationContext,
-            sb,
-            uAnnotation,
-            qualifiedName,
-            target,
-            showDefaultAttrs
-        )
-        return sb.toString()
-    }
-
-    override fun snapshot(targetCodebase: Codebase) = this
-
-    override fun isNonNull(): Boolean {
-        if (uAnnotation.javaPsi is KtLightNullabilityAnnotation<*> && originalName == "") {
-            // Hack/workaround: some UAST annotation nodes do not provide qualified name :=(
-            return true
-        }
-        return super.isNonNull()
+internal object UAnnotationItem {
+
+    private fun getAnnotationAttributes(
+        codebase: PsiBasedCodebase,
+        uAnnotation: UAnnotation,
+    ): List<AnnotationAttribute> {
+        val annotationPsiClass = uAnnotation.resolve()
+        return uAnnotation.attributeValues
+            .map { attribute ->
+                val name = attribute.name ?: ANNOTATION_ATTR_VALUE
+                AnnotationAttribute.createLazyAttribute(
+                    name,
+                    codebase.valueFactory.providerForAnnotationValue(
+                        annotationPsiClass,
+                        name,
+                        attribute.expression
+                    ),
+                )
+            }
+            .toList()
     }
 
-    companion object {
-        private fun getAnnotationAttributes(
-            codebase: PsiBasedCodebase,
-            uAnnotation: UAnnotation
-        ): List<AnnotationAttribute> =
-            uAnnotation.attributeValues
-                .map { attribute ->
-                    DefaultAnnotationAttribute(
-                        attribute.name ?: ANNOTATION_ATTR_VALUE,
-                        createValue(codebase, attribute.expression)
-                    )
-                }
-                .toList()
-
-        fun create(
-            codebase: PsiBasedCodebase,
-            uAnnotation: UAnnotation,
-        ): AnnotationItem? {
-            // If the qualified name is a typealias, convert it to the aliased type because that is
-            // the version that will be present as a class in the codebase.
-            val originalName =
-                uAnnotation.qualifiedName?.let {
-                    (codebase.findTypeAlias(it)?.aliasedType as? PsiClassTypeItem)?.qualifiedName
-                        ?: it
-                }
-                    ?: return null
-            val qualifiedName =
-                codebase.annotationManager.normalizeInputName(originalName) ?: return null
-            return UAnnotationItem(
-                annotationContext = codebase,
-                uAnnotation = uAnnotation,
-                originalName = originalName,
-                qualifiedName = qualifiedName,
-            )
-        }
-
-        private fun getAttributes(
-            annotation: UAnnotation,
-            showDefaultAttrs: Boolean
-        ): List<Pair<String?, UExpression?>> {
-            val annotationClass = annotation.javaPsi?.nameReferenceElement?.resolve() as? PsiClass
-            val list = mutableListOf<Pair<String?, UExpression?>>()
-            if (annotationClass != null && showDefaultAttrs) {
-                for (method in annotationClass.methods) {
-                    if (method !is PsiAnnotationMethod) {
-                        continue
-                    }
-                    list.add(Pair(method.name, annotation.findAttributeValue(method.name)))
-                }
-            } else {
-                for (attr in annotation.attributeValues) {
-                    list.add(Pair(attr.name, attr.expression))
-                }
-            }
-            return list
-        }
-
-        private fun appendAnnotation(
-            codebase: PsiBasedCodebase,
-            sb: StringBuilder,
-            uAnnotation: UAnnotation,
-            originalName: String?,
-            target: AnnotationTarget,
-            showDefaultAttrs: Boolean
-        ) {
-            val qualifiedName =
-                codebase.annotationManager.normalizeOutputName(originalName, target) ?: return
-
-            val attributes = getAttributes(uAnnotation, showDefaultAttrs)
-            if (attributes.isEmpty()) {
-                sb.append("@$qualifiedName")
-                return
-            }
-
-            sb.append("@")
-            sb.append(qualifiedName)
-            sb.append("(")
-            if (
-                attributes.size == 1 &&
-                    (attributes[0].first == null || attributes[0].first == ANNOTATION_ATTR_VALUE)
-            ) {
-                // Special case: omit "value" if it's the only attribute
-                appendValue(codebase, sb, attributes[0].second, target, showDefaultAttrs)
-            } else {
-                var first = true
-                for (attribute in attributes) {
-                    if (first) {
-                        first = false
-                    } else {
-                        sb.append(", ")
-                    }
-                    sb.append(attribute.first ?: ANNOTATION_ATTR_VALUE)
-                    sb.append('=')
-                    appendValue(codebase, sb, attribute.second, target, showDefaultAttrs)
-                }
-            }
-            sb.append(")")
-        }
-
-        private fun appendValue(
-            codebase: PsiBasedCodebase,
-            sb: StringBuilder,
-            value: UExpression?,
-            target: AnnotationTarget,
-            showDefaultAttrs: Boolean
-        ) {
-            // Compute annotation string -- we don't just use value.text here
-            // because that may not use fully qualified names, e.g. the source may say
-            //  @RequiresPermission(Manifest.permission.ACCESS_COARSE_LOCATION)
-            // and we want to compute
-            //
-            // @androidx.annotation.RequiresPermission(android.Manifest.permission.ACCESS_COARSE_LOCATION)
-            when (value) {
-                null -> sb.append("null")
-                is ULiteralExpression -> sb.append(CodePrinter.constantToSource(value.value))
-                is UQualifiedReferenceExpression -> { // the value is a Foo.BAR type of reference.
-                    // expand `Foo` to fully qualified name `com.example.Foo`
-                    appendQualifiedName(codebase, sb, value.receiver as UReferenceExpression)
-                    // append accessor `.`
-                    sb.append(value.accessType.name)
-                    // append `BAR`
-                    sb.append(value.selector.asRenderString())
-                }
-                is UReferenceExpression -> {
-                    // expand Foo to fully qualified name com.example.Foo
-                    appendQualifiedName(codebase, sb, value)
-                }
-                is UBinaryExpression -> {
-                    appendValue(codebase, sb, value.leftOperand, target, showDefaultAttrs)
-                    sb.append(' ')
-                    sb.append(value.operator.text)
-                    sb.append(' ')
-                    appendValue(codebase, sb, value.rightOperand, target, showDefaultAttrs)
-                }
-                is UCallExpression -> {
-                    if (value.isArrayInitializer()) {
-                        sb.append('{')
-                        var first = true
-                        for (initializer in value.valueArguments) {
-                            if (first) {
-                                first = false
-                            } else {
-                                sb.append(", ")
-                            }
-                            appendValue(codebase, sb, initializer, target, showDefaultAttrs)
-                        }
-                        sb.append('}')
-                    } // TODO: support UCallExpression for other cases than array initializers
-                }
-                is UAnnotation -> {
-                    appendAnnotation(
-                        codebase,
-                        sb,
-                        value,
-                        // Normalize the input name of the annotation.
-                        codebase.annotationManager.normalizeInputName(value.qualifiedName!!),
-                        target,
-                        showDefaultAttrs
-                    )
-                }
-                else -> {
-                    val source = getConstantSource(value)
-                    if (source != null) {
-                        sb.append(source)
-                        return
-                    }
-                    sb.append(value.sourcePsi?.text ?: value.asSourceString())
-                }
-            }
-        }
-
-        private fun appendQualifiedName(
-            codebase: PsiBasedCodebase,
-            sb: StringBuilder,
-            value: UReferenceExpression
-        ) {
-            when (val resolved = value.resolve()) {
-                is PsiField -> {
-                    val containing = resolved.containingClass
-                    if (containing != null) {
-                        // If it's a field reference, see if it looks like the field is hidden; if
-                        // so, inline the value
-                        val cls = codebase.findOrCreateClass(containing)
-                        val initializer = resolved.initializer
-                        if (initializer != null) {
-                            val fieldItem = cls.findField(resolved.name)
-                            if (fieldItem == null || fieldItem.isHiddenOrRemoved()) {
-                                // Use the literal value instead
-                                val source = getConstantSource(initializer)
-                                if (source != null) {
-                                    sb.append(source)
-                                    return
-                                }
-                            }
-                        }
-                        containing.qualifiedName?.let { sb.append(it).append('.') }
-                    }
-
-                    sb.append(resolved.name)
-                }
-                is PsiClass -> resolved.qualifiedName?.let { sb.append(it) }
-                else -> {
-                    sb.append(value.sourcePsi?.text ?: value.asSourceString())
-                }
-            }
-        }
-
-        private fun getConstantSource(value: UExpression): String? {
-            val constant = value.evaluate()
-            return CodePrinter.constantToExpression(constant)
-        }
-
-        private fun getConstantSource(value: PsiExpression): String? {
-            val constant = JavaConstantExpressionEvaluator.computeConstantExpression(value, false)
-            return CodePrinter.constantToExpression(constant)
-        }
-    }
-}
-
-private fun createValue(codebase: PsiBasedCodebase, value: UExpression): AnnotationAttributeValue {
-    return if (value.isArrayInitializer()) {
-        val uCallExpression = value as UCallExpression
-        DefaultAnnotationArrayAttributeValue(
-            { getText(uCallExpression) },
-            { uCallExpression.valueArguments.map { createValue(codebase, it) }.toList() }
+    fun create(
+        codebase: PsiBasedCodebase,
+        uAnnotation: UAnnotation,
+    ): AnnotationItem? {
+        // If the qualified name is a typealias, convert it to the aliased type because that is
+        // the version that will be present as a class in the codebase.
+        val originalName =
+            uAnnotation.qualifiedName?.let {
+                (codebase.findTypeAlias(it)?.aliasedType as? PsiClassTypeItem)?.qualifiedName ?: it
+            } ?: return null
+        return AnnotationItem.createAttributesLazily(
+            annotationContext = codebase,
+            fileLocation = PsiFileLocation.fromPsiElement(uAnnotation.sourcePsi),
+            originalName = originalName,
+            attributesGetter = { getAnnotationAttributes(codebase, uAnnotation) },
         )
-    } else {
-        UAnnotationSingleAttributeValue(codebase, value)
     }
 }
-
-internal class UAnnotationSingleAttributeValue(
-    private val codebase: PsiBasedCodebase,
-    private val psiValue: UExpression
-) : DefaultAnnotationSingleAttributeValue({ getText(psiValue) }, { getValue(psiValue) }) {
-
-    companion object {
-        private fun getValue(psiValue: UExpression): Any? {
-            if (psiValue is ULiteralExpression) {
-                val value = psiValue.value
-                if (value != null) {
-                    return value
-                } else if (psiValue.isNull) {
-                    return null
-                }
-            }
-            if (psiValue is PsiLiteral) {
-                return psiValue.value ?: getText(psiValue).removeSurrounding("\"")
-            }
-
-            val value = ConstantEvaluator.evaluate(null, psiValue)
-            if (value != null) {
-                return value
-            }
-
-            if (psiValue is UClassLiteralExpression) {
-                // The value of a class literal expression like String.class or String::class
-                // is the fully qualified name, java.lang.String
-                val type = psiValue.type
-                if (type != null) {
-                    return type.canonicalText
-                }
-            }
-
-            return getText(psiValue).removeSurrounding("\"")
-        }
-    }
-
-    override fun resolve(): Item? {
-        if (psiValue is UReferenceExpression) {
-            when (val resolved = psiValue.resolve()) {
-                is PsiField -> return codebase.findField(resolved)
-                is PsiClass -> return codebase.findOrCreateClass(resolved)
-            }
-        }
-        return null
-    }
-}
-
-private fun getText(element: UElement): String {
-    return element.sourcePsi?.text ?: element.asSourceString()
-}
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/kotlin/KotlinBytecodeApis.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/kotlin/KotlinBytecodeApis.kt
new file mode 100644
index 000000000..a80a3d424
--- /dev/null
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/kotlin/KotlinBytecodeApis.kt
@@ -0,0 +1,488 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.psi.kotlin
+
+import com.android.SdkConstants
+import com.android.tools.lint.helpers.readAllBytes
+import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ConstructorItem
+import com.android.tools.metalava.model.KOTLIN_METADATA
+import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.TargetLanguageSet
+import com.android.tools.metalava.model.VisibilityLevel
+import com.android.tools.metalava.model.item.DefaultClassItem
+import com.android.tools.metalava.model.psi.PsiAnnotationItem
+import com.android.tools.metalava.model.psi.PsiBasedCodebase
+import com.android.tools.metalava.model.psi.PsiCallableItem
+import com.android.tools.metalava.model.psi.PsiConstructorItem
+import com.android.tools.metalava.model.psi.PsiMethodItem
+import com.android.tools.metalava.model.psi.psiParameters
+import com.android.tools.metalava.model.value.IntValue
+import com.android.tools.metalava.model.value.StringValue
+import com.intellij.openapi.project.Project
+import com.intellij.psi.JavaPsiFacade
+import com.intellij.psi.PsiClass
+import com.intellij.psi.PsiMethod
+import com.intellij.psi.PsiModifier
+import com.intellij.psi.search.GlobalSearchScope
+import java.io.File
+import java.util.zip.ZipEntry
+import java.util.zip.ZipFile
+import java.util.zip.ZipOutputStream
+import kotlin.metadata.KmClass
+import kotlin.metadata.KmDeclarationContainer
+import kotlin.metadata.KmProperty
+import kotlin.metadata.Visibility
+import kotlin.metadata.hasAnnotations
+import kotlin.metadata.jvm.JvmMethodSignature
+import kotlin.metadata.jvm.KotlinClassMetadata
+import kotlin.metadata.jvm.Metadata
+import kotlin.metadata.jvm.getterSignature
+import kotlin.metadata.jvm.setterSignature
+import kotlin.metadata.jvm.signature
+import kotlin.metadata.jvm.syntheticMethodForAnnotations
+import kotlin.metadata.visibility
+import org.objectweb.asm.ClassReader
+import org.objectweb.asm.ClassVisitor
+import org.objectweb.asm.ClassWriter
+import org.objectweb.asm.MethodVisitor
+import org.objectweb.asm.Opcodes
+
+/**
+ * Functionality for loading APIs from jar files compiled from Kotlin source code.
+ *
+ * First, the jar file needs to be processed by [rewriteJar] to remove the `ACC_SYNTHETIC` modifier
+ * from methods to allow them to be read by psi, and to track all the qualified names of classes
+ * present in the jar. Then, [loadPsiFromProject] will search for the class names from the jar in a
+ * psi project to add APIs to the [codebase].
+ */
+internal class KotlinBytecodeApis(val codebase: PsiBasedCodebase) {
+    /** Class names to process. Populated by [rewriteJar] and used by [loadPsiFromProject]. */
+    private val qualifiedClassNames = mutableListOf<String>()
+
+    /**
+     * A map from the fully qualified name of a multi-file class facade to the paths of the class
+     * files that make it up. Each class part corresponds to a source file, and metadata for the
+     * entries can only be found in the class part, not the multi-file class facade.
+     */
+    private val multiFileClassParts: MutableMap<String, List<String>> = mutableMapOf()
+
+    /**
+     * Processes the [originalJarFile] to remove the `ACC_SYNTHETIC` modifier from methods. This is
+     * done because psi does not process synthetic members, but they can be important for API
+     * tracking (e.g. methods annotated with [DeprecationLevel.HIDDEN]).
+     *
+     * Also saves the qualified names of all classes in the jar.
+     */
+    fun rewriteJar(originalJarFile: File): File {
+        val newJarFile = kotlin.io.path.createTempFile(suffix = ".jar").toFile()
+        val outputStream = ZipOutputStream(newJarFile.outputStream())
+        ZipFile(originalJarFile).use { jar ->
+            for (entry in jar.entries().iterator()) {
+                val fileName = entry.name
+                if (
+                    !fileName.endsWith(SdkConstants.DOT_CLASS) ||
+                        fileName.endsWith("package-info.class")
+                ) {
+                    // for entries that are not .class files, just write them to the new jar
+                    outputStream.putNextEntry(entry)
+                    outputStream.write(jar.readAllBytes(entry))
+                    continue
+                }
+
+                val qualifiedName =
+                    fileName
+                        .removeSuffix(SdkConstants.DOT_CLASS)
+                        .replace('/', '.')
+                        .replace('$', '.')
+                qualifiedClassNames.add(qualifiedName)
+
+                // Create a reader for the old jar, and a writer for the new.
+                val classReader = ClassReader(jar.getInputStream(entry))
+                val classWriter = ClassWriter(/* flags= */ 0)
+                // Process the class with a visitor that defers to the writer in all cases except
+                // for methods.
+                classReader.accept(
+                    object : ClassVisitor(Opcodes.ASM9, classWriter) {
+                        override fun visitMethod(
+                            access: Int,
+                            name: String,
+                            descriptor: String?,
+                            signature: String?,
+                            exceptions: Array<String>?
+                        ): MethodVisitor {
+                            // Update the access flags of the method
+                            val newAccess =
+                                if (access and Opcodes.ACC_BRIDGE != 0) {
+                                    // If this is a bridge method, leave the accessors as-is, since
+                                    // we don't need to track these (these are generated by the java
+                                    // compiler to handle type erasure).
+                                    access
+                                } else {
+                                    // Otherwise, unset the synthetic flag so this method can be
+                                    // processed by psi
+                                    access and Opcodes.ACC_SYNTHETIC.inv()
+                                }
+                            // Visit the method with the class writer, using the new access flags
+                            return super.visitMethod(
+                                newAccess,
+                                name,
+                                descriptor,
+                                signature,
+                                exceptions
+                            )
+                        }
+                    },
+                    ClassReader.SKIP_CODE
+                )
+                outputStream.putNextEntry(ZipEntry(fileName))
+                outputStream.write(classWriter.toByteArray())
+            }
+        }
+        outputStream.flush()
+        outputStream.close()
+        return newJarFile
+    }
+
+    /**
+     * Uses the [project] to load the psi for all classes previously found by [rewriteJar], and adds
+     * members to the [codebase].
+     *
+     * This will not add any classes to the [codebase], but for any existing classes, it will add
+     * any callables which are not already present in the class item in the codebase.
+     */
+    fun loadPsiFromProject(project: Project) {
+        val facade = JavaPsiFacade.getInstance(project)
+        val scope = GlobalSearchScope.allScope(project)
+
+        for (qualifiedName in qualifiedClassNames) {
+            val psiClass = facade.findClass(qualifiedName, scope) ?: continue
+            val classItem = codebase.findClass(qualifiedName) as? DefaultClassItem ?: continue
+            // Find associated Kotlin metadata for the class. If there isn't any, this wasn't a
+            // Kotlin source class and can be skipped.
+            val metadataContainer = psiClass.getMetadataContainer() ?: continue
+            addMethodsToClass(psiClass, classItem, metadataContainer)
+        }
+
+        // Process all multi-file classes. Each multi-file class is made up of parts from classes
+        // generated from each file of the multi-file class. The class parts have the kotlin
+        // metadata for the class members, while the multi-file class does not.
+        for ((qualifiedName, classParts) in multiFileClassParts) {
+            // Find the multi-file class itself in the codebase.
+            val multiFileClassItem =
+                codebase.findClass(qualifiedName) as? DefaultClassItem ?: continue
+            for (classPartPath in classParts) {
+                // Find the psi and metadata corresponding to this part of the multi-file class.
+                val psiClassPart =
+                    facade.findClass(classPartPath.replace("/", "."), scope) ?: continue
+                val metadataContainer = psiClassPart.getMetadataContainer() ?: continue
+                // Use the class part and metadata to add entries to the multi-file class item.
+                addMethodsToClass(psiClassPart, multiFileClassItem, metadataContainer)
+            }
+        }
+    }
+
+    /** Adds to the [classItem] the methods from the [psiClass] which are not already present. */
+    private fun addMethodsToClass(
+        psiClass: PsiClass,
+        classItem: DefaultClassItem,
+        metadataContainer: KmDeclarationContainer,
+    ) {
+        val classTypeItemFactory = codebase.globalTypeItemFactory.from(classItem)
+        for (psiMethod in psiClass.methods) {
+            // Skip processing certain methods based on name.
+            if (skipTracking(psiMethod.name)) continue
+            // Only process visible APIs. Internal APIs will have the public modifier, which can
+            // be corrected later using the Kotlin metadata.
+            if (
+                !psiMethod.modifierList.hasModifierProperty(PsiModifier.PUBLIC) &&
+                    !psiMethod.modifierList.hasModifierProperty(PsiModifier.PROTECTED)
+            )
+                continue
+
+            // Skip tracking constructors with the kotlin DefaultConstructorMarker. Every Kotlin
+            // source class gets a constructor like this generated from the default constructor.
+            // TODO(b/417740481): decide if it is ever worth tracking these
+            if (
+                psiMethod.isConstructor &&
+                    psiMethod.psiParameters.any {
+                        it.type.canonicalText == "kotlin.jvm.internal.DefaultConstructorMarker"
+                    }
+            )
+                continue
+
+            // Don't re-add methods which are already present: find the items which might have
+            // the same signature of this one, to compare by erased signature.
+            val potentialMatches =
+                erasedSignaturesOfPotentialMatchingCallables(psiMethod, classItem)
+            // Right now, it would be complicated to get the real erased signature of the item
+            // because that involves replacing variable types with their bounds. Get an
+            // approximation by just dropping type arguments, to enable exiting early before
+            // creating a codebase item if there's a definite match.
+            // It would be nice to use the ClassUtil.getAsmMethodSignature helper here, but it
+            // drops type variables completely.
+            val semiErasedSignature =
+                psiMethod.psiParameters.joinToString { it.type.canonicalText.dropTypeArguments() }
+            // Check if there's a signature match (technically, it would be possible to find a
+            // false match here if a type variable that is in semiErasedSignature had the same
+            // name as a primitive type used in one of the potential matches, but that shouldn't
+            // be allowed).
+            if (potentialMatches.any { it == semiErasedSignature }) {
+                continue
+            }
+
+            // Create the item.
+            val callableItem =
+                if (psiMethod.isConstructor) {
+                    PsiConstructorItem.create(
+                        codebase,
+                        classItem,
+                        psiMethod,
+                        classTypeItemFactory,
+                        targetLanguages = TargetLanguageSet.BYTECODE_ONLY,
+                    )
+                } else {
+                    PsiMethodItem.create(
+                            codebase,
+                            classItem,
+                            psiMethod,
+                            classTypeItemFactory,
+                            targetLanguages = TargetLanguageSet.BYTECODE_ONLY,
+                        )
+                        .takeUnless {
+                            // Skip enum synthetic methods since we don't track those.
+                            it.isEnumSyntheticMethod()
+                        }
+                } ?: continue
+
+            // Double check that there isn't already a callable with the same signature. The
+            // previous check didn't replace variable types with their bounds, so now that it is
+            // easy to do that, make sure there isn't a matching signature.
+            if (potentialMatches.isNotEmpty()) {
+                val erasedSignature =
+                    callableItem.parameters().joinToString { it.type().toErasedTypeString() }
+                if (
+                    erasedSignature != semiErasedSignature &&
+                        potentialMatches.any { it == erasedSignature }
+                )
+                    continue
+            }
+
+            // Update the visibility of the item based on metadata, if needed.
+            if (callableItem.isInternal(metadataContainer, psiClass)) {
+                callableItem.mutateModifiers { setVisibilityLevel(VisibilityLevel.INTERNAL) }
+            }
+
+            // Add the constructed callable.
+            when (callableItem) {
+                is ConstructorItem -> classItem.addConstructor(callableItem)
+                is MethodItem -> classItem.addMethod(callableItem)
+            }
+        }
+    }
+
+    /**
+     * Whether an item with the given [methodName] should not be included in API tracking
+     *
+     * Value classes have equals, toString, and hashCode `-impl` methods which we don't track
+     * because they are common to all value classes.
+     *
+     * The `$` is used for mangled names of internal elements (which are not @PublishedApi), and
+     * delegate and lambda generated elements used by the class itself but not external callers, so
+     * they don't need to be tracked.
+     */
+    private fun skipTracking(methodName: String) =
+        methodName == "equals-impl" ||
+            methodName == "equals-impl0" ||
+            methodName == "toString-impl" ||
+            methodName == "hashCode-impl" ||
+            methodName.contains('$')
+
+    /** Removes type arguments (anything between "<" and ">") from the type string. */
+    private fun String.dropTypeArguments(): String =
+        substringBefore("<") + substringAfterLast(">", "")
+
+    /**
+     * Finds callables of the [classItem] that might have the same signature as the [psiMethod]
+     * (those that have the same name and parameter count), and return their erased signatures.
+     */
+    private fun erasedSignaturesOfPotentialMatchingCallables(
+        psiMethod: PsiMethod,
+        classItem: ClassItem
+    ): List<String> {
+        val callables =
+            if (psiMethod.isConstructor) {
+                classItem.constructors()
+            } else {
+                classItem.methods()
+            }
+        return callables
+            .filter { callable ->
+                callable.name() == psiMethod.name &&
+                    callable.parameters().size == psiMethod.parameters.size
+            }
+            .map { callable ->
+                callable.parameters().joinToString { it.type().toErasedTypeString() }
+            }
+    }
+
+    /**
+     * Loads the Kotlin metadata for the class and returns the [KmDeclarationContainer] where
+     * information about the class members is stored.
+     */
+    private fun PsiClass.getMetadataContainer(): KmDeclarationContainer? {
+        // Find a @Metadata annotation on the class, and convert to Kotlin metadata
+        val metadataAnnotation =
+            annotations.singleOrNull { it.qualifiedName == KOTLIN_METADATA } ?: return null
+        val annotationItem = PsiAnnotationItem.create(codebase, metadataAnnotation) ?: return null
+        val metadata = annotationItem.toMetadata()
+
+        // Return the relevant metadata container. Uses `readLenient` instead of `readStrict` as the
+        // only metadata needed is signatures and visibility, which according to the docs should be
+        // safe to do on metadata generated by different compiler versions (`readStrict` errors if
+        // the metadata was generated by a different compiler version).
+        return when (val classMetadata = KotlinClassMetadata.readLenient(metadata)) {
+            is KotlinClassMetadata.Class -> classMetadata.kmClass
+            is KotlinClassMetadata.FileFacade -> classMetadata.kmPackage
+            is KotlinClassMetadata.MultiFileClassPart -> classMetadata.kmPackage
+            is KotlinClassMetadata.MultiFileClassFacade -> {
+                // A multi-file class facade does not have the metadata for the class members. Each
+                // class part corresponding to a source file contains the metadata for the members
+                // from that file. Track what the parts of this multi-file class are, so they can be
+                // processed later.
+                qualifiedName?.let { multiFileClassParts[it] = classMetadata.partClassNames }
+                null
+            }
+            is KotlinClassMetadata.SyntheticClass,
+            is KotlinClassMetadata.Unknown -> null
+        }
+    }
+
+    /** Converts the annotation (assumed to be @kotlin.Metadata) to [Metadata]. */
+    private fun AnnotationItem.toMetadata(): Metadata {
+        // Utilities for getting the necessary attribute values.
+        fun getIntAttribute(name: String): Int? =
+            (findAttribute(name)?.value as? IntValue)?.underlyingValue
+
+        fun getStringAttribute(name: String): String? =
+            (findAttribute(name)?.value as? StringValue)?.underlyingValue
+
+        fun getIntArrayAttribute(name: String): IntArray? =
+            findAttribute(name)
+                ?.value
+                ?.asFlatList()
+                ?.mapNotNull { (it as? IntValue)?.underlyingValue }
+                ?.toIntArray()
+
+        fun AnnotationItem.getStringArrayAttribute(name: String): Array<String>? =
+            findAttribute(name)
+                ?.value
+                ?.asFlatList()
+                ?.mapNotNull { (it as? StringValue)?.underlyingValue }
+                ?.toTypedArray()
+
+        // Find all annotation values.
+        val kind = getIntAttribute("k")
+        val metadataVersion = getIntArrayAttribute("mv")
+        val data1 = getStringArrayAttribute("d1")
+        val data2 = getStringArrayAttribute("d2")
+        val extraString = getStringAttribute("xs")
+        val packageName = getStringAttribute("pn")
+        val extraInt = getIntAttribute("xi")
+
+        return Metadata(kind, metadataVersion, data1, data2, extraString, packageName, extraInt)
+    }
+
+    /** Checks if the item's true visibility is internal based on the metadata from [container]. */
+    private fun PsiCallableItem.isInternal(
+        container: KmDeclarationContainer?,
+        psiClass: PsiClass
+    ): Boolean {
+        if (container == null) return false
+        val expectedDescriptor = internalDesc(voidConstructorTypes = true)
+        val visibility =
+            // For constructors and functions generated from constructor definitions, check if there
+            // is a constructor with the right signature.
+            if (isConstructor() || name() == "constructor-impl") {
+                (container as? KmClass)
+                    ?.constructors
+                    ?.firstOrNull { it.signature?.descriptor == expectedDescriptor }
+                    ?.visibility
+            } else {
+                // Cut off the mangled part of the name, if there is one.
+                // val simpleName = name().substringBefore('-')
+                // Check for a function with the right signature.
+                container.functions
+                    .firstOrNull { it.signature.matches(name(), expectedDescriptor) }
+                    ?.visibility
+                    // No matching function, check if this is a property accessor.
+                    ?: container.properties.firstNotNullOfOrNull {
+                        if (it.getterSignature.matches(name(), expectedDescriptor)) {
+                            // If this property was annotated with @PublishedApi, that won't have
+                            // been propagated to the getter, do so manually.
+                            propagatePublishedAnnotationIfNeeded(it, psiClass)
+                            // A getter always has the same visibility as the property.
+                            it.visibility
+                        } else if (it.setterSignature.matches(name(), expectedDescriptor)) {
+                            // If this property was annotated with @PublishedApi, that won't have
+                            // been propagated to the setter, do so manually.
+                            propagatePublishedAnnotationIfNeeded(it, psiClass)
+                            // A setter's visibility can be different from the property.
+                            it.setter?.visibility
+                        } else {
+                            null
+                        }
+                    }
+            }
+
+        return visibility == Visibility.INTERNAL
+    }
+
+    /** Whether the signature exists and has the [expectedName] and [expectedDescriptor]. */
+    private fun JvmMethodSignature?.matches(
+        expectedName: String,
+        expectedDescriptor: String,
+    ): Boolean {
+        return this != null && expectedName == name && descriptor == expectedDescriptor
+    }
+
+    /**
+     * Checks if the [kmProperty] was annotated in source with the [PublishedApi] annotation, and if
+     * it was, adds the annotation to the callable item.
+     */
+    private fun PsiCallableItem.propagatePublishedAnnotationIfNeeded(
+        kmProperty: KmProperty,
+        psiClass: PsiClass,
+    ) {
+        if (kmProperty.visibility == Visibility.INTERNAL && kmProperty.hasAnnotations) {
+            // The annotations on a property in source end up in bytecode on a synthetic method
+            // generated to track the annotations. Find that method in the psi class.
+            val annotationMethodSignature = kmProperty.syntheticMethodForAnnotations ?: return
+            val annotationMethod =
+                psiClass.methods.singleOrNull { it.name == annotationMethodSignature.name }
+                    ?: return
+            // Check if the method is @PublishedApi, propagate it to the accessor method if so.
+            val publishedAnnotation =
+                annotationMethod.annotations.firstOrNull {
+                    it.qualifiedName == "kotlin.PublishedApi"
+                } ?: return
+            val annotationItem = PsiAnnotationItem.create(codebase, publishedAnnotation)
+            mutateModifiers { addAnnotation(annotationItem) }
+        }
+    }
+}
diff --git a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiCodebasePropertyTest.kt b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiCodebasePropertyTest.kt
index 79d235922..abc7c1a6d 100644
--- a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiCodebasePropertyTest.kt
+++ b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiCodebasePropertyTest.kt
@@ -21,6 +21,7 @@ import com.android.tools.metalava.testing.createAndroidModuleDescription
 import com.android.tools.metalava.testing.createCommonModuleDescription
 import com.android.tools.metalava.testing.createModuleDescription
 import com.android.tools.metalava.testing.createProjectDescription
+import com.android.tools.metalava.testing.defaultJvmPlatforms
 import com.android.tools.metalava.testing.kotlin
 import com.google.common.truth.Truth.assertThat
 import org.junit.Test
@@ -58,8 +59,9 @@ class PsiCodebasePropertyTest : BaseModelTest() {
                     createModuleDescription(
                         moduleName = "main",
                         android = true,
+                        kotlinPlatforms = defaultJvmPlatforms,
                         sourceFiles = arrayOf(source),
-                        dependsOn = emptyList()
+                        dependsOn = emptyList(),
                     )
                 )
         ) {
diff --git a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiFieldItemTest.kt b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiFieldItemTest.kt
index df61c6037..31f447b08 100644
--- a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiFieldItemTest.kt
+++ b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiFieldItemTest.kt
@@ -51,7 +51,7 @@ class PsiFieldItemTest : BaseModelTest() {
         ) {
             val fooClass = codebase.assertClass("test.pkg.Foo")
             val x = fooClass.fields().single()
-            assertNull(x.legacyInitialValue(false))
+            assertNull(x.constantValue)
         }
     }
 
diff --git a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiSourceParserTest.kt b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiSourceParserTest.kt
index d0da46555..5ee5b35a0 100644
--- a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiSourceParserTest.kt
+++ b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiSourceParserTest.kt
@@ -92,6 +92,7 @@ class PsiSourceParserTest : TemporaryFolderOwner, Assertions {
                 classPath = emptyList(),
                 apiPackages = null,
                 projectDescription = null,
+                compiledSourceJar = null,
             )
     }
 
diff --git a/metalava-model-psi/src/test/resources/model-test-suite-baseline.txt b/metalava-model-psi/src/test/resources/model-test-suite-baseline.txt
index c4f1a1f3a..32448431b 100644
--- a/metalava-model-psi/src/test/resources/model-test-suite-baseline.txt
+++ b/metalava-model-psi/src/test/resources/model-test-suite-baseline.txt
@@ -6,9 +6,11 @@ com.android.tools.metalava.model.testsuite.CommonModifierListWriterTest
   modifiers public explicitly final method in final class[java,k1]
   modifiers public explicitly final method in final class[java,k2]
 
-com.android.tools.metalava.model.testsuite.annotationitem.CommonAnnotationItemTest
-  annotation with enum values[java,k1]
-  annotation with enum values[java,k2]
+com.android.tools.metalava.model.testsuite.CommonTargetLanguageTest
+  Test type aliases can only be used from Kotlin[kotlin,k1]
+
+com.android.tools.metalava.model.testsuite.classitem.CommonDataClassTest
+  Test data class copy method visibility with ConsistentCopyVisibility[kotlin,k1]
 
 com.android.tools.metalava.model.testsuite.typealiasitem.CommonTypeAliasItemTest
   accessing type alias from codebase[kotlin,k1]
@@ -40,26 +42,12 @@ com.android.tools.metalava.model.testsuite.typeitem.CommonTypeStringTest
   Type string[java,k2,null annotated parameterized inner type - annotated]
   Type string[java,k2,null annotated parameterized inner type - kotlin nulls]
 
-com.android.tools.metalava.model.testsuite.value.CommonParameterizedAnnotationToSourceValueTest
-  testLegacySource[kotlin,k1,source,class array literal]
-  testLegacySource[kotlin,k1,source,class int array literal]
-  testLegacySource[kotlin,k1,source,class void primitive class]
-  testLegacySource[kotlin,k1,source,class void wrapper class]
-  testLegacySource[kotlin,k1,source,class]
-  testLegacySource[kotlin,k2,source,class array literal]
-  testLegacySource[kotlin,k2,source,class int array literal]
-  testLegacySource[kotlin,k2,source,class void primitive class]
-  testLegacySource[kotlin,k2,source,class void wrapper class]
-  testLegacySource[kotlin,k2,source,class]
+com.android.tools.metalava.model.testsuite.value.CommonParameterizedFieldValueTest
+  testFieldValue[kotlin,k1,source,null - intermediate non-constant expression]
+  testFieldValue[kotlin,k2,source,null - intermediate non-constant expression]
+  testFieldValue[kotlin,k2,source,unsigned int - expression]
 
-com.android.tools.metalava.model.testsuite.value.CommonParameterizedAttributeValueTest
-  testLegacySource[kotlin,k1,source,class array literal]
-  testLegacySource[kotlin,k1,source,class int array literal]
-  testLegacySource[kotlin,k1,source,class void primitive class]
-  testLegacySource[kotlin,k1,source,class void wrapper class]
-  testLegacySource[kotlin,k1,source,class]
-  testLegacySource[kotlin,k2,source,class array literal]
-  testLegacySource[kotlin,k2,source,class int array literal]
-  testLegacySource[kotlin,k2,source,class void primitive class]
-  testLegacySource[kotlin,k2,source,class void wrapper class]
-  testLegacySource[kotlin,k2,source,class]
+com.android.tools.metalava.model.testsuite.value.CommonParameterizedFieldWriteWithSemicolonValueTest
+  testLegacySource[kotlin,k1,source,null - intermediate non-constant expression]
+  testLegacySource[kotlin,k2,source,null - intermediate non-constant expression]
+  testLegacySource[kotlin,k2,source,unsigned int - expression]
diff --git a/metalava-model-snapshot-testing/src/test/resources/model-test-suite-baseline.txt b/metalava-model-snapshot-testing/src/test/resources/model-test-suite-baseline.txt
index c26fcb4a4..eeff417f0 100644
--- a/metalava-model-snapshot-testing/src/test/resources/model-test-suite-baseline.txt
+++ b/metalava-model-snapshot-testing/src/test/resources/model-test-suite-baseline.txt
@@ -35,19 +35,14 @@ com.android.tools.metalava.model.testsuite.CommonModifierListWriterTest
   modifiers public explicitly final method in final class[psi,java,k1]
   modifiers public explicitly final method in final class[psi,java,k2]
 
+com.android.tools.metalava.model.testsuite.CommonTargetLanguageTest
+  Test type aliases can only be used from Kotlin[psi,kotlin,k1]
+
 com.android.tools.metalava.model.testsuite.annotationitem.CommonAnnotationItemTest
-  annotation toSource() with char values[text]
-  annotation toSource() with class values[text]
-  annotation toSource() with compound expression values[text]
-  annotation toSource() with compound expression values[turbine]
-  annotation toSource() with constant literal values[turbine]
-  annotation toSource() with number values[text]
-  annotation with constant literal values[text]
-  annotation with enum values[psi,java,k1]
-  annotation with enum values[psi,java,k2]
-  annotation with infinity values[text]
-  annotation with negative number values[text]
-  annotation with type cast values[text]
+  annotation with unknown field[turbine]
+
+com.android.tools.metalava.model.testsuite.classitem.CommonDataClassTest
+  Test data class copy method visibility with ConsistentCopyVisibility[psi,kotlin,k1]
 
 com.android.tools.metalava.model.testsuite.classitem.CommonDuplicateClassItemTest
   Test duplicate classes[turbine]
@@ -63,10 +58,6 @@ com.android.tools.metalava.model.testsuite.documentation.CommonParameterizedDocu
 com.android.tools.metalava.model.testsuite.fielditem.CommonFieldItemTest
   Test implicit nullability of constant field initialized from @NonNull method[turbine]
 
-com.android.tools.metalava.model.testsuite.fielditem.SourceFieldItemTest
-  test default value of an enum constant field[turbine]
-  test non final field with default value as constant expression[turbine]
-
 com.android.tools.metalava.model.testsuite.methoditem.CommonParameterItemTest
   Test publicName reports correct name when called on binary class - Object#equals[turbine]
   Test publicName reports correct name when called on binary class - ViewGroup#onLayout[turbine]
@@ -143,166 +134,39 @@ com.android.tools.metalava.model.testsuite.typeitem.CommonTypeStringTest
   Type string[psi,java,k2,null annotated parameterized inner type - kotlin nulls]
 
 com.android.tools.metalava.model.testsuite.value.CommonParameterizedAnnotationToSourceValueTest
-  testLegacySource[psi,kotlin,k1,source,class array literal]
-  testLegacySource[psi,kotlin,k1,source,class int array literal]
-  testLegacySource[psi,kotlin,k1,source,class void primitive class]
-  testLegacySource[psi,kotlin,k1,source,class void wrapper class]
-  testLegacySource[psi,kotlin,k1,source,class]
-  testLegacySource[psi,kotlin,k2,source,class array literal]
-  testLegacySource[psi,kotlin,k2,source,class int array literal]
-  testLegacySource[psi,kotlin,k2,source,class void primitive class]
-  testLegacySource[psi,kotlin,k2,source,class void wrapper class]
-  testLegacySource[psi,kotlin,k2,source,class]
-  testLegacySource[text,source,String using constant]
-  testLegacySource[text,source,annotation]
-  testLegacySource[text,source,char escaped]
-  testLegacySource[text,source,char unicode]
-  testLegacySource[text,source,char]
-  testLegacySource[text,source,double NaN]
-  testLegacySource[text,source,double negative infinity]
-  testLegacySource[text,source,double positive infinity]
-  testLegacySource[text,source,double with exponent]
-  testLegacySource[text,source,float NaN]
-  testLegacySource[text,source,float negative infinity]
-  testLegacySource[text,source,float positive infinity]
-  testLegacySource[text,source,float with exponent]
-  testLegacySource[text,source,float with upper F]
-  testLegacySource[text,source,int negative]
-  testLegacySource[text,source,int positive]
-  testLegacySource[text,source,long with lower l]
-  testLegacySource[turbine,jar,annotation]
-  testLegacySource[turbine,jar,double NaN]
-  testLegacySource[turbine,jar,double negative infinity]
-  testLegacySource[turbine,jar,double positive infinity]
-  testLegacySource[turbine,jar,float NaN]
-  testLegacySource[turbine,jar,float negative infinity]
-  testLegacySource[turbine,jar,float positive infinity]
-  testLegacySource[turbine,source,String using constant]
-  testLegacySource[turbine,source,annotation]
-  testLegacySource[turbine,source,double NaN]
-  testLegacySource[turbine,source,double with int]
-  testLegacySource[turbine,source,float NaN]
-  testLegacySource[turbine,source,float with int]
-  testLegacySource[turbine,source,int positive]
-  testLegacySource[turbine,source,long with int]
+  testLegacySource[text,source,byte - cast]
+  testLegacySource[text,source,class literal - array of basic class]
+  testLegacySource[text,source,class literal - array of generic class]
+  testLegacySource[text,source,class literal - basic class]
+  testLegacySource[text,source,class literal - generic class]
+  testLegacySource[text,source,short - cast]
 
 com.android.tools.metalava.model.testsuite.value.CommonParameterizedAttributeDefaultValueTest
-  testLegacySource[text,source,String array]
-  testLegacySource[text,source,String using constant]
-  testLegacySource[text,source,annotation]
-  testLegacySource[text,source,char escaped]
-  testLegacySource[text,source,char unicode]
-  testLegacySource[text,source,char]
-  testLegacySource[text,source,class array literal]
-  testLegacySource[text,source,class void wrapper class]
-  testLegacySource[text,source,class]
-  testLegacySource[text,source,double NaN]
-  testLegacySource[text,source,double negative infinity]
-  testLegacySource[text,source,double positive infinity]
-  testLegacySource[text,source,double with exponent]
-  testLegacySource[text,source,float NaN]
-  testLegacySource[text,source,float negative infinity]
-  testLegacySource[text,source,float positive infinity]
-  testLegacySource[text,source,float with exponent]
-  testLegacySource[text,source,float with upper F]
-  testLegacySource[text,source,int positive]
-  testLegacySource[text,source,long with lower l]
-  testLegacySource[turbine,jar,annotation]
-  testLegacySource[turbine,jar,double NaN]
-  testLegacySource[turbine,jar,double negative infinity]
-  testLegacySource[turbine,jar,double positive infinity]
-  testLegacySource[turbine,jar,float NaN]
-  testLegacySource[turbine,jar,float negative infinity]
-  testLegacySource[turbine,jar,float positive infinity]
-  testLegacySource[turbine,source,annotation]
-  testLegacySource[turbine,source,double with int]
-  testLegacySource[turbine,source,float with int]
-  testLegacySource[turbine,source,long with int]
+  testLegacySource[text,source,byte - cast]
+  testLegacySource[text,source,short - cast]
+  testMethodDefaultValue[text,source,byte - cast]
+  testMethodDefaultValue[text,source,short - cast]
 
 com.android.tools.metalava.model.testsuite.value.CommonParameterizedAttributeValueTest
-  testLegacySource[psi,kotlin,k1,source,class array literal]
-  testLegacySource[psi,kotlin,k1,source,class int array literal]
-  testLegacySource[psi,kotlin,k1,source,class void primitive class]
-  testLegacySource[psi,kotlin,k1,source,class void wrapper class]
-  testLegacySource[psi,kotlin,k1,source,class]
-  testLegacySource[psi,kotlin,k2,source,class array literal]
-  testLegacySource[psi,kotlin,k2,source,class int array literal]
-  testLegacySource[psi,kotlin,k2,source,class void primitive class]
-  testLegacySource[psi,kotlin,k2,source,class void wrapper class]
-  testLegacySource[psi,kotlin,k2,source,class]
-  testLegacySource[text,source,annotation]
-  testLegacySource[text,source,char escaped]
-  testLegacySource[text,source,char unicode]
-  testLegacySource[text,source,char]
-  testLegacySource[text,source,enum]
-  testLegacySource[turbine,jar,annotation]
-  testLegacySource[turbine,jar,char unicode]
-  testLegacySource[turbine,jar,double NaN]
-  testLegacySource[turbine,jar,double negative infinity]
-  testLegacySource[turbine,jar,double positive infinity]
-  testLegacySource[turbine,jar,float NaN]
-  testLegacySource[turbine,jar,float negative infinity]
-  testLegacySource[turbine,jar,float positive infinity]
-  testLegacySource[turbine,jar,int negative]
-  testLegacySource[turbine,source,String using constant]
-  testLegacySource[turbine,source,annotation]
-  testLegacySource[turbine,source,double NaN]
-  testLegacySource[turbine,source,double negative infinity]
-  testLegacySource[turbine,source,double positive infinity]
-  testLegacySource[turbine,source,double with exponent]
-  testLegacySource[turbine,source,double with int]
-  testLegacySource[turbine,source,enum]
-  testLegacySource[turbine,source,float NaN]
-  testLegacySource[turbine,source,float negative infinity]
-  testLegacySource[turbine,source,float positive infinity]
-  testLegacySource[turbine,source,float with exponent]
-  testLegacySource[turbine,source,float with int]
-  testLegacySource[turbine,source,float with upper F]
-  testLegacySource[turbine,source,int negative]
-  testLegacySource[turbine,source,int positive]
-  testLegacySource[turbine,source,long with int]
-  testLegacySource[turbine,source,long with lower l]
+  testAttributeValue[text,source,byte - cast]
+  testAttributeValue[text,source,short - cast]
 
 com.android.tools.metalava.model.testsuite.value.CommonParameterizedFieldValueTest
-  testLegacySource[text,source,String using constant]
-  testLegacySource[text,source,class array literal]
-  testLegacySource[text,source,class int array literal]
-  testLegacySource[text,source,class void primitive class]
-  testLegacySource[text,source,class void wrapper class]
-  testLegacySource[text,source,class]
-  testLegacySource[text,source,double NaN]
-  testLegacySource[text,source,double negative infinity]
-  testLegacySource[text,source,double positive infinity]
-  testLegacySource[text,source,enum]
-  testLegacySource[text,source,float NaN]
-  testLegacySource[text,source,float negative infinity]
-  testLegacySource[text,source,float positive infinity]
-  testLegacySource[text,source,long with int]
-  testLegacySource[turbine,jar,double NaN]
-  testLegacySource[turbine,jar,double negative infinity]
-  testLegacySource[turbine,jar,double positive infinity]
-  testLegacySource[turbine,jar,float NaN]
-  testLegacySource[turbine,jar,float negative infinity]
-  testLegacySource[turbine,jar,float positive infinity]
+  testFieldValue[psi,kotlin,k1,source,null - intermediate non-constant expression]
+  testFieldValue[psi,kotlin,k2,source,null - intermediate non-constant expression]
+  testFieldValue[psi,kotlin,k2,source,unsigned int - expression]
+  testFieldValue[text,source,byte - cast]
+  testFieldValue[text,source,short - cast]
 
 com.android.tools.metalava.model.testsuite.value.CommonParameterizedFieldWriteWithSemicolonValueTest
-  testLegacySource[text,source,String using constant]
-  testLegacySource[text,source,class array literal]
-  testLegacySource[text,source,class int array literal]
-  testLegacySource[text,source,class void primitive class]
-  testLegacySource[text,source,class void wrapper class]
-  testLegacySource[text,source,class]
-  testLegacySource[text,source,double NaN]
-  testLegacySource[text,source,double negative infinity]
-  testLegacySource[text,source,double positive infinity]
-  testLegacySource[text,source,enum]
-  testLegacySource[text,source,float NaN]
-  testLegacySource[text,source,float negative infinity]
-  testLegacySource[text,source,float positive infinity]
-  testLegacySource[text,source,long with int]
-  testLegacySource[turbine,jar,double NaN]
-  testLegacySource[turbine,jar,double negative infinity]
-  testLegacySource[turbine,jar,double positive infinity]
-  testLegacySource[turbine,jar,float NaN]
-  testLegacySource[turbine,jar,float negative infinity]
-  testLegacySource[turbine,jar,float positive infinity]
+  testLegacySource[psi,kotlin,k1,source,null - intermediate non-constant expression]
+  testLegacySource[psi,kotlin,k2,source,null - intermediate non-constant expression]
+  testLegacySource[psi,kotlin,k2,source,unsigned int - expression]
+  testLegacySource[text,source,byte - cast]
+  testLegacySource[text,source,short - cast]
+
+com.android.tools.metalava.model.testsuite.value.ParameterizedValueParserTest
+  Test parse[text,byte - cast,annotation_to_source,kotlin,source]
+  Test parse[text,byte - cast,signatureExpression,jar]
+  Test parse[text,short - cast,annotation_to_source,kotlin,jar]
+  Test parse[text,short - cast,signatureExpression,jar]
diff --git a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceParser.kt b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceParser.kt
index 564a0379e..a617845a6 100644
--- a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceParser.kt
+++ b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceParser.kt
@@ -43,6 +43,8 @@ interface SourceParser {
      *   [Codebase.getTopLevelClassesFromSource] list.
      * @param projectDescription Lint project model that can describe project structures in detail.
      *   Only supported by the PSI model.
+     * @param compiledSourceJar A jar file containing the compiled version of [sourceSet]. Used to
+     *   add the compiled JVM forms of Kotlin source APIs. Only supported by the PSI model.
      */
     fun parseSources(
         sourceSet: SourceSet,
@@ -50,6 +52,7 @@ interface SourceParser {
         classPath: List<File>,
         apiPackages: PackageFilter?,
         projectDescription: File?,
+        compiledSourceJar: File?,
     ): Codebase
 
     /**
diff --git a/metalava-model-source/src/testFixtures/java/com/android/tools/metalava/model/source/SourceModelSuiteRunner.kt b/metalava-model-source/src/testFixtures/java/com/android/tools/metalava/model/source/SourceModelSuiteRunner.kt
index 4808548c2..182dbcb70 100644
--- a/metalava-model-source/src/testFixtures/java/com/android/tools/metalava/model/source/SourceModelSuiteRunner.kt
+++ b/metalava-model-source/src/testFixtures/java/com/android/tools/metalava/model/source/SourceModelSuiteRunner.kt
@@ -48,6 +48,13 @@ class SourceModelSuiteRunner(private val sourceModelProvider: SourceModelProvide
         inputs: ModelSuiteRunner.TestInputs,
         test: (Codebase) -> Unit
     ) {
+        // Skip tests that require using compiled sources if the provider does not support it
+        if (
+            inputs.compiledSourceJar != null &&
+                !sourceModelProvider.capabilities.contains(Capability.JAR_WITH_SOURCES)
+        )
+            return
+
         sourceModelProvider.createEnvironmentManager(forTesting = true).use { environmentManager ->
             val classPath = buildList {
                 add(getAndroidJar())
@@ -87,6 +94,7 @@ class SourceModelSuiteRunner(private val sourceModelProvider: SourceModelProvide
             classPath = classPath,
             apiPackages = testFixture.apiPackages,
             projectDescription = inputs.projectDescription,
+            compiledSourceJar = inputs.compiledSourceJar?.createFile(inputs.mainSourceDir.dir)
         )
     }
 
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BaseModelTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BaseModelTest.kt
index b9e615f65..afcf2c84d 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BaseModelTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BaseModelTest.kt
@@ -211,6 +211,7 @@ abstract class BaseModelTest() :
     private fun createCodebaseFromInputSetAndRun(
         inputSets: Array<out InputSet>,
         projectDescription: TestFile?,
+        compiledSourceJar: TestFile?,
         testFixture: TestFixture,
         test: CodebaseContext.() -> Unit,
     ) {
@@ -229,6 +230,7 @@ abstract class BaseModelTest() :
                     additionalMainSourceDir = additionalSourceDir,
                     testFixture = testFixture,
                     projectDescription = projectDescriptionFile,
+                    compiledSourceJar = compiledSourceJar,
                 )
             runner.createCodebaseAndRun(inputs) { codebase ->
                 val context =
@@ -286,12 +288,14 @@ abstract class BaseModelTest() :
     fun runCodebaseTest(
         vararg sources: InputSet,
         projectDescription: TestFile? = null,
+        compiledSourceJar: TestFile? = null,
         testFixture: TestFixture = TestFixture(),
         test: CodebaseContext.() -> Unit,
     ) {
         createCodebaseFromInputSetAndRun(
             inputSets = sources,
             projectDescription = projectDescription,
+            compiledSourceJar = compiledSourceJar,
             testFixture = testFixture,
             test = test,
         )
@@ -327,12 +331,14 @@ abstract class BaseModelTest() :
     fun runSourceCodebaseTest(
         vararg sources: InputSet,
         projectDescription: TestFile? = null,
+        compiledSourceJar: TestFile? = null,
         testFixture: TestFixture = TestFixture(),
         test: CodebaseContext.() -> Unit,
     ) {
         createCodebaseFromInputSetAndRun(
             inputSets = sources,
             projectDescription = projectDescription,
+            compiledSourceJar = compiledSourceJar,
             testFixture = testFixture,
             test = test,
         )
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BootstrapSourceModelProviderTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BootstrapSourceModelProviderTest.kt
index 6e42c0786..1caf04a52 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BootstrapSourceModelProviderTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BootstrapSourceModelProviderTest.kt
@@ -16,12 +16,19 @@
 
 package com.android.tools.metalava.model.testsuite
 
+import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
 import com.android.tools.metalava.model.AnnotationRetention
 import com.android.tools.metalava.model.ClassTypeItem
-import com.android.tools.metalava.model.DefaultAnnotationSingleAttributeValue
 import com.android.tools.metalava.model.PrimitiveTypeItem
 import com.android.tools.metalava.model.VariableTypeItem
 import com.android.tools.metalava.model.noOpAnnotationManager
+import com.android.tools.metalava.model.testing.classTypeItem
+import com.android.tools.metalava.model.testing.value.annotationItem
+import com.android.tools.metalava.model.testing.value.arrayValue
+import com.android.tools.metalava.model.testing.value.arrayValueFromAny
+import com.android.tools.metalava.model.testing.value.classObjectValue
+import com.android.tools.metalava.model.testing.value.fieldReferenceValue
+import com.android.tools.metalava.model.value.asInt
 import com.android.tools.metalava.testing.java
 import com.google.common.truth.Truth.assertThat
 import kotlin.test.assertEquals
@@ -243,9 +250,11 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
                         }
                     """
                 ),
-                java("""
+                java(
+                    """
                         package test;
-                     """),
+                    """
+                ),
             ),
         ) {
             val packageItem = codebase.assertPackage("test.pkg")
@@ -469,31 +478,42 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
 
             assertEquals(3, customAnno1.attributes.count())
             assertEquals(false, customAnno1.isRetention())
-            assertEquals(
-                true,
-                listOf("child1", "child2").toTypedArray() contentEquals
-                    custAnno1Attr1.legacyValue.value() as Array<*>
-            )
-            assertEquals(5, custAnno1Attr2.legacyValue.value())
-            assertEquals("test.SimpleClass", custAnno1Attr3.legacyValue.value())
+            assertEquals(arrayValueFromAny("child1", "child2"), custAnno1Attr1.value)
+            assertEquals(5, custAnno1Attr2.value.asInt())
+            assertEquals(classObjectValue(classTypeItem("test.SimpleClass")), custAnno1Attr3.value)
             assertEquals(annoClassItem1, customAnno1.resolve())
             assertEquals(true, retAnno.isRetention())
-            assertEquals(AnnotationRetention.RUNTIME, annoClassItem1.getRetention())
+            assertEquals(AnnotationRetention.RUNTIME, annoClassItem1.annotationClass.retention)
 
             assertEquals(annoClassItem2, customAnno2.resolve())
-            assertEquals(12, custAnno2Attr1.legacyValue.value())
+            assertEquals(12, custAnno2Attr1.value.asInt())
 
-            assertEquals("@test.Nullable", nullAnno.toSource())
+            assertEquals(annotationItem("test.Nullable"), nullAnno)
 
             assertEquals(
-                "@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)",
-                retAnno.toSource()
+                annotationItem(
+                    "java.lang.annotation.Retention",
+                    ANNOTATION_ATTR_VALUE to
+                        fieldReferenceValue("java.lang.annotation.RetentionPolicy", "RUNTIME"),
+                ),
+                retAnno
             )
             assertEquals(
-                "@java.lang.annotation.Target(java.lang.annotation.ElementType.FIELD)",
-                tarAnno.toSource()
+                annotationItem(
+                    "java.lang.annotation.Target",
+                    ANNOTATION_ATTR_VALUE to
+                        arrayValue(
+                            fieldReferenceValue("java.lang.annotation.ElementType", "FIELD"),
+                        ),
+                ),
+                tarAnno
+            )
+            assertEquals(
+                arrayValue(
+                    fieldReferenceValue("java.lang.annotation.ElementType", "FIELD"),
+                ),
+                tarAnnoAttr1.value
             )
-            assertEquals(true, tarAnnoAttr1.legacyValue is DefaultAnnotationSingleAttributeValue)
         }
     }
 
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonApiVariantSelectorsTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonApiVariantSelectorsTest.kt
index 411517084..6a816cac0 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonApiVariantSelectorsTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonApiVariantSelectorsTest.kt
@@ -371,9 +371,11 @@ class CommonApiVariantSelectorsTest : BaseModelTest() {
     fun `Test accessible`() {
         runCodebaseTest(
             inputSet(
-                java("""
+                java(
+                    """
                         package test.pkg;
-                    """),
+                    """
+                ),
                 java(
                     """
                         package test.pkg;
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonModelTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonModelTest.kt
index 83c541244..cc777160e 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonModelTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonModelTest.kt
@@ -33,9 +33,11 @@ class CommonModelTest : BaseModelTest() {
     @Test
     fun `empty file`() {
         runCodebaseTest(
-            signature("""
+            signature(
+                """
                     // Signature format: 2.0
-                """),
+                """
+            ),
             java(""),
         ) {
             assertNotNull(codebase)
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonModifierListTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonModifierListTest.kt
index 9cfcd5366..d68f6277c 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonModifierListTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonModifierListTest.kt
@@ -16,8 +16,8 @@
 
 package com.android.tools.metalava.model.testsuite
 
+import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.DefaultAnnotationItem
 import com.android.tools.metalava.model.JAVA_LANG_DEPRECATED
 import com.android.tools.metalava.model.ModifierList
 import com.android.tools.metalava.model.MutableModifierList
@@ -61,8 +61,7 @@ class CommonModifierListTest : BaseModelTest() {
     @Test
     fun `test equals() of empty modifiers`() {
         runWithCodebase {
-            val annotation =
-                DefaultAnnotationItem.create(codebase, JAVA_LANG_DEPRECATED, emptyList())!!
+            val annotation = codebase.createAnnotationFromAttributes(JAVA_LANG_DEPRECATED)!!
 
             // Create an empty set of modifiers
             val modifiers = createMutableModifiers(VisibilityLevel.PUBLIC)
@@ -102,7 +101,11 @@ class CommonModifierListTest : BaseModelTest() {
     fun `test toString()`() {
         runWithCodebase {
             val annotation =
-                DefaultAnnotationItem.create(codebase, FileLocation.UNKNOWN, JAVA_LANG_DEPRECATED) {
+                AnnotationItem.createAttributesLazily(
+                    codebase,
+                    FileLocation.UNKNOWN,
+                    JAVA_LANG_DEPRECATED
+                ) {
                     emptyList()
                 }!!
             val modifiers =
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonTargetLanguageTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonTargetLanguageTest.kt
new file mode 100644
index 000000000..7caf42388
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonTargetLanguageTest.kt
@@ -0,0 +1,1279 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite
+
+import com.android.tools.lint.checks.infrastructure.TestFiles.base64gzip
+import com.android.tools.metalava.model.PrimitiveTypeItem
+import com.android.tools.metalava.model.TargetLanguage
+import com.android.tools.metalava.model.VisibilityLevel
+import com.android.tools.metalava.testing.generateBase64gzipFromKotlin
+import com.android.tools.metalava.testing.java
+import com.android.tools.metalava.testing.kotlin
+import com.google.common.truth.Truth.assertThat
+import org.junit.Test
+
+/**
+ * Tests the target languages of items.
+ *
+ * To generate a jar file from Kotlin source files, see [generateBase64gzipFromKotlin]. The output
+ * can be used with [base64gzip] in tests.
+ *
+ * Most of the tests below do not have signature file cases because they are mainly supposed to test
+ * how Kotlin language features translate to target languages. Parsing of target languages is tested
+ * in the ApiFileTest in the metalava-model-text module.
+ */
+class CommonTargetLanguageTest : BaseModelTest() {
+    @Test
+    fun `Test regular items which can be used from any language`() {
+        runCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+                    public class FooClass {
+                        public void fooMethod() {}
+                        public int fooField = 0;
+                    }
+                """
+            ),
+            kotlin(
+                """
+                    package test.pkg
+                    class FooClass {
+                        fun fooMethod() = Unit
+                        companion object {
+                            @JvmField
+                            val fooField: Int = 0
+                        }
+                    }
+                """
+            ),
+            signature(
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public class FooClass {
+                        ctor public FooClass();
+                        method public void fooMethod();
+                        field public int fooField;
+                      }
+                    }
+                """
+            )
+        ) {
+            val cls = codebase.assertClass("test.pkg.FooClass")
+            val items =
+                listOf(
+                    codebase.assertPackage("test.pkg"),
+                    cls,
+                    cls.assertConstructor(""),
+                    cls.assertMethod("fooMethod", ""),
+                    cls.assertField("fooField"),
+                )
+
+            for (item in items) {
+                assertThat(item.targetLanguages)
+                    .containsExactly(
+                        TargetLanguage.JAVA,
+                        TargetLanguage.KOTLIN,
+                        TargetLanguage.BYTECODE,
+                    )
+            }
+        }
+    }
+
+    @Test
+    fun `Test properties can only be used from Kotlin`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    class FooClass {
+                        val fooProperty = 0
+                    }
+                """
+            ),
+            signature(
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public class FooClass {
+                        property public int fooProperty;
+                      }
+                    }
+                """
+            )
+        ) {
+            val prop = codebase.assertClass("test.pkg.FooClass").assertProperty("fooProperty")
+            assertThat(prop.targetLanguages).containsExactly(TargetLanguage.KOTLIN)
+        }
+    }
+
+    @Test
+    fun `Test type aliases can only be used from Kotlin`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    typealias Foo = String
+                """
+            ),
+            signature(
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public typealias Foo = String;
+                    }
+                """
+            ),
+        ) {
+            val alias = codebase.assertTypeAlias("test.pkg.Foo")
+            assertThat(alias.targetLanguages).containsExactly(TargetLanguage.KOTLIN)
+        }
+    }
+
+    @Test
+    fun `Test value class constructor and boxing methods`() {
+        runCodebaseTest(
+            inputSet(
+                kotlin(
+                    """
+                        package test.pkg
+                        @JvmInline
+                        value class IntValue(val v: Int)
+                    """
+                )
+            ),
+            // Compiled from the Kotlin source file above with [generateBase64gzipFromKotlin]
+            compiledSourceJar =
+                base64gzip(
+                    "test.jar",
+                    // kotlinc version info: kotlinc-jvm 1.9.23 (JRE 17.0.6+10-b802.1)
+                    "" +
+                        "H4sIAAAAAAAA/wvwZmYRYeDg4GBgYFBkQAYiDCwMvq4hjrqefm76vo5+nm6u" +
+                        "wSF6vm7/TjEwfPY9c9rHW1fvIq+3rta5M+c3BxlcMX7wtEjPy1fH0/di6aot" +
+                        "QR+8dAu1vM6c0Q77cE7/5Mkzj58+esrEEODNzrFeWHO9JdACcyAOwGm9OBCX" +
+                        "pBaX6Bdkp+t75pWEJeaUpuol5yQWF9eG3A2WDhX5f3f2+rNpjbMvBG1a8M35" +
+                        "dku/2tGo1SJLFmztXhi6IvDUZaGyQ06bOm/6Luvf8zL+QbO+1a8H3PxWwY0b" +
+                        "jfkeza6f/LjiXdpkA8XHPkX252yfl5/7Obf42/v6+v/MB2JzDFVsT38t+vq3" +
+                        "6FzBnkWRmVGGBmwb07ediTlacmrn8tvVYSe7FY8I6EXHTVScclKKZ41rvbMz" +
+                        "j5eMTGHVt7Lc6YlbChiL5yWeWJ1bwXtb8/ytq1WtD4uOnRCriruVv6R8afy2" +
+                        "O1u0rcOU2wTbXjDf3rjX1b5lUZtKkBaLm6SQrP/Ma01Np5dkXns9bfNhg9k7" +
+                        "Xzxd9PjAyT1t2hLTZ2S2nXQUnBc+Z0LX5KDCp/9F46d35RtoyPJJ6KWypax/" +
+                        "KLXO+660y7KbGs9NeRIjVMvyhRp3L9u9O+j2RiamwyJyUxVvOivyrdmUktUV" +
+                        "U7rF9IzC6iSpzVJGn45MVN63Zv2stKO8C44ZuS3c/+Dzzec8WZdvrtv7YavJ" +
+                        "nt4VW/adFlhZuTusWbH0YteMfOfTXPxMVwvYi4We/y3jchVNjHQMXGW57nrG" +
+                        "tD1RyhzeL398Uz7Dl6F9k4lf5YYz29sYr8ouw2QJI9a4/crTLQ9pvLm+p+vt" +
+                        "k29RV+9krc6yKJm4duYbmzWR83YmV6mdrNgqukgysajzNOuVt79V6hNPS1s+" +
+                        "sGb5c/nlwdKp/cVTuy8zT62L0dAKV9qintF/yc7HOvzcvjgpe9sZjyu32Uzq" +
+                        "4lr3uebFm+MZEZzdJ1bpiew6/lxk4auHhdPS+///2vZ3lsCtVQLOQbNTzkzn" +
+                        "ndwqoKwiHBsZtOTa5NiQVqWLh71CjpzblxjT5vXy8Z0pd+5976i9KcejzJr0" +
+                        "0HPzrlzTeTNvi3pP2xpmpO26OfF0tYLMrQ9nLv2bFcn/7pXb2psakf05lZ7r" +
+                        "zWXPr4tyvb315deFj6/YXN68clFIrh/rtHvBn4Id1SO3cCxS+Tknz9JT5+3E" +
+                        "ldMD+F8eCFxi+orb+cch8w+iExYIhzqfc0n4o5d5evsX7Y6zyTFevbKO1/s/" +
+                        "zDoh9/CV4L0/R7/fYfZ8rGvPpqauy7BT0mXBCQ6/gtX33V5aLfvJmZNXsuia" +
+                        "f8HvDecVLpUaXfbdfN5z3/1lz1uOKW+o9Lp5Mu3y8v8s//kmXnj4RfOH4L3I" +
+                        "C+r7p18vmL1eP7O38fj/gwXSRT0tKWItiv7fO7QkD9TuEW84vctj7Q6ejF8s" +
+                        "n/d23Hr2UUGp8tNZ1umXxWbosz17dcVQbJlaXfOv1wdubd14RW/aK3NG5TNH" +
+                        "9WaGM+ftuHeeK397j8djZh3WW9s5IvcdjW/Mf3U84t36cBsDr1P6YfV7rWKP" +
+                        "sZWESWn/2KC/v8XuI3PSw/mCfF9P9Anc9H6+0+vB4oZXLHI/fxbm/Hp1/sOc" +
+                        "b7FWtT6/k41MtwkYbch6IMzMuuaioD/Pqq/LoxP07A7/EnOLzdAziznyp/Si" +
+                        "6zXXI65XjtbGF/U/O3V0TrekuKT49ZqHE7of/geXOaue8lfrszAw3GbHV+ZI" +
+                        "AzG8yMtNzMzTy84vycnMi8/NTynNSU1OSEhIA2KWJD82jYCkC0kMYLO/Ku3Z" +
+                        "KwzUKQEuzxiZRBgQpiOXdaACFRXgKl7RTUF2vTiKCfW4S0l0Q5CdKY1iyGcW" +
+                        "vN4O8GZlAyljBsIrQNqfFcQDAH2x79Q5BgAA"
+                ),
+        ) {
+            val intValue = codebase.assertClass("test.pkg.IntValue")
+
+            val ctorImpl = intValue.assertMethod("constructor-impl", "int")
+            ctorImpl.returnType().assertPrimitiveTypeItem {
+                assertThat(kind).isEqualTo(PrimitiveTypeItem.Primitive.INT)
+            }
+            assertThat(ctorImpl.targetLanguages).containsExactly(TargetLanguage.BYTECODE)
+            assertThat(ctorImpl.modifiers.getVisibilityLevel()).isEqualTo(VisibilityLevel.PUBLIC)
+            assertThat(ctorImpl.modifiers.isStatic()).isTrue()
+
+            val boxImpl = intValue.assertMethod("box-impl", "int")
+            boxImpl.returnType().assertClassTypeItem {
+                assertThat(qualifiedName).isEqualTo("test.pkg.IntValue")
+            }
+            assertThat(boxImpl.targetLanguages).containsExactly(TargetLanguage.BYTECODE)
+            assertThat(boxImpl.modifiers.getVisibilityLevel()).isEqualTo(VisibilityLevel.PUBLIC)
+            assertThat(boxImpl.modifiers.isStatic()).isTrue()
+
+            val unboxImpl = intValue.assertMethod("unbox-impl", "")
+            unboxImpl.returnType().assertPrimitiveTypeItem {
+                assertThat(kind).isEqualTo(PrimitiveTypeItem.Primitive.INT)
+            }
+            assertThat(unboxImpl.targetLanguages).containsExactly(TargetLanguage.BYTECODE)
+            assertThat(unboxImpl.modifiers.getVisibilityLevel()).isEqualTo(VisibilityLevel.PUBLIC)
+            assertThat(unboxImpl.modifiers.isStatic()).isFalse()
+
+            assertThat(intValue.methods().map { it.name() })
+                .containsExactly(
+                    "constructor-impl",
+                    "box-impl",
+                    "unbox-impl",
+                    "getV",
+                    "toString",
+                    "hashCode",
+                    "equals"
+                )
+
+            // TODO(b/407735992): constructor itself should be Kotlin only
+            intValue.assertConstructor("int")
+        }
+    }
+
+    @Test
+    fun `Test function using value class parameter`() {
+        runCodebaseTest(
+            inputSet(
+                kotlin(
+                    """
+                        package test.pkg
+                        @JvmInline
+                        value class IntValue(val v: Int)
+                        class Foo {
+                            fun usesIntValue(iv: IntValue) = Unit
+                        }
+                    """
+                ),
+            ),
+            // Compiled from the Kotlin source file above with [generateBase64gzipFromKotlin]
+            compiledSourceJar =
+                base64gzip(
+                    "test.jar",
+                    // kotlinc version info: kotlinc-jvm 1.9.23 (JRE 17.0.6+10-b802.1)
+                    "" +
+                        "H4sIAAAAAAAA/31VeTQbWhpPJZZ6sce+1DaqVILWGKqMl8aTROy11RZ7NMRe" +
+                        "2qJqLfVC7YLBqNZObVVLUXtijdKILc+orTytWkuNds6Z0Z5p7z2/P+459/t9" +
+                        "9/vO734/YzQQBAGwsbEBAAApwOkFAYAAGIS5rhLSUA+G0TVE6iHMzKEYvc8D" +
+                        "AMAWhkI2QCtBRznQSgpDlOFaU+XxS/OLflAU5iISMxpYWme6iVLyVUBRKIoW" +
+                        "m0Ow/n7KwuIfi0wAYzQrWxXfhSqNkwTqJzD+YXrBEwS4+gfAfG66w5DeARZY" +
+                        "fKAr1BmP9fcPNZ8xE70OOZ4hVQ26RZBGTJ/l78DpUUS5bpsySFF+fULB9acm" +
+                        "A1TeoM5fnz2gYYqJLSsO85EwzYP5X7g0zSJqLnH+QQpPWQjecEtRllow8NMZ" +
+                        "urp0a2g/13/nz/DwY2C7HV5F9ip522/7yG/Ip6XQGmejosxS495Ase0OGGh6" +
+                        "Qr9j0Z8g1cUNvWGfLJXaLwIuR4TD4WCUmJjv7Z0grwxsnc8Z/zxsX5lXMAf9" +
+                        "wvDU69vRDL+ePoHb9lOEoluPHRqm6xSvWMjE8MQsA+k1rQidqMIYWVMFkJ4w" +
+                        "r7hR1sT9++Qi3MRaeu0rZVLT8mLhQnt/S4yiUEYmLqZflyfPMicpPsXUd/GY" +
+                        "3yEjnqAsL84pBHVlcaliiFSiZ0SvFdPkl9TAWKu/BBF4I5qLm5tN6TVMTK8g" +
+                        "EmlSNLgUZ/kzF89428A6NYpkmZNIrYjqh65kmbbyqmy3bo78HlW9gpfzW7Ql" +
+                        "sCeVVtm6WX+5JfFpXRuZuySk2SJSKnA0PpMAJ7NzMb32YfXnXToKYkfwY611" +
+                        "TUo1Kic90ltsZNjQK3s7MhROD0UaE5fsGzjLui0qJF7FWUiV2f6lTIZGp/y7" +
+                        "yZb49X/t2Lye9izz/FtAckXWO61y67wm59ty/cH1/IXCWL8HZObx9U+y4Viy" +
+                        "qMb8FdAhdaUjMI3on5ZABaaF2corWErXnfcgjmkbXLEcarMX0bmauRDSoPUo" +
+                        "nr1y6+7yu14Pq7MJfaVQyIveJUjBKsM33Z14fNBwlM09VcoNNyW5UDI4UqK5" +
+                        "ZWT57KxNiyZS7MyjpUdfocy7htqwtjGolYXp1OnZ3bhQmgRYhtmJgax94aWW" +
+                        "l0XnR6fXW6gqImqx5DuSYlOblLHP2dZcG6t6FTR5ayI+BFmlLj5caYOg169s" +
+                        "FyyMa1FrSwrNvQyZ02fNPpjpnreuYyuU3c/x1kBeXE8uyTDmWmk3KVJb/QW+" +
+                        "16m+yZ+Uz3cdPnTN8RCKIzd+VIwbdLZFJYrrThI3s/skGKs8s4fdu9NA5IKS" +
+                        "DovceSVAk/C1/D42Q5+yOb0VzeL9s3jvgMIJI59P1cOSY4GqVEztMLJtrngp" +
+                        "qkemOgRF63ejPjkGHXMmjzA+XtjjmbUeOf8yY9KHVAXDJUb0Hnf4iPo9jHIR" +
+                        "iJIy2o1TEG4PbRG8R36hX/Ec7HEA2mqNm3r7XlI65MMgcwZVIBPG8nZ1XEWg" +
+                        "WC4s8mCtfaq+Zhyavqp+RobSDc2yBHo/nx1mJzQ+1F8AXmSeamSzbut2iCCs" +
+                        "9lptVFlqKaMGYBbhrZp2PSwBFiKKe9Wwl1Ha74FOjH/wcG73/c5NQy81oeb/" +
+                        "eW8VJLG/74s/WB3ezNmx0ww1+OSsqtbArVrtOc8HZC4f5TECl24/ueEI1X51" +
+                        "IKBn5wH9q23XYeAoYgLRhRjvDnXwI74d6M5JEBYUFpy8y0hKYBx/nTmli1x3" +
+                        "YCAAgM76s5nDe3rm6BEI/xk3dsYYAvXv3KHNn+MWiiqoAvrAVKK9jayPSMfZ" +
+                        "KJB+8kMm/XvTcENSl2ejLz7VLlZM5vPZQ6ChJKc8u3oYxGnCCxHNdYkw26Ke" +
+                        "R5sLDzsEbXLfAQfmyouHCZ2LndGquqcCeuIk12nu0ssgdeBUx/mtwBt8Wcij" +
+                        "1I4pnbg1n/mDahNs9fYDc/BaKzlS4hJeUMHEpNg5WaD/KFh7/00eEdl2TrwL" +
+                        "bDskZNU1spzonztw8W6ahwqvTVKakZvAeq/B02zA2KOM4cclU1F6seDfyAjy" +
+                        "EmZjy7Fps8kdsMtxOaeXREbENtL83be7Hw+R3Rzrg+kbzyPgtKPtXCXB8Wet" +
+                        "qPkK7ffxfwaXDTd7ufXcytzHHX3gAN849m6RxNGnmMOUJwLmEu5eG0vMozya" +
+                        "7HZJMphL0EVR3GDn4i8LmOFW/cfCMwSp2LG04jchN1xsDB9ZKSBn3K3Tbxa4" +
+                        "5l0Qu0+9SSJSbT7uQW6VsA+SjYM2QiN36/FzhcvpRYl0yJo7kznDzDvfQrXn" +
+                        "8Ok4NfdYNHcseLs8xPuyB8caRGMj9YD0HN2EprBo3NcuZ0tkI/E0VGO4LaWz" +
+                        "fSu4ike6DM9dZ3YoeDyvYAvryO7kiM7+9Qj2RQy6/Iuxg2cAgBSmn4lB9AT/" +
+                        "9T8vLM4bepMQgMd5O3gRXALxrs6Ojo5uJwA5GbLIGzuNOAG+Cm1buqWV7yRS" +
+                        "6Ku5nWGCAP7Hftr4vrjrt+tHXvs9y2kpC37DEP5jy/ye5HQLeL8h2QL9vz/w" +
+                        "ffzpMkW/rYP1p20zRjOzfLkFOtmQkwfYsn45/RvR+gOthggAAA=="
+                )
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+
+            val mangledMethod = fooClass.assertMethod("usesIntValue-Vxmw0xk", "int")
+            assertThat(mangledMethod.targetLanguages).containsExactly(TargetLanguage.BYTECODE)
+            mangledMethod.returnType().assertPrimitiveTypeItem {
+                assertThat(kind).isEqualTo(PrimitiveTypeItem.Primitive.VOID)
+            }
+
+            // TODO(b/407735992): non-mangled method should be kotlin only and have IntValue param
+            // type instead of int
+            fooClass.assertMethod("usesIntValue", "int")
+
+            assertThat(fooClass.methods()).hasSize(2)
+        }
+    }
+
+    @Test
+    fun `Test function in value class`() {
+        runCodebaseTest(
+            inputSet(
+                kotlin(
+                    """
+                        package test.pkg
+                        @JvmInline
+                        value class IntValue(val v: Int) {
+                            fun foo() = Unit
+                        }
+                    """
+                ),
+            ),
+            // Compiled from the Kotlin source file above with [generateBase64gzipFromKotlin]
+            compiledSourceJar =
+                base64gzip(
+                    "test.jar",
+                    // kotlinc version info: kotlinc-jvm 1.9.23 (JRE 17.0.6+10-b802.1)
+                    "" +
+                        "H4sIAAAAAAAA/wvwZmYRYeDg4GBgYFBkQAYiDCwMvq4hjrqefm76vo5+nm6u" +
+                        "wSF6vm7/TjEwfPY9c9rHW1fvIq+3rta5M+c3BxlcMX7wtEjPy1fH0/di6aot" +
+                        "QR+8dAu1vM6c0Q77cE7/5Mkzj58+esrEEODNzrFeWHO9JdACcyAOwGm9OBCX" +
+                        "pBaX6Bdkp+t75pWEJeaUpuol5yQWF9eGeAcrh4r8e+er/rLEaqHwPM4Vi43P" +
+                        "PVFkkSg5lpggcaFQ6vACAzfJkostZiZPUnc5n5009x+TeN6WOzsSF4ZyTQmJ" +
+                        "7LCun5xambf88wqHyKl3qs8//n1u5/M5t+v///4tz/DsA6vzGcNc9XB7jadf" +
+                        "VgUbnPI15ji24K10u9u6nBDvnV/n1m5+wfIweYLXsuCED0svWTFbL9m/TonD" +
+                        "kqVPYOZc29NpEmfiH85Jn7B/zVW1tV57feo0bX1NJl3U8DV2mXNr2eUNq1TP" +
+                        "W/lcqzGvOe3GsvjvrqfLQu+ZSjsekWTiX7vqqc6unaIhPIkRBxXcJA69FQlq" +
+                        "5zY6duLyiutnX+kdTnmVNWV1416Fz1qTJMTnCPMIX0+98frHqoIaX4t1f/Y/" +
+                        "fn3oI6+W3242HueV2XnrH4ndE9m3PTSjQzPkvUho3vkN38Oydqf5x6403Kg3" +
+                        "Ry9/mkvnvUUSufmiwSe0Zrj4ubrNsUhbEfAs3HdxTnWIsqbtfXumzy/Febw2" +
+                        "7wquflm1skKasbGu/WB88bczbM5/tLq87i0SW7u3L+Ro7BnOee1cKheN10as" +
+                        "vuW3OLIki1dffqfsFV/d2rMtncvcWU8bNd8qFp9lUO913fXdHjvlaZGPTshf" +
+                        "mbMp9Oxb+bCi1e2ie72aZlyKuL0hzerYuocSSx5PdZa3FVebNiHCobne4df0" +
+                        "aRM0GO6rPvrcvbjn0PEdh7Z2K7fWxUwW1fudyX9Z7+I5W0sv6+n6++OkdlvM" +
+                        "eno5p1JB7kLFJP/fevU8HpuW/AyfPMunKCPs2pQlJseW3by8f19u5OFZu6Qu" +
+                        "KqX07vrUsGxtVpTPgpPtO3dZGGbcUnjZZrUrMTdF+VqnUnCbpydfxsHT+RLi" +
+                        "4Qs2XTha88WnOu7slUbnYtVlbYkK/qZV19a8mdH7/JjfTZG760R7iw5mRDh9" +
+                        "mzLR97iG3BrJUv8ws+yzbhdrkjgVN15cYxV2VCdim+u141ezzhrKdP/qlXw1" +
+                        "94mYud4+zZIuBTZ7piU/pyyZo2H99t+Z9QF9Lw98lFzLGP7ysNjarNOMiVaM" +
+                        "nEodVQ/WePv8j//VEMQ/Yd2LY7yd5s8Y30/cvkH1nOGO0q6LFY9Y1qv4Fzh7" +
+                        "z3/wjPPdnzdMu1U4+1s61V9PvPMtaLrrq3SP78kp+o8nVPTLPUv7veuksY/8" +
+                        "d8Y/cxWC5/76wjrz7fGS5gvFnw1el1gbHj75Zv6D+wffW5+La5j/4J5T0aNq" +
+                        "Ra+1TvsXmHLI/WK/KPaUQ5Pz2VJFv+8f180+wHym+smihYe0VYROzUtcODuQ" +
+                        "W+6TkZC6+LrCjx22PxaxhxstjzjT859t6f7yfXJ6Sw8v3XH5cMfnwOUzzPfc" +
+                        "+pBSH1qRfW0Ly7QPNz7vcz5zSMyK/b7XvKSl++MV+UWE4w/8q9t6fHKs9aT3" +
+                        "D//u+906+bG9gsZflpPXdbfN79p7JXq1wbyKpXyPmb/XydxeV804//K7Cy81" +
+                        "31o5hm9/ePnjwr49faY2i5Wvlda09G8/mJOTUCy92CxE+nwuy92vE3vX8O7v" +
+                        "behlX/dsX+9us2c5NY+6BKUDpYPNjMzydkqddXtjDyqfjkRd3B/NwsDgyYGv" +
+                        "fJIGYnjxmJuYmaeXnV+Sk5kXn5ufUpqTmpyQkJAGxCxJfmwaAUkXkhjAZd9X" +
+                        "pT17hYE6JcBlHyOTCAPCdORyEVT4ogJcRTG6KciuF0cxoR53iYpuCLIzpVEM" +
+                        "kWfF6+0Ab1Y2kDJmILwCpKtZQTwAfGF5dWUGAAA="
+                )
+        ) {
+            val intValue = codebase.assertClass("test.pkg.IntValue")
+
+            val mangledMethod = intValue.assertMethod("foo-impl", "int")
+            assertThat(mangledMethod.targetLanguages).containsExactly(TargetLanguage.BYTECODE)
+            mangledMethod.returnType().assertPrimitiveTypeItem {
+                assertThat(kind).isEqualTo(PrimitiveTypeItem.Primitive.VOID)
+            }
+
+            // TODO(b/407735992): non-mangled method should be kotlin only
+            intValue.assertMethod("foo", "")
+
+            assertThat(intValue.methods().map { it.name() })
+                .containsExactly(
+                    "foo-impl",
+                    "foo",
+                    "constructor-impl",
+                    "getV",
+                    "toString",
+                    "hashCode",
+                    "equals",
+                    "box-impl",
+                    "unbox-impl",
+                )
+        }
+    }
+
+    @Test
+    fun `Test functions using different value classes with the same inlined value`() {
+        runCodebaseTest(
+            inputSet(
+                kotlin(
+                    """
+                        package test.pkg
+                        @JvmInline
+                        value class IntValueA(val v: Int)
+                        @JvmInline
+                        value class IntValueB(val v: Int)
+                        class Foo {
+                            fun foo(ivA: IntValueA) = Unit
+                            fun foo(ivB: IntValueB) = Unit
+                        }
+                    """
+                )
+            ),
+            // Compiled from the Kotlin source file above with [generateBase64gzipFromKotlin]
+            compiledSourceJar =
+                base64gzip(
+                    "test.jar",
+                    // kotlinc version info: kotlinc-jvm 1.9.23 (JRE 17.0.6+10-b802.1)
+                    "" +
+                        "H4sIAAAAAAAA/5WXeTQUXhvHh+xG1hAiWxEzlsjyo2KsM/ZtNMhOMmObQSLr" +
+                        "GGRJlmgsFUpk38k2lrJPQirKUCO7UXbRq97feX/VeX+/97zPPc8f95x7v/ee" +
+                        "5zz38zzXBHaEhgvAwMAAAACEAT8bF4AGYKhtoQHSN9KRMdQw0tfRNrcAG+oc" +
+                        "9AEAXwwH+g1gIPAwCwx0ZmiAWG0mO3qWRPYDQw2l9Q2H/YtrzChQkO8Z6MCA" +
+                        "lBVlSKa3d+ADeYZMDTCB0TOUc0qWqxweoHToJn97PO+hY1zRGBkfT3cZfS+M" +
+                        "lSPS31UD7Ix0RKNvWMDQ/NpsB27riNJXm3r6Ap6ok6x6YhdEurFsPsiv4cmK" +
+                        "ftQBbMrnS8mgIJSHeI2UZVIrQYbUTst01DYkvNjhqd4x14HEKS3T9RKrFJiV" +
+                        "qfhgfuHe4kr5063VsLBvR9rVkXIFav0bfhv7fkM+zXmXPBAwOVm6Sve6Adtu" +
+                        "TF9j4USwVW+8cBcb2ObybeG0Xj5giXYYBAKECgj4Xt8MQGVM+02LzAl0JsMn" +
+                        "KHx15rmVTzaYOtMTboPWJ2um9FavtiEbPeABJTpAUeBwTJ1zMHMoUJtFv8CC" +
+                        "wdbpRVOZfGkQLVxvrGQc5B7jeAo9PKhNjMhQYYHLndIYAXJGaaqVK4OPnS6Y" +
+                        "6fsm1Qo+NuVgoirGZniXat6zIYnfbOvUsMe5viAWCK9V3JRNF6lsfqVsNKAk" +
+                        "nCAbrRutt2kSS/NEuggvBj+BYhnpKc7sSMAlqPl+5OV4BTesnqEzyT+e/8L+" +
+                        "c+MSmq52Hjl+eRvB917HAjHlHDvabPdEYx89fDPTG9LPwUo95sNTzfFpP4BJ" +
+                        "+5jjJU3TYpWy8St3mhGiDLD57Ud1ybW8L6yrGAWhNeJXI9EqZMmeBMcegWv7" +
+                        "ZbZukoMdoYNPXht5lVsOltYV4yA88ZpGAYKvpImTcuqpLs1vmYazZRu7yNRX" +
+                        "t2+ktFWQEwUoJ6gP5tdJuL7nDX3d8xHQC2CudCn2t5w1uh5Cj3Kk3O1lknIE" +
+                        "Bz6r2Qjqa9OOB53HbDorlGC1XSx5mN59qL5pskHh7a9+HnZjItSQAWUZK1xk" +
+                        "KD/bj+vVjGVPiSuTljRb7AUXa96ecxQ/4+Q+JQuGPFz3DTVaWQruakOy4W5T" +
+                        "D1MKLr2r4yMOLN8UZ7aRupue96aCrM52FHXNzSNssIQ+0D//FTKtRLeuuWA8" +
+                        "K8kdXpq3/Ha96aOyInEdWSw5lmUe93Av7avtC30rUKSE/vlCGyN5WLDLZ/FR" +
+                        "iKoPl0fibgdbK4UlhFZsToucbM7O2wZ7+xm0z+T0hTfDPF/3xYZo86kq3YYA" +
+                        "rFLYmvrWxZfX+m9F9F5ivuhFyy4hH8k5uVJv2pTkEUmdlZXzeINzUmXpbCwm" +
+                        "xyBwZAmdslo/r/KAihGZaxZQNbFedIHQBhHDKPszhWIDZzfiVsmKk7OLMIQz" +
+                        "aS1MdhInIC58l9axZ+RGHpSOAlilJVWBzaTAR/CqBFuZvLogtVi93BA0gdxA" +
+                        "O8sc0agalLDTuzZ1/0C1IgAlXRv/cNewnQH9ADZbG85ftlXdMQESfbkNiI/Y" +
+                        "RGne8V6Dk7J25e7sLR5jTUj5nDVmX26UUUmVk/6M6fxSv8yDW9/CrbfdsRD1" +
+                        "KlGtzZmgMo5tifuqEbqhoQJZrbtn1QpvZBgJjRxkGiSCsMASvu2ui1SemC7O" +
+                        "qKv789yZ8cSK1mgYWIGHH+x00EQSWRSZEVmYiZBpNEaTnV5118QnxC+2+vR0" +
+                        "U8K+Y2c/e6hejgYAINH/39jR/As7ExZcBysbsDvpWgETClbU61SlObrLODMm" +
+                        "D01Bk2JSTTIXBJ/u5IkUr0NKvxlxDaAwW1dERNBmSTs8Ejuu2omt+KAkB/wE" +
+                        "rcrxVRt4vZUbvBIU8umPTwt/YmdJtsB2xBc9uA81qn+XZ+qZ9eQQO/7EOd5G" +
+                        "vCPczzhwayCFHxIrbCv3TgQikTp23DrmoCmSt0BZeQazbAWKOcSO0wtaHHt9" +
+                        "JblO+qm8+1iWIk7quLrNXOHaas/Kwn2vWtRYn5sUTg43B+mvmxRnhZhqcEge" +
+                        "PwOWk2ixuDuUh5VyuaqQ9cjOLbPf1gAth0521SBYGsTe98AVObIR+Y2YOiUd" +
+                        "Gza/4cqZO5V4C8CMWuZuejtMZR9wFS36GL5S6GUCg47rzBa3nLVi9gIiH0kH" +
+                        "xDEKKoq8uaUplnlMY0zh4QJCKlPb6hlwlssF23XbWS/TvjYRz4nlI85FE+7I" +
+                        "uNw724MKrl/rqDajnMvr2BOEFExbDXIPErVlnN6zghBq0o8jn2by+L7fgkn0" +
+                        "McRzFz/ELTeUBvSiaqitzZSUEqPnupMJHBCKiZbNA2FluHnuRTeM3Wh7VmC3" +
+                        "vLEr9ya/12AVOjjnuleL+ThKNZNG5U3La1m7fGQD3fy1Fs68wI4uDh7mK6Qt" +
+                        "/W8dHKeh7f1c24UjUfzy90jycGNWl11fy5RGrgfqGsFpm6ZvGzGbG5+75glq" +
+                        "xOqxSgsLMh8xZig0Afewgu/SuEXc0FqQfnotheYHdhanTlm42lnqYhXnMwv5" +
+                        "xVktT4jmvB0RHxt1q+KxFBFDWN8srqz25uUxKQrJDj4tFbhpN2MPZOi0jrhy" +
+                        "7WXZKr7U/ZnXIFciKi0BMXzl0oyAhG6dbX5Nm6NCVHXz2JV66KwoTOBlFmqi" +
+                        "dsFt2E+6ya5yGefZwL2RtjtY1C1yAxoC1uOwiz8JxRPn0zgHXgreDWXcSaZJ" +
+                        "Eik1tY+TUaO3N0rWWmYrF/EJzSjptts9NrrsbGuUKKQxkkTB49U7akWbd+Iz" +
+                        "GoXEEuvVgAbNtSd7SgERYmzZpM37t0ZhBjISlMY32qU5pKHpcEhBhksdfPZi" +
+                        "ytf7xhcY1ZPbP0lann5kmLXD+fUPLc2Ys4Uk3Wvuplm7lwU6z9vbv+Q7cutb" +
+                        "lOmFj8qSvaBw4YI9rXTAd+wQtO2xlrYAvApBU+j2qiArG2MvGt54zStiz4wE" +
+                        "NhZy9r3+Wamn7ehyjhBspTulRdiBC12k+wM7LFUd+7dNR7YB/REbqBmtyW77" +
+                        "CG/P59YnluBqPtCb3q8c2prMn+EMrPg8t33ut2LP7Rxxmr7HfnSjN4ntTf+n" +
+                        "RigpP3yBRjBowxcZPEukZG+e0f+OHduNE1hMyeK2li4Vv9hMnFHLAYZ+gOD+" +
+                        "epIgTn8zCkQv523nl+zP5svmT2kfmSwMJDu8J5REJUQt5vp1EeZ+YOfjHUP1" +
+                        "/40djp+xo+Pt/W/gRJvaeXNocKmf7Q+teFE1ivAYQ1wYwc+Z5RkrnnIws4s6" +
+                        "ZxoppwaqKDV3gN+NwG9rfj29yxryctuBoXUnPyGwruuczge1yeAVla3cybs7" +
+                        "a18WlQCBPlHC5SJFX8dbjoQp6SNl6VZlBWJCLySwfm3ZdBw1PQekW8yNjW4i" +
+                        "OiC9FL/IOjb2tLv1PIZryku/MuZflv24mfrxVafuXiKPrvrCW2AdXkH6mSUd" +
+                        "9wA533f9EXubwQ4fpPI9zMK+6yBVL/qdSbRLJ71zVICrqos/YDBVOEwKY3lq" +
+                        "9J3bNaUcZENzl92K4WlwoAKpDIdHJygYn344X9DRX+I2dB4xSmn4eNyzObvI" +
+                        "Olf/ze5BtOFpMVeBCbRR3KW+lbjML9lvgr2ePjq7V3HZ7Xo000j8cYwkjpxa" +
+                        "yOA0BtzLf9z0Bd6kgzkIJC7n5sVcT8aI4jTtuoZHhu+fYOF3fGo8YKY+j913" +
+                        "U+Zqyk1d+eKisKT1VJPnCVGnkiPqsWTByVq+53FM6XpOcSifXdANICL1/K0Z" +
+                        "1+KQfXzaYNa96RCRdt/ovPQU7jKzASGlk8wZfuyNacOdgSOhTVv3ogJUG/yk" +
+                        "h+gVEe0i3SJM3+p9DhynH3ILjL88YLEtbM7A462vEhh8TrX7hVdbC8eiqaDW" +
+                        "qAj9kukQ5iBG+EwkVtxXjpaZY5FDpUjceCZFa5rne/akZfSEH1ABAEJH/il7" +
+                        "+A/9P606ytHDC+zpjUF6eNmjvF38ka7ODg4ObodO42REJ2Hi9MIJ8KMP3xBp" +
+                        "buH8s+SZwKiouQB/qf/co3//CPxqf/ct+F3l55LL+4tC2D9097+r/PyCflXZ" +
+                        "pPn7Yv27ys+R5PhFBcX4397e7/t/jhb/L/ufMP9j9E1gtHTfl9EeDpvDC9AD" +
+                        "v8/+Be9L4gd4DQAA"
+                )
+        ) {
+            val foo = codebase.assertClass("test.pkg.Foo")
+
+            val mangledMethodA = foo.assertMethod("foo-GHfTWwk", "int")
+            assertThat(mangledMethodA.targetLanguages).containsExactly(TargetLanguage.BYTECODE)
+            mangledMethodA.returnType().assertPrimitiveTypeItem {
+                assertThat(kind).isEqualTo(PrimitiveTypeItem.Primitive.VOID)
+            }
+
+            val mangledMethodB = foo.assertMethod("foo-wveqTnY", "int")
+            assertThat(mangledMethodB.targetLanguages).containsExactly(TargetLanguage.BYTECODE)
+            mangledMethodB.returnType().assertPrimitiveTypeItem {
+                assertThat(kind).isEqualTo(PrimitiveTypeItem.Primitive.VOID)
+            }
+
+            // TODO(b/407735992): non-mangled methods should have distinct signatures
+            assertThat(foo.methods()).hasSize(4)
+        }
+    }
+
+    @Test
+    fun `Test only one copy of function with type variable`() {
+        runCodebaseTest(
+            inputSet(
+                kotlin(
+                    """
+                    package test.pkg
+                    class Foo<T> {
+                        fun foo(t: T) = Unit
+                    }
+                    """
+                )
+            ),
+            // Compiled from the Kotlin source file above with [generateBase64gzipFromKotlin]
+            compiledSourceJar =
+                base64gzip(
+                    "test.jar",
+                    // kotlinc version info: kotlinc-jvm 1.9.23 (JRE 17.0.6+10-b802.1)
+                    "" +
+                        "H4sIAAAAAAAA/wvwZmYRYeDg4GBgYFBkQAYiDCwMvq4hjrqefm76vo5+nm6u" +
+                        "wSF6vm7/TjEwfPY9c9rHW1fvIq+3rta5M+c3BxlcMX7wtEjPy1fH0/di6aot" +
+                        "QR+8dAu1vM6c0Q77cE7/5Mkzj58+esrEEODNzrFeWHO9JdACcyAOwGm9EBCX" +
+                        "pBaX6Bdkp+u75efrJeckFhfnBvrmX3YQqN3t9+aIr/TypYq890WWbGGf46ag" +
+                        "uELLcWnXAgahrUUnMyfvSJx9pHvT7K7F9dz/G4SF2FMKn7grps2VC+jmz7+3" +
+                        "p9L48cb6/z8/Ch8ItklbMSNi9ofPJULzNJ42Gm7hWyy+t7hQ8dBMD7WH7Q8r" +
+                        "bYz0+9d58xwMPevceNB2SqeJO49f9vr4Ru7z7oKqbU0/VUwPu72/P9fkmGVw" +
+                        "V+Lu0tqjcfOPbV2koX7GIOffe9OsvSuNjGe2vE9SPnaI49KPP4cWSs9s3cR6" +
+                        "oUHzZfySs7eOHGPnyd+05d1ntu+brzxvbBVSP5Sbk/KybuGUpYyvP5jVx/75" +
+                        "evVp4+cybQ2Tyt03Cpm3n5yfnqlXXRbXHuZyJq/o5Qb14Kr7hzZKHee5Os/n" +
+                        "0ffTPw3iXJIsut8qZqmk1W6cYLZf5PTyokkcm2MEvvtfLTLs8l+i+6YmRs3t" +
+                        "3ON9VybNWT/JRTJxiZcJ34GXr2+13z66oL6jekrrt4Suo3/fa9SfPv2d827M" +
+                        "kwqHiEjJB8m9Sb2fSlfdeJa+s11v560XT3q/hn7cdHGTFtOh9p3VzTHazxLM" +
+                        "+8s/djwytMzaklfMsLx7rV5eycZeq8A7bxY1zmWc4Sa8nU0jc03mnWs7Fj/M" +
+                        "DCkKuhrxnxuUFpb0Ryw4w8jAsJsJX1qQBmJ4UsxNzMzTy84vycnMi8/NTynN" +
+                        "SU1OSEhIA2KWJD82jYCkC0kM4HT2VWnPXmGgTglwOmNkEmFAmI6cBkEJHRXg" +
+                        "SvbopiC7XgjFhHqsqRddP7ILpVH0dzPh9XGANysbSBkzEJ4H0s+ZQDwAzcJc" +
+                        "6cwDAAA="
+                )
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+            fooClass.assertMethod("foo", "java.lang.Object")
+            assertThat(fooClass.methods()).hasSize(1)
+        }
+    }
+
+    @Test
+    fun `Test function of nested class using value class type`() {
+        runCodebaseTest(
+            inputSet(
+                kotlin(
+                    """
+                        package test.pkg
+                        @JvmInline
+                        value class IntValue(val intValue: Int)
+
+                        class Foo {
+                            class Bar {
+                                fun foobar() = IntValue(0)
+                            }
+                        }
+                        """,
+                )
+            ),
+            // Compiled from the Kotlin source file above with [generateBase64gzipFromKotlin]
+            compiledSourceJar =
+                base64gzip(
+                    "test.jar",
+                    // kotlinc version info: kotlinc-jvm 1.9.23 (JRE 17.0.6+10-b802.1)
+                    "" +
+                        "H4sIAAAAAAAA/31WeTQUahsf+0y2MNdYqgmZpmFmGjtxs2SSuaMZocUSE4MJ" +
+                        "kwzXklvWylguiqJRQrlhZAkzQsiIcK3dMfZwy5X1utaMT91zvk+dr573PH+8" +
+                        "57zP73nPs/zOj4ATEgYDgEAgAABQAew0MEAYgLe0M0OesMGi8WY2J7CWp+xQ" +
+                        "eCy/FQD4G9/2+iccEtUliUMiOtp+L7M93Ks9OnkZZY3XPIHvCnxSbjtvjfRH" +
+                        "WLe1aTjMd6BbWtrGJ99OCgIIODFgsdyhYsPtBPrbTvhmesi20zwCaOhLFz3R" +
+                        "J/xoDm4+gR6oCz5uAQHhdkOnlO3BW0OZxe3kiMxO29IHyxYD0UmwpnMF4FzC" +
+                        "RYgFMZ8Yh8ZxQeItMLL+T9CQnroXYudpS/WQfTRsRIm2VLf+Fqx5YbAd5mbO" +
+                        "ucvY8J9d2+xg1QXM8jfnoFcFq+hoxZSsyVDWuouhp4FLV6FOkYJCFFd3pd2p" +
+                        "idbK6ityLpho2k2yuoUsnuHsbnWXFG2aVbiTrSKqLpVoYMEdKHGOHWuIAZZJ" +
+                        "CLn4Dl3k2oTwmG80JNK1sRWdCf1GanUaNRVNj5z7K5QwEphjUG7iTPvGXbDu" +
+                        "gWRblcNtv1KOt5anZp66dBdArvEzHJDouUuvR3GkSe2UqkjiCQZZYS79fUgz" +
+                        "ZsoAtTedP7IQOLUqCuKmRY7ZPkoCKjHH2Es1ZhkZCZddGgGi9rJrsKmqC+wj" +
+                        "uGe+Gp2Yn6aIxBRn+ZQGBK4eBrcbcGwElyJgmCIVtdN7DBHF/9j3FFYJ9Flx" +
+                        "4EtB9T7LhlE8WgUFfQUtSVVDdP2sqKpLbab8ugoh5l6hn5NnQ3+LPXIn2Xiu" +
+                        "kkmwk0mLAedljIcmkFsKdCPLbwX5HG30uT+bwpg3TTHJTRv07Oxw1jgZQpaw" +
+                        "cIn6Y+6VW2zwrjDdYtIR1tAmxS+kjmJQnuyc4QMtPJPF8g2F9QcHHj2WdL1F" +
+                        "BSVGuGVSWvd0MlFw3leVP7U0ym49zmptmoqwhkLiWm8D20EZOTrS3W23y4oh" +
+                        "2JPS5OAspFTew8hpY6jRBkbJoUG1tFA8ZnlB0TI/NPjWZH/q6ZEKGzlzR3mS" +
+                        "aWhqwlqFmTkQc0yvq0TdkoLsd7OHy5kUHrP88EGZ4/GEFs42fYgcnjFJQux3" +
+                        "jHbLN0UY+zpUFnK0AwpILd1vrMl5Xno+LOl4oemsszxHzHS9i3OxrrL6dAlS" +
+                        "f+rZo/F++wKvaj3Gj7R7GZ6heva3ER2/vdIKtebreqmLQ8xuaVryJnOf6hyH" +
+                        "/RIVaiWe+Lt3/Dpnd+28QK2QbPlDyqufZa6NqFND0n4BlfjH435LVnu/LuMi" +
+                        "16/mZNKQWbeaXH3A+/nkuxcTF8Wt/EQV4VpRcoN/NcEZL5ZiBdsSgt6sg/yg" +
+                        "ywBVxv5TjIvLwi0rJLbZ+5vCd+zZDB+98EX0/Nxu0F6brEjoGMMw/GMYS7Jy" +
+                        "ifcAI7pvSywK2SqjJatpZcGcTbbTitgIRu9PD0x28b/bOQEiVys+G13Yr8Za" +
+                        "HIt8DYG8eCdUZeQfz7pZMpLN51UGIVHPGvPW8S9uBNSq/dlnqsxcedLgiFTr" +
+                        "XgWIR6wgSWmeC+mjyusY+bDpH5pTpK1b6xyoNTxnzjrNQSlp3u33Tdl1rvSN" +
+                        "mKtYg94fjpiT0Pf+QEQ0R/SCrkyMJI2z5viKet7D2X1yGZKRKKqq++gFIREh" +
+                        "jWBrXKHSqvB9v0jWmcZ1WKyzFyqLdWNt/Dm9kH6Dnk/fqJ3cV6MB0UY9cnJ3" +
+                        "cvo7QQgluiX0iX0Uz0c/NxQGAJbEvsc+sjvZB0ul/ks8eAIep0wEm6zgtbr8" +
+                        "dYiOcnUDbxvYl+x2iWhE7mowtSO0wArSJ5Jr3RcftYXJpK8hN8WYwhBZ9ock" +
+                        "RE3OWfeAWcN3QxuzzSNX0cWA2jFtFVor+/3pOmXnR96gY/lLE1Hxst7sLnzB" +
+                        "Yx5TOGn0vlfO0KH6gU0ekBgNfXBNNnv0FwruTP7Jq0tRT8/MPUZ1wdi2NkG5" +
+                        "qR9u1kc1Jxy63r/H9MGPG0lGp8XajK5Ho8eJCjcygMc8jHe9jM9POH787bXE" +
+                        "liNo/toMPe6VdhK8eKXDg2Nx8ucRt4JoJTeUHlMlNZs3dyRrSXUGbs5iJrD3" +
+                        "SZ1DVKcXRTPyQnlpJyzIRn/IaccnEPstVYvsn5+/lC5VVsHuXRv4a6bTwIQg" +
+                        "6at78L5iqtEUjaIppbKKSu1b1MYwy+KGdQiDYZw2ObkISezW0EvYBYOxMqBB" +
+                        "KJckwXWcHESMLzv2Kf3o/7GDv+ddLD4Y8+cFzZfwnAYwHZP2dFD47JUXzbBd" +
+                        "8hFNcTFU4qb0p+bZe8duhAsAABsC32ue/FfNO2DudvnfBvoSzaiyZmA+WT5o" +
+                        "KnLG9ol5H+UZorc3hpPJgeMzCrP77BpjohRdC0+lDZE9vYxlt25m1QSXLrgC" +
+                        "hz8SOZUPsAUBq+Rh/ZGV4ef6I7VX+YKj+2YPB2Mp41Bpqc0hg2GvuJcCastW" +
+                        "94BHwV3ZW+VhB8I4EU2uRwnJWtKKhZQiZ1P5CrrEntj4kCKdxsvTPqUbEvTi" +
+                        "t1UaKUVRQZULpXX62mISTSPd+7V8ZRJzowLsqiDHeQdysm6mInWNpQ6F6OaL" +
+                        "iGjWB5TcUD3rGMWNRiyu5MqEuwnbjzXK0c+RDmnmAkT19vMTrHOMGOuSsZ6p" +
+                        "C3GvXw9ODrt/WNxzX8zQJSu+MoShW9azoreympriWbQY+uf0ocx4kELXXac3" +
+                        "ZY+pIVlL0356+uGVDp7ew75pDmXvwrVundsqx0prfjRUEpvWuU5+0rHVPbhX" +
+                        "4a/Ag7O42Ly0uAm+F/d2i3iXpIcRr+pgQ4WVndLWAXEzcIv7QfA5nFLdhvE+" +
+                        "dRNWQXd1az1ciwIfsNaQPZr4kAvM8WJ7XeupzKP3VE9BQFTbicfaOSbVayBW" +
+                        "Utm0Y/RyfLl/5tPDEFcB1IzlhGfbefI0+DW04w5j6w7SDuT81oA5LorIb3dS" +
+                        "5uZuyiyodzNpriIG0FHza3R4j8xtQEFVr0BPVbzGXgMlJicjtsjffjwD65Iz" +
+                        "/3n7l+6BeJvbwzMh+L0BUt72/0ofXzdvP9RFKs3H2++8L9U90MfjgqurK3nb" +
+                        "hUk2onACqZME+Kxr/lF9XiO3HanwWdcICIIB/0PfqXk+Casv7Vsy62uUndwF" +
+                        "+QLh6rfV0tcgO3dI9guQTeH/R3pfx+8sofwX8WzRb+3d1xg7S6X8BcYG8Lul" +
+                        "J+BERD89E9k+Z7Y/cRr06fYfVDQfO8UKAAA="
+                )
+        ) {
+            val barClass = codebase.assertClass("test.pkg.Foo.Bar")
+
+            val mangledMethod = barClass.assertMethod("foobar-RVb1_dM", "")
+            assertThat(mangledMethod.targetLanguages).containsExactly(TargetLanguage.BYTECODE)
+            mangledMethod.returnType().assertPrimitiveTypeItem {
+                assertThat(kind).isEqualTo(PrimitiveTypeItem.Primitive.INT)
+            }
+
+            // TODO(b/407735992): non-mangled method should be kotlin only and have IntValue return
+            // type instead of int
+            barClass.assertMethod("foobar", "")
+
+            assertThat(barClass.methods()).hasSize(2)
+        }
+    }
+
+    @Test
+    fun `Test functions returning value class types and visibility`() {
+        runCodebaseTest(
+            inputSet(
+                kotlin(
+                    """
+                        package test.pkg
+                        @JvmInline
+                        value class IntValue(val intValue: Int)
+
+                        open class Foo {
+                            fun publicValueClassFunction() = IntValue(0)
+                            protected fun protectedValueClassFunction() = IntValue(0)
+                            @PublishedApi internal fun internalValueClassFunction() = IntValue(0)
+                            private fun privateValueClassFunction() = IntValue(0)
+                        }
+                        """
+                )
+            ),
+            // Compiled from the Kotlin source file above with [generateBase64gzipFromKotlin]
+            compiledSourceJar =
+                base64gzip(
+                    "test.jar",
+                    // kotlinc version info: kotlinc-jvm 1.9.23 (JRE 17.0.6+10-b802.1)
+                    "" +
+                        "H4sIAAAAAAAA/31WeTjUaxv+YRqEaEyNpbJLNDMmWSYUacRMlpElMWosY5kx" +
+                        "k4xiThsijl1lK04bp7JMYx/78iGyJjEkhHDsJTKO8el81/V96vrqea/7v/e5" +
+                        "3+t9rue578caJwCCAkJCQgAAKABbAwqAAAuMrTHc3NIUaWFsaW6KOW2LsDDl" +
+                        "tQDAZ4vWV6dwcESXGA6u3t7aUWCj+UZrePwiAmtx0NyiK+B5oc0CFu6njm1t" +
+                        "1bBfaEc2N7eOjn8Y5wescYJCTMkDTPTmA7qbsP7p87BN0D386cgLZE+kOZVu" +
+                        "T6QEeCDcKER//6u2g6dl7aAbg/eYbaTge502+Q+WTQZuxqk2nM2GPrEmw0zw" +
+                        "T/G/I3F9wiLNqiTdU3JB3dU1gufoS7WwfXTTYJbWjte6G6pNi+/aVInHG1PT" +
+                        "1/zmVtfb2dX+c7z1ebnr/KVRSOnEjHEGm+uC9tRz6co5nCslFdqnvdLm3EBv" +
+                        "YffkErLHGiRcze7AmbONEi3uYuCGOamUhwpglR2xeiZ9AyxC+EhdmFCBqICL" +
+                        "7yC5zzKoP++thmiylmlxZwzniFK1RmVxQxaBUyyDEkWdkOuLnW1bS4VqKyfY" +
+                        "KGi2xvucbCm8fe/0hVSAVElFD4h2p0bVIhrFXdt8SkPw5ukkqfnkyaAm1JQe" +
+                        "Ym8yb2gxYOorWLgvKWTEJitOSCZvpGyp0jgtLeaiSz0AtoOsqk6VupXp44p8" +
+                        "NTpRp6bw+ETC7sQ6dVytqprtgFM9NF9dFZWroOSwB63O/GLXnVPK12PWqLZ0" +
+                        "qZayjA7tpxf7IK8gxWhK6l2XpRW1aU0+8V9h+CdXos7uLpN7Fq6fkmAwX5Jn" +
+                        "bbszKQyamTbKiCE1Z2uHFN65RDlWT/ljLjF9wSjR8EnSO8/OdoKGVRBJ1MQl" +
+                        "tHf+JTE8cPtv2kxXffbgug81qNpHrzCBkEaRyzmTwfZlqHICA46diLvVrIAQ" +
+                        "tL5jmF/9YjyWf8FXkTe1NFzWcpLd0jAVjJWD/d5yV6hNOO3xYfHXrXcLmDBT" +
+                        "K3FSYAZ8R+ajkGkDuSNrKBn7OsX8HJGw5UVpzFNG4J1xzm2HoWJLyeNOu12N" +
+                        "GLdjVouNjwuhTuh0sVQwPnAO0U5N0jDnBGZmRrbR4zn9apnRI/j7WcM4dXmn" +
+                        "m8SnRuoGvvYlOY1a/tmuza/fYkmZXjoUtni0wHSGY78TarrWhcDUllWZZsF1" +
+                        "p4qyRjl22V7lOulH6ffTPBk6dnfV25+9PMTA8rS9VERgxncOYvrHn7w4fFL1" +
+                        "WijDTCS2wzua2yhRtcBXJQApfOTz8vLOG0MqtKCka8Isv2jcswSlSe5OF0mO" +
+                        "krNh3b3qrwnlyt4V4xM1Y2QRMypYWu1QqOS7vxrU0muWwvlbYy695QpT5ZYB" +
+                        "xXT50+nkZVDzimuZ8WQkKMWuLJ2ic/UTcmFeQnivZUaI3Eg6+urfv7HFSpb6" +
+                        "H6DA+zYEQ+EtOw9BDpqZ5M0l2B4KXgtEyicHJLj4pXaOCZPKpYuGF+WV2J9G" +
+                        "Ql7BYDUTAqVH/KLZkayhh7z+kktwRFF9JteiJsK/Suljj5Fs3srzOie40uuv" +
+                        "gEjwCtw1yXMxeViWi9r92/SupkRxbEu1Pa2yn9DIpdvLxC0QO9Yh3D7xiLDr" +
+                        "pnpvdukfd0Xe71UPbgp+I3xlbChulD3Pk9bxfv+wRzJNLARBU3QfdhPYJqAR" +
+                        "iMXlyHwF/UENYZ+p56qGE7wQGeyI1dGKqJyoiKinUWtV4/sqNWBaiCxnd2fn" +
+                        "zzECCPCGwDf1kT53swINAoAlwV+pD2Sr+pjSaP8RnpjTHVaSeAnee3L5IFWE" +
+                        "4l3Lz3swLG5EFFnMQhlDPqQ9Alsg97QWD9Y8HhgkDZFHWYvH8EwXA3ODFDCN" +
+                        "h2/k2ETfteHUV6SufryXqktbnmDShvgMbjbE4/Ns7bP9vGbBxpDoWoNLR2LH" +
+                        "0byHX/IZM29tISjwLGshjFEn4eSY6x5/gyQfq2zivFe4WdORp9+lFN5gX/5X" +
+                        "5NmGxf652Akz9sAyGQvica9llq0WV/VaeWi5b0j4nvtSfzvlgY5PMNKuL++Z" +
+                        "vDOsLelkpv2MnX7ogRSwaoLHGWpY8KMdg9zSQ7g6B+qk/vvSB6kXlawzFnId" +
+                        "8AOfXubSSkCEx33bMU34OT3q8v3yCfU/59RuBVZwIruiHZVtEgABcvxGekQO" +
+                        "xPuLRbhVJfX98DbqhYJe7dL2DlFCr6dI5dxuJOvPyO44Gd3Vz9JaOh24Rc+Z" +
+                        "JuHpAHNN/g+MujdC2GWFo6JTV9V6bn2ojze2bj91slMzHlXUvWJgAYfG3LzG" +
+                        "HSFFYnKprEn+z8lWiQoOVQvxh2+xcRNNLzQ/rkptT4ZLmHArakxNus7OgAKS" +
+                        "ic8PXlnBlDsG1Ota9ih10NFPMZXhivmC7WHrxcwT3UXrsfEhzgNVcmr7safI" +
+                        "lIod/cS2wV34yXfyhRcVJDAXzm5M4jqdJ2nybGzSLkP/McLa9nWRA3vIykVa" +
+                        "++dut4ouQUWPFJitGJqM9QlnHdsweWsa//klIeb+Hke01T7e9fyjIX+fv9He" +
+                        "iY7hZAckyCREuFUiHV4YTxwl9gpp7JEnubU3VsRsc96/S5fy7l+5ApqRGKi4" +
+                        "pgLR7KC5F+QVpETlE0Q6Uh9SALmschGyovy6mu9bz9bHBQ7T+QFgFvSrnpXd" +
+                        "xH8N25foTUWQaXSKN/WcL809gOLhdv78edImQK6WYDVr105X4B83/qJYUSm5" +
+                        "mSn1jxvz8UOB/7Fvdepv68D38bPl4EeWrRMH+47h+s89/keSrSWAfEeyDvp/" +
+                        "o/pj/tZvyn6XzxL8ZdmscdvA366BNg+UDwDEvvEB/wY/8WT0NwkAAA=="
+                )
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+
+            val publicMangledMethod = fooClass.assertMethod("publicValueClassFunction-RVb1_dM", "")
+            assertThat(publicMangledMethod.targetLanguages).containsExactly(TargetLanguage.BYTECODE)
+            assertThat(publicMangledMethod.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.PUBLIC)
+            publicMangledMethod.returnType().assertPrimitiveTypeItem {
+                assertThat(kind).isEqualTo(PrimitiveTypeItem.Primitive.INT)
+            }
+
+            val protectedMangledMethod =
+                fooClass.assertMethod("protectedValueClassFunction-RVb1_dM", "")
+            assertThat(protectedMangledMethod.targetLanguages)
+                .containsExactly(TargetLanguage.BYTECODE)
+            assertThat(protectedMangledMethod.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.PROTECTED)
+            protectedMangledMethod.returnType().assertPrimitiveTypeItem {
+                assertThat(kind).isEqualTo(PrimitiveTypeItem.Primitive.INT)
+            }
+
+            val internalMangledMethod =
+                fooClass.assertMethod("internalValueClassFunction-RVb1_dM", "")
+            assertThat(internalMangledMethod.targetLanguages)
+                .containsExactly(TargetLanguage.BYTECODE)
+            assertThat(internalMangledMethod.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.INTERNAL)
+            internalMangledMethod.returnType().assertPrimitiveTypeItem {
+                assertThat(kind).isEqualTo(PrimitiveTypeItem.Primitive.INT)
+            }
+
+            // There isn't a private mangled method since those don't need to be tracked.
+
+            // TODO(b/407735992): non-mangled methods should be kotlin only and have IntValue return
+            // type instead of int
+            fooClass.assertMethod("publicValueClassFunction", "")
+            fooClass.assertMethod("protectedValueClassFunction", "")
+            fooClass.assertMethod("internalValueClassFunction", "")
+            fooClass.assertMethod("privateValueClassFunction", "")
+
+            assertThat(fooClass.methods()).hasSize(7)
+        }
+    }
+
+    @Test
+    fun `Test internal visibility value class constructor`() {
+        runCodebaseTest(
+            inputSet(
+                kotlin(
+                    """
+                    package test.pkg
+                    @JvmInline
+                    value class IntValue internal constructor(val v: Int)
+                    """
+                ),
+            ),
+            // Compiled from the Kotlin source file above with [generateBase64gzipFromKotlin]
+            compiledSourceJar =
+                base64gzip(
+                    "test.jar",
+                    // kotlinc version info: kotlinc-jvm 1.9.23 (JRE 17.0.6+10-b802.1)
+                    "" +
+                        "H4sIAAAAAAAA/wvwZmYRYeDg4GBgYFBkQAYiDCwMvq4hjrqefm76vo5+nm6u" +
+                        "wSF6vm7/TjEwfPY9c9rHW1fvIq+3rta5M+c3BxlcMX7wtEjPy1fH0/di6aot" +
+                        "QR+8dAu1vM6c0Q77cE7/5Mkzj58+esrEEODNzrFeWHO9JdACcyAOwGm9OBCX" +
+                        "pBaX6Bdkp+t75pWEJeaUpuol5yQWF9eG3A2WDhX5f3f2+rNpjbMvBG1a8M35" +
+                        "dku/2tGo1SJLFmztXhi6IvDUZaGyQ06bOm/6Luvf8zL+QbO+ld0Lbn6r4MaN" +
+                        "xnyPZtdPflzxLm2ygeJjnyL7c7b771t+Lz93d///v3/5Gco3Hp3wRef66avf" +
+                        "T1se/tiVtjTz6AGJI/NuGhWLXtZ8Pi/vfaSqfpuA846cSte2ALVsgw1if3l5" +
+                        "DTUKC468vHF7a2zbxUOs5yrbFNdve2ias9wmO/y1aNtpSeXoF66Z8yfen1p3" +
+                        "u+jyujcRvRJuEov4c45/E/sr0iU1yWOlgESqR4lSahQ3l97k5ZHro8/xHc55" +
+                        "ljSlu7FZ4bPUuoSYomWSauypFfcKnaz8vI5P/V9eE2u17+CCEpOEHVMkC6p5" +
+                        "rxfE/rqnYHjWzXJ9IsdhrZXVk1numN69O/VWnyiHxLIvK3hOynFnJkxdGhQs" +
+                        "surx2kS2SNHLM65OmKjdJ/MytfaqiXaeg+k0Q66/rPPP26UHzD5X9rb1/dKH" +
+                        "uS6qv/Sclzx7G8XbdsVVRPP+smmici6rHvI9Uzn/+622SGhLKqvrymc74hZH" +
+                        "fsrqVdBdKnz7vIH1grUp3DYTUvgltxSHnwrukzw8IfzBV+uiGcp9h+rOrr7h" +
+                        "l7c+9OzabavanKVvzjp57uCspzOtl6VP6g2PVqxS9uErtGzYVTv/jX7OzsUM" +
+                        "Ne0d9Va2O9Z9KlxXVFi14FI/t+tTr5ZnLGcDZ7VnPjt187r34+XsxTbnp00+" +
+                        "9dJRS2vHuc8LN8svTlTVUVq9KyBDfn5wy6r245HzbP+9vv0t0yljtROPZ/4m" +
+                        "w/tmPhyKbifUdm1b4rFWffcaLtXF7VNXdMytPbzjzDSRAzvbi6rvL2Y6wZco" +
+                        "oTlBwH/W1dzVH8/cWRexadPWSZGas3ij3zE/vtCWPu3b9TNVG8LNs866naxK" +
+                        "Oe1btfdlRdlVrVvrfJfzyy5/NnOer+vSpuJVG3vmTYrnjjq5y1VA9fTzLac9" +
+                        "czP7fPa2VHlw9yn1Bt6XOCRud6DcoSksROCnDtOH3U90z19ar2DWX6hpWsYS" +
+                        "a38oW6m6ZbV7xWdx+6J+ld7tf2Rm1OQwnjyrwOyaVtAU/VdiqfSMeQENOy+e" +
+                        "jLI/+PawncMS6ZRl1Wf3Kfys89Hn2DuB4fOUPPXfvvP/Cf+xdnFqv7z8gXtF" +
+                        "uuP8P3F5h3P37ltiyCb3n/1w7ilDIyEdD+d17yaGGDX+rtBXmF46Ma5w5oUv" +
+                        "nM+qJbc+/KigvPPTw6bT7OIHxJl3WJX2tK7svL/gn9WGsly9raeX/vI90FG8" +
+                        "UfvZVQfpdd9XH7qtq3zpB4N343fdpGnpH8MfzP5lOO33a1F+B8+fF1+tD19+" +
+                        "+kbDOa9kVvlvd/UX+v9piPiR3uJsu1FZ5dulyrVCPzQmWDW6//trYVb7Pb3C" +
+                        "77PeWrtlPw0de3VbeNZI/TjiwJi95Yhwc9bfl2Izus9v2NcaKD6rm1fcsD6m" +
+                        "ZGKpYKFgaeH97XcWlz9NOne0p7unO3tf4YmjH+pBpc6WtUpvDVkYGO6x4yt1" +
+                        "pIEYXujlJmbm6WXnl+Rk5sXn5qeU5qQmJyQkpAExS5Ifm0ZA0oUkBnCJ9lVp" +
+                        "z15hoE4JcInGyCTCgDAdubQDFamoAFcBi24KsuvFUUyox11OohuC7ExpFEO+" +
+                        "suD1doA3KxtIGTMQXgHSgawgHgAluPxSOwYAAA=="
+                )
+        ) {
+            val intValue = codebase.assertClass("test.pkg.IntValue")
+
+            val ctorImpl = intValue.assertMethod("constructor-impl", "int")
+            assertThat(ctorImpl.targetLanguages).containsExactly(TargetLanguage.BYTECODE)
+            assertThat(ctorImpl.modifiers.getVisibilityLevel()).isEqualTo(VisibilityLevel.INTERNAL)
+
+            // TODO(b/407735992): constructor itself should be Kotlin only
+            intValue.assertConstructor("int")
+        }
+    }
+
+    @Test
+    fun `Test properties of value class types and visibility`() {
+        runCodebaseTest(
+            inputSet(
+                kotlin(
+                    """
+                        package test.pkg
+                        @JvmInline
+                        value class IntValue(val intValue: Int)
+
+                        open class Foo {
+                            var publicValueClassProperty = IntValue(0)
+                            protected var protectedValueClassProperty = IntValue(0)
+                            @PublishedApi internal var internalValueClassProperty = IntValue(0)
+                        }
+                        """
+                )
+            ),
+            // Compiled from the Kotlin source file above with [generateBase64gzipFromKotlin]
+            compiledSourceJar =
+                base64gzip(
+                    "test.jar",
+                    // kotlinc version info: kotlinc-jvm 1.9.23 (JRE 17.0.6+10-b802.1)
+                    "" +
+                        "H4sIAAAAAAAA/32WeTTUex/Hf7YxsjOMpe5YMkfDjBCZJCTbiOwtIjMyZQzu" +
+                        "ZAhR1/rIRNlDlC4elQhDZrJFTMYQiowl+40kuxjb1X3OeR51nvp8z/u/7+f9" +
+                        "Pd/POZ/3edla8fBCADAYDACAIrC7IAAvYG3qaIy0tDHTsDa2sTQzdXBEWZtt" +
+                        "MQFg0ZrVetIKieoUtkIi2llvyu0PvtMenriCwlirW1p3Bjym2s9hkCQEhsVS" +
+                        "c55r12hpYY1NjE5wA7ZW/OASyQMl6J0HDu/I9qfPQ3dE9vQna/zufUnD0pfs" +
+                        "jCUGeKI8iFh//zDHQQd5J8j2YFZJGz48q8O+7MGKSX/UbXjTuSeQPFtvqIld" +
+                        "oV2chlWvgGALHH/4JCz4bV09/wXy0kvob2Sz8FJtka7D23DG/EAbHHu8OSN7" +
+                        "nfRlbbOdVuf/ZWtzFnaDu4qiIZuUMxFC47ihL+m5dRYdeiojE9mr87XtfBOZ" +
+                        "Set+6vpkvEkMZ5GCLJlpFmNeFAY1fZG5m6sIUhFJ0DPp7S91jRlpiAaXC/G4" +
+                        "+Qx699oE9xX3qAmla5tVdsSzjyjXqdVUNhW4sivlNIU0T8B6E2ba1jMgOvsT" +
+                        "7RUPsu4QzJnU5CyH3zMAfI0vul/obQblJapZFNdGqIqws8zGy8ymTwYzNKf0" +
+                        "UPvSt4bmA6ZWQQK9aREj9gW3wXLFI/SlGuPMzPgrbo0AyEliDT5V5UHXt6rw" +
+                        "UevQPDllZ5fkKp3UgLB6CVd17HdphJQh4JpPFZVP70UjSpad3hZVcXVbNKsu" +
+                        "Bb4krqAj+8iVBI1QDWE/ZUTnVVklHT8G4c4q1C4vlHJOmg57FKN/N/Ho7PNi" +
+                        "W0fxtGhIfuZYSDy+5YlOBDUlkGjYSLz/JSl7zijJIC9t4FJHu6vaqWC8kIlb" +
+                        "5PvZ19iYoD3XdEpw+rTBTYJvcB1Bj5romkmEFZ3JofmEwNlBAYYnbv+rRRHF" +
+                        "b5tiUFb3bCKBe85HaWtqaZjONKcxm6bCMTBoHDMV3CaQ+ech0S5WankJ1OyU" +
+                        "KD4oBymS/zBi+ijsyLqmnHODUlmRYPTKvKxpYUhQygQ7+fRQpY3kcRdpnFFI" +
+                        "cvxapfFxsOYJ3c5SFVMCko11UpU0KDph+vmzfLPnY3IY3egh8sOMwW2EgksU" +
+                        "ttAIcdTH+XlRs7b/E1xLVw8Gn39Zl0gTvcUznXO2z0Vz+qWba4mOvMp0KfLw" +
+                        "VEXBGNvpyeUXutnHyPcyL4XoOqUi2h+91grBbOlcVhGEGqeom/ZN5D07ZA6/" +
+                        "HhliIZjwxusWp1msdo6rlkeC+pDw+qr4H0MqfsFp1wVKSbesHiUqT3LE3STZ" +
+                        "yucNGrLqVhNf7PeqnvhYP+4taOELklXVipQc+NSkml2/FMPNig/s4Qj4wlYA" +
+                        "pWwFh2zvFd6Wrzi68eRN3rtO9GyibtiCxtysmMA+m5wI2Eg2OmzjGk34+VLf" +
+                        "A03Qb9v8kUimuJaEuoVJ8ZdER63w9SANhfSARDdSRse4AP6FbMXwvIIybWEk" +
+                        "ohUKrf/IU3WEdIt2s3Qod6vveSASVdGYz7Guj/WvVf6r20i++OvjBhekctcq" +
+                        "IBj+FYlLuzSfPizP0ZS+Ni3FSBLFMOuc/Wr6XJs5ZGe523PYN5sSnF7R2Ogb" +
+                        "ZnrvpPSP4zTuvUeEM8LfCYSOD90eo81uyep6fcjtlswUjkD5KV0c9uDh41EL" +
+                        "wlgVya3y3veNoJ1p5MBjXC+jcmixa2PVlCJKLKWQsl478VuNGlQbVXD+4vnz" +
+                        "i/E8KNA2z7f0kb0QVY3mBYAl/l+lj8Tu9DHz8/tP8MQ7Dp3qd4ZsFS82JmgO" +
+                        "zykLW+amcEdCLNyJM3QC0vPxxQMzCF3P1Du66Jt8Ma8SQv1krrUWeG0zOAPQ" +
+                        "PJunKwdN2f1bhQRGoIXs3cK00PYaxtDal6vtNe+3a7en/YD+1SRjSWloU8+8" +
+                        "8fyjaaa7ECcxGCctX+Bvu1EQcrE76paMyULuTO+oWkwvk2Bqwm0pRXotNMUV" +
+                        "PhIbx77somX/yt5/H6o60LrqA32QqCMzqtb8OBfLm7lH6k8htvOLvmfexl2+" +
+                        "jeMb0R8r1U9tsOrBeiIGfAJeMaGt/nwHSj+dLpWDmwxATNoDoybQeOU9aQLY" +
+                        "wxaxelR045k13Mw7ij5/WhApPm+5BhOwyOCUP+ACYdfEiBPUNYepJT11WoOC" +
+                        "4f4ljvKnD2V1r5abQs94Zojyi6SdUTIb6yszFEPN51ZxDf1lPo/MTBjb49BL" +
+                        "bRV6O+Fx+hDx3zLkKNi55ew0a2Hr+4z7ZxuKshry7r47erNzxKPWcg1E7acW" +
+                        "kwnr5RLxn7KEBn0vYVLLkhBTgwmIA/Z6dodUkmcCK/MkriVN1mAwdOrzAsYV" +
+                        "+wPX6/qDB2aqP29qrbzR75m5g+V9LRZ+RPy0BD2Fombp6harFpfT59JhvpGX" +
+                        "XjO0xf8+TI+rAtCTAxjHh2cT6+eBwulHH0q6YjNtQ26wUmWmqmfelzZtfIK3" +
+                        "ni4GL2PHQ6tJ6pMPPtMDKNhqon7PYmA5IXgooxtkCmf6tg2B36x83HzAqehe" +
+                        "KMq0NI9EMdz6xQPfat2TzOpfCvs42lM4RPcpwRtUbFZnHKNe4YvtJ+uMvtuW" +
+                        "CaYHHUraoEitnhyWQkQXG7B9MsNOkR6LlEc/t91TelVmXVIyzHDwK7tcYVO7" +
+                        "TBbDV0NS6lDwiJv07drwjyMoiuPvKN83y6mNokA2y0c+Sn1wH13+Q12WNxma" +
+                        "JBk5fpa1nAwTO7dAij5qqU9htUfFXq80pJtWaCUdhh3AccrA6OOvIDra9q+W" +
+                        "PMUXbMW91E/EvXaTzj0ROGpDjf3sKc48KL7Uej6PpD4sa7r6rLx+UPDz5rFO" +
+                        "e6N1U3fDfJVwmCr9ZMQxtjmrPi7ciYdvIF+xR6jIwwN2y8EzPywPfWVv1l7L" +
+                        "BCGGNEOJwc2wtjE8xyJN7k3eu0i2QTejF/aWb3N928pCHbqXMw8ANIN+tZXy" +
+                        "O/ovkvhgvXxR3n5kopfvBR+/iwFETw93d3f8jnhxNiBVW1wHDviHN5aVqmsk" +
+                        "dzpl/uENLm4I8D/33SzyDXi+r5/hz48uuzMF+p3DjZ9TzI8mu0cg8Z3JJu//" +
+                        "C6Mf+3d/U/67/mTwL8dma8UH+naNd+dAuABg9psf8De6dQ/VGQoAAA=="
+                )
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+
+            val publicMangledGetter =
+                fooClass.assertMethod("getPublicValueClassProperty-RVb1_dM", "")
+            assertThat(publicMangledGetter.targetLanguages).containsExactly(TargetLanguage.BYTECODE)
+            assertThat(publicMangledGetter.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.PUBLIC)
+            publicMangledGetter.returnType().assertPrimitiveTypeItem {
+                assertThat(kind).isEqualTo(PrimitiveTypeItem.Primitive.INT)
+            }
+            val publicMangledSetter =
+                fooClass.assertMethod("setPublicValueClassProperty-Vxmw0xk", "int")
+            assertThat(publicMangledSetter.targetLanguages).containsExactly(TargetLanguage.BYTECODE)
+            assertThat(publicMangledSetter.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.PUBLIC)
+            publicMangledSetter.returnType().assertPrimitiveTypeItem {
+                assertThat(kind).isEqualTo(PrimitiveTypeItem.Primitive.VOID)
+            }
+
+            val protectedMangledGetter =
+                fooClass.assertMethod("getProtectedValueClassProperty-RVb1_dM", "")
+            assertThat(protectedMangledGetter.targetLanguages)
+                .containsExactly(TargetLanguage.BYTECODE)
+            assertThat(protectedMangledGetter.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.PROTECTED)
+            protectedMangledGetter.returnType().assertPrimitiveTypeItem {
+                assertThat(kind).isEqualTo(PrimitiveTypeItem.Primitive.INT)
+            }
+            val protectedMangledSetter =
+                fooClass.assertMethod("setProtectedValueClassProperty-Vxmw0xk", "int")
+            assertThat(protectedMangledSetter.targetLanguages)
+                .containsExactly(TargetLanguage.BYTECODE)
+            assertThat(protectedMangledSetter.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.PROTECTED)
+            protectedMangledSetter.returnType().assertPrimitiveTypeItem {
+                assertThat(kind).isEqualTo(PrimitiveTypeItem.Primitive.VOID)
+            }
+
+            val internalMangledGetter =
+                fooClass.assertMethod("getInternalValueClassProperty-RVb1_dM", "")
+            assertThat(internalMangledGetter.targetLanguages)
+                .containsExactly(TargetLanguage.BYTECODE)
+            assertThat(internalMangledGetter.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.INTERNAL)
+            internalMangledGetter.returnType().assertPrimitiveTypeItem {
+                assertThat(kind).isEqualTo(PrimitiveTypeItem.Primitive.INT)
+            }
+            val internalMangledSetter =
+                fooClass.assertMethod("setInternalValueClassProperty-Vxmw0xk", "int")
+            assertThat(internalMangledSetter.targetLanguages)
+                .containsExactly(TargetLanguage.BYTECODE)
+            assertThat(internalMangledSetter.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.INTERNAL)
+            internalMangledSetter.returnType().assertPrimitiveTypeItem {
+                assertThat(kind).isEqualTo(PrimitiveTypeItem.Primitive.VOID)
+            }
+
+            // TODO(b/407735992): non-mangled accessors should be kotlin only and use IntValue
+            // type instead of int
+            fooClass.assertMethod("getPublicValueClassProperty", "")
+            fooClass.assertMethod("setPublicValueClassProperty", "int")
+            fooClass.assertMethod("getProtectedValueClassProperty", "")
+            fooClass.assertMethod("setProtectedValueClassProperty", "int")
+            // TODO(b/407735992): name in psi is different between k1 and k2 (k2 has mangled suffix
+            // with $)
+            fooClass.methods().single {
+                it.name() == "getInternalValueClassProperty" ||
+                    it.name().startsWith("getInternalValueClassProperty\$")
+            }
+            fooClass.methods().single {
+                it.name() == "setInternalValueClassProperty" ||
+                    it.name().startsWith("setInternalValueClassProperty\$")
+            }
+
+            assertThat(fooClass.methods()).hasSize(12)
+        }
+    }
+
+    @Test
+    fun `Test multi file class`() {
+        runCodebaseTest(
+            inputSet(
+                kotlin(
+                    "test/pkg/IntValue.kt",
+                    """
+                    package test.pkg
+                    @JvmInline value class IntValue(val v: Int)
+                    """
+                ),
+                kotlin(
+                    "test/pkg/FooA.kt",
+                    """
+                    @file:JvmName("Foo")
+                    @file:JvmMultifileClass
+                    package test.pkg
+                    fun fooA(iv: IntValue) = Unit
+                    """
+                ),
+                kotlin(
+                    "test/pkg/FooB.kt",
+                    """
+                    @file:JvmName("Foo")
+                    @file:JvmMultifileClass
+                    package test.pkg
+                    fun fooB(iv: IntValue) = Unit
+                    """
+                ),
+            ),
+            // Compiled from the source above with [generateBase64gzipFromKotlin]
+            compiledSourceJar =
+                base64gzip(
+                    "test.jar",
+                    // kotlinc version info: kotlinc-jvm 1.9.23 (JRE 17.0.6+10-b802.1)
+                    "" +
+                        "H4sIAAAAAAAA/+2WeTTUex/Hxz5Xg8HYlzBTyTBEkp0YZaaxDNkymEjIPkN2" +
+                        "KSl0SYXKkkRlD0OJLNli5iG7QZohBsmSKMp16Z7zPHieuuf+/3x/5/M753fO" +
+                        "7/v+/n6f1znf78sMzcIKAQCBQAAAIA3YPiAAVgAGaamvYGxipIjRNzE2QlpY" +
+                        "IjBGf7QDAEsYCvkkWgHRxYVWkOugdJZjlXpVaBP+CBRG3hjTFZBPwi6gFPzk" +
+                        "UBQK3GqhQ7GtjTI+MTbBDDBDcwBL+A+WqG8uoLZZZj9dnm+ziGcJREXf8+cU" +
+                        "jXx8EM6eeALhd1OyCbM+uJBecYlsEXaRR6u9QR42qhUV22bU23Tnpa8Uy3WX" +
+                        "wVbhQL0IctoijeOreYukUpchj0N+wfkX+aGjug7vAOn0Ow39Mv0dD3X9EMll" +
+                        "9cIoi1qaSf3DWIJmelxS5Y2cKo5cjcejymEeCuExvbHDn4Xzdd9eZtJnxE0q" +
+                        "iLm7+A/qpUhLC4EouOPEOmhEaHXL6adJaqMyKNBEZglRCsqwc9OZvHffwuH5" +
+                        "ie5lil4/QHZUDYZMRLvbxA8+x5xzeFLqJLviAvOepJtR5laVpHK7LaCSQWH7" +
+                        "MRv7+ucmk1IeLLjIG08ZJnXbowWa3aBRt6nICled42ieJwSKf/702h7/zgKG" +
+                        "wSsKyuWoDGmAZRDGrszYOJy64ezqBj6SZzV1r0jnJiIfUYmbdRpolvRAzAzO" +
+                        "Q3kb48y/sm61Prplv6YmEwAwzfSr1ovuar2j4+ZNH038CwHGFOPTowcOL188" +
+                        "7sEcoHsRpkcHHmt+NNbCJJCDEmSC6dW+N/O6mTs0VFowu/+98KIpba+vgbgZ" +
+                        "xPu7bFNhPPhquMrSKKWjxrGubgOwwPoF+M1KJM0ecq7NGHc/U1m8jiR9DXyf" +
+                        "fOUkyjZjn48Rw4PiGf9mtV7i6qr/2iGcIOt8xIrUAeBLKTOjQRFIhUJAcg3W" +
+                        "yiQn2dQ2HWFXkyDuqQ74IohYtLX3SM1Nx0jyZxZZ+5EckDKCmKm4EyRknViJ" +
+                        "dXhStzl4T0LR/XduL4fCfqupFPqWZipz/fvK5JI+ai4NqkPGGXt3jdLuNxSW" +
+                        "Vckz2jNIhz0nIj9EvwmOtLTJjDA3heBDs+DLIToSedRQdbm7VIleZ9tJ/0e4" +
+                        "9dTro31LVJsMN+vPox3wgsdyA0blIfanKpKtBpJjLYBBz0nvLideHFcoljwC" +
+                        "qisBMT8TuRyz4Hu1lHBQxrC6i0d0dhzRyqD4+F04bAhvTAZlgKz9FBqPjIE0" +
+                        "ByUugVae6ho6+b6lxei7+fbUq2n1q06tM20xFciCfbq+yRPE/I+ZHvt7pub/" +
+                        "Z/pfTNdq8j3gRcVw/sfgBV/3Oo69TK2n7bU9hSMcRVi9Vdi56HRuZwbW8Frg" +
+                        "w72HB1txCa3/mGla5MTy3zMV2s7U2JtohfcMOPsX0HDLtxZipyAbb9NK/uUa" +
+                        "lfYGW5a1YjAcnbi/2a4AkpNVEf/g1BPz9h6+wFfHymKpmEeJNdOOtMuKGmu0" +
+                        "PTwaFlGlKtxjaZG3xoPmXG8pSY+f9Nft0GZc6FjNIKzMR0ZusNTjPA/BtMnL" +
+                        "/svr/h2+Ndm27naHlNhLz1VS7JuJ7VWPh0Ot2uKlm8CI0w5J0rfbREGFyEgD" +
+                        "AxBKXNwvZCXQKxVP8mUiZOJfF3gFcQ0f7BzqC7lC9295LRjiMOSTcyHXsXKE" +
+                        "BNe0gsbwxkyxDJe+ROpGZ8fAsHKsRiJ8EqZ3+y9dIue4939IKW9USquamsge" +
+                        "r2+riYELp95xj2nT5820Tr8RdwvrN7Eh4Jga56MkK8EtjDjL7lJCFy1GvxUz" +
+                        "fESVZaiC8Db7An34oqofVVdjh0uZmRshksnSVANp7sIyF484+wCSKkWq4Ixo" +
+                        "uajyp6YkaG1hyT3XZq6sFmWjB3W0JSoD5NFDLX65UHG45vcnpFoyOC+42uqy" +
+                        "dEBX3B0fAzInD3OfLweBj7EeyIkUwNvqm+erFw+4pdTYQYHo6a8rUAq3G5zK" +
+                        "zAMbNGD/aI8KjjvkLKzM5lAHTVV/JTs7UBP38f2KXd+IR4HHUWJS0d1ZrULb" +
+                        "zCrnkP1tQRUC2SJ4/1gyW+/Hb7BIPFlMnabJ+r1nuiEgOZGQHN/DkhxhLytn" +
+                        "LUM64JbYrXNS07qj1kFUV/vOeHCl1s04zuKlsKnZVjeb3+Jf5yMgL1oZkAcz" +
+                        "dL+Uc4kba5Xr98BD+WADbJoLJZXr1hUwFMaPs8Xm9N/CWV6R6WpEWTZ11OLt" +
+                        "Y1DT4yO3R0a/XAunSoKgbGfoxuUvvFQz7w4LoFMqrJThyHI8OVRKfGiB0v3H" +
+                        "PVueuRmjIqqsbaJnsHGJmkRnsR1yuGJ6+cF4r1ZPeV62pZcJW8qoxScL/QO2" +
+                        "JGA2bDXdW91Y/mNSXqoZz3S9eY7qzB712gWuMDbYlGHfDRVe4Tq06CeFdc4z" +
+                        "S8KpWOfjb5ahNfvLjj8PiVaLXNT+otcdRE6MajPeo+fNziurfIl/ZOaZ+YsE" +
+                        "9wjmNLGMJ8v8IzqzKteIGRRizyzh5vyzafUHi0DPTGxgGfXztG5DnQGMeDSc" +
+                        "MyL6guDntvkJ1ZHJD2g7Z9pipNJIjDhU+i4b/nWPdjaK3XfvPButDIGFI1ju" +
+                        "6TSEKWZXBmtdO5EZRmiYILFNxkdVaQRcv5IX+y7rD42ngV7yFfG5a5h6IKEU" +
+                        "Pdl3Uaz4S/mrYQVo91cAOmpFYcywttkxymem1WauxFpLCdWuaBX5UgPXwk60" +
+                        "EoV/fapYF62zyHKGfp+Xe/l1ApiKZlShaA8vzrBKrq76ea7NdC6kr+A0wk9+" +
+                        "c1ZWrQQrP/Wg8bOwFXbxmoLylx+fdkLoNK4JGuHcEEfsm74HdCH7kU3I3uZw" +
+                        "R//Eyfbm9HgRIRGhgTD6jXj6xg8ts5zmFVZkBQCGOX6154ht1r+t0Avv7o04" +
+                        "70P0dPd29PJxCfA86+zk5OS6WaxnTNhlad0TY7LGm5YIf20iNBZI7kxM5OBL" +
+                        "GN0HTLh1IRbCD33Ip3KjqCmrGfBj/T7FsZItJTz+QwuZmCGA/3zBdmXc8tKd" +
+                        "42eWujtlu/3w7UiI/J+yuXv+9pNWdMf8NaZfGdPunO27+86cDpZfndK7c7YT" +
+                        "E9qRk83205Nhd8j2tovtCBHk/CVqMzQb+9Zr7JtXzubfpHBuPf0JTn2S0FAM" +
+                        "AAA="
+                )
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+
+            val mangledMethodA = fooClass.assertMethod("fooA-Vxmw0xk", "int")
+            assertThat(mangledMethodA.targetLanguages).containsExactly(TargetLanguage.BYTECODE)
+            mangledMethodA.returnType().assertPrimitiveTypeItem {
+                assertThat(kind).isEqualTo(PrimitiveTypeItem.Primitive.VOID)
+            }
+
+            val mangledMethodB = fooClass.assertMethod("fooB-Vxmw0xk", "int")
+            assertThat(mangledMethodB.targetLanguages).containsExactly(TargetLanguage.BYTECODE)
+            mangledMethodB.returnType().assertPrimitiveTypeItem {
+                assertThat(kind).isEqualTo(PrimitiveTypeItem.Primitive.VOID)
+            }
+
+            // TODO(b/407735992): non-mangled method should be kotlin only and have IntValue param
+            // type instead of int
+            fooClass.assertMethod("fooA", "int")
+            fooClass.assertMethod("fooB", "int")
+
+            assertThat(fooClass.methods()).hasSize(4)
+        }
+    }
+
+    @Test
+    fun `Test hidden deprecation level with value class type`() {
+        runCodebaseTest(
+            inputSet(
+                kotlin(
+                    """
+                    package test.pkg
+                    @JvmInline value class IntValue(val v: Int)
+                    class Foo {
+                        @Deprecated(level = DeprecationLevel.HIDDEN, message = "")
+                        fun foo(iv: IntValue) = Unit
+                    }
+                    """
+                )
+            ),
+            // Compiled from the source above with [generateBase64gzipFromKotlin]
+            compiledSourceJar =
+                base64gzip(
+                    "test.jar",
+                    // kotlinc version info: kotlinc-jvm 1.9.23 (JRE 17.0.6+10-b802.1)
+                    "" +
+                        "H4sIAAAAAAAA/31VezgTbBsf5pDzYXKuly3mtDm8kjNpK5uJkUwOjQgv5rAp" +
+                        "osWLq/hKkrN8bXmlkuMoWc7KGEL0zlTTSNMqEjnmVd91fZ+6vrqf6/fHc13P" +
+                        "/buv577u+/dzRQsBQQAxMTEAAKAJ2B4gABCAQXg4GDq5IOEYBxcnJMLdA4ZB" +
+                        "fukFABYwzD5ntCFsSAptqDfAHKzHGj015UzHwFAYAyfMEOk2DTuHMozWQzGZ" +
+                        "+p5zA3AGg8mdfjUtCHBFi4pVK+hWW2wVMN+C60/LK22BGBRLhEf9cRLuFEn0" +
+                        "xIeTgmCB4fjY2CSP5+5qR0Cbz4ur+4OTi59g664vObJTs7S7ve+Ayq43ZFKO" +
+                        "VLj1jsjHdeyvu8DClGfRef6cP+GWqxwJGUv35FpT6VfF5Bzu6ffBOUaaXOcY" +
+                        "uwGbmVMDK9dilz6QyZtCbb7hxhCbvsWYxY2YgSg6FRfqbWwkUnuykenTText" +
+                        "usk+48nI1OyShR3zy9a8ylCVrESQHR0lUerq0QlLcRH5eFqUQGwpvudOxGkp" +
+                        "tu7g+GhC2mTMo56dCX7jhLJTf/k3TtD0rTzB6XLpb4TYtQ8RdqnUdAhWD4hU" +
+                        "kdc4XDiWktJXFjr2Nq++06i46c00ldvGoKfrK+cXhKYzHORKj5ZczsjBRk9v" +
+                        "KvrnZxCMoBrSyrAgkRPVk6pV6OdqB8pZ0BkzSbzXnjiCfHJzeXMzll0rKNgJ" +
+                        "2pWryXLUlK6sOxGW4UOimTF/uxOgWq9q8rErG9xSWV0U3C11/ZEJktLKWWDN" +
+                        "SIaNsKoezjX8Tr9YQWvpk70V3+z5pyZpKKOA4NgnLiM4GiUaKz+zESeOUMTj" +
+                        "HNxuW1Q9C8mje4PF0LzlJTBTOkSfJSgD+dtR5J0PKj7DOFDZRNivFZxv0QHl" +
+                        "P6NnvJta8h6dCLsTto+YfbeQb12JK20KTNBmnG5QpKrgYy70CT99twYh4/vU" +
+                        "LDhWwPURXjspNys2N3NEKPesD1TvqBZNJyRr2NbZ6uhAi5+qnU0BN77R+kqG" +
+                        "eNVC4hv+4xCvHZk9t2GgB49nQJTZyei8k1mbq40bRbLjt2UdscUnmPlSOWmy" +
+                        "YIiCLw5bNpbj65GmNdSJ8ugaaMH7pKN43ImrEy8+n09i7ZIECwdMOtU/iDAr" +
+                        "LWQrovMaPE30EfX4vjO/qY/PMYe/FOFk3s8i77KguKzweKdqc43BKm8Eu4G3" +
+                        "SOE+tR6pv0X1iHARznvh/tHdQQdHE6NCVkoiLZwM3mXfyneV4bW5lZnNSli0" +
+                        "zEklCkPeHBi9bCqn3IpW/Wi4IR6woJyPDTz4ZBFM1647eD8h1Zw8b/PZfvh0" +
+                        "X1Yyw0nCPlJEDmqSojAxe8/twaXQs4LFatcqFhUmbPmm54nXmMQRfuyVD/d4" +
+                        "FpR5sfBSbFwd6xPPrr3VEULclyR+NvXUzk+MD9NmE6/for0DOfNko4l0dbBm" +
+                        "oTC+Z8SGihKJ2v1BmFMHw+rDhIps2xPh1MZ46/OHShNj26dpwq8zk5ssSf9K" +
+                        "u3Xh5fUvljVxEQYNmX+tYtrEYmvRr0fPqVV9ru9gG4KHlwHo5CXDVwdauv2T" +
+                        "CbOPvd5XH7U2QvXCPckPLX0fiRA9VfWXa+CtqbbzQgGT/5aTXuy5JMtCzzSh" +
+                        "ODfOzQJ3raxEh6/ODs6VLPlaJjmvBZqYNcqa1IRxFISEK4fkDkveXrx57DjM" +
+                        "tnN1J9I3BLbXp2udNIQYQ3QhnnYn+cdkve7tLslUUVJRepY4eTlzcvOb5njw" +
+                        "5JThQACALforzZHfrjlIAuE/cuPrhiGM2MsmNV+ym00dC71OE+g1hxzi/J6i" +
+                        "ILYD6nZxfzYAt9+miYFtjObrNe+wQa4rLIuW2Ku7giLXoV2VaAHSnsGW+IVg" +
+                        "+trSTDXhpcAEIodCTRuebD8O5081STyS5evkQJxzwuGJtc3whPG0bo715cKn" +
+                        "MiqVSNOqtnTuDWA+peylU3fN3xvkJ0npH9nWrRq7pV/ekxYtCzvQX0AZ05iy" +
+                        "zMXd15VGUvNDhnRuWYFQe86kCEjG6WlrBXlZ6ebGj5ntCYtqpPb332RL+rgo" +
+                        "e3W52njaKVnydCw1FXe7GDzQNsW3A4sG3hisuxZVIipa2+eC995dS8xdsy7A" +
+                        "JL1XaUsSkpqZH2XR+o/xa202p1yncTY1s/QjYVbJmOb66S/LvcHuennW5nOv" +
+                        "d99/y36xzk3ILNxNYxjHdPhsVDu4lXMhGhLcYeMW0ydTwzn0wzADUpB24+NO" +
+                        "X+OEa/zyLoNTC35XHjEOFa3L8DZNs/kJFgM09QwvPafRg7i8tx2mCWqbR2x3" +
+                        "LR44WC6oxvkUGRwduFc946iuxEULGvteS9uaz9VqN6L4cAcpIxcssJMj5KAY" +
+                        "FFBJXfGj6JAP7x1HcHvd5itq7c1Kyk/f6IkcvufM0sUa6hloylbIdw5By311" +
+                        "QRrYEkq8vlWNVsnFGlW8FClln9KkNYx/TreS+0p6Jyix6AYH6qNnj5ms24+j" +
+                        "fFT7Okz18RsrUoIAwJrgr4ZJbQv/9c8IfGgk7A8CMTw00j+CcIIUHhR4/Pjx" +
+                        "4C0AA1xEoK4BTwIA3wZ1UYv+UGErU/mbOQoIggD/Y99unF/d+fv4mVf/yLJ9" +
+                        "FZS+YyD/3HJ/JNneAvnvSBaA/2+Hfszf/k217/LtRX/ZNle0sMjXZ8CtAxIA" +
+                        "AEpEv97+AaE81ZDGCAAA"
+                )
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+
+            val mangledMethod = fooClass.assertMethod("foo-Vxmw0xk", "int")
+            assertThat(mangledMethod.targetLanguages).containsExactly(TargetLanguage.BYTECODE)
+            mangledMethod.returnType().assertPrimitiveTypeItem {
+                assertThat(kind).isEqualTo(PrimitiveTypeItem.Primitive.VOID)
+            }
+            assertThat(mangledMethod.modifiers.isDeprecated()).isTrue()
+
+            // TODO(b/407735992): non-mangled method should be kotlin only and have IntValue param
+            // type instead of int
+            fooClass.assertMethod("foo", "int")
+
+            assertThat(fooClass.methods()).hasSize(2)
+        }
+    }
+
+    @Test
+    fun `Test propagating PublishedApi from properties to accessors`() {
+        runCodebaseTest(
+            inputSet(
+                kotlin(
+                    """
+                    package test.pkg
+                    @JvmInline value class IntValue(val value: Int)
+                    class Foo {
+                        @PublishedApi internal var foo = IntValue(0)
+                    }
+                    """
+                )
+            ),
+            compiledSourceJar =
+                // Compiled from the source above with [generateBase64gzipFromKotlin]
+                base64gzip(
+                    "test.jar",
+                    // kotlinc version info: kotlinc-jvm 1.9.23 (JRE 17.0.6+10-b802.1)
+                    "" +
+                        "H4sIAAAAAAAA/31WeTgU6hofW0aNfZkxJabsMTOUY4uyz9gJyXIZY2lixjJj" +
+                        "jeyyX51cWyEnlLEdKhzrVCrLIMwgocmaPUuGujjqPs+96rn1fs/vv+/9vc/3" +
+                        "Pt/7+72WJmzsQgAgEAgAAGCAwyEEYAeYGdjoKKLNDRFmOuZoQ4NLNnAzw70u" +
+                        "AGDDjNptaqII7+c2UZTvpfY9skbSzjJmAuDGZgpos/5A8mPrj8aK/vLGVOoZ" +
+                        "u4+9iM5O6tTM5AwrwNKEE1gtKFetflBA9QCWPy0PPgDJg0hC+Hl7IdAEkh3G" +
+                        "J9ADjvXBEIkRNj3EtzZ8+y1ziCt2J97gBu25XvNeXQ6nEWRLMqSL0XK2flBU" +
+                        "Mowb/KJfzdjnjX3tg1djDASDwnGExykgShSlTErgmk9rS8KMyHQGvVxD3g9d" +
+                        "XW4df7eyF1S4t8f85wWWsRfZILlh0lg4tu33YXy9u42jJyhVZ/zsqGHrtZF/" +
+                        "/Xt0q+BKEBaohBIerMcAPYgaesXLJqaX+WKFOI3uwpZWHHieo9ZYt048z3B8" +
+                        "53cnyzm35lqa/POZioIzW3/sBLsHl7jU02rJmp5nEzAJH9i668Y4EGm/xwgN" +
+                        "KNukIkHBpzxaqLNSTtLe9/uRy2IJuUsvUOBYzuhZIaenOZQepCmoa735fQPy" +
+                        "Ll9C977vdiMyPLZh6SPFT04zioVj2M95ZEJCN82z5J4rEJ0LaUVLrkB7VwIi" +
+                        "XoFQoEthtHQb3vgQ5JmYSvRReo0dMu1uqhxVtiNZ0KgAhrlBVyabA1Ty6Cm7" +
+                        "PYXdWl4ZjltBu/FeJQy8fjzTGRrd2OT9m+gAuCUxVNyBFMr3MEYzR1ht9YtU" +
+                        "pnucAZgeMB405lm+NHRHx8Fapi4bQ6BcTVIKkaCcHDhfJ5pJ9BCW7auoSlEO" +
+                        "mUq39+R60OASXJ6V/857eP3Mch7htoThOfpf9irO2Fd+3ANrDpr6vglJUnAR" +
+                        "y8yIgbY/4/RZtnlY9klhfs6zWKfZhfloU/HLUrkm/KOCj41wFgO9JY+qwa/M" +
+                        "eT1DoxW5H9yXHw6Bkbaw5xTi6R3JpcaSr7ykbIeeYSsoBc2fh9rMHnYlk3m4" +
+                        "vAeULLIleW3FpPNH6SW0zTByiryVtIN9MrnmkS8EXGa9Y3PxD72J5YhsDQnD" +
+                        "uALLW/Yho2T8nR6vl0F0ocrK7LRrnVcddHky9Y5XWU24qECjFXxpjj21OyMC" +
+                        "up4tHk12PQpX0g3qefFNK9AqA+eSdOK12sQCkTaQRtJLAz4ps6TiZomsrY5p" +
+                        "3wzeecqaeqWVReda/BxDVEJHZiEhBBy90eQOW1FGFBFOTlmHbQLzguKGaWP8" +
+                        "VSff97g0d2hlgCbWA1wnn3BIqMaCJG895SJ8+oIap2wmsBYez694IjimvURM" +
+                        "JMWaBncvHbP+wJznKJIR2K6wCnQbeVzWRmnTkySpBR69ERc8+yRpNR6ytTNa" +
+                        "rHLk5D4nWjwgM3NapBhmzkyUv0WJaAZHpbQCyxtQVxfYiS2p4cyQjFtqoSvy" +
+                        "YATczwU4NtOJpVqk7/PsDEe3bNRMw7OWuFlOU+PhuZfZCA1DfUeZRoY9DDaF" +
+                        "I0P1iYL+4Eiu1jIxbFmbi7/CdXO5teGF1cteXSNRnV0Mfu2lckRR2n6U/bZX" +
+                        "nJ5W7Wn9rcnQKoGQE5b5FKN/RJzo09ro+9PgCzy/4HXV7cUuEV0N7SErWk3y" +
+                        "A1J7XrrFx3mRnNhAHx9Me/QkIzc2px6u1qGeqJao0bCKW+lvCkAuuo7qDD1V" +
+                        "sVCfltgR/6o+F9O9stXZAYBFzl+pj8Bh9TH09f2P8HhYv7MYtIRoMeveNhJS" +
+                        "CRSInhWfsDQ2dts1M/EhDKdMu3fFNAQ5bldU4Z09rjnt/7nwwyOEJDSJ1zPX" +
+                        "d8/qZfW4xOmt91/8P+cTLdreXoiM3GP1Ez8OQuOOXbmmymvS1CrOhkWmVwqW" +
+                        "TztMYOY9lkequiFCCR+yptTXlWJrax3MTsU85BFWStgsiZrvJM8ELUMmi62Z" +
+                        "WjDN8cZNTYMH9CBRmjCRbnoquphHTFDy0wRTFIK5jZxkoAYzzgew65GVVxb5" +
+                        "WW7WFZMbXCrxzd5L8dqmMS/4qgrqtDMt7jzXI4NqFMOsxqTbdsrbPbo3wnHo" +
+                        "m0tKVJu8VpJY9SbZkSjm764aNMqTn9VKYfrgVBRw/C8dZY7i0zhgJ9kzgjVu" +
+                        "FWroXC4l6xwL/NKCy59r6E27YTEHFf/N4dzwKn5d+TpUNDwpIHa1WtS4IJvO" +
+                        "uTtx+8bqMgO7wFRfZMoioR0Czn0PHdoZobYp0Bop28HUbYagxQd+/MfQIiqK" +
+                        "qKRGvM1hXiq/P84Wau5EWzRDN4XOqvokdCZPvUE0VuaNh2LpTrrKwm2Ev2zL" +
+                        "p9h3gbTCt8vpzvXF464571bDBnBvSoMngTcnVlOrrSKXgzUDrw9zhRDv9y9E" +
+                        "xo7c07R7/mKN0VVmXVYameQW3Yh/Nu+NtNpmqbx39/QnsdyzrGorVqYw+8e6" +
+                        "ksLoLm+a1E12U0xeAPRsR3q78dNdy3ShVtjGJ2tJaMwCRD0AXWBA0L+BGjyf" +
+                        "A6e61CB7e3lkDJfu5d33dduUmSuz083nAokHiZS6QYaNdDeKfORSy2UvVfGF" +
+                        "pYGcL0S5uT1t5xZUrUFJZZmOPVtnyaHgx9Qv6ro6MKou2rhauxpIIJCnM4Rz" +
+                        "hDu4IPvfrLRbX1M7jRUAmGP71Wc+foD/OjkegyPAvX1JPjiCC97XPdDHA+vq" +
+                        "6up5AHY38yOylm6v3QDfuD+dam4RPMiEfLNpFlYhwP/YD1v41z3h+/jZ1vAj" +
+                        "y+FRBH/HEPlz8/+R5HALBL4j2WX/fzP8Y/7hZx7/Lr+L85dtszThOPL1GvvB" +
+                        "EWIBAKS/8gH+BkSorclQCQAA"
+                )
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+            val property = fooClass.assertProperty("foo")
+            assertThat(property.modifiers.getVisibilityLevel()).isEqualTo(VisibilityLevel.INTERNAL)
+            assertThat(property.annotationNames()).contains("kotlin.PublishedApi")
+
+            val getter = fooClass.assertMethod("getFoo-RVb1_dM", "")
+            assertThat(getter.modifiers.getVisibilityLevel()).isEqualTo(VisibilityLevel.INTERNAL)
+            assertThat(getter.annotationNames()).contains("kotlin.PublishedApi")
+
+            val setter = fooClass.assertMethod("setFoo-Vxmw0xk", "int")
+            assertThat(setter.modifiers.getVisibilityLevel()).isEqualTo(VisibilityLevel.INTERNAL)
+            assertThat(setter.annotationNames()).contains("kotlin.PublishedApi")
+        }
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/ModelSuiteRunner.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/ModelSuiteRunner.kt
index 7f516ce47..e6b11ccaf 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/ModelSuiteRunner.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/ModelSuiteRunner.kt
@@ -83,6 +83,9 @@ interface ModelSuiteRunner : FilterableCodebaseCreator {
 
         /** An XML file describing the structure of the project (mainly used for KMP projects). */
         val projectDescription: File?,
+
+        /** A jar file with the compiled sources of [mainSourceDir]. */
+        val compiledSourceJar: TestFile?,
     )
 
     /**
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/annotationitem/CommonAnnotationItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/annotationitem/CommonAnnotationItemTest.kt
index 56431da53..4c9e8b659 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/annotationitem/CommonAnnotationItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/annotationitem/CommonAnnotationItemTest.kt
@@ -20,15 +20,32 @@ import com.android.tools.metalava.model.ANNOTATION_IN_ALL_STUBS
 import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.BaseItemVisitor
 import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.getAttributeValue
-import com.android.tools.metalava.model.getAttributeValues
+import com.android.tools.metalava.model.PrimitiveTypeItem.Primitive
+import com.android.tools.metalava.model.annotation.AnnotationFilter
+import com.android.tools.metalava.model.annotation.DefaultAnnotationManager
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
+import com.android.tools.metalava.model.testing.classTypeItem
+import com.android.tools.metalava.model.testing.value.annotationItem
+import com.android.tools.metalava.model.testing.value.annotationValue
+import com.android.tools.metalava.model.testing.value.arrayValue
+import com.android.tools.metalava.model.testing.value.arrayValueFromAny
+import com.android.tools.metalava.model.testing.value.assertValuesAreStrictlyEqual
+import com.android.tools.metalava.model.testing.value.classObjectValue
+import com.android.tools.metalava.model.testing.value.fieldReferenceValue
+import com.android.tools.metalava.model.testing.value.literalValue
+import com.android.tools.metalava.model.testing.value.primitiveValueForKind
 import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.model.value.FieldReferenceValue
+import com.android.tools.metalava.model.value.Value
 import com.android.tools.metalava.reporter.FileLocation
+import com.android.tools.metalava.reporter.RecordingReporter
+import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import kotlin.test.assertEquals
+import kotlin.test.assertNotNull
+import kotlin.test.assertSame
 import org.junit.Test
 
 /** Annotation that is added on a line before the item being annotated. */
@@ -76,7 +93,7 @@ class CommonAnnotationItemTest : BaseModelTest() {
             object : BaseItemVisitor() {
                 override fun visitItem(item: Item) {
                     item.modifiers.annotations().forEach {
-                        addDetails(it.fileLocation, it.toSource())
+                        addDetails(it.fileLocation, it.toString())
                     }
                     addDetails(item.fileLocation, item.describe())
                 }
@@ -236,596 +253,23 @@ class CommonAnnotationItemTest : BaseModelTest() {
             val testClass = codebase.assertClass("test.pkg.Test")
             val anno = testClass.modifiers.annotations().single()
 
-            val other = anno.getAttributeValue<AnnotationItem>("annotationValue")!!
-            assertEquals("test.pkg.Other", other.qualifiedName)
-            other.assertAttributeValue("value", "other")
-
-            val otherAsList = anno.getAttributeValues<AnnotationItem>("annotationValue")
-            assertEquals(listOf(other), otherAsList)
-
-            val others = anno.getAttributeValues<AnnotationItem>("annotationArrayValue")!!
-            assertEquals(
-                "other1, other2",
-                others.mapNotNull { it.getAttributeValue("value") }.joinToString()
-            )
-        }
-    }
-
-    @Test
-    fun `annotation with boolean values`() {
-        runCodebaseTest(
-            signature(
-                """
-                    // Signature format: 2.0
-                    package test.pkg {
-                      @test.pkg.Test.Anno(
-                          booleanValue = true,
-                          booleanArrayValue = {true, false},
-                      )
-                      public class Test {
-                        ctor public Test();
-                      }
-
-                      public @interface Test.Anno {
-                          method public boolean booleanValue();
-                          method public boolean[] booleanArrayValue();
-                      }
-                    }
-                """
-            ),
-            java(
-                """
-                    package test.pkg;
-
-                    @Test.Anno(
-                      booleanValue = true,
-                      booleanArrayValue = {true, false}
-                    )
-                    public class Test {
-                        public Test() {}
-
-                        public @interface Anno {
-                          boolean booleanValue();
-                          boolean[] booleanArrayValue();
-                        }
-                    }
-                """
-            ),
-        ) {
-            val testClass = codebase.assertClass("test.pkg.Test")
-            val anno = testClass.modifiers.annotations().single()
-
-            anno.assertAttributeValue("booleanValue", true)
-            anno.assertAttributeValues("booleanValue", listOf(true))
-            anno.assertAttributeValues("booleanArrayValue", listOf(true, false))
-        }
-    }
-
-    @Test
-    fun `annotation with char values`() {
-        runCodebaseTest(
-            signature(
-                """
-                    // Signature format: 2.0
-                    package test.pkg {
-                      @test.pkg.Test.Anno(
-                          charValue = 'a',
-                          charArrayValue = {'a', 'b'},
-                      )
-                      public class Test {
-                        ctor public Test();
-                      }
-
-                      public @interface Test.Anno {
-                          method public char charValue();
-                          method public char[] charArrayValue();
-                      }
-                    }
-                """
-            ),
-            java(
-                """
-                    package test.pkg;
-
-                    @Test.Anno(
-                      charValue = 'a',
-                      charArrayValue = {'a', 'b'}
-                    )
-                    public class Test {
-                        public Test() {}
-
-                        public @interface Anno {
-                          char charValue();
-                          char[] charArrayValue();
-                        }
-                    }
-                """
-            ),
-        ) {
-            val testClass = codebase.assertClass("test.pkg.Test")
-            val anno = testClass.modifiers.annotations().single()
-
-            anno.assertAttributeValue("charValue", 'a')
-            anno.assertAttributeValues("charValue", listOf('a'))
-            anno.assertAttributeValues("charArrayValue", listOf('a', 'b'))
-        }
-    }
-
-    @Test
-    fun `annotation with class values`() {
-        runCodebaseTest(
-            signature(
-                """
-                    // Signature format: 2.0
-                    package test.pkg {
-                      @test.pkg.Test.Anno(
-                          classValue = test.pkg.Test,
-                          classArrayValue = {test.pkg.Test, Anno}
-                      )
-                      public class Test {
-                        ctor public Test();
-                      }
-
-                      public @interface Test.Anno {
-                          method public Class<?> classValue();
-                          method public Class<?>[] classArrayValue();
-                      }
-                    }
-                """
-            ),
-            java(
-                """
-                    package test.pkg;
-
-                    @Test.Anno(
-                      classValue = Test.class,
-                      classArrayValue = {Test.class, Anno.class}
-                    )
-                    public class Test {
-                        public Test() {}
-
-                        public @interface Anno {
-                          Class<?> classValue();
-                          Class<?>[] classArrayValue();
-                        }
-                    }
-                """
-            ),
-        ) {
-            val testClass = codebase.assertClass("test.pkg.Test")
-            val anno = testClass.modifiers.annotations().single()
-
-            // A class value can be retrieved as a string.
-            anno.assertAttributeValue("classValue", "test.pkg.Test")
-            anno.assertAttributeValues("classValue", listOf("test.pkg.Test"))
-            anno.assertAttributeValues("classArrayValue", listOf("test.pkg.Test", "Anno"))
-        }
-    }
-
-    @Test
-    fun `annotation with number values`() {
-        runCodebaseTest(
-            signature(
-                """
-                    // Signature format: 2.0
-                    package test.pkg {
-                      @test.pkg.Test.Anno(
-                          byteValue = 1,
-                          byteArrayValue = {1, 2},
-
-                          doubleValue = 1.5,
-                          doubleArrayValue = {1.5, 2.5},
-
-                          floatValue = 0.5F,
-                          floatArrayValue = {0.5F, 1.5F},
-
-                          intValue = 1,
-                          intArrayValue = {1, 2, 3},
-
-                          longValue = 2,
-                          longArrayValue = {2, 4},
-
-                          shortValue = 3,
-                          shortArrayValue = {3, 5},
-                      )
-                      public class Test {
-                        ctor public Test();
-                      }
-
-                      public @interface Test.Anno {
-                          method public byte byteValue();
-                          method public byte[] byteArrayValue();
-
-                          method public double doubleValue();
-                          method public double[] doubleArrayValue();
-
-                          method public float floatValue();
-                          method public float[] floatArrayValue();
-
-                          method public int intValue();
-                          method public int[] intArrayValue();
-
-                          method public long longValue();
-                          method public long[] longArrayValue();
-
-                          method public short shortValue();
-                          method public short[] shortArrayValue();
-                      }
-                    }
-                """
-            ),
-            java(
-                """
-                    package test.pkg;
-
-                    @Test.Anno(
-                      byteValue = 1,
-                      byteArrayValue = {1, 2},
-
-                      doubleValue = 1.5,
-                      doubleArrayValue = {1.5, 2.5},
-
-                      floatValue = 0.5F,
-                      floatArrayValue = {0.5F, 1.5F},
-
-                      intValue = 1,
-                      intArrayValue = {1, 2, 3},
-
-                      longValue = 2L,
-                      longArrayValue = {2L, 4L},
-
-                      shortValue = 3,
-                      shortArrayValue = {3, 5}
-                    )
-                    public class Test {
-                        public Test() {}
-
-                        public @interface Anno {
-                          byte byteValue();
-                          byte[] byteArrayValue();
-
-                          double doubleValue();
-                          double[] doubleArrayValue();
-
-                          float floatValue();
-                          float[] floatArrayValue();
-
-                          int intValue();
-                          int[] intArrayValue();
-
-                          long longValue();
-                          long[] longArrayValue();
-
-                          short shortValue();
-                          short[] shortArrayValue();
-                        }
-                    }
-                """
-            ),
-        ) {
-            val testClass = codebase.assertClass("test.pkg.Test")
-            val anno = testClass.modifiers.annotations().single()
-
-            anno.assertAttributeValue("byteValue", 1.toByte())
-            anno.assertAttributeValues("byteValue", byteArrayOf(1).toList())
-            anno.assertAttributeValues("byteArrayValue", byteArrayOf(1, 2).toList())
-
-            anno.assertAttributeValue("doubleValue", 1.5)
-            anno.assertAttributeValues("doubleValue", listOf(1.5))
-            anno.assertAttributeValues("doubleArrayValue", listOf(1.5, 2.5))
-
-            anno.assertAttributeValue("floatValue", 0.5F)
-            anno.assertAttributeValues("floatValue", listOf(0.5F))
-            anno.assertAttributeValues("floatArrayValue", listOf(0.5F, 1.5F))
-
-            anno.assertAttributeValue("intValue", 1)
-            anno.assertAttributeValues("intValue", listOf(1))
-            anno.assertAttributeValues("intArrayValue", listOf(1, 2, 3))
-
-            anno.assertAttributeValue("longValue", 2L)
-            anno.assertAttributeValues("longValue", listOf(2L))
-            anno.assertAttributeValues("longArrayValue", listOf(2L, 4L))
-
-            anno.assertAttributeValue("shortValue", 3.toShort())
-            anno.assertAttributeValues("shortValue", listOf(3.toShort()))
-            anno.assertAttributeValues("shortArrayValue", shortArrayOf(3, 5).toList())
-        }
-    }
-
-    @Test
-    fun `annotation with string values`() {
-        runCodebaseTest(
-            signature(
-                """
-                    // Signature format: 2.0
-                    package test.pkg {
-                      @test.pkg.Test.Anno(
-                          stringValue = "string",
-                          stringArrayValue = {"string1", "string2"},
-                      )
-                      public class Test {
-                        ctor public Test();
-                      }
-
-                      public @interface Test.Anno {
-                          method public String stringValue();
-                          method public String[] stringArrayValue();
-                      }
-                    }
-                """
-            ),
-            java(
-                """
-                    package test.pkg;
-
-                    @Test.Anno(
-                      stringValue = "string",
-                      stringArrayValue = {"string1", "string2"}
-                    )
-                    public class Test {
-                        public Test() {}
-
-                        public @interface Anno {
-                          String stringValue();
-                          String[] stringArrayValue();
-                        }
-                    }
-                """
-            ),
-        ) {
-            val testClass = codebase.assertClass("test.pkg.Test")
-            val anno = testClass.modifiers.annotations().single()
-
-            anno.assertAttributeValue("stringValue", "string")
-            anno.assertAttributeValues("stringValue", listOf("string"))
-            anno.assertAttributeValues("stringArrayValue", listOf("string1", "string2"))
-        }
-    }
-
-    @Test
-    fun `annotation array values with single element`() {
-        runCodebaseTest(
-            signature(
-                """
-                    // Signature format: 2.0
-                    package test.pkg {
-                      @test.pkg.Test.Anno("string")
-                      public class Test {
-                        ctor public Test();
-                      }
-
-                      public @interface Test.Anno {
-                          method public String[] value();
-                      }
-                    }
-                """
-            ),
-            java(
-                """
-                    package test.pkg;
-
-                    @Test.Anno("string")
-                    public class Test {
-                        public Test() {}
-
-                        public @interface Anno {
-                          String[] value();
-                        }
-                    }
-                """
-            ),
-        ) {
-            val testClass = codebase.assertClass("test.pkg.Test")
-            val anno = testClass.modifiers.annotations().single()
-
-            // It is expected to be not of array type
-            anno.assertAttributeValue("value", "string")
-        }
-    }
-
-    @Test
-    fun `annotation array values with single array element`() {
-        runCodebaseTest(
-            signature(
-                """
-                    // Signature format: 2.0
-                    package test.pkg {
-                      @test.pkg.Test.Anno({"string"})
-                      public class Test {
-                        ctor public Test();
-                      }
-
-                      public @interface Test.Anno {
-                          method public String[] value();
-                      }
-                    }
-                """
-            ),
-            java(
-                """
-                    package test.pkg;
-
-                    @Test.Anno({"string"})
-                    public class Test {
-                        public Test() {}
-
-                        public @interface Anno {
-                          String[] value();
-                        }
-                    }
-                """
-            ),
-        ) {
-            val testClass = codebase.assertClass("test.pkg.Test")
-            val anno = testClass.modifiers.annotations().single()
-
-            // It is expected to be of array type
-            anno.assertAttributeValues("value", listOf("string"))
-        }
-    }
-
-    @Test
-    fun `annotation with enum values`() {
-        runCodebaseTest(
-            signature(
-                """
-                    // Signature format: 2.0
-                    package test.pkg {
-                      @test.pkg.Test.Anno(
-                          enumValue = test.pkg.Enum.ENUM1,
-                          enumArrayValue = {test.pkg.Enum.ENUM1, test.pkg.Enum.ENUM2},
-                      )
-                      public class Test {
-                        ctor public Test();
-                      }
-
-                      public @interface Test.Anno {
-                          method public Enum stringValue();
-                          method public Enum[] stringArrayValue();
-                      }
-
-                      public enum Enum {
-                        enum_constant public test.pkg.Enum ENUM1;
-                        enum_constant public test.pkg.Enum ENUM2;
-                      }
-                    }
-                """
-            ),
-            java(
-                """
-                    package test.pkg;
-
-                    @Test.Anno(
-                      enumValue = Enum.ENUM1,
-                      enumArrayValue = {Enum.ENUM1,Enum.ENUM2}
-                    )
-                    public class Test {
-                        public Test() {}
-
-                        public @interface Anno {
-                          Enum enumValue();
-                          Enum[] enumArrayValue();
-                        }
-                    }
-
-                    public enum Enum {
-                      ENUM1,
-                      ENUM2,
-                    }
-                """
-            ),
-        ) {
-            val testClass = codebase.assertClass("test.pkg.Test")
-            val anno = testClass.modifiers.annotations().single()
-
-            anno.assertAttributeValue("enumValue", "test.pkg.Enum.ENUM1")
-            anno.assertAttributeValues("enumValue", listOf("test.pkg.Enum.ENUM1"))
-            anno.assertAttributeValues(
-                "enumArrayValue",
-                listOf("test.pkg.Enum.ENUM1", "test.pkg.Enum.ENUM2")
-            )
-        }
-    }
-
-    @Test
-    fun `annotation with constant literal values`() {
-        runCodebaseTest(
-            signature(
-                """
-                    // Signature format: 2.0
-                    package test.pkg {
-                      @test.pkg.Test.Anno(test.pkg.Test.FIELD)
-                      public class Test {
-                        ctor public Test();
-                        field public static final int FIELD = 5;
-                      }
-
-                      public @interface Test.Anno {
-                         method public Int value();
-                      }
-                    }
-                """
-            ),
-            java(
-                """
-                    package test.pkg;
-
-                    @Test.Anno(Test.FIELD)
-                    public class Test {
-                        public Test() {}
-
-                        public static final int FIELD = 5;
-
-                        public @interface Anno {
-                          int value();
-                        }
-                    }
-                """
-            ),
-        ) {
-            val testClass = codebase.assertClass("test.pkg.Test")
-            val anno = testClass.modifiers.annotations().single()
-
-            anno.assertAttributeValue("value", 5)
-        }
-    }
-
-    @Test
-    fun `annotation toSource() with annotation values`() {
-        runCodebaseTest(
-            signature(
-                """
-                    // Signature format: 2.0
-                    package test.pkg {
-                      @test.pkg.Test.Anno(
-                        annotationValue = @test.pkg.Other("other"),
-                        annotationArrayValue = {@test.pkg.Other("other1"), @test.pkg.Other("other2")}
-                      )
-                      public class Test {
-                        ctor public Test();
-                      }
-
-                      public @interface Test.Anno {
-                          method public test.pkg.Other annotationValue();
-                          method public test.pkg.Other[] annotationArrayValue();
-                      }
-                    }
-                """
-            ),
-            java(
-                """
-                    package test.pkg;
-
-                    @Test.Anno(
-                      annotationValue = @test.pkg.Other("other"),
-                      annotationArrayValue = {@test.pkg.Other("other1"), @test.pkg.Other("other2")}
-                    )
-                    public class Test {
-                        public Test() {}
-
-                        public @interface Anno {
-                          Other annotationValue();
-                          Other[] annotationArrayValue();
-                        }
-                    }
-
-                    @interface Other {
-                        String value();
-                    }
-                """
-            ),
-        ) {
-            val testClass = codebase.assertClass("test.pkg.Test")
-            val anno = testClass.modifiers.annotations().single()
-
-            val toSource =
-                "@test.pkg.Test.Anno(annotationValue=@test.pkg.Other(\"other\"), annotationArrayValue={@test.pkg.Other(\"other1\"), @test.pkg.Other(\"other2\")})"
-            assertEquals(toSource, anno.toSource())
+            val expectedAnno =
+                annotationItem(
+                    "test.pkg.Test.Anno",
+                    "annotationValue" to
+                        annotationValue("test.pkg.Other", "value" to literalValue("other")),
+                    "annotationArrayValue" to
+                        arrayValue(
+                            annotationValue("test.pkg.Other", "value" to literalValue("other1")),
+                            annotationValue("test.pkg.Other", "value" to literalValue("other2")),
+                        ),
+                )
+            assertEquals(expectedAnno, anno)
         }
     }
 
     @Test
-    fun `annotation toSource() with boolean values`() {
+    fun `annotation with boolean values`() {
         runCodebaseTest(
             signature(
                 """
@@ -868,13 +312,18 @@ class CommonAnnotationItemTest : BaseModelTest() {
             val testClass = codebase.assertClass("test.pkg.Test")
             val anno = testClass.modifiers.annotations().single()
 
-            val toSource = "@test.pkg.Test.Anno(booleanValue=true, booleanArrayValue={true, false})"
-            assertEquals(toSource, anno.toSource())
+            val expectedAnno =
+                annotationItem(
+                    "test.pkg.Test.Anno",
+                    "booleanValue" to literalValue(true),
+                    "booleanArrayValue" to arrayValueFromAny(true, false),
+                )
+            assertEquals(expectedAnno, anno)
         }
     }
 
     @Test
-    fun `annotation toSource() with char values`() {
+    fun `annotation with char values`() {
         runCodebaseTest(
             signature(
                 """
@@ -882,7 +331,7 @@ class CommonAnnotationItemTest : BaseModelTest() {
                     package test.pkg {
                       @test.pkg.Test.Anno(
                           charValue = 'a',
-                          charArrayValue = {'a', '\uFF00'},
+                          charArrayValue = {'a', '\uff00'},
                       )
                       public class Test {
                         ctor public Test();
@@ -901,7 +350,7 @@ class CommonAnnotationItemTest : BaseModelTest() {
 
                     @Test.Anno(
                       charValue = 'a',
-                      charArrayValue = {'a', '\uFF00'}
+                      charArrayValue = {'a', '\uff00'}
                     )
                     public class Test {
                         public Test() {}
@@ -917,21 +366,26 @@ class CommonAnnotationItemTest : BaseModelTest() {
             val testClass = codebase.assertClass("test.pkg.Test")
             val anno = testClass.modifiers.annotations().single()
 
-            val toSource = "@test.pkg.Test.Anno(charValue='a', charArrayValue={'a', '\\uff00'})"
-            assertEquals(toSource, anno.toSource())
+            val expectedAnno =
+                annotationItem(
+                    "test.pkg.Test.Anno",
+                    "charValue" to literalValue('a'),
+                    "charArrayValue" to arrayValueFromAny('a', '\uff00'),
+                )
+            assertEquals(expectedAnno, anno)
         }
     }
 
     @Test
-    fun `annotation toSource() with class values`() {
+    fun `annotation with class values`() {
         runCodebaseTest(
             signature(
                 """
                     // Signature format: 2.0
                     package test.pkg {
                       @test.pkg.Test.Anno(
-                          classValue = test.pkg.Test,
-                          classArrayValue = {test.pkg.Test, Anno}
+                          classValue = test.pkg.Test.class,
+                          classArrayValue = {test.pkg.Test.class, test.pkg.Test.Anno.class}
                       )
                       public class Test {
                         ctor public Test();
@@ -950,7 +404,7 @@ class CommonAnnotationItemTest : BaseModelTest() {
 
                     @Test.Anno(
                       classValue = Test.class,
-                      classArrayValue = {Test.class, Anno.class}
+                      classArrayValue = {Test.class, Test.Anno.class}
                     )
                     public class Test {
                         public Test() {}
@@ -966,14 +420,29 @@ class CommonAnnotationItemTest : BaseModelTest() {
             val testClass = codebase.assertClass("test.pkg.Test")
             val anno = testClass.modifiers.annotations().single()
 
-            val toSource =
-                "@test.pkg.Test.Anno(classValue=Test.class, classArrayValue={Test.class, Anno.class})"
-            assertEquals(toSource, anno.toSource())
+            val testClassTypeItem = classTypeItem("test.pkg.Test")
+            val testClassObjectValue = classObjectValue(testClassTypeItem)
+            val expectedAnno =
+                annotationItem(
+                    "test.pkg.Test.Anno",
+                    "classValue" to testClassObjectValue,
+                    "classArrayValue" to
+                        arrayValue(
+                            testClassObjectValue,
+                            classObjectValue(
+                                classTypeItem(
+                                    "test.pkg.Test.Anno",
+                                    outerClassType = testClassTypeItem
+                                )
+                            ),
+                        ),
+                )
+            assertEquals(expectedAnno, anno)
         }
     }
 
     @Test
-    fun `annotation toSource() with number values`() {
+    fun `annotation with number values`() {
         runCodebaseTest(
             signature(
                 """
@@ -986,14 +455,14 @@ class CommonAnnotationItemTest : BaseModelTest() {
                           doubleValue = 1.5,
                           doubleArrayValue = {1.5, 2.5},
 
-                          floatValue = 0.5F,
-                          floatArrayValue = {0.5F, 1.5F},
+                          floatValue = 0.5f,
+                          floatArrayValue = {0.5f, 1.5f},
 
                           intValue = 1,
                           intArrayValue = {1, 2, 3},
 
-                          longValue = 2,
-                          longArrayValue = {2, 4},
+                          longValue = 2L,
+                          longArrayValue = {2L, 4L},
 
                           shortValue = 3,
                           shortArrayValue = {3, 5},
@@ -1076,14 +545,28 @@ class CommonAnnotationItemTest : BaseModelTest() {
             val testClass = codebase.assertClass("test.pkg.Test")
             val anno = testClass.modifiers.annotations().single()
 
-            val toSource =
-                "@test.pkg.Test.Anno(byteValue=1, byteArrayValue={1, 2}, doubleValue=1.5, doubleArrayValue={1.5, 2.5}, floatValue=0.5f, floatArrayValue={0.5f, 1.5f}, intValue=1, intArrayValue={1, 2, 3}, longValue=2L, longArrayValue={2L, 4L}, shortValue=3, shortArrayValue={3, 5})"
-            assertEquals(toSource, anno.toSource())
+            val expectedAnno =
+                annotationItem(
+                    "test.pkg.Test.Anno",
+                    "byteValue" to literalValue(1.toByte()),
+                    "byteArrayValue" to arrayValueFromAny(1.toByte(), 2.toByte()),
+                    "doubleValue" to literalValue(1.5),
+                    "doubleArrayValue" to arrayValueFromAny(1.5, 2.5),
+                    "floatValue" to literalValue(0.5f),
+                    "floatArrayValue" to arrayValueFromAny(0.5f, 1.5f),
+                    "intValue" to literalValue(1),
+                    "intArrayValue" to arrayValueFromAny(1, 2, 3),
+                    "longValue" to literalValue(2L),
+                    "longArrayValue" to arrayValueFromAny(2L, 4L),
+                    "shortValue" to literalValue(3.toShort()),
+                    "shortArrayValue" to arrayValueFromAny(3.toShort(), 5.toShort()),
+                )
+            assertEquals(expectedAnno, anno)
         }
     }
 
     @Test
-    fun `annotation toSource() with string values`() {
+    fun `annotation with string values`() {
         runCodebaseTest(
             signature(
                 """
@@ -1126,14 +609,18 @@ class CommonAnnotationItemTest : BaseModelTest() {
             val testClass = codebase.assertClass("test.pkg.Test")
             val anno = testClass.modifiers.annotations().single()
 
-            val toSource =
-                "@test.pkg.Test.Anno(stringValue=\"string\", stringArrayValue={\"string1\", \"string2\"})"
-            assertEquals(toSource, anno.toSource())
+            val expectedAnno =
+                annotationItem(
+                    "test.pkg.Test.Anno",
+                    "stringValue" to literalValue("string"),
+                    "stringArrayValue" to arrayValueFromAny("string1", "string2"),
+                )
+            assertEquals(expectedAnno, anno)
         }
     }
 
     @Test
-    fun `annotation toSource() for array values with single element`() {
+    fun `annotation array values with single element`() {
         runCodebaseTest(
             signature(
                 """
@@ -1168,13 +655,18 @@ class CommonAnnotationItemTest : BaseModelTest() {
             val testClass = codebase.assertClass("test.pkg.Test")
             val anno = testClass.modifiers.annotations().single()
 
-            val toSource = "@test.pkg.Test.Anno(\"string\")"
-            assertEquals(toSource, anno.toSource())
+            // It is expected to be of array type
+            val expectedAnno =
+                annotationItem(
+                    "test.pkg.Test.Anno",
+                    "value" to arrayValueFromAny("string"),
+                )
+            assertEquals(expectedAnno, anno)
         }
     }
 
     @Test
-    fun `annotation toSource() for array values with single array element`() {
+    fun `annotation array values with single array element`() {
         runCodebaseTest(
             signature(
                 """
@@ -1209,13 +701,18 @@ class CommonAnnotationItemTest : BaseModelTest() {
             val testClass = codebase.assertClass("test.pkg.Test")
             val anno = testClass.modifiers.annotations().single()
 
-            val toSource = "@test.pkg.Test.Anno({\"string\"})"
-            assertEquals(toSource, anno.toSource())
+            // It is expected to be of array type
+            val expectedAnno =
+                annotationItem(
+                    "test.pkg.Test.Anno",
+                    "value" to arrayValueFromAny("string"),
+                )
+            assertEquals(expectedAnno, anno)
         }
     }
 
     @Test
-    fun `annotation toSource() with enum values`() {
+    fun `annotation with enum values`() {
         runCodebaseTest(
             signature(
                 """
@@ -1230,8 +727,8 @@ class CommonAnnotationItemTest : BaseModelTest() {
                       }
 
                       public @interface Test.Anno {
-                          method public Enum stringValue();
-                          method public Enum[] stringArrayValue();
+                          method public Enum enumValue();
+                          method public Enum[] enumArrayValue();
                       }
 
                       public enum Enum {
@@ -1268,14 +765,33 @@ class CommonAnnotationItemTest : BaseModelTest() {
             val testClass = codebase.assertClass("test.pkg.Test")
             val anno = testClass.modifiers.annotations().single()
 
-            val toSource =
-                "@test.pkg.Test.Anno(enumValue=test.pkg.Enum.ENUM1, enumArrayValue={test.pkg.Enum.ENUM1, test.pkg.Enum.ENUM2})"
-            assertEquals(toSource, anno.toSource())
+            val expectedAnno =
+                annotationItem(
+                    "test.pkg.Test.Anno",
+                    "enumValue" to fieldReferenceValue("test.pkg.Enum", "ENUM1"),
+                    "enumArrayValue" to
+                        arrayValue(
+                            fieldReferenceValue("test.pkg.Enum", "ENUM1"),
+                            fieldReferenceValue("test.pkg.Enum", "ENUM2"),
+                        ),
+                )
+            assertEquals(expectedAnno, anno)
+
+            // Make sure that the enum value resolves to the enum field.
+            val enumValue = anno.assertAttribute("enumValue").value as FieldReferenceValue
+            val enum1Field = codebase.assertClass("test.pkg.Enum").assertField("ENUM1")
+            assertSame(enum1Field, enumValue.resolve(), message = "enumValue.resolve()")
+
+            val enumArrayValue =
+                anno.assertAttribute("enumArrayValue").value.asFlatList().map {
+                    it as FieldReferenceValue
+                }
+            assertSame(enum1Field, enumArrayValue[0].resolve(), "enumArrayValue[0].resolve()")
         }
     }
 
     @Test
-    fun `annotation toSource() with constant literal values`() {
+    fun `annotation with constant literal values`() {
         runCodebaseTest(
             signature(
                 """
@@ -1313,33 +829,105 @@ class CommonAnnotationItemTest : BaseModelTest() {
             val testClass = codebase.assertClass("test.pkg.Test")
             val anno = testClass.modifiers.annotations().single()
 
-            val toSource = "@test.pkg.Test.Anno(test.pkg.Test.FIELD)"
-            assertEquals(toSource, anno.toSource())
+            val expectedAnno =
+                annotationItem(
+                    "test.pkg.Test.Anno",
+                    "value" to fieldReferenceValue("test.pkg.Test", "FIELD"),
+                )
+            assertEquals(expectedAnno, anno)
         }
     }
 
     @Test
-    fun `annotation toSource() with compound expression values`() {
+    fun `annotation with unknown field`() {
+        val reporter = RecordingReporter()
         runCodebaseTest(
             signature(
                 """
                     // Signature format: 2.0
                     package test.pkg {
-                      @test.pkg.Test.Anno(value=test.pkg.Test.FIELD1+test.pkg.Test.FIELD2, name="FirstName"+"LastName", id=1+test.pkg.FIELD1)
+                      @test.pkg.Test.Anno(
+                          intValue = other.pkg.TestEnum.UNKNOWN,
+                          intArrayValue = {TestEnum.UNKNOWN, UNKNOWN},
+                      )
                       public class Test {
                         ctor public Test();
-                        field public static final int FIELD1 = 5;
-                        field public static final int FIELD2 = 7;
                       }
 
                       public @interface Test.Anno {
-                          method public int value();
-                          method public String name();
-                          method public int id();
+                          method public int intValue();
+                          method public int[] intArrayValue();
                       }
                     }
                 """
             ),
+            java(
+                """
+                    package test.pkg;
+                    import other.pkg.TestEnum;
+                    import static other.pkg.TestEnum.UNKNOWN;
+
+                    @Test.Anno(
+                      intValue = other.pkg.TestEnum.UNKNOWN,
+                      intArrayValue = {TestEnum.UNKNOWN, UNKNOWN}
+                    )
+                    public class Test {
+                        public Test() {}
+
+                        public @interface Anno {
+                          int intValue();
+                          int[] intArrayValue();
+                        }
+                    }
+                """
+            ),
+            kotlin(
+                """
+                    package test.pkg
+                    import other.pkg.TestEnum
+                    import other.pkg.TestEnum.UNKNOWN
+
+                    @Test.Anno(
+                      intValue = other.pkg.TestEnum.UNKNOWN,
+                      intArrayValue = [TestEnum.UNKNOWN, UNKNOWN]
+                    )
+                    class Test {
+                        annotation class Anno(
+                          val intValue: Int,
+                          val intArrayValue: IntArray,
+                        )
+                    }
+                """
+            ),
+            testFixture =
+                TestFixture(
+                    reporter = reporter,
+                )
+        ) {
+            val testClass = codebase.assertClass("test.pkg.Test")
+            val anno = testClass.modifiers.annotations().single()
+
+            val intValue = anno.assertAttribute("intValue").value
+            assertValuesAreStrictlyEqual(
+                intValue,
+                fieldReferenceValue("other.pkg.TestEnum", "UNKNOWN")
+            )
+
+            val intArrayValue = anno.assertAttribute("intArrayValue").value
+            assertValuesAreStrictlyEqual(
+                intArrayValue,
+                arrayValue(
+                    fieldReferenceValue("TestEnum", "UNKNOWN"),
+                    fieldReferenceValue("", "UNKNOWN"),
+                )
+            )
+        }
+    }
+
+    @RequiresCapabilities(Capability.JAVA)
+    @Test
+    fun `annotation with compound expression values`() {
+        runCodebaseTest(
             java(
                 """
                     package test.pkg;
@@ -1363,15 +951,93 @@ class CommonAnnotationItemTest : BaseModelTest() {
             val testClass = codebase.assertClass("test.pkg.Test")
             val anno = testClass.modifiers.annotations().single()
 
-            anno.assertAttributeValue("value", 12)
-            anno.assertAttributeValue("name", "FirstNameLastName")
-            anno.assertAttributeValue("id", 6)
-            val toSource =
-                "@test.pkg.Test.Anno(value=test.pkg.Test.FIELD1 + test.pkg.Test.FIELD2, name=\"FirstName\" + \"LastName\", id=1 + test.pkg.Test.FIELD1)"
-            assertEquals(toSource, anno.toSource())
+            val expectedAnno =
+                annotationItem(
+                    "test.pkg.Test.Anno",
+                    "value" to literalValue(12),
+                    "name" to literalValue("FirstNameLastName"),
+                    "id" to literalValue(6),
+                )
+            assertEquals(expectedAnno, anno)
+        }
+    }
+
+    private fun checkGetVsSetParamAnnotation(
+        attributeType: String,
+        attributePrimitive: Primitive,
+        expectedAttributeString: String,
+    ) {
+        runCodebaseTest(
+            kotlin(
+                """
+                        package test.pkg
+
+                        annotation class Anno(val attr: $attributeType)
+
+                        class Test {
+                            @get:Anno(attr = 12) @setparam:Anno(attr = 12) var property = 0
+                        }
+                    """
+            )
+        ) {
+            val testClass = codebase.assertClass("test.pkg.Test")
+            val property = testClass.properties().single()
+
+            val expectedValue = primitiveValueForKind(attributePrimitive, 12)
+
+            // Test the annotation on the property (the @get:Anno).
+            property.modifiers.annotations().single().let { anno ->
+                assertValuesAreStrictlyEqual(
+                    expectedValue,
+                    anno.assertAttribute("attr").value,
+                    message = "@get:Anno"
+                )
+            }
+
+            // Test the annotation on the setter parameter (the @setparam:Anno).
+            val setter = property.setter
+            assertNotNull(setter, message = "setter method")
+            val parameter = setter.parameters().single()
+            parameter.modifiers.annotations().single().let { anno ->
+                assertValuesAreStrictlyEqual(
+                    expectedValue,
+                    anno.assertAttribute("attr").value,
+                    message = "@setparam:Anno"
+                )
+            }
         }
     }
 
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `annotation on @get and @setparam annotations - byte`() {
+        checkGetVsSetParamAnnotation(
+            attributeType = "Byte",
+            attributePrimitive = Primitive.BYTE,
+            expectedAttributeString = "12",
+        )
+    }
+
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `annotation on @get and @setparam annotations - short`() {
+        checkGetVsSetParamAnnotation(
+            attributeType = "Short",
+            attributePrimitive = Primitive.SHORT,
+            expectedAttributeString = "12",
+        )
+    }
+
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `annotation on @get and @setparam annotations - long`() {
+        checkGetVsSetParamAnnotation(
+            attributeType = "Long",
+            attributePrimitive = Primitive.LONG,
+            expectedAttributeString = "12L",
+        )
+    }
+
     @Test
     fun `annotation with negative number values`() {
         runCodebaseTest(
@@ -1383,7 +1049,7 @@ class CommonAnnotationItemTest : BaseModelTest() {
                           doubleValue = -1.5,
                           floatValue = -0.5F,
                           intValue = -1,
-                          longValue = -2,
+                          longValue = -2L,
                           shortValue = -3,
                       )
                       public class Test {
@@ -1428,18 +1094,21 @@ class CommonAnnotationItemTest : BaseModelTest() {
             val testClass = codebase.assertClass("test.pkg.Test")
             val anno = testClass.modifiers.annotations().single()
 
-            anno.assertAttributeValue("doubleValue", -1.5)
-            anno.assertAttributeValue("floatValue", -0.5F)
-            anno.assertAttributeValue("intValue", -1)
-            anno.assertAttributeValue("longValue", -2L)
-            anno.assertAttributeValue("shortValue", -3.toShort())
-
-            val toSource =
-                "@test.pkg.Test.Anno(doubleValue=-1.5, floatValue=-0.5F, intValue=0xffffffff, longValue=-2L, shortValue=0xfffffffd)"
-            assertEquals(toSource, anno.toSource())
+            val expectedAnno =
+                annotationItem(
+                    "test.pkg.Test.Anno",
+                    "doubleValue" to literalValue(-1.5),
+                    "floatValue" to literalValue(-0.5F),
+                    "intValue" to literalValue(-1),
+                    "longValue" to literalValue(-2L),
+                    "shortValue" to literalValue((-3).toShort()),
+                )
+            assertEquals(expectedAnno, anno)
         }
     }
 
+    // Does not work with signature files as they do not support casts.
+    @RequiresCapabilities(Capability.JAVA)
     @Test
     fun `annotation with type cast values`() {
         runCodebaseTest(
@@ -1476,8 +1145,12 @@ class CommonAnnotationItemTest : BaseModelTest() {
             val testClass = codebase.assertClass("test.pkg.Test")
             val anno = testClass.modifiers.annotations().single()
 
-            anno.assertAttributeValue("value", 5)
-            assertEquals("@test.pkg.Test.Anno(0x5)", anno.toSource())
+            val expectedAnno =
+                annotationItem(
+                    "test.pkg.Test.Anno",
+                    "value" to literalValue(5),
+                )
+            assertEquals(expectedAnno, anno)
         }
     }
 
@@ -1488,13 +1161,13 @@ class CommonAnnotationItemTest : BaseModelTest() {
                 """
                     // Signature format: 2.0
                     package test.pkg {
-                      @test.pkg.Test.Anno({java.lang.Double.POSITIVE_INFINITY,java.lang.Double.POSITIVE_INFINITY})
+                      @test.pkg.Test.Anno({java.lang.Double.POSITIVE_INFINITY,java.lang.Double.NEGATIVE_INFINITY})
                       public class Test {
                         ctor public Test();
                       }
 
                       public @interface Test.Anno {
-                          method public double [] value();
+                          method public double[] value();
                       }
                     }
                 """
@@ -1517,11 +1190,50 @@ class CommonAnnotationItemTest : BaseModelTest() {
             val testClass = codebase.assertClass("test.pkg.Test")
             val anno = testClass.modifiers.annotations().single()
 
-            anno.assertAttributeValues("value", listOf(2147483647, -2147483648))
-            assertEquals(
-                "@test.pkg.Test.Anno({java.lang.Double.POSITIVE_INFINITY, java.lang.Double.NEGATIVE_INFINITY})",
-                anno.toSource()
-            )
+            val expectedAnno =
+                annotationItem(
+                    "test.pkg.Test.Anno",
+                    "value" to
+                        arrayValueFromAny(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY),
+                )
+            assertEquals(expectedAnno, anno)
+        }
+    }
+
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `annotation on @file`() {
+        runCodebaseTest(
+            inputSet(
+                kotlin(
+                    """
+                        @file:RestrictTo(RestrictTo.Scope.LIBRARY)
+                        package test.pkg
+
+                        import androidx.annotation.RestrictTo
+
+                        class Foo
+
+                        const val CONSTANT = 1
+                    """
+                ),
+                KnownSourceFiles.restrictToSource,
+            ),
+        ) {
+            val testClass = codebase.assertClass("test.pkg.FooKt")
+            val anno = testClass.modifiers.annotations().single()
+
+            val attribute = anno.assertAttribute("value")
+            val expected =
+                arrayValue(
+                    Value.createFieldReferenceValue(
+                        codebase,
+                        "androidx.annotation.RestrictTo.Scope",
+                        "LIBRARY"
+                    ),
+                )
+            val actual = attribute.value
+            assertEquals(expected, actual)
         }
     }
 
@@ -1610,25 +1322,60 @@ class CommonAnnotationItemTest : BaseModelTest() {
         }
     }
 
-    inline fun <reified T : Any> AnnotationItem.assertAttributeValue(
-        attributeName: String,
-        expected: T
-    ) {
-        assertEquals(
-            expected,
-            getAttributeValue(attributeName),
-            message = "getAttributeValue($attributeName)"
-        )
-    }
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `annotation on internal`() {
+        // Create a filter that will treat RestrictTo(Scope.LIBRARY) as a show annotation.
+        val showFilter =
+            AnnotationFilter.create(
+                listOf(
+                    "androidx.annotation.RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY)",
+                )
+            )
 
-    inline fun <reified T : Any> AnnotationItem.assertAttributeValues(
-        attributeName: String,
-        expected: List<T>
-    ) {
-        assertEquals(
-            expected,
-            getAttributeValues(attributeName),
-            message = "getAttributeValues($attributeName)"
-        )
+        runCodebaseTest(
+            inputSet(
+                kotlin(
+                    """
+                        package test.pkg
+
+                        import androidx.annotation.RestrictTo
+
+                        // Defined during codebase construction as it is accessible because while it
+                        // is internal it is annotated with a show annotation.
+                        @RestrictTo(RestrictTo.Scope.LIBRARY)
+                        internal class Foo
+
+                        // Not defined during codebase construction as it is inaccessible because it
+                        // is internal and while it has an annotation it is not a show annotation as
+                        // the scope is incorrect.
+                        @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
+                        internal class Bar
+
+                        // Not defined during codebase construction as it is inaccessible because it
+                        // is internal.
+                        internal class Baz
+                    """
+                ),
+                KnownSourceFiles.restrictToSource,
+            ),
+            testFixture =
+                TestFixture(
+                    DefaultAnnotationManager(
+                        config =
+                            DefaultAnnotationManager.Config(
+                                allShowAnnotations = showFilter,
+                                showAnnotations = showFilter,
+                            )
+                    )
+                ),
+        ) {
+            // This should be defined.
+            codebase.assertClass("test.pkg.Foo")
+            // This should not be defined.
+            codebase.assertResolvedClass("test.pkg.Bar")
+            // This should not be defined.
+            codebase.assertResolvedClass("test.pkg.Baz")
+        }
     }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonDataClassTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonDataClassTest.kt
index 72ec539d1..7f7348770 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonDataClassTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonDataClassTest.kt
@@ -17,6 +17,7 @@
 package com.android.tools.metalava.model.testsuite.classitem
 
 import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.VisibilityLevel
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.model.testing.testTypeString
@@ -193,4 +194,207 @@ class CommonDataClassTest : BaseModelTest() {
             )
         }
     }
+
+    @Test
+    fun `Test data class copy method visibility without CopyVisibility annotations`() {
+        /*
+        Currently, the default visibility for a data class copy method is public, regardless of the
+        constructor visibility, unless ConsistentCopyVisibility is used. In the future, the default
+        will flip so that the copy method visibility matches the constructor unless
+        ExposedCopyVisibility is used.
+        See https://kotlinlang.org/api/core/kotlin-stdlib/kotlin/-exposed-copy-visibility/
+         */
+        runCodebaseTest(
+            kotlin(
+                """
+                package test.pkg
+                data class PublicConstructor(val value: Int)
+                data class InternalConstructor internal constructor(val value: Int)
+                data class InternalPublishedConstructor @PublishedApi internal constructor(val value: Int)
+                data class PrivateConstructor private constructor(val value: Int)
+                """
+            )
+        ) {
+            val publicCtorClass = codebase.assertClass("test.pkg.PublicConstructor")
+            val publicCtor = publicCtorClass.assertConstructor("int")
+            assertThat(publicCtor.modifiers.getVisibilityLevel()).isEqualTo(VisibilityLevel.PUBLIC)
+            val publicCtorCopy = publicCtorClass.assertMethod("copy", "int")
+            assertThat(publicCtorCopy.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.PUBLIC)
+
+            val internalCtorClass = codebase.assertClass("test.pkg.InternalConstructor")
+            val internalCtor = internalCtorClass.assertConstructor("int")
+            assertThat(internalCtor.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.INTERNAL)
+            val internalCtorCopy = internalCtorClass.assertMethod("copy", "int")
+            assertThat(internalCtorCopy.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.PUBLIC)
+
+            val internalPublishedCtorClass =
+                codebase.assertClass("test.pkg.InternalPublishedConstructor")
+            val internalPublishedCtor = internalPublishedCtorClass.assertConstructor("int")
+            assertThat(internalPublishedCtor.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.INTERNAL)
+            assertThat(internalPublishedCtor.annotationNames()).contains("kotlin.PublishedApi")
+            val internalPublishedCtorCopy = internalPublishedCtorClass.assertMethod("copy", "int")
+            assertThat(internalPublishedCtorCopy.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.PUBLIC)
+            assertThat(internalPublishedCtorCopy.annotationNames())
+                .doesNotContain("kotlin.PublishedApi")
+
+            val privateCtorClass = codebase.assertClass("test.pkg.PrivateConstructor")
+            val privateCtor = privateCtorClass.assertConstructor("int")
+            assertThat(privateCtor.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.PRIVATE)
+            val privateCtorCopy = privateCtorClass.assertMethod("copy", "int")
+            assertThat(privateCtorCopy.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.PUBLIC)
+        }
+    }
+
+    @Test
+    fun `Test data class copy method visibility with ConsistentCopyVisibility`() {
+        // @ConsistentCopyVisibility makes the copy method visibility match the constructor
+        runCodebaseTest(
+            kotlin(
+                """
+                package test.pkg
+                @ConsistentCopyVisibility
+                data class PublicConstructor(val value: Int)
+                @ConsistentCopyVisibility
+                data class InternalConstructor internal constructor(val value: Int)
+                @ConsistentCopyVisibility
+                data class InternalPublishedConstructor @PublishedApi internal constructor(val value: Int)
+                @ConsistentCopyVisibility
+                data class PrivateConstructor private constructor(val value: Int)
+                """
+            )
+        ) {
+            val publicCtorClass = codebase.assertClass("test.pkg.PublicConstructor")
+            val publicCtor = publicCtorClass.assertConstructor("int")
+            assertThat(publicCtor.modifiers.getVisibilityLevel()).isEqualTo(VisibilityLevel.PUBLIC)
+            val publicCtorCopy = publicCtorClass.assertMethod("copy", "int")
+            assertThat(publicCtorCopy.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.PUBLIC)
+
+            val internalCtorClass = codebase.assertClass("test.pkg.InternalConstructor")
+            val internalCtor = internalCtorClass.assertConstructor("int")
+            assertThat(internalCtor.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.INTERNAL)
+            // The copy method gets a mangled name with K2 (copy$<module name>).
+            val internalCtorCopy =
+                internalCtorClass.methods().single { it.name().startsWith("copy") }
+            assertThat(internalCtorCopy.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.INTERNAL)
+
+            val internalPublishedCtorClass =
+                codebase.assertClass("test.pkg.InternalPublishedConstructor")
+            val internalPublishedCtor = internalPublishedCtorClass.assertConstructor("int")
+            assertThat(internalPublishedCtor.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.INTERNAL)
+            assertThat(internalPublishedCtor.annotationNames()).contains("kotlin.PublishedApi")
+            // The copy method gets a mangled name with K2 (copy$<module name>).
+            val internalPublishedCtorCopy =
+                internalPublishedCtorClass.methods().single { it.name().startsWith("copy") }
+            assertThat(internalPublishedCtorCopy.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.INTERNAL)
+            // Note: @ConsistentCopyVisibility on an internal @PublishedApi constructor does not
+            // make the copy method @PublishedApi, just internal.
+            assertThat(internalPublishedCtorCopy.annotationNames())
+                .doesNotContain("kotlin.PublishedApi")
+
+            val privateCtorClass = codebase.assertClass("test.pkg.PrivateConstructor")
+            val privateCtor = privateCtorClass.assertConstructor("int")
+            assertThat(privateCtor.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.PRIVATE)
+            val privateCtorCopy = privateCtorClass.assertMethod("copy", "int")
+            assertThat(privateCtorCopy.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.PRIVATE)
+        }
+    }
+
+    @Test
+    fun `Test data class copy method visibility with ExposedCopyVisibility`() {
+        // With @ExposedCopyVisibility, the copy method is always public.
+        runCodebaseTest(
+            kotlin(
+                """
+                        package test.pkg
+                        @ExposedCopyVisibility
+                        data class PublicConstructor(val value: Int)
+                        @ExposedCopyVisibility
+                        data class InternalConstructor internal constructor(val value: Int)
+                        @ExposedCopyVisibility
+                        data class InternalPublishedConstructor @PublishedApi internal constructor(val value: Int)
+                        @ExposedCopyVisibility
+                        data class PrivateConstructor private constructor(val value: Int)
+                        """
+            )
+        ) {
+            val publicCtorClass = codebase.assertClass("test.pkg.PublicConstructor")
+            val publicCtor = publicCtorClass.assertConstructor("int")
+            assertThat(publicCtor.modifiers.getVisibilityLevel()).isEqualTo(VisibilityLevel.PUBLIC)
+            val publicCtorCopy = publicCtorClass.assertMethod("copy", "int")
+            assertThat(publicCtorCopy.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.PUBLIC)
+
+            val internalCtorClass = codebase.assertClass("test.pkg.InternalConstructor")
+            val internalCtor = internalCtorClass.assertConstructor("int")
+            assertThat(internalCtor.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.INTERNAL)
+            val internalCtorCopy = internalCtorClass.assertMethod("copy", "int")
+            assertThat(internalCtorCopy.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.PUBLIC)
+
+            val internalPublishedCtorClass =
+                codebase.assertClass("test.pkg.InternalPublishedConstructor")
+            val internalPublishedCtor = internalPublishedCtorClass.assertConstructor("int")
+            assertThat(internalPublishedCtor.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.INTERNAL)
+            assertThat(internalPublishedCtor.annotationNames()).contains("kotlin.PublishedApi")
+            val internalPublishedCtorCopy = internalPublishedCtorClass.assertMethod("copy", "int")
+            assertThat(internalPublishedCtorCopy.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.PUBLIC)
+            assertThat(internalPublishedCtorCopy.annotationNames())
+                .doesNotContain("kotlin.PublishedApi")
+
+            val privateCtorClass = codebase.assertClass("test.pkg.PrivateConstructor")
+            val privateCtor = privateCtorClass.assertConstructor("int")
+            assertThat(privateCtor.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.PRIVATE)
+            val privateCtorCopy = privateCtorClass.assertMethod("copy", "int")
+            assertThat(privateCtorCopy.modifiers.getVisibilityLevel())
+                .isEqualTo(VisibilityLevel.PUBLIC)
+        }
+    }
+
+    @Test
+    fun `Test optional parameters for data class constructor and copy method`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                package test.pkg
+                data class Foo(val optionalParam: Int = 0, val requiredParam: Int) {
+                    // Manual copy function, where the parameter is not optional
+                    fun copy(requiredParam: Int)
+                }
+                """
+            )
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+            val ctor = fooClass.assertConstructor("int,int")
+            // The first constructor parameter is optional, the second is not.
+            assertThat(ctor.parameters()[0].hasDefaultValue()).isTrue()
+            assertThat(ctor.parameters()[1].hasDefaultValue()).isFalse()
+
+            // This is the copy function generated by the constructor. All parameters are optional.
+            val generatedCopy = fooClass.assertMethod("copy", "int,int")
+            assertThat(generatedCopy.parameters()[0].hasDefaultValue()).isTrue()
+            assertThat(generatedCopy.parameters()[1].hasDefaultValue()).isTrue()
+
+            // This is a copy function defined in source, where the only parameter is not optional.
+            val manualCopy = fooClass.assertMethod("copy", "int")
+            assertThat(manualCopy.parameters().single().hasDefaultValue()).isFalse()
+        }
+    }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonFieldItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonFieldItemTest.kt
index 53cbf6773..5af192869 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonFieldItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonFieldItemTest.kt
@@ -22,6 +22,7 @@ import com.android.tools.metalava.model.testsuite.BaseModelTest
 import com.android.tools.metalava.model.testsuite.assertHasNonNullNullability
 import com.android.tools.metalava.model.testsuite.assertHasNullableNullability
 import com.android.tools.metalava.model.testsuite.runNullabilityTest
+import com.android.tools.metalava.model.value.asFloat
 import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
@@ -499,13 +500,13 @@ class CommonFieldItemTest : BaseModelTest() {
             val fields = testClass.fields()
             assertEquals(3, fields.size, message = "field count")
             for (field in fields) {
-                val value = field.legacyInitialValue(true) as Float
+                val value = field.constantValue?.asFloat()!!
                 val valueBits = value.toBits()
                 assertEquals(
                     minNormalBits,
                     valueBits,
                     message =
-                        "field ${field.name()} - expected ${Integer.toHexString(minNormalBits)}, found ${Integer.toHexString(valueBits)}"
+                        "field ${field.name()} - constantValue - expected ${Integer.toHexString(minNormalBits)}, found ${Integer.toHexString(valueBits)}"
                 )
 
                 val written =
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/SourceFieldItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/SourceFieldItemTest.kt
index af8e5cf9b..c3388cdaf 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/SourceFieldItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/SourceFieldItemTest.kt
@@ -17,9 +17,11 @@
 package com.android.tools.metalava.model.testsuite.fielditem
 
 import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.model.value.asAny
+import com.android.tools.metalava.model.value.asInt
 import com.android.tools.metalava.testing.java
 import kotlin.test.assertEquals
-import kotlin.test.assertNotNull
+import kotlin.test.assertNull
 import org.junit.Test
 
 /** Common tests for [FieldItem.InitialValue]. */
@@ -55,8 +57,7 @@ class SourceFieldItemTest : BaseModelTest() {
                     Double.POSITIVE_INFINITY,
                     61184.toChar(),
                 )
-            assertEquals(fieldValues, classItem.fields().map { it.legacyInitialValue(false) })
-            assertEquals(fieldValues, classItem.fields().map { it.legacyInitialValue(true) })
+            assertEquals(fieldValues, classItem.fields().map { it.constantValue?.asAny() })
         }
     }
 
@@ -79,10 +80,8 @@ class SourceFieldItemTest : BaseModelTest() {
             val classItem = codebase.assertClass("test.pkg.Test")
             val fieldItem1 = classItem.assertField("field1")
             val fieldItem2 = classItem.assertField("field2")
-            assertEquals(38, fieldItem1.legacyInitialValue(true))
-            assertEquals(38, fieldItem1.legacyInitialValue(false))
-            assertEquals(91, fieldItem2.legacyInitialValue(true))
-            assertEquals(91, fieldItem2.legacyInitialValue(false))
+            assertEquals(38, fieldItem1.constantValue?.asInt())
+            assertEquals(91, fieldItem2.constantValue?.asInt())
         }
     }
 
@@ -112,10 +111,8 @@ class SourceFieldItemTest : BaseModelTest() {
             val fieldItem1 = classItem.assertField("field1")
             val fieldItem2 = classItem.assertField("field2")
 
-            assertEquals(null, fieldItem1.legacyInitialValue(false))
-            assertEquals(null, fieldItem1.legacyInitialValue(true))
-            assertEquals(null, fieldItem2.legacyInitialValue(true))
-            assertEquals(null, fieldItem2.legacyInitialValue(false))
+            assertEquals(null, fieldItem1.constantValue)
+            assertEquals(null, fieldItem2.constantValue)
         }
     }
 
@@ -136,8 +133,8 @@ class SourceFieldItemTest : BaseModelTest() {
             val classItem = codebase.assertClass("test.pkg.Test")
             val fieldItem = classItem.assertField("ENUM1")
 
-            assertNotNull(fieldItem.legacyInitialValue(true))
-            assertNotNull(fieldItem.legacyInitialValue(false))
+            // An enum is not its own constant value.
+            assertNull(fieldItem.constantValue)
         }
     }
 
@@ -149,15 +146,17 @@ class SourceFieldItemTest : BaseModelTest() {
                     package test.pkg;
 
                     public class Test {
-                        public static final Class<?> field = String.class;;
+                        public static final Class<?> field = String.class;
                     }
                 """
             ),
         ) {
             val classItem = codebase.assertClass("test.pkg.Test")
             val fieldItem = classItem.assertField("field")
-            assertEquals(null, fieldItem.legacyInitialValue(true))
-            assertNotNull(fieldItem.legacyInitialValue(false))
+
+            // TODO(b/354633349): Class literals are not supported for fields as it is not clear
+            //  that is needed.
+            assertNull(fieldItem.constantValue)
         }
     }
 
@@ -177,8 +176,7 @@ class SourceFieldItemTest : BaseModelTest() {
             val classItem = codebase.assertClass("test.pkg.Test")
             val fieldItem = classItem.assertField("field")
 
-            assertEquals(null, fieldItem.legacyInitialValue(true))
-            assertEquals(7, fieldItem.legacyInitialValue(false))
+            assertNull(fieldItem.constantValue)
         }
     }
 
@@ -202,10 +200,8 @@ class SourceFieldItemTest : BaseModelTest() {
             val fieldItem1 = classItem.assertField("field1")
             val fieldItem2 = classItem.assertField("field2")
 
-            assertEquals(null, fieldItem1.legacyInitialValue(true))
-            assertEquals(27, fieldItem1.legacyInitialValue(false))
-            assertEquals(null, fieldItem2.legacyInitialValue(true))
-            assertEquals(91, fieldItem2.legacyInitialValue(false))
+            assertEquals(null, fieldItem1.constantValue)
+            assertEquals(null, fieldItem2.constantValue)
         }
     }
 
@@ -217,15 +213,17 @@ class SourceFieldItemTest : BaseModelTest() {
                     package test.pkg;
 
                     public class Test {
-                        public static Class<?> field = String.class;;
+                        public static Class<?> field = String.class;
                     }
                 """
             ),
         ) {
             val classItem = codebase.assertClass("test.pkg.Test")
             val fieldItem = classItem.assertField("field")
-            assertEquals(null, fieldItem.legacyInitialValue(true))
-            assertNotNull(fieldItem.legacyInitialValue(false))
+
+            // TODO(b/354633349): Class literals are not supported for fields as it is not clear
+            //  that is needed.
+            assertNull(fieldItem.constantValue)
         }
     }
 
@@ -264,9 +262,9 @@ class SourceFieldItemTest : BaseModelTest() {
             )
             assertEquals(fieldItem.type(), duplicateField.type(), message = "duplicated types")
             assertEquals(
-                fieldItem.legacyInitialValue(),
-                duplicateField.legacyInitialValue(),
-                message = "duplicated initial value"
+                fieldItem.constantValue,
+                duplicateField.constantValue,
+                message = "duplicated constant value"
             )
             assertEquals(classItem, duplicateField.inheritedFrom, message = "inheritedFrom")
         }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonMethodItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonMethodItemTest.kt
index 0239b6ad8..f8cd0420b 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonMethodItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonMethodItemTest.kt
@@ -18,6 +18,13 @@ package com.android.tools.metalava.model.testsuite.methoditem
 
 import com.android.tools.metalava.model.JAVA_LANG_THROWABLE
 import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.PrimitiveTypeItem
+import com.android.tools.metalava.model.testing.classTypeItem
+import com.android.tools.metalava.model.testing.value.annotationValue
+import com.android.tools.metalava.model.testing.value.arrayValueFromAny
+import com.android.tools.metalava.model.testing.value.classObjectValue
+import com.android.tools.metalava.model.testing.value.fieldReferenceValue
+import com.android.tools.metalava.model.testing.value.literalValue
 import com.android.tools.metalava.model.testsuite.BaseModelTest
 import com.android.tools.metalava.testing.createAndroidModuleDescription
 import com.android.tools.metalava.testing.createCommonModuleDescription
@@ -28,6 +35,7 @@ import kotlin.test.assertEquals
 import kotlin.test.assertFalse
 import kotlin.test.assertNotEquals
 import kotlin.test.assertNull
+import kotlin.test.assertTrue
 import org.junit.Test
 
 /** Common tests for implementations of [MethodItem]. */
@@ -375,26 +383,26 @@ class CommonMethodItemTest : BaseModelTest() {
             val classItem = codebase.assertClass("test.pkg.TestAnnotation")
 
             val values =
-                listOf<String>(
-                    "7",
-                    "-7",
-                    "1",
-                    "1.0f",
-                    "-1.0f",
-                    "1L",
-                    "-1L",
-                    "false",
-                    "\"pref\"",
-                    "{'a', 'b', 'c'}",
-                    "\'a\'",
-                    "java.lang.Double.NEGATIVE_INFINITY",
-                    "7",
-                    "12",
-                    "@test.pkg.TestAnnotation.InnerAnnotation",
-                    "java.lang.Integer.class",
-                    "test.pkg.TestAnnotation.InnerEnum.ENUM1"
+                listOf(
+                    literalValue(7),
+                    literalValue(-7),
+                    literalValue(1.toByte()),
+                    literalValue(1.0f),
+                    literalValue(-1.0f),
+                    literalValue(1L),
+                    literalValue(-1L),
+                    literalValue(false),
+                    literalValue("pref"),
+                    arrayValueFromAny('a', 'b', 'c'),
+                    arrayValueFromAny('a'),
+                    fieldReferenceValue("java.lang.Double", "NEGATIVE_INFINITY"),
+                    literalValue(7),
+                    literalValue(12),
+                    annotationValue("test.pkg.TestAnnotation.InnerAnnotation"),
+                    classObjectValue(classTypeItem("java.lang.Integer")),
+                    fieldReferenceValue("test.pkg.TestAnnotation.InnerEnum", "ENUM1"),
                 )
-            assertEquals(values, classItem.methods().map { it.legacyDefaultValue() })
+            assertEquals(values, classItem.methods().map { it.defaultValue })
         }
     }
 
@@ -456,4 +464,62 @@ class CommonMethodItemTest : BaseModelTest() {
             assertEquals(fooClass.methods().size, 7)
         }
     }
+
+    @Test
+    fun `JvmOverloads with initial vararg parameter`() {
+        val commonSource =
+            kotlin(
+                "commonMain/src/test/pkg/Foo.kt",
+                """
+                package test.pkg
+                import kotlin.jvm.JvmOverloads
+                expect class Foo {
+                    @JvmOverloads
+                    fun foo(vararg str: String, bool: Boolean = true)
+                }
+                """
+            )
+        val androidSource =
+            kotlin(
+                "androidMain/src/test/pkg/Foo.kt",
+                """
+                package test.pkg
+                actual class Foo {
+                    @JvmOverloads
+                    actual fun foo(vararg str: String, bool: Boolean) = Unit
+                }
+                """
+            )
+
+        runCodebaseTest(
+            inputSet(androidSource, commonSource),
+            projectDescription =
+                createProjectDescription(
+                    createAndroidModuleDescription(arrayOf(androidSource)),
+                    createCommonModuleDescription(arrayOf(commonSource)),
+                ),
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+
+            // Overload with both parameters: parameter is not varargs because it is not final.
+            val withArrayType = fooClass.methods().single { it.parameters().size == 2 }
+            withArrayType.parameters()[0].type().assertArrayTypeItem {
+                assertFalse(isVarargs)
+                assertTrue(componentType.isString())
+            }
+            withArrayType.parameters()[1].type().assertPrimitiveTypeItem {
+                assertEquals(kind, PrimitiveTypeItem.Primitive.BOOLEAN)
+            }
+
+            // Overload with single parameter: parameter is varargs because it is final.
+            val withVarargsType = fooClass.methods().single { it.parameters().size == 1 }
+            withVarargsType.parameters()[0].type().assertArrayTypeItem {
+                assertTrue(isVarargs)
+                assertTrue(componentType.isString())
+            }
+
+            // Check there are no other methods.
+            assertEquals(fooClass.methods().size, 2)
+        }
+    }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/sourcefile/CommonSourceFileTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/sourcefile/CommonSourceFileTest.kt
index f0c89885c..2680df4b4 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/sourcefile/CommonSourceFileTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/sourcefile/CommonSourceFileTest.kt
@@ -94,9 +94,11 @@ class CommonSourceFileTest : BaseModelTest() {
                         }
                     """
                 ),
-                java("""
+                java(
+                    """
                         package empty;
-                    """),
+                    """
+                ),
             )
         ) {
             val classItem = codebase.assertClass("test.pkg.Test")
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeAliasTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeAliasTest.kt
index 410cc025c..d64a5ae3c 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeAliasTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeAliasTest.kt
@@ -121,7 +121,7 @@ class CommonTypeAliasTest : BaseModelTest() {
     private fun getClassOrWildcardExtendsBound(typeItem: TypeItem): TypeItem {
         return typeItem as? ClassTypeItem
             ?: (typeItem as? WildcardTypeItem)?.extendsBound
-                ?: error("expected class type or wildcard type with extends bound, was $typeItem")
+            ?: error("expected class type or wildcard type with extends bound, was $typeItem")
     }
 
     @Test
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeModifiersTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeModifiersTest.kt
index c980e7f20..e1e5154eb 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeModifiersTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeModifiersTest.kt
@@ -1642,7 +1642,7 @@ class CommonTypeModifiersTest : BaseModelTest() {
                 """
                 package test.pkg;
                 public class Foo {
-                    public final String nonNullStringConstant = "non null value";
+                    public static final String nonNullStringConstant = "non null value";
                     public final String nullStringConstant = null;
                     public String nonConstantString = "non null value";
                 }
@@ -1654,7 +1654,7 @@ class CommonTypeModifiersTest : BaseModelTest() {
                 // Signature format: 2.0
                 package test.pkg {
                   public class Foo {
-                    field public final String nonNullStringConstant = "non null value";
+                    field public static final String nonNullStringConstant = "non null value";
                     field public final String nullStringConstant;
                     field public String nonConstantString;
                   }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/BaseCommonParameterizedValueTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/BaseCommonParameterizedValueTest.kt
index c6f399457..4fc6ea4c8 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/BaseCommonParameterizedValueTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/BaseCommonParameterizedValueTest.kt
@@ -23,6 +23,8 @@ import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.junit4.ParameterFilter
 import com.android.tools.metalava.model.provider.InputFormat
 import com.android.tools.metalava.model.testing.CodebaseCreatorConfig
+import com.android.tools.metalava.model.testing.value.assertValuesAreStrictlyEqual
+import com.android.tools.metalava.model.testing.value.runValueTest
 import com.android.tools.metalava.model.testsuite.BaseModelTest
 import com.android.tools.metalava.model.testsuite.ModelSuiteRunner
 import com.android.tools.metalava.model.testsuite.value.BaseCommonParameterizedValueTest.Companion.testCases
@@ -31,6 +33,11 @@ import com.android.tools.metalava.model.testsuite.value.CommonParameterizedField
 import com.android.tools.metalava.model.testsuite.value.TestClassCreator.Companion.ATTRIBUTE_NAME
 import com.android.tools.metalava.model.testsuite.value.TestClassCreator.Companion.FIELD_NAME
 import com.android.tools.metalava.model.testsuite.value.ValueExample.Companion.valueExamples
+import com.android.tools.metalava.model.value.FieldReferenceValue
+import com.android.tools.metalava.model.value.Value
+import com.android.tools.metalava.model.value.ValueKind
+import com.android.tools.metalava.model.value.ValueUseSite
+import com.android.tools.metalava.testing.EntryPointCallerRule
 import com.android.tools.metalava.testing.TestFileCache
 import com.android.tools.metalava.testing.cacheIn
 import com.android.tools.metalava.testing.jarFromSources
@@ -38,7 +45,10 @@ import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import com.android.tools.metalava.testing.signature
 import kotlin.test.assertEquals
-import org.junit.Test
+import kotlin.test.assertTrue
+import org.junit.Assert.assertArrayEquals
+import org.junit.AssumptionViolatedException
+import org.junit.Rule
 import org.junit.runners.Parameterized
 
 /**
@@ -51,9 +61,9 @@ import org.junit.runners.Parameterized
  *
  * [TestCase] provides the details of the test to run but the actual test logic is provided by
  * subclasses of this class. Each subclass selects the [TestCase]s that apply to it and then runs
- * the test to check different [ValueUseSite]s, e.g. annotation value, method default value, field
- * value. This approach was taken instead of having methods for each use of a value because the
- * values should be being handled consistently irrespective of where they are being used, but
+ * the test to check different [LegacyValueUseSite]s, e.g. annotation value, method default value,
+ * field value. This approach was taken instead of having methods for each use of a value because
+ * the values should be being handled consistently irrespective of where they are being used, but
  * currently they are not. Having all the tests for them being run on the same [TestCase]s
  * highlights the inconsistencies and makes it easier to migrate to consistent handling of the
  * values.
@@ -68,29 +78,35 @@ import org.junit.runners.Parameterized
  *
  * The set of tests to run is defined by a list of [ValueExample]s which provide the necessary
  * information to construct [TestClass]es and the [TestCase]s that run against them. Each
- * [ValueExample] is tested in all possible [ValueUseSite] (although some examples do not work on
- * some sites). The aim is to create an exhaustive set of tests that first map out the existing
+ * [ValueExample] is tested in all possible [LegacyValueUseSite] (although some examples do not work
+ * on some sites). The aim is to create an exhaustive set of tests that first map out the existing
  * inconsistencies and eventually ensure consistent behavior.
  *
  * @param testFileCache the [TestFileCache] in which all the [TestFile]s used by this test class
  *   will be cached.
  * @param testJarFile the [TestFile] for the jar file built from all the java source files used by
  *   this test class.
- * @param valueUseSite the [ValueUseSite] being tested by this class.
- * @param legacySourceGetter gets the legacy source representation as expected by
- *   [ValueExample.expectedLegacySourceFor].
+ * @param legacyValueUseSite the [LegacyValueUseSite] being tested by this class.
  */
 abstract class BaseCommonParameterizedValueTest(
     private val testFileCache: TestFileCache,
     private val testJarFile: TestFile,
-    private val valueUseSite: ValueUseSite,
-    private val legacySourceGetter: TestCaseContext.() -> String,
+    private val legacyValueUseSite: LegacyValueUseSite,
 ) : BaseModelTest() {
 
     @Parameterized.Parameter(0) lateinit var codebaseProducer: CodebaseProducer
 
     @Parameterized.Parameter(1) lateinit var testCase: TestCase
 
+    /**
+     * Will try and rewrite the stack trace of any test failures to refer to the location where the
+     * [ValueExample] that is currently being tested was created.
+     */
+    @get:Rule
+    val entryPointCallerRule = EntryPointCallerRule {
+        testCase.valueExample.entryPointCallerTracker
+    }
+
     /** Produces a [Codebase] to test and runs the test on it. */
     sealed class CodebaseProducer(val kind: ProducerKind) {
         /**
@@ -107,10 +123,10 @@ abstract class BaseCommonParameterizedValueTest(
 
         protected fun CodebaseContext.runTestCase(
             testCase: TestCase,
-            valueUseSite: ValueUseSite,
+            legacyValueUseSite: LegacyValueUseSite,
             test: TestCaseContext.() -> Unit
         ) {
-            val testCaseContext = TestCaseContext(this, testCase, kind, valueUseSite)
+            val testCaseContext = TestCaseContext(this, testCase, kind, legacyValueUseSite)
             testCaseContext.test()
         }
 
@@ -124,12 +140,13 @@ abstract class BaseCommonParameterizedValueTest(
         /** The [ValueExample] on which this test case is based. */
         val valueExample: ValueExample,
     ) : Assertions {
-        private val testClassesByInputFormat = mutableMapOf<InputFormat, TestClasses>()
+        private val testClassesByInputFormat = mutableMapOf<InputFormat, TestClasses?>()
 
-        /** Get the [TestClass] appropriate for [valueUseSite]. */
-        fun testClassFor(inputFormat: InputFormat, valueUseSite: ValueUseSite) =
+        /** Get the [TestClass] appropriate for [legacyValueUseSite]. */
+        fun testClassFor(inputFormat: InputFormat, legacyValueUseSite: LegacyValueUseSite) =
             testClassesByInputFormat
                 .computeIfAbsent(inputFormat) {
+                    if (it !in valueExample.validForInputFormats) return@computeIfAbsent null
                     val creator =
                         when (it) {
                             InputFormat.JAVA -> JavaTestClassCreator
@@ -140,7 +157,7 @@ abstract class BaseCommonParameterizedValueTest(
 
                     TestClasses(creator, valueExample)
                 }
-                .testClassFor(valueUseSite)
+                ?.testClassFor(legacyValueUseSite)
 
         override fun toString() = valueExample.name
     }
@@ -148,10 +165,10 @@ abstract class BaseCommonParameterizedValueTest(
     /**
      * Creates and caches the [TestClass]es needed for [valueExample].
      *
-     * When first requested for a [TestClass] for [ValueUseSite] in [testClassFor] it will invoke
-     * [testClassCreator] to create one, cache it and return it. On subsequent calls it will return
-     * the cached version. This ensures a single [TestClass] for each [ValueUseSite]/[ValueExample]
-     * combination.
+     * When first requested for a [TestClass] for [LegacyValueUseSite] in [testClassFor] it will
+     * invoke [testClassCreator] to create one, cache it and return it. On subsequent calls it will
+     * return the cached version. This ensures a single [TestClass] for each
+     * [LegacyValueUseSite]/[ValueExample] combination.
      *
      * @param testClassCreator responsible for creating instances of the [TestClass] that this
      *   caches.
@@ -161,14 +178,14 @@ abstract class BaseCommonParameterizedValueTest(
         private val testClassCreator: TestClassCreator,
         private val valueExample: ValueExample
     ) {
-        /** Get the [TestClass] appropriate for [valueUseSite]. */
-        fun testClassFor(valueUseSite: ValueUseSite) =
-            when (valueUseSite) {
-                ValueUseSite.ATTRIBUTE_VALUE,
-                ValueUseSite.ANNOTATION_TO_SOURCE -> annotatedWithAnnotationWithoutDefaults
-                ValueUseSite.ATTRIBUTE_DEFAULT_VALUE -> annotationWithDefaults
-                ValueUseSite.FIELD_VALUE,
-                ValueUseSite.FIELD_WRITE_WITH_SEMICOLON -> field
+        /** Get the [TestClass] appropriate for [legacyValueUseSite]. */
+        fun testClassFor(legacyValueUseSite: LegacyValueUseSite) =
+            when (legacyValueUseSite) {
+                LegacyValueUseSite.ATTRIBUTE_VALUE,
+                LegacyValueUseSite.ANNOTATION_TO_SOURCE -> annotatedWithAnnotationWithoutDefaults
+                LegacyValueUseSite.ATTRIBUTE_DEFAULT_VALUE -> annotationWithDefaults
+                LegacyValueUseSite.FIELD_VALUE,
+                LegacyValueUseSite.FIELD_WRITE_WITH_SEMICOLON -> field
             }
 
         /**
@@ -274,11 +291,11 @@ abstract class BaseCommonParameterizedValueTest(
                 SourceCodebaseProducer,
             )
 
-        internal fun testCasesForValueUseSite(valueUseSite: ValueUseSite) =
+        internal fun testCasesForValueUseSite(legacyValueUseSite: LegacyValueUseSite) =
             testCases.filter {
                 // Only select TestCase's whose ValueExample is suitable for the specified
-                // ValueUseSite.
-                valueUseSite in it.valueExample.suitableFor
+                // LegacyValueUseSite.
+                legacyValueUseSite in it.valueExample.suitableFor
             }
 
         /** Create cross product of [codebaseProducers] and [testCases]. */
@@ -300,15 +317,15 @@ abstract class BaseCommonParameterizedValueTest(
             testCase: TestCase,
             test: TestCaseContext.() -> Unit
         ) {
+            val testClass =
+                testCase.testClassFor(inputFormat, legacyValueUseSite)
+                    ?: error("No $inputFormat class provided for $legacyValueUseSite")
             // Cache the sources so that they can be reused.
-            val sources =
-                testCase.testClassFor(inputFormat, valueUseSite).testFileSet.map {
-                    it.cacheIn(testFileCache)
-                }
+            val sources = testClass.testFileSet.map { it.cacheIn(testFileCache) }
 
             // Run the test on the sources.
             runSourceCodebaseTest(inputSet(sources.toList())) {
-                runTestCase(testCase, valueUseSite, test)
+                runTestCase(testCase, legacyValueUseSite, test)
             }
         }
     }
@@ -337,7 +354,7 @@ abstract class BaseCommonParameterizedValueTest(
                         additionalClassPath = listOf(cachedJarFile.createFile(temporaryFolder.root))
                     ),
             ) {
-                runTestCase(testCase, valueUseSite, test)
+                runTestCase(testCase, legacyValueUseSite, test)
             }
         }
     }
@@ -347,9 +364,9 @@ abstract class BaseCommonParameterizedValueTest(
      *
      * Makes it easy to share behavior between them.
      */
-    open class BaseCompanion(private val valueUseSite: ValueUseSite) {
-        /** The list of all [valueUseSite] test cases. */
-        private val valueUseTestCases = testCasesForValueUseSite(valueUseSite)
+    open class BaseCompanion(private val legacyValueUseSite: LegacyValueUseSite) {
+        /** The list of all [legacyValueUseSite] test cases. */
+        private val valueUseTestCases = testCasesForValueUseSite(legacyValueUseSite)
 
         /** The list of parameters for this test class. */
         val testParameters = testCasesForCodebaseProducers(valueUseTestCases)
@@ -362,7 +379,9 @@ abstract class BaseCommonParameterizedValueTest(
             // The jar includes all the distinct [TestFile]s used by [testCases].
             val sourcesForJar = buildSet {
                 for (testCase in testCases) {
-                    addAll(testCase.testClassFor(InputFormat.JAVA, valueUseSite).testFileSet)
+                    testCase.testClassFor(InputFormat.JAVA, legacyValueUseSite)?.testFileSet?.let {
+                        addAll(it)
+                    }
                 }
             }
 
@@ -379,15 +398,17 @@ abstract class BaseCommonParameterizedValueTest(
         delegate: CodebaseContext,
         private val testCase: TestCase,
         val producerKind: ProducerKind,
-        private val valueUseSite: ValueUseSite,
+        private val legacyValueUseSite: LegacyValueUseSite,
     ) : CodebaseContext by delegate {
         /** Get the [ClassItem] to be tested from this [Codebase]. */
         val testClassItem
             get(): ClassItem {
-                val qualifiedName =
-                    "test.pkg.${testCase.testClassFor(inputFormat, valueUseSite).className}"
-                return codebase.resolveClass(qualifiedName)
-                    ?: error("Expected $qualifiedName to be defined")
+                return testCase.testClassFor(inputFormat, legacyValueUseSite)?.className?.let {
+                    className ->
+                    val qualifiedName = "test.pkg.$className"
+                    codebase.resolveClass(qualifiedName)
+                        ?: error("Expected $qualifiedName to be defined")
+                } ?: error("No $inputFormat class provided for $legacyValueUseSite")
             }
     }
 
@@ -413,22 +434,115 @@ abstract class BaseCommonParameterizedValueTest(
         actualGetter: TestCaseContext.() -> T,
     ) {
         runTestOnCodebase {
+            // If a test is not valid for the expected value then it is not valid for any other
+            // tests from the same example so check to make sure that it is valid, skipping if it is
+            // not.
+            skipTestIfNotValidForExpectedValue(
+                testCase.valueExample.expectedValue.expectationFor(producerKind, legacyValueUseSite)
+            )
+
             // Get the actual value.
             val actual = actualGetter()
 
             // Get the expected value.
-            val expected = expectation.expectationFor(producerKind, valueUseSite, codebase)
+            val expected = expectation.expectationFor(producerKind, legacyValueUseSite)
 
             // Compare the two.
-            assertEquals(expected, actual)
+            if (expected is Array<*> && actual is Array<*>) {
+                assertArrayEquals(expected, actual)
+            } else {
+                assertEquals(expected, actual)
+            }
         }
     }
 
-    @Test
-    fun testLegacySource() {
+    /**
+     * Check the [ValueExample.expectedLegacySource] against the [String] returned by
+     * [LegacyValueUseSite.legacySourceGetter].
+     */
+    protected fun checkLegacySource() {
         val expectedLegacySource = testCase.valueExample.expectedLegacySourceFor(inputFormat)
+        val legacySourceGetter =
+            legacyValueUseSite.legacySourceGetter
+                ?: error(
+                    "LegacyValueUseSite.$legacyValueUseSite does not provide a legacySourceGetter"
+                )
+
         runExpectationTest(expectedLegacySource, legacySourceGetter)
     }
+
+    /**
+     * Check the [ValueExample.expectedValue] against the [Value] returned by [actualValueGetter].
+     */
+    protected fun checkExpectedValue(
+        actualValueGetter: TestCaseContext.() -> Value?,
+    ) {
+        runTestOnCodebase {
+            // Get the expected value.
+            val expectation = testCase.valueExample.expectedValue
+            expectation.expectationFor(producerKind, legacyValueUseSite).runValueTest { expected ->
+                // Make sure the expected value is valid for this test.
+                skipTestIfNotValidForExpectedValue(expected)
+
+                // Filter the expected value for fields. FieldItem.constantValue can only be a
+                // constant value, i.e. a primitive or String literal. However, the source can be
+                // given a non-constant value, e.g. an array, field reference, etc. A reference to
+                // a constant field will be replaced with its constant value but otherwise the field
+                // will have a null expectation. This ensures that the expectation is correct.
+                val filteredExpected =
+                    if (expected != null && legacyValueUseSite.valueUseSite == ValueUseSite.FIELD) {
+                        // Fields only use constant literal values.
+                        expected.asLiteralValue()
+                    } else expected
+
+                // Get the actual value.
+                val actual = actualValueGetter()
+
+                // Strictly compare the Values to ensure that where necessary they have included any
+                // information needed to generate correct legacy string representations.
+                assertValuesAreStrictlyEqual(filteredExpected, actual)
+
+                // Fields are equal if they reference the same qualified class name and field name.
+                // However, for testing purposes this needs to verify that their constant values
+                // also match.
+                if (filteredExpected is FieldReferenceValue) {
+                    assertTrue(
+                        actual is FieldReferenceValue,
+                        message = "value is not a field it is ${actual?.javaClass}"
+                    )
+                    assertValuesAreStrictlyEqual(
+                        filteredExpected.asLiteralValue(),
+                        actual.asLiteralValue(),
+                        message = "field constant: "
+                    )
+                }
+            }
+        }
+    }
+
+    /**
+     * Check to make sure that the test is valid for the combination of [expectedValue],
+     * [inputFormat] and [legacyValueUseSite].
+     *
+     * These tests cannot be filtered out by the [ParameterFilter] as that only has access to the
+     * first two.
+     */
+    private fun skipTestIfNotValidForExpectedValue(expectedValue: Value?) {
+        // Null expected values are ok.
+        if (expectedValue == null) return
+
+        // Only fields have special restrictions.
+        if (legacyValueUseSite.valueUseSite != ValueUseSite.FIELD) return
+
+        // Signature file fields only use literal values in their initializers. So, using any other
+        // kind is invalid.
+        val kind = expectedValue.kind
+        if (inputFormat == InputFormat.SIGNATURE && kind !in ValueKind.LITERAL_KINDS) {
+            throw AssumptionViolatedException(
+                "Using value `$expectedValue` as an initializer for a field in a signature file is invalid; ignoring"
+            )
+        }
+    }
 }
 
 /** Interface for objects that create [TestClass] instances. */
@@ -491,6 +605,18 @@ object JavaTestClassCreator : TestClassCreator {
                 package test.pkg;
                 public interface Constants {
                     String STRING_CONSTANT = "constant";
+                    int INT_CONSTANT = 37;
+                    long LONG_CONSTANT = 9L;
+                }
+            """
+        )
+
+    private val testGenericClass =
+        java(
+            """
+                package test.pkg;
+                public interface GenericClass<T> {
+                    String STRING_CONSTANT = "constant";
                 }
             """
         )
@@ -523,6 +649,18 @@ object JavaTestClassCreator : TestClassCreator {
             .asTestClass("OtherAnnotation")
             .dependsOn(testEnumClass)
 
+    private val singleValueAnnotationClass =
+        java(
+                """
+                    package test.pkg;
+                    
+                    public @interface SingleValueAnnotation {
+                        String value();
+                    }
+                """
+            )
+            .asTestClass("SingleValueAnnotation")
+
     /** Append all the imports provided by this list to [buffer]. */
     private fun appendImportsTo(valueExample: ValueExample, buffer: StringBuilder) {
         for (javaImport in valueExample.javaImports) {
@@ -565,7 +703,9 @@ object JavaTestClassCreator : TestClassCreator {
             )
             .asTestClass(className)
             .dependsOn(otherAnnotationClass)
+            .dependsOn(singleValueAnnotationClass)
             .dependsOn(testConstantsClass)
+            .dependsOn(testGenericClass)
     }
 
     /**
@@ -629,7 +769,9 @@ object JavaTestClassCreator : TestClassCreator {
             )
             .asTestClass(className)
             .dependsOn(otherAnnotationClass)
+            .dependsOn(singleValueAnnotationClass)
             .dependsOn(testConstantsClass)
+            .dependsOn(testGenericClass)
     }
 }
 
@@ -641,6 +783,20 @@ object KotlinTestClassCreator : TestClassCreator {
                 package test.pkg
                 object Constants {
                     const val STRING_CONSTANT = "constant"
+                    const val INT_CONSTANT = 37
+                    const val LONG_CONSTANT = 9L
+                }
+            """
+        )
+
+    private val testGenericClass =
+        kotlin(
+            """
+                package test.pkg
+                interface GenericClass<T> {
+                    companion object {
+                        const val STRING_CONSTANT = "constant"
+                    }
                 }
             """
         )
@@ -661,18 +817,41 @@ object KotlinTestClassCreator : TestClassCreator {
                 """
                     package test.pkg
 
+                    import kotlin.reflect.KClass
+
                     annotation class OtherAnnotation(
-                        val classType: Class<*> = void.javaClass,
+                        val classType: KClass<*> = Unit::class,
                         val enumType: TestEnum = TestEnum.DEFAULT,
                         val intType: Int = -1,
                         val stringType: String = "default",
-                        val stringArrayType: Array<String> = emptyArray(),
+                        val stringArrayType: Array<String> = [],
                     )
                 """
             )
             .asTestClass("OtherAnnotation")
             .dependsOn(testEnumClass)
 
+    private val singleValueAnnotationClass =
+        kotlin(
+                """
+                    package test.pkg
+
+                    annotation class SingleValueAnnotation(
+                        val value: String,
+                    )
+                """
+            )
+            .asTestClass("SingleValueAnnotation")
+
+    /** Append all the imports provided by this list to [buffer]. */
+    private fun appendImportsTo(valueExample: ValueExample, buffer: StringBuilder) {
+        for (kotlinImport in valueExample.kotlinImports) {
+            buffer.append("import ")
+            buffer.append(kotlinImport)
+            buffer.append("\n")
+        }
+    }
+
     /**
      * Create an annotation [TestClass] for [valueExample].
      *
@@ -689,14 +868,16 @@ object KotlinTestClassCreator : TestClassCreator {
         return kotlin(
                 buildString {
                     append("package test.pkg\n")
+                    appendImportsTo(valueExample, this)
                     append("annotation class $className(\n")
                     append("    val ")
                     append(ATTRIBUTE_NAME)
                     append(": ")
-                    append(valueExample.kotlinType)
+                    append(valueExample.kotlinTypeForAnnotation)
                     if (withDefaults) {
                         append(" = ")
-                        append(valueExample.kotlinExpression)
+                        // Kotlin nested annotations do not use an @ prefix so remove it.
+                        append(valueExample.kotlinExpressionForAnnotation.removePrefix("@"))
                     }
                     append("\n")
                     append(")\n")
@@ -704,7 +885,9 @@ object KotlinTestClassCreator : TestClassCreator {
             )
             .asTestClass(className)
             .dependsOn(otherAnnotationClass)
+            .dependsOn(singleValueAnnotationClass)
             .dependsOn(testConstantsClass)
+            .dependsOn(testGenericClass)
     }
 
     /**
@@ -725,12 +908,14 @@ object KotlinTestClassCreator : TestClassCreator {
         return kotlin(
                 buildString {
                     append("package test.pkg\n")
+                    appendImportsTo(valueExample, this)
                     append("@")
                     append(annotationTestClass.className)
                     append("(")
                     append(ATTRIBUTE_NAME)
                     append(" = ")
-                    append(valueExample.kotlinExpression)
+                    // Kotlin nested annotations do not use an @ prefix so remove it.
+                    append(valueExample.kotlinExpressionForAnnotation.removePrefix("@"))
                     append(")\n")
                     append("class $className {}\n")
                 }
@@ -753,6 +938,7 @@ object KotlinTestClassCreator : TestClassCreator {
         return kotlin(
                 buildString {
                     append("package test.pkg\n")
+                    appendImportsTo(valueExample, this)
                     append("class $className {\n")
                     append("    companion object {\n")
                     append("        const val ")
@@ -768,7 +954,9 @@ object KotlinTestClassCreator : TestClassCreator {
             )
             .asTestClass(className)
             .dependsOn(otherAnnotationClass)
+            .dependsOn(singleValueAnnotationClass)
             .dependsOn(testConstantsClass)
+            .dependsOn(testGenericClass)
     }
 }
 
@@ -782,6 +970,11 @@ object SignatureTestClassCreator : TestClassCreator {
                 package test.pkg {
                   public interface Constants {
                     field public static final String STRING_CONSTANT = "constant";
+                    field public static final int INT_CONSTANT = 37;
+                    field public static final long LONG_CONSTANT = 9L;
+                  }
+                  public interface GenericClass<T> {
+                    field public static final String STRING_CONSTANT = "constant";
                   }
                 }
             """
@@ -878,7 +1071,7 @@ object SignatureTestClassCreator : TestClassCreator {
                 buildString {
                     append("// Signature format: 2.0\n")
                     append("package test.pkg {\n")
-                    append("  @")
+                    append("  @test.pkg.")
                     append(annotationTestClass.className)
                     append("(")
                     append(ATTRIBUTE_NAME)
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonLegacyValueFormatterTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonLegacyValueFormatterTest.kt
new file mode 100644
index 000000000..ffb888bfa
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonLegacyValueFormatterTest.kt
@@ -0,0 +1,618 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.value
+
+import com.android.tools.metalava.model.Assertions.Companion.assertClass
+import com.android.tools.metalava.model.Assertions.Companion.assertMethod
+import com.android.tools.metalava.model.Assertions.Companion.assertResolvedClass
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ClassResolver
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.PrimitiveTypeItem.Primitive
+import com.android.tools.metalava.model.junit4.ParameterFilter
+import com.android.tools.metalava.model.provider.Capability
+import com.android.tools.metalava.model.provider.InputFormat
+import com.android.tools.metalava.model.testing.CodebaseCreatorConfig
+import com.android.tools.metalava.model.testing.RequiresCapabilities
+import com.android.tools.metalava.model.testing.value.annotationValue
+import com.android.tools.metalava.model.testing.value.arrayValue
+import com.android.tools.metalava.model.testing.value.fieldReferenceValue
+import com.android.tools.metalava.model.testing.value.lazyFieldReferenceValue
+import com.android.tools.metalava.model.testing.value.literalValue
+import com.android.tools.metalava.model.testing.value.primitiveValueForKind
+import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.model.testsuite.ModelSuiteRunner
+import com.android.tools.metalava.model.value.DoubleValue
+import com.android.tools.metalava.model.value.LegacyValueFormatter
+import com.android.tools.metalava.model.value.LegacyValueFormatter.InlineFieldValue
+import com.android.tools.metalava.model.value.LegacyValueFormatter.Settings
+import com.android.tools.metalava.model.value.Value
+import com.android.tools.metalava.model.value.ValueStringConfiguration
+import com.android.tools.metalava.testing.TestFileCache
+import com.android.tools.metalava.testing.TestFileCacheRule
+import com.android.tools.metalava.testing.cacheIn
+import com.android.tools.metalava.testing.jarFromSources
+import com.android.tools.metalava.testing.java
+import com.android.tools.metalava.testing.kotlin
+import com.android.tools.metalava.testing.signature
+import kotlin.test.assertEquals
+import org.junit.ClassRule
+import org.junit.Ignore
+import org.junit.Test
+import org.junit.runners.Parameterized
+
+/** Tests for [LegacyValueFormatter] that will run it across jars and sources. */
+class CommonLegacyValueFormatterTest : BaseModelTest() {
+
+    /** The [Codebase] producer kind. */
+    @Parameterized.Parameter(0) lateinit var producerKind: ProducerKind
+
+    companion object {
+        /** Run the tests for each [ProducerKind]. */
+        @JvmStatic @Parameterized.Parameters fun params() = ProducerKind.entries
+
+        /** Filter the parameters. */
+        @JvmStatic
+        @ParameterFilter
+        fun parameterFilter(
+            config: CodebaseCreatorConfig<ModelSuiteRunner>,
+            producerKind: ProducerKind,
+        ): Boolean {
+            val inputFormat = config.inputFormat
+
+            // Supports all input formats but only Java can produce jars.
+            return (inputFormat == InputFormat.JAVA || producerKind != ProducerKind.JAR)
+        }
+
+        /** Create a [TestFileCache] whose lifespan encompasses all the tests in this class. */
+        @ClassRule @JvmField val testFileCacheRule = TestFileCacheRule()
+
+        /**
+         * Java file used in [checkFormatting] to provide context for [LegacyValueFormatter.format].
+         */
+        private val javaFiles =
+            listOf(
+                    java(
+                        """
+                            package test.pkg;
+                            public interface Foo {
+                                void method();
+                            }
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+                            public class Hidden {
+                                /** @hide */
+                                public static final int FIELD = 2;
+                                /** @hide */
+                                public static final int FIELD_NO_VALUE = Integer.parseInt("2");
+                            }
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+                            /** @removed */
+                            public class Removed {
+                                public static final int FIELD = 3;
+                                public static final int FIELD_NO_VALUE = Integer.parseInt("3");
+                            }
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+                            class NotPublic {
+                                static final int FIELD = 4;
+                                static final int FIELD_NO_VALUE = Integer.parseInt("4");
+                            }
+                        """
+                    ),
+                )
+                .map { it.cacheIn(testFileCacheRule) }
+
+        /**
+         * Fake Java file used in [checkFormatting] when [producerKind] is [ProducerKind.JAR] just
+         * to force the [Codebase] to be created so the classes from the jar file can be accessed.
+         */
+        private val fakeJavaFile =
+            java(
+                    """
+                        package fake;
+                        public class Fake {}
+                    """
+                )
+                .cacheIn(testFileCacheRule)
+
+        /**
+         * Kotlin file used in [checkFormatting] to provide context for
+         * [LegacyValueFormatter.format].
+         */
+        val kotlinFiles =
+            listOf(
+                    kotlin(
+                        """
+                            package test.pkg
+                            interface Foo {
+                                fun method()
+                            }
+                        """
+                    ),
+                    kotlin(
+                        """
+                            package test.pkg
+                            object Hidden {
+                                /** @hide */
+                                const val FIELD = 2
+                                /** @hide */
+                                val FIELD_NO_VALUE = "2".toInt()
+                            }
+                        """
+                    ),
+                    kotlin(
+                        """
+                            package test.pkg
+                            /** @removed */
+                            object Removed {
+                                const val FIELD = 3
+                                val FIELD_NO_VALUE = "3".toInt()
+                            }
+                        """
+                    ),
+                    kotlin(
+                        """
+                            package test.pkg
+                            object NotPublic {
+                                internal const val FIELD = 4
+                                internal val FIELD_NO_VALUE = "4".toInt()
+                            }
+                        """
+                    ),
+                )
+                .map { it.cacheIn(testFileCacheRule) }
+
+        /**
+         * Signature file used in [checkFormatting] to provide context for
+         * [LegacyValueFormatter.format].
+         */
+        private val signatureFile =
+            signature(
+                    """
+                        // Signature format: 2.0
+                        package test.pkg {
+                          public interface Foo {
+                            method public void method();
+                          }
+                        }
+                    """
+                )
+                .cacheIn(testFileCacheRule)
+
+        /**
+         * Jar file used in [checkFormatting] when [producerKind] is [ProducerKind.JAR] to provide
+         * context for [LegacyValueFormatter.format].
+         */
+        private val jarFile =
+            jarFromSources("test.jar", *javaFiles.toTypedArray()).cacheIn(testFileCacheRule)
+
+        /** Shared value for use in the tests. */
+        val DOUBLE_NAN = DoubleValue.NaN
+    }
+
+    /** Provides access to the information needed when formatting. */
+    private class FormattingContext(
+        delegate: CodebaseContext,
+        producerKind: ProducerKind,
+    ) : CodebaseContext by delegate {
+        /** The [ClassItem] that will provide the context. */
+        private val classItem =
+            // Classes loaded from the jar file have to be resolved, while classes loaded from
+            // sources do not.
+            if (producerKind == ProducerKind.JAR) codebase.assertResolvedClass("test.pkg.Foo")
+            else codebase.assertClass("test.pkg.Foo")
+
+        /** A method that can used for the context in [LegacyValueFormatter.format]. */
+        val method
+            get() = classItem.assertMethod("method", "")
+
+        fun LegacyValueFormatter.assertFormattedValue(expected: String, value: Value) {
+            assertEquals(expected, format(value, method), message = value.toString())
+        }
+    }
+
+    /**
+     * Check the formatting.
+     *
+     * Runs [body] on a [FormattingContext] that abstracts away the
+     */
+    private fun checkFormatting(body: FormattingContext.() -> Unit) {
+        val additionalClassPath =
+            when (producerKind) {
+                ProducerKind.JAR -> listOf(jarFile.createFile(temporaryFolder.root))
+                else -> emptyList()
+            }
+
+        val testFixture = TestFixture(additionalClassPath = additionalClassPath)
+
+        val testFiles =
+            when (inputFormat) {
+                InputFormat.SIGNATURE -> listOf(signatureFile)
+                InputFormat.JAVA ->
+                    if (producerKind == ProducerKind.JAR) listOf(fakeJavaFile) else javaFiles
+                InputFormat.KOTLIN -> kotlinFiles
+            }
+
+        runCodebaseTest(
+            inputSet(testFiles),
+            testFixture = testFixture,
+        ) {
+            FormattingContext(this, producerKind).body()
+        }
+    }
+
+    @Test
+    fun `Test replacement values - replaces`() {
+        checkFormatting {
+            val settings =
+                Settings(
+                    stringReplacement =
+                        mapOf(
+                            DOUBLE_NAN to "NOT_A_NUMBER",
+                        )
+                )
+            val formatter = LegacyValueFormatter(settings)
+            formatter.assertFormattedValue("NOT_A_NUMBER", DOUBLE_NAN)
+        }
+    }
+
+    @Test
+    fun `Test replacement values in array - replaces`() {
+        checkFormatting {
+            val settings =
+                Settings(
+                    stringReplacement =
+                        mapOf(
+                            DOUBLE_NAN to "NOT_A_NUMBER",
+                        )
+                )
+            val formatter = LegacyValueFormatter(settings)
+            formatter.assertFormattedValue("{NOT_A_NUMBER}", arrayValue(DOUBLE_NAN))
+        }
+    }
+
+    @Test
+    fun `Test replacement values in annotation - replaces`() {
+        checkFormatting {
+            val settings =
+                Settings(
+                    stringReplacement =
+                        mapOf(
+                            DOUBLE_NAN to "NOT_A_NUMBER",
+                        )
+                )
+            val formatter = LegacyValueFormatter(settings)
+            formatter.assertFormattedValue(
+                "@test.pkg.Anno(other = NOT_A_NUMBER)",
+                annotationValue(
+                    "test.pkg.Anno",
+                    "other" to DOUBLE_NAN,
+                )
+            )
+        }
+    }
+
+    @Test
+    fun `Test replacement values - does not replace`() {
+        checkFormatting {
+            val settings =
+                Settings(
+                    stringReplacement =
+                        mapOf(
+                            DOUBLE_NAN to "NOT_A_NUMBER",
+                        )
+                )
+            val formatter = LegacyValueFormatter(settings)
+            formatter.assertFormattedValue("3.0", literalValue(3.0))
+        }
+    }
+
+    @Test
+    fun `Test jar specific settings`() {
+        checkFormatting {
+            val sourceSettings = Settings(stringReplacement = mapOf(DOUBLE_NAN to "Source"))
+            val jarSettings = Settings(stringReplacement = mapOf(DOUBLE_NAN to "Jar"))
+            val formatter =
+                LegacyValueFormatter(
+                    javaSettings = sourceSettings,
+                    jarSettings = jarSettings,
+                )
+            val expected = if (producerKind == ProducerKind.JAR) "Jar" else "Source"
+            formatter.assertFormattedValue(expected, DOUBLE_NAN)
+        }
+    }
+
+    @RequiresCapabilities(Capability.JAVA)
+    @Test
+    fun `Test kotlin specific settings`() {
+        checkFormatting {
+            val javaSettings = Settings(stringReplacement = mapOf(DOUBLE_NAN to "Java"))
+            val kotlinSettings = Settings(stringReplacement = mapOf(DOUBLE_NAN to "Kotlin"))
+
+            val formatter =
+                LegacyValueFormatter(
+                    javaSettings = javaSettings,
+                    kotlinSettings = kotlinSettings,
+                )
+            val actual = formatter.format(DOUBLE_NAN, method)
+            val expected = if (inputFormat == InputFormat.JAVA) "Java" else "Kotlin"
+            assertEquals(expected, actual)
+        }
+    }
+
+    @Test
+    fun `Test char - useDoubleQuotesForChar = false`() {
+        checkFormatting {
+            val javaSettings = Settings(useDoubleQuotesForChar = false)
+            val formatter = LegacyValueFormatter(javaSettings = javaSettings)
+            formatter.assertFormattedValue("'a'", literalValue('a'))
+        }
+    }
+
+    @Test
+    fun `Test char - useDoubleQuotesForChar = true`() {
+        checkFormatting {
+            val javaSettings = Settings(useDoubleQuotesForChar = true)
+            val formatter = LegacyValueFormatter(javaSettings = javaSettings)
+            val actual = formatter.format(literalValue('a'), method)
+            assertEquals("\"a\"", actual)
+        }
+    }
+
+    @Test
+    fun `Test char - dropLongAndFloatTypeSuffix = false`() {
+        checkFormatting {
+            val javaSettings =
+                Settings(
+                    valueStringConfiguration =
+                        ValueStringConfiguration(
+                            useOriginalValueForNumbers = true,
+                        ),
+                    dropLongAndFloatTypeSuffix = false,
+                )
+            val formatter = LegacyValueFormatter(javaSettings = javaSettings)
+            formatter.assertFormattedValue("10L", literalValue(10L))
+            formatter.assertFormattedValue("10", primitiveValueForKind(Primitive.LONG, 10))
+            formatter.assertFormattedValue("2.3f", literalValue(2.3f))
+            formatter.assertFormattedValue("10", primitiveValueForKind(Primitive.FLOAT, 10))
+        }
+    }
+
+    @Test
+    fun `Test char - dropLongAndFloatTypeSuffix = true`() {
+        checkFormatting {
+            val javaSettings =
+                Settings(
+                    valueStringConfiguration =
+                        ValueStringConfiguration(
+                            useOriginalValueForNumbers = true,
+                        ),
+                    dropLongAndFloatTypeSuffix = true,
+                )
+            val formatter = LegacyValueFormatter(javaSettings = javaSettings)
+            formatter.assertFormattedValue("10", literalValue(10L))
+            formatter.assertFormattedValue("10", primitiveValueForKind(Primitive.LONG, 10))
+            formatter.assertFormattedValue("2.3", literalValue(2.3f))
+            formatter.assertFormattedValue("10", primitiveValueForKind(Primitive.FLOAT, 10))
+        }
+    }
+
+    @Test
+    fun `Test field - unresolvable`() {
+        checkFormatting {
+            val javaSettings = Settings()
+            val formatter = LegacyValueFormatter(javaSettings = javaSettings)
+            // Unresolvable fields should just use their name as a value MUST be provided.
+            formatter.assertFormattedValue(
+                "unknown.pkg.Unknown.FIELD",
+                lazyFieldReferenceValue(
+                    classResolver = ClassResolver.RETURN_NULL,
+                    "unknown.pkg.Unknown",
+                    "FIELD"
+                )
+            )
+        }
+    }
+
+    // Does not work with signature files as they do not contain inaccessible fields.
+    @RequiresCapabilities(Capability.JAVA)
+    @Test
+    fun `Test field - resolvable but inaccessible with no value - default`() {
+        checkFormatting {
+            val javaSettings = Settings()
+            val formatter = LegacyValueFormatter(javaSettings = javaSettings)
+
+            // Hidden fields with no value should just use their name as a value MUST be provided.
+            formatter.assertFormattedValue(
+                "test.pkg.Hidden.FIELD_NO_VALUE",
+                lazyFieldReferenceValue(
+                    codebase,
+                    "test.pkg.Hidden",
+                    "FIELD_NO_VALUE",
+                )
+            )
+
+            // Removed fields with no value should just use their name as a value MUST be provided.
+            formatter.assertFormattedValue(
+                "test.pkg.Removed.FIELD_NO_VALUE",
+                lazyFieldReferenceValue(codebase, "test.pkg.Removed", "FIELD_NO_VALUE")
+            )
+
+            // Non-`public` fields with no value should just use their name as a value MUST be
+            // provided.
+            formatter.assertFormattedValue(
+                "test.pkg.NotPublic.FIELD_NO_VALUE",
+                lazyFieldReferenceValue(codebase, "test.pkg.NotPublic", "FIELD_NO_VALUE")
+            )
+        }
+    }
+
+    // Does not work with signature files as they do not contain inaccessible fields.
+    @RequiresCapabilities(Capability.JAVA)
+    // Temporarily disable the test as it fails in snapshot because snapshot does not track
+    // removed and/or hidden status.
+    @Ignore
+    @Test
+    fun `Test field - resolvable but inaccessible with value - default`() {
+        checkFormatting {
+            val javaSettings = Settings()
+            val formatter = LegacyValueFormatter(javaSettings = javaSettings)
+
+            val hiddenExpected =
+                when (producerKind) {
+                    // @hide javadoc is not available in jars so they are not treated as hidden.
+                    ProducerKind.JAR -> "test.pkg.Hidden.FIELD"
+                    // Hidden fields with a value should just use that value.
+                    ProducerKind.SOURCE -> "2"
+                }
+            formatter.assertFormattedValue(
+                hiddenExpected,
+                lazyFieldReferenceValue(codebase, "test.pkg.Hidden", "FIELD")
+            )
+
+            val removedExpected =
+                when (producerKind) {
+                    // @removed javadoc is not available in jars so they are not treated as removed.
+                    ProducerKind.JAR -> "test.pkg.Removed.FIELD"
+                    // Removed fields with a value should just use that value.
+                    ProducerKind.SOURCE -> "3"
+                }
+            formatter.assertFormattedValue(
+                removedExpected,
+                lazyFieldReferenceValue(codebase, "test.pkg.Removed", "FIELD")
+            )
+
+            // Non-`public` fields with a value should just use that value.
+            formatter.assertFormattedValue(
+                "4",
+                lazyFieldReferenceValue(codebase, "test.pkg.NotPublic", "FIELD")
+            )
+        }
+    }
+
+    // Does not work with signature files as they do not contain inaccessible fields.
+    @RequiresCapabilities(Capability.JAVA)
+    @Test
+    fun `Test field - resolvable and inaccessible with no value - WHEN_HIDDEN_OR_REMOVED`() {
+        checkFormatting {
+            val javaSettings = Settings(inlineFields = InlineFieldValue.WHEN_INACCESSIBLE)
+            val formatter = LegacyValueFormatter(javaSettings = javaSettings)
+
+            // Hidden fields with no value should just use their name as a value MUST be provided.
+            formatter.assertFormattedValue(
+                "test.pkg.Hidden.FIELD_NO_VALUE",
+                lazyFieldReferenceValue(
+                    codebase,
+                    "test.pkg.Hidden",
+                    "FIELD_NO_VALUE",
+                )
+            )
+
+            // Removed fields with no value should just use their name as a value MUST be provided.
+            formatter.assertFormattedValue(
+                "test.pkg.Removed.FIELD_NO_VALUE",
+                lazyFieldReferenceValue(codebase, "test.pkg.Removed", "FIELD_NO_VALUE")
+            )
+
+            // Non-`public` fields that are not hidden or removed should be kept.
+            formatter.assertFormattedValue(
+                "test.pkg.NotPublic.FIELD_NO_VALUE",
+                lazyFieldReferenceValue(codebase, "test.pkg.NotPublic", "FIELD_NO_VALUE")
+            )
+        }
+    }
+
+    // Does not work with signature files as they do not contain inaccessible fields.
+    @RequiresCapabilities(Capability.JAVA)
+    // Temporarily disable the test as it fails in snapshot because snapshot does not track
+    // removed and/or hidden status.
+    @Ignore
+    @Test
+    fun `Test field - resolvable and inaccessible with value - WHEN_HIDDEN_OR_REMOVED`() {
+        checkFormatting {
+            val javaSettings = Settings(inlineFields = InlineFieldValue.WHEN_HIDDEN_OR_REMOVED)
+            val formatter = LegacyValueFormatter(javaSettings = javaSettings)
+
+            val hiddenExpected =
+                when (producerKind) {
+                    // @hide javadoc is not available in jars so they are not treated as hidden.
+                    ProducerKind.JAR -> "test.pkg.Hidden.FIELD"
+                    // Hidden fields with a value should just use that value.
+                    ProducerKind.SOURCE -> "2"
+                }
+            formatter.assertFormattedValue(
+                hiddenExpected,
+                lazyFieldReferenceValue(codebase, "test.pkg.Hidden", "FIELD")
+            )
+
+            val removedExpected =
+                when (producerKind) {
+                    // @removed javadoc is not available in jars so they are not treated as removed.
+                    ProducerKind.JAR -> "test.pkg.Removed.FIELD"
+                    // Removed fields with a value should just use that value.
+                    ProducerKind.SOURCE -> "3"
+                }
+            formatter.assertFormattedValue(
+                removedExpected,
+                lazyFieldReferenceValue(codebase, "test.pkg.Removed", "FIELD")
+            )
+
+            // Non-`public` fields that are not hidden or removed should be kept.
+            formatter.assertFormattedValue(
+                "test.pkg.NotPublic.FIELD",
+                lazyFieldReferenceValue(codebase, "test.pkg.NotPublic", "FIELD")
+            )
+        }
+    }
+
+    @Test
+    fun `Test field - always inline with no value`() {
+        checkFormatting {
+            val javaSettings = Settings(inlineFields = InlineFieldValue.ALWAYS)
+            val formatter = LegacyValueFormatter(javaSettings = javaSettings)
+            // Inlined fields with no value just use their name as a value MUST be provided.
+            formatter.assertFormattedValue(
+                "test.pkg.AlwaysInline.FIELD",
+                fieldReferenceValue("test.pkg.AlwaysInline", "FIELD")
+            )
+        }
+    }
+
+    @Test
+    fun `Test field - always inline with value`() {
+        checkFormatting {
+            val javaSettings = Settings(inlineFields = InlineFieldValue.ALWAYS)
+            val formatter = LegacyValueFormatter(javaSettings = javaSettings)
+            // Inlined fields with a value should just that that value.
+            formatter.assertFormattedValue(
+                "99",
+                fieldReferenceValue("test.pkg.AlwaysInline", "FIELD", literalValue(99))
+            )
+        }
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedAnnotationToSourceValueTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedAnnotationToSourceValueTest.kt
index 58e6d5833..79639d284 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedAnnotationToSourceValueTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedAnnotationToSourceValueTest.kt
@@ -16,10 +16,11 @@
 
 package com.android.tools.metalava.model.testsuite.value
 
-import com.android.tools.metalava.model.testsuite.value.ValueUseSite.ANNOTATION_TO_SOURCE
+import com.android.tools.metalava.model.testsuite.value.LegacyValueUseSite.ANNOTATION_TO_SOURCE
 import com.android.tools.metalava.testing.TestFileCache
 import com.android.tools.metalava.testing.TestFileCacheRule
 import org.junit.ClassRule
+import org.junit.Test
 import org.junit.runners.Parameterized
 
 /** Run parameterized tests for [ANNOTATION_TO_SOURCE]. */
@@ -28,16 +29,6 @@ class CommonParameterizedAnnotationToSourceValueTest :
         testFileCacheRule.cache,
         testJarFile,
         ANNOTATION_TO_SOURCE,
-        legacySourceGetter = {
-            // Get the annotation to test.
-            val annotation = testClassItem.modifiers.annotations().first()
-
-            // Generate the whole annotation representation.
-            val wholeAnnotation = annotation.toSource()
-
-            // Extract the value from the whole annotation.
-            wholeAnnotation.substringAfter("=").substringBeforeLast(")")
-        },
     ) {
     companion object : BaseCompanion(ANNOTATION_TO_SOURCE) {
         /** Create a [TestFileCache] whose lifespan encompasses all the tests in this class. */
@@ -46,4 +37,9 @@ class CommonParameterizedAnnotationToSourceValueTest :
         /** Supply the list of test cases as the parameters for this test class. */
         @JvmStatic @Parameterized.Parameters fun params() = testParameters
     }
+
+    @Test
+    fun testLegacySource() {
+        checkLegacySource()
+    }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedAttributeDefaultValueTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedAttributeDefaultValueTest.kt
index f35947bad..2efe63927 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedAttributeDefaultValueTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedAttributeDefaultValueTest.kt
@@ -16,12 +16,12 @@
 
 package com.android.tools.metalava.model.testsuite.value
 
-import com.android.tools.metalava.model.Assertions.Companion.assertMethod
+import com.android.tools.metalava.model.testsuite.value.LegacyValueUseSite.ATTRIBUTE_DEFAULT_VALUE
 import com.android.tools.metalava.model.testsuite.value.TestClassCreator.Companion.ATTRIBUTE_NAME
-import com.android.tools.metalava.model.testsuite.value.ValueUseSite.ATTRIBUTE_DEFAULT_VALUE
 import com.android.tools.metalava.testing.TestFileCache
 import com.android.tools.metalava.testing.TestFileCacheRule
 import org.junit.ClassRule
+import org.junit.Test
 import org.junit.runners.Parameterized
 
 /** Run parameterized tests for [ATTRIBUTE_DEFAULT_VALUE]. */
@@ -30,11 +30,6 @@ class CommonParameterizedAttributeDefaultValueTest :
         testFileCacheRule.cache,
         testJarFile,
         ATTRIBUTE_DEFAULT_VALUE,
-        legacySourceGetter = {
-            val annotationMethod = testClassItem.assertMethod(ATTRIBUTE_NAME, "")
-
-            annotationMethod.legacyDefaultValue()
-        },
     ) {
     companion object : BaseCompanion(ATTRIBUTE_DEFAULT_VALUE) {
         /** Create a [TestFileCache] whose lifespan encompasses all the tests in this class. */
@@ -43,4 +38,18 @@ class CommonParameterizedAttributeDefaultValueTest :
         /** Supply the list of test cases as the parameters for this test class. */
         @JvmStatic @Parameterized.Parameters fun params() = testParameters
     }
+
+    @Test
+    fun testLegacySource() {
+        checkLegacySource()
+    }
+
+    @Test
+    fun testMethodDefaultValue() {
+        checkExpectedValue {
+            val annotationMethod = testClassItem.assertMethod(ATTRIBUTE_NAME, "")
+
+            annotationMethod.defaultValue
+        }
+    }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedAttributeValueTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedAttributeValueTest.kt
index 1e3884137..e260bf3df 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedAttributeValueTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedAttributeValueTest.kt
@@ -16,12 +16,12 @@
 
 package com.android.tools.metalava.model.testsuite.value
 
-import com.android.tools.metalava.model.Assertions.Companion.assertAttribute
+import com.android.tools.metalava.model.testsuite.value.LegacyValueUseSite.ATTRIBUTE_VALUE
 import com.android.tools.metalava.model.testsuite.value.TestClassCreator.Companion.ATTRIBUTE_NAME
-import com.android.tools.metalava.model.testsuite.value.ValueUseSite.ATTRIBUTE_VALUE
 import com.android.tools.metalava.testing.TestFileCache
 import com.android.tools.metalava.testing.TestFileCacheRule
 import org.junit.ClassRule
+import org.junit.Test
 import org.junit.runners.Parameterized
 
 /** Run parameterized tests for [ATTRIBUTE_VALUE]. */
@@ -30,12 +30,6 @@ class CommonParameterizedAttributeValueTest :
         testFileCacheRule.cache,
         testJarFile,
         ATTRIBUTE_VALUE,
-        legacySourceGetter = {
-            val annotation = testClassItem.modifiers.annotations().first()
-            val annotationAttribute = annotation.assertAttribute(ATTRIBUTE_NAME)
-
-            annotationAttribute.legacyValue.toSource()
-        }
     ) {
     companion object : BaseCompanion(ATTRIBUTE_VALUE) {
         /** Create a [TestFileCache] whose lifespan encompasses all the tests in this class. */
@@ -44,4 +38,15 @@ class CommonParameterizedAttributeValueTest :
         /** Supply the list of test cases as the parameters for this test class. */
         @JvmStatic @Parameterized.Parameters fun params() = testParameters
     }
+
+    @Test
+    fun testAttributeValue() {
+        // This is identical for all annotation attribute use sites so only needs testing once.
+        checkExpectedValue {
+            val annotation = testClassItem.modifiers.annotations().first()
+            val annotationAttribute = annotation.assertAttribute(ATTRIBUTE_NAME)
+
+            annotationAttribute.value
+        }
+    }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedFieldValueTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedFieldValueTest.kt
index 352f3ce9e..fc0ad1431 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedFieldValueTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedFieldValueTest.kt
@@ -16,14 +16,12 @@
 
 package com.android.tools.metalava.model.testsuite.value
 
-import com.android.tools.metalava.model.Assertions.Companion.assertField
+import com.android.tools.metalava.model.testsuite.value.LegacyValueUseSite.FIELD_VALUE
 import com.android.tools.metalava.model.testsuite.value.TestClassCreator.Companion.FIELD_NAME
-import com.android.tools.metalava.model.testsuite.value.ValueExample.Companion.NO_INITIAL_FIELD_VALUE
-import com.android.tools.metalava.model.testsuite.value.ValueUseSite.FIELD_VALUE
 import com.android.tools.metalava.testing.TestFileCache
 import com.android.tools.metalava.testing.TestFileCacheRule
-import kotlin.test.assertNotNull
 import org.junit.ClassRule
+import org.junit.Test
 import org.junit.runners.Parameterized
 
 /** Run parameterized tests for [FIELD_VALUE]. */
@@ -32,11 +30,6 @@ class CommonParameterizedFieldValueTest :
         testFileCacheRule.cache,
         testJarFile,
         FIELD_VALUE,
-        legacySourceGetter = {
-            val field = testClassItem.assertField(FIELD_NAME)
-            val fieldValue = assertNotNull(field.legacyFieldValue, "No field value")
-            fieldValue.initialValue(true)?.toString() ?: NO_INITIAL_FIELD_VALUE
-        },
     ) {
     companion object : BaseCompanion(FIELD_VALUE) {
         /** Create a [TestFileCache] whose lifespan encompasses all the tests in this class. */
@@ -45,4 +38,13 @@ class CommonParameterizedFieldValueTest :
         /** Supply the list of test cases as the parameters for this test class. */
         @JvmStatic @Parameterized.Parameters fun params() = testParameters
     }
+
+    @Test
+    fun testFieldValue() {
+        // This is identical for all field use sites so only needs testing once.
+        checkExpectedValue {
+            val field = testClassItem.assertField(FIELD_NAME)
+            field.constantValue
+        }
+    }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedFieldWriteWithSemicolonValueTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedFieldWriteWithSemicolonValueTest.kt
index 85fe97032..d379f55fa 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedFieldWriteWithSemicolonValueTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonParameterizedFieldWriteWithSemicolonValueTest.kt
@@ -16,15 +16,11 @@
 
 package com.android.tools.metalava.model.testsuite.value
 
-import com.android.tools.metalava.model.Assertions.Companion.assertField
-import com.android.tools.metalava.model.testsuite.value.TestClassCreator.Companion.FIELD_NAME
-import com.android.tools.metalava.model.testsuite.value.ValueExample.Companion.NO_INITIAL_FIELD_VALUE
-import com.android.tools.metalava.model.testsuite.value.ValueUseSite.FIELD_WRITE_WITH_SEMICOLON
+import com.android.tools.metalava.model.testsuite.value.LegacyValueUseSite.FIELD_WRITE_WITH_SEMICOLON
 import com.android.tools.metalava.testing.TestFileCache
 import com.android.tools.metalava.testing.TestFileCacheRule
-import java.io.PrintWriter
-import java.io.StringWriter
 import org.junit.ClassRule
+import org.junit.Test
 import org.junit.runners.Parameterized
 
 /** Run parameterized tests for [FIELD_WRITE_WITH_SEMICOLON]. */
@@ -33,19 +29,13 @@ class CommonParameterizedFieldWriteWithSemicolonValueTest :
         testFileCacheRule.cache,
         testJarFile,
         FIELD_WRITE_WITH_SEMICOLON,
-        legacySourceGetter = {
-            val field = testClassItem.assertField(FIELD_NAME)
+    ) {
 
-            // Print the field with semicolon.
-            val stringWriter = StringWriter()
-            PrintWriter(stringWriter).use { writer -> field.writeValueWithSemicolon(writer) }
-            val withSemicolon = stringWriter.toString()
+    @Test
+    fun testLegacySource() {
+        checkLegacySource()
+    }
 
-            // Extract the value from the " = ...; // ...." string.
-            if (withSemicolon == ";") NO_INITIAL_FIELD_VALUE
-            else withSemicolon.substringAfter(" = ").substringBefore(";")
-        },
-    ) {
     companion object : BaseCompanion(FIELD_WRITE_WITH_SEMICOLON) {
         /** Create a [TestFileCache] whose lifespan encompasses all the tests in this class. */
         @ClassRule @JvmField val testFileCacheRule = TestFileCacheRule()
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonValueTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonValueTest.kt
new file mode 100644
index 000000000..3033e9f86
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/CommonValueTest.kt
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.value
+
+import com.android.tools.metalava.model.provider.Capability
+import com.android.tools.metalava.model.testing.RequiresCapabilities
+import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.model.value.Value
+import com.android.tools.metalava.model.value.ValueStringConfiguration
+import com.android.tools.metalava.testing.kotlin
+import kotlin.test.assertEquals
+import kotlin.test.assertNotNull
+import org.junit.Test
+
+/**
+ * One off tests for [Value] related functionality that are not covered by the parameterized tests.
+ */
+class CommonValueTest : BaseModelTest() {
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `Test reference to renamed companion object field`() {
+        runCodebaseTest(
+            inputSet(
+                kotlin(
+                    """
+                        package test.other
+
+                        class Other {
+                            companion object Friend {
+                                const val FIELD = 1
+                            }
+                        }
+                    """
+                ),
+                kotlin(
+                    """
+                        package test.pkg
+                        import test.other.Other
+                        annotation class Test(val attr: Int = Other.FIELD)
+                    """
+                ),
+            )
+        ) {
+            val value = codebase.assertClass("test.pkg.Test").methods().single().defaultValue
+            assertNotNull(value)
+            assertEquals(
+                "test.other.Other.Friend.FIELD",
+                value.toValueString(ValueStringConfiguration(showKotlinCompanionClass = true))
+            )
+        }
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/Expectation.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/Expectation.kt
index 6d7983e8d..f79e8f664 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/Expectation.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/Expectation.kt
@@ -16,31 +16,32 @@
 
 package com.android.tools.metalava.model.testsuite.value
 
-import com.android.tools.metalava.model.Codebase
 import kotlin.properties.ReadWriteProperty
 import kotlin.reflect.KProperty
 
 /** Encapsulates a set of expectations about values. */
 interface Expectation<out T> {
+    /** Get the expectations of type [T] for [producerKind] at [legacyValueUseSite]. */
+    fun expectationFor(producerKind: ProducerKind, legacyValueUseSite: LegacyValueUseSite): T
+
     /**
-     * Get the expectations of type [T] for [producerKind] at [valueUseSite] for testing within
-     * [codebase].
+     * Check to see if this has an expectation (which may be null) for [producerKind] at
+     * [legacyValueUseSite].
      */
-    fun expectationFor(
+    fun hasExpectationFor(
         producerKind: ProducerKind,
-        valueUseSite: ValueUseSite,
-        codebase: Codebase
-    ): T
+        legacyValueUseSite: LegacyValueUseSite
+    ): Boolean
 }
 
 /**
  * Builder for expectations.
  *
  * This makes it easy to create a set of expectations for all possible combinations of
- * [ProducerKind] and [ValueUseSite] without duplicating effort.
+ * [ProducerKind] and [LegacyValueUseSite] without duplicating effort.
  */
-internal fun <T : Any> expectations(body: ExpectationsBuilder<T>.() -> Unit) =
-    nullableExpectations(body = body)
+internal fun <T : Any> expectations(body: ExpectationsBuilder<T?>.() -> Unit) =
+    nullableExpectations(optionalDefaultValueProvider = { null }, body = body)
 
 /**
  * Builder for expectations that allows null.
@@ -60,15 +61,6 @@ private fun <T> nullableExpectations(
     return builder.expectations(optionalDefaultValueProvider)
 }
 
-/**
- * Builder for partial expectations.
- *
- * Allows `null` values and is expected to be a partial set of expectations that falls back to
- * another set of expectations. See [fallBackTo].
- */
-internal fun <T> partialExpectations(body: ExpectationsBuilder<T?>.() -> Unit) =
-    nullableExpectations(optionalDefaultValueProvider = { null }, body = body)
-
 /**
  * Create an [Expectation] from an [Expectation] that returns `null`, i.e. a partial set, by falling
  * back to another [Expectation] that does not contain `null`, i.e. a full set.
@@ -79,36 +71,6 @@ internal fun <T> partialExpectations(body: ExpectationsBuilder<T?>.() -> Unit) =
 fun <T> Expectation<T?>.fallBackTo(other: Expectation<T>) =
     if (this === other) other else ChainedExpectation(this, other)
 
-/** Produces an expectation of type `T` from a [Codebase]. */
-typealias CodebaseExpectationProducer<T> = (Codebase) -> T
-
-/**
- * Create an [Expectation] that instead of storing the expectations or type [T] will store
- * [CodebaseExpectationProducer] that when passed a [Codebase] will produce the expectation.
- *
- * Needed for creating expectations that require a [Codebase].
- */
-internal fun <T> codebaseExpectations(
-    body: ExpectationsBuilder<CodebaseExpectationProducer<T>>.() -> Unit
-): Expectation<T> {
-    // Create an intermediate [Expectation] that takes `CodebaseExpectationProducer<T>`s instead of
-    // `T`s.
-    val intermediate = expectations(body)
-
-    // Wrap that intermediate object in another that will delegate to it to obtain a
-    // `CodebaseExpectationProducer<T>` and then return the expectation it produces.
-    return object : Expectation<T> {
-        override fun expectationFor(
-            producerKind: ProducerKind,
-            valueUseSite: ValueUseSite,
-            codebase: Codebase
-        ): T {
-            val producer = intermediate.expectationFor(producerKind, valueUseSite, codebase)
-            return producer(codebase)
-        }
-    }
-}
-
 /**
  * A [ReadWriteProperty] which will store the value that is set on the property in [map] for all
  * [keys].
@@ -127,7 +89,7 @@ internal class MutableMapDelegate<K, T>(
 }
 
 /** The key into the map of expected values in [ExpectationsBuilder.ExpectationMap]. */
-private typealias ExpectationKey = Pair<ProducerKind, ValueUseSite>
+private typealias ExpectationKey = Pair<ProducerKind, LegacyValueUseSite>
 
 /**
  * Populates [expectationMap] with values for all [producerKinds].
@@ -140,7 +102,7 @@ internal open class PerProducerKindBuilder<T>(
 ) {
     /**
      * Stores its value in [expectationMap] for the cross product of [producerKinds] and
-     * [ValueUseSite.entries].
+     * [LegacyValueUseSite.entries].
      *
      * This must be set before any of the other properties as this will overwrite them.
      */
@@ -148,52 +110,48 @@ internal open class PerProducerKindBuilder<T>(
         MutableMapDelegate(
             expectationMap,
             producerKinds.flatMap { producerKind ->
-                ValueUseSite.entries.map { producerKind to it }
+                LegacyValueUseSite.entries.map { producerKind to it }
             }
         )
 
     /**
      * Stores its value in [expectationMap] for the cross product of [producerKinds] and
-     * [ValueUseSite.ATTRIBUTE_VALUE].
-     */
-    var attributeValue: T by
-        MutableMapDelegate(expectationMap, producerKinds.map { it to ValueUseSite.ATTRIBUTE_VALUE })
-
-    /**
-     * Stores its value in [expectationMap] for the cross product of [producerKinds] and
-     * [ValueUseSite.ATTRIBUTE_VALUE].
+     * [LegacyValueUseSite.ATTRIBUTE_VALUE].
      */
     var annotationToSource: T by
         MutableMapDelegate(
             expectationMap,
-            producerKinds.map { it to ValueUseSite.ANNOTATION_TO_SOURCE }
+            producerKinds.map { it to LegacyValueUseSite.ANNOTATION_TO_SOURCE }
         )
 
     /**
      * Stores its value in [expectationMap] for the cross product of [producerKinds] and
-     * [ValueUseSite.ATTRIBUTE_DEFAULT_VALUE].
+     * [LegacyValueUseSite.ATTRIBUTE_DEFAULT_VALUE].
      */
     var attributeDefaultValue: T by
         MutableMapDelegate(
             expectationMap,
-            producerKinds.map { it to ValueUseSite.ATTRIBUTE_DEFAULT_VALUE }
+            producerKinds.map { it to LegacyValueUseSite.ATTRIBUTE_DEFAULT_VALUE }
         )
 
     /**
      * Stores its value in [expectationMap] for the cross product of [producerKinds] and
-     * [ValueUseSite.FIELD_VALUE].
+     * [LegacyValueUseSite.FIELD_VALUE].
      */
     var fieldValue: T by
-        MutableMapDelegate(expectationMap, producerKinds.map { it to ValueUseSite.FIELD_VALUE })
+        MutableMapDelegate(
+            expectationMap,
+            producerKinds.map { it to LegacyValueUseSite.FIELD_VALUE }
+        )
 
     /**
      * Stores its value in [expectationMap] for the cross product of [producerKinds] and
-     * [ValueUseSite.FIELD_WRITE_WITH_SEMICOLON].
+     * [LegacyValueUseSite.FIELD_WRITE_WITH_SEMICOLON].
      */
     var fieldWriteWithSemicolon: T by
         MutableMapDelegate(
             expectationMap,
-            producerKinds.map { it to ValueUseSite.FIELD_WRITE_WITH_SEMICOLON }
+            producerKinds.map { it to LegacyValueUseSite.FIELD_WRITE_WITH_SEMICOLON }
         )
 }
 
@@ -237,12 +195,19 @@ internal class ExpectationsBuilder<T> :
     ) : Expectation<T> {
         override fun expectationFor(
             producerKind: ProducerKind,
-            valueUseSite: ValueUseSite,
-            codebase: Codebase
+            legacyValueUseSite: LegacyValueUseSite
         ): T {
-            val key = producerKind to valueUseSite
+            val key = producerKind to legacyValueUseSite
             return map[key] ?: defaultValueProvider(key)
         }
+
+        override fun hasExpectationFor(
+            producerKind: ProducerKind,
+            legacyValueUseSite: LegacyValueUseSite
+        ): Boolean {
+            val key = producerKind to legacyValueUseSite
+            return key in map
+        }
     }
 }
 
@@ -252,13 +217,20 @@ internal class ExpectationsBuilder<T> :
  */
 private class ChainedExpectation<T>(
     private val first: Expectation<T?>,
-    private val second: Expectation<T>,
-) : Expectation<T> {
+    private val second: Expectation<T?>,
+) : Expectation<T?> {
     override fun expectationFor(
         producerKind: ProducerKind,
-        valueUseSite: ValueUseSite,
-        codebase: Codebase
+        legacyValueUseSite: LegacyValueUseSite,
+    ) =
+        if (first.hasExpectationFor(producerKind, legacyValueUseSite)) {
+            first.expectationFor(producerKind, legacyValueUseSite)
+        } else second.expectationFor(producerKind, legacyValueUseSite)
+
+    override fun hasExpectationFor(
+        producerKind: ProducerKind,
+        legacyValueUseSite: LegacyValueUseSite
     ) =
-        first.expectationFor(producerKind, valueUseSite, codebase)
-            ?: second.expectationFor(producerKind, valueUseSite, codebase)
+        first.hasExpectationFor(producerKind, legacyValueUseSite) ||
+            second.hasExpectationFor(producerKind, legacyValueUseSite)
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/LegacyValueUseSite.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/LegacyValueUseSite.kt
new file mode 100644
index 000000000..95288018e
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/LegacyValueUseSite.kt
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.value
+
+import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.Assertions.Companion.assertField
+import com.android.tools.metalava.model.Assertions.Companion.assertMethod
+import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.testsuite.value.BaseCommonParameterizedValueTest.TestCaseContext
+import com.android.tools.metalava.model.testsuite.value.TestClassCreator.Companion.ATTRIBUTE_NAME
+import com.android.tools.metalava.model.testsuite.value.TestClassCreator.Companion.FIELD_NAME
+import com.android.tools.metalava.model.value.ValueUseSite
+import java.util.EnumSet
+
+/**
+ * The possible places where values can be provided.
+ *
+ * @param valueUseSite the [ValueUseSite] that will replace the [LegacyValueUseSite].
+ * @param legacySourceGetter gets the legacy source representation as expected by
+ *   [ValueExample.expectedLegacySourceFor].
+ */
+enum class LegacyValueUseSite(
+    val valueUseSite: ValueUseSite,
+    val legacySourceGetter: (TestCaseContext.() -> String?)? = null,
+) {
+    /** The default value specified on an annotation class's method. */
+    ATTRIBUTE_DEFAULT_VALUE(
+        ValueUseSite.ANNOTATION,
+        legacySourceGetter = {
+            val annotationMethod = testClassItem.assertMethod(ATTRIBUTE_NAME, "")
+
+            annotationMethod.legacyDefaultValue()
+        },
+    ),
+
+    /** An annotation attribute value specified in an annotation instance. */
+    ATTRIBUTE_VALUE(
+        ValueUseSite.ANNOTATION,
+    ),
+
+    /**
+     * An annotation attribute value produced by [AnnotationItem.toSource] called on an annotation
+     * instance.
+     */
+    ANNOTATION_TO_SOURCE(
+        ValueUseSite.ANNOTATION,
+        legacySourceGetter = {
+            // Get the annotation to test.
+            val annotation = testClassItem.modifiers.annotations().first()
+
+            // Generate the whole annotation representation, not including default values.
+            val wholeAnnotation = annotation.toSource(context = testClassItem)
+
+            // Extract the value from the whole annotation.
+            wholeAnnotation
+                .substringAfter("=")
+                .substringBeforeLast(")")
+                // Remove optional space after the =
+                .trimStart()
+        },
+    ),
+
+    /** The value of a field. */
+    FIELD_VALUE(
+        ValueUseSite.FIELD,
+    ),
+
+    /** The value of a field written out by [FieldItem.writeValueWithSemicolon]. */
+    FIELD_WRITE_WITH_SEMICOLON(
+        ValueUseSite.FIELD,
+        legacySourceGetter = {
+            val field = testClassItem.assertField(FIELD_NAME)
+
+            // Print the field with semicolon.
+            val stringWriter = java.io.StringWriter()
+            java.io.PrintWriter(stringWriter).use { writer ->
+                field.writeValueWithSemicolon(writer)
+            }
+            val withSemicolon = stringWriter.toString()
+
+            // Extract the value from the " = ...; // ...." string.
+            if (withSemicolon == ";") null
+            else withSemicolon.substringAfter(" = ").substringBefore(";")
+        },
+    ),
+}
+
+/**
+ * The set of all [LegacyValueUseSite]s.
+ *
+ * Default for [ValueExample.suitableFor].
+ */
+internal val allLegacyValueUseSites = EnumSet.allOf(LegacyValueUseSite::class.java)
+
+/**
+ * The set of all field [LegacyValueUseSite]s, i.e. [LegacyValueUseSite.FIELD_VALUE] and
+ * [LegacyValueUseSite.FIELD_WRITE_WITH_SEMICOLON].
+ */
+internal val allFieldLegacyValueUseSites =
+    EnumSet.of(LegacyValueUseSite.FIELD_VALUE, LegacyValueUseSite.FIELD_WRITE_WITH_SEMICOLON)
+
+/**
+ * The set of all [LegacyValueUseSite]s except [LegacyValueUseSite.FIELD_VALUE] and
+ * [LegacyValueUseSite.FIELD_WRITE_WITH_SEMICOLON].
+ *
+ * Stored in [ValueExample.suitableFor] for any [ValueExample] that does not work on fields.
+ */
+internal val allLegacyValueUseSitesExceptFields =
+    allLegacyValueUseSites - allFieldLegacyValueUseSites
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/ParameterizedValueParserTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/ParameterizedValueParserTest.kt
new file mode 100644
index 000000000..e04e7ed16
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/ParameterizedValueParserTest.kt
@@ -0,0 +1,267 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.value
+
+import com.android.tools.metalava.model.junit4.ParameterFilter
+import com.android.tools.metalava.model.provider.InputFormat
+import com.android.tools.metalava.model.testing.CodebaseCreatorConfig
+import com.android.tools.metalava.model.testing.value.runValueTest
+import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.model.testsuite.ModelSuiteRunner
+import com.android.tools.metalava.model.testsuite.value.ValueExample.Companion.valueExamples
+import com.android.tools.metalava.model.type.TypeItemParser
+import com.android.tools.metalava.model.value.Value
+import com.android.tools.metalava.model.value.ValueParser
+import com.android.tools.metalava.testing.EntryPointCallerRule
+import java.util.EnumSet
+import kotlin.test.assertEquals
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runners.Parameterized
+
+/**
+ * A parameterized test for [ValueParser] which will use all the possible values that could be
+ * written out to a signature file for the [ValueExample.valueExamples].
+ *
+ * That ensures that any time new values are added to the [ValueExample.valueExamples] because of
+ * output changes or just improving the test coverage it will also make sure that they can be read
+ * back in from the signature files.
+ */
+class ParameterizedValueParserTest : BaseModelTest() {
+
+    @Parameterized.Parameter(0) lateinit var testCase: TestCase
+
+    /**
+     * Will try and rewrite the stack trace of any test failures to refer to the location where the
+     * [ValueExample] that is currently being tested was created.
+     */
+    @get:Rule
+    val entryPointCallerRule = EntryPointCallerRule {
+        testCase.valueExample.entryPointCallerTracker
+    }
+
+    /** Specifies how a [TestCase] will determine whether it passed or not. */
+    enum class Comparison {
+        /** The [Value] parsed from [TestCase.input] must match the [TestCase.expectedValue]. */
+        STRICT,
+
+        /**
+         * A [Value] must have been parsed from [TestCase.input].
+         *
+         * The writing of some [Value]s to signature files loses information that is necessary to
+         * recreate the original, e.g. the field references may not be fully qualified. In that case
+         * the current goal is simply to ensure that they can be parsed back in.
+         */
+        PARSE,
+    }
+
+    class TestCase(
+        val label: String,
+        /** The [ValueExample] on which this test case is based. */
+        val valueExample: ValueExample,
+        val signatureType: String,
+        val input: String,
+        val expectedValue: Value,
+        val comparison: Comparison,
+    ) {
+        override fun equals(other: Any?): Boolean {
+            if (this === other) return true
+            if (javaClass != other?.javaClass) return false
+
+            other as TestCase
+
+            if (signatureType != other.signatureType) return false
+            if (input != other.input) return false
+            if (expectedValue != other.expectedValue) return false
+
+            return true
+        }
+
+        override fun hashCode(): Int {
+            var result = input.hashCode()
+            result = 31 * result + expectedValue.hashCode()
+            return result
+        }
+
+        override fun toString() = label
+    }
+
+    companion object {
+        /** Filter the parameters. */
+        @JvmStatic
+        @ParameterFilter
+        fun parameterFilter(
+            config: CodebaseCreatorConfig<ModelSuiteRunner>,
+            testCase: TestCase,
+        ): Boolean {
+            val inputFormat = config.inputFormat
+
+            // Ignore any tests that are not for the signature file.
+            return inputFormat == InputFormat.SIGNATURE
+        }
+
+        /** The set of [LegacyValueUseSite]s which end up being written to a signature file. */
+        private val legacyValueUseSitesWrittenToSignatureFiles =
+            EnumSet.of(
+                LegacyValueUseSite.ANNOTATION_TO_SOURCE,
+                LegacyValueUseSite.ATTRIBUTE_DEFAULT_VALUE,
+                LegacyValueUseSite.FIELD_WRITE_WITH_SEMICOLON,
+            )
+
+        /**
+         * The set of [InputFormat]s that generate the content that gets written to the signature
+         * files.
+         */
+        private val sourceInputFormats = EnumSet.of(InputFormat.JAVA, InputFormat.KOTLIN)
+
+        /**
+         * A list of [TestCase]s constructed from [ValueExample]s.
+         *
+         * The intent is that this will include every possible representation of values that are
+         * written to signature files as that is the set of possible inputs to the [ValueParser].
+         */
+        private val testCases =
+            valueExamples
+                .flatMap { valueExample ->
+                    // If the example is not suitable for signature files then ignore it.
+                    if (InputFormat.SIGNATURE !in valueExample.validForInputFormats)
+                        return@flatMap emptyList()
+
+                    val signatureType = valueExample.signatureType
+                    buildList {
+                        // Iterate over jar and source representations.
+                        for (producerKind in ProducerKind.entries) {
+                            // Get the expected value. Uses LegacyValueUseSite.ATTRIBUTE_VALUE but
+                            // any would be ok as all use sites have the same expected value.
+                            val expectedValue =
+                                valueExample.expectedValue.expectationFor(
+                                    producerKind,
+                                    LegacyValueUseSite.ATTRIBUTE_VALUE
+                                ) ?: continue
+
+                            // The expression is only guaranteed to produce the expected source
+                            // value. The jar value could have lost some information, e.g. a
+                            // constant field reference will have been replaced with its constant
+                            // value. Select how the result should be compared appropriately.
+                            val comparison =
+                                if (producerKind == ProducerKind.SOURCE) Comparison.STRICT
+                                else Comparison.PARSE
+
+                            // Add a test case for the input signature expression.
+                            add(
+                                TestCase(
+                                    "${valueExample.name},signatureExpression,${producerKind.name.lowercase()}",
+                                    valueExample,
+                                    signatureType,
+                                    valueExample.signatureExpression,
+                                    expectedValue,
+                                    comparison,
+                                )
+                            )
+
+                            // Iterate over all value use sites that are written to signature files.
+                            for (legacyValueUseSite in legacyValueUseSitesWrittenToSignatureFiles) {
+                                // Cover Java dnd Kotlin representations.
+                                for (sourceInputFormat in sourceInputFormats) {
+                                    // Get the expected representation for this combination of
+                                    // options as this will be an input to the parser.
+                                    val input =
+                                        valueExample
+                                            .expectedLegacySourceFor(sourceInputFormat)
+                                            .expectationFor(producerKind, legacyValueUseSite)
+
+                                    // Ignore no values.
+                                    if (input == null) continue
+
+                                    val label =
+                                        "${valueExample.name},${legacyValueUseSite.name.lowercase()},${sourceInputFormat.name.lowercase()},${producerKind.name.lowercase()}"
+
+                                    // Add a test case for the input.
+                                    add(
+                                        TestCase(
+                                            label,
+                                            valueExample,
+                                            signatureType,
+                                            input,
+                                            expectedValue,
+                                            // Just make sure that the value can be parsed.
+                                            Comparison.PARSE,
+                                        )
+                                    )
+                                }
+                            }
+                        }
+                    }
+                }
+                // The above produces a lot of duplicates so remove them.
+                .distinct()
+                // Put them in order.
+                .sortedWith(compareBy { it.label })
+                // Apply some filtering to remove known problematic cases.
+                .filter {
+                    // Ignore any tests that use Kotlin syntax for representing array types as they
+                    // cannot yet be converted from `Array<X>` into `X[]`.
+                    !it.input.startsWith("Array<")
+                }
+
+        /** Supply the list of test cases as the parameters for this test class. */
+        @JvmStatic @Parameterized.Parameters fun params() = testCases
+    }
+
+    @Test
+    fun `Test parse`() {
+        runCodebaseTest(
+            signature(
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public class Foo {
+                        field public static final ${testCase.signatureType} FIELD;
+                      }
+                      public interface Constants {
+                        field public static final String STRING_CONSTANT = "constant";
+                        field public static final int INT_CONSTANT = 37;
+                      }
+                      public interface GenericClass<T> {
+                        field public static final String STRING_CONSTANT = "constant";
+                      }
+                      public enum TestEnum {
+                        enum_constant public static final test.pkg.TestEnum DEFAULT;
+                        enum_constant public static final test.pkg.TestEnum VALUE1;
+                      }
+                    }
+                """
+            )
+        ) {
+            // Run the test on the expected value ignoring any [ValueProviderException]s if its
+            // kind is not fully supported across implementation models.
+            testCase.expectedValue.runValueTest { expected ->
+                val typeItem = codebase.assertClass("test.pkg.Foo").assertField("FIELD").type()
+                val valueParser = ValueParser(codebase, TypeItemParser.forValueParser(codebase))
+                val actualValue = valueParser.parse(typeItem, testCase.input)
+                when (testCase.comparison) {
+                    Comparison.STRICT -> {
+                        assertEquals(expected, actualValue)
+                    }
+                    Comparison.PARSE -> {
+                        // If it got here then it did not fail above so there is nothing else to do.
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/ValueExample.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/ValueExample.kt
index fa0682a17..e332da80c 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/ValueExample.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/ValueExample.kt
@@ -16,18 +16,34 @@
 
 package com.android.tools.metalava.model.testsuite.value
 
-import com.android.tools.metalava.model.FieldItem
-import com.android.tools.metalava.model.PrimitiveTypeItem
+import com.android.tools.metalava.model.PrimitiveTypeItem.Primitive
 import com.android.tools.metalava.model.provider.InputFormat
-import com.android.tools.metalava.model.testsuite.value.ValueExample.Companion.NO_INITIAL_FIELD_VALUE
+import com.android.tools.metalava.model.testing.arrayTypeItem
+import com.android.tools.metalava.model.testing.classTypeItem
+import com.android.tools.metalava.model.testing.primitiveTypeForKind
+import com.android.tools.metalava.model.testing.value.annotationValue
+import com.android.tools.metalava.model.testing.value.arrayValue
+import com.android.tools.metalava.model.testing.value.arrayValueFromAny
+import com.android.tools.metalava.model.testing.value.classObjectValue
+import com.android.tools.metalava.model.testing.value.fieldReferenceValue
+import com.android.tools.metalava.model.testing.value.literalValue
+import com.android.tools.metalava.model.testing.value.primitiveValueForKind
+import com.android.tools.metalava.model.value.DoubleValue
+import com.android.tools.metalava.model.value.Value
+import com.android.tools.metalava.model.value.ValueUseSite
+import com.android.tools.metalava.testing.EntryPoint
+import com.android.tools.metalava.testing.EntryPointCallerTracker
 import java.util.EnumSet
+import kotlin.reflect.KClass
 
 /**
  * Encapsulates information about a value example.
  *
  * This will be useful for a number of different tests around values.
  */
-class ValueExample(
+class ValueExample
+@EntryPoint
+constructor(
     /**
      * The name of the example.
      *
@@ -37,10 +53,13 @@ class ValueExample(
     val name: String,
 
     /** The java type. */
-    val javaType: String,
+    val javaType: String = "",
 
     /** The java expression for the value. */
-    val javaExpression: String,
+    val javaExpression: String = "",
+
+    /** The optional java imports. */
+    val javaImports: List<String> = emptyList(),
 
     /**
      * The Kotlin type.
@@ -58,8 +77,30 @@ class ValueExample(
      */
     val kotlinExpression: String = javaExpression,
 
-    /** The optional java imports. */
-    val javaImports: List<String> = emptyList(),
+    /**
+     * The Kotlin type for use in annotations.
+     *
+     * Kotlin automatically maps between [KClass] and [Class] when creating, using and reading
+     * annotations so annotations it must use [KClass] not [Class].
+     */
+    val kotlinTypeForAnnotation: String = if (kotlinType == "Class<*>") "KClass<*>" else kotlinType,
+
+    /**
+     * The Kotlin expression for use in annotations.
+     *
+     * Kotlin automatically maps between [KClass] and [Class] when creating, using and reading
+     * annotations so annotations it must use `<class>::class` not `<class>::class.java`.
+     */
+    val kotlinExpressionForAnnotation: String = kotlinExpression.substringBefore(".java"),
+
+    /**
+     * The optional Kotlin imports.
+     *
+     * Automatically adds `kotlin.reflect.KClass` if needed.
+     */
+    val kotlinImports: List<String> =
+        if (kotlinTypeForAnnotation == "KClass<*>") javaImports + "kotlin.reflect.KClass"
+        else javaImports,
 
     /**
      * The signature type, defaults to [javaType] as signature files generally use Java types and
@@ -75,8 +116,11 @@ class ValueExample(
      */
     val signatureExpression: String = javaExpression,
 
-    /** The set of [ValueUseSite]s in which this example will be tested; defaults to all of them. */
-    val suitableFor: Set<ValueUseSite> = allValueUseSites,
+    /**
+     * The set of [LegacyValueUseSite]s in which this example will be tested; defaults to all of
+     * them.
+     */
+    val suitableFor: Set<LegacyValueUseSite> = allLegacyValueUseSites,
 
     /** The set of [InputFormat]s for which this example is valid. */
     val validForInputFormats: Set<InputFormat> = allInputFormats,
@@ -84,20 +128,27 @@ class ValueExample(
     /**
      * The legacy string representation of [javaExpression].
      *
-     * This may differ by [ProducerKind] and [ValueUseSite].
+     * This may differ by [ProducerKind] and [LegacyValueUseSite].
      */
-    private val expectedLegacySource: Expectation<String>,
+    private val expectedLegacySource: Expectation<String?>,
 
     /**
      * Kotlin source expressions can have a different representation than the same source expression
      * in Java.
      *
-     * Rather than make [Expectation] support another dimension on top of [ValueUseSite] and
+     * Rather than make [Expectation] support another dimension on top of [LegacyValueUseSite] and
      * [ProducerKind] for the few cases where there are differences, it is handled by having this
      * Kotlin specific expectation sit alongside and default to [expectedLegacySource].
      */
     private val expectedKotlinLegacySource: Expectation<String?> = expectedLegacySource,
 
+    /**
+     * The expected [Value] for this case.
+     *
+     * This may differ by [ProducerKind] and [LegacyValueUseSite].
+     */
+    val expectedValue: Expectation<Value?>,
+
     /**
      * Controls which [ValueExample]s in [allValueExamples] are run.
      *
@@ -112,51 +163,78 @@ class ValueExample(
     val testThis: Boolean = false,
 ) {
     /**
-     * If the field is not a constant then wrap it in an Expectation that will enforce that fields
-     * only have constant values.
+     * Record the stack trace of the creation of this which can be used to provide a stack trace to
+     * the creator of this instance in the event of a test failure.
+     */
+    val entryPointCallerTracker = EntryPointCallerTracker()
+
+    /**
+     * Enforces that field values are constant.
+     *
+     * If the example is not for a constant type then this returns an [Expectation] that will
+     * replace the expected value for fields with `null`. Otherwise, this just returns this
+     * [Expectation].
      */
-    private fun wrapLegacySource(expectation: Expectation<String>) =
-        if (isConstant) expectation
-        else constantFieldLegacySourceExpectation.fallBackTo(expectation)
+    private fun <T : Any> Expectation<T?>.enforceFieldValuesAreConstant(): Expectation<T?> =
+        if (isConstant) this else TransformFieldExpectation(this, { null })
 
     /** Get the expected legacy source for [inputFormat]. */
     fun expectedLegacySourceFor(inputFormat: InputFormat) =
-        wrapLegacySource(
-            when (inputFormat) {
-                InputFormat.KOTLIN ->
-                    // Kotlin overrides the standard expectations.
-                    expectedKotlinLegacySource.fallBackTo(expectedLegacySource)
-                else -> expectedLegacySource
-            }
-        )
+        when (inputFormat) {
+            InputFormat.KOTLIN ->
+                // Kotlin overrides the standard expectations.
+                expectedKotlinLegacySource.fallBackTo(expectedLegacySource)
+            else -> expectedLegacySource
+        }.enforceFieldValuesAreConstant()
 
     /** The suffix to add to class names to make them specific to this example. */
-    val classSuffix = name.replace(" ", "_")
+    val classSuffix = name.replace(' ', '_').replace('-', '_')
 
     /** True if this is supported to be a field constant. */
     private val isConstant
-        get() = javaType in constantTypeNames
+        get() = javaType in constantTypeNames || kotlinType in unsignedConstantTypeNames
 
     companion object {
-        /**
-         * A special value used for fields for whom [FieldItem.legacyInitialValue] returns `null`.
-         */
-        internal const val NO_INITIAL_FIELD_VALUE = "NO INITIAL FIELD VALUE"
-
         /** Names of constant types used in [ValueExample.javaType]. */
         private val constantTypeNames = buildSet {
-            for (kind in PrimitiveTypeItem.Primitive.entries) {
+            for (kind in Primitive.entries) {
                 add(kind.primitiveName)
             }
             add("String")
         }
 
+        /**
+         * Unsigned types are mapped to their signed types so should be treated as being constant.
+         */
+        private val unsignedConstantTypeNames =
+            setOf(
+                "UByte",
+                "UInt",
+                "ULong",
+                "UShort",
+            )
+
         /** All the [InputFormat]s. */
         private val allInputFormats = EnumSet.allOf(InputFormat::class.java)
 
+        /** All except Kotlin. */
+        private val notValidForKotlin = EnumSet.complementOf(EnumSet.of(InputFormat.KOTLIN))
+
+        /** Only Kotlin. */
+        private val onlyValidForKotlin = EnumSet.of(InputFormat.KOTLIN)
+
+        /** All except Signature. */
+        private val notValidForSignature = EnumSet.complementOf(EnumSet.of(InputFormat.SIGNATURE))
+
+        /** All except Java. */
+        private val notValidForJava = EnumSet.complementOf(EnumSet.of(InputFormat.JAVA))
+
+        /** Only Java. */
+        private val onlyValidForJava = EnumSet.of(InputFormat.JAVA)
+
         /**
          * The list of all [ValueExample]s that could be tested across [ProducerKind] and
-         * [ValueUseSite]s.
+         * [LegacyValueUseSite]s.
          */
         private val allValueExamples =
             listOf(
@@ -171,26 +249,127 @@ class ValueExample(
                     expectedLegacySource =
                         expectations {
                             common = "@test.pkg.OtherAnnotation(intType = 1)"
-                            source { common = "@OtherAnnotation(intType = 1)" }
-                            // TODO(b/354633349): Missing attributes.
-                            attributeDefaultValue = "@test.pkg.OtherAnnotation"
+                            annotationToSource = "@test.pkg.OtherAnnotation(intType=1)"
+                        },
+                    expectedKotlinLegacySource =
+                        expectations { common = "test.pkg.OtherAnnotation(intType=1)" },
+                    // Annotation literals cannot be used in fields.
+                    suitableFor = allLegacyValueUseSitesExceptFields,
+                    expectedValue =
+                        expectations {
+                            common =
+                                annotationValue(
+                                    "test.pkg.OtherAnnotation",
+                                    "intType" to literalValue(1),
+                                )
+                        },
+                ),
+                ValueExample(
+                    name = "annotation - no attributes",
+                    javaType = "test.pkg.OtherAnnotation",
+                    javaExpression = "@test.pkg.OtherAnnotation",
+                    // Kotlin must supply parentheses as it treats an annotation as an annotation
+                    // class constructor call.
+                    kotlinExpression = "test.pkg.OtherAnnotation()",
+                    expectedLegacySource =
+                        expectations {
+                            common = "@test.pkg.OtherAnnotation"
 
+                            annotationToSource = "@test.pkg.OtherAnnotation"
+                        },
+                    expectedKotlinLegacySource =
+                        expectations {
+                            common = "test.pkg.OtherAnnotation()"
+
+                            source { attributeDefaultValue = "test.pkg.OtherAnnotation()" }
+                        },
+                    // Annotation literals cannot be used in fields.
+                    suitableFor = allLegacyValueUseSitesExceptFields,
+                    expectedValue =
+                        expectations { common = annotationValue("test.pkg.OtherAnnotation") },
+                ),
+                ValueExample(
+                    name = "annotation - multiple attributes",
+                    javaType = "test.pkg.OtherAnnotation",
+                    javaExpression = "@test.pkg.OtherAnnotation(stringType=\"one\", intType=3)",
+                    expectedLegacySource =
+                        expectations {
+                            common = "@test.pkg.OtherAnnotation(stringType = \"one\", intType = 3)"
+
+                            annotationToSource =
+                                "@test.pkg.OtherAnnotation(stringType=\"one\", intType=3)"
+                        },
+                    expectedKotlinLegacySource =
+                        expectations {
+                            common = "test.pkg.OtherAnnotation(stringType=\"one\", intType=3)"
+                        },
+                    // Annotation literals cannot be used in fields.
+                    suitableFor = allLegacyValueUseSitesExceptFields,
+                    expectedValue =
+                        expectations {
+                            common =
+                                annotationValue(
+                                    "test.pkg.OtherAnnotation",
+                                    "intType" to literalValue(3),
+                                    "stringType" to literalValue("one"),
+                                )
+                        },
+                ),
+                ValueExample(
+                    name = "annotation - single value",
+                    javaType = "test.pkg.SingleValueAnnotation",
+                    javaExpression = "@test.pkg.SingleValueAnnotation(\"text\")",
+                    expectedLegacySource =
+                        expectations { common = "@test.pkg.SingleValueAnnotation(\"text\")" },
+                    expectedKotlinLegacySource =
+                        expectations { common = "test.pkg.SingleValueAnnotation(\"text\")" },
+                    // Annotation literals cannot be used in fields.
+                    suitableFor = allLegacyValueUseSitesExceptFields,
+                    expectedValue =
+                        expectations {
+                            common =
+                                annotationValue(
+                                    "test.pkg.SingleValueAnnotation",
+                                    "value" to literalValue("text"),
+                                )
+                        },
+                ),
+                ValueExample(
+                    name = "annotation - array of annotations",
+                    javaType = "test.pkg.OtherAnnotation[]",
+                    javaExpression =
+                        "{@test.pkg.OtherAnnotation(intType = 1), @test.pkg.OtherAnnotation(intType = 2)}",
+                    kotlinType = "Array<test.pkg.OtherAnnotation>",
+                    kotlinExpression =
+                        "[test.pkg.OtherAnnotation(intType = 1), test.pkg.OtherAnnotation(intType = 2)]",
+                    expectedLegacySource =
+                        expectations {
+                            common =
+                                "{@test.pkg.OtherAnnotation(intType = 1), @test.pkg.OtherAnnotation(intType = 2)}"
                             annotationToSource =
-                                "@test.pkg.OtherAnnotation(" +
-                                    "classType=void.class," +
-                                    " enumType=test.pkg.TestEnum.DEFAULT," +
-                                    " intType=1," +
-                                    " stringType=\"default\"," +
-                                    " stringArrayType={}" +
-                                    ")"
+                                "{@test.pkg.OtherAnnotation(intType=1), @test.pkg.OtherAnnotation(intType=2)}"
                         },
                     expectedKotlinLegacySource =
-                        partialExpectations {
-                            attributeDefaultValue = "@OtherAnnotation(intType = 1)"
-                            annotationToSource = "@OtherAnnotation(intType = 1)"
+                        expectations {
+                            common =
+                                "{test.pkg.OtherAnnotation(intType=1), test.pkg.OtherAnnotation(intType=2)}"
                         },
                     // Annotation literals cannot be used in fields.
-                    suitableFor = allValueUseSitesExceptFields,
+                    suitableFor = allLegacyValueUseSitesExceptFields,
+                    expectedValue =
+                        expectations {
+                            common =
+                                arrayValue(
+                                    annotationValue(
+                                        "test.pkg.OtherAnnotation",
+                                        "intType" to literalValue(1),
+                                    ),
+                                    annotationValue(
+                                        "test.pkg.OtherAnnotation",
+                                        "intType" to literalValue(2),
+                                    ),
+                                )
+                        },
                 ),
                 // Check a simple boolean true value.
                 ValueExample(
@@ -199,6 +378,7 @@ class ValueExample(
                     javaExpression = "true",
                     kotlinType = "Boolean",
                     expectedLegacySource = expectations { common = "true" },
+                    expectedValue = expectations { common = literalValue(true) },
                 ),
                 // Check a simple boolean false value.
                 ValueExample(
@@ -207,6 +387,7 @@ class ValueExample(
                     javaExpression = "false",
                     kotlinType = "Boolean",
                     expectedLegacySource = expectations { common = "false" },
+                    expectedValue = expectations { common = literalValue(false) },
                 ),
                 // Check a simple byte.
                 ValueExample(
@@ -215,6 +396,38 @@ class ValueExample(
                     javaExpression = "116",
                     kotlinType = "Byte",
                     expectedLegacySource = expectations { common = "116" },
+                    expectedValue =
+                        expectations { common = primitiveValueForKind(Primitive.BYTE, 116) },
+                ),
+                // Check a negative byte.
+                ValueExample(
+                    name = "byte - negative int",
+                    javaType = "byte",
+                    javaExpression = "-7",
+                    kotlinType = "Byte",
+                    expectedLegacySource =
+                        expectations {
+                            common = "-7"
+
+                            annotationToSource = "0xfffffff9"
+                        },
+                    expectedKotlinLegacySource = expectations { common = "-7" },
+                    expectedValue =
+                        expectations { common = primitiveValueForKind(Primitive.BYTE, -7) },
+                ),
+                // Check a byte cast expression.
+                ValueExample(
+                    name = "byte - cast",
+                    javaType = "byte",
+                    javaExpression = "(byte) 116",
+                    kotlinType = "Byte",
+                    kotlinExpression = "116.toByte()",
+                    expectedLegacySource = expectations { common = "116" },
+                    expectedValue =
+                        expectations {
+                            common = literalValue(116.toByte(), nonLiteralInSource = true)
+                            jar { common = primitiveValueForKind(Primitive.BYTE, 116) }
+                        },
                 ),
                 // Check a simple char.
                 ValueExample(
@@ -226,12 +439,10 @@ class ValueExample(
                     expectedLegacySource =
                         expectations {
                             common = "'x'"
-                            // TODO(b/354633349): Should have surrounding quotes.
-                            fieldValue = "x"
                             fieldWriteWithSemicolon = "120"
                         },
-                    expectedKotlinLegacySource =
-                        partialExpectations { attributeDefaultValue = "\"x\"" },
+                    expectedKotlinLegacySource = expectations { attributeDefaultValue = "\"x\"" },
+                    expectedValue = expectations { common = literalValue('x') },
                 ),
                 // Check a unicode char.
                 ValueExample(
@@ -243,14 +454,11 @@ class ValueExample(
                     expectedLegacySource =
                         expectations {
                             common = "'\\u2912'"
-                            // TODO(b/354633349): Should have surrounding quotes and use the
-                            //   `\uABCD` form.
-                            fieldValue = ""
-                            jar { attributeValue = "''" }
                             fieldWriteWithSemicolon = "10514"
                         },
                     expectedKotlinLegacySource =
-                        partialExpectations { attributeDefaultValue = "\"\\u2912\"" },
+                        expectations { attributeDefaultValue = "\"\\u2912\"" },
+                    expectedValue = expectations { common = literalValue('\u2912') },
                 ),
                 // Check char escaped.
                 ValueExample(
@@ -263,22 +471,44 @@ class ValueExample(
                         expectations {
                             // This seems like the best representation. Quoted and escaped.
                             common = "'\\t'"
-                            // TODO(b/354633349): Should have surrounding quotes and use the
-                            //   `\uABCD` form.
-                            fieldValue = "\t"
                             fieldWriteWithSemicolon = "9"
                         },
-                    expectedKotlinLegacySource =
-                        partialExpectations { attributeDefaultValue = "\"\\t\"" },
+                    expectedKotlinLegacySource = expectations { attributeDefaultValue = "\"\\t\"" },
+                    expectedValue = expectations { common = literalValue('\t') },
+                ),
+                // Check a class literal for a basic class.
+                ValueExample(
+                    name = "class literal - basic class",
+                    javaType = "Class<?>",
+                    javaExpression = "BitSet.class",
+                    javaImports = listOf("java.util.BitSet"),
+                    kotlinType = "Class<*>",
+                    kotlinExpression = "BitSet::class.java",
+                    signatureExpression = "java.util.BitSet.class",
+                    expectedLegacySource =
+                        expectations {
+                            common = "java.util.BitSet.class"
+                            source {
+                                // TODO(b/354633349): Fully qualified is better.
+                                common = "BitSet.class"
+                                attributeDefaultValue = "java.util.BitSet.class"
+                            }
+                        },
+                    expectedKotlinLegacySource = expectations { common = "BitSet::class" },
+                    expectedValue =
+                        expectations {
+                            common = classObjectValue(classTypeItem("java.util.BitSet"))
+                        },
                 ),
-                // Check a class literal.
+                // Check a class literal for a generic class.
                 ValueExample(
-                    name = "class",
+                    name = "class literal - generic class",
                     javaType = "Class<?>",
                     javaExpression = "List.class",
                     javaImports = listOf("java.util.List"),
                     kotlinType = "Class<*>",
                     kotlinExpression = "List::class.java",
+                    signatureExpression = "java.util.List.class",
                     expectedLegacySource =
                         expectations {
                             common = "java.util.List.class"
@@ -288,20 +518,46 @@ class ValueExample(
                                 attributeDefaultValue = "java.util.List.class"
                             }
                         },
+                    expectedKotlinLegacySource = expectations { common = "List::class" },
+                    expectedValue =
+                        expectations { common = classObjectValue(classTypeItem("java.util.List")) },
+                ),
+                // Check an array of a basic class literal.
+                ValueExample(
+                    name = "class literal - array of basic class",
+                    javaType = "Class<?>",
+                    javaExpression = "BitSet[].class",
+                    javaImports = listOf("java.util.BitSet"),
+                    kotlinType = "Class<*>",
+                    kotlinExpression = "Array<BitSet>::class.java",
+                    signatureExpression = "java.util.BitSet[].class",
+                    expectedLegacySource =
+                        expectations {
+                            common = "java.util.BitSet[].class"
+                            source {
+                                // TODO(b/354633349): Fully qualified is better.
+                                common = "BitSet[].class"
+                                attributeDefaultValue = "java.util.BitSet[].class"
+                            }
+                        },
                     expectedKotlinLegacySource =
-                        partialExpectations {
-                            // Some value use sites throw a class cast exception.
-                            attributeDefaultValue = "List::class.java"
+                        expectations { source { common = "Array<BitSet>::class" } },
+                    expectedValue =
+                        expectations {
+                            common =
+                                classObjectValue(arrayTypeItem(classTypeItem("java.util.BitSet")))
                         },
                 ),
-                // Check an array class literal.
+                // Check an array of a generic class literal.
                 ValueExample(
-                    name = "class array literal",
+                    name = "class literal - array of generic class",
                     javaType = "Class<?>",
                     javaExpression = "List[].class",
                     javaImports = listOf("java.util.List"),
-                    kotlinType = "Class<*>",
-                    kotlinExpression = "Array<List>::class.java",
+                    // While Kotlin can correctly map a `List[].class` instance from a Java
+                    // annotation it has no way of representing it in the source.
+                    validForInputFormats = notValidForKotlin,
+                    signatureExpression = "java.util.List[].class",
                     expectedLegacySource =
                         expectations {
                             common = "java.util.List[].class"
@@ -311,29 +567,29 @@ class ValueExample(
                                 attributeDefaultValue = "java.util.List[].class"
                             }
                         },
-                    expectedKotlinLegacySource =
-                        partialExpectations {
-                            // Some value use sites throw a class cast exception.
-                            attributeDefaultValue = "Array<List>::class.java"
+                    expectedValue =
+                        expectations {
+                            common =
+                                classObjectValue(arrayTypeItem(classTypeItem("java.util.List")))
                         },
                 ),
-                // Check a primitive class literal.
+                // Check a primitive void class literal.
                 ValueExample(
-                    name = "class void primitive class",
+                    name = "class literal - void primitive",
                     javaType = "Class<?>",
                     javaExpression = "void.class",
-                    kotlinType = "Class<*>",
-                    kotlinExpression = "Unit::class.java",
+                    // While Kotlin can correctly map a `void.class` instance from a Java annotation
+                    // it has no way of representing it in the source.
+                    validForInputFormats = notValidForKotlin,
                     expectedLegacySource = expectations { common = "void.class" },
-                    expectedKotlinLegacySource =
-                        partialExpectations {
-                            // Some value use sites throw a class cast exception.
-                            attributeDefaultValue = "Unit::class.java"
+                    expectedValue =
+                        expectations {
+                            common = classObjectValue(primitiveTypeForKind(Primitive.VOID))
                         },
                 ),
-                // Check a primitive wrapper class literal.
+                // Check a primitive void wrapper class literal.
                 ValueExample(
-                    name = "class void wrapper class",
+                    name = "class literal - void wrapper",
                     javaType = "Class<?>",
                     javaExpression = "Void.class",
                     kotlinType = "Class<*>",
@@ -344,28 +600,60 @@ class ValueExample(
                             source {
                                 // TODO(b/354633349): Fully qualified is better unless java.lang
                                 //   prefix is removed.
-                                attributeValue = "Void.class"
                                 annotationToSource = "Void.class"
                             }
                         },
-                    expectedKotlinLegacySource =
-                        partialExpectations {
-                            // Some value use sites throw a class cast exception.
-                            attributeDefaultValue = "java.lang.Void::class.java"
+                    expectedKotlinLegacySource = expectations { common = "java.lang.Void::class" },
+                    expectedValue =
+                        expectations { common = classObjectValue(classTypeItem("java.lang.Void")) },
+                ),
+                ValueExample(
+                    name = "class literal - int primitive",
+                    javaType = "Class<?>",
+                    javaExpression = "int.class",
+                    kotlinType = "Class<*>",
+                    kotlinExpression = "Int::class.java",
+                    expectedLegacySource = expectations { common = "int.class" },
+                    expectedKotlinLegacySource = expectations { common = "Int::class" },
+                    expectedValue =
+                        expectations {
+                            common = classObjectValue(primitiveTypeForKind(Primitive.INT))
+                        },
+                ),
+                ValueExample(
+                    name = "class literal - int wrapper",
+                    javaType = "Class<?>",
+                    javaExpression = "Integer.class",
+                    kotlinType = "Class<*>",
+                    kotlinExpression = "Integer::class.java",
+                    expectedLegacySource =
+                        expectations {
+                            common = "java.lang.Integer.class"
+                            source {
+                                // TODO(b/354633349): Fully qualified is better unless java.lang
+                                //   prefix is removed.
+                                annotationToSource = "Integer.class"
+                            }
+                        },
+                    expectedKotlinLegacySource = expectations { common = "Integer::class" },
+                    expectedValue =
+                        expectations {
+                            common = classObjectValue(classTypeItem("java.lang.Integer"))
                         },
                 ),
                 // Check a primitive array class literal.
                 ValueExample(
-                    name = "class int array literal",
+                    name = "class literal - int array",
                     javaType = "Class<?>",
                     javaExpression = "int[].class",
                     kotlinType = "Class<*>",
                     kotlinExpression = "IntArray::class.java",
                     expectedLegacySource = expectations { common = "int[].class" },
-                    expectedKotlinLegacySource =
-                        partialExpectations {
-                            // Some value use sites throw a class cast exception.
-                            attributeDefaultValue = "IntArray::class.java"
+                    expectedKotlinLegacySource = expectations { common = "IntArray::class" },
+                    expectedValue =
+                        expectations {
+                            common =
+                                classObjectValue(arrayTypeItem(primitiveTypeForKind(Primitive.INT)))
                         },
                 ),
                 // Check a simple double.
@@ -375,6 +663,7 @@ class ValueExample(
                     javaExpression = "3.141",
                     kotlinType = "Double",
                     expectedLegacySource = expectations { common = "3.141" },
+                    expectedValue = expectations { common = literalValue(3.141) },
                 ),
                 // Check a simple double with int
                 ValueExample(
@@ -392,26 +681,98 @@ class ValueExample(
 
                             source {
                                 // TODO(b/354633349): Consistency is good.
-                                attributeDefaultValue = "3"
-                                attributeValue = "3"
-                                annotationToSource = "3"
+                                common = "3"
+                                fieldWriteWithSemicolon = "3.0"
                             }
                         },
-                    expectedKotlinLegacySource = partialExpectations { source { common = "3" } },
+                    expectedKotlinLegacySource = expectations { annotationToSource = "3.0" },
+                    expectedValue =
+                        expectations {
+                            // Expect a double value created from an int.
+                            common = primitiveValueForKind(Primitive.DOUBLE, 3)
+                            jar { common = literalValue(3.0) }
+                        },
                 ),
-                // Check a simple double with exponent
+                // Check a simple double with negative int
                 ValueExample(
-                    name = "double with exponent",
+                    name = "double - negative int",
                     javaType = "double",
-                    javaExpression = "7e10",
+                    javaExpression = "-2",
+                    kotlinType = "Double",
+                    expectedLegacySource =
+                        expectations {
+                            common = "-2.0"
+
+                            source {
+                                // TODO(b/354633349): Consistency is good.
+                                attributeDefaultValue = "-2"
+                                annotationToSource = "0xfffffffe"
+                            }
+                        },
+                    expectedKotlinLegacySource = expectations { annotationToSource = "-2.0" },
+                    expectedValue =
+                        expectations {
+                            // Expect a double value created from an int.
+                            common = primitiveValueForKind(Primitive.DOUBLE, -2)
+                            jar { common = literalValue(-2.0) }
+                        },
+                ),
+                // Check a simple double with float
+                ValueExample(
+                    name = "double - float",
+                    javaType = "double",
+                    javaExpression = "2.0f",
+                    kotlinType = "Double",
+                    expectedLegacySource =
+                        expectations {
+                            common = "2.0"
+
+                            source {
+                                attributeDefaultValue = "2.0f"
+                                annotationToSource = "2.0f"
+                            }
+                        },
+                    expectedKotlinLegacySource = expectations { annotationToSource = "2.0" },
+                    expectedValue =
+                        expectations {
+                            // Expect a double value created from a float.
+                            common = primitiveValueForKind(Primitive.DOUBLE, 2.0f)
+                            jar { common = literalValue(2.0) }
+                        },
+                ),
+                // Check a simple double with float
+                ValueExample(
+                    name = "double - negative float",
+                    javaType = "double",
+                    javaExpression = "-2.0f",
                     kotlinType = "Double",
                     expectedLegacySource =
                         expectations {
-                            common = "7.0E10"
+                            common = "-2.0"
 
-                            source { attributeValue = "7e10" }
+                            source {
+                                // TODO(b/354633349): Consistency is good.
+                                attributeDefaultValue = "-2.0f"
+                                annotationToSource = "-2.0F"
+                            }
+                        },
+                    expectedKotlinLegacySource = expectations { annotationToSource = "-2.0" },
+                    expectedValue =
+                        expectations {
+                            // Expect a double value created from a float
+                            common = primitiveValueForKind(Primitive.DOUBLE, -2.0f)
+                            jar { common = literalValue(-2.0) }
                         },
                 ),
+                // Check a simple double with exponent
+                ValueExample(
+                    name = "double with exponent",
+                    javaType = "double",
+                    javaExpression = "7e10",
+                    kotlinType = "Double",
+                    expectedLegacySource = expectations { common = "7.0E10" },
+                    expectedValue = expectations { common = literalValue(7e10) },
+                ),
                 // Check a special double - Nan.
                 ValueExample(
                     name = "double NaN",
@@ -420,6 +781,8 @@ class ValueExample(
                     kotlinType = "Double",
                     expectedLegacySource =
                         expectations {
+                            fieldWriteWithSemicolon = "(0.0/0.0)"
+
                             // TODO(b/354633349): Every single use has a different representation!?
                             //   Ideally, this should just `java.lang.Double.NaN` when that is how
                             //   it is referenced in the source and some expression like `(0.0/0.0)`
@@ -427,25 +790,20 @@ class ValueExample(
                             //   itself.
                             source {
                                 attributeDefaultValue = "java.lang.Double.NaN"
-                                attributeValue = "Double.NaN"
                                 annotationToSource = "java.lang.Double.NaN"
-                                fieldValue = "NaN"
-                                fieldWriteWithSemicolon = "(0.0/0.0)"
                             }
 
                             jar {
                                 attributeDefaultValue = "(0.0/0.0)"
-                                attributeValue = "0.0d / 0.0"
                                 annotationToSource = "0.0 / 0.0"
-                                fieldValue = NO_INITIAL_FIELD_VALUE
-                                fieldWriteWithSemicolon = NO_INITIAL_FIELD_VALUE
                             }
                         },
                     expectedKotlinLegacySource =
-                        partialExpectations {
+                        expectations {
                             attributeDefaultValue = "kotlin.jvm.internal.DoubleCompanionObject.NaN"
                             annotationToSource = "kotlin.jvm.internal.DoubleCompanionObject.NaN"
                         },
+                    expectedValue = expectations { common = DoubleValue.NaN },
                 ),
                 // Check a special double - +infinity.
                 ValueExample(
@@ -455,6 +813,8 @@ class ValueExample(
                     kotlinType = "Double",
                     expectedLegacySource =
                         expectations {
+                            fieldWriteWithSemicolon = "(1.0/0.0)"
+
                             // TODO(b/354633349): Every single use has a different representation!?
                             //   Ideally, this should just `java.lang.Double.NaN` when that is how
                             //   it is referenced in the source and some expression like `(1.0/0.0)`
@@ -462,27 +822,22 @@ class ValueExample(
                             //   `java.lang.Double.POSITIVE_INFINITY` itself.
                             source {
                                 attributeDefaultValue = "java.lang.Double.POSITIVE_INFINITY"
-                                attributeValue = "Double.POSITIVE_INFINITY"
                                 annotationToSource = "java.lang.Double.POSITIVE_INFINITY"
-                                fieldValue = "Infinity"
-                                fieldWriteWithSemicolon = "(1.0/0.0)"
                             }
 
                             jar {
                                 attributeDefaultValue = "(1.0/0.0)"
-                                attributeValue = "1.0 / 0.0"
                                 annotationToSource = "1.0 / 0.0"
-                                fieldValue = NO_INITIAL_FIELD_VALUE
-                                fieldWriteWithSemicolon = NO_INITIAL_FIELD_VALUE
                             }
                         },
                     expectedKotlinLegacySource =
-                        partialExpectations {
+                        expectations {
                             attributeDefaultValue =
                                 "kotlin.jvm.internal.DoubleCompanionObject.POSITIVE_INFINITY"
                             annotationToSource =
                                 "kotlin.jvm.internal.DoubleCompanionObject.POSITIVE_INFINITY"
                         },
+                    expectedValue = expectations { common = DoubleValue.POSITIVE_INFINITY },
                 ),
                 ValueExample(
                     name = "double negative infinity",
@@ -491,6 +846,8 @@ class ValueExample(
                     kotlinType = "Double",
                     expectedLegacySource =
                         expectations {
+                            fieldWriteWithSemicolon = "(-1.0/0.0)"
+
                             // TODO(b/354633349): Every single use has a different representation!?
                             //   Ideally, this should just `java.lang.Double.NaN` when that is how
                             //   it is referenced in the source and some expression like `(1.0/0.0)`
@@ -498,27 +855,40 @@ class ValueExample(
                             //   `java.lang.Double.NEGATIVE_INFINITY` itself.
                             source {
                                 attributeDefaultValue = "java.lang.Double.NEGATIVE_INFINITY"
-                                attributeValue = "Double.NEGATIVE_INFINITY"
                                 annotationToSource = "java.lang.Double.NEGATIVE_INFINITY"
-                                fieldValue = "-Infinity"
-                                fieldWriteWithSemicolon = "(-1.0/0.0)"
                             }
 
                             jar {
                                 attributeDefaultValue = "(-1.0/0.0)"
-                                attributeValue = "-1.0 / 0.0"
                                 annotationToSource = "-1.0 / 0.0"
-                                fieldValue = NO_INITIAL_FIELD_VALUE
-                                fieldWriteWithSemicolon = NO_INITIAL_FIELD_VALUE
                             }
                         },
                     expectedKotlinLegacySource =
-                        partialExpectations {
+                        expectations {
                             attributeDefaultValue =
                                 "kotlin.jvm.internal.DoubleCompanionObject.NEGATIVE_INFINITY"
                             annotationToSource =
                                 "kotlin.jvm.internal.DoubleCompanionObject.NEGATIVE_INFINITY"
                         },
+                    expectedValue =
+                        expectations { common = literalValue(Double.NEGATIVE_INFINITY) },
+                ),
+                ValueExample(
+                    name = "double - negative max",
+                    javaType = "double",
+                    javaExpression = "-1.7976931348623157E308",
+                    kotlinType = "Double",
+                    expectedLegacySource = expectations { common = "-1.7976931348623157E308" },
+                    expectedValue = expectations { common = literalValue(-Double.MAX_VALUE) },
+                ),
+                ValueExample(
+                    name = "double - hex",
+                    javaType = "double",
+                    javaExpression = "0x1p3",
+                    // Kotlin does not support hex floating point numbers.
+                    validForInputFormats = notValidForKotlin,
+                    expectedLegacySource = expectations { common = "8.0" },
+                    expectedValue = expectations { common = literalValue(8.0) },
                 ),
                 // Check an enum literal.
                 ValueExample(
@@ -528,70 +898,435 @@ class ValueExample(
                     // Must fully qualify most classes in signature files.
                     signatureType = "test.pkg.TestEnum",
                     signatureExpression = "test.pkg.TestEnum.VALUE1",
+                    expectedLegacySource = expectations { common = "test.pkg.TestEnum.VALUE1" },
+                    expectedValue =
+                        expectations {
+                            common = fieldReferenceValue("test.pkg.TestEnum", "VALUE1")
+                        },
+                ),
+                // Check a statically imported enum literal.
+                ValueExample(
+                    name = "enum - static import",
+                    javaType = "TestEnum",
+                    javaExpression = "VALUE1",
+                    javaImports = listOf("static test.pkg.TestEnum.VALUE1"),
+                    kotlinImports = listOf("test.pkg.TestEnum.VALUE1"),
+                    // Signature files does not support unqualified fields.
+                    validForInputFormats = notValidForSignature,
+                    expectedLegacySource = expectations { common = "test.pkg.TestEnum.VALUE1" },
+                    expectedValue =
+                        expectations {
+                            common = fieldReferenceValue("test.pkg.TestEnum", "VALUE1")
+                        },
+                ),
+                ValueExample(
+                    name = "field - generic class constant",
+                    javaType = "String",
+                    javaExpression = "GenericClass.STRING_CONSTANT",
+                    signatureExpression = "test.pkg.GenericClass.STRING_CONSTANT",
                     expectedLegacySource =
                         expectations {
-                            common = "test.pkg.TestEnum.VALUE1"
+                            common = "\"constant\""
+
                             source {
-                                // TODO(b/354633349): Fully qualified is better.
-                                attributeValue = "TestEnum.VALUE1"
+                                common = "test.pkg.GenericClass.STRING_CONSTANT"
+                                // TODO(b/354633349): Should probably be a field reference, at least
+                                //   in some cases.
+                                fieldWriteWithSemicolon = "\"constant\""
+                            }
+                        },
+                    expectedKotlinLegacySource =
+                        expectations {
+                            annotationToSource = "test.pkg.GenericClass.Companion.STRING_CONSTANT"
+                        },
+                    expectedValue =
+                        expectations {
+                            common =
+                                fieldReferenceValue(
+                                    "test.pkg.GenericClass",
+                                    "STRING_CONSTANT",
+                                    literalValue("constant")
+                                )
+                            jar {
+                                // The compiler will always inline a constant field value.
+                                common = literalValue("constant")
                             }
                         },
                 ),
-                // Check a simple float with int
+                // Check the behavior of using an int constant field converted to a long value.
                 ValueExample(
-                    name = "float with int",
-                    javaType = "float",
-                    javaExpression = "3",
-                    kotlinType = "Float",
+                    name = "field - long with int constant",
+                    javaType = "long",
+                    javaExpression = "Constants.INT_CONSTANT",
+                    kotlinType = "Long",
+                    signatureExpression = "test.pkg.Constants.INT_CONSTANT",
                     expectedLegacySource =
                         expectations {
-                            // TODO(b/354633349): Consistency is good. It's not clear what the best
-                            //  way of formatting this is. Add a trailing F to make it clear it is a
-                            //  float when parsing the signature file even if the annotation
-                            //  definition is not available or only add it when strictly necessary.
-                            common = "3.0F"
+                            common = "37L"
 
                             source {
-                                // TODO(b/354633349): Consistency is good.
-                                attributeDefaultValue = "3"
-                                attributeValue = "3"
-                                annotationToSource = "3"
+                                annotationToSource = "test.pkg.Constants.INT_CONSTANT"
+                                attributeDefaultValue = "test.pkg.Constants.INT_CONSTANT"
                             }
-
+                        },
+                    expectedValue =
+                        expectations {
+                            common =
+                                fieldReferenceValue(
+                                    "test.pkg.Constants",
+                                    "INT_CONSTANT",
+                                    primitiveValueForKind(
+                                        Primitive.LONG,
+                                        37,
+                                        nonLiteralInSource = true,
+                                    )
+                                )
                             jar {
-                                // TODO(b/354633349): Consistency is good.
-                                common = "3.0f"
+                                // The compiler will always inline a constant field value using the
+                                // correct type.
+                                common = literalValue(37L)
                             }
-
-                            // TODO(b/354633349): Consistency is good.
-                            fieldValue = "3.0"
-                            fieldWriteWithSemicolon = "3.0f"
                         },
-                    expectedKotlinLegacySource = partialExpectations { source { common = "3" } },
                 ),
-                // Check a simple float with exponent
+                // Check the behavior of using an int constant field converted to a byte value.
                 ValueExample(
-                    name = "float with exponent",
-                    javaType = "float",
-                    javaExpression = "7e10f",
-                    kotlinType = "Float",
+                    name = "field - converted to byte",
+                    javaType = "byte",
+                    kotlinType = "Byte",
+                    kotlinExpression = "test.pkg.Constants.INT_CONSTANT.toByte()",
+                    signatureExpression = "test.pkg.Constants.INT_CONSTANT.toByte()",
+                    // Only Kotlin needs to support explicit casting like this, Java will cast
+                    // implicitly. Signature files may contain these casts, so it needs to know how
+                    // to parse them.
+                    validForInputFormats = notValidForJava,
                     expectedLegacySource =
                         expectations {
-                            common = "7.0E10f"
+                            common = "test.pkg.Constants.INT_CONSTANT"
 
-                            source { attributeValue = "7e10f" }
-
-                            fieldValue = "7.0E10"
+                            fieldWriteWithSemicolon = "37"
                         },
                     expectedKotlinLegacySource =
-                        partialExpectations { attributeDefaultValue = "7.0E10" },
-                ),
+                        expectations {
+                            source {
+                                annotationToSource = "test.pkg.Constants.INT_CONSTANT.toByte()"
+                                attributeDefaultValue = "test.pkg.Constants.INT_CONSTANT"
+                            }
+                        },
+                    expectedValue =
+                        expectations {
+                            common =
+                                fieldReferenceValue(
+                                    "test.pkg.Constants",
+                                    "INT_CONSTANT",
+                                    primitiveValueForKind(
+                                        Primitive.BYTE,
+                                        37,
+                                        nonLiteralInSource = true,
+                                    ),
+                                )
+                        },
+                ),
+                // Check the behavior of using an int constant field converted to a double value.
+                ValueExample(
+                    name = "field - converted to double",
+                    javaType = "double",
+                    kotlinType = "Double",
+                    kotlinExpression = "test.pkg.Constants.INT_CONSTANT.toDouble()",
+                    signatureExpression = "test.pkg.Constants.INT_CONSTANT.toDouble()",
+                    // Only Kotlin needs to support explicit casting like this, Java will cast
+                    // implicitly. Signature files may contain these casts, so it needs to know how
+                    // to parse them.
+                    validForInputFormats = notValidForJava,
+                    expectedLegacySource =
+                        expectations {
+                            common = "test.pkg.Constants.INT_CONSTANT"
+
+                            fieldWriteWithSemicolon = "37.0"
+                        },
+                    expectedKotlinLegacySource =
+                        expectations {
+                            source {
+                                annotationToSource = "test.pkg.Constants.INT_CONSTANT.toDouble()"
+                                attributeDefaultValue = "test.pkg.Constants.INT_CONSTANT"
+                            }
+                        },
+                    expectedValue =
+                        expectations {
+                            common =
+                                fieldReferenceValue(
+                                    "test.pkg.Constants",
+                                    "INT_CONSTANT",
+                                    primitiveValueForKind(
+                                        Primitive.DOUBLE,
+                                        37,
+                                        nonLiteralInSource = true,
+                                    ),
+                                )
+                        },
+                ),
+                // Check the behavior of using an int constant field converted to a float value.
+                ValueExample(
+                    name = "field - converted to float",
+                    javaType = "float",
+                    kotlinType = "Float",
+                    kotlinExpression = "test.pkg.Constants.INT_CONSTANT.toFloat()",
+                    signatureExpression = "test.pkg.Constants.INT_CONSTANT.toFloat()",
+                    // Only Kotlin needs to support explicit casting like this, Java will cast
+                    // implicitly. Signature files may contain these casts, so it needs to know how
+                    // to parse them.
+                    validForInputFormats = notValidForJava,
+                    expectedLegacySource =
+                        expectations {
+                            common = "test.pkg.Constants.INT_CONSTANT"
+
+                            fieldWriteWithSemicolon = "37.0f"
+                        },
+                    expectedKotlinLegacySource =
+                        expectations {
+                            source {
+                                annotationToSource = "test.pkg.Constants.INT_CONSTANT.toFloat()"
+                                attributeDefaultValue = "test.pkg.Constants.INT_CONSTANT"
+                            }
+                        },
+                    expectedValue =
+                        expectations {
+                            common =
+                                fieldReferenceValue(
+                                    "test.pkg.Constants",
+                                    "INT_CONSTANT",
+                                    primitiveValueForKind(
+                                        Primitive.FLOAT,
+                                        37,
+                                        nonLiteralInSource = true,
+                                    ),
+                                )
+                        },
+                ),
+                // Check the behavior of using a long constant field converted to an int value.
+                ValueExample(
+                    name = "field - converted to int",
+                    javaType = "int",
+                    kotlinType = "Int",
+                    kotlinExpression = "test.pkg.Constants.LONG_CONSTANT.toInt()",
+                    signatureExpression = "test.pkg.Constants.LONG_CONSTANT.toInt()",
+                    // Only Kotlin needs to support explicit casting like this, Java will cast
+                    // implicitly. Signature files may contain these casts, so it needs to know how
+                    // to parse them.
+                    validForInputFormats = notValidForJava,
+                    expectedLegacySource =
+                        expectations {
+                            common = "test.pkg.Constants.LONG_CONSTANT"
+
+                            fieldWriteWithSemicolon = "9"
+                        },
+                    expectedKotlinLegacySource =
+                        expectations {
+                            source {
+                                annotationToSource = "test.pkg.Constants.LONG_CONSTANT.toInt()"
+                                attributeDefaultValue = "test.pkg.Constants.LONG_CONSTANT"
+                            }
+                        },
+                    expectedValue =
+                        expectations {
+                            common =
+                                fieldReferenceValue(
+                                    "test.pkg.Constants",
+                                    "LONG_CONSTANT",
+                                    primitiveValueForKind(
+                                        Primitive.INT,
+                                        9L,
+                                        nonLiteralInSource = true,
+                                    ),
+                                )
+                        },
+                ),
+                // Check the behavior of using an int constant field converted to a long value.
+                ValueExample(
+                    name = "field - converted to long",
+                    javaType = "long",
+                    kotlinType = "Long",
+                    kotlinExpression = "test.pkg.Constants.INT_CONSTANT.toLong()",
+                    signatureExpression = "test.pkg.Constants.INT_CONSTANT.toLong()",
+                    // Only Kotlin needs to support explicit casting like this, Java will cast
+                    // implicitly. Signature files may contain these casts, so it needs to know how
+                    // to parse them.
+                    validForInputFormats = notValidForJava,
+                    expectedLegacySource =
+                        expectations {
+                            common = "test.pkg.Constants.INT_CONSTANT"
+
+                            fieldWriteWithSemicolon = "37L"
+                        },
+                    expectedKotlinLegacySource =
+                        expectations {
+                            source {
+                                annotationToSource = "test.pkg.Constants.INT_CONSTANT.toLong()"
+                                attributeDefaultValue = "test.pkg.Constants.INT_CONSTANT"
+                            }
+                        },
+                    expectedValue =
+                        expectations {
+                            common =
+                                fieldReferenceValue(
+                                    "test.pkg.Constants",
+                                    "INT_CONSTANT",
+                                    primitiveValueForKind(
+                                        Primitive.LONG,
+                                        37,
+                                        nonLiteralInSource = true,
+                                    ),
+                                )
+                        },
+                ),
+                // Check the behavior of using an int constant field converted to a short value.
+                ValueExample(
+                    name = "field - converted to short",
+                    javaType = "short",
+                    kotlinType = "Short",
+                    kotlinExpression = "test.pkg.Constants.INT_CONSTANT.toShort()",
+                    signatureExpression = "test.pkg.Constants.INT_CONSTANT.toShort()",
+                    // Only Kotlin needs to support explicit casting like this, Java will cast
+                    // implicitly. Signature files may contain these casts, so it needs to know how
+                    // to parse them.
+                    validForInputFormats = notValidForJava,
+                    expectedLegacySource =
+                        expectations {
+                            common = "test.pkg.Constants.INT_CONSTANT"
+
+                            fieldWriteWithSemicolon = "37"
+                        },
+                    expectedKotlinLegacySource =
+                        expectations {
+                            source {
+                                annotationToSource = "test.pkg.Constants.INT_CONSTANT.toShort()"
+                                attributeDefaultValue = "test.pkg.Constants.INT_CONSTANT"
+                            }
+                        },
+                    expectedValue =
+                        expectations {
+                            common =
+                                fieldReferenceValue(
+                                    "test.pkg.Constants",
+                                    "INT_CONSTANT",
+                                    primitiveValueForKind(
+                                        Primitive.SHORT,
+                                        37,
+                                        nonLiteralInSource = true,
+                                    ),
+                                )
+                        },
+                ),
+                // Check a negative float
+                ValueExample(
+                    name = "float - negative",
+                    javaType = "float",
+                    javaExpression = "-2.7f",
+                    kotlinType = "Float",
+                    expectedLegacySource =
+                        expectations {
+                            common = "-2.7f"
+
+                            // TODO(b/354633349): Consistency is good.
+                            annotationToSource = "-2.7F"
+                        },
+                    expectedKotlinLegacySource =
+                        expectations {
+                            annotationToSource = "-2.7f"
+                            attributeDefaultValue = "-2.7"
+                        },
+                    expectedValue =
+                        expectations {
+                            // Expect a float value created from an int.
+                            common = literalValue(-2.7f)
+                        },
+                ),
+                // Check a simple float with int
+                ValueExample(
+                    name = "float with int",
+                    javaType = "float",
+                    javaExpression = "3",
+                    kotlinType = "Float",
+                    expectedLegacySource =
+                        expectations {
+                            // TODO(b/354633349): Consistency is good. It's not clear what the best
+                            //  way of formatting this is. Add a trailing F to make it clear it is a
+                            //  float when parsing the signature file even if the annotation
+                            //  definition is not available or only add it when strictly necessary.
+                            common = "3.0F"
+
+                            source {
+                                // TODO(b/354633349): Consistency is good.
+                                common = "3"
+                            }
+
+                            jar {
+                                // TODO(b/354633349): Consistency is good.
+                                common = "3.0f"
+                            }
+
+                            fieldWriteWithSemicolon = "3.0f"
+                        },
+                    expectedKotlinLegacySource = expectations { annotationToSource = "3.0f" },
+                    expectedValue =
+                        expectations {
+                            // Expect a float value created from an int.
+                            common = primitiveValueForKind(Primitive.FLOAT, 3)
+                            jar { common = literalValue(3.0f) }
+                        },
+                ),
+                // Check a simple float with int
+                ValueExample(
+                    name = "float - negative int",
+                    javaType = "float",
+                    javaExpression = "-2",
+                    kotlinType = "Float",
+                    expectedLegacySource =
+                        expectations {
+                            // TODO(b/354633349): Consistency is good. It's not clear what the best
+                            //  way of formatting this is. Add a trailing F to make it clear it is a
+                            //  float when parsing the signature file even if the annotation
+                            //  definition is not available or only add it when strictly necessary.
+                            common = "-2.0f"
+
+                            source {
+                                // TODO(b/354633349): Consistency is good.
+                                attributeDefaultValue = "-2"
+                                annotationToSource = "0xfffffffe"
+                            }
+
+                            jar {
+                                // TODO(b/354633349): Consistency is good.
+                                annotationToSource = "-2.0F"
+                            }
+                        },
+                    expectedKotlinLegacySource = expectations { annotationToSource = "-2.0f" },
+                    expectedValue =
+                        expectations {
+                            // Expect a float value created from an int.
+                            common = primitiveValueForKind(Primitive.FLOAT, -2)
+                            jar { common = literalValue(-2.0f) }
+                        },
+                ),
+                // Check a simple float with exponent
+                ValueExample(
+                    name = "float with exponent",
+                    javaType = "float",
+                    javaExpression = "7e10f",
+                    kotlinType = "Float",
+                    expectedLegacySource = expectations { common = "7.0E10f" },
+                    expectedKotlinLegacySource = expectations { attributeDefaultValue = "7.0E10" },
+                    expectedValue = expectations { common = literalValue(7e10f) },
+                ),
                 // Check a simple float with upper F.
                 ValueExample(
                     name = "float with upper F",
                     javaType = "float",
                     javaExpression = "3.141F",
                     kotlinType = "Float",
+                    // Signature files only contain a float with an 'F' suffix in annotations when
+                    // the source expression was not a literal. Use 'f' suffix here as this is a
+                    // literal. The 'F' suffix is tested below in the "float - expression" example.
+                    signatureExpression = "3.141f",
                     expectedLegacySource =
                         expectations {
                             common = "3.141F"
@@ -605,12 +1340,10 @@ class ValueExample(
                                 common = "3.141f"
                             }
 
-                            // TODO(b/354633349): Consistency is good.
-                            fieldValue = "3.141"
                             fieldWriteWithSemicolon = "3.141f"
                         },
-                    expectedKotlinLegacySource =
-                        partialExpectations { attributeDefaultValue = "3.141" },
+                    expectedKotlinLegacySource = expectations { attributeDefaultValue = "3.141" },
+                    expectedValue = expectations { common = literalValue(3.141F) },
                 ),
                 // Check a simple float with lower F.
                 ValueExample(
@@ -618,15 +1351,9 @@ class ValueExample(
                     javaType = "float",
                     javaExpression = "3.141f",
                     kotlinType = "Float",
-                    expectedLegacySource =
-                        expectations {
-                            common = "3.141f"
-
-                            // TODO(b/354633349): Consistency is good.
-                            fieldValue = "3.141"
-                        },
-                    expectedKotlinLegacySource =
-                        partialExpectations { attributeDefaultValue = "3.141" },
+                    expectedLegacySource = expectations { common = "3.141f" },
+                    expectedKotlinLegacySource = expectations { attributeDefaultValue = "3.141" },
+                    expectedValue = expectations { common = literalValue(3.141f) },
                 ),
                 // Check a special float - Nan.
                 ValueExample(
@@ -636,31 +1363,31 @@ class ValueExample(
                     kotlinType = "Float",
                     expectedLegacySource =
                         expectations {
+                            fieldWriteWithSemicolon = "(0.0f/0.0f)"
+
                             // TODO(b/354633349): Every single use has a different representation!?
                             //   Ideally, this should just `java.lang.Float.NaN` when that is how it
                             //   is referenced in the source and some expression like `(0.0f/0.0f)`
                             //   when it is defined like that, e.g. on `java.lang.Float.NaN` itself.
                             source {
                                 attributeDefaultValue = "java.lang.Float.NaN"
-                                attributeValue = "Float.NaN"
                                 annotationToSource = "java.lang.Float.NaN"
-                                fieldValue = "NaN"
-                                fieldWriteWithSemicolon = "(0.0f/0.0f)"
                             }
 
                             jar {
                                 attributeDefaultValue = "(0.0/0.0)"
-                                attributeValue = "0.0f / 0.0"
                                 annotationToSource = "0.0f / 0.0"
-                                fieldValue = NO_INITIAL_FIELD_VALUE
-                                fieldWriteWithSemicolon = NO_INITIAL_FIELD_VALUE
                             }
                         },
                     expectedKotlinLegacySource =
-                        partialExpectations {
+                        expectations {
                             attributeDefaultValue = "kotlin.jvm.internal.FloatCompanionObject.NaN"
                             annotationToSource = "kotlin.jvm.internal.FloatCompanionObject.NaN"
                         },
+                    expectedValue =
+                        expectations {
+                            common = literalValue(Float.NaN, nonLiteralInSource = true)
+                        },
                 ),
                 // Check a special float - +infinity.
                 ValueExample(
@@ -670,6 +1397,8 @@ class ValueExample(
                     kotlinType = "Float",
                     expectedLegacySource =
                         expectations {
+                            fieldWriteWithSemicolon = "(1.0f/0.0f)"
+
                             // TODO(b/354633349): Every single use has a different representation!?
                             //   Ideally, this should just `java.lang.Float.NaN` when that is how it
                             //   is referenced in the source and some expression like `(1.0f/0.0f)`
@@ -677,27 +1406,26 @@ class ValueExample(
                             //   `java.lang.Float.POSITIVE_INFINITY` itself.
                             source {
                                 attributeDefaultValue = "java.lang.Float.POSITIVE_INFINITY"
-                                attributeValue = "Float.POSITIVE_INFINITY"
                                 annotationToSource = "java.lang.Float.POSITIVE_INFINITY"
-                                fieldValue = "Infinity"
-                                fieldWriteWithSemicolon = "(1.0f/0.0f)"
                             }
 
                             jar {
                                 attributeDefaultValue = "(1.0/0.0)"
-                                attributeValue = "1.0f / 0.0"
                                 annotationToSource = "1.0f / 0.0"
-                                fieldValue = NO_INITIAL_FIELD_VALUE
-                                fieldWriteWithSemicolon = NO_INITIAL_FIELD_VALUE
                             }
                         },
                     expectedKotlinLegacySource =
-                        partialExpectations {
+                        expectations {
                             attributeDefaultValue =
                                 "kotlin.jvm.internal.FloatCompanionObject.POSITIVE_INFINITY"
                             annotationToSource =
                                 "kotlin.jvm.internal.FloatCompanionObject.POSITIVE_INFINITY"
                         },
+                    expectedValue =
+                        expectations {
+                            common =
+                                literalValue(Float.POSITIVE_INFINITY, nonLiteralInSource = true)
+                        },
                 ),
                 ValueExample(
                     name = "float negative infinity",
@@ -706,6 +1434,8 @@ class ValueExample(
                     kotlinType = "Float",
                     expectedLegacySource =
                         expectations {
+                            fieldWriteWithSemicolon = "(-1.0f/0.0f)"
+
                             // TODO(b/354633349): Every single use has a different representation!?
                             //   Ideally, this should just `java.lang.Float.NaN` when that is how it
                             //   is referenced in the source and some expression like `(1.0f/0.0f)`
@@ -713,27 +1443,58 @@ class ValueExample(
                             //   `java.lang.Float.NEGATIVE_INFINITY` itself.
                             source {
                                 attributeDefaultValue = "java.lang.Float.NEGATIVE_INFINITY"
-                                attributeValue = "Float.NEGATIVE_INFINITY"
                                 annotationToSource = "java.lang.Float.NEGATIVE_INFINITY"
-                                fieldValue = "-Infinity"
-                                fieldWriteWithSemicolon = "(-1.0f/0.0f)"
                             }
 
                             jar {
                                 attributeDefaultValue = "(-1.0/0.0)"
-                                attributeValue = "-1.0f / 0.0"
                                 annotationToSource = "-1.0F / 0.0"
-                                fieldValue = NO_INITIAL_FIELD_VALUE
-                                fieldWriteWithSemicolon = NO_INITIAL_FIELD_VALUE
                             }
                         },
                     expectedKotlinLegacySource =
-                        partialExpectations {
+                        expectations {
                             attributeDefaultValue =
                                 "kotlin.jvm.internal.FloatCompanionObject.NEGATIVE_INFINITY"
                             annotationToSource =
                                 "kotlin.jvm.internal.FloatCompanionObject.NEGATIVE_INFINITY"
                         },
+                    expectedValue = expectations { common = literalValue(Float.NEGATIVE_INFINITY) },
+                ),
+                ValueExample(
+                    name = "float - hex",
+                    javaType = "float",
+                    javaExpression = "0x1p3f",
+                    // Kotlin does not support hex floating point numbers.
+                    validForInputFormats = notValidForKotlin,
+                    expectedLegacySource = expectations { common = "8.0f" },
+                    expectedValue = expectations { common = literalValue(8.0f) },
+                ),
+                ValueExample(
+                    name = "float - expression",
+                    javaType = "float",
+                    javaExpression = "2.125f * 1.5f",
+                    kotlinType = "Float",
+                    // Signature files do not support expressions but a float that was represented
+                    // by an expression in the source will use an 'F' suffix so use that here
+                    // instead to ensure the correct value is created.
+                    signatureExpression = "3.1875F",
+                    expectedLegacySource =
+                        expectations {
+                            common = "3.1875f"
+                            source { annotationToSource = "3.1875F" }
+                        },
+                    expectedKotlinLegacySource =
+                        expectations {
+                            source {
+                                annotationToSource = "3.1875f"
+                                attributeDefaultValue = "3.1875"
+                            }
+                        },
+                    expectedValue =
+                        expectations {
+                            common = literalValue(3.1875f, nonLiteralInSource = true)
+                            jar { common = literalValue(3.1875f) }
+                        },
                 ),
                 // Check a simple int.
                 ValueExample(
@@ -742,6 +1503,7 @@ class ValueExample(
                     javaExpression = "17",
                     kotlinType = "Int",
                     expectedLegacySource = expectations { common = "17" },
+                    expectedValue = expectations { common = literalValue(17) },
                 ),
                 // Check an int with a unary plus.
                 ValueExample(
@@ -749,18 +1511,21 @@ class ValueExample(
                     javaType = "int",
                     javaExpression = "+17",
                     kotlinType = "Int",
+                    // Signature files do not contain ints with a leading + but ints with a leading
+                    // + in the source are written out as hexadecimal (as the leading + makes it a
+                    // unary plus expression and so not a literal). Hence, the hexadecimal form is
+                    // used here.
+                    signatureExpression = "0x11",
                     expectedLegacySource =
                         expectations {
                             common = "17"
-                            source {
-                                // TODO(b/354633349): The leading + is unnecessary.
-                                attributeValue = "+17"
-
-                                annotationToSource = "0x11"
-                            }
+                            source { annotationToSource = "0x11" }
+                        },
+                    expectedValue =
+                        expectations {
+                            common = literalValue(17, nonLiteralInSource = true)
+                            jar { common = literalValue(17) }
                         },
-                    expectedKotlinLegacySource =
-                        partialExpectations { attributeDefaultValue = "+17" },
                 ),
                 // Check an int with a unary minus.
                 ValueExample(
@@ -774,6 +1539,36 @@ class ValueExample(
 
                             annotationToSource = "0xffffffef"
                         },
+                    expectedValue = expectations { common = literalValue(-17) },
+                ),
+                // Check an int with a complex expression
+                ValueExample(
+                    name = "int - complex",
+                    javaType = "int",
+                    javaExpression = "('_'<<24)|('P'<<16)|('N'<<8)|'G'",
+                    kotlinType = "Int",
+                    kotlinExpression =
+                        "('_'.code shl 24) or ('P'.code shl 16) or ('N'.code shl 8) or 'G'.code",
+                    // TODO(b/354633349): Only valid for Java, Kotlin is inconsistent and signature
+                    //   files do not have complex expressions at all.
+                    validForInputFormats = onlyValidForJava,
+                    expectedLegacySource =
+                        expectations {
+                            common = "1599098439"
+
+                            source { annotationToSource = "0x5f504e47" }
+                        },
+                    expectedKotlinLegacySource =
+                        expectations {
+                            source {
+                                annotationToSource = "0x5f000000 | 0x500000 | 0x4e00 | 'G'.code"
+                            }
+                        },
+                    expectedValue =
+                        expectations {
+                            common = literalValue(1599098439, nonLiteralInSource = true)
+                            jar { common = literalValue(1599098439) }
+                        },
                 ),
                 // Check a simple long with an integer value.
                 ValueExample(
@@ -788,30 +1583,55 @@ class ValueExample(
                             //  long when parsing the signature file even if the annotation
                             //  definition is not available or only add it when strictly necessary.
                             common = "1000L"
-                            fieldValue = "1000"
                             source {
                                 attributeDefaultValue = "1000"
-                                attributeValue = "1000"
                                 annotationToSource = "1000"
                             }
                         },
-                    expectedKotlinLegacySource =
-                        partialExpectations { annotationToSource = "1000L" },
+                    expectedKotlinLegacySource = expectations { annotationToSource = "1000L" },
+                    expectedValue =
+                        expectations {
+                            // Expect a long value created from an int.
+                            common = primitiveValueForKind(Primitive.LONG, 1000)
+                            jar { common = literalValue(1000L) }
+                        },
                 ),
-                // Check a simple long with an upper case suffix.
+                // Check a simple long specified with a negative integer value.
                 ValueExample(
-                    name = "long with upper L",
+                    name = "long - with negative int",
                     javaType = "long",
-                    javaExpression = "10000000000L",
+                    javaExpression = "-278",
                     kotlinType = "Long",
                     expectedLegacySource =
                         expectations {
-                            common = "10000000000L"
-                            // TODO(b/354633349): Consistency is good.
-                            fieldValue = "10000000000"
+                            // TODO(b/354633349): Consistency is good. It's not clear what the best
+                            //  way of formatting this is. Add a trailing L to make it clear it is a
+                            //  long when parsing the signature file even if the annotation
+                            //  definition is not available or only add it when strictly necessary.
+                            common = "-278L"
+                            source {
+                                attributeDefaultValue = "-278"
+                                annotationToSource = "0xfffffeea"
+                            }
                         },
+                    expectedKotlinLegacySource = expectations { annotationToSource = "-278L" },
+                    expectedValue =
+                        expectations {
+                            // Expect a long value created from an int.
+                            common = primitiveValueForKind(Primitive.LONG, -278)
+                            jar { common = literalValue(-278L) }
+                        },
+                ),
+                // Check a simple long with an upper case suffix.
+                ValueExample(
+                    name = "long with upper L",
+                    javaType = "long",
+                    javaExpression = "10000000000L",
+                    kotlinType = "Long",
+                    expectedLegacySource = expectations { common = "10000000000L" },
                     expectedKotlinLegacySource =
-                        partialExpectations { attributeDefaultValue = "10000000000" },
+                        expectations { attributeDefaultValue = "10000000000" },
+                    expectedValue = expectations { common = literalValue(10000000000L) },
                 ),
                 // Check a simple long with a lower case suffix.
                 ValueExample(
@@ -821,50 +1641,105 @@ class ValueExample(
                     kotlinType = "Long",
                     // Kotlin does not support using a lower case l as a suffix for long, presumably
                     // because it looks too similar to a number 1.
-                    validForInputFormats = EnumSet.complementOf(EnumSet.of(InputFormat.KOTLIN)),
+                    validForInputFormats = notValidForKotlin,
+                    expectedLegacySource = expectations { common = "10000000000L" },
+                    expectedValue = expectations { common = literalValue(10000000000L) },
+                ),
+                ValueExample(
+                    name = "long - min with suffix",
+                    javaType = "long",
+                    javaExpression = "-9223372036854775808L",
+                    expectedLegacySource = expectations { common = "-9223372036854775808L" },
+                    // Kotlin does not support specifying -9223372036854775808L as a literal.
+                    // See https://youtrack.jetbrains.com/issue/KT-4749.
+                    validForInputFormats = notValidForKotlin,
+                    expectedValue = expectations { common = literalValue(Long.MIN_VALUE) },
+                ),
+                // Check a simple short.
+                ValueExample(
+                    name = "short",
+                    javaType = "short",
+                    javaExpression = "32000",
+                    kotlinType = "Short",
+                    expectedLegacySource = expectations { common = "32000" },
+                    expectedValue =
+                        expectations { common = primitiveValueForKind(Primitive.SHORT, 32000) },
+                ),
+                // Check a negative short.
+                ValueExample(
+                    name = "short - negative int",
+                    javaType = "short",
+                    javaExpression = "-237",
+                    kotlinType = "Short",
                     expectedLegacySource =
                         expectations {
-                            common = "10000000000L"
-                            // TODO(b/354633349): Consistency is good.
-                            fieldValue = "10000000000"
-
-                            source {
-                                // TODO(b/354633349): Consistency is good.
-                                attributeValue = "10000000000l"
-                            }
+                            common = "-237"
+                            annotationToSource = "0xffffff13"
                         },
+                    expectedKotlinLegacySource = expectations { common = "-237" },
+                    expectedValue =
+                        expectations { common = primitiveValueForKind(Primitive.SHORT, -237) }
                 ),
-                // Check a simple short with a lower case suffix.
+                // Check a short cast expression.
                 ValueExample(
-                    name = "short",
+                    name = "short - cast",
                     javaType = "short",
-                    javaExpression = "32000",
+                    javaExpression = "(short) 32000",
                     kotlinType = "Short",
+                    kotlinExpression = "32000.toShort()",
                     expectedLegacySource = expectations { common = "32000" },
+                    expectedValue =
+                        expectations {
+                            common = literalValue(32000.toShort(), nonLiteralInSource = true)
+                            jar {
+                                // There is no short constant in a class file, only ints.
+                                common = primitiveValueForKind(Primitive.SHORT, 32000)
+                            }
+                        },
                 ),
                 // Check a simple string.
                 ValueExample(
                     name = "String",
                     javaType = "String",
                     javaExpression = "\"string\"",
-                    expectedLegacySource =
-                        expectations {
-                            common = "\"string\""
-                            // TODO(b/354633349): Should have surrounding quotes.
-                            fieldValue = "string"
-                        },
+                    expectedLegacySource = expectations { common = "\"string\"" },
+                    expectedValue = expectations { common = literalValue("string") },
                 ),
                 ValueExample(
                     name = "String escaped",
                     javaType = "String",
                     javaExpression = "\"str\\ning\"",
-                    expectedLegacySource =
+                    expectedLegacySource = expectations { common = "\"str\\ning\"" },
+                    expectedValue = expectations { common = literalValue("str\ning") },
+                ),
+                // Check an empty array.
+                ValueExample(
+                    name = "array - empty",
+                    javaType = "int[]",
+                    javaExpression = "{}",
+                    kotlinType = "IntArray",
+                    kotlinExpression = "[]",
+                    // Literal arrays are only allowed in annotations not fields.
+                    suitableFor = allLegacyValueUseSitesExceptFields,
+                    expectedLegacySource = expectations { common = "{}" },
+                    expectedKotlinLegacySource =
                         expectations {
-                            common = "\"str\\ning\""
-                            // TODO(b/354633349): Should have surrounding quotes and newline should
-                            //   be escaped.
-                            fieldValue = "str\ning"
+                            // TODO(b/354633349): Fix this, it should not be an empty string.
+                            attributeDefaultValue = ""
                         },
+                    expectedValue = expectations { common = arrayValueFromAny() },
+                ),
+                ValueExample(
+                    name = "array - single",
+                    javaType = "int[]",
+                    javaExpression = "{1}",
+                    kotlinType = "IntArray",
+                    kotlinExpression = "[1]",
+                    // Literal arrays are only allowed in annotations not fields.
+                    suitableFor = allLegacyValueUseSitesExceptFields,
+                    expectedLegacySource = expectations { common = "{1}" },
+                    expectedKotlinLegacySource = expectations { attributeDefaultValue = "{1}" },
+                    expectedValue = expectations { common = arrayValueFromAny(1) },
                 ),
                 // Check a simple string array.
                 ValueExample(
@@ -874,10 +1749,10 @@ class ValueExample(
                     kotlinType = "Array<String>",
                     kotlinExpression = "[\"string1\", \"string2\"]",
                     // Literal arrays are only allowed in annotations not fields.
-                    suitableFor = allValueUseSitesExceptFields,
+                    suitableFor = allLegacyValueUseSitesExceptFields,
                     expectedLegacySource = expectations { common = "{\"string1\", \"string2\"}" },
-                    expectedKotlinLegacySource =
-                        partialExpectations { attributeValue = "[\"string1\", \"string2\"]" },
+                    expectedValue =
+                        expectations { common = arrayValueFromAny("string1", "string2") },
                 ),
                 // Check passing a single value to an array type.
                 ValueExample(
@@ -887,45 +1762,234 @@ class ValueExample(
                     kotlinType = "Array<String>",
                     // Fields that are of type String[] cannot be given a solitary string like an
                     // annotation attribute can.
-                    suitableFor = allValueUseSitesExceptFields,
+                    suitableFor = allLegacyValueUseSitesExceptFields,
                     expectedLegacySource =
                         expectations {
                             common = "\"string\""
 
                             jar { common = "{\"string\"}" }
                         },
+                    expectedValue = expectations { common = arrayValueFromAny("string") },
                 ),
                 ValueExample(
                     name = "String using constant",
                     javaType = "String",
                     javaExpression = "Constants.STRING_CONSTANT",
+                    // Must fully qualify most classes in signature files.
+                    signatureExpression = "test.pkg.Constants.STRING_CONSTANT",
                     expectedLegacySource =
                         expectations {
                             common = "\"constant\""
 
-                            jar {
-                                // TODO(b/354633349): Should have surrounding quotes.
-                                fieldValue = "constant"
-                            }
-
                             source {
                                 common = "test.pkg.Constants.STRING_CONSTANT"
-                                // TODO(b/354633349): Fully qualified is better.
-                                attributeValue = "Constants.STRING_CONSTANT"
-                                // TODO(b/354633349): Should have surrounding quotes, if not
-                                //   a field reference.
-                                fieldValue = "constant"
                                 // TODO(b/354633349): Should probably be a field reference, at least
                                 //   in some cases.
                                 fieldWriteWithSemicolon = "\"constant\""
                             }
                         },
-                )
+                    expectedValue =
+                        expectations {
+                            common =
+                                fieldReferenceValue(
+                                    "test.pkg.Constants",
+                                    "STRING_CONSTANT",
+                                    literalValue("constant")
+                                )
+                            jar {
+                                // The compiler will always inline a constant field value.
+                                common = literalValue("constant")
+                            }
+                        },
+                ),
+                ValueExample(
+                    name = "method call",
+                    javaType = "String",
+                    javaExpression = "System.getProperty(\"PROPERTY\")",
+                    // Only suitable for use in fields as annotations cannot use non-constant
+                    // methods.
+                    suitableFor = allFieldLegacyValueUseSites,
+                    // Signature never has a method call for a value.
+                    validForInputFormats = notValidForSignature,
+                    expectedLegacySource = expectations { common = null },
+                    expectedValue = expectations { common = null },
+                ),
+                // Null value
+                ValueExample(
+                    name = "null",
+                    javaType = "String",
+                    javaExpression = "null",
+                    // Only suitable for use in fields as annotations cannot have `null` values.
+                    suitableFor = allFieldLegacyValueUseSites,
+                    // Signature never has a null field value.
+                    validForInputFormats = notValidForSignature,
+                    expectedLegacySource = expectations { common = null },
+                    expectedValue = expectations { common = null },
+                ),
+                // Check a constant value used with a non-constant type that should result in a null
+                // value.
+                ValueExample(
+                    name = "null - constant value with non-constant type",
+                    javaType = "java.lang.CharSequence",
+                    javaExpression = "\"string\"",
+                    // Only suitable for use in fields. Annotations cannot use a CharSequence type.
+                    suitableFor = allFieldLegacyValueUseSites,
+                    // Signature never has a null field value.
+                    validForInputFormats = notValidForSignature,
+                    expectedLegacySource = expectations { common = null },
+                    expectedValue = expectations { common = null },
+                ),
+                // Check an expression that results in a primitive value via an intermediate
+                // non-constant expression results in a null value.
+                ValueExample(
+                    name = "null - intermediate non-constant expression",
+                    javaType = "int",
+                    javaExpression = "(new int[]{1})[0]",
+                    kotlinType = "Int",
+                    kotlinExpression = "arrayOf(1)[0]",
+                    // Only suitable for use in fields. Annotations cannot use a non-constant
+                    // expression.
+                    suitableFor = allFieldLegacyValueUseSites,
+                    // Signature never has a null field value.
+                    validForInputFormats = notValidForSignature,
+                    expectedLegacySource = expectations { common = null },
+                    expectedValue = expectations { common = null },
+                ),
+                // Check an expression that creates a fixed size array.
+                ValueExample(
+                    name = "null - fixed array",
+                    javaType = "int[]",
+                    javaExpression = "new int[0]",
+                    kotlinType = "IntArray",
+                    kotlinExpression = "emptyArray()",
+                    // Only suitable for use in fields. Annotations cannot use `new ...`
+                    // expressions.
+                    suitableFor = allFieldLegacyValueUseSites,
+                    // Signature never has a null field value.
+                    validForInputFormats = notValidForSignature,
+                    expectedLegacySource = expectations { common = null },
+                    expectedValue = expectations { common = null },
+                ),
+                ValueExample(
+                    name = "unsigned byte - basic",
+                    kotlinType = "UByte",
+                    kotlinExpression = "95U",
+                    // Only suitable for use in fields. Annotations cannot use Kotlin unsigned
+                    // values.
+                    suitableFor = allFieldLegacyValueUseSites,
+                    validForInputFormats = onlyValidForKotlin,
+                    expectedLegacySource =
+                        expectations {
+                            common = "95U"
+
+                            fieldWriteWithSemicolon = "95"
+                        },
+                    expectedValue =
+                        expectations {
+                            // Modelled as a signed byte value.
+                            common = primitiveValueForKind(Primitive.BYTE, 95)
+                        },
+                ),
+                ValueExample(
+                    name = "unsigned int - basic",
+                    kotlinType = "UInt",
+                    kotlinExpression = "53U",
+                    // Only suitable for use in fields. Annotations cannot use Kotlin unsigned
+                    // values.
+                    suitableFor = allFieldLegacyValueUseSites,
+                    validForInputFormats = onlyValidForKotlin,
+                    expectedLegacySource =
+                        expectations {
+                            common = "53"
+
+                            fieldWriteWithSemicolon = "53"
+                        },
+                    expectedValue =
+                        expectations {
+                            // Modelled as a signed int value.
+                            common = literalValue(53)
+                        },
+                ),
+                ValueExample(
+                    name = "unsigned int - expression",
+                    kotlinType = "UInt",
+                    kotlinExpression = "53U + 12U",
+                    // Only suitable for use in fields. Annotations cannot use Kotlin unsigned
+                    // values.
+                    suitableFor = allFieldLegacyValueUseSites,
+                    validForInputFormats = onlyValidForKotlin,
+                    expectedLegacySource =
+                        expectations {
+                            common = "65"
+
+                            fieldWriteWithSemicolon = "65"
+                        },
+                    expectedValue =
+                        expectations {
+                            // Modelled as a signed int value.
+                            common = literalValue(65, nonLiteralInSource = true)
+                        },
+                ),
+                ValueExample(
+                    name = "unsigned long - basic",
+                    kotlinType = "ULong",
+                    kotlinExpression = "37UL",
+                    // Only suitable for use in fields. Annotations cannot use Kotlin unsigned
+                    // values.
+                    suitableFor = allFieldLegacyValueUseSites,
+                    validForInputFormats = onlyValidForKotlin,
+                    expectedLegacySource =
+                        expectations {
+                            common = "37"
+
+                            fieldWriteWithSemicolon = "37L"
+                        },
+                    expectedValue =
+                        expectations {
+                            // Modelled as a signed long value.
+                            common = literalValue(37L)
+                        },
+                ),
+                ValueExample(
+                    name = "unsigned short - basic",
+                    kotlinType = "UShort",
+                    kotlinExpression = "103U",
+                    // Only suitable for use in fields. Annotations cannot use Kotlin unsigned
+                    // values.
+                    suitableFor = allFieldLegacyValueUseSites,
+                    validForInputFormats = onlyValidForKotlin,
+                    expectedLegacySource =
+                        expectations {
+                            common = "103"
+
+                            fieldWriteWithSemicolon = "103"
+                        },
+                    expectedValue =
+                        expectations {
+                            // Modelled as a signed short value.
+                            common = primitiveValueForKind(Primitive.SHORT, 103)
+                        },
+                ),
+                ValueExample(
+                    name = "kotlin replace with",
+                    kotlinType = "kotlin.ReplaceWith",
+                    kotlinExpression = "ReplaceWith(\"something\")",
+                    suitableFor = allLegacyValueUseSites,
+                    validForInputFormats = onlyValidForKotlin,
+                    expectedLegacySource = expectations { common = "kotlin.ReplaceWith()" },
+                    expectedValue =
+                        expectations {
+                            common =
+                                annotationValue(
+                                    "kotlin.ReplaceWith",
+                                )
+                        }
+                ),
             )
 
         /**
          * The list of [ValueExample]s that will be tested across [ProducerKind] and
-         * [ValueUseSite]s.
+         * [LegacyValueUseSite]s.
          */
         internal val valueExamples =
             allValueExamples
@@ -935,14 +1999,27 @@ class ValueExample(
 }
 
 /**
- * A partial [Expectation] that returns [NO_INITIAL_FIELD_VALUE] for fields.
- *
- * This is used when a [ValueExample] is not a constant and so a field that uses it will not have a
- * value. It is checked first and then [falls back to](fallBackTo)
- * [ValueExample.expectedLegacySource],
+ * An [Expectation] that will apply [transform] to expected values returned from [delegate] for
+ * [LegacyValueUseSite.FIELD_VALUE] and [LegacyValueUseSite.FIELD_WRITE_WITH_SEMICOLON].
  */
-private val constantFieldLegacySourceExpectation =
-    partialExpectations<String> {
-        fieldValue = NO_INITIAL_FIELD_VALUE
-        fieldWriteWithSemicolon = NO_INITIAL_FIELD_VALUE
-    }
+class TransformFieldExpectation<T : Any>(
+    private val delegate: Expectation<T?>,
+    private val transform: (T) -> T? = { it }
+) : Expectation<T?> {
+    override fun expectationFor(
+        producerKind: ProducerKind,
+        legacyValueUseSite: LegacyValueUseSite
+    ) =
+        delegate.expectationFor(producerKind, legacyValueUseSite)?.let { expected ->
+            if (legacyValueUseSite.valueUseSite == ValueUseSite.FIELD)
+                expected.let { transform(it) }
+            else expected
+        }
+
+    override fun hasExpectationFor(
+        producerKind: ProducerKind,
+        legacyValueUseSite: LegacyValueUseSite
+    ) =
+        if (legacyValueUseSite.valueUseSite == ValueUseSite.FIELD) true
+        else delegate.hasExpectationFor(producerKind, legacyValueUseSite)
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/ValueUseSite.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/ValueUseSite.kt
deleted file mode 100644
index af27d3682..000000000
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/value/ValueUseSite.kt
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2025 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.testsuite.value
-
-import com.android.tools.metalava.model.AnnotationItem
-import com.android.tools.metalava.model.FieldItem
-import java.util.EnumSet
-
-/** The possible places where values can be provided. */
-enum class ValueUseSite {
-    /** The default value specified on an annotation class's method. */
-    ATTRIBUTE_DEFAULT_VALUE,
-
-    /** An annotation attribute value specified in an annotation instance. */
-    ATTRIBUTE_VALUE,
-
-    /**
-     * An annotation attribute value produced by [AnnotationItem.toSource] called on an annotation
-     * instance.
-     */
-    ANNOTATION_TO_SOURCE,
-
-    /** The value of a field. */
-    FIELD_VALUE,
-
-    /** The value of a field written out by [FieldItem.writeValueWithSemicolon]. */
-    FIELD_WRITE_WITH_SEMICOLON,
-}
-
-/**
- * The set of all [ValueUseSite]s.
- *
- * Default for [ValueExample.suitableFor].
- */
-internal val allValueUseSites = EnumSet.allOf(ValueUseSite::class.java)
-
-/**
- * The set of all [ValueUseSite]s except [ValueUseSite.FIELD_VALUE] and
- * [ValueUseSite.FIELD_WRITE_WITH_SEMICOLON].
- *
- * Stored in [ValueExample.suitableFor] for any [ValueExample] that does not work on fields.
- */
-internal val allValueUseSitesExceptFields =
-    allValueUseSites - ValueUseSite.FIELD_VALUE - ValueUseSite.FIELD_WRITE_WITH_SEMICOLON
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ApiFile.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ApiFile.kt
index fef714099..3503a4934 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ApiFile.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ApiFile.kt
@@ -28,10 +28,8 @@ import com.android.tools.metalava.model.ClassResolver
 import com.android.tools.metalava.model.ClassTypeItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.ConstructorItem
-import com.android.tools.metalava.model.DefaultAnnotationItem
 import com.android.tools.metalava.model.DefaultTypeParameterList
 import com.android.tools.metalava.model.ExceptionTypeItem
-import com.android.tools.metalava.model.FixedFieldValue
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.ItemDocumentation
 import com.android.tools.metalava.model.JAVA_LANG_DEPRECATED
@@ -41,8 +39,9 @@ import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.MutableModifierList
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.PrimitiveTypeItem
-import com.android.tools.metalava.model.PrimitiveTypeItem.Primitive
 import com.android.tools.metalava.model.SelectableItem
+import com.android.tools.metalava.model.TargetLanguage
+import com.android.tools.metalava.model.TargetLanguageSet
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeNullability
 import com.android.tools.metalava.model.TypeParameterItem
@@ -61,8 +60,15 @@ import com.android.tools.metalava.model.item.DefaultTypeParameterItem
 import com.android.tools.metalava.model.item.MutablePackageDoc
 import com.android.tools.metalava.model.item.PackageDocs
 import com.android.tools.metalava.model.item.ParameterDefaultValue
-import com.android.tools.metalava.model.javaUnescapeString
+import com.android.tools.metalava.model.parser.FileLocationTracker
+import com.android.tools.metalava.model.parser.TokenPurpose
+import com.android.tools.metalava.model.parser.Tokenizer
 import com.android.tools.metalava.model.type.MethodFingerprint
+import com.android.tools.metalava.model.type.TypeItemParser
+import com.android.tools.metalava.model.type.TypeItemParserErrorReporter
+import com.android.tools.metalava.model.value.Value
+import com.android.tools.metalava.model.value.ValueParser
+import com.android.tools.metalava.model.value.ValueUseSite
 import com.android.tools.metalava.reporter.FileLocation
 import com.android.tools.metalava.reporter.Issues
 import java.io.File
@@ -169,10 +175,10 @@ sealed class SignatureFile {
                 file.readText(UTF_8)
             } catch (ex: IOException) {
                 throw ApiParseException(
-                    "Error reading API file",
-                    location = FileLocation.createLocation(file.toPath()),
-                    cause = ex
-                )
+                        "Error reading API file",
+                        location = FileLocation.createLocation(file.toPath()),
+                    )
+                    .apply { initCause(ex) }
             }
     }
 
@@ -209,16 +215,11 @@ private constructor(
      */
     private lateinit var fileLocationTracker: FileLocationTracker
 
-    /**
-     * Report recoverable errors encountered while parsing.
-     *
-     * Retrieves the location of the error from [fileLocationTracker].
-     */
-    private val errorReporter =
-        object : SignatureErrorReporter {
+    /** Report recoverable errors encountered while parsing types. */
+    private val typeItemParserErrorReporter =
+        object : TypeItemParserErrorReporter {
             override fun report(issue: Issues.Issue, message: String) {
-                val location = fileLocationTracker.fileLocation()
-                codebase.reporter.report(issue, null, message, location)
+                reportIssue(issue, message)
             }
         }
 
@@ -230,7 +231,7 @@ private constructor(
      */
     private val typeParser by
         lazy(LazyThreadSafetyMode.NONE) {
-            TextTypeParser(codebase, kotlinStyleNulls!!, errorReporter)
+            TextTypeParser(codebase, kotlinStyleNulls!!, typeItemParserErrorReporter)
         }
 
     /**
@@ -244,6 +245,13 @@ private constructor(
     /** Creates [Item] instances for [codebase]. */
     private val itemFactory = assembler.itemFactory
 
+    /** The [ValueParser] to use for creating [Value]s from a signature file. */
+    private val valueParser =
+        ValueParser(
+            codebase,
+            TypeItemParser.forValueParser(codebase, typeItemParserErrorReporter),
+        )
+
     /**
      * Whether types should be interpreted to be in Kotlin format (e.g. ? suffix means nullable, !
      * suffix means unknown, and absence of a suffix means not nullable.
@@ -268,6 +276,13 @@ private constructor(
      */
     private var appending: Boolean = false
 
+    /**
+     * A map from [DefaultClassItem] to list of [ClassCharacteristics] for re-definition of the
+     * original class that needs to be checked for consistency against the [DefaultClassItem] and
+     * then merge any extensions into it.
+     */
+    private var deferredMerges = mutableMapOf<DefaultClassItem, MutableList<ClassCharacteristics>>()
+
     /** Map from [ClassItem] to [TextTypeItemFactory]. */
     private val classToTypeItemFactory = IdentityHashMap<ClassItem, TextTypeItemFactory>()
 
@@ -330,6 +345,8 @@ private constructor(
                 first = false
             }
 
+            parser.performAnyDeferredMerges()
+
             apiStatsConsumer(parser.stats)
 
             return assembler.codebase
@@ -397,6 +414,18 @@ private constructor(
         }
     }
 
+    /**
+     * Report a recoverable issue encountered while parsing.
+     *
+     * Retrieves the location of the error from [fileLocationTracker].
+     *
+     * Note: Non-recoverable issues result in an exception being thrown.
+     */
+    private fun reportIssue(issue: Issues.Issue, message: String) {
+        val location = fileLocationTracker.fileLocation()
+        codebase.reporter.report(issue, null, message, location)
+    }
+
     /**
      * Mark this [SelectableItem] as being part of the main API surface, i.e. the one that is being
      * created.
@@ -471,7 +500,7 @@ private constructor(
         // Remember the API variant of the file being parsed.
         this.apiVariant = apiVariant
 
-        val tokenizer = Tokenizer(path, apiText.toCharArray())
+        val tokenizer = Tokenizer(path, apiText.toCharArray(), ::ApiParseException)
 
         // Get the preceding tracker, if any.
         val precedingTracker =
@@ -487,7 +516,8 @@ private constructor(
         // Disallow a mixture of kotlinStyleNulls settings.
         if (kotlinStyleNulls != null && kotlinStyleNulls != format.kotlinStyleNulls) {
             val precedingFile = precedingTracker!!.fileLocation().path
-            errorReporter.report(
+            reportIssue(
+                Issues.SIGNATURE_FILE_ERROR,
                 "Preceding file $precedingFile has different setting of kotlin-style-nulls which may cause issues"
             )
         }
@@ -613,11 +643,7 @@ private constructor(
         var classKind = ClassKind.CLASS
         var superClassType: ClassTypeItem? = null
 
-        // Metalava: including annotations in file now
-        val annotations = getAnnotations(tokenizer, token)
-        token = tokenizer.current
-        val modifiers = parseModifiers(tokenizer, token, annotations)
-
+        val (modifiers, targetLanguages) = parseModifiersAndTargetLanguages(tokenizer, token)
         // Remember this position as this seems like a good place to use to report issues with the
         // class item.
         val classPosition = tokenizer.fileLocation()
@@ -724,21 +750,34 @@ private constructor(
             modifiers.setStatic(false)
         }
 
-        // Get the characteristics of the class being added as they may be needed to compare against
-        // the characteristics of the same class from a previously processed signature file.
-        val newClassCharacteristics =
-            ClassCharacteristics(
-                fileLocation = classPosition,
-                qualifiedName = qualifiedClassName,
-                fullName = fullName,
-                classKind = classKind,
-                modifiers = modifiers.toImmutable(),
-                superClassType = superClassType,
-            )
+        // Check for the existing class from a previously parsed file. If it was found then use that
+        // and return. If it could not be found then drop through to create it.
+        codebase.findClassInCodebase(qualifiedClassName)?.let { existingClass ->
+
+            // Parse the class body adding each member created to the existing class.
+            parseClassBody(tokenizer, existingClass, typeItemFactoryForClass(existingClass))
+
+            // Although the class was first defined in a separate file it is being modified in the
+            // current file so that may include it in the main API surface.
+            existingClass.markExistingClassForMainApiSurface()
+
+            // Get the characteristics of the class being added as they may be needed to compare
+            // against the characteristics of the same class from a previously processed signature
+            // file.
+            val newClassCharacteristics =
+                ClassCharacteristics(
+                    fileLocation = classPosition,
+                    qualifiedName = qualifiedClassName,
+                    fullName = fullName,
+                    classKind = classKind,
+                    modifiers = modifiers.toImmutable(),
+                    superClassType = superClassType,
+                )
+
+            // Perform any merge checks after loading all the files. That is needed because merging
+            // may resolve classes and doing that during parsing can lead to issues.
+            deferMergingIntoExistingClass(existingClass, newClassCharacteristics)
 
-        // Check to see if there is an existing class, if so merge this class definition into that
-        // one and return. Otherwise, drop through and create a whole new class.
-        if (tryMergingIntoExistingClass(tokenizer, newClassCharacteristics)) {
             return
         }
 
@@ -767,6 +806,7 @@ private constructor(
                 origin = ClassOrigin.COMMAND_LINE,
                 superClassType = superClassType,
                 interfaceTypes = interfaceTypes.toList(),
+                targetLanguages = targetLanguages,
             )
         cl.markForMainApiSurface()
 
@@ -780,24 +820,40 @@ private constructor(
         parseClassBody(tokenizer, cl, typeItemFactory)
     }
 
+    /**
+     * Defer merging [newClassCharacteristics] into [existingClass] until after all signature files
+     * have been resolved.
+     */
+    private fun deferMergingIntoExistingClass(
+        existingClass: DefaultClassItem,
+        newClassCharacteristics: ClassCharacteristics
+    ) {
+        val merges = deferredMerges.computeIfAbsent(existingClass) { mutableListOf() }
+        merges.add(newClassCharacteristics)
+    }
+
+    /** Perform any deferred merges added by [deferMergingIntoExistingClass]. */
+    private fun performAnyDeferredMerges() {
+        for ((existingClass, newClasses) in deferredMerges) {
+            for (newClassCharacteristics in newClasses) {
+                tryMergingIntoExistingClass(existingClass, newClassCharacteristics)
+            }
+        }
+    }
+
     /**
      * Try merging the new class into an existing class that was previously loaded from a separate
      * signature file.
      *
-     * Will throw an exception if there is an existing class but it is not compatible with the new
+     * Will throw an exception if there is an existing class, but it is not compatible with the new
      * class.
      *
      * @return `false` if there is no existing class, `true` if there is and the merge succeeded.
      */
     private fun tryMergingIntoExistingClass(
-        tokenizer: Tokenizer,
+        existingClass: DefaultClassItem,
         newClassCharacteristics: ClassCharacteristics,
-    ): Boolean {
-        // Check for the existing class from a previously parsed file. If it could not be found
-        // then return.
-        val existingClass =
-            codebase.findClassInCodebase(newClassCharacteristics.qualifiedName) ?: return false
-
+    ) {
         // Make sure the new class characteristics are compatible with the old class
         // characteristic.
         val existingCharacteristics = ClassCharacteristics.of(existingClass)
@@ -826,15 +882,6 @@ private constructor(
             // definition found later should be prioritized, overwrite the superclass type.
             existingClass.setSuperClassType(newSuperClassType)
         }
-
-        // Parse the class body adding each member created to the existing class.
-        parseClassBody(tokenizer, existingClass, typeItemFactoryForClass(existingClass))
-
-        // Although the class was first defined in a separate file it is being modified in the
-        // current file so that may include it in the main API surface.
-        existingClass.markExistingClassForMainApiSurface()
-
-        return true
     }
 
     /** Get the [TextTypeItemFactory] for a previously created [ClassItem]. */
@@ -1004,8 +1051,7 @@ private constructor(
                 }
 
                 Pair(existingTypeParameterList, typeItemFactoryForClass(existingClass))
-            }
-                ?: Pair(typeParameterList, typeItemFactory)
+            } ?: Pair(typeParameterList, typeItemFactory)
 
         return DeclaredClassTypeComponents(
             fullName = fullName,
@@ -1088,7 +1134,9 @@ private constructor(
         while (true) {
             val annotationSource = getAnnotationSource(tokenizer, token) ?: break
             token = tokenizer.current
-            DefaultAnnotationItem.create(codebase, annotationSource)?.let { annotationItem ->
+            // TODO(b/354633349): Look at just passing the tokenizer through to
+            //  parseAnnotationItem(Tokenizer) to save some time.
+            valueParser.parseAnnotationItem(annotationSource)?.let { annotationItem ->
                 add(annotationItem)
             }
         }
@@ -1120,10 +1168,7 @@ private constructor(
         var token = startingToken
         val method: ConstructorItem
 
-        // Metalava: including annotations in file now
-        val annotations = getAnnotations(tokenizer, token)
-        token = tokenizer.current
-        val modifiers = parseModifiers(tokenizer, token, annotations)
+        val (modifiers, targetLanguages) = parseModifiersAndTargetLanguages(tokenizer, token)
 
         // Get a TypeParameterList and accompanying TypeItemFactory
         val (typeParameterList, typeItemFactory) =
@@ -1163,6 +1208,7 @@ private constructor(
                 // the same as whether it was created by the compiler or in the source has no effect
                 // on the API surface.
                 implicitConstructor = false,
+                targetLanguages = targetLanguages,
             )
         method.markForMainApiSurface()
 
@@ -1180,10 +1226,7 @@ private constructor(
         var token = startingToken
         val method: MethodItem
 
-        // Metalava: including annotations in file now
-        val annotations = getAnnotations(tokenizer, token)
-        token = tokenizer.current
-        val modifiers = parseModifiers(tokenizer, token, annotations)
+        val (modifiers, targetLanguages) = parseModifiersAndTargetLanguages(tokenizer, token)
 
         // Get a TypeParameterList and accompanying TypeParameterScope
         val (typeParameterList, typeItemFactory) =
@@ -1222,7 +1265,7 @@ private constructor(
         val returnType =
             typeItemFactory.getMethodReturnType(
                 returnTypeString,
-                annotations,
+                modifiers.annotations(),
                 MethodFingerprint(name, parameters.size),
                 cl.isAnnotationType()
             )
@@ -1233,7 +1276,7 @@ private constructor(
         }
 
         var throwsList = emptyList<ExceptionTypeItem>()
-        var defaultAnnotationMethodValue = ""
+        var defaultAnnotationMethodValue: String? = null
 
         when (token) {
             "throws" -> {
@@ -1249,6 +1292,11 @@ private constructor(
             throw ApiParseException("expected ; found $token", tokenizer)
         }
 
+        val defaultValueProvider =
+            defaultAnnotationMethodValue?.let { valueString ->
+                valueParser.providerFor(returnType, valueString, ValueUseSite.ANNOTATION)
+            }
+
         method =
             itemFactory.createMethodItem(
                 fileLocation = tokenizer.fileLocation(),
@@ -1262,7 +1310,8 @@ private constructor(
                     createParameterItems(containingCallable, parameters, typeItemFactory)
                 },
                 throwsTypes = throwsList,
-                annotationDefault = defaultAnnotationMethodValue,
+                defaultValueProvider = defaultValueProvider,
+                targetLanguages = targetLanguages,
             )
 
         // Ignore enum synthetic methods. They are no longer included in signature files as they add
@@ -1290,9 +1339,7 @@ private constructor(
         isEnumConstant: Boolean,
     ) {
         var token = startingToken
-        val annotations = getAnnotations(tokenizer, token)
-        token = tokenizer.current
-        val modifiers = parseModifiers(tokenizer, token, annotations)
+        val (modifiers, targetLanguages) = parseModifiersAndTargetLanguages(tokenizer, token)
         token = tokenizer.current
         tokenizer.assertIdent(token)
 
@@ -1317,7 +1364,7 @@ private constructor(
         // Get the optional value.
         val valueString =
             if ("=" == token) {
-                token = tokenizer.requireToken(false)
+                token = tokenizer.requireToken(purpose = TokenPurpose.VALUE)
                 token.also { token = tokenizer.requireToken() }
             } else null
 
@@ -1328,13 +1375,25 @@ private constructor(
                 isEnumConstant = isEnumConstant,
                 isFinal = modifiers.isFinal(),
                 isInitialValueNonNull = { valueString != null && valueString != "null" },
-                itemAnnotations = annotations,
+                itemAnnotations = modifiers.annotations(),
             )
         synchronizeNullability(type, modifiers)
 
-        // Parse the value string.
-        val fieldValue =
-            valueString?.let { FixedFieldValue(parseValue(type, valueString, tokenizer)) }
+        // In signature files fields have to be static and final in order for them to have a
+        // constant value in addition to a value.
+        val constantValueProvider =
+            if (valueString != null) {
+                if (modifiers.isStatic() && modifiers.isFinal())
+                    valueParser.providerFor(type, valueString, ValueUseSite.FIELD)
+                else {
+                    // Report that the value is being ignored.
+                    reportIssue(
+                        Issues.SIGNATURE_FILE_ERROR,
+                        "Field $name in $cl has a value of `$valueString` but is not `static` and `final`; ignoring value"
+                    )
+                    null
+                }
+            } else null
 
         if (";" != token) {
             throw ApiParseException("expected ; found $token", tokenizer)
@@ -1348,20 +1407,58 @@ private constructor(
                 containingClass = cl,
                 type = type,
                 isEnumConstant = isEnumConstant,
-                fieldValue = fieldValue,
+                constantValueProvider = constantValueProvider,
+                targetLanguages = targetLanguages,
             )
         field.markForMainApiSurface()
         cl.addField(field)
     }
 
-    private fun parseModifiers(
+    /**
+     * Parses and creates an optional target language set and modifiers (see [parseModifiers]).
+     *
+     * When the method returns, the current token of [tokenizer] will be the first token after the
+     * modifiers.
+     */
+    private fun parseModifiersAndTargetLanguages(
         tokenizer: Tokenizer,
-        startingToken: String?,
-        annotations: List<AnnotationItem>
-    ): MutableModifierList {
+        startingToken: String,
+    ): Pair<MutableModifierList, Set<TargetLanguage>> {
         var token = startingToken
+        // Check if there's a token describing the target languages of the item. If there is, get
+        // the next token, if not, use the set of all languages.
+        val targetLanguages =
+            TargetLanguageSet.signatureFileRepresentationToTargetLanguageSet[token]?.also {
+                token = tokenizer.requireToken()
+            } ?: TargetLanguageSet.ALL
+
+        val modifiers = parseModifiers(tokenizer, token)
+        return modifiers to targetLanguages
+    }
+
+    /**
+     * Parses and creates modifiers, including annotations and keyword modifiers.
+     *
+     * If there is no visibility modifier, [VisibilityLevel.PACKAGE_PRIVATE] is used.
+     *
+     * When the method returns, the current token of [tokenizer] will be the first token after the
+     * modifiers.
+     */
+    private fun parseModifiers(tokenizer: Tokenizer, startingToken: String): MutableModifierList {
+        val annotations = getAnnotations(tokenizer, startingToken)
         val modifiers = createModifiers(VisibilityLevel.PACKAGE_PRIVATE, annotations)
+        parseKeywordModifiers(tokenizer, modifiers)
+        return modifiers
+    }
 
+    /**
+     * Updates the [modifiers] to reflect all modifier keywords parsed from [tokenizer].
+     *
+     * The method starts processing from the current token of [tokenizer]. When the method returns,
+     * the current token of [tokenizer] will be the first token after the modifiers.
+     */
+    private fun parseKeywordModifiers(tokenizer: Tokenizer, modifiers: MutableModifierList) {
+        var token = tokenizer.current
         processModifiers@ while (true) {
             token =
                 when (token) {
@@ -1460,7 +1557,6 @@ private constructor(
                     else -> break@processModifiers
                 }
         }
-        return modifiers
     }
 
     /** Creates a [MutableModifierList], setting the deprecation based on the [annotations]. */
@@ -1476,67 +1572,6 @@ private constructor(
         return modifiers
     }
 
-    private fun parseValue(
-        type: TypeItem,
-        value: String?,
-        fileLocationTracker: FileLocationTracker,
-    ): Any? {
-        return if (value != null) {
-            if (type is PrimitiveTypeItem) {
-                parsePrimitiveValue(type, value, fileLocationTracker)
-            } else if (type.isString()) {
-                if ("null" == value) {
-                    null
-                } else {
-                    javaUnescapeString(value.substring(1, value.length - 1))
-                }
-            } else {
-                value
-            }
-        } else null
-    }
-
-    private fun parsePrimitiveValue(
-        type: PrimitiveTypeItem,
-        value: String,
-        fileLocationTracker: FileLocationTracker,
-    ): Any {
-        return when (type.kind) {
-            Primitive.BOOLEAN ->
-                if ("true" == value) java.lang.Boolean.TRUE else java.lang.Boolean.FALSE
-            Primitive.BYTE,
-            Primitive.SHORT,
-            Primitive.INT -> Integer.valueOf(value)
-            Primitive.LONG -> java.lang.Long.valueOf(value.substring(0, value.length - 1))
-            Primitive.FLOAT ->
-                when (value) {
-                    "(1.0f/0.0f)",
-                    "(1.0f / 0.0f)" -> Float.POSITIVE_INFINITY
-                    "(-1.0f/0.0f)",
-                    "(-1.0f / 0.0f)" -> Float.NEGATIVE_INFINITY
-                    "(0.0f/0.0f)",
-                    "(0.0f / 0.0f)" -> Float.NaN
-                    else -> java.lang.Float.valueOf(value)
-                }
-            Primitive.DOUBLE ->
-                when (value) {
-                    "(1.0/0.0)",
-                    "(1.0 / 0.0)" -> Double.POSITIVE_INFINITY
-                    "(-1.0/0.0)",
-                    "(-1.0 / 0.0)" -> Double.NEGATIVE_INFINITY
-                    "(0.0/0.0)",
-                    "(0.0 / 0.0)" -> Double.NaN
-                    else -> java.lang.Double.valueOf(value)
-                }
-            Primitive.CHAR -> value.toInt().toChar()
-            Primitive.VOID ->
-                throw ApiParseException(
-                    "Found value $value assigned to void type",
-                    fileLocationTracker
-                )
-        }
-    }
-
     private fun parseProperty(
         tokenizer: Tokenizer,
         cl: DefaultClassItem,
@@ -1544,11 +1579,7 @@ private constructor(
         startingToken: String
     ) {
         var token = startingToken
-
-        // Metalava: including annotations in file now
-        val annotations = getAnnotations(tokenizer, token)
-        token = tokenizer.current
-        val modifiers = parseModifiers(tokenizer, token, annotations)
+        val modifiers = parseModifiers(tokenizer, token)
 
         // Get a TypeParameterList and accompanying TypeParameterScope
         val (typeParameterList, typeItemFactory) =
@@ -1690,7 +1721,7 @@ private constructor(
     ): TypeParameterListAndFactory<TextTypeItemFactory> {
         // Split the type parameter list string into a list of strings, one for each type
         // parameter.
-        val typeParameterStrings = TextTypeParser.typeParameterStrings(typeParameterListString)
+        val typeParameterStrings = TypeItemParser.typeParameterStrings(typeParameterListString)
 
         // Create the List<TypeParameterItem> and the corresponding TypeItemFactory that can be
         // used to resolve TypeParameterItems from the list. This performs the construction in two
@@ -1781,10 +1812,7 @@ private constructor(
                 token = tokenizer.requireToken()
             }
 
-            // Metalava: including annotations in file now
-            val annotations = getAnnotations(tokenizer, token)
-            token = tokenizer.current
-            val modifiers = parseModifiers(tokenizer, token, annotations)
+            val modifiers = parseModifiers(tokenizer, token)
             token = tokenizer.current
 
             val typeString: String
@@ -1808,7 +1836,7 @@ private constructor(
                 // Java style: parse the type, then the public name if it has one.
                 typeString = scanForTypeString(tokenizer, token)
                 token = tokenizer.current
-                if (Tokenizer.isIdent(token) && token != "=") {
+                if (Tokenizer.isIdent(token)) {
                     name = token
                     publicName = name
                     token = tokenizer.requireToken()
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ApiParseException.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ApiParseException.kt
index aa5962af5..ec059162c 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ApiParseException.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ApiParseException.kt
@@ -16,29 +16,18 @@
 package com.android.tools.metalava.model.text
 
 import com.android.tools.metalava.model.MetalavaApi
+import com.android.tools.metalava.model.parser.FileLocationTracker
+import com.android.tools.metalava.model.parser.ParseException
 import com.android.tools.metalava.reporter.FileLocation
 
 @MetalavaApi
 class ApiParseException(
     message: String,
-    private val location: FileLocation? = null,
-    cause: Exception? = null,
-) : Exception(message, cause) {
+    location: FileLocation? = null,
+) : ParseException(message, location) {
 
     internal constructor(
         message: String,
         fileLocationTracker: FileLocationTracker,
-        cause: Exception? = null,
-    ) : this(message, fileLocationTracker.fileLocation(), cause = cause)
-
-    override val message: String
-        get() {
-            return buildString {
-                location?.appendTo(this)
-                if (isNotEmpty()) {
-                    append(": ")
-                }
-                append(super.message)
-            }
-        }
+    ) : this(message, fileLocationTracker.fileLocation())
 }
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ClassCharacteristics.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ClassCharacteristics.kt
index c15ceb20c..dbbd42685 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ClassCharacteristics.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ClassCharacteristics.kt
@@ -51,7 +51,7 @@ internal data class ClassCharacteristics(
 
     /** The super class type . */
     val superClassType: ClassTypeItem?,
-// TODO(b/323168612): Add interface type strings.
+    // TODO(b/323168612): Add interface type strings.
 ) {
     /**
      * Checks if the [other] from different signature file can be merged with this
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/FileFormat.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/FileFormat.kt
index 70414f30e..edef73fe2 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/FileFormat.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/FileFormat.kt
@@ -523,10 +523,10 @@ data class FileFormat(
                 // the problem. This is done here instead of when throwing the exception as the
                 // original thrower does not have that context.
                 throw ApiParseException(
-                    "Signature format error - ${cause.message}",
-                    FileLocation.createLocation(path, lineNumberReader.lineNumber),
-                    cause,
-                )
+                        "Signature format error - ${cause.message}",
+                        FileLocation.createLocation(path, lineNumberReader.lineNumber),
+                    )
+                    .apply { initCause(cause) }
             }
         }
 
@@ -782,27 +782,27 @@ data class FileFormat(
             // Apply any language defaults first as they take priority over version defaults.
             language?.applyLanguageDefaults(this)
             return base.copy(
-                includeDefaultParameterValues = includeDefaultParameterValues
-                        ?: base.includeDefaultParameterValues,
-                includeTypeUseAnnotations = includeTypeUseAnnotations
-                        ?: base.includeTypeUseAnnotations,
+                includeDefaultParameterValues =
+                    includeDefaultParameterValues ?: base.includeDefaultParameterValues,
+                includeTypeUseAnnotations =
+                    includeTypeUseAnnotations ?: base.includeTypeUseAnnotations,
                 kotlinNameTypeOrder = kotlinNameTypeOrder ?: base.kotlinNameTypeOrder,
                 kotlinStyleNulls = kotlinStyleNulls ?: base.kotlinStyleNulls,
                 language = language ?: base.language,
                 migrating = migrating ?: base.migrating,
                 name = name ?: base.name,
-                specifiedAddAdditionalOverrides = addAdditionalOverrides
-                        ?: base.specifiedAddAdditionalOverrides,
-                specifiedNormalizeFinalModifier = normalizeFinalModifier
-                        ?: base.specifiedNormalizeFinalModifier,
-                specifiedOverloadedMethodOrder = overloadedMethodOrder
-                        ?: base.specifiedOverloadedMethodOrder,
-                specifiedSortWholeExtendsList = sortWholeExtendsList
-                        ?: base.specifiedSortWholeExtendsList,
-                specifiedStripJavaLangPrefix = stripJavaLangPrefix
-                        ?: base.specifiedStripJavaLangPrefix,
-                specifiedTypeArgumentSpacing = typeArgumentSpacing
-                        ?: base.specifiedTypeArgumentSpacing,
+                specifiedAddAdditionalOverrides =
+                    addAdditionalOverrides ?: base.specifiedAddAdditionalOverrides,
+                specifiedNormalizeFinalModifier =
+                    normalizeFinalModifier ?: base.specifiedNormalizeFinalModifier,
+                specifiedOverloadedMethodOrder =
+                    overloadedMethodOrder ?: base.specifiedOverloadedMethodOrder,
+                specifiedSortWholeExtendsList =
+                    sortWholeExtendsList ?: base.specifiedSortWholeExtendsList,
+                specifiedStripJavaLangPrefix =
+                    stripJavaLangPrefix ?: base.specifiedStripJavaLangPrefix,
+                specifiedTypeArgumentSpacing =
+                    typeArgumentSpacing ?: base.specifiedTypeArgumentSpacing,
                 surface = surface ?: base.surface,
             )
         }
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/SignatureWriter.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/SignatureWriter.kt
index 96547007f..8e8cff045 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/SignatureWriter.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/SignatureWriter.kt
@@ -28,7 +28,10 @@ import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.ModifierListWriter
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.PropertyItem
+import com.android.tools.metalava.model.SelectableItem
 import com.android.tools.metalava.model.StripJavaLangPrefix
+import com.android.tools.metalava.model.TargetLanguageSet
+import com.android.tools.metalava.model.TypeAliasItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.model.TypeStringConfiguration
@@ -108,11 +111,7 @@ class SignatureWriter(
             write(field.name())
         }
 
-        field.writeValueWithSemicolon(
-            writer,
-            allowDefaultValue = false,
-            requireInitialValue = false
-        )
+        field.writeValueWithSemicolon(writer)
         write("\n")
     }
 
@@ -202,9 +201,20 @@ class SignatureWriter(
     }
 
     private fun writeModifiers(item: Item) {
+        (item as? SelectableItem)?.let { writeTargetLanguage(it) }
         modifierListWriter.write(item, normalizeFinal = fileFormat.normalizeFinalModifier)
     }
 
+    private fun writeTargetLanguage(item: SelectableItem) {
+        // Properties and type aliases are always only for Kotlin use, so don't bother writing it.
+        if (item is PropertyItem || item is TypeAliasItem) return
+
+        val modifier =
+            TargetLanguageSet.targetLanguageSetToSignatureFileRepresentation[item.targetLanguages]
+                ?: return
+        write("$modifier ")
+    }
+
     private fun writeSuperClassStatement(cls: ClassItem) {
         if (cls.isEnum() || cls.isAnnotationType() || cls.isInterface()) {
             return
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebaseAssembler.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebaseAssembler.kt
index 1adb715f3..3019c19f4 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebaseAssembler.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebaseAssembler.kt
@@ -22,7 +22,7 @@ import com.android.tools.metalava.model.ClassResolver
 import com.android.tools.metalava.model.ClassTypeItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.ItemLanguage
+import com.android.tools.metalava.model.SourceLanguage
 import com.android.tools.metalava.model.bestGuessAtFullName
 import com.android.tools.metalava.model.item.DefaultClassItem
 import com.android.tools.metalava.model.item.DefaultCodebase
@@ -46,7 +46,7 @@ internal class TextCodebaseAssembler(
             codebase = codebase,
             // Signature files do not contain information about whether an item was originally
             // created from Java or Kotlin.
-            defaultItemLanguage = ItemLanguage.UNKNOWN,
+            defaultSourceLanguage = SourceLanguage.UNKNOWN,
             // Signature files have already been separated by API surface variants, so they can use
             // the same immutable ApiVariantSelectors.
             defaultVariantSelectorsFactory = ApiVariantSelectors.IMMUTABLE_FACTORY,
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextTypeParser.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextTypeParser.kt
index 9e500c5a4..a3537b872 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextTypeParser.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextTypeParser.kt
@@ -16,72 +16,47 @@
 
 package com.android.tools.metalava.model.text
 
+import com.android.tools.metalava.model.AnnotationContext
 import com.android.tools.metalava.model.AnnotationItem
-import com.android.tools.metalava.model.ArrayTypeItem
 import com.android.tools.metalava.model.BaseTypeVisitor
 import com.android.tools.metalava.model.ClassTypeItem
-import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.DefaultAnnotationItem
-import com.android.tools.metalava.model.JAVA_LANG_OBJECT
 import com.android.tools.metalava.model.JAVA_LANG_PREFIX
 import com.android.tools.metalava.model.PrimitiveTypeItem
-import com.android.tools.metalava.model.ReferenceTypeItem
-import com.android.tools.metalava.model.TypeArgumentTypeItem
 import com.android.tools.metalava.model.TypeItem
-import com.android.tools.metalava.model.TypeModifiers
 import com.android.tools.metalava.model.TypeNullability
 import com.android.tools.metalava.model.TypeParameterScope
 import com.android.tools.metalava.model.TypeVisitor
 import com.android.tools.metalava.model.VariableTypeItem
-import com.android.tools.metalava.model.WildcardTypeItem
+import com.android.tools.metalava.model.text.TextTypeParser.CacheEntry
 import com.android.tools.metalava.model.type.ContextNullability
-import com.android.tools.metalava.model.type.DefaultArrayTypeItem
-import com.android.tools.metalava.model.type.DefaultClassTypeItem
-import com.android.tools.metalava.model.type.DefaultPrimitiveTypeItem
-import com.android.tools.metalava.model.type.DefaultTypeModifiers
-import com.android.tools.metalava.model.type.DefaultVariableTypeItem
-import com.android.tools.metalava.model.type.DefaultWildcardTypeItem
+import com.android.tools.metalava.model.type.TypeItemParser
+import com.android.tools.metalava.model.type.TypeItemParserErrorReporter
+import com.android.tools.metalava.model.type.UnqualifiedClassHandler
 import com.android.tools.metalava.reporter.Issues
-import kotlin.collections.HashMap
-
-/** Parses and caches types for a [codebase]. */
-internal class TextTypeParser(
-    val codebase: Codebase,
-    val kotlinStyleNulls: Boolean = false,
-    delegateErrorReporter: SignatureErrorReporter = SignatureErrorReporter.THROWING,
-) {
-    /**
-     * Tracks whether types that were unqualified and so implicitly treated as being part of the
-     * 'java.lang` package are actually part of that package. If they are not then an error is
-     * reported and it is not prefixed with `java.lang`.
-     */
-    private val javaLangPackage: JavaLangPackage = JavaLangPackage.DEFAULT
 
-    /**
-     * A count of the errors reported through [errorReporter].
-     *
-     * This is used to prevent caching [TypeItem]s that reported errors to make sure that every such
-     * case is reported.
-     */
-    private var errorCount = 0
+/** Parses and caches types within a [annotationContext]. */
+internal class TextTypeParser
+private constructor(
+    annotationContext: AnnotationContext,
+    kotlinStyleNulls: Boolean,
+    private val countingErrorReporter: CountingErrorReporter,
+) :
+    TypeItemParser(
+        annotationContext,
+        UnqualifiedClassHandler.PREFIX_WITH_JAVA_LANG_OR_REPORT_ERROR,
+        kotlinStyleNulls,
+        countingErrorReporter,
+    ) {
 
     /**
-     * Report a recoverable error.
-     *
-     * This keeps a count of how many were reported so that [CacheEntry.getTypeItem] can use that to
-     * determine if any errors were found while parsing a type ([errorCount] increased) and so
-     * prevent it from being cached which would suppress any more errors with that type string.
+     * Secondary constructor that will wrap the [errorReporter] it is given in a
+     * [CountingErrorReporter] before calling the primary constructor.
      */
-    private val errorReporter: SignatureErrorReporter =
-        object : SignatureErrorReporter {
-            override fun report(
-                issue: Issues.Issue,
-                message: String,
-            ) {
-                delegateErrorReporter.report(issue, message)
-                errorCount += 1
-            }
-        }
+    constructor(
+        annotationContext: AnnotationContext,
+        kotlinStyleNulls: Boolean = false,
+        errorReporter: TypeItemParserErrorReporter = TypeItemParserErrorReporter.THROWING,
+    ) : this(annotationContext, kotlinStyleNulls, CountingErrorReporter(errorReporter))
 
     /**
      * The cache key, incorporates some information from [ContextNullability] and [kotlinStyleNulls]
@@ -106,42 +81,14 @@ internal class TextTypeParser(
     internal var cacheHit = 0
     internal var cacheSize = 0
 
-    /** A [TypeItem] representing `java.lang.Object`, suitable for general use. */
-    private val objectType: ReferenceTypeItem
-        get() = cachedParseType(JAVA_LANG_OBJECT, TypeParameterScope.empty) as ReferenceTypeItem
-
-    /**
-     * Creates or retrieves from the cache a [TypeItem] representing [type], in the context of the
-     * type parameters from [typeParameterScope], if applicable.
-     */
-    fun obtainTypeFromString(
-        type: String,
-        typeParameterScope: TypeParameterScope,
-        contextNullability: ContextNullability = ContextNullability.none,
-    ): TypeItem = cachedParseType(type, typeParameterScope, emptyList(), contextNullability)
-
-    /**
-     * Creates or retrieves from the cache a [TypeItem] representing [type], in the context of the
-     * type parameters from [typeParameterScope], if applicable.
-     *
-     * Used internally, as it has an extra [annotations] parameter that allows the annotations on
-     * array components to be correctly associated with the correct component. They are optional
-     * leading type-use annotations that have already been removed from the arrays type string.
-     */
-    private fun cachedParseType(
+    /** Override [parseType] to cache the result, if possible. */
+    override fun parseType(
         type: String,
         typeParameterScope: TypeParameterScope,
-        annotations: List<AnnotationItem> = emptyList(),
-        contextNullability: ContextNullability = ContextNullability.none,
+        annotations: List<AnnotationItem>,
+        forceClassToBeNonNull: Boolean,
     ): TypeItem {
         requests++
-
-        // Class types used as super types, i.e. in an extends or implements list are forced to be
-        // [TypeNullability.NONNULL], just as they would be if kotlinStyleNulls was true. Use the
-        // same cache key for both so that they reuse cached types where possible.
-        val forceClassToBeNonNull =
-            contextNullability.forcedNullability == TypeNullability.NONNULL || kotlinStyleNulls
-
         // Don't use the cache when there are type-use annotations not contained in the string.
         return if (annotations.isEmpty()) {
             val key = Key(forceClassToBeNonNull, type)
@@ -154,618 +101,17 @@ internal class TextTypeParser(
             result.getTypeItem(typeParameterScope)
         } else {
             cacheSkip++
-            parseType(type, typeParameterScope, annotations, forceClassToBeNonNull)
-        }
-    }
-
-    /** Converts the [type] to a [TypeItem] in the context of the [typeParameterScope]. */
-    private fun parseType(
-        type: String,
-        typeParameterScope: TypeParameterScope,
-        annotations: List<AnnotationItem>,
-        // Forces a [ClassTypeItem] to have [TypeNullability.NONNULL]
-        forceClassToBeNonNull: Boolean = false,
-    ): TypeItem {
-        val (unannotated, annotationsFromString) = trimLeadingAnnotations(type)
-        val allAnnotations = annotations + annotationsFromString
-        val (withoutNullability, nullability) =
-            splitNullabilitySuffix(
-                unannotated,
-                // If forceClassToBeNonNull is true then a plain class type without any nullability
-                // suffix must be treated as if it was not null, which is just how it would be
-                // treated when kotlinStyleNulls is true. So, pretend that kotlinStyleNulls is true.
-                kotlinStyleNulls || forceClassToBeNonNull,
-                errorReporter,
-            )
-        val trimmed = withoutNullability.trim()
-
-        // Figure out what kind of type this is.
-        //
-        // Start with variable as the type parameter scope allows us to determine whether something
-        // is a type parameter or not. Also, if a type parameter has the same name as a primitive
-        // type (possible in Kotlin, but not Java) then it will be treated as a type parameter not a
-        // primitive.
-        //
-        // Then try parsing as a primitive as while Kotlin classes can shadow primitive types
-        // they would need to be fully qualified.
-        return asVariable(trimmed, typeParameterScope, allAnnotations, nullability)
-            ?: asPrimitive(type, trimmed, allAnnotations, nullability)
-            // Try parsing as a wildcard before trying to parse as an array.
-            // `? extends java.lang.String[]` should be parsed as a wildcard with an array bound,
-            // not as an array of wildcards, for consistency with how this would be compiled.
-            ?: asWildcard(trimmed, typeParameterScope, allAnnotations, nullability)
-            // Try parsing as an array.
-            ?: asArray(trimmed, allAnnotations, nullability, typeParameterScope)
-            // If it isn't anything else, parse the type as a class.
-            ?: asClass(trimmed, typeParameterScope, allAnnotations, nullability)
-    }
-
-    /**
-     * Try parsing [type] as a primitive. This will return a non-null [PrimitiveTypeItem] if [type]
-     * exactly matches a primitive name.
-     *
-     * [type] should have annotations and nullability markers stripped, with [original] as the
-     * complete annotated type. Once annotations are properly handled (b/300081840), preserving
-     * [original] won't be necessary.
-     */
-    private fun asPrimitive(
-        original: String,
-        type: String,
-        annotations: List<AnnotationItem>,
-        nullability: TypeNullability?
-    ): PrimitiveTypeItem? {
-        val kind =
-            when (type) {
-                "byte" -> PrimitiveTypeItem.Primitive.BYTE
-                "char" -> PrimitiveTypeItem.Primitive.CHAR
-                "double" -> PrimitiveTypeItem.Primitive.DOUBLE
-                "float" -> PrimitiveTypeItem.Primitive.FLOAT
-                "int" -> PrimitiveTypeItem.Primitive.INT
-                "long" -> PrimitiveTypeItem.Primitive.LONG
-                "short" -> PrimitiveTypeItem.Primitive.SHORT
-                "boolean" -> PrimitiveTypeItem.Primitive.BOOLEAN
-                "void" -> PrimitiveTypeItem.Primitive.VOID
-                else -> return null
-            }
-        if (nullability != null && nullability != TypeNullability.NONNULL) {
-            errorReporter.report("Invalid nullability suffix on primitive: $original")
-        }
-        return DefaultPrimitiveTypeItem(modifiers(annotations, TypeNullability.NONNULL), kind)
-    }
-
-    /**
-     * Try parsing [type] as an array. This will return a non-null [ArrayTypeItem] if [type] ends
-     * with `[]` or `...`.
-     *
-     * The context [typeParameterScope] are used to parse the component type of the array.
-     */
-    private fun asArray(
-        type: String,
-        componentAnnotations: List<AnnotationItem>,
-        nullability: TypeNullability?,
-        typeParameterScope: TypeParameterScope
-    ): ArrayTypeItem? {
-        // Check if this is a regular array or varargs.
-        val (inner, varargs) =
-            if (type.endsWith("...")) {
-                Pair(type.dropLast(3), true)
-            } else if (type.endsWith("[]")) {
-                Pair(type.dropLast(2), false)
-            } else {
-                return null
-            }
-
-        // Create lists of the annotations and nullability markers for each dimension of the array.
-        // These are in separate lists because annotations appear in the type string in order from
-        // outermost array annotations to innermost array annotations (for `T @A [] @B [] @ C[]`,
-        // `@A` applies to the three-dimensional array, `@B` applies to the inner two-dimensional
-        // arrays, and `@C` applies to the inner one-dimensional arrays), while nullability markers
-        // appear in order from the innermost array nullability to the outermost array nullability
-        // (for `T[]![]?[]`, the three-dimensional array has no nullability marker, the inner
-        // two-dimensional arrays have `?` as the nullability marker, and the innermost arrays have
-        // `!` as a nullability marker.
-        val allAnnotations = mutableListOf<List<AnnotationItem>>()
-        // The nullability marker for the outer array is already known, include it in the list.
-        val allNullability = mutableListOf(nullability)
-
-        // Remove annotations from the end of the string, add them to the list.
-        var annotationsResult = trimTrailingAnnotations(inner)
-        var componentString = annotationsResult.first
-        allAnnotations.add(annotationsResult.second)
-
-        // Remove nullability marker from the component type, but don't add it to the list yet, as
-        // it might not be an array.
-        var nullabilityResult =
-            splitNullabilitySuffix(
-                componentString,
-                kotlinStyleNulls,
-                errorReporter,
-            )
-        componentString = nullabilityResult.first
-        var componentNullability = nullabilityResult.second
-
-        // Work through all layers of arrays to get to the inner component type.
-        // Inner arrays can't be varargs.
-        while (componentString.endsWith("[]")) {
-            // The component is an array, add the nullability to the list.
-            allNullability.add(componentNullability)
-
-            // Remove annotations from the end of the string, add them to the list.
-            annotationsResult = trimTrailingAnnotations(componentString.removeSuffix("[]"))
-            componentString = annotationsResult.first
-            allAnnotations.add(annotationsResult.second)
-
-            // Remove nullability marker from the new component type, but don't add it to the list
-            // yet, as the next component type might not be an array.
-            nullabilityResult =
-                splitNullabilitySuffix(
-                    componentString,
-                    kotlinStyleNulls,
-                    errorReporter,
-                )
-            componentString = nullabilityResult.first
-            componentNullability = nullabilityResult.second
-        }
-
-        // Re-add the component's nullability suffix when parsing the component type, and include
-        // the leading annotations already removed from the type string.
-        componentString += componentNullability?.suffix.orEmpty()
-        val deepComponentType =
-            cachedParseType(componentString, typeParameterScope, componentAnnotations)
-
-        // Join the annotations and nullability markers -- as described in the comment above, these
-        // appear in the string in reverse order of each other. The modifiers list will be ordered
-        // from innermost array modifiers to outermost array modifiers.
-        val allModifiers =
-            allAnnotations.zip(allNullability.reversed()).map { (annotations, nullability) ->
-                modifiers(annotations, nullability)
-            }
-        // The final modifiers are in the list apply to the outermost array.
-        val componentModifiers = allModifiers.dropLast(1)
-        val arrayModifiers = allModifiers.last()
-        // Create the component type of the outermost array by building up the inner component type.
-        val componentType =
-            componentModifiers.fold(deepComponentType) { component, modifiers ->
-                DefaultArrayTypeItem(modifiers, component, false)
-            }
-
-        // Create the outer array.
-        return DefaultArrayTypeItem(arrayModifiers, componentType, varargs)
-    }
-
-    /**
-     * Try parsing [type] as a wildcard. This will return a non-null [WildcardTypeItem] if [type]
-     * begins with `?`.
-     *
-     * The context [typeParameterScope] are needed to parse the bounds of the wildcard.
-     *
-     * [type] should have annotations and nullability markers stripped.
-     */
-    private fun asWildcard(
-        type: String,
-        typeParameterScope: TypeParameterScope,
-        annotations: List<AnnotationItem>,
-        nullability: TypeNullability?
-    ): WildcardTypeItem? {
-        // See if this is a wildcard
-        if (!type.startsWith("?")) return null
-
-        val modifiers = modifiers(annotations, TypeNullability.UNDEFINED)
-
-        // Unbounded wildcard type: there is an implicit Object extends bound
-        if (type == "?") return DefaultWildcardTypeItem(modifiers, objectType, null)
-
-        // If there's a bound, the nullability suffix applies there instead.
-        val bound = type.substring(2) + nullability?.suffix.orEmpty()
-        return if (bound.startsWith("extends")) {
-            val extendsBound = bound.substring(8)
-            DefaultWildcardTypeItem(
-                modifiers,
-                getWildcardBound(extendsBound, typeParameterScope),
-                null,
-            )
-        } else if (bound.startsWith("super")) {
-            val superBound = bound.substring(6)
-            DefaultWildcardTypeItem(
-                modifiers,
-                // All wildcards have an implicit Object extends bound
-                objectType,
-                getWildcardBound(superBound, typeParameterScope),
-            )
-        } else {
-            errorReporter.report("Type starts with \"?\" but doesn't appear to be wildcard: $type")
-
-            // Ignore the part after the "?" and treat it as an unbounded wildcard.
-            DefaultWildcardTypeItem(modifiers, objectType, null)
+            unCachedParseType(type, typeParameterScope, annotations, forceClassToBeNonNull)
         }
     }
 
-    private fun getWildcardBound(bound: String, typeParameterScope: TypeParameterScope) =
-        cachedParseType(bound, typeParameterScope) as ReferenceTypeItem
-
-    /**
-     * Try parsing [type] as a type variable. This will return a non-null [VariableTypeItem] if
-     * [type] matches a parameter from [typeParameterScope].
-     *
-     * [type] should have annotations and nullability markers stripped.
-     */
-    private fun asVariable(
+    /** Delegates to super, non-caching [parseType] method. */
+    private fun unCachedParseType(
         type: String,
         typeParameterScope: TypeParameterScope,
         annotations: List<AnnotationItem>,
-        nullability: TypeNullability?
-    ): VariableTypeItem? {
-        val param = typeParameterScope.findTypeParameter(type) ?: return null
-        return DefaultVariableTypeItem(modifiers(annotations, nullability), param)
-    }
-
-    /**
-     * Parse the [type] as a class. This function will always return a non-null [ClassTypeItem], so
-     * it should only be used when it is certain that [type] is not a different kind of type.
-     *
-     * The context [typeParameterScope] are used to parse the parameters of the class type.
-     *
-     * [type] should have annotations and nullability markers stripped.
-     */
-    private fun asClass(
-        type: String,
-        typeParameterScope: TypeParameterScope,
-        annotations: List<AnnotationItem>,
-        nullability: TypeNullability?
-    ): ClassTypeItem {
-        return createClassType(type, null, typeParameterScope, annotations, nullability)
-    }
-
-    /**
-     * Creates a class name for the class represented by [type] with optional [outerClassType].
-     *
-     * For instance, `test.pkg.Outer<P1>` would be the [outerClassType] when parsing `Inner<P2>`
-     * from the [original] type `test.pkg.Outer<P1>.Inner<P2>`.
-     */
-    private fun createClassType(
-        type: String,
-        outerClassType: ClassTypeItem?,
-        typeParameterScope: TypeParameterScope,
-        annotations: List<AnnotationItem>,
-        nullability: TypeNullability?
-    ): ClassTypeItem {
-        val (name, afterName, classAnnotations) = splitClassType(type)
-
-        val qualifiedName =
-            if (outerClassType != null) {
-                // This is a nested type, add the prefix of the outer name
-                "${outerClassType.qualifiedName}.$name"
-            } else if (!name.contains('.')) {
-                val javaLangName = "java.lang.$name"
-                if (javaLangPackage.containsQualified(javaLangName)) {
-                    // Reverse the effect of [TypeItem.stripJavaLangPrefix].
-                    javaLangName
-                } else {
-                    errorReporter.report(
-                        Issues.UNQUALIFIED_TYPE_ERROR,
-                        "Unqualified type '$name' is not in 'java.lang' and is not a type parameter in scope"
-                    )
-                    name
-                }
-            } else {
-                name
-            }
-
-        val (argumentStrings, remainder) = typeParameterStringsWithRemainder(afterName)
-        val arguments =
-            argumentStrings.map { cachedParseType(it, typeParameterScope) as TypeArgumentTypeItem }
-        // If this is an outer class type (there's a remainder), call it non-null and don't apply
-        // the leading annotations (they belong to the nested class type).
-        val classModifiers =
-            if (remainder != null) {
-                modifiers(classAnnotations, TypeNullability.NONNULL)
-            } else {
-                modifiers(classAnnotations + annotations, nullability)
-            }
-        val classType =
-            DefaultClassTypeItem(codebase, classModifiers, qualifiedName, arguments, outerClassType)
-
-        if (remainder != null) {
-            if (!remainder.startsWith('.')) {
-                errorReporter.report(
-                    "Could not parse type `$type`. Found unexpected string after type parameters: $remainder"
-                )
-                // Ignore the remainder.
-                return classType
-            }
-
-            // This is a nested class type, recur with the new outer class
-            return createClassType(
-                remainder.substring(1),
-                classType,
-                typeParameterScope,
-                annotations,
-                nullability
-            )
-        }
-
-        return classType
-    }
-
-    private fun modifiers(
-        annotations: List<AnnotationItem>,
-        nullability: TypeNullability?
-    ): TypeModifiers {
-        return DefaultTypeModifiers.create(
-            annotations,
-            nullability,
-        )
-    }
-
-    /**
-     * Removes all annotations at the beginning of the type, returning the trimmed type and list of
-     * annotations.
-     */
-    fun trimLeadingAnnotations(type: String): Pair<String, List<AnnotationItem>> {
-        val annotations = mutableListOf<AnnotationItem>()
-        var trimmed = type.trim()
-        while (trimmed.startsWith('@')) {
-            val end = findAnnotationEnd(trimmed, 1)
-            val annotationSource = trimmed.substring(0, end).trim()
-            DefaultAnnotationItem.create(codebase, annotationSource)?.let { annotationItem ->
-                annotations.add(annotationItem)
-            }
-            trimmed = trimmed.substring(end).trim()
-        }
-        return Pair(trimmed, annotations)
-    }
-
-    /**
-     * Removes all annotations at the end of the [type], returning the trimmed type and list of
-     * annotations. This is for use with arrays where annotations applying to the array type go
-     * after the component type, for instance `String @A []`. The input [type] should **not**
-     * include the array suffix (`[]` or `...`).
-     */
-    fun trimTrailingAnnotations(type: String): Pair<String, List<AnnotationItem>> {
-        // The simple way to implement this would be to work from the end of the string, finding
-        // `@` and removing annotations from the end. However, it is possible for an annotation
-        // string to contain an `@`, so this is not a safe way to remove the annotations.
-        // Instead, this finds all annotations starting from the beginning of the string, then
-        // works backwards to find which ones are the trailing annotations.
-        val allAnnotationIndices = mutableListOf<Pair<Int, Int>>()
-        var trimmed = type.trim()
-
-        // First find all annotations, saving the first and last index.
-        var currIndex = 0
-        while (currIndex < trimmed.length) {
-            if (trimmed[currIndex] == '@') {
-                val endIndex = findAnnotationEnd(trimmed, currIndex + 1)
-                allAnnotationIndices.add(Pair(currIndex, endIndex))
-                currIndex = endIndex + 1
-            } else {
-                currIndex++
-            }
-        }
-
-        val annotations = mutableListOf<AnnotationItem>()
-        // Go through all annotations from the back, seeing if they're at the end of the string.
-        for ((start, end) in allAnnotationIndices.reversed()) {
-            // This annotation isn't at the end, so we've hit the last trailing annotation
-            if (end < trimmed.length) {
-                break
-            }
-            val annotationSource = trimmed.substring(start)
-            DefaultAnnotationItem.create(codebase, annotationSource)?.let { annotationItem ->
-                annotations.add(annotationItem)
-            }
-            // Cut this annotation off, so now the next one can end at the last index.
-            trimmed = trimmed.substring(0, start).trim()
-        }
-        return Pair(trimmed, annotations.reversed())
-    }
-
-    /**
-     * Given [type] which represents a class, splits the string into the qualified name of the
-     * class, the remainder of the type string, and a list of type-use annotations. The remainder of
-     * the type string might be the type parameter list, nested class names, or a combination
-     *
-     * For `java.util.@A @B List<java.lang.@C String>`, returns the triple ("java.util.List",
-     * "<java.lang.@C String", listOf("@A", "@B")).
-     *
-     * For `test.pkg.Outer.Inner`, returns the triple ("test.pkg.Outer", ".Inner", emptyList()).
-     *
-     * For `test.pkg.@test.pkg.A Outer<P1>.@test.pkg.B Inner<P2>`, returns the triple
-     * ("test.pkg.Outer", "<P1>.@test.pkg.B Inner<P2>", listOf("@test.pkg.A")).
-     */
-    fun splitClassType(type: String): Triple<String, String?, List<AnnotationItem>> {
-        // The constructed qualified type name
-        var name = ""
-        // The part of the type which still needs to be parsed
-        var remaining = type.trim()
-        // The annotations of the type, may be set later
-        var annotations = emptyList<AnnotationItem>()
-
-        var dotIndex = remaining.indexOf('.')
-        var paramIndex = remaining.indexOf('<')
-        var annotationIndex = remaining.indexOf('@')
-
-        // Find which of '.', '<', or '@' comes first, if any
-        var minIndex = minIndex(dotIndex, paramIndex, annotationIndex)
-        while (minIndex != null) {
-            when (minIndex) {
-                // '.' is first, the next part is part of the qualified class name.
-                dotIndex -> {
-                    val nextNameChunk = remaining.substring(0, dotIndex)
-                    name += nextNameChunk
-                    remaining = remaining.substring(dotIndex)
-                    // Assumes that package names are all lower case and class names will have
-                    // an upper class character (the [START_WITH_UPPER] API lint check should
-                    // make this a safe assumption). If the name is a class name, we've found
-                    // the complete class name, return.
-                    if (nextNameChunk.any { it.isUpperCase() }) {
-                        return Triple(name, remaining, annotations)
-                    }
-                }
-                // '<' is first, the end of the class name has been reached.
-                paramIndex -> {
-                    name += remaining.substring(0, paramIndex)
-                    remaining = remaining.substring(paramIndex)
-                    return Triple(name, remaining, annotations)
-                }
-                // '@' is first, trim all annotations.
-                annotationIndex -> {
-                    name += remaining.substring(0, annotationIndex)
-                    trimLeadingAnnotations(remaining.substring(annotationIndex)).let {
-                        (first, second) ->
-                        remaining = first
-                        annotations = second
-                    }
-                }
-            }
-            // Reset indices -- the string may now start with '.' for the next chunk of the name
-            // but this should find the end of the next chunk.
-            dotIndex = remaining.indexOf('.', 1)
-            paramIndex = remaining.indexOf('<')
-            annotationIndex = remaining.indexOf('@')
-            minIndex = minIndex(dotIndex, paramIndex, annotationIndex)
-        }
-        // End of the name reached with no leftover string.
-        name += remaining
-        return Triple(name, null, annotations)
-    }
-
-    companion object {
-        /**
-         * Splits the Kotlin-style nullability marker off the type string, returning a pair of the
-         * cleaned type string and the nullability suffix.
-         */
-        fun splitNullabilitySuffix(
-            type: String,
-            kotlinStyleNulls: Boolean,
-            errorReporter: SignatureErrorReporter = SignatureErrorReporter.THROWING,
-        ): Pair<String, TypeNullability?> {
-            return if (kotlinStyleNulls) {
-                // Don't interpret the wildcard type `?` as a nullability marker.
-                if (type == "?") {
-                    Pair(type, TypeNullability.UNDEFINED)
-                } else if (type.endsWith("?")) {
-                    Pair(type.dropLast(1), TypeNullability.NULLABLE)
-                } else if (type.endsWith("!")) {
-                    Pair(type.dropLast(1), TypeNullability.PLATFORM)
-                } else {
-                    Pair(type, TypeNullability.NONNULL)
-                }
-            } else if (((type.length > 1) && type.endsWith("?")) || type.endsWith("!")) {
-                errorReporter.report("Format does not support Kotlin-style null type syntax: $type")
-                Pair(type.dropLast(1), TypeNullability.PLATFORM)
-            } else {
-                Pair(type, null)
-            }
-        }
-
-        /**
-         * Returns the minimum valid list index from the input, or null if there isn't one. -1 is
-         * not a valid index.
-         */
-        private fun minIndex(vararg index: Int): Int? = index.filter { it != -1 }.minOrNull()
-
-        /**
-         * Given a string and the index in that string which is the start of an annotation (the
-         * character _after_ the `@`), returns the index of the end of the annotation.
-         */
-        fun findAnnotationEnd(type: String, start: Int): Int {
-            var index = start
-            val length = type.length
-            var balance = 0
-            while (index < length) {
-                val c = type[index]
-                if (c == '(') {
-                    balance++
-                } else if (c == ')') {
-                    balance--
-                    if (balance == 0) {
-                        return index + 1
-                    }
-                } else if (c != '.' && !Character.isJavaIdentifierPart(c) && balance == 0) {
-                    break
-                }
-                index++
-            }
-            return index
-        }
-
-        /**
-         * Breaks a string representing type parameters into a list of the type parameter strings.
-         *
-         * E.g. `"<A, B, C>"` -> `["A", "B", "C"]` and `"<List<A>, B>"` -> `["List<A>", "B"]`.
-         */
-        fun typeParameterStrings(typeString: String?): List<String> {
-            return typeParameterStringsWithRemainder(typeString).first
-        }
-
-        /**
-         * Breaks a string representing type parameters into a list of the type parameter strings,
-         * and also returns the remainder of the string after the closing ">".
-         *
-         * E.g. `"<A, B, C>.Inner"` -> `Pair(["A", "B", "C"], ".Inner")`
-         */
-        fun typeParameterStringsWithRemainder(typeString: String?): Pair<List<String>, String?> {
-            val s = typeString ?: return Pair(emptyList(), null)
-            if (!s.startsWith("<")) return Pair(emptyList(), s)
-            val list = mutableListOf<String>()
-            var balance = 0
-            var expect = false
-            var start = 0
-            var i = 0
-            while (i < s.length) {
-                val c = s[i]
-                if (c == '<') {
-                    balance++
-                    expect = balance == 1
-                } else if (c == '>') {
-                    balance--
-                    if (balance == 0) {
-                        add(list, s, start, i)
-                        return if (i == s.length - 1) {
-                            Pair(list, null)
-                        } else {
-                            Pair(list, s.substring(i + 1))
-                        }
-                    }
-                } else if (c == ',') {
-                    expect =
-                        if (balance == 1) {
-                            add(list, s, start, i)
-                            true
-                        } else {
-                            false
-                        }
-                } else {
-                    // This is the start of a parameter
-                    if (expect && balance == 1) {
-                        start = i
-                        expect = false
-                    }
-
-                    if (c == '@') {
-                        // Skip the entire text of the annotation
-                        i = findAnnotationEnd(typeString, i + 1)
-                        continue
-                    }
-                }
-                i++
-            }
-            return Pair(list, null)
-        }
-
-        /**
-         * Adds the substring of [s] from [from] to [to] to the [list], trimming whitespace from the
-         * front.
-         */
-        private fun add(list: MutableList<String>, s: String, from: Int, to: Int) {
-            for (i in from until to) {
-                if (!Character.isWhitespace(s[i])) {
-                    list.add(s.substring(i, to))
-                    return
-                }
-            }
-        }
-    }
+        forceClassToBeNonNull: Boolean,
+    ) = super.parseType(type, typeParameterScope, annotations, forceClassToBeNonNull)
 
     /**
      * The cache entry, that contains the [TypeItem] that has been produced from the [type] and
@@ -829,13 +175,13 @@ internal class TextTypeParser(
                 }
 
             // Remember the number of errors that have been reported so far.
-            val startErrorCount = errorCount
+            val startErrorCount = countingErrorReporter.errorCount
 
             // Parse the [type] to produce a [TypeItem]. This may report errors.
             val typeItem = createTypeItem(typeParameterScope)
 
             // If the error count is different then do not cache this.
-            if (errorCount != startErrorCount) {
+            if (countingErrorReporter.errorCount != startErrorCount) {
                 return typeItem
             }
 
@@ -866,7 +212,7 @@ internal class TextTypeParser(
          * the requested [typeParameterScope].
          */
         private fun createTypeItem(typeParameterScope: TypeParameterScope): TypeItem {
-            return parseType(type, typeParameterScope, emptyList(), forceClassToBeNonNull)
+            return unCachedParseType(type, typeParameterScope, emptyList(), forceClassToBeNonNull)
         }
     }
 
@@ -920,3 +266,30 @@ internal class TextTypeParser(
      */
     private val unqualifiedNameGatherer = UnqualifiedNameGatherer()
 }
+
+/**
+ * Report a recoverable error.
+ *
+ * This keeps a count of how many were reported so that [CacheEntry.getTypeItem] can use that to
+ * determine if any errors were found while parsing a type ([errorCount] increased) and so prevent
+ * it from being cached which would suppress any more errors with that type string.
+ */
+private class CountingErrorReporter(
+    private val delegateErrorReporter: TypeItemParserErrorReporter
+) : TypeItemParserErrorReporter {
+    /**
+     * A count of the errors reported through this.
+     *
+     * This is used to prevent caching [TypeItem]s that reported errors to make sure that every such
+     * case is reported.
+     */
+    var errorCount = 0
+
+    override fun report(
+        issue: Issues.Issue,
+        message: String,
+    ) {
+        delegateErrorReporter.report(issue, message)
+        errorCount += 1
+    }
+}
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/Tokenizer.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/Tokenizer.kt
deleted file mode 100644
index 5c64df0ff..000000000
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/Tokenizer.kt
+++ /dev/null
@@ -1,219 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.text
-
-import com.android.tools.metalava.reporter.FileLocation
-import java.nio.file.Path
-
-/**
- * Extracts tokens from a sequence of characters.
- *
- * The tokens are not the usual sort of tokens created by a tokenizer, e.g. some tokens contain
- * white spaces and even whole strings. e.g. an annotation, including parameters if present, can be
- * returned as a single token, if requested (e.g. by calling [requireToken] with
- * `parenIsSep=false`).
- */
-internal class Tokenizer(private val path: Path, private val buffer: CharArray) :
-    FileLocationTracker {
-    private var position = 0
-    private var line = 1
-
-    override fun fileLocation(): FileLocation {
-        return FileLocation.createLocation(path, line)
-    }
-
-    private fun eatWhitespace(): Boolean {
-        var ate = false
-        while (position < buffer.size && isSpace(buffer[position])) {
-            if (buffer[position] == '\n') {
-                line++
-            }
-            position++
-            ate = true
-        }
-        return ate
-    }
-
-    private fun eatComment(): Boolean {
-        if (position + 1 < buffer.size) {
-            if (buffer[position] == '/' && buffer[position + 1] == '/') {
-                position += 2
-                while (position < buffer.size && !isNewline(buffer[position])) {
-                    position++
-                }
-                return true
-            }
-        }
-        return false
-    }
-
-    private fun eatWhitespaceAndComments() {
-        while (eatWhitespace() || eatComment()) {
-            // intentionally consume whitespace and comments
-        }
-    }
-
-    fun requireToken(parenIsSep: Boolean = true, eatWhitespace: Boolean = true): String {
-        val token = getToken(parenIsSep, eatWhitespace)
-        return token ?: throw ApiParseException("Unexpected end of file", this)
-    }
-
-    fun offset(): Int {
-        return position
-    }
-
-    fun getStringFromOffset(offset: Int): String {
-        return String(buffer, offset, position - offset)
-    }
-
-    lateinit var current: String
-
-    fun getToken(parenIsSep: Boolean = true, eatWhitespace: Boolean = true): String? {
-        if (eatWhitespace) {
-            eatWhitespaceAndComments()
-        }
-        if (position >= buffer.size) {
-            return null
-        }
-        val line = line
-        val c = buffer[position]
-        val start = position
-        position++
-        if (c == '"') {
-            val STATE_BEGIN = 0
-            val STATE_ESCAPE = 1
-            var state = STATE_BEGIN
-            while (true) {
-                if (position >= buffer.size) {
-                    throw ApiParseException("Unexpected end of file for \" starting at $line", this)
-                }
-                val k = buffer[position]
-                if (k == '\n' || k == '\r') {
-                    throw ApiParseException(
-                        "Unexpected newline for \" starting at $line in $path",
-                        this
-                    )
-                }
-                position++
-                when (state) {
-                    STATE_BEGIN ->
-                        when (k) {
-                            '\\' -> state = STATE_ESCAPE
-                            '"' -> {
-                                current = String(buffer, start, position - start)
-                                return current
-                            }
-                        }
-                    STATE_ESCAPE -> state = STATE_BEGIN
-                }
-            }
-        } else if (isSeparator(c, parenIsSep)) {
-            current = c.toString()
-            return current
-        } else {
-            var genericDepth = 0
-            do {
-                while (position < buffer.size) {
-                    val d = buffer[position]
-                    if (isSpace(d) || isSeparator(d, parenIsSep)) {
-                        break
-                    } else if (d == '"') {
-                        // String literal in token: skip the full thing
-                        position++
-                        while (position < buffer.size) {
-                            if (buffer[position] == '"') {
-                                position++
-                                break
-                            } else if (buffer[position] == '\\') {
-                                position++
-                            }
-                            position++
-                        }
-                        continue
-                    }
-                    position++
-                }
-                if (position < buffer.size) {
-                    if (buffer[position] == '<') {
-                        genericDepth++
-                        position++
-                    } else if (genericDepth != 0) {
-                        if (buffer[position] == '>') {
-                            genericDepth--
-                        }
-                        position++
-                    }
-                }
-            } while (
-                position < buffer.size &&
-                    (!isSpace(buffer[position]) && !isSeparator(buffer[position], parenIsSep) ||
-                        genericDepth != 0)
-            )
-            if (position >= buffer.size) {
-                throw ApiParseException("Unexpected end of file for \" starting at $line", this)
-            }
-            current = String(buffer, start, position - start)
-            return current
-        }
-    }
-
-    internal fun assertIdent(token: String) {
-        if (!isIdent(token[0])) {
-            throw ApiParseException("Expected identifier: $token", this)
-        }
-    }
-
-    companion object {
-        private fun isSpace(c: Char): Boolean {
-            return c == ' ' || c == '\t' || c == '\n' || c == '\r'
-        }
-
-        private fun isNewline(c: Char): Boolean {
-            return c == '\n' || c == '\r'
-        }
-
-        private fun isSeparator(c: Char, parenIsSep: Boolean): Boolean {
-            if (parenIsSep) {
-                if (c == '(' || c == ')') {
-                    return true
-                }
-            }
-            return c == '{' || c == '}' || c == ',' || c == ';' || c == '<' || c == '>'
-        }
-
-        private fun isIdent(c: Char): Boolean {
-            return c != '"' && !isSeparator(c, true)
-        }
-
-        internal fun isIdent(token: String): Boolean {
-            return isIdent(token[0])
-        }
-    }
-}
-
-/**
- * Interface implemented by [Tokenizer] which keeps track of the [FileLocation] for the current
- * token.
- *
- * This is provided to avoid passing [Tokenizer] to code that might need access to the current
- * [FileLocation] but does not consume tokens. That makes that code and the [Tokenizer] state easier
- * to reason about.
- */
-internal interface FileLocationTracker {
-    /** Get the current [FileLocation]. */
-    fun fileLocation(): FileLocation
-}
diff --git a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/ApiFileTest.kt b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/ApiFileTest.kt
index 11bf98ee1..e873421d4 100644
--- a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/ApiFileTest.kt
+++ b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/ApiFileTest.kt
@@ -23,8 +23,10 @@ import com.android.tools.metalava.model.ClassKind
 import com.android.tools.metalava.model.ClassResolver
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.SelectableItem
+import com.android.tools.metalava.model.TargetLanguageSet
 import com.android.tools.metalava.model.api.surface.ApiSurfaces
 import com.android.tools.metalava.model.noOpAnnotationManager
+import com.android.tools.metalava.model.testing.value.literalValue
 import com.android.tools.metalava.testing.getAndroidJar
 import com.google.common.truth.Truth.assertThat
 import kotlin.test.assertEquals
@@ -497,6 +499,36 @@ class ApiFileTest : BaseTextCodebaseTest() {
         }
     }
 
+    @Test
+    fun `Test classes split across multiple files`() {
+        runSignatureTest(
+            signature(
+                "current.txt",
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                        public class Foo {
+                        }
+                    }
+                """
+            ),
+            signature(
+                "system.txt",
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                        @test.pkg.Anno(12) public class Foo {
+                        }
+
+                        public @interface Anno {
+                            method public int value();
+                        }
+                    }
+                """
+            ),
+        ) {}
+    }
+
     @Test
     fun `Test unknown interface should still be marked as such`() {
         runSignatureTest(
@@ -542,13 +574,13 @@ class ApiFileTest : BaseTextCodebaseTest() {
             assertThat(reportedIssues)
                 .isEqualTo(
                     """
-                        MAIN_SRC/api.txt:3: error: Type starts with "?" but doesn't appear to be wildcard: ? blah1 [SignatureFileError]
-                        MAIN_SRC/api.txt:4: error: Format does not support Kotlin-style null type syntax: int? [SignatureFileError]
-                        MAIN_SRC/api.txt:4: error: Invalid nullability suffix on primitive: int? [SignatureFileError]
-                        MAIN_SRC/api.txt:5: error: Could not parse type `Comparable<test.pkg.Foo>blah2`. Found unexpected string after type parameters: blah2 [SignatureFileError]
-                        MAIN_SRC/api.txt:6: error: Format does not support Kotlin-style null type syntax: int? [SignatureFileError]
-                        MAIN_SRC/api.txt:6: error: Invalid nullability suffix on primitive: int? [SignatureFileError]
-                        MAIN_SRC/api.txt:8: error: Type starts with "?" but doesn't appear to be wildcard: ? blah1 [SignatureFileError]
+                        MAIN_SRC/api.txt:3: error: Type starts with "?" but doesn't appear to be wildcard: ? blah1 [TypeParseError]
+                        MAIN_SRC/api.txt:4: error: Format does not support Kotlin-style null type syntax: int? [TypeParseError]
+                        MAIN_SRC/api.txt:4: error: Invalid nullability suffix on primitive: int? [TypeParseError]
+                        MAIN_SRC/api.txt:5: error: Could not parse type `Comparable<test.pkg.Foo>blah2`. Found unexpected string after type parameters: blah2 [TypeParseError]
+                        MAIN_SRC/api.txt:6: error: Format does not support Kotlin-style null type syntax: int? [TypeParseError]
+                        MAIN_SRC/api.txt:6: error: Invalid nullability suffix on primitive: int? [TypeParseError]
+                        MAIN_SRC/api.txt:8: error: Type starts with "?" but doesn't appear to be wildcard: ? blah1 [TypeParseError]
                     """
                         .trimIndent()
                 )
@@ -583,7 +615,7 @@ class ApiFileTest : BaseTextCodebaseTest() {
         ) {
             assertThat(reportedIssues)
                 .isEqualTo(
-                    "MAIN_SRC/api.txt:4: error: Invalid nullability suffix on primitive: int? [SignatureFileError]"
+                    "MAIN_SRC/api.txt:4: error: Invalid nullability suffix on primitive: int? [TypeParseError]"
                 )
 
             val fooClass = codebase.assertClass("test.pkg.Foo")
@@ -616,6 +648,39 @@ class ApiFileTest : BaseTextCodebaseTest() {
             .isEqualTo("[java.util.List<Number>, java.util.RandomAccess]")
     }
 
+    @Test
+    fun `Test invalid field initializers`() {
+        runSignatureTest(
+            signature(
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                        public class Foo {
+                            field public final int FIELD1 = 1;
+                            field public static int FIELD2 = 2;
+                            field public static final int FIELD3 = 3;
+                        }
+                    }
+                """
+            ),
+        ) {
+            assertThat(reportedIssues)
+                .isEqualTo(
+                    """
+                        MAIN_SRC/api.txt:4: error: Field FIELD1 in class test.pkg.Foo has a value of `1` but is not `static` and `final`; ignoring value [SignatureFileError]
+                        MAIN_SRC/api.txt:5: error: Field FIELD2 in class test.pkg.Foo has a value of `2` but is not `static` and `final`; ignoring value [SignatureFileError]
+                    """
+                        .trimIndent()
+                )
+
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+
+            assertThat(fooClass.assertField("FIELD1").constantValue).isNull()
+            assertThat(fooClass.assertField("FIELD2").constantValue).isNull()
+            assertThat(fooClass.assertField("FIELD3").constantValue).isEqualTo(literalValue(3))
+        }
+    }
+
     @Test
     fun `Test for main API surface`() {
         val testFiles =
@@ -708,6 +773,153 @@ class ApiFileTest : BaseTextCodebaseTest() {
         )
     }
 
+    @Test
+    fun `Test method target language`() {
+        runCodebaseTest(
+            signature(
+                """
+                // Signature format: 5.0
+                package test.pkg {
+                  public class Foo {
+                    method public void noTargetsListed();
+                    method @BytecodeOnly public void bytecodeOnly();
+                    method @KotlinOnly public void kotlinOnly();
+                    method @InaccessibleFromJava public void inaccessibleFromJava();
+                    method @InaccessibleFromKotlin public void inaccessibleFromKotlin();
+                    method @OtherAnnotation public void noTargetsWithOtherAnnotation();
+                    method @BytecodeOnly @OtherAnnotation public void bytecodeOnlyWithOtherAnnotation();
+                  }
+                }
+                """
+            )
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+
+            val noTargetsListed = fooClass.assertMethod("noTargetsListed", "")
+            assertThat(noTargetsListed.targetLanguages).isEqualTo(TargetLanguageSet.ALL)
+            assertThat(noTargetsListed.annotationNames()).isEmpty()
+
+            val bytecodeOnly = fooClass.assertMethod("bytecodeOnly", "")
+            assertThat(bytecodeOnly.targetLanguages).isEqualTo(TargetLanguageSet.BYTECODE_ONLY)
+            assertThat(bytecodeOnly.annotationNames()).isEmpty()
+
+            val kotlinOnly = fooClass.assertMethod("kotlinOnly", "")
+            assertThat(kotlinOnly.targetLanguages).isEqualTo(TargetLanguageSet.KOTLIN_ONLY)
+            assertThat(kotlinOnly.annotationNames()).isEmpty()
+
+            val inaccessibleFromJava = fooClass.assertMethod("inaccessibleFromJava", "")
+            assertThat(inaccessibleFromJava.targetLanguages).isEqualTo(TargetLanguageSet.NOT_JAVA)
+            assertThat(inaccessibleFromJava.annotationNames()).isEmpty()
+
+            val inaccessibleFromKotlin = fooClass.assertMethod("inaccessibleFromKotlin", "")
+            assertThat(inaccessibleFromKotlin.targetLanguages)
+                .isEqualTo(TargetLanguageSet.NOT_KOTLIN)
+            assertThat(inaccessibleFromKotlin.annotationNames()).isEmpty()
+
+            val noTargetsWithOtherAnnotation =
+                fooClass.assertMethod("noTargetsWithOtherAnnotation", "")
+            assertThat(noTargetsWithOtherAnnotation.targetLanguages)
+                .isEqualTo(TargetLanguageSet.ALL)
+            assertThat(noTargetsWithOtherAnnotation.annotationNames())
+                .containsExactly("androidx.annotation.OtherAnnotation")
+
+            val bytecodeOnlyWithOtherAnnotation =
+                fooClass.assertMethod("bytecodeOnlyWithOtherAnnotation", "")
+            assertThat(bytecodeOnlyWithOtherAnnotation.targetLanguages)
+                .isEqualTo(TargetLanguageSet.BYTECODE_ONLY)
+            assertThat(bytecodeOnlyWithOtherAnnotation.annotationNames())
+                .containsExactly("androidx.annotation.OtherAnnotation")
+        }
+    }
+
+    @Test
+    fun `Test constructor target language`() {
+        runCodebaseTest(
+            signature(
+                """
+                // Signature format: 5.0
+                package test.pkg {
+                  public class Foo {
+                    ctor @BytecodeOnly public Foo();
+                  }
+                }
+                """
+            )
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+
+            val bytecodeOnlyCtor = fooClass.assertConstructor("")
+            assertThat(bytecodeOnlyCtor.targetLanguages).isEqualTo(TargetLanguageSet.BYTECODE_ONLY)
+            assertThat(bytecodeOnlyCtor.annotationNames()).isEmpty()
+        }
+    }
+
+    @Test
+    fun `Test field target language from signature file`() {
+        runCodebaseTest(
+            signature(
+                """
+                // Signature format: 5.0
+                package test.pkg {
+                  public class Foo {
+                    field @InaccessibleFromKotlin public int inaccessibleFromKotlin;
+                  }
+                }
+                """
+            )
+        ) {
+            val fooClass = codebase.assertClass("test.pkg.Foo")
+
+            val inaccessibleFromKotlin = fooClass.assertField("inaccessibleFromKotlin")
+            assertThat(inaccessibleFromKotlin.targetLanguages)
+                .isEqualTo(TargetLanguageSet.NOT_KOTLIN)
+            assertThat(inaccessibleFromKotlin.annotationNames()).isEmpty()
+        }
+    }
+
+    @Test
+    fun `Test class target language`() {
+        runCodebaseTest(
+            signature(
+                """
+                // Signature format: 5.0
+                package test.pkg {
+                  public class NoTargetsListed {
+                  }
+                  @KotlinOnly public class KotlinOnlyClass {
+                  }
+                  @OtherAnnotation public class NoTargetsWithOtherAnnotation {
+                  }
+                  @KotlinOnly @OtherAnnotation public class KotlinOnlyClassWithOtherAnnotation {
+                  }
+                }
+                """
+            )
+        ) {
+            val noTargetsListed = codebase.assertClass("test.pkg.NoTargetsListed")
+            assertThat(noTargetsListed.targetLanguages).isEqualTo(TargetLanguageSet.ALL)
+            assertThat(noTargetsListed.annotationNames()).isEmpty()
+
+            val kotlinOnlyClass = codebase.assertClass("test.pkg.KotlinOnlyClass")
+            assertThat(kotlinOnlyClass.targetLanguages).isEqualTo(TargetLanguageSet.KOTLIN_ONLY)
+            assertThat(kotlinOnlyClass.annotationNames()).isEmpty()
+
+            val noTargetsWithOtherAnnotation =
+                codebase.assertClass("test.pkg.NoTargetsWithOtherAnnotation")
+            assertThat(noTargetsWithOtherAnnotation.targetLanguages)
+                .isEqualTo(TargetLanguageSet.ALL)
+            assertThat(noTargetsWithOtherAnnotation.annotationNames())
+                .containsExactly("androidx.annotation.OtherAnnotation")
+
+            val kotlinOnlyClassWithOtherAnnotation =
+                codebase.assertClass("test.pkg.KotlinOnlyClassWithOtherAnnotation")
+            assertThat(kotlinOnlyClassWithOtherAnnotation.targetLanguages)
+                .isEqualTo(TargetLanguageSet.KOTLIN_ONLY)
+            assertThat(kotlinOnlyClassWithOtherAnnotation.annotationNames())
+                .containsExactly("androidx.annotation.OtherAnnotation")
+        }
+    }
+
     class TestClassItem private constructor(delegate: ClassItem) : ClassItem by delegate {
         companion object {
             fun create(name: String): TestClassItem {
diff --git a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/FileFormatTest.kt b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/FileFormatTest.kt
index e641aa921..ec61419eb 100644
--- a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/FileFormatTest.kt
+++ b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/FileFormatTest.kt
@@ -314,10 +314,11 @@ class FileFormatTest {
     @Test
     fun `Check header and specifier (v5)`() {
         headerAndSpecifierTest(
-            header = """
-                // Signature format: 5.0
+            header =
+                """
+                    // Signature format: 5.0
 
-            """,
+                """,
             specifier = "5.0",
             format = FileFormat.V5,
         )
@@ -364,10 +365,11 @@ class FileFormatTest {
     @Test
     fun `Check header and specifier (v2)`() {
         headerAndSpecifierTest(
-            header = """
-                // Signature format: 2.0
+            header =
+                """
+                    // Signature format: 2.0
 
-            """,
+                """,
             specifier = "2.0",
             format = FileFormat.V2,
         )
diff --git a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/SignatureInputOutputTest.kt b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/SignatureInputOutputTest.kt
index 5881fa3b8..34cb2d0b9 100644
--- a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/SignatureInputOutputTest.kt
+++ b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/SignatureInputOutputTest.kt
@@ -23,7 +23,9 @@ import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.PrimitiveTypeItem
 import com.android.tools.metalava.model.StripJavaLangPrefix
 import com.android.tools.metalava.model.VisibilityLevel
+import com.android.tools.metalava.model.testing.value.fieldReferenceValue
 import com.android.tools.metalava.model.text.FileFormat.TypeArgumentSpacing
+import com.android.tools.metalava.model.value.asString
 import com.android.tools.metalava.model.visitors.ApiPredicate
 import com.android.tools.metalava.model.visitors.ApiType
 import com.google.common.truth.Truth.assertThat
@@ -155,7 +157,7 @@ class SignatureInputOutputTest : Assertions {
             assertThat(field.name()).isEqualTo("foo")
             assertThat(field.type().isString()).isTrue()
             assertThat(field.modifiers.getVisibilityLevel()).isEqualTo(VisibilityLevel.PROTECTED)
-            assertThat(field.legacyInitialValue()).isNull()
+            assertThat(field.constantValue).isNull()
         }
     }
 
@@ -165,7 +167,7 @@ class SignatureInputOutputTest : Assertions {
             """
                 package test.pkg {
                   public class Foo {
-                    field public static foo: String = "hi";
+                    field public static final foo: String = "hi";
                   }
                 }
             """
@@ -179,7 +181,7 @@ class SignatureInputOutputTest : Assertions {
             assertThat(field.type().isString()).isTrue()
             assertThat(field.modifiers.getVisibilityLevel()).isEqualTo(VisibilityLevel.PUBLIC)
             assertThat(field.modifiers.isStatic()).isTrue()
-            assertThat(field.legacyInitialValue()).isEqualTo("hi")
+            assertThat(field.constantValue?.asString()).isEqualTo("hi")
         }
     }
 
@@ -256,7 +258,8 @@ class SignatureInputOutputTest : Assertions {
                 .isEqualTo(PrimitiveTypeItem.Primitive.INT)
             assertThat(method.parameters()).isEmpty()
 
-            assertThat(method.legacyDefaultValue()).isEqualTo("java.lang.Integer.MIN_VALUE")
+            assertThat(method.defaultValue)
+                .isEqualTo(fieldReferenceValue("java.lang.Integer", "MIN_VALUE"))
         }
     }
 
@@ -845,6 +848,72 @@ class SignatureInputOutputTest : Assertions {
         runInputOutputTest(api, FileFormat.V5)
     }
 
+    @Test
+    fun `Test method target language`() {
+        val api =
+            """
+            // Signature format: 5.0
+            package test.pkg {
+              public class Foo {
+                method @BytecodeOnly public void bytecodeOnly();
+                method @BytecodeOnly @OtherAnnotation public void bytecodeOnlyWithOtherAnnotation();
+                method @InaccessibleFromJava public void inaccessibleFromJava();
+                method @InaccessibleFromKotlin public void inaccessibleFromKotlin();
+                method @KotlinOnly public void kotlinOnly();
+                method public void noTargetsListed();
+                method @OtherAnnotation public void noTargetsWithOtherAnnotation();
+              }
+            }
+            """
+        runInputOutputTest(api, FileFormat.V5)
+    }
+
+    @Test
+    fun `Test constructor target language`() {
+        val api =
+            """
+            // Signature format: 5.0
+            package test.pkg {
+              public class Foo {
+                ctor @BytecodeOnly public Foo();
+              }
+            }
+            """
+        runInputOutputTest(api, FileFormat.V5)
+    }
+
+    @Test
+    fun `Test field target language`() {
+        val api =
+            """
+            // Signature format: 5.0
+            package test.pkg {
+              public class Foo {
+                field @InaccessibleFromKotlin public int inaccessibleFromKotlin;
+              }
+            }
+            """
+        runInputOutputTest(api, FileFormat.V5)
+    }
+
+    @Test
+    fun `Test class target language`() {
+        val api =
+            """
+            package test.pkg {
+              @KotlinOnly public class KotlinOnlyClass {
+              }
+              @KotlinOnly @OtherAnnotation public class KotlinOnlyClassWithOtherAnnotation {
+              }
+              public class NoTargetsListed {
+              }
+              @OtherAnnotation public class NoTargetsWithOtherAnnotation {
+              }
+            }
+            """
+        runInputOutputTest(api, FileFormat.V5)
+    }
+
     companion object {
         private val kotlinStyleFormat =
             FileFormat.V5.copy(kotlinNameTypeOrder = true, formatDefaults = FileFormat.V5)
diff --git a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TokenizerTest.kt b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TokenizerTest.kt
deleted file mode 100644
index 5c69bb672..000000000
--- a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TokenizerTest.kt
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.text
-
-import java.nio.file.Path
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertThrows
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.junit.runners.Parameterized
-
-@RunWith(Parameterized::class)
-class TokenizerTest(private val params: Params) {
-
-    data class Params(
-        val input: String,
-        val parenIsSep: Boolean = true,
-        val expectedToken: String? = null,
-        val expectedError: String? = null,
-    ) {
-        init {
-            if (expectedToken == null && expectedError == null) {
-                throw IllegalArgumentException(
-                    "Expected one of `expectedToken` and `expectedError`, found neither"
-                )
-            } else if (expectedToken != null && expectedError != null) {
-                throw IllegalArgumentException(
-                    "Expected one of `expectedToken` and `expectedError`, found both"
-                )
-            }
-        }
-
-        override fun toString(): String = input
-    }
-
-    companion object {
-        private val params =
-            listOf(
-                Params(
-                    input = """  "string"  """,
-                    expectedToken = """"string"""",
-                ),
-                Params(
-                    input = """  "string  """,
-                    expectedError = """api.txt:1: Unexpected end of file for " starting at 1""",
-                ),
-                Params(
-                    input = """  "string\""",
-                    expectedError = """api.txt:1: Unexpected end of file for " starting at 1""",
-                ),
-                Params(
-                    input = """ @pkg.Annotation("string") """,
-                    parenIsSep = false,
-                    expectedToken = """@pkg.Annotation("string")""",
-                ),
-                Params(
-                    input = """ @pkg.Annotation("string """,
-                    parenIsSep = false,
-                    expectedError = """api.txt:1: Unexpected end of file for " starting at 1""",
-                ),
-            )
-
-        @JvmStatic
-        @Parameterized.Parameters(name = "#{index} -{0}")
-        fun testParams(): List<Params> = params
-    }
-
-    @Test
-    fun `check token`() {
-        val tokenizer = Tokenizer(Path.of("api.txt"), params.input.toCharArray())
-
-        fun requireToken(): String {
-            return tokenizer.requireToken(parenIsSep = params.parenIsSep)
-        }
-
-        params.expectedError?.let { expectedError ->
-            val exception = assertThrows(ApiParseException::class.java) { requireToken() }
-            assertEquals(expectedError, exception.message)
-        }
-
-        params.expectedToken?.let { expectedToken ->
-            val token = requireToken()
-            assertEquals(expectedToken, token)
-        }
-    }
-}
diff --git a/metalava-model-text/src/test/resources/model-test-suite-baseline.txt b/metalava-model-text/src/test/resources/model-test-suite-baseline.txt
index 9ebac1b0d..6a4a49682 100644
--- a/metalava-model-text/src/test/resources/model-test-suite-baseline.txt
+++ b/metalava-model-text/src/test/resources/model-test-suite-baseline.txt
@@ -1,13 +1,3 @@
-com.android.tools.metalava.model.testsuite.annotationitem.CommonAnnotationItemTest
-  annotation toSource() with char values
-  annotation toSource() with class values
-  annotation toSource() with compound expression values
-  annotation toSource() with number values
-  annotation with constant literal values
-  annotation with infinity values
-  annotation with negative number values
-  annotation with type cast values
-
 com.android.tools.metalava.model.testsuite.typeitem.CommonIsAssignableFromTest
   Test assignability without unboxing[boxedInt to primitiveInt]
   Test assignability without unboxing[number to boxedInt]
@@ -18,81 +8,33 @@ com.android.tools.metalava.model.testsuite.typeitem.CommonTypeParameterItemTest
   Test type parameter with annotations
 
 com.android.tools.metalava.model.testsuite.value.CommonParameterizedAnnotationToSourceValueTest
-  testLegacySource[source,String using constant]
-  testLegacySource[source,annotation]
-  testLegacySource[source,char escaped]
-  testLegacySource[source,char unicode]
-  testLegacySource[source,char]
-  testLegacySource[source,double NaN]
-  testLegacySource[source,double negative infinity]
-  testLegacySource[source,double positive infinity]
-  testLegacySource[source,double with exponent]
-  testLegacySource[source,float NaN]
-  testLegacySource[source,float negative infinity]
-  testLegacySource[source,float positive infinity]
-  testLegacySource[source,float with exponent]
-  testLegacySource[source,float with upper F]
-  testLegacySource[source,int negative]
-  testLegacySource[source,int positive]
-  testLegacySource[source,long with lower l]
+  testLegacySource[source,byte - cast]
+  testLegacySource[source,class literal - array of basic class]
+  testLegacySource[source,class literal - array of generic class]
+  testLegacySource[source,class literal - basic class]
+  testLegacySource[source,class literal - generic class]
+  testLegacySource[source,short - cast]
 
 com.android.tools.metalava.model.testsuite.value.CommonParameterizedAttributeDefaultValueTest
-  testLegacySource[source,String array]
-  testLegacySource[source,String using constant]
-  testLegacySource[source,annotation]
-  testLegacySource[source,char escaped]
-  testLegacySource[source,char unicode]
-  testLegacySource[source,char]
-  testLegacySource[source,class array literal]
-  testLegacySource[source,class void wrapper class]
-  testLegacySource[source,class]
-  testLegacySource[source,double NaN]
-  testLegacySource[source,double negative infinity]
-  testLegacySource[source,double positive infinity]
-  testLegacySource[source,double with exponent]
-  testLegacySource[source,float NaN]
-  testLegacySource[source,float negative infinity]
-  testLegacySource[source,float positive infinity]
-  testLegacySource[source,float with exponent]
-  testLegacySource[source,float with upper F]
-  testLegacySource[source,int positive]
-  testLegacySource[source,long with lower l]
+  testLegacySource[source,byte - cast]
+  testLegacySource[source,short - cast]
+  testMethodDefaultValue[source,byte - cast]
+  testMethodDefaultValue[source,short - cast]
 
 com.android.tools.metalava.model.testsuite.value.CommonParameterizedAttributeValueTest
-  testLegacySource[source,annotation]
-  testLegacySource[source,char escaped]
-  testLegacySource[source,char unicode]
-  testLegacySource[source,char]
-  testLegacySource[source,enum]
+  testAttributeValue[source,byte - cast]
+  testAttributeValue[source,short - cast]
 
 com.android.tools.metalava.model.testsuite.value.CommonParameterizedFieldValueTest
-  testLegacySource[source,String using constant]
-  testLegacySource[source,class array literal]
-  testLegacySource[source,class int array literal]
-  testLegacySource[source,class void primitive class]
-  testLegacySource[source,class void wrapper class]
-  testLegacySource[source,class]
-  testLegacySource[source,double NaN]
-  testLegacySource[source,double negative infinity]
-  testLegacySource[source,double positive infinity]
-  testLegacySource[source,enum]
-  testLegacySource[source,float NaN]
-  testLegacySource[source,float negative infinity]
-  testLegacySource[source,float positive infinity]
-  testLegacySource[source,long with int]
+  testFieldValue[source,byte - cast]
+  testFieldValue[source,short - cast]
 
 com.android.tools.metalava.model.testsuite.value.CommonParameterizedFieldWriteWithSemicolonValueTest
-  testLegacySource[source,String using constant]
-  testLegacySource[source,class array literal]
-  testLegacySource[source,class int array literal]
-  testLegacySource[source,class void primitive class]
-  testLegacySource[source,class void wrapper class]
-  testLegacySource[source,class]
-  testLegacySource[source,double NaN]
-  testLegacySource[source,double negative infinity]
-  testLegacySource[source,double positive infinity]
-  testLegacySource[source,enum]
-  testLegacySource[source,float NaN]
-  testLegacySource[source,float negative infinity]
-  testLegacySource[source,float positive infinity]
-  testLegacySource[source,long with int]
+  testLegacySource[source,byte - cast]
+  testLegacySource[source,short - cast]
+
+com.android.tools.metalava.model.testsuite.value.ParameterizedValueParserTest
+  Test parse[byte - cast,annotation_to_source,kotlin,source]
+  Test parse[byte - cast,signatureExpression,jar]
+  Test parse[short - cast,annotation_to_source,kotlin,jar]
+  Test parse[short - cast,signatureExpression,jar]
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineAnnotationFactory.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineAnnotationFactory.kt
index 35d5204e7..17f29d1ac 100644
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineAnnotationFactory.kt
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineAnnotationFactory.kt
@@ -18,21 +18,16 @@ package com.android.tools.metalava.model.turbine
 
 import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
 import com.android.tools.metalava.model.AnnotationAttribute
-import com.android.tools.metalava.model.AnnotationAttributeValue
 import com.android.tools.metalava.model.AnnotationItem
-import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.DefaultAnnotationArrayAttributeValue
-import com.android.tools.metalava.model.DefaultAnnotationAttribute
-import com.android.tools.metalava.model.DefaultAnnotationItem
-import com.android.tools.metalava.model.DefaultAnnotationSingleAttributeValue
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.value.Value
+import com.android.tools.metalava.model.value.ValueProvider
 import com.android.tools.metalava.reporter.FileLocation
 import com.google.common.collect.ImmutableList
 import com.google.common.collect.ImmutableMap
+import com.google.turbine.binder.bound.TypeBoundClass
 import com.google.turbine.model.Const
-import com.google.turbine.model.Const.ArrayInitValue
-import com.google.turbine.model.Const.Kind
 import com.google.turbine.tree.Tree
-import com.google.turbine.tree.Tree.ArrayInit
 import com.google.turbine.tree.Tree.Assign
 import com.google.turbine.tree.Tree.Expression
 import com.google.turbine.tree.Tree.Literal
@@ -41,20 +36,23 @@ import com.google.turbine.type.AnnoInfo
 /**
  * Factory for creating [AnnotationItem]s from [AnnoInfo]s.
  *
- * @param codebase the [Codebase] to which the [AnnotationItem] will belong.
- * @param sourceFileCache provides mapping from [AnnoInfo.source] to location.
+ * @param globalContext provides access to some global context needed by this.
  */
-internal class TurbineAnnotationFactory(
-    private val codebase: Codebase,
-    private val sourceFileCache: TurbineSourceFileCache,
-) {
+internal class TurbineAnnotationFactory(globalContext: TurbineGlobalContext) :
+    TurbineGlobalContext by globalContext {
     /** Creates a list of AnnotationItems from given list of Turbine Annotations */
-    internal fun createAnnotations(annotations: List<AnnoInfo>): List<AnnotationItem> {
-        return annotations.mapNotNull { createAnnotation(it) }
+    internal fun createAnnotations(
+        annotations: List<AnnoInfo>,
+        fieldResolver: TurbineFieldResolver? = null,
+    ): List<AnnotationItem> {
+        return annotations.mapNotNull { createAnnotation(it, fieldResolver) }
     }
 
     /** Create an [AnnotationItem] from an [AnnoInfo]. */
-    private fun createAnnotation(annotation: AnnoInfo): AnnotationItem? {
+    internal fun createAnnotation(
+        annotation: AnnoInfo,
+        fieldResolver: TurbineFieldResolver? = null,
+    ): AnnotationItem? {
         // Get the source representation of the annotation. This will be null for an annotation
         // loaded from a class file.
         val tree: Tree.Anno? = annotation.tree()
@@ -70,15 +68,24 @@ internal class TurbineAnnotationFactory(
                 ?.let { sourceFile -> TurbineFileLocation.forTree(sourceFile, tree) }
                 ?: FileLocation.UNKNOWN
 
-        return DefaultAnnotationItem.create(codebase, fileLocation, qualifiedName) {
-            getAnnotationAttributes(annotation.values(), tree?.args())
+        val annotationClass = annotation.sym()?.let { typeBoundClassForSymbol(it) }
+
+        return AnnotationItem.createAttributesLazily(codebase, fileLocation, qualifiedName) {
+            getAnnotationAttributes(
+                annotationClass,
+                annotation.values(),
+                tree?.args(),
+                fieldResolver,
+            )
         }
     }
 
     /** Creates a list of AnnotationAttribute from the map of name-value attribute pairs */
     private fun getAnnotationAttributes(
+        annotationClass: TypeBoundClass?,
         attrs: ImmutableMap<String, Const>,
-        exprs: ImmutableList<Expression>?
+        exprs: ImmutableList<Expression>?,
+        fieldResolver: TurbineFieldResolver?,
     ): List<AnnotationAttribute> {
         val attributes = mutableListOf<AnnotationAttribute>()
         if (exprs != null) {
@@ -88,56 +95,81 @@ internal class TurbineAnnotationFactory(
                         exp as Assign
                         val name = exp.name().value()
                         val assignExp = exp.expr()
+                        val const = attrs[name]!!
                         attributes.add(
-                            DefaultAnnotationAttribute(
+                            AnnotationAttribute.createLazyAttribute(
                                 name,
-                                createAttrValue(attrs[name]!!, assignExp)
+                                createAttributeValueProvider(
+                                    annotationClass,
+                                    name,
+                                    const,
+                                    assignExp,
+                                    fieldResolver,
+                                ),
                             )
                         )
                     }
                     else -> {
                         val name = ANNOTATION_ATTR_VALUE
-                        val value =
+                        val const =
                             attrs[name]
                                 ?: (exp as? Literal)?.value()
-                                    ?: error(
+                                ?: error(
                                     "Cannot find value for default 'value' attribute from $exp"
                                 )
                         attributes.add(
-                            DefaultAnnotationAttribute(name, createAttrValue(value, exp))
+                            AnnotationAttribute.createLazyAttribute(
+                                name,
+                                createAttributeValueProvider(
+                                    annotationClass,
+                                    name,
+                                    const,
+                                    exp,
+                                    fieldResolver,
+                                ),
+                            )
                         )
                     }
                 }
             }
         } else {
-            for ((name, value) in attrs) {
-                attributes.add(DefaultAnnotationAttribute(name, createAttrValue(value, null)))
+            for ((name, const) in attrs) {
+                attributes.add(
+                    AnnotationAttribute.createLazyAttribute(
+                        name,
+                        createAttributeValueProvider(
+                            annotationClass,
+                            name,
+                            const,
+                            null,
+                            fieldResolver,
+                        ),
+                    )
+                )
             }
         }
         return attributes
     }
 
-    private fun createAttrValue(const: Const, expr: Expression?): AnnotationAttributeValue {
-        if (const.kind() == Kind.ARRAY) {
-            const as ArrayInitValue
-            if (const.elements().count() == 1 && expr != null && expr !is ArrayInit) {
-                // This is case where defined type is array type but provided attribute value is
-                // single non-array element
-                // For e.g. @Anno(5) where Anno is @interface Anno {int [] value()}
-                val constLiteral = const.elements().single()
-                return DefaultAnnotationSingleAttributeValue(
-                    { TurbineValue(constLiteral, expr).getSourceForAnnotationValue() },
-                    { constLiteral.underlyingValue }
-                )
-            }
-            return DefaultAnnotationArrayAttributeValue(
-                { TurbineValue(const, expr).getSourceForAnnotationValue() },
-                { const.elements().map { createAttrValue(it, null) } }
-            )
-        }
-        return DefaultAnnotationSingleAttributeValue(
-            { TurbineValue(const, expr).getSourceForAnnotationValue() },
-            { const.underlyingValue }
-        )
+    /**
+     * Create a [ValueProvider] that will create (and cache) a [Value]
+     *
+     * @param annotationClass the optional [TypeBoundClass] for the annotation. If provided it will
+     *   be used to find a [TypeItem] for the annotation attribute called [attributeName].
+     * @param attributeName the name of the annotation.
+     * @param const the [Const] value.
+     * @param expr the optional source [Expression].
+     * @param fieldResolver the optional [TurbineFieldResolver] used to resolve field [expr]s to the
+     *   field definition.
+     */
+    private fun createAttributeValueProvider(
+        annotationClass: TypeBoundClass?,
+        attributeName: String,
+        const: Const,
+        expr: Expression?,
+        fieldResolver: TurbineFieldResolver?,
+    ): ValueProvider {
+        val turbineValue = TurbineValue(const, expr, fieldResolver)
+        return valueFactory.providerForAnnotationValue(annotationClass, attributeName, turbineValue)
     }
 }
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineClassBuilder.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineClassBuilder.kt
index ea0b6ea44..7d7dbfdd2 100644
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineClassBuilder.kt
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineClassBuilder.kt
@@ -24,7 +24,6 @@ import com.android.tools.metalava.model.ClassKind
 import com.android.tools.metalava.model.ClassOrigin
 import com.android.tools.metalava.model.DefaultTypeParameterList
 import com.android.tools.metalava.model.ExceptionTypeItem
-import com.android.tools.metalava.model.FixedFieldValue
 import com.android.tools.metalava.model.ItemDocumentation.Companion.toItemDocumentationFactory
 import com.android.tools.metalava.model.ItemDocumentationFactory
 import com.android.tools.metalava.model.ModifierFlags.Companion.ABSTRACT
@@ -51,9 +50,9 @@ import com.android.tools.metalava.model.createMutableModifiers
 import com.android.tools.metalava.model.hasAnnotation
 import com.android.tools.metalava.model.item.DefaultClassItem
 import com.android.tools.metalava.model.item.DefaultTypeParameterItem
-import com.android.tools.metalava.model.item.FieldValue
 import com.android.tools.metalava.model.item.ParameterDefaultValue
 import com.android.tools.metalava.model.type.MethodFingerprint
+import com.android.tools.metalava.model.value.ValueUseSite
 import com.android.tools.metalava.reporter.FileLocation
 import com.google.common.collect.ImmutableList
 import com.google.common.collect.ImmutableMap
@@ -77,6 +76,7 @@ import com.google.turbine.tree.Tree.TyDecl
 import com.google.turbine.tree.Tree.VarDecl
 import com.google.turbine.type.AnnoInfo
 import com.google.turbine.type.Type
+import kotlin.jvm.optionals.getOrNull
 
 /**
  * Responsible for creating [ClassItem]s from either source or binary [ClassSymbol] and
@@ -217,7 +217,7 @@ internal class TurbineClassBuilder(
     }
 
     private fun createModifiers(flag: Int, annoInfos: List<AnnoInfo>): MutableModifierList {
-        val annotations = annotationFactory.createAnnotations(annoInfos)
+        val annotations = annotationFactory.createAnnotations(annoInfos, fieldResolver)
         val modifierItem =
             when (flag) {
                 0 -> { // No Modifier. Default modifier is PACKAGE_PRIVATE in such case
@@ -393,7 +393,6 @@ internal class TurbineClassBuilder(
                     field.annotations(),
                 )
             val isEnumConstant = (flags and TurbineFlag.ACC_ENUM) != 0
-            val fieldValue = createInitialValue(field)
             val type =
                 typeItemFactory.getFieldType(
                     underlyingType = field.type(),
@@ -403,10 +402,22 @@ internal class TurbineClassBuilder(
                     isInitialValueNonNull = {
                         // The initial value is non-null if the value is a literal which is not
                         // null.
-                        fieldValue.initialValue(false) != null
+                        isInitialValueNonNull(field)
                     }
                 )
 
+            val constantValueProvider =
+                field.value()?.let { const ->
+                    // In Java fields have to be static and final in order for them to have a
+                    // constant value
+                    if (!fieldModifierItem.isStatic() || !fieldModifierItem.isFinal()) {
+                        return@let null
+                    }
+                    val expr = field.decl()?.init()?.getOrNull()
+                    val turbineValue = TurbineValue(const, expr, fieldResolver)
+                    valueFactory.providerFor(type, turbineValue, ValueUseSite.FIELD)
+                }
+
             val documentation = javadoc(decl)
             val fieldItem =
                 itemFactory.createFieldItem(
@@ -417,7 +428,7 @@ internal class TurbineClassBuilder(
                     containingClass = classItem,
                     type = type,
                     isEnumConstant = isEnumConstant,
-                    fieldValue = fieldValue,
+                    constantValueProvider = constantValueProvider,
                 )
 
             classItem.addField(fieldItem)
@@ -448,12 +459,10 @@ internal class TurbineClassBuilder(
                 )
             val documentation = javadoc(decl)
             val defaultValueExpr = getAnnotationDefaultExpression(method)
-            val defaultValue =
+            val defaultTurbineValue =
                 method.defaultValue()?.let { defaultConst ->
                     TurbineValue(defaultConst, defaultValueExpr, fieldResolver)
-                        .getSourceForMethodDefault()
                 }
-                    ?: ""
 
             val parameters = method.parameters()
             val fingerprint = MethodFingerprint(name, parameters.size)
@@ -466,6 +475,11 @@ internal class TurbineClassBuilder(
                     isAnnotationElement = isAnnotationElement,
                 )
 
+            val defaultValueProvider =
+                defaultTurbineValue?.let {
+                    valueFactory.providerFor(returnType, it, ValueUseSite.ANNOTATION)
+                }
+
             val methodItem =
                 itemFactory.createMethodItem(
                     fileLocation = TurbineFileLocation.forTree(classItem, decl),
@@ -484,7 +498,7 @@ internal class TurbineClassBuilder(
                         )
                     },
                     throwsTypes = getThrowsList(method.exceptions(), methodTypeItemFactory),
-                    annotationDefault = defaultValue,
+                    defaultValueProvider = defaultValueProvider,
                 )
 
             // Ignore enum synthetic methods.
@@ -629,10 +643,16 @@ internal class TurbineClassBuilder(
             .toItemDocumentationFactory()
     }
 
-    private fun createInitialValue(field: FieldInfo): FieldValue {
+    /**
+     * Check to see whether the initial value for [field] is non-null.
+     *
+     * If it is `non-null` then the field itself can be treated as if it is non-null, i.e. as if it
+     * had an `@NonNull` annotation.
+     */
+    private fun isInitialValueNonNull(field: FieldInfo): Boolean {
         val optExpr = field.decl()?.init()
-        val expr = if (optExpr != null && optExpr.isPresent()) optExpr.get() else null
-        val constantValue = field.value()?.getValue()
+        val expr = if (optExpr != null && optExpr.isPresent) optExpr.get() else null
+        val constantValue = field.value()?.value
 
         val initialValueWithoutRequiredConstant =
             when {
@@ -653,7 +673,7 @@ internal class TurbineClassBuilder(
                     }
             }
 
-        return FixedFieldValue(constantValue, initialValueWithoutRequiredConstant)
+        return initialValueWithoutRequiredConstant != null
     }
 
     /**
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineCodebaseInitialiser.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineCodebaseInitialiser.kt
index c5dcaa25f..38f779dc4 100644
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineCodebaseInitialiser.kt
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineCodebaseInitialiser.kt
@@ -22,9 +22,9 @@ import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassOrigin
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.ItemDocumentation.Companion.toItemDocumentationFactory
-import com.android.tools.metalava.model.ItemLanguage
 import com.android.tools.metalava.model.JAVA_PACKAGE_INFO
 import com.android.tools.metalava.model.PackageFilter
+import com.android.tools.metalava.model.SourceLanguage
 import com.android.tools.metalava.model.TypeParameterScope
 import com.android.tools.metalava.model.VisibilityLevel
 import com.android.tools.metalava.model.createImmutableModifiers
@@ -97,19 +97,21 @@ internal class TurbineCodebaseInitialiser(
     override lateinit var annotationFactory: TurbineAnnotationFactory
 
     /** Global [TurbineTypeItemFactory] from which all other instances are created. */
-    private lateinit var globalTypeItemFactory: TurbineTypeItemFactory
+    override lateinit var globalTypeItemFactory: TurbineTypeItemFactory
 
     /** Creates [Item] instances for [codebase]. */
     override val itemFactory =
         DefaultItemFactory(
             codebase = codebase,
             // Turbine can only process java files.
-            defaultItemLanguage = ItemLanguage.JAVA,
+            defaultSourceLanguage = SourceLanguage.JAVA,
             // Source files need to track which parts belong to which API surface variants, so they
             // need to create an ApiVariantSelectors instance that can be used to track that.
             defaultVariantSelectorsFactory = ApiVariantSelectors.MUTABLE_FACTORY,
         )
 
+    override lateinit var valueFactory: TurbineValueFactory
+
     /**
      * Data Type: TurbineElements (An implementation of javax.lang.model.util.Elements)
      *
@@ -206,8 +208,11 @@ internal class TurbineCodebaseInitialiser(
         // CompUnit associated with the SourceFile so pass in all the CompUnits so it can find it.
         sourceFileCache = TurbineSourceFileCache(codebase, allUnits)
 
+        // Create the TurbineValueProviderFactory
+        valueFactory = TurbineValueFactory(this)
+
         // Create a factory for creating annotations from AnnoInfo.
-        annotationFactory = TurbineAnnotationFactory(codebase, sourceFileCache)
+        annotationFactory = TurbineAnnotationFactory(this)
 
         // Create the global TurbineTypeItemFactory.
         globalTypeItemFactory =
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineGlobalContext.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineGlobalContext.kt
index 1f22d97a3..53bbe6dac 100644
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineGlobalContext.kt
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineGlobalContext.kt
@@ -16,10 +16,12 @@
 
 package com.android.tools.metalava.model.turbine
 
-import com.android.tools.metalava.model.DefaultAnnotationItem
+import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.DefaultItem
+import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.item.DefaultCodebase
 import com.android.tools.metalava.model.item.DefaultItemFactory
+import com.android.tools.metalava.model.value.Value
 import com.google.turbine.binder.bound.SourceTypeBoundClass
 import com.google.turbine.binder.bound.TypeBoundClass
 import com.google.turbine.binder.sym.ClassSymbol
@@ -36,9 +38,19 @@ internal interface TurbineGlobalContext {
     /** Factory for creating [DefaultItem] implementations. */
     val itemFactory: DefaultItemFactory
 
-    /** Factory for creating [DefaultAnnotationItem]s from [AnnoInfo] objects. */
+    /** Factory for creating [AnnotationItem]s from [AnnoInfo] objects. */
     val annotationFactory: TurbineAnnotationFactory
 
+    /** Factory for creating [Value]s from [TurbineValue]s. */
+    val valueFactory: TurbineValueFactory
+
+    /**
+     * Provides support for creating [TypeItem]s.
+     *
+     * This cannot be used to create [TypeItem]s which may contain type variables.
+     */
+    val globalTypeItemFactory: TurbineTypeItemFactory
+
     /** True if comments should be read, false otherwise. */
     val allowReadingComments: Boolean
 
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceParser.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceParser.kt
index b061f25ed..698496e31 100644
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceParser.kt
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceParser.kt
@@ -41,8 +41,16 @@ internal class TurbineSourceParser(
         description: String,
         classPath: List<File>,
         apiPackages: PackageFilter?,
-        projectDescription: File?
+        projectDescription: File?,
+        compiledSourceJar: File?,
     ): Codebase {
+        if (projectDescription != null) {
+            error("Turbine model does not support --project")
+        }
+        if (compiledSourceJar != null) {
+            error("Turbine model does not support --compiled-jar")
+        }
+
         val rootDir = sourceSet.sourcePath.firstOrNull() ?: File("").canonicalFile
 
         val assembler =
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineValue.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineValue.kt
index bfda4befa..c24d89b50 100644
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineValue.kt
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineValue.kt
@@ -18,12 +18,6 @@ package com.android.tools.metalava.model.turbine
 
 import com.google.turbine.binder.bound.TypeBoundClass
 import com.google.turbine.model.Const
-import com.google.turbine.model.Const.ArrayInitValue
-import com.google.turbine.model.Const.Kind
-import com.google.turbine.model.Const.Value
-import com.google.turbine.model.TurbineConstantTypeKind
-import com.google.turbine.tree.Tree
-import com.google.turbine.tree.Tree.ArrayInit
 import com.google.turbine.tree.Tree.ConstVarName
 import com.google.turbine.tree.Tree.Expression
 
@@ -57,128 +51,5 @@ internal class TurbineValue(
     val expr: Expression?,
 
     /** If available, then can be used to resolve [ConstVarName] to [TypeBoundClass.FieldInfo]. */
-    val fieldResolver: TurbineFieldResolver? = null,
-) {
-    /**
-     * Get the source representation of this value suitable for use when writing a method's default
-     * value.
-     */
-    fun getSourceForMethodDefault(): String {
-        // Check for field references first.
-        if (expr != null) {
-            when (expr.kind()) {
-                Tree.Kind.CONST_VAR_NAME -> {
-                    // If the const is an enum then use that as it will be fully qualified but the
-                    // ConstVarName will not.
-                    if (const.kind() != Kind.ENUM_CONSTANT && fieldResolver != null) {
-                        expr as ConstVarName
-                        val fieldInfo = fieldResolver.resolveField(expr)
-                        val fieldSymbol = fieldInfo?.sym()
-                        if (fieldSymbol != null) {
-                            return "${fieldSymbol.owner().qualifiedName}.${fieldSymbol.name()}"
-                        }
-                    }
-                }
-                // Fall back to using the const.
-                else -> {}
-            }
-        }
-
-        return when (const.kind()) {
-            Kind.PRIMITIVE -> {
-                when ((const as Value).constantTypeKind()) {
-                    TurbineConstantTypeKind.FLOAT -> {
-                        val value = (const as Const.FloatValue).value()
-                        when {
-                            value == Float.POSITIVE_INFINITY -> "java.lang.Float.POSITIVE_INFINITY"
-                            value == Float.NEGATIVE_INFINITY -> "java.lang.Float.NEGATIVE_INFINITY"
-                            else -> value.toString() + "f"
-                        }
-                    }
-                    TurbineConstantTypeKind.DOUBLE -> {
-                        val value = (const as Const.DoubleValue).value()
-                        when {
-                            value == Double.POSITIVE_INFINITY ->
-                                "java.lang.Double.POSITIVE_INFINITY"
-                            value == Double.NEGATIVE_INFINITY ->
-                                "java.lang.Double.NEGATIVE_INFINITY"
-                            else -> const.toString()
-                        }
-                    }
-                    TurbineConstantTypeKind.BYTE -> const.getValue().toString()
-                    else -> const.toString()
-                }
-            }
-            Kind.ARRAY -> {
-                const as ArrayInitValue
-                // This is case where defined type is array type but default value is
-                // single non-array element
-                // For e.g. char[] letter() default 'a';
-                if (const.elements().count() == 1 && expr != null && expr !is ArrayInit) {
-                    TurbineValue(const.elements().single(), expr).getSourceForMethodDefault()
-                } else const.underlyingValue.toString()
-            }
-            Kind.CLASS_LITERAL -> "${const.underlyingValue}.class"
-            else -> const.underlyingValue.toString()
-        }
-    }
-
-    /**
-     * Get the source representation of this value suitable for use when writing an annotation
-     * attribute's value.
-     */
-    fun getSourceForAnnotationValue(): String {
-        return when (const.kind()) {
-            Kind.PRIMITIVE -> {
-                when ((const as Value).constantTypeKind()) {
-                    TurbineConstantTypeKind.INT -> {
-                        val value = (const as Const.IntValue).value()
-                        if (value < 0 || (expr != null && expr.kind() == Tree.Kind.TYPE_CAST))
-                            "0x" + value.toUInt().toString(16) // Hex Value
-                        else value.toString()
-                    }
-                    TurbineConstantTypeKind.SHORT -> {
-                        val value = (const as Const.ShortValue).value()
-                        if (value < 0) "0x" + value.toUInt().toString(16) else value.toString()
-                    }
-                    TurbineConstantTypeKind.FLOAT -> {
-                        val value = (const as Const.FloatValue).value()
-                        when {
-                            value == Float.POSITIVE_INFINITY -> "java.lang.Float.POSITIVE_INFINITY"
-                            value == Float.NEGATIVE_INFINITY -> "java.lang.Float.NEGATIVE_INFINITY"
-                            value < 0 -> value.toString() + "F" // Handling negative values
-                            else -> value.toString() + "f" // Handling positive values
-                        }
-                    }
-                    TurbineConstantTypeKind.DOUBLE -> {
-                        val value = (const as Const.DoubleValue).value()
-                        when {
-                            value == Double.POSITIVE_INFINITY ->
-                                "java.lang.Double.POSITIVE_INFINITY"
-                            value == Double.NEGATIVE_INFINITY ->
-                                "java.lang.Double.NEGATIVE_INFINITY"
-                            else -> const.toString()
-                        }
-                    }
-                    TurbineConstantTypeKind.BYTE -> const.getValue().toString()
-                    else -> const.toString()
-                }
-            }
-            Kind.ARRAY -> {
-                const as ArrayInitValue
-                val values =
-                    if (expr != null)
-                        const.elements().zip((expr as ArrayInit).exprs(), ::TurbineValue)
-                    else const.elements().map { TurbineValue(it, null) }
-                values.joinToString(prefix = "{", postfix = "}") {
-                    it.getSourceForAnnotationValue()
-                }
-            }
-            Kind.ENUM_CONSTANT -> const.underlyingValue.toString()
-            Kind.CLASS_LITERAL -> {
-                expr?.toString() ?: "${const.underlyingValue}.class"
-            }
-            else -> const.toString()
-        }
-    }
-}
+    val fieldResolver: TurbineFieldResolver?,
+)
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineValueFactory.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineValueFactory.kt
new file mode 100644
index 000000000..54a9bbe11
--- /dev/null
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineValueFactory.kt
@@ -0,0 +1,301 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.turbine
+
+import com.android.tools.metalava.model.ArrayTypeItem
+import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.type.ContextNullability
+import com.android.tools.metalava.model.value.ArrayElementValue
+import com.android.tools.metalava.model.value.BaseCachingDeferredTypeValueProvider
+import com.android.tools.metalava.model.value.CachingValueProvider
+import com.android.tools.metalava.model.value.CombinedValueProvider
+import com.android.tools.metalava.model.value.ConstantValue
+import com.android.tools.metalava.model.value.ImplementationValueToModelFactory
+import com.android.tools.metalava.model.value.Value
+import com.android.tools.metalava.model.value.ValueFactory
+import com.android.tools.metalava.model.value.ValueProviderException
+import com.android.tools.metalava.model.value.ValueUseSite
+import com.google.turbine.binder.bound.EnumConstantValue
+import com.google.turbine.binder.bound.TurbineAnnotationValue
+import com.google.turbine.binder.bound.TurbineClassValue
+import com.google.turbine.binder.bound.TypeBoundClass
+import com.google.turbine.model.Const
+import com.google.turbine.model.Const.ArrayInitValue
+import com.google.turbine.model.TurbineConstantTypeKind
+import com.google.turbine.tree.Tree
+import com.google.turbine.tree.Tree.ArrayInit
+import com.google.turbine.tree.Tree.ConstVarName
+import com.google.turbine.tree.Tree.Expression
+
+/**
+ * Factory for creating [Value]s from [TurbineValue]s.
+ *
+ * @param globalContext provides access to some global context needed by this.
+ */
+internal class TurbineValueFactory(globalContext: TurbineGlobalContext) :
+    ValueFactory,
+    ImplementationValueToModelFactory<TurbineValue>,
+    TurbineGlobalContext by globalContext {
+    /**
+     * Get a [CombinedValueProvider] that will create (and cache) a [Value] of [optionalTypeItem]
+     * from [turbineValue].
+     *
+     * @param optionalTypeItem the optional type for the value, e.g. [MethodItem.returnType] (for
+     *   attribute or attribute default values) or [FieldItem.type].
+     * @param turbineValue the underlying Turbine value.
+     * @param valueUseSite the [ValueUseSite] for which this will provide a [Value].
+     */
+    fun providerFor(
+        optionalTypeItem: TypeItem?,
+        turbineValue: TurbineValue,
+        valueUseSite: ValueUseSite,
+    ): CombinedValueProvider =
+        CachingValueProvider(this, optionalTypeItem, turbineValue, valueUseSite)
+
+    /**
+     * Get a [CombinedValueProvider] that will create (and cache) a [Value] for attribute
+     * [attributeName] of [annotationClass] from [turbineValue].
+     *
+     * @param annotationClass the optional [TypeBoundClass].
+     * @param attributeName the name of the attribute whose value it will provide.
+     * @param turbineValue the underlying Turbine value.
+     */
+    fun providerForAnnotationValue(
+        annotationClass: TypeBoundClass?,
+        attributeName: String,
+        turbineValue: TurbineValue
+    ): CombinedValueProvider =
+        if (annotationClass == null) {
+            // If no annotationClass could be found then just use a normal provider with a `null`
+            // optionalTypeItem.
+            providerFor(null, turbineValue, ValueUseSite.ANNOTATION)
+        } else {
+            // Otherwise, create a provider that will get the attribute's type if possible.
+            TurbineCachingAnnotationValueProvider(
+                this,
+                turbineValue,
+                globalTypeItemFactory,
+                annotationClass,
+                attributeName,
+            )
+        }
+
+    override fun implementationValueToModelValue(
+        optionalTypeItem: TypeItem?,
+        implementationValue: TurbineValue,
+        valueUseSite: ValueUseSite,
+    ) = implementationValue.toValue(optionalTypeItem)
+
+    /** Create a [Value] of [optionalTypeItem] from this [TurbineValue]. */
+    private fun TurbineValue.toValue(optionalTypeItem: TypeItem?): Value {
+        if (const is ArrayInitValue) {
+            val arrayTypeItem = optionalTypeItem as ArrayTypeItem
+            val elementTypeItem = arrayTypeItem.componentType
+
+            val elements = const.elements()
+            val exprElements = (expr as? ArrayInit)?.exprs()
+            val turbineValues =
+                elements.mapIndexed { index, element ->
+                    TurbineValue(element, exprElements?.get(index), fieldResolver)
+                }
+
+            val values = turbineValues.map { it.toArrayElementValue(elementTypeItem) }
+
+            // If the source was a single non-array expression of an array type then that needs to
+            // be passed to the `ArrayValue`. Turbine has automatically wrapped that in an
+            // `ArrayInitValue` so check the expression. If the expression was provided (i.e. from
+            // sources not jars) but was not an `ArrayInit` expression (no `exprElements) then it
+            // was unwrapped in the sources, otherwise it was not.
+            val wasUnwrappedInSource = expr != null && exprElements == null
+
+            return createArrayValue(values, wasUnwrappedInSource)
+        }
+
+        return if (optionalTypeItem is ArrayTypeItem) {
+            // The type is an array so this is an example of not having to add curly braces around a
+            // single value in an annotation attribute. Create a value for the component type and
+            // then wrap it in an ArrayValue.
+            val singleValue = toArrayElementValue(optionalTypeItem.componentType)
+            createArrayValue(listOf(singleValue), wasUnwrappedInSource = true)
+        } else {
+            toArrayElementValue(optionalTypeItem)
+        }
+    }
+
+    /** Create an [ArrayElementValue] of [optionalTypeItem] from this [TurbineValue]. */
+    private fun TurbineValue.toArrayElementValue(optionalTypeItem: TypeItem?): ArrayElementValue {
+        when (const.kind()) {
+            Const.Kind.CLASS_LITERAL -> {
+                const as TurbineClassValue
+                // Get the type of the class literal. e.g. if the expression was `X.class` then this
+                // will be of type `X`, or if the expression was of type `X[].class` then this will
+                // be of type `X[]`. `X` may be a primitive type.
+                val classLiteralTypeItem =
+                    globalTypeItemFactory.createType(
+                        const.type(),
+                        isVarArg = false,
+                        ContextNullability.forceNonNull
+                    )
+
+                return createClassObjectValue(
+                    classLiteralTypeItem,
+                    sourceExpression = expr?.toString(),
+                )
+            }
+            Const.Kind.ANNOTATION -> {
+                const as TurbineAnnotationValue
+                val annotation = annotationFactory.createAnnotation(const.info(), fieldResolver)!!
+                return createAnnotationValue(annotation)
+            }
+            Const.Kind.ENUM_CONSTANT -> {
+                const as EnumConstantValue
+                // Create an EnumConstantValue for the underlying Turbine EnumConstantValue.
+                val fieldSymbol = const.sym()
+                return createFieldReferenceValue(
+                    codebase,
+                    fieldSymbol.owner().qualifiedName,
+                    fieldSymbol.name(),
+                )
+            }
+            else -> {}
+        }
+
+        // Check for a field reference if a field resolver is available.
+        if (expr != null && expr is ConstVarName && fieldResolver != null) {
+            val fieldInfo = fieldResolver.resolveField(expr)
+            val fieldSymbol = fieldInfo?.sym()
+            // If the field could be resolved then wrap it around the constant value.
+            if (fieldSymbol != null) {
+                return createFieldReferenceValueWithDeferredConstantValue(
+                    codebase,
+                    fieldSymbol.owner().qualifiedName,
+                    fieldSymbol.name(),
+                    optionalTypeItem,
+                )
+            }
+        }
+
+        return toConstant(optionalTypeItem)
+    }
+
+    /** Create a [ConstantValue] of [optionalTypeItem] from this [TurbineValue]. */
+    private fun TurbineValue.toConstant(optionalTypeItem: TypeItem?): ConstantValue {
+        if (const.kind() == Const.Kind.PRIMITIVE) {
+            val underlyingValue = (const as Const.Value).value
+
+            // If no expr is provided then this comes from a .class file, otherwise it comes from
+            // the source.
+            if (expr == null) {
+                // A .class file stores byte and short constants as ints so convert them back from
+                // the Turbine value (which has been converted to the correct type) to the behavior
+                // relied upon by Psi legacy behavior.
+                val transformedValue =
+                    when (underlyingValue) {
+                        is Byte -> underlyingValue.toInt()
+                        is Short -> underlyingValue.toInt()
+                        else -> underlyingValue
+                    }
+
+                return createLiteralValue(optionalTypeItem, transformedValue)
+            } else {
+                // Check to see if the underlying value has been already been converted from the
+                // source literal type to a type appropriate for where it is being used. If it has
+                // then this undoes the conversion to preserve the information about the source
+                // literal type. That is needed to enable consistent processing with legacy value
+                // handling which often uses the source type directly, e.g. when parsing
+                //     `longValue = 1`
+                // it may write it as
+                //     `longValue = 1`
+                // instead of the more consistent
+                //     `longValue = 1L`.
+                val transformedValue =
+                    when (underlyingValue) {
+                        is Byte,
+                        is Double,
+                        is Float,
+                        is Long,
+                        is Short -> {
+                            when (expr.getLiteralKind()) {
+                                TurbineConstantTypeKind.INT -> {
+                                    (underlyingValue as Number).toInt()
+                                }
+                                TurbineConstantTypeKind.FLOAT -> {
+                                    (underlyingValue as Number).toFloat()
+                                }
+                                else -> underlyingValue
+                            }
+                        }
+                        else -> underlyingValue
+                    }
+
+                // A value is considered non-literal if it was not a literal expression.
+                val nonLiteralInSource = expr !is Tree.Literal
+                return createLiteralValue(optionalTypeItem, transformedValue, nonLiteralInSource)
+            }
+        }
+
+        throw ValueProviderException(
+            "Unknown value '$const' of ${const.javaClass} for type $optionalTypeItem"
+        )
+    }
+
+    /**
+     * Get the literal kind of this expression.
+     *
+     * If this is itself a [Tree.Literal] then return its [Tree.Literal.tykind]. Otherwise, if this
+     * is a [Tree.Unary], e.g. `-<expr>` of `+<expr>`, then it will call this on its
+     * [Tree.Unary.expr].
+     */
+    private fun Expression.getLiteralKind(): TurbineConstantTypeKind? =
+        when (this) {
+            is Tree.Literal -> this.tykind()
+            is Tree.Unary -> expr().getLiteralKind()
+            else -> null
+        }
+}
+
+/**
+ * A [BaseCachingDeferredTypeValueProvider] that is used for annotation attribute values.
+ *
+ * It will attempt to find the [optionalTypeItem] by looking for the attribute method called
+ * [attributeName] in [annotationClass] and if found, converting its return type to a [TypeItem]
+ * using [globalTypeItemFactory].
+ */
+private class TurbineCachingAnnotationValueProvider(
+    factory: ImplementationValueToModelFactory<TurbineValue>,
+    implementationValue: TurbineValue,
+    private val globalTypeItemFactory: TurbineTypeItemFactory,
+    private val annotationClass: TypeBoundClass,
+    private val attributeName: String,
+) :
+    BaseCachingDeferredTypeValueProvider<TurbineValue>(
+        factory,
+        implementationValue,
+        ValueUseSite.ANNOTATION,
+    ) {
+
+    override fun optionalTypeItem() =
+        annotationClass
+            // Try and find the attribute method.
+            .methods()
+            .firstOrNull { it.name() == attributeName }
+            // If found then convert its return type to a TypeItem.
+            ?.returnType()
+            ?.let { type -> globalTypeItemFactory.getGeneralType(type) }
+}
diff --git a/metalava-model-turbine/src/test/resources/model-test-suite-baseline.txt b/metalava-model-turbine/src/test/resources/model-test-suite-baseline.txt
index d025395ee..bd274146f 100644
--- a/metalava-model-turbine/src/test/resources/model-test-suite-baseline.txt
+++ b/metalava-model-turbine/src/test/resources/model-test-suite-baseline.txt
@@ -1,6 +1,5 @@
 com.android.tools.metalava.model.testsuite.annotationitem.CommonAnnotationItemTest
-  annotation toSource() with compound expression values
-  annotation toSource() with constant literal values
+  annotation with unknown field
 
 com.android.tools.metalava.model.testsuite.classitem.CommonDuplicateClassItemTest
   Test duplicate classes
@@ -11,10 +10,6 @@ com.android.tools.metalava.model.testsuite.documentation.CommonParameterizedDocu
 com.android.tools.metalava.model.testsuite.fielditem.CommonFieldItemTest
   Test implicit nullability of constant field initialized from @NonNull method
 
-com.android.tools.metalava.model.testsuite.fielditem.SourceFieldItemTest
-  test default value of an enum constant field
-  test non final field with default value as constant expression
-
 com.android.tools.metalava.model.testsuite.methoditem.CommonParameterItemTest
   Test publicName reports correct name when called on binary class - Object#equals
   Test publicName reports correct name when called on binary class - ViewGroup#onLayout
@@ -29,78 +24,3 @@ com.android.tools.metalava.model.testsuite.typeitem.CommonTypeModifiersTest
   Test interface types
   Test leading annotation on array type
   Test super class and interface types of interface
-
-com.android.tools.metalava.model.testsuite.value.CommonParameterizedAnnotationToSourceValueTest
-  testLegacySource[jar,annotation]
-  testLegacySource[jar,double NaN]
-  testLegacySource[jar,double negative infinity]
-  testLegacySource[jar,double positive infinity]
-  testLegacySource[jar,float NaN]
-  testLegacySource[jar,float negative infinity]
-  testLegacySource[jar,float positive infinity]
-  testLegacySource[source,String using constant]
-  testLegacySource[source,annotation]
-  testLegacySource[source,double NaN]
-  testLegacySource[source,double with int]
-  testLegacySource[source,float NaN]
-  testLegacySource[source,float with int]
-  testLegacySource[source,int positive]
-  testLegacySource[source,long with int]
-
-com.android.tools.metalava.model.testsuite.value.CommonParameterizedAttributeDefaultValueTest
-  testLegacySource[jar,annotation]
-  testLegacySource[jar,double NaN]
-  testLegacySource[jar,double negative infinity]
-  testLegacySource[jar,double positive infinity]
-  testLegacySource[jar,float NaN]
-  testLegacySource[jar,float negative infinity]
-  testLegacySource[jar,float positive infinity]
-  testLegacySource[source,annotation]
-  testLegacySource[source,double with int]
-  testLegacySource[source,float with int]
-  testLegacySource[source,long with int]
-
-com.android.tools.metalava.model.testsuite.value.CommonParameterizedAttributeValueTest
-  testLegacySource[jar,annotation]
-  testLegacySource[jar,char unicode]
-  testLegacySource[jar,double NaN]
-  testLegacySource[jar,double negative infinity]
-  testLegacySource[jar,double positive infinity]
-  testLegacySource[jar,float NaN]
-  testLegacySource[jar,float negative infinity]
-  testLegacySource[jar,float positive infinity]
-  testLegacySource[jar,int negative]
-  testLegacySource[source,String using constant]
-  testLegacySource[source,annotation]
-  testLegacySource[source,double NaN]
-  testLegacySource[source,double negative infinity]
-  testLegacySource[source,double positive infinity]
-  testLegacySource[source,double with exponent]
-  testLegacySource[source,double with int]
-  testLegacySource[source,enum]
-  testLegacySource[source,float NaN]
-  testLegacySource[source,float negative infinity]
-  testLegacySource[source,float positive infinity]
-  testLegacySource[source,float with exponent]
-  testLegacySource[source,float with int]
-  testLegacySource[source,float with upper F]
-  testLegacySource[source,int negative]
-  testLegacySource[source,int positive]
-  testLegacySource[source,long with int]
-  testLegacySource[source,long with lower l]
-
-com.android.tools.metalava.model.testsuite.value.CommonParameterizedFieldValueTest
-  testLegacySource[jar,double NaN]
-  testLegacySource[jar,double negative infinity]
-  testLegacySource[jar,double positive infinity]
-  testLegacySource[jar,float NaN]
-  testLegacySource[jar,float negative infinity]
-  testLegacySource[jar,float positive infinity]
-
-com.android.tools.metalava.model.testsuite.value.CommonParameterizedFieldWriteWithSemicolonValueTest
-  testLegacySource[jar,double NaN]
-  testLegacySource[jar,double negative infinity]
-  testLegacySource[jar,double positive infinity]
-  testLegacySource[jar,float NaN]
-  testLegacySource[jar,float negative infinity]
-  testLegacySource[jar,float positive infinity]
diff --git a/metalava-model/build.gradle.kts b/metalava-model/build.gradle.kts
index bbf427d46..dbe57f9ff 100644
--- a/metalava-model/build.gradle.kts
+++ b/metalava-model/build.gradle.kts
@@ -25,6 +25,7 @@ plugins {
 dependencies {
     implementation(project(":metalava-reporter"))
 
+    testImplementation(project(":metalava-testing"))
     testImplementation(libs.junit4)
     testImplementation(libs.truth)
     testImplementation(libs.kotlinTest)
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/AndroidConstants.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/AndroidConstants.kt
index e3f77dcee..1bc0ba18f 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/AndroidConstants.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/AndroidConstants.kt
@@ -39,6 +39,9 @@ const val ANDROIDX_NULLABLE = "androidx.annotation.Nullable"
 const val RECENTLY_NULLABLE = "androidx.annotation.RecentlyNullable"
 const val RECENTLY_NONNULL = "androidx.annotation.RecentlyNonNull"
 
-const val ANDROID_DEPRECATED_FOR_SDK = "android.annotation.DeprecatedForSdk"
-
 const val ANDROIDX_REQUIRES_PERMISSION = "androidx.annotation.RequiresPermission"
+const val ANDROIDX_REQUIRES_PERMISSION_READ = "androidx.annotation.RequiresPermission.Read"
+const val ANDROIDX_REQUIRES_PERMISSION_WRITE = "androidx.annotation.RequiresPermission.Write"
+
+const val ANDROIDX_INT_RANGE = "androidx.annotation.IntRange"
+const val ANDROIDX_FLOAT_RANGE = "androidx.annotation.FloatRange"
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationItem.kt
index 44677ce55..390a334d7 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationItem.kt
@@ -16,10 +16,19 @@
 
 package com.android.tools.metalava.model
 
+import com.android.tools.metalava.model.annotation.AnnotationDefaults
 import com.android.tools.metalava.model.api.flags.ApiFlag
 import com.android.tools.metalava.model.api.flags.ApiFlags
+import com.android.tools.metalava.model.type.TypeItemParser
+import com.android.tools.metalava.model.value.LegacyValueFormatter.Companion.ANNOTATION_SOURCE_FORMATTER
+import com.android.tools.metalava.model.value.Value
+import com.android.tools.metalava.model.value.ValueLanguage
+import com.android.tools.metalava.model.value.ValueParser
+import com.android.tools.metalava.model.value.ValueProvider
+import com.android.tools.metalava.model.value.ValueStringConfiguration
+import com.android.tools.metalava.model.value.provider
 import com.android.tools.metalava.reporter.FileLocation
-import kotlin.reflect.KClass
+import java.lang.StringBuilder
 
 fun isNullnessAnnotation(qualifiedName: String): Boolean =
     isNullableAnnotation(qualifiedName) || isNonNullAnnotation(qualifiedName)
@@ -72,10 +81,76 @@ sealed interface AnnotationItem {
      */
     val apiFlag: ApiFlag?
 
-    /** Generates source code for this annotation (using fully qualified names) */
+    /**
+     * Append the string representation of this annotation to the [builder] according to
+     * [configuration] and [annotationIsValue].
+     *
+     * If [annotationIsValue] is `true` then this is being written out as a value, i.e. either
+     * nested within another [AnnotationItem] or as [MethodItem.defaultValue]. In that case
+     * [ValueStringConfiguration.valueLanguage] affects the representation of the annotation as
+     * follows:
+     * * Kotlin does not use a leading `@` for annotation values but Java does.
+     * * Parentheses are optional everywhere for an annotation with an empty attributes list except
+     *   when used as a Kotlin annotation value where they are required.
+     *
+     * Otherwise, if [annotationIsValue] is `false` then this uses the [ValueLanguage.JAVA]
+     * representation as that is the same as Kotlin.
+     */
+    fun appendAnnotationStringTo(
+        builder: StringBuilder,
+        configuration: ValueStringConfiguration,
+        annotationIsValue: Boolean,
+    ) {
+        // While top level annotations use the Java syntax for Kotlin and Java, nested annotations
+        // use different syntax for each one.
+        val language = if (annotationIsValue) configuration.valueLanguage else ValueLanguage.JAVA
+        builder.append(language.annotationClassPrefix)
+
+        // Get the annotation class name.
+        val formatName = configuration.annotationQualifiedNameGetter(this)
+        builder.append(formatName)
+
+        if (language.annotationAttributesListRequiresParentheses || attributes.isNotEmpty()) {
+            builder.append("(")
+
+            val nameValueSeparator = configuration.annotationAttributeNameValueSeparator.text
+
+            val singleAttribute = attributes.singleOrNull()
+            if (singleAttribute == null) {
+                var separator = ""
+
+                // Get the attributes in the correct order.
+                val orderedAttributes =
+                    if (configuration.sortAnnotationAttributes) attributes.sortedBy { it.name }
+                    else attributes
+
+                for (attribute in orderedAttributes) {
+                    builder.append(separator)
+                    builder.append(attribute.name).append(nameValueSeparator)
+                    configuration.appendNestedValueTo(builder, attribute.value)
+                    separator = ", "
+                }
+            } else {
+                // A single attribute whose attribute name is "value" can just use the value.
+                val name = singleAttribute.name
+                if (name != ANNOTATION_ATTR_VALUE) {
+                    builder.append(name).append(nameValueSeparator)
+                }
+                configuration.appendNestedValueTo(builder, singleAttribute.value)
+            }
+
+            builder.append(")")
+        }
+    }
+
+    /**
+     * Generates source code for this annotation (using fully qualified names).
+     *
+     * @param target the [AnnotationTarget] for which this is being generated.
+     */
     fun toSource(
         target: AnnotationTarget = AnnotationTarget.SIGNATURE_FILE,
-        showDefaultAttrs: Boolean = true
+        context: Item? = null,
     ): String
 
     /** The applicable targets for this annotation */
@@ -121,10 +196,7 @@ sealed interface AnnotationItem {
     }
 
     /** Returns the given named attribute if specified */
-    fun findAttribute(name: String?): AnnotationAttribute? {
-        val actualName = name ?: ANNOTATION_ATTR_VALUE
-        return attributes.firstOrNull { it.name == actualName }
-    }
+    fun findAttribute(name: String) = attributes.firstOrNull { it.name == name }
 
     /** Find the class declaration for the given annotation */
     fun resolve(): ClassItem?
@@ -185,7 +257,7 @@ sealed interface AnnotationItem {
             val cls = resolve()
             if (cls != null) {
                 if (cls.isAnnotationType()) {
-                    return cls.getRetention()
+                    return cls.annotationClass.retention
                 }
             }
 
@@ -249,171 +321,119 @@ sealed interface AnnotationItem {
                 }
             }
         }
-    }
-}
 
-/** Get the [TypeNullability] from a list of [AnnotationItem]s. */
-val List<AnnotationItem>.typeNullability
-    get() = mapNotNull { it.typeNullability }.firstOrNull()
-
-/**
- * Get the value of the named attribute as an object of the specified type or null if the attribute
- * could not be found.
- *
- * This can only be called for attributes which have a single value, it will throw an exception if
- * called for an attribute whose value is any array type. See [getAttributeValues] instead.
- *
- * This supports the following types for [T]:
- * * [String] - the attribute must be of type [String] or [Class].
- * * [AnnotationItem] - the attribute must be of an annotation type.
- * * [Boolean] - the attribute must be of type [Boolean].
- * * [Byte] - the attribute must be of type [Byte].
- * * [Char] - the attribute must be of type [Char].
- * * [Double] - the attribute must be of type [Double].
- * * [Float] - the attribute must be of type [Float].
- * * [Int] - the attribute must be of type [Int].
- * * [Long] - the attribute must be of type [Long].
- * * [Short] - the attribute must be of type [Short].
- *
- * Any other types will result in a [ClassCastException].
- */
-inline fun <reified T : Any> AnnotationItem.getAttributeValue(name: String): T? {
-    val value = nonInlineGetAttributeValue(T::class, name) ?: return null
-    return value as T
-}
-
-/**
- * Non-inline portion of functionality needed by [getAttributeValue]; separated to reduce the cost
- * of inlining [getAttributeValue].
- */
-@PublishedApi
-internal fun AnnotationItem.nonInlineGetAttributeValue(kClass: KClass<*>, name: String): Any? {
-    val attributeValue = findAttribute(name)?.legacyValue ?: return null
-    val value =
-        when (attributeValue) {
-            is AnnotationArrayAttributeValue ->
-                throw IllegalStateException("Annotation attribute is of type array")
-            else -> attributeValue.value()
+        /** Create an annotation from [source]. */
+        fun createFromSource(
+            annotationContext: AnnotationContext,
+            source: String,
+        ): AnnotationItem? {
+            val valueParser =
+                ValueParser(
+                    annotationContext,
+                    TypeItemParser.forValueParser(annotationContext),
+                )
+            return valueParser.parseAnnotationItem(source)
         }
-            ?: return null
-
-    return convertValue(annotationContext, kClass, value)
-}
-
-/**
- * Get the values of the named attribute as a list of objects of the specified type or null if the
- * attribute could not be found.
- *
- * This can be used to get the value of an attribute that is either one of the types in
- * [getAttributeValue] (in which case this returns a list containing a single item), or an array of
- * one of the types in [getAttributeValue] (in which case this returns a list containing all the
- * items in the array).
- */
-inline fun <reified T : Any> AnnotationItem.getAttributeValues(name: String): List<T>? {
-    return nonInlineGetAttributeValues(T::class, name) { it as T }
-}
 
-/**
- * Non-inline portion of functionality needed by [getAttributeValues]; separated to reduce the cost
- * of inlining [getAttributeValues].
- */
-@PublishedApi
-internal fun <T : Any> AnnotationItem.nonInlineGetAttributeValues(
-    kClass: KClass<*>,
-    name: String,
-    caster: (Any) -> T
-): List<T>? {
-    val attributeValue = findAttribute(name)?.legacyValue ?: return null
-    val values =
-        when (attributeValue) {
-            is AnnotationArrayAttributeValue -> attributeValue.values.mapNotNull { it.value() }
-            else -> listOfNotNull(attributeValue.value())
+        /**
+         * Create a [DefaultAnnotationItem] deferring the creation of the attributes until needed.
+         *
+         * Maps the [originalName] to a [qualifiedName] by using the [annotationContext]'s
+         * [AnnotationManager.normalizeInputName].
+         */
+        fun createAttributesLazily(
+            annotationContext: AnnotationContext,
+            fileLocation: FileLocation,
+            originalName: String,
+            attributesGetter: () -> List<AnnotationAttribute>,
+        ): AnnotationItem? {
+            val qualifiedName =
+                annotationContext.annotationManager.normalizeInputName(originalName) ?: return null
+            return DefaultAnnotationItem(
+                annotationContext = annotationContext,
+                fileLocation = fileLocation,
+                originalName = originalName,
+                qualifiedName = qualifiedName,
+                attributesGetter = attributesGetter,
+            )
         }
 
-    return values.mapNotNull { convertValue(annotationContext, kClass, it) }.map { caster(it) }
-}
-
-/**
- * Perform some conversions to try and make [value] to be an instance of [kClass].
- *
- * This fixes up some known issues with [value] not corresponding to the expected type but otherwise
- * simply returns the value it is given. It is the caller's responsibility to actually cast the
- * returned value to the correct type.
- */
-private fun convertValue(
-    annotationContext: AnnotationContext,
-    kClass: KClass<*>,
-    value: Any
-): Any? {
-    // The value stored for number types is not always the same as the type of the annotation
-    // attributes. This is for a number of reasons, e.g.
-    // * In a .class file annotation values are stored in the constant pool and some number types do
-    //   not have their own constant form (or their own array constant form) so are stored as
-    //   instances of a wider type. They need to be converted to the correct type.
-    // * In signature files annotation values are not always stored as the narrowest type, may not
-    //   have a suffix and type information may not always be available when parsing.
-    if (Number::class.java.isAssignableFrom(kClass.java)) {
-        value as Number
-        return when (kClass) {
-            // Byte does have its own constant form but when stored in an array it is stored as an
-            // int.
-            Byte::class -> value.toByte()
-            // DefaultAnnotationValue.create() always reads integers as longs.
-            Int::class -> value.toInt()
-            // DefaultAnnotationValue.create() always reads floating point as doubles.
-            Float::class -> value.toFloat()
-            // Short does not have its own constant form.
-            Short::class -> value.toShort()
-            else -> value
+        /**
+         * Create a [DefaultAnnotationItem] with [attributes].
+         *
+         * Maps the [originalName] to a [qualifiedName] by using the [annotationContext]'s
+         * [AnnotationManager.normalizeInputName].
+         */
+        fun createWithAttributes(
+            annotationContext: AnnotationContext,
+            fileLocation: FileLocation,
+            originalName: String,
+            attributes: List<AnnotationAttribute>,
+        ): AnnotationItem? {
+            return createAttributesLazily(annotationContext, fileLocation, originalName) {
+                attributes
+            }
         }
     }
-
-    // TODO: Push down into the model as that is likely to be more efficient.
-    if (kClass == AnnotationItem::class) {
-        return DefaultAnnotationItem.create(annotationContext, value as String)
-    }
-
-    return value
 }
 
+/** Get the [TypeNullability] from a list of [AnnotationItem]s. */
+val List<AnnotationItem>.typeNullability
+    get() = mapNotNull { it.typeNullability }.firstOrNull()
+
 /** Provides contextual information needed by [AnnotationItem]s. */
 interface AnnotationContext : ClassResolver {
     /** The manager of annotations within this context. */
     val annotationManager: AnnotationManager
 
     /**
-     * Creates an annotation item for the given (fully qualified) Java source.
+     * Get the defaults for the annotation class called [qualifiedName].
      *
-     * Returns `null` if the source contains an annotation that is not recognized by Metalava.
+     * While the default implementation is in terms of [resolveClass] this is separate to allow
+     * subclasses to provide defaults without resolving a [ClassItem] as that can have side effects
+     * which cause problems if done during [Codebase] construction.
      */
-    fun createAnnotation(
-        source: String,
-        context: Item? = null,
-    ): AnnotationItem?
+    fun defaultsForAnnotationClass(qualifiedName: String) =
+        resolveClass(qualifiedName)?.annotationClass?.defaults ?: AnnotationDefaults.EMPTY
+
+    companion object {
+        /**
+         * Instance that can be used in contexts where [resolveClass] always returns null, e.g.
+         * testing or when parsing annotations provides on the command line.
+         */
+        val DEFAULT_RESOLVE_NULL: AnnotationContext =
+            object : AnnotationContext, ClassResolver by ClassResolver.RETURN_NULL {
+                /**
+                 * Return [noOpAnnotationManager] rather than just throwing an exception as most
+                 * uses of [AnnotationItem]s will make at least one call to [annotationManager] and
+                 * having it return a valid, but basic implementation makes this more useful.
+                 */
+                override val annotationManager
+                    get() = noOpAnnotationManager
+            }
+    }
 }
 
 /** Default implementation of an annotation item */
-open class DefaultAnnotationItem
-/** The primary constructor is private to force subclasses to use the secondary constructor. */
-protected constructor(
+internal class DefaultAnnotationItem(
     override val annotationContext: AnnotationContext,
     override val fileLocation: FileLocation,
 
     /** Fully qualified name of the annotation (prior to name mapping) */
-    protected val originalName: String,
+    private val originalName: String,
 
     /** Fully qualified name of the annotation (after name mapping) */
-    final override val qualifiedName: String,
+    override val qualifiedName: String,
 
     /** Possibly empty list of attributes. */
-    attributesGetter: (AnnotationItem) -> List<AnnotationAttribute>,
+    attributesGetter: () -> List<AnnotationAttribute>,
 ) : AnnotationItem {
 
     override val targets
         get() = info.targets
 
-    final override val attributes: List<AnnotationAttribute> by
-        lazy(LazyThreadSafetyMode.NONE) { attributesGetter(this) }
+    override val attributes: List<AnnotationAttribute> by
+        lazy(LazyThreadSafetyMode.NONE, attributesGetter)
 
     /** Information that metalava has gathered about this annotation item. */
     internal val info: AnnotationInfo by lazy {
@@ -475,7 +495,22 @@ protected constructor(
             originalName,
             qualifiedName,
         ) {
-            attributes.map { DefaultAnnotationAttribute(it.name, it.legacyValue.snapshot()) }
+            attributes.map { attributeToSnapshot ->
+                // Defer retrieval of the value until it is needed as it could throw an exception.
+                // This makes it easier to incrementally expand the Value model without breaking
+                // existing snapshot tests.
+                // TODO(b/354633349): Stop deferring retrieval.
+                val valueProvider =
+                    object : ValueProvider {
+                        override val value: Value
+                            get() = attributeToSnapshot.value.snapshot(targetCodebase)
+                    }
+
+                AnnotationAttribute.createLazyAttribute(
+                    attributeToSnapshot.name,
+                    valueProvider,
+                )
+            }
         }
     }
 
@@ -490,94 +525,17 @@ protected constructor(
         return result
     }
 
-    override fun toSource(target: AnnotationTarget, showDefaultAttrs: Boolean): String {
-        val qualifiedName =
-            annotationContext.annotationManager.normalizeOutputName(qualifiedName, target)
-                ?: return ""
-
-        return formatAnnotationItem(qualifiedName, attributes)
+    override fun toSource(target: AnnotationTarget, context: Item?): String {
+        return ANNOTATION_SOURCE_FORMATTER.annotationItemToSource(this, target, context)
     }
 
-    final override fun toString() = toSource()
-
-    companion object {
-        fun formatAnnotationItem(
-            qualifiedName: String,
-            attributes: List<AnnotationAttribute>,
-        ): String {
-            return buildString {
-                append("@")
-                append(qualifiedName)
-                if (attributes.isNotEmpty()) {
-                    val suppressDefaultAnnotationAttribute = attributes.size == 1
-                    append("(")
-                    attributes.forEachIndexed { i, attribute ->
-                        if (i != 0) {
-                            append(", ")
-                        }
-                        if (
-                            !suppressDefaultAnnotationAttribute ||
-                                attribute.name != ANNOTATION_ATTR_VALUE
-                        ) {
-                            append(attribute.name)
-                            append("=")
-                        }
-                        append(attribute.legacyValue)
-                    }
-                    append(")")
-                }
-            }
-        }
-
-        fun create(annotationContext: AnnotationContext, source: String): AnnotationItem? {
-            val index = source.indexOf("(")
-            val originalName =
-                if (index == -1) source.substring(1) // Strip @
-                else source.substring(1, index)
-
-            @Suppress("UNUSED_PARAMETER")
-            fun attributes(annotationItem: AnnotationItem): List<AnnotationAttribute> =
-                if (index == -1) {
-                    emptyList()
-                } else {
-                    DefaultAnnotationAttribute.createList(
-                        source.substring(index + 1, source.lastIndexOf(')'))
-                    )
-                }
-
-            return create(annotationContext, FileLocation.UNKNOWN, originalName, ::attributes)
-        }
-
-        fun create(
-            annotationContext: AnnotationContext,
-            originalName: String,
-            attributes: List<AnnotationAttribute> = emptyList(),
-            context: Item? = null
-        ): AnnotationItem? {
-            val source = formatAnnotationItem(originalName, attributes)
-            return annotationContext.createAnnotation(source, context)
-        }
-
-        /**
-         * Create a [DefaultAnnotationItem] by mapping the [originalName] to a [qualifiedName] by
-         * using the [annotationContext]'s [AnnotationManager.normalizeInputName].
-         */
-        fun create(
-            annotationContext: AnnotationContext,
-            fileLocation: FileLocation,
-            originalName: String,
-            attributesGetter: (AnnotationItem) -> List<AnnotationAttribute>,
-        ): AnnotationItem? {
-            val qualifiedName =
-                annotationContext.annotationManager.normalizeInputName(originalName) ?: return null
-            return DefaultAnnotationItem(
-                annotationContext = annotationContext,
-                fileLocation = fileLocation,
-                originalName = originalName,
-                qualifiedName = qualifiedName,
-                attributesGetter = attributesGetter,
-            )
-        }
+    override fun toString() = buildString {
+        appendAnnotationStringTo(
+            this,
+            ValueStringConfiguration.DEFAULT,
+            // This method is never used for values.
+            annotationIsValue = false,
+        )
     }
 }
 
@@ -590,287 +548,50 @@ sealed interface AnnotationAttribute {
     val name: String
 
     /**
-     * The legacy annotation value.
+     * The value of this attribute.
      *
-     * This is called `legacy` because this an old, inconsistent representation of an attribute
-     * value that exposes implementation details. It will be replaced by a properly modelled value
-     * representation.
+     * The [Value] will be suitable for use as an annotation attribute value as specified by JLS
+     * 9.6.1 (what this model calls "attributes", the JSL calls "elements"). That includes constant
+     * fields.
      */
-    val legacyValue: AnnotationAttributeValue
-
-    /**
-     * Return all leaf values; this flattens the complication of handling
-     * {@code @SuppressLint("warning")} and {@code @SuppressLint({"warning1","warning2"})
-     */
-    fun leafValues(): List<AnnotationAttributeValue> {
-        val result = mutableListOf<AnnotationAttributeValue>()
-        AnnotationAttributeValue.addValues(legacyValue, result)
-        return result
-    }
-}
-
-const val ANNOTATION_VALUE_FALSE = "false"
-const val ANNOTATION_VALUE_TRUE = "true"
-
-/** An annotation value */
-sealed interface AnnotationAttributeValue {
-    /** Generates source code for this annotation value */
-    fun toSource(): String
-
-    /** The value of the annotation */
-    fun value(): Any?
-
-    /**
-     * If the annotation declaration references a field (or class etc.), return the resolved class
-     */
-    fun resolve(): Item?
-
-    /**
-     * Take a snapshot of this [AnnotationAttributeValue] suitable for use in a snapshot [Codebase].
-     */
-    fun snapshot(): AnnotationAttributeValue
+    val value: Value
 
     companion object {
-        fun addValues(
-            value: AnnotationAttributeValue,
-            into: MutableList<AnnotationAttributeValue>
-        ) {
-            if (value is AnnotationArrayAttributeValue) {
-                for (v in value.values) {
-                    addValues(v, into)
-                }
-            } else if (value is AnnotationSingleAttributeValue) {
-                into.add(value)
-            }
-        }
-    }
-}
-
-/** An annotation value (for a single item, not an array) */
-sealed interface AnnotationSingleAttributeValue : AnnotationAttributeValue {
-    val value: Any?
-
-    override fun value() = value
-}
-
-/** An annotation value for an array of items */
-sealed interface AnnotationArrayAttributeValue : AnnotationAttributeValue {
-    /** The annotation values */
-    val values: List<AnnotationAttributeValue>
+        /**
+         * Create an [AnnotationAttribute] called [name] that will retrieve its [Value] from
+         * [valueProvider] when requested.
+         */
+        fun createLazyAttribute(name: String, valueProvider: ValueProvider): AnnotationAttribute =
+            DefaultAnnotationAttribute(name, valueProvider)
 
-    override fun resolve(): Item? {
-        error("resolve() should not be called on an array value")
+        /** Create an [AnnotationAttribute] called [name] with [value]. */
+        fun createAttribute(name: String, value: Value): AnnotationAttribute =
+            DefaultAnnotationAttribute(name, value.provider())
     }
-
-    override fun value() = values.mapNotNull { it.value() }.toTypedArray()
 }
 
-class DefaultAnnotationAttribute(
+const val ANNOTATION_VALUE_TRUE = "true"
+
+internal class DefaultAnnotationAttribute(
     override val name: String,
-    override val legacyValue: AnnotationAttributeValue
+    private val valueProvider: ValueProvider,
 ) : AnnotationAttribute {
-    companion object {
-        fun create(name: String, value: String): DefaultAnnotationAttribute {
-            return DefaultAnnotationAttribute(name, DefaultAnnotationValue.create(value))
-        }
 
-        fun createList(source: String): List<AnnotationAttribute> {
-            val list = mutableListOf<AnnotationAttribute>() // TODO: default size = 2
-            var begin = 0
-            var index = 0
-            val length = source.length
-            while (index < length) {
-                val c = source[index]
-                if (c == '{') {
-                    index = findEnd(source, index + 1, length, '}')
-                } else if (c == '"') {
-                    index = findEnd(source, index + 1, length, '"')
-                } else if (c == ',') {
-                    addAttribute(list, source, begin, index)
-                    index++
-                    begin = index
-                    continue
-                } else if (c == ' ' && index == begin) {
-                    begin++
-                }
-
-                index++
-            }
-
-            if (begin < length) {
-                addAttribute(list, source, begin, length)
-            }
-
-            return list
-        }
-
-        private fun findEnd(source: String, from: Int, to: Int, sentinel: Char): Int {
-            var i = from
-            while (i < to) {
-                val c = source[i]
-                if (c == '\\') {
-                    i++
-                } else if (c == sentinel) {
-                    return i
-                }
-                i++
-            }
-            return to
-        }
-
-        private fun addAttribute(
-            list: MutableList<AnnotationAttribute>,
-            source: String,
-            from: Int,
-            to: Int
-        ) {
-            var split = source.indexOf('=', from)
-            if (split >= to) {
-                split = -1
-            }
-            val name: String
-            val value: String
-            val valueBegin: Int
-            val valueEnd: Int
-            if (split == -1) {
-                valueBegin = from
-                valueEnd = to
-                name = "value"
-            } else {
-                name = source.substring(from, split).trim()
-                valueBegin = split + 1
-                valueEnd = to
-            }
-            value = source.substring(valueBegin, valueEnd).trim()
-            if (!value.isEmpty()) {
-                list.add(create(name, value))
-            }
-        }
-    }
+    override val value: Value
+        get() = valueProvider.value
 
     override fun toString(): String {
-        return "$name=$legacyValue"
+        return "$name=${value.toValueString()}"
     }
 
     override fun equals(other: Any?): Boolean {
         if (other !is AnnotationAttribute) return false
-        return name == other.name && legacyValue == other.legacyValue
+        return name == other.name && value == other.value
     }
 
     override fun hashCode(): Int {
         var result = name.hashCode()
-        result = 31 * result + legacyValue.hashCode()
+        result = 31 * result + value.hashCode()
         return result
     }
 }
-
-abstract class DefaultAnnotationValue(sourceGetter: () -> String) : AnnotationAttributeValue {
-    companion object {
-        fun create(valueSource: String): DefaultAnnotationValue {
-            return if (valueSource.startsWith("{")) { // Array
-                DefaultAnnotationArrayAttributeValue(
-                    { valueSource },
-                    {
-                        assert(valueSource.startsWith("{") && valueSource.endsWith("}")) {
-                            valueSource
-                        }
-                        valueSource
-                            .substring(1, valueSource.length - 1)
-                            .split(",")
-                            .map { create(it.trim()) }
-                            .toList()
-                    },
-                )
-            } else {
-                DefaultAnnotationSingleAttributeValue(
-                    { valueSource },
-                    {
-                        when {
-                            valueSource == ANNOTATION_VALUE_TRUE -> true
-                            valueSource == ANNOTATION_VALUE_FALSE -> false
-                            valueSource.startsWith("\"") -> valueSource.removeSurrounding("\"")
-                            valueSource.startsWith('\'') -> valueSource.removeSurrounding("'")[0]
-                            else ->
-                                try {
-                                    if (valueSource.contains(".")) {
-                                        valueSource.toDouble()
-                                    } else {
-                                        valueSource.toLong()
-                                    }
-                                } catch (e: NumberFormatException) {
-                                    valueSource
-                                }
-                        }
-                    },
-                )
-            }
-        }
-    }
-
-    /** The annotation value, expressed as source code */
-    private val valueSource: String by lazy(LazyThreadSafetyMode.NONE, sourceGetter)
-
-    override fun toSource() = valueSource
-
-    override fun toString(): String = toSource()
-}
-
-open class DefaultAnnotationSingleAttributeValue(
-    sourceGetter: () -> String,
-    valueGetter: () -> Any?
-) : DefaultAnnotationValue(sourceGetter), AnnotationSingleAttributeValue {
-
-    override val value by lazy(LazyThreadSafetyMode.NONE, valueGetter)
-
-    override fun resolve(): Item? = null
-
-    override fun snapshot(): AnnotationSingleAttributeValue {
-        // Take a snapshot of the value and sources by immediately forcing them to be initialized
-        // from their respective getters. That way there will be no connection to the original
-        // attribute value.
-        val newValue = value
-        val newSource = toSource()
-        return DefaultAnnotationSingleAttributeValue(
-            sourceGetter = { newSource },
-            valueGetter = { newValue },
-        )
-    }
-
-    override fun equals(other: Any?): Boolean {
-        if (other !is AnnotationSingleAttributeValue) return false
-        return value == other.value
-    }
-
-    override fun hashCode(): Int {
-        return value.hashCode()
-    }
-}
-
-class DefaultAnnotationArrayAttributeValue(
-    sourceGetter: () -> String,
-    valuesGetter: () -> List<AnnotationAttributeValue>
-) : DefaultAnnotationValue(sourceGetter), AnnotationArrayAttributeValue {
-
-    override val values by lazy(LazyThreadSafetyMode.NONE, valuesGetter)
-
-    override fun snapshot(): AnnotationArrayAttributeValue {
-        // Take a snapshot of the values and sources by immediately forcing them to be initialized
-        // from their respective getters. That way there will be no connection to the original
-        // attribute value.
-        val newValues = values.map { it.snapshot() }
-        val newSource = toSource()
-        return DefaultAnnotationArrayAttributeValue(
-            sourceGetter = { newSource },
-            valuesGetter = { newValues },
-        )
-    }
-
-    override fun equals(other: Any?): Boolean {
-        if (other !is AnnotationArrayAttributeValue) return false
-        return values == other.values
-    }
-
-    override fun hashCode(): Int {
-        return values.hashCode()
-    }
-}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationManager.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationManager.kt
index 40007b4f0..e0f8fb1fc 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationManager.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationManager.kt
@@ -27,16 +27,15 @@ interface AnnotationManager {
      *
      * Annotations that should not be used internally are mapped to null.
      */
-    fun normalizeInputName(qualifiedName: String?): String?
+    fun normalizeInputName(qualifiedName: String): String?
 
     /**
      * Maps an annotation name to the name to be used in signatures/stubs/external annotation files.
-     * Annotations that should not be exported are mapped to null.
      */
     fun normalizeOutputName(
-        qualifiedName: String?,
+        qualifiedName: String,
         target: AnnotationTarget = AnnotationTarget.SIGNATURE_FILE
-    ): String?
+    ): String
 
     /** Returns true if [annotationName] is the name of one of the show annotations. */
     fun isShowAnnotationName(annotationName: String): Boolean = false
@@ -150,11 +149,11 @@ internal class NoOpAnnotationManager : BaseAnnotationManager() {
         return NoOpAnnotationInfo(annotationItem.qualifiedName)
     }
 
-    override fun normalizeInputName(qualifiedName: String?): String? {
+    override fun normalizeInputName(qualifiedName: String): String {
         return qualifiedName
     }
 
-    override fun normalizeOutputName(qualifiedName: String?, target: AnnotationTarget): String? {
+    override fun normalizeOutputName(qualifiedName: String, target: AnnotationTarget): String {
         return qualifiedName
     }
 
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/CallableItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/CallableItem.kt
index db31e6476..bee490cfe 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/CallableItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/CallableItem.kt
@@ -236,6 +236,34 @@ interface CallableItem : MemberItem, TypeParameterListOwner {
         }
     }
 
+    /**
+     * Like [CallableItem.internalName] but is the desc-portion of the internal signature, e.g. for
+     * the method "void create(int x, int y)" the internal name of the constructor is "create" and
+     * the desc is "(II)V"
+     */
+    fun internalDesc(voidConstructorTypes: Boolean = false): String {
+        val sb = StringBuilder()
+        sb.append("(")
+
+        // Inner, i.e. non-static nested, classes get an implicit constructor parameter for the
+        // outer type
+        if (
+            isConstructor() &&
+                containingClass().containingClass() != null &&
+                !containingClass().modifiers.isStatic()
+        ) {
+            sb.append(containingClass().containingClass()?.type()?.internalName() ?: "")
+        }
+
+        for (parameter in parameters()) {
+            sb.append(parameter.type().internalName())
+        }
+
+        sb.append(")")
+        sb.append(if (voidConstructorTypes && isConstructor()) "V" else returnType().internalName())
+        return sb.toString()
+    }
+
     companion object {
         private fun compareCallables(
             o1: CallableItem,
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ClassItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/ClassItem.kt
index 732d4b155..30d43b3c5 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/ClassItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/ClassItem.kt
@@ -16,6 +16,8 @@
 
 package com.android.tools.metalava.model
 
+import com.android.tools.metalava.model.annotation.AnnotationClass
+
 /**
  * Represents a {@link https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html Class}
  *
@@ -253,22 +255,6 @@ interface ClassItem : ClassContentItem, SelectableItem, TypeParameterListOwner {
     override fun toStringForItem() = "class ${qualifiedName()}"
 
     companion object {
-        /** Looks up the retention policy for the given class */
-        fun findRetention(cls: ClassItem): AnnotationRetention {
-            val modifiers = cls.modifiers
-            val annotation = modifiers.findAnnotation(AnnotationItem::isRetention)
-            val value = annotation?.findAttribute(ANNOTATION_ATTR_VALUE)
-            val source = value?.legacyValue?.toSource()
-            return when {
-                source == null -> AnnotationRetention.getDefault(cls)
-                source.contains("CLASS") -> AnnotationRetention.CLASS
-                source.contains("RUNTIME") -> AnnotationRetention.RUNTIME
-                source.contains("SOURCE") -> AnnotationRetention.SOURCE
-                source.contains("BINARY") -> AnnotationRetention.BINARY
-                else -> AnnotationRetention.getDefault(cls)
-            }
-        }
-
         // Same as doclava1 (modulo the new handling when class names match)
         val comparator: Comparator<in ClassItem> = Comparator { o1, o2 ->
             val delta = o1.fullName().compareTo(o2.fullName())
@@ -453,8 +439,12 @@ interface ClassItem : ClassContentItem, SelectableItem, TypeParameterListOwner {
     /** Returns the corresponding source file, if any */
     fun sourceFile(): SourceFile?
 
-    /** If this class is an annotation type, returns the retention of this class */
-    fun getRetention(): AnnotationRetention
+    /**
+     * Get the [AnnotationClass] for this class.
+     *
+     * This must only be called when [ClassItem.classKind] is [ClassKind.ANNOTATION_TYPE].
+     */
+    val annotationClass: AnnotationClass
 
     /**
      * Return superclass matching the given predicate. When a superclass doesn't match, we'll keep
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ClassKind.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/ClassKind.kt
index db9aaa06c..70bef7377 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/ClassKind.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/ClassKind.kt
@@ -20,17 +20,30 @@ package com.android.tools.metalava.model
  * The kind of class.
  *
  * Corresponds to similarly named values in [javax.lang.model.element.ElementKind].
+ *
+ * @param supportsInitializerBlock `true` if the class kind supports initializer blocks, e.g. `{
+ *   field = 0; }` or `static { FIELD = 0; }`.
  */
-enum class ClassKind {
+enum class ClassKind(
+    val supportsInitializerBlock: Boolean,
+) {
     /** An interface. */
-    INTERFACE,
+    INTERFACE(
+        supportsInitializerBlock = false,
+    ),
 
     /** An enum class. */
-    ENUM,
+    ENUM(
+        supportsInitializerBlock = true,
+    ),
 
     /** An annotation class. */
-    ANNOTATION_TYPE,
+    ANNOTATION_TYPE(
+        supportsInitializerBlock = false,
+    ),
 
     /** A normal class. */
-    CLASS
+    CLASS(
+        supportsInitializerBlock = true,
+    ),
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ClassResolver.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/ClassResolver.kt
index d5557bd87..14c80b248 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/ClassResolver.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/ClassResolver.kt
@@ -19,4 +19,28 @@ package com.android.tools.metalava.model
 /** Resolves an erased class name to a [ClassItem] or null if it cannot find a matching class. */
 interface ClassResolver {
     fun resolveClass(erasedName: String): ClassItem?
+
+    companion object {
+        /**
+         * A [ClassResolver] that will throw an exception when [resolveClass] is called.
+         *
+         * Useful for testing and when a [resolveClass] will not be called.
+         */
+        val THROWING =
+            object : ClassResolver {
+                override fun resolveClass(erasedName: String): ClassItem? {
+                    error("Unsupported: Cannot resolve $erasedName")
+                }
+            }
+
+        /**
+         * A [ClassResolver] that will return `null` when [resolveClass] is called.
+         *
+         * Useful for testing when [resolveClass] will be called but should return `null`.
+         */
+        val RETURN_NULL =
+            object : ClassResolver {
+                override fun resolveClass(erasedName: String) = null
+            }
+    }
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/Codebase.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/Codebase.kt
index ad9d323aa..d3d4a368b 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/Codebase.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/Codebase.kt
@@ -102,6 +102,45 @@ interface Codebase : ClassResolver, AnnotationContext {
         visitor.visit(this)
     }
 
+    /**
+     * Creates an annotation item for the given (fully qualified) Java source.
+     *
+     * Returns `null` if the source contains an annotation that is not recognized by Metalava.
+     */
+    fun createAnnotation(
+        source: String,
+        context: Item? = null,
+    ): AnnotationItem?
+
+    /**
+     * Create an [AnnotationItem] appropriate for this [Codebase] from the [attributes] by creating
+     * a source representation of the annotation and the calling [createAnnotation].
+     */
+    fun createAnnotationFromAttributes(
+        originalName: String,
+        attributes: List<Pair<String, String>> = emptyList(),
+        context: Item? = null,
+    ): AnnotationItem? {
+        val source = buildString {
+            append("@")
+            append(originalName)
+            if (attributes.isNotEmpty()) {
+                append("(")
+                attributes.forEachIndexed { i, attribute ->
+                    if (i != 0) {
+                        append(", ")
+                    }
+                    append(attribute.first)
+                    append("=")
+                    append(attribute.second)
+                }
+                append(")")
+            }
+        }
+
+        return createAnnotation(source, context)
+    }
+
     /** Reports that the given operation is unsupported for this codebase type */
     fun unsupported(desc: String? = null): Nothing {
         error(
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/DefaultModifierList.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/DefaultModifierList.kt
index f2b74aa77..cfcc97dff 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/DefaultModifierList.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/DefaultModifierList.kt
@@ -45,6 +45,9 @@ import com.android.tools.metalava.model.ModifierFlags.Companion.VARARG
 import com.android.tools.metalava.model.ModifierFlags.Companion.VISIBILITY_LEVEL_ENUMS
 import com.android.tools.metalava.model.ModifierFlags.Companion.VISIBILITY_MASK
 import com.android.tools.metalava.model.ModifierFlags.Companion.VOLATILE
+import com.android.tools.metalava.model.value.FieldReferenceValue
+import com.android.tools.metalava.model.value.Value
+import com.android.tools.metalava.model.value.asInt
 import java.lang.annotation.Retention
 import java.lang.annotation.RetentionPolicy
 
@@ -444,6 +447,10 @@ internal class DefaultMutableModifierList(
         set(ACTUAL, actual)
     }
 
+    override fun setConst(const: Boolean) {
+        set(CONST, const)
+    }
+
     override fun mutateAnnotations(mutator: MutableList<AnnotationItem>.() -> Unit) {
         val mutable = annotations.toMutableList()
         mutable.mutator()
@@ -544,10 +551,18 @@ fun createMutableModifiers(
  * @param otherwiseValue the value of the `otherwise` attribute, or `""` if no attribute is
  *   provided.
  */
-private fun useVisibilityFromVisibleForTesting(otherwiseValue: String, flags: Int): Int {
+private fun useVisibilityFromVisibleForTesting(otherwiseValue: Value, flags: Int): Int {
     /** Check to see if this matches [visibility] or numeric [value]. */
-    fun String.matchesVisibility(visibility: String, value: Int) =
-        endsWith(visibility) || equals(value.toString())
+    fun Value.matchesVisibility(visibility: String, value: Int) =
+        // If it is a field then check the name, otherwise check to see if the numeric value
+        // matches. Do not call asInt() on FieldReferenceValue as that would cause the field to be
+        // resolved which could cause problems as this is called during Codebase construction. It
+        // does mean that if a custom constant field was used instead of one of the ones from
+        // VisibleForTesting.Companion then it might not work as expected. However, that would be
+        // confusing having `@VisibleForTesting(otherwise = CUSTOM_FIELD)`. If supporting that was
+        // required then the processing of @VisibleForTesting would have to be done AFTER codebase
+        // creation.
+        if (this is FieldReferenceValue) fieldName == visibility else asInt() == value
 
     val visibilityFlags =
         when {
@@ -584,12 +599,10 @@ fun createMutableModifiers(
         annotations
             .find { it.qualifiedName == ANDROIDX_VISIBLE_FOR_TESTING }
             ?.let { visibleForTesting ->
-                visibleForTesting.findAttribute(ATTR_OTHERWISE)?.legacyValue?.let { otherwiseValue
-                    ->
-                    useVisibilityFromVisibleForTesting(otherwiseValue.toSource(), flags)
+                visibleForTesting.findAttribute(ATTR_OTHERWISE)?.value?.let { otherwiseValue ->
+                    useVisibilityFromVisibleForTesting(otherwiseValue, flags)
                 }
-            }
-            ?: flags
+            } ?: flags
 
     return DefaultMutableModifierList(actualFlags, annotations)
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/FieldItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/FieldItem.kt
index 578f7bf7a..127c57740 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/FieldItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/FieldItem.kt
@@ -16,7 +16,8 @@
 
 package com.android.tools.metalava.model
 
-import com.android.tools.metalava.model.item.FieldValue
+import com.android.tools.metalava.model.value.ConstantValue
+import com.android.tools.metalava.model.value.asAny
 import java.io.PrintWriter
 
 @MetalavaApi
@@ -35,23 +36,16 @@ interface FieldItem : MemberItem, InheritableItem {
     ) = containingClass().findCorrespondingItemIn(codebase)?.findField(name())
 
     /**
-     * The optional value of this [FieldItem].
+     * The optional constant value of the field.
      *
-     * This is called `legacy` because this an old, inconsistent representation of the field value
-     * that exposes implementation details. It will be replaced by a properly modelled value
-     * representation.
-     */
-    val legacyFieldValue: FieldValue?
-
-    /**
-     * The legacy initial/constant value, if any. If [requireConstant] the initial value will only
-     * be returned if it's constant.
+     * This is the [constantValue] provided in the source or in the jar and will be part of the API
+     * if the [FieldItem] is.
      *
-     * This is called `legacy` because this an old, inconsistent representation of the field value
-     * that exposes implementation details. It will be replaced by a properly modelled value
-     * representation.
+     * The [ConstantValue] is the result of a constant expression as defined by JLS 15.28, i.e. a
+     * value of a primitive or [String] type (see [ConstantValue]) on a field which is `static` and
+     * `final`.
      */
-    fun legacyInitialValue(requireConstant: Boolean = true): Any?
+    val constantValue: ConstantValue?
 
     /**
      * An enum can contain both enum constants and fields; this method provides a way to distinguish
@@ -89,9 +83,9 @@ interface FieldItem : MemberItem, InheritableItem {
      * Check the declared value with a typed comparison, not a string comparison, to accommodate
      * toolchains with different fp -> string conversions.
      */
-    fun hasSameValue(other: FieldItem): Boolean {
-        val thisConstant = legacyInitialValue()
-        val otherConstant = other.legacyInitialValue()
+    fun hasSameConstantValue(other: FieldItem): Boolean {
+        val thisConstant = constantValue
+        val otherConstant = other.constantValue
         if (thisConstant == null != (otherConstant == null)) {
             return false
         }
@@ -109,7 +103,9 @@ interface FieldItem : MemberItem, InheritableItem {
             return true
         }
 
-        if (thisConstant.toString() == otherConstant.toString()) {
+        if (thisConstant.toValueString() == otherConstant?.toValueString()) {
+            // TODO(b/354633349): Add support for a special compare ignoring type that handles all
+            //   the conversions that the ValueFactory.createLiteralValue(...) handles.
             // e.g. Integer(3) and Short(3) are the same; when comparing
             // with signature files we sometimes don't have the right
             // types from signatures
@@ -134,103 +130,116 @@ interface FieldItem : MemberItem, InheritableItem {
 
     /**
      * If this field has no initial value, it just writes ";", otherwise it writes " = value;" with
-     * the correct Java syntax for the initial value
+     * the correct Java syntax for the initial value.
+     *
+     * @param writer the [PrintWriter] to which this will write the field value.
+     * @param nonConstantExpressionProvider optional provider of an expression that will initialize
+     *   the field but will not be considered to be a constant expression as defined in JLS 15.28.
+     * @return `true` if a value was written, false otherwise.
      */
     fun writeValueWithSemicolon(
         writer: PrintWriter,
-        allowDefaultValue: Boolean = false,
-        requireInitialValue: Boolean = false
-    ) {
-        val value =
-            legacyInitialValue(!allowDefaultValue)
-                ?: if (allowDefaultValue && !containingClass().isClass()) type().defaultValue()
-                else null
-        if (value != null) {
-            when (value) {
-                is Int -> {
-                    writer.print(" = ")
-                    writer.print(value)
-                    writer.print("; // 0x")
-                    writer.print(Integer.toHexString(value))
-                }
-                is String -> {
-                    writer.print(" = ")
-                    writer.print('"')
-                    writer.print(javaEscapeString(value))
-                    writer.print('"')
-                    writer.print(";")
-                }
-                is Long -> {
-                    writer.print(" = ")
-                    writer.print(value)
-                    writer.print(String.format("L; // 0x%xL", value))
-                }
-                is Boolean -> {
-                    writer.print(" = ")
-                    writer.print(value)
-                    writer.print(";")
-                }
-                is Byte -> {
-                    writer.print(" = ")
-                    writer.print(value)
-                    writer.print("; // 0x")
-                    writer.print(Integer.toHexString(value.toInt()))
-                }
-                is Short -> {
-                    writer.print(" = ")
-                    writer.print(value)
-                    writer.print("; // 0x")
-                    writer.print(Integer.toHexString(value.toInt()))
-                }
-                is Float -> {
-                    writer.print(" = ")
-                    when {
-                        value == Float.POSITIVE_INFINITY -> writer.print("(1.0f/0.0f);")
-                        value == Float.NEGATIVE_INFINITY -> writer.print("(-1.0f/0.0f);")
-                        java.lang.Float.isNaN(value) -> writer.print("(0.0f/0.0f);")
-                        // Force MIN_NORMAL to use the String representation created by
-                        // java.lang.Float.toString() before the bug fix in JDK 19  - see
-                        // https://inside.java/2022/09/23/quality-heads-up/ for details.
-                        value == java.lang.Float.MIN_NORMAL ->
-                            writer.format("1.17549435E-38f;", value)
-                        else -> {
-                            writer.print(canonicalizeFloatingPointString(value.toString()))
-                            writer.print("f;")
-                        }
+        nonConstantExpressionProvider: ((FieldItem) -> String?)? = null,
+    ): Boolean {
+        // Use [constantValue] which is only non-null on static final fields.
+        when (val value = constantValue?.asAny()) {
+            is Int -> {
+                writer.print(" = ")
+                writer.print(value)
+                writer.print("; // 0x")
+                writer.print(Integer.toHexString(value))
+            }
+            is String -> {
+                writer.print(" = ")
+                writer.print('"')
+                writer.print(javaEscapeString(value))
+                writer.print('"')
+                writer.print(";")
+            }
+            is Long -> {
+                writer.print(" = ")
+                writer.print(value)
+                writer.print(String.format("L; // 0x%xL", value))
+            }
+            is Boolean -> {
+                writer.print(" = ")
+                writer.print(value)
+                writer.print(";")
+            }
+            is Byte -> {
+                writer.print(" = ")
+                writer.print(value)
+                writer.print("; // 0x")
+                writer.print(Integer.toHexString(value.toInt()))
+            }
+            is Short -> {
+                writer.print(" = ")
+                writer.print(value)
+                writer.print("; // 0x")
+                writer.print(Integer.toHexString(value.toInt()))
+            }
+            is Float -> {
+                writer.print(" = ")
+                when {
+                    value == Float.POSITIVE_INFINITY -> writer.print("(1.0f/0.0f);")
+                    value == Float.NEGATIVE_INFINITY -> writer.print("(-1.0f/0.0f);")
+                    java.lang.Float.isNaN(value) -> writer.print("(0.0f/0.0f);")
+                    // Force MIN_NORMAL to use the String representation created by
+                    // java.lang.Float.toString() before the bug fix in JDK 19  - see
+                    // https://inside.java/2022/09/23/quality-heads-up/ for details.
+                    value == java.lang.Float.MIN_NORMAL -> writer.format("1.17549435E-38f;", value)
+                    else -> {
+                        writer.print(value.toString())
+                        writer.print("f;")
                     }
                 }
-                is Double -> {
-                    writer.print(" = ")
-                    when {
-                        value == Double.POSITIVE_INFINITY -> writer.print("(1.0/0.0);")
-                        value == Double.NEGATIVE_INFINITY -> writer.print("(-1.0/0.0);")
-                        java.lang.Double.isNaN(value) -> writer.print("(0.0/0.0);")
-                        else -> {
-                            writer.print(canonicalizeFloatingPointString(value.toString()))
-                            writer.print(";")
-                        }
+            }
+            is Double -> {
+                writer.print(" = ")
+                when {
+                    value == Double.POSITIVE_INFINITY -> writer.print("(1.0/0.0);")
+                    value == Double.NEGATIVE_INFINITY -> writer.print("(-1.0/0.0);")
+                    java.lang.Double.isNaN(value) -> writer.print("(0.0/0.0);")
+                    else -> {
+                        writer.print(value.toString())
+                        writer.print(";")
                     }
                 }
-                is Char -> {
-                    writer.print(" = ")
-                    val intValue = value.code
-                    writer.print(intValue)
-                    writer.print("; // ")
-                    writer.print(
-                        String.format("0x%04x '%s'", intValue, javaEscapeString(value.toString()))
-                    )
-                }
-                else -> {
-                    writer.print(';')
-                }
             }
-        } else {
-            // in interfaces etc we must have an initial value
-            if (requireInitialValue && !containingClass().isClass()) {
-                writer.print(" = null")
+            is Char -> {
+                writer.print(" = ")
+                val intValue = value.code
+                writer.print(intValue)
+                writer.print("; // ")
+                writer.print(
+                    String.format("0x%04x '%s'", intValue, javaEscapeString(value.toString()))
+                )
+            }
+            else -> {
+                // A non-constant expression initializer is only needed if the field is static and
+                // final. If it was just final and not static then it must be part of a normal class
+                // or an enum in which case they will use a separate initializer block to initialize
+                // the field.
+                if (modifiers.isFinal() && modifiers.isStatic()) {
+                    // Get the non-constant expression, if possible. If one is provided then write
+                    // it out.
+                    nonConstantExpressionProvider?.invoke(this)?.let { nonConstantExpression ->
+                        writer.print(" = ")
+                        writer.print(nonConstantExpression)
+                        writer.print("; // Not compile-time constant")
+                        // A value was written.
+                        return true
+                    }
+                }
+
+                writer.print(';')
+                // A value was not written.
+                return false
             }
-            writer.print(';')
         }
+
+        // A value was written.
+        return true
     }
 }
 
@@ -360,24 +369,3 @@ fun javaUnescapeString(str: String): String {
     }
     return buf.toString()
 }
-
-/**
- * Returns a canonical string representation of a floating point number. The representation is
- * suitable for use as Java source code. This method also addresses bug #4428022 in the Sun JDK.
- */
-// From doclava1
-fun canonicalizeFloatingPointString(value: String): String {
-    var str = value
-    if (str.indexOf('E') != -1) {
-        return str
-    }
-
-    // 1.0 is the only case where a trailing "0" is allowed.
-    // 1.00 is canonicalized as 1.0.
-    var i = str.length - 1
-    val d = str.indexOf('.')
-    while (i >= d + 2 && str[i] == '0') {
-        str = str.substring(0, i--)
-    }
-    return str
-}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/FixedFieldValue.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/FixedFieldValue.kt
deleted file mode 100644
index 4f4908c4c..000000000
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/FixedFieldValue.kt
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model
-
-import com.android.tools.metalava.model.item.FieldValue
-
-/** Provides access to the initial values of a field. */
-class FixedFieldValue(
-    private var initialValueWithRequiredConstant: Any?,
-    private var initialValueWithoutRequiredConstant: Any? = initialValueWithRequiredConstant,
-) : FieldValue {
-
-    override fun initialValue(requireConstant: Boolean) =
-        if (requireConstant) initialValueWithRequiredConstant
-        else initialValueWithoutRequiredConstant
-
-    override fun snapshot() = this
-}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/Item.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/Item.kt
index 5eb7a7375..a3a3e696c 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/Item.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/Item.kt
@@ -16,6 +16,7 @@
 
 package com.android.tools.metalava.model
 
+import com.android.tools.metalava.model.value.StringValue
 import com.android.tools.metalava.reporter.BaselineKey
 import com.android.tools.metalava.reporter.FileLocation
 import com.android.tools.metalava.reporter.Reportable
@@ -134,24 +135,24 @@ interface Item : Reportable {
     fun toStringForItem(): String
 
     /**
-     * The language in which this was written, or [ItemLanguage.UNKNOWN] if not known, e.g. when
+     * The language in which this was written, or [SourceLanguage.UNKNOWN] if not known, e.g. when
      * created from a signature file.
      */
-    val itemLanguage: ItemLanguage
+    val sourceLanguage: SourceLanguage
 
     /**
      * Is this element declared in Java (rather than Kotlin) ?
      *
-     * See [itemLanguage].
+     * See [sourceLanguage].
      */
-    fun isJava() = itemLanguage.isJava()
+    fun isJava() = sourceLanguage.isJava()
 
     /**
      * Is this element declared in Kotlin (rather than Java) ?
      *
-     * See [itemLanguage].
+     * See [sourceLanguage].
      */
-    fun isKotlin() = itemLanguage.isKotlin()
+    fun isKotlin() = sourceLanguage.isKotlin()
 
     /**
      * Returns true if this [Item]'s modifier list contains any suppress compatibility
@@ -383,7 +384,7 @@ interface Item : Reportable {
 abstract class DefaultItem(
     override val codebase: Codebase,
     final override val fileLocation: FileLocation,
-    final override val itemLanguage: ItemLanguage,
+    final override val sourceLanguage: SourceLanguage,
     modifiers: BaseModifierList,
     documentationFactory: ItemDocumentationFactory,
 ) : Item {
@@ -453,16 +454,11 @@ abstract class DefaultItem(
                 if (annotationName in SUPPRESS_ANNOTATIONS) {
                     for (attribute in annotation.attributes) {
                         // Assumption that all annotations in SUPPRESS_ANNOTATIONS only have
-                        // one attribute such as value/names that is varargs of String
-                        val value = attribute.legacyValue
-                        if (value is AnnotationArrayAttributeValue) {
-                            // Example: @SuppressLint({"RequiresFeature", "AllUpper"})
-                            for (innerValue in value.values) {
-                                innerValue.value()?.toString()?.let { add(it) }
-                            }
-                        } else {
-                            // Example: @SuppressLint("RequiresFeature")
-                            value.value()?.toString()?.let { add(it) }
+                        // one attribute such as value/names that is an array of String, e.g.
+                        // Example: @SuppressLint({"RequiresFeature", "AllUpper"})
+                        // Example: @SuppressLint("RequiresFeature")
+                        for (value in attribute.value.asFlatList()) {
+                            if (value is StringValue) add(value.underlyingValue)
                         }
                     }
                 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/JavaConstants.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/JavaConstants.kt
index 111f9c293..827d4bd02 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/JavaConstants.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/JavaConstants.kt
@@ -40,6 +40,8 @@ const val KT_RETENTION = "kotlin.annotation.Retention"
 
 const val JVM_STATIC = "kotlin.jvm.JvmStatic"
 
+const val KOTLIN_METADATA = "kotlin.Metadata"
+
 /** True if the annotation name represents @Retention (either the Java or Kotlin version) */
 fun isRetention(qualifiedName: String?): Boolean =
     JAVA_RETENTION == qualifiedName || KT_RETENTION == qualifiedName
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/MethodItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/MethodItem.kt
index 52e836140..8db992e03 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/MethodItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/MethodItem.kt
@@ -16,6 +16,9 @@
 
 package com.android.tools.metalava.model
 
+import com.android.tools.metalava.model.value.LegacyValueFormatter
+import com.android.tools.metalava.model.value.Value
+
 @MetalavaApi
 interface MethodItem : CallableItem, InheritableItem {
     /**
@@ -234,7 +237,21 @@ interface MethodItem : CallableItem, InheritableItem {
      * that exposes implementation details. It will be replaced by a properly modelled value
      * representation.
      */
-    fun legacyDefaultValue(): String
+    fun legacyDefaultValue() =
+        defaultValue?.let { value ->
+            LegacyValueFormatter.ATTRIBUTE_DEFAULT_FORMATTER.format(value, this)
+        } ?: ""
+
+    /**
+     * The optional default value of the method.
+     *
+     * Replacement for [legacyDefaultValue].
+     *
+     * The [Value] will be suitable for use as an annotation attribute value as specified by JLS
+     * 9.6.1 (what this model calls "attributes", the JSL calls "elements"). That includes constant
+     * fields.
+     */
+    val defaultValue: Value?
 
     /** Whether this method is a getter/setter for an underlying Kotlin property (val/var) */
     fun isKotlinProperty(): Boolean = false
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ModifierListWriter.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/ModifierListWriter.kt
index 4f898c843..9d2265c12 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/ModifierListWriter.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/ModifierListWriter.kt
@@ -297,7 +297,7 @@ private constructor(
                     }
                 }
 
-                val source = printAnnotation.toSource(target, showDefaultAttrs = false)
+                val source = printAnnotation.toSource(target, item)
 
                 if (omitCommonPackages) {
                     writer.write(AnnotationItem.shortenAnnotation(source))
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/MutableModifierList.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/MutableModifierList.kt
index 82035ce60..708adb87a 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/MutableModifierList.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/MutableModifierList.kt
@@ -45,6 +45,8 @@ interface MutableModifierList : BaseModifierList {
 
     fun setInfix(infix: Boolean)
 
+    fun setConst(const: Boolean)
+
     fun setOperator(operator: Boolean)
 
     fun setInline(inline: Boolean)
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/SelectableItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/SelectableItem.kt
index b2afa5ad3..f7eeebe15 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/SelectableItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/SelectableItem.kt
@@ -110,4 +110,7 @@ interface SelectableItem : Item {
         superMethods: Boolean,
         duplicate: Boolean,
     ): SelectableItem?
+
+    /** The languages from which this [Item] can be used. */
+    val targetLanguages: Set<TargetLanguage>
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ItemLanguage.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/SourceLanguage.kt
similarity index 88%
rename from metalava-model/src/main/java/com/android/tools/metalava/model/ItemLanguage.kt
rename to metalava-model/src/main/java/com/android/tools/metalava/model/SourceLanguage.kt
index 65eef152c..b3904487f 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/ItemLanguage.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/SourceLanguage.kt
@@ -16,8 +16,8 @@
 
 package com.android.tools.metalava.model
 
-/** The language of an item. */
-enum class ItemLanguage {
+/** The source language an [Item] was written in. This is distinct from the [TargetLanguage]s. */
+enum class SourceLanguage {
     KOTLIN,
     JAVA,
     UNKNOWN {
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/TargetLanguage.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/TargetLanguage.kt
new file mode 100644
index 000000000..c8dd659f3
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/TargetLanguage.kt
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model
+
+import java.util.EnumSet
+
+/**
+ * The [TargetLanguage]s for an [Item] represent which languages a client can use the [Item] from.
+ *
+ * This is distinct from the [SourceLanguage] of an [Item]. An API defined in one language may be
+ * usable from all [TargetLanguage]s or only from a subset.
+ *
+ * Note that an API from source might be represented as multiple [Item]s with different signatures
+ * that have different [TargetLanguage]s (for example, an API defined in Kotlin with [JvmName] will
+ * be represented with one item using the original name from source, which can be referenced from
+ * Kotlin, and one item using the name from the annotation, which can be referenced from Java and
+ * from bytecode).
+ */
+enum class TargetLanguage {
+    /** [Item]s with [KOTLIN] as a [TargetLanguage] can be referenced from Kotlin source code. */
+    KOTLIN,
+    /** [Item]s with [JAVA] as a [TargetLanguage] can be referenced from Java source code. */
+    JAVA,
+    /** [Item]s with [BYTECODE] as a [TargetLanguage] can be referenced from compiled bytecode. */
+    BYTECODE
+}
+
+/** Standard sets of [TargetLanguage]s. */
+object TargetLanguageSet {
+    /**
+     * [TargetLanguage] set for an API that can be referenced from both Java and Kotlin source and
+     * from bytecode.
+     */
+    val ALL: Set<TargetLanguage> =
+        EnumSet.of(TargetLanguage.BYTECODE, TargetLanguage.JAVA, TargetLanguage.KOTLIN)
+
+    /**
+     * [TargetLanguage] set for an API that can only be referenced from Kotlin source.
+     *
+     * Examples include:
+     * - The version of a Kotlin API annotated with [JvmName] that uses the original source name
+     *   rather than the name from the annotation.
+     */
+    val KOTLIN_ONLY: Set<TargetLanguage> = EnumSet.of(TargetLanguage.KOTLIN)
+
+    /**
+     * [TargetLanguage] set for an API that can only be referenced from bytecode, not from source
+     * code in Java or Kotlin.
+     *
+     * Examples include:
+     * - Deprecated Kotlin APIs with [DeprecationLevel.HIDDEN]. These APIs cannot be referenced from
+     *   source code, but exist in the bytecode to provide compatibility with clients compiled
+     *   against a previous version before the API was deprecated.
+     * - The mangled form of a Kotlin API function a value class type (see
+     *   https://kotlinlang.org/docs/inline-classes.html#mangling). These functions are referenced
+     *   from Kotlin code using the non-mangled name and value class type (represented with a
+     *   separate [MethodItem] with that signature), but when compiled the referenced use this
+     *   mangled form.
+     */
+    val BYTECODE_ONLY: Set<TargetLanguage> = EnumSet.of(TargetLanguage.BYTECODE)
+
+    /**
+     * [TargetLanguage] set for an API that cannot be referenced from Kotlin source, but can be
+     * referenced from Java source and from bytecode.
+     *
+     * Examples include:
+     * - The renamed version of a Kotlin API annotated with [JvmName]
+     */
+    val NOT_KOTLIN: Set<TargetLanguage> = EnumSet.of(TargetLanguage.BYTECODE, TargetLanguage.JAVA)
+
+    /**
+     * [TargetLanguage] set for an API that cannot be referenced from Java source, but can be
+     * referenced from Kotlin source and from bytecode.
+     *
+     * Examples include:
+     * - An API annotated with [JvmSynthetic]
+     */
+    val NOT_JAVA: Set<TargetLanguage> = EnumSet.of(TargetLanguage.BYTECODE, TargetLanguage.KOTLIN)
+
+    /**
+     * [TargetLanguage] set with all targets except [TargetLanguage.BYTECODE]. This might be used by
+     * a visitor which wants to skip APIs that only exist in bytecode.
+     */
+    val SOURCE: Set<TargetLanguage> = EnumSet.of(TargetLanguage.JAVA, TargetLanguage.KOTLIN)
+
+    /**
+     * Mapping from the representation used in signature files to the corresponding target language
+     * set.
+     */
+    val signatureFileRepresentationToTargetLanguageSet =
+        mapOf(
+            "@KotlinOnly" to KOTLIN_ONLY,
+            "@BytecodeOnly" to BYTECODE_ONLY,
+            "@InaccessibleFromKotlin" to NOT_KOTLIN,
+            "@InaccessibleFromJava" to NOT_JAVA,
+        )
+
+    /**
+     * Reverse of [modifierToSet]: mapping from a target language set to the corresponding modifier
+     * to use in signature files.
+     */
+    val targetLanguageSetToSignatureFileRepresentation =
+        signatureFileRepresentationToTargetLanguageSet.entries.associate { it.value to it.key }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeItem.kt
index ecc472b94..409cb7501 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeItem.kt
@@ -564,8 +564,11 @@ abstract class DefaultTypeItem(
                         typeParameter.asErasedType()?.let { boundsType ->
                             appendTypeString(boundsType, configuration)
                         }
-                        // No explicit bounds were provided so use the default of java.lang.Object.
-                        ?: if (configuration.stripJavaLangPrefix == StripJavaLangPrefix.ALWAYS) {
+                            // No explicit bounds were provided so use the default of
+                            // java.lang.Object.
+                            ?: if (
+                                configuration.stripJavaLangPrefix == StripJavaLangPrefix.ALWAYS
+                            ) {
                                 append("Object")
                             } else {
                                 append(JAVA_LANG_OBJECT)
@@ -856,64 +859,110 @@ interface PrimitiveTypeItem : TypeItem {
     /** The possible kinds of primitives. */
     enum class Primitive(
         val primitiveName: String,
+        val kotlinName: String,
         val defaultValue: Any?,
         val defaultValueString: String,
         val wrapperClass: Class<*>,
     ) {
         BOOLEAN(
             primitiveName = "boolean",
+            kotlinName = "Boolean",
             defaultValue = false,
             defaultValueString = "false",
             wrapperClass = java.lang.Boolean::class.java,
         ),
         BYTE(
             primitiveName = "byte",
+            kotlinName = "Byte",
             defaultValue = 0.toByte(),
             defaultValueString = "0",
             wrapperClass = java.lang.Byte::class.java,
         ),
         CHAR(
             primitiveName = "char",
+            kotlinName = "Char",
             defaultValue = 0.toChar(),
             defaultValueString = "0",
             wrapperClass = java.lang.Character::class.java,
         ),
         DOUBLE(
             primitiveName = "double",
+            kotlinName = "Double",
             defaultValue = 0.0,
             defaultValueString = "0",
             wrapperClass = java.lang.Double::class.java,
         ),
         FLOAT(
             primitiveName = "float",
+            kotlinName = "Float",
             defaultValue = 0F,
             defaultValueString = "0",
             wrapperClass = java.lang.Float::class.java,
         ),
         INT(
             primitiveName = "int",
+            kotlinName = "Int",
             defaultValue = 0,
             defaultValueString = "0",
             wrapperClass = java.lang.Integer::class.java,
         ),
         LONG(
             primitiveName = "long",
+            kotlinName = "Long",
             defaultValue = 0L,
             defaultValueString = "0",
             wrapperClass = java.lang.Long::class.java,
         ),
         SHORT(
             primitiveName = "short",
+            kotlinName = "Short",
             defaultValue = 0.toShort(),
             defaultValueString = "0",
             wrapperClass = java.lang.Short::class.java,
         ),
         VOID(
             primitiveName = "void",
+            // Kotlin does not really have a name for this but Nothing is closest.
+            kotlinName = "Nothing",
             defaultValue = null,
             defaultValueString = "null",
             wrapperClass = java.lang.Void::class.java,
-        )
+        ),
+        ;
+
+        /**
+         * The name of the Kotlin function that will convert a [Number] to an instance of this type.
+         *
+         * This is `null` for non-numeric [Primitive]s.
+         */
+        val kotlinNumericConversionFunction =
+            if (Number::class.java.isAssignableFrom(wrapperClass)) "to$kotlinName" else null
+
+        companion object {
+            /** Map from [Primitive.wrapperClass]'s name to [Primitive]. */
+            private val wrapperClassNameToKind =
+                Primitive.entries.associateBy { it.wrapperClass.name }
+
+            /**
+             * Get the [Primitive] associated with [wrapperClassName], returning `null`, if it could
+             * not be found.
+             */
+            fun forWrapperClassName(wrapperClassName: String) =
+                wrapperClassNameToKind[wrapperClassName]
+
+            /** Map from [Primitive.kotlinNumericConversionFunction]'s name to [Primitive]. */
+            private val kotlinNumericConversionFunctionNameToKind =
+                Primitive.entries
+                    .filter { it.kotlinNumericConversionFunction != null }
+                    .associateBy { it.kotlinNumericConversionFunction }
+
+            /**
+             * Get the [Primitive] associated with the Kotlin numeric conversion function called
+             * [name], returning `null`, if it could not be found.
+             */
+            fun forKotlinNumericConversionFunctionName(name: String) =
+                kotlinNumericConversionFunctionNameToKind[name]
+        }
     }
 
     override fun defaultValue(): Any? = kind.defaultValue
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterItem.kt
index fe8d72797..bdbde5202 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterItem.kt
@@ -18,8 +18,6 @@ package com.android.tools.metalava.model
 
 @MetalavaApi
 interface TypeParameterItem {
-    val codebase: Codebase
-
     /** Return the modifiers of this class */
     @MetalavaApi val modifiers: ModifierList
 
@@ -36,8 +34,7 @@ interface TypeParameterItem {
      * something of this type. That is either the first bound (the super class) or
      * `java.lang.Object` if there are no bounds.
      */
-    fun asErasedType(): BoundsTypeItem? =
-        typeBounds().firstOrNull() ?: codebase.resolveClass(JAVA_LANG_OBJECT)?.type()
+    fun asErasedType(): BoundsTypeItem?
 
     fun isReified(): Boolean
 
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/AnnotationClass.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/AnnotationClass.kt
new file mode 100644
index 000000000..0ff205709
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/AnnotationClass.kt
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.annotation
+
+import com.android.tools.metalava.model.AnnotationRetention
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ClassKind
+
+/**
+ * Encapsulates information extracted from a [ClassItem] whose [ClassItem.classKind] is
+ * [ClassKind.ANNOTATION_TYPE].
+ */
+interface AnnotationClass {
+    /**
+     * The retention of the associated [ClassItem], if none is specified then uses a language
+     * specific default.
+     */
+    val retention: AnnotationRetention
+
+    /** Get the annotation defaults for the associated [ClassItem]. */
+    val defaults: AnnotationDefaults
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/AnnotationDefaults.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/AnnotationDefaults.kt
new file mode 100644
index 000000000..fb245ac5a
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/AnnotationDefaults.kt
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.annotation
+
+import com.android.tools.metalava.model.value.Value
+
+/** The set of defaults for an annotation. */
+class AnnotationDefaults(private val defaultsByName: Map<String, Value>) {
+    /**
+     * Apply the defaults to [nameToValue].
+     *
+     * Returns a [Map] that includes [nameToValue] plus a default [Value] for any name in
+     * [defaultsByName] that does not have a [Value] in [nameToValue].
+     */
+    fun apply(nameToValue: Map<String, Value>): Map<String, Value> {
+        if (defaultsByName.isEmpty()) return nameToValue
+
+        return buildMap {
+            putAll(nameToValue)
+            for ((name, value) in defaultsByName) {
+                if (name !in this) put(name, value)
+            }
+        }
+    }
+
+    companion object {
+        val EMPTY = AnnotationDefaults(emptyMap())
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/AnnotationFilter.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/AnnotationFilter.kt
index 60c3fb2ff..20600d6d3 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/AnnotationFilter.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/AnnotationFilter.kt
@@ -16,28 +16,27 @@
 
 package com.android.tools.metalava.model.annotation
 
-import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
-import com.android.tools.metalava.model.AnnotationArrayAttributeValue
-import com.android.tools.metalava.model.AnnotationAttribute
+import com.android.tools.metalava.model.AnnotationContext
 import com.android.tools.metalava.model.AnnotationItem
-import com.android.tools.metalava.model.AnnotationSingleAttributeValue
-import com.android.tools.metalava.model.DefaultAnnotationAttribute
+import com.android.tools.metalava.model.value.ArrayElementValue
+import com.android.tools.metalava.model.value.ArrayValue
+import com.android.tools.metalava.model.value.Value
 import java.util.TreeMap
 
 interface AnnotationFilter {
     // tells whether an annotation is included by the filter
     fun matches(annotation: AnnotationItem): Boolean
-    // tells whether an annotation is included by this filter
-    fun matches(annotationSource: String): Boolean
 
     // Returns a sorted set of fully qualified annotation names that may be included by this filter.
     // Note that this filter might incorporate parameters but this function strips them.
     fun getIncludedAnnotationNames(): Set<String>
+
     // Returns true if [getIncludedAnnotationNames] includes the given qualified name
     fun matchesAnnotationName(qualifiedName: String): Boolean
 
     // Returns true if nothing is matched by this filter
     fun isEmpty(): Boolean
+
     // Returns true if some annotation is matched by this filter
     fun isNotEmpty(): Boolean
 
@@ -69,43 +68,12 @@ class AnnotationFilterBuilder {
     // Note that the order of calls to this method could affect the return from
     // {@link #firstQualifiedName} .
     fun add(option: String) {
-        val (matchResult, pattern) =
-            if (option.startsWith("!")) {
-                Pair(false, option.substring(1))
-            } else {
-                Pair(true, option)
-            }
-        inclusionExpressions.add(AnnotationFilterEntry.fromOption(pattern, matchResult))
+        inclusionExpressions.add(AnnotationFilterEntry.fromOption(option))
     }
 
     /** Build the [AnnotationFilter]. */
     fun build(): AnnotationFilter {
-        // Sort the expressions by match result, so that those expressions that exclude come before
-        // those which include.
-        val map =
-            inclusionExpressions
-                .sortedBy { it.matchResult }
-                .groupByTo(TreeMap()) { it.qualifiedName }
-
-        // Verify that the filter is consistent.
-        for ((fqn, patterns) in map.entries) {
-            val (includes, excludes) = patterns.partition { it.matchResult }
-            if (excludes.isNotEmpty()) {
-                for (exclude in excludes) {
-                    if (exclude.attributes.isEmpty()) {
-                        throw IllegalStateException(
-                            "Exclude pattern '$exclude' is invalid as it does not specify attributes"
-                        )
-                    }
-                }
-
-                if (includes.isEmpty()) {
-                    throw IllegalStateException(
-                        "Patterns for '$fqn' contains ${excludes.size} excludes but no includes"
-                    )
-                }
-            }
-        }
+        val map = inclusionExpressions.groupByTo(TreeMap()) { it.qualifiedName }
         return ImmutableAnnotationFilter(map)
     }
 }
@@ -115,16 +83,11 @@ private class ImmutableAnnotationFilter(
     private val qualifiedNameToEntries: Map<String, List<AnnotationFilterEntry>>
 ) : AnnotationFilter {
 
-    override fun matches(annotationSource: String): Boolean {
-        val wrapper = AnnotationFilterEntry.fromSource(annotationSource)
-        return matches(wrapper)
-    }
-
     override fun matches(annotation: AnnotationItem): Boolean {
         val qualifiedName = annotation.qualifiedName
         // If the annotation name is not in the map of annotation names that can be matched then
-        // this can never match so return immediately rather than generating the source
-        // representation of the annotation.
+        // this can never match so return immediately rather than generating a entry for the
+        // annotation.
         if (qualifiedName !in qualifiedNameToEntries) {
             return false
         }
@@ -134,8 +97,7 @@ private class ImmutableAnnotationFilter(
 
     private fun matches(annotation: AnnotationFilterEntry): Boolean {
         val entries = qualifiedNameToEntries[annotation.qualifiedName] ?: return false
-        return entries.firstOrNull { entry -> annotationsMatch(entry, annotation) }?.matchResult
-            ?: false
+        return entries.any { entry -> annotationsMatch(entry, annotation) }
     }
 
     override fun getIncludedAnnotationNames(): Set<String> = qualifiedNameToEntries.keys
@@ -156,104 +118,73 @@ private class ImmutableAnnotationFilter(
         filter: AnnotationFilterEntry,
         existingAnnotation: AnnotationFilterEntry
     ): Boolean {
-        if (filter.attributes.count() > existingAnnotation.attributes.count()) {
+        // The annotation must have an attribute for each attribute in the filter.
+        if (filter.attributes.size > existingAnnotation.attributes.size) {
             return false
         }
-        for (attribute in filter.attributes) {
-            val existingValue = existingAnnotation.findAttribute(attribute.name)?.legacyValue
-            val existingValueSource = existingValue?.toSource()
-            val attributeValueSource = attribute.legacyValue.toSource()
-            if (attribute.name == "value") {
-                // Special-case where varargs value annotation attribute can be specified with
-                // either @Foo(BAR) or @Foo({BAR}) and they are equivalent.
-                when {
-                    attribute.legacyValue is AnnotationSingleAttributeValue &&
-                        existingValue is AnnotationArrayAttributeValue -> {
-                        if (existingValueSource != "{$attributeValueSource}") return false
-                    }
-                    attribute.legacyValue is AnnotationArrayAttributeValue &&
-                        existingValue is AnnotationSingleAttributeValue -> {
-                        if ("{$existingValueSource}" != attributeValueSource) return false
-                    }
-                    else -> {
-                        if (existingValueSource != attributeValueSource) return false
-                    }
-                }
-            } else {
-                if (existingValueSource != attributeValueSource) {
-                    return false
-                }
-            }
+
+        // The annotation must have the same value as every filter attribute.
+        val annotationAttributes = existingAnnotation.attributes
+        return filter.attributes.all { (attributeName, filterValue) ->
+            filterValue == annotationAttributes[attributeName]
         }
-        return true
     }
 }
 
-// An AnnotationFilterEntry filters for annotations having a certain qualifiedName and
-// possibly certain attributes.
-// An AnnotationFilterEntry doesn't necessarily have a Codebase like an AnnotationItem does
-private class AnnotationFilterEntry(
+/**
+ * An [AnnotationFilterEntry] filters for annotations having a certain [qualifiedName] and possibly
+ * certain [attributes].
+ *
+ * An [AnnotationFilterEntry] does not have a Codebase like an [AnnotationItem] does.
+ */
+private class AnnotationFilterEntry
+private constructor(
     val qualifiedName: String,
-    val attributes: List<AnnotationAttribute>,
-    /** The result that will be returned from [AnnotationFilter.matches] when this entry matches. */
-    val matchResult: Boolean,
+    val attributes: Map<String, Value>,
 ) {
-    fun findAttribute(name: String?): AnnotationAttribute? {
-        val actualName = name ?: ANNOTATION_ATTR_VALUE
-        return attributes.firstOrNull { it.name == actualName }
-    }
-
-    override fun toString(): String {
-        return buildString {
-            if (!matchResult) {
-                append("!")
-            }
-            append(qualifiedName)
-            if (attributes.isNotEmpty()) {
-                append("(")
-                attributes.joinTo(this)
-                append(")")
+    companion object {
+        /** Normalize this [Value] to simplify comparison. */
+        private fun Value.normalizeValue(): Value =
+            when (this) {
+                is ArrayValue -> {
+                    val size = elements.size
+                    when (size) {
+                        0 -> this
+                        // Replace an array containing a single value with the normalized value.
+                        1 -> elements[0]
+                        // Normalize the elements of the array.
+                        else -> Value.createArrayValue(elements)
+                    }
+                }
+                is ArrayElementValue -> this
             }
-        }
-    }
 
-    companion object {
-        fun fromSource(source: String): AnnotationFilterEntry {
-            val text = source.replace("@", "")
-            return fromOption(text)
+        fun fromOption(text: String): AnnotationFilterEntry {
+            val annotationItem =
+                AnnotationItem.createFromSource(
+                    // Use the NoOpAnnotationManager whose `normalizeInputName(...)` method will not
+                    // reject any annotations so createFromSource(...) will never return null.
+                    AnnotationContext.DEFAULT_RESOLVE_NULL,
+                    "@$text"
+                ) ?: error("Could not construct annotation from `$text`")
+
+            return fromAnnotationItem(annotationItem)
         }
 
-        fun fromOption(text: String, matchResult: Boolean = true): AnnotationFilterEntry {
-            val index = text.indexOf("(")
+        fun fromAnnotationItem(annotationItem: AnnotationItem): AnnotationFilterEntry {
+            val qualifiedName = annotationItem.qualifiedName
 
-            val qualifiedName =
-                if (index == -1) {
-                    text
-                } else {
-                    text.substring(0, index)
-                }
+            // Create a map from attribute name to normalized value.
+            val attributes =
+                annotationItem.attributes.associateBy({ it.name }) { it.value.normalizeValue() }
 
-            val attributes: List<AnnotationAttribute> =
-                if (index == -1) {
-                    emptyList()
-                } else {
-                    DefaultAnnotationAttribute.createList(
-                        text.substring(index + 1, text.lastIndexOf(')'))
-                    )
-                }
-            return AnnotationFilterEntry(qualifiedName, attributes, matchResult)
-        }
+            // Merge in any default values.
+            val withDefaults =
+                annotationItem.annotationContext
+                    .defaultsForAnnotationClass(annotationItem.qualifiedName)
+                    .apply(attributes)
 
-        fun fromAnnotationItem(annotationItem: AnnotationItem): AnnotationFilterEntry {
-            // Have to call toSource to resolve attribute values into fully qualified class names.
-            // For example: resolving RestrictTo(LIBRARY_GROUP) into
-            // RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP)
-            // In addition, toSource (with the default argument showDefaultAttrs=true) retrieves
-            // default attributes from the definition of the annotation. For example,
-            // @SystemApi actually is converted into @android.annotation.SystemApi(\
-            // client=android.annotation.SystemApi.Client.PRIVILEGED_APPS,\
-            // process=android.annotation.SystemApi.Process.ALL)
-            return fromSource(annotationItem.toSource())
+            return AnnotationFilterEntry(qualifiedName, withDefaults)
         }
     }
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/DefaultAnnotationManager.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/DefaultAnnotationManager.kt
index 1947112d3..48b0bcd3d 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/DefaultAnnotationManager.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/DefaultAnnotationManager.kt
@@ -20,17 +20,14 @@ import com.android.tools.metalava.model.ANDROIDX_ANNOTATION_PREFIX
 import com.android.tools.metalava.model.ANDROIDX_NONNULL
 import com.android.tools.metalava.model.ANDROIDX_NULLABLE
 import com.android.tools.metalava.model.ANDROID_ANNOTATION_PREFIX
-import com.android.tools.metalava.model.ANDROID_DEPRECATED_FOR_SDK
 import com.android.tools.metalava.model.ANDROID_FLAGGED_API
 import com.android.tools.metalava.model.ANDROID_NONNULL
 import com.android.tools.metalava.model.ANDROID_NULLABLE
 import com.android.tools.metalava.model.ANDROID_SYSTEM_API
 import com.android.tools.metalava.model.ANDROID_TEST_API
-import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
 import com.android.tools.metalava.model.ANNOTATION_EXTERNAL
 import com.android.tools.metalava.model.ANNOTATION_EXTERNAL_ONLY
 import com.android.tools.metalava.model.ANNOTATION_IN_ALL_STUBS
-import com.android.tools.metalava.model.ANNOTATION_IN_DOC_STUBS_AND_EXTERNAL
 import com.android.tools.metalava.model.ANNOTATION_SDK_STUBS_ONLY
 import com.android.tools.metalava.model.ANNOTATION_SIGNATURE_ONLY
 import com.android.tools.metalava.model.ANNOTATION_STUBS_ONLY
@@ -45,6 +42,7 @@ import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.FilterPredicate
 import com.android.tools.metalava.model.JAVA_LANG_PREFIX
 import com.android.tools.metalava.model.JVM_STATIC
+import com.android.tools.metalava.model.KOTLIN_METADATA
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.ModifierList
 import com.android.tools.metalava.model.NO_ANNOTATION_TARGETS
@@ -59,6 +57,7 @@ import com.android.tools.metalava.model.TypedefMode
 import com.android.tools.metalava.model.annotation.DefaultAnnotationManager.Config
 import com.android.tools.metalava.model.api.flags.ApiFlag
 import com.android.tools.metalava.model.api.flags.ApiFlags
+import com.android.tools.metalava.model.api.flags.optionalFlagName
 import com.android.tools.metalava.model.computeTypeNullability
 import com.android.tools.metalava.model.hasAnnotation
 import com.android.tools.metalava.model.isNonNullAnnotation
@@ -159,7 +158,7 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
         val qualifiedName = annotationItem.qualifiedName
 
         // Check to see if this requires a special [KeyFactory] and use it if it does.
-        val keyFactory = annotationNameToKeyFactory.get(qualifiedName)
+        val keyFactory = annotationNameToKeyFactory[qualifiedName]
         if (keyFactory != null) {
             return keyFactory(annotationItem)
         }
@@ -172,8 +171,7 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
         return LazyAnnotationInfo(this, config, annotationItem)
     }
 
-    override fun normalizeInputName(qualifiedName: String?): String? {
-        qualifiedName ?: return null
+    override fun normalizeInputName(qualifiedName: String): String? {
         if (passThroughAnnotation(qualifiedName)) {
             return qualifiedName
         }
@@ -261,7 +259,6 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
             "android.annotation.NonUiContext" -> return "androidx.annotation.NonUiContext"
 
             // Misc
-            ANDROID_DEPRECATED_FOR_SDK -> return ANDROID_DEPRECATED_FOR_SDK
             "android.annotation.CallSuper" -> return "androidx.annotation.CallSuper"
             "android.annotation.CheckResult" -> return "androidx.annotation.CheckResult"
             "android.annotation.Discouraged" -> return "androidx.annotation.Discouraged"
@@ -324,14 +321,18 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
                     qualifiedName.startsWith(ANDROID_ANNOTATION_PREFIX) -> {
                         return qualifiedName
                     }
+
+                    // Ravenwood annotations are meaningless to Metalava.
+                    qualifiedName.startsWith("android.ravenwood.") -> return null
+
+                    // Keep any other unknown annotations.
                     else -> qualifiedName
                 }
             }
         }
     }
 
-    override fun normalizeOutputName(qualifiedName: String?, target: AnnotationTarget): String? {
-        qualifiedName ?: return null
+    override fun normalizeOutputName(qualifiedName: String, target: AnnotationTarget): String {
         if (passThroughAnnotation(qualifiedName)) {
             return qualifiedName
         }
@@ -356,10 +357,15 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
 
     private fun passThroughAnnotation(qualifiedName: String) =
         config.passThroughAnnotations.contains(qualifiedName) ||
-            config.allShowAnnotations.matches(qualifiedName) ||
-            config.hideAnnotations.matches(qualifiedName)
+            config.allShowAnnotations.matchesAnnotationName(qualifiedName) ||
+            config.hideAnnotations.matchesAnnotationName(qualifiedName)
 
-    private val TYPEDEF_ANNOTATION_TARGETS =
+    /**
+     * Targets for type def annotations, i.e. `@IntDef` and `@StringDef` annotated annotations.
+     *
+     * Depends on the [DefaultAnnotationManager.Config.typedefMode].
+     */
+    private val typedefAnnotationTargets =
         if (
             config.typedefMode == TypedefMode.INLINE || config.typedefMode == TypedefMode.NONE
         ) // just here for compatibility purposes
@@ -388,7 +394,7 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
             "android.annotation.StringDef",
             "androidx.annotation.StringDef",
             "android.annotation.LongDef",
-            "androidx.annotation.LongDef" -> return TYPEDEF_ANNOTATION_TARGETS
+            "androidx.annotation.LongDef" -> return typedefAnnotationTargets
             "android.annotation.RestrictedForEnvironment" -> return ANNOTATION_EXTERNAL
 
             // Not directly API relevant
@@ -425,7 +431,6 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
             "dalvik.annotation.optimization.ReachabilitySensitive" -> return NO_ANNOTATION_TARGETS
 
             // TODO(aurimas): consider using annotation directly instead of modifiers
-            ANDROID_DEPRECATED_FOR_SDK,
             "kotlin.Deprecated" ->
                 return NO_ANNOTATION_TARGETS // tracked separately as a pseudo-modifier
             "java.lang.Deprecated", // tracked separately as a pseudo-modifier
@@ -456,6 +461,7 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
             "kotlin.jvm.JvmOverloads",
             "kotlin.jvm.JvmField",
             JVM_STATIC,
+            KOTLIN_METADATA,
             "kotlin.jvm.JvmName" -> return NO_ANNOTATION_TARGETS
         }
 
@@ -491,16 +497,6 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
         // habit of loading all annotation classes it encounters.)
 
         if (qualifiedName.startsWith("androidx.annotation.")) {
-            if (qualifiedName == ANDROIDX_NULLABLE || qualifiedName == ANDROIDX_NONNULL) {
-                // Right now, nullness annotations (other than @RecentlyNullable and
-                // @RecentlyNonNull)
-                // have to go in external annotations since they aren't in the class path for
-                // annotation processors. However, we do want them showing up in the
-                // documentation using
-                // their real annotation names.
-                return ANNOTATION_IN_DOC_STUBS_AND_EXTERNAL
-            }
-
             return ANNOTATION_EXTERNAL
         }
 
@@ -518,7 +514,7 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
         }
 
         if (cls.isAnnotationType()) {
-            val retention = cls.getRetention()
+            val retention = cls.annotationClass.retention
             if (
                 retention == AnnotationRetention.RUNTIME ||
                     retention == AnnotationRetention.CLASS ||
@@ -713,11 +709,8 @@ private class LazyAnnotationInfo(
     override val apiFlag by lazy(LazyThreadSafetyMode.NONE) { getFlagForAnnotation(annotationItem) }
 
     private fun getFlagForAnnotation(annotationItem: AnnotationItem): ApiFlag? {
-        if (annotationItem.qualifiedName != ANDROID_FLAGGED_API) return null
         val apiFlags = config.apiFlags ?: return null
-        val valueAttribute =
-            annotationItem.attributes.find { it.name == ANNOTATION_ATTR_VALUE } ?: return null
-        val flagName = valueAttribute.legacyValue.value() as String
+        val flagName = annotationItem.optionalFlagName ?: return null
         return apiFlags[flagName]
     }
 
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/api/flags/ApiFlags.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/api/flags/ApiFlags.kt
index e9ea46497..0badca888 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/api/flags/ApiFlags.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/api/flags/ApiFlags.kt
@@ -16,11 +16,15 @@
 
 package com.android.tools.metalava.model.api.flags
 
+import com.android.tools.metalava.model.ANDROID_FLAGGED_API
+import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
 import com.android.tools.metalava.model.ANNOTATION_IN_ALL_STUBS
+import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.AnnotationTarget
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.NO_ANNOTATION_TARGETS
 import com.android.tools.metalava.model.Showability
+import com.android.tools.metalava.model.value.asString
 
 /**
  * The available set of configured [ApiFlag]s.
@@ -94,3 +98,25 @@ private constructor(
             )
     }
 }
+
+/**
+ * Get the optional flag name from this [AnnotationItem].
+ *
+ * Returns `null` if this is not [ANDROID_FLAGGED_API] and does not have a `value` attribute.
+ * Otherwise, it returns the value attribute as a [String].
+ *
+ * If the value exists but is not resolvable this returns the name of the field to preserve previous
+ * behavior.
+ */
+val AnnotationItem.optionalFlagName: String?
+    get() {
+        if (qualifiedName != ANDROID_FLAGGED_API) return null
+        val valueAttribute = findAttribute(ANNOTATION_ATTR_VALUE) ?: return null
+        return valueAttribute.value.let { value ->
+            // Use the literal string value, if possible. It will not be possible if the value is
+            // an unresolvable field reference.
+            value.asString()
+                // Fallback to using the string representation of the field reference.
+                ?: value.toValueString()
+        }
+    }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultAnnotationClass.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultAnnotationClass.kt
new file mode 100644
index 000000000..dbfcc1a71
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultAnnotationClass.kt
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.item
+
+import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
+import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.AnnotationRetention
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.annotation.AnnotationClass
+import com.android.tools.metalava.model.annotation.AnnotationDefaults
+import com.android.tools.metalava.model.findAnnotation
+import com.android.tools.metalava.model.value.FieldReferenceValue
+
+class DefaultAnnotationClass(private val classItem: ClassItem) : AnnotationClass {
+    override val retention by lazy(LazyThreadSafetyMode.NONE) { findRetention(classItem) }
+
+    override val defaults by
+        lazy(LazyThreadSafetyMode.NONE) {
+            val nameToValue =
+                classItem
+                    .methods()
+                    .mapNotNull {
+                        val value = it.defaultValue ?: return@mapNotNull null
+                        val name = it.name()
+                        name to value
+                    }
+                    .toMap()
+            if (nameToValue.isEmpty()) AnnotationDefaults.EMPTY else AnnotationDefaults(nameToValue)
+        }
+
+    companion object {
+        /** Looks up the retention policy for the given class */
+        private fun findRetention(cls: ClassItem): AnnotationRetention {
+            val modifiers = cls.modifiers
+            val annotation = modifiers.findAnnotation(AnnotationItem::isRetention)
+            val value = annotation?.findAttribute(ANNOTATION_ATTR_VALUE)?.value
+            val fieldName =
+                (value as? FieldReferenceValue)?.fieldName
+                    ?: return AnnotationRetention.getDefault(cls)
+            return AnnotationRetention.valueOf(fieldName)
+        }
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultCallableItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultCallableItem.kt
index f03a671aa..b11aebe68 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultCallableItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultCallableItem.kt
@@ -25,8 +25,9 @@ import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.ExceptionTypeItem
 import com.android.tools.metalava.model.ItemDocumentationFactory
-import com.android.tools.metalava.model.ItemLanguage
 import com.android.tools.metalava.model.ParameterItem
+import com.android.tools.metalava.model.SourceLanguage
+import com.android.tools.metalava.model.TargetLanguage
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.reporter.FileLocation
@@ -44,7 +45,8 @@ typealias ParameterItemsFactory = (CallableItem) -> List<ParameterItem>
 abstract class DefaultCallableItem(
     codebase: Codebase,
     fileLocation: FileLocation,
-    itemLanguage: ItemLanguage,
+    sourceLanguage: SourceLanguage,
+    targetLanguages: Set<TargetLanguage>,
     modifiers: BaseModifierList,
     documentationFactory: ItemDocumentationFactory,
     variantSelectorsFactory: ApiVariantSelectorsFactory,
@@ -59,7 +61,8 @@ abstract class DefaultCallableItem(
     DefaultMemberItem(
         codebase,
         fileLocation,
-        itemLanguage,
+        sourceLanguage,
+        targetLanguages,
         modifiers,
         documentationFactory,
         variantSelectorsFactory,
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultClassItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultClassItem.kt
index d3948e681..fab63eb6a 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultClassItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultClassItem.kt
@@ -16,7 +16,6 @@
 
 package com.android.tools.metalava.model.item
 
-import com.android.tools.metalava.model.AnnotationRetention
 import com.android.tools.metalava.model.ApiVariantSelectorsFactory
 import com.android.tools.metalava.model.BaseModifierList
 import com.android.tools.metalava.model.ClassItem
@@ -26,21 +25,24 @@ import com.android.tools.metalava.model.ClassTypeItem
 import com.android.tools.metalava.model.ConstructorItem
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.ItemDocumentationFactory
-import com.android.tools.metalava.model.ItemLanguage
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.MutableModifierList
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.PropertyItem
 import com.android.tools.metalava.model.SourceFile
+import com.android.tools.metalava.model.SourceLanguage
+import com.android.tools.metalava.model.TargetLanguage
 import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.model.VisibilityLevel
+import com.android.tools.metalava.model.annotation.AnnotationClass
 import com.android.tools.metalava.model.type.DefaultResolvedClassTypeItem
 import com.android.tools.metalava.reporter.FileLocation
 
 open class DefaultClassItem(
     codebase: DefaultCodebase,
     fileLocation: FileLocation,
-    itemLanguage: ItemLanguage,
+    sourceLanguage: SourceLanguage,
+    targetLanguages: Set<TargetLanguage>,
     modifiers: BaseModifierList,
     documentationFactory: ItemDocumentationFactory,
     variantSelectorsFactory: ApiVariantSelectorsFactory,
@@ -57,7 +59,8 @@ open class DefaultClassItem(
     DefaultSelectableItem(
         codebase = codebase,
         fileLocation = fileLocation,
-        itemLanguage = itemLanguage,
+        sourceLanguage = sourceLanguage,
+        targetLanguages = targetLanguages,
         modifiers = modifiers,
         documentationFactory = documentationFactory,
         variantSelectorsFactory = variantSelectorsFactory,
@@ -213,7 +216,7 @@ open class DefaultClassItem(
     override fun createDefaultConstructor(visibility: VisibilityLevel): ConstructorItem {
         return DefaultConstructorItem.createDefaultConstructor(
             codebase = codebase,
-            itemLanguage = itemLanguage,
+            sourceLanguage = sourceLanguage,
             variantSelectorsFactory = variantSelectors::duplicate,
             containingClass = this,
             visibility = visibility,
@@ -281,19 +284,19 @@ open class DefaultClassItem(
         mutableNestedClasses.add(classItem)
     }
 
-    /** Cache result of [getRetention]. */
-    private var cacheRetention: AnnotationRetention? = null
+    /** Cache value of [annotationClass]. */
+    private lateinit var cachedAnnotationClass: AnnotationClass
 
-    final override fun getRetention(): AnnotationRetention {
-        cacheRetention?.let {
-            return it
-        }
+    override val annotationClass: AnnotationClass
+        get() {
+            if (classKind != ClassKind.ANNOTATION_TYPE) {
+                error("annotationClass can only be accessed on annotation classes")
+            }
 
-        if (!isAnnotationType()) {
-            error("getRetention() should only be called on annotation classes")
-        }
+            if (!::cachedAnnotationClass.isInitialized) {
+                cachedAnnotationClass = DefaultAnnotationClass(this)
+            }
 
-        cacheRetention = ClassItem.findRetention(this)
-        return cacheRetention!!
-    }
+            return cachedAnnotationClass
+        }
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultCodebase.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultCodebase.kt
index 109bf275f..44c3e5fe4 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultCodebase.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultCodebase.kt
@@ -20,7 +20,6 @@ import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.AnnotationManager
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.DefaultAnnotationItem
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.TypeAliasItem
 import com.android.tools.metalava.model.api.surface.ApiSurfaces
@@ -197,6 +196,6 @@ open class DefaultCodebase(
         source: String,
         context: Item?,
     ): AnnotationItem? {
-        return DefaultAnnotationItem.create(this, source)
+        return AnnotationItem.createFromSource(this, source)
     }
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultConstructorItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultConstructorItem.kt
index aa070f033..6bfe66817 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultConstructorItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultConstructorItem.kt
@@ -27,7 +27,9 @@ import com.android.tools.metalava.model.ConstructorItem
 import com.android.tools.metalava.model.ExceptionTypeItem
 import com.android.tools.metalava.model.ItemDocumentation
 import com.android.tools.metalava.model.ItemDocumentationFactory
-import com.android.tools.metalava.model.ItemLanguage
+import com.android.tools.metalava.model.SourceLanguage
+import com.android.tools.metalava.model.TargetLanguage
+import com.android.tools.metalava.model.TargetLanguageSet
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.model.VisibilityLevel
@@ -37,7 +39,8 @@ import com.android.tools.metalava.reporter.FileLocation
 open class DefaultConstructorItem(
     codebase: Codebase,
     fileLocation: FileLocation,
-    itemLanguage: ItemLanguage,
+    sourceLanguage: SourceLanguage,
+    targetLanguages: Set<TargetLanguage>,
     modifiers: BaseModifierList,
     documentationFactory: ItemDocumentationFactory,
     variantSelectorsFactory: ApiVariantSelectorsFactory,
@@ -54,7 +57,8 @@ open class DefaultConstructorItem(
     DefaultCallableItem(
         codebase = codebase,
         fileLocation = fileLocation,
-        itemLanguage = itemLanguage,
+        sourceLanguage = sourceLanguage,
+        targetLanguages = targetLanguages,
         modifiers = modifiers,
         documentationFactory = documentationFactory,
         variantSelectorsFactory = variantSelectorsFactory,
@@ -81,7 +85,7 @@ open class DefaultConstructorItem(
     companion object {
         fun createDefaultConstructor(
             codebase: Codebase,
-            itemLanguage: ItemLanguage,
+            sourceLanguage: SourceLanguage,
             variantSelectorsFactory: ApiVariantSelectorsFactory,
             containingClass: ClassItem,
             visibility: VisibilityLevel,
@@ -94,7 +98,8 @@ open class DefaultConstructorItem(
                     codebase = codebase,
                     // Use the location of the containing class for the default constructor.
                     fileLocation = containingClass.fileLocation,
-                    itemLanguage = itemLanguage,
+                    sourceLanguage = sourceLanguage,
+                    targetLanguages = TargetLanguageSet.ALL,
                     modifiers = modifiers,
                     documentationFactory = ItemDocumentation.NONE_FACTORY,
                     variantSelectorsFactory = variantSelectorsFactory,
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultFieldItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultFieldItem.kt
index 3298f1da3..d39134c69 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultFieldItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultFieldItem.kt
@@ -22,14 +22,18 @@ import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.ItemDocumentationFactory
-import com.android.tools.metalava.model.ItemLanguage
+import com.android.tools.metalava.model.SourceLanguage
+import com.android.tools.metalava.model.TargetLanguage
 import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.value.ConstantValue
+import com.android.tools.metalava.model.value.OptionalValueProvider
 import com.android.tools.metalava.reporter.FileLocation
 
 open class DefaultFieldItem(
     codebase: Codebase,
     fileLocation: FileLocation,
-    itemLanguage: ItemLanguage,
+    sourceLanguage: SourceLanguage,
+    targetLanguages: Set<TargetLanguage>,
     variantSelectorsFactory: ApiVariantSelectorsFactory,
     modifiers: BaseModifierList,
     documentationFactory: ItemDocumentationFactory,
@@ -37,12 +41,13 @@ open class DefaultFieldItem(
     containingClass: ClassItem,
     private var type: TypeItem,
     private val isEnumConstant: Boolean,
-    override val legacyFieldValue: FieldValue?,
+    private val constantValueProvider: OptionalValueProvider?,
 ) :
     DefaultMemberItem(
         codebase = codebase,
         fileLocation = fileLocation,
-        itemLanguage = itemLanguage,
+        sourceLanguage = sourceLanguage,
+        targetLanguages = targetLanguages,
         modifiers = modifiers,
         documentationFactory = documentationFactory,
         variantSelectorsFactory = variantSelectorsFactory,
@@ -63,7 +68,8 @@ open class DefaultFieldItem(
         DefaultFieldItem(
                 codebase = codebase,
                 fileLocation = fileLocation,
-                itemLanguage = itemLanguage,
+                sourceLanguage = sourceLanguage,
+                targetLanguages = targetLanguages,
                 variantSelectorsFactory = variantSelectors::duplicate,
                 modifiers = modifiers,
                 documentationFactory = documentation::duplicate,
@@ -71,12 +77,12 @@ open class DefaultFieldItem(
                 containingClass = targetContainingClass,
                 type = type,
                 isEnumConstant = isEnumConstant,
-                legacyFieldValue = legacyFieldValue,
+                constantValueProvider = constantValueProvider,
             )
             .also { duplicated -> duplicated.inheritedFrom = containingClass() }
 
-    final override fun legacyInitialValue(requireConstant: Boolean) =
-        legacyFieldValue?.initialValue(requireConstant)
+    final override val constantValue
+        get() = constantValueProvider?.optionalValue?.let { it as ConstantValue }
 
     final override fun isEnumConstant(): Boolean = isEnumConstant
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultItemFactory.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultItemFactory.kt
index 98bfd37c9..9f3368f69 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultItemFactory.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultItemFactory.kt
@@ -31,15 +31,18 @@ import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.ItemDocumentation
 import com.android.tools.metalava.model.ItemDocumentationFactory
-import com.android.tools.metalava.model.ItemLanguage
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.PropertyItem
 import com.android.tools.metalava.model.SourceFile
+import com.android.tools.metalava.model.SourceLanguage
+import com.android.tools.metalava.model.TargetLanguage
+import com.android.tools.metalava.model.TargetLanguageSet
 import com.android.tools.metalava.model.TypeAliasItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterList
+import com.android.tools.metalava.model.value.OptionalValueProvider
 import com.android.tools.metalava.reporter.FileLocation
 
 /**
@@ -53,7 +56,7 @@ class DefaultItemFactory(
     private val codebase: DefaultCodebase,
 
     /** The default language for [Item]s created by this. */
-    private val defaultItemLanguage: ItemLanguage,
+    private val defaultSourceLanguage: SourceLanguage,
 
     /** The default [ApiVariantSelectorsFactory] for [Item]s created by this. */
     private val defaultVariantSelectorsFactory: ApiVariantSelectorsFactory,
@@ -66,11 +69,13 @@ class DefaultItemFactory(
         qualifiedName: String,
         containingPackage: PackageItem?,
         overviewDocumentation: ResourceFile?,
+        targetLanguages: Set<TargetLanguage> = TargetLanguageSet.ALL,
     ): DefaultPackageItem {
         return DefaultPackageItem(
             codebase,
             fileLocation,
-            defaultItemLanguage,
+            defaultSourceLanguage,
+            targetLanguages,
             modifiers,
             documentationFactory,
             defaultVariantSelectorsFactory,
@@ -83,7 +88,8 @@ class DefaultItemFactory(
     /** Create a [ConstructorItem]. */
     fun createClassItem(
         fileLocation: FileLocation,
-        itemLanguage: ItemLanguage = defaultItemLanguage,
+        sourceLanguage: SourceLanguage = defaultSourceLanguage,
+        targetLanguages: Set<TargetLanguage> = TargetLanguageSet.ALL,
         modifiers: BaseModifierList,
         documentationFactory: ItemDocumentationFactory = ItemDocumentation.NONE_FACTORY,
         source: SourceFile? = null,
@@ -99,7 +105,8 @@ class DefaultItemFactory(
         DefaultClassItem(
             codebase,
             fileLocation,
-            itemLanguage,
+            sourceLanguage,
+            targetLanguages,
             modifiers,
             documentationFactory,
             defaultVariantSelectorsFactory,
@@ -117,7 +124,8 @@ class DefaultItemFactory(
     /** Create a [ConstructorItem]. */
     fun createConstructorItem(
         fileLocation: FileLocation,
-        itemLanguage: ItemLanguage = defaultItemLanguage,
+        sourceLanguage: SourceLanguage = defaultSourceLanguage,
+        targetLanguages: Set<TargetLanguage> = TargetLanguageSet.ALL,
         modifiers: BaseModifierList,
         documentationFactory: ItemDocumentationFactory,
         name: String,
@@ -133,7 +141,8 @@ class DefaultItemFactory(
         DefaultConstructorItem(
             codebase,
             fileLocation,
-            itemLanguage,
+            sourceLanguage,
+            targetLanguages,
             modifiers,
             documentationFactory,
             defaultVariantSelectorsFactory,
@@ -151,19 +160,21 @@ class DefaultItemFactory(
     /** Create a [FieldItem]. */
     fun createFieldItem(
         fileLocation: FileLocation,
-        itemLanguage: ItemLanguage = defaultItemLanguage,
+        sourceLanguage: SourceLanguage = defaultSourceLanguage,
+        targetLanguages: Set<TargetLanguage> = TargetLanguageSet.ALL,
         modifiers: BaseModifierList,
         documentationFactory: ItemDocumentationFactory,
         name: String,
         containingClass: ClassItem,
         type: TypeItem,
         isEnumConstant: Boolean,
-        fieldValue: FieldValue?,
+        constantValueProvider: OptionalValueProvider?,
     ): FieldItem =
         DefaultFieldItem(
             codebase,
             fileLocation,
-            itemLanguage,
+            sourceLanguage,
+            targetLanguages,
             defaultVariantSelectorsFactory,
             modifiers,
             documentationFactory,
@@ -171,13 +182,14 @@ class DefaultItemFactory(
             containingClass,
             type,
             isEnumConstant,
-            fieldValue,
+            constantValueProvider,
         )
 
     /** Create a [MethodItem]. */
     fun createMethodItem(
         fileLocation: FileLocation,
-        itemLanguage: ItemLanguage = defaultItemLanguage,
+        sourceLanguage: SourceLanguage = defaultSourceLanguage,
+        targetLanguages: Set<TargetLanguage> = TargetLanguageSet.ALL,
         modifiers: BaseModifierList,
         documentationFactory: ItemDocumentationFactory,
         name: String,
@@ -187,12 +199,13 @@ class DefaultItemFactory(
         parameterItemsFactory: ParameterItemsFactory,
         throwsTypes: List<ExceptionTypeItem>,
         callableBodyFactory: CallableBodyFactory = CallableBody.UNAVAILABLE_FACTORY,
-        annotationDefault: String,
+        defaultValueProvider: OptionalValueProvider?,
     ): MethodItem =
         DefaultMethodItem(
             codebase,
             fileLocation,
-            itemLanguage,
+            sourceLanguage,
+            targetLanguages,
             modifiers,
             documentationFactory,
             defaultVariantSelectorsFactory,
@@ -203,13 +216,13 @@ class DefaultItemFactory(
             parameterItemsFactory,
             throwsTypes,
             callableBodyFactory,
-            annotationDefault,
+            defaultValueProvider,
         )
 
     /** Create a [ParameterItem]. */
     fun createParameterItem(
         fileLocation: FileLocation,
-        itemLanguage: ItemLanguage = defaultItemLanguage,
+        sourceLanguage: SourceLanguage = defaultSourceLanguage,
         modifiers: BaseModifierList,
         name: String,
         publicNameProvider: PublicNameProvider,
@@ -221,7 +234,7 @@ class DefaultItemFactory(
         DefaultParameterItem(
             codebase,
             fileLocation,
-            itemLanguage,
+            sourceLanguage,
             modifiers,
             name,
             publicNameProvider,
@@ -234,7 +247,7 @@ class DefaultItemFactory(
     /** Create a [PropertyItem]. */
     fun createPropertyItem(
         fileLocation: FileLocation,
-        itemLanguage: ItemLanguage = defaultItemLanguage,
+        sourceLanguage: SourceLanguage = defaultSourceLanguage,
         documentationFactory: ItemDocumentationFactory = ItemDocumentation.NONE_FACTORY,
         modifiers: BaseModifierList,
         name: String,
@@ -250,7 +263,7 @@ class DefaultItemFactory(
         DefaultPropertyItem(
             codebase,
             fileLocation,
-            itemLanguage,
+            sourceLanguage,
             documentationFactory,
             defaultVariantSelectorsFactory,
             modifiers,
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultMemberItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultMemberItem.kt
index 158740695..57f0f7a41 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultMemberItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultMemberItem.kt
@@ -21,14 +21,16 @@ import com.android.tools.metalava.model.BaseModifierList
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.ItemDocumentationFactory
-import com.android.tools.metalava.model.ItemLanguage
 import com.android.tools.metalava.model.MemberItem
+import com.android.tools.metalava.model.SourceLanguage
+import com.android.tools.metalava.model.TargetLanguage
 import com.android.tools.metalava.reporter.FileLocation
 
 abstract class DefaultMemberItem(
     codebase: Codebase,
     fileLocation: FileLocation,
-    itemLanguage: ItemLanguage,
+    sourceLanguage: SourceLanguage,
+    targetLanguages: Set<TargetLanguage>,
     modifiers: BaseModifierList,
     documentationFactory: ItemDocumentationFactory,
     variantSelectorsFactory: ApiVariantSelectorsFactory,
@@ -38,7 +40,8 @@ abstract class DefaultMemberItem(
     DefaultSelectableItem(
         codebase = codebase,
         fileLocation = fileLocation,
-        itemLanguage = itemLanguage,
+        sourceLanguage = sourceLanguage,
+        targetLanguages = targetLanguages,
         modifiers = modifiers,
         documentationFactory = documentationFactory,
         variantSelectorsFactory = variantSelectorsFactory,
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultMethodItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultMethodItem.kt
index d74f5e45d..46e702f17 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultMethodItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultMethodItem.kt
@@ -23,16 +23,19 @@ import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.ExceptionTypeItem
 import com.android.tools.metalava.model.ItemDocumentationFactory
-import com.android.tools.metalava.model.ItemLanguage
 import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.SourceLanguage
+import com.android.tools.metalava.model.TargetLanguage
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterList
+import com.android.tools.metalava.model.value.OptionalValueProvider
 import com.android.tools.metalava.reporter.FileLocation
 
 open class DefaultMethodItem(
     codebase: Codebase,
     fileLocation: FileLocation,
-    itemLanguage: ItemLanguage,
+    sourceLanguage: SourceLanguage,
+    targetLanguages: Set<TargetLanguage>,
     modifiers: BaseModifierList,
     documentationFactory: ItemDocumentationFactory,
     variantSelectorsFactory: ApiVariantSelectorsFactory,
@@ -43,12 +46,13 @@ open class DefaultMethodItem(
     parameterItemsFactory: ParameterItemsFactory,
     throwsTypes: List<ExceptionTypeItem>,
     callableBodyFactory: CallableBodyFactory,
-    private val annotationDefault: String = "",
+    private val defaultValueProvider: OptionalValueProvider?,
 ) :
     DefaultCallableItem(
         codebase,
         fileLocation,
-        itemLanguage,
+        sourceLanguage,
+        targetLanguages,
         modifiers,
         documentationFactory,
         variantSelectorsFactory,
@@ -66,7 +70,8 @@ open class DefaultMethodItem(
 
     override fun isExtensionMethod(): Boolean = false // java does not support extension methods
 
-    override fun legacyDefaultValue() = annotationDefault
+    final override val defaultValue
+        get() = defaultValueProvider?.optionalValue
 
     private lateinit var superMethodList: List<MethodItem>
 
@@ -102,7 +107,8 @@ open class DefaultMethodItem(
         return DefaultMethodItem(
                 codebase = codebase,
                 fileLocation = fileLocation,
-                itemLanguage = itemLanguage,
+                sourceLanguage = sourceLanguage,
+                targetLanguages = targetLanguages,
                 modifiers = modifiers,
                 documentationFactory = documentation::duplicate,
                 variantSelectorsFactory = variantSelectors::duplicate,
@@ -115,8 +121,8 @@ open class DefaultMethodItem(
                     parameters.map { it.duplicate(containingCallable, typeVariableMap) }
                 },
                 throwsTypes = throwsTypes,
-                annotationDefault = annotationDefault,
                 callableBodyFactory = body::duplicate,
+                defaultValueProvider = defaultValueProvider,
             )
             .also { duplicated ->
                 duplicated.inheritedFrom = containingClass()
@@ -213,8 +219,8 @@ open class DefaultMethodItem(
                     methods.add(superMethod)
                 }
             }
-            // A method could not be found in this interface so search its interfaces.
-            ?: appendSuperMethodsFromInterfaces(methods, itfClass)
+                // A method could not be found in this interface so search its interfaces.
+                ?: appendSuperMethodsFromInterfaces(methods, itfClass)
         }
     }
 
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPackageItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPackageItem.kt
index 0a62b6183..62c24a1d4 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPackageItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPackageItem.kt
@@ -21,15 +21,17 @@ import com.android.tools.metalava.model.BaseModifierList
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.ItemDocumentationFactory
-import com.android.tools.metalava.model.ItemLanguage
 import com.android.tools.metalava.model.PackageItem
+import com.android.tools.metalava.model.SourceLanguage
+import com.android.tools.metalava.model.TargetLanguage
 import com.android.tools.metalava.model.TypeAliasItem
 import com.android.tools.metalava.reporter.FileLocation
 
 open class DefaultPackageItem(
     codebase: Codebase,
     fileLocation: FileLocation,
-    itemLanguage: ItemLanguage,
+    sourceLanguage: SourceLanguage,
+    targetLanguages: Set<TargetLanguage>,
     modifiers: BaseModifierList,
     documentationFactory: ItemDocumentationFactory,
     variantSelectorsFactory: ApiVariantSelectorsFactory,
@@ -40,7 +42,8 @@ open class DefaultPackageItem(
     DefaultSelectableItem(
         codebase = codebase,
         fileLocation = fileLocation,
-        itemLanguage = itemLanguage,
+        sourceLanguage = sourceLanguage,
+        targetLanguages = targetLanguages,
         modifiers = modifiers,
         documentationFactory = documentationFactory,
         variantSelectorsFactory = variantSelectorsFactory,
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultParameterItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultParameterItem.kt
index 18aea2abd..cf7b29acc 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultParameterItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultParameterItem.kt
@@ -22,8 +22,8 @@ import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.DefaultItem
 import com.android.tools.metalava.model.ItemDocumentation
-import com.android.tools.metalava.model.ItemLanguage
 import com.android.tools.metalava.model.ParameterItem
+import com.android.tools.metalava.model.SourceLanguage
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterBindings
 import com.android.tools.metalava.reporter.FileLocation
@@ -31,7 +31,7 @@ import com.android.tools.metalava.reporter.FileLocation
 open class DefaultParameterItem(
     codebase: Codebase,
     fileLocation: FileLocation,
-    itemLanguage: ItemLanguage,
+    sourceLanguage: SourceLanguage,
     modifiers: BaseModifierList,
     private val name: String,
     protected val publicNameProvider: PublicNameProvider,
@@ -43,7 +43,7 @@ open class DefaultParameterItem(
     DefaultItem(
         codebase = codebase,
         fileLocation = fileLocation,
-        itemLanguage = itemLanguage,
+        sourceLanguage = sourceLanguage,
         modifiers = modifiers,
         documentationFactory = ItemDocumentation.NONE_FACTORY,
     ),
@@ -81,7 +81,7 @@ open class DefaultParameterItem(
         DefaultParameterItem(
             codebase,
             fileLocation,
-            itemLanguage,
+            sourceLanguage,
             modifiers,
             name(),
             publicNameProvider,
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPropertyItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPropertyItem.kt
index 301c03f28..005b7a03f 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPropertyItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPropertyItem.kt
@@ -22,10 +22,11 @@ import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.ItemDocumentationFactory
-import com.android.tools.metalava.model.ItemLanguage
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.PropertyItem
+import com.android.tools.metalava.model.SourceLanguage
+import com.android.tools.metalava.model.TargetLanguageSet
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.reporter.FileLocation
@@ -33,7 +34,7 @@ import com.android.tools.metalava.reporter.FileLocation
 open class DefaultPropertyItem(
     codebase: Codebase,
     fileLocation: FileLocation,
-    itemLanguage: ItemLanguage,
+    sourceLanguage: SourceLanguage,
     documentationFactory: ItemDocumentationFactory,
     variantSelectorsFactory: ApiVariantSelectorsFactory,
     modifiers: BaseModifierList,
@@ -50,7 +51,10 @@ open class DefaultPropertyItem(
     DefaultMemberItem(
         codebase,
         fileLocation,
-        itemLanguage,
+        sourceLanguage,
+        // Properties can only be used directly from Kotlin. They are used from Java through their
+        // accessors and/or backing field.
+        targetLanguages = TargetLanguageSet.KOTLIN_ONLY,
         modifiers,
         documentationFactory,
         variantSelectorsFactory,
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultSelectableItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultSelectableItem.kt
index 687ab8207..a66a81201 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultSelectableItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultSelectableItem.kt
@@ -22,9 +22,10 @@ import com.android.tools.metalava.model.BaseModifierList
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.DefaultItem
 import com.android.tools.metalava.model.ItemDocumentationFactory
-import com.android.tools.metalava.model.ItemLanguage
 import com.android.tools.metalava.model.SelectableItem
 import com.android.tools.metalava.model.Showability
+import com.android.tools.metalava.model.SourceLanguage
+import com.android.tools.metalava.model.TargetLanguage
 import com.android.tools.metalava.model.api.surface.ApiVariantSet
 import com.android.tools.metalava.model.api.surface.MutableApiVariantSet
 import com.android.tools.metalava.reporter.FileLocation
@@ -32,15 +33,16 @@ import com.android.tools.metalava.reporter.FileLocation
 abstract class DefaultSelectableItem(
     codebase: Codebase,
     fileLocation: FileLocation,
-    itemLanguage: ItemLanguage,
+    sourceLanguage: SourceLanguage,
     modifiers: BaseModifierList,
     documentationFactory: ItemDocumentationFactory,
     variantSelectorsFactory: ApiVariantSelectorsFactory,
+    override val targetLanguages: Set<TargetLanguage>,
 ) :
     DefaultItem(
         codebase,
         fileLocation,
-        itemLanguage,
+        sourceLanguage,
         modifiers,
         documentationFactory,
     ),
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultTypeAliasItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultTypeAliasItem.kt
index 876fa0db9..889b6e4a3 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultTypeAliasItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultTypeAliasItem.kt
@@ -19,8 +19,9 @@ package com.android.tools.metalava.model.item
 import com.android.tools.metalava.model.ApiVariantSelectorsFactory
 import com.android.tools.metalava.model.BaseModifierList
 import com.android.tools.metalava.model.ItemDocumentationFactory
-import com.android.tools.metalava.model.ItemLanguage
 import com.android.tools.metalava.model.PackageItem
+import com.android.tools.metalava.model.SourceLanguage
+import com.android.tools.metalava.model.TargetLanguageSet
 import com.android.tools.metalava.model.TypeAliasItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterList
@@ -42,7 +43,9 @@ open class DefaultTypeAliasItem(
         codebase = codebase,
         fileLocation = fileLocation,
         // Type aliases only exist in Kotlin
-        itemLanguage = ItemLanguage.KOTLIN,
+        sourceLanguage = SourceLanguage.KOTLIN,
+        // Type aliases can only be used from Kotlin
+        targetLanguages = TargetLanguageSet.KOTLIN_ONLY,
         modifiers = modifiers,
         documentationFactory = documentationFactory,
         variantSelectorsFactory = variantSelectorsFactory,
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultTypeParameterItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultTypeParameterItem.kt
index 65dbdd8d4..722c11632 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultTypeParameterItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultTypeParameterItem.kt
@@ -18,7 +18,8 @@ package com.android.tools.metalava.model.item
 
 import com.android.tools.metalava.model.BaseModifierList
 import com.android.tools.metalava.model.BoundsTypeItem
-import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.ClassResolver
+import com.android.tools.metalava.model.JAVA_LANG_OBJECT
 import com.android.tools.metalava.model.ModifierList
 import com.android.tools.metalava.model.TypeParameterItem
 import com.android.tools.metalava.model.VariableTypeItem
@@ -27,7 +28,7 @@ import com.android.tools.metalava.model.type.DefaultVariableTypeItem
 
 /** A [TypeParameterItem] implementation suitable for use by multiple models. */
 open class DefaultTypeParameterItem(
-    override val codebase: Codebase,
+    protected open val classResolver: ClassResolver,
     modifiers: BaseModifierList,
     private val name: String,
     private val isReified: Boolean,
@@ -55,6 +56,9 @@ open class DefaultTypeParameterItem(
 
     final override fun typeBounds(): List<BoundsTypeItem> = bounds
 
+    override fun asErasedType() =
+        typeBounds().firstOrNull() ?: classResolver.resolveClass(JAVA_LANG_OBJECT)?.type()
+
     final override fun isReified(): Boolean = isReified
 
     override fun equals(other: Any?): Boolean {
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/parser/ParseException.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/parser/ParseException.kt
new file mode 100644
index 000000000..673a41926
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/parser/ParseException.kt
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tools.metalava.model.parser
+
+import com.android.tools.metalava.model.MetalavaApi
+import com.android.tools.metalava.reporter.FileLocation
+
+@MetalavaApi
+open class ParseException(
+    message: String,
+    private val location: FileLocation? = null,
+) : Exception(message) {
+
+    override val message: String
+        get() {
+            return buildString {
+                location?.appendTo(this)
+                if (isNotEmpty()) {
+                    append(": ")
+                }
+                append(super.message)
+            }
+        }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/parser/Tokenizer.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/parser/Tokenizer.kt
new file mode 100644
index 000000000..bceddbd2e
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/parser/Tokenizer.kt
@@ -0,0 +1,352 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.parser
+
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.value.Value
+import com.android.tools.metalava.reporter.FileLocation
+import java.nio.file.Path
+
+/**
+ * Extracts tokens from a sequence of characters.
+ *
+ * The tokens are not the usual sort of tokens created by a tokenizer, e.g. some tokens contain
+ * white spaces and even whole strings. e.g. an annotation, including parameters if present, can be
+ * returned as a single token, if requested (e.g. by calling [requireToken] with
+ * `purpose=TokenPurpose.VALUE`).
+ *
+ * @param path the [Path] to the source being read.
+ * @param buffer the [CharArray] from which this will read tokens.
+ * @param exceptionCreator factory method for creating exceptions that will be thrown.
+ */
+class Tokenizer(
+    private val path: Path,
+    private val buffer: CharArray,
+    private val exceptionCreator: (String, FileLocation) -> ParseException = ::ParseException,
+) : FileLocationTracker {
+
+    /** The position of the next character to read in [buffer]. */
+    private var position = 0
+
+    /** The current line being read. */
+    private var line = 1
+
+    override fun fileLocation(): FileLocation {
+        return FileLocation.createLocation(path, line)
+    }
+
+    private fun throwException(message: String): Nothing {
+        throw exceptionCreator(message, fileLocation())
+    }
+
+    /** Get the remainder. */
+    fun remainder(): String = String(buffer, position, buffer.size - position)
+
+    /**
+     * Eat whitespace, including newline characters.
+     *
+     * Scans through the [buffer] from the current [position], stopping at the first non-whitespace
+     * character, updating [position] and [line] as needed.
+     *
+     * @return `true` if any whitespace characters were eaten, `false` otherwise.
+     */
+    private fun eatWhitespace(): Boolean {
+        var ate = false
+        while (position < buffer.size && isSpace(buffer[position])) {
+            if (buffer[position] == '\n') {
+                line++
+            }
+            position++
+            ate = true
+        }
+        return ate
+    }
+
+    /**
+     * Eat a line comment, if any, starting at the current [position] and ending at the end of the
+     * line but not moving onto the next line.
+     *
+     * If [position] does not point to a `/` immediately followed by another `/` then this does
+     * nothing.
+     *
+     * @return `true` if a line comment was found, `false` otherwise.
+     */
+    private fun eatComment(): Boolean {
+        if (position + 1 < buffer.size) {
+            if (buffer[position] == '/' && buffer[position + 1] == '/') {
+                position += 2
+                while (position < buffer.size && !isNewline(buffer[position])) {
+                    position++
+                }
+                return true
+            }
+        }
+        return false
+    }
+
+    /** Eat whitespace and line comments until a non-whitespace, non-line comment is found. */
+    private fun eatWhitespaceAndComments() {
+        while (eatWhitespace() || eatComment()) {
+            // intentionally consume whitespace and comments
+        }
+    }
+
+    /**
+     * Get the next token, failing if the end of the file is reached.
+     *
+     * @param purpose determines which characters will be included in the token.
+     * @return the token String found.
+     */
+    fun requireToken(purpose: TokenPurpose = TokenPurpose.GENERAL): String {
+        val token = getToken(purpose)
+        return token ?: throwException("Unexpected end of file")
+    }
+
+    /**
+     * The current [position], used to record the start of a block of text that will be retrieved
+     * later by [getStringFromOffset].
+     */
+    fun offset(): Int {
+        return position
+    }
+
+    /**
+     * Get the contents of [buffer] from [offset] to [position].
+     *
+     * @param offset an offset previously returned by [offset].
+     */
+    fun getStringFromOffset(offset: Int): String {
+        return String(buffer, offset, position - offset)
+    }
+
+    /** The current token. */
+    lateinit var current: String
+
+    /**
+     * Get the next token, returning null if the end of the file is reached.
+     *
+     * @param purpose determines which characters will be included in the token.
+     * @return the token String found, or null.
+     */
+    fun getToken(purpose: TokenPurpose = TokenPurpose.GENERAL): String? {
+        // Eat any white space or comments that come before the token.
+        eatWhitespaceAndComments()
+
+        if (position >= buffer.size) {
+            return null
+        }
+        val start = position
+        // If the first character is a separator then that is the token.
+        if (isSeparator(buffer[position], purpose)) {
+            // Nothing else to do, the separator is the token.
+            position++
+        } else {
+            scanForEndOfToken(purpose)
+        }
+        current = String(buffer, start, position - start)
+        return current
+    }
+
+    /**
+     * Scan from [position] (which is the start of the token) to the end of the token and return.
+     *
+     * When this returns [position] will point to the character after the end of the token.
+     *
+     * @see inlinedScanForEndOfTokenFragment
+     */
+    private fun scanForEndOfToken(purpose: TokenPurpose) {
+        inlinedScanForEndOfTokenFragment(purpose) { c -> isSpace(c) || isSeparator(c, purpose) }
+    }
+
+    /**
+     * Scan from [position] (which is the start of the token fragment) to the end of the token
+     * fragment and return.
+     *
+     * A token fragment is a whole token or part of a token. e.g. while "1" is a whole token, given
+     * a token of "Generic<AnotherGeneric<A>, B>" then "<AnotherGeneric<A>, B>" is a token fragment
+     * of the whole token and "<A>" is a token fragment of that.
+     *
+     * A token fragment starts with [openChar] and ends with [closeChar]. It is an error if the end
+     * of the buffer is reached before matching the corresponding [closeChar] character.
+     *
+     * @see inlinedScanForEndOfTokenFragment
+     */
+    private fun scanForEndOfTokenFragment(openChar: Char, closeChar: Char) {
+        inlinedScanForEndOfTokenFragment(purpose = TokenPurpose.VALUE, openChar) { c ->
+            c == closeChar
+        }
+    }
+
+    /**
+     * An inline function that avoids duplicating almost identical code in [scanForEndOfToken] and
+     * [scanForEndOfTokenFragment] while avoiding the performance cost of passing lambdas as
+     * parameters.
+     *
+     * Scan from [position] (which is the start of the token, or token fragment) to the end of the
+     * token, or token fragment, and return.
+     *
+     * When [openChar] is `null` this is scanning for the end of a token and will stop when it
+     * either reaches a character matched by [endOfTokenPredicate] or the end of the buffer. On
+     * return [position] will point to the matched character or just past the end of the buffer
+     * respectively.
+     *
+     * When [openChar] is not-null then this is scanning for the end of a token fragment and will
+     * stop when it reaches a character matched by [endOfTokenPredicate]. It is an error if it hits
+     * the end of the buffer before it matches a character. On return [position] will point to just
+     * after the matched character.
+     *
+     * If this finds a `<` character it will call [scanForEndOfTokenFragment] to find the matching
+     * `>` character, failing if it reaches the end of the buffer first.
+     *
+     * If [purpose] is [TokenPurpose.VALUE] and this finds a `(` character, it will call
+     * [scanForEndOfTokenFragment] to find the matching `)` character, failing if it reaches the end
+     * of the buffer first.
+     */
+    private inline fun inlinedScanForEndOfTokenFragment(
+        purpose: TokenPurpose,
+        openChar: Char? = null,
+        endOfTokenPredicate: (Char) -> Boolean
+    ) {
+        val line = line
+        while (position < buffer.size) {
+            // Get the next character and assume that it is part of the token by incrementing the
+            // position.
+            val c = buffer[position]
+            position++
+
+            if (c == '"') {
+                scanForClosingQuotes()
+            } else if (c == '<') {
+                // Open a type parameter/argument list. Make sure to continue to the next `>`.
+                scanForEndOfTokenFragment('<', '>')
+            } else if (purpose == TokenPurpose.VALUE && c == '(') {
+                // Open a parenthesized fragment. Make sure to continue to the next `)`.
+                scanForEndOfTokenFragment('(', ')')
+            } else if (purpose == TokenPurpose.VALUE && c == '{') {
+                // Open a braced fragment. Make sure to continue to the next `}`.
+                scanForEndOfTokenFragment('{', '}')
+            } else if (endOfTokenPredicate(c)) {
+                if (openChar == null) {
+                    position--
+                }
+                return
+            }
+        }
+
+        // If reached the end of the buffer but the token is incomplete then throw an error.
+        if (openChar != null) {
+            throwException("Unexpected end of file for $openChar starting at $line")
+        }
+    }
+
+    /**
+     * Scan from [position] (which should be immediately after the opening quotes) until after the
+     * matching closing quotes.
+     */
+    private fun scanForClosingQuotes() {
+        while (position < buffer.size) {
+            val k = buffer[position]
+            position++
+            if (k == '\n' || k == '\r') {
+                throwException("Unexpected newline for \" starting at $line")
+            }
+
+            if (k == '"') {
+                return
+            } else if (k == '\\') {
+                // Skip the escaped character. This only really matters if the character is a quote
+                // as without skipping it would be treated as the closing quote.
+                position++
+            }
+        }
+        throwException("Unexpected end of file for \" starting at $line")
+    }
+
+    fun assertIdent(token: String) {
+        if (!isIdent(token[0])) {
+            throwException("Expected identifier: $token")
+        }
+    }
+
+    companion object {
+        private fun isSpace(c: Char): Boolean {
+            return c == ' ' || c == '\t' || c == '\n' || c == '\r'
+        }
+
+        private fun isNewline(c: Char): Boolean {
+            return c == '\n' || c == '\r'
+        }
+
+        private fun isSeparator(c: Char, purpose: TokenPurpose): Boolean {
+            if (purpose == TokenPurpose.GENERAL) {
+                // This only affects whether an open parenthesis is treated as a separator. A close
+                // parenthesis is always treated as a separator because:
+                // 1. If an open parenthesis is a separator then so should a close parenthesis.
+                // 2. If an open parenthesis is not a separator then its matching close parenthesis
+                //    will be included in the token irrespective of whether it is a separator or
+                //    not.
+                // 3. An unbalanced close parenthesis, e.g. in `attr=1)`, should be treated as a
+                //    separator so it is not included in the preceding token, e.g. the above should
+                //    tokenize as `attr`, `=`, `1`, `)`  and NOT `attr`, `=`, `1)`.
+                // Ditto for open and close braces.
+                if (c == '(' || c == '{') {
+                    return true
+                }
+            }
+            return c == ')' || c == '}' || c == ',' || c == ';' || c == '<' || c == '>' || c == '='
+        }
+
+        private fun isIdent(c: Char): Boolean {
+            return c != '"' && !isSeparator(c, TokenPurpose.GENERAL)
+        }
+
+        fun isIdent(token: String): Boolean {
+            return isIdent(token[0])
+        }
+    }
+}
+
+/** The purpose for which a token will be used. */
+enum class TokenPurpose {
+    /**
+     * General purpose, e.g. for parsing signature files.
+     *
+     * This will generally return unbalanced tokens, e.g. `{` and `}` will be returned separately.
+     * The sole exception is `<` and `>` which will be balanced for use in [TypeItem]s.
+     */
+    GENERAL,
+
+    /**
+     * The token will represent a [Value].
+     *
+     * This will balance out delimiters like `(` and `)`.
+     */
+    VALUE,
+}
+
+/**
+ * Interface implemented by [Tokenizer] which keeps track of the [FileLocation] for the current
+ * token.
+ *
+ * This is provided to avoid passing [Tokenizer] to code that might need access to the current
+ * [FileLocation] but does not consume tokens. That makes that code and the [Tokenizer] state easier
+ * to reason about.
+ */
+interface FileLocationTracker {
+    /** Get the current [FileLocation]. */
+    fun fileLocation(): FileLocation
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/provider/Capability.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/provider/Capability.kt
index 6e75500b1..f7f6d9268 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/provider/Capability.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/provider/Capability.kt
@@ -29,4 +29,7 @@ enum class Capability() {
 
     /** Has access to documentation. */
     DOCUMENTATION,
+
+    /** Can load additional APIs from a jar file when creating an API from source files. */
+    JAR_WITH_SOURCES,
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/CodebaseSnapshotTaker.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/CodebaseSnapshotTaker.kt
index fb1e25103..f3a244f09 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/CodebaseSnapshotTaker.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/CodebaseSnapshotTaker.kt
@@ -27,7 +27,6 @@ import com.android.tools.metalava.model.DelegatedVisitor
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.ItemDocumentationFactory
-import com.android.tools.metalava.model.ItemLanguage
 import com.android.tools.metalava.model.ItemVisitor
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.ModifierList
@@ -36,6 +35,7 @@ import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.PropertyItem
 import com.android.tools.metalava.model.SelectableItem
 import com.android.tools.metalava.model.Showability
+import com.android.tools.metalava.model.SourceLanguage
 import com.android.tools.metalava.model.TypeAliasItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterList
@@ -49,6 +49,8 @@ import com.android.tools.metalava.model.item.DefaultTypeParameterItem
 import com.android.tools.metalava.model.item.MutablePackageDoc
 import com.android.tools.metalava.model.item.PackageDoc
 import com.android.tools.metalava.model.item.PackageDocs
+import com.android.tools.metalava.model.value.OptionalValueProvider
+import com.android.tools.metalava.model.value.Value
 
 /** Constructs a [Codebase] by taking a snapshot of another [Codebase] that is being visited. */
 class CodebaseSnapshotTaker
@@ -74,7 +76,7 @@ private constructor(referenceVisitorFactory: (DelegatedVisitor) -> ItemVisitor)
             DefaultItemFactory(
                 snapshotCodebase,
                 // Snapshots currently only support java.
-                defaultItemLanguage = ItemLanguage.JAVA,
+                defaultSourceLanguage = SourceLanguage.JAVA,
                 // Snapshots have already been separated by API surface variants, so they can use
                 // the same immutable ApiVariantSelectors.
                 ApiVariantSelectors.IMMUTABLE_FACTORY,
@@ -224,7 +226,8 @@ private constructor(referenceVisitorFactory: (DelegatedVisitor) -> ItemVisitor)
         val newClass =
             itemFactory.createClassItem(
                 fileLocation = classToSnapshot.fileLocation,
-                itemLanguage = classToSnapshot.itemLanguage,
+                sourceLanguage = classToSnapshot.sourceLanguage,
+                targetLanguages = classToSnapshot.targetLanguages,
                 modifiers = classToSnapshot.modifiers.snapshot(),
                 documentationFactory = snapshotDocumentation(classToSnapshot, cls),
                 source = cls.sourceFile(),
@@ -262,7 +265,8 @@ private constructor(referenceVisitorFactory: (DelegatedVisitor) -> ItemVisitor)
             constructorTypeItemFactory.inScope {
                 itemFactory.createConstructorItem(
                     fileLocation = constructorToSnapshot.fileLocation,
-                    itemLanguage = constructorToSnapshot.itemLanguage,
+                    sourceLanguage = constructorToSnapshot.sourceLanguage,
+                    targetLanguages = constructorToSnapshot.targetLanguages,
                     modifiers = constructorToSnapshot.modifiers.snapshot(),
                     documentationFactory =
                         snapshotDocumentation(constructorToSnapshot, constructor),
@@ -298,13 +302,24 @@ private constructor(referenceVisitorFactory: (DelegatedVisitor) -> ItemVisitor)
                 methodToSnapshot.typeParameterList.snapshot(methodToSnapshot.describe())
             }
 
+        // Defer retrieval of the defaultValue until it is needed as it could throw an exception.
+        // This makes it easier to incrementally expand the Value model without breaking existing
+        // snapshot tests.
+        // TODO(b/354633349): Stop deferring retrieval.
+        val defaultValueProvider =
+            object : OptionalValueProvider {
+                override val optionalValue: Value?
+                    get() = methodToSnapshot.defaultValue?.snapshot(snapshotCodebase)
+            }
+
         val newMethod =
             // Resolve any type parameters used in the method's return type and parameter items
             // within the scope of the method's SnapshotTypeItemFactory.
             methodTypeItemFactory.inScope {
                 itemFactory.createMethodItem(
                     fileLocation = methodToSnapshot.fileLocation,
-                    itemLanguage = methodToSnapshot.itemLanguage,
+                    sourceLanguage = methodToSnapshot.sourceLanguage,
+                    targetLanguages = methodToSnapshot.targetLanguages,
                     modifiers = methodToSnapshot.modifiers.snapshot(),
                     documentationFactory = snapshotDocumentation(methodToSnapshot, method),
                     name = methodToSnapshot.name(),
@@ -317,7 +332,7 @@ private constructor(referenceVisitorFactory: (DelegatedVisitor) -> ItemVisitor)
                     throwsTypes =
                         methodToSnapshot.throwsTypes().map { typeItemFactory.getExceptionType(it) },
                     callableBodyFactory = methodToSnapshot.body::snapshot,
-                    annotationDefault = methodToSnapshot.legacyDefaultValue(),
+                    defaultValueProvider = defaultValueProvider,
                 )
             }
         newMethod.copySelectedApiVariants(methodToSnapshot)
@@ -328,6 +343,16 @@ private constructor(referenceVisitorFactory: (DelegatedVisitor) -> ItemVisitor)
     override fun visitField(field: FieldItem) {
         val fieldToSnapshot = field.actualItemToSnapshot
 
+        // Defer retrieval of the initialValue until it is needed as it could throw an exception.
+        // This makes it easier to incrementally expand the Value model without breaking existing
+        // snapshot tests.
+        // TODO(b/354633349): Stop deferring retrieval.
+        val constantValueProvider =
+            object : OptionalValueProvider {
+                override val optionalValue: Value?
+                    get() = fieldToSnapshot.constantValue?.snapshot(snapshotCodebase)
+            }
+
         val containingClass = field.containingClass().getSnapshotClass()
         val newField =
             // Resolve any type parameters used in the field's type within the scope of the
@@ -335,14 +360,15 @@ private constructor(referenceVisitorFactory: (DelegatedVisitor) -> ItemVisitor)
             globalTypeItemFactory.from(containingClass).inScope {
                 itemFactory.createFieldItem(
                     fileLocation = fieldToSnapshot.fileLocation,
-                    itemLanguage = fieldToSnapshot.itemLanguage,
+                    sourceLanguage = fieldToSnapshot.sourceLanguage,
+                    targetLanguages = fieldToSnapshot.targetLanguages,
                     modifiers = fieldToSnapshot.modifiers.snapshot(),
                     documentationFactory = snapshotDocumentation(fieldToSnapshot, field),
                     name = fieldToSnapshot.name(),
                     containingClass = containingClass,
                     type = fieldToSnapshot.type().snapshot(),
                     isEnumConstant = fieldToSnapshot.isEnumConstant(),
-                    fieldValue = fieldToSnapshot.legacyFieldValue?.snapshot(),
+                    constantValueProvider = constantValueProvider,
                 )
             }
         newField.copySelectedApiVariants(fieldToSnapshot)
@@ -366,7 +392,7 @@ private constructor(referenceVisitorFactory: (DelegatedVisitor) -> ItemVisitor)
             propertyTypeItemFactory.inScope {
                 itemFactory.createPropertyItem(
                     fileLocation = propertyToSnapshot.fileLocation,
-                    itemLanguage = propertyToSnapshot.itemLanguage,
+                    sourceLanguage = propertyToSnapshot.sourceLanguage,
                     modifiers = propertyToSnapshot.modifiers.snapshot(),
                     documentationFactory = snapshotDocumentation(propertyToSnapshot, property),
                     name = propertyToSnapshot.name(),
@@ -417,10 +443,9 @@ private constructor(referenceVisitorFactory: (DelegatedVisitor) -> ItemVisitor)
         // Take a snapshot of a class that is referenced from, but not defined within, the snapshot.
         originalClass.accept(referenceVisitor)
 
-        // Find the newly added class.
-        val classItem =
-            snapshotCodebase.findClass(originalClass.qualifiedName())
-                ?: error("Could not snapshot class $qualifiedName")
+        // Find the newly added class, if no class was added then it is not part of this snapshot
+        // so return `null`.
+        val classItem = snapshotCodebase.findClass(originalClass.qualifiedName()) ?: return null
 
         // Any class that is created only when resolving references is by definition not part of the
         // codebase and so will not be emitted.
@@ -480,7 +505,7 @@ private constructor(referenceVisitorFactory: (DelegatedVisitor) -> ItemVisitor)
                     this,
                     { typeParameterItem ->
                         DefaultTypeParameterItem(
-                            codebase = snapshotCodebase,
+                            classResolver = snapshotCodebase,
                             modifiers = typeParameterItem.modifiers.snapshot(),
                             name = typeParameterItem.name(),
                             isReified = typeParameterItem.isReified()
@@ -491,6 +516,7 @@ private constructor(referenceVisitorFactory: (DelegatedVisitor) -> ItemVisitor)
                         typeParameterItem.typeBounds().map { typeItemFactory.getBoundsType(it) }
                     },
                 )
+
         /** General [TypeItem] specific snapshot. */
         internal fun TypeItem.snapshot() = typeItemFactory.getGeneralType(this)
 
@@ -528,7 +554,7 @@ private constructor(referenceVisitorFactory: (DelegatedVisitor) -> ItemVisitor)
 
                 itemFactory.createParameterItem(
                     fileLocation = parameterItem.fileLocation,
-                    itemLanguage = parameterItem.itemLanguage,
+                    sourceLanguage = parameterItem.sourceLanguage,
                     modifiers = parameterItem.modifiers.snapshot(),
                     name = name,
                     publicNameProvider = { publicName },
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultTypeModifiers.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultTypeModifiers.kt
index d52a375c9..daf525cae 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultTypeModifiers.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/type/DefaultTypeModifiers.kt
@@ -69,7 +69,7 @@ class DefaultTypeModifiers(
                     ?: annotations
                         .firstOrNull { it.isNullnessAnnotation() }
                         ?.let { TypeNullability.ofAnnotation(it) }
-                        ?: TypeNullability.PLATFORM
+                    ?: TypeNullability.PLATFORM
 
             // If the annotations are empty then use one of the predefined instances.
             if (annotations.isEmpty()) {
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/JavaLangPackage.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/type/JavaLangPackage.kt
similarity index 98%
rename from metalava-model-text/src/main/java/com/android/tools/metalava/model/text/JavaLangPackage.kt
rename to metalava-model/src/main/java/com/android/tools/metalava/model/type/JavaLangPackage.kt
index 1d2687aab..5984e5c8a 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/JavaLangPackage.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/type/JavaLangPackage.kt
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.android.tools.metalava.model.text
+package com.android.tools.metalava.model.type
 
 import com.android.tools.metalava.model.ClassResolver
 import com.android.tools.metalava.model.JAVA_LANG_PACKAGE
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/type/TypeItemFactory.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/type/TypeItemFactory.kt
index a251e49f1..3ebba3780 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/type/TypeItemFactory.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/type/TypeItemFactory.kt
@@ -82,6 +82,9 @@ interface TypeItemFactory<in T, F : TypeItemFactory<T, F>> {
     /** Get a type suitable for use in an `extends` clause of a concrete class. */
     fun getSuperClassType(underlyingType: T): ClassTypeItem
 
+    /** Get a type suitable for use as a class reference. */
+    fun getClassReferenceType(underlyingType: T): ClassTypeItem
+
     // Item specific type methods.
 
     /**
@@ -224,9 +227,9 @@ class ContextNullability(
     ): TypeNullability =
         // If forced is set then use that as the top priority.
         forcedNullability
-        // If kotlin provides it then use that as it is most accurate, ignore PLATFORM though
-        // as that may be overridden by annotations or the default.
-        ?: kotlinNullability?.takeIf { nullability -> nullability != TypeNullability.PLATFORM }
+            // If kotlin provides it then use that as it is most accurate, ignore PLATFORM though
+            // as that may be overridden by annotations or the default.
+            ?: kotlinNullability?.takeIf { nullability -> nullability != TypeNullability.PLATFORM }
             // If annotations provide it then use them as the developer requested.
             ?: typeAnnotations.typeNullability
             // If item annotations are found then check them.
@@ -275,6 +278,11 @@ abstract class DefaultTypeItemFactory<in T, F : DefaultTypeItemFactory<T, F>>(
 
     override fun getSuperClassType(underlyingType: T) = getSuperType(underlyingType)
 
+    override fun getClassReferenceType(underlyingType: T): ClassTypeItem {
+        return getType(underlyingType, contextNullability = ContextNullability.forceNonNull)
+            as ClassTypeItem
+    }
+
     /**
      * Creates a [ClassTypeItem] that is suitable for use as a super type, e.g. in an `extends` or
      * `implements` list.
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/type/TypeItemParser.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/type/TypeItemParser.kt
new file mode 100644
index 000000000..92ba91df5
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/type/TypeItemParser.kt
@@ -0,0 +1,742 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.type
+
+import com.android.tools.metalava.model.AnnotationContext
+import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.ArrayTypeItem
+import com.android.tools.metalava.model.ClassResolver
+import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.JAVA_LANG_OBJECT
+import com.android.tools.metalava.model.PrimitiveTypeItem
+import com.android.tools.metalava.model.ReferenceTypeItem
+import com.android.tools.metalava.model.TypeArgumentTypeItem
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.TypeModifiers
+import com.android.tools.metalava.model.TypeNullability
+import com.android.tools.metalava.model.TypeParameterScope
+import com.android.tools.metalava.model.VariableTypeItem
+import com.android.tools.metalava.model.WildcardTypeItem
+import com.android.tools.metalava.model.value.ValueParser
+
+/**
+ * Parses and caches types within an [annotationContext].
+ *
+ * @param unqualifiedClassHandler responsible for determining how to handle unqualified types.
+ * @param kotlinStyleNulls whether Kotlin style nulls, i.e. no nullability suffix for non-null, `?`
+ *   for nullable, and `!` for platform are supported or not.
+ * @param errorReporter channel for reporting recoverable errors found while parsing.
+ */
+open class TypeItemParser(
+    val annotationContext: AnnotationContext,
+    private val unqualifiedClassHandler: UnqualifiedClassHandler,
+    val kotlinStyleNulls: Boolean = false,
+    private val errorReporter: TypeItemParserErrorReporter = TypeItemParserErrorReporter.THROWING,
+) {
+    /** [ValueParser] used for parsing type use annotations. */
+    private val valueParser = ValueParser(annotationContext, this)
+
+    /** A [TypeItem] representing `java.lang.Object`, suitable for general use. */
+    private val objectType: ReferenceTypeItem
+        get() =
+            parseTypeWithContextNullability(JAVA_LANG_OBJECT, TypeParameterScope.empty)
+                as ReferenceTypeItem
+
+    /**
+     * Creates or retrieves from the cache a [TypeItem] representing [type], in the context of the
+     * type parameters from [typeParameterScope], if applicable.
+     */
+    fun obtainTypeFromString(
+        type: String,
+        typeParameterScope: TypeParameterScope,
+        contextNullability: ContextNullability = ContextNullability.none,
+    ): TypeItem =
+        parseTypeWithContextNullability(type, typeParameterScope, emptyList(), contextNullability)
+
+    /**
+     * Parse [type] and return a [TypeItem], in the context of type parameters from
+     * [typeParameterScope], if applicable.
+     *
+     * Used internally, as it has an extra [annotations] parameter that allows the annotations on
+     * array components to be correctly associated with the correct component. They are optional
+     * leading type-use annotations that have already been removed from the arrays type string.
+     *
+     * This will also map [contextNullability] to a [Boolean] that controls whether a
+     * [ClassTypeItem] is forced to be non-null, taking into account [kotlinStyleNulls].
+     */
+    private fun parseTypeWithContextNullability(
+        type: String,
+        typeParameterScope: TypeParameterScope,
+        annotations: List<AnnotationItem> = emptyList(),
+        contextNullability: ContextNullability = ContextNullability.none,
+    ): TypeItem {
+        // Class types used as super types, i.e. in an extends or implements list are forced to be
+        // [TypeNullability.NONNULL], just as they would be if kotlinStyleNulls was true. Use the
+        // same cache key for both so that they reuse cached types where possible.
+        val forceClassToBeNonNull =
+            contextNullability.forcedNullability == TypeNullability.NONNULL || kotlinStyleNulls
+
+        return parseType(type, typeParameterScope, annotations, forceClassToBeNonNull)
+    }
+
+    /** Converts the [type] to a [TypeItem] in the context of the [typeParameterScope]. */
+    protected open fun parseType(
+        type: String,
+        typeParameterScope: TypeParameterScope,
+        annotations: List<AnnotationItem>,
+        // Forces a [ClassTypeItem] to have [TypeNullability.NONNULL]
+        forceClassToBeNonNull: Boolean = false,
+    ): TypeItem {
+        val (unannotated, annotationsFromString) = trimLeadingAnnotations(type)
+        val allAnnotations = annotations + annotationsFromString
+        val (withoutNullability, nullability) =
+            splitNullabilitySuffix(
+                unannotated,
+                // If forceClassToBeNonNull is true then a plain class type without any nullability
+                // suffix must be treated as if it was not null, which is just how it would be
+                // treated when kotlinStyleNulls is true. So, pretend that kotlinStyleNulls is true.
+                kotlinStyleNulls || forceClassToBeNonNull,
+                errorReporter,
+            )
+        val trimmed = withoutNullability.trim()
+
+        // Figure out what kind of type this is.
+        //
+        // Start with variable as the type parameter scope allows us to determine whether something
+        // is a type parameter or not. Also, if a type parameter has the same name as a primitive
+        // type (possible in Kotlin, but not Java) then it will be treated as a type parameter not a
+        // primitive.
+        //
+        // Then try parsing as a primitive as while Kotlin classes can shadow primitive types
+        // they would need to be fully qualified.
+        return asVariable(trimmed, typeParameterScope, allAnnotations, nullability)
+            ?: asPrimitive(type, trimmed, allAnnotations, nullability)
+            // Try parsing as a wildcard before trying to parse as an array.
+            // `? extends java.lang.String[]` should be parsed as a wildcard with an array bound,
+            // not as an array of wildcards, for consistency with how this would be compiled.
+            ?: asWildcard(trimmed, typeParameterScope, allAnnotations, nullability)
+            // Try parsing as an array.
+            ?: asArray(trimmed, allAnnotations, nullability, typeParameterScope)
+            // If it isn't anything else, parse the type as a class.
+            ?: asClass(trimmed, typeParameterScope, allAnnotations, nullability)
+    }
+
+    /**
+     * Try parsing [type] as a primitive. This will return a non-null [PrimitiveTypeItem] if [type]
+     * exactly matches a primitive name.
+     *
+     * [type] should have annotations and nullability markers stripped, with [original] as the
+     * complete annotated type. Once annotations are properly handled (b/300081840), preserving
+     * [original] won't be necessary.
+     */
+    private fun asPrimitive(
+        original: String,
+        type: String,
+        annotations: List<AnnotationItem>,
+        nullability: TypeNullability?
+    ): PrimitiveTypeItem? {
+        val kind =
+            when (type) {
+                "byte" -> PrimitiveTypeItem.Primitive.BYTE
+                "char" -> PrimitiveTypeItem.Primitive.CHAR
+                "double" -> PrimitiveTypeItem.Primitive.DOUBLE
+                "float" -> PrimitiveTypeItem.Primitive.FLOAT
+                "int" -> PrimitiveTypeItem.Primitive.INT
+                "long" -> PrimitiveTypeItem.Primitive.LONG
+                "short" -> PrimitiveTypeItem.Primitive.SHORT
+                "boolean" -> PrimitiveTypeItem.Primitive.BOOLEAN
+                "void" -> PrimitiveTypeItem.Primitive.VOID
+                else -> return null
+            }
+        if (nullability != null && nullability != TypeNullability.NONNULL) {
+            errorReporter.report("Invalid nullability suffix on primitive: $original")
+        }
+        return DefaultPrimitiveTypeItem(modifiers(annotations, TypeNullability.NONNULL), kind)
+    }
+
+    /**
+     * Try parsing [type] as an array. This will return a non-null [ArrayTypeItem] if [type] ends
+     * with `[]` or `...`.
+     *
+     * The context [typeParameterScope] are used to parse the component type of the array.
+     */
+    private fun asArray(
+        type: String,
+        componentAnnotations: List<AnnotationItem>,
+        nullability: TypeNullability?,
+        typeParameterScope: TypeParameterScope
+    ): ArrayTypeItem? {
+        // Check if this is a regular array or varargs.
+        val (inner, varargs) =
+            if (type.endsWith("...")) {
+                Pair(type.dropLast(3), true)
+            } else if (type.endsWith("[]")) {
+                Pair(type.dropLast(2), false)
+            } else {
+                return null
+            }
+
+        // Create lists of the annotations and nullability markers for each dimension of the array.
+        // These are in separate lists because annotations appear in the type string in order from
+        // outermost array annotations to innermost array annotations (for `T @A [] @B [] @ C[]`,
+        // `@A` applies to the three-dimensional array, `@B` applies to the inner two-dimensional
+        // arrays, and `@C` applies to the inner one-dimensional arrays), while nullability markers
+        // appear in order from the innermost array nullability to the outermost array nullability
+        // (for `T[]![]?[]`, the three-dimensional array has no nullability marker, the inner
+        // two-dimensional arrays have `?` as the nullability marker, and the innermost arrays have
+        // `!` as a nullability marker.
+        val allAnnotations = mutableListOf<List<AnnotationItem>>()
+        // The nullability marker for the outer array is already known, include it in the list.
+        val allNullability = mutableListOf(nullability)
+
+        // Remove annotations from the end of the string, add them to the list.
+        var annotationsResult = trimTrailingAnnotations(inner)
+        var componentString = annotationsResult.first
+        allAnnotations.add(annotationsResult.second)
+
+        // Remove nullability marker from the component type, but don't add it to the list yet, as
+        // it might not be an array.
+        var nullabilityResult =
+            splitNullabilitySuffix(
+                componentString,
+                kotlinStyleNulls,
+                errorReporter,
+            )
+        componentString = nullabilityResult.first
+        var componentNullability = nullabilityResult.second
+
+        // Work through all layers of arrays to get to the inner component type.
+        // Inner arrays can't be varargs.
+        while (componentString.endsWith("[]")) {
+            // The component is an array, add the nullability to the list.
+            allNullability.add(componentNullability)
+
+            // Remove annotations from the end of the string, add them to the list.
+            annotationsResult = trimTrailingAnnotations(componentString.removeSuffix("[]"))
+            componentString = annotationsResult.first
+            allAnnotations.add(annotationsResult.second)
+
+            // Remove nullability marker from the new component type, but don't add it to the list
+            // yet, as the next component type might not be an array.
+            nullabilityResult =
+                splitNullabilitySuffix(
+                    componentString,
+                    kotlinStyleNulls,
+                    errorReporter,
+                )
+            componentString = nullabilityResult.first
+            componentNullability = nullabilityResult.second
+        }
+
+        // Re-add the component's nullability suffix when parsing the component type, and include
+        // the leading annotations already removed from the type string.
+        componentString += componentNullability?.suffix.orEmpty()
+        val deepComponentType =
+            parseTypeWithContextNullability(
+                componentString,
+                typeParameterScope,
+                componentAnnotations
+            )
+
+        // Join the annotations and nullability markers -- as described in the comment above, these
+        // appear in the string in reverse order of each other. The modifiers list will be ordered
+        // from innermost array modifiers to outermost array modifiers.
+        val allModifiers =
+            allAnnotations.zip(allNullability.reversed()).map { (annotations, nullability) ->
+                modifiers(annotations, nullability)
+            }
+        // The final modifiers are in the list apply to the outermost array.
+        val componentModifiers = allModifiers.dropLast(1)
+        val arrayModifiers = allModifiers.last()
+        // Create the component type of the outermost array by building up the inner component type.
+        val componentType =
+            componentModifiers.fold(deepComponentType) { component, modifiers ->
+                DefaultArrayTypeItem(modifiers, component, false)
+            }
+
+        // Create the outer array.
+        return DefaultArrayTypeItem(arrayModifiers, componentType, varargs)
+    }
+
+    /**
+     * Try parsing [type] as a wildcard. This will return a non-null [WildcardTypeItem] if [type]
+     * begins with `?`.
+     *
+     * The context [typeParameterScope] are needed to parse the bounds of the wildcard.
+     *
+     * [type] should have annotations and nullability markers stripped.
+     */
+    private fun asWildcard(
+        type: String,
+        typeParameterScope: TypeParameterScope,
+        annotations: List<AnnotationItem>,
+        nullability: TypeNullability?
+    ): WildcardTypeItem? {
+        // See if this is a wildcard
+        if (!type.startsWith("?")) return null
+
+        val modifiers = modifiers(annotations, TypeNullability.UNDEFINED)
+
+        // Unbounded wildcard type: there is an implicit Object extends bound
+        if (type == "?") return DefaultWildcardTypeItem(modifiers, objectType, null)
+
+        // If there's a bound, the nullability suffix applies there instead.
+        val bound = type.substring(2) + nullability?.suffix.orEmpty()
+        return if (bound.startsWith("extends")) {
+            val extendsBound = bound.substring(8)
+            DefaultWildcardTypeItem(
+                modifiers,
+                getWildcardBound(extendsBound, typeParameterScope),
+                null,
+            )
+        } else if (bound.startsWith("super")) {
+            val superBound = bound.substring(6)
+            DefaultWildcardTypeItem(
+                modifiers,
+                // All wildcards have an implicit Object extends bound
+                objectType,
+                getWildcardBound(superBound, typeParameterScope),
+            )
+        } else {
+            errorReporter.report("Type starts with \"?\" but doesn't appear to be wildcard: $type")
+
+            // Ignore the part after the "?" and treat it as an unbounded wildcard.
+            DefaultWildcardTypeItem(modifiers, objectType, null)
+        }
+    }
+
+    private fun getWildcardBound(bound: String, typeParameterScope: TypeParameterScope) =
+        parseTypeWithContextNullability(bound, typeParameterScope) as ReferenceTypeItem
+
+    /**
+     * Try parsing [type] as a type variable. This will return a non-null [VariableTypeItem] if
+     * [type] matches a parameter from [typeParameterScope].
+     *
+     * [type] should have annotations and nullability markers stripped.
+     */
+    private fun asVariable(
+        type: String,
+        typeParameterScope: TypeParameterScope,
+        annotations: List<AnnotationItem>,
+        nullability: TypeNullability?
+    ): VariableTypeItem? {
+        val param = typeParameterScope.findTypeParameter(type) ?: return null
+        return DefaultVariableTypeItem(modifiers(annotations, nullability), param)
+    }
+
+    /**
+     * Parse the [type] as a class. This function will always return a non-null [ClassTypeItem], so
+     * it should only be used when it is certain that [type] is not a different kind of type.
+     *
+     * The context [typeParameterScope] are used to parse the parameters of the class type.
+     *
+     * [type] should have annotations and nullability markers stripped.
+     */
+    private fun asClass(
+        type: String,
+        typeParameterScope: TypeParameterScope,
+        annotations: List<AnnotationItem>,
+        nullability: TypeNullability?
+    ): ClassTypeItem {
+        return createClassType(type, null, typeParameterScope, annotations, nullability)
+    }
+
+    /**
+     * Creates a class name for the class represented by [type] with optional [outerClassType].
+     *
+     * For instance, `test.pkg.Outer<P1>` would be the [outerClassType] when parsing `Inner<P2>`
+     * from the original type `test.pkg.Outer<P1>.Inner<P2>`.
+     */
+    private fun createClassType(
+        type: String,
+        outerClassType: ClassTypeItem?,
+        typeParameterScope: TypeParameterScope,
+        annotations: List<AnnotationItem>,
+        nullability: TypeNullability?
+    ): ClassTypeItem {
+        val (name, afterName, classAnnotations) = splitClassType(type)
+
+        val qualifiedName =
+            if (outerClassType != null) {
+                // This is a nested type, add the prefix of the outer name
+                "${outerClassType.qualifiedName}.$name"
+            } else {
+                name
+            }
+
+        val (argumentStrings, remainder) = typeParameterStringsWithRemainder(afterName)
+        val arguments =
+            argumentStrings.map {
+                parseTypeWithContextNullability(it, typeParameterScope) as TypeArgumentTypeItem
+            }
+        // If this is an outer class type (there's a remainder), call it non-null and don't apply
+        // the leading annotations (they belong to the nested class type).
+        val classModifiers =
+            if (remainder != null) {
+                modifiers(classAnnotations, TypeNullability.NONNULL)
+            } else {
+                modifiers(classAnnotations + annotations, nullability)
+            }
+
+        // If the class name is qualified (i.e. contains a `.`) then create the ClassTypeItem,
+        // directly, otherwise defer to the unqualifiedTypeHandler to create it instead.
+        val classType =
+            if (qualifiedName.contains('.')) {
+                DefaultClassTypeItem(
+                    annotationContext,
+                    classModifiers,
+                    qualifiedName,
+                    arguments,
+                    outerClassType
+                )
+            } else {
+                unqualifiedClassHandler.handleUnqualifiedType(
+                    annotationContext,
+                    errorReporter,
+                    classModifiers,
+                    name,
+                    arguments,
+                    outerClassType
+                )
+            }
+
+        if (remainder != null) {
+            if (!remainder.startsWith('.')) {
+                errorReporter.report(
+                    "Could not parse type `$type`. Found unexpected string after type parameters: $remainder"
+                )
+                // Ignore the remainder.
+                return classType
+            }
+
+            // This is a nested class type, recur with the new outer class
+            return createClassType(
+                remainder.substring(1),
+                classType,
+                typeParameterScope,
+                annotations,
+                nullability
+            )
+        }
+
+        return classType
+    }
+
+    private fun modifiers(
+        annotations: List<AnnotationItem>,
+        nullability: TypeNullability?
+    ): TypeModifiers {
+        return DefaultTypeModifiers.create(
+            annotations,
+            nullability,
+        )
+    }
+
+    /**
+     * Removes all annotations at the beginning of the type, returning the trimmed type and list of
+     * annotations.
+     */
+    fun trimLeadingAnnotations(type: String): Pair<String, List<AnnotationItem>> {
+        val annotations = mutableListOf<AnnotationItem>()
+        var trimmed = type.trim()
+        while (trimmed.startsWith('@')) {
+            val end = findAnnotationEnd(trimmed, 1)
+            val annotationSource = trimmed.substring(0, end).trim()
+            valueParser.parseAnnotationItem(annotationSource)?.let { annotationItem ->
+                annotations.add(annotationItem)
+            }
+            trimmed = trimmed.substring(end).trim()
+        }
+        return Pair(trimmed, annotations)
+    }
+
+    /**
+     * Removes all annotations at the end of the [type], returning the trimmed type and list of
+     * annotations. This is for use with arrays where annotations applying to the array type go
+     * after the component type, for instance `String @A []`. The input [type] should **not**
+     * include the array suffix (`[]` or `...`).
+     */
+    fun trimTrailingAnnotations(type: String): Pair<String, List<AnnotationItem>> {
+        // The simple way to implement this would be to work from the end of the string, finding
+        // `@` and removing annotations from the end. However, it is possible for an annotation
+        // string to contain an `@`, so this is not a safe way to remove the annotations.
+        // Instead, this finds all annotations starting from the beginning of the string, then
+        // works backwards to find which ones are the trailing annotations.
+        val allAnnotationIndices = mutableListOf<Pair<Int, Int>>()
+        var trimmed = type.trim()
+
+        // First find all annotations, saving the first and last index.
+        var currIndex = 0
+        while (currIndex < trimmed.length) {
+            if (trimmed[currIndex] == '@') {
+                val endIndex = findAnnotationEnd(trimmed, currIndex + 1)
+                allAnnotationIndices.add(Pair(currIndex, endIndex))
+                currIndex = endIndex + 1
+            } else {
+                currIndex++
+            }
+        }
+
+        val annotations = mutableListOf<AnnotationItem>()
+        // Go through all annotations from the back, seeing if they're at the end of the string.
+        for ((start, end) in allAnnotationIndices.reversed()) {
+            // This annotation isn't at the end, so we've hit the last trailing annotation
+            if (end < trimmed.length) {
+                break
+            }
+            val annotationSource = trimmed.substring(start)
+            valueParser.parseAnnotationItem(annotationSource)?.let { annotationItem ->
+                annotations.add(annotationItem)
+            }
+            // Cut this annotation off, so now the next one can end at the last index.
+            trimmed = trimmed.substring(0, start).trim()
+        }
+        return Pair(trimmed, annotations.reversed())
+    }
+
+    /**
+     * Given [type] which represents a class, splits the string into the qualified name of the
+     * class, the remainder of the type string, and a list of type-use annotations. The remainder of
+     * the type string might be the type parameter list, nested class names, or a combination
+     *
+     * For `java.util.@A @B List<java.lang.@C String>`, returns the triple ("java.util.List",
+     * "<java.lang.@C String", listOf("@A", "@B")).
+     *
+     * For `test.pkg.Outer.Inner`, returns the triple ("test.pkg.Outer", ".Inner", emptyList()).
+     *
+     * For `test.pkg.@test.pkg.A Outer<P1>.@test.pkg.B Inner<P2>`, returns the triple
+     * ("test.pkg.Outer", "<P1>.@test.pkg.B Inner<P2>", listOf("@test.pkg.A")).
+     */
+    fun splitClassType(type: String): Triple<String, String?, List<AnnotationItem>> {
+        // The constructed qualified type name
+        var name = ""
+        // The part of the type which still needs to be parsed
+        var remaining = type.trim()
+        // The annotations of the type, may be set later
+        var annotations = emptyList<AnnotationItem>()
+
+        var dotIndex = remaining.indexOf('.')
+        var paramIndex = remaining.indexOf('<')
+        var annotationIndex = remaining.indexOf('@')
+
+        // Find which of '.', '<', or '@' comes first, if any
+        var minIndex = minIndex(dotIndex, paramIndex, annotationIndex)
+        while (minIndex != null) {
+            when (minIndex) {
+                // '.' is first, the next part is part of the qualified class name.
+                dotIndex -> {
+                    val nextNameChunk = remaining.substring(0, dotIndex)
+                    name += nextNameChunk
+                    remaining = remaining.substring(dotIndex)
+                    // Assumes that package names are all lower case and class names will have
+                    // an upper class character (the [START_WITH_UPPER] API lint check should
+                    // make this a safe assumption). If the name is a class name, we've found
+                    // the complete class name, return.
+                    if (nextNameChunk.any { it.isUpperCase() }) {
+                        return Triple(name, remaining, annotations)
+                    }
+                }
+                // '<' is first, the end of the class name has been reached.
+                paramIndex -> {
+                    name += remaining.substring(0, paramIndex)
+                    remaining = remaining.substring(paramIndex)
+                    return Triple(name, remaining, annotations)
+                }
+                // '@' is first, trim all annotations.
+                annotationIndex -> {
+                    name += remaining.substring(0, annotationIndex)
+                    trimLeadingAnnotations(remaining.substring(annotationIndex)).let {
+                        (first, second) ->
+                        remaining = first
+                        annotations = second
+                    }
+                }
+            }
+            // Reset indices -- the string may now start with '.' for the next chunk of the name
+            // but this should find the end of the next chunk.
+            dotIndex = remaining.indexOf('.', 1)
+            paramIndex = remaining.indexOf('<')
+            annotationIndex = remaining.indexOf('@')
+            minIndex = minIndex(dotIndex, paramIndex, annotationIndex)
+        }
+        // End of the name reached with no leftover string.
+        name += remaining
+        return Triple(name, null, annotations)
+    }
+
+    companion object {
+        /**
+         * Splits the Kotlin-style nullability marker off the type string, returning a pair of the
+         * cleaned type string and the nullability suffix.
+         */
+        fun splitNullabilitySuffix(
+            type: String,
+            kotlinStyleNulls: Boolean,
+            errorReporter: TypeItemParserErrorReporter = TypeItemParserErrorReporter.THROWING,
+        ): Pair<String, TypeNullability?> {
+            return if (kotlinStyleNulls) {
+                // Don't interpret the wildcard type `?` as a nullability marker.
+                if (type == "?") {
+                    Pair(type, TypeNullability.UNDEFINED)
+                } else if (type.endsWith("?")) {
+                    Pair(type.dropLast(1), TypeNullability.NULLABLE)
+                } else if (type.endsWith("!")) {
+                    Pair(type.dropLast(1), TypeNullability.PLATFORM)
+                } else {
+                    Pair(type, TypeNullability.NONNULL)
+                }
+            } else if (((type.length > 1) && type.endsWith("?")) || type.endsWith("!")) {
+                errorReporter.report("Format does not support Kotlin-style null type syntax: $type")
+                Pair(type.dropLast(1), TypeNullability.PLATFORM)
+            } else {
+                Pair(type, null)
+            }
+        }
+
+        /**
+         * Returns the minimum valid list index from the input, or null if there isn't one. -1 is
+         * not a valid index.
+         */
+        private fun minIndex(vararg index: Int): Int? = index.filter { it != -1 }.minOrNull()
+
+        /**
+         * Given a string and the index in that string which is the start of an annotation (the
+         * character _after_ the `@`), returns the index of the end of the annotation.
+         */
+        fun findAnnotationEnd(type: String, start: Int): Int {
+            var index = start
+            val length = type.length
+            var balance = 0
+            while (index < length) {
+                val c = type[index]
+                if (c == '(') {
+                    balance++
+                } else if (c == ')') {
+                    balance--
+                    if (balance == 0) {
+                        return index + 1
+                    }
+                } else if (c != '.' && !Character.isJavaIdentifierPart(c) && balance == 0) {
+                    break
+                }
+                index++
+            }
+            return index
+        }
+
+        /**
+         * Breaks a string representing type parameters into a list of the type parameter strings.
+         *
+         * E.g. `"<A, B, C>"` -> `["A", "B", "C"]` and `"<List<A>, B>"` -> `["List<A>", "B"]`.
+         */
+        fun typeParameterStrings(typeString: String?): List<String> {
+            return typeParameterStringsWithRemainder(typeString).first
+        }
+
+        /**
+         * Breaks a string representing type parameters into a list of the type parameter strings,
+         * and also returns the remainder of the string after the closing ">".
+         *
+         * E.g. `"<A, B, C>.Inner"` -> `Pair(["A", "B", "C"], ".Inner")`
+         */
+        fun typeParameterStringsWithRemainder(typeString: String?): Pair<List<String>, String?> {
+            val s = typeString ?: return Pair(emptyList(), null)
+            if (!s.startsWith("<")) return Pair(emptyList(), s)
+            val list = mutableListOf<String>()
+            var balance = 0
+            var expect = false
+            var start = 0
+            var i = 0
+            while (i < s.length) {
+                val c = s[i]
+                if (c == '<') {
+                    balance++
+                    expect = balance == 1
+                } else if (c == '>') {
+                    balance--
+                    if (balance == 0) {
+                        add(list, s, start, i)
+                        return if (i == s.length - 1) {
+                            Pair(list, null)
+                        } else {
+                            Pair(list, s.substring(i + 1))
+                        }
+                    }
+                } else if (c == ',') {
+                    expect =
+                        if (balance == 1) {
+                            add(list, s, start, i)
+                            true
+                        } else {
+                            false
+                        }
+                } else {
+                    // This is the start of a parameter
+                    if (expect && balance == 1) {
+                        start = i
+                        expect = false
+                    }
+
+                    if (c == '@') {
+                        // Skip the entire text of the annotation
+                        i = findAnnotationEnd(typeString, i + 1)
+                        continue
+                    }
+                }
+                i++
+            }
+            return Pair(list, null)
+        }
+
+        /**
+         * Adds the substring of [s] from [from] to [to] to the [list], trimming whitespace from the
+         * front.
+         */
+        private fun add(list: MutableList<String>, s: String, from: Int, to: Int) {
+            for (i in from until to) {
+                if (!Character.isWhitespace(s[i])) {
+                    list.add(s.substring(i, to))
+                    return
+                }
+            }
+        }
+
+        /**
+         * Returns a [TypeItemParser] suitable for use by the [ValueParser].
+         *
+         * It does not support kotlin style nulls, or annotations and treats unqualified types as if
+         * they were qualified.
+         */
+        fun forValueParser(
+            classResolver: ClassResolver,
+            errorReporter: TypeItemParserErrorReporter = TypeItemParserErrorReporter.THROWING,
+        ): TypeItemParser {
+            val annotationContext =
+                object : AnnotationContext, ClassResolver by classResolver {
+                    override val annotationManager
+                        get() = error("Annotations not supported")
+                }
+
+            return TypeItemParser(
+                annotationContext,
+                UnqualifiedClassHandler.PREFIX_WITH_JAVA_LANG,
+                kotlinStyleNulls = false,
+                errorReporter
+            )
+        }
+    }
+}
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/SignatureErrorReporter.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/type/TypeItemParserErrorReporter.kt
similarity index 61%
rename from metalava-model-text/src/main/java/com/android/tools/metalava/model/text/SignatureErrorReporter.kt
rename to metalava-model/src/main/java/com/android/tools/metalava/model/type/TypeItemParserErrorReporter.kt
index b9613a1ee..810dd5995 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/SignatureErrorReporter.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/type/TypeItemParserErrorReporter.kt
@@ -14,34 +14,39 @@
  * limitations under the License.
  */
 
-package com.android.tools.metalava.model.text
+package com.android.tools.metalava.model.type
 
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.reporter.Issues
 
 /**
- * Provides support for reporting recoverable errors while parsing signature files.
+ * Provides support for reporting recoverable errors while parsing type items.
  *
  * A recoverable error is one that is not caused by syntax issues and there is an obvious way of
- * moving past after reporting the problem, e.g. not the invalid information in the [Codebase].
+ * moving past after reporting the problem, e.g. an [Issues.UNQUALIFIED_TYPE_ERROR] could be
+ * bypassed by assuming that it is a valid class and creating a stub in the [Codebase].
  *
  * This is primarily for testing and reading historical versions which may not quite match the
- * expected format. In normal use signature files are always generated by Metalava and so should
- * always be readable by Metalava.
+ * expected format. In normal use types are nearly always generated by Metalava and so should always
+ * be readable by Metalava. The exception would be types which appear in an annotation instance
+ * specified on the command line.
  */
-internal interface SignatureErrorReporter {
+interface TypeItemParserErrorReporter {
     /** Report recoverable errors encountered while parsing. */
     fun report(issue: Issues.Issue, message: String)
 
-    /** Report recoverable errors encountered while parsing, using [Issues.SIGNATURE_FILE_ERROR]. */
-    fun report(message: String) = report(Issues.SIGNATURE_FILE_ERROR, message)
+    /** Report recoverable errors encountered while parsing, using a generic issue. */
+    fun report(message: String) = report(Issues.TYPE_PARSE_ERROR, message)
 
     companion object {
-        /** A [SignatureErrorReporter] that throws an exception at the first error it encounters. */
+        /**
+         * A [TypeItemParserErrorReporter] that throws an exception at the first error it
+         * encounters.
+         */
         val THROWING =
-            object : SignatureErrorReporter {
+            object : TypeItemParserErrorReporter {
                 override fun report(issue: Issues.Issue, message: String) {
-                    throw ApiParseException("$message [$issue]")
+                    error("$message [$issue]")
                 }
             }
     }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/type/UnqualifiedClassHandler.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/type/UnqualifiedClassHandler.kt
new file mode 100644
index 000000000..dcbc0b697
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/type/UnqualifiedClassHandler.kt
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.type
+
+import com.android.tools.metalava.model.ClassResolver
+import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.TypeArgumentTypeItem
+import com.android.tools.metalava.model.TypeModifiers
+import com.android.tools.metalava.reporter.Issues
+
+/**
+ * Responsible for handling an unqualified [ClassTypeItem] in a string representation of a type
+ * being parsed.
+ */
+interface UnqualifiedClassHandler {
+    /**
+     * Determine what to do with a type with an [unqualifiedName].
+     *
+     * It can either throw an exception, or return a value [ClassTypeItem]. In the latter case it
+     * can also report an error to [errorReporter], if necessary.
+     *
+     * All the parameters apart from [unqualifiedName] and [errorReporter] have the same meaning as
+     * for [DefaultClassTypeItem].
+     */
+    fun handleUnqualifiedType(
+        classResolver: ClassResolver,
+        errorReporter: TypeItemParserErrorReporter,
+        modifiers: TypeModifiers,
+        unqualifiedName: String,
+        arguments: List<TypeArgumentTypeItem>,
+        outerClassType: ClassTypeItem?,
+    ): ClassTypeItem
+
+    companion object {
+        /**
+         * [UnqualifiedClassHandler] that will prefix with `java.lang.` if appropriate, otherwise
+         * report an error and just use the unqualified name as is.
+         */
+        val PREFIX_WITH_JAVA_LANG_OR_REPORT_ERROR: UnqualifiedClassHandler =
+            PrefixWithJavaLang(reportAsError = true)
+
+        /**
+         * [UnqualifiedClassHandler] that will prefix with `java.lang.` if appropriate, otherwise
+         * just use the unqualified name as is.
+         */
+        val PREFIX_WITH_JAVA_LANG: UnqualifiedClassHandler =
+            PrefixWithJavaLang(reportAsError = false)
+    }
+
+    /** An [UnqualifiedClassHandler] that will prefix with `java.lang.` if appropriate. */
+    private class PrefixWithJavaLang(private val reportAsError: Boolean) : UnqualifiedClassHandler {
+        /**
+         * Tracks whether types that were unqualified and so implicitly treated as being part of the
+         * 'java.lang` package are actually part of that package. If they are not then an error is
+         * reported and it is not prefixed with `java.lang`.
+         */
+        private val javaLangPackage: JavaLangPackage = JavaLangPackage.DEFAULT
+
+        override fun handleUnqualifiedType(
+            classResolver: ClassResolver,
+            errorReporter: TypeItemParserErrorReporter,
+            modifiers: TypeModifiers,
+            unqualifiedName: String,
+            arguments: List<TypeArgumentTypeItem>,
+            outerClassType: ClassTypeItem?
+        ): ClassTypeItem {
+            val javaLangName = "java.lang.$unqualifiedName"
+            val qualifiedName =
+                if (javaLangPackage.containsQualified(javaLangName)) {
+                    // Reverse the effect of [TypeItem.stripJavaLangPrefix].
+                    javaLangName
+                } else {
+                    if (reportAsError) {
+                        errorReporter.report(
+                            Issues.UNQUALIFIED_TYPE_ERROR,
+                            "Unqualified type '$unqualifiedName' is not in 'java.lang' and is not a type parameter in scope"
+                        )
+                    }
+                    unqualifiedName
+                }
+
+            return DefaultClassTypeItem(
+                classResolver,
+                modifiers,
+                qualifiedName,
+                arguments,
+                outerClassType
+            )
+        }
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/value/DefaultAnnotationValue.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/value/DefaultAnnotationValue.kt
new file mode 100644
index 000000000..1b0a5f302
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/value/DefaultAnnotationValue.kt
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.value
+
+import com.android.tools.metalava.model.AnnotationItem
+
+internal class DefaultAnnotationValue(
+    override val annotationItem: AnnotationItem,
+) : DefaultValue(), AnnotationValue {}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/value/DefaultArrayValue.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/value/DefaultArrayValue.kt
new file mode 100644
index 000000000..86280a7db
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/value/DefaultArrayValue.kt
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.value
+
+import com.android.tools.metalava.model.Codebase
+
+internal class DefaultArrayValue(
+    override val elements: List<ArrayElementValue>,
+    private val wasUnwrappedInSource: Boolean,
+) : DefaultValue(), ArrayValue {
+    override fun appendValueStringTo(
+        builder: StringBuilder,
+        configuration: ValueStringConfiguration
+    ) {
+        @Suppress("DEPRECATION")
+        if (
+            wasUnwrappedInSource &&
+                configuration.singleArrayElementFormat == SingleArrayElementFormat.SOURCE
+        ) {
+            configuration.appendNestedValueTo(builder, elements[0])
+        } else super.appendValueStringTo(builder, configuration)
+    }
+
+    override fun snapshot(targetCodebase: Codebase): ArrayValue {
+        if (elements.isEmpty()) return this
+        val snapshotElements = elements.map { it.snapshot(targetCodebase) }
+        return Value.createArrayValue(snapshotElements, wasUnwrappedInSource)
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/value/DefaultClassObjectValue.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/value/DefaultClassObjectValue.kt
new file mode 100644
index 000000000..abcbb83fe
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/value/DefaultClassObjectValue.kt
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.value
+
+import com.android.tools.metalava.model.TypeItem
+
+internal class DefaultClassObjectValue(
+    override val typeItem: TypeItem,
+    private val sourceExpression: String?,
+) : DefaultValue(), ClassObjectValue {
+    /** Override to use [sourceExpression] if required. */
+    override fun appendValueStringTo(
+        builder: StringBuilder,
+        configuration: ValueStringConfiguration
+    ) {
+        if (
+            configuration.classObjectValueFormat == ClassObjectValueFormat.SOURCE &&
+                sourceExpression != null
+        )
+            builder.append(sourceExpression)
+        else super.appendValueStringTo(builder, configuration)
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/value/DefaultFieldReferenceValue.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/value/DefaultFieldReferenceValue.kt
new file mode 100644
index 000000000..71b6e4641
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/value/DefaultFieldReferenceValue.kt
@@ -0,0 +1,178 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.value
+
+import com.android.tools.metalava.model.ClassResolver
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.PrimitiveTypeItem.Primitive
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.value.Value.Companion.toString
+import java.util.Optional
+import kotlin.jvm.optionals.getOrNull
+
+/** Base class for [FieldReferenceValue] implementations. */
+internal abstract class BaseFieldReferenceValue(
+    private val classResolver: ClassResolver,
+    override val qualifiedClassName: String,
+    override val fieldName: String,
+    private val kotlinCompanionClass: String?,
+    private val explicitConversionTo: Primitive?,
+) : DefaultValue(), FieldReferenceValue {
+
+    init {
+        // Make sure that `explicitConversionTo`, if specified, has a numeric conversion function.
+        require(
+            explicitConversionTo == null ||
+                explicitConversionTo.kotlinNumericConversionFunction != null
+        ) {
+            "Unexpected explicitConversionTo of $explicitConversionTo"
+        }
+    }
+
+    override fun appendValueStringTo(
+        builder: StringBuilder,
+        configuration: ValueStringConfiguration
+    ) {
+        if (kotlinCompanionClass != null && configuration.showKotlinCompanionClass) {
+            builder.append(kotlinCompanionClass).append('.').append(fieldName)
+        } else {
+            super.appendValueStringTo(builder, configuration)
+        }
+
+        // If required, add an explicit conversion function call to the value representation.
+        if (configuration.showKotlinConversionFunction && explicitConversionTo != null) {
+            val conversionFunction = explicitConversionTo.kotlinNumericConversionFunction
+            builder.append('.').append(conversionFunction).append("()")
+        }
+    }
+
+    private lateinit var optionalFieldItem: Optional<FieldItem>
+
+    /**
+     * The optional constant value of this field.
+     *
+     * Is `null` if the field does not reference a constant value.
+     *
+     * Note: This is NOT used in [equals], [hashCode] or [toString]. That is because this may be
+     * provided lazily and accessing it may have side effects but those methods are not expected to
+     * have side effects.
+     */
+    protected abstract val constantValue: ConstantValue?
+
+    /**
+     * Implement this here rather than in [FieldReferenceValue] as it needs to access
+     * [constantValue] which is an implementation detail.
+     */
+    override fun snapshot(targetCodebase: Codebase) =
+        Value.createFieldReferenceValue(
+            targetCodebase,
+            qualifiedClassName,
+            fieldName,
+            constantValue,
+            kotlinCompanionClass,
+            explicitConversionTo,
+        )
+
+    override fun resolve(): FieldItem? {
+        if (!::optionalFieldItem.isInitialized) {
+            if (qualifiedClassName == "") {
+                optionalFieldItem = Optional.empty()
+            } else {
+                optionalFieldItem =
+                    Optional.ofNullable(
+                        classResolver
+                            .resolveClass(qualifiedClassName)
+                            ?.findField(
+                                fieldName,
+                                includeSuperClasses = true,
+                                includeInterfaces = true,
+                            )
+                    )
+            }
+        }
+        return optionalFieldItem.getOrNull()
+    }
+}
+
+internal class DefaultFieldReferenceValue(
+    classResolver: ClassResolver,
+    qualifiedClassName: String,
+    fieldName: String,
+    override val constantValue: ConstantValue? = null,
+    kotlinCompanionClass: String? = null,
+    explicitConversionTo: Primitive? = null,
+) :
+    BaseFieldReferenceValue(
+        classResolver,
+        qualifiedClassName,
+        fieldName,
+        kotlinCompanionClass,
+        explicitConversionTo,
+    ) {
+
+    /** The [constantValue], if present, may be a [LiteralValue]. */
+    override fun asLiteralValue() = constantValue?.asLiteralValue()
+}
+
+internal class LazyFieldReferenceValue(
+    classResolver: ClassResolver,
+    qualifiedClassName: String,
+    fieldName: String,
+    private val optionalTypeItem: TypeItem?,
+    kotlinCompanionClass: String?,
+    explicitConversionTo: Primitive?,
+) :
+    BaseFieldReferenceValue(
+        classResolver,
+        qualifiedClassName,
+        fieldName,
+        kotlinCompanionClass,
+        explicitConversionTo,
+    ) {
+
+    private lateinit var optionalConstantValue: Optional<ConstantValue>
+
+    override val constantValue: ConstantValue?
+        get() {
+            if (!::optionalConstantValue.isInitialized) {
+                optionalConstantValue = Optional.ofNullable(retrieveConstantValue())
+            }
+
+            return optionalConstantValue.getOrNull()
+        }
+
+    private fun retrieveConstantValue(): ConstantValue? {
+        val fieldItem = resolve() ?: return null
+        if (fieldItem.isEnumConstant()) return null
+
+        // The actual constant value of a field reference is affected by the type of where it is
+        // used, just as it would if the field reference was replaced by its constant value. So,
+        // an `int` constant field that is used where a `long` is expected will be represented
+        // as a `LongValue` that was originally specified as an int.
+        //
+        // A field reference is not a literal so a value retrieved from a field must always be
+        // marked as non-literal.
+        return fieldItem.constantValue?.convertToType(
+            optionalTypeItem,
+            forceNonLiteralInSource = true,
+        )
+    }
+
+    /** The [optionalConstantValue], if present, may be a [LiteralValue]. */
+    override fun asLiteralValue() = constantValue?.asLiteralValue()
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/value/DefaultLiteralValue.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/value/DefaultLiteralValue.kt
new file mode 100644
index 000000000..4b95ceb1e
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/value/DefaultLiteralValue.kt
@@ -0,0 +1,268 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.value
+
+import com.android.tools.metalava.model.PrimitiveTypeItem
+import com.android.tools.metalava.model.TypeItem
+
+/** Base class for all [LiteralValue] implementations. */
+internal sealed class DefaultLiteralValue<U : Any> : DefaultValue(), LiteralValue<U> {
+    // Implement this in the class not the interface as it requires implementation details.
+
+    override fun convertToType(
+        optionalTypeItem: TypeItem?,
+        forceNonLiteralInSource: Boolean,
+    ): LiteralValue<*> {
+        optionalTypeItem ?: return this
+        if (optionalTypeItem.isPossiblyUnresolvedString() && underlyingValue is String) return this
+        if (optionalTypeItem !is PrimitiveTypeItem)
+            error("Cannot convert $this to a $optionalTypeItem")
+
+        // If the underlying value is already of the correct type and this is not being force to be
+        // non-literal, or if it is then it is already non-literal, then just return this.
+        // Otherwise, just drop through and perform the conversion.
+        if (
+            optionalTypeItem.kind.wrapperClass.isInstance(underlyingValue) &&
+                (!forceNonLiteralInSource || nonLiteralInSource)
+        )
+            return this
+
+        // Use the original value and original non-literal status.
+        return Value.createLiteralValue(
+            optionalTypeItem,
+            originalValue,
+            // Mark this as non-literal if it is being forced of this is already non-literal.
+            forceNonLiteralInSource || nonLiteralInSource
+        )
+    }
+
+    /**
+     * The original value of this from the source.
+     *
+     * This will differ from [underlyingValue] if this needed to be converted by
+     * [Value.createLiteralValue] to match the [TypeItem] for where this will be used. This is used
+     * to tweak formatting to match legacy behavior.
+     *
+     * This is [Any] instead of [Number] because the original value could be a [Char].
+     */
+    open val originalValue: Any
+        get() = underlyingValue
+
+    /**
+     * True if the source representation of this was a non-literal, i.e. not a literal expression
+     * but some other expression. This includes negative and explicitly positive numbers as they
+     * both are represented as a unary minus/plus expression respectively. For jars this is
+     * generally false but may be true for some values that cannot be represented as a literal, e.g.
+     * `Float.NaN`, etc.
+     */
+    open val nonLiteralInSource: Boolean
+        get() = false
+}
+
+internal sealed class DefaultPrimitiveValue<U : Any> : DefaultLiteralValue<U>(), PrimitiveValue<U>
+
+internal sealed class DefaultNumericValue<U : Number>(
+    override val originalValue: Any,
+    override val nonLiteralInSource: Boolean,
+) : DefaultPrimitiveValue<U>() {
+    /**
+     * If the [configuration] has [ValueStringConfiguration.useOriginalValueForNumbers] set to
+     * `true` and [originalValue] is also `true` then this will append [underlyingValue] as if it
+     * was an `int`, otherwise it will invoke [appendNumericValueTo] to append the value as normal.
+     */
+    final override fun appendValueStringTo(
+        builder: StringBuilder,
+        configuration: ValueStringConfiguration
+    ) {
+        configuration.specialValues[this]?.let {
+            builder.append(it)
+            return
+        }
+
+        if (configuration.useOriginalValueForNumbers) {
+            when (val originalValue = originalValue) {
+                is Int -> {
+                    appendIntegerValueTo(builder, configuration, originalValue)
+                    return
+                }
+                is Float -> {
+                    appendFloatValueTo(builder, configuration, originalValue)
+                    return
+                }
+            }
+        }
+
+        // Append the default numeric value to builder.
+        appendNumericValueTo(builder, configuration)
+    }
+
+    /**
+     * Append [intValue] to [builder] taking into account all relevant properties in
+     * [configuration].
+     */
+    internal fun appendIntegerValueTo(
+        builder: StringBuilder,
+        configuration: ValueStringConfiguration,
+        intValue: Int,
+    ) {
+        val format =
+            if (nonLiteralInSource) configuration.nonLiteralIntFormat else IntFormat.DECIMAL
+        when (format) {
+            IntFormat.HEXADECIMAL -> {
+                builder.append("0x").append(Integer.toHexString(intValue))
+            }
+            else -> {
+                builder.append(intValue)
+            }
+        }
+    }
+
+    /**
+     * Append [floatValue] to [builder] taking into account all relevant properties in
+     * [configuration].
+     */
+    internal fun appendFloatValueTo(
+        builder: StringBuilder,
+        configuration: ValueStringConfiguration,
+        floatValue: Float,
+    ) {
+        // If it was not a literal then use the non-literal suffix. This is mutually
+        // exclusive with it being specified as an int so it does not matter which one is
+        // performed first.
+        val suffix = if (nonLiteralInSource) configuration.nonLiteralFloatSuffix else 'f'
+        builder.append(floatValue).append(suffix)
+    }
+
+    internal open fun appendNumericValueTo(
+        builder: StringBuilder,
+        configuration: ValueStringConfiguration
+    ) {
+        builder.append(underlyingValue)
+    }
+
+    override fun appendLegacyStateTo(builder: StringBuilder) {
+        // If the original value class does not match the underlying value class then that could
+        // affect the legacy behavior of this so make sure that information is included in the
+        // legacy state string representation.
+        val expectedOriginalValueClass = underlyingValue.javaClass
+        val actualOriginalValueClass = originalValue.javaClass
+        if (actualOriginalValueClass != expectedOriginalValueClass) {
+            when (actualOriginalValueClass) {
+                intWrapperClass -> builder.append(",asInt")
+                floatWrapperClass -> builder.append(",asFloat")
+                else ->
+                    // If the value expected an int, but it was not an int then include that in the
+                    // state.
+                    if (expectedOriginalValueClass == intWrapperClass) builder.append(",!asInt")
+                    // If the value expected a float, but it was not a float then include that in
+                    // the state.
+                    else if (
+                        expectedOriginalValueClass == floatWrapperClass &&
+                            !originalValue.isSpecialDouble()
+                    )
+                        builder.append(",!asFloat")
+            }
+        }
+        if (nonLiteralInSource) builder.append(",nonLiteral")
+    }
+
+    /**
+     * Checks to see whether this is a special [Double].
+     *
+     * This is needed as Psi has some special handling of floating point values which do not have a
+     * literal representation. It represents such values that are retrieved from a class constant
+     * pool similar to how they are represented in the source, i.e. as a division-by-zero
+     * expression. Unfortunately, it does not do that in exactly the same way, i.e. it uses
+     * `(0.0f/0.0)` to represent `Float.NaN`. Unfortunately, that actually evaluates to a `Double`.
+     * The source uses `(0.0f/0.0f)` which evaluates to a `Float`.
+     */
+    private fun Any.isSpecialDouble() = this is Double && (isInfinite() || isNaN())
+
+    companion object {
+        private val intWrapperClass = Int::class.javaObjectType
+        private val floatWrapperClass = Float::class.javaObjectType
+    }
+}
+
+internal class DefaultBooleanValue(override val underlyingValue: Boolean) :
+    DefaultPrimitiveValue<Boolean>(), BooleanValue
+
+internal class DefaultByteValue(
+    override val underlyingValue: Byte,
+    originalValue: Any = underlyingValue,
+    nonLiteralInSource: Boolean = false,
+) : DefaultNumericValue<Byte>(originalValue, nonLiteralInSource), ByteValue
+
+internal class DefaultCharValue(override val underlyingValue: Char) :
+    DefaultPrimitiveValue<Char>(), CharValue
+
+internal class DefaultDoubleValue(
+    override val underlyingValue: Double,
+    originalValue: Any = underlyingValue,
+    nonLiteralInSource: Boolean = false,
+) : DefaultNumericValue<Double>(originalValue, nonLiteralInSource), DoubleValue
+
+internal class DefaultFloatValue(
+    override val underlyingValue: Float,
+    originalValue: Any = underlyingValue,
+    nonLiteralInSource: Boolean = false,
+) : DefaultNumericValue<Float>(originalValue, nonLiteralInSource), FloatValue {
+
+    override fun appendNumericValueTo(
+        builder: StringBuilder,
+        configuration: ValueStringConfiguration
+    ) {
+        appendFloatValueTo(builder, configuration, underlyingValue)
+    }
+}
+
+internal class DefaultIntValue(
+    override val underlyingValue: Int,
+    originalValue: Any = underlyingValue,
+    nonLiteralInSource: Boolean = false,
+) : DefaultNumericValue<Int>(originalValue, nonLiteralInSource), IntValue {
+
+    override fun appendNumericValueTo(
+        builder: StringBuilder,
+        configuration: ValueStringConfiguration
+    ) {
+        appendIntegerValueTo(builder, configuration, underlyingValue)
+    }
+}
+
+internal class DefaultLongValue(
+    override val underlyingValue: Long,
+    originalValue: Any = underlyingValue,
+    nonLiteralInSource: Boolean = false,
+) : DefaultNumericValue<Long>(originalValue, nonLiteralInSource), LongValue {
+
+    override fun appendNumericValueTo(
+        builder: StringBuilder,
+        configuration: ValueStringConfiguration
+    ) {
+        builder.append(underlyingValue).append('L')
+    }
+}
+
+internal class DefaultShortValue(
+    override val underlyingValue: Short,
+    originalValue: Any = underlyingValue,
+    nonLiteralInSource: Boolean = false,
+) : DefaultNumericValue<Short>(originalValue, nonLiteralInSource), ShortValue
+
+internal class DefaultStringValue(override val underlyingValue: String) :
+    DefaultLiteralValue<String>(), StringValue
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/value/ImplementationValueToModelFactory.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/value/ImplementationValueToModelFactory.kt
new file mode 100644
index 000000000..f19319e33
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/value/ImplementationValueToModelFactory.kt
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.value
+
+import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.TypeItem
+
+/**
+ * Interface provided by a model implementation to construct a model [Value] from an implementation
+ * value of type [I].
+ */
+interface ImplementationValueToModelFactory<I> {
+    /**
+     * Construct a model [Value] instance of [optionalTypeItem] from [implementationValue].
+     *
+     * If the [implementationValue] cannot be mapped to a [Value], e.g. because it is a field
+     * initializer that is not a constant expression, and [valueUseSite] is [ValueUseSite.FIELD]
+     * then this must return `null`. Otherwise, this must always return a [Value] or throw an
+     * exception.
+     */
+    fun implementationValueToModelValue(
+        optionalTypeItem: TypeItem?,
+        implementationValue: I,
+        valueUseSite: ValueUseSite,
+    ): Value?
+}
+
+/** A [BaseCachingValueProvider] for a model implementation of a non-attribute value. */
+class CachingValueProvider<I>(
+    private val factory: ImplementationValueToModelFactory<I>,
+    private val optionalTypeItem: TypeItem?,
+    private val implementationValue: I,
+    valueUseSite: ValueUseSite,
+) : BaseCachingValueProvider(valueUseSite) {
+    override fun provideValue() =
+        factory.implementationValueToModelValue(
+            optionalTypeItem,
+            implementationValue,
+            valueUseSite,
+        )
+}
+
+/**
+ * A [BaseCachingValueProvider] for a model implementation of a value whose [TypeItem] is not known
+ * at construction time.
+ *
+ * When this is called the [TypeItem] of the [Value] to be created is not known. So, subclasses of
+ * this must encapsulate the information necessary to allow the [Value]'s type to be resolved and
+ * use that in [optionalTypeItem] to return the [TypeItem], or `null` if it could not be found.
+ */
+abstract class BaseCachingDeferredTypeValueProvider<I>(
+    private val factory: ImplementationValueToModelFactory<I>,
+    private val implementationValue: I,
+    valueUseSite: ValueUseSite,
+) : BaseCachingValueProvider(valueUseSite) {
+
+    /** Get the optional [TypeItem] for the [Value] to be created. */
+    protected abstract fun optionalTypeItem(): TypeItem?
+
+    final override fun provideValue() =
+        factory.implementationValueToModelValue(
+            optionalTypeItem(),
+            implementationValue,
+            valueUseSite,
+        )
+}
+
+/**
+ * A [BaseCachingDeferredTypeValueProvider] for a model implementation of an attribute value.
+ *
+ * When this is called the [TypeItem] of the annotation attribute is not known. So, this
+ * encapsulates [annotationClassItemProvider] and [attributeName] to allow the annotation's
+ * [ClassItem] to be resolved and the [MethodItem] called [attributeName] found.
+ *
+ * If the definition of [AnnotationItem] is not resolvable then it will fail to find the [TypeItem]
+ * and use `null` instead.
+ */
+class CachingAnnotationValueProvider<I>(
+    factory: ImplementationValueToModelFactory<I>,
+    private val attributeName: String,
+    implementationValue: I,
+    private val annotationClassItemProvider: () -> ClassItem?,
+) :
+    BaseCachingDeferredTypeValueProvider<I>(
+        factory,
+        implementationValue,
+        valueUseSite = ValueUseSite.ANNOTATION
+    ) {
+
+    /**
+     * Secondary constructor that provides an [annotationClassItemProvider] using [annotationItem]'s
+     * [AnnotationItem.resolve] method.
+     */
+    constructor(
+        factory: ImplementationValueToModelFactory<I>,
+        annotationItem: AnnotationItem,
+        attributeName: String,
+        implementationValue: I,
+    ) : this(factory, attributeName, implementationValue, annotationItem::resolve)
+
+    /**
+     * Get the [MethodItem.returnType] of the [annotationClassItemProvider]'s attribute method
+     * called [attributeName].
+     */
+    override fun optionalTypeItem(): TypeItem? {
+        val annotationClassItem = annotationClassItemProvider() ?: return null
+        val attributeMethodItem = annotationClassItem.findMethod(attributeName, "")
+        return attributeMethodItem?.returnType()
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/value/LegacyValueFormatter.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/value/LegacyValueFormatter.kt
new file mode 100644
index 000000000..7f69d7aad
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/value/LegacyValueFormatter.kt
@@ -0,0 +1,548 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.value
+
+import com.android.tools.metalava.model.ANDROID_FLAGGED_API
+import com.android.tools.metalava.model.AnnotationAttribute
+import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.AnnotationTarget
+import com.android.tools.metalava.model.ClassContentItem
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ClassOrigin
+import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.MemberItem
+import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.SelectableItem
+import com.android.tools.metalava.model.SourceLanguage
+import com.android.tools.metalava.model.javaEscapeString
+import java.lang.StringBuilder
+
+/**
+ * Provide support for formatting [Value]s consistently with various legacy string representations.
+ *
+ * Legacy string representations of values are extremely inconsistent and vary by:
+ * * The legacy use site, e.g. [FieldItem.writeValueWithSemicolon], [MethodItem.legacyDefaultValue],
+ *   [AnnotationItem.toSource].
+ * * The [ClassItem.origin], i.e. sources or jars.
+ * * The source language, i.e. Kotlin or Java. Signature files are not a factor because they
+ *   preserve what was written into them from sources.
+ *
+ * The purpose of this is to take all those factors into account so that it can produce the same
+ * output from a [Value] as is currently produced by the legacy use site. Ultimately, the plan is to
+ * implement the legacy string representations by applying one of these to the [Value].
+ *
+ * There will be one instance of this created per legacy use site.
+ *
+ * @param javaSettings the [Settings] to use when formatting a value whose context [MemberItem] is
+ *   loaded from Java sources, will also apply to Kotlin sources unless [kotlinSettings] is provided
+ *   and [MemberItem]s loaded from a Jar when [jarSettings] is not provided.
+ * @param kotlinSettings the [Settings] to use when formatting a value whose context [MemberItem] is
+ *   loaded from Kotlin sources; defaults to [javaSettings].
+ * @param jarSettings the [Settings] to use when formatting a value whose context [MemberItem] is
+ *   loaded from a jar; defaults to [javaSettings].
+ */
+class LegacyValueFormatter(
+    javaSettings: Settings,
+    kotlinSettings: Settings = javaSettings,
+    jarSettings: Settings = javaSettings,
+) {
+    /**
+     * Copy the [javaSettings] and bind it to this [LegacyValueFormatter] so that
+     * [ appendFormattedValue] will be called for nested [Value]s.
+     */
+    private val javaSettings = javaSettings.bindTo(this)
+
+    /**
+     * Copy the [kotlinSettings] and bind it to this [LegacyValueFormatter] so that
+     * [ appendFormattedValue] will be called for nested [Value]s.
+     */
+    private val kotlinSettings = kotlinSettings.bindTo(this)
+
+    /**
+     * Copy the [jarSettings] and bind it to this [LegacyValueFormatter] so that
+     * [ appendFormattedValue] will be called for nested [Value]s.
+     */
+    private val jarSettings = jarSettings.bindTo(this)
+
+    /**
+     * Determines whether to inline a [FieldReferenceValue] with its [ConstantValue], if available.
+     *
+     * If the field does not have a [ConstantValue], e.g. because it is an enum, unresolvable, or
+     * not a constant field then just format it as a normal field reference. That is probably wrong
+     * but the formatter MUST always write something out.
+     */
+    enum class InlineFieldValue {
+        /** Always inline the [FieldReferenceValue], if possible. */
+        ALWAYS,
+
+        /**
+         * Only inline the [FieldReferenceValue], if it is hidden or removed (as determined by
+         * [SelectableItem.isHiddenOrRemoved]).
+         */
+        WHEN_HIDDEN_OR_REMOVED,
+
+        /**
+         * Only inline the [FieldReferenceValue], if it is inaccessible, i.e. hidden, removed or not
+         * public.
+         */
+        WHEN_INACCESSIBLE,
+    }
+
+    /** Settings that affect the formatting of a [Value]. */
+    data class Settings(
+        /** The configuration that is used as the basis for [boundConfiguration]. */
+        private val valueStringConfiguration: ValueStringConfiguration =
+            ValueStringConfiguration.DEFAULT,
+
+        /**
+         * A map from [Value] to the string representation to use in place of the [Value]'s string
+         * representation.
+         *
+         * Used to provide special string representations for specific values, e.g. special floating
+         * point numbers.
+         */
+        val stringReplacement: Map<Value, String> = emptyMap(),
+
+        /** The lambda that will be invoked to append nested [Value]s. */
+        val nestedValueAppender: (Value, StringBuilder, Settings) -> Unit = { value, builder, _ ->
+            value.appendValueStringTo(builder)
+        },
+
+        /** Determines whether to inline a [FieldReferenceValue]. */
+        val inlineFields: InlineFieldValue = InlineFieldValue.WHEN_INACCESSIBLE,
+
+        /**
+         * If `true` then just use the [Number.toString] method for [LiteralValue.underlyingValue]s
+         * that are [Number]s.
+         */
+        val dropLongAndFloatTypeSuffix: Boolean = false,
+
+        /**
+         * If `true` then just use double quotes for [CharValue] not single quotes, which is the
+         * default.
+         */
+        val useDoubleQuotesForChar: Boolean = false,
+    ) {
+        /**
+         * The configuration that must be used when calling [Value.toValueString].
+         *
+         * This is a copy of [valueStringConfiguration] with its
+         * [ValueStringConfiguration.nestedValueAppender] set to redirect the call to
+         * [nestedValueAppender].
+         */
+        val boundConfiguration =
+            valueStringConfiguration.copy(
+                nestedValueAppender = { value, builder, _ ->
+                    nestedValueAppender(value, builder, this)
+                }
+            )
+
+        /**
+         * Create a copy of this which delegates calls to [nestedValueAppender] to
+         * [nestedFormatter]'s [LegacyValueFormatter.appendFormattedValue] method.
+         */
+        fun bindTo(nestedFormatter: LegacyValueFormatter): Settings {
+            return copy(nestedValueAppender = nestedFormatter::appendFormattedValue)
+        }
+    }
+
+    /**
+     * Format [value] within the [context].
+     *
+     * The [context] must be provided as follows:
+     * * When formatting a [Value] from [FieldItem.constantValue] it must be the [FieldItem].
+     * * When formatting a [Value] from [MethodItem.defaultValue] it must be the [MethodItem].
+     *
+     * This is not suitable for formatting a [Value] from [AnnotationAttribute.value].
+     */
+    fun format(value: Value, context: MemberItem): String {
+        val settings = selectSettingsForContext(context)
+        return format(settings, value)
+    }
+
+    /**
+     * Select the settings to use based on whether it is from the classpath (a jar) or sources. That
+     * determination is made using [context]. If that is `null` then this will use the
+     * [javaSettings] by default.
+     */
+    private fun selectSettingsForContext(context: Item?) =
+        when {
+            context == null -> javaSettings
+            context is ClassContentItem && context.origin == ClassOrigin.CLASS_PATH -> jarSettings
+            context.sourceLanguage == SourceLanguage.KOTLIN -> kotlinSettings
+            else -> javaSettings
+        }
+
+    /** Format [value] according to [settings]. */
+    private fun format(settings: Settings, value: Value) = buildString {
+        appendFormattedValue(value, this, settings)
+    }
+
+    /** Append the formatted [value] to [builder] according to [settings]. */
+    private fun appendFormattedValue(value: Value, builder: StringBuilder, settings: Settings) {
+        // If there is a string replacement then return it.
+        settings.stringReplacement[value]?.let { replacement ->
+            builder.append(replacement)
+            return
+        }
+
+        if (settings.useDoubleQuotesForChar && value is CharValue) {
+            val underlyingValue = value.underlyingValue
+            builder.append('"').append(javaEscapeString(underlyingValue.toString())).append('"')
+            return
+        }
+
+        // If the value is a field that should always be inlined, or is unresolvable or inaccessible
+        // then use its value, if available. Otherwise, fall back to using it anyway as a value must
+        // be formatted.
+        val valueToAppend =
+            (value as? FieldReferenceValue)?.let { field ->
+                when (settings.inlineFields) {
+                    // The field should always be inlined, if possible.
+                    InlineFieldValue.ALWAYS -> field.asLiteralValue()
+
+                    // The field should be inlined only when it is inaccessible.
+                    InlineFieldValue.WHEN_INACCESSIBLE ->
+                        if (field.resolve().isAccessible()) field else field.asLiteralValue()
+
+                    // The field should be inlined only when it is hidden or removed.
+                    InlineFieldValue.WHEN_HIDDEN_OR_REMOVED ->
+                        if (field.resolve()?.isHiddenOrRemoved() != true) field
+                        else field.asLiteralValue()
+                }
+            } ?: value
+
+        // Fallback to just using the default value representation according to the settings. This
+        // passes in the [Settings.boundConfiguration] as that has a `nestedValueAppender` that
+        // will call back into this method for nested values, i.e. values in an array and attribute
+        // values of nested annotations.
+        valueToAppend.appendValueStringTo(builder, settings.boundConfiguration)
+
+        if (settings.dropLongAndFloatTypeSuffix) {
+            val lastCharIndex = builder.length - 1
+            if (
+                (valueToAppend is LongValue && builder[lastCharIndex] == 'L') ||
+                    (valueToAppend is FloatValue && builder[lastCharIndex] == 'f')
+            ) {
+                builder.setLength(lastCharIndex)
+            }
+        }
+    }
+
+    /** True if this [FieldItem] is not-null, is not hidden or removed and is public. */
+    private fun FieldItem?.isAccessible() = this != null && !isHiddenOrRemoved() && isPublic
+
+    /** Get the annotation specific settings that incorporate [target] and [alwaysInlineFields]. */
+    private fun annotationSpecificSetting(
+        settings: Settings,
+        target: AnnotationTarget,
+        alwaysInlineFields: Boolean,
+    ) =
+        settings.copy(
+            valueStringConfiguration =
+                // Incorporate the target into the [ValueStringConfiguration]. This uses the
+                // [Settings.boundConfiguration] as the [Settings.valueStringConfiguration] is
+                // intentionally inaccessible as it must not be used directly. That is not an issue
+                // as the `boundConfiguration` is identical to `valueStringConfiguration` apart from
+                // the `nestedValueAppender` and that will be updated by [Settings]'s initializer.
+                settings.boundConfiguration.copy(
+                    annotationQualifiedNameGetter = { annotationItem ->
+                        annotationItem.annotationContext.annotationManager.normalizeOutputName(
+                            annotationItem.qualifiedName,
+                            target
+                        )
+                    },
+                ),
+            inlineFields =
+                if (alwaysInlineFields) InlineFieldValue.ALWAYS else settings.inlineFields,
+        )
+
+    /** Format [annotationItem] to match the legacy behavior of [AnnotationItem.toSource]. */
+    fun annotationItemToSource(
+        annotationItem: AnnotationItem,
+        target: AnnotationTarget,
+        context: Item?
+    ): String {
+        val settings = selectSettingsForContext(context)
+
+        val alwaysInlineFields = annotationItem.qualifiedName == ANDROID_FLAGGED_API
+
+        val annotationSpecificSetting =
+            annotationSpecificSetting(settings, target, alwaysInlineFields)
+
+        return buildString {
+            // Append the annotation item.  This passes in the [Settings.boundConfiguration] as that
+            // has a `nestedValueAppender` that will call back into [appendFormattedValue] for
+            // nested values, i.e. values in an array and attribute values of nested annotations.
+            annotationItem.appendAnnotationStringTo(
+                this,
+                annotationSpecificSetting.boundConfiguration,
+                annotationIsValue = false
+            )
+        }
+    }
+
+    companion object {
+        /** Setting for formatting [MethodItem.defaultValue] from Java sources. */
+        private val ATTRIBUTE_DEFAULT_JAVA_SETTINGS =
+            Settings(
+                valueStringConfiguration =
+                    ValueStringConfiguration(
+                        // Use the source representation of a single array element when formatting.
+                        singleArrayElementFormat =
+                            @Suppress("DEPRECATION") SingleArrayElementFormat.SOURCE,
+
+                        // Annotation attributes are not sorted in the default values.
+                        sortAnnotationAttributes = false,
+
+                        // Some values are treated specially in [MethodItem.defaultValue].
+                        specialValues =
+                            mapOf(
+                                DoubleValue.NaN to "java.lang.Double.NaN",
+                                DoubleValue.NEGATIVE_INFINITY to
+                                    "java.lang.Double.NEGATIVE_INFINITY",
+                                DoubleValue.POSITIVE_INFINITY to
+                                    "java.lang.Double.POSITIVE_INFINITY",
+                                FloatValue.NaN to "java.lang.Float.NaN",
+                                FloatValue.NEGATIVE_INFINITY to "java.lang.Float.NEGATIVE_INFINITY",
+                                FloatValue.POSITIVE_INFINITY to "java.lang.Float.POSITIVE_INFINITY",
+                            ),
+
+                        // In the source, values that were written as ints were formatted as ints
+                        // even if they were `double`, `float`, or `long`.
+                        useOriginalValueForNumbers = true,
+                    ),
+            )
+
+        /** Setting for formatting [MethodItem.defaultValue] from Kotlin sources. */
+        private val ATTRIBUTE_DEFAULT_KOTLIN_SETTINGS =
+            Settings(
+                valueStringConfiguration =
+                    ValueStringConfiguration(
+                        // Legacy formatting of annotations in Kotlin default methods do not use
+                        // spaces in the separator between attribute name and value.
+                        annotationAttributeNameValueSeparator =
+                            AnnotationAttributeNameValueSeparator.WITHOUT_SPACES,
+
+                        // ClassObjectValues are output using their source expression in Kotlin.
+                        classObjectValueFormat = ClassObjectValueFormat.SOURCE,
+
+                        // Use the source representation of a single array element when formatting.
+                        singleArrayElementFormat =
+                            @Suppress("DEPRECATION") SingleArrayElementFormat.SOURCE,
+
+                        // Annotation attributes are not sorted in the default values.
+                        sortAnnotationAttributes = false,
+
+                        // Some values are treated differently in Kotlin in
+                        // [MethodItem.defaultValue].
+                        specialValues =
+                            mapOf(
+                                DoubleValue.NaN to "kotlin.jvm.internal.DoubleCompanionObject.NaN",
+                                DoubleValue.NEGATIVE_INFINITY to
+                                    "kotlin.jvm.internal.DoubleCompanionObject.NEGATIVE_INFINITY",
+                                DoubleValue.POSITIVE_INFINITY to
+                                    "kotlin.jvm.internal.DoubleCompanionObject.POSITIVE_INFINITY",
+                                FloatValue.NaN to "kotlin.jvm.internal.FloatCompanionObject.NaN",
+                                FloatValue.NEGATIVE_INFINITY to
+                                    "kotlin.jvm.internal.FloatCompanionObject.NEGATIVE_INFINITY",
+                                FloatValue.POSITIVE_INFINITY to
+                                    "kotlin.jvm.internal.FloatCompanionObject.POSITIVE_INFINITY",
+                            ),
+
+                        // In the source, values that were written as ints were formatted as ints
+                        // even if they were `double`, `float`, or `long`.
+                        useOriginalValueForNumbers = true,
+
+                        // Use Kotlin formatting of values.
+                        valueLanguage = ValueLanguage.KOTLIN,
+                    ),
+                stringReplacement =
+                    mapOf(
+                        // Ignore an empty array as that is the legacy behavior for method default
+                        // values created from Kotlin sources.
+                        Value.createArrayValue(emptyList()) to "",
+                    ),
+
+                // Method default values from Kotlin sources do not add a type suffix character for
+                // long or float.
+                dropLongAndFloatTypeSuffix = true,
+
+                // Chars are wrapped in double quotes for method default values created from
+                // Kotlin sources.
+                useDoubleQuotesForChar = true,
+            )
+
+        /** Setting for formatting [MethodItem.defaultValue] from Jar classes. */
+        private val ATTRIBUTE_DEFAULT_JAR_SETTINGS =
+            Settings(
+                valueStringConfiguration =
+                    ValueStringConfiguration(
+                        // Do not unwrap a single array element when formatting a value from a jar
+                        // as they were never unwrapped.
+                        singleArrayElementFormat = SingleArrayElementFormat.WRAP,
+
+                        // Annotation attributes are not sorted in the default values.
+                        sortAnnotationAttributes = false,
+
+                        // In the jar file special values were always stored as their constant value
+                        // so they
+                        // were never formatted as their fields.
+                        specialValues =
+                            mapOf(
+                                DoubleValue.NaN to "(0.0/0.0)",
+                                DoubleValue.NEGATIVE_INFINITY to "(-1.0/0.0)",
+                                DoubleValue.POSITIVE_INFINITY to "(1.0/0.0)",
+                                FloatValue.NaN to "(0.0/0.0)",
+                                FloatValue.NEGATIVE_INFINITY to "(-1.0/0.0)",
+                                FloatValue.POSITIVE_INFINITY to "(1.0/0.0)",
+                            ),
+
+                        // In the jar, values are always stored as their actual type so were never
+                        // represented as an int.
+                        useOriginalValueForNumbers = false,
+                    ),
+            )
+
+        /** A [LegacyValueFormatter] for formatting [MethodItem.defaultValue]s. */
+        val ATTRIBUTE_DEFAULT_FORMATTER =
+            LegacyValueFormatter(
+                javaSettings = ATTRIBUTE_DEFAULT_JAVA_SETTINGS,
+                kotlinSettings = ATTRIBUTE_DEFAULT_KOTLIN_SETTINGS,
+                jarSettings = ATTRIBUTE_DEFAULT_JAR_SETTINGS,
+            )
+
+        /** Setting for formatting [AnnotationItem.toSource] from Java sources. */
+        private val ANNOTATION_SOURCE_JAVA_SETTINGS =
+            ATTRIBUTE_DEFAULT_JAVA_SETTINGS.copy(
+                valueStringConfiguration =
+                    ATTRIBUTE_DEFAULT_JAVA_SETTINGS.boundConfiguration.copy(
+                        // Legacy AnnotationItem.toSource() formats Java annotations without spaces
+                        // around the `=` in `attr=value`.
+                        annotationAttributeNameValueSeparator =
+                            AnnotationAttributeNameValueSeparator.WITHOUT_SPACES,
+
+                        // Legacy AnnotationItem.toSource() formats class references as they were
+                        // specified in the source.
+                        classObjectValueFormat = ClassObjectValueFormat.SOURCE,
+
+                        // Legacy AnnotationItem.toSource() uses `F` as the suffix for floats that
+                        // were not specified as literals in the source.
+                        nonLiteralFloatSuffix = 'F',
+
+                        // Legacy AnnotationItem.toSource() formats ints as hexadecimals if they
+                        // were not specified as literals in the source.
+                        nonLiteralIntFormat = IntFormat.HEXADECIMAL,
+                    ),
+            )
+
+        /** Setting for formatting [AnnotationItem.toSource] from Kotlin sources. */
+        private val ANNOTATION_SOURCE_KOTLIN_SETTINGS =
+            ATTRIBUTE_DEFAULT_KOTLIN_SETTINGS.copy(
+                valueStringConfiguration =
+                    ATTRIBUTE_DEFAULT_KOTLIN_SETTINGS.boundConfiguration.copy(
+                        // Legacy AnnotationItem.toSource() formats Kotlin annotations with spaces
+                        // around the `=` in `attr = value`.
+                        annotationAttributeNameValueSeparator =
+                            AnnotationAttributeNameValueSeparator.WITHOUT_SPACES,
+
+                        // Legacy AnnotationItem.toSource() formats ints as hexadecimals if they
+                        // were not specified as literals in the source.
+                        nonLiteralIntFormat = IntFormat.HEXADECIMAL,
+
+                        // Legacy AnnotationItem.toSource() includes the companion object's class
+                        // name in references to fields defined in a companion object.
+                        showKotlinCompanionClass = true,
+
+                        // Legacy AnnotationItem.toSource() includes a call to a numeric conversion
+                        // function, e.g. `INT_FIELD.toLong()`.
+                        showKotlinConversionFunction = true,
+
+                        // Legacy AnnotationItem.toSource() formats numbers based on the literal
+                        // they used in the source/constant type in class constant pool.
+                        useOriginalValueForNumbers = false,
+                    ),
+
+                // Override [ATTRIBUTE_DEFAULT_KOTLIN_SETTINGS] which does not handle empty arrays
+                // correctly while this does.
+                stringReplacement = emptyMap(),
+
+                // Legacy AnnotationItem.toSource() adds double quotes around chars from Kotlin
+                // sources.
+                useDoubleQuotesForChar = false,
+
+                // Legacy AnnotationItem.toSource() does not add long or float suffixes for values
+                // obtained from Kotlin sources.
+                dropLongAndFloatTypeSuffix = false,
+
+                // Legacy AnnotationItem.toSource() only inlined hidden or removed fields used in
+                // Kotlin sources. It would keep non-public fields.
+                inlineFields = InlineFieldValue.WHEN_HIDDEN_OR_REMOVED,
+            )
+
+        /** Setting for formatting [AnnotationItem.toSource] from Jar classes. */
+        private val ANNOTATION_SOURCE_JAR_SETTINGS =
+            Settings(
+                valueStringConfiguration =
+                    ValueStringConfiguration(
+                        // Legacy AnnotationItem.toSource() formats jar annotations without spaces
+                        // around the `=` in `attr=value`.
+                        annotationAttributeNameValueSeparator =
+                            AnnotationAttributeNameValueSeparator.WITHOUT_SPACES,
+
+                        // Legacy AnnotationItem.toSource() uses `F` as the suffix for negative
+                        // floats in the jar.
+                        nonLiteralFloatSuffix = 'F',
+
+                        // Legacy AnnotationItem.toSource() formats negative ints as hexadecimals
+                        // when they came from a jar.
+                        nonLiteralIntFormat = IntFormat.HEXADECIMAL,
+
+                        // Do not unwrap a single array element when formatting a value from a jar
+                        // as they were never unwrapped.
+                        singleArrayElementFormat = SingleArrayElementFormat.WRAP,
+
+                        // Annotation attributes are not sorted in the default values.
+                        sortAnnotationAttributes = false,
+
+                        // In the jar, while values are always stored as their actual type bytes and
+                        // shorts do not have their own constant type and so are stored as ints.
+                        useOriginalValueForNumbers = true,
+                    ),
+                // In the jar file special values were always stored as their constant value so they
+                // were never formatted as their fields.
+                stringReplacement =
+                    mapOf(
+                        DoubleValue.NaN to "0.0 / 0.0",
+                        DoubleValue.NEGATIVE_INFINITY to "-1.0 / 0.0",
+                        DoubleValue.POSITIVE_INFINITY to "1.0 / 0.0",
+                        FloatValue.NaN to "0.0f / 0.0",
+                        FloatValue.NEGATIVE_INFINITY to "-1.0F / 0.0",
+                        FloatValue.POSITIVE_INFINITY to "1.0f / 0.0",
+                    ),
+            )
+
+        /** Used in [AnnotationItem.toSource]. */
+        val ANNOTATION_SOURCE_FORMATTER =
+            LegacyValueFormatter(
+                javaSettings = ANNOTATION_SOURCE_JAVA_SETTINGS,
+                kotlinSettings = ANNOTATION_SOURCE_KOTLIN_SETTINGS,
+                jarSettings = ANNOTATION_SOURCE_JAR_SETTINGS,
+            )
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/value/Value.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/value/Value.kt
new file mode 100644
index 000000000..61195d65b
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/value/Value.kt
@@ -0,0 +1,849 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.value
+
+import com.android.tools.metalava.model.AnnotationAttribute
+import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.ArrayTypeItem
+import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.PrimitiveTypeItem
+import com.android.tools.metalava.model.PrimitiveTypeItem.Primitive
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.javaEscapeString
+import com.android.tools.metalava.model.value.Value.Companion.toString
+import java.util.EnumSet
+import java.util.Objects
+import kotlin.reflect.KClass
+
+/**
+ * Represents a value in a [Codebase].
+ *
+ * A [Value]'s primary purpose is to ensure consistent behavior irrespective of the source
+ * expression from which it was created, i.e. consumers of [Value]s should not have to worry about
+ * the source expression. e.g. assuming they are being assigned to a `long` field the following
+ * expressions should result in [Value] instances which are equal to each other:
+ * * `3000`
+ * * `3000L`
+ * * `3_000L`
+ *
+ * However, there is also a need to create exactly the same string representations of a [Value] as
+ * are currently produced by the various legacy source representations, which often is affected by
+ * the original source expression. That will require additional information to be kept in the
+ * [Value] about the original source expression. Eventually, the goal will be to deprecate, remove
+ * and stop supporting consuming the legacy source representations but this is needed in the
+ * meantime.
+ *
+ * These two requirements are in conflict and will be resolved on the basis that consistent behavior
+ * is more important in the long term so it will be prioritized for convenience and simplicity.
+ *
+ * Supporting the two requirements will be done by splitting the [Value] state into two sets as
+ * described below.
+ *
+ * ### "Normalized State" ###
+ *
+ * This is the state that is independent of the particular form of the original source expression
+ * from which it was created. Another way of describing it is the value that would be used at
+ * runtime after the compiler has processed the expression, with the caveat that constant fields
+ * will be preserved.
+ *
+ * It has the following characteristics:
+ * 1. It will be accessible through [Value] interfaces.
+ * 2. It will be included in the default output of [Value.toValueString].
+ * 3. It will be compared using [equals] and hashed using [hashCode].
+ *
+ * That last point means it will not be possible to use a [Value] as a key where its legacy
+ * representation is important.
+ *
+ * ### "Legacy State" ###
+ *
+ * This is the state that is dependent on some aspect of the particular form of the original source
+ * expression.
+ *
+ * It has the following characteristics:
+ * 1. It will NOT be accessible through [Value] interfaces.
+ * 2. It will affect the output of [Value.toValueString] when given an appropriate
+ *    [ValueStringConfiguration].
+ * 3. It will be provided via implementations of [debugStringForValue] and used by [toString].
+ *
+ * That last point means that the [toString] value can be used as a key into a cache when the legacy
+ * representation of the cached data is important, e.g. in testing or when preserving legacy
+ * behavior in the output.
+ *
+ * Special support has been added assert equality of [Value]s when the legacy state is important.
+ * See `assertValuesAreStrictlyEqual(...)`.
+ */
+sealed interface Value {
+    /** The kind of this [Value]. */
+    val kind: ValueKind
+
+    /**
+     * Get this [Value] as a [LiteralValue], or return `null` if it cannot be represented as one.
+     *
+     * This will return `null` for every [Value] except [LiteralValue] and maybe
+     * [FieldReferenceValue], which will return its constant value if it has one.
+     */
+    fun asLiteralValue(): LiteralValue<*>? = null
+
+    /** Get this [Value] as a flat list of [ArrayElementValue]s. */
+    fun asFlatList(): List<ArrayElementValue>
+
+    /**
+     * Create a snapshot for this suitable for use in [targetCodebase].
+     *
+     * This is needed as some [Value]s will reference items in the [Codebase].
+     */
+    fun snapshot(targetCodebase: Codebase) = this
+
+    /**
+     * Transform this [Value].
+     *
+     * @param transformer transforms an [ArrayElementValue] to either another [ArrayElementValue] or
+     *   `null` if the input [ArrayElementValue] should be ignored for some reason.
+     */
+    fun transform(transformer: (ArrayElementValue) -> ArrayElementValue?): Value?
+
+    /**
+     * A string representation of the value.
+     *
+     * See [appendValueStringTo] for more details.
+     */
+    fun toValueString(
+        configuration: ValueStringConfiguration = ValueStringConfiguration.DEFAULT
+    ): String
+
+    /**
+     * Append a string representation of this to [builder] as required by [configuration].
+     *
+     * There can be many different representations of each value but the default version used here
+     * should be the simplest source representation of the value.
+     *
+     * By default, i.e. when [configuration] is equal to [ValueStringConfiguration.DEFAULT], this
+     * will only include "Normalized State" in the returned [String]. However, with a suitable
+     * [ValueStringConfiguration] it may include "Legacy State".
+     */
+    fun appendValueStringTo(
+        builder: StringBuilder,
+        configuration: ValueStringConfiguration = ValueStringConfiguration.DEFAULT
+    )
+
+    /**
+     * Whether this value is equal to [other].
+     *
+     * This is implemented on each sub-interface of [Value] instead of [equals] because interfaces
+     * are not allowed to implement [equals].
+     *
+     * Note: This must only compare "Normalized State", see [Value] for more information.
+     */
+    fun equalToValue(other: Value): Boolean
+
+    /**
+     * Hashcode for the type.
+     *
+     * This is implemented on each sub-interface of [Value] instead of [hashCode] because interfaces
+     * are not allowed to implement [hashCode].
+     *
+     * Note: This must only hash "Normalized State", see [Value] for more information.
+     */
+    fun hashCodeForValue(): Int
+
+    /**
+     * Provides a string representation of the complete internal state, both "Normalized" and
+     * "Legacy"; useful for debugging and testing.
+     *
+     * See [appendDebugStringTo] for more details.
+     */
+    @Deprecated(message = "Do not call directly", replaceWith = ReplaceWith("toString()"))
+    fun debugStringForValue(): String
+
+    /**
+     * Appends a string representation of the complete internal state, both "Normalized" and
+     * "Legacy", to [builder]; useful for debugging and testing.
+     *
+     * See [Value] for an explanation of the terms "Normalized" and "Legacy".
+     *
+     * The [toString] method (which calls this) should be used instead of calling this directly. To
+     * encourage that this is deprecated.
+     *
+     * As this will provide access to "Legacy State" which cannot be exposed through these
+     * interfaces this will need to be implemented in the implementation classes.
+     */
+    @Deprecated(message = "Do not call directly", replaceWith = ReplaceWith("toString()"))
+    fun appendDebugStringTo(builder: StringBuilder) {
+        appendValueStringTo(builder, ValueStringConfiguration.DEBUG)
+        appendLegacyStateTo(builder)
+    }
+
+    /**
+     * Append any legacy state to the string representation.
+     *
+     * Care must be taken when deciding what legacy state needs to be included in the string
+     * representation as that will affect whether values are considered strictly equal or not.
+     */
+    fun appendLegacyStateTo(builder: StringBuilder) {}
+
+    /** Append this [Value]'s [toString] result to [builder]. */
+    fun appendToStringTo(builder: StringBuilder)
+
+    /**
+     * The string representation of a [Value] that includes the implementation class name as well as
+     * [debugStringForValue].
+     */
+    override fun toString(): String
+
+    /**
+     * Companion object implements [ValueFactory] to allow factory methods to be accessed for
+     * testing purposes using the object, e.g. [Value.createLiteralValue].
+     */
+    companion object : ValueFactory
+}
+
+/** Get this [Value] as an [Any], or `null` if it cannot be represented as an [Any]. */
+fun Value.asAny() = asLiteralValue()?.underlyingValue
+
+/** Get this [Value] as a [Boolean], or `null` if it cannot be represented as a [Boolean]. */
+fun Value.asBoolean() = (asLiteralValue() as? BooleanValue)?.underlyingValue
+
+/** Get this [Value] as a [Double], or `null` if it cannot be represented as a [Double]. */
+fun Value.asDouble() = (asLiteralValue() as? DoubleValue)?.underlyingValue
+
+/** Get this [Value] as a [Float], or `null` if it cannot be represented as a [Float]. */
+fun Value.asFloat() = (asLiteralValue() as? FloatValue)?.underlyingValue
+
+/** Get this [Value] as an [Int], or `null` if it cannot be represented as a [Int]. */
+fun Value.asInt() = (asLiteralValue() as? IntValue)?.underlyingValue
+
+/** Get this [Value] as a [Long], or `null` if it cannot be represented as a [Long]. */
+fun Value.asLong() = (asLiteralValue() as? LongValue)?.underlyingValue
+
+/** Get this [Value] as a [String], or `null` if it cannot be represented as a [String]. */
+fun Value.asString() = (asLiteralValue() as? StringValue)?.underlyingValue
+
+/**
+ * Configuration options for how to represent a value as a string.
+ *
+ * @param annotationAttributeNameValueSeparator The string to use to separate annotation attribute
+ *   name and value.
+ * @param annotationQualifiedNameGetter The lambda to call to retrieve the qualified class name for
+ *   an [AnnotationItem].
+ * @param classObjectValueFormat How to format a [ClassObjectValue].
+ * @param nestedValueAppender The function to use to append nested [Value]s to a [StringBuilder].
+ * @param nonLiteralFloatSuffix The suffix to use for a [FloatValue] that was represented in the
+ *   source as an expression (including negative numbers which are represented as a unary minus
+ *   expression).
+ * @param nonLiteralIntFormat How to format an [IntValue] that was represented in the source as an
+ *   expression (including negative numbers which are represented as a unary minus expression).
+ * @param showKotlinCompanionClass Whether to show that a field is in a Kotlin Companion object or
+ *   not.
+ * @param showKotlinConversionFunction Whether to show an explicit conversion function call, e.g.
+ *   `.toLong()` for a field reference that requires converting in Kotlin.
+ * @param singleArrayElementFormat How to treat an array that contains only a single element.
+ * @param sortAnnotationAttributes Whether to sort the attributes by name or keep them in the order
+ *   they were added.
+ * @param useOriginalValueForNumbers Whether to use the original value for a number value, i.e.
+ *   [ByteValue], [DoubleValue], [FloatValue], [IntValue], [LongValue], [ShortValue]. At the moment
+ *   this is limited to only using the original value if it was an `Int`.
+ * @param valueLanguage The language whose representation of [Value] should be used.
+ */
+data class ValueStringConfiguration(
+    val annotationAttributeNameValueSeparator: AnnotationAttributeNameValueSeparator =
+        AnnotationAttributeNameValueSeparator.WITH_SPACES,
+    val annotationQualifiedNameGetter: (AnnotationItem) -> String = { it.qualifiedName },
+    val classObjectValueFormat: ClassObjectValueFormat = ClassObjectValueFormat.JAVA,
+    val showKotlinCompanionClass: Boolean = false,
+    val showKotlinConversionFunction: Boolean = false,
+    val nestedValueAppender: (Value, StringBuilder, ValueStringConfiguration) -> Unit =
+        Value::appendValueStringTo,
+    val nonLiteralFloatSuffix: Char = 'f',
+    val nonLiteralIntFormat: IntFormat = IntFormat.DECIMAL,
+    val singleArrayElementFormat: SingleArrayElementFormat = SingleArrayElementFormat.WRAP,
+    val sortAnnotationAttributes: Boolean = true,
+    val specialValues: Map<LiteralValue<*>, String> = defaultSpecialValues,
+    val useOriginalValueForNumbers: Boolean = false,
+    val valueLanguage: ValueLanguage = ValueLanguage.JAVA,
+) {
+    /** Use the [nestedValueAppender] to append a string representation of [Value] to [builder]. */
+    fun appendNestedValueTo(builder: StringBuilder, value: Value) {
+        nestedValueAppender(value, builder, this)
+    }
+
+    companion object {
+        /**
+         * Default set of special values.
+         *
+         * Must be initialized before any [ValueStringConfiguration], e.g. [DEFAULT], is created.
+         */
+        private val defaultSpecialValues =
+            mapOf<LiteralValue<*>, String>(
+                DoubleValue.NaN to "(0.0/0.0)",
+                DoubleValue.NEGATIVE_INFINITY to "(-1.0/0.0)",
+                DoubleValue.POSITIVE_INFINITY to "(1.0/0.0)",
+                FloatValue.NaN to "(0.0f/0.0f)",
+                FloatValue.NEGATIVE_INFINITY to "(-1.0f/0.0f)",
+                FloatValue.POSITIVE_INFINITY to "(1.0f/0.0f)",
+            )
+
+        /** Default configuration. */
+        val DEFAULT = ValueStringConfiguration()
+
+        /** Debug configuration. */
+        val DEBUG: ValueStringConfiguration =
+            ValueStringConfiguration(
+                // Use [appendToStringTo] for nested values.
+                nestedValueAppender = { value, builder, _ -> value.appendToStringTo(builder) },
+            )
+    }
+}
+
+enum class AnnotationAttributeNameValueSeparator(val text: String) {
+    WITH_SPACES(text = " = "),
+    WITHOUT_SPACES(text = "="),
+}
+
+/** Enumeration of how a [ClassObjectValue] should be formatted. */
+enum class ClassObjectValueFormat {
+    /** Use Java style, i.e. <type>.class. */
+    JAVA,
+
+    /**
+     * Use the same representation as the source, i.e. if the source was unqualified Kotlin style
+     * class literal then use that. If the source representation is not available then behave as
+     * [JAVA].
+     */
+    SOURCE,
+}
+
+/** Possible ways to format an [IntValue]. */
+enum class IntFormat {
+    /** Format as a decimal number. */
+    DECIMAL,
+
+    /** Format as a hexadecimal number with a leader 0x. */
+    HEXADECIMAL,
+}
+
+/** Enumeration of how an array containing a single element should be formatted. */
+enum class SingleArrayElementFormat {
+    /** Always wrap the element inside an array. */
+    WRAP,
+
+    /** Do not wrap the element inside an array. */
+    UNWRAP,
+
+    /**
+     * Use the same representation as the source, i.e. if the source was unwrapped then leave it
+     * unwrapped, otherwise wrap it.
+     */
+    @Deprecated(
+        message = "Relying on the source representation leads to inconsistencies",
+        replaceWith = ReplaceWith("WRAP"),
+    )
+    SOURCE,
+}
+
+/** Enumeration of the language the value should be formatted for. */
+enum class ValueLanguage(
+    /** Prefix to add before an annotation class name. */
+    val annotationClassPrefix: String,
+
+    /**
+     * `true` if the annotation requires parentheses even if the attributes are empty, `false`
+     * otherwise.
+     */
+    val annotationAttributesListRequiresParentheses: Boolean,
+) {
+    /** Values should be represented as they would in Java. */
+    JAVA(
+        /** Java style annotations, e.g. @MarkerAnnotation. */
+        annotationClassPrefix = "@",
+        annotationAttributesListRequiresParentheses = false,
+    ),
+
+    /** Values should be represented as they would in Kotlin. */
+    KOTLIN(
+        /** Kotlin style annotations, e.g. MarkerAnnotation(). */
+        annotationClassPrefix = "",
+        annotationAttributesListRequiresParentheses = true,
+    ),
+}
+
+/** Enumeration of the different types of [ValueKind]. */
+enum class ValueKind(
+    val valueKClass: KClass<out Value>,
+    val primitiveKind: Primitive? = null,
+) {
+    ANNOTATION(
+        valueKClass = AnnotationValue::class,
+    ),
+    ARRAY(
+        valueKClass = ArrayValue::class,
+    ),
+    BOOLEAN(
+        valueKClass = BooleanValue::class,
+        primitiveKind = Primitive.BOOLEAN,
+    ),
+    BYTE(
+        valueKClass = ByteValue::class,
+        primitiveKind = Primitive.BYTE,
+    ),
+    CHAR(
+        valueKClass = CharValue::class,
+        primitiveKind = Primitive.CHAR,
+    ),
+    CLASS(
+        valueKClass = ClassObjectValue::class,
+    ),
+    DOUBLE(
+        valueKClass = DoubleValue::class,
+        primitiveKind = Primitive.DOUBLE,
+    ),
+    FIELD(
+        valueKClass = FieldReferenceValue::class,
+    ),
+    FLOAT(
+        valueKClass = FloatValue::class,
+        primitiveKind = Primitive.FLOAT,
+    ),
+    INT(
+        valueKClass = IntValue::class,
+        primitiveKind = Primitive.INT,
+    ),
+    LONG(
+        valueKClass = LongValue::class,
+        primitiveKind = Primitive.LONG,
+    ),
+    SHORT(
+        valueKClass = ShortValue::class,
+        primitiveKind = Primitive.SHORT,
+    ),
+    STRING(
+        valueKClass = StringValue::class,
+    ),
+    ;
+
+    override fun toString() = super.toString().lowercase()
+
+    companion object {
+        /** The set of [ValueKind]s that represent primitive values. */
+        private val PRIMITIVE_KINDS: Set<ValueKind> =
+            EnumSet.noneOf(ValueKind::class.java).apply {
+                addAll(entries.filter { it.primitiveKind != null })
+            }
+
+        /** The set of [ValueKind]s that represent literal values. */
+        val LITERAL_KINDS: Set<ValueKind> = EnumSet.of(STRING).apply { addAll(PRIMITIVE_KINDS) }
+    }
+}
+
+/** A [Value] that is allowed to be used in [ArrayValue.elements]. */
+sealed interface ArrayElementValue : Value {
+    override fun asFlatList() = listOf(this)
+
+    /** Override to specialize the return type. */
+    override fun snapshot(targetCodebase: Codebase): ArrayElementValue = this
+
+    /** Override to specialize the return type. */
+    override fun transform(transformer: (ArrayElementValue) -> ArrayElementValue?) =
+        transformer(this)
+}
+
+/** A [Value] that can be used in a constant field as defined by JLS 15.28. */
+sealed interface ConstantValue : ArrayElementValue {
+    /**
+     * Convert this [ConstantValue] to be of the [optionalTypeItem].
+     *
+     * @param optionalTypeItem if `null` then no conversion is possible or if this [ConstantValue]
+     *   is already of the correct type then no conversion is necessary. In either case this just
+     *   returns itself. Otherwise, it will use [Value.createLiteralValue] to perform the
+     *   conversion.
+     * @param forceNonLiteralInSource if `true` then the returned value will, if possible, be marked
+     *   as non-literal which can affect the legacy formatting. If `false` then the returned value
+     *   will preserve the non-literal status of this.
+     */
+    fun convertToType(
+        optionalTypeItem: TypeItem?,
+        forceNonLiteralInSource: Boolean = false,
+    ): ConstantValue
+}
+
+/**
+ * A [Value] that encapsulates an [underlyingValue] that can be either a primitive or a String.
+ *
+ * There is one sub-interface of this for each possible [LiteralValue]. The reason for doing that
+ * rather than having a single [LiteralValue] containing an [Any] is it will provide type safety.
+ */
+sealed interface LiteralValue<T : Any> : ConstantValue {
+    /**
+     * The underlying value.
+     *
+     * Will be a primitive type's object wrapper (e.g. [java.lang.Integer]) or a [String].
+     */
+    val underlyingValue: T
+
+    /** This is a [LiteralValue]. */
+    override fun asLiteralValue() = this
+
+    /**
+     * Default implementation just appends the underlying value's standard [String.toString] value.
+     */
+    override fun appendValueStringTo(
+        builder: StringBuilder,
+        configuration: ValueStringConfiguration
+    ) {
+        builder.append(underlyingValue)
+    }
+}
+
+/** A [LiteralValue] that is of a primitive type. */
+sealed interface PrimitiveValue<T : Any> : LiteralValue<T>
+
+/** A [Value] that encapsulates a [Boolean]. */
+sealed interface BooleanValue : PrimitiveValue<Boolean> {
+    override val kind: ValueKind
+        get() = ValueKind.BOOLEAN
+
+    override fun equalToValue(other: Value) =
+        other is BooleanValue && underlyingValue == other.underlyingValue
+
+    override fun hashCodeForValue() = underlyingValue.hashCode()
+
+    companion object {
+        val FALSE: BooleanValue = DefaultBooleanValue(false)
+        val TRUE: BooleanValue = DefaultBooleanValue(true)
+    }
+}
+
+/** A [Value] that encapsulates an integral value, i.e. a [Byte], [Int], [Long] or [Short]. */
+sealed interface IntegralValue<T : Number> : PrimitiveValue<T>
+
+/** A [Value] that encapsulates a [Byte]. */
+sealed interface ByteValue : IntegralValue<Byte> {
+    override val kind: ValueKind
+        get() = ValueKind.BYTE
+
+    override fun equalToValue(other: Value) =
+        other is ByteValue && underlyingValue == other.underlyingValue
+
+    override fun hashCodeForValue() = underlyingValue.hashCode()
+}
+
+/** A [Value] that encapsulates a [Char]. */
+sealed interface CharValue : PrimitiveValue<Char> {
+    override val kind: ValueKind
+        get() = ValueKind.CHAR
+
+    override fun equalToValue(other: Value) =
+        other is CharValue && underlyingValue == other.underlyingValue
+
+    override fun hashCodeForValue() = underlyingValue.hashCode()
+
+    override fun appendValueStringTo(
+        builder: StringBuilder,
+        configuration: ValueStringConfiguration
+    ) {
+        builder.append('\'').append(javaEscapeString(underlyingValue.toString())).append('\'')
+    }
+}
+
+/** A [Value] that encapsulates a floating point value, i.e. a [Double] or [Float]. */
+sealed interface FloatingPointValue<T : Number> : PrimitiveValue<T>
+
+/** A [Value] that encapsulates a [Double]. */
+sealed interface DoubleValue : FloatingPointValue<Double> {
+    override val kind: ValueKind
+        get() = ValueKind.DOUBLE
+
+    override fun equalToValue(other: Value) =
+        other is DoubleValue &&
+            (underlyingValue == other.underlyingValue ||
+                (underlyingValue.isNaN() && other.underlyingValue.isNaN()))
+
+    override fun hashCodeForValue() = underlyingValue.hashCode()
+
+    companion object {
+        // These are all non-literals as there is no source literal for these. They all either
+        // require using a division-by-zero expression or a field that itself uses division-by-zero.
+        val NaN: DoubleValue = DefaultDoubleValue(Double.NaN, nonLiteralInSource = true)
+        val NEGATIVE_INFINITY: DoubleValue =
+            DefaultDoubleValue(Double.NEGATIVE_INFINITY, nonLiteralInSource = true)
+        val POSITIVE_INFINITY: DoubleValue =
+            DefaultDoubleValue(Double.POSITIVE_INFINITY, nonLiteralInSource = true)
+    }
+}
+
+/** A [Value] that encapsulates a [Float]. */
+sealed interface FloatValue : FloatingPointValue<Float> {
+    override val kind: ValueKind
+        get() = ValueKind.FLOAT
+
+    override fun equalToValue(other: Value) =
+        other is FloatValue &&
+            (underlyingValue == other.underlyingValue ||
+                (underlyingValue.isNaN() && other.underlyingValue.isNaN()))
+
+    override fun hashCodeForValue() = underlyingValue.hashCode()
+
+    companion object {
+        // These are all non-literals as there is no source literal for these. They all either
+        // require using a division-by-zero expression or a field that itself uses division-by-zero.
+        val NaN: FloatValue = DefaultFloatValue(Float.NaN, nonLiteralInSource = true)
+        val NEGATIVE_INFINITY: FloatValue =
+            DefaultFloatValue(Float.NEGATIVE_INFINITY, nonLiteralInSource = true)
+        val POSITIVE_INFINITY: FloatValue =
+            DefaultFloatValue(Float.POSITIVE_INFINITY, nonLiteralInSource = true)
+    }
+}
+
+/** A [Value] that encapsulates a [Int]. */
+sealed interface IntValue : IntegralValue<Int> {
+    override val kind: ValueKind
+        get() = ValueKind.INT
+
+    override fun equalToValue(other: Value) =
+        other is IntValue && underlyingValue == other.underlyingValue
+
+    override fun hashCodeForValue() = underlyingValue.hashCode()
+
+    companion object {
+        val MIN_VALUE: IntValue =
+            DefaultIntValue(
+                Int.MIN_VALUE,
+                // This is non-literal as it is a negative number and literals have no sign.
+                nonLiteralInSource = true,
+            )
+        val MAX_VALUE: IntValue = DefaultIntValue(Int.MAX_VALUE)
+    }
+}
+
+/** A [Value] that encapsulates a [Long]. */
+sealed interface LongValue : IntegralValue<Long> {
+    override val kind: ValueKind
+        get() = ValueKind.LONG
+
+    override fun equalToValue(other: Value) =
+        other is LongValue && underlyingValue == other.underlyingValue
+
+    override fun hashCodeForValue() = underlyingValue.hashCode()
+}
+
+/** A [Value] that encapsulates a [Short]. */
+sealed interface ShortValue : IntegralValue<Short> {
+    override val kind: ValueKind
+        get() = ValueKind.SHORT
+
+    override fun equalToValue(other: Value) =
+        other is ShortValue && underlyingValue == other.underlyingValue
+
+    override fun hashCodeForValue() = underlyingValue.hashCode()
+}
+
+/** A [Value] that encapsulates a [String]. */
+sealed interface StringValue : LiteralValue<String> {
+    override val kind: ValueKind
+        get() = ValueKind.STRING
+
+    override fun equalToValue(other: Value) =
+        other is StringValue && underlyingValue == other.underlyingValue
+
+    override fun hashCodeForValue() = underlyingValue.hashCode()
+
+    override fun appendValueStringTo(
+        builder: StringBuilder,
+        configuration: ValueStringConfiguration
+    ) {
+        builder.append('"').append(javaEscapeString(underlyingValue)).append('"')
+    }
+}
+
+/**
+ * A [Value] that references a field in [qualifiedClassName] with name [fieldName].
+ *
+ * It has an optional [constantValue].
+ */
+sealed interface FieldReferenceValue : ArrayElementValue {
+    override val kind: ValueKind
+        get() = ValueKind.FIELD
+
+    /** The qualified name of the class that contains the field. */
+    val qualifiedClassName: String
+
+    /** The name of the field. */
+    val fieldName: String
+
+    /** Resolve this to a [FieldItem], if possible. */
+    fun resolve(): FieldItem?
+
+    override fun equalToValue(other: Value) =
+        other is FieldReferenceValue &&
+            qualifiedClassName == other.qualifiedClassName &&
+            fieldName == other.fieldName
+
+    override fun hashCodeForValue() = Objects.hash(qualifiedClassName, fieldName)
+
+    override fun appendValueStringTo(
+        builder: StringBuilder,
+        configuration: ValueStringConfiguration
+    ) {
+        if (qualifiedClassName != "") {
+            builder.append(qualifiedClassName).append('.')
+        }
+        builder.append(fieldName)
+    }
+}
+
+/** A [Value] wrapper around an [annotationItem]. */
+sealed interface AnnotationValue : ArrayElementValue {
+    override val kind: ValueKind
+        get() = ValueKind.ANNOTATION
+
+    /**
+     * An annotation, used as a value in other annotations, including the default value of an
+     * annotation's attribute method.
+     */
+    val annotationItem: AnnotationItem
+
+    /**
+     * Get this [AnnotationItem]'s [AnnotationItem.attributes] as a map from
+     * [AnnotationAttribute.name] to [AnnotationAttribute.value].
+     *
+     * Used to implement [equalToValue] and [hashCodeForValue] to
+     */
+    private fun AnnotationItem.attributesMap() = attributes.associateBy({ it.name }) { it.value }
+
+    override fun equalToValue(other: Value) =
+        other is AnnotationValue &&
+            annotationItem.attributesMap() == other.annotationItem.attributesMap()
+
+    override fun hashCodeForValue() =
+        annotationItem.qualifiedName.hashCode() * 31 + annotationItem.attributesMap().hashCode()
+
+    override fun appendValueStringTo(
+        builder: StringBuilder,
+        configuration: ValueStringConfiguration
+    ) =
+        annotationItem.appendAnnotationStringTo(
+            builder,
+            configuration,
+            annotationIsValue = true,
+        )
+}
+
+/** A [Value] reference to a [Class] object. */
+sealed interface ClassObjectValue : ArrayElementValue {
+    override val kind: ValueKind
+        get() = ValueKind.CLASS
+
+    /**
+     * The type whose [Class] object this encapsulates.
+     *
+     * Must be one of:
+     * * A [PrimitiveTypeItem].
+     * * A [ClassTypeItem] with no [ClassTypeItem.arguments].
+     * * An [ArrayTypeItem] of one of these (including [ArrayTypeItem]).
+     */
+    val typeItem: TypeItem
+
+    override fun equalToValue(other: Value) =
+        other is ClassObjectValue && typeItem == other.typeItem
+
+    override fun hashCodeForValue() = typeItem.hashCode()
+
+    override fun appendValueStringTo(
+        builder: StringBuilder,
+        configuration: ValueStringConfiguration
+    ) {
+        builder.append(typeItem).append(".class")
+    }
+}
+
+/** A [Value] that is an array whose contents are [elements]. */
+sealed interface ArrayValue : Value {
+    override val kind: ValueKind
+        get() = ValueKind.ARRAY
+
+    /** The array elements. */
+    val elements: List<ArrayElementValue>
+
+    override fun asFlatList() = elements
+
+    override fun equalToValue(other: Value) = other is ArrayValue && elements == other.elements
+
+    override fun hashCodeForValue() = elements.hashCode()
+
+    override fun appendValueStringTo(
+        builder: StringBuilder,
+        configuration: ValueStringConfiguration
+    ) {
+        if (
+            elements.size == 1 &&
+                configuration.singleArrayElementFormat == SingleArrayElementFormat.UNWRAP
+        ) {
+            configuration.appendNestedValueTo(builder, elements[0])
+        } else {
+            builder.append('{')
+            for ((index, element) in elements.withIndex()) {
+                if (index > 0) {
+                    builder.append(", ")
+                }
+                configuration.appendNestedValueTo(builder, element)
+            }
+            builder.append('}')
+        }
+    }
+
+    /**
+     * Transform this [ArrayValue].
+     *
+     * Applies [transformer] to each of the [ArrayElementValue]s in [elements] to create a new list
+     * and then wraps it in a new [ArrayValue]. If [transformer] returns `null` for an element then
+     * it is not added to the resulting list.
+     */
+    override fun transform(transformer: (ArrayElementValue) -> ArrayElementValue?): ArrayValue? {
+        if (elements.isEmpty()) return this
+        val transformedElements = elements.mapNotNull { transformer(it) }
+        return Value.createArrayValue(transformedElements)
+    }
+}
+
+/** Base implementation of [Value]. */
+internal sealed class DefaultValue : Value {
+    final override fun equals(other: Any?): Boolean {
+        if (other !is Value) return false
+        return equalToValue(other)
+    }
+
+    final override fun hashCode(): Int = hashCodeForValue()
+
+    final override fun toValueString(configuration: ValueStringConfiguration) = buildString {
+        appendValueStringTo(this, configuration)
+    }
+
+    @Suppress("DEPRECATION")
+    @Deprecated("Do not call directly", replaceWith = ReplaceWith("toString()"))
+    final override fun debugStringForValue() = buildString { appendDebugStringTo(this) }
+
+    @Suppress("DEPRECATION")
+    final override fun appendToStringTo(builder: StringBuilder) {
+        builder.append(kind.valueKClass.java.simpleName)
+        builder.append("(")
+        builder.append(debugStringForValue())
+        builder.append(")")
+    }
+
+    final override fun toString() = buildString { appendToStringTo(this) }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/value/ValueFactory.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/value/ValueFactory.kt
new file mode 100644
index 000000000..909948f0e
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/value/ValueFactory.kt
@@ -0,0 +1,640 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.value
+
+import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.ArrayTypeItem
+import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ClassResolver
+import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.PrimitiveTypeItem
+import com.android.tools.metalava.model.PrimitiveTypeItem.Primitive
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.TypeVisitor
+import com.android.tools.metalava.model.VariableTypeItem
+import com.android.tools.metalava.model.WildcardTypeItem
+import com.android.tools.metalava.model.javaEscapeString
+import com.android.tools.metalava.model.value.ValueFactory.Companion.primitiveValueFactories
+
+/**
+ * Provides support for creating instances of [Value]s.
+ *
+ * This is implemented on [Value.Companion] to make it easy to create instances using something like
+ * [Value.createLiteralValue] and is intended to be implemented by a model specific class that maps
+ * from model specific classes to [Value]s.
+ */
+interface ValueFactory {
+    /**
+     * Create a [LiteralValue] if possible, otherwise throw an exception.
+     *
+     * If [optionalTypeItem] is provided then this checks to make sure that it and [underlyingValue]
+     * are consistent, converting the latter to match the former if possible without losing
+     * information . e.g.
+     * * If [optionalTypeItem] is an integer type then [underlyingValue] is expected to be an
+     *   integer type, and it will be converted to the appropriate type. If [optionalTypeItem] is
+     *   [Primitive.BYTE] and [underlyingValue] is an integer with value 30 then the conversion will
+     *   succeed. If it has a value of 300 it will not succeed.
+     * * Similarly, if [optionalTypeItem] is a floating point type then [underlyingValue] is
+     *   expected to be an integer or floating point type.
+     *
+     * The resulting [LiteralValue.underlyingValue] has the following types for [Primitive]:
+     * * [Primitive.BOOLEAN] -> [java.lang.Boolean]
+     * * [Primitive.BYTE] -> [java.lang.Byte]
+     * * [Primitive.CHAR] -> [java.lang.Character]
+     * * [Primitive.DOUBLE] -> [java.lang.Double]
+     * * [Primitive.FLOAT] -> [java.lang.Float]
+     * * [Primitive.INT] -> [java.lang.Integer]
+     * * [Primitive.LONG] -> [java.lang.Long]
+     * * [Primitive.SHORT] -> [java.lang.Short]
+     * * [ClassTypeItem] of [java.lang.String] -> [java.lang.String]
+     *
+     * If [optionalTypeItem] is not provided then the [underlyingValue] type will be used to
+     * determine which [LiteralValue] is returned.
+     *
+     * The [underlyingValue] (after possibly undergoing type conversion to another `java.lang`
+     * object) is mapped to a subclass of [LiteralValue] as follows:
+     * * [java.lang.Boolean] -> [BooleanValue]
+     * * [java.lang.Byte] -> [ByteValue]
+     * * [java.lang.Character] -> [CharValue]
+     * * [java.lang.Double] -> [DoubleValue]
+     * * [java.lang.Float] -> [FloatValue]
+     * * [java.lang.Integer] -> [IntValue]
+     * * [java.lang.Long] -> [LongValue]
+     * * [java.lang.Short] -> [ShortValue]
+     * * [java.lang.String] -> [StringValue]
+     *
+     * @param optionalTypeItem the optional [TypeItem] for the context in which the value is used,
+     *   e.g. [MethodItem.returnType] for [MethodItem.defaultValue]. It should be available unless
+     *   the source is incomplete, e.g. missing annotation class definitions.
+     * @param nonLiteralInSource indicates whether the value was represented as a literal in the
+     *   source, or a more complex expression. This can affect legacy formatting.
+     */
+    fun createLiteralValue(
+        optionalTypeItem: TypeItem?,
+        underlyingValue: Any,
+        nonLiteralInSource: Boolean = false,
+    ): LiteralValue<*> {
+        val literalValue =
+            when (optionalTypeItem) {
+                is PrimitiveTypeItem -> {
+                    // Normalized the primitive value to ensure that they are consistent with the
+                    // type.
+                    val primitiveKind = optionalTypeItem.kind
+                    val primitiveValue = normalizePrimitive(underlyingValue, primitiveKind)
+
+                    createPrimitiveValueForKind(
+                        primitiveKind,
+                        primitiveValue,
+                        underlyingValue,
+                        nonLiteralInSource,
+                    )
+                }
+                is ClassTypeItem -> {
+                    // The only allowable class type is a String.
+                    if (optionalTypeItem.isPossiblyUnresolvedString() && underlyingValue is String)
+                        DefaultStringValue(underlyingValue)
+                    else null
+                }
+                null -> {
+                    // No type was provided so just wrap the underlyingValue in the appropriate
+                    // LiteralValue wrapper.
+                    if (underlyingValue is String) {
+                        DefaultStringValue(underlyingValue)
+                    } else {
+                        Primitive.entries
+                            .find {
+                                it.wrapperClass.isInstance(underlyingValue) && it != Primitive.VOID
+                            }
+                            ?.let { primitiveKind ->
+                                createPrimitiveValueForKind(
+                                    primitiveKind,
+                                    underlyingValue,
+                                    underlyingValue,
+                                    nonLiteralInSource,
+                                )
+                            }
+                            ?: error(
+                                "Underlying value '$underlyingValue' of ${underlyingValue.javaClass} is not supported"
+                            )
+                    }
+                }
+                else -> null
+            }
+
+        literalValue
+            ?: throw ValueProviderException(
+                "Incompatible type '$optionalTypeItem', for underlying value `$underlyingValue` of ${underlyingValue.javaClass}"
+            )
+        return literalValue
+    }
+
+    /**
+     * Create an [ArrayValue] containing [elements].
+     *
+     * Every call that supplies an empty [elements] will return the same instance of [ArrayValue].
+     * It is the caller's responsibility to ensure that every [ArrayElementValue] in [elements] has
+     * the same [Value.kind] (excluding [ValueKind.FIELD]). This will throw an exception if it does
+     * not.
+     */
+    fun createArrayValue(
+        elements: List<ArrayElementValue>,
+        wasUnwrappedInSource: Boolean = false
+    ): ArrayValue {
+        if (elements.isEmpty()) return EMPTY_ARRAY
+        if (wasUnwrappedInSource && elements.size != 1)
+            error("wasUnwrappedInSource was set to true but array does not contain 1 element")
+        val groupedByKind = elements.groupBy { it.kind }
+        val kindCount = groupedByKind.size
+        // Only allow 1 kind or 2 if one of them is field.
+        if (kindCount == 1 || (kindCount == 2 && ValueKind.FIELD in groupedByKind))
+            return DefaultArrayValue(elements, wasUnwrappedInSource)
+        val message = buildString {
+            append("Expected array elements to be all of the same kind but found ")
+            append(kindCount)
+            append(" different kinds of value:")
+            for (entry in groupedByKind) {
+                append("\n    ")
+                append(entry.key)
+                append(" -> ")
+                entry.value.joinTo(this)
+            }
+        }
+        error(message)
+    }
+
+    /**
+     * Create a [ClassObjectValue] encapsulating [typeItem].
+     *
+     * [typeItem] must be one of the following:
+     * * A [PrimitiveTypeItem].
+     * * A [ClassTypeItem] with no [ClassTypeItem.arguments].
+     * * An [ArrayTypeItem] of one of these (including [ArrayTypeItem]).
+     */
+    fun createClassObjectValue(typeItem: TypeItem, sourceExpression: String?): ClassObjectValue {
+        typeItem.accept(classObjectValueTypeChecker)
+        return DefaultClassObjectValue(typeItem, sourceExpression)
+    }
+
+    /**
+     * Create a [FieldReferenceValue] called [fieldName] in [qualifiedClassName].
+     *
+     * If the field has a constant initializer then it will be retrieved when calling
+     * [FieldReferenceValue.asLiteralValue].
+     *
+     * @param classResolver used to resolve [qualifiedClassName] to a [ClassItem] in
+     *   [FieldReferenceValue.resolve]
+     * @param qualifiedClassName the qualified name of the class containing the field. Is an empty
+     *   string if the field is unqualified.
+     * @param fieldName the name of the field.
+     * @param optionalTypeItem the optional [TypeItem] determined by the context within which the
+     *   [FieldReferenceValue] will be used.
+     * @param kotlinCompanionClass the name of the companion class if the field is inside a Kotlin
+     *   `Companion` object, `null` if it is not. In either case [qualifiedClassName] is the name of
+     *   the main class, NOT the companion class.
+     */
+    fun createFieldReferenceValueWithDeferredConstantValue(
+        classResolver: ClassResolver,
+        qualifiedClassName: String,
+        fieldName: String,
+        optionalTypeItem: TypeItem?,
+        kotlinCompanionClass: String? = null,
+        explicitConversionTo: Primitive? = null,
+    ): ArrayElementValue {
+        // Create a field.
+        val fieldReferenceValue =
+            LazyFieldReferenceValue(
+                classResolver,
+                qualifiedClassName,
+                fieldName,
+                optionalTypeItem,
+                kotlinCompanionClass,
+                explicitConversionTo,
+            )
+
+        // The field may need mapping to a constant value to eliminate differences between Kotlin
+        // and Java.
+        return normalizeFieldReferenceValue(fieldReferenceValue)
+    }
+
+    /**
+     * Create a [FieldReferenceValue] called [fieldName] in [qualifiedClassName] with an optional
+     * [constantValue].
+     */
+    fun createFieldReferenceValue(
+        classResolver: ClassResolver,
+        qualifiedClassName: String,
+        fieldName: String,
+        constantValue: ConstantValue? = null,
+        kotlinCompanionClass: String? = null,
+        explicitConversionTo: Primitive? = null,
+    ): ArrayElementValue {
+        // Create a field.
+        val fieldReferenceValue =
+            DefaultFieldReferenceValue(
+                classResolver,
+                qualifiedClassName,
+                fieldName,
+                constantValue,
+                kotlinCompanionClass,
+                explicitConversionTo,
+            )
+
+        // The field may need mapping to a constant value to eliminate differences between Kotlin
+        // and Java.
+        return normalizeFieldReferenceValue(fieldReferenceValue)
+    }
+
+    /** Normalize [FieldReferenceValue]s to eliminate differences between Java and Kotlin. */
+    private fun normalizeFieldReferenceValue(
+        fieldReferenceValue: FieldReferenceValue
+    ): ArrayElementValue {
+        return specialFieldsToReplacementValue[fieldReferenceValue] ?: fieldReferenceValue
+    }
+
+    /** Create an [AnnotationValue] that wraps an [AnnotationItem]. */
+    fun createAnnotationValue(annotationItem: AnnotationItem): AnnotationValue =
+        DefaultAnnotationValue(annotationItem)
+
+    /** Check if this [TypeItem] is a constant type, i.e. a [String] or a primitive type. */
+    fun TypeItem.isConstantType() = isPossiblyUnresolvedString() || this is PrimitiveTypeItem
+
+    companion object {
+        /**
+         * Map from [Primitive] to a [PrimitiveValueFactory] to use to create an appropriate
+         * [DefaultLiteralValue] subclass.
+         */
+        val primitiveValueFactories =
+            mapOf<Primitive, PrimitiveValueFactory<*>>(
+                Primitive.BOOLEAN to
+                    { underlyingValue, _, _ ->
+                        DefaultBooleanValue(underlyingValue as Boolean)
+                    },
+                Primitive.BYTE to
+                    { underlyingValue, originalValue, nonLiteralInSource ->
+                        val byteValue = underlyingValue as Byte
+                        val effectivelyNonLiteralInSource =
+                            nonLiteralInSource ||
+                                // Negative numbers are treated as if they were created from a unary
+                                // minus expression. That is true even when they are read from a jar
+                                // where they are stored as a negative number.
+                                byteValue < 0
+
+                        DefaultByteValue(
+                            byteValue,
+                            originalValue,
+                            effectivelyNonLiteralInSource,
+                        )
+                    },
+                Primitive.CHAR to
+                    { underlyingValue, _, _ ->
+                        DefaultCharValue(underlyingValue as Char)
+                    },
+                Primitive.DOUBLE to
+                    { underlyingValue, originalValue, nonLiteralInSource ->
+                        val doubleValue = underlyingValue as Double
+                        val effectivelyNonLiteralInSource =
+                            nonLiteralInSource ||
+                                // Negative numbers are treated as if they were created from a unary
+                                // minus expression. That is true even when they are read from a jar
+                                // where they are stored as a negative number.
+                                doubleValue < 0 ||
+                                // Similarly, NaN, +Infinity, -Infinity are treated as if they were
+                                // an expression as there is no literal for them. That is true even
+                                // when they are read from a jar where they are stored as a special
+                                // set of bits.
+                                doubleValue.isNaN() ||
+                                doubleValue.isInfinite()
+
+                        DefaultDoubleValue(
+                            doubleValue,
+                            originalValue,
+                            effectivelyNonLiteralInSource,
+                        )
+                    },
+                Primitive.FLOAT to
+                    { underlyingValue, originalValue, nonLiteralInSource ->
+                        val floatValue = underlyingValue as Float
+                        val effectivelyNonLiteralInSource =
+                            nonLiteralInSource ||
+                                // Negative numbers are treated as if they were created from a unary
+                                // minus expression. That is true even when they are read from a jar
+                                // where they are stored as a negative number.
+                                floatValue < 0 ||
+                                // Similarly, NaN, +Infinity, -Infinity are treated as if they were
+                                // an expression as there is no literal for them. That is true even
+                                // when they are read from a jar where they are stored as a special
+                                // set of bits.
+                                floatValue.isNaN() ||
+                                floatValue.isInfinite()
+
+                        DefaultFloatValue(
+                            floatValue,
+                            originalValue,
+                            effectivelyNonLiteralInSource,
+                        )
+                    },
+                Primitive.INT to
+                    { underlyingValue, originalValue, nonLiteralInSource ->
+                        val intValue = underlyingValue as Int
+                        val effectivelyNonLiteralInSource =
+                            nonLiteralInSource ||
+                                // Negative numbers are treated as if they were created from a unary
+                                // minus expression. That is true even when they are read from a jar
+                                // where they are stored as a negative number.
+                                intValue < 0
+                        DefaultIntValue(
+                            intValue,
+                            originalValue,
+                            effectivelyNonLiteralInSource,
+                        )
+                    },
+                Primitive.LONG to
+                    { underlyingValue, originalValue, nonLiteralInSource ->
+                        val longValue = underlyingValue as Long
+                        val effectivelyNonLiteralInSource =
+                            nonLiteralInSource ||
+                                // Negative numbers are treated as if they were created from a unary
+                                // minus expression. That is true even when they are read from a jar
+                                // where they are stored as a negative number.
+                                longValue < 0
+
+                        DefaultLongValue(
+                            longValue,
+                            originalValue,
+                            effectivelyNonLiteralInSource,
+                        )
+                    },
+                Primitive.SHORT to
+                    { underlyingValue, originalValue, nonLiteralInSource ->
+                        val shortValue = underlyingValue as Short
+                        val effectivelyNonLiteralInSource =
+                            nonLiteralInSource ||
+                                // Negative numbers are treated as if they were created from a unary
+                                // minus expression. That is true even when they are read from a jar
+                                // where they are stored as a negative number.
+                                shortValue < 0
+
+                        DefaultShortValue(
+                            shortValue,
+                            originalValue,
+                            effectivelyNonLiteralInSource,
+                        )
+                    },
+            )
+
+        /**
+         * Create a simple [FieldReferenceValue] for [fieldName] in class [qualifiedName]
+         *
+         * Note: This does not work for fields in nested classes.
+         */
+        private fun fieldReference(qualifiedName: String, fieldName: String) =
+            DefaultFieldReferenceValue(ClassResolver.THROWING, qualifiedName, fieldName)
+
+        /**
+         * Adds mappings for special fields [field] of [type] to [value].
+         *
+         * This adds a mapping for each of the Java and Kotlin special fields called [field] of
+         * [type] to [value].
+         */
+        private fun MutableMap<FieldReferenceValue, ConstantValue>.addFieldMappings(
+            type: String,
+            field: String,
+            value: ConstantValue
+        ) {
+            put(fieldReference("java.lang.$type", field), value)
+            put(fieldReference("kotlin.jvm.internal.${type}CompanionObject", field), value)
+        }
+
+        /**
+         * Map from [FieldReferenceValue] to a [ConstantValue] for some special fields which differ
+         * between Java and Kotlin.
+         */
+        private val specialFieldsToReplacementValue = buildMap {
+            addFieldMappings("Double", "NaN", DoubleValue.NaN)
+            addFieldMappings("Double", "NEGATIVE_INFINITY", DoubleValue.NEGATIVE_INFINITY)
+            addFieldMappings("Double", "POSITIVE_INFINITY", DoubleValue.POSITIVE_INFINITY)
+
+            addFieldMappings("Float", "NaN", FloatValue.NaN)
+            addFieldMappings("Float", "NEGATIVE_INFINITY", FloatValue.NEGATIVE_INFINITY)
+            addFieldMappings("Float", "POSITIVE_INFINITY", FloatValue.POSITIVE_INFINITY)
+        }
+
+        /**
+         * Create a [PrimitiveValue] for [primitiveKind] and [primitiveValue].
+         *
+         * The caller has already made sure that the [primitiveValue] is appropriate for
+         * [primitiveKind].
+         *
+         * The [originalValue] is the original value that was retrieved from the expression before
+         * any casting was performed to ensure it matches the [primitiveKind]. e.g. if the original
+         * source expression was an `int` literal, e.g. `10` and [primitiveKind] is [Primitive.LONG]
+         * then the [primitiveValue] will be a `java.lang.Long` instance with a value of `10L` but
+         * the [originalValue] will be a `java.lang.Integer` instance with a value of `10`.
+         *
+         * It supports the [ValueStringConfiguration.useOriginalValueForNumbers] behavior.
+         */
+        private fun createPrimitiveValueForKind(
+            primitiveKind: Primitive,
+            primitiveValue: Any,
+            originalValue: Any,
+            nonLiteralInSource: Boolean,
+        ) =
+            primitiveValueFactories[primitiveKind]?.let { factory ->
+                factory(primitiveValue, originalValue, nonLiteralInSource)
+            } ?: error("Cannot create PrimitiveValue: unknown primitive kind: $primitiveKind")
+
+        /** Normalize the [underlyingValue] to make it consistent with [primitiveKind]. */
+        private fun normalizePrimitive(underlyingValue: Any, primitiveKind: Primitive): Any {
+            val primitiveValue =
+                when (underlyingValue) {
+                    is Boolean -> {
+                        if (primitiveKind == Primitive.BOOLEAN) underlyingValue else null
+                    }
+                    is Char -> {
+                        val convertedValue: Any? =
+                            when (primitiveKind) {
+                                Primitive.BYTE ->
+                                    convertInteger(underlyingValue.code) { it.toByte() }
+                                Primitive.CHAR -> underlyingValue
+                                Primitive.INT -> convertInteger(underlyingValue.code) { it.toInt() }
+                                Primitive.LONG -> convertInteger(underlyingValue.code) { it }
+                                Primitive.SHORT ->
+                                    convertInteger(underlyingValue.code) { it.toShort() }
+                                else -> null
+                            }
+                        if (convertedValue != null) {
+                            checkLossyConversion(underlyingValue, primitiveKind, convertedValue)
+                        }
+                        convertedValue
+                    }
+                    is String -> {
+                        // A single character string can be used as a char.
+                        if (primitiveKind == Primitive.CHAR && underlyingValue.length == 1)
+                            underlyingValue[0]
+                        else null
+                    }
+                    is Number -> {
+                        val convertedValue: Any? =
+                            when (primitiveKind) {
+                                Primitive.BYTE -> convertInteger(underlyingValue) { it.toByte() }
+                                Primitive.CHAR ->
+                                    if (underlyingValue.isIntegerNumber())
+                                        underlyingValue.toInt().toChar()
+                                    else null
+                                Primitive.DOUBLE -> convertFloating(underlyingValue) { it }
+                                Primitive.FLOAT -> convertFloating(underlyingValue) { it.toFloat() }
+                                Primitive.INT -> convertInteger(underlyingValue) { it.toInt() }
+                                Primitive.LONG -> convertInteger(underlyingValue) { it }
+                                Primitive.SHORT -> convertInteger(underlyingValue) { it.toShort() }
+                                else -> null
+                            }
+
+                        if (convertedValue != null) {
+                            checkLossyConversion(underlyingValue, primitiveKind, convertedValue)
+                        }
+                        convertedValue
+                    }
+                    else -> null
+                }
+
+            primitiveValue
+                ?: error(
+                    "Unsupported primitive type: ${primitiveKind.primitiveName}, for underlying value `$underlyingValue` of ${underlyingValue.javaClass}"
+                )
+            return primitiveValue
+        }
+
+        /** True if this [Number] is an integer (in the general sense). */
+        private fun Number.isIntegerNumber() =
+            this is Byte || this is Int || this is Long || this is Short
+
+        /** True if this [Number] is a floating point number. */
+        private fun Number.isFloatingNumber() = this is Float || this is Double
+
+        /**
+         * Check to see [converted] which was the result of converting from [original] to
+         * [targetKind] can be converted back to [original] without loss. If it cannot then throw an
+         * exception.
+         */
+        private fun checkLossyConversion(original: Any, targetKind: Primitive, converted: Any) {
+            val convertedNumber =
+                when (converted) {
+                    is Number -> converted
+                    is Char -> converted.code
+                    else -> error("unknown converted $converted of ${converted.javaClass}")
+                }
+
+            val roundTrip =
+                when (original) {
+                    is Byte -> convertedNumber.toByte()
+                    is Char -> convertedNumber.toInt().toChar()
+                    is Double -> convertedNumber.toDouble()
+                    is Float -> convertedNumber.toFloat()
+                    is Int -> convertedNumber.toInt()
+                    is Long -> convertedNumber.toLong()
+                    is Short -> convertedNumber.toShort()
+                    else -> error("unknown original $original of ${original.javaClass}")
+                }
+
+            if (roundTrip != original) {
+                error(
+                    "Conversion of ${javaEscapeString(original.toString())} to ${targetKind.primitiveName} is lossy and produces $converted; round trip value is ${javaEscapeString(roundTrip.toString())}"
+                )
+            }
+        }
+
+        /**
+         * Convert an integer [Number] to another integer [Number] by first converting it to [Long]
+         * and then using [convert] to convert to another integer [Number].
+         */
+        private inline fun convertInteger(number: Number, convert: (Long) -> Number): Number? {
+            if (!number.isIntegerNumber()) {
+                return null
+            }
+
+            // Convert it to a long value as that is not lossy.
+            val longValue = number.toLong()
+
+            // Convert it to the correct type for the primitive kind.
+            return convert(longValue)
+        }
+
+        /**
+         * Convert a floating point or integer [Number] to another floating point [Number] by first
+         * converting it to [Double] and then using [convert] to convert to another floating point
+         * [Number].
+         */
+        private inline fun convertFloating(number: Number, convert: (Double) -> Number): Number? {
+            if (!number.isFloatingNumber() && !number.isIntegerNumber()) {
+                return null
+            }
+
+            // Convert it to a double value as that is not lossy.
+            val doubleValue = number.toDouble()
+
+            // Convert it to the correct type for the primitive kind.
+            return convert(doubleValue)
+        }
+
+        /** An empty [ArrayValue]. */
+        private val EMPTY_ARRAY = DefaultArrayValue(emptyList(), wasUnwrappedInSource = false)
+
+        /** Checks the [TypeItem] supplied to [createClassObjectValue]. */
+        val classObjectValueTypeChecker =
+            object : TypeVisitor {
+                private fun invalidType(typeItem: TypeItem): Nothing {
+                    error("'$typeItem' is an invalid type for a class object value")
+                }
+
+                override fun visit(arrayType: ArrayTypeItem) {
+                    arrayType.componentType.accept(this)
+                }
+
+                override fun visit(classType: ClassTypeItem) {
+                    if (classType.arguments.isNotEmpty()) {
+                        error(
+                            "'$classType' is an invalid type for a class object value as it has type arguments"
+                        )
+                    }
+                }
+
+                override fun visit(variableType: VariableTypeItem) {
+                    invalidType(variableType)
+                }
+
+                override fun visit(wildcardType: WildcardTypeItem) {
+                    invalidType(wildcardType)
+                }
+            }
+    }
+}
+
+/** Type of values in [primitiveValueFactories]. */
+internal typealias PrimitiveValueFactory<T> =
+    (underlyingValue: Any, originalValue: Any, nonLiteralInSource: Boolean) -> PrimitiveValue<T>
+
+/**
+ * Check to see whether this [TypeItem] is `java.lang.String`.
+ *
+ * As the definition of `java.lang.String` may not have been provided to Metalava also check for
+ * `String` as that is most likely to be an unresolved reference to `java.lang.String`. If it was a
+ * custom class then presumably that would be defined somewhere in which case it would have been
+ * resolved to the class and so would not be an unqualified name.
+ */
+internal fun TypeItem.isPossiblyUnresolvedString() =
+    isString() || (this is ClassTypeItem && qualifiedName == "String")
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/value/ValueParser.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/value/ValueParser.kt
new file mode 100644
index 000000000..c37d946ee
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/value/ValueParser.kt
@@ -0,0 +1,653 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.value
+
+import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
+import com.android.tools.metalava.model.AnnotationAttribute
+import com.android.tools.metalava.model.AnnotationContext
+import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.ArrayTypeItem
+import com.android.tools.metalava.model.ClassResolver
+import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.PrimitiveTypeItem
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.TypeParameterScope
+import com.android.tools.metalava.model.javaUnescapeString
+import com.android.tools.metalava.model.parser.ParseException
+import com.android.tools.metalava.model.parser.TokenPurpose
+import com.android.tools.metalava.model.parser.Tokenizer
+import com.android.tools.metalava.model.type.ContextNullability
+import com.android.tools.metalava.model.type.TypeItemParser
+import com.android.tools.metalava.reporter.FileLocation
+import java.nio.file.Path
+
+/**
+ * Parser for the string representation of [Value]s that is used in a signature file or an
+ * annotation created from a string.
+ */
+class ValueParser(
+    private val annotationContext: AnnotationContext,
+    private val typeItemParser: TypeItemParser,
+) : ValueFactory, ImplementationValueToModelFactory<String> {
+
+    /**
+     * Get a [CombinedValueProvider] that will create (and cache) a [Value] of [typeItem] from
+     * [text].
+     *
+     * @param typeItem the required type for the value, e.g. [MethodItem.returnType] or
+     *   [FieldItem.type].
+     * @param text the String value to be parsed.
+     * @param valueUseSite the [ValueUseSite] for which this will provide a [Value].
+     */
+    fun providerFor(
+        typeItem: TypeItem,
+        text: String,
+        valueUseSite: ValueUseSite,
+    ): CombinedValueProvider = CachingValueProvider(this, typeItem, text, valueUseSite)
+
+    /**
+     * Get a [CombinedValueProvider] that will create (and cache) a [Value] for attribute
+     * [attributeName] of [annotationClassName] from [text].
+     *
+     * @param annotationClassName the containing [AnnotationItem]'s qualified class name.
+     * @param attributeName the name of the attribute whose value it will provide.
+     * @param text the String value to be parsed.
+     */
+    private fun providerForAnnotationValue(
+        annotationClassName: String,
+        attributeName: String,
+        text: String
+    ) =
+        CachingAnnotationValueProvider(this, attributeName, text) {
+            annotationContext.resolveClass(annotationClassName)
+        }
+
+    override fun implementationValueToModelValue(
+        optionalTypeItem: TypeItem?,
+        implementationValue: String,
+        valueUseSite: ValueUseSite
+    ) =
+        when (valueUseSite) {
+            ValueUseSite.ANNOTATION -> {
+                // For annotations convert to any Value.
+                parse(optionalTypeItem, implementationValue)
+            }
+            ValueUseSite.FIELD -> {
+                // For fields convert to ConstantValues if possible, otherwise throw an exception.
+                parseConstant(optionalTypeItem, implementationValue)
+                    ?: unknownToken(optionalTypeItem, implementationValue)
+            }
+        }
+
+    /** Parse the [text] to provide a [Value] of the [optionalTypeItem]. */
+    fun parse(optionalTypeItem: TypeItem?, text: String): Value? =
+        when {
+            text.isEmpty() -> null
+            text[0] == '{' -> {
+                // The text looks like it is an array literal that could contain multiple values so
+                // it will require splitting into separate parts, so create a Tokenizer to do that.
+                val tokenizer = tokenizerOf(text)
+                parseWithTokenizer(optionalTypeItem, tokenizer)
+            }
+            optionalTypeItem is ArrayTypeItem -> {
+                // The type is an array so this is an example of not having to add curly braces
+                // around a single value in an annotation attribute. Create a value for the
+                // component type and then wrap it in an ArrayValue.
+                val singleValue = parseArrayElementValue(optionalTypeItem.componentType, text)
+                createArrayValue(listOf(singleValue), wasUnwrappedInSource = true)
+            }
+            else -> {
+                parseArrayElementValue(optionalTypeItem, text)
+            }
+        }
+
+    /** Create a [Tokenizer] of [text]. */
+    private fun tokenizerOf(text: String) = Tokenizer(Path.of("unknown"), text.toCharArray())
+
+    /** Parse a [Value] of the [optionalTypeItem] from [tokenizer]. */
+    private fun parseWithTokenizer(optionalTypeItem: TypeItem?, tokenizer: Tokenizer) =
+        when (val token = tokenizer.requireToken()) {
+            "{" -> {
+                val componentType = (optionalTypeItem as? ArrayTypeItem)?.componentType
+                val elements = buildList {
+                    while (true) {
+                        // The next token could be the end of the array or a value.
+                        val valueToken = tokenizer.requireToken(purpose = TokenPurpose.VALUE)
+
+                        // If it is the end of the array (because the array is empty) then break
+                        // out.
+                        if (valueToken == "}") break
+
+                        // Parse the token as a value and add it to the list.
+                        val element = parseArrayElementValue(componentType, valueToken)
+                        add(element)
+
+                        // The next token should be either a `,` or a `}`.
+                        when (val separator = tokenizer.requireToken()) {
+                            "," -> continue
+                            "}" -> break
+                            else ->
+                                throw ParseException("Expected ',' or '}' but found '$separator'")
+                        }
+                    }
+                }
+                createArrayValue(elements)
+            }
+            else -> {
+                throw ParseException("Expected '{' but found '$token'")
+            }
+        }
+
+    /** Parse the [text] to provide an [ArrayElementValue] of the [optionalTypeItem]. */
+    private fun parseArrayElementValue(
+        optionalTypeItem: TypeItem?,
+        text: String
+    ): ArrayElementValue {
+        // Try and parse the constants first as they will be more prevalent and the following code
+        // is more expensive.
+        parseConstant(optionalTypeItem, text)?.let {
+            return it
+        }
+
+        // If the text matches the pattern then extract the `<type>`, parse using `typeItemParser`
+        // and wrap in a `ClassObjectValue`.
+        classLiteralPattern.matchEntire(text)?.let { matchResult ->
+            // Get the type string. The pattern requires it so it is safe to assume it is available.
+            val typeString = matchResult.groups[TYPE_GROUP_INDEX]!!.value
+            val classLiteralTypeItem =
+                typeItemParser.obtainTypeFromString(typeString, TypeParameterScope.empty)
+            return createClassObjectValue(classLiteralTypeItem, text)
+        }
+
+        // Check to see if it looks like a field reference.
+        fieldReferencePattern.matchEntire(text)?.let { matchResult ->
+
+            // Get the class and field. The class name is optional but the field name is required so
+            // it is safe to assume it is available.
+            val className = matchResult.groups[CLASS_NAME_GROUP_INDEX]?.value ?: ""
+            val fieldName = matchResult.groups[FIELD_NAME_GROUP_INDEX]!!.value
+
+            // If there was an explicit conversion function call on the field reference then make
+            // sure to track that.
+            val explicitConversionTo =
+                matchResult.groups[OPTIONAL_CONVERSION_FUNCTION_NAME_GROUP_INDEX]?.value?.let {
+                    conversionFunctionName ->
+                    PrimitiveTypeItem.Primitive.forKotlinNumericConversionFunctionName(
+                        conversionFunctionName
+                    )
+                }
+
+            // Parse the class name to a type.
+            val classTypeItem =
+                typeItemParser.obtainTypeFromString(
+                    className,
+                    TypeParameterScope.empty,
+                    ContextNullability.forceNonNull,
+                ) as ClassTypeItem
+
+            val qualifiedClassName = classTypeItem.qualifiedName
+            return createFieldReferenceValueWithDeferredConstantValue(
+                annotationContext,
+                qualifiedClassName,
+                fieldName,
+                optionalTypeItem,
+                explicitConversionTo = explicitConversionTo,
+            )
+        }
+
+        // Handle a Java style annotation value which starts with an '@'.
+        val first = text.first()
+        if (first == '@') {
+            parseAnnotationValue(text)?.let {
+                return it
+            } ?: unknownToken(optionalTypeItem, text)
+        }
+
+        // Check to see if it is a Kotlin annotation value, which looks like a constructor call for
+        // the annotation class.
+        annotationConstructorPattern.matchAt(text, 0)?.let {
+            parseAnnotationValue(text)?.let {
+                return it
+            } ?: unknownToken(optionalTypeItem, text)
+        }
+
+        unknownToken(optionalTypeItem, text)
+    }
+
+    /** Parse the [text] to provide a [ConstantValue] of the [optionalTypeItem]. */
+    private fun parseConstant(optionalTypeItem: TypeItem?, text: String): ConstantValue? {
+
+        knownSpecialValues[text]?.let { value ->
+            return value.convertToType(optionalTypeItem)
+        }
+
+        val first = text.first()
+        when {
+            first == '"' -> {
+                val last = text.last()
+                if (last != '"') error("string '$text' starts with \" but does not end with \"")
+                val string = javaUnescapeString(text.substring(1, text.length - 1))
+                return createLiteralValue(optionalTypeItem, string)
+            }
+            first == '\'' -> {
+                val last = text.last()
+                if (last != '\'') error("character \"$text\" starts with ' but does not end with '")
+                val string = javaUnescapeString(text.substring(1, text.length - 1))
+                if (string.length != 1)
+                    error(
+                        "character \"$text\" should contain a single character but contains ${string.length}"
+                    )
+                val char = string[0]
+                return createLiteralValue(optionalTypeItem, char)
+            }
+            first == '+' || first == '-' || first.isDigit() ->
+                return parseNumber(optionalTypeItem, text)
+        }
+
+        return null
+    }
+
+    /** Throw an exception when [text] cannot be parsed. */
+    private fun unknownToken(optionalTypeItem: TypeItem?, text: String): Nothing =
+        throw ValueProviderException("Unknown token <$text> of $optionalTypeItem")
+
+    /**
+     * Parse a number from [text].
+     *
+     * @param optionalTypeItem the optional [TypeItem], if present then the parsed value will be
+     *   converted to be appropriate for this [TypeItem].
+     * @param text the text to parse.
+     */
+    private fun parseNumber(
+        optionalTypeItem: TypeItem?,
+        text: String,
+    ): ConstantValue {
+        // Handle hexadecimal numbers first as they could end with a 'f' which would be treated as
+        // a float below.
+        if (text.startsWith("0x")) {
+            // Check for a binary exponent as that means it is a hex floating point number.
+            if (text.any { it == 'p' || it == 'P' }) {
+                // Floating point hex value.
+                val last = text.last()
+                val number =
+                    if (last == 'f') {
+                        text.substring(0, text.length - 1).toFloat()
+                    } else {
+                        text.toDouble()
+                    }
+                return createLiteralValue(
+                    optionalTypeItem,
+                    number,
+                    // Hexadecimal floating point numbers can only be present in the signature file
+                    // if they were present in the source.
+                    nonLiteralInSource = false,
+                )
+            }
+
+            // Remove the leading "0x"
+            val withoutLeading0x = text.substring(2)
+
+            // Parse as long as a number like 0xFFFFFFFF is parsed as a positive number and will
+            // fail because the largest positive int is 0x80000000. So, parse as long and then cast
+            // down to an int. That is done explicitly here rather than rely on the casting done by
+            // createLiteralValue(...) as it will fail because this cast will be lossy for numbers
+            // larger than the largest positive int. They will become negative numbers. However,
+            // that is what the original number was so it is ok.
+            val int = withoutLeading0x.toLong(16).toInt()
+            return createLiteralValue(
+                optionalTypeItem,
+                int,
+                // AnnotationItem.toSource() will use format ints obtained from literals as decimals
+                // and ints obtained from complex expressions as decimals so treat hexadecimals as
+                // if they are not literals. That should allow signature files to be read and then
+                // written out again without changing the formatting.
+                nonLiteralInSource = true
+            )
+        }
+
+        // Check the last character to see if it indicated the type of the number.
+        when (val suffix = text.last()) {
+            'L',
+            'l' -> {
+                val long = text.substring(0, text.length - 1).toLong()
+                return createLiteralValue(optionalTypeItem, long)
+            }
+            'F',
+            'f' -> {
+                val float = text.substring(0, text.length - 1).toFloat()
+                // AnnotationItem.toSource() uses 'F' as the suffix for floats obtained from
+                // expressions and 'f' for those obtained from literals.
+                val nonLiteralInSource = suffix == 'F'
+                return createLiteralValue(optionalTypeItem, float, nonLiteralInSource)
+            }
+        }
+
+        // Try parsing as a long first. This will cover bytes, ints, longs, and shorts.
+        text.toLongOrNull()?.let { long ->
+            // Cast down to an int if allowed as an integer number without a trailing L or l is
+            // treated as an integer in source.
+            if (long in Int.MIN_VALUE..Int.MAX_VALUE) {
+                return createLiteralValue(optionalTypeItem, long.toInt())
+            } else {
+                // Otherwise, rely on createLiteralValue(...) to do appropriate non-lossy casting to
+                // match the optional type item.
+                return createLiteralValue(optionalTypeItem, long)
+            }
+        }
+
+        // Try parsing as a double. This will cover floats too.
+        text.toDoubleOrNull()?.let { double ->
+            if (
+                optionalTypeItem is PrimitiveTypeItem &&
+                    optionalTypeItem.kind == PrimitiveTypeItem.Primitive.FLOAT
+            ) {
+                return createLiteralValue(optionalTypeItem, double.toFloat())
+            } else {
+                return createLiteralValue(optionalTypeItem, double)
+            }
+        }
+
+        throw ValueProviderException("Unsupported numeric value <$text> of $optionalTypeItem")
+    }
+
+    /** Parse [text] to produce an [AnnotationValue], if possible. */
+    private fun parseAnnotationValue(text: String): AnnotationValue? {
+        val annotationItem = parseAnnotationItem(text) ?: return null
+        return createAnnotationValue(annotationItem)
+    }
+
+    /** Parse [text] to produce an [AnnotationItem], if possible. */
+    fun parseAnnotationItem(text: String): AnnotationItem? {
+        val tokenizer = tokenizerOf(text)
+
+        // Parse the annotation item from the tokenizer.
+        val annotationItem = parseAnnotationItem(tokenizer)
+
+        // Make sure that all the significant text was consumed.
+        tokenizer.getToken()?.let { token ->
+            error(
+                "Expected to consume all the contents of `$text` but did not, next token is '$token', remainder is '${tokenizer.remainder()}'"
+            )
+        }
+
+        return annotationItem
+    }
+
+    /**
+     * Parse stream of tokens produced by [tokenizer] to create an [AnnotationItem], if possible.
+     *
+     * On entry [tokenizer] next token must be the annotation's class name, optionally prefixed with
+     * an `@`. On exit, the next token will be the one after the annotation.
+     */
+    private fun parseAnnotationItem(tokenizer: Tokenizer): AnnotationItem? {
+        // May start with an '@', the remainder is the annotation class name.
+        val annotationClassName =
+            tokenizer.requireToken().let { token ->
+                if (token[0] == '@') token.substring(1) else token
+            }
+
+        val token = tokenizer.getToken()
+        val attributes =
+            when (token) {
+                "(" -> {
+                    parseAnnotationAttributes(annotationClassName, tokenizer).also {
+                        require(tokenizer.current == ")") {
+                            "Expected ')' but found ${tokenizer.current}"
+                        }
+                    }
+                }
+                else -> emptyList()
+            }
+
+        return AnnotationItem.createWithAttributes(
+            annotationContext,
+            FileLocation.UNKNOWN,
+            annotationClassName,
+            attributes
+        )
+    }
+
+    /**
+     * Parse stream of tokens produced by [tokenizer] to create a list of [AnnotationAttribute]s for
+     * [annotationClassName].
+     *
+     * On entry [tokenizer]'s [Tokenizer.current] must be `(`. On exit, it will be the matching `)`.
+     */
+    private fun parseAnnotationAttributes(
+        annotationClassName: String,
+        tokenizer: Tokenizer
+    ): List<AnnotationAttribute> {
+        require(tokenizer.current == "(") { "Expected '(' but found ${tokenizer.current}" }
+
+        // At this point there are a number of possibilities:
+        // * ")", i.e. close parenthesis for an empty list of annotation attributes.
+        // * <any value> (which is equivalent to 'value=<any value>').
+        // * <attribute-name>=<any value>.
+        tokenizer.requireToken(purpose = TokenPurpose.VALUE).let { token ->
+            // A minor optimization to avoid creating a new mutable list only for it to be empty.
+            if (token == ")") return emptyList()
+        }
+
+        return buildList {
+            do {
+                // At this point there are three possibilities for the token:
+                // * `)` - closing of the attribute list after a trailing `,`.
+                // * <any value> (which is equivalent to 'value=<any value>').
+                // * <attribute-name>=<any value>.
+                val token = tokenizer.current
+                if (token == ")") return@buildList
+
+                // Differentiate between them by checking the next token. If it is = then it is
+                // the second option, otherwise it is the first. After this the tokenizer.current
+                // must be the next token after the value.
+                val nextToken = tokenizer.requireToken()
+                val (attributeName, valueText) =
+                    if (nextToken == "=") {
+                        // Get the next token as a value.
+                        val valueToken = tokenizer.requireToken(purpose = TokenPurpose.VALUE)
+                        // Get the next token ready in the tokenizer.
+                        tokenizer.requireToken()
+                        // Pair up the attribute name and value text.
+                        token to valueToken
+                    } else {
+                        // Pair up the default attribute name and the value text.
+                        ANNOTATION_ATTR_VALUE to token
+                    }
+
+                // Patch the value if necessary.
+                val patchedValue =
+                    if (tokenizer.current == "-") {
+                        // TODO(b/354633349): Temporary workaround that is needed because some
+                        //  historical files from `prebuilts/sdk` have expressions like
+                        //  `0x400000000 - 1`. Those files have been fixed downstream but the
+                        //  `prebuilts/sdk` repository is not modifiable in aosp/metalava-main.
+                        val expectingOne =
+                            tokenizer.requireToken(purpose = TokenPurpose.VALUE) == "1"
+                        require(expectingOne) {
+                            """Expected "... - 1" but found "... - $expectingOne""""
+                        }
+
+                        // Get the next token ready in the tokenizer.
+                        tokenizer.requireToken()
+
+                        (Integer.decode(valueText) - 1).toString()
+                    } else valueText
+
+                // At this point there are two possibilities:
+                // * ",", i.e. the separator between this and the next attribute.
+                // * "," followed by ")", i.e. an unnecessary comma following by the closing
+                //   parenthesis of the attribute list.
+                // * ")", i.e. close parenthesis for the list of annotation attributes.
+                when (val separator = tokenizer.current) {
+                    "," -> {
+                        // Get the next token which should be a value ready in the tokenizer but
+                        // could also be a close parenthesis.
+                        tokenizer.requireToken(purpose = TokenPurpose.VALUE)
+                    }
+                    ")" -> {
+                        // Nothing to do, will break out next time around the loop but this case
+                        // allows the else clause to throw an error.
+                    }
+                    else ->
+                        throw ValueProviderException(
+                            "Unknown token <$separator>, expected one of `,` or `)`"
+                        )
+                }
+
+                // Get Value provider.
+                val valueProvider =
+                    providerForAnnotationValue(
+                        annotationClassName,
+                        attributeName,
+                        patchedValue,
+                    )
+
+                // Add the attribute to the list.
+                add(
+                    AnnotationAttribute.createLazyAttribute(
+                        attributeName,
+                        valueProvider,
+                    )
+                )
+            } while (true)
+        }
+    }
+
+    companion object {
+        /** The default instance of this. */
+        val DEFAULT =
+            ValueParser(
+                // Any attempts to resolve an annotation's class in order to determine the type of
+                // its attributes will return null which will prevent any conversion of values to
+                // the correct type but still allow annotations to be parsed correctly.
+                AnnotationContext.DEFAULT_RESOLVE_NULL,
+                TypeItemParser.forValueParser(ClassResolver.THROWING),
+            )
+
+        /**
+         * Map of all the different string representations of various special floating point
+         * numbers.
+         */
+        private val specialFloats =
+            mapOf(
+                DoubleValue.NaN to
+                    listOf(
+                        "(0.0/0.0)",
+                        "0.0 / 0.0",
+                        "Double.NaN",
+                        "java.lang.Double.NaN",
+                        "kotlin.jvm.internal.DoubleCompanionObject.NaN",
+                    ),
+                DoubleValue.NEGATIVE_INFINITY to
+                    listOf(
+                        "(-1.0/0.0)",
+                        "-1.0 / 0.0",
+                        "Double.NEGATIVE_INFINITY",
+                        "java.lang.Double.NEGATIVE_INFINITY",
+                        "kotlin.jvm.internal.DoubleCompanionObject.NEGATIVE_INFINITY",
+                    ),
+                DoubleValue.POSITIVE_INFINITY to
+                    listOf(
+                        "(1.0/0.0)",
+                        "1.0 / 0.0",
+                        "Double.POSITIVE_INFINITY",
+                        "java.lang.Double.POSITIVE_INFINITY",
+                        "kotlin.jvm.internal.DoubleCompanionObject.POSITIVE_INFINITY",
+                    ),
+                FloatValue.NaN to
+                    listOf(
+                        "(0.0f/0.0f)",
+                        "0.0f / 0.0",
+                        "Float.NaN",
+                        "java.lang.Float.NaN",
+                        "kotlin.jvm.internal.FloatCompanionObject.NaN",
+                    ),
+                FloatValue.NEGATIVE_INFINITY to
+                    listOf(
+                        "(-1.0f/0.0f)",
+                        "-1.0f / 0.0",
+                        "-1.0F / 0.0",
+                        "Float.NEGATIVE_INFINITY",
+                        "java.lang.Float.NEGATIVE_INFINITY",
+                        "kotlin.jvm.internal.FloatCompanionObject.NEGATIVE_INFINITY",
+                    ),
+                FloatValue.POSITIVE_INFINITY to
+                    listOf(
+                        "(1.0f/0.0f)",
+                        "1.0f / 0.0",
+                        "Float.POSITIVE_INFINITY",
+                        "java.lang.Float.POSITIVE_INFINITY",
+                        "kotlin.jvm.internal.FloatCompanionObject.POSITIVE_INFINITY",
+                    ),
+            )
+
+        /** A map of all the known special values. */
+        private val knownSpecialValues =
+            mapOf(
+                "false" to BooleanValue.FALSE,
+                "true" to BooleanValue.TRUE,
+            ) + specialFloats.flatMap { (value, alternatives) -> alternatives.map { it to value } }
+
+        /**
+         * Pattern to match a class literal of the following forms:
+         * * <type>.class - Java form.
+         * * <type>::class - Kotlin form used in annotations.
+         * * <type>::class.java - Kotlin form used in fields. It matches this for legacy reasons but
+         *   fields should not be class literals as they are not constants.
+         *
+         * Where `<type>` can be a primitive, class type or array type.
+         *
+         * The pattern matches a possibly qualified identifier, followed by type information like a
+         * type argument list (e.g. in `java.util.List<*>`, or `Array<String>`) or array dimensions
+         * (e.g. `int[]`) following by either `::class`, `::class.java` or `.class`.
+         */
+        internal val classLiteralPattern =
+            Regex("""(([a-zA-Z0-9_]+(?:\.[a-zA-Z0-9_]+)*)[^:.]*)(::class(\.java)?|\.class)""")
+
+        /** Index of type group in [classLiteralPattern]. */
+        private const val TYPE_GROUP_INDEX = 1
+
+        /**
+         * Pattern to match a field, including a class literal of the form `<class>.class` and an
+         * unqualified field of the form `FIELD`.
+         *
+         * This also matches an optional call to a numeric conversion function, e.g. `Int.toLong()`.
+         */
+        internal val fieldReferencePattern =
+            Regex(
+                """(?:([a-zA-Z0-9_]+(?:\.[a-zA-Z0-9_]+)*)\.)?([a-zA-Z0-9_]+)(?:\.(to(?:Byte|Double|Float|Int|Long|Short))\(\))?"""
+            )
+
+        /** Index of class name group in [fieldReferencePattern]. */
+        private const val CLASS_NAME_GROUP_INDEX = 1
+
+        /** Index of field name group in [fieldReferencePattern]. */
+        private const val FIELD_NAME_GROUP_INDEX = 2
+
+        /** Index of optional conversion function name group in [fieldReferencePattern]. */
+        private const val OPTIONAL_CONVERSION_FUNCTION_NAME_GROUP_INDEX = 3
+
+        /**
+         * Pattern to match a Kotlin style annotation value which looks like a constructor call for
+         * the annotation's class.
+         */
+        internal val annotationConstructorPattern =
+            Regex("""([a-zA-Z0-9_]+(?:\.[a-zA-Z0-9_]+)*)\(""")
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/value/ValueProvider.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/value/ValueProvider.kt
new file mode 100644
index 000000000..2113a4ed3
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/value/ValueProvider.kt
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.value
+
+import com.android.tools.metalava.model.Codebase
+import java.util.Optional
+import kotlin.jvm.optionals.getOrNull
+
+/**
+ * Allows the creation of [Value] to be deferred until they are requested.
+ *
+ * This is needed for a number of reasons:
+ * * The [Value] model and support for it in the various model implementations is a work in progress
+ *   and as such it will not support all values for a while. That may mean it throws an exception or
+ *   returns `null` or an invalid [Value]. Inlining that work during the normal [Codebase]
+ *   construction would break everything. Deferring the creation ensures that any issues only arise
+ *   when they are requested, i.e. testing during development.
+ * * The `Psi` model is quite slow and creating [Value]s can be costly as it has to check to
+ *   evaluate expressions to see if they are constant. That is not true for `Turbine` as it
+ *   evaluates any constant expressions up front.
+ * * The `Text` model requires creating a [Value] from a string and while that may not be
+ *   particularly expensive it is still wasted time if the [Value] is not needed.
+ */
+interface ValueProvider {
+    /** Get the value, creating it if necessary. */
+    val value: Value
+}
+
+/** Return a provider for this [Value]. */
+fun Value.provider(): ValueProvider = FixedValueProvider(this)
+
+/** A [ValueProvider] that simply returns [value]. */
+private class FixedValueProvider(override val value: Value) : ValueProvider
+
+/** Like [ValueProvider] but allows a `null` [Value] to be returned. */
+interface OptionalValueProvider {
+    val optionalValue: Value?
+}
+
+/**
+ * A special [RuntimeException] that indicates a problem with a [ValueProvider].
+ *
+ * These exceptions will be ignored by [Value] tests during development of the [Value] model to
+ * avoid having to keep updating the baseline files which become a source of conflicts when changed
+ * frequently.
+ *
+ * TODO(b/354633349): Stop ignoring exceptions.
+ */
+class ValueProviderException(message: String) : RuntimeException(message)
+
+/** A combination of both [ValueProvider] and [OptionalValueProvider]. */
+interface CombinedValueProvider : ValueProvider, OptionalValueProvider
+
+/**
+ * A [CombinedValueProvider] that provides support to subclasses for caching a [Value] that has been
+ * provided.
+ *
+ * @param valueUseSite the [ValueUseSite] for which this will provide a [Value].
+ */
+abstract class BaseCachingValueProvider(protected val valueUseSite: ValueUseSite) :
+    CombinedValueProvider {
+    /** The cached value. */
+    private lateinit var _value: Optional<Value>
+
+    /** Get the cached value, calling [provideValue] if it has not yet been cached. */
+    private fun cachedValue(): Optional<Value> {
+        if (!::_value.isInitialized) {
+            val providedValue = provideValue()
+            val valueToCache =
+                when (valueUseSite) {
+                    ValueUseSite.ANNOTATION ->
+                        providedValue
+                            ?: error(
+                                "Provider returned `null` but nulls are not allowed on annotation values"
+                            )
+                    ValueUseSite.FIELD -> providedValue?.asLiteralValue()
+                }
+
+            _value = Optional.ofNullable(valueToCache)
+        }
+        return _value
+    }
+
+    final override val value: Value
+        get() = cachedValue().getOrNull() ?: error("No value provided")
+
+    final override val optionalValue: Value?
+        get() = cachedValue().getOrNull()
+
+    /** Provide an optional [Value] to be cached. */
+    protected abstract fun provideValue(): Value?
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/value/ValueUseSite.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/value/ValueUseSite.kt
new file mode 100644
index 000000000..b3684b90e
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/value/ValueUseSite.kt
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.value
+
+import com.android.tools.metalava.model.AnnotationAttribute
+import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.MethodItem
+
+/**
+ * Enumeration of the different sites where [Value]s can be used and which have unique restrictions.
+ */
+enum class ValueUseSite {
+    /**
+     * Represents either [AnnotationAttribute.value] or [MethodItem.defaultValue] as they both allow
+     * all [Value]s.
+     */
+    ANNOTATION,
+    /** Represents [FieldItem.constantValue] as it only allows [ConstantValue]s. */
+    FIELD,
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/ApiVisitor.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/ApiVisitor.kt
index 91e52b8c0..1f80cbab5 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/ApiVisitor.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/ApiVisitor.kt
@@ -20,10 +20,15 @@ import com.android.tools.metalava.model.BaseItemVisitor
 import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.FilterPredicate
 import com.android.tools.metalava.model.ItemVisitor
 import com.android.tools.metalava.model.MemberItem
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.PropertyItem
+import com.android.tools.metalava.model.SelectableItem
+import com.android.tools.metalava.model.TargetLanguage
+import com.android.tools.metalava.model.TargetLanguageSet
+import java.util.function.Predicate
 
 open class ApiVisitor(
     /** @see BaseItemVisitor.preserveClassNesting */
@@ -48,6 +53,12 @@ open class ApiVisitor(
      * annotated API relative to the base API.
      */
     protected val showUnannotated: Boolean = true,
+
+    /**
+     * The target languages to consider. If an item's target languages do not include any of these
+     * languages, it will be skipped.
+     */
+    targetLanguages: Set<TargetLanguage> = TargetLanguageSet.ALL,
 ) : BaseItemVisitor(preserveClassNesting, visitParameterItems) {
 
     constructor(
@@ -56,16 +67,20 @@ open class ApiVisitor(
 
         /** Configuration that may come from the command line. */
         apiPredicateConfig: ApiPredicate.Config,
+
+        /** The target languages to consider. */
+        targetLanguages: Set<TargetLanguage> = TargetLanguageSet.ALL,
     ) : this(
         visitParameterItems = visitParameterItems,
         apiFilters = defaultFilters(apiPredicateConfig),
+        targetLanguages = targetLanguages,
     )
 
     /** The filter to use to determine if we should emit an item */
-    protected val filterEmit = apiFilters.emit
+    protected val filterEmit = addTargetLanguageCheck(apiFilters.emit, targetLanguages)
 
     /** The filter to use to determine if we should emit a reference to an item */
-    protected val filterReference = apiFilters.reference
+    protected val filterReference = addTargetLanguageCheck(apiFilters.reference, targetLanguages)
 
     companion object {
         /** Get the default [ApiFilters] to use with [ApiVisitor]. */
@@ -89,6 +104,19 @@ open class ApiVisitor(
                 includeApisForStubPurposes = true,
                 config = apiPredicateConfig.copy(ignoreShown = true),
             )
+
+        /**
+         * Updates the [filter] to also check that the [SelectableItem] has at least one of the
+         * [targetLanguages].
+         */
+        private fun addTargetLanguageCheck(
+            filter: FilterPredicate,
+            targetLanguages: Set<TargetLanguage>
+        ): FilterPredicate {
+            return Predicate { item: SelectableItem ->
+                filter.test(item) && item.targetLanguages.intersect(targetLanguages).isNotEmpty()
+            }
+        }
     }
 
     /**
diff --git a/metalava-model/src/test/java/com/android/tools/metalava/model/AnnotationItemTest.kt b/metalava-model/src/test/java/com/android/tools/metalava/model/AnnotationItemTest.kt
index d459d6ecf..609e51123 100644
--- a/metalava-model/src/test/java/com/android/tools/metalava/model/AnnotationItemTest.kt
+++ b/metalava-model/src/test/java/com/android/tools/metalava/model/AnnotationItemTest.kt
@@ -16,14 +16,17 @@
 
 package com.android.tools.metalava.model
 
-import org.junit.Assert
+import com.android.tools.metalava.model.testing.value.annotationItem
+import com.android.tools.metalava.model.value.ValueLanguage
+import com.android.tools.metalava.model.value.ValueStringConfiguration
+import kotlin.test.assertEquals
 import org.junit.Test
 
 class AnnotationItemTest {
 
     fun checkShortenAnnotation(expected: String, source: String) {
-        Assert.assertEquals(expected, AnnotationItem.shortenAnnotation(source))
-        Assert.assertEquals(source, AnnotationItem.unshortenAnnotation(expected))
+        assertEquals(expected, AnnotationItem.shortenAnnotation(source))
+        assertEquals(source, AnnotationItem.unshortenAnnotation(expected))
     }
 
     @Test
@@ -39,4 +42,56 @@ class AnnotationItemTest {
         checkShortenAnnotation("@my.Annotation", "@my.Annotation")
         checkShortenAnnotation("@m.Annotation", "@m.Annotation")
     }
+
+    fun checkAppendAnnotationStringTo(
+        expected: String,
+        annotationItem: AnnotationItem,
+        configuration: ValueStringConfiguration,
+        annotationIsValue: Boolean,
+    ) {
+        val actual = buildString {
+            annotationItem.appendAnnotationStringTo(this, configuration, annotationIsValue)
+        }
+        assertEquals(expected, actual)
+    }
+
+    @Test
+    fun `Test non-value annotation for java`() {
+        checkAppendAnnotationStringTo(
+            "@test.pkg.Anno",
+            annotationItem("test.pkg.Anno"),
+            configuration = ValueStringConfiguration(valueLanguage = ValueLanguage.JAVA),
+            annotationIsValue = false,
+        )
+    }
+
+    @Test
+    fun `Test non-value annotation for kotlin`() {
+        checkAppendAnnotationStringTo(
+            "@test.pkg.Anno",
+            annotationItem("test.pkg.Anno"),
+            configuration = ValueStringConfiguration(valueLanguage = ValueLanguage.KOTLIN),
+            annotationIsValue = false,
+        )
+    }
+
+    @Test
+    fun `Test value annotation for java`() {
+        checkAppendAnnotationStringTo(
+            "@test.pkg.Anno",
+            annotationItem("test.pkg.Anno"),
+            configuration = ValueStringConfiguration(valueLanguage = ValueLanguage.JAVA),
+            annotationIsValue = true,
+        )
+    }
+
+    @Test
+    fun `Test value annotation for kotlin`() {
+        checkAppendAnnotationStringTo(
+            "test.pkg.Anno()",
+            annotationItem("test.pkg.Anno"),
+            configuration = ValueStringConfiguration(valueLanguage = ValueLanguage.KOTLIN),
+            annotationIsValue = true,
+        )
+    }
 }
diff --git a/metalava-model/src/test/java/com/android/tools/metalava/model/DefaultAnnotationItemTest.kt b/metalava-model/src/test/java/com/android/tools/metalava/model/DefaultAnnotationItemTest.kt
index 145c9c750..ab0899c25 100644
--- a/metalava-model/src/test/java/com/android/tools/metalava/model/DefaultAnnotationItemTest.kt
+++ b/metalava-model/src/test/java/com/android/tools/metalava/model/DefaultAnnotationItemTest.kt
@@ -16,44 +16,21 @@
 
 package com.android.tools.metalava.model
 
-import com.android.tools.metalava.model.item.CodebaseAssembler
-import com.android.tools.metalava.model.item.DefaultCodebase
-import com.android.tools.metalava.model.item.PackageDoc
-import java.io.File
+import com.android.tools.metalava.model.testing.value.arrayValue
+import com.android.tools.metalava.model.testing.value.fieldReferenceValue
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertTrue
 import org.junit.Test
 
 class DefaultAnnotationItemTest : Assertions {
-    // Placeholder for use in test where we don't need codebase functionality
-    private val placeholderCodebase =
-        DefaultCodebase(
-            location = File("").canonicalFile,
-            description = "",
-            preFiltered = false,
-            config = Codebase.Config.NOOP,
-            trustedApi = false,
-            supportsDocumentation = false,
-            assembler =
-                object : CodebaseAssembler {
-                    override fun createPackageItem(
-                        packageName: String,
-                        packageDoc: PackageDoc,
-                        containingPackage: PackageItem?,
-                    ) = error("unsupported")
-
-                    override fun createClassFromUnderlyingModel(qualifiedName: String) = null
-                },
-        )
 
     private fun createDefaultAnnotationItem(source: String) =
-        DefaultAnnotationItem.create(placeholderCodebase, source)
+        AnnotationItem.createFromSource(AnnotationContext.DEFAULT_RESOLVE_NULL, source)
             ?: error("Could not create annotation from: '$source'")
 
     @Test
     fun testSimple() {
         val annotation = createDefaultAnnotationItem("@androidx.annotation.Nullable")
-        assertEquals("@androidx.annotation.Nullable", annotation.toSource())
         assertEquals("androidx.annotation.Nullable", annotation.qualifiedName)
         assertTrue(annotation.attributes.isEmpty())
     }
@@ -62,13 +39,12 @@ class DefaultAnnotationItemTest : Assertions {
     fun testIntRange() {
         val annotation =
             createDefaultAnnotationItem("@androidx.annotation.IntRange(from = 20, to = 40)")
-        assertEquals("@androidx.annotation.IntRange(from=20, to=40)", annotation.toSource())
         assertEquals("androidx.annotation.IntRange", annotation.qualifiedName)
         assertEquals(2, annotation.attributes.size)
         assertEquals("from", annotation.assertAttribute("from").name)
-        assertEquals("20", annotation.assertAttribute("from").legacyValue.toString())
+        assertEquals("20", annotation.assertAttribute("from").value.toValueString())
         assertEquals("to", annotation.assertAttribute("to").name)
-        assertEquals("40", annotation.assertAttribute("to").legacyValue.toString())
+        assertEquals("40", annotation.assertAttribute("to").value.toValueString())
     }
 
     @Test
@@ -77,24 +53,23 @@ class DefaultAnnotationItemTest : Assertions {
             createDefaultAnnotationItem(
                 "@androidx.annotation.IntDef({STYLE_NORMAL, STYLE_NO_TITLE, STYLE_NO_FRAME, STYLE_NO_INPUT})"
             )
-        assertEquals(
-            "@androidx.annotation.IntDef({STYLE_NORMAL, STYLE_NO_TITLE, STYLE_NO_FRAME, STYLE_NO_INPUT})",
-            annotation.toSource()
-        )
         assertEquals("androidx.annotation.IntDef", annotation.qualifiedName)
         assertEquals(1, annotation.attributes.size)
         val attribute = annotation.assertAttribute("value")
         assertEquals("value", attribute.name)
         assertEquals(
             "{STYLE_NORMAL, STYLE_NO_TITLE, STYLE_NO_FRAME, STYLE_NO_INPUT}",
-            attribute.legacyValue.toString()
+            attribute.value.toValueString()
         )
 
-        assertTrue(attribute.legacyValue is AnnotationArrayAttributeValue)
-        if (attribute is AnnotationArrayAttributeValue) {
-            val list = attribute.values
-            assertEquals(3, list.size)
-            assertEquals("STYLE_NO_TITLE", list[1].toSource())
-        }
+        assertEquals(
+            arrayValue(
+                fieldReferenceValue("", "STYLE_NORMAL"),
+                fieldReferenceValue("", "STYLE_NO_TITLE"),
+                fieldReferenceValue("", "STYLE_NO_FRAME"),
+                fieldReferenceValue("", "STYLE_NO_INPUT"),
+            ),
+            attribute.value
+        )
     }
 }
diff --git a/metalava-model/src/test/java/com/android/tools/metalava/model/parser/TokenizerTest.kt b/metalava-model/src/test/java/com/android/tools/metalava/model/parser/TokenizerTest.kt
new file mode 100644
index 000000000..5a0900826
--- /dev/null
+++ b/metalava-model/src/test/java/com/android/tools/metalava/model/parser/TokenizerTest.kt
@@ -0,0 +1,266 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.parser
+
+import java.nio.file.Path
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertThrows
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
+
+@RunWith(Parameterized::class)
+class TokenizerTest(private val params: Params) {
+
+    data class Params(
+        val input: String,
+        val label: String = input,
+        val purpose: TokenPurpose = TokenPurpose.GENERAL,
+        val expectedTokens: List<String>? = null,
+        val expectedError: String? = null,
+    ) {
+        init {
+            if (expectedTokens == null && expectedError == null) {
+                throw IllegalArgumentException(
+                    "Expected one of `expectedToken` and `expectedError`, found neither"
+                )
+            } else if (expectedTokens != null && expectedError != null) {
+                throw IllegalArgumentException(
+                    "Expected one of `expectedToken` and `expectedError`, found both"
+                )
+            }
+        }
+
+        override fun toString(): String = "$label,purpose=$purpose"
+    }
+
+    companion object {
+        private val params =
+            listOf(
+                Params(
+                    input = """  "string"  """,
+                    expectedTokens = listOf(""""string""""),
+                ),
+                Params(
+                    input = """  "string  """,
+                    expectedError = """api.txt:1: Unexpected end of file for " starting at 1""",
+                ),
+                Params(
+                    input = """  "string\""",
+                    expectedError = """api.txt:1: Unexpected end of file for " starting at 1""",
+                ),
+                // Test handling of empty parentheses.
+                Params(
+                    input = """@pkg.Annotation()""",
+                    purpose = TokenPurpose.VALUE,
+                    expectedTokens = listOf("""@pkg.Annotation()"""),
+                ),
+                Params(
+                    input = """@pkg.Annotation()""",
+                    purpose = TokenPurpose.GENERAL,
+                    expectedTokens = listOf("@pkg.Annotation", "(", ")"),
+                ),
+                // Test handling of empty parentheses with extra space.
+                Params(
+                    input = """@pkg.Annotation( )""",
+                    purpose = TokenPurpose.VALUE,
+                    expectedTokens = listOf("@pkg.Annotation( )"),
+                ),
+                Params(
+                    input = """@pkg.Annotation( )""",
+                    purpose = TokenPurpose.GENERAL,
+                    expectedTokens = listOf("@pkg.Annotation", "(", ")"),
+                ),
+                // Test handling of parentheses with one parameter.
+                Params(
+                    input = """@pkg.Annotation("string")""",
+                    purpose = TokenPurpose.VALUE,
+                    expectedTokens = listOf("""@pkg.Annotation("string")"""),
+                ),
+                Params(
+                    input = """@pkg.Annotation("string")""",
+                    purpose = TokenPurpose.GENERAL,
+                    expectedTokens = listOf("@pkg.Annotation", "(", "\"string\"", ")"),
+                ),
+                // Test handling of parentheses with multiple, space separated parameters.
+                Params(
+                    input = """@pkg.Annotation(stringAttr="string", intAttr=1)""",
+                    purpose = TokenPurpose.VALUE,
+                    expectedTokens = listOf("@pkg.Annotation(stringAttr=\"string\", intAttr=1)"),
+                ),
+                Params(
+                    input = """@pkg.Annotation(stringAttr="string", intAttr=1)""",
+                    purpose = TokenPurpose.GENERAL,
+                    expectedTokens =
+                        listOf(
+                            "@pkg.Annotation",
+                            "(",
+                            "stringAttr",
+                            "=",
+                            "\"string\"",
+                            ",",
+                            "intAttr",
+                            "=",
+                            "1",
+                            ")",
+                        ),
+                ),
+                // Test handling of nested layer of parentheses.
+                Params(
+                    input = """@pkg.Annotation(attr=1, nested=@pkg.Nested("string"))""",
+                    purpose = TokenPurpose.VALUE,
+                    expectedTokens =
+                        listOf("""@pkg.Annotation(attr=1, nested=@pkg.Nested("string"))"""),
+                ),
+                Params(
+                    input = """@pkg.Annotation(attr=1, nested=@pkg.Nested("string"))""",
+                    purpose = TokenPurpose.GENERAL,
+                    expectedTokens =
+                        listOf(
+                            "@pkg.Annotation",
+                            "(",
+                            "attr",
+                            "=",
+                            "1",
+                            ",",
+                            "nested",
+                            "=",
+                            "@pkg.Nested",
+                            "(",
+                            "\"string\"",
+                            ")",
+                            ")",
+                        ),
+                ),
+                // Test handling of unmatched open parentheses.
+                Params(
+                    input = """@pkg.Annotation(""",
+                    purpose = TokenPurpose.VALUE,
+                    expectedError = """api.txt:1: Unexpected end of file for ( starting at 1""",
+                ),
+                Params(
+                    input = """@pkg.Annotation(""",
+                    purpose = TokenPurpose.GENERAL,
+                    expectedTokens = listOf("@pkg.Annotation", "("),
+                ),
+                // Test handling of trailing closed parentheses.
+                Params(
+                    input = """1)""",
+                    purpose = TokenPurpose.VALUE,
+                    expectedTokens = listOf("1", ")"),
+                ),
+                Params(
+                    input = """1)""",
+                    purpose = TokenPurpose.GENERAL,
+                    expectedTokens = listOf("1", ")"),
+                ),
+                // Test handling of unmatched open quotes.
+                Params(
+                    input = """ @pkg.Annotation("string """,
+                    purpose = TokenPurpose.VALUE,
+                    expectedError = """api.txt:1: Unexpected end of file for " starting at 1""",
+                ),
+                Params(
+                    input = """ value=1""",
+                    expectedTokens = listOf("value", "=", "1"),
+                ),
+                Params(
+                    label = "line comment",
+                    input =
+                        """
+                            // Comment before token
+                            name
+                        """,
+                    expectedTokens = listOf("name"),
+                ),
+                Params(
+                    input = """test.pkg.Generic<String>""",
+                    expectedTokens = listOf("test.pkg.Generic<String>"),
+                ),
+                Params(
+                    input = """test.pkg.Generic<String, Integer>""",
+                    expectedTokens = listOf("test.pkg.Generic<String, Integer>"),
+                ),
+                Params(
+                    input = """test.pkg.Generic<String, Integer, test.pkg.Nested<A, B>>""",
+                    expectedTokens =
+                        listOf("test.pkg.Generic<String, Integer, test.pkg.Nested<A, B>>"),
+                ),
+                Params(
+                    input = """<A extends Other, B>""",
+                    expectedTokens = listOf("<", "A", "extends", "Other", ",", "B", ">"),
+                ),
+                Params(
+                    input = """<A extends Other<A>>""",
+                    expectedTokens = listOf("<", "A", "extends", "Other<A>", ">"),
+                ),
+                Params(
+                    input = """Other<String""",
+                    expectedError = "api.txt:1: Unexpected end of file for < starting at 1",
+                ),
+                // Test handling of braces.
+                Params(
+                    input = """{1, 2}""",
+                    purpose = TokenPurpose.GENERAL,
+                    expectedTokens = listOf("{", "1", ",", "2", "}"),
+                ),
+                Params(
+                    input = """{1, 2}""",
+                    purpose = TokenPurpose.VALUE,
+                    // TODO(b/354633349): This is wrong, should be a single token.
+                    expectedTokens = listOf("{1, 2}"),
+                ),
+                // Test handling of unbalanced brace.
+                Params(
+                    input = """{1,""",
+                    purpose = TokenPurpose.GENERAL,
+                    expectedTokens = listOf("{", "1", ","),
+                ),
+                Params(
+                    input = """{1,""",
+                    purpose = TokenPurpose.VALUE,
+                    expectedError = "api.txt:1: Unexpected end of file for { starting at 1",
+                ),
+            )
+
+        @JvmStatic @Parameterized.Parameters(name = "<{0}>") fun testParams(): List<Params> = params
+    }
+
+    @Test
+    fun `check token`() {
+        val tokenizer = Tokenizer(Path.of("api.txt"), params.input.toCharArray())
+
+        fun requireToken(): String {
+            return tokenizer.requireToken(purpose = params.purpose)
+        }
+
+        params.expectedError?.let { expectedError ->
+            val exception = assertThrows(ParseException::class.java) { requireToken() }
+            assertEquals(expectedError, exception.message)
+        }
+
+        params.expectedTokens?.let { expectedTokens ->
+            val tokens = buildList {
+                do {
+                    tokenizer.getToken(purpose = params.purpose)?.let { token -> add(token) }
+                        ?: break
+                } while (true)
+            }
+            assertEquals(expectedTokens, tokens)
+        }
+    }
+}
diff --git a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextTypeParserTest.kt b/metalava-model/src/test/java/com/android/tools/metalava/model/type/TypeItemParserTest.kt
similarity index 86%
rename from metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextTypeParserTest.kt
rename to metalava-model/src/test/java/com/android/tools/metalava/model/type/TypeItemParserTest.kt
index c5d666d13..b9fa45d78 100644
--- a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextTypeParserTest.kt
+++ b/metalava-model/src/test/java/com/android/tools/metalava/model/type/TypeItemParserTest.kt
@@ -14,12 +14,12 @@
  * limitations under the License.
  */
 
-package com.android.tools.metalava.model.text
+package com.android.tools.metalava.model.type
 
+import com.android.tools.metalava.model.AnnotationContext
 import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.ArrayTypeItem
 import com.android.tools.metalava.model.ClassTypeItem
-import com.android.tools.metalava.model.DefaultAnnotationItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeNullability
 import com.android.tools.metalava.model.TypeParameterScope
@@ -27,30 +27,37 @@ import com.google.common.truth.Truth.assertThat
 import org.junit.Assert
 import org.junit.Test
 
-class TextTypeParserTest : BaseTextCodebaseTest() {
-    private val typeParser = run {
-        val signatureFile = SignatureFile.fromText("test", "")
-        val codebase = ApiFile.parseApi(listOf(signatureFile))
-        TextTypeParser(codebase)
-    }
+class TypeItemParserTest {
+    private val typeParser =
+        TypeItemParser(
+            // This context is needed because this test compares types with annotations that have
+            // been created from text. Comparing those annotations requires comparing the value of
+            // the annotation attributes. Getting an attribute value requires resolving the
+            // annotation class in order to find the attribute type so that the value can be
+            // converted into the correct type. The default context throws an exception when
+            // resolving the annotation class. This one returns `null` when resolving the annotation
+            // class which just means the value type will be determined from the text.
+            AnnotationContext.DEFAULT_RESOLVE_NULL,
+            UnqualifiedClassHandler.PREFIX_WITH_JAVA_LANG_OR_REPORT_ERROR,
+        )
 
     private fun parseType(type: String) =
         typeParser.obtainTypeFromString(type, TypeParameterScope.empty)
 
     @Test
     fun `Test type parameter strings`() {
-        assertThat(TextTypeParser.typeParameterStrings(null).toString()).isEqualTo("[]")
-        assertThat(TextTypeParser.typeParameterStrings("").toString()).isEqualTo("[]")
-        assertThat(TextTypeParser.typeParameterStrings("<X>").toString()).isEqualTo("[X]")
-        assertThat(TextTypeParser.typeParameterStrings("<ABC,DEF extends T>").toString())
+        assertThat(TypeItemParser.typeParameterStrings(null).toString()).isEqualTo("[]")
+        assertThat(TypeItemParser.typeParameterStrings("").toString()).isEqualTo("[]")
+        assertThat(TypeItemParser.typeParameterStrings("<X>").toString()).isEqualTo("[X]")
+        assertThat(TypeItemParser.typeParameterStrings("<ABC,DEF extends T>").toString())
             .isEqualTo("[ABC, DEF extends T]")
         assertThat(
-                TextTypeParser.typeParameterStrings("<T extends java.lang.Comparable<? super T>>")
+                TypeItemParser.typeParameterStrings("<T extends java.lang.Comparable<? super T>>")
                     .toString()
             )
             .isEqualTo("[T extends java.lang.Comparable<? super T>]")
         assertThat(
-                TextTypeParser.typeParameterStrings("<java.util.List<java.lang.String>[]>")
+                TypeItemParser.typeParameterStrings("<java.util.List<java.lang.String>[]>")
                     .toString()
             )
             .isEqualTo("[java.util.List<java.lang.String>[]]")
@@ -59,15 +66,15 @@ class TextTypeParserTest : BaseTextCodebaseTest() {
     @Test
     fun `Test type parameter strings with annotations`() {
         assertThat(
-                TextTypeParser.typeParameterStrings(
+                TypeItemParser.typeParameterStrings(
                     "<java.lang.@androidx.annotation.IntRange(from=5,to=10) Integer>"
                 )
             )
             .containsExactly("java.lang.@androidx.annotation.IntRange(from=5,to=10) Integer")
-        assertThat(TextTypeParser.typeParameterStrings("<@test.pkg.C String>"))
+        assertThat(TypeItemParser.typeParameterStrings("<@test.pkg.C String>"))
             .containsExactly("@test.pkg.C String")
         assertThat(
-                TextTypeParser.typeParameterStrings(
+                TypeItemParser.typeParameterStrings(
                     "<java.lang.@androidx.annotation.IntRange(from=5,to=10) Integer, @test.pkg.C String>"
                 )
             )
@@ -79,50 +86,50 @@ class TextTypeParserTest : BaseTextCodebaseTest() {
 
     @Test
     fun `Test type parameter strings with remainder`() {
-        assertThat(TextTypeParser.typeParameterStringsWithRemainder(null))
+        assertThat(TypeItemParser.typeParameterStringsWithRemainder(null))
             .isEqualTo(Pair(emptyList<String>(), null))
-        assertThat(TextTypeParser.typeParameterStringsWithRemainder(""))
+        assertThat(TypeItemParser.typeParameterStringsWithRemainder(""))
             .isEqualTo(Pair(emptyList<String>(), ""))
-        assertThat(TextTypeParser.typeParameterStringsWithRemainder("<X>"))
+        assertThat(TypeItemParser.typeParameterStringsWithRemainder("<X>"))
             .isEqualTo(Pair(listOf("X"), null))
-        assertThat(TextTypeParser.typeParameterStringsWithRemainder("<X>.Inner"))
+        assertThat(TypeItemParser.typeParameterStringsWithRemainder("<X>.Inner"))
             .isEqualTo(Pair(listOf("X"), ".Inner"))
-        assertThat(TextTypeParser.typeParameterStringsWithRemainder("<X, Y, Z>.Inner<A, B, C>"))
+        assertThat(TypeItemParser.typeParameterStringsWithRemainder("<X, Y, Z>.Inner<A, B, C>"))
             .isEqualTo(Pair(listOf("X", "Y", "Z"), ".Inner<A, B, C>"))
     }
 
     @Test
     fun `Test splitting Kotlin nullability suffix`() {
-        assertThat(TextTypeParser.splitNullabilitySuffix("String!", true))
+        assertThat(TypeItemParser.splitNullabilitySuffix("String!", true))
             .isEqualTo(Pair("String", TypeNullability.PLATFORM))
-        assertThat(TextTypeParser.splitNullabilitySuffix("String?", true))
+        assertThat(TypeItemParser.splitNullabilitySuffix("String?", true))
             .isEqualTo(Pair("String", TypeNullability.NULLABLE))
-        assertThat(TextTypeParser.splitNullabilitySuffix("String", true))
+        assertThat(TypeItemParser.splitNullabilitySuffix("String", true))
             .isEqualTo(Pair("String", TypeNullability.NONNULL))
         // Check that wildcards work
-        assertThat(TextTypeParser.splitNullabilitySuffix("?", true))
+        assertThat(TypeItemParser.splitNullabilitySuffix("?", true))
             .isEqualTo(Pair("?", TypeNullability.UNDEFINED))
-        assertThat(TextTypeParser.splitNullabilitySuffix("T", true))
+        assertThat(TypeItemParser.splitNullabilitySuffix("T", true))
             .isEqualTo(Pair("T", TypeNullability.NONNULL))
     }
 
     @Test
     fun `Test splitting Kotlin nullability suffix when kotlinStyleNulls is false`() {
-        assertThat(TextTypeParser.splitNullabilitySuffix("String", false))
+        assertThat(TypeItemParser.splitNullabilitySuffix("String", false))
             .isEqualTo(Pair("String", null))
-        assertThat(TextTypeParser.splitNullabilitySuffix("?", false)).isEqualTo(Pair("?", null))
+        assertThat(TypeItemParser.splitNullabilitySuffix("?", false)).isEqualTo(Pair("?", null))
 
         Assert.assertThrows(
             "Format does not support Kotlin-style null type syntax: String!",
-            ApiParseException::class.java
+            IllegalStateException::class.java
         ) {
-            TextTypeParser.splitNullabilitySuffix("String!", false)
+            TypeItemParser.splitNullabilitySuffix("String!", false)
         }
         Assert.assertThrows(
             "Format does not support Kotlin-style null type syntax: String?",
-            ApiParseException::class.java
+            IllegalStateException::class.java
         ) {
-            TextTypeParser.splitNullabilitySuffix("String?", false)
+            TypeItemParser.splitNullabilitySuffix("String?", false)
         }
     }
 
@@ -139,7 +146,9 @@ class TextTypeParserTest : BaseTextCodebaseTest() {
         val (type, annotations) = annotationFunction(original)
         assertThat(type).isEqualTo(expectedType)
         val expectedAnnotationItems =
-            expectedAnnotations.map { DefaultAnnotationItem.create(typeParser.codebase, it) }
+            expectedAnnotations.map {
+                AnnotationItem.createFromSource(typeParser.annotationContext, it)
+            }
         assertThat(annotations).isEqualTo(expectedAnnotationItems)
     }
 
@@ -274,7 +283,7 @@ class TextTypeParserTest : BaseTextCodebaseTest() {
     }
 
     /**
-     * Verifies that calling [TextTypeParser.splitClassType] returns the triple of
+     * Verifies that calling [TypeItemParser.splitClassType] returns the triple of
      * [expectedClassName], [expectedParams], [expectedAnnotations].
      */
     private fun testClassAnnotations(
@@ -287,7 +296,9 @@ class TextTypeParserTest : BaseTextCodebaseTest() {
         assertThat(className).isEqualTo(expectedClassName)
         assertThat(params).isEqualTo(expectedParams)
         val expectedAnnotationItems =
-            expectedAnnotations.map { DefaultAnnotationItem.create(typeParser.codebase, it) }
+            expectedAnnotations.map {
+                AnnotationItem.createFromSource(typeParser.annotationContext, it)
+            }
         assertThat(annotations).isEqualTo(expectedAnnotationItems)
     }
 
diff --git a/metalava-model/src/test/java/com/android/tools/metalava/model/value/BaseCachingValueProviderTest.kt b/metalava-model/src/test/java/com/android/tools/metalava/model/value/BaseCachingValueProviderTest.kt
new file mode 100644
index 000000000..d753a2959
--- /dev/null
+++ b/metalava-model/src/test/java/com/android/tools/metalava/model/value/BaseCachingValueProviderTest.kt
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.value
+
+import kotlin.test.assertEquals
+import kotlin.test.assertNull
+import kotlin.test.assertSame
+import org.junit.Assert.assertThrows
+import org.junit.Test
+
+class BaseCachingValueProviderTest {
+
+    class ValueProviderCounter(valueUseSite: ValueUseSite, private val provider: () -> Value?) :
+        BaseCachingValueProvider(valueUseSite) {
+        var provideValueCallCount = 0
+
+        override fun provideValue(): Value? {
+            provideValueCallCount += 1
+            return provider()
+        }
+    }
+
+    @Test
+    fun `Test only calls provideValue once when it returns null`() {
+        val counter =
+            ValueProviderCounter(
+                // Use field as it allows null and this test needs to test that it can cache nulls.
+                valueUseSite = ValueUseSite.FIELD,
+            ) {
+                null
+            }
+        assertEquals(0, counter.provideValueCallCount, "before")
+        assertNull(counter.optionalValue)
+        assertEquals(1, counter.provideValueCallCount, "after first call")
+        assertNull(counter.optionalValue)
+        assertEquals(1, counter.provideValueCallCount, "after second call")
+    }
+
+    @Test
+    fun `Test only calls provideValue once when it returns non-null`() {
+        val stringValue = Value.createLiteralValue(null, "string")
+        val counter =
+            ValueProviderCounter(
+                // Use annotation as it does not allow nulls.
+                valueUseSite = ValueUseSite.ANNOTATION,
+            ) {
+                stringValue
+            }
+        assertEquals(0, counter.provideValueCallCount, "before")
+        assertSame(stringValue, counter.optionalValue)
+        assertEquals(1, counter.provideValueCallCount, "after first call")
+        assertSame(stringValue, counter.optionalValue)
+        assertEquals(1, counter.provideValueCallCount, "after second call")
+    }
+
+    @Test
+    fun `Test value fails when provideValue returns null`() {
+        val counter =
+            ValueProviderCounter(
+                // Use field as it allows null and this test needs to test that provider can return
+                // nulls, but they are inaccessible via `value` property.
+                valueUseSite = ValueUseSite.FIELD,
+            ) {
+                null
+            }
+        val exception = assertThrows(IllegalStateException::class.java) { counter.value }
+
+        assertEquals("No value provided", exception.message)
+    }
+
+    @Test
+    fun `Test optionalValue fails when provideValue returns null when it is not allowed`() {
+        val counter =
+            ValueProviderCounter(
+                // Use annotation as it does not allow nulls.
+                valueUseSite = ValueUseSite.ANNOTATION,
+            ) {
+                null
+            }
+        val exception = assertThrows(IllegalStateException::class.java) { counter.value }
+
+        assertEquals(
+            "Provider returned `null` but nulls are not allowed on annotation values",
+            exception.message
+        )
+    }
+}
diff --git a/metalava-model/src/test/java/com/android/tools/metalava/model/value/LiteralValueTest.kt b/metalava-model/src/test/java/com/android/tools/metalava/model/value/LiteralValueTest.kt
new file mode 100644
index 000000000..c3a85c3d1
--- /dev/null
+++ b/metalava-model/src/test/java/com/android/tools/metalava/model/value/LiteralValueTest.kt
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.value
+
+import com.android.tools.metalava.model.PrimitiveTypeItem.Primitive
+import com.android.tools.metalava.model.testing.primitiveTypeForKind
+import com.android.tools.metalava.model.testing.value.assertValuesAreStrictlyEqual
+import com.android.tools.metalava.model.testing.value.literalValue
+import com.android.tools.metalava.model.testing.value.primitiveValueForKind
+import kotlin.test.assertSame
+import org.junit.Test
+
+/** General tests for [LiteralValue] classes. */
+class LiteralValueTest {
+    @Test
+    fun `Test convertToType - literal to literal of same type`() {
+        val input = literalValue(1)
+        val intType = primitiveTypeForKind(Primitive.INT)
+        val converted = input.convertToType(intType)
+        // No conversion was necessary.
+        assertSame(input, converted)
+    }
+
+    @Test
+    fun `Test convertToType - literal to literal of different type`() {
+        val input = literalValue(1)
+        val doubleType = primitiveTypeForKind(Primitive.DOUBLE)
+        val converted = input.convertToType(doubleType)
+        assertValuesAreStrictlyEqual(primitiveValueForKind(Primitive.DOUBLE, 1), converted)
+    }
+
+    @Test
+    fun `Test convertToType - non-literal to literal of same type`() {
+        val input = literalValue(1, nonLiteralInSource = true)
+        val intType = primitiveTypeForKind(Primitive.INT)
+        val converted = input.convertToType(intType)
+        // No conversion was necessary.
+        assertSame(input, converted)
+    }
+
+    @Test
+    fun `Test convertToType - non-literal to literal of different type`() {
+        val input = literalValue(1, nonLiteralInSource = true)
+        val doubleType = primitiveTypeForKind(Primitive.DOUBLE)
+        val converted = input.convertToType(doubleType)
+        val expected =
+            primitiveValueForKind(
+                Primitive.DOUBLE,
+                1,
+                nonLiteralInSource = true,
+            )
+        assertValuesAreStrictlyEqual(expected, converted)
+    }
+
+    @Test
+    fun `Test convertToType - float from int literal to double`() {
+        val input = primitiveValueForKind(Primitive.FLOAT, 1)
+        val doubleType = primitiveTypeForKind(Primitive.DOUBLE)
+        val converted = input.convertToType(doubleType)
+        assertValuesAreStrictlyEqual(primitiveValueForKind(Primitive.DOUBLE, 1), converted)
+    }
+
+    @Test
+    fun `Test convertToType - literal to forced non-literal of same type`() {
+        val input = literalValue(1)
+        val intType = primitiveTypeForKind(Primitive.INT)
+        val converted = input.convertToType(intType, forceNonLiteralInSource = true)
+        assertValuesAreStrictlyEqual(literalValue(1, nonLiteralInSource = true), converted)
+    }
+
+    @Test
+    fun `Test convertToType - literal to forced non-literal of different type`() {
+        val input = literalValue(1)
+        val doubleType = primitiveTypeForKind(Primitive.DOUBLE)
+        val converted = input.convertToType(doubleType, forceNonLiteralInSource = true)
+        assertValuesAreStrictlyEqual(
+            primitiveValueForKind(Primitive.DOUBLE, 1, nonLiteralInSource = true),
+            converted
+        )
+    }
+}
diff --git a/metalava-model/src/test/java/com/android/tools/metalava/model/value/ParameterizedAnnotationParserTestCase.kt b/metalava-model/src/test/java/com/android/tools/metalava/model/value/ParameterizedAnnotationParserTestCase.kt
new file mode 100644
index 000000000..e15d377df
--- /dev/null
+++ b/metalava-model/src/test/java/com/android/tools/metalava/model/value/ParameterizedAnnotationParserTestCase.kt
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.value
+
+import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.testing.value.annotationItem
+import com.android.tools.metalava.model.testing.value.annotationValue
+import com.android.tools.metalava.model.testing.value.assertValuesAreStrictlyEqual
+import com.android.tools.metalava.model.testing.value.literalValue
+import com.android.tools.metalava.testing.EntryPointCallerRule
+import com.android.tools.metalava.testing.EntryPointCallerTracker
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
+
+/** Tests for [ValueParser.parseAnnotationItem]. */
+@RunWith(Parameterized::class)
+class ParameterizedAnnotationParserTestCase {
+
+    /** The [TestCase] currently being tested. */
+    @Parameterized.Parameter(0) lateinit var testCase: TestCase
+
+    /**
+     * Will try and rewrite the stack trace of any test failures to refer to the location where the
+     * [TestCase] that is currently being tested was created.
+     */
+    @get:Rule val entryPointCallerRule = EntryPointCallerRule { testCase.entryPointCallerTracker }
+
+    class TestCase(
+        private val label: String,
+        val input: String,
+        val expected: AnnotationItem,
+    ) {
+        /**
+         * Record the stack trace of the creation of this which can be used to provide a stack trace
+         * to the creator of this instance in the event of a test failure.
+         */
+        val entryPointCallerTracker = EntryPointCallerTracker()
+
+        override fun toString() = label
+    }
+
+    companion object {
+        private val testCases =
+            listOf(
+                // Test without a leading @ just to show that they can be processed. Following tests
+                // will all use @ as it looks more obviously an annotation.
+                TestCase(
+                    "no attribute list - no leading @",
+                    input = "test.pkg.Anno",
+                    expected = annotationItem("test.pkg.Anno"),
+                ),
+                TestCase(
+                    "no attribute list - leading @",
+                    input = "@test.pkg.Anno",
+                    expected = annotationItem("test.pkg.Anno"),
+                ),
+                TestCase(
+                    "empty attribute list",
+                    input = "@test.pkg.Anno()",
+                    expected = annotationItem("test.pkg.Anno"),
+                ),
+                TestCase(
+                    "single attribute - no name",
+                    input = "@test.pkg.Anno(1)",
+                    expected =
+                        annotationItem(
+                            "test.pkg.Anno",
+                            "value" to literalValue(1),
+                        ),
+                ),
+                TestCase(
+                    "single attribute - value name",
+                    input = "@test.pkg.Anno(value = 1)",
+                    expected =
+                        annotationItem(
+                            "test.pkg.Anno",
+                            "value" to literalValue(1),
+                        ),
+                ),
+                TestCase(
+                    "single attribute - other name",
+                    input = "@test.pkg.Anno(other = 1)",
+                    expected =
+                        annotationItem(
+                            "test.pkg.Anno",
+                            "other" to literalValue(1),
+                        ),
+                ),
+                TestCase(
+                    "single attribute - trailing comma",
+                    // This is not strictly legal in Java, but it is in Kotlin and there are quite a
+                    // few tests that do this.
+                    input = "@test.pkg.Anno(other = 1,)",
+                    expected =
+                        annotationItem(
+                            "test.pkg.Anno",
+                            "other" to literalValue(1),
+                        ),
+                ),
+                TestCase(
+                    "multiple attributes - simple",
+                    input = "@test.pkg.Anno(other = 1, another = 2L)",
+                    expected =
+                        annotationItem(
+                            "test.pkg.Anno",
+                            "other" to literalValue(1),
+                            "another" to literalValue(2L),
+                        ),
+                ),
+                TestCase(
+                    "multiple attributes - trailing comma",
+                    // This is not strictly legal in Java, but it is in Kotlin and there are quite a
+                    // few tests that do this.
+                    input = "@test.pkg.Anno(other = 1, another = 2L,)",
+                    expected =
+                        annotationItem(
+                            "test.pkg.Anno",
+                            "other" to literalValue(1),
+                            "another" to literalValue(2L),
+                        ),
+                ),
+                TestCase(
+                    "legacy attributes - subtract one",
+                    input = "@test.pkg.Anno(other = 0x40000000 - 1)",
+                    expected =
+                        annotationItem(
+                            "test.pkg.Anno",
+                            "other" to literalValue(0x3fffffff),
+                        ),
+                ),
+                TestCase(
+                    "nested annotation - no attributes",
+                    input = "@test.pkg.Anno(other = @test.pkg.OtherAnno)",
+                    expected =
+                        annotationItem(
+                            "test.pkg.Anno",
+                            "other" to annotationValue("test.pkg.OtherAnno"),
+                        ),
+                ),
+                TestCase(
+                    "nested annotation - empty attributes",
+                    input = "@test.pkg.Anno(other = @test.pkg.OtherAnno())",
+                    expected =
+                        annotationItem(
+                            "test.pkg.Anno",
+                            "other" to annotationValue("test.pkg.OtherAnno"),
+                        ),
+                ),
+                TestCase(
+                    "nested annotation - kotlin style - empty attributes",
+                    input = "@test.pkg.Anno(other = test.pkg.OtherAnno())",
+                    expected =
+                        annotationItem(
+                            "test.pkg.Anno",
+                            "other" to annotationValue("test.pkg.OtherAnno"),
+                        ),
+                ),
+                TestCase(
+                    "nested annotation - multiple attributes",
+                    input = "@test.pkg.Anno(other = @test.pkg.OtherAnno(value = 'a', attr = 1.0))",
+                    expected =
+                        annotationItem(
+                            "test.pkg.Anno",
+                            "other" to
+                                annotationValue(
+                                    "test.pkg.OtherAnno",
+                                    "value" to literalValue('a'),
+                                    "attr" to literalValue(1.0),
+                                ),
+                        ),
+                ),
+                TestCase(
+                    "nested annotation - kotlin style - multiple attributes",
+                    // Kotlin style.
+                    input = "@test.pkg.Anno(other = test.pkg.OtherAnno(value = 'a', attr = 1.0))",
+                    expected =
+                        annotationItem(
+                            "test.pkg.Anno",
+                            "other" to
+                                annotationValue(
+                                    "test.pkg.OtherAnno",
+                                    "value" to literalValue('a'),
+                                    "attr" to literalValue(1.0),
+                                ),
+                        ),
+                ),
+            )
+
+        /** Supply the list of test cases as the parameters for this test class. */
+        @JvmStatic @Parameterized.Parameters(name = "{0}") fun params() = testCases
+    }
+
+    @Test
+    fun `Test parse`() {
+        val annotation = ValueParser.DEFAULT.parseAnnotationItem(testCase.input)!!
+
+        // Wrap in an AnnotationValue before comparing to use its equals(...) method which is
+        // defined in terms of the qualified name and the attribute name/Value pairs, ignoring the
+        // order.
+        val expected = Value.createAnnotationValue(testCase.expected)
+        val actual = Value.createAnnotationValue(annotation)
+
+        assertValuesAreStrictlyEqual(expected, actual)
+    }
+}
diff --git a/metalava-model/src/test/java/com/android/tools/metalava/model/value/ParameterizedCreateLiteralNoTypeItemTest.kt b/metalava-model/src/test/java/com/android/tools/metalava/model/value/ParameterizedCreateLiteralNoTypeItemTest.kt
new file mode 100644
index 000000000..21a419f5b
--- /dev/null
+++ b/metalava-model/src/test/java/com/android/tools/metalava/model/value/ParameterizedCreateLiteralNoTypeItemTest.kt
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.value
+
+import com.android.tools.metalava.model.TypeItem
+import kotlin.test.assertEquals
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
+
+/**
+ * Tests for [ValueFactory.createLiteralValue] when no [TypeItem] is provided.
+ *
+ * Makes sure that the correct [LiteralValue] subclass is created depending on the
+ * `underlyingValue`. The type should ensure that but this test just makes sure.
+ */
+@RunWith(Parameterized::class)
+class ParameterizedCreateLiteralNoTypeItemTest {
+    @Parameterized.Parameter(0) lateinit var creationTest: CreationTest
+
+    class CreationTest(
+        val underlyingValue: Any,
+        val expectedLiteralValue: LiteralValue<*>,
+    ) {
+        override fun toString() = underlyingValue.javaClass.simpleName.lowercase()
+    }
+
+    companion object {
+        private val creationTests =
+            listOf(
+                CreationTest(true, DefaultBooleanValue(true)),
+                CreationTest(123.toByte(), DefaultByteValue(123.toByte())),
+                CreationTest('a', DefaultCharValue('a')),
+                CreationTest(1.0, DefaultDoubleValue(1.0)),
+                CreationTest(1.0f, DefaultFloatValue(1.0f)),
+                CreationTest(12, DefaultIntValue(12)),
+                CreationTest(99L, DefaultLongValue(99L)),
+                CreationTest(1234.toShort(), DefaultShortValue(1234.toShort())),
+                CreationTest("string", DefaultStringValue("string")),
+            )
+
+        /** Supply the list of creation tests as the parameters for this test class. */
+        @JvmStatic @Parameterized.Parameters(name = "{0}") fun params() = creationTests
+    }
+
+    @Test
+    fun `creation test`() {
+        val literalValue = Value.createLiteralValue(null, creationTest.underlyingValue)
+        assertEquals(literalValue, creationTest.expectedLiteralValue, message = "literal value")
+        assertEquals(
+            creationTest.underlyingValue,
+            literalValue.underlyingValue,
+            "literal value's underlying value"
+        )
+    }
+}
diff --git a/metalava-model/src/test/java/com/android/tools/metalava/model/value/ParameterizedLiteralValueConversionTest.kt b/metalava-model/src/test/java/com/android/tools/metalava/model/value/ParameterizedLiteralValueConversionTest.kt
new file mode 100644
index 000000000..8aa7e4b5e
--- /dev/null
+++ b/metalava-model/src/test/java/com/android/tools/metalava/model/value/ParameterizedLiteralValueConversionTest.kt
@@ -0,0 +1,609 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.value
+
+import com.android.tools.metalava.model.PrimitiveTypeItem.Primitive
+import com.android.tools.metalava.model.javaEscapeString
+import com.android.tools.metalava.model.testing.primitiveTypeForKind
+import com.android.tools.metalava.model.testing.stringType
+import com.android.tools.metalava.testing.EntryPoint
+import com.android.tools.metalava.testing.EntryPointCallerRule
+import com.android.tools.metalava.testing.EntryPointCallerTracker
+import kotlin.test.assertEquals
+import org.junit.Assert.assertThrows
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
+
+/**
+ * A comprehensive set of tests that verify the behavior of converting from one
+ * [ValueKind.LITERAL_KINDS] to another, for all possible combinations.
+ */
+@RunWith(Parameterized::class)
+class ParameterizedLiteralValueConversionTest {
+    @Parameterized.Parameter(0) lateinit var conversionTest: ConversionTest
+
+    /**
+     * Will try and rewrite the stack trace of any test failures to refer to the location where the
+     * [conversionTest] that is currently being tested was created.
+     */
+    @get:Rule
+    val entryPointCallerRule = EntryPointCallerRule {
+        conversionTest.conversionExample.entryPointCallerTracker
+    }
+
+    /** An example of a conversion. */
+    abstract class ConversionExample {
+        /** Record stack trace for this instance. */
+        val entryPointCallerTracker = EntryPointCallerTracker()
+
+        /** Check the example within the context of [ConversionTest]. */
+        abstract fun ConversionTest.checkExample()
+    }
+
+    /** A [ConversionExample] that works ok. */
+    class ConversionIsOk(
+        private val input: Any,
+        private val expectedOutput: Any,
+    ) : ConversionExample() {
+        override fun ConversionTest.checkExample() {
+            val expectedClass = targetKind.wrapperClass
+            checkNormalization(input, targetKind, expectedOutput, expectedClass)
+        }
+
+        override fun toString() = "ok on $input"
+    }
+
+    /** A [ConversionExample] that produces the same output as the input. */
+    class ConversionIsSame(
+        private val input: Any,
+    ) : ConversionExample() {
+        override fun ConversionTest.checkExample() {
+            val expectedClass = targetKind.wrapperClass
+            checkNormalization(input, targetKind, input, expectedClass)
+        }
+
+        override fun toString() = "same on $input"
+    }
+
+    /** A [ConversionExample] that is lossy. */
+    class ConversionIsLossy<T : Any>(
+        private val input: T,
+        private val lossyOutput: Any,
+        private val roundTripValue: T,
+    ) : ConversionExample() {
+        override fun ConversionTest.checkExample() {
+            checkNormalizationIsLossy(input, targetKind, lossyOutput, roundTripValue)
+        }
+
+        override fun toString() = "lossy when ${javaEscapeString(input.toString())}"
+    }
+
+    /** A [ConversionExample] that is unsupported. */
+    class ConversionIsUnsupported(private val input: Any?) : ConversionExample() {
+        override fun ConversionTest.checkExample() {
+            // If no input value has been provided then just use the default value. For strings use
+            // an empty string as the default.
+            val actualInput = input ?: fromKind.primitiveKind?.defaultValue ?: ""
+            checkNormalizationIsUnsupported(actualInput, targetKind)
+        }
+
+        override fun toString() = "unsupported"
+    }
+
+    /** A [ConversionExample] that is incompatible. */
+    class ConversionIsIncompatible : ConversionExample() {
+        override fun ConversionTest.checkExample() {
+            // If the conversion is incompatible then it does not matter what the input is so just
+            // use the default value.
+            val input = fromKind.primitiveKind?.defaultValue ?: ""
+            checkNormalizationIsIncompatible(input, targetKind)
+        }
+
+        override fun toString() = "incompatible"
+    }
+
+    /** A conversion test from [fromKind] to [targetKind] using [conversionExample]. */
+    data class ConversionTest(
+        val fromKind: ValueKind,
+        val targetKind: ValueKind,
+        val conversionExample: ConversionExample,
+    ) {
+        fun runTest() {
+            with(conversionExample) { checkExample() }
+        }
+
+        /**
+         * Check that the normalization of the [input] to match the [targetKind] results in the
+         * [expectedOutput] of the [expectedClass].
+         */
+        fun checkNormalization(
+            input: Any,
+            targetKind: ValueKind,
+            expectedOutput: Any,
+            expectedClass: Class<*>
+        ) {
+            val description = "Converting $input of ${input.javaClass} to $targetKind"
+            val normalized = createLiteralValue(targetKind, input).underlyingValue
+            assertEquals<Class<*>>(
+                expectedClass,
+                normalized.javaClass,
+                message = "$description: incorrect class"
+            )
+            assertEquals(expectedOutput, normalized, message = "$description: incorrect output")
+        }
+
+        /**
+         * Check the normalization of [input] to match the [targetKind] results in the [lossyOutput]
+         * and if it is then round tripped back to the original type it results in [roundTripValue].
+         */
+        fun <T : Any> checkNormalizationIsLossy(
+            input: T,
+            targetKind: ValueKind,
+            lossyOutput: Any,
+            roundTripValue: T,
+        ) {
+            val description = "Converting $input of ${input.javaClass} to $targetKind"
+            val exception =
+                assertThrows(RuntimeException::class.java) { createLiteralValue(targetKind, input) }
+            assertEquals(
+                "Conversion of ${javaEscapeString(input.toString())} to $targetKind is lossy and produces $lossyOutput; round trip value is ${javaEscapeString(roundTripValue.toString())}",
+                exception.message,
+                description
+            )
+        }
+
+        /** Check the normalization of [input] to match the [targetKind] is unsupported. */
+        fun checkNormalizationIsUnsupported(
+            input: Any,
+            targetKind: ValueKind,
+        ) {
+            val description = "Converting $input of ${input.javaClass} to $targetKind"
+            val exception =
+                assertThrows(RuntimeException::class.java) { createLiteralValue(targetKind, input) }
+            assertEquals(
+                "Unsupported primitive type: $targetKind, for underlying value `$input` of ${input.javaClass}",
+                exception.message,
+                description
+            )
+        }
+
+        /** Check the normalization of [input] to match the [targetKind] is incompatible. */
+        fun checkNormalizationIsIncompatible(
+            input: Any,
+            targetKind: ValueKind,
+        ) {
+            val description = "Converting $input of ${input.javaClass} to $targetKind"
+            val exception =
+                assertThrows(RuntimeException::class.java) { createLiteralValue(targetKind, input) }
+            assertEquals(
+                "Incompatible type '${targetKind.wrapperClass.name}', for underlying value `$input` of ${input.javaClass}",
+                exception.message,
+                description
+            )
+        }
+
+        private fun createLiteralValue(targetKind: ValueKind, input: Any): LiteralValue<*> {
+            val typeItem =
+                targetKind.primitiveKind?.let { primitiveTypeForKind(it) } ?: stringType()
+            return Value.createLiteralValue(typeItem, input)
+        }
+
+        override fun toString() = "$fromKind to $targetKind is $conversionExample"
+    }
+
+    companion object {
+        /**
+         * Get the `java.lang` boxing wrapper class suitable for this [ValueKind].
+         *
+         * Only works for primitive [ValueKind]s and [ValueKind.STRING].
+         */
+        val ValueKind.wrapperClass
+            get() =
+                primitiveKind?.wrapperClass
+                    ?: if (this == ValueKind.STRING) String::class.java
+                    else error("No wrapper class found for $this")
+
+        /** The conversion between two [ValueKind]s is unsupported. */
+        @EntryPoint
+        internal fun unsupported(input: Any? = null) = listOf(ConversionIsUnsupported(input))
+
+        /** The conversion between two [ValueKind]s is incompatible. */
+        private fun incompatible() = listOf(ConversionIsIncompatible())
+
+        /** The conversion between two literals works fine. */
+        @EntryPoint
+        internal fun ok(input: Any, expectedOutput: Any) =
+            listOf(ConversionIsOk(input, expectedOutput))
+
+        /** The conversion between two literals produces the same output as input. */
+        @EntryPoint internal fun same(input: Any) = listOf(ConversionIsSame(input))
+
+        /** The conversion between two primitives is lossy. */
+        @EntryPoint
+        internal fun <T : Any> lossy(
+            input: T,
+            lossyOutput: Any,
+            roundTripValue: T,
+        ) = listOf(ConversionIsLossy(input, lossyOutput, roundTripValue))
+
+        /**
+         * A map from every [Primitive] to every [Primitive] with a list of [ConversionExample]s.
+         */
+        private val conversionMatrix =
+            mapOf(
+                ValueKind.BOOLEAN to
+                    mapOf(
+                        ValueKind.BOOLEAN to same(input = true),
+                        ValueKind.BYTE to unsupported(),
+                        ValueKind.CHAR to unsupported(),
+                        ValueKind.DOUBLE to unsupported(),
+                        ValueKind.FLOAT to unsupported(),
+                        ValueKind.INT to unsupported(),
+                        ValueKind.LONG to unsupported(),
+                        ValueKind.SHORT to unsupported(),
+                        ValueKind.STRING to incompatible(),
+                    ),
+                ValueKind.BYTE to
+                    mapOf(
+                        ValueKind.BOOLEAN to unsupported(),
+                        ValueKind.BYTE to same(input = 100.toByte()),
+                        ValueKind.CHAR to
+                            ok(
+                                input = 66.toByte(),
+                                expectedOutput = 'B',
+                            ) +
+                                // A negative byte to a character to an int, to a byte produces the
+                                // exact same negative byte as this started with so it is not
+                                // considered lossy.
+                                ok(
+                                    input = (-12).toByte(),
+                                    expectedOutput = '\uFFF4',
+                                ),
+                        ValueKind.DOUBLE to
+                            ok(
+                                input = (-77).toByte(),
+                                expectedOutput = -77.0,
+                            ),
+                        ValueKind.FLOAT to
+                            ok(
+                                input = 15.toByte(),
+                                expectedOutput = 15.0f,
+                            ),
+                        ValueKind.INT to
+                            ok(
+                                input = 127.toByte(),
+                                expectedOutput = 127,
+                            ),
+                        ValueKind.LONG to
+                            ok(
+                                input = (-125).toByte(),
+                                expectedOutput = -125L,
+                            ),
+                        ValueKind.SHORT to
+                            ok(
+                                input = 53.toByte(),
+                                expectedOutput = 53.toShort(),
+                            ),
+                        ValueKind.STRING to incompatible(),
+                    ),
+                ValueKind.CHAR to
+                    mapOf(
+                        ValueKind.BOOLEAN to unsupported(),
+                        ValueKind.BYTE to
+                            ok(
+                                input = 'a',
+                                expectedOutput = 97.toByte(),
+                            ) +
+                                lossy(
+                                    input = '\u0090',
+                                    lossyOutput = (-112).toByte(),
+                                    roundTripValue = '\uff90',
+                                ),
+                        ValueKind.CHAR to same(input = 'a'),
+                        ValueKind.DOUBLE to unsupported(),
+                        ValueKind.FLOAT to unsupported(),
+                        ValueKind.INT to
+                            ok(
+                                input = 'a',
+                                expectedOutput = 97,
+                            ),
+                        ValueKind.LONG to
+                            ok(
+                                input = 'a',
+                                expectedOutput = 97L,
+                            ),
+                        ValueKind.SHORT to
+                            ok(
+                                input = 'a',
+                                expectedOutput = 97.toShort(),
+                            ) +
+                                // A character above \u7FFF produces a negative short but when it is
+                                // converted back to a character it produces the original character
+                                // so it is not considered lossy.
+                                ok(
+                                    input = '\u9000',
+                                    expectedOutput = (-28672).toShort(),
+                                ),
+                        ValueKind.STRING to incompatible(),
+                    ),
+                ValueKind.DOUBLE to
+                    mapOf(
+                        ValueKind.BOOLEAN to unsupported(),
+                        ValueKind.BYTE to unsupported(),
+                        ValueKind.CHAR to unsupported(),
+                        ValueKind.DOUBLE to same(input = 7.89E-200),
+                        ValueKind.FLOAT to
+                            ok(
+                                input = -3.125,
+                                expectedOutput = -3.125f,
+                            ) +
+                                lossy(
+                                    input = 2.0e60,
+                                    lossyOutput = Float.POSITIVE_INFINITY,
+                                    roundTripValue = Double.POSITIVE_INFINITY,
+                                ),
+                        ValueKind.INT to unsupported(),
+                        ValueKind.LONG to unsupported(),
+                        ValueKind.SHORT to unsupported(),
+                        ValueKind.STRING to incompatible(),
+                    ),
+                ValueKind.FLOAT to
+                    mapOf(
+                        ValueKind.BOOLEAN to unsupported(),
+                        ValueKind.BYTE to unsupported(),
+                        ValueKind.CHAR to unsupported(),
+                        ValueKind.DOUBLE to
+                            ok(
+                                input = Float.MAX_VALUE,
+                                expectedOutput = 3.4028234663852886E38,
+                            ),
+                        ValueKind.FLOAT to same(input = 123456.79f),
+                        ValueKind.INT to unsupported(),
+                        ValueKind.LONG to unsupported(),
+                        ValueKind.SHORT to unsupported(),
+                        ValueKind.STRING to incompatible(),
+                    ),
+                ValueKind.INT to
+                    mapOf(
+                        ValueKind.BOOLEAN to unsupported(),
+                        ValueKind.BYTE to
+                            ok(
+                                input = 1,
+                                expectedOutput = 1.toByte(),
+                            ) +
+                                lossy(
+                                    input = 128,
+                                    lossyOutput = -128,
+                                    roundTripValue = -128,
+                                ),
+                        ValueKind.CHAR to
+                            ok(
+                                input = 169,
+                                expectedOutput = '',
+                            ) +
+                                lossy(
+                                    input = 123456,
+                                    lossyOutput = '\uE240',
+                                    roundTripValue = 57920,
+                                ),
+                        ValueKind.DOUBLE to
+                            ok(
+                                input = Int.MAX_VALUE,
+                                expectedOutput = 2.147483647E9,
+                            ),
+                        ValueKind.FLOAT to
+                            ok(
+                                input = 123456,
+                                expectedOutput = 123456.0f,
+                            ) +
+                                lossy(
+                                    input = 16_777_217,
+                                    lossyOutput = 1.6777216E7f,
+                                    roundTripValue = 16_777_216,
+                                ),
+                        ValueKind.INT to same(input = 99),
+                        ValueKind.LONG to
+                            ok(
+                                input = Int.MIN_VALUE,
+                                expectedOutput = -2147483648L,
+                            ),
+                        ValueKind.SHORT to
+                            ok(
+                                input = -123,
+                                expectedOutput = (-123).toShort(),
+                            ) +
+                                lossy(
+                                    input = 1 shl 18,
+                                    lossyOutput = 0,
+                                    roundTripValue = 0,
+                                ),
+                        ValueKind.STRING to incompatible(),
+                    ),
+                ValueKind.LONG to
+                    mapOf(
+                        ValueKind.BOOLEAN to unsupported(),
+                        ValueKind.BYTE to
+                            ok(
+                                input = 1L,
+                                expectedOutput = 1.toByte(),
+                            ) +
+                                lossy(
+                                    input = 130L,
+                                    lossyOutput = (-126).toByte(),
+                                    roundTripValue = -126L,
+                                ),
+                        ValueKind.CHAR to
+                            ok(
+                                input = 0x2345L,
+                                expectedOutput = '\u2345',
+                            ) +
+                                lossy(
+                                    input = 12_345_678_900L,
+                                    lossyOutput = '\u1C34',
+                                    roundTripValue = 7220,
+                                ),
+                        ValueKind.DOUBLE to
+                            ok(
+                                input = 20_000_000_000L,
+                                expectedOutput = 2.0E10,
+                            ) +
+                                lossy(
+                                    input = (1L shl 53) + 1,
+                                    lossyOutput = 9.007199254740992E15,
+                                    roundTripValue = 9007199254740992L,
+                                ),
+                        ValueKind.FLOAT to
+                            ok(
+                                input = 9_999_999L,
+                                expectedOutput = 9999999.0f,
+                            ) +
+                                lossy(
+                                    input = 123_456_789_123L,
+                                    lossyOutput = 1.2345679E11,
+                                    roundTripValue = 123456790528L,
+                                ),
+                        ValueKind.INT to
+                            ok(
+                                input = 1L shl 30,
+                                expectedOutput = 1 shl 30,
+                            ) +
+                                lossy(
+                                    input = 1L shl 56,
+                                    lossyOutput = 0,
+                                    roundTripValue = 0,
+                                ),
+                        ValueKind.LONG to same(input = Long.MIN_VALUE),
+                        ValueKind.SHORT to
+                            ok(
+                                input = -32768L,
+                                expectedOutput = Short.MIN_VALUE,
+                            ) +
+                                lossy(
+                                    input = 44444L,
+                                    lossyOutput = (-21092).toShort(),
+                                    roundTripValue = -21092,
+                                ),
+                        ValueKind.STRING to incompatible(),
+                    ),
+                ValueKind.SHORT to
+                    mapOf(
+                        ValueKind.BOOLEAN to unsupported(),
+                        ValueKind.BYTE to
+                            ok(
+                                input = 9.toShort(),
+                                expectedOutput = 9.toByte(),
+                            ) +
+                                lossy(
+                                    input = 257.toShort(),
+                                    lossyOutput = 1,
+                                    roundTripValue = 1,
+                                ),
+                        ValueKind.CHAR to
+                            ok(
+                                input = Short.MAX_VALUE,
+                                expectedOutput = '\u7FFF',
+                            ) +
+                                // A negative short to a character to an int, to a short produces
+                                // the exact same negative short as this started with so it is not
+                                // considered lossy.
+                                ok(
+                                    input = (-56).toShort(),
+                                    expectedOutput = '\uFFC8',
+                                ),
+                        ValueKind.DOUBLE to
+                            ok(
+                                input = Short.MAX_VALUE,
+                                expectedOutput = 32767.0,
+                            ),
+                        ValueKind.FLOAT to
+                            ok(
+                                input = Short.MIN_VALUE,
+                                expectedOutput = -32768.0f,
+                            ),
+                        ValueKind.INT to
+                            ok(
+                                input = 1234,
+                                expectedOutput = 1234,
+                            ),
+                        ValueKind.LONG to
+                            ok(
+                                input = -12345,
+                                expectedOutput = -12345L,
+                            ),
+                        ValueKind.SHORT to same(input = 9876.toShort()),
+                        ValueKind.STRING to incompatible(),
+                    ),
+                ValueKind.STRING to
+                    mapOf(
+                        ValueKind.BOOLEAN to unsupported(),
+                        ValueKind.BYTE to unsupported(),
+                        ValueKind.CHAR to
+                            // Single character string can be converted to a char.
+                            ok(
+                                input = "a",
+                                expectedOutput = 'a',
+                            ) +
+                                // Empty strings cannot be converted to a char.
+                                unsupported(
+                                    input = "",
+                                ) +
+                                // Multi-character strings cannot be converted to a char.
+                                unsupported(
+                                    input = "aa",
+                                ),
+                        ValueKind.DOUBLE to unsupported(),
+                        ValueKind.FLOAT to unsupported(),
+                        ValueKind.INT to unsupported(),
+                        ValueKind.LONG to unsupported(),
+                        ValueKind.SHORT to unsupported(),
+                        ValueKind.STRING to same(input = "string"),
+                    ),
+            )
+
+        /**
+         * Flatten the matrix of [Primitive] to [Primitive] to list of [ConversionExample]s into a
+         * list of [ConversionTest]s.
+         */
+        private val conversionTests = let {
+            // Make sure that every literal kind is used as the fromKind and targetKind.
+            val allKinds = ValueKind.LITERAL_KINDS
+
+            require(conversionMatrix.keys == allKinds) {
+                "Expected conversion from every one of $allKinds, but found ${conversionMatrix.keys}"
+            }
+            conversionMatrix.flatMap { (fromKind, targetMap) ->
+                require(targetMap.keys == allKinds) {
+                    "Expected conversion from $fromKind to every one of $allKinds, but found ${targetMap.keys}"
+                }
+
+                targetMap.flatMap { (targetKind, examples) ->
+                    examples.map { example -> ConversionTest(fromKind, targetKind, example) }
+                }
+            }
+        }
+
+        /** Supply the list of test cases as the parameters for this test class. */
+        @JvmStatic @Parameterized.Parameters(name = "{0}") fun params() = conversionTests
+    }
+
+    @Test
+    fun `conversion test`() {
+        conversionTest.runTest()
+    }
+}
diff --git a/metalava-model/src/test/java/com/android/tools/metalava/model/value/ParameterizedValueEqualityTest.kt b/metalava-model/src/test/java/com/android/tools/metalava/model/value/ParameterizedValueEqualityTest.kt
new file mode 100644
index 000000000..163013629
--- /dev/null
+++ b/metalava-model/src/test/java/com/android/tools/metalava/model/value/ParameterizedValueEqualityTest.kt
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.value
+
+import com.android.tools.metalava.model.testing.value.literalValue
+import kotlin.test.assertEquals
+import kotlin.test.assertNotEquals
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
+
+/** Tests for [Value.equals] and [Value.hashCode]. */
+@RunWith(Parameterized::class)
+class ParameterizedValueEqualityTest {
+    @Parameterized.Parameter(0) lateinit var equalityTest: EqualityTest
+
+    /**
+     * An equality test.
+     *
+     * @param value1 to compare.
+     * @param value2 to compare.
+     * @param equal true if [value1] and [value2] should compare equal, false otherwise.
+     */
+    class EqualityTest(
+        private val value1: Value,
+        private val value2: Value,
+        private val equal: Boolean,
+    ) {
+        private val operator
+            get() = if (equal) "==" else "!="
+
+        override fun toString() =
+            "${value1.kind}(${value1.toValueString()}) $operator ${value2.kind}(${value2.toValueString()})"
+
+        fun runTest() {
+            if (equal) {
+                assertEquals(value1, value2, message = "equality")
+
+                // If the values are equal then they hash codes must also be equal.
+                val hash1 = value1.hashCode()
+                val hash2 = value2.hashCode()
+                assertEquals(hash1, hash2, message = "hash code")
+            } else {
+                assertNotEquals(value1, value2)
+            }
+        }
+    }
+
+    companion object {
+        /** Create a pair of two different [LiteralValue]s. */
+        private fun <T : Any> differentLiterals(t1: T, t2: T) =
+            if (t1 == t2) error("$t1 and $t2 must be different")
+            else {
+                val l1 = literalValue(t1)
+                val l2 = literalValue(t2)
+                if (l1.kind != l2.kind) error("$l1 and $l2 must be of the same kind")
+                l1 to l2
+            }
+
+        /**
+         * Create a list of pairs of unequal [Value]s.
+         *
+         * This ensures that for every kind there is at least one value of the same kind which is
+         * different.
+         */
+        private val pairsOfUnequalValues =
+            listOf(
+                differentLiterals(true, false),
+                differentLiterals(Byte.MAX_VALUE, Byte.MIN_VALUE),
+                differentLiterals('a', 'b'),
+                differentLiterals(Double.NaN, 1.0),
+                differentLiterals(1001.5E99, -17.5),
+                differentLiterals(Float.NaN, 1.0f),
+                differentLiterals(745.67f, -93.4f),
+                differentLiterals(19, 10),
+                differentLiterals(100L, -100L),
+                differentLiterals(Short.MAX_VALUE, Short.MIN_VALUE),
+                differentLiterals("alpha", "beta")
+            )
+
+        /**
+         * Flatten the pairs into one list of [Value]s where each [Value] in the list is unequal to
+         * all the others.
+         */
+        private val allValues = pairsOfUnequalValues.flatMap { listOf(it.first, it.second) }
+
+        /**
+         * Create a list of [EqualityTest]s to run that test all possible combinations of the
+         * values.
+         */
+        private val equalityTests = buildList {
+            // Iterate over all the values twice, with indices.
+            for ((index1, value1) in allValues.withIndex()) {
+                for ((index2, value2) in allValues.withIndex()) {
+                    // Use the indices to tell if the values are the same, not equality of the
+                    // values as this is testing equality of values.
+                    if (index1 == index2) {
+                        // Each value must compare equal to itself.
+                        add(EqualityTest(value1, value1, equal = true))
+                    } else {
+                        // Each value must compare unequal to the others.
+                        add(EqualityTest(value1, value2, equal = false))
+                    }
+                }
+            }
+        }
+
+        /** Supply the list of equality tests as the parameters for this test class. */
+        @JvmStatic @Parameterized.Parameters(name = "{0}") fun params() = equalityTests
+    }
+
+    @Test
+    fun `equality test`() {
+        equalityTest.runTest()
+    }
+}
diff --git a/metalava-model/src/test/java/com/android/tools/metalava/model/value/ParameterizedValueStringTest.kt b/metalava-model/src/test/java/com/android/tools/metalava/model/value/ParameterizedValueStringTest.kt
new file mode 100644
index 000000000..388bf4843
--- /dev/null
+++ b/metalava-model/src/test/java/com/android/tools/metalava/model/value/ParameterizedValueStringTest.kt
@@ -0,0 +1,1139 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.value
+
+import com.android.tools.metalava.model.PrimitiveTypeItem.Primitive
+import com.android.tools.metalava.model.testing.arrayTypeItem
+import com.android.tools.metalava.model.testing.primitiveTypeForKind
+import com.android.tools.metalava.model.testing.stringType
+import com.android.tools.metalava.model.testing.value.annotationValue
+import com.android.tools.metalava.model.testing.value.annotationValueFromSource
+import com.android.tools.metalava.model.testing.value.arrayValue
+import com.android.tools.metalava.model.testing.value.arrayValueFromAny
+import com.android.tools.metalava.model.testing.value.classObjectValue
+import com.android.tools.metalava.model.testing.value.fieldReferenceValue
+import com.android.tools.metalava.model.testing.value.literalValue
+import com.android.tools.metalava.model.testing.value.primitiveValueForKind
+import com.android.tools.metalava.testing.EntryPoint
+import com.android.tools.metalava.testing.EntryPointCallerRule
+import com.android.tools.metalava.testing.EntryPointCallerTracker
+import com.android.tools.metalava.testing.ExitPoint
+import kotlin.test.assertEquals
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
+
+/** Tests for [Value.toValueString]. */
+@RunWith(Parameterized::class)
+class ParameterizedValueStringTest {
+    @Parameterized.Parameter(0) lateinit var testCase: TestCase
+
+    /**
+     * Will try and rewrite the stack trace of any test failures to refer to the location where the
+     * [testCase] that is currently being tested was created.
+     */
+    @get:Rule val entryPointCallerRule = EntryPointCallerRule { testCase.entryPointCallerTracker }
+
+    class TestCase(
+        /** The name of the test. */
+        private val name: String,
+
+        /** The value to test. */
+        private val value: Value,
+
+        /**
+         * The [LabelledConfig] whose [LabelledConfig.valueStringConfiguration] is passed to
+         * [Value.toValueString].
+         */
+        private val config: LabelledConfig,
+
+        /**
+         * The expected value returned from [Value.toValueString] when passed the
+         * [ValueStringConfiguration] from [config].
+         */
+        private val expectedValueString: String,
+
+        /**
+         * The expected value returned from [Value.toString] when passed the
+         * [ValueStringConfiguration] from [config].
+         */
+        private val expectedDebugString: String,
+    ) {
+        /**
+         * Record the stack trace of the creation of this which can be used to provide a stack trace
+         * to the creator of this instance in the event of a test failure.
+         */
+        val entryPointCallerTracker = EntryPointCallerTracker()
+
+        override fun toString() = name
+
+        /** Run the test. */
+        fun runTest() {
+            assertEquals(expectedValueString, value.toValueString(config.valueStringConfiguration))
+        }
+
+        /** Run the debug test. */
+        fun runDebugTest() {
+            @Suppress("DEPRECATION") assertEquals(expectedDebugString, value.debugStringForValue())
+        }
+    }
+
+    /**
+     * A wrapper around a [valueStringConfiguration] that adds a [label] for use in the
+     * [TestCase.name].
+     */
+    class LabelledConfig(
+        val label: String,
+        val valueStringConfiguration: ValueStringConfiguration
+    ) {
+        companion object {
+            val DEFAULT = LabelledConfig("default", ValueStringConfiguration.DEFAULT)
+
+            val ANNOTATION_ATTRIBUTE_NAME_VALUE_WITHOUT_SPACES =
+                LabelledConfig(
+                    "annotation-attribute-name-value-without-spaces",
+                    ValueStringConfiguration(
+                        annotationAttributeNameValueSeparator =
+                            AnnotationAttributeNameValueSeparator.WITHOUT_SPACES,
+                    )
+                )
+
+            val ANNOTATION_CLASS_RENAMER =
+                LabelledConfig(
+                    "annotation-class-renamer",
+                    ValueStringConfiguration(
+                        annotationQualifiedNameGetter = { annotationItem ->
+                            annotationItem.qualifiedName.replace(
+                                "android.annotation.",
+                                "androidx.annotation."
+                            )
+                        }
+                    )
+                )
+
+            val CLASS_OBJECT_VALUE_SOURCE =
+                LabelledConfig(
+                    "class-object-value-as-source",
+                    ValueStringConfiguration(classObjectValueFormat = ClassObjectValueFormat.SOURCE)
+                )
+
+            val NON_LITERAL_FLOAT_SUFFIX =
+                LabelledConfig(
+                    "non-literal-float-suffix",
+                    ValueStringConfiguration(nonLiteralFloatSuffix = 'F')
+                )
+
+            val NON_LITERAL_INT_HEX =
+                LabelledConfig(
+                    "non-literal-int-hex",
+                    ValueStringConfiguration(nonLiteralIntFormat = IntFormat.HEXADECIMAL)
+                )
+
+            val SHOW_KOTLIN_COMPANION_OBJECT =
+                LabelledConfig(
+                    "show-kotlin-companion-object",
+                    ValueStringConfiguration(showKotlinCompanionClass = true)
+                )
+
+            val SHOW_KOTLIN_CONVERSION_FUNCTION =
+                LabelledConfig(
+                    "show-kotlin-conversion-function",
+                    ValueStringConfiguration(showKotlinConversionFunction = true)
+                )
+
+            val SPECIAL_VALUES =
+                LabelledConfig(
+                    "special-values",
+                    ValueStringConfiguration(
+                        specialValues =
+                            mapOf(
+                                DoubleValue.NaN to "DoubleValue.NaN",
+                                DoubleValue.NEGATIVE_INFINITY to "DoubleValue.NEGATIVE_INFINITY",
+                                DoubleValue.POSITIVE_INFINITY to "DoubleValue.POSITIVE_INFINITY",
+                                FloatValue.NaN to "FloatValue.NaN",
+                                FloatValue.NEGATIVE_INFINITY to "FloatValue.NEGATIVE_INFINITY",
+                                FloatValue.POSITIVE_INFINITY to "FloatValue.POSITIVE_INFINITY",
+                                IntValue.MIN_VALUE to "Integer.MIN_VALUE",
+                                IntValue.MAX_VALUE to "Integer.MAX_VALUE",
+                            )
+                    ),
+                )
+
+            val USE_ORIGINAL_NUMBER =
+                LabelledConfig(
+                    "use-original-number",
+                    ValueStringConfiguration(
+                        useOriginalValueForNumbers = true,
+                    )
+                )
+
+            val USE_ORIGINAL_NUMBER_AND_NON_LITERAL_FLOAT_SUFFIX =
+                LabelledConfig(
+                    "use-original-number/non-literal-float-suffix",
+                    ValueStringConfiguration(
+                        nonLiteralFloatSuffix = 'F',
+                        useOriginalValueForNumbers = true,
+                    )
+                )
+
+            val USE_ORIGINAL_NUMBER_AND_NON_LITERAL_INT_HEX =
+                LabelledConfig(
+                    "use-original-number/non-literal-int-hex",
+                    ValueStringConfiguration(
+                        nonLiteralIntFormat = IntFormat.HEXADECIMAL,
+                        useOriginalValueForNumbers = true,
+                    )
+                )
+
+            val USE_ORIGINAL_NUMBER_UNWRAP_SINGLE_ARRAY_ELEMENT =
+                LabelledConfig(
+                    "use-original-number/unwrap",
+                    ValueStringConfiguration(
+                        useOriginalValueForNumbers = true,
+                        singleArrayElementFormat = SingleArrayElementFormat.UNWRAP,
+                    ),
+                )
+
+            val UNSORTED_ATTRIBUTES =
+                LabelledConfig(
+                    "unsorted",
+                    ValueStringConfiguration(sortAnnotationAttributes = false)
+                )
+
+            val UNWRAP_SINGLE_ARRAY_ELEMENT =
+                LabelledConfig(
+                    "unwrap",
+                    ValueStringConfiguration(
+                        singleArrayElementFormat = SingleArrayElementFormat.UNWRAP,
+                    )
+                )
+
+            val VALUE_LANGUAGE_KOTLIN =
+                LabelledConfig(
+                    "value-language-kotlin",
+                    ValueStringConfiguration(valueLanguage = ValueLanguage.KOTLIN)
+                )
+        }
+    }
+
+    companion object {
+        /**
+         * Create a [TestCase] for [value] with the [expectedDefaultValueString] and optionally
+         * invoke [body] to create additional [TestCase]s for the same [Value].
+         *
+         * @param expectedDefaultValueString The expected value returned from [Value.toValueString],
+         *   i.e. with [ValueStringConfiguration.DEFAULT].
+         * @param expectedDefaultDebugString The expected value returned from
+         *   [Value.debugStringForValue].
+         */
+        @EntryPoint
+        internal fun testCasesForValue(
+            valueLabel: String? = null,
+            value: Value,
+            expectedDefaultValueString: String,
+            expectedDefaultDebugString: String = expectedDefaultValueString,
+            body: (TestCaseBuilder.() -> Unit)? = null,
+        ) = buildList {
+            TestCaseBuilder(
+                    this,
+                    valueLabel,
+                    value,
+                    expectedDefaultValueString,
+                    expectedDefaultDebugString,
+                )
+                .let { builder ->
+                    builder.verifyConfigMatchesDefault(LabelledConfig.DEFAULT)
+                    if (body != null) {
+                        builder.buildTestCases(body)
+                    }
+                }
+        }
+
+        /**
+         * Builder for [TestCase]s.
+         *
+         * @param testCases the list of [TestCase]s to update.
+         * @param valueLabel the optional label to use if the [value]'s [Value.toValueString] is not
+         *   helpful.
+         * @param value the [Value] whose [Value.toValueString] is being tested.
+         * @param expectedDefaultValueString The expected value returned from
+         *   `Value.toValueString()`, i.e. with [ValueStringConfiguration.DEFAULT].
+         */
+        internal class TestCaseBuilder(
+            private val testCases: MutableList<TestCase>,
+            valueLabel: String? = null,
+            private val value: Value,
+            private val expectedDefaultValueString: String,
+            private val expectedDefaultDebugString: String,
+        ) {
+            private val prefix = "${value.kind},${valueLabel ?: value.toValueString()}"
+
+            private fun addTestCase(
+                config: LabelledConfig,
+                expectedValueString: String,
+                expectedDebugString: String,
+            ) {
+                testCases.add(
+                    TestCase(
+                        "$prefix,${config.label}",
+                        value,
+                        config,
+                        expectedValueString,
+                        expectedDebugString,
+                    )
+                )
+            }
+
+            /**
+             * Add a [TestCase] that verifies that passing [LabelledConfig.valueStringConfiguration]
+             * to [Value.toValueString] results in the same value as if the
+             * [ValueStringConfiguration.DEFAULT] was used, i.e. [expectedDefaultValueString].
+             */
+            @EntryPoint
+            fun verifyConfigMatchesDefault(config: LabelledConfig) {
+                addTestCase(
+                    config,
+                    expectedDefaultValueString,
+                    expectedDefaultDebugString,
+                )
+            }
+
+            /**
+             * Add a [TestCase] that verifies that passing [LabelledConfig.valueStringConfiguration]
+             * to [Value.toValueString] results in [expectedValueString].
+             */
+            @EntryPoint
+            fun verifyConfigChangesOutput(config: LabelledConfig, expectedValueString: String) {
+                // Changing the configuration should not affect the debug string.
+                addTestCase(config, expectedValueString, expectedDefaultDebugString)
+            }
+
+            /** Separated out as required by [ExitPoint]. */
+            @ExitPoint
+            fun buildTestCases(body: TestCaseBuilder.() -> Unit) {
+                body()
+            }
+        }
+
+        private val testCases =
+            listOf(
+                // ****************************** Annotations ******************************
+                testCasesForValue(
+                    value = annotationValueFromSource("@test.pkg.Anno"),
+                    expectedDefaultValueString = "@test.pkg.Anno",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.VALUE_LANGUAGE_KOTLIN,
+                        "test.pkg.Anno()"
+                    )
+
+                    verifyConfigMatchesDefault(
+                        LabelledConfig.ANNOTATION_ATTRIBUTE_NAME_VALUE_WITHOUT_SPACES
+                    )
+
+                    // Renaming android.annotation. to androidx.annotation does not affect this
+                    // annotation.
+                    verifyConfigMatchesDefault(LabelledConfig.ANNOTATION_CLASS_RENAMER)
+                },
+                testCasesForValue(
+                    value = annotationValueFromSource("@test.pkg.Anno(intValue = 1)"),
+                    expectedDefaultValueString = "@test.pkg.Anno(intValue = 1)",
+                    expectedDefaultDebugString = "@test.pkg.Anno(intValue = IntValue(1))",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.VALUE_LANGUAGE_KOTLIN,
+                        "test.pkg.Anno(intValue = 1)"
+                    )
+
+                    verifyConfigChangesOutput(
+                        LabelledConfig.ANNOTATION_ATTRIBUTE_NAME_VALUE_WITHOUT_SPACES,
+                        "@test.pkg.Anno(intValue=1)"
+                    )
+                },
+                testCasesForValue(
+                    // An annotation with an explicit value attribute
+                    value = annotationValueFromSource("@test.pkg.Anno(value = 1)"),
+                    expectedDefaultValueString = "@test.pkg.Anno(1)",
+                    expectedDefaultDebugString = "@test.pkg.Anno(IntValue(1))",
+                ) {
+                    verifyConfigMatchesDefault(
+                        LabelledConfig.ANNOTATION_ATTRIBUTE_NAME_VALUE_WITHOUT_SPACES
+                    )
+                },
+                testCasesForValue(
+                    // An annotation with an implicit value attribute
+                    value = annotationValueFromSource("@test.pkg.Anno(1)"),
+                    expectedDefaultValueString = "@test.pkg.Anno(1)",
+                    expectedDefaultDebugString = "@test.pkg.Anno(IntValue(1))",
+                ) {
+                    verifyConfigMatchesDefault(
+                        LabelledConfig.ANNOTATION_ATTRIBUTE_NAME_VALUE_WITHOUT_SPACES
+                    )
+                },
+                testCasesForValue(
+                    // An annotation with an explicit value attribute and another attribute.
+                    value = annotationValueFromSource("@test.pkg.Anno(value = 1, intValue = 3)"),
+                    expectedDefaultValueString = "@test.pkg.Anno(intValue = 3, value = 1)",
+                    expectedDefaultDebugString =
+                        "@test.pkg.Anno(intValue = IntValue(3), value = IntValue(1))",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.UNSORTED_ATTRIBUTES,
+                        "@test.pkg.Anno(value = 1, intValue = 3)"
+                    )
+
+                    verifyConfigChangesOutput(
+                        LabelledConfig.ANNOTATION_ATTRIBUTE_NAME_VALUE_WITHOUT_SPACES,
+                        "@test.pkg.Anno(intValue=3, value=1)"
+                    )
+                },
+                testCasesForValue(
+                    // Create an annotation with attribute in non-alphabetical order.
+                    value =
+                        annotationValueFromSource("@test.pkg.Anno(longValue = 1L, intValue = 1)"),
+                    expectedDefaultValueString = "@test.pkg.Anno(intValue = 1, longValue = 1L)",
+                    expectedDefaultDebugString =
+                        "@test.pkg.Anno(intValue = IntValue(1), longValue = LongValue(1L))",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.UNSORTED_ATTRIBUTES,
+                        "@test.pkg.Anno(longValue = 1L, intValue = 1)"
+                    )
+                },
+                testCasesForValue(
+                    value =
+                        annotationValue(
+                            "test.pkg.Anno",
+                            "nested" to annotationValueFromSource("@other.pkg.OtherAnno")
+                        ),
+                    expectedDefaultValueString = "@test.pkg.Anno(nested = @other.pkg.OtherAnno)",
+                    expectedDefaultDebugString =
+                        "@test.pkg.Anno(nested = AnnotationValue(@other.pkg.OtherAnno))",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.VALUE_LANGUAGE_KOTLIN,
+                        "test.pkg.Anno(nested = other.pkg.OtherAnno())"
+                    )
+                },
+                testCasesForValue(
+                    value =
+                        annotationValue(
+                            "android.annotation.Test",
+                            "nested" to annotationValue("android.annotation.Nested"),
+                        ),
+                    expectedDefaultValueString =
+                        "@android.annotation.Test(nested = @android.annotation.Nested)",
+                    expectedDefaultDebugString =
+                        "@android.annotation.Test(nested = AnnotationValue(@android.annotation.Nested))",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.ANNOTATION_CLASS_RENAMER,
+                        "@androidx.annotation.Test(nested = @androidx.annotation.Nested)"
+                    )
+                },
+                // ********************************* Arrays *********************************
+                testCasesForValue(
+                    value = arrayValueFromAny(),
+                    expectedDefaultValueString = "{}",
+                ) {
+                    verifyConfigMatchesDefault(LabelledConfig.UNWRAP_SINGLE_ARRAY_ELEMENT)
+                },
+                testCasesForValue(
+                    valueLabel = "single integer",
+                    value = arrayValueFromAny(1),
+                    expectedDefaultValueString = "{1}",
+                    expectedDefaultDebugString = "{IntValue(1)}",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.UNWRAP_SINGLE_ARRAY_ELEMENT,
+                        expectedValueString = "1",
+                    )
+                },
+                testCasesForValue(
+                    valueLabel = "single string",
+                    value = arrayValueFromAny("single"),
+                    expectedDefaultValueString = "{\"single\"}",
+                    expectedDefaultDebugString = "{StringValue(\"single\")}",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.UNWRAP_SINGLE_ARRAY_ELEMENT,
+                        expectedValueString = "\"single\"",
+                    )
+                },
+                testCasesForValue(
+                    valueLabel = "integers",
+                    value = arrayValueFromAny(1, 2, 3),
+                    expectedDefaultValueString = "{1, 2, 3}",
+                    expectedDefaultDebugString = "{IntValue(1), IntValue(2), IntValue(3)}",
+                ) {
+                    verifyConfigMatchesDefault(LabelledConfig.UNWRAP_SINGLE_ARRAY_ELEMENT)
+                },
+                testCasesForValue(
+                    valueLabel = "strings",
+                    value = arrayValueFromAny("first", "second", "third"),
+                    expectedDefaultValueString = "{\"first\", \"second\", \"third\"}",
+                    expectedDefaultDebugString =
+                        "{StringValue(\"first\"), StringValue(\"second\"), StringValue(\"third\")}",
+                ) {
+                    verifyConfigMatchesDefault(LabelledConfig.UNWRAP_SINGLE_ARRAY_ELEMENT)
+                },
+                testCasesForValue(
+                    valueLabel = "array of long as int",
+                    value = arrayValue(primitiveValueForKind(Primitive.LONG, 3)),
+                    expectedDefaultValueString = "{3L}",
+                    expectedDefaultDebugString = "{LongValue(3L,asInt)}",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.USE_ORIGINAL_NUMBER_UNWRAP_SINGLE_ARRAY_ELEMENT,
+                        expectedValueString = "3",
+                    )
+                },
+                // ********************************* Booleans *********************************
+                testCasesForValue(
+                    value = literalValue(true),
+                    expectedDefaultValueString = "true",
+                ),
+                testCasesForValue(
+                    value = literalValue(false),
+                    expectedDefaultValueString = "false",
+                ),
+                // ********************************* Bytes *********************************
+                testCasesForValue(
+                    value = literalValue(0.toByte()),
+                    expectedDefaultValueString = "0",
+                ),
+                testCasesForValue(
+                    value = literalValue(Byte.MAX_VALUE),
+                    expectedDefaultValueString = "127",
+                ),
+                testCasesForValue(
+                    value = literalValue(Byte.MIN_VALUE),
+                    expectedDefaultValueString = "-128",
+                    expectedDefaultDebugString = "-128,nonLiteral",
+                ),
+                testCasesForValue(
+                    "byte as int",
+                    value = primitiveValueForKind(Primitive.BYTE, 10),
+                    expectedDefaultValueString = "10",
+                    expectedDefaultDebugString = "10,asInt",
+                ) {
+                    verifyConfigMatchesDefault(LabelledConfig.USE_ORIGINAL_NUMBER)
+
+                    // Even when treating this as an int it should not be formatted using
+                    // hexadecimal because it was not a non-literal.
+                    verifyConfigMatchesDefault(
+                        LabelledConfig.USE_ORIGINAL_NUMBER_AND_NON_LITERAL_INT_HEX
+                    )
+                },
+                testCasesForValue(
+                    "byte as non-literal int",
+                    value = primitiveValueForKind(Primitive.BYTE, -20),
+                    expectedDefaultValueString = "-20",
+                    expectedDefaultDebugString = "-20,asInt,nonLiteral",
+                ) {
+                    verifyConfigMatchesDefault(LabelledConfig.USE_ORIGINAL_NUMBER)
+
+                    // When treating this as an int it should be formatted using hexadecimal because
+                    // it was a non-literal.
+                    verifyConfigChangesOutput(
+                        LabelledConfig.USE_ORIGINAL_NUMBER_AND_NON_LITERAL_INT_HEX,
+                        expectedValueString = "0xffffffec"
+                    )
+                },
+                // ********************************* Chars *********************************
+                testCasesForValue(
+                    value = literalValue('a'),
+                    expectedDefaultValueString = "'a'",
+                ),
+                testCasesForValue(
+                    value = literalValue('\t'),
+                    expectedDefaultValueString = "'\\t'",
+                ),
+                testCasesForValue(
+                    value = literalValue('\n'),
+                    expectedDefaultValueString = "'\\n'",
+                ),
+                testCasesForValue(
+                    value = literalValue('\u1245'),
+                    expectedDefaultValueString = "'\\u1245'",
+                ),
+                // ********************************* Classes *********************************
+                testCasesForValue(
+                    value = classObjectValue(primitiveTypeForKind(Primitive.VOID)),
+                    expectedDefaultValueString = "void.class",
+                ),
+                testCasesForValue(
+                    value = classObjectValue(primitiveTypeForKind(Primitive.INT)),
+                    expectedDefaultValueString = "int.class",
+                ),
+                testCasesForValue(
+                    value = classObjectValue(stringType()),
+                    expectedDefaultValueString = "java.lang.String.class",
+                ),
+                testCasesForValue(
+                    value =
+                        classObjectValue(
+                            arrayTypeItem(primitiveTypeForKind(Primitive.INT)),
+                            sourceExpression = "IntArray::class"
+                        ),
+                    expectedDefaultValueString = "int[].class",
+                ) {
+                    // The value being tested has a source expression so this configuration will
+                    // produce a different result than the default.
+                    verifyConfigChangesOutput(
+                        LabelledConfig.CLASS_OBJECT_VALUE_SOURCE,
+                        "IntArray::class"
+                    )
+                },
+                testCasesForValue(
+                    value = classObjectValue(arrayTypeItem(arrayTypeItem(stringType()))),
+                    expectedDefaultValueString = "java.lang.String[][].class",
+                ) {
+                    // The value being tested does not have a source expression so this
+                    // configuration will not produce a different result than the default.
+                    verifyConfigMatchesDefault(LabelledConfig.CLASS_OBJECT_VALUE_SOURCE)
+                },
+                // ****************************** Constant Fields ******************************
+                testCasesForValue(
+                    value = fieldReferenceValue("test.pkg.AClass", "FIELD"),
+                    expectedDefaultValueString = "test.pkg.AClass.FIELD",
+                ) {
+                    verifyConfigMatchesDefault(LabelledConfig.SHOW_KOTLIN_COMPANION_OBJECT)
+                    verifyConfigMatchesDefault(LabelledConfig.SHOW_KOTLIN_CONVERSION_FUNCTION)
+                },
+                testCasesForValue(
+                    value = fieldReferenceValue("test.pkg.AClass", "FIELD", literalValue(2)),
+                    expectedDefaultValueString = "test.pkg.AClass.FIELD",
+                ),
+                testCasesForValue(
+                    value =
+                        fieldReferenceValue(
+                            "test.pkg.AClass",
+                            "FIELD",
+                            kotlinCompanionClass = "test.pkg.AClass.Companion",
+                        ),
+                    expectedDefaultValueString = "test.pkg.AClass.FIELD",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.SHOW_KOTLIN_COMPANION_OBJECT,
+                        "test.pkg.AClass.Companion.FIELD"
+                    )
+                },
+                testCasesForValue(
+                    value =
+                        fieldReferenceValue(
+                            "test.pkg.AClass",
+                            "FIELD",
+                            explicitConversionTo = Primitive.BYTE,
+                        ),
+                    expectedDefaultValueString = "test.pkg.AClass.FIELD",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.SHOW_KOTLIN_CONVERSION_FUNCTION,
+                        "test.pkg.AClass.FIELD.toByte()"
+                    )
+                },
+                testCasesForValue(
+                    value =
+                        fieldReferenceValue(
+                            "test.pkg.AClass",
+                            "FIELD",
+                            explicitConversionTo = Primitive.DOUBLE,
+                        ),
+                    expectedDefaultValueString = "test.pkg.AClass.FIELD",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.SHOW_KOTLIN_CONVERSION_FUNCTION,
+                        "test.pkg.AClass.FIELD.toDouble()"
+                    )
+                },
+                testCasesForValue(
+                    value =
+                        fieldReferenceValue(
+                            "test.pkg.AClass",
+                            "FIELD",
+                            explicitConversionTo = Primitive.FLOAT,
+                        ),
+                    expectedDefaultValueString = "test.pkg.AClass.FIELD",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.SHOW_KOTLIN_CONVERSION_FUNCTION,
+                        "test.pkg.AClass.FIELD.toFloat()"
+                    )
+                },
+                testCasesForValue(
+                    value =
+                        fieldReferenceValue(
+                            "test.pkg.AClass",
+                            "FIELD",
+                            explicitConversionTo = Primitive.INT,
+                        ),
+                    expectedDefaultValueString = "test.pkg.AClass.FIELD",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.SHOW_KOTLIN_CONVERSION_FUNCTION,
+                        "test.pkg.AClass.FIELD.toInt()"
+                    )
+                },
+                testCasesForValue(
+                    value =
+                        fieldReferenceValue(
+                            "test.pkg.AClass",
+                            "FIELD",
+                            explicitConversionTo = Primitive.LONG,
+                        ),
+                    expectedDefaultValueString = "test.pkg.AClass.FIELD",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.SHOW_KOTLIN_CONVERSION_FUNCTION,
+                        "test.pkg.AClass.FIELD.toLong()"
+                    )
+                },
+                testCasesForValue(
+                    value =
+                        fieldReferenceValue(
+                            "test.pkg.AClass",
+                            "FIELD",
+                            explicitConversionTo = Primitive.SHORT,
+                        ),
+                    expectedDefaultValueString = "test.pkg.AClass.FIELD",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.SHOW_KOTLIN_CONVERSION_FUNCTION,
+                        "test.pkg.AClass.FIELD.toShort()"
+                    )
+                },
+                // ********************************* Doubles *********************************
+                testCasesForValue(
+                    value = literalValue(0.0),
+                    expectedDefaultValueString = "0.0",
+                ) {
+                    verifyConfigMatchesDefault(LabelledConfig.SPECIAL_VALUES)
+
+                    verifyConfigMatchesDefault(LabelledConfig.USE_ORIGINAL_NUMBER)
+                },
+                testCasesForValue(
+                    value = literalValue(Double.MAX_VALUE),
+                    expectedDefaultValueString = "1.7976931348623157E308",
+                ),
+                testCasesForValue(
+                    value = literalValue(Double.MIN_VALUE),
+                    expectedDefaultValueString = "4.9E-324",
+                ),
+                testCasesForValue(
+                    value = literalValue(Double.NaN),
+                    expectedDefaultValueString = "(0.0/0.0)",
+                    expectedDefaultDebugString = "(0.0/0.0),nonLiteral",
+                ) {
+                    verifyConfigChangesOutput(LabelledConfig.SPECIAL_VALUES, "DoubleValue.NaN")
+                },
+                testCasesForValue(
+                    value = literalValue(Double.NEGATIVE_INFINITY),
+                    expectedDefaultValueString = "(-1.0/0.0)",
+                    expectedDefaultDebugString = "(-1.0/0.0),nonLiteral",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.SPECIAL_VALUES,
+                        "DoubleValue.NEGATIVE_INFINITY"
+                    )
+                },
+                testCasesForValue(
+                    value = literalValue(Double.POSITIVE_INFINITY),
+                    expectedDefaultValueString = "(1.0/0.0)",
+                    expectedDefaultDebugString = "(1.0/0.0),nonLiteral",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.SPECIAL_VALUES,
+                        "DoubleValue.POSITIVE_INFINITY"
+                    )
+                },
+                testCasesForValue(
+                    "double as int",
+                    value = primitiveValueForKind(Primitive.DOUBLE, 3),
+                    expectedDefaultValueString = "3.0",
+                    expectedDefaultDebugString = "3.0,asInt",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.USE_ORIGINAL_NUMBER,
+                        expectedValueString = "3",
+                    )
+
+                    // Even when treating this as an int it should not be formatted using
+                    // hexadecimal because it was not a non-literal.
+                    verifyConfigChangesOutput(
+                        LabelledConfig.USE_ORIGINAL_NUMBER_AND_NON_LITERAL_INT_HEX,
+                        expectedValueString = "3"
+                    )
+                },
+                testCasesForValue(
+                    "double as non-literal int",
+                    value =
+                        primitiveValueForKind(
+                            Primitive.DOUBLE,
+                            -7,
+                            nonLiteralInSource = true,
+                        ),
+                    expectedDefaultValueString = "-7.0",
+                    expectedDefaultDebugString = "-7.0,asInt,nonLiteral",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.USE_ORIGINAL_NUMBER,
+                        expectedValueString = "-7",
+                    )
+
+                    // When treating this as an int it should be formatted using hexadecimal because
+                    // it was a non-literal.
+                    verifyConfigChangesOutput(
+                        LabelledConfig.USE_ORIGINAL_NUMBER_AND_NON_LITERAL_INT_HEX,
+                        expectedValueString = "0xfffffff9"
+                    )
+                },
+                testCasesForValue(
+                    "double as float",
+                    value = primitiveValueForKind(Primitive.DOUBLE, 3.0f),
+                    expectedDefaultValueString = "3.0",
+                    expectedDefaultDebugString = "3.0,asFloat",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.USE_ORIGINAL_NUMBER,
+                        expectedValueString = "3.0f",
+                    )
+
+                    // Even when treating this as a float it should not be formatted using the
+                    // non-literal float suffix because it was not a non-literal.
+                    verifyConfigChangesOutput(
+                        LabelledConfig.USE_ORIGINAL_NUMBER_AND_NON_LITERAL_FLOAT_SUFFIX,
+                        expectedValueString = "3.0f"
+                    )
+                },
+                testCasesForValue(
+                    "double as non-literal float",
+                    value =
+                        primitiveValueForKind(
+                            Primitive.DOUBLE,
+                            -7.0f,
+                            nonLiteralInSource = true,
+                        ),
+                    expectedDefaultValueString = "-7.0",
+                    expectedDefaultDebugString = "-7.0,asFloat,nonLiteral",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.USE_ORIGINAL_NUMBER,
+                        expectedValueString = "-7.0f",
+                    )
+
+                    // When treating this as a float it should be formatted using the non-literal
+                    // float suffix because it was a non-literal.
+                    verifyConfigChangesOutput(
+                        LabelledConfig.USE_ORIGINAL_NUMBER_AND_NON_LITERAL_FLOAT_SUFFIX,
+                        expectedValueString = "-7.0F"
+                    )
+                },
+                // ********************************* Enum *********************************
+                testCasesForValue(
+                    value = fieldReferenceValue("test.pkg.EnumClass", "VALUE1"),
+                    expectedDefaultValueString = "test.pkg.EnumClass.VALUE1",
+                ),
+                // ********************************* Floats *********************************
+                testCasesForValue(
+                    value = literalValue(0.0f),
+                    expectedDefaultValueString = "0.0f",
+                ) {
+                    verifyConfigMatchesDefault(LabelledConfig.SPECIAL_VALUES)
+
+                    verifyConfigMatchesDefault(LabelledConfig.USE_ORIGINAL_NUMBER)
+                },
+                testCasesForValue(
+                    value = literalValue(Float.MAX_VALUE),
+                    expectedDefaultValueString = "3.4028235E38f",
+                ),
+                testCasesForValue(
+                    value = literalValue(Float.MIN_VALUE),
+                    expectedDefaultValueString = "1.4E-45f",
+                ) {
+                    verifyConfigMatchesDefault(LabelledConfig.NON_LITERAL_FLOAT_SUFFIX)
+                },
+                testCasesForValue(
+                    value = literalValue(-1.4f),
+                    expectedDefaultValueString = "-1.4f",
+                    expectedDefaultDebugString = "-1.4f,nonLiteral",
+                ) {
+                    verifyConfigChangesOutput(LabelledConfig.NON_LITERAL_FLOAT_SUFFIX, "-1.4F")
+                },
+                testCasesForValue(
+                    value = literalValue(7.9f, nonLiteralInSource = true),
+                    expectedDefaultValueString = "7.9f",
+                    expectedDefaultDebugString = "7.9f,nonLiteral",
+                ) {
+                    verifyConfigChangesOutput(LabelledConfig.NON_LITERAL_FLOAT_SUFFIX, "7.9F")
+                },
+                testCasesForValue(
+                    value = literalValue(Float.NaN),
+                    expectedDefaultValueString = "(0.0f/0.0f)",
+                    expectedDefaultDebugString = "(0.0f/0.0f),nonLiteral",
+                ) {
+                    verifyConfigChangesOutput(LabelledConfig.SPECIAL_VALUES, "FloatValue.NaN")
+                },
+                testCasesForValue(
+                    value = literalValue(Float.NEGATIVE_INFINITY),
+                    expectedDefaultValueString = "(-1.0f/0.0f)",
+                    expectedDefaultDebugString = "(-1.0f/0.0f),nonLiteral",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.SPECIAL_VALUES,
+                        "FloatValue.NEGATIVE_INFINITY"
+                    )
+                },
+                testCasesForValue(
+                    value = literalValue(Float.POSITIVE_INFINITY),
+                    expectedDefaultValueString = "(1.0f/0.0f)",
+                    expectedDefaultDebugString = "(1.0f/0.0f),nonLiteral",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.SPECIAL_VALUES,
+                        "FloatValue.POSITIVE_INFINITY"
+                    )
+                },
+                testCasesForValue(
+                    "float as int",
+                    value = primitiveValueForKind(Primitive.FLOAT, 3),
+                    expectedDefaultValueString = "3.0f",
+                    expectedDefaultDebugString = "3.0f,asInt",
+                ) {
+                    verifyConfigChangesOutput(LabelledConfig.USE_ORIGINAL_NUMBER, "3")
+
+                    // Even when treating this as an int it should not be formatted using
+                    // hexadecimal because it was not a non-literal.
+                    verifyConfigChangesOutput(
+                        LabelledConfig.USE_ORIGINAL_NUMBER_AND_NON_LITERAL_INT_HEX,
+                        expectedValueString = "3"
+                    )
+                },
+                testCasesForValue(
+                    "float as non-literal int",
+                    value =
+                        primitiveValueForKind(
+                            Primitive.FLOAT,
+                            -7,
+                            nonLiteralInSource = true,
+                        ),
+                    expectedDefaultValueString = "-7.0f",
+                    expectedDefaultDebugString = "-7.0f,asInt,nonLiteral",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.USE_ORIGINAL_NUMBER,
+                        expectedValueString = "-7",
+                    )
+
+                    // When treating this as an int it should be formatted using hexadecimal because
+                    // it was a non-literal.
+                    verifyConfigChangesOutput(
+                        LabelledConfig.USE_ORIGINAL_NUMBER_AND_NON_LITERAL_INT_HEX,
+                        expectedValueString = "0xfffffff9"
+                    )
+                },
+                // This checks the behavior of a Psi edge case where, due to the way that it
+                // emulates special (i.e. NaN, infinity) floating values from class constant pool as
+                // divide-by-zero expressions, the Float special values are represented as Double
+                // special values. This makes sure that they are treated as if they were floats.
+                testCasesForValue(
+                    valueLabel = "Double.NaN for float",
+                    value = primitiveValueForKind(Primitive.FLOAT, Double.NaN),
+                    expectedDefaultValueString = "(0.0f/0.0f)",
+                    expectedDefaultDebugString = "(0.0f/0.0f),nonLiteral",
+                ),
+                // This should never happen in practice as it is impossible to assign a double to a
+                // float without casting it, in which case it is no longer a float. However, Psi
+                // does not strictly follow the rules so it is possible that this may happen somehow
+                // and it is best to be prepared.
+                testCasesForValue(
+                    value = primitiveValueForKind(Primitive.FLOAT, 10.0),
+                    expectedDefaultValueString = "10.0f",
+                    expectedDefaultDebugString = "10.0f,!asFloat",
+                ),
+                // ********************************* Ints *********************************
+                testCasesForValue(
+                    value = literalValue(0),
+                    expectedDefaultValueString = "0",
+                ) {
+                    verifyConfigMatchesDefault(LabelledConfig.NON_LITERAL_INT_HEX)
+
+                    verifyConfigMatchesDefault(LabelledConfig.SPECIAL_VALUES)
+                },
+                testCasesForValue(
+                    value = IntValue.MAX_VALUE,
+                    expectedDefaultValueString = "2147483647",
+                ) {
+                    verifyConfigMatchesDefault(LabelledConfig.NON_LITERAL_INT_HEX)
+
+                    verifyConfigChangesOutput(LabelledConfig.SPECIAL_VALUES, "Integer.MAX_VALUE")
+                },
+                testCasesForValue(
+                    value = IntValue.MIN_VALUE,
+                    expectedDefaultValueString = "-2147483648",
+                    expectedDefaultDebugString = "-2147483648,nonLiteral",
+                ) {
+                    // Negative ints are considered as being a unary minus expression of the
+                    // absolute value.
+                    verifyConfigChangesOutput(LabelledConfig.NON_LITERAL_INT_HEX, "0x80000000")
+
+                    verifyConfigChangesOutput(LabelledConfig.SPECIAL_VALUES, "Integer.MIN_VALUE")
+                },
+                testCasesForValue(
+                    value = literalValue(892536243, nonLiteralInSource = true),
+                    expectedDefaultValueString = "892536243",
+                    expectedDefaultDebugString = "892536243,nonLiteral",
+                ) {
+                    verifyConfigChangesOutput(LabelledConfig.NON_LITERAL_INT_HEX, "0x353305b3")
+                },
+                // This should never happen in practice as it is impossible to assign a long to an
+                // int without casting it, in which case it is no longer an int. However, Psi does
+                // not strictly follow the rules so it is possible that this may happen somehow and
+                // it is best to be prepared.
+                testCasesForValue(
+                    value = primitiveValueForKind(Primitive.INT, 10L),
+                    expectedDefaultValueString = "10",
+                    expectedDefaultDebugString = "10,!asInt",
+                ),
+                // ********************************* Longs *********************************
+                testCasesForValue(
+                    value = literalValue(0L),
+                    expectedDefaultValueString = "0L",
+                ) {
+                    verifyConfigMatchesDefault(LabelledConfig.USE_ORIGINAL_NUMBER)
+                },
+                testCasesForValue(
+                    value = literalValue(Long.MAX_VALUE),
+                    expectedDefaultValueString = "9223372036854775807L",
+                ),
+                testCasesForValue(
+                    value = literalValue(Long.MIN_VALUE),
+                    expectedDefaultValueString = "-9223372036854775808L",
+                    expectedDefaultDebugString = "-9223372036854775808L,nonLiteral",
+                ),
+                testCasesForValue(
+                    "long as int",
+                    value = primitiveValueForKind(Primitive.LONG, 3),
+                    expectedDefaultValueString = "3L",
+                    expectedDefaultDebugString = "3L,asInt",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.USE_ORIGINAL_NUMBER,
+                        expectedValueString = "3",
+                    )
+
+                    // Even when treating this as an int it should not be formatted using
+                    // hexadecimal because it was not a non-literal.
+                    verifyConfigChangesOutput(
+                        LabelledConfig.USE_ORIGINAL_NUMBER_AND_NON_LITERAL_INT_HEX,
+                        expectedValueString = "3",
+                    )
+                },
+                testCasesForValue(
+                    "long as non-literal int",
+                    value = primitiveValueForKind(Primitive.LONG, -37),
+                    expectedDefaultValueString = "-37L",
+                    expectedDefaultDebugString = "-37L,asInt,nonLiteral",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.USE_ORIGINAL_NUMBER,
+                        expectedValueString = "-37",
+                    )
+
+                    // When treating this as an int it should be formatted using hexadecimal because
+                    // it was a non-literal.
+                    verifyConfigChangesOutput(
+                        LabelledConfig.USE_ORIGINAL_NUMBER_AND_NON_LITERAL_INT_HEX,
+                        expectedValueString = "0xffffffdb"
+                    )
+                },
+                // ********************************* Shorts *********************************
+                testCasesForValue(
+                    value = literalValue(0.toShort()),
+                    expectedDefaultValueString = "0",
+                ),
+                testCasesForValue(
+                    value = literalValue(Short.MAX_VALUE),
+                    expectedDefaultValueString = "32767",
+                ),
+                testCasesForValue(
+                    value = literalValue(Short.MIN_VALUE),
+                    expectedDefaultValueString = "-32768",
+                    expectedDefaultDebugString = "-32768,nonLiteral",
+                ),
+                testCasesForValue(
+                    "short as int",
+                    value = primitiveValueForKind(Primitive.SHORT, 3),
+                    expectedDefaultValueString = "3",
+                    expectedDefaultDebugString = "3,asInt",
+                ) {
+                    verifyConfigMatchesDefault(LabelledConfig.USE_ORIGINAL_NUMBER)
+
+                    // Even when treating this as an int it should not be formatted using
+                    // hexadecimal because it was not a non-literal.
+                    verifyConfigMatchesDefault(
+                        LabelledConfig.USE_ORIGINAL_NUMBER_AND_NON_LITERAL_INT_HEX
+                    )
+                },
+                testCasesForValue(
+                    "short as non-literal int",
+                    value = primitiveValueForKind(Primitive.SHORT, -111),
+                    expectedDefaultValueString = "-111",
+                    expectedDefaultDebugString = "-111,asInt,nonLiteral",
+                ) {
+                    verifyConfigChangesOutput(
+                        LabelledConfig.USE_ORIGINAL_NUMBER,
+                        expectedValueString = "-111",
+                    )
+
+                    // When treating this as an int it should be formatted using hexadecimal because
+                    // it was a non-literal.
+                    verifyConfigChangesOutput(
+                        LabelledConfig.USE_ORIGINAL_NUMBER_AND_NON_LITERAL_INT_HEX,
+                        expectedValueString = "0xffffff91"
+                    )
+                },
+                // ********************************* Strings *********************************
+                testCasesForValue(
+                    value = literalValue("string"),
+                    expectedDefaultValueString = "\"string\"",
+                ),
+                testCasesForValue(
+                    value = literalValue("str\ting\n"),
+                    expectedDefaultValueString = "\"str\\ting\\n\"",
+                ),
+                testCasesForValue(
+                    value = literalValue("str\u89EFing"),
+                    expectedDefaultValueString = "\"str\\u89efing\"",
+                ),
+            )
+
+        /** Supply the list of creation tests as the parameters for this test class. */
+        @JvmStatic @Parameterized.Parameters(name = "{0}") fun params() = testCases.flatten()
+    }
+
+    @Test
+    fun `toValueString test`() {
+        testCase.runTest()
+    }
+
+    @Test
+    fun `toString test`() {
+        testCase.runDebugTest()
+    }
+}
diff --git a/metalava-model/src/test/java/com/android/tools/metalava/model/value/ValueFactoryTest.kt b/metalava-model/src/test/java/com/android/tools/metalava/model/value/ValueFactoryTest.kt
new file mode 100644
index 000000000..59b137e99
--- /dev/null
+++ b/metalava-model/src/test/java/com/android/tools/metalava/model/value/ValueFactoryTest.kt
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tools.metalava.model.value
+
+import com.android.tools.metalava.model.testing.arrayTypeItem
+import com.android.tools.metalava.model.testing.classTypeItem
+import com.android.tools.metalava.model.testing.stringType
+import com.android.tools.metalava.model.testing.value.arrayValue
+import com.android.tools.metalava.model.testing.value.arrayValueFromAny
+import com.android.tools.metalava.model.testing.value.classObjectValue
+import com.android.tools.metalava.model.testing.value.fieldReferenceValue
+import com.android.tools.metalava.model.testing.value.literalValue
+import com.android.tools.metalava.model.testing.variableTypeItem
+import com.android.tools.metalava.model.testing.wildcardTypeItem
+import kotlin.test.assertEquals
+import kotlin.test.assertSame
+import org.junit.Assert.assertThrows
+import org.junit.Test
+
+/**
+ * Tests [ValueFactory] behavior that is not covered by the other parameterized tests that test
+ * different aspects of this.
+ */
+class ValueFactoryTest {
+    @Test
+    fun `createLiteralValue - no type item - invalid underlyingValue`() {
+        val exception =
+            assertThrows(IllegalStateException::class.java) {
+                Value.createLiteralValue(null, ValueFactoryTest::class.java)
+            }
+
+        assertEquals(
+            "Underlying value 'class com.android.tools.metalava.model.value.ValueFactoryTest' of class java.lang.Class is not supported",
+            exception.message
+        )
+    }
+
+    @Test
+    fun `createArrayValue - empty`() {
+        val firstEmpty = Value.createArrayValue(emptyList())
+        val secondEmpty = arrayValueFromAny()
+        assertSame(firstEmpty, secondEmpty)
+    }
+
+    @Test
+    fun `createArrayValue - mixture of kinds`() {
+        val exception =
+            assertThrows(IllegalStateException::class.java) {
+                arrayValueFromAny(1, 1.0f, 2, 3.0, "text")
+            }
+
+        assertEquals(
+            """
+                Expected array elements to be all of the same kind but found 4 different kinds of value:
+                    int -> IntValue(1), IntValue(2)
+                    float -> FloatValue(1.0f)
+                    double -> DoubleValue(3.0)
+                    string -> StringValue("text")
+            """
+                .trimIndent(),
+            exception.message?.trimEnd()
+        )
+    }
+
+    @Test
+    fun `createArrayValue - mixture of one kind plus field`() {
+        val arrayValue =
+            arrayValue(
+                literalValue("text"),
+                fieldReferenceValue("test.pkg.Foo", "FIELD"),
+            )
+
+        assertEquals("{\"text\", test.pkg.Foo.FIELD}", arrayValue.toValueString())
+    }
+
+    @Test
+    fun `createClassObjectValue - invalid variable type`() {
+        val exception =
+            assertThrows(IllegalStateException::class.java) {
+                classObjectValue(variableTypeItem("T"))
+            }
+
+        assertEquals("'T' is an invalid type for a class object value", exception.message)
+    }
+
+    @Test
+    fun `createClassObjectValue - array of invalid variable type`() {
+        val exception =
+            assertThrows(IllegalStateException::class.java) {
+                classObjectValue(arrayTypeItem(variableTypeItem("T")))
+            }
+
+        assertEquals("'T' is an invalid type for a class object value", exception.message)
+    }
+
+    @Test
+    fun `createClassObjectValue - invalid wildcard type`() {
+        val exception =
+            assertThrows(IllegalStateException::class.java) { classObjectValue(wildcardTypeItem()) }
+
+        assertEquals("'?' is an invalid type for a class object value", exception.message)
+    }
+
+    @Test
+    fun `createClassObjectValue - invalid class arguments`() {
+        val exception =
+            assertThrows(IllegalStateException::class.java) {
+                classObjectValue(classTypeItem("java.util.List", arguments = listOf(stringType())))
+            }
+
+        assertEquals(
+            "'java.util.List<java.lang.String>' is an invalid type for a class object value as it has type arguments",
+            exception.message
+        )
+    }
+}
diff --git a/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/Assertions.kt b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/Assertions.kt
index ea5670563..5b4e3cdf9 100644
--- a/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/Assertions.kt
+++ b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/Assertions.kt
@@ -204,7 +204,11 @@ interface Assertions {
     /** Get the [AnnotationAttribute] from the [AnnotationItem], failing if it does not exist. */
     fun AnnotationItem.assertAttribute(name: String): AnnotationAttribute {
         val attribute = findAttribute(name)
-        assertNotNull(attribute, message = "Expected $this to contain attribute $name")
+        assertNotNull(
+            attribute,
+            message =
+                "Expected ${this.qualifiedName} to contain attribute $name but found ${attributes.joinToString { it.name }}"
+        )
         return attribute
     }
 
diff --git a/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/junit4/CustomizableParameterizedRunner.kt b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/junit4/CustomizableParameterizedRunner.kt
index 5532e4c06..b125df8ac 100644
--- a/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/junit4/CustomizableParameterizedRunner.kt
+++ b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/junit4/CustomizableParameterizedRunner.kt
@@ -97,8 +97,7 @@ abstract class CustomizableParameterizedRunner<A : Any>(
             val parametersMethod =
                 testClass.getAnnotatedMethods(Parameters::class.java).firstOrNull {
                     it.isPublic && it.isStatic
-                }
-                    ?: return null
+                } ?: return null
             return when (val parameters = parametersMethod.invokeExplosively(null)) {
                     is List<*> -> parameters
                     is Iterable<*> -> parameters.toList()
diff --git a/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/testing/TestableTypeItem.kt b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/testing/TestableTypeItem.kt
index 796848b3e..e74425048 100644
--- a/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/testing/TestableTypeItem.kt
+++ b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/testing/TestableTypeItem.kt
@@ -16,8 +16,26 @@
 
 package com.android.tools.metalava.model.testing
 
+import com.android.tools.metalava.model.ArrayTypeItem
+import com.android.tools.metalava.model.ClassResolver
+import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.DefaultModifierList
+import com.android.tools.metalava.model.JAVA_LANG_STRING
+import com.android.tools.metalava.model.PrimitiveTypeItem
+import com.android.tools.metalava.model.PrimitiveTypeItem.Primitive
+import com.android.tools.metalava.model.ReferenceTypeItem
+import com.android.tools.metalava.model.TypeArgumentTypeItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeStringConfiguration
+import com.android.tools.metalava.model.VariableTypeItem
+import com.android.tools.metalava.model.WildcardTypeItem
+import com.android.tools.metalava.model.item.DefaultTypeParameterItem
+import com.android.tools.metalava.model.type.DefaultArrayTypeItem
+import com.android.tools.metalava.model.type.DefaultClassTypeItem
+import com.android.tools.metalava.model.type.DefaultPrimitiveTypeItem
+import com.android.tools.metalava.model.type.DefaultTypeModifiers
+import com.android.tools.metalava.model.type.DefaultVariableTypeItem
+import com.android.tools.metalava.model.type.DefaultWildcardTypeItem
 
 /**
  * The default [TypeStringConfiguration] that [testTypeString] uses to obtain the defaults for its
@@ -40,3 +58,51 @@ fun TypeItem.testTypeString(
             kotlinStyleNulls = kotlinStyleNulls,
         )
     )
+
+/** Create a [PrimitiveTypeItem] for [kind]. */
+fun primitiveTypeForKind(kind: Primitive): PrimitiveTypeItem =
+    DefaultPrimitiveTypeItem(DefaultTypeModifiers.emptyNonNullModifiers, kind)
+
+/** Create a [ClassTypeItem] for [JAVA_LANG_STRING]. */
+fun stringType(): ClassTypeItem = classTypeItem(JAVA_LANG_STRING)
+
+/** Create a [ClassTypeItem] for [qualifiedName] with [arguments] inside [outerClassType]. */
+fun classTypeItem(
+    qualifiedName: String,
+    arguments: List<TypeArgumentTypeItem> = emptyList(),
+    outerClassType: ClassTypeItem? = null,
+): ClassTypeItem =
+    DefaultClassTypeItem(
+        ClassResolver.THROWING,
+        DefaultTypeModifiers.emptyNonNullModifiers,
+        qualifiedName,
+        arguments,
+        outerClassType,
+    )
+
+/** Create a [ArrayTypeItem] for [componentType]. */
+fun arrayTypeItem(componentType: TypeItem): ArrayTypeItem =
+    DefaultArrayTypeItem(
+        DefaultTypeModifiers.emptyNonNullModifiers,
+        componentType,
+        isVarargs = false,
+    )
+
+/** Create a [VariableTypeItem] for a [TypeArgumentTypeItem] called [name]. */
+fun variableTypeItem(name: String): VariableTypeItem =
+    DefaultVariableTypeItem(
+        DefaultTypeModifiers.emptyNonNullModifiers,
+        DefaultTypeParameterItem(
+            ClassResolver.THROWING,
+            DefaultModifierList.create(0),
+            name,
+            isReified = false
+        )
+    )
+
+/** Create a [WildcardTypeItem] for [extendsBound] of [superBound] . */
+fun wildcardTypeItem(
+    extendsBound: ReferenceTypeItem? = null,
+    superBound: ReferenceTypeItem? = null,
+): WildcardTypeItem =
+    DefaultWildcardTypeItem(DefaultTypeModifiers.emptyUndefinedModifiers, extendsBound, superBound)
diff --git a/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/testing/value/TestableValue.kt b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/testing/value/TestableValue.kt
new file mode 100644
index 000000000..f7b6b25b1
--- /dev/null
+++ b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/testing/value/TestableValue.kt
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testing.value
+
+import com.android.tools.metalava.model.AnnotationAttribute
+import com.android.tools.metalava.model.AnnotationContext
+import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.ClassResolver
+import com.android.tools.metalava.model.PrimitiveTypeItem.Primitive
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.testing.primitiveTypeForKind
+import com.android.tools.metalava.model.value.AnnotationValue
+import com.android.tools.metalava.model.value.ArrayElementValue
+import com.android.tools.metalava.model.value.ArrayValue
+import com.android.tools.metalava.model.value.ClassObjectValue
+import com.android.tools.metalava.model.value.ConstantValue
+import com.android.tools.metalava.model.value.FieldReferenceValue
+import com.android.tools.metalava.model.value.LiteralValue
+import com.android.tools.metalava.model.value.PrimitiveValue
+import com.android.tools.metalava.model.value.Value
+import com.android.tools.metalava.model.value.ValueKind
+import com.android.tools.metalava.model.value.ValueProviderException
+import com.android.tools.metalava.model.value.provider
+import com.android.tools.metalava.reporter.FileLocation
+import java.util.EnumSet
+import kotlin.test.assertEquals
+import org.junit.AssumptionViolatedException
+
+/** Create a [LiteralValue] from the [underlyingValue]. */
+fun literalValue(underlyingValue: Any, nonLiteralInSource: Boolean = false) =
+    Value.createLiteralValue(null, underlyingValue, nonLiteralInSource)
+
+/** Create a [PrimitiveValue] of [kind] from the [underlyingValue]. */
+fun primitiveValueForKind(
+    kind: Primitive,
+    underlyingValue: Any,
+    nonLiteralInSource: Boolean = false,
+) = Value.createLiteralValue(primitiveTypeForKind(kind), underlyingValue, nonLiteralInSource)
+
+/** Create an [ArrayValue] containing [literals]. */
+fun arrayValueFromAny(vararg literals: Any) =
+    Value.createArrayValue(literals.map { literalValue(it) })
+
+/** Create an [ArrayValue] containing [values]. */
+fun arrayValue(vararg values: ArrayElementValue) = Value.createArrayValue(values.toList())
+
+/** Create a [ClassObjectValue] containing [typeItem]. */
+fun classObjectValue(typeItem: TypeItem, sourceExpression: String? = null) =
+    Value.createClassObjectValue(typeItem, sourceExpression)
+
+/**
+ * Create a [FieldReferenceValue] called [fieldName] in [qualifiedClassName] with an optional
+ * [constantValue].
+ */
+fun fieldReferenceValue(
+    qualifiedClassName: String,
+    fieldName: String,
+    constantValue: ConstantValue? = null,
+    kotlinCompanionClass: String? = null,
+    explicitConversionTo: Primitive? = null,
+) =
+    Value.createFieldReferenceValue(
+        ClassResolver.RETURN_NULL,
+        qualifiedClassName,
+        fieldName,
+        constantValue,
+        kotlinCompanionClass,
+        explicitConversionTo,
+    )
+
+/**
+ * Create a [FieldReferenceValue] called [fieldName] in [qualifiedClassName] whose [ConstantValue]
+ * is determined lazily.
+ */
+fun lazyFieldReferenceValue(
+    classResolver: ClassResolver,
+    qualifiedClassName: String,
+    fieldName: String,
+    optionalTypeItem: TypeItem? = null,
+) =
+    Value.createFieldReferenceValueWithDeferredConstantValue(
+        classResolver,
+        qualifiedClassName,
+        fieldName,
+        optionalTypeItem,
+    )
+
+/** Create an [AnnotationValue] from [source]. */
+fun annotationValueFromSource(source: String) =
+    Value.createAnnotationValue(
+        AnnotationItem.createFromSource(AnnotationContext.DEFAULT_RESOLVE_NULL, source)!!
+    )
+
+fun annotationValue(qualifiedClassName: String, vararg attributes: Pair<String, Value>) =
+    Value.createAnnotationValue(annotationItem(qualifiedClassName, *attributes))
+
+fun annotationItem(qualifiedClassName: String, vararg attributes: Pair<String, Value>) =
+    AnnotationItem.createAttributesLazily(
+        AnnotationContext.DEFAULT_RESOLVE_NULL,
+        FileLocation.UNKNOWN,
+        qualifiedClassName
+    ) {
+        attributes.map { (name, value) ->
+            AnnotationAttribute.createLazyAttribute(
+                name,
+                value.provider(),
+            )
+        }
+    }!!
+
+/**
+ * The set of [ValueKind]s that are fully supported across models and so will be tested rigorously,
+ * i.e. will not ignore [ValueProviderException]
+ *
+ * As each additional [ValueKind] is supported across the models they will be added here to ensure
+ * that there are no regressions.
+ */
+private val fullySupportedValueKinds =
+    EnumSet.noneOf(ValueKind::class.java).apply {
+        addAll(ValueKind.LITERAL_KINDS)
+        add(ValueKind.ANNOTATION)
+        add(ValueKind.ARRAY)
+        add(ValueKind.CLASS)
+        add(ValueKind.FIELD)
+    }
+
+/**
+ * Run a test on this [Value] ignoring any [ValueProviderException]s if its [Value.kind] is not
+ * fully supported across model implementations.
+ */
+fun Value?.runValueTest(body: (Value?) -> Unit) {
+    // Check whether this kind is fully supported, assume they are if this is null.
+    val fullySupported = this?.kind?.let { kind -> kind in fullySupportedValueKinds } ?: true
+
+    // ValueProviderExceptions are not treated as test failures if the value kind is not fully
+    // supported to avoid having to keep updating baseline files while expanding Value support
+    // across the models.
+    // TODO(b/354633349): Stop ignoring exceptions.
+    try {
+        body(this)
+    } catch (e: ValueProviderException) {
+        if (fullySupported) {
+            throw e
+        } else {
+            throw AssumptionViolatedException("Ignoring exception thrown while retrieving value", e)
+        }
+    }
+}
+
+/**
+ * A special assertion check that performs strict testing of the values.
+ *
+ * It first uses [assertEquals] on the values to verify that the normalized value is equal according
+ * to [Value.equals]. It then uses [assertEquals] on the [Value.toString] output which will include
+ * any internal state, e.g. information preserved from the original source.
+ */
+fun assertValuesAreStrictlyEqual(v1: Value?, v2: Value?, message: String? = null) {
+    val prefix = if (message == null) "" else "$message: "
+    assertEquals(v1, v2, "${prefix}use equals()")
+    assertEquals(v1?.toString(), v2?.toString(), "${prefix}compare toString()")
+}
diff --git a/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Issues.kt b/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Issues.kt
index a3a301911..19daa2b78 100644
--- a/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Issues.kt
+++ b/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Issues.kt
@@ -32,44 +32,58 @@ object Issues {
 
     // Signature file parsing
     val SIGNATURE_FILE_ERROR by Issue(Severity.ERROR)
+
+    // Type item parsing
+    val TYPE_PARSE_ERROR by Issue(Severity.ERROR)
     // TODO(b/394789173): Hide until AndroidX has disabled it.
     val UNQUALIFIED_TYPE_ERROR by Issue(Severity.HIDDEN)
 
     // Compatibility issues
-    val ADDED_ANNOTATION by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val ADDED_PACKAGE by Issue(Severity.HIDDEN, Category.COMPATIBILITY)
-    val ADDED_CLASS by Issue(Severity.HIDDEN, Category.COMPATIBILITY)
-    val ADDED_METHOD by Issue(Severity.HIDDEN, Category.COMPATIBILITY)
-    val ADDED_FIELD by Issue(Severity.HIDDEN, Category.COMPATIBILITY)
-    val ADDED_INTERFACE by Issue(Severity.HIDDEN, Category.COMPATIBILITY)
-    val REMOVED_ANNOTATION by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val REMOVED_PACKAGE by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val REMOVED_CLASS by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val REMOVED_METHOD by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val REMOVED_FIELD by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val REMOVED_INTERFACE by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val CHANGED_STATIC by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val ADDED_FINAL by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val CHANGED_VOLATILE by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val CHANGED_TYPE by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val CHANGED_VALUE by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val CHANGED_SUPERCLASS by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val CHANGED_SCOPE by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val CHANGED_ABSTRACT by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val CHANGED_DEFAULT by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val CHANGED_THROWS by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val CHANGED_NATIVE by Issue(Severity.HIDDEN, Category.COMPATIBILITY)
-    val CHANGED_CLASS by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val CHANGED_DEPRECATED by Issue(Severity.HIDDEN, Category.COMPATIBILITY)
-    val ADDED_FINAL_UNINSTANTIABLE by Issue(Severity.HIDDEN, Category.COMPATIBILITY)
-    val REMOVED_FINAL by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val REMOVED_FINAL_STRICT by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val REMOVED_DEPRECATED_CLASS by Issue(REMOVED_CLASS, Category.COMPATIBILITY)
-    val REMOVED_DEPRECATED_METHOD by Issue(REMOVED_METHOD, Category.COMPATIBILITY)
-    val REMOVED_DEPRECATED_FIELD by Issue(REMOVED_FIELD, Category.COMPATIBILITY)
-    val ADDED_ABSTRACT_METHOD by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val ADDED_REIFIED by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val REMOVED_JVM_DEFAULT_WITH_COMPATIBILITY by Issue(Severity.ERROR, Category.COMPATIBILITY)
+    // This refers to adding usage of an `--api-compat-annotation` (not adding a definition)
+    val ADDED_ANNOTATION by Issue(Severity.ERROR, Category.OTHER_COMPATIBILITY)
+    val ADDED_PACKAGE by Issue(Severity.HIDDEN, Category.OTHER_COMPATIBILITY)
+    val ADDED_CLASS by Issue(Severity.HIDDEN, Category.OTHER_COMPATIBILITY)
+    // Adding an abstract method is breaking, but that is a separate issue.
+    val ADDED_METHOD by Issue(Severity.HIDDEN, Category.OTHER_COMPATIBILITY)
+    // Note that this may be breaking if the class/interface can be implemented, but the reporter
+    // doesn't distinguish those cases.
+    val ADDED_FIELD by Issue(Severity.HIDDEN, Category.OTHER_COMPATIBILITY)
+    val ADDED_INTERFACE by Issue(Severity.HIDDEN, Category.OTHER_COMPATIBILITY)
+    // This refers to removing usage of an `--api-compat-annotation` (not removing a definition)
+    val REMOVED_ANNOTATION by Issue(Severity.ERROR, Category.OTHER_COMPATIBILITY)
+    val REMOVED_PACKAGE by Issue(Severity.ERROR, Category.BINARY_AND_SOURCE_COMPATIBILITY)
+    val REMOVED_CLASS by Issue(Severity.ERROR, Category.BINARY_AND_SOURCE_COMPATIBILITY)
+    val REMOVED_METHOD by Issue(Severity.ERROR, Category.BINARY_AND_SOURCE_COMPATIBILITY)
+    val REMOVED_FIELD by Issue(Severity.ERROR, Category.BINARY_AND_SOURCE_COMPATIBILITY)
+    val REMOVED_INTERFACE by Issue(Severity.ERROR, Category.BINARY_AND_SOURCE_COMPATIBILITY)
+    val CHANGED_STATIC by Issue(Severity.ERROR, Category.BINARY_AND_SOURCE_COMPATIBILITY)
+    val ADDED_FINAL by Issue(Severity.ERROR, Category.BINARY_AND_SOURCE_COMPATIBILITY)
+    val CHANGED_VOLATILE by Issue(Severity.ERROR, Category.OTHER_COMPATIBILITY)
+    // There are some type changes that would be source compatible but not binary compatible, but
+    // treat all changes as both to be safe.
+    val CHANGED_TYPE by Issue(Severity.ERROR, Category.BINARY_AND_SOURCE_COMPATIBILITY)
+    val CHANGED_VALUE by Issue(Severity.ERROR, Category.BINARY_COMPATIBILITY_ONLY)
+    val CHANGED_SUPERCLASS by Issue(Severity.ERROR, Category.BINARY_AND_SOURCE_COMPATIBILITY)
+    val CHANGED_SCOPE by Issue(Severity.ERROR, Category.BINARY_AND_SOURCE_COMPATIBILITY)
+    val CHANGED_ABSTRACT by Issue(Severity.ERROR, Category.BINARY_AND_SOURCE_COMPATIBILITY)
+    val CHANGED_DEFAULT by Issue(Severity.ERROR, Category.BINARY_AND_SOURCE_COMPATIBILITY)
+    val CHANGED_THROWS by Issue(Severity.ERROR, Category.BINARY_AND_SOURCE_COMPATIBILITY)
+    val CHANGED_NATIVE by Issue(Severity.HIDDEN, Category.OTHER_COMPATIBILITY)
+    val CHANGED_CLASS by Issue(Severity.ERROR, Category.BINARY_AND_SOURCE_COMPATIBILITY)
+    val CHANGED_DEPRECATED by Issue(Severity.HIDDEN, Category.SOURCE_COMPATIBILITY_ONLY)
+    val ADDED_FINAL_UNINSTANTIABLE by Issue(Severity.HIDDEN, Category.OTHER_COMPATIBILITY)
+    val REMOVED_FINAL by Issue(Severity.ERROR, Category.BINARY_COMPATIBILITY_ONLY)
+    val REMOVED_FINAL_STRICT by Issue(Severity.ERROR, Category.OTHER_COMPATIBILITY)
+    val REMOVED_DEPRECATED_CLASS by Issue(REMOVED_CLASS, Category.BINARY_AND_SOURCE_COMPATIBILITY)
+    val REMOVED_DEPRECATED_METHOD by Issue(REMOVED_METHOD, Category.BINARY_AND_SOURCE_COMPATIBILITY)
+    val REMOVED_DEPRECATED_FIELD by Issue(REMOVED_FIELD, Category.BINARY_AND_SOURCE_COMPATIBILITY)
+    val ADDED_ABSTRACT_METHOD by Issue(Severity.ERROR, Category.BINARY_AND_SOURCE_COMPATIBILITY)
+    val ADDED_REIFIED by Issue(Severity.ERROR, Category.BINARY_COMPATIBILITY_ONLY)
+    val REMOVED_JVM_DEFAULT_WITH_COMPATIBILITY by
+        Issue(Severity.ERROR, Category.BINARY_COMPATIBILITY_ONLY)
+    val REMOVED_FROM_BYTECODE by Issue(Severity.ERROR, Category.BINARY_COMPATIBILITY_ONLY)
+    val REMOVED_FROM_JAVA by Issue(Severity.ERROR, Category.SOURCE_COMPATIBILITY_ONLY)
+    val REMOVED_FROM_KOTLIN by Issue(Severity.ERROR, Category.SOURCE_COMPATIBILITY_ONLY)
 
     // Issues in javadoc generation
     val UNRESOLVED_LINK by Issue(Severity.ERROR, Category.DOCUMENTATION)
@@ -93,14 +107,16 @@ object Issues {
 
     val MISSING_PERMISSION by Issue(Severity.ERROR, Category.DOCUMENTATION)
     val MULTIPLE_THREAD_ANNOTATIONS by Issue(Severity.ERROR, Category.DOCUMENTATION)
-    val INVALID_NULL_CONVERSION by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val PARAMETER_NAME_CHANGE by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val OPERATOR_REMOVAL by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val INFIX_REMOVAL by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val VARARG_REMOVAL by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val ADD_SEALED by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val FUN_REMOVAL by Issue(Severity.ERROR, Category.COMPATIBILITY)
-    val BECAME_UNCHECKED by Issue(Severity.ERROR, Category.COMPATIBILITY)
+    val INVALID_NULL_CONVERSION by Issue(Severity.ERROR, Category.SOURCE_COMPATIBILITY_ONLY)
+    val PARAMETER_NAME_CHANGE by Issue(Severity.ERROR, Category.SOURCE_COMPATIBILITY_ONLY)
+    val OPERATOR_REMOVAL by Issue(Severity.ERROR, Category.SOURCE_COMPATIBILITY_ONLY)
+    val INFIX_REMOVAL by Issue(Severity.ERROR, Category.SOURCE_COMPATIBILITY_ONLY)
+    val VARARG_REMOVAL by Issue(Severity.ERROR, Category.BINARY_AND_SOURCE_COMPATIBILITY)
+    val ADD_SEALED by Issue(Severity.ERROR, Category.SOURCE_COMPATIBILITY_ONLY)
+    val FUN_REMOVAL by Issue(Severity.ERROR, Category.SOURCE_COMPATIBILITY_ONLY)
+    // Removing an API from the checked surface isn't itself breaking, but it could allow both
+    // binary and source breaking changes to be made to the API in the future.
+    val BECAME_UNCHECKED by Issue(Severity.ERROR, Category.OTHER_COMPATIBILITY)
     val ANNOTATION_EXTRACTION by Issue(Severity.ERROR)
     val SUPERFLUOUS_PREFIX by Issue(Severity.WARNING)
     val HIDDEN_TYPEDEF_CONSTANT by Issue(Severity.ERROR)
@@ -207,7 +223,7 @@ object Issues {
     val UNIQUE_KOTLIN_OPERATOR by Issue(Severity.ERROR, Category.API_LINT)
     val SAM_SHOULD_BE_LAST by Issue(Severity.WARNING, Category.API_LINT)
     val MISSING_JVMSTATIC by Issue(Severity.WARNING, Category.API_LINT)
-    val DEFAULT_VALUE_CHANGE by Issue(Severity.ERROR, Category.COMPATIBILITY)
+    val DEFAULT_VALUE_CHANGE by Issue(Severity.ERROR, Category.SOURCE_COMPATIBILITY_ONLY)
     val DOCUMENT_EXCEPTIONS by Issue(Severity.ERROR, Category.API_LINT)
     val FORBIDDEN_SUPER_CLASS by Issue(Severity.ERROR, Category.API_LINT)
     val MISSING_NULLABILITY by Issue(Severity.ERROR, Category.API_LINT)
@@ -234,8 +250,7 @@ object Issues {
     val GETTER_SETTER_NULLABILITY by Issue(Severity.WARNING_ERROR_WHEN_NEW, Category.API_LINT)
     val CONDITIONAL_REQUIRES_PERMISSION_NOT_EXPLAINED by Issue(Severity.HIDDEN, Category.API_LINT)
     val VALUE_CLASS_DEFINITION by Issue(Severity.ERROR, Category.API_LINT)
-    val INVALID_ENVIRONMENT_IN_RESTRICTED_FOR_ENVIRONMENT by
-        Issue(Severity.ERROR, Category.API_LINT)
+    val MISSING_ENVIRONMENTS_VALUE by Issue(Severity.ERROR, Category.API_LINT)
     val MISSING_FROM_VALUE by Issue(Severity.ERROR, Category.API_LINT)
     val INHERIT_CHANGES_SIGNATURE by Issue(Severity.WARNING_ERROR_WHEN_NEW)
     val DATA_CLASS_DEFINITION by Issue(Severity.HIDDEN, Category.API_LINT)
@@ -251,7 +266,11 @@ object Issues {
             )
 
     fun findIssuesByCategory(category: Category?): List<Issue> =
-        allIssues.filter { it.category == category }
+        if (category == null) {
+            emptyList()
+        } else {
+            allIssues.filter { it.category.isSameOrSubCategory(category) }
+        }
 
     class Issue
     private constructor(
@@ -264,6 +283,12 @@ object Issues {
         /** Applicable category */
         val category: Category,
     ) : ReadOnlyProperty<Issues, Issue> {
+        init {
+            if (category == Category.COMPATIBILITY) {
+                error("Issues should use a sub-category of compatibility")
+            }
+        }
+
         /** The name of this issue */
         lateinit var name: String
             internal set
@@ -307,14 +332,32 @@ object Issues {
         }
     }
 
-    enum class Category(val description: String) {
-        COMPATIBILITY("Compatibility"),
+    enum class Category(val description: String, val parent: Category? = null) {
         DOCUMENTATION("Documentation"),
         API_LINT("API Lint"),
-        UNKNOWN("Default");
+        UNKNOWN("Default"),
+
+        /**
+         * The compatibility issue is a parent for more specific types of compatibility. Each
+         * compatibility issue should use a specific subcategory (enforced by the [Issue]
+         * constructor).
+         */
+        COMPATIBILITY("Compatibility"),
+        BINARY_COMPATIBILITY_ONLY("Binary Compatibility Breaking", COMPATIBILITY),
+        SOURCE_COMPATIBILITY_ONLY("Source Compatibility Breaking", COMPATIBILITY),
+        BINARY_AND_SOURCE_COMPATIBILITY("Binary and Source Compatibility Breaking", COMPATIBILITY),
+        OTHER_COMPATIBILITY("Other Compatibility", COMPATIBILITY);
 
         /** Identifier for use in command-line arguments and reporting. */
         val id: String = enumConstantToCamelCase(name)
+
+        /**
+         * Returns whether this category matches [otherCategory], or if a sub category of
+         * [otherCategory].
+         */
+        internal fun isSameOrSubCategory(otherCategory: Category): Boolean {
+            return this == otherCategory || parent?.isSameOrSubCategory(otherCategory) == true
+        }
     }
 
     init {
diff --git a/metalava-testing/build.gradle.kts b/metalava-testing/build.gradle.kts
index b3dc9116b..082d685bc 100644
--- a/metalava-testing/build.gradle.kts
+++ b/metalava-testing/build.gradle.kts
@@ -23,6 +23,7 @@ plugins {
 dependencies {
     implementation(libs.androidLintTests)
     implementation(libs.junit4)
+    implementation(libs.androidToolsExternalKotlinCompiler)
 
     testImplementation(libs.kotlinTest)
 }
diff --git a/metalava-testing/src/main/java/com/android/tools/metalava/testing/AndroidTestUtils.kt b/metalava-testing/src/main/java/com/android/tools/metalava/testing/AndroidTestUtils.kt
index b1b7ff383..a4fd6d0a7 100644
--- a/metalava-testing/src/main/java/com/android/tools/metalava/testing/AndroidTestUtils.kt
+++ b/metalava-testing/src/main/java/com/android/tools/metalava/testing/AndroidTestUtils.kt
@@ -23,7 +23,8 @@ private const val API_LEVEL = 31
 private fun getAndroidJarFromEnv(apiLevel: Int): File {
     val sdkRoot =
         System.getenv("ANDROID_SDK_ROOT")
-            ?: System.getenv("ANDROID_HOME") ?: error("Expected ANDROID_SDK_ROOT to be set")
+            ?: System.getenv("ANDROID_HOME")
+            ?: error("Expected ANDROID_SDK_ROOT to be set")
     val jar = File(sdkRoot, "platforms/android-$apiLevel/android.jar")
     if (!jar.exists()) {
         error("Missing ${jar.absolutePath} file in the SDK")
diff --git a/metalava-testing/src/main/java/com/android/tools/metalava/testing/EntryPointCallerTracker.kt b/metalava-testing/src/main/java/com/android/tools/metalava/testing/EntryPointCallerTracker.kt
new file mode 100644
index 000000000..b65e28a0c
--- /dev/null
+++ b/metalava-testing/src/main/java/com/android/tools/metalava/testing/EntryPointCallerTracker.kt
@@ -0,0 +1,412 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.testing
+
+import org.junit.rules.TestRule
+import org.junit.runner.Description
+import org.junit.runners.Parameterized
+import org.junit.runners.model.Statement
+
+/**
+ * Marks a function (or constructor) that is an entry point into some test infrastructure.
+ *
+ * The purpose of this is to allow an [EntryPointCallerTracker] to scan a stack trace, ignore test
+ * infrastructure methods, and find the caller into the test infrastructure as that is probably the
+ * most useful place to go to in the event of a test failure.
+ *
+ * Functions (or constructors) that are annotated with this must not be private as Kotlin will drop
+ * the annotation. It will also mangle the name but that is not an issue as the mangled name appears
+ * in the stack traces anyway.
+ *
+ * See [EntryPointCallerRule].
+ */
+@Target(AnnotationTarget.CONSTRUCTOR, AnnotationTarget.FUNCTION) annotation class EntryPoint
+
+/**
+ * Marks a function (or constructor) that is an exit point from a test infrastructure.
+ *
+ * If some test infrastructure code calls a lambda provided by the test case then the function (or
+ * constructor) that calls the lambda should be annotated with this. That will ensure that calls
+ * from the lambda are treated as calls into the test infrastructure and not part of the test
+ * infrastructure itself.
+ *
+ * A function (or constructor) cannot be both an entry and exit point. If that is necessary, then it
+ * must be split into two, with the part that calls the lambda being annotated with this.
+ *
+ * See [EntryPointCallerRule].
+ */
+@Target(AnnotationTarget.CONSTRUCTOR, AnnotationTarget.FUNCTION) annotation class ExitPoint
+
+/**
+ * Records the stack trace of this object's creation and uses it to rewrite the stack trace of a
+ * [Throwable] in the event of a test failure.
+ *
+ * The purpose of this is to make the stack trace for a test failure in a parameterized test more
+ * useful by pointing to the location where the test data was created rather than the location of
+ * the failing assertion which will be the same for all tests.
+ *
+ * This would typically be used in a parameterized test where the same test method and assertion is
+ * run for multiple different set of arguments. In the event of a failing test, the location of the
+ * failing assertion is probably less important than the location of the code that created the
+ * particular set of arguments being tested.
+ *
+ * That can be achieved by creating an instance of this in the set of arguments being tested and
+ * running any test code within [runTest]. If that test code fails with a [Throwable] then it will
+ * replace the stack trace of that exception with the stack trace for the creation of this instance.
+ *
+ * Even then there will be many stack frames, and it would not be clear which one was the important
+ * one and which was not. To address that, entry points into the test infrastructure that could lead
+ * to the creation of this must be marked with @[EntryPoint]. This will then make sure that the
+ * stack frame for the caller of one of those methods is at the top of the stack trace.
+ *
+ * e.g.
+ *
+ * ```
+ *     ... val testCase: TestCase
+ *
+ *     class TestCase(...) {
+ *         val entryPointCallerTracker = EntryPointCallerTracker()
+ *     }
+ *
+ *     @EntryPoint
+ *     fun addTestCase(...) {
+ *         testCases.add(TestCase(...));
+ *     }
+ *
+ *     val testCases = buildTestCases {
+ *         addTestCase(...broken...)
+ *     }
+ *
+ *     @Test
+ *     fun `run test`() {
+ *         testCase.entryPointCallerTracker.runTest {
+ *             assert...
+ *         }
+ *     }
+ * ```
+ *
+ * When the assertion fails the top stack frame will reference `addTestCase(...broken...)`.
+ */
+class EntryPointCallerTracker @EntryPoint constructor() {
+    /**
+     * Create a [Throwable] to preserve the stack trace at the point this was created but defer all
+     * the rest of the work until a [Throwable] is thrown in [runTest].
+     */
+    private val throwable = Throwable()
+
+    /**
+     * Run [body] and if it throws a [Throwable] and it has no init cause then replace its stack
+     * trace with a stripped stack trace such that the top frame is the caller into the entry point
+     * that caused this to be created.
+     *
+     * It only modifies the stack trace of a [Throwable] that has no init cause as the init cause is
+     * used to preserve the original stack trace from the [Throwable].
+     */
+    fun runTest(body: () -> Unit) {
+        try {
+            body()
+        } catch (e: Throwable) {
+            // Only modify the stack trace if there was no cause provided as otherwise there is no
+            // place to attach the original stack trace. That means modifying the stack trace would
+            // be lossy and the convenience of a fast way to navigate to the test data creation is
+            // not worth losing information that may be vital to debugging the problem.
+            if (e.cause == null) {
+                // Preserve the original stack trace in the init cause just in case it is needed for
+                // debugging.
+                val initCause =
+                    Exception("Original stack trace").also { it.stackTrace = e.stackTrace }
+                e.initCause(initCause)
+
+                // Set the stack trace to point to the caller of an entry point into the test
+                // infrastructure.
+                e.stackTrace = throwable.entryPointStack
+            }
+
+            throw e
+        }
+    }
+
+    /** Get this [Throwable]'s [stackTrace], starting from the caller into the entry point. */
+    private val Throwable.entryPointStack: Array<StackTraceElement>?
+        get() {
+            val elements = stackTrace
+
+            var entryPointCallerIndex = -1
+            for ((index, element) in elements.withIndex()) {
+                val elementType = element.elementType()
+                if (elementType == StackElementType.ENTRY) entryPointCallerIndex = index
+                else if (elementType == StackElementType.EXIT) break
+            }
+            return if (entryPointCallerIndex == -1) {
+                elements
+            } else {
+                elements.sliceArray((entryPointCallerIndex + 1)..<elements.size)
+            }
+        }
+
+    /** The type of [StackTraceElement]. */
+    private enum class StackElementType {
+        ENTRY,
+        EXIT,
+    }
+
+    /**
+     * Get the type of this, depends on the annotations associated with the method/constructor to
+     * which this refers.
+     *
+     * If it is not annotated with either [EntryPoint] or [ExitPoint] then this returns `null`.
+     */
+    private fun StackTraceElement.elementType(): StackElementType? {
+        if (!className.startsWith("com.android.tools.metalava.")) return null
+        val javaClass =
+            try {
+                Class.forName(className)
+            } catch (e: Exception) {
+                return null
+            }
+
+        // There could be overloads of the method as the StackTraceElement does not provide enough
+        // information to differentiate between them. This just picks the first one found which is
+        // good enough.
+        val method = javaClass.findMethodOrConstructor(methodName) ?: return null
+        val isEntryPoint = method.getAnnotation(EntryPoint::class.java) != null
+        val isExitPoint = method.getAnnotation(ExitPoint::class.java) != null
+        if (isEntryPoint && isExitPoint) {
+            error("$method has both @EntryPoint and @ExitPoint, pick one")
+        }
+        if (isEntryPoint) return StackElementType.ENTRY
+        if (isExitPoint) return StackElementType.EXIT
+        return null
+    }
+
+    /**
+     * Find a method or constructor (if [name] is `<init>`) on this class.
+     *
+     * Will return the first one found.
+     */
+    private fun Class<*>.findMethodOrConstructor(name: String) =
+        if (name == "<init>") {
+            constructors.firstOrNull()
+        } else {
+            methods.find { it.name == name }
+        }
+}
+
+/**
+ * A [TestRule] that is intended for use with parameterized tests to make it easier to debug test
+ * failures by rewriting the stack trace to the place where the test data was created.
+ *
+ * [Parameterized] tests use the same test code to run multiple tests based on parameters injected
+ * into the tests. The problem with that is that when there is a test failure it is most likely
+ * caused by the test data but the stack trace always points to the location where the test data is
+ * used not where the test data was created. This addresses that by catching and rewriting the stack
+ * trace of [Throwable]s thrown by a test method to refer to where the test data was created.
+ *
+ * It is used as follows:
+ * 1. Create an [EntryPointCallerTracker] instance and store it in the test data when it is created.
+ *    That records the stack trace by creating an exception.
+ * 2. Add this rule, passing in a lambda that will return the [EntryPointCallerTracker] from the
+ *    test data that is injected into the test class instance.
+ *
+ * That will rewrite the stack trace for any [Throwable] thrown to the one used to create the
+ * [EntryPointCallerTracker]. However, before it does that it will filter out any elements from the
+ * top of [EntryPointCallerTracker]'s stack trace that are part of the test infrastructure, i.e. not
+ * related to the creation of a specific instance of test data. The intent is to make sure that the
+ * top of the stack is most relevant to the current test data being tested.
+ *
+ * That filtering is controlled via the [EntryPoint] and [ExitPoint] annotations on the methods or
+ * constructors in the stack trace. The basic behavior is that the top of the stack will refer to
+ * the first caller to an [EntryPoint] found while searching from the start position upwards to the
+ * top of the stack. The start position will be either the first [ExitPoint] found while searching
+ * from the top of the stack downwards, or the bottom of the stack if no [ExitPoint] is found.
+ *
+ * e.g. The [EntryPointCallerTracker]'s constructor is not important, so it is annotated with
+ * [EntryPoint]. So, by default the top of the stack will be the location that called the
+ * [EntryPointCallerTracker] constructor not the constructor itself.
+ *
+ * In practice, the [EntryPointCallerTracker] is most likely created something like this:
+ * ```
+ *     data class TestData(...) {
+ *       internal val entryPointCallerTracker = EntryPointCallerTracker()
+ *     }
+ * ```
+ *
+ * In that case the top of the stack will be the `TestData` constructor `TestData.<init>()` which is
+ * not relevant when dealing with an issue with a specific `TestData` instance. To remove that it
+ * can be annotated with [EntryPoint], e.g.
+ *
+ * ```
+ *     data class @EntryPoint constructor TestData(...) {
+ *       ...
+ *     }
+ * ```
+ *
+ * That way the top of the stack will now point to the code that created `TestData`.
+ *
+ * If the creation of the test data is more complex and does not just involve calling
+ * `TestData(...)` directly then the methods/constructors that provide support can be annotated as
+ * well. It is not necessary to annotate every such method/constructor, only those which are called
+ * directly to create a specific instance of `TestData`.
+ *
+ * If the test infrastructure uses builder methods, i.e. methods that are supplied with a lambda
+ * that can create test data then the methods called by the lambda needs to be annotated with
+ * [EntryPoint] but the builder method does not. Unless, the builder method also creates test data
+ * directly too.
+ *
+ * e.g. in the following `builder` method does not need annotation with [EntryPoint] but the
+ * `Builder.addTest(...)` method does.
+ *
+ * ```
+ *     fun builder(body: Builder.() -> Unit): List<TestData> {
+ *       val builder = Builder()
+ *       builder.body()
+ *       return builder.build()
+ *     }
+ *
+ *     class Builder {
+ *       @EntryPoint
+ *       fun addTest(name: String, data: Int) {...}
+ *       fun build(): List<TestData> {...}
+ *     }
+ *
+ *     val testCases = builder {
+ *        ...
+ *        addTest("fred", 1)
+ *        addTest("wilma", 2)
+ *        addTest("barney", 3)
+ *        ...
+ *     }
+ * ```
+ *
+ * A test failure with `"fred"` data would be reported on the `addTest("fred", 1)` line, while a
+ * test failure with `"wilma"` data would be reported on the `addTest("wilma", 2)` line, and so on.
+ *
+ * However, if the `builder` method was changed to add its own test data like the following then it
+ * does need annotation with [EntryPoint]:
+ * ```
+ *     fun builder(defaultData: Int, body: Builder.() -> Unit): List<TestData> {
+ *       val builder = Builder()
+ *       builder.addTest("default", defaultData)
+ *       builder.body()
+ *       return builder.build()
+ *     }
+ *
+ *     val testCases = builder(defaultData = 4) {
+ *        ...
+ *        addTest("fred", 1)
+ *        addTest("wilma", 2)
+ *        addTest("barney", 3)
+ *        ...
+ *     }
+ * ```
+ *
+ * Without it an error with the `"default"` data would be reported on the
+ * `builder.addTest("default", defaultData)` line, but it would be more helpful if it was reported
+ * on the `builder(defaultData = 4) {` line.
+ *
+ * Unfortunately, just annotating it with `[EntryPoint]` would mean that errors in the `"fred"` data
+ * would also be reported on the `builder(defaultData = 4) {` as that will be the first [EntryPoint]
+ * found while searching from the bottom of the stack as the unfiltered stack for creating the
+ * `"fred"` data will look something like this:
+ * ```
+ *     EntryPointCallerTracker.<init>  [EntryPoint]
+ *     <*Test>$TestData.<init>
+ *     <*Test>$Builder.addTest         [EntryPoint]
+ *     <*Test>$lambda
+ *     <*Test>.builder                 [EntryPoint]
+ *     <*Test>$Companion.<clinit>
+ * ```
+ *
+ * The first (from the bottom) `[EntryPoint]` (which is the call to `builder(...)`) and everything
+ * above will be removed.
+ *
+ * That can be avoided by annotating the method that calls the lambda with [ExitPoint] that will
+ * reset the starting point for the search to that place. However, it would not help to add that to
+ * the `builder` method directly as it would not be clear that it applied only to the lambda (which
+ * is why using an [EntryPoint] and [ExitPoint] annotation on the same method is not allowed). So,
+ * the call to the lambda needs moving out into its own method which is annotated with [ExitPoint].
+ *
+ * e.g. the result would be something like this:
+ * ```
+ *     fun builder(defaultData: Int, body: Builder.() -> Unit): List<TestData> {
+ *       val builder = Builder()
+ *       builder.addTest("default", defaultData)
+ *       return builder.build(body)
+ *     }
+ *
+ *     class Builder {
+ *       @EntryPoint
+ *       fun addTest(name: String, data: Int) {...}
+ *       @ExitPoint
+ *       fun build(body: Builder.() -> Unit): List<TestData> {
+ *         body()
+ *         ...
+ *       }
+ *     }
+ *
+ *     val testCases = builder(defaultData = 4) {
+ *        ...
+ *        addTest("fred", 1)
+ *        addTest("wilma", 2)
+ *        addTest("barney", 3)
+ *        ...
+ *     }
+ * ```
+ *
+ * With that, the stack trace for the `"default"` data would be:
+ * ```
+ *     EntryPointCallerTracker.<init>  [EntryPoint]
+ *     <*Test>$TestData.<init>
+ *     <*Test>$Builder.addTest         [EntryPoint]
+ *     <*Test>.builder                 [EntryPoint]
+ *     <*Test>$Companion.<clinit>
+ * ```
+ *
+ * In the event of a test failure the elements for `builder` and above would be removed so the top
+ * of the stack trace would correctly refer to the call to `builder(defaultData = 4) {`.
+ *
+ * The stack trace for `"fred"` data would be:
+ * ```
+ *     EntryPointCallerTracker.<init>  [EntryPoint]
+ *     <*Test>$TestData.<init>
+ *     <*Test>$Builder.addTest         [EntryPoint]
+ *     <*Test>$lambda
+ *     <*Test>$Builder.build           [ExitPoint]
+ *     <*Test>.builder                 [EntryPoint]
+ *     <*Test>$Companion.<clinit>
+ * ```
+ *
+ * The `[ExitPoint]` would cause the upwards search for an [EntryPoint] to start from there so the
+ * fact that `builder` is an [EntryPoint] would be ignored. So, the top of the stack trace for the
+ * `"fred"` data would be the call from the lambda to `addTest("fred", 1)`.
+ *
+ * @param entryPointCallerTrackerProvider provides the [EntryPointCallerTracker] when needed. The
+ *   [EntryPointCallerTracker] cannot be supplied directly when this is constructed as this is
+ *   created before the test data is injected into the test class.
+ */
+class EntryPointCallerRule(
+    private val entryPointCallerTrackerProvider: () -> EntryPointCallerTracker
+) : TestRule {
+    override fun apply(base: Statement, description: Description): Statement {
+        return object : Statement() {
+            override fun evaluate() {
+                val entryPointCaller = entryPointCallerTrackerProvider()
+                entryPointCaller.runTest { base.evaluate() }
+            }
+        }
+    }
+}
diff --git a/metalava-testing/src/main/java/com/android/tools/metalava/testing/KnownSourceFiles.kt b/metalava-testing/src/main/java/com/android/tools/metalava/testing/KnownSourceFiles.kt
index 99858e357..3a8f712df 100644
--- a/metalava-testing/src/main/java/com/android/tools/metalava/testing/KnownSourceFiles.kt
+++ b/metalava-testing/src/main/java/com/android/tools/metalava/testing/KnownSourceFiles.kt
@@ -204,4 +204,103 @@ object KnownSourceFiles {
                 }
             """
         )
+
+    val intRangeAnnotationSource: TestFile =
+        TestFiles.java(
+            """
+                package android.annotation;
+                import java.lang.annotation.*;
+                import static java.lang.annotation.ElementType.*;
+                import static java.lang.annotation.RetentionPolicy.SOURCE;
+                @Retention(SOURCE)
+                @Target({METHOD,PARAMETER,FIELD,LOCAL_VARIABLE,ANNOTATION_TYPE})
+                public @interface IntRange {
+                    /** Smallest value, inclusive */
+                    long from() default Long.MIN_VALUE;
+                    /** Largest value, inclusive */
+                    long to() default Long.MAX_VALUE;
+                }
+            """
+        )
+
+    val floatRangeAnnotationSource: TestFile =
+        TestFiles.java(
+            """
+                package android.annotation;
+                import java.lang.annotation.*;
+                import static java.lang.annotation.ElementType.*;
+                import static java.lang.annotation.RetentionPolicy.SOURCE;
+                @Retention(SOURCE)
+                @Target({METHOD,PARAMETER,FIELD,LOCAL_VARIABLE,ANNOTATION_TYPE})
+                public @interface FloatRange {
+                    /** Smallest value. Whether it is inclusive or not is determined
+                     * by {@link #fromInclusive} */
+                    double from() default Double.NEGATIVE_INFINITY;
+                    /** Largest value. Whether it is inclusive or not is determined
+                     * by {@link #toInclusive} */
+                    double to() default Double.POSITIVE_INFINITY;
+                    /** Whether the from value is included in the range */
+                    boolean fromInclusive() default true;
+                    /** Whether the to value is included in the range */
+                    boolean toInclusive() default true;
+                }
+            """
+        )
+
+    val restrictToSource: TestFile =
+        TestFiles.kotlin(
+                """
+                    package androidx.annotation
+
+                    import androidx.annotation.RestrictTo.Scope
+                    import java.lang.annotation.ElementType.*
+
+                    @MustBeDocumented
+                    @Retention(AnnotationRetention.BINARY)
+                    @Target(
+                        AnnotationTarget.ANNOTATION_CLASS,
+                        AnnotationTarget.CLASS,
+                        AnnotationTarget.FUNCTION,
+                        AnnotationTarget.PROPERTY_GETTER,
+                        AnnotationTarget.PROPERTY_SETTER,
+                        AnnotationTarget.CONSTRUCTOR,
+                        AnnotationTarget.FIELD,
+                        AnnotationTarget.FILE
+                    )
+                    // Needed due to Kotlin's lack of PACKAGE annotation target
+                    // https://youtrack.jetbrains.com/issue/KT-45921
+                    @Suppress("DEPRECATED_JAVA_ANNOTATION")
+                    @java.lang.annotation.Target(ANNOTATION_TYPE, TYPE, METHOD, CONSTRUCTOR, FIELD, PACKAGE)
+                    annotation class RestrictTo(vararg val value: Scope) {
+                        enum class Scope {
+                            LIBRARY,
+                            LIBRARY_GROUP,
+                            LIBRARY_GROUP_PREFIX,
+                            @Deprecated("Use LIBRARY_GROUP_PREFIX instead.")
+                            GROUP_ID,
+                            TESTS,
+                            SUBCLASSES,
+                        }
+                    }
+                """
+            )
+            .indented()
+
+    val sdkConstantSource: TestFile =
+        TestFiles.java(
+                """
+                    package android.annotation;
+                    import java.lang.annotation.*;
+                    /** @hide */
+                    @Target({ ElementType.FIELD })
+                    @Retention(RetentionPolicy.SOURCE)
+                    public @interface SdkConstant {
+                        enum SdkConstantType {
+                            ACTIVITY_INTENT_ACTION, BROADCAST_INTENT_ACTION, SERVICE_ACTION, INTENT_CATEGORY, FEATURE
+                        }
+                        SdkConstantType value();
+                    }
+                """
+            )
+            .indented()
 }
diff --git a/metalava-testing/src/main/java/com/android/tools/metalava/testing/KotlinTestUtils.kt b/metalava-testing/src/main/java/com/android/tools/metalava/testing/KotlinTestUtils.kt
index 82223beaa..f407354c8 100644
--- a/metalava-testing/src/main/java/com/android/tools/metalava/testing/KotlinTestUtils.kt
+++ b/metalava-testing/src/main/java/com/android/tools/metalava/testing/KotlinTestUtils.kt
@@ -16,6 +16,8 @@
 
 package com.android.tools.metalava.testing
 
+import com.android.tools.lint.checks.infrastructure.TestFile
+import com.android.tools.lint.checks.infrastructure.TestFiles.toBase64gzip
 import java.io.File
 
 private const val DOT_KT = ".kt"
@@ -46,3 +48,60 @@ fun findKotlinStdlibPaths(sources: Array<String>): List<File> {
         emptyList()
     }
 }
+
+/**
+ * Utility to create the base64gzip of a jar file compiled from test source [kotlinFiles].
+ *
+ * [kotlincPath] should be the absolute path to a local kotlinc binary
+ * (https://kotlinlang.org/docs/command-line.html).
+ *
+ * The output includes a comment with the kotlinc version used followed by the base64gzip.
+ *
+ * Example:
+ * ```
+ * val kotlinFiles = listOf(
+ *     kotlin("package test\nclass MyClass"),
+ * )
+ * val base64gzip = generateBase64gzipFromKotlin(kotlinFiles, "/path/to/kotlinc")
+ * ```
+ *
+ * Use base64gzip in your test with `base64gzip("test.jar", base64gzip)`
+ */
+fun generateBase64gzipFromKotlin(kotlinFiles: List<TestFile>, kotlincPath: String): String {
+    // Create all test kotlin files.
+    val workingDirectory = TestFile.createTempDirectory()
+    workingDirectory.mkdirs()
+    val kotlinFilePaths =
+        kotlinFiles.map { kotlinFile -> kotlinFile.createFile(workingDirectory).absolutePath }
+
+    // Create the jar file which will be used as output.
+    val outputJar = File(workingDirectory, "out.jar")
+    outputJar.createNewFile()
+
+    // Run the Kotlin compiler.
+    val proc =
+        ProcessBuilder(kotlincPath, "-d", outputJar.absolutePath, *kotlinFilePaths.toTypedArray())
+            .directory(workingDirectory)
+            .redirectOutput(ProcessBuilder.Redirect.PIPE)
+            .redirectError(ProcessBuilder.Redirect.PIPE)
+            .start()
+    proc.waitFor()
+
+    if (proc.exitValue() != 0) {
+        error("Could not create jar:\n${proc.errorReader().readText()}")
+    }
+
+    // Convert the jar to base64gzip that can be used in tests.
+    val base64gzip = toBase64gzip(outputJar)
+
+    // Get the kotlinc version used to include in a comment
+    val versionProc =
+        ProcessBuilder(kotlincPath, "-version")
+            .redirectOutput(ProcessBuilder.Redirect.PIPE)
+            .redirectError(ProcessBuilder.Redirect.PIPE)
+            .start()
+    versionProc.waitFor()
+    val versionOutput = versionProc.errorReader().readText()
+
+    return "// kotlinc version $versionOutput$base64gzip"
+}
diff --git a/metalava-testing/src/main/java/com/android/tools/metalava/testing/ProjectDescriptionTestUtils.kt b/metalava-testing/src/main/java/com/android/tools/metalava/testing/ProjectDescriptionTestUtils.kt
index 31f5f7622..af21f05b9 100644
--- a/metalava-testing/src/main/java/com/android/tools/metalava/testing/ProjectDescriptionTestUtils.kt
+++ b/metalava-testing/src/main/java/com/android/tools/metalava/testing/ProjectDescriptionTestUtils.kt
@@ -17,22 +17,30 @@
 package com.android.tools.metalava.testing
 
 import com.android.tools.lint.checks.infrastructure.TestFile
+import org.jetbrains.kotlin.config.serializeComponentPlatforms
+import org.jetbrains.kotlin.platform.CommonPlatforms
+import org.jetbrains.kotlin.platform.jvm.JvmPlatforms
 
 private val standardClasspath = getKotlinStdlibPaths() + getAndroidJar()
 val standardProjectXmlClasspath =
     standardClasspath.joinToString("\n") { "<classpath file=\"$it\"/>" }
 
+val defaultCommonKotlinPlatforms =
+    CommonPlatforms.defaultCommonPlatform.serializeComponentPlatforms()
+val defaultJvmPlatforms = JvmPlatforms.defaultJvmPlatform.serializeComponentPlatforms()
+
 /** The XML string for one module of a project (using the [standardProjectXmlClasspath]). */
 fun createModuleDescription(
     moduleName: String,
     android: Boolean,
+    kotlinPlatforms: String,
     sourceFiles: Array<TestFile>,
     dependsOn: List<String> = listOf("commonMain"),
 ): String {
     val sourceLines = sourceFiles.joinToString("\n") { "<src file=\"${it.targetRelativePath}\" />" }
     val dependsOnLines = dependsOn.joinToString("\n") { "<dep module=\"$it\" kind=\"dependsOn\"/>" }
     return """
-        <module name="$moduleName" android="$android">
+        <module name="$moduleName" android="$android" kotlinPlatforms="$kotlinPlatforms">
           $dependsOnLines
           $sourceLines
           $standardProjectXmlClasspath
@@ -42,7 +50,13 @@ fun createModuleDescription(
 
 /** The XML string for the common module of a project. */
 fun createCommonModuleDescription(sourceFiles: Array<TestFile>): String {
-    return createModuleDescription("commonMain", false, sourceFiles, emptyList())
+    return createModuleDescription(
+        moduleName = "commonMain",
+        android = false,
+        kotlinPlatforms = defaultCommonKotlinPlatforms,
+        sourceFiles = sourceFiles,
+        dependsOn = emptyList(),
+    )
 }
 
 /** The XML string for the android module of a project. */
@@ -50,7 +64,13 @@ fun createAndroidModuleDescription(
     sourceFiles: Array<TestFile>,
     dependsOn: List<String> = listOf("commonMain"),
 ): String {
-    return createModuleDescription("androidMain", true, sourceFiles, dependsOn)
+    return createModuleDescription(
+        moduleName = "androidMain",
+        android = true,
+        kotlinPlatforms = defaultJvmPlatforms,
+        sourceFiles = sourceFiles,
+        dependsOn = dependsOn,
+    )
 }
 
 /** The XML string for a project, with no root dir set (so the file location is the root dir). */
diff --git a/metalava-testing/src/test/java/com/android/tools/metalava/testing/EntryPointCallerTrackerTest.kt b/metalava-testing/src/test/java/com/android/tools/metalava/testing/EntryPointCallerTrackerTest.kt
new file mode 100644
index 000000000..9e07f2ecf
--- /dev/null
+++ b/metalava-testing/src/test/java/com/android/tools/metalava/testing/EntryPointCallerTrackerTest.kt
@@ -0,0 +1,235 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.testing
+
+import java.io.IOException
+import kotlin.test.assertEquals
+import kotlin.test.fail
+import org.junit.Assert.assertThrows
+import org.junit.Test
+
+class EntryPointCallerTrackerTest {
+
+    /**
+     * The name of this class, used in [Throwable.dump] to remove any stack elements before the
+     * first call into this class.
+     */
+    private val thisClassPrefix = javaClass.name
+
+    /**
+     * Example test data.
+     *
+     * This is used instead of just [EntryPointCallerTracker] as this is more like how it will
+     * actually be used.
+     */
+    data class TestData(val name: String) {
+        internal val entryPointCallerTracker = EntryPointCallerTracker()
+    }
+
+    /** A simple test infrastructure entry point. */
+    @EntryPoint fun testInfraSimpleEntryPoint() = TestData("with entry point")
+
+    /** A test infrastructure entry point that will call another entry point. */
+    @EntryPoint fun testInfraReEntrantEntryPoint() = testInfraSimpleEntryPoint()
+
+    /**
+     * A test infrastructure entry point that will call out to non-test infrastructure code in
+     * [body] via [testInfraExitPoint].
+     */
+    @EntryPoint
+    fun testInfraExitThenReEnterEntryPoint(body: () -> TestData) = testInfraExitPoint(body)
+
+    /**
+     * A test infrastructure exit point that will call out to non-test infrastructure code in
+     * [body].
+     */
+    @ExitPoint fun testInfraExitPoint(body: () -> TestData) = body()
+
+    /**
+     * A test infrastructure method that tries to be both entry and exit point which is not allowed.
+     */
+    @EntryPoint
+    @ExitPoint
+    fun testInfraCannotBeBothExitAndEntryPoint() = testInfraSimpleEntryPoint()
+
+    /**
+     * Dump the [Throwable] state for testing in [checkTrackerBehavior].
+     *
+     * Removes parts of the stack trace to make it more stable, e.g.
+     * * line numbers, for obvious reasons.
+     * * lambda numbers, e.g. (`$5` from `lambda$5`). These are removed as the number is based on
+     *   the lambdas created in the source file so adding a lambda can change the numbers used
+     *   elsewhere in the same file.
+     * * Anything below the first call into this class as that depends on how the test is run, e.g.
+     *   in the IDE, on the command line, etc.
+     */
+    private fun Throwable.dump() = buildString {
+        append(this@dump.javaClass.name)
+        append(": ")
+        append(message)
+        append("\n")
+        val stackTraceCopy = stackTrace
+        val firstCallIntoThisClass =
+            stackTraceCopy.indexOfLast { it.className.startsWith(thisClassPrefix) }
+        val trimmed = stackTraceCopy.sliceArray(0..firstCallIntoThisClass)
+        for (stackTraceElement in trimmed) {
+            append("  at ")
+            append(stackTraceElement.className)
+            append(".")
+            // Remove the lambda number to make tests more stable.
+            append(stackTraceElement.methodName.replaceAfter("lambda", ""))
+            append("\n")
+        }
+    }
+
+    /**
+     * Check the tracker behavior used in [testData] when a test failure occurs.
+     *
+     * @param testData the [TestData] whose [TestData.entryPointCallerTracker] is tested.
+     * @param expectedDump the expected result of calling [Throwable.dump] on the exception that is
+     *   thrown.
+     */
+    private fun checkTrackerBehavior(
+        testData: TestData,
+        expectedDump: String,
+        failure: () -> Unit = { fail("Fail") },
+    ) {
+        val tracker = testData.entryPointCallerTracker
+        val exception = assertThrows(Throwable::class.java) { tracker.runTest(failure) }
+
+        assertEquals(expectedDump.trimIndent(), exception.dump().trimEnd())
+    }
+
+    @Test
+    fun `Test cannot be both entry and exit point`() {
+        // Verify that `ExitPoint` and `EntryPoint` cannot both be provided.
+        val testData = testInfraCannotBeBothExitAndEntryPoint()
+        val tracker = testData.entryPointCallerTracker
+        val exception =
+            assertThrows(IllegalStateException::class.java) { tracker.runTest { fail("Fail") } }
+
+        assertEquals(
+            "public final com.android.tools.metalava.testing.EntryPointCallerTrackerTest${'$'}TestData com.android.tools.metalava.testing.EntryPointCallerTrackerTest.testInfraCannotBeBothExitAndEntryPoint() has both @EntryPoint and @ExitPoint, pick one",
+            exception.message
+        )
+    }
+
+    @Test
+    fun `Test does nothing if no exceptions thrown`() {
+        val testData = testInfraCannotBeBothExitAndEntryPoint()
+        val tracker = testData.entryPointCallerTracker
+        tracker.run { // Works ok.
+        }
+    }
+
+    @Test
+    fun `Test does nothing if no init cause`() {
+        // Verify that if the AssertionError has a cause that the tracker does not change its stack
+        // trace.
+        checkTrackerBehavior(
+            TestData("no entry point"),
+            """
+                java.lang.AssertionError: Fail
+                  at com.android.tools.metalava.testing.EntryPointCallerTrackerTest.Test_does_nothing_if_no_init_cause${'$'}lambda
+                  at com.android.tools.metalava.testing.EntryPointCallerTracker.runTest
+                  at com.android.tools.metalava.testing.EntryPointCallerTrackerTest.checkTrackerBehavior${'$'}lambda
+                  at org.junit.Assert.assertThrows
+                  at org.junit.Assert.assertThrows
+                  at com.android.tools.metalava.testing.EntryPointCallerTrackerTest.checkTrackerBehavior
+                  at com.android.tools.metalava.testing.EntryPointCallerTrackerTest.Test does nothing if no init cause
+            """
+        ) {
+            val cause = Exception("Cause")
+            throw AssertionError("Fail", cause)
+        }
+    }
+
+    @Test
+    fun `Test no entry point`() {
+        // Verify that `EntryPointCallerTracker.<init>` is treated as an entry point and removed
+        // from the stack trace.
+        checkTrackerBehavior(
+            TestData("no entry point"),
+            """
+                java.lang.AssertionError: Fail
+                  at com.android.tools.metalava.testing.EntryPointCallerTrackerTest${'$'}TestData.<init>
+                  at com.android.tools.metalava.testing.EntryPointCallerTrackerTest.Test no entry point
+            """
+        )
+    }
+
+    @Test
+    fun `Test not an assertion error`() {
+        // Verify that `EntryPointCallerTracker.<init>` is treated as an entry point and removed
+        // from the stack trace.
+        checkTrackerBehavior(
+            TestData("no entry point"),
+            """
+                java.io.IOException: I/O exception
+                  at com.android.tools.metalava.testing.EntryPointCallerTrackerTest${'$'}TestData.<init>
+                  at com.android.tools.metalava.testing.EntryPointCallerTrackerTest.Test not an assertion error
+            """
+        ) {
+            throw IOException("I/O exception")
+        }
+    }
+
+    @Test
+    fun `Test simple entry point`() {
+        // Verify that `testInfraSimpleEntryPoint()` is treated as the entry point and the top of
+        // the stack trace refers to this method's call to it.
+        checkTrackerBehavior(
+            testInfraSimpleEntryPoint(),
+            """
+                java.lang.AssertionError: Fail
+                  at com.android.tools.metalava.testing.EntryPointCallerTrackerTest.Test simple entry point
+            """
+        )
+    }
+
+    @Test
+    fun `Test re-entrant entry point`() {
+        // Verify that `testInfraReEntrantEntryPoint()` is treated as the entry point and the top of
+        // the stack trace refers to this method's call to it and not the call that it makes to
+        // `testInfraSimpleEntryPoint()`.
+        checkTrackerBehavior(
+            testInfraReEntrantEntryPoint(),
+            """
+                java.lang.AssertionError: Fail
+                  at com.android.tools.metalava.testing.EntryPointCallerTrackerTest.Test re-entrant entry point
+            """
+        )
+    }
+
+    @Test
+    fun `Test exit then re-enter entry point`() {
+        // Verify that the call to `testInfraSimpleEntryPoint()` from the lambda supplied to
+        // `testInfraExitThenReEnterEntryPoint()` is treated as the entry point and the top of the
+        // stack trace refers to the lambda's call to it and not this method's call to
+        // `testInfraExitThenReEnterEntryPoint()`.
+        checkTrackerBehavior(
+            testInfraExitThenReEnterEntryPoint { testInfraSimpleEntryPoint() },
+            """
+                java.lang.AssertionError: Fail
+                  at com.android.tools.metalava.testing.EntryPointCallerTrackerTest.Test_exit_then_re_enter_entry_point${'$'}lambda
+                  at com.android.tools.metalava.testing.EntryPointCallerTrackerTest.testInfraExitPoint
+                  at com.android.tools.metalava.testing.EntryPointCallerTrackerTest.testInfraExitThenReEnterEntryPoint
+                  at com.android.tools.metalava.testing.EntryPointCallerTrackerTest.Test exit then re-enter entry point
+            """
+        )
+    }
+}
diff --git a/metalava/Android.bp b/metalava/Android.bp
index 615d819db..759a2ba64 100644
--- a/metalava/Android.bp
+++ b/metalava/Android.bp
@@ -50,6 +50,7 @@ java_binary_host {
         "metalava-tools-common-m2-deps",
         "metalava-gradle-plugin-deps",
         "gson-prebuilt-jar-2.9.1",
+        "kotlin_metadata_jvm",
     ],
     main_class: "com.android.tools.metalava.Driver",
     target: {
diff --git a/metalava/src/main/java/com/android/tools/metalava/AndroidApiChecks.kt b/metalava/src/main/java/com/android/tools/metalava/AndroidApiChecks.kt
index b0b6c15a7..c99197233 100644
--- a/metalava/src/main/java/com/android/tools/metalava/AndroidApiChecks.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/AndroidApiChecks.kt
@@ -26,9 +26,12 @@ import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.SelectableItem
 import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.value.asString
 import com.android.tools.metalava.model.visitors.ApiVisitor
+import com.android.tools.metalava.permission.getRequiresPermissionInfo
 import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.reporter.Reporter
+import com.android.tools.metalava.reporter.Severity
 import java.util.regex.Pattern
 
 /** Misc API suggestions */
@@ -199,21 +202,10 @@ class AndroidApiChecks(val reporter: Reporter) {
         val text = callable.documentation
 
         val annotation = callable.modifiers.findAnnotation("androidx.annotation.RequiresPermission")
-        if (annotation != null) {
-            var conditional = false
-            val permissions = mutableListOf<String>()
-            for (attribute in annotation.attributes) {
-                when (attribute.name) {
-                    "value",
-                    "allOf",
-                    "anyOf" -> {
-                        attribute.leafValues().mapTo(permissions) { it.toSource() }
-                    }
-                    "conditional" -> {
-                        conditional = attribute.legacyValue.value() == true
-                    }
-                }
-            }
+        val requiresPermissionInfo = annotation?.getRequiresPermissionInfo()
+        if (requiresPermissionInfo != null) {
+            val conditional = requiresPermissionInfo.conditional
+            val permissions = requiresPermissionInfo.permissionValues.mapNotNull { it.asString() }
             for (item in permissions) {
                 val perm = item.substringAfterLast('.')
                 // Search for the permission name as a whole word.
@@ -223,7 +215,11 @@ class AndroidApiChecks(val reporter: Reporter) {
                     reporter.report(
                         Issues.REQUIRES_PERMISSION,
                         callable,
-                        "Method '${callable.name()}' documentation duplicates auto-generated documentation by @RequiresPermission. If the permissions are only required under certain circumstances use conditional=true to suppress the auto-documentation"
+                        "Method '${callable.name()}' documentation duplicates auto-generated documentation by @RequiresPermission. If the permissions are only required under certain circumstances use conditional=true to suppress the auto-documentation",
+                        // TODO(b/414336151): Temporarily downgrade severity to error-when-new as
+                        //   there are a few issues in Android that were not being reported
+                        //   correctly before switching to the new Value model.
+                        maximumSeverity = Severity.WARNING_ERROR_WHEN_NEW,
                     )
                 } else if (!mentioned && conditional) {
                     reporter.report(
diff --git a/metalava/src/main/java/com/android/tools/metalava/AnnotationsMerger.kt b/metalava/src/main/java/com/android/tools/metalava/AnnotationsMerger.kt
index cf252f4f6..fb92682b2 100644
--- a/metalava/src/main/java/com/android/tools/metalava/AnnotationsMerger.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/AnnotationsMerger.kt
@@ -48,12 +48,9 @@ import com.android.tools.metalava.model.ANDROIDX_NULLABLE
 import com.android.tools.metalava.model.ANDROIDX_STRING_DEF
 import com.android.tools.metalava.model.ANDROID_FLAGGED_API
 import com.android.tools.metalava.model.ANNOTATION_VALUE_TRUE
-import com.android.tools.metalava.model.AnnotationAttribute
 import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.DefaultAnnotationAttribute
-import com.android.tools.metalava.model.DefaultAnnotationItem
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.SelectableItem
@@ -136,6 +133,7 @@ class AnnotationsMerger(
                         classPath = options.classpath,
                         apiPackages = options.apiPackages,
                         projectDescription = null,
+                        compiledSourceJar = null,
                     )
                 mergeJavaStubsCodebase(javaStubsCodebase)
             }
@@ -283,8 +281,7 @@ class AnnotationsMerger(
                     if (old.modifiers.annotations().isEmpty()) {
                         old.type()?.let { typeItem ->
                             if (typeItem.modifiers.annotations.isEmpty()) return
-                        }
-                            ?: return
+                        } ?: return
                     }
 
                     reporter.report(
@@ -561,21 +558,14 @@ class AnnotationsMerger(
                 val value1 = valueElement1.getAttribute(ATTR_VAL)
                 val valName2 = valueElement2.getAttribute(ATTR_NAME)
                 val value2 = valueElement2.getAttribute(ATTR_VAL)
-                return DefaultAnnotationItem.create(
-                    codebase,
+                return codebase.createAnnotationFromAttributes(
                     "androidx.annotation.IntRange",
                     listOf(
                         // Add "L" suffix to ensure that we don't for example interpret "-1" as
                         // an integer -1 and then end up recording it as "ffffffff" instead of
                         // -1L
-                        DefaultAnnotationAttribute.create(
-                            valName1,
-                            value1 + (if (value1.last().isDigit()) "L" else "")
-                        ),
-                        DefaultAnnotationAttribute.create(
-                            valName2,
-                            value2 + (if (value2.last().isDigit()) "L" else "")
-                        )
+                        valName1 to value1 + (if (value1.last().isDigit()) "L" else ""),
+                        valName2 to value2 + (if (value2.last().isDigit()) "L" else ""),
                     ),
                 )
             }
@@ -646,18 +636,14 @@ class AnnotationsMerger(
                     }
                 }
 
-                val attributes = mutableListOf<AnnotationAttribute>()
-                attributes.add(DefaultAnnotationAttribute.create(TYPE_DEF_VALUE_ATTRIBUTE, value))
-                if (flag) {
-                    attributes.add(
-                        DefaultAnnotationAttribute.create(
-                            TYPE_DEF_FLAG_ATTRIBUTE,
-                            ANNOTATION_VALUE_TRUE
-                        )
-                    )
+                val attributes = buildList {
+                    add(TYPE_DEF_VALUE_ATTRIBUTE to value)
+                    if (flag) {
+                        add(TYPE_DEF_FLAG_ATTRIBUTE to ANNOTATION_VALUE_TRUE)
+                    }
                 }
-                return DefaultAnnotationItem.create(
-                    codebase,
+
+                return codebase.createAnnotationFromAttributes(
                     if (valName == "stringValues") ANDROIDX_STRING_DEF else ANDROIDX_INT_DEF,
                     attributes,
                 )
@@ -666,39 +652,32 @@ class AnnotationsMerger(
                 name == ANDROID_STRING_DEF ||
                 name == ANDROIDX_INT_DEF ||
                 name == ANDROID_INT_DEF -> {
-                val attributes = mutableListOf<AnnotationAttribute>()
-                val parseChild: (Element) -> Unit = { child: Element ->
-                    val elementName = child.getAttribute(ATTR_NAME)
-                    val value = child.getAttribute(ATTR_VAL)
-                    when (elementName) {
-                        TYPE_DEF_VALUE_ATTRIBUTE -> {
-                            attributes.add(
-                                DefaultAnnotationAttribute.create(TYPE_DEF_VALUE_ATTRIBUTE, value)
-                            )
-                        }
-                        TYPE_DEF_FLAG_ATTRIBUTE -> {
-                            if (ANNOTATION_VALUE_TRUE == value) {
-                                attributes.add(
-                                    DefaultAnnotationAttribute.create(
-                                        TYPE_DEF_FLAG_ATTRIBUTE,
-                                        ANNOTATION_VALUE_TRUE
-                                    )
-                                )
+                val attributes = buildList {
+                    val parseChild: (Element) -> Unit = { child: Element ->
+                        val elementName = child.getAttribute(ATTR_NAME)
+                        val value = child.getAttribute(ATTR_VAL)
+                        when (elementName) {
+                            TYPE_DEF_VALUE_ATTRIBUTE -> {
+                                add(TYPE_DEF_VALUE_ATTRIBUTE to value)
+                            }
+                            TYPE_DEF_FLAG_ATTRIBUTE -> {
+                                if (ANNOTATION_VALUE_TRUE == value) {
+                                    add(TYPE_DEF_FLAG_ATTRIBUTE to ANNOTATION_VALUE_TRUE)
+                                }
+                            }
+                            else -> {
+                                error("Unrecognized element: " + elementName)
                             }
-                        }
-                        else -> {
-                            error("Unrecognized element: " + elementName)
                         }
                     }
-                }
-                val children = getChildren(annotationElement)
-                parseChild(children[0])
-                if (children.size == 2) {
-                    parseChild(children[1])
+                    val children = getChildren(annotationElement)
+                    parseChild(children[0])
+                    if (children.size == 2) {
+                        parseChild(children[1])
+                    }
                 }
                 val intDef = ANDROIDX_INT_DEF == name || ANDROID_INT_DEF == name
-                return DefaultAnnotationItem.create(
-                    codebase,
+                return codebase.createAnnotationFromAttributes(
                     if (intDef) ANDROIDX_INT_DEF else ANDROIDX_STRING_DEF,
                     attributes,
                 )
@@ -709,19 +688,14 @@ class AnnotationsMerger(
                 val value = valueElement.getAttribute(ATTR_VAL)
                 val pure = valueElement.getAttribute(ATTR_PURE)
                 return if (pure != null && pure.isNotEmpty()) {
-                    DefaultAnnotationItem.create(
-                        codebase,
+                    codebase.createAnnotationFromAttributes(
                         name,
-                        listOf(
-                            DefaultAnnotationAttribute.create(TYPE_DEF_VALUE_ATTRIBUTE, value),
-                            DefaultAnnotationAttribute.create(ATTR_PURE, pure)
-                        ),
+                        listOf(TYPE_DEF_VALUE_ATTRIBUTE to value, ATTR_PURE to pure),
                     )
                 } else {
-                    DefaultAnnotationItem.create(
-                        codebase,
+                    codebase.createAnnotationFromAttributes(
                         name,
-                        listOf(DefaultAnnotationAttribute.create(TYPE_DEF_VALUE_ATTRIBUTE, value)),
+                        listOf(TYPE_DEF_VALUE_ATTRIBUTE to value),
                     )
                 }
             }
@@ -732,16 +706,14 @@ class AnnotationsMerger(
                 if (children.isEmpty()) {
                     return codebase.createAnnotation("@$name")
                 }
-                val attributes = mutableListOf<AnnotationAttribute>()
-                for (valueElement in children) {
-                    attributes.add(
-                        DefaultAnnotationAttribute.create(
-                            valueElement.getAttribute(ATTR_NAME) ?: continue,
-                            valueElement.getAttribute(ATTR_VAL) ?: continue
-                        )
-                    )
+                val attributes = buildList {
+                    for (valueElement in children) {
+                        val attributeName = valueElement.getAttribute(ATTR_NAME) ?: continue
+                        val attributeValue = valueElement.getAttribute(ATTR_VAL) ?: continue
+                        add(attributeName to attributeValue)
+                    }
                 }
-                return DefaultAnnotationItem.create(codebase, name, attributes)
+                return codebase.createAnnotationFromAttributes(name, attributes)
             }
         }
     }
@@ -799,13 +771,8 @@ class AnnotationsMerger(
                     val qualifiedName = annotation.qualifiedName
                     if (any { it.qualifiedName == qualifiedName }) continue
 
-                    val annotationToMerge =
-                        item.codebase.createAnnotation(
-                            annotation.toSource(showDefaultAttrs = false),
-                            item,
-                        )
-                            ?: continue
-
+                    // Take a snapshot of the annotation for use in this codebase.
+                    val annotationToMerge = annotation.snapshot(item.codebase)
                     add(annotationToMerge)
                 }
             }
diff --git a/metalava/src/main/java/com/android/tools/metalava/ApiAnalyzer.kt b/metalava/src/main/java/com/android/tools/metalava/ApiAnalyzer.kt
index 9e7829f18..9ba05aa2b 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ApiAnalyzer.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/ApiAnalyzer.kt
@@ -16,15 +16,10 @@
 
 package com.android.tools.metalava
 
-import com.android.tools.metalava.apilevels.internalDesc
 import com.android.tools.metalava.manifest.Manifest
 import com.android.tools.metalava.manifest.emptyManifest
 import com.android.tools.metalava.model.ANDROIDX_REQUIRES_PERMISSION
 import com.android.tools.metalava.model.ANDROID_ANNOTATION_PREFIX
-import com.android.tools.metalava.model.ANDROID_DEPRECATED_FOR_SDK
-import com.android.tools.metalava.model.ANDROID_SYSTEM_API
-import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
-import com.android.tools.metalava.model.AnnotationAttributeValue
 import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.BaseItemVisitor
 import com.android.tools.metalava.model.BaseTypeVisitor
@@ -36,19 +31,21 @@ import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.FilterPredicate
 import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.JAVA_LANG_DEPRECATED
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.PackageList
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.PropertyItem
 import com.android.tools.metalava.model.SelectableItem
+import com.android.tools.metalava.model.TargetLanguageSet
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.model.VariableTypeItem
 import com.android.tools.metalava.model.annotation.AnnotationFilter
 import com.android.tools.metalava.model.source.SourceParser
+import com.android.tools.metalava.model.value.asString
 import com.android.tools.metalava.model.visitors.ApiPredicate
 import com.android.tools.metalava.model.visitors.ApiVisitor
+import com.android.tools.metalava.permission.getRequiresPermissionInfo
 import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.reporter.Reporter
 import java.io.File
@@ -429,75 +426,62 @@ class ApiAnalyzer(
         val annotation = method.modifiers.findAnnotation(ANDROIDX_REQUIRES_PERMISSION)
         var hasAnnotation = false
 
-        if (annotation != null) {
+        val requiresPermissionInfo = annotation?.getRequiresPermissionInfo()
+        if (requiresPermissionInfo != null) {
             hasAnnotation = true
-            for (attribute in annotation.attributes) {
-                var values: List<AnnotationAttributeValue>? = null
-                var any = false
-                when (attribute.name) {
-                    "value",
-                    "allOf" -> {
-                        values = attribute.leafValues()
-                    }
-                    "anyOf" -> {
-                        any = true
-                        values = attribute.leafValues()
-                    }
-                }
-
-                values ?: continue
-
-                val system = ArrayList<String>()
-                val nonSystem = ArrayList<String>()
-                val missing = ArrayList<String>()
-                for (value in values) {
-                    val perm = (value.value() ?: value.toSource()).toString()
-                    val level = config.manifest.getPermissionLevel(perm)
-                    if (level == null) {
-                        if (any) {
-                            missing.add(perm)
-                            continue
-                        }
-
-                        reporter.report(
-                            Issues.REQUIRES_PERMISSION,
-                            method,
-                            "Permission '$perm' is not defined by manifest ${config.manifest}."
-                        )
+            val values = requiresPermissionInfo.permissionValues
+            val any = requiresPermissionInfo.any
+
+            val system = ArrayList<String>()
+            val nonSystem = ArrayList<String>()
+            val missing = ArrayList<String>()
+            for (value in values) {
+                val permission = value.asString() ?: continue
+                val level = config.manifest.getPermissionLevel(permission)
+                if (level == null) {
+                    if (any) {
+                        missing.add(permission)
                         continue
                     }
-                    if (
-                        level.contains("normal") ||
-                            level.contains("dangerous") ||
-                            level.contains("ephemeral")
-                    ) {
-                        nonSystem.add(perm)
-                    } else {
-                        system.add(perm)
-                    }
-                }
-                if (any && missing.size == values.size) {
-                    reporter.report(
-                        Issues.REQUIRES_PERMISSION,
-                        method,
-                        "None of the permissions ${missing.joinToString()} are defined by manifest " +
-                            "${config.manifest}."
-                    )
-                }
 
-                if (system.isEmpty() && nonSystem.isEmpty()) {
-                    hasAnnotation = false
-                } else if (any && nonSystem.isNotEmpty() || !any && system.isEmpty()) {
                     reporter.report(
                         Issues.REQUIRES_PERMISSION,
                         method,
-                        "Method '" +
-                            method.name() +
-                            "' must be protected with a system permission; it currently" +
-                            " allows non-system callers holding " +
-                            nonSystem.toString()
+                        "Permission '$permission' is not defined by manifest ${config.manifest}."
                     )
+                    continue
                 }
+                if (
+                    level.contains("normal") ||
+                        level.contains("dangerous") ||
+                        level.contains("ephemeral")
+                ) {
+                    nonSystem.add(permission)
+                } else {
+                    system.add(permission)
+                }
+            }
+            if (any && missing.size == values.size) {
+                reporter.report(
+                    Issues.REQUIRES_PERMISSION,
+                    method,
+                    "None of the permissions ${missing.joinToString()} are defined by manifest " +
+                        "${config.manifest}."
+                )
+            }
+
+            if (system.isEmpty() && nonSystem.isEmpty()) {
+                hasAnnotation = false
+            } else if (any && nonSystem.isNotEmpty() || !any && system.isEmpty()) {
+                reporter.report(
+                    Issues.REQUIRES_PERMISSION,
+                    method,
+                    "Method '" +
+                        method.name() +
+                        "' must be protected with a system permission; it currently" +
+                        " allows non-system callers holding " +
+                        nonSystem.toString()
+                )
             }
         }
 
@@ -516,9 +500,16 @@ class ApiAnalyzer(
             return
         }
 
+        // Create a special annotation with no attributes. This will not work in Android but it will
+        // work in SystemServerCheckTest.
+        // TODO(b/412743564): Fix this so it works in Android.
+        val systemServiceCheckAnnotation =
+            AnnotationItem.createFromSource(codebase, "@$ANDROID_SYSTEM_SERVICE_CHECK")
+
         val checkSystemApi =
             !reporter.isSuppressed(Issues.REQUIRES_PERMISSION) &&
-                config.allShowAnnotations.matches(ANDROID_SYSTEM_API) &&
+                systemServiceCheckAnnotation != null &&
+                config.allShowAnnotations.matches(systemServiceCheckAnnotation) &&
                 !config.manifest.isEmpty()
         val checkHiddenShowAnnotations =
             !reporter.isSuppressed(Issues.UNHIDDEN_SYSTEM_API) &&
@@ -528,6 +519,8 @@ class ApiAnalyzer(
             object :
                 ApiVisitor(
                     apiPredicateConfig = @Suppress("DEPRECATION") options.apiPredicateConfig,
+                    // Don't run checks on elements that only exist in bytecode.
+                    targetLanguages = TargetLanguageSet.SOURCE,
                 ) {
                 override fun visitParameter(parameter: ParameterItem) {
                     checkTypeReferencesHidden(parameter, parameter.type())
@@ -550,13 +543,7 @@ class ApiAnalyzer(
                             // messages (unlike java.lang.Deprecated which has no attributes).
                             // Instead, these
                             // are added to the documentation by the [DocAnalyzer].
-                            !item.isKotlin() &&
-                            // @DeprecatedForSdk will show up as an alias for @Deprecated, but it's
-                            // correct
-                            // and expected to *not* combine this with @deprecated in the text;
-                            // here,
-                            // the text comes from an annotation attribute.
-                            item.modifiers.isAnnotatedWith(JAVA_LANG_DEPRECATED)
+                            !item.isKotlin()
                     ) {
                         reporter.report(
                             Issues.DEPRECATION_MISMATCH,
@@ -564,22 +551,6 @@ class ApiAnalyzer(
                             "${item.toString().capitalize()}: @Deprecated annotation (present) and @deprecated doc tag (not present) do not match"
                         )
                         // TODO: Check opposite (doc tag but no annotation)
-                    } else {
-                        val deprecatedForSdk =
-                            item.modifiers.findAnnotation(ANDROID_DEPRECATED_FOR_SDK)
-                        if (deprecatedForSdk != null) {
-                            if (item.documentation.hasTagSection("@deprecated")) {
-                                reporter.report(
-                                    Issues.DEPRECATION_MISMATCH,
-                                    item,
-                                    "${item.toString().capitalize()}: Documentation contains `@deprecated` which implies this API is fully deprecated, not just @DeprecatedForSdk"
-                                )
-                            } else {
-                                val value = deprecatedForSdk.findAttribute(ANNOTATION_ATTR_VALUE)
-                                val message = value?.legacyValue?.value()?.toString() ?: ""
-                                item.appendDocumentation(message, "@deprecated")
-                            }
-                        }
                     }
 
                     if (
@@ -673,7 +644,12 @@ class ApiAnalyzer(
     fun handleStripping() {
         val notStrippable = HashSet<ClassItem>(5000)
 
-        val filter = ApiPredicate(config = config.apiPredicateConfig.copy(ignoreShown = true))
+        val filter = FilterPredicate { selectableItem ->
+            ApiPredicate(config = config.apiPredicateConfig.copy(ignoreShown = true))
+                .test(selectableItem) &&
+                // Don't consider references from elements that only exist in bytecode.
+                selectableItem.targetLanguages != TargetLanguageSet.BYTECODE_ONLY
+        }
 
         // If a class is public or protected, not hidden, not imported and marked as included,
         // then we can't strip it
@@ -688,7 +664,9 @@ class ApiAnalyzer(
             if (!cl.isHiddenOrRemoved()) {
                 val publiclyConstructable =
                     !cl.modifiers.isSealed() && cl.constructors().any { it.isApiCandidate() }
-                for (m in cl.methods()) {
+                for (m in
+                // Don't run checks on elements that only exist in bytecode.
+                cl.methods().filter { it.targetLanguages != TargetLanguageSet.BYTECODE_ONLY }) {
                     if (!m.isApiCandidate()) {
                         if (publiclyConstructable && m.modifiers.isAbstract()) {
                             reporter.report(
@@ -1055,3 +1033,9 @@ private fun MethodItemSet.removeMatchingMethods(method: MethodItem) {
         }
     }
 }
+
+/**
+ * A special constant used to ensure that [ApiAnalyzer.checkSystemPermissions] is only called from
+ * the SystemServiceCheckTest.
+ */
+const val ANDROID_SYSTEM_SERVICE_CHECK = "android.annotation.SystemServiceCheck"
diff --git a/metalava/src/main/java/com/android/tools/metalava/ApiFlagsCreator.kt b/metalava/src/main/java/com/android/tools/metalava/ApiFlagsCreator.kt
index b57842897..2a68a569c 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ApiFlagsCreator.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/ApiFlagsCreator.kt
@@ -28,31 +28,49 @@ import com.android.utils.associateNotNull
 
 /** Create [ApiFlags] from some source of information about the flags. */
 object ApiFlagsCreator {
-    /** Create [ApiFlags] from [apiFlagsConfig]. */
-    fun createFromConfig(apiFlagsConfig: ApiFlagsConfig?): ApiFlags? {
-        return apiFlagsConfig?.createApiFlags()
+    /**
+     * Create [ApiFlags] from [apiFlagsConfig].
+     *
+     * @param pruneDisabledFlags If flags which are [IMMUTABLE] and [DISABLED] should not be
+     *   included in the [ApiFlags].
+     */
+    fun createFromConfig(
+        apiFlagsConfig: ApiFlagsConfig?,
+        pruneDisabledFlags: Boolean = true
+    ): ApiFlags? {
+        return apiFlagsConfig?.createApiFlags(pruneDisabledFlags)
     }
 
-    /** Create [ApiFlags] from [ApiFlagsConfig]. */
-    private fun ApiFlagsConfig.createApiFlags(): ApiFlags {
-        val byQualifiedName = flags.associateNotNull { config -> config.createApiFlag() }
+    /**
+     * Create [ApiFlags] from [ApiFlagsConfig].
+     *
+     * @param pruneDisabledFlags If flags which are [IMMUTABLE] and [DISABLED] should not be
+     *   included in the [ApiFlags].
+     */
+    private fun ApiFlagsConfig.createApiFlags(pruneDisabledFlags: Boolean): ApiFlags {
+        val byQualifiedName =
+            flags.associateNotNull { config -> config.createApiFlag(pruneDisabledFlags) }
         return ApiFlags(byQualifiedName)
     }
 
     /**
      * Create [Pair] of qualified flag name and [ApiFlag] from [ApiFlagConfig].
      *
-     * Returns `null` if [ApiFlagConfig.mutability] is [IMMUTABLE] and [ApiFlagConfig.status] is
-     * [DISABLED] as that is the default [ApiFlags.get] returns for flags that cannot be found.
+     * If [pruneDisabledFlags] is `true` then this will return `null` if [ApiFlagConfig.mutability]
+     * is [IMMUTABLE] and [ApiFlagConfig.status] is [DISABLED] as that is the default [ApiFlags.get]
+     * returns for flags that cannot be found.
      */
-    private fun ApiFlagConfig.createApiFlag(): Pair<String, ApiFlag>? {
+    private fun ApiFlagConfig.createApiFlag(
+        pruneDisabledFlags: Boolean = true
+    ): Pair<String, ApiFlag>? {
         val apiFlag =
             when (mutability) {
                 MUTABLE -> ApiFlag.KEEP_FLAGGED_API
                 IMMUTABLE ->
                     when (status) {
                         ENABLED -> ApiFlag.FINALIZE_FLAGGED_API
-                        DISABLED -> return null
+                        DISABLED ->
+                            if (pruneDisabledFlags) return null else ApiFlag.REVERT_FLAGGED_API
                     }
             }
         val qualifiedName = "$pkg.$name"
diff --git a/metalava/src/main/java/com/android/tools/metalava/ApiLevelsGenerationOptions.kt b/metalava/src/main/java/com/android/tools/metalava/ApiLevelsGenerationOptions.kt
index 6ad81f620..94a78f047 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ApiLevelsGenerationOptions.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/ApiLevelsGenerationOptions.kt
@@ -361,13 +361,9 @@ class ApiLevelsGenerationOptions(
         files: List<MatchedPatternFile>,
     ): VersionedApi {
         val version = updater.apiVersion
-        val jar =
-            files.singleOrNull()?.file
-                ?: error(
-                    "Expected only one jar file for version $version but found ${files.size}:\n${files.joinToString("\n") {"    $it"}}"
-                )
-        verbosePrint { "Found API $version at $jar" }
-        return VersionedJarApi(jar, updater)
+        val jarFiles = files.map { it.file }
+        verbosePrint { "Found API $version at ${jarFiles.joinToString()}" }
+        return VersionedJarApi(jarFiles, updater)
     }
 
     /** Print string returned by [message] if verbose output has been requested. */
@@ -533,14 +529,20 @@ class ApiLevelsGenerationOptions(
             if (moduleMap.isEmpty())
                 continue // TODO(b/259115852): remove this (though it is an optimization too).
 
-            val byVersion = moduleFiles.groupBy { it.version }
-            byVersion.mapTo(list) { (version, files) ->
-                val extVersion = ExtVersion.fromLevel(version.major)
+            // Extension modules only have a major version so group by that.
+            val byMajorVersion = moduleFiles.groupBy { it.version.major }
+            val lastMajorVersion = byMajorVersion.keys.max()
+            byMajorVersion.mapTo(list) { (extVersionNumber, files) ->
+                val extVersion = ExtVersion.fromLevel(extVersionNumber)
+                // If the extension is the last extension version then it will make sure that any
+                // new APIs appear to have been added in `versionNotInAndroidSdk`.
+                val isLatestExtVersion = extVersionNumber == lastMajorVersion
                 val updater =
                     ApiHistoryUpdater.forExtVersion(
                         versionNotInAndroidSdk,
                         extVersion,
                         mainlineModule,
+                        isLatestExtVersion,
                     )
                 versionedApiFactory(updater, files)
             }
diff --git a/metalava/src/main/java/com/android/tools/metalava/ApiSelectionOptions.kt b/metalava/src/main/java/com/android/tools/metalava/ApiSelectionOptions.kt
index 99d879546..8746f32c4 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ApiSelectionOptions.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/ApiSelectionOptions.kt
@@ -61,7 +61,7 @@ class ApiSelectionOptions(
                 .trimIndent()
     ) {
 
-    private val apiSurface by
+    internal val apiSurface by
         option(
             ARG_API_SURFACE,
             metavar = "<surface>",
diff --git a/metalava/src/main/java/com/android/tools/metalava/CategoryRedirectingReporter.kt b/metalava/src/main/java/com/android/tools/metalava/CategoryRedirectingReporter.kt
index 37437bacd..9ed1c0ea6 100644
--- a/metalava/src/main/java/com/android/tools/metalava/CategoryRedirectingReporter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/CategoryRedirectingReporter.kt
@@ -58,7 +58,11 @@ class CategoryRedirectingReporter(
             Category.API_LINT,
             Category.DOCUMENTATION ->
                 apiLintReporter.report(id, reportable, message, location, maximumSeverity)
-            Category.COMPATIBILITY ->
+            Category.COMPATIBILITY,
+            Category.BINARY_COMPATIBILITY_ONLY,
+            Category.SOURCE_COMPATIBILITY_ONLY,
+            Category.BINARY_AND_SOURCE_COMPATIBILITY,
+            Category.OTHER_COMPATIBILITY ->
                 compatibilityReporter.report(id, reportable, message, location, maximumSeverity)
             else -> defaultReporter.report(id, reportable, message, location, maximumSeverity)
         }
diff --git a/metalava/src/main/java/com/android/tools/metalava/ComparisonVisitor.kt b/metalava/src/main/java/com/android/tools/metalava/ComparisonVisitor.kt
index 5d194499f..de90892f5 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ComparisonVisitor.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/ComparisonVisitor.kt
@@ -43,6 +43,8 @@ open class ComparisonVisitor {
 
     open fun removedItem(old: SelectableItem, from: SelectableItem?) {}
 
+    open fun compareSelectableItems(old: SelectableItem, new: SelectableItem) {}
+
     open fun comparePackageItems(old: PackageItem, new: PackageItem) {}
 
     open fun compareClassItems(old: ClassItem, new: ClassItem) {}
@@ -411,6 +413,7 @@ class CodebaseComparator {
         new: SelectableItem
     ) {
         visitor.compareItems(old, new)
+        visitor.compareSelectableItems(old, new)
 
         if (old is CallableItem) {
             visitor.compareCallableItems(old, new as CallableItem)
diff --git a/metalava/src/main/java/com/android/tools/metalava/Driver.kt b/metalava/src/main/java/com/android/tools/metalava/Driver.kt
index 732b55438..d67d5c668 100644
--- a/metalava/src/main/java/com/android/tools/metalava/Driver.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/Driver.kt
@@ -29,6 +29,7 @@ import com.android.tools.metalava.cli.common.VersionCommand
 import com.android.tools.metalava.cli.common.cliError
 import com.android.tools.metalava.cli.common.commonOptions
 import com.android.tools.metalava.cli.compatibility.CompatibilityCheckOptions.CheckRequest
+import com.android.tools.metalava.cli.flag.FlagReportCommand
 import com.android.tools.metalava.cli.help.HelpCommand
 import com.android.tools.metalava.cli.historical.AndroidJarsToSignaturesCommand
 import com.android.tools.metalava.cli.internal.MakeAnnotationsPackagePrivateCommand
@@ -156,8 +157,8 @@ internal fun processFlags(
         options.useK2Uast?.let { useK2Uast ->
             ModelOptions.build("from command line") { this[PsiModelOptions.useK2Uast] = useK2Uast }
         }
-        // Otherwise, use the [ModelOptions] specified in the [TestEnvironment] if any.
-        ?: executionEnvironment.testEnvironment?.modelOptions?.apply {
+            // Otherwise, use the [ModelOptions] specified in the [TestEnvironment] if any.
+            ?: executionEnvironment.testEnvironment?.modelOptions?.apply {
                 // Make sure that the [options.useK2Uast] matches the test environment.
                 options.useK2Uast = this[PsiModelOptions.useK2Uast]
             }
@@ -540,8 +541,7 @@ private fun ActionContext.checkCompatibility(
         val compatibilityCheckCanBeSkipped =
             check.lastSignatureFile?.let { signatureFile ->
                 compareFileContents(apiFile, signatureFile)
-            }
-                ?: false
+            } ?: false
         // TODO(b/301282006): Remove global variable use when this can be tested properly
         fastPathCheckResult = compatibilityCheckCanBeSkipped
         if (compatibilityCheckCanBeSkipped) return
@@ -552,8 +552,12 @@ private fun ActionContext.checkCompatibility(
             signatureFileCache.load(signatureFiles, classResolverProvider.classResolver)
         }
 
-    // If configured, compares the new API with the previous API and reports
-    // any incompatibilities.
+    val apiName =
+        if (apiType == ApiType.REMOVED) {
+            "removed"
+        } else options.apiSelectionOptions.apiSurface
+
+    // If configured, compares the new API with the previous API and reports any incompatibilities.
     CompatibilityCheck.checkCompatibility(
         newCodebase,
         oldCodebase,
@@ -561,6 +565,7 @@ private fun ActionContext.checkCompatibility(
         reporter,
         options.issueConfiguration,
         options.apiCompatAnnotations,
+        apiName,
     )
 }
 
@@ -650,6 +655,7 @@ private fun ActionContext.loadFromSources(
             classPath = options.classpath,
             apiPackages = options.apiPackages,
             projectDescription = options.projectDescription,
+            compiledSourceJar = options.compiledSourceJar
         )
 
     progressTracker.progress("Analyzing API: ")
@@ -917,6 +923,7 @@ private fun createMetalavaCommand(
     command.subcommands(
         MainCommand(command.commonOptions, executionEnvironment),
         AndroidJarsToSignaturesCommand(),
+        FlagReportCommand(),
         HelpCommand(),
         JarToJDiffCommand(),
         MakeAnnotationsPackagePrivateCommand(),
diff --git a/metalava/src/main/java/com/android/tools/metalava/ExtractAnnotations.kt b/metalava/src/main/java/com/android/tools/metalava/ExtractAnnotations.kt
index 965811c0a..ae5929655 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ExtractAnnotations.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/ExtractAnnotations.kt
@@ -16,10 +16,15 @@
 
 package com.android.tools.metalava
 
-import com.android.tools.lint.annotations.Extractor
+import com.android.tools.lint.LintCliClient.Companion.printWriter
 import com.android.tools.metalava.model.ANDROIDX_ANNOTATION_PREFIX
+import com.android.tools.metalava.model.ANDROIDX_FLOAT_RANGE
+import com.android.tools.metalava.model.ANDROIDX_INT_RANGE
+import com.android.tools.metalava.model.ANDROIDX_REQUIRES_PERMISSION_READ
+import com.android.tools.metalava.model.ANDROIDX_REQUIRES_PERMISSION_WRITE
 import com.android.tools.metalava.model.ANDROID_ANNOTATION_PREFIX
 import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
+import com.android.tools.metalava.model.AnnotationAttribute
 import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.AnnotationRetention
 import com.android.tools.metalava.model.AnnotationTarget
@@ -33,30 +38,25 @@ import com.android.tools.metalava.model.MemberItem
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.ParameterItem
+import com.android.tools.metalava.model.PrimitiveTypeItem
 import com.android.tools.metalava.model.findAnnotation
-import com.android.tools.metalava.model.psi.CodePrinter
-import com.android.tools.metalava.model.psi.report
-import com.android.tools.metalava.model.psi.uAnnotation
+import com.android.tools.metalava.model.value.AnnotationValue
+import com.android.tools.metalava.model.value.FieldReferenceValue
+import com.android.tools.metalava.model.value.SingleArrayElementFormat
+import com.android.tools.metalava.model.value.Value
+import com.android.tools.metalava.model.value.ValueStringConfiguration
+import com.android.tools.metalava.model.value.asDouble
+import com.android.tools.metalava.model.value.asLong
 import com.android.tools.metalava.model.visitors.ApiVisitor
 import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.reporter.Reporter
 import com.google.common.xml.XmlEscapers
-import com.intellij.psi.PsiAnnotation
-import com.intellij.psi.PsiNameValuePair
 import java.io.BufferedOutputStream
 import java.io.File
 import java.io.FileOutputStream
 import java.io.PrintWriter
-import java.io.StringWriter
 import java.util.jar.JarEntry
 import java.util.jar.JarOutputStream
-import kotlin.text.Charsets.UTF_8
-import org.jetbrains.uast.UAnnotation
-import org.jetbrains.uast.UCallExpression
-import org.jetbrains.uast.UExpression
-import org.jetbrains.uast.UastEmptyExpression
-import org.jetbrains.uast.UastFacade
-import org.jetbrains.uast.toUElement
 
 // Like the tools/base Extractor class, but limited to our own (mapped) AnnotationItems,
 // and only those with source retention (and in particular right now that just means the
@@ -74,24 +74,6 @@ class ExtractAnnotations(
     private val packageToAnnotationPairs =
         LinkedHashMap<PackageItem, MutableList<Pair<Item, AnnotationItem>>>()
 
-    private val fieldNamePrinter =
-        CodePrinter(
-            codebase = codebase,
-            reporter = reporter,
-            filterReference = filterReference,
-            inlineFieldValues = false,
-            skipUnknown = true,
-        )
-
-    private val fieldValuePrinter =
-        CodePrinter(
-            codebase = codebase,
-            reporter = reporter,
-            filterReference = filterReference,
-            inlineFieldValues = true,
-            skipUnknown = true,
-        )
-
     private val classToAnnotationHolder = mutableMapOf<String, AnnotationItem>()
 
     fun extractAnnotations() {
@@ -106,6 +88,10 @@ class ExtractAnnotations(
                         .sortedBy { it.qualifiedName() }
                         .toList()
 
+                // Create a print writer to the JarOutputStream. Care must be taken not to close
+                // this until all entries have been written.
+                val printWriter = zos.printWriter()
+
                 for (pkg in sortedPackages) {
                     // Note: Using / rather than File.separator: jar lib requires it
                     val name = pkg.qualifiedName().replace('.', '/') + "/annotations.xml"
@@ -121,7 +107,7 @@ class ExtractAnnotations(
                         pairs.sortBy { it.first.getExternalAnnotationSignature() }
                     }
 
-                    StringPrintWriter.create().use { writer ->
+                    printWriter.let { writer ->
                         writer.println("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<root>")
 
                         var open = false
@@ -147,11 +133,15 @@ class ExtractAnnotations(
                             writer.println()
                         }
                         writer.println("</root>\n")
-                        writer.close()
-                        val bytes = writer.contents.toByteArray(UTF_8)
-                        zos.write(bytes)
-                        zos.closeEntry()
+
+                        // Flush the writer to ensure all the data is written to the zip entry
+                        // before it is closed. Do not close the writer as that will close the whole
+                        // zip output stream.
+                        writer.flush()
                     }
+
+                    // Close the zip entry.
+                    zos.closeEntry()
                 }
             }
         }
@@ -233,7 +223,7 @@ class ExtractAnnotations(
                     typeDefClass.modifiers.findAnnotation(AnnotationItem::isTypeDefAnnotation)
                 if (typeDefAnnotation != null) {
                     // Make sure it has the right retention
-                    if (typeDefClass.getRetention() != AnnotationRetention.SOURCE) {
+                    if (typeDefClass.annotationClass.retention != AnnotationRetention.SOURCE) {
                         reporter.report(
                             Issues.ANNOTATION_EXTRACTION,
                             typeDefClass,
@@ -263,37 +253,6 @@ class ExtractAnnotations(
         }
     }
 
-    /**
-     * A writer which stores all its contents into a string and has the ability to mark a certain
-     * freeze point and then reset back to it
-     */
-    private class StringPrintWriter constructor(private val stringWriter: StringWriter) :
-        PrintWriter(stringWriter) {
-        private var mark: Int = 0
-
-        val contents: String
-            get() = stringWriter.toString()
-
-        fun mark() {
-            flush()
-            mark = stringWriter.buffer.length
-        }
-
-        fun reset() {
-            stringWriter.buffer.setLength(mark)
-        }
-
-        override fun toString(): String {
-            return contents
-        }
-
-        companion object {
-            fun create(): StringPrintWriter {
-                return StringPrintWriter(StringWriter(1000))
-            }
-        }
-    }
-
     private fun escapeXml(unescaped: String): String {
         return XmlEscapers.xmlAttributeEscaper().escape(unescaped)
     }
@@ -359,126 +318,232 @@ class ExtractAnnotations(
         return null
     }
 
-    private fun writeAnnotation(
-        writer: StringPrintWriter,
+    private fun writeAnnotation(writer: PrintWriter, item: Item, annotationItem: AnnotationItem) {
+        // Retrieve the attributes from the annotation item.
+        val attributes = retrieveAttributes(item, annotationItem)
+
+        // Some annotations need to keep field references and some need to replace them with their
+        // constant value.
+        val keepFieldReferences = keepFieldReferences(annotationItem)
+
+        // Perform some transformations and filtering on the attributes.
+        val transformedAttributes =
+            attributes.mapNotNull { attribute ->
+                val name = attribute.name
+
+                // Platform typedef annotations declare prefix/suffix attributes for historical
+                // reasons, and they are no longer necessary; they should also not be part of the
+                // extracted metadata.
+                if (
+                    ("prefix" == name || "suffix" == name) && annotationItem.isTypeDefAnnotation()
+                ) {
+                    reporter.report(
+                        Issues.SUPERFLUOUS_PREFIX,
+                        item,
+                        "Superfluous $name attribute on typedef"
+                    )
+                    return@mapNotNull null
+                }
+
+                // Transform/filter the value.
+                val transformedValue =
+                    attribute.value.transform { value ->
+                        when (value) {
+                            // If the value is a field then it needs some additional checking.
+                            is FieldReferenceValue -> {
+                                // Make sure it can be resolved, if not report an issue.
+                                val fieldItem = value.resolve()
+                                if (fieldItem == null) {
+                                    reporter.report(
+                                        Issues.INTERNAL_ERROR,
+                                        reportable = null,
+                                        "Unexpected reference to ${value.toValueString()}",
+                                        location = annotationItem.fileLocation,
+                                    )
+                                    return@transform null
+                                }
+
+                                if (keepFieldReferences) {
+                                    // If keeping the field then make sure it can be referenced from
+                                    // the API. If not then discard it.
+                                    if (!filterReference.test(fieldItem)) {
+                                        // This field is not visible: remove from typedef
+                                        reporter.report(
+                                            Issues.HIDDEN_TYPEDEF_CONSTANT,
+                                            fieldItem,
+                                            "Typedef class references hidden field $fieldItem: removed from typedef metadata"
+                                        )
+                                        return@transform null
+                                    }
+
+                                    value
+                                } else {
+                                    value.asLiteralValue()
+                                }
+                            }
+                            // Other values can just be passed straight through.
+                            else -> value
+                        }
+                    }
+
+                // If the transformed value is null then filter it out.
+                transformedValue ?: return@mapNotNull null
+
+                name to transformedValue
+            }
+
+        // If an annotation had attributes, but they were all filtered out then the chances are that
+        // the annotation is worthless so drop it altogether.
+        if (attributes.isNotEmpty() && transformedAttributes.isEmpty()) {
+            // All items were filtered out: don't write the annotation at all
+            return
+        }
+
+        // Write the annotation element.
+        val qualifiedName = annotationItem.qualifiedName
+        writeAnnotationElement(writer, qualifiedName, transformedAttributes)
+    }
+
+    /** Retrieve the attributes from [annotationItem]. */
+    private fun retrieveAttributes(
         item: Item,
         annotationItem: AnnotationItem
-    ) {
-        val uAnnotation = annotationItem.uAnnotation ?: return
+    ): List<AnnotationAttribute> {
         val qualifiedName = annotationItem.qualifiedName
 
-        writer.mark()
-        writer.print("    <annotation name=\"")
-        writer.print(qualifiedName)
-
-        var attributes =
-            // Ensure consistent ordering.
-            uAnnotation.attributeValues.sortedWith(
+        // Ensure consistent ordering.
+        val attributes =
+            annotationItem.attributes.sortedWith(
                 compareBy(
                     // Ensure that the value attribute is written first
-                    { (it.name ?: ANNOTATION_ATTR_VALUE) != ANNOTATION_ATTR_VALUE },
-                    { it.name }
+                    { it.name != ANNOTATION_ATTR_VALUE },
+                    { it.name },
                 )
             )
 
+        when (qualifiedName) {
+            ANDROIDX_REQUIRES_PERMISSION_READ,
+            ANDROIDX_REQUIRES_PERMISSION_WRITE -> {
+                if (attributes.size == 1) {
+                    // The external annotations format does not allow for nested/complex
+                    // annotations. However, these special annotations (@RequiresPermission.Read,
+                    // @RequiresPermission.Write) are known to only be simple containers with a
+                    // single permission child, so instead we "inline" the content:
+                    //  @Read(@RequiresPermission(allOf={P1,P2},conditional=true)
+                    //     =>
+                    //  @RequiresPermission.Read(allOf({P1,P2},conditional=true)
+                    //
+                    // That's setting attributes that don't actually exist on the container
+                    // permission, but we'll counteract that on the read-annotations side.
+                    (attributes[0].value as? AnnotationValue)?.let { value ->
+                        return value.annotationItem.attributes
+                    }
+                }
+            }
+            // `@IntRange` can be used to set the range of both `int`s and `long`s. As a result its
+            // `from` and `to` attributes are `long` as that covers both types. However, it makes
+            // little sense to use `long` values when the type to which it is applied is an `int`.
+            // In that case this converts those attributes to `int`s.
+            // TODO(b/354633349): Consider moving this to annotation item creation to make the value
+            //   types appropriate for the annotated item everywhere not just here.
+            ANDROIDX_INT_RANGE -> {
+                val type = item.type()
+                if (type is PrimitiveTypeItem && type.kind == PrimitiveTypeItem.Primitive.INT) {
+                    return attributes.mapNotNull { attribute ->
+                        val name = attribute.name
+                        if (name == "from" || name == "to") {
+                            attribute.value.asLong()?.let { long ->
+                                val intValue = Value.createLiteralValue(null, long.toInt())
+                                AnnotationAttribute.createAttribute(name, intValue)
+                            }
+                        } else attribute
+                    }
+                }
+            }
+            // `@FloatRange` can be used to set the range of both `float`s and `doubles`s. As a
+            // result its `from` and `to` attributes are `doubles` as that covers both types.
+            // However, it makes little sense to use `doubles` values when the type to which it is
+            // applied is a `float`. Especially given that converting a `float` to a `double` can
+            // result in a different serialized form. In that case this converts those attributes to
+            // `float`s.
+            ANDROIDX_FLOAT_RANGE -> {
+                val type = item.type()
+                if (type is PrimitiveTypeItem && type.kind == PrimitiveTypeItem.Primitive.FLOAT) {
+                    return attributes.mapNotNull { attribute ->
+                        val name = attribute.name
+                        if (name == "from" || name == "to") {
+                            attribute.value.asDouble()?.let { double ->
+                                val floatValue = Value.createLiteralValue(null, double.toFloat())
+                                AnnotationAttribute.createAttribute(name, floatValue)
+                            }
+                        } else attribute
+                    }
+                }
+            }
+        }
+
+        return attributes
+    }
+
+    /**
+     * Write the annotation element to [writer].
+     *
+     * @param qualifiedName the name of the annotation class.
+     * @param attributes the attributes, as a list of name/value pairs.
+     */
+    private fun writeAnnotationElement(
+        writer: PrintWriter,
+        qualifiedName: String,
+        attributes: List<Pair<String, Value>>
+    ) {
+        // Begin the annotation element.
+        writer.print("    <annotation name=\"")
+        writer.print(qualifiedName)
+
+        // If no attributes are provided then close it immediately.
         if (attributes.isEmpty()) {
             writer.print("\"/>")
             writer.println()
             return
         }
 
+        // Complete the open annotation element.
         writer.print("\">")
         writer.println()
 
-        if (attributes.size == 1 && Extractor.REQUIRES_PERMISSION.isPrefix(qualifiedName, true)) {
-            val expression = attributes[0].expression
-            if (expression is UAnnotation) {
-                // The external annotations format does not allow for nested/complex annotations.
-                // However, these special annotations (@RequiresPermission.Read,
-                // @RequiresPermission.Write, etc.) are known to only be simple containers with a
-                // single permission child, so instead we "inline" the content:
-                //  @Read(@RequiresPermission(allOf={P1,P2},conditional=true)
-                //     =>
-                //      @RequiresPermission.Read(allOf({P1,P2},conditional=true)
-                // That's setting attributes that don't actually exist on the container permission,
-                // but we'll counteract that on the read-annotations side.
-                val annotation = expression as UAnnotation
-                attributes = annotation.attributeValues
-            } else if (expression is UCallExpression) {
-                val nestedPsi = expression.sourcePsi as? PsiAnnotation
-                val annotation =
-                    nestedPsi?.let {
-                        UastFacade.convertElement(it, expression, UAnnotation::class.java)
-                    } as? UAnnotation
-                annotation?.attributeValues?.let { attributes = it }
-            } else if (
-                expression is UastEmptyExpression && attributes[0].sourcePsi is PsiNameValuePair
-            ) {
-                val memberValue = (attributes[0].sourcePsi as PsiNameValuePair).value
-                if (memberValue is PsiAnnotation) {
-                    val annotation = memberValue.toUElement(UAnnotation::class.java)
-                    annotation?.attributeValues?.let { attributes = it }
-                }
-            }
-        }
-
-        val inlineConstants = isInlinedConstant(annotationItem)
-        var empty = true
-        for (pair in attributes) {
-            val expression = pair.expression
-            val value = attributeString(expression, inlineConstants) ?: continue
-            empty = false
-            var name = pair.name
-            if (name == null) {
-                name = ANNOTATION_ATTR_VALUE // default name
-            }
-
-            // Platform typedef annotations declare prefix/suffix attributes for historical reasons,
-            // and they are no longer necessary; they should also not be part of the extracted
-            // metadata.
-            if (("prefix" == name || "suffix" == name) && annotationItem.isTypeDefAnnotation()) {
-                reporter.report(
-                    Issues.SUPERFLUOUS_PREFIX,
-                    item,
-                    "Superfluous $name attribute on typedef"
-                )
-                continue
-            }
+        // Add entries for each attribute.
+        for ((name, value) in attributes) {
+            val valueString = value.toValueString(EXTRACT_VALUE_STRING_CONFIGURATION)
 
             // The value could contain fully qualified references to enum values that are in the
             // android.annotation package. If so, then replace them with references in the
             // androidx.annotation package.
-            val normalizedValue =
-                value.replace(ANDROID_ANNOTATION_PREFIX, ANDROIDX_ANNOTATION_PREFIX)
+            val normalizedValueString =
+                valueString.replace(ANDROID_ANNOTATION_PREFIX, ANDROIDX_ANNOTATION_PREFIX)
 
             writer.print("      <val name=\"")
             writer.print(name)
             writer.print("\" val=\"")
-            writer.print(escapeXml(normalizedValue))
+            writer.print(escapeXml(normalizedValueString))
             writer.println("\" />")
         }
 
-        if (empty && attributes.isNotEmpty()) {
-            // All items were filtered out: don't write the annotation at all
-            writer.reset()
-            return
-        }
-
         writer.println("    </annotation>")
     }
 
-    private fun attributeString(value: UExpression?, inlineConstants: Boolean): String? {
-        val printer =
-            if (inlineConstants) {
-                fieldValuePrinter
-            } else {
-                fieldNamePrinter
-            }
-
-        return printer.toSourceString(value)
+    /** Type def annotations must keep field references. */
+    private fun keepFieldReferences(annotationItem: AnnotationItem): Boolean {
+        return annotationItem.isTypeDefAnnotation()
     }
 
-    private fun isInlinedConstant(annotationItem: AnnotationItem): Boolean {
-        return annotationItem.isTypeDefAnnotation()
+    companion object {
+        /**
+         * [ValueStringConfiguration] that is used when serializing [Value]s to an `annotations.xml`
+         * file.
+         */
+        private val EXTRACT_VALUE_STRING_CONFIGURATION =
+            ValueStringConfiguration(
+                singleArrayElementFormat = SingleArrayElementFormat.UNWRAP,
+            )
     }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/JDiffXmlWriter.kt b/metalava/src/main/java/com/android/tools/metalava/JDiffXmlWriter.kt
index 3d383c699..42d8ae051 100644
--- a/metalava/src/main/java/com/android/tools/metalava/JDiffXmlWriter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/JDiffXmlWriter.kt
@@ -30,7 +30,6 @@ import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.PropertyItem
 import com.android.tools.metalava.model.TypeItem
-import com.android.tools.metalava.model.psi.CodePrinter
 import com.android.tools.metalava.model.visitors.ApiFilters
 import com.android.tools.metalava.model.visitors.ApiVisitor
 import com.android.tools.metalava.model.visitors.FilteringApiVisitor
@@ -156,12 +155,6 @@ class JDiffXmlWriter(
 
     override fun visitField(field: FieldItem) {
         val modifiers = field.modifiers
-        val initialValue = field.legacyInitialValue(true)
-        val value =
-            if (initialValue != null) {
-                XmlUtils.toXmlAttributeValue(CodePrinter.constantToSource(initialValue))
-            } else null
-
         writer.print("<field name=\"")
         writer.print(field.name())
         writer.print("\"\n type=\"")
@@ -170,7 +163,9 @@ class JDiffXmlWriter(
         writer.print(modifiers.isTransient())
         writer.print("\"\n volatile=\"")
         writer.print(modifiers.isVolatile())
-        if (value != null) {
+        field.constantValue?.asLiteralValue()?.let { literalValue ->
+            val value = XmlUtils.toXmlAttributeValue(literalValue.toValueString())
+
             writer.print("\"\n value=\"")
             writer.print(value)
         }
diff --git a/metalava/src/main/java/com/android/tools/metalava/KotlinInteropChecks.kt b/metalava/src/main/java/com/android/tools/metalava/KotlinInteropChecks.kt
index 5898ace42..3b294ae58 100644
--- a/metalava/src/main/java/com/android/tools/metalava/KotlinInteropChecks.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/KotlinInteropChecks.kt
@@ -24,6 +24,7 @@ import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.PropertyItem
 import com.android.tools.metalava.model.psi.PsiEnvironmentManager
+import com.android.tools.metalava.model.value.ClassObjectValue
 import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.reporter.Reporter
 import com.intellij.psi.util.PsiUtil
@@ -84,9 +85,8 @@ class KotlinInteropChecks(val reporter: Reporter) {
                 if (annotation != null) {
                     // There can be multiple values
                     for (attribute in annotation.attributes) {
-                        for (v in attribute.leafValues()) {
-                            val source = v.toSource()
-                            if (source.endsWith(exception.simpleName() + "::class")) {
+                        for (v in attribute.value.asFlatList()) {
+                            if (v is ClassObjectValue && v.typeItem == exception.type()) {
                                 return
                             }
                         }
@@ -223,6 +223,12 @@ class KotlinInteropChecks(val reporter: Reporter) {
             return
         }
 
+        if (method.containingClass().modifiers.isData() && method.name() == "copy") {
+            // The generated copy method for a data class cannot be annotated. It is possible this
+            // also skips warning for a copy method defined in source for a data class.
+            return
+        }
+
         var haveDefault = false
         for (parameter in parameters) {
             if (parameter.hasDefaultValue()) {
diff --git a/metalava/src/main/java/com/android/tools/metalava/MainCommand.kt b/metalava/src/main/java/com/android/tools/metalava/MainCommand.kt
index f72455bcd..058f7efbe 100644
--- a/metalava/src/main/java/com/android/tools/metalava/MainCommand.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/MainCommand.kt
@@ -221,8 +221,8 @@ class MainCommand(
         val sourceModelProvider =
             // Use the [SourceModelProvider] specified by the [TestEnvironment], if any.
             executionEnvironment.testEnvironment?.sourceModelProvider
-            // Otherwise, use the one specified on the command line, or the default.
-            ?: SourceModelProvider.getImplementation(optionGroup.sourceModelProvider)
+                // Otherwise, use the one specified on the command line, or the default.
+                ?: SourceModelProvider.getImplementation(optionGroup.sourceModelProvider)
 
         try {
             sourceModelProvider
diff --git a/metalava/src/main/java/com/android/tools/metalava/Options.kt b/metalava/src/main/java/com/android/tools/metalava/Options.kt
index f2839adcb..080cd282a 100644
--- a/metalava/src/main/java/com/android/tools/metalava/Options.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/Options.kt
@@ -203,6 +203,7 @@ class Options(
     /** Writer to direct output to. */
     val stdout: PrintWriter
         get() = executionEnvironment.stdout
+
     /** Writer to direct error messages to. */
     val stderr: PrintWriter
         get() = executionEnvironment.stderr
@@ -301,6 +302,9 @@ class Options(
     /** Lint project description that describes project's module structure in details */
     var projectDescription: File? = null
 
+    /** Jar file with the compiled version of the sources from [sources]/[sourcePath]. */
+    val compiledSourceJar: File? by sourceOptions::compiledSourceJar
+
     val apiClassResolution by
         enumOption(
             help =
@@ -343,8 +347,7 @@ class Options(
                     (reportable as? Item)?.let { item ->
                         val pkg = (item as? PackageItem) ?: item.containingPackage()
                         pkg == null || packageFilter.matches(pkg)
-                    }
-                        ?: true
+                    } ?: true
                 }
             }
         }
diff --git a/metalava/src/main/java/com/android/tools/metalava/SdkFileWriter.kt b/metalava/src/main/java/com/android/tools/metalava/SdkFileWriter.kt
index 06702a632..12d7ac2f7 100644
--- a/metalava/src/main/java/com/android/tools/metalava/SdkFileWriter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/SdkFileWriter.kt
@@ -16,9 +16,10 @@
 
 package com.android.tools.metalava
 
+import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.value.asString
 import java.io.BufferedWriter
 import java.io.File
 import java.io.FileWriter
@@ -73,24 +74,26 @@ class SdkFileWriter(val codebase: Codebase, private val outputDir: File) {
             // first check constant fields for the SdkConstant annotation.
             val fields = clazz.fields()
             for (field in fields) {
-                val value = field.legacyInitialValue() ?: continue
-                val annotations = field.modifiers.annotations()
-                for (annotation in annotations) {
-                    if (ANDROID_SDK_CONSTANT == annotation.qualifiedName) {
-                        val resolved =
-                            annotation.findAttribute(null)?.leafValues()?.firstOrNull()?.resolve()
-                                as? FieldItem
-                                ?: continue
-                        when (resolved.containingClass().qualifiedName() + "." + resolved.name()) {
-                            SDK_CONSTANT_TYPE_ACTIVITY_ACTION ->
-                                activityActions.add(value.toString())
-                            SDK_CONSTANT_TYPE_BROADCAST_ACTION ->
-                                broadcastActions.add(value.toString())
-                            SDK_CONSTANT_TYPE_SERVICE_ACTION -> serviceActions.add(value.toString())
-                            SDK_CONSTANT_TYPE_CATEGORY -> categories.add(value.toString())
-                            SDK_CONSTANT_TYPE_FEATURE -> features.add(value.toString())
-                        }
-                    }
+                // Only interested in ones annotated with SdkConstant.
+                val sdkConstantAnnotation =
+                    field.modifiers.findAnnotation(ANDROID_SDK_CONSTANT) ?: continue
+
+                // Get the value of the field, as a string even if it is defined in terms of another
+                // field. If it has no such value ignore the field.
+                val underlyingString = field.constantValue?.asString() ?: continue
+
+                // Get the SdkConstantType from the SdkConstant annotation's `value` attribute,
+                // if available.
+                val sdkConstantType =
+                    sdkConstantAnnotation.findAttribute(ANNOTATION_ATTR_VALUE)?.value ?: continue
+
+                // Add the field value to the appropriate collection for the SdkConstantType.
+                when (sdkConstantType.toValueString()) {
+                    SDK_CONSTANT_TYPE_ACTIVITY_ACTION -> activityActions.add(underlyingString)
+                    SDK_CONSTANT_TYPE_BROADCAST_ACTION -> broadcastActions.add(underlyingString)
+                    SDK_CONSTANT_TYPE_SERVICE_ACTION -> serviceActions.add(underlyingString)
+                    SDK_CONSTANT_TYPE_CATEGORY -> categories.add(underlyingString)
+                    SDK_CONSTANT_TYPE_FEATURE -> features.add(underlyingString)
                 }
             }
 
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/AddApisFromCodebase.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/AddApisFromCodebase.kt
index 3f8e45b60..5253e0722 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/AddApisFromCodebase.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/AddApisFromCodebase.kt
@@ -51,7 +51,13 @@ fun addApisFromCodebase(
             }
 
             override fun visitClass(cls: ClassItem) {
-                val newClass = api.updateClass(cls.nameInApi(), updater, cls.effectivelyDeprecated)
+                val newClass =
+                    api.updateClass(
+                        cls.nameInApi(),
+                        updater,
+                        cls.effectivelyDeprecated,
+                        cls.isEnum(),
+                    )
                 currentClass = newClass
 
                 when (cls.classKind) {
@@ -70,11 +76,6 @@ fun addApisFromCodebase(
                         if (newClass.name != enumClass) {
                             newClass.updateSuperClass(enumClass, updater)
                         }
-
-                        // Mimic doclava enum methods
-                        enumMethodNames(newClass.name).forEach { name ->
-                            newClass.updateMethod(name, updater, false)
-                        }
                     }
                     ClassKind.ANNOTATION_TYPE -> {
                         // Implicit super class; match convention from bytecode
@@ -159,44 +160,7 @@ fun addApisFromCodebase(
                 val separator = if (useInternalNames) "/" else "."
                 return nameParts.joinToString(separator)
             }
-
-            /** The names of the doclava enum methods, based on [Api.useInternalNames] */
-            fun enumMethodNames(className: String): List<String> {
-                return if (useInternalNames) {
-                    listOf("valueOf(Ljava/lang/String;)L$className;", "values()[L$className;")
-                } else {
-                    listOf("valueOf(java.lang.String)", "values()")
-                }
-            }
         }
 
     codebaseFragment.accept(delegatedVisitor)
 }
-
-/**
- * Like [CallableItem.internalName] but is the desc-portion of the internal signature, e.g. for the
- * method "void create(int x, int y)" the internal name of the constructor is "create" and the desc
- * is "(II)V"
- */
-fun CallableItem.internalDesc(voidConstructorTypes: Boolean = false): String {
-    val sb = StringBuilder()
-    sb.append("(")
-
-    // Inner, i.e. non-static nested, classes get an implicit constructor parameter for the
-    // outer type
-    if (
-        isConstructor() &&
-            containingClass().containingClass() != null &&
-            !containingClass().modifiers.isStatic()
-    ) {
-        sb.append(containingClass().containingClass()?.type()?.internalName() ?: "")
-    }
-
-    for (parameter in parameters()) {
-        sb.append(parameter.type().internalName())
-    }
-
-    sb.append(")")
-    sb.append(if (voidConstructorTypes && isConstructor()) "V" else returnType().internalName())
-    return sb.toString()
-}
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/Api.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/Api.kt
index d83f6460e..86c52edba 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/Api.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/Api.kt
@@ -60,16 +60,18 @@ class Api(val useInternalNames: Boolean) : ParentApiElement {
      * @param name the name of the class
      * @param updater the [ApiHistoryUpdater] that will update the element with information about
      *   the version to which it belongs.
-     * @param deprecated whether the class was deprecated in the API version
-     * @return the newly created or a previously existed class
+     * @param deprecated whether the class was deprecated in the API version.
+     * @param isEnum whether the class is an enum class.
+     * @return the newly created or an already existing class.
      */
     fun updateClass(
         name: String,
         updater: ApiHistoryUpdater,
         deprecated: Boolean,
+        isEnum: Boolean,
     ): ApiClass {
         val existing = mClasses[name]
-        val classElement = existing ?: ApiClass(name).apply { mClasses[name] = this }
+        val classElement = existing ?: ApiClass(name, isEnum).apply { mClasses[name] = this }
         updater.update(classElement, deprecated)
         return classElement
     }
@@ -84,6 +86,10 @@ class Api(val useInternalNames: Boolean) : ParentApiElement {
         removeImplicitInterfaces()
         removeOverridingMethods()
         prunePackagePrivateClasses()
+
+        // Add any class dependent members. This is done here, after creating the API, as they need
+        // to copy the containing class's state and that changes during creation.
+        addClassDependentMembersIfNeeded()
     }
 
     val classes: Collection<ApiClass>
@@ -97,9 +103,9 @@ class Api(val useInternalNames: Boolean) : ParentApiElement {
     fun patchSdkExtensionsHistory() {
         val sdkExtensions =
             findClass("android/os/ext/SdkExtensions")
-            // This is either for the module-lib/system-server (null) or for a non-Android API.
-            // Either way it does not need patching.
-            ?: return
+                // This is either for the module-lib/system-server (null) or for a non-Android API.
+                // Either way it does not need patching.
+                ?: return
 
         val sdk30 = ApiVersion.fromLevel(30)
         val sdk31 = ApiVersion.fromLevel(31)
@@ -179,6 +185,18 @@ class Api(val useInternalNames: Boolean) : ParentApiElement {
         }
     }
 
+    /**
+     * Adds class dependent members, if needed.
+     *
+     * These are members whose history is identical to the containing class, e.g. compiler generated
+     * enum methods.
+     */
+    private fun addClassDependentMembersIfNeeded() {
+        for (cls in mClasses.values) {
+            cls.addClassDependentMembersIfNeeded()
+        }
+    }
+
     fun removeMissingClasses() {
         for (cls in mClasses.values) {
             cls.removeMissingClasses(mClasses)
@@ -201,7 +219,8 @@ class Api(val useInternalNames: Boolean) : ParentApiElement {
         if (results.isNotEmpty()) {
             var message = ""
             for ((key, value) in results) {
-                message += """
+                message +=
+                    """
   $key referenced by:"""
                 for (referencer in value) {
                     message += "\n    $referencer"
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiClass.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiClass.kt
index d1e28fdac..1a877c12c 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiClass.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiClass.kt
@@ -21,7 +21,7 @@ import com.google.common.collect.Iterables
  * Represents a class or an interface and its methods/fields. This is used to write the simplified
  * XML file containing all the public API.
  */
-class ApiClass(name: String) : ApiElement(name) {
+class ApiClass(name: String, private val isEnum: Boolean) : ApiElement(name) {
 
     private val mSuperClasses = mutableMapOf<String, ApiElement>()
     private val mInterfaces = mutableMapOf<String, ApiElement>()
@@ -79,6 +79,29 @@ class ApiClass(name: String) : ApiElement(name) {
     val methods: Collection<ApiElement>
         get() = mMethods.values
 
+    /** The names of the compiler generated enum methods. */
+    private fun enumMethodNames(): List<String> {
+        return if (name.contains("/")) {
+            listOf("valueOf(Ljava/lang/String;)L$name;", "values()[L$name;")
+        } else {
+            listOf("valueOf(java.lang.String)", "values()")
+        }
+    }
+
+    /**
+     * Adds class dependent members, if needed.
+     *
+     * These are members whose history is identical to the containing class, e.g. compiler generated
+     * enum methods.
+     */
+    fun addClassDependentMembersIfNeeded() {
+        if (!isEnum) return
+
+        for (methodName in enumMethodNames()) {
+            mMethods[methodName] = ApiElement(methodName, this)
+        }
+    }
+
     /**
      * Updates an element for [superClassType], creating and adding one if necessary.
      *
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiElement.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiElement.kt
index f92157702..e83c47009 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiElement.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiElement.kt
@@ -47,13 +47,28 @@ interface ParentApiElement {
  * @param name the name of the API element
  */
 open class ApiElement(val name: String) : ParentApiElement, Comparable<ApiElement> {
+    /**
+     * A special constructor, used by [ApiClass.addClassDependentMembersIfNeeded] that will be used
+     * to create additional members on [containingClass] whose API history is identical to the
+     * class.
+     *
+     * This is currently used for compiler generated enum methods `valueOf(String)` and `values()`.
+     */
+    internal constructor(name: String, containingClass: ApiClass) : this(name) {
+        since = containingClass.since
+        sinceExtension = containingClass.sinceExtension
+        sdks = containingClass.sdks
+        mainlineModule = containingClass.mainlineModule
+        deprecatedIn = containingClass.deprecatedIn
+        lastPresentIn = containingClass.lastPresentIn
+    }
 
     /**
      * The Android API level of this ApiElement. i.e. The Android platform SDK version this API was
      * first introduced in.
      */
     final override lateinit var since: ApiVersion
-        private set
+        protected set
 
     /**
      * The extension version of this ApiElement. i.e. The Android extension SDK version this API was
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiHistoryUpdater.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiHistoryUpdater.kt
index ccf0d68d8..9a68e25b5 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiHistoryUpdater.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiHistoryUpdater.kt
@@ -60,11 +60,15 @@ sealed interface ApiHistoryUpdater {
     /**
      * Extends [ApiVersionUpdater] to also update the [ApiElement.sinceExtension] and
      * [ApiElement.mainlineModule] properties.
+     *
+     * This will only call the super class' [ApiVersionUpdater.update] method if
+     * [isLatestExtVersion] is `true`.
      */
     private class ExtensionUpdater(
         nextSdkVersion: ApiVersion,
         private val extVersion: ExtVersion,
-        private val module: String
+        private val module: String,
+        private val isLatestExtVersion: Boolean,
     ) : ApiVersionUpdater(nextSdkVersion) {
         override fun update(api: Api) {
             // Do not update the Api with the next sdk version as that could cause all classes
@@ -73,7 +77,10 @@ sealed interface ApiHistoryUpdater {
         }
 
         override fun update(apiElement: ApiElement, deprecated: Boolean) {
-            super.update(apiElement, deprecated)
+            // Only update the ApiVersion if this is the latest extension version.
+            if (isLatestExtVersion) {
+                super.update(apiElement, deprecated)
+            }
             apiElement.updateExtension(extVersion)
             if (apiElement is ApiClass) {
                 apiElement.updateMainlineModule(module)
@@ -99,9 +106,10 @@ sealed interface ApiHistoryUpdater {
         fun forExtVersion(
             nextSdkVersion: ApiVersion,
             extVersion: ExtVersion,
-            module: String
+            module: String,
+            isLatestExtVersion: Boolean,
         ): ApiHistoryUpdater {
-            return ExtensionUpdater(nextSdkVersion, extVersion, module)
+            return ExtensionUpdater(nextSdkVersion, extVersion, module, isLatestExtVersion)
         }
     }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/JarReaderUtils.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/JarReaderUtils.kt
index 756ab6fb9..77a69cd77 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/JarReaderUtils.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/JarReaderUtils.kt
@@ -16,11 +16,14 @@
 package com.android.tools.metalava.apilevels
 
 import com.android.SdkConstants
+import com.android.tools.metalava.model.JAVA_ENUM_VALUES
+import com.android.tools.metalava.model.JAVA_ENUM_VALUE_OF
 import java.io.File
 import java.io.FileInputStream
 import java.util.zip.ZipInputStream
 import org.objectweb.asm.ClassReader
 import org.objectweb.asm.Opcodes
+import org.objectweb.asm.Type
 import org.objectweb.asm.tree.ClassNode
 import org.objectweb.asm.tree.FieldNode
 import org.objectweb.asm.tree.MethodNode
@@ -51,15 +54,19 @@ fun Api.readJar(
             val classNode = ClassNode(Opcodes.ASM5)
             reader.accept(classNode, 0)
 
-            val classDeprecated = isDeprecated(classNode.access)
+            val classAccess = classNode.access
+            val isEnum = (classAccess and Opcodes.ACC_ENUM) != 0
+
+            val classDeprecated = isDeprecated(classAccess)
             val theClass =
                 updateClass(
                     classNode.name,
                     updater,
                     classDeprecated,
+                    isEnum,
                 )
 
-            theClass.updateHidden((classNode.access and Opcodes.ACC_PUBLIC) == 0)
+            theClass.updateHidden((classAccess and Opcodes.ACC_PUBLIC) == 0)
 
             // super class
             if (classNode.superName != null) {
@@ -86,19 +93,53 @@ fun Api.readJar(
                 }
             }
 
+            // If this is an enum class then it will contain two methods added by the compiler, i.e.
+            //   public static E valueOf(String)
+            //   public static E[] values()
+            //
+            // Those methods are not recorded in signature files as there is no point in tracking
+            // their history separately from the class. So, they need to be ignored here.
+            //
+            // If needed, compute the description of the two enum methods to simplify comparison.
+            val (valueOfDesc, valuesDesc) =
+                if (isEnum) {
+                    val enumType = Type.getObjectType(classNode.name)
+                    "(Ljava/lang/String;)${enumType.descriptor}" to "()[$enumType"
+                } else null to null
+
             // methods
             for (method in classNode.methods) {
                 val methodNode = method as MethodNode
-                if ((methodNode.access and (Opcodes.ACC_PUBLIC or Opcodes.ACC_PROTECTED)) == 0) {
+                val methodAccess = methodNode.access
+
+                // The only methods of interest are public and protected methods.
+                if ((methodAccess and (Opcodes.ACC_PUBLIC or Opcodes.ACC_PROTECTED)) == 0) {
                     continue
                 }
-                if (methodNode.name != "<clinit>") {
-                    theClass.updateMethod(
-                        methodNode.name + methodNode.desc,
-                        updater,
-                        classDeprecated || isDeprecated(methodNode.access),
-                    )
+                val methodName = method.name
+
+                // The class initializer is an implementation detail.
+                if (methodName == "<clinit>") {
+                    continue
                 }
+
+                val methodDesc = methodNode.desc
+                // Ignore synthetic enum methods, i.e. valueOf(String) and values().
+                if (
+                    isEnum &&
+                        methodAccess and Opcodes.ACC_STATIC != 0 &&
+                        (methodName == JAVA_ENUM_VALUE_OF && methodDesc == valueOfDesc) ||
+                        (methodName == JAVA_ENUM_VALUES && methodDesc == valuesDesc)
+                ) {
+                    continue
+                }
+
+                // Add the method.
+                theClass.updateMethod(
+                    methodName + methodDesc,
+                    updater,
+                    classDeprecated || isDeprecated(methodAccess),
+                )
             }
         }
     }
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/PatternNode.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/PatternNode.kt
index e6793274f..c09412c4e 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/PatternNode.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/PatternNode.kt
@@ -442,6 +442,26 @@ sealed class PatternNode {
             }
         },
 
+        /**
+         * Corresponds to the [PatternFileState.library] and [MatchedPatternFile.library]
+         * properties.
+         */
+        LIBRARY(
+            "library",
+            help = {
+                """
+                    Optional property that stores the name of a library.
+                """
+            },
+        ) {
+            override fun track(
+                config: ScanConfig,
+                state: PatternFileState,
+                value: String,
+                placeholder: Placeholder,
+            ) = state.copy(library = value)
+        },
+
         /**
          * Corresponds to the [PatternFileState.module] and [MatchedPatternFile.module] properties.
          */
@@ -590,6 +610,28 @@ sealed class PatternNode {
             },
         ),
 
+        /**
+         * The {library} placeholder.
+         *
+         * Generally, each version/module pair is supposed to have a single file representing it for
+         * each surface. However, sometimes it can be broken down into multiple files, e.g.
+         * `android.test.base.jar` was previously part of `android.jar` but was separated out. So,
+         * in order to generate an accurate history of the `android.test` classes it is necessary to
+         * include the `android.test.base.jar` alongside `android.jar`. That can be achieved by
+         * using the {library} placeholder.
+         */
+        LIBRARY(
+            property = Property.LIBRARY,
+            format = null,
+            pattern = """[a-z-.]+""",
+            help = {
+                """
+                    Matches a library name which must consist of lower case letters, hyphens and
+                    `.`s.
+                """
+            },
+        ),
+
         /** The {module} placeholder. */
         MODULE(
             property = Property.MODULE,
@@ -819,6 +861,9 @@ internal data class PatternFileState(
 
     /** The optional surface that was extracted from the path. */
     val surface: ApiSurface? = null,
+
+    /** The optional name of the library. */
+    val library: String? = null,
 ) {
     /**
      * Construct a [MatchedPatternFile] from this.
@@ -835,6 +880,7 @@ internal data class PatternFileState(
                 extension = extension,
                 module = module,
                 surface = surface,
+                library = library,
             )
 
     /**
@@ -871,6 +917,9 @@ data class MatchedPatternFile(
 
     /** The optional surface that was extracted from the [File] path. */
     val surface: ApiSurface? = null,
+
+    /** The optional library that was extracted from the [File] path. */
+    val library: String? = null,
 ) {
     /**
      * Create a string representation of the properties, used for testing and debugging.
@@ -899,6 +948,11 @@ data class MatchedPatternFile(
                 append(surface.name)
                 append("'")
             }
+            if (library != null) {
+                append(", library='")
+                append(library)
+                append("'")
+            }
             append(")")
         }
     }
@@ -917,6 +971,8 @@ private val matchedPatternFileComparator: Comparator<MatchedPatternFile> =
         { it.module },
         // Then sort them from the lowest version to the highest version.
         { it.version },
+        // Group into those without libraries and then by those with library, in order.
+        { it.library },
         // Then group into those without surface and then by those with a surface, in order.
         { it.surface },
     )
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedJarApi.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedJarApi.kt
index 1b6cbeaa6..80ef0c985 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedJarApi.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedJarApi.kt
@@ -16,6 +16,7 @@
 
 package com.android.tools.metalava.apilevels
 
+import com.android.tools.metalava.apilevels.VersionedSignatureApi.Companion.stringsToBashBraceExpansion
 import java.io.File
 
 /**
@@ -24,13 +25,24 @@ import java.io.File
  * The [updater] is responsible for updating the [Api].
  */
 class VersionedJarApi(
-    val jar: File,
+    val files: List<File>,
     updater: ApiHistoryUpdater,
     private val filter: ((String) -> Boolean)? = null,
 ) : VersionedApi(updater) {
     override fun updateApi(api: Api) {
-        api.readJar(jar, updater, filter)
+        for (file in files) {
+            api.readJar(file, updater, filter)
+        }
     }
 
-    override fun toString() = "VersionedJarApi(jar=$jar, updater=$updater)"
+    override fun toString(): String {
+        // Compute the string representation of the files. Listing a number of potentially long
+        // files all on one line can make it difficult to debug. As the files are likely to contain
+        // common prefixes and suffixes, e.g. `prebuilts/sdk/28/public/api/android.txt` and
+        // `prebuilts/sdk/28/system/api/android.txt` this replaces it with a string that uses bash
+        // brace expansion syntax so it would generate all the original if used in bash, e.g.
+        // `prebuilts/sdk/28/{public,system}/api/android.txt`.
+        val filesAsString = stringsToBashBraceExpansion(files.map { it.path })
+        return "VersionedJarApi(jar=$filesAsString, updater=$updater)"
+    }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/common/SourceOptions.kt b/metalava/src/main/java/com/android/tools/metalava/cli/common/SourceOptions.kt
index 958080e71..2ab71657e 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/common/SourceOptions.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/common/SourceOptions.kt
@@ -17,6 +17,7 @@
 package com.android.tools.metalava.cli.common
 
 import com.android.SdkConstants
+import com.android.tools.metalava.ARG_SOURCE_FILES
 import com.android.tools.metalava.model.PackageFilter
 import com.github.ajalt.clikt.parameters.groups.OptionGroup
 import com.github.ajalt.clikt.parameters.options.convert
@@ -27,6 +28,8 @@ const val ARG_SOURCE_PATH = "--source-path"
 
 const val ARG_STUB_PACKAGES = "--stub-packages"
 
+const val ARG_COMPILED_SOURCES = "--compiled-sources"
+
 /** The name of the group, can be used in help text to refer to the options in this group. */
 const val SOURCE_OPTIONS_GROUP = "Sources"
 
@@ -90,4 +93,18 @@ class SourceOptions :
                         .trimIndent()
             )
             .convert { PackageFilter.parse(it) }
+
+    val compiledSourceJar by
+        option(
+                ARG_COMPILED_SOURCES,
+                metavar = "<path>",
+                help =
+                    """
+                        Jar file with the compiled version of $ARG_SOURCE_FILES, loaded in addition
+                        to the source files. Used to include the bytecode version of Kotlin source
+                        APIs.
+                    """
+                        .trimIndent(),
+            )
+            .existingFile()
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/flag/FlagReportCommand.kt b/metalava/src/main/java/com/android/tools/metalava/cli/flag/FlagReportCommand.kt
new file mode 100644
index 000000000..ffaa60487
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/flag/FlagReportCommand.kt
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.cli.flag
+
+import com.android.tools.metalava.ARG_CONFIG_FILE
+import com.android.tools.metalava.ApiFlagsCreator
+import com.android.tools.metalava.ConfigFileOptions
+import com.android.tools.metalava.OptionsDelegate
+import com.android.tools.metalava.cli.common.DefaultSignatureFileLoader
+import com.android.tools.metalava.cli.common.MetalavaSubCommand
+import com.android.tools.metalava.cli.common.cliError
+import com.android.tools.metalava.cli.common.existingFile
+import com.android.tools.metalava.flag.ApiFlagReportProducer
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.api.flags.ApiFlag
+import com.android.tools.metalava.model.text.SignatureFile
+import com.github.ajalt.clikt.parameters.arguments.argument
+import com.github.ajalt.clikt.parameters.arguments.multiple
+import com.github.ajalt.clikt.parameters.groups.provideDelegate
+
+class FlagReportCommand :
+    MetalavaSubCommand(
+        help = "Generates a flag report",
+    ) {
+    private val flagReportOptions by FlagReportOptions()
+
+    private val configFileOptions by ConfigFileOptions()
+
+    private val apiFiles by
+        argument(
+                name = "<api-file>",
+                help = "API signature files for which the flag report is being generated.",
+            )
+            .existingFile()
+            .multiple(required = true)
+
+    override fun run() {
+        // Make sure that none of the code called by this command accesses the global `options`
+        // property.
+        OptionsDelegate.disallowAccess()
+
+        val apiFlagsConfig =
+            configFileOptions.config.apiFlags
+                ?: cliError(
+                    "Must provide a $ARG_CONFIG_FILE option that specifies a config file containing an `<api-flags/>` entry"
+                )
+
+        // Create flags; do not prune away any flags that have the default behavior of reverting so
+        // that this can differentiate between known flags that revert and unknown flags that will
+        // revert by default.
+        val apiFlags =
+            ApiFlagsCreator.createFromConfig(apiFlagsConfig, pruneDisabledFlags = false)!!
+
+        // Load the Codebase from the signature files.
+        val codebaseConfig = Codebase.Config.NOOP
+        val signatureFileLoader = DefaultSignatureFileLoader(codebaseConfig)
+        val signatureApi = signatureFileLoader.load(SignatureFile.fromFiles(apiFiles))
+
+        // Produce a report for how the supplied flags affect the Codebase.
+        val report = ApiFlagReportProducer.produceFlagReport(signatureApi, apiFlags)
+
+        // Output the report file.
+        val reportFile = flagReportOptions.flagReportFile
+        reportFile.printWriter().use { writer ->
+            for ((qualifiedName, apiFlag) in report.flagStatuses) {
+                val status =
+                    when (apiFlag) {
+                        ApiFlag.KEEP_FLAGGED_API -> "known,kept"
+                        ApiFlag.FINALIZE_FLAGGED_API -> "known,finalized"
+                        ApiFlag.REVERT_FLAGGED_API -> "known,reverted"
+                        else -> "unknown,reverted"
+                    }
+                writer.println("$qualifiedName,$status")
+            }
+        }
+    }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/flag/FlagReportOptions.kt b/metalava/src/main/java/com/android/tools/metalava/cli/flag/FlagReportOptions.kt
new file mode 100644
index 000000000..c67547479
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/flag/FlagReportOptions.kt
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.cli.flag
+
+import com.android.tools.metalava.cli.common.HARD_NEWLINE
+import com.android.tools.metalava.cli.common.newFile
+import com.github.ajalt.clikt.parameters.groups.OptionGroup
+import com.github.ajalt.clikt.parameters.options.option
+import com.github.ajalt.clikt.parameters.options.required
+import com.github.ajalt.clikt.parameters.options.validate
+
+/** The name of the group, can be used in help text to refer to the options in this group. */
+const val FLAG_REPORT_OPTIONS_GROUP = "Flag Report"
+
+class FlagReportOptions :
+    OptionGroup(
+        name = FLAG_REPORT_OPTIONS_GROUP,
+        help =
+            """
+                Options that control the flag report file.
+            """
+                .trimIndent(),
+    ) {
+
+    internal val flagReportFile by
+        option(
+                "--output-file",
+                help =
+                    """
+                        A file into which Metalava will output a report about how flags provided by
+                        a --config-file affect the signature files passed to this command.
+
+                        The extension of the file determines the output. Currently, only `csv` is
+                        supported and it will output a CSV file with three columns:
+
+                        1. The qualified flag name.$HARD_NEWLINE
+                        2. Either "known" or "unknown".$HARD_NEWLINE
+                        3. Either "kept", "finalized", reverted"$HARD_NEWLINE
+                    """,
+                metavar = "<file>",
+            )
+            .newFile()
+            .required()
+            .validate { file ->
+                require(file.extension == "csv") {
+                    "Extension of flag report file '$file' must be csv but it was '${file.extension}'"
+                }
+            }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/help/IssuesCommand.kt b/metalava/src/main/java/com/android/tools/metalava/cli/help/IssuesCommand.kt
index 824d4770f..1e9c72f5d 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/help/IssuesCommand.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/help/IssuesCommand.kt
@@ -44,7 +44,7 @@ class IssuesCommand :
                         val dataColumnHeaders = formatDataColumns("Category", "Default Severity")
                         return """
 Available Issues                             $dataColumnHeaders
----------------------------------------------+--------------------------+--------------------
+---------------------------------------------+---------------------------------------+--------------------
                             """
                             .trimIndent()
                     }
@@ -138,7 +138,7 @@ internal fun formatDataColumns(
     severity: String,
     useNonBreakingSpace: Boolean = false
 ): String {
-    return "|  %-22s  |   %s".format(category, severity).let {
+    return "|  %-35s  |   %s".format(category, severity).let {
         if (useNonBreakingSpace) it.replace(" ", NON_BREAKING_SPACE) else it
     }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/historical/ConvertJarsToSignatureFiles.kt b/metalava/src/main/java/com/android/tools/metalava/cli/historical/ConvertJarsToSignatureFiles.kt
index 109ef2284..25f5ea8bb 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/historical/ConvertJarsToSignatureFiles.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/historical/ConvertJarsToSignatureFiles.kt
@@ -31,7 +31,6 @@ import com.android.tools.metalava.model.ANDROIDX_NULLABLE
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.CodebaseFragment
-import com.android.tools.metalava.model.DefaultAnnotationItem
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.FilterPredicate
 import com.android.tools.metalava.model.Item
@@ -318,10 +317,8 @@ class ConvertJarsToSignatureFiles(
                 setDeprecated(true)
                 // Add a Deprecated annotation to be consistent with model providers.
                 addAnnotation(
-                    DefaultAnnotationItem.create(
-                        codebase,
+                    codebase.createAnnotationFromAttributes(
                         JAVA_LANG_DEPRECATED,
-                        emptyList(),
                         context = this@deprecateIfRequired
                     )
                 )
diff --git a/metalava/src/main/java/com/android/tools/metalava/compatibility/CompatibilityCheck.kt b/metalava/src/main/java/com/android/tools/metalava/compatibility/CompatibilityCheck.kt
index c8f62ff04..a696bd4f4 100644
--- a/metalava/src/main/java/com/android/tools/metalava/compatibility/CompatibilityCheck.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/compatibility/CompatibilityCheck.kt
@@ -20,8 +20,6 @@ import com.android.tools.metalava.CodebaseComparator
 import com.android.tools.metalava.ComparisonVisitor
 import com.android.tools.metalava.JVM_DEFAULT_WITH_COMPATIBILITY
 import com.android.tools.metalava.cli.common.cliError
-import com.android.tools.metalava.model.ANDROID_SYSTEM_API
-import com.android.tools.metalava.model.ANDROID_TEST_API
 import com.android.tools.metalava.model.ArrayTypeItem
 import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
@@ -31,13 +29,15 @@ import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.FilterPredicate
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.Item.Companion.describe
-import com.android.tools.metalava.model.ItemLanguage
 import com.android.tools.metalava.model.MergedCodebase
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.MultipleTypeVisitor
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.SelectableItem
+import com.android.tools.metalava.model.SourceLanguage
+import com.android.tools.metalava.model.TargetLanguage
+import com.android.tools.metalava.model.TargetLanguageSet
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeNullability
 import com.android.tools.metalava.model.VariableTypeItem
@@ -49,18 +49,17 @@ import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.reporter.Issues.Issue
 import com.android.tools.metalava.reporter.Reporter
 import com.android.tools.metalava.reporter.Severity
-import com.intellij.psi.PsiField
 
 /**
  * Compares the current API with a previous version and makes sure the changes are compatible. For
  * example, you can make a previously nullable parameter non null, but not vice versa.
  */
 class CompatibilityCheck(
-    val filterReference: FilterPredicate,
-    private val apiType: ApiType,
+    private val filterReference: FilterPredicate,
     private val reporter: Reporter,
     private val issueConfiguration: IssueConfiguration,
     private val apiCompatAnnotations: Set<String>,
+    private val apiName: String?,
 ) : ComparisonVisitor() {
 
     var foundProblems = false
@@ -221,6 +220,41 @@ class CompatibilityCheck(
         compareItemNullability(old, new)
     }
 
+    override fun compareSelectableItems(old: SelectableItem, new: SelectableItem) {
+        // Adding target languages is allowed, removing is not
+        val removedTargetLanguages = old.targetLanguages.minus(new.targetLanguages)
+        val item = Item.Companion.describe(new)
+        // Report issues on the old version of the item. If they were reported on the new version,
+        // they wouldn't end up reported, since removing from bytecode is only binary breaking and
+        // wouldn't be reported for the new item which only targets source (similarly for removing
+        // a source target language).
+        for (removedTargetLanguage in removedTargetLanguages) {
+            when (removedTargetLanguage) {
+                TargetLanguage.BYTECODE -> {
+                    report(
+                        Issues.REMOVED_FROM_BYTECODE,
+                        old,
+                        "$item has been removed from bytecode",
+                    )
+                }
+                TargetLanguage.KOTLIN -> {
+                    report(
+                        Issues.REMOVED_FROM_KOTLIN,
+                        old,
+                        "$item can no longer be resolved from Kotlin source",
+                    )
+                }
+                TargetLanguage.JAVA -> {
+                    report(
+                        Issues.REMOVED_FROM_JAVA,
+                        old,
+                        "$item can no longer be resolved from Java source",
+                    )
+                }
+            }
+        }
+    }
+
     override fun compareParameterItems(old: ParameterItem, new: ParameterItem) {
         val prevName = old.publicName()
         val newName = new.publicName()
@@ -725,27 +759,16 @@ class CompatibilityCheck(
                 val message =
                     "${describe(new, capitalize = true)} has changed type from $oldType to $newType"
                 report(Issues.CHANGED_TYPE, new, message)
-            } else if (!old.hasSameValue(new)) {
-                val prevValue = old.legacyInitialValue()
-                val prevString =
-                    if (prevValue == null && !old.modifiers.isFinal()) {
-                        "nothing/not constant"
-                    } else {
-                        prevValue
-                    }
-
-                val newValue = new.legacyInitialValue()
-                val newString =
-                    if (newValue is PsiField) {
-                        newValue.containingClass?.qualifiedName + "." + newValue.name
-                    } else {
-                        newValue
-                    }
+            } else if (!old.hasSameConstantValue(new)) {
+                val oldString = old.constantValue?.toValueString() ?: "nothing/not constant"
+                val newString = new.constantValue?.toValueString() ?: "nothing/not constant"
                 val message =
-                    "${describe(
-                    new,
-                    capitalize = true
-                )} has changed value from $prevString to $newString"
+                    "${
+                        describe(
+                            new,
+                            capitalize = true
+                        )
+                    } has changed value from $oldString to $newString"
 
                 report(Issues.CHANGED_VALUE, new, message)
             }
@@ -788,7 +811,7 @@ class CompatibilityCheck(
             oldModifiers.isFinal() &&
                 !newModifiers.isFinal() &&
                 oldModifiers.isStatic() &&
-                old.legacyInitialValue() != null
+                old.constantValue != null
         ) {
             report(
                 Issues.REMOVED_FINAL,
@@ -817,7 +840,6 @@ class CompatibilityCheck(
         }
     }
 
-    @Suppress("DEPRECATION")
     private fun handleAdded(issue: Issue, item: SelectableItem) {
         if (item.originallyHidden) {
             // This is an element which is hidden but is referenced from
@@ -831,16 +853,13 @@ class CompatibilityCheck(
             return
         }
 
-        var message = "Added ${describe(item)}"
-
-        // Clarify error message for removed API to make it less ambiguous
-        if (apiType == ApiType.REMOVED) {
-            message += " to the removed API"
-        } else if (options.allShowAnnotations.isNotEmpty()) {
-            if (options.allShowAnnotations.matchesAnnotationName(ANDROID_SYSTEM_API)) {
-                message += " to the system API"
-            } else if (options.allShowAnnotations.matchesAnnotationName(ANDROID_TEST_API)) {
-                message += " to the test API"
+        val message = buildString {
+            append("Added ")
+            append(describe(item))
+            if (apiName != null) {
+                append(" to the ")
+                append(apiName)
+                append(" API")
             }
         }
 
@@ -927,7 +946,7 @@ class CompatibilityCheck(
                                 // Hack to always mark added Kotlin interface methods as abstract
                                 // until we properly support JVM default methods for Kotlin.
                                 // TODO(b/200077254): Remove Kotlin special case
-                                if (new.itemLanguage == ItemLanguage.KOTLIN) {
+                                if (new.sourceLanguage == SourceLanguage.KOTLIN) {
                                     Issues.ADDED_ABSTRACT_METHOD
                                 } else {
                                     Issues.ADDED_METHOD
@@ -1028,7 +1047,39 @@ class CompatibilityCheck(
             // treat all issues for all unchecked items as `Severity.IGNORE`.
             return
         }
-        if (reporter.report(issue, item, message, location, maximumSeverity = maximumSeverity)) {
+
+        val targetLanguages =
+            (item as? SelectableItem)?.targetLanguages ?: (item.parent())?.targetLanguages
+        val existsInBytecode = targetLanguages?.contains(TargetLanguage.BYTECODE) != false
+        // Add detail about the kind of compatibility issue this is, and skip the issue if it does
+        // not apply to the given target languages.
+        val newMessage =
+            when (issue.category) {
+                Issues.Category.BINARY_AND_SOURCE_COMPATIBILITY -> {
+                    // This issue matters for both binary and source compatibility. Binary compat is
+                    // more important, so if the item exists in bytecode, describe the issue as
+                    // binary breaking. If the item only exists in source, describe the issue as
+                    // source breaking.
+                    if (existsInBytecode) {
+                        "Binary breaking change: $message"
+                    } else {
+                        "Source breaking change: $message"
+                    }
+                }
+                Issues.Category.BINARY_COMPATIBILITY_ONLY -> {
+                    // The item doesn't exist in bytecode, don't report binary compatibility issues.
+                    if (!existsInBytecode) return
+                    "Binary breaking change: $message"
+                }
+                Issues.Category.SOURCE_COMPATIBILITY_ONLY -> {
+                    // The item can't be used from source, don't report source compatibility issues.
+                    if (targetLanguages == TargetLanguageSet.BYTECODE_ONLY) return
+                    "Source breaking change: $message"
+                }
+                else -> message
+            }
+
+        if (reporter.report(issue, item, newMessage, location, maximumSeverity = maximumSeverity)) {
             // If the issue was reported and was an error then remember that this found some
             // problems so that the process can be aborted after finishing the checks.
             val severity = minOf(maximumSeverity, issueConfiguration.getSeverity(issue))
@@ -1047,6 +1098,7 @@ class CompatibilityCheck(
             reporter: Reporter,
             issueConfiguration: IssueConfiguration,
             apiCompatAnnotations: Set<String>,
+            apiName: String?,
         ) {
             val filter =
                 apiType
@@ -1058,10 +1110,10 @@ class CompatibilityCheck(
             val checker =
                 CompatibilityCheck(
                     filter,
-                    apiType,
                     reporter,
                     issueConfiguration,
                     apiCompatAnnotations,
+                    apiName,
                 )
 
             val oldFullCodebase =
diff --git a/metalava/src/main/java/com/android/tools/metalava/config/BuildPropertiesConfig.kt b/metalava/src/main/java/com/android/tools/metalava/config/BuildPropertiesConfig.kt
new file mode 100644
index 000000000..9f5f15535
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/config/BuildPropertiesConfig.kt
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.config
+
+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty
+
+data class BuildPropertiesConfig(
+    @field:JacksonXmlProperty(localName = "build-property", namespace = CONFIG_NAMESPACE)
+    val properties: List<BuildPropertyConfig> = emptyList(),
+) : CombinableConfig<BuildPropertiesConfig> {
+
+    /** Combine with another [BuildPropertyConfig] by concatenating the [properties]s. */
+    override fun combineWith(other: BuildPropertiesConfig) =
+        BuildPropertiesConfig(properties + other.properties)
+
+    /** Validate this object, i.e. check to make sure that the contained objects are consistent. */
+    fun validate() {}
+}
+
+data class BuildPropertyConfig(
+    /** The build property name */
+    @field:JacksonXmlProperty(isAttribute = true) val name: String,
+    /** The build property value */
+    @field:JacksonXmlProperty(isAttribute = true) val value: String,
+) {}
diff --git a/metalava/src/main/java/com/android/tools/metalava/config/Config.kt b/metalava/src/main/java/com/android/tools/metalava/config/Config.kt
index 61e3cd81d..fba775a1b 100644
--- a/metalava/src/main/java/com/android/tools/metalava/config/Config.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/config/Config.kt
@@ -29,6 +29,8 @@ data class Config(
     val apiFlags: ApiFlagsConfig? = null,
     @field:JacksonXmlProperty(localName = "api-surfaces", namespace = CONFIG_NAMESPACE)
     val apiSurfaces: ApiSurfacesConfig? = null,
+    @field:JacksonXmlProperty(localName = "build-properties", namespace = CONFIG_NAMESPACE)
+    val buildProperties: BuildPropertiesConfig? = null,
 ) : CombinableConfig<Config> {
 
     /** Combine this [Config] with another returning a [Config] object that combines them both. */
@@ -36,6 +38,7 @@ data class Config(
         Config(
             apiFlags = combine(apiFlags, other.apiFlags),
             apiSurfaces = combine(apiSurfaces, other.apiSurfaces),
+            buildProperties = combine(buildProperties, other.buildProperties)
         )
 
     /**
@@ -50,6 +53,7 @@ data class Config(
     internal fun validate() {
         apiFlags?.validate()
         apiSurfaces?.validate()
+        buildProperties?.validate()
     }
 }
 
diff --git a/metalava/src/main/java/com/android/tools/metalava/config/ConfigParser.kt b/metalava/src/main/java/com/android/tools/metalava/config/ConfigParser.kt
index a83315528..6e3cbb7b1 100644
--- a/metalava/src/main/java/com/android/tools/metalava/config/ConfigParser.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/config/ConfigParser.kt
@@ -105,8 +105,8 @@ class ConfigParser private constructor() : DefaultHandler() {
                 .reduceOrNull(Config::combineWith)
                 // Validate the config.
                 ?.apply { validate() }
-            // If no configuration files were created then return an empty Config.
-            ?: Config()
+                // If no configuration files were created then return an empty Config.
+                ?: Config()
         }
 
         /**
diff --git a/metalava/src/main/java/com/android/tools/metalava/doc/DocAnalyzer.kt b/metalava/src/main/java/com/android/tools/metalava/doc/DocAnalyzer.kt
index cd149b942..67652cedb 100644
--- a/metalava/src/main/java/com/android/tools/metalava/doc/DocAnalyzer.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/doc/DocAnalyzer.kt
@@ -27,7 +27,6 @@ import com.android.tools.metalava.apilevels.ApiVersion
 import com.android.tools.metalava.cli.common.ExecutionEnvironment
 import com.android.tools.metalava.model.ANDROIDX_ANNOTATION_PREFIX
 import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
-import com.android.tools.metalava.model.AnnotationAttributeValue
 import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
@@ -41,11 +40,18 @@ import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.SelectableItem
-import com.android.tools.metalava.model.getAttributeValue
 import com.android.tools.metalava.model.getCallableParameterDescriptorUsingDots
 import com.android.tools.metalava.model.psi.containsLinkTags
+import com.android.tools.metalava.model.value.FieldReferenceValue
+import com.android.tools.metalava.model.value.FloatingPointValue
+import com.android.tools.metalava.model.value.IntegralValue
+import com.android.tools.metalava.model.value.Value
+import com.android.tools.metalava.model.value.asBoolean
+import com.android.tools.metalava.model.value.asInt
+import com.android.tools.metalava.model.value.asString
 import com.android.tools.metalava.model.visitors.ApiPredicate
 import com.android.tools.metalava.model.visitors.ApiVisitor
+import com.android.tools.metalava.permission.getRequiresPermissionInfo
 import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.reporter.Reporter
 import java.io.File
@@ -107,6 +113,31 @@ class DocAnalyzer(
 
     val mentionsNull: Pattern = Pattern.compile("\\bnull\\b")
 
+    /** Format this [Value] for use in handling `IntRange` and `FloatRange` annotations. */
+    private fun Value.forRange(): String =
+        when (this) {
+            is IntegralValue<*> -> {
+                // Format as an int if it will fit, otherwise a long.
+                val asLong = underlyingValue.toLong()
+                if (asLong >= Int.MIN_VALUE && asLong <= Int.MAX_VALUE) asLong.toString()
+                else "${asLong}L"
+            }
+            is FloatingPointValue<*> -> {
+                // Format as a float if it will fit, otherwise a double.
+                val asDouble = underlyingValue.toDouble()
+                if (asDouble >= -Float.MAX_VALUE && asDouble <= Float.MAX_VALUE) "${asDouble}f"
+                else asDouble.toString()
+            }
+            is FieldReferenceValue -> {
+                // Format as a link to the field.
+                "{@link ${qualifiedClassName}#$fieldName}"
+            }
+            else -> {
+                // Use default source formatting.
+                toValueString()
+            }
+        }
+
     private fun documentsFromAnnotations() {
         // Note: Doclava1 inserts its own javadoc parameters into the documentation,
         // which is then later processed by javadoc to insert actual descriptions.
@@ -171,19 +202,14 @@ class DocAnalyzer(
                     return result ?: emptyList()
                 }
 
-                /** Fallback if field can't be resolved or if an inlined string value is used */
+                /**
+                 * Fallback if field can't be resolved or if an inlined string value is used then
+                 * try and find the field in the `android.Manifest.permission` class if available.
+                 */
                 private fun findPermissionField(codebase: Codebase, value: Any): FieldItem? {
                     val perm = value.toString()
                     val permClass = codebase.findClass("android.Manifest.permission")
-                    permClass
-                        ?.fields()
-                        ?.filter {
-                            it.legacyInitialValue(requireConstant = false)?.toString() == perm
-                        }
-                        ?.forEach {
-                            return it
-                        }
-                    return null
+                    return permClass?.fields()?.firstOrNull { it.constantValue?.asString() == perm }
                 }
 
                 private fun handleAnnotation(
@@ -239,7 +265,7 @@ class DocAnalyzer(
                     annotation.resolve()?.modifiers?.annotations()?.forEach { nested ->
                         if (depth == 20) { // Temp debugging
                             throw StackOverflowError(
-                                "Unbounded recursion, processing annotation ${annotation.toSource()} " +
+                                "Unbounded recursion, processing annotation $annotation " +
                                     "in $item at ${annotation.fileLocation} "
                             )
                         } else if (nested.qualifiedName !in visitedClasses) {
@@ -252,10 +278,8 @@ class DocAnalyzer(
                     val text =
                         (annotation.findAttribute("message")
                                 ?: annotation.findAttribute(ANNOTATION_ATTR_VALUE))
-                            ?.legacyValue
-                            ?.value()
-                            ?.toString()
-                            ?: return
+                            ?.value
+                            ?.asString() ?: return
                     if (text.isBlank() || item.documentation.contains(text)) {
                         return
                     }
@@ -276,8 +300,7 @@ class DocAnalyzer(
                                     item
                                         .containingCallable()
                                         .documentation
-                                        .findTagDocumentation("param", item.name())
-                                        ?: ""
+                                        .findTagDocumentation("param", item.name()) ?: ""
                                 }
                                 is CallableItem -> {
                                     // Don't inspect param docs (and other tags) for this purpose.
@@ -314,26 +337,10 @@ class DocAnalyzer(
                     if (item !is MemberItem) {
                         return
                     }
-                    var values: List<AnnotationAttributeValue>? = null
-                    var any = false
-                    var conditional = false
-                    for (attribute in annotation.attributes) {
-                        when (attribute.name) {
-                            "value",
-                            "allOf" -> {
-                                values = attribute.leafValues()
-                            }
-                            "anyOf" -> {
-                                any = true
-                                values = attribute.leafValues()
-                            }
-                            "conditional" -> {
-                                conditional = attribute.legacyValue.value() == true
-                            }
-                        }
-                    }
 
-                    if (!values.isNullOrEmpty() && !conditional) {
+                    val requiresPermissionInfo = annotation.getRequiresPermissionInfo() ?: return
+                    val (values, any, conditional) = requiresPermissionInfo
+                    if (values.isNotEmpty() && !conditional) {
                         // Look at macros_override.cs for the usage of these
                         // tags. In particular, search for def:dump_permission
 
@@ -347,23 +354,25 @@ class DocAnalyzer(
                                 else -> sb.append(" and ")
                             }
 
-                            val resolved = value.resolve()
+                            val resolvedField = (value as? FieldReferenceValue)?.resolve()
                             val field =
-                                if (resolved is FieldItem) resolved
-                                else {
-                                    val v: Any = value.value() ?: value.toSource()
+                                if (resolvedField == null) {
+                                    val v = value.asString() ?: value.toValueString()
                                     if (v == CARRIER_PRIVILEGES_MARKER) {
                                         // TODO: Warn if using allOf with carrier
                                         sb.append(
                                             "{@link android.telephony.TelephonyManager#hasCarrierPrivileges carrier privileges}"
                                         )
                                         continue
+                                    } else {
+                                        findPermissionField(codebase, v)
                                     }
-                                    findPermissionField(codebase, v)
-                                }
+                                } else resolvedField
                             if (field == null) {
-                                val v = value.value()?.toString() ?: value.toSource()
-                                if (editDistance(CARRIER_PRIVILEGES_MARKER, v, 3) < 3) {
+                                val v = value.asString()
+                                if (
+                                    v != null && editDistance(CARRIER_PRIVILEGES_MARKER, v, 3) < 3
+                                ) {
                                     reporter.report(
                                         Issues.MISSING_PERMISSION,
                                         item,
@@ -373,10 +382,10 @@ class DocAnalyzer(
                                     reporter.report(
                                         Issues.MISSING_PERMISSION,
                                         item,
-                                        "Cannot find permission field for $value required by $item (may be hidden or removed)"
+                                        "Cannot find permission field for ${value.toValueString()} required by $item (may be hidden or removed)"
                                     )
                                 }
-                                sb.append(value.toSource())
+                                sb.append(value.toValueString())
                             } else {
                                 if (filterReference.test(field)) {
                                     sb.append(
@@ -400,14 +409,10 @@ class DocAnalyzer(
                 }
 
                 private fun handleRange(annotation: AnnotationItem, item: Item) {
-                    val from: String? = annotation.findAttribute("from")?.legacyValue?.toSource()
-                    val to: String? = annotation.findAttribute("to")?.legacyValue?.toSource()
+                    val from = annotation.findAttribute("from")?.value?.forRange()
+                    val to = annotation.findAttribute("to")?.value?.forRange()
                     // TODO: inclusive/exclusive attributes on FloatRange!
                     if (from != null || to != null) {
-                        val args = HashMap<String, String>()
-                        if (from != null) args["from"] = from
-                        if (from != null) args["from"] = from
-                        if (to != null) args["to"] = to
                         val doc =
                             if (from != null && to != null) {
                                 "Value is between $from and $to inclusive"
@@ -421,8 +426,8 @@ class DocAnalyzer(
                 }
 
                 private fun handleTypeDef(annotation: AnnotationItem, item: Item) {
-                    val values = annotation.findAttribute("value")?.leafValues() ?: return
-                    val flag = annotation.findAttribute("flag")?.legacyValue?.toSource() == "true"
+                    val values = annotation.findAttribute("value")?.value?.asFlatList() ?: return
+                    val flag = annotation.findAttribute("flag")?.value?.asBoolean() == true
 
                     // Look at macros_override.cs for the usage of these
                     // tags. In particular, search for def:dump_int_def
@@ -455,7 +460,7 @@ class DocAnalyzer(
                             }
                         )
 
-                        val field = value.resolve()
+                        val field = (value as? FieldReferenceValue)?.resolve()
                         if (field is FieldItem)
                             if (filterReference.test(field)) {
                                 sb.append(
@@ -476,25 +481,23 @@ class DocAnalyzer(
                                 )
                             }
                         else {
-                            sb.append(value.toSource())
+                            sb.append(value.toValueString())
                         }
                     }
                     appendDocumentation(sb.toString(), item, true)
                 }
 
                 private fun handleRequiresFeature(annotation: AnnotationItem, item: Item) {
-                    val value =
-                        annotation.findAttribute("value")?.leafValues()?.firstOrNull() ?: return
-                    val resolved = value.resolve()
-                    val field = resolved as? FieldItem
+                    val value = annotation.findAttribute("value")?.value ?: return
+                    val field = (value as? FieldReferenceValue)?.resolve()
                     val featureField =
                         if (field == null) {
                             reporter.report(
                                 Issues.MISSING_PERMISSION,
                                 item,
-                                "Cannot find feature field for $value required by $item (may be hidden or removed)"
+                                "Cannot find feature field for ${value.toValueString()} required by $item (may be hidden or removed)"
                             )
-                            "{@link ${value.toSource()}}"
+                            "{@link ${value.toValueString()}}"
                         } else {
                             if (filterReference.test(field)) {
                                 "{@link ${field.containingClass().qualifiedName()}#${field.name()} ${field.containingClass().simpleName()}#${field.name()}}"
@@ -502,14 +505,15 @@ class DocAnalyzer(
                                 reporter.report(
                                     Issues.MISSING_PERMISSION,
                                     item,
-                                    "Feature field $value required by $item is hidden or removed"
+                                    "Feature field ${value.toValueString()} required by $item is hidden or removed"
                                 )
                                 "${field.containingClass().simpleName()}#${field.name()}"
                             }
                         }
 
                     val enforcement =
-                        annotation.getAttributeValue("enforcement") ?: DEFAULT_ENFORCEMENT
+                        annotation.findAttribute("enforcement")?.value?.asString()
+                            ?: DEFAULT_ENFORCEMENT
 
                     // Compute the link uri and text from the enforcement setting.
                     val regexp = """(?:.*\.)?([^.#]+)#(.*)""".toRegex()
@@ -541,35 +545,35 @@ class DocAnalyzer(
                  */
                 private fun handleRequiresApi(annotation: AnnotationItem, item: SelectableItem) {
                     val level = run {
-                        val api =
-                            annotation.findAttribute("api")?.leafValues()?.firstOrNull()?.value()
+                        val api = annotation.findAttribute("api")?.value?.asInt()
                         if (api == null || api == 1) {
-                            annotation.findAttribute("value")?.leafValues()?.firstOrNull()?.value()
-                                ?: return
+                            annotation.findAttribute("value")?.value?.asInt() ?: return
                         } else {
                             api
                         }
                     }
 
-                    if (level is Int) {
-                        addApiVersionDocumentation(ApiVersion.fromLevel(level), item)
-                    }
+                    addApiVersionDocumentation(ApiVersion.fromLevel(level), item)
                 }
 
                 private fun handleRestrictedForEnvironment(
                     annotationItem: AnnotationItem,
                     item: Item
                 ) {
-                    val environmentsValue: String? =
-                        annotationItem.findAttribute("environments")?.legacyValue?.toSource()
-                    val fromValue: String? =
-                        annotationItem.findAttribute("from")?.legacyValue?.toSource()
+                    val environmentsValue =
+                        annotationItem
+                            .findAttribute("environments")
+                            ?.value
+                            ?.asFlatList()
+                            ?.firstOrNull()
+                            ?.asString()
+                    val fromValue = annotationItem.findAttribute("from")?.value?.asInt()
 
-                    if (environmentsValue == null || !environmentsValue.endsWith("SDK_SANDBOX")) {
+                    if (environmentsValue == null) {
                         reporter.report(
-                            Issues.INVALID_ENVIRONMENT_IN_RESTRICTED_FOR_ENVIRONMENT,
+                            Issues.MISSING_ENVIRONMENTS_VALUE,
                             item,
-                            "Invalid 'environments' value '$environmentsValue', must be 'SDK_SANDBOX'"
+                            "Missing 'environments' value for @RestrictedForEnvironment annotation"
                         )
                         return
                     }
@@ -584,24 +588,17 @@ class DocAnalyzer(
                     }
 
                     appendDocumentation(
-                        "Restricted for SDK Runtime environment in API level $fromValue.\n",
+                        "Restricted for $environmentsValue environment in API level $fromValue.\n",
                         item,
                         false
                     )
                 }
 
                 private fun handleColumn(annotation: AnnotationItem, item: Item) {
-                    val value =
-                        annotation.findAttribute("value")?.leafValues()?.firstOrNull() ?: return
-                    val readOnly =
-                        annotation
-                            .findAttribute("readOnly")
-                            ?.leafValues()
-                            ?.firstOrNull()
-                            ?.value() == true
+                    val value = annotation.findAttribute("value")?.value ?: return
+                    val readOnly = annotation.findAttribute("readOnly")?.value?.asBoolean() == true
                     val sb = StringBuilder(100)
-                    val resolved = value.resolve()
-                    val field = resolved as? FieldItem
+                    val field = (value as? FieldReferenceValue)?.resolve()
                     sb.append("This constant represents a column name that can be used with a ")
                     sb.append("{@link android.content.ContentProvider}")
                     sb.append(" through a ")
@@ -614,9 +611,9 @@ class DocAnalyzer(
                         reporter.report(
                             Issues.MISSING_COLUMN,
                             item,
-                            "Cannot find feature field for $value required by $item (may be hidden or removed)"
+                            "Cannot find feature field for ${value.toValueString()} required by $item (may be hidden or removed)"
                         )
-                        sb.append("{@link ${value.toSource()}}")
+                        sb.append("{@link ${value.toValueString()}}")
                     } else {
                         if (filterReference.test(field)) {
                             sb.append(
@@ -626,7 +623,7 @@ class DocAnalyzer(
                             reporter.report(
                                 Issues.MISSING_COLUMN,
                                 item,
-                                "Feature field $value required by $item is hidden or removed"
+                                "Feature field ${value.toValueString()} required by $item is hidden or removed"
                             )
                             sb.append("${field.containingClass().simpleName()}#${field.name()} ")
                         }
@@ -834,12 +831,6 @@ class DocAnalyzer(
      */
     private fun addApiVersionDocumentation(apiVersion: ApiVersion?, item: SelectableItem) {
         if (apiVersion != null) {
-            if (item.originallyHidden) {
-                // @SystemApi, @TestApi etc -- don't apply API versions here since we don't have
-                // accurate historical data
-                return
-            }
-
             // Check to see whether an API version should not be included in the documentation.
             if (!apiVersionFilter(apiVersion)) {
                 return
diff --git a/metalava/src/main/java/com/android/tools/metalava/flag/ApiFlagReport.kt b/metalava/src/main/java/com/android/tools/metalava/flag/ApiFlagReport.kt
new file mode 100644
index 000000000..50ae57946
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/flag/ApiFlagReport.kt
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.flag
+
+import com.android.tools.metalava.model.api.flags.ApiFlag
+
+/** Report about the flag status. */
+class ApiFlagReport(private val apiFlagByName: Map<String, ApiFlag?>) {
+    /** An individual flag's status. */
+    data class FlagStatus(
+        /** The qualified name of the flag. */
+        val qualifiedName: String,
+
+        /** The effect that the flag will have on the API. */
+        val apiFlag: ApiFlag?,
+    )
+
+    /** Get all the [FlagStatus]es for the flags, in order by [FlagStatus.qualifiedName]. */
+    val flagStatuses: List<FlagStatus>
+        get() = apiFlagByName.map { FlagStatus(it.key, it.value) }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/flag/ApiFlagReportProducer.kt b/metalava/src/main/java/com/android/tools/metalava/flag/ApiFlagReportProducer.kt
new file mode 100644
index 000000000..4caf7bf6e
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/flag/ApiFlagReportProducer.kt
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.flag
+
+import com.android.tools.metalava.model.ANDROID_FLAGGED_API
+import com.android.tools.metalava.model.BaseItemVisitor
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.SelectableItem
+import com.android.tools.metalava.model.api.flags.ApiFlags
+import com.android.tools.metalava.model.api.flags.optionalFlagName
+
+/**
+ * Produces an [ApiFlagReport] by visiting the [Codebase] and collating the names of all the flags
+ * used and then querying their status.
+ */
+object ApiFlagReportProducer : BaseItemVisitor(visitParameterItems = false) {
+    /** The set of all the flag names. */
+    private val allFlagNames = mutableSetOf<String>()
+
+    /**
+     * Visitor for a [SelectableItem] that may be annotated with an [ANDROID_FLAGGED_API]
+     * annotation. Extracts the flag name if available and adds it to the [allFlagNames] set.
+     */
+    override fun visitSelectableItem(item: SelectableItem) {
+        val flaggedApiAnnotation = item.modifiers.findAnnotation(ANDROID_FLAGGED_API) ?: return
+        val flagName = flaggedApiAnnotation.optionalFlagName ?: return
+        allFlagNames += flagName
+    }
+
+    /**
+     * Produce an [ApiFlagReport] by extracting all the flag names used in [codebase] and then
+     * finding their status from [apiFlags].
+     */
+    fun produceFlagReport(codebase: Codebase, apiFlags: ApiFlags): ApiFlagReport {
+        // Gather the names of all the flags used in this codebase.
+        codebase.accept(this)
+
+        val flagStatusByName =
+            allFlagNames.sorted().associateWith { flagName -> apiFlags.byQualifiedName[flagName] }
+        return ApiFlagReport(flagStatusByName)
+    }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/lint/ApiLint.kt b/metalava/src/main/java/com/android/tools/metalava/lint/ApiLint.kt
index 9b905435a..a605072a0 100644
--- a/metalava/src/main/java/com/android/tools/metalava/lint/ApiLint.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/lint/ApiLint.kt
@@ -73,12 +73,16 @@ import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.PrimitiveTypeItem
 import com.android.tools.metalava.model.PropertyItem
 import com.android.tools.metalava.model.SelectableItem
+import com.android.tools.metalava.model.TargetLanguageSet
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeNullability
 import com.android.tools.metalava.model.TypeStringConfiguration
 import com.android.tools.metalava.model.VariableTypeItem
 import com.android.tools.metalava.model.findAnnotation
 import com.android.tools.metalava.model.hasAnnotation
+import com.android.tools.metalava.model.value.ValueKind
+import com.android.tools.metalava.model.value.asInt
+import com.android.tools.metalava.model.value.asString
 import com.android.tools.metalava.model.visitors.ApiPredicate
 import com.android.tools.metalava.model.visitors.ApiType
 import com.android.tools.metalava.model.visitors.ApiVisitor
@@ -209,6 +213,9 @@ private constructor(
         // even when the signatures match that of a super method exactly (notably the ones checking
         // that nullability overrides are consistent).
         apiFilters = ApiType.PUBLIC_API.getNonElidingApiFilters(apiPredicateConfig),
+        // API lint checks are only relevant to the API surface as used from source, not APIs that
+        // only exist in bytecode.
+        targetLanguages = TargetLanguageSet.SOURCE,
     ) {
 
     /** Predicate that checks if the item appears in the signature file. */
@@ -512,16 +519,18 @@ private constructor(
             item.modifiers.findAnnotation { it.qualifiedName == ANDROID_FLAGGED_API } ?: return
         val attr = annotation.attributes.find { attr -> attr.name == "value" } ?: return
 
-        if (attr.legacyValue.resolve() == null) {
-            val value = attr.legacyValue.value() as? String
-            if (value == attr.legacyValue.toSource()) {
-                // For a string literal, source and value are never the same, so this happens only
-                // when a reference isn't resolvable.
-                return
-            }
+        // Get the flag value, should be a reference to a constant field.
+        val flagValue = attr.value
+        if (flagValue.kind != ValueKind.FIELD) {
+            // It is not a reference to a field so get the string value and try and see if the field
+            // could be found.
+            val value = flagValue.asString()
 
+            // Reverse engineer the string value to a field reference and resolve it to a FieldItem,
+            // if possible.
             val field = value?.let { aconfigFlagLiteralToFieldOrNull(item.codebase, it) }
 
+            // Generate some helpful text so the developer knows what to do to fix it.
             val replacement =
                 if (field != null) {
                     val (fieldSource, fieldItem) = field
@@ -669,7 +678,7 @@ private constructor(
             )
         } else if (
             (field.type() is PrimitiveTypeItem || field.type().isString()) &&
-                field.legacyInitialValue(true) == null
+                field.constantValue?.asLiteralValue() == null
         ) {
             report(
                 COMPILE_TIME_CONSTANT,
@@ -819,7 +828,7 @@ private constructor(
         if (!field.type().isString()) {
             return
         }
-        val value = field.legacyInitialValue(true) as? String ?: return
+        val value = field.constantValue?.asString() ?: return
         if (!(name.contains("_ACTION") || name.contains("ACTION_") || value.contains(".action."))) {
             return
         }
@@ -860,7 +869,7 @@ private constructor(
         if (name.startsWith("ACTION_") || !field.type().isString()) {
             return
         }
-        val value = field.legacyInitialValue(true) as? String ?: return
+        val value = field.constantValue?.asString() ?: return
         if (!(name.contains("_EXTRA") || name.contains("EXTRA_") || value.contains(".extra"))) {
             return
         }
@@ -1151,7 +1160,7 @@ private constructor(
             fields
                 .firstOrNull { it.name() == fieldName }
                 ?.let { field ->
-                    if (field.legacyInitialValue(true) != fieldValue) {
+                    if (field.constantValue?.asString() != fieldValue) {
                         report(
                             INTERFACE_CONSTANT,
                             field,
@@ -1798,7 +1807,7 @@ private constructor(
             val name = field.name()
             val index = name.indexOf("FLAG_")
             if (index != -1) {
-                val value = field.legacyInitialValue() as? Int ?: continue
+                val value = field.constantValue?.asInt() ?: continue
                 val scope = name.substring(0, index)
                 val prev = known?.get(scope) ?: 0
                 if (known != null && (prev and value) != 0) {
@@ -2077,8 +2086,7 @@ private constructor(
                         it.parameters().find { param ->
                             item.parameterIndex == param.parameterIndex
                         }
-                    }
-                        ?: emptyList()
+                    } ?: emptyList()
                 is MethodItem -> item.superMethods()
                 else -> emptyList()
             }
@@ -2993,7 +3001,7 @@ private constructor(
         }
         val name = field.name()
         val endsWithService = name.endsWith("_SERVICE")
-        val value = field.legacyInitialValue(requireConstant = true) as? String
+        val value = field.constantValue?.asString()
 
         if (value == null) {
             val mustEndInService =
@@ -3270,8 +3278,7 @@ private constructor(
                 } else {
                     requiredParameters.last()
                 }
-                ?.parameterIndex
-                ?: return
+                ?.parameterIndex ?: return
         optionalParameters.forEach { parameter ->
             if (parameter.parameterIndex < lastRequiredParameterIndex) {
                 report(
@@ -3319,8 +3326,7 @@ private constructor(
             val setter =
                 methods.singleOrNull {
                     it.name() == expectedSetterName && it.parameters().size == 1
-                }
-                    ?: continue
+                } ?: continue
 
             val getterReturnType = getter.returnType()
             val setterParamType = setter.parameters().single().type()
@@ -3405,8 +3411,7 @@ private constructor(
             name.startsWith(prop(it)) &&
                 name.getOrNull(prop(it).length)?.let { charAfterPrefix ->
                     charAfterPrefix.isUpperCase() || charAfterPrefix.isDigit()
-                }
-                    ?: false
+                } ?: false
         }
 
         private val badBooleanGetterPrefixes = listOf("isHas", "isCan", "isShould", "get", "is")
@@ -3518,8 +3523,8 @@ private constructor(
         private fun isServiceDumpMethod(item: Item) =
             when (item) {
                 is MethodItem -> isServiceDumpMethod(item)
-                is ParameterItem -> item.possibleContainingMethod()?.let { isServiceDumpMethod(it) }
-                        ?: false
+                is ParameterItem ->
+                    item.possibleContainingMethod()?.let { isServiceDumpMethod(it) } ?: false
                 else -> false
             }
 
diff --git a/metalava/src/main/java/com/android/tools/metalava/manifest/Manifest.kt b/metalava/src/main/java/com/android/tools/metalava/manifest/Manifest.kt
index 65dcf2070..3e40445de 100644
--- a/metalava/src/main/java/com/android/tools/metalava/manifest/Manifest.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/manifest/Manifest.kt
@@ -84,8 +84,7 @@ class Manifest(private val manifest: File?, private val reporter: Reporter?) {
                 Issues.PARSE_ERROR,
                 manifest,
                 "Failed to parse $manifest: ${error.message}"
-            )
-                ?: throw error
+            ) ?: throw error
             defaultInfo
         }
     }
diff --git a/metalava/src/main/java/com/android/tools/metalava/permission/RequiresPermissionInfo.kt b/metalava/src/main/java/com/android/tools/metalava/permission/RequiresPermissionInfo.kt
new file mode 100644
index 000000000..b7c18ff70
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/permission/RequiresPermissionInfo.kt
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.permission
+
+import com.android.tools.metalava.model.ANDROIDX_REQUIRES_PERMISSION
+import com.android.tools.metalava.model.AnnotationAttribute
+import com.android.tools.metalava.model.AnnotationItem
+import com.android.tools.metalava.model.value.ArrayElementValue
+import com.android.tools.metalava.model.value.FieldReferenceValue
+import com.android.tools.metalava.model.value.StringValue
+import com.android.tools.metalava.model.value.asBoolean
+
+/** Encapsulate information extracted from an [ANDROIDX_REQUIRES_PERMISSION] attribute. */
+data class RequiresPermissionInfo(
+    /** The list of permissions, either [StringValue] or [FieldReferenceValue]. */
+    val permissionValues: List<ArrayElementValue>,
+
+    /** `true` if any permission in [permissionValues] is needed, `false` if all are needed. */
+    val any: Boolean,
+
+    /**
+     * `true` if the set of permissions required is conditional, `false` otherwise.
+     *
+     * If `true` then the documentation will not be automatically updated to include the permission
+     * requirements. Instead, it is up to the developer to document the permissions needed for each
+     * condition.
+     */
+    val conditional: Boolean,
+) {
+    companion object {
+        internal fun from(annotationItem: AnnotationItem): RequiresPermissionInfo? {
+            var permissionsAttribute: AnnotationAttribute? = null
+            var any = false
+            var conditional = false
+            for (attribute in annotationItem.attributes) {
+                when (attribute.name) {
+                    "value",
+                    "allOf" -> {
+                        permissionsAttribute = attribute
+                    }
+                    "anyOf" -> {
+                        any = true
+                        permissionsAttribute = attribute
+                    }
+                    "conditional" -> conditional = attribute.value.asBoolean() == true
+                }
+            }
+
+            return if (permissionsAttribute == null) {
+                null
+            } else {
+                RequiresPermissionInfo(permissionsAttribute.value.asFlatList(), any, conditional)
+            }
+        }
+    }
+}
+
+/**
+ * Get an instance of [RequiresPermissionInfo] from [AnnotationItem], or `null` if the annotation is
+ * not a `RequiresPermission` annotation.
+ */
+fun AnnotationItem.getRequiresPermissionInfo() =
+    if (qualifiedName == ANDROIDX_REQUIRES_PERMISSION) RequiresPermissionInfo.from(this) else null
diff --git a/metalava/src/main/java/com/android/tools/metalava/stub/JavaStubWriter.kt b/metalava/src/main/java/com/android/tools/metalava/stub/JavaStubWriter.kt
index 72672d013..8d0a3ade3 100644
--- a/metalava/src/main/java/com/android/tools/metalava/stub/JavaStubWriter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/stub/JavaStubWriter.kt
@@ -28,6 +28,7 @@ import com.android.tools.metalava.model.JAVA_LANG_STRING
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.ModifierListWriter
 import com.android.tools.metalava.model.PrimitiveTypeItem
+import com.android.tools.metalava.model.PrimitiveTypeItem.Primitive
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterBindings
 import com.android.tools.metalava.model.TypeParameterList
@@ -236,9 +237,9 @@ internal class JavaStubWriter(
             is PrimitiveTypeItem -> {
                 val kind = type.kind
                 return when (kind) {
-                    PrimitiveTypeItem.Primitive.BOOLEAN,
-                    PrimitiveTypeItem.Primitive.INT,
-                    PrimitiveTypeItem.Primitive.LONG -> kind.defaultValueString
+                    Primitive.BOOLEAN,
+                    Primitive.INT,
+                    Primitive.LONG -> kind.defaultValueString
                     else -> "(${kind.primitiveName})${kind.defaultValueString}"
                 }
             }
@@ -314,10 +315,9 @@ internal class JavaStubWriter(
         generateThrowsList(method)
 
         if (containingClass.isAnnotationType()) {
-            val default = method.legacyDefaultValue()
-            if (default.isNotEmpty()) {
+            method.defaultValue?.let { defaultValue ->
                 writer.print(" default ")
-                writer.print(default)
+                writer.print(defaultValue.toValueString())
             }
         }
 
@@ -343,18 +343,23 @@ internal class JavaStubWriter(
         writer.print(field.type().toTypeString())
         writer.print(' ')
         writer.print(field.name())
-        val needsInitialization =
-            field.modifiers.isFinal() &&
-                field.legacyInitialValue(true) == null &&
-                field.containingClass().isClass()
-        field.writeValueWithSemicolon(
-            writer,
-            allowDefaultValue = !needsInitialization,
-            requireInitialValue = !needsInitialization
-        )
+
+        // Write the value, if any, falling back to the non-constant expression provider.
+        val valueWasWritten =
+            field.writeValueWithSemicolon(
+                writer,
+                JavaStubWriter::nonConstantExpressionProvider,
+            )
         writer.print("\n")
 
-        if (needsInitialization) {
+        // An initializer block is needed if no value was written by the call to
+        // `writeValueWithSemicolon(...)`, the field is final (so needs initializing) and the
+        // containing class supports initializer blocks.
+        val useInitializerBlock =
+            !valueWasWritten &&
+                field.modifiers.isFinal() &&
+                field.containingClass().classKind.supportsInitializerBlock
+        if (useInitializerBlock) {
             if (field.modifiers.isStatic()) {
                 writer.print("static ")
             }
@@ -393,4 +398,44 @@ internal class JavaStubWriter(
             }
         }
     }
+
+    companion object {
+        /**
+         * Provide a non-constant expression for [field], if needed.
+         *
+         * Returns an expression, appropriate for the [field]'s [FieldItem.type] which will not be
+         * considered to be a constant expression as defined in JLS 15.28.
+         */
+        private fun nonConstantExpressionProvider(field: FieldItem): String? {
+            // Classes and enums can just use a separate initializer block.
+            if (field.containingClass().classKind.supportsInitializerBlock) return null
+            val fieldType = field.type()
+            return when {
+                fieldType is PrimitiveTypeItem -> {
+                    nonConstantExpressionForPrimitive[fieldType.kind]!!
+                }
+                fieldType.isString() -> {
+                    "java.lang.String.valueOf(0)"
+                }
+                else -> "null"
+            }
+        }
+
+        /**
+         * A map from [Primitive] to an expression that, if evaluated, will return in a value of the
+         * primitive type but which is not considered to be a constant expression so will not be
+         * inlined by the compiler.
+         */
+        private val nonConstantExpressionForPrimitive =
+            mapOf(
+                Primitive.BOOLEAN to """java.lang.Boolean.parseBoolean("false")""",
+                Primitive.BYTE to """java.lang.Byte.parseByte("0")""",
+                Primitive.CHAR to """"A".charAt(0)""",
+                Primitive.DOUBLE to """java.lang.Double.parseDouble("0")""",
+                Primitive.FLOAT to """java.lang.Float.parseFloat("0")""",
+                Primitive.INT to """java.lang.Integer.parseInt("0")""",
+                Primitive.LONG to """java.lang.Long.parseLong("0")""",
+                Primitive.SHORT to """java.lang.Short.parseShort("0")""",
+            )
+    }
 }
diff --git a/metalava/src/main/resources/schemas/config.xsd b/metalava/src/main/resources/schemas/config.xsd
index 38950f088..890f66150 100644
--- a/metalava/src/main/resources/schemas/config.xsd
+++ b/metalava/src/main/resources/schemas/config.xsd
@@ -54,6 +54,13 @@
                         </xs:documentation>
                     </xs:annotation>
                 </xs:element>
+                <xs:element name="build-properties" type="config:BuildPropertiesType" minOccurs="0">
+                    <xs:annotation>
+                        <xs:documentation>
+                            The definitions of a set of Build Properties.
+                        </xs:documentation>
+                    </xs:annotation>
+                </xs:element>
             </xs:choice>
         </xs:complexType>
 
@@ -82,6 +89,15 @@
             <xs:field xpath="@name"/>
         </xs:key>
 
+        <!--
+         ! A key that makes sure that Build Property names are unique within the containing
+         ! file.
+         !-->
+        <xs:key name="BuildPropertyName">
+            <xs:selector xpath=".//config:build-property"/>
+            <xs:field xpath="@name"/>
+        </xs:key>
+
     </xs:element>
 
     <xs:complexType name="ApiSurfacesType">
@@ -155,7 +171,7 @@
     <xs:complexType name="ApiFlagType">
         <xs:annotation>
             <xs:documentation>
-                The type of the `api-flag` element defined inside `ApiSurfacesType`.
+                The type of the `api-flag` element defined inside `ApiFlagsType`.
             </xs:documentation>
         </xs:annotation>
         <xs:choice/>
@@ -252,4 +268,64 @@
             <xs:pattern value="[a-z0-9_]+"/>
         </xs:restriction>
     </xs:simpleType>
+
+    <xs:complexType name="BuildPropertiesType">
+        <xs:annotation>
+            <xs:documentation>
+                The type of the `build-properties` element defined inside `config`.
+            </xs:documentation>
+        </xs:annotation>
+        <xs:choice>
+            <xs:element name="build-property" type="config:BuildPropertyType" minOccurs="1" maxOccurs="unbounded">
+                <xs:annotation>
+                    <xs:documentation>
+                        Build property definition.
+                    </xs:documentation>
+                </xs:annotation>
+            </xs:element>
+        </xs:choice>
+    </xs:complexType>
+
+    <xs:complexType name="BuildPropertyType">
+        <xs:annotation>
+            <xs:documentation>
+                The type of the `build-property` element defined inside `BuildPropertiesType`.
+            </xs:documentation>
+        </xs:annotation>
+        <xs:attribute name="name" type="config:BuildPropertyNameType" use="required">
+            <xs:annotation>
+                <xs:documentation>
+                    The required name of the build property.
+                </xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+        <xs:attribute name="value" type="config:BuildPropertyValueType" use="required">
+            <xs:annotation>
+                <xs:documentation>
+                    The required value of the build property.
+                </xs:documentation>
+            </xs:annotation>
+        </xs:attribute>
+    </xs:complexType>
+
+    <xs:simpleType name="BuildPropertyNameType">
+        <xs:annotation>
+            <xs:documentation>
+                The type of a build property name
+            </xs:documentation>
+        </xs:annotation>
+        <xs:restriction base="xs:string">
+            <xs:pattern value="[a-zA-Z0-9_]+"/>
+        </xs:restriction>
+    </xs:simpleType>
+
+    <xs:simpleType name="BuildPropertyValueType">
+        <xs:annotation>
+            <xs:documentation>
+                The type of a build property value
+            </xs:documentation>
+        </xs:annotation>
+        <xs:restriction base="xs:string">
+        </xs:restriction>
+    </xs:simpleType>
 </xs:schema>
diff --git a/metalava/src/test/java/com/android/tools/metalava/AndroidApiChecksTest.kt b/metalava/src/test/java/com/android/tools/metalava/AndroidApiChecksTest.kt
index ff1d791c8..ae5eb1a17 100644
--- a/metalava/src/test/java/com/android/tools/metalava/AndroidApiChecksTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/AndroidApiChecksTest.kt
@@ -19,6 +19,7 @@ package com.android.tools.metalava
 import com.android.tools.metalava.cli.common.ARG_WARNING
 import com.android.tools.metalava.lint.DefaultLintErrorMessage
 import com.android.tools.metalava.reporter.Issues
+import com.android.tools.metalava.testing.KnownSourceFiles.sdkConstantSource
 import com.android.tools.metalava.testing.java
 import org.junit.Test
 
@@ -76,7 +77,7 @@ class AndroidApiChecksTest : DriverTest() {
             expectedIssues =
                 """
                 src/android/pkg/PermissionTest.java:14: error: Method 'test0' documentation mentions permissions without declaring @RequiresPermission [RequiresPermission]
-                src/android/pkg/PermissionTest.java:21: error: Method 'test1' documentation duplicates auto-generated documentation by @RequiresPermission. If the permissions are only required under certain circumstances use conditional=true to suppress the auto-documentation [RequiresPermission]
+                src/android/pkg/PermissionTest.java:21: warning: Method 'test1' documentation duplicates auto-generated documentation by @RequiresPermission. If the permissions are only required under certain circumstances use conditional=true to suppress the auto-documentation (ErrorWhenNew) [RequiresPermission]
                 src/android/pkg/PermissionTest.java:41: warning: Method 'conditionalBad' documentation does not explain when the conditional permission 'ACCESS_COARSE_LOCATION' is required. [ConditionalRequiresPermissionNotExplained]
                 """,
             sourceFiles =
diff --git a/metalava/src/test/java/com/android/tools/metalava/AnnotationFilterTest.kt b/metalava/src/test/java/com/android/tools/metalava/AnnotationFilterTest.kt
index f7b28cd43..fe60e280e 100644
--- a/metalava/src/test/java/com/android/tools/metalava/AnnotationFilterTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/AnnotationFilterTest.kt
@@ -18,8 +18,9 @@ package com.android.tools.metalava
 
 import com.android.tools.metalava.model.annotation.AnnotationFilter
 import com.android.tools.metalava.model.annotation.AnnotationFilterBuilder
+import com.android.tools.metalava.model.testing.value.annotationItem
+import com.android.tools.metalava.model.testing.value.literalValue
 import org.junit.Assert.assertEquals
-import org.junit.AssumptionViolatedException
 import org.junit.Test
 import org.junit.runner.RunWith
 import org.junit.runners.Parameterized
@@ -42,11 +43,9 @@ class AnnotationFilterTest(private val params: Params) {
     data class Params(
         val name: String,
         val patterns: List<String>,
-        val expectedError: String? = null,
         val expectedIncludedAnnotationNames: Set<String> = emptySet(),
         val expectedEmpty: Boolean = false,
         val expectedMatchesSimple: Boolean = false,
-        val expectedMatchesImplicitValue: Boolean = false,
         val expectedMatchesNamedValue: Boolean = false,
         val expectedMatchesNamedOther: Boolean = false,
         val expectedMatchesAnnotationName: Boolean = expectedMatchesSimple,
@@ -71,7 +70,6 @@ class AnnotationFilterTest(private val params: Params) {
                     patterns = listOf("test.pkg.Annotation"),
                     expectedIncludedAnnotationNames = setOf("test.pkg.Annotation"),
                     expectedMatchesSimple = true,
-                    expectedMatchesImplicitValue = true,
                     expectedMatchesNamedValue = true,
                     expectedMatchesNamedOther = true,
                 ),
@@ -80,7 +78,6 @@ class AnnotationFilterTest(private val params: Params) {
                     patterns = listOf("test.pkg.Annotation()"),
                     expectedIncludedAnnotationNames = setOf("test.pkg.Annotation"),
                     expectedMatchesSimple = true,
-                    expectedMatchesImplicitValue = true,
                     expectedMatchesNamedValue = true,
                     expectedMatchesNamedOther = true,
                 ),
@@ -100,7 +97,6 @@ class AnnotationFilterTest(private val params: Params) {
                     name = "implicit-value",
                     patterns = listOf("""test.pkg.Annotation("value")"""),
                     expectedIncludedAnnotationNames = setOf("test.pkg.Annotation"),
-                    expectedMatchesImplicitValue = true,
                     expectedMatchesNamedValue = true,
                     expectedMatchesAnnotationName = true,
                 ),
@@ -108,7 +104,6 @@ class AnnotationFilterTest(private val params: Params) {
                     name = "named-value",
                     patterns = listOf("""test.pkg.Annotation(value = "value")"""),
                     expectedIncludedAnnotationNames = setOf("test.pkg.Annotation"),
-                    expectedMatchesImplicitValue = true,
                     expectedMatchesNamedValue = true,
                     expectedMatchesAnnotationName = true,
                 ),
@@ -132,72 +127,20 @@ class AnnotationFilterTest(private val params: Params) {
                             "other.OtherAnnotation",
                             "test.pkg.Annotation",
                         ),
-                    expectedMatchesImplicitValue = true,
                     expectedMatchesNamedValue = true,
                     expectedMatchesNamedOther = true,
                     expectedMatchesAnnotationName = true,
                     expectedMatchesOtherAnnotationName = true,
                 ),
-                Params(
-                    name = "excluding-no-attributes",
-                    patterns = listOf("!test.pkg.Annotation"),
-                    expectedError =
-                        "Exclude pattern '!test.pkg.Annotation' is invalid as it does not specify attributes",
-                ),
-                Params(
-                    name = "excluding-no-excluding",
-                    patterns =
-                        listOf(
-                            """!test.pkg.Annotation(value = "value")""",
-                            """!test.pkg.Annotation(value = "other")""",
-                        ),
-                    expectedError =
-                        "Patterns for 'test.pkg.Annotation' contains 2 excludes but no includes",
-                ),
-                Params(
-                    name = "excluding-more-specific-first",
-                    patterns =
-                        listOf(
-                            """!test.pkg.Annotation(value = "value")""",
-                            "test.pkg.Annotation",
-                        ),
-                    expectedIncludedAnnotationNames = setOf("test.pkg.Annotation"),
-                    expectedMatchesSimple = true,
-                    expectedMatchesNamedOther = true,
-                    expectedMatchesAnnotationName = true,
-                ),
-                Params(
-                    name = "excluding-more-specific-last",
-                    patterns =
-                        listOf(
-                            "test.pkg.Annotation",
-                            """!test.pkg.Annotation(value = "value")""",
-                        ),
-                    expectedIncludedAnnotationNames = setOf("test.pkg.Annotation"),
-                    expectedMatchesSimple = true,
-                    expectedMatchesNamedOther = true,
-                    expectedMatchesAnnotationName = true,
-                ),
             )
 
         @JvmStatic @Parameterized.Parameters(name = "{0}") fun testParameters() = params
     }
 
     private fun buildFilter(): AnnotationFilter {
-        var error: String? = null
-        try {
-            val builder = AnnotationFilterBuilder()
-            params.patterns.forEach(builder::add)
-            val filter = builder.build()
-            if (params.expectedError == null) {
-                return filter
-            }
-        } catch (e: IllegalStateException) {
-            error = e.message
-        }
-
-        assertEquals(params.expectedError, error)
-        throw AssumptionViolatedException("filter was not built")
+        val builder = AnnotationFilterBuilder()
+        params.patterns.forEach(builder::add)
+        return builder.build()
     }
 
     @Test
@@ -209,47 +152,38 @@ class AnnotationFilterTest(private val params: Params) {
     }
 
     @Test
-    fun `Test match simple annotation no parentheses`() {
-        val filter = buildFilter()
-
-        assertEquals(params.expectedMatchesSimple, filter.matches("test.pkg.Annotation"))
-    }
-
-    @Test
-    fun `Test match simple annotation, parentheses but no arguments`() {
+    fun `Test match simple annotation no attributes`() {
         val filter = buildFilter()
 
-        assertEquals(params.expectedMatchesSimple, filter.matches("test.pkg.Annotation()"))
-    }
-
-    @Test
-    fun `Test match annotation, implicit property name`() {
-        val filter = buildFilter()
+        val annotationItem = annotationItem("test.pkg.Annotation")
 
-        assertEquals(
-            params.expectedMatchesImplicitValue,
-            filter.matches("""test.pkg.Annotation("value")""")
-        )
+        assertEquals(params.expectedMatchesSimple, filter.matches(annotationItem))
     }
 
     @Test
     fun `Test match annotation, value property`() {
         val filter = buildFilter()
 
-        assertEquals(
-            params.expectedMatchesNamedValue,
-            filter.matches("""test.pkg.Annotation(value = "value")""")
-        )
+        val annotationItem =
+            annotationItem(
+                "test.pkg.Annotation",
+                "value" to literalValue("value"),
+            )
+
+        assertEquals(params.expectedMatchesNamedValue, filter.matches(annotationItem))
     }
 
     @Test
     fun `Test match annotation, other property`() {
         val filter = buildFilter()
 
-        assertEquals(
-            params.expectedMatchesNamedOther,
-            filter.matches("""test.pkg.Annotation(other = "other")""")
-        )
+        val annotationItem =
+            annotationItem(
+                "test.pkg.Annotation",
+                "other" to literalValue("other"),
+            )
+
+        assertEquals(params.expectedMatchesNamedOther, filter.matches(annotationItem))
     }
 
     @Test
diff --git a/metalava/src/test/java/com/android/tools/metalava/AnnotationsMergerTest.kt b/metalava/src/test/java/com/android/tools/metalava/AnnotationsMergerTest.kt
index b590aedde..c55e806fe 100644
--- a/metalava/src/test/java/com/android/tools/metalava/AnnotationsMergerTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/AnnotationsMergerTest.kt
@@ -133,7 +133,6 @@ class AnnotationsMergerTest : DriverTest() {
     fun `Signature files contain annotations`() {
         check(
             format = FileFormat.V2,
-            includeSystemApiAnnotations = false,
             sourceFiles =
                 arrayOf(
                     java(
@@ -335,7 +334,7 @@ class AnnotationsMergerTest : DriverTest() {
     fun `Merge qualifier annotations from Java stub files onto stubs that are not in the API signature file`() {
         check(
             format = FileFormat.V2,
-            includeSystemApiAnnotations = true,
+            includeSystemApiAnnotations = SystemApiType.TEST,
             sourceFiles =
                 arrayOf(
                     java(
diff --git a/metalava/src/test/java/com/android/tools/metalava/ApiAnalyzerTest.kt b/metalava/src/test/java/com/android/tools/metalava/ApiAnalyzerTest.kt
index 00e53c4af..678238d00 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ApiAnalyzerTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ApiAnalyzerTest.kt
@@ -16,6 +16,7 @@
 
 package com.android.tools.metalava
 
+import com.android.tools.lint.checks.infrastructure.TestFiles.base64gzip
 import com.android.tools.metalava.cli.common.ARG_ERROR
 import com.android.tools.metalava.cli.common.ARG_HIDE
 import com.android.tools.metalava.lint.DefaultLintErrorMessage
@@ -23,6 +24,7 @@ import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.model.text.FileFormat
 import com.android.tools.metalava.reporter.Issues
+import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import org.junit.Test
@@ -732,11 +734,10 @@ class ApiAnalyzerTest : DriverTest() {
 
     @Test
     fun `Test propagation of @hide through package and class nesting`() {
-        //
         check(
             // Include system API annotations as a show annotation overrides hidden on a class that
             // is in a hidden package.
-            includeSystemApiAnnotations = true,
+            includeSystemApiAnnotations = SystemApiType.PRIVILEGED_APPS,
             // This is set to true so any class that is incorrectly unhidden will be included in the
             // generated API and fail the test.
             showUnannotated = true,
@@ -796,6 +797,7 @@ class ApiAnalyzerTest : DriverTest() {
                             public class C {}
                         """
                     ),
+                    KnownSourceFiles.systemApiSource,
                 ),
             api =
                 """
@@ -868,4 +870,92 @@ class ApiAnalyzerTest : DriverTest() {
             extraArguments = arrayOf(ARG_ERROR, Issues.INHERIT_CHANGES_SIGNATURE.name)
         )
     }
+
+    @RequiresCapabilities(Capability.KOTLIN, Capability.JAR_WITH_SOURCES)
+    @Test
+    fun `Checks do not run on bytecode-only items`() {
+        check(
+            expectedIssues =
+                """
+                src/test/pkg/IntValue.kt:8: warning: Method test.pkg.Foo.usesHiddenTypeAndValueClass(int) references hidden type test.pkg.HiddenClass. [HiddenTypeParameter]
+                src/test/pkg/IntValue.kt:8: warning: Return type of unavailable type test.pkg.HiddenClass in test.pkg.Foo.usesHiddenTypeAndValueClass() [UnavailableSymbol]
+                src/test/pkg/IntValue.kt:8: error: Class test.pkg.HiddenClass is hidden but was referenced (in return type) from public method test.pkg.Foo.usesHiddenTypeAndValueClass(int) [ReferencesHidden]
+                """,
+            expectedFail = DefaultLintErrorMessage,
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                            package test.pkg
+                            @JvmInline value class IntValue(val v: Int)
+
+                            /** @hide */
+                            class HiddenClass
+
+                            interface Foo {
+                                fun usesHiddenTypeAndValueClass(iv: IntValue): HiddenClass
+                            }
+                        """
+                    )
+                ),
+            // Compiled from the source above with [generateBase64gzipFromKotlin]
+            compiledSourceJar =
+                base64gzip(
+                    "test.jar",
+                    // kotlinc version info: kotlinc-jvm 1.9.23 (JRE 17.0.6+10-b802.1)
+                    "" +
+                        "H4sIAAAAAAAA/31WeTgU3hoeM0ayZBvCVD8TIcuQLWRJ00wxYUwI2cZOxjbG" +
+                        "zqSGMGookSxFKvs6lCU7WSZClDUSgxQSIurSvc+96rl1zvP9d773O8/3nu89" +
+                        "LwYNYoYAWFlZAQAADLB7QQDMAH2ksY6srgFKTl/HQBeFPG8M10d97wAAlvXp" +
+                        "nefQsvAeTrSsVBe9uwwr/0pxfMoHrqcvo6vfQ8ylYRf1ZL2l9Oh0adPFLrn2" +
+                        "dvrk1LspIACD3sNaxHe0SG27wPHtwPyx/P7t8HUk+Mp5XXKW0/XwNcW5Ex3h" +
+                        "9u44AiHUePQ81ATyYzSl6IVTeMpLbOn9VcQwmSreYpEHybpfTskwyTbq6OP1" +
+                        "azxVGj2o/4haM2szflVOfWOcnUv9fHiJ4r53KaRbkwGfnG7JwybP+Wh3aTL8" +
+                        "u9bTCKsLJNIPUL2V+zExzc4Vn5Utny6vmkxzV4tj8iwlzhV0yxbfjsrHw8Gm" +
+                        "7RRYMzf8onU8LKFdmCMfSUIgOPQOHPAOWvXDJ+FoXkyEdFxbHj6Ac/ho91B/" +
+                        "UMSET2ubQJD1kGeW/0ObihGa9AlT0UieyBnQcMkzpDY5M1IMK8WMEuI9aJg8" +
+                        "cOVKZ5brwIfEsib5lMqZqczJ+vaaSGnBpDuuke06POkXUuNibmG9p37w2yTF" +
+                        "eMpLHtwnCHdkcSiaEC5Ej0JPPxqUZChz4MyO+Hnyhlc/qq7GDpcAgU2QQ7dh" +
+                        "gwjYvvxSB7cYSyJNmS6SZydcJqzwuTletDa/6K5TC+f9VgVURt348iCDw61v" +
+                        "sPDZYrlSzfVsWm0nd05gtelVGLEn5o4nopONC9jvtYfAy9jyY0Py48x1jHLV" +
+                        "Cl+7JNZYiLKiZ7+uitL3uUgPArnE3iBYPlrqBcYcsxdUAFvXiSapNUrOv66J" +
+                        "+fh+1aJ/xC3PTdU3viB5XiPfPL3SPki8PaCcP1MI5xPdCX718ZsYCdcJVRs/" +
+                        "wbzZN9tAvE0l3Kb0gW6HWUpKXThMk3Ch9mqdO3Ghq9ZaWFvzzmRghcbNGLbC" +
+                        "5ZCZ+ecuZnspbblwSNVzBiRjbsI70Zn6Y6Ni6y73UC43ApviQE/ivBXBLSrG" +
+                        "Z2WOzRq4ZWUccbinSc+4uasWZxmpNzs5kjAythYVOniIQxRsN6FbVoVXTk8e" +
+                        "5kcnlpsqSCPLcJ3BIgeGFum93++ac32aQxUMSppT3QN1i44f7C60QA6Xz65k" +
+                        "TL7S6CvLyTTGG4ATx85/Pq8jYU5jzRRbT/VQ05X5GJ+ThOGarTfKUp5jV6td" +
+                        "5AwBi82c7o9T5BGsQwt/lt1is1sWTMLan3m5IlojXnrmaRD5OGlJc+1kb0An" +
+                        "Nbxdl/2kBwuPpMIVvpG5J0ZVN1zDgCnQtOwVvhGtecUo3zS6b9884ebCk1m1" +
+                        "jCVW93SsX+ngl1nthjqEmK9qKFsY2V/gS/vClPLI9Ae0hf34Ekl+JPKAKCwZ" +
+                        "jGvr08zUY/H6ZwE8XgrHSsNBd7UaQuQyKwI1os6mhxAapmjgaUp4pToxNiIn" +
+                        "+u397+rFfniZcsrDDf16VkIJerr/MrRwraxxWFa09ysAHb4q++50bYtNuOfc" +
+                        "c7NPRRc05PU65ExJz9StWll8TYWlvxbL1ZG1lkB2E/d49q203eAeRDMq9cYf" +
+                        "XJ5jPrS+7u2+Mde9mLpqpR567pu9gnIFt0Kx2zgfCJzfw2PIkbvy+KItXKtp" +
+                        "QwBl5QJXsWzeJPYgB5DNyFctoTY+1OmOllSK0H6h/a9DJuIoEz9+ao7xLI+g" +
+                        "HDMAMLznb5ojvFtzzro6ODh6IHYE59+ygzeqNgDqQDQV6w9LdyBOL5rkRbA3" +
+                        "G9hnirXqY/iUlYxBJxrCHQfkQSXvL26CpPnYETJbkpNWWTQ1NWqwBMOplqSl" +
+                        "xZRqS81weFgytly8YJUnElclxGbfa8uxHn6HTQ5StTBK3FPq3HdWXtVZTzq4" +
+                        "K05V1d05/srk4WglRK/W0SaMx9ba+FFEhnKsezbNX7SAlcz/fqlHSQdpxpEs" +
+                        "WF8f+b4u26w/CkyM3FqnEwMjqjUM3bXy6M6c1vZJOUUXrjECNfptlz7lFuEv" +
+                        "kvkCNWivsoXAN2GvsRZjBigrtTDIaFyqnfRcdLFsq9QAui80SnwyvQZbkj1m" +
+                        "SDMRHTRFGQVlEB0iTOJVsq/2NXQWLm2R+bFjp0A5D/zza3gmsnnVSeIVe8vQ" +
+                        "6eHVbf4CTyNGW5wxoR2lB8VC8tfN1uIR6ZJsWjFvZi4LJRTrVoZfwqh4hTHt" +
+                        "EJNDyz9hxAQAtDP9jRje3cSgPD3/8w9gGjz6TkJSn+i6v054V4HphTwVgale" +
+                        "Ho2CShjn5BpJYnUq39NynvSId1V1FCKCKBsSi/xRoJjG69RTGtewcdxn844v" +
+                        "+zm/hb54snCvDhBw4xuZ+Dif0n3m6tdiyRBumHBHTizBlWUp5TsmTf0f5cam" +
+                        "XqngrLJzyf77GXMP26sU5Pp14AWhQ2nX30qU8eDWvDeyCJpLj0OOBDbwqbc4" +
+                        "cHPd/mCYpaKS2AoxULeS14aPeCcz8ofmY9mSLvHVmRo49erW8k26Xt/Cmgzk" +
+                        "AoFLKsf6TJLkO1f3SlACFSH6PDEux7jWjTfZTotcKZu2GxPY+8wNmXnkpsUw" +
+                        "ZS72+oMzNto9drWbM/0guc9JSY1c0IbPTVfJue34RhSjO+END/TNN0MRchrp" +
+                        "ociXhOKtb8rKHivUex6b77pRNxj3ElpnS/ReGF8c7Q5sIlqTF/FGBgb9GV38" +
+                        "j8OOfPx+5EsAbM4MaSqhNF6yLODPvxELDM6rogTH7gmBFrsVXLOIkXdEmz3X" +
+                        "f/TmrDe7EZdDSXTBISAFTxkW8Jfxk/lkoSQrLDDGtUMtFG86nbJNqxXwb9RC" +
+                        "t+O/NgOPc/WAX/L0dXf1sMF7OhDdHe1tbW2dtoPZzoBFEmP30g7wc55XDtc8" +
+                        "49vOFPzpIZiAEMD/0Hf7ix0T8+v6k6X5HWW3Yuz/BYH0Z2fyO8ju1y38C8gy" +
+                        "89+k5nec3a3k/QUnluX/Tcbv+bvbBf0l35n1r+3HoMEsO8fA29ty+wJNO3iA" +
+                        "fwFEnOJ9NQoAAA=="
+                )
+        )
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/ApiFileTest.kt b/metalava/src/test/java/com/android/tools/metalava/ApiFileTest.kt
index 7176f501a..0e0215162 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ApiFileTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ApiFileTest.kt
@@ -1015,7 +1015,7 @@ class ApiFileTest : DriverTest() {
                     method @Deprecated public boolean equals(Object?);
                     method @Deprecated public String toString();
                     field public static final String MY_CONSTANT1 = "constant";
-                    field public final String MY_CONSTANT2 = "constant";
+                    field public final String MY_CONSTANT2;
                     field public String! MY_CONSTANT3;
                   }
                 }
@@ -1267,6 +1267,104 @@ class ApiFileTest : DriverTest() {
         )
     }
 
+    /**
+     * Test for b/174708311 [RequiresOptIn] annotations on properties should be implicitly
+     * propagated to getters / setters to match Kotlin compiler behavior
+     */
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `Test RequiresOptIn on properties`() {
+        check(
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                        package test.pkg
+
+                        @RequiresOptIn
+                        @Retention(AnnotationRetention.BINARY)
+                        annotation class ExperimentalBar
+
+                        class FancyBar
+
+                        @ExperimentalBar
+                        val ExperimentalPropertyWithGetter: FancyBar = FancyBar()
+
+                        @JvmField
+                        @ExperimentalBar
+                        val ExperimentalJvmFieldProperty: FancyBar = FancyBar()
+
+                        @ExperimentalBar
+                        const val ExperimentalConstField: Int = 5
+
+                        @ExperimentalBar
+                        var experimentalPropertyWithGetterAndSetter: FancyBar? = null
+
+                        object Bar {
+                            @ExperimentalBar
+                            val ExperimentalPropertyWithGetterInsideObject: FancyBar = FancyBar()
+                        }
+
+                        @ExperimentalBar
+                        var experimentalPropertyWithCustomGetterAndSetter: FancyBar?
+                            get() = null
+                            set(value) {}
+
+                        /*
+                        The Kotlin compiler does not support explicit RequiresOptIn annotations on
+                        getters (it does for setters), but previously this was used by consumers in
+                        order to enable proper Metalava tracking and make the experimental lint
+                        check consider the getter experimental. This is a regression test to make
+                        sure that we do not add the annotation twice, if it is already present.
+                         */
+                        @Suppress("OPT_IN_MARKER_ON_WRONG_TARGET")
+                        @get:ExperimentalBar
+                        @set:ExperimentalBar
+                        @ExperimentalBar
+                        var experimentalPropertyWithExplicitAnnotationsOnGetterAndSetter: FancyBar?
+                            get() = null
+                            set(value) {}
+                        """
+                    )
+                ),
+            format = FileFormat.V5,
+            api =
+                """
+                // Signature format: 5.0
+                package test.pkg {
+                  public final class Bar {
+                    method @SuppressCompatibility @test.pkg.ExperimentalBar public test.pkg.FancyBar getExperimentalPropertyWithGetterInsideObject();
+                    property @SuppressCompatibility @test.pkg.ExperimentalBar public test.pkg.FancyBar ExperimentalPropertyWithGetterInsideObject;
+                    field public static final test.pkg.Bar INSTANCE;
+                  }
+                  @SuppressCompatibility @kotlin.RequiresOptIn @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) public @interface ExperimentalBar {
+                  }
+                  public final class ExperimentalBarKt {
+                    method @SuppressCompatibility @test.pkg.ExperimentalBar public static test.pkg.FancyBar? getExperimentalPropertyWithCustomGetterAndSetter();
+                    method @SuppressCompatibility @test.pkg.ExperimentalBar public static test.pkg.FancyBar? getExperimentalPropertyWithExplicitAnnotationsOnGetterAndSetter();
+                    method @SuppressCompatibility @test.pkg.ExperimentalBar public static test.pkg.FancyBar getExperimentalPropertyWithGetter();
+                    method @SuppressCompatibility @test.pkg.ExperimentalBar public static test.pkg.FancyBar? getExperimentalPropertyWithGetterAndSetter();
+                    method @SuppressCompatibility @test.pkg.ExperimentalBar public static void setExperimentalPropertyWithCustomGetterAndSetter(test.pkg.FancyBar?);
+                    method @SuppressCompatibility @test.pkg.ExperimentalBar public static void setExperimentalPropertyWithExplicitAnnotationsOnGetterAndSetter(test.pkg.FancyBar?);
+                    method @SuppressCompatibility @test.pkg.ExperimentalBar public static void setExperimentalPropertyWithGetterAndSetter(test.pkg.FancyBar?);
+                    property @SuppressCompatibility @test.pkg.ExperimentalBar public static int ExperimentalConstField;
+                    property @SuppressCompatibility @test.pkg.ExperimentalBar public static test.pkg.FancyBar ExperimentalJvmFieldProperty;
+                    property @SuppressCompatibility @test.pkg.ExperimentalBar public static test.pkg.FancyBar ExperimentalPropertyWithGetter;
+                    property @SuppressCompatibility @test.pkg.ExperimentalBar public static test.pkg.FancyBar? experimentalPropertyWithCustomGetterAndSetter;
+                    property @SuppressCompatibility @test.pkg.ExperimentalBar public static test.pkg.FancyBar? experimentalPropertyWithExplicitAnnotationsOnGetterAndSetter;
+                    property @SuppressCompatibility @test.pkg.ExperimentalBar public static test.pkg.FancyBar? experimentalPropertyWithGetterAndSetter;
+                    field @SuppressCompatibility @test.pkg.ExperimentalBar public static final int ExperimentalConstField = 5; // 0x5
+                    field @SuppressCompatibility @test.pkg.ExperimentalBar public static final test.pkg.FancyBar ExperimentalJvmFieldProperty;
+                  }
+                  public final class FancyBar {
+                    ctor public FancyBar();
+                  }
+                }
+                """,
+            suppressCompatibilityMetaAnnotations = arrayOf("kotlin.RequiresOptIn")
+        )
+    }
+
     @Test
     fun `Extract class with generics`() {
         // Basic interface with generics; makes sure <T extends Object> is written as just <T>
@@ -4113,7 +4211,7 @@ class ApiFileTest : DriverTest() {
                     import androidx.annotation.IntRange;
 
                     public final class ApiClass {
-                        private int hiddenConstant = 1;
+                        private static final int hiddenConstant = 1;
                         public ApiClass(@IntRange(from=1) int x) {}
                         public void method(@IntRange(from = hiddenConstant) int x) {}
                     }
@@ -4216,7 +4314,7 @@ class ApiFileTest : DriverTest() {
                   public final class MyDataClass {
                     ctor public MyDataClass(String constructorProperty, String internalConstructorProperty);
                     method public String component1();
-                    method public test.pkg.MyDataClass copy(String constructorProperty, String internalConstructorProperty);
+                    method public test.pkg.MyDataClass copy(optional String constructorProperty, optional String internalConstructorProperty);
                     method public String getConstructorProperty();
                     property public String constructorProperty;
                   }
@@ -4875,9 +4973,10 @@ class ApiFileTest : DriverTest() {
                 arrayOf(
                     "androidx.annotation.RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY)"
                 ),
-            api = """
-                // Signature format: 4.0
-            """
+            api =
+                """
+                    // Signature format: 4.0
+                """,
         )
     }
 
@@ -5208,7 +5307,7 @@ class ApiFileTest : DriverTest() {
                         package test.pkg
                         internal fun bar() {}
 
-                        private val baz
+                        private val baz = 0
 
                         class Toast {
                             val foo: Int = 0
@@ -5233,7 +5332,7 @@ class ApiFileTest : DriverTest() {
                         @PublishedApi
                         internal fun internalYetPublished() {}
 
-                        private val buzz
+                        private val buzz = 0
                     """
                     ),
                     kotlin(
@@ -5889,4 +5988,88 @@ class ApiFileTest : DriverTest() {
                 """
         )
     }
+
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `Test functions from delegate`() {
+        check(
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                        package test.pkg
+                        internal interface Base {
+                            fun baseMethod()
+                            val baseVal: Int
+                        }
+                        internal class BaseImpl : Base {
+                            override fun baseMethod() = Unit
+                            override val baseVal = 0
+                        }
+                        class Delegated : Base by BaseImpl()
+                        """
+                    )
+                ),
+            // Compiled from the source above with [generateBase64gzipFromKotlin]
+            compiledSourceJar =
+                base64gzip(
+                    "test.jar",
+                    // kotlinc version info: kotlinc-jvm 1.9.23 (JRE 17.0.6+10-b802.1)
+                    "" +
+                        "H4sIAAAAAAAA/wvwZmYRYeDg4GBgYFBkQAYiDCwMvq4hjrqefm76vo5+nm6u" +
+                        "wSF6vm7/TjEwfPY9c9rHW1fvIq+3rta5M+c3BxlcMX7wtEjPy1fH0/di6aot" +
+                        "QR+8dAu1vM6c0Q77cE7/5Mkzj58+esrEEODNzrFeWHO9JdACcyAOwGm9MBCX" +
+                        "pBaX6Bdkp+s7JRan6iXnJBYXh/r7+h9yEJlzd9q2kIlNXQf4Dao2euyp/KR8" +
+                        "TKqHU+1IS3f0jYTczN7dAv1/xPj/cfC3FXxxl7w/qcLg5pnZc2t/p937fv65" +
+                        "eIPwFkmtKC3ZfUsmf4jReNlkyHI+Se+Qz5PJH/Tqpim/PZT0Iblq/9RfKyWM" +
+                        "I9jbmSepBc2OZ564dmnHwmve3HNVKz3mJulssUh9cHmna9kZh5sMEhFev6KT" +
+                        "8mSTHie3nX666OFnte+VG2J+lFQ8+Hln84qi9xt3xpRUtt+taLz8TPZ71f54" +
+                        "fgvD14lfE9ffk12eW10WYLR5F8/Ve/u3arBU7voYH3a9w33lMtF33Tdfe8Sp" +
+                        "zkzJ+Jq+029Z0YQVKueeRM4Tj3qx5MRU5+LE2S8emDlz8jlcbU0XMbm+o13s" +
+                        "KneRVnC7fYtoovKhtBaubR2LpBQdcjmWBRz/JjDvUN+hdU7JveuMvDp/6IPi" +
+                        "YG/Lnb3OjAwMCxnxxYE4ehx45hbkQOIhN+B03mUHEdtk629HVHpnT5vU9v23" +
+                        "6sMtSexOixZwLQ4IcBQMCnucMsXv8Y3QtKCNZ8I/MK65qaCouNEhcHqNyCM/" +
+                        "LtHcyDvV53eWn7tz/Hz8/XqGio7bPN1uWcLvedk/tl0wknybyijhvEX7m+uc" +
+                        "zhqB/X7lqedZCiRXHZdj1zD80R+67oww2/dzd/1YGSs4+FPZzr/ROLvhit3V" +
+                        "B4LOM4TqVM/6XVQ3mnDsmpXS7PrJBiwv489N4lLSmfZwgd/lbe2tJ0PkJod9" +
+                        "aRX8Mt34VnmmdFrsTasJWR4/+U9tElv4T+rw7JtbBK14n1+wiDyiuUtE1m/r" +
+                        "zZK7mRt7Lx1Un2+kXyliMlesfuOmvTI7W/Z8Z5efH9zbvjnz8uOlJ7b/X2d8" +
+                        "pU/fgznw/4FD7M7O6RVhX5bWLi3aaSq5tOiP3xLJ1FdvF6lv6pPQPv1f5fD2" +
+                        "oyl3Js8+NenqW8+8Kx5lU8JCamc9bxV0E915TGru4cV2dpF377WLlebGF3y6" +
+                        "3nH0G5eI9/d9in+cDhws/fTP5uVjtp+nHjLPUUxpXyfX+f685U3PxA/9E2Q5" +
+                        "xQOsr37VnmY3X+Dz/5LSguJ36x+JHfVdpRv8Nkc8r2kqy3Mhkw1eAmdZnhcu" +
+                        "5F5WKDh9l0Z2iIledkGvx+OuY01uvou9fpiDEkdG4ubYG8CE8YAJX+KQQE4c" +
+                        "Lqk5qemJJakpkNRRGhjrL+woYrv5dtn210q3+bdcyV/LEXrTqUYoWUkqyfMq" +
+                        "i+/il80zt03eVLLb2yr4kfL+JvkHm/VVtDrV2r5clE/ds/mKlIrdmb9W38/Z" +
+                        "Fj97vj7fnsGm4fyEcCet+u33P8/vDPiyQyiWu+fg7YfVd/grr3yO31ru4h5p" +
+                        "IJm27O7rGC7uzLYzixW4riSzFReufHmo6a1Cq47zu5D82g3SURbPD1ydEb2y" +
+                        "RP31vesSXL3Ge7P1ziWbcTPLOXvlsk9aeMPCu6z34EvOpcdn2fhEXIkVMVxu" +
+                        "HquwwfcE98Jtj9d1T1J7njTvhOmvjVzNJ9Q7ync+Kuk3vGHsKbbMN0zaYIPd" +
+                        "VXsWK+V5buWtCwv3xBf1TCosyrGa53tPJX9K3/fwXqlo/377NI27Z6rCbq64" +
+                        "ef44e472+5kiy+/18ZvM0lz+Zsv0i+XrjM7ME2s4EfHWXl9JbJqe3ndRzY8m" +
+                        "77juyrs8eppxQeyw+R7ZINX7HdY2OZ8SF3z2vFgp298mu1HwRUpdtsjKBIVZ" +
+                        "jTwctUKuGx9pdSh3ik6ydK02SoiLe+133vRr3I2U1VNsfYoOrJY7uLKu/fc7" +
+                        "DuP4CdZLZjXuTjHmfPdALvL7EvFKESHRl9Zq33UyfE/evnr+RO3Ro/6c/8qP" +
+                        "zTs3Zdnu/zM15f+lHzvw94he4sw/bInTJxx7KnbGat2Vwq192Tv8FPOuFApv" +
+                        "j0oQEr2Tp6gdOCFiwgbVdx46XiKqz1S8RP6zgZJVptGxH4LAJKXDjC9ZSQMx" +
+                        "vNrJTczM08vOL8nJzIvPzU8pzUlNTkhISANiliQ/No2ApAtJDOA65avSnr3C" +
+                        "0EQZ4M3IJMKAMB25vgFVaqgAVxWHbgpyiSmMYkI99poK3QDkXCWOYgAzE85i" +
+                        "Ft0Q5DCUQDFEgQV3dkQ3BTm0pFFMKWfDG/oB3qxsIGWsQBgN9MtlMA8AIz7W" +
+                        "WUQIAAA="
+                ),
+            // The delegate APIs shouldn't be bytecode only, but it is better that they are tracked
+            // that way than not tracked at all.
+            api =
+                """
+                // Signature format: 5.0
+                package test.pkg {
+                  public final class Delegated {
+                    ctor public Delegated();
+                    method @BytecodeOnly public void baseMethod();
+                    method @BytecodeOnly public int getBaseVal();
+                  }
+                }
+                """
+        )
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/ApiFromTextTest.kt b/metalava/src/test/java/com/android/tools/metalava/ApiFromTextTest.kt
index 23bdb1444..ad9116a2c 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ApiFromTextTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ApiFromTextTest.kt
@@ -543,7 +543,7 @@ class ApiFromTextTest : DriverTest() {
                 package libcore.util {
                   public @interface NonNull {
                     method public abstract int from() default java.lang.Integer.MIN_VALUE;
-                    method public abstract double fromWithCast() default (double)java.lang.Float.NEGATIVE_INFINITY;
+                    method public abstract double fromWithCast() default java.lang.Double.NEGATIVE_INFINITY;
                     method public abstract String myString() default "This is a \"string\"";
                     method public abstract int to() default java.lang.Integer.MAX_VALUE;
                   }
diff --git a/metalava/src/test/java/com/android/tools/metalava/ApiLevelsGenerationOptionsTest.kt b/metalava/src/test/java/com/android/tools/metalava/ApiLevelsGenerationOptionsTest.kt
index 99d4398c7..3469f431a 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ApiLevelsGenerationOptionsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ApiLevelsGenerationOptionsTest.kt
@@ -250,6 +250,49 @@ class ApiLevelsGenerationOptionsTest :
     /** Dump the contents of this list to a string. */
     private fun List<VersionedApi>.dump() = cleanupString(joinToString("\n"))
 
+    @Test
+    fun `Test multiple jar files for version forAndroidConfig`() {
+        val root = buildFileStructure {
+            dir("1") {
+                dir("public") {
+                    emptyFile("foo.jar")
+                    emptyFile("bar.jar")
+                }
+            }
+            dir("2") {
+                dir("public") {
+                    emptyFile("foo.jar")
+                    emptyFile("bar.jar")
+                    emptyFile("baz.jar")
+                }
+            }
+        }
+
+        val apiVersionsXml = temporaryFolder.newFile("api-versions.xml")
+        runTest(
+            ARG_CURRENT_VERSION,
+            "30",
+            ARG_GENERATE_API_LEVELS,
+            apiVersionsXml.path,
+            ARG_ANDROID_JAR_PATTERN,
+            "$root/{version:level}/*/{library}.jar",
+        ) {
+            val apiHistoryConfig = options.testForAndroidConfig()
+            assertThat(apiHistoryConfig).isNotNull()
+
+            // Compute the list of versioned files.
+            assertThat(apiHistoryConfig!!.versionedApis.dump())
+                .isEqualTo(
+                    """
+                        VersionedJarApi(jar=TESTROOT/1/public/{bar,foo}.jar, updater=ApiVersionUpdater(version=1))
+                        VersionedJarApi(jar=TESTROOT/2/public/{bar,baz,foo}.jar, updater=ApiVersionUpdater(version=2))
+                        VersionedSourceApi(version=30)
+                    """
+                        .trimIndent()
+                )
+        }
+    }
+
     @Test
     fun `Test extension jar files in forAndroidConfig`() {
         val root = buildFileStructure {
diff --git a/metalava/src/test/java/com/android/tools/metalava/BaselineTest.kt b/metalava/src/test/java/com/android/tools/metalava/BaselineTest.kt
index 59bd108b7..e4bda9cb8 100644
--- a/metalava/src/test/java/com/android/tools/metalava/BaselineTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/BaselineTest.kt
@@ -178,9 +178,8 @@ class BaselineTest : DriverTest() {
         // When using show annotations we should only reference errors that are present in the delta
         check(
             format = FileFormat.V2,
-            includeSystemApiAnnotations = true,
-            extraArguments =
-                arrayOf(ARG_SHOW_ANNOTATION, "android.annotation.TestApi", ARG_API_LINT),
+            includeSystemApiAnnotations = SystemApiType.TEST,
+            extraArguments = arrayOf(ARG_API_LINT),
             baselineTestInfo =
                 BaselineTestInfo(
                     inputContents = "",
diff --git a/metalava/src/test/java/com/android/tools/metalava/DeprecatedTest.kt b/metalava/src/test/java/com/android/tools/metalava/DeprecatedTest.kt
index a748bb508..17d0725b4 100644
--- a/metalava/src/test/java/com/android/tools/metalava/DeprecatedTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/DeprecatedTest.kt
@@ -287,7 +287,8 @@ class DeprecatedTest : DriverTest() {
                       }
                     }
                 """,
-            api = """
+            api =
+                """
                     // Signature format: 5.0
                 """,
             stubPaths = emptyArray(),
diff --git a/metalava/src/test/java/com/android/tools/metalava/DriverTest.kt b/metalava/src/test/java/com/android/tools/metalava/DriverTest.kt
index 5a2062d2c..70be736ca 100644
--- a/metalava/src/test/java/com/android/tools/metalava/DriverTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/DriverTest.kt
@@ -26,6 +26,7 @@ import com.android.tools.lint.checks.infrastructure.TestFiles.java
 import com.android.tools.lint.checks.infrastructure.TestFiles.kotlin
 import com.android.tools.lint.checks.infrastructure.stripComments
 import com.android.tools.lint.client.api.LintClient
+import com.android.tools.metalava.cli.common.ARG_COMPILED_SOURCES
 import com.android.tools.metalava.cli.common.ARG_HIDE
 import com.android.tools.metalava.cli.common.ARG_NO_COLOR
 import com.android.tools.metalava.cli.common.ARG_QUIET
@@ -50,6 +51,8 @@ import com.android.tools.metalava.cli.lint.ARG_UPDATE_BASELINE_API_LINT
 import com.android.tools.metalava.cli.signature.ARG_FORMAT
 import com.android.tools.metalava.model.ANDROIDX_ANNOTATION_PACKAGE
 import com.android.tools.metalava.model.ANDROID_ANNOTATION_PACKAGE
+import com.android.tools.metalava.model.ANDROID_SYSTEM_API
+import com.android.tools.metalava.model.ANDROID_TEST_API
 import com.android.tools.metalava.model.Assertions
 import com.android.tools.metalava.model.StripJavaLangPrefix
 import com.android.tools.metalava.model.provider.Capability
@@ -358,8 +361,7 @@ abstract class DriverTest :
                     baselineFile,
                     inputContents,
                 )
-        }
-            ?: BaselineCheck("", emptyArray(), null, "")
+        } ?: BaselineCheck("", emptyArray(), null, "")
     }
 
     @Suppress("DEPRECATION")
@@ -466,7 +468,7 @@ abstract class DriverTest :
         /** See [TestEnvironment.skipEmitPackages], defaults to [DEFAULT_SKIP_EMIT_PACKAGES]. */
         skipEmitPackages: List<String>? = null,
         /** Whether we should include --showAnnotations=android.annotation.SystemApi */
-        includeSystemApiAnnotations: Boolean = false,
+        includeSystemApiAnnotations: SystemApiType? = null,
         /** Whether we should warn about super classes that are stripped because they are hidden */
         includeStrippedSuperclassWarnings: Boolean = false,
         /**
@@ -526,6 +528,8 @@ abstract class DriverTest :
         sourceFiles: Array<TestFile> = emptyArray(),
         /** Lint project description */
         projectDescription: TestFile? = null,
+        /** Jar file with the compiled sources loaded in addition to [sourceFiles]. */
+        compiledSourceJar: TestFile? = null,
         /** [ARG_REPEAT_ERRORS_MAX] */
         repeatErrorsMax: Int = 0,
         /**
@@ -610,6 +614,18 @@ abstract class DriverTest :
 
         val projectDescriptionFile = projectDescription?.createFile(project)
 
+        val compiledSourceJarFile = compiledSourceJar?.createFile(project)
+        if (
+            compiledSourceJarFile != null &&
+                Capability.JAR_WITH_SOURCES !in codebaseCreatorConfig.creator.capabilities
+        ) {
+            error(
+                "Provider ${codebaseCreatorConfig.providerName} does not support compiled " +
+                    "sources; please add `@RequiresCapabilities(Capability.JAR_WITH_SOURCES)` to " +
+                    "the test"
+            )
+        }
+
         val apiClassResolutionArgs =
             arrayOf(ARG_API_CLASS_RESOLUTION, apiClassResolution.optionValue)
 
@@ -789,19 +805,16 @@ abstract class DriverTest :
             }
 
         val showAnnotationArguments =
-            if (showAnnotations.isNotEmpty() || includeSystemApiAnnotations) {
+            if (showAnnotations.isNotEmpty() || includeSystemApiAnnotations != null) {
                 val args = mutableListOf<String>()
                 for (annotation in showAnnotations) {
                     args.add(ARG_SHOW_ANNOTATION)
                     args.add(annotation)
                 }
-                if (includeSystemApiAnnotations && !args.contains("android.annotation.SystemApi")) {
-                    args.add(ARG_SHOW_ANNOTATION)
-                    args.add("android.annotation.SystemApi")
-                }
-                if (includeSystemApiAnnotations && !args.contains("android.annotation.TestApi")) {
-                    args.add(ARG_SHOW_ANNOTATION)
-                    args.add("android.annotation.TestApi")
+                if (includeSystemApiAnnotations != null) {
+                    if (!args.contains(includeSystemApiAnnotations.annotationClass)) {
+                        args.addAll(includeSystemApiAnnotations.extraArguments)
+                    }
                 }
                 args.toTypedArray()
             } else {
@@ -1075,6 +1088,10 @@ abstract class DriverTest :
                             addAll(classpathArgs)
                             addAll(kotlinPathArgs)
                         }
+                        if (compiledSourceJarFile != null) {
+                            add(ARG_COMPILED_SOURCES)
+                            add(compiledSourceJarFile.absolutePath)
+                        }
                     }
                     .toTypedArray()
 
@@ -1426,22 +1443,7 @@ fun findKotlinStdlibPathArgs(sources: Array<String>): Array<String> {
         )
 }
 
-val intRangeAnnotationSource: TestFile =
-    java(
-            """
-        package android.annotation;
-        import java.lang.annotation.*;
-        import static java.lang.annotation.ElementType.*;
-        import static java.lang.annotation.RetentionPolicy.SOURCE;
-        @Retention(SOURCE)
-        @Target({METHOD,PARAMETER,FIELD,LOCAL_VARIABLE,ANNOTATION_TYPE})
-        public @interface IntRange {
-            long from() default Long.MIN_VALUE;
-            long to() default Long.MAX_VALUE;
-        }
-        """
-        )
-        .indented()
+val intRangeAnnotationSource = KnownSourceFiles.intRangeAnnotationSource
 
 val intDefAnnotationSource: TestFile =
     java(
@@ -1562,27 +1564,50 @@ val requiresApiSource: TestFile =
         )
         .indented()
 
+val flaggedApiSource: TestFile =
+    java(
+            """
+        package android.annotation;
+        import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
+        import static java.lang.annotation.ElementType.CONSTRUCTOR;
+        import static java.lang.annotation.ElementType.FIELD;
+        import static java.lang.annotation.ElementType.METHOD;
+        import static java.lang.annotation.ElementType.TYPE;
+
+        import java.lang.annotation.Retention;
+        import java.lang.annotation.RetentionPolicy;
+        import java.lang.annotation.Target;
+        /** @hide */
+        @Target({TYPE, METHOD, CONSTRUCTOR, FIELD, ANNOTATION_TYPE})
+        @Retention(RetentionPolicy.CLASS)
+        public @interface FlaggedApi {
+            String value();
+        }
+    """
+        )
+        .indented()
+
 private fun restrictedForEnvironmentClass(packageName: String): TestFile =
     java(
             """
             package $packageName;
             import java.lang.annotation.*;
             import static java.lang.annotation.ElementType.*;
-            import static java.lang.annotation.RetentionPolicy.SOURCE;
+            import static java.lang.annotation.RetentionPolicy;
             /** @hide */
-            @Retention(SOURCE)
+            @Retention(RetentionPolicy.RUNTIME)
             @Target({TYPE})
             public @interface RestrictedForEnvironment {
-              Environment[] environments();
+              @Environment String[] environments();
               int from();
-              enum Environment {
-                SDK_SANDBOX {
-                    @Override
-                    public String toString() {
-                        return "SDK Runtime";
-                    }
-                }
-              }
+              String ENVIRONMENT_SDK_RUNTIME = "SDK Runtime";
+              /** @hide */
+              @StringDef(prefix = "ENVIRONMENT_", value = {
+                ENVIRONMENT_SDK_RUNTIME
+              })
+              @Retention(RetentionPolicy.SOURCE)
+              @interface Environment {}
+
               @Retention(RetentionPolicy.RUNTIME)
               @Target(TYPE)
               @interface Container {
@@ -1596,23 +1621,6 @@ private fun restrictedForEnvironmentClass(packageName: String): TestFile =
 val androidXRestrictedForEnvironment = restrictedForEnvironmentClass(ANDROIDX_ANNOTATION_PACKAGE)
 val androidRestrictedForEnvironment = restrictedForEnvironmentClass(ANDROID_ANNOTATION_PACKAGE)
 
-val sdkConstantSource: TestFile =
-    java(
-            """
-    package android.annotation;
-    import java.lang.annotation.*;
-    @Target({ ElementType.FIELD })
-    @Retention(RetentionPolicy.SOURCE)
-    public @interface SdkConstant {
-        enum SdkConstantType {
-            ACTIVITY_INTENT_ACTION, BROADCAST_INTENT_ACTION, SERVICE_ACTION, INTENT_CATEGORY, FEATURE
-        }
-        SdkConstantType value();
-    }
-    """
-        )
-        .indented()
-
 val broadcastBehaviorSource: TestFile =
     java(
             """
@@ -1805,44 +1813,7 @@ val widgetSource: TestFile =
         )
         .indented()
 
-val restrictToSource: TestFile =
-    kotlin(
-            """
-    package androidx.annotation
-
-    import androidx.annotation.RestrictTo.Scope
-    import java.lang.annotation.ElementType.*
-
-    @MustBeDocumented
-    @Retention(AnnotationRetention.BINARY)
-    @Target(
-        AnnotationTarget.ANNOTATION_CLASS,
-        AnnotationTarget.CLASS,
-        AnnotationTarget.FUNCTION,
-        AnnotationTarget.PROPERTY_GETTER,
-        AnnotationTarget.PROPERTY_SETTER,
-        AnnotationTarget.CONSTRUCTOR,
-        AnnotationTarget.FIELD,
-        AnnotationTarget.FILE
-    )
-    // Needed due to Kotlin's lack of PACKAGE annotation target
-    // https://youtrack.jetbrains.com/issue/KT-45921
-    @Suppress("DEPRECATED_JAVA_ANNOTATION")
-    @java.lang.annotation.Target(ANNOTATION_TYPE, TYPE, METHOD, CONSTRUCTOR, FIELD, PACKAGE)
-    annotation class RestrictTo(vararg val value: Scope) {
-        enum class Scope {
-            LIBRARY,
-            LIBRARY_GROUP,
-            LIBRARY_GROUP_PREFIX,
-            @Deprecated("Use LIBRARY_GROUP_PREFIX instead.")
-            GROUP_ID,
-            TESTS,
-            SUBCLASSES,
-        }
-    }
-    """
-        )
-        .indented()
+val restrictToSource = KnownSourceFiles.restrictToSource
 
 val visibleForTestingSource: TestFile =
     java(
@@ -1913,23 +1884,6 @@ val publishedApiSource: TestFile =
         )
         .indented()
 
-val deprecatedForSdkSource: TestFile =
-    java(
-            """
-    package android.annotation;
-    import static java.lang.annotation.RetentionPolicy.SOURCE;
-    import java.lang.annotation.Retention;
-    /** @hide */
-    @Retention(SOURCE)
-    @SuppressWarnings("WeakerAccess")
-    public @interface DeprecatedForSdk {
-        String value();
-        Class<?>[] allowIn() default {};
-    }
-    """
-        )
-        .indented()
-
 val DEFAULT_SKIP_EMIT_PACKAGES =
     listOf(
         // Do not emit classes in a number of java packages. While tests will
@@ -1955,3 +1909,44 @@ val TYPE_USE_FORMAT =
         kotlinStyleNulls = false,
         specifiedStripJavaLangPrefix = StripJavaLangPrefix.ALWAYS,
     )
+
+/**
+ * Enumeration of the different types of system APIs used in Android.
+ *
+ * While this is Android specific it does test behavior relied upon by other users of Metalava, e.g.
+ * AndroidX.
+ *
+ * @param annotationClass The annotation class name, used to check to see if this is present in the
+ *   arguments already.
+ * @param annotationFilter The annotation filter to pass on the command line, e.g. for a
+ *   `--show-annotation` option.
+ */
+enum class SystemApiType(
+    val annotationClass: String,
+    private val annotationFilter: String = ANDROID_SYSTEM_API,
+    private val forStubs: List<SystemApiType> = emptyList()
+) {
+    PRIVILEGED_APPS(
+        annotationClass = ANDROID_SYSTEM_API,
+        annotationFilter = "$ANDROID_SYSTEM_API(client=$ANDROID_SYSTEM_API.Client.PRIVILEGED_APPS)",
+    ),
+    // MODULE_LIBRARIES is not required yet.
+    // SYSTEM_SERVER is not required yet.
+    TEST(
+        annotationClass = ANDROID_TEST_API,
+        annotationFilter = ANDROID_TEST_API,
+        forStubs = listOf(PRIVILEGED_APPS),
+    ),
+    ;
+
+    /** The arguments to pass on the command line. */
+    val extraArguments
+        get() = buildList {
+            add(ARG_SHOW_ANNOTATION)
+            add(annotationFilter)
+            for (forStub in forStubs) {
+                add(ARG_SHOW_FOR_STUB_PURPOSES_ANNOTATION)
+                add(forStub.annotationFilter)
+            }
+        }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/ExtractAnnotationsTest.kt b/metalava/src/test/java/com/android/tools/metalava/ExtractAnnotationsTest.kt
index 0592653fa..8f220082b 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ExtractAnnotationsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ExtractAnnotationsTest.kt
@@ -176,7 +176,7 @@ class ExtractAnnotationsTest : DriverTest() {
                     <root>
                       <item name="test.pkg.LongDefTest void setFlags(java.lang.Object, int) 1">
                         <annotation name="androidx.annotation.LongDef">
-                          <val name="value" val="{test.pkg.LongDefTestKt.STYLE_NORMAL, test.pkg.LongDefTestKt.STYLE_NO_TITLE, test.pkg.LongDefTestKt.STYLE_NO_FRAME, test.pkg.LongDefTestKt.STYLE_NO_INPUT, 3, 4L}" />
+                          <val name="value" val="{test.pkg.LongDefTestKt.STYLE_NORMAL, test.pkg.LongDefTestKt.STYLE_NO_TITLE, test.pkg.LongDefTestKt.STYLE_NO_FRAME, test.pkg.LongDefTestKt.STYLE_NO_INPUT, 3L, 4L}" />
                           <val name="flag" val="true" />
                         </annotation>
                       </item>
@@ -187,7 +187,7 @@ class ExtractAnnotationsTest : DriverTest() {
                       </item>
                       <item name="test.pkg.LongDefTest.Inner void setInner(int) 0">
                         <annotation name="androidx.annotation.LongDef">
-                          <val name="value" val="{test.pkg.LongDefTestKt.STYLE_NORMAL, test.pkg.LongDefTestKt.STYLE_NO_TITLE, test.pkg.LongDefTestKt.STYLE_NO_FRAME, test.pkg.LongDefTestKt.STYLE_NO_INPUT, 3, 4L}" />
+                          <val name="value" val="{test.pkg.LongDefTestKt.STYLE_NORMAL, test.pkg.LongDefTestKt.STYLE_NO_TITLE, test.pkg.LongDefTestKt.STYLE_NO_FRAME, test.pkg.LongDefTestKt.STYLE_NO_INPUT, 3L, 4L}" />
                           <val name="flag" val="true" />
                         </annotation>
                       </item>
@@ -259,7 +259,7 @@ class ExtractAnnotationsTest : DriverTest() {
                     <root>
                       <item name="test.pkg.LongDefTest void setFlags(java.lang.Object, int) 1">
                         <annotation name="androidx.annotation.LongDef">
-                          <val name="value" val="{test.pkg.LongDefTestKt.STYLE_NORMAL, test.pkg.LongDefTestKt.STYLE_NO_TITLE, test.pkg.LongDefTestKt.STYLE_NO_FRAME, test.pkg.LongDefTestKt.STYLE_NO_INPUT, 3, 4L}" />
+                          <val name="value" val="{test.pkg.LongDefTestKt.STYLE_NORMAL, test.pkg.LongDefTestKt.STYLE_NO_TITLE, test.pkg.LongDefTestKt.STYLE_NO_FRAME, test.pkg.LongDefTestKt.STYLE_NO_INPUT, 3L, 4L}" />
                           <val name="flag" val="true" />
                         </annotation>
                       </item>
@@ -270,7 +270,7 @@ class ExtractAnnotationsTest : DriverTest() {
                       </item>
                       <item name="test.pkg.LongDefTest.Inner void setInner(int) 0">
                         <annotation name="androidx.annotation.LongDef">
-                          <val name="value" val="{test.pkg.LongDefTestKt.STYLE_NORMAL, test.pkg.LongDefTestKt.STYLE_NO_TITLE, test.pkg.LongDefTestKt.STYLE_NO_FRAME, test.pkg.LongDefTestKt.STYLE_NO_INPUT, 3, 4L}" />
+                          <val name="value" val="{test.pkg.LongDefTestKt.STYLE_NORMAL, test.pkg.LongDefTestKt.STYLE_NO_TITLE, test.pkg.LongDefTestKt.STYLE_NO_FRAME, test.pkg.LongDefTestKt.STYLE_NO_INPUT, 3L, 4L}" />
                           <val name="flag" val="true" />
                         </annotation>
                       </item>
@@ -357,7 +357,6 @@ class ExtractAnnotationsTest : DriverTest() {
     fun `Include merged annotations in exported source annotations`() {
         check(
             format = FileFormat.V2,
-            includeSystemApiAnnotations = false,
             expectedIssues = "error: Unexpected reference to Nonexistent.Field [InternalError]",
             sourceFiles =
                 arrayOf(
@@ -424,7 +423,6 @@ class ExtractAnnotationsTest : DriverTest() {
     fun `Only including class retention annotations in stubs`() {
         check(
             format = FileFormat.V2,
-            includeSystemApiAnnotations = false,
             sourceFiles =
                 arrayOf(
                     java(
@@ -598,7 +596,7 @@ class ExtractAnnotationsTest : DriverTest() {
                 package test.pkg {
                   public class IntDefTest {
                     ctor public IntDefTest();
-                    method public void setFlags(Object, @IntDef(value={test.pkg.IntDefTest.STYLE_NORMAL, test.pkg.IntDefTest.STYLE_NO_TITLE, test.pkg.IntDefTest.STYLE_NO_FRAME, test.pkg.IntDefTest.STYLE_NO_INPUT, 3, 3 + 1}, flag=true) int);
+                    method public void setFlags(Object, @IntDef(value={test.pkg.IntDefTest.STYLE_NORMAL, test.pkg.IntDefTest.STYLE_NO_TITLE, test.pkg.IntDefTest.STYLE_NO_FRAME, test.pkg.IntDefTest.STYLE_NO_INPUT, 3, 0x4}, flag=true) int);
                     method public void setStyle(@IntDef({test.pkg.IntDefTest.STYLE_NORMAL, test.pkg.IntDefTest.STYLE_NO_TITLE, test.pkg.IntDefTest.STYLE_NO_FRAME, test.pkg.IntDefTest.STYLE_NO_INPUT}) int, int);
                     method public void testIntDef(int);
                     field public static final int STYLE_NORMAL = 0; // 0x0
@@ -612,7 +610,7 @@ class ExtractAnnotationsTest : DriverTest() {
                   }
                   public static class IntDefTest.Inner {
                     ctor public IntDefTest.Inner();
-                    method public void setInner(@IntDef(value={test.pkg.IntDefTest.STYLE_NORMAL, test.pkg.IntDefTest.STYLE_NO_TITLE, test.pkg.IntDefTest.STYLE_NO_FRAME, test.pkg.IntDefTest.STYLE_NO_INPUT, 3, 3 + 1}, flag=true) int);
+                    method public void setInner(@IntDef(value={test.pkg.IntDefTest.STYLE_NORMAL, test.pkg.IntDefTest.STYLE_NO_TITLE, test.pkg.IntDefTest.STYLE_NO_FRAME, test.pkg.IntDefTest.STYLE_NO_INPUT, 3, 0x4}, flag=true) int);
                   }
                 }
             """
@@ -656,7 +654,6 @@ class ExtractAnnotationsTest : DriverTest() {
     fun `Test generics in XML attributes are encoded`() {
         check(
             format = FileFormat.V2,
-            includeSystemApiAnnotations = false,
             sourceFiles =
                 arrayOf(
                     java(
@@ -810,15 +807,23 @@ class ExtractAnnotationsTest : DriverTest() {
             extractAnnotations =
                 mapOf(
                     "test.pkg" to
-                        // TODO(b/331752084): Add missing annotations
                         """
                             <?xml version="1.0" encoding="UTF-8"?>
                             <root>
                               <item name="test.pkg.Foo void foo1()">
+                                <annotation name="androidx.annotation.RequiresPermission">
+                                  <val name="value" val="&quot;Permission1&quot;" />
+                                </annotation>
                               </item>
                               <item name="test.pkg.Foo void foo2()">
+                                <annotation name="androidx.annotation.RequiresPermission">
+                                  <val name="value" val="&quot;Permission2&quot;" />
+                                </annotation>
                               </item>
                               <item name="test.pkg.Foo void foo3()">
+                                <annotation name="androidx.annotation.RequiresPermission">
+                                  <val name="value" val="&quot;UnresolvedPermission&quot;" />
+                                </annotation>
                               </item>
                             </root>
                         """
diff --git a/metalava/src/test/java/com/android/tools/metalava/FlaggedApiEdgeCasesTest.kt b/metalava/src/test/java/com/android/tools/metalava/FlaggedApiEdgeCasesTest.kt
index fcf4e7497..4f6a7f5d1 100644
--- a/metalava/src/test/java/com/android/tools/metalava/FlaggedApiEdgeCasesTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/FlaggedApiEdgeCasesTest.kt
@@ -45,6 +45,7 @@ class FlaggedApiEdgeCasesTest : DriverTest() {
                     java(
                         """
                             package other.pkg;
+                            import $ANDROID_FLAGGED_API;
 
                             public abstract class Other {
                                 @$ANDROID_FLAGGED_API("flag.name")
@@ -67,6 +68,7 @@ class FlaggedApiEdgeCasesTest : DriverTest() {
                             }
                         """
                     ),
+                    flaggedApiSource
                 ),
             stubFiles =
                 arrayOf(
@@ -126,6 +128,7 @@ class FlaggedApiEdgeCasesTest : DriverTest() {
                             }
                         """
                     ),
+                    flaggedApiSource
                 ),
             checkCompatibilityApiReleased =
                 """
@@ -149,4 +152,106 @@ class FlaggedApiEdgeCasesTest : DriverTest() {
                 ),
         )
     }
+
+    @Test
+    fun `Test javadoc for flagged class includes @apiSince`() {
+        check(
+            configFiles = arrayOf(KnownConfigFiles.configEmptyApiFlags),
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            /**
+                            * Javadoc for Test
+                            */
+                            @$ANDROID_FLAGGED_API("flag.name")
+                            public class Test {
+                            }
+                        """
+                    ),
+                    flaggedApiSource
+                ),
+            docStubs = true,
+            applyApiLevelsXml =
+                """
+                    <?xml version="1.0" encoding="utf-8"?>
+                    <api version="2">
+                      <class name="test/pkg/Test" since="31">
+                      </class>
+                    </api>
+                """,
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            /**
+                             * Javadoc for Test
+                             * @apiSince 31
+                             */
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public class Test {
+                            Test() { throw new RuntimeException("Stub!"); }
+                            }
+                        """
+                    )
+                ),
+            checkCompatibilityApiReleased =
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public class Test {
+                      }
+                    }
+                """,
+        )
+    }
+
+    @Test
+    fun `Test unresolvable flag field`() {
+        check(
+            configFiles = arrayOf(KnownConfigFiles.configEmptyApiFlags),
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            @$ANDROID_FLAGGED_API(UnresolvableFlag.FLAG_NAME)
+                            public class Test {
+                            }
+                        """
+                    ),
+                    flaggedApiSource
+                ),
+            api =
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public class Test {
+                      }
+                    }
+                """,
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public class Test {
+                            Test() { throw new RuntimeException("Stub!"); }
+                            }
+                        """
+                    )
+                ),
+            checkCompatibilityApiReleased =
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public class Test {
+                      }
+                    }
+                """,
+        )
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/JarToJDiffCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/JarToJDiffCommandTest.kt
index d0d20c00b..1d2905f36 100644
--- a/metalava/src/test/java/com/android/tools/metalava/JarToJDiffCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/JarToJDiffCommandTest.kt
@@ -17,6 +17,8 @@
 package com.android.tools.metalava
 
 import com.android.tools.metalava.cli.common.BaseCommandTest
+import com.android.tools.metalava.testing.jarFromSources
+import com.android.tools.metalava.testing.java
 import java.io.File
 import kotlin.test.assertEquals
 import org.junit.Assert
@@ -194,4 +196,58 @@ Arguments:
             verify { assertEquals(expectedXml.trimIndent(), xmlFile.readText().trim()) }
         }
     }
+
+    @Test
+    fun `Test enums`() {
+        commandTest {
+            args += "jar-to-jdiff"
+            args +=
+                jarFromSources(
+                    "test.jar",
+                    java(
+                        """
+                        package test.pkg;
+                        public enum Foo {
+                            CONSTANT
+                        }
+                    """
+                    )
+                )
+
+            val xmlFile = outputFile("api.xml")
+            args += xmlFile
+
+            val expectedXml =
+                """
+                    <api xmlns:metalava="http://www.android.com/metalava/">
+                    <package name="test.pkg"
+                    >
+                    <class name="Foo"
+                     extends="java.lang.Enum"
+                     abstract="false"
+                     static="false"
+                     final="true"
+                     deprecated="not deprecated"
+                     visibility="public"
+                    >
+                    <field name="CONSTANT"
+                     type="test.pkg.Foo"
+                     transient="false"
+                     volatile="false"
+                     static="true"
+                     final="true"
+                     deprecated="not deprecated"
+                     visibility="public"
+                     metalava:enumConstant="true"
+                    >
+                    </field>
+                    </class>
+                    </package>
+                    </api>
+                """
+
+            // Verify that the generate file is correct.
+            verify { assertEquals(expectedXml.trimIndent(), xmlFile.readText().trim()) }
+        }
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/KotlinInteropChecksTest.kt b/metalava/src/test/java/com/android/tools/metalava/KotlinInteropChecksTest.kt
index c0a33a19a..32378599a 100644
--- a/metalava/src/test/java/com/android/tools/metalava/KotlinInteropChecksTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/KotlinInteropChecksTest.kt
@@ -162,14 +162,14 @@ class KotlinInteropChecksTest : DriverTest() {
                     kotlin(
                         """
                     package test.pkg
-
+                    import java.math.BigInteger
                     @SuppressWarnings("all")
                     class Foo {
                         fun ok1() { }
                         companion object {
                             const val INTEGER_ONE = 1
-                            val BIG_INTEGER_ONE = BigInteger.ONE
-                            private val PRIVATE_BIG_INTEGER = BigInteger.ONE
+                            val BIG_INTEGER_ONE: BigInteger = BigInteger.ONE // type specified to define nullability
+                            private val PRIVATE_BIG_INTEGER: BigInteger = BigInteger.ONE
                             var wrongNeedsJvmStatic = 1
                             @JvmStatic var ok = 1.5
                             @JvmStatic val WRONG = 2
@@ -557,4 +557,27 @@ class KotlinInteropChecksTest : DriverTest() {
                 ),
         )
     }
+
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `Check no JvmOverloads warning for data class copy method`() {
+        check(
+            apiLint = "", // Enabled
+            expectedIssues =
+                // Line 3 is where notCopy is defined. The copy method would get line 2 (where the
+                // class/constructor is defined).
+                "src/test/pkg/Foo.kt:3: warning: A Kotlin method with default parameter values should be annotated with @JvmOverloads for better Java interoperability; see https://android.github.io/kotlin-guides/interop.html#function-overloads-for-defaults [MissingJvmstatic]",
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                        package test.pkg
+                        data class Foo(val p0: Int = 0, val p1: String = "") {
+                            fun notCopy(p0: Int = 0, p1: String = "") = Unit
+                        }
+                        """
+                    )
+                )
+        )
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/NullnessMigrationTest.kt b/metalava/src/test/java/com/android/tools/metalava/NullnessMigrationTest.kt
index 1b78e2b8a..fe3717913 100644
--- a/metalava/src/test/java/com/android/tools/metalava/NullnessMigrationTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/NullnessMigrationTest.kt
@@ -18,6 +18,7 @@ package com.android.tools.metalava
 
 import com.android.tools.metalava.model.SUPPORT_TYPE_USE_ANNOTATIONS
 import com.android.tools.metalava.model.text.FileFormat
+import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import org.junit.Test
 
@@ -637,7 +638,7 @@ class NullnessMigrationTest : DriverTest() {
     fun `Merge nullness annotations in stubs that are not in the API signature file`() {
         check(
             format = FileFormat.V2,
-            includeSystemApiAnnotations = true,
+            includeSystemApiAnnotations = SystemApiType.PRIVILEGED_APPS,
             sourceFiles =
                 arrayOf(
                     java(
@@ -684,6 +685,7 @@ class NullnessMigrationTest : DriverTest() {
                     ),
                     androidxNonNullSource,
                     androidxNullableSource,
+                    KnownSourceFiles.systemApiSource,
                 ),
             migrateNullsApiList =
                 listOf(
diff --git a/metalava/src/test/java/com/android/tools/metalava/OptionsTest.kt b/metalava/src/test/java/com/android/tools/metalava/OptionsTest.kt
index cab7b83d1..44aa03c41 100644
--- a/metalava/src/test/java/com/android/tools/metalava/OptionsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/OptionsTest.kt
@@ -87,6 +87,7 @@ Sub-commands:
   main                                       The default sub-command that is run if no sub-command is specified.
   android-jars-to-signatures                 Rewrite the signature files in the `prebuilts/sdk` directory in the Android
                                              source tree.
+  flag-report                                Generates a flag report
   help                                       Provides help for general metalava concepts.
   jar-to-jdiff                               Convert a jar file into a file in the JDiff XML format.
   merge-signatures                           Merge multiple signature files together into a single file.
diff --git a/metalava/src/test/java/com/android/tools/metalava/ParameterizedFlaggedApiTest.kt b/metalava/src/test/java/com/android/tools/metalava/ParameterizedFlaggedApiTest.kt
index 9e378db6e..554d74717 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ParameterizedFlaggedApiTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ParameterizedFlaggedApiTest.kt
@@ -909,7 +909,8 @@ class ParameterizedFlaggedApiTest(private val config: Configuration) : DriverTes
                     public final class Foo {
                     public Foo() { throw new RuntimeException("Stub!"); }
                     public void method() { throw new RuntimeException("Stub!"); }
-                    public final int field = 2; // 0x2
+                    public final int field;
+                    { field = 0; }
                     }
                 """
                 ),
@@ -990,7 +991,7 @@ class ParameterizedFlaggedApiTest(private val config: Configuration) : DriverTes
                                   @FlaggedApi("test.pkg.flags.foo_bar") public final class Foo {
                                     ctor public Foo();
                                     method public void method();
-                                    field public final int field = 2; // 0x2
+                                    field public final int field;
                                   }
                                 }
                             """,
@@ -1102,7 +1103,8 @@ class ParameterizedFlaggedApiTest(private val config: Configuration) : DriverTes
                     public final class Foo {
                     public Foo() { throw new RuntimeException("Stub!"); }
                     public void method() { throw new RuntimeException("Stub!"); }
-                    public final int field = 2; // 0x2
+                    public final int field;
+                    { field = 0; }
                     }
                 """
                 ),
@@ -1187,7 +1189,7 @@ class ParameterizedFlaggedApiTest(private val config: Configuration) : DriverTes
                                   @FlaggedApi("test.pkg.flags.foo_bar") public final class Foo {
                                     ctor public Foo();
                                     method public void method();
-                                    field public final int field = 2; // 0x2
+                                    field public final int field;
                                   }
                                 }
                             """,
diff --git a/metalava/src/test/java/com/android/tools/metalava/ParameterizedSelectedApiVariantsTest.kt b/metalava/src/test/java/com/android/tools/metalava/ParameterizedSelectedApiVariantsTest.kt
index f6305ab8f..a95d8d3af 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ParameterizedSelectedApiVariantsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ParameterizedSelectedApiVariantsTest.kt
@@ -16,7 +16,6 @@
 
 package com.android.tools.metalava
 
-import com.android.tools.metalava.model.ANDROID_SYSTEM_API
 import com.android.tools.metalava.model.api.surface.ApiVariantType
 import com.android.tools.metalava.model.testing.surfaces.SelectedApiVariantsTestData
 import com.android.tools.metalava.model.testing.surfaces.selectedApiVariantsTestData
@@ -44,12 +43,11 @@ class ParameterizedSelectedApiVariantsTest : DriverTest() {
                 .partition { apiVariantTypeForTestSignatureFile(it) != ApiVariantType.REMOVED }
 
         // If the test needs a base ApiSurface then add --show-annotation SystemApi to create one.
-        val extraArguments =
-            if (testData.needsBase) arrayOf(ARG_SHOW_ANNOTATION, ANDROID_SYSTEM_API)
-            else emptyArray()
+        val includeSystemApiAnnotations =
+            if (testData.needsBase) SystemApiType.PRIVILEGED_APPS else null
 
         check(
-            extraArguments = extraArguments,
+            includeSystemApiAnnotations = includeSystemApiAnnotations,
             // Although this test is only check the selectedApiVariants state it must provide source
             // files as otherwise the compatibility check will fail as it will compare the API
             // loaded from the signature files against an empty Codebase and report that items have
diff --git a/metalava/src/test/java/com/android/tools/metalava/ProjectDescriptionTest.kt b/metalava/src/test/java/com/android/tools/metalava/ProjectDescriptionTest.kt
index 65d71603a..bc4dc3987 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ProjectDescriptionTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ProjectDescriptionTest.kt
@@ -21,6 +21,7 @@ import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.testing.createAndroidModuleDescription
 import com.android.tools.metalava.testing.createCommonModuleDescription
 import com.android.tools.metalava.testing.createProjectDescription
+import com.android.tools.metalava.testing.defaultJvmPlatforms
 import com.android.tools.metalava.testing.getAndroidJar
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
@@ -87,7 +88,7 @@ class ProjectDescriptionTest : DriverTest() {
                     "project.xml",
                     """
                         <project>
-                          <module name="app" android="true" library="false">
+                          <module name="app" android="true" library="false" kotlinPlatforms="$defaultJvmPlatforms">
                             <src file="androidMain/src/some/pkg/Foo.kt" />
                             <src file="androidMain/src/test/Bar.java" />
                             <classpath file="${getAndroidJar()}"/>
@@ -147,7 +148,7 @@ class ProjectDescriptionTest : DriverTest() {
                     """
                         <project>
                           <root dir="src/androidMain"/>
-                          <module name="androidMain" android="true">
+                          <module name="androidMain" android="true" kotlinPlatforms="$defaultJvmPlatforms">
                             <src file="src/androidMain/some/pkg/Foo.kt" />
                             $standardProjectXmlClasspath
                           </module>
@@ -194,7 +195,7 @@ class ProjectDescriptionTest : DriverTest() {
                     """
                         <project>
                           <root dir="src/androidMain"/>
-                          <module name="androidMain">
+                          <module name="androidMain" kotlinPlatforms="$defaultJvmPlatforms">
                             <src file="src/androidMain/some/pkg/Foo.kt"/>
                             $standardProjectXmlClasspath
                           </module>
diff --git a/metalava/src/test/java/com/android/tools/metalava/RequiresFeatureTest.kt b/metalava/src/test/java/com/android/tools/metalava/RequiresFeatureTest.kt
index e3108b4f8..ecb629476 100644
--- a/metalava/src/test/java/com/android/tools/metalava/RequiresFeatureTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/RequiresFeatureTest.kt
@@ -117,7 +117,7 @@ class RequiresFeatureTest : DriverTest() {
             expectedText =
                 "Requires the PackageManager#FEATURE_HIDDEN feature which can be detected using {@link android.content.pm.PackageManager#hasSystemFeature(String) PackageManager.hasSystemFeature(String)}.",
             expectedIssues =
-                "src/test/pkg/FeatureUser.java:6: error: Feature field PackageManager.FEATURE_HIDDEN required by class test.pkg.FeatureUser is hidden or removed [MissingPermission]",
+                "src/test/pkg/FeatureUser.java:6: error: Feature field android.content.pm.PackageManager.FEATURE_HIDDEN required by class test.pkg.FeatureUser is hidden or removed [MissingPermission]",
         )
     }
 
diff --git a/metalava/src/test/java/com/android/tools/metalava/SdkFileWriterTest.kt b/metalava/src/test/java/com/android/tools/metalava/SdkFileWriterTest.kt
index 23f32a839..eab8e8d52 100644
--- a/metalava/src/test/java/com/android/tools/metalava/SdkFileWriterTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/SdkFileWriterTest.kt
@@ -19,6 +19,7 @@
 package com.android.tools.metalava
 
 import com.android.tools.metalava.lint.DefaultLintErrorMessage
+import com.android.tools.metalava.testing.KnownSourceFiles.sdkConstantSource
 import com.android.tools.metalava.testing.java
 import org.junit.Test
 
@@ -29,33 +30,33 @@ class SdkFileWriterTest : DriverTest() {
             expectedFail = DefaultLintErrorMessage,
             expectedIssues =
                 """
-                src/android/telephony/SubscriptionManager.java:11: error: Field 'ACTION_DEFAULT_SUBSCRIPTION_CHANGED' is missing @BroadcastBehavior [BroadcastBehavior]
+                    src/android/telephony/SubscriptionManager.java:11: error: Field 'ACTION_DEFAULT_SUBSCRIPTION_CHANGED' is missing @BroadcastBehavior [BroadcastBehavior]
                 """,
             sourceFiles =
                 arrayOf(
                     java(
                         """
-                package android.telephony;
+                            package android.telephony;
 
-                import android.annotation.SdkConstant;
-                import android.annotation.SdkConstant.SdkConstantType;
+                            import android.annotation.SdkConstant;
+                            import android.annotation.SdkConstant.SdkConstantType;
 
-                public class SubscriptionManager {
-                    /**
-                     * Broadcast Action: The default subscription has changed.
-                     */
-                    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
-                    public static final String ACTION_DEFAULT_SUBSCRIPTION_CHANGED
-                            = "android.telephony.action.DEFAULT_SUBSCRIPTION_CHANGED";
-                }
-            """
+                            public class SubscriptionManager {
+                                /**
+                                 * Broadcast Action: The default subscription has changed.
+                                 */
+                                @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+                                public static final String ACTION_DEFAULT_SUBSCRIPTION_CHANGED
+                                        = "android.telephony.action.DEFAULT_SUBSCRIPTION_CHANGED";
+                            }
+                        """
                     ),
-                    sdkConstantSource
+                    sdkConstantSource,
                 ),
             sdkBroadcastActions =
                 """
-            android.telephony.action.DEFAULT_SUBSCRIPTION_CHANGED
-            """
+                    android.telephony.action.DEFAULT_SUBSCRIPTION_CHANGED
+                """,
         )
     }
 
@@ -66,22 +67,167 @@ class SdkFileWriterTest : DriverTest() {
                 arrayOf(
                     java(
                         """
-                package android.content;
+                            package android.content;
+
+                            import android.annotation.SdkConstant;
+                            import android.annotation.SdkConstant.SdkConstantType;
+
+                            public class Intent {
+                                @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+                                public static final String ACTION_MAIN = "android.intent.action.MAIN";
+                            }
+                        """
+                    ),
+                    sdkConstantSource,
+                ),
+            sdkActivityActions =
+                """
+                    android.intent.action.MAIN
+                """,
+        )
+    }
+
+    @Test
+    fun `Test generating activity actions - indirect`() {
+        check(
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package android.content;
+
+                            import android.annotation.SdkConstant;
+                            import android.annotation.SdkConstant.SdkConstantType;
+
+                            public class Intent {
+                                // A constant used below to show that it can access the value
+                                // even if it is defined in another constant field.
+                                private static final String CONSTANT = "android.intent.action.MAIN";
+
+                                @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+                                public static final String ACTION_MAIN = CONSTANT;
+                            }
+                        """
+                    ),
+                    sdkConstantSource,
+                ),
+            sdkActivityActions =
+                """
+                    android.intent.action.MAIN
+                """,
+        )
+    }
+
+    @Test
+    fun `Test generating activity actions - duplicate`() {
+        check(
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package android.content;
+
+                            import android.annotation.SdkConstant;
+                            import android.annotation.SdkConstant.SdkConstantType;
+
+                            public class Intent {
+                                @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+                                public static final String ACTION_MAIN = "android.intent.action.MAIN";
+
+                                // Duplicate using the same constant.
+                                @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+                                public static final String ACTION_MAIN2 = ACTION_MAIN;
+                            }
+                        """
+                    ),
+                    sdkConstantSource,
+                ),
+            sdkActivityActions =
+                """
+                    android.intent.action.MAIN
+                    android.intent.action.MAIN
+                """,
+        )
+    }
+
+    @Test
+    fun `Test generating service actions`() {
+        check(
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+
+                            import android.annotation.SdkConstant;
+                            import android.annotation.SdkConstant.SdkConstantType;
+
+                            public class Foo {
+                                @SdkConstant(SdkConstantType.SERVICE_ACTION)
+                                public static final String SERVICE_TEST = "android.service.Test";
+                            }
+                        """
+                    ),
+                    sdkConstantSource,
+                ),
+            sdkServiceActions =
+                """
+                    android.service.Test
+                """,
+        )
+    }
+
+    @Test
+    fun `Test generating intent categories`() {
+        check(
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
 
-                import android.annotation.SdkConstant;
-                import android.annotation.SdkConstant.SdkConstantType;
+                            import android.annotation.SdkConstant;
+                            import android.annotation.SdkConstant.SdkConstantType;
 
-                public class Intent {
-                    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
-                    public static final String ACTION_MAIN = "android.intent.action.MAIN";
-                }
+                            public class Foo {
+                                @SdkConstant(SdkConstantType.INTENT_CATEGORY)
+                                public static final String INTENT_CATEGORY_TEST = "android.intent.category.TEST";
+                            }
+                        """
+                    ),
+                    sdkConstantSource,
+                ),
+            sdkCategories =
                 """
+                    android.intent.category.TEST
+                """,
+        )
+    }
+
+    @Test
+    fun `Test generating features`() {
+        check(
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+
+                            import android.annotation.SdkConstant;
+                            import android.annotation.SdkConstant.SdkConstantType;
+
+                            public class Foo {
+                                @SdkConstant(SdkConstantType.FEATURE)
+                                public static final String FEATURE_TES = "android.test.feature";
+                            }
+                        """
                     ),
-                    sdkConstantSource
+                    sdkConstantSource,
                 ),
-            sdkActivityActions = """
-            android.intent.action.MAIN
-            """
+            sdkFeatures =
+                """
+                    android.test.feature
+                """,
         )
     }
 
@@ -92,26 +238,26 @@ class SdkFileWriterTest : DriverTest() {
                 arrayOf(
                     java(
                         """
-                package android.widget;
+                            package android.widget;
 
-                import android.content.Context;
-                import android.annotation.Widget;
+                            import android.content.Context;
+                            import android.annotation.Widget;
 
-                @Widget
-                public class MyButton extends android.view.View {
-                    public MyButton(Context context) {
-                        super(context, null);
-                    }
-                }
-            """
+                            @Widget
+                            public class MyButton extends android.view.View {
+                                public MyButton(Context context) {
+                                    super(context, null);
+                                }
+                            }
+                        """
                     ),
-                    widgetSource
+                    widgetSource,
                 ),
             sdkWidgets =
                 """
-            Wandroid.view.View java.lang.Object
-            Wandroid.widget.MyButton android.view.View java.lang.Object
-            """
+                    Wandroid.view.View java.lang.Object
+                    Wandroid.widget.MyButton android.view.View java.lang.Object
+                """,
         )
     }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/ShowAnnotationTest.kt b/metalava/src/test/java/com/android/tools/metalava/ShowAnnotationTest.kt
index 2dc036ab0..b9f5d1cb7 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ShowAnnotationTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ShowAnnotationTest.kt
@@ -31,7 +31,7 @@ class ShowAnnotationTest : DriverTest() {
     @Test
     fun `Basic showAnnotation test`() {
         check(
-            includeSystemApiAnnotations = true,
+            includeSystemApiAnnotations = SystemApiType.PRIVILEGED_APPS,
             expectedIssues =
                 "src/test/pkg/Foo.java:18: error: @SystemApi APIs must also be marked @hide: method test.pkg.Foo.method4() [UnhiddenSystemApi]",
             expectedFail = DefaultLintErrorMessage,
@@ -85,7 +85,7 @@ class ShowAnnotationTest : DriverTest() {
     @Test
     fun `Basic showAnnotation with showUnannotated test`() {
         check(
-            includeSystemApiAnnotations = true,
+            includeSystemApiAnnotations = SystemApiType.PRIVILEGED_APPS,
             showUnannotated = true,
             expectedIssues =
                 "src/test/pkg/Foo.java:18: error: @SystemApi APIs must also be marked @hide: method test.pkg.Foo.method4() [UnhiddenSystemApi]",
@@ -147,7 +147,7 @@ class ShowAnnotationTest : DriverTest() {
     @Test
     fun `Check @TestApi handling`() {
         check(
-            includeSystemApiAnnotations = true,
+            includeSystemApiAnnotations = SystemApiType.TEST,
             sourceFiles =
                 arrayOf(
                     java(
@@ -182,11 +182,6 @@ class ShowAnnotationTest : DriverTest() {
                     ),
                     testApiSource,
                 ),
-            extraArguments =
-                arrayOf(
-                    ARG_SHOW_ANNOTATION,
-                    "android.annotation.TestApi",
-                ),
             api =
                 """
                 package test.pkg {
@@ -270,12 +265,7 @@ class ShowAnnotationTest : DriverTest() {
                 """
             """
                     .trimIndent(),
-            includeSystemApiAnnotations = true,
-            extraArguments =
-                arrayOf(
-                    ARG_SHOW_ANNOTATION,
-                    "android.annotation.TestApi",
-                )
+            includeSystemApiAnnotations = SystemApiType.TEST,
         )
     }
 
@@ -380,9 +370,9 @@ class ShowAnnotationTest : DriverTest() {
             showAnnotations = arrayOf("android.annotation.SystemApi"),
             expectedIssues =
                 """
-                    src/test/pkg/Class1.java:8: error: Attempting to unhide method test.pkg.Class1.method1(), but surrounding class test.pkg.Class1 is hidden and should also be annotated with @android.annotation.SystemApi(client=android.annotation.SystemApi.Client.PRIVILEGED_APPS) [ShowingMemberInHiddenClass]
-                    src/test/pkg/Class1.java:12: error: Attempting to unhide class test.pkg.Class1.InnerClass1, but surrounding class test.pkg.Class1 is hidden and should also be annotated with @android.annotation.SystemApi(client=android.annotation.SystemApi.Client.PRIVILEGED_APPS) [ShowingMemberInHiddenClass]
-                    src/test/pkg/Class2.java:11: error: Attempting to unhide method test.pkg.Class2.InnerClass2.method2(), but surrounding class test.pkg.Class2.InnerClass2 is hidden and should also be annotated with @android.annotation.SystemApi(client=android.annotation.SystemApi.Client.PRIVILEGED_APPS) [ShowingMemberInHiddenClass]
+                    src/test/pkg/Class1.java:8: error: Attempting to unhide method test.pkg.Class1.method1(), but surrounding class test.pkg.Class1 is hidden and should also be annotated with @android.annotation.SystemApi [ShowingMemberInHiddenClass]
+                    src/test/pkg/Class1.java:12: error: Attempting to unhide class test.pkg.Class1.InnerClass1, but surrounding class test.pkg.Class1 is hidden and should also be annotated with @android.annotation.SystemApi [ShowingMemberInHiddenClass]
+                    src/test/pkg/Class2.java:11: error: Attempting to unhide method test.pkg.Class2.InnerClass2.method2(), but surrounding class test.pkg.Class2.InnerClass2 is hidden and should also be annotated with @android.annotation.SystemApi [ShowingMemberInHiddenClass]
                 """,
             expectedFail = DefaultLintErrorMessage,
         )
@@ -777,7 +767,8 @@ class ShowAnnotationTest : DriverTest() {
                     systemApiSource
                 ),
             showAnnotations = arrayOf("android.annotation.SystemApi"),
-            expectedIssues = """
+            expectedIssues =
+                """
                 """,
             api =
                 """
diff --git a/metalava/src/test/java/com/android/tools/metalava/SystemServiceCheckTest.kt b/metalava/src/test/java/com/android/tools/metalava/SystemServiceCheckTest.kt
index b9c1d53a0..50eb293a5 100644
--- a/metalava/src/test/java/com/android/tools/metalava/SystemServiceCheckTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/SystemServiceCheckTest.kt
@@ -17,6 +17,7 @@
 package com.android.tools.metalava
 
 import com.android.tools.metalava.lint.DefaultLintErrorMessage
+import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
 import org.junit.Test
 
@@ -25,14 +26,16 @@ class SystemServiceCheckTest : DriverTest() {
     fun `SystemService OK, loaded from signature file`() {
         check(
             expectedIssues = "", // OK
-            includeSystemApiAnnotations = true,
+            // TODO(b/412743564): Use includeSystemApiAnnotations = SystemApiType.PRIVILEGED_APPS
+            //   instead of the following.
+            extraArguments = arrayOf(ARG_SHOW_ANNOTATION, ANDROID_SYSTEM_SERVICE_CHECK),
             sourceFiles =
                 arrayOf(
                     java(
                         """
                     package test.pkg;
                     import android.annotation.RequiresPermission;
-                    @android.annotation.SystemService
+                    @android.annotation.SystemService("Myservice")
                     public class MyTest2 {
                         @RequiresPermission(anyOf={"foo.bar.PERMISSION1","foo.bar.PERMISSION2"})
                         public int myMethod1() { }
@@ -40,7 +43,7 @@ class SystemServiceCheckTest : DriverTest() {
                     """
                     ),
                     systemServiceSource,
-                    requiresPermissionSource
+                    requiresPermissionSource,
                 ),
             manifest =
                 """<?xml version="1.0" encoding="UTF-8"?>
@@ -63,14 +66,16 @@ class SystemServiceCheckTest : DriverTest() {
     fun `SystemService OK, loaded from source`() {
         check(
             expectedIssues = "", // OK
-            includeSystemApiAnnotations = true,
+            // TODO(b/412743564): Use includeSystemApiAnnotations = SystemApiType.PRIVILEGED_APPS
+            //   instead of the following.
+            extraArguments = arrayOf(ARG_SHOW_ANNOTATION, ANDROID_SYSTEM_SERVICE_CHECK),
             sourceFiles =
                 arrayOf(
                     java(
                         """
                     package test.pkg;
 
-                    @android.annotation.SystemService
+                    @android.annotation.SystemService("Myservice")
                     public class MyTest2 {
                         @android.annotation.RequiresPermission(anyOf={"foo.bar.PERMISSION1","foo.bar.PERMISSION2"})
                         public void myMethod1() {
@@ -78,7 +83,8 @@ class SystemServiceCheckTest : DriverTest() {
                     }
                     """
                     ),
-                    systemServiceSource
+                    systemServiceSource,
+                    requiresPermissionSource,
                 ),
             manifest =
                 """<?xml version="1.0" encoding="UTF-8"?>
@@ -103,20 +109,23 @@ class SystemServiceCheckTest : DriverTest() {
             expectedFail = DefaultLintErrorMessage,
             expectedIssues =
                 "src/test/pkg/MyTest1.java:4: error: Method 'myMethod2' must be protected with a system permission. [RequiresPermission]",
-            includeSystemApiAnnotations = true,
+            // TODO(b/412743564): Use includeSystemApiAnnotations = SystemApiType.PRIVILEGED_APPS
+            //   instead of the following.
+            extraArguments = arrayOf(ARG_SHOW_ANNOTATION, ANDROID_SYSTEM_SERVICE_CHECK),
             sourceFiles =
                 arrayOf(
                     java(
                         """
                     package test.pkg;
-                    @android.annotation.SystemService
+                    @android.annotation.SystemService("Myservice")
                     public class MyTest1 {
                         public int myMethod2() { }
                     }
                     """
                     ),
                     systemServiceSource,
-                    requiresPermissionSource
+                    requiresPermissionSource,
+                    KnownSourceFiles.systemApiSource,
                 ),
             manifest =
                 """<?xml version="1.0" encoding="UTF-8"?>
@@ -129,14 +138,16 @@ class SystemServiceCheckTest : DriverTest() {
     fun `Check SystemService -- can miss a permission with anyOf`() {
         check(
             expectedIssues = "",
-            includeSystemApiAnnotations = true,
+            // TODO(b/412743564): Use includeSystemApiAnnotations = SystemApiType.PRIVILEGED_APPS
+            //   instead of the following.
+            extraArguments = arrayOf(ARG_SHOW_ANNOTATION, ANDROID_SYSTEM_SERVICE_CHECK),
             sourceFiles =
                 arrayOf(
                     java(
                         """
                     package test.pkg;
                     import android.annotation.RequiresPermission;
-                    @android.annotation.SystemService
+                    @android.annotation.SystemService("myservice")
                     public class MyTest2 {
                         @RequiresPermission(anyOf={"foo.bar.PERMISSION1","foo.bar.PERMISSION2"})
                         public int myMethod1() { }
@@ -144,7 +155,7 @@ class SystemServiceCheckTest : DriverTest() {
                     """
                     ),
                     systemServiceSource,
-                    requiresPermissionSource
+                    requiresPermissionSource,
                 ),
             manifest =
                 """<?xml version="1.0" encoding="UTF-8"?>
@@ -168,14 +179,16 @@ class SystemServiceCheckTest : DriverTest() {
                 src/test/pkg/MyTest2.java:6: error: Method 'myMethod1' must be protected with a system permission. [RequiresPermission]
                 src/test/pkg/MyTest2.java:6: error: None of the permissions foo.bar.PERMISSION1, foo.bar.PERMISSION2 are defined by manifest TESTROOT/manifest.xml. [RequiresPermission]
                 """,
-            includeSystemApiAnnotations = true,
+            // TODO(b/412743564): Use includeSystemApiAnnotations = SystemApiType.PRIVILEGED_APPS
+            //   instead of the following.
+            extraArguments = arrayOf(ARG_SHOW_ANNOTATION, ANDROID_SYSTEM_SERVICE_CHECK),
             sourceFiles =
                 arrayOf(
                     java(
                         """
                     package test.pkg;
                     import android.annotation.RequiresPermission;
-                    @android.annotation.SystemService
+                    @android.annotation.SystemService("Myservice")
                     public class MyTest2 {
                         @RequiresPermission(anyOf={"foo.bar.PERMISSION1","foo.bar.PERMISSION2"})
                         public int myMethod1() { }
@@ -183,7 +196,8 @@ class SystemServiceCheckTest : DriverTest() {
                     """
                     ),
                     systemServiceSource,
-                    requiresPermissionSource
+                    requiresPermissionSource,
+                    KnownSourceFiles.systemApiSource,
                 ),
             manifest =
                 """<?xml version="1.0" encoding="UTF-8"?>
@@ -198,14 +212,16 @@ class SystemServiceCheckTest : DriverTest() {
             expectedFail = DefaultLintErrorMessage,
             expectedIssues =
                 "src/test/pkg/MyTest2.java:6: error: Permission 'foo.bar.PERMISSION2' is not defined by manifest TESTROOT/manifest.xml. [RequiresPermission]",
-            includeSystemApiAnnotations = true,
+            // TODO(b/412743564): Use includeSystemApiAnnotations = SystemApiType.PRIVILEGED_APPS
+            //   instead of the following.
+            extraArguments = arrayOf(ARG_SHOW_ANNOTATION, ANDROID_SYSTEM_SERVICE_CHECK),
             sourceFiles =
                 arrayOf(
                     java(
                         """
                         package test.pkg;
                         import android.annotation.RequiresPermission;
-                        @android.annotation.SystemService
+                        @android.annotation.SystemService("Myservice")
                         public class MyTest2 {
                             @RequiresPermission(allOf={"foo.bar.PERMISSION1","foo.bar.PERMISSION2"})
                             public int test() { }
@@ -213,7 +229,8 @@ class SystemServiceCheckTest : DriverTest() {
                         """
                     ),
                     systemServiceSource,
-                    requiresPermissionSource
+                    requiresPermissionSource,
+                    KnownSourceFiles.systemApiSource,
                 ),
             manifest =
                 """<?xml version="1.0" encoding="UTF-8"?>
@@ -236,7 +253,9 @@ class SystemServiceCheckTest : DriverTest() {
                 "src/test/pkg/MyTest2.java:7: error: Method 'test' must be protected with a system " +
                     "permission; it currently allows non-system callers holding [foo.bar.PERMISSION1, " +
                     "foo.bar.PERMISSION2] [RequiresPermission]",
-            includeSystemApiAnnotations = true,
+            // TODO(b/412743564): Use includeSystemApiAnnotations = SystemApiType.PRIVILEGED_APPS
+            //   instead of the following.
+            extraArguments = arrayOf(ARG_SHOW_ANNOTATION, ANDROID_SYSTEM_SERVICE_CHECK),
             sourceFiles =
                 arrayOf(
                     java(
@@ -244,7 +263,7 @@ class SystemServiceCheckTest : DriverTest() {
                     package test.pkg;
                     import android.annotation.RequiresPermission;
                     @SuppressWarnings("WeakerAccess")
-                    @android.annotation.SystemService
+                    @android.annotation.SystemService("Myservice")
                     public class MyTest2 {
                         @RequiresPermission(anyOf={"foo.bar.PERMISSION1","foo.bar.PERMISSION2"})
                         public int test() { }
@@ -252,7 +271,8 @@ class SystemServiceCheckTest : DriverTest() {
                     """
                     ),
                     systemServiceSource,
-                    requiresPermissionSource
+                    requiresPermissionSource,
+                    KnownSourceFiles.systemApiSource,
                 ),
             manifest =
                 """<?xml version="1.0" encoding="UTF-8"?>
@@ -277,26 +297,31 @@ class SystemServiceCheckTest : DriverTest() {
             expectedFail = DefaultLintErrorMessage,
             expectedIssues =
                 """
-                src/test/pkg/MyTest2.java:6: error: Method 'test' must be protected with a system permission. [RequiresPermission]
-                src/test/pkg/MyTest2.java:6: error: Permission 'Manifest.permission.MY_PERMISSION' is not defined by manifest TESTROOT/manifest.xml. [RequiresPermission]
-                src/test/pkg/MyTest2.java:6: error: Permission 'Manifest.permission.MY_PERMISSION2' is not defined by manifest TESTROOT/manifest.xml. [RequiresPermission]
+                src/test/pkg/MyTest2.java:8: error: Method 'test' must be protected with a system permission. [RequiresPermission]
+                src/test/pkg/MyTest2.java:8: error: Permission 'android.permission.MY_PERMISSION' is not defined by manifest TESTROOT/manifest.xml. [RequiresPermission]
+                src/test/pkg/MyTest2.java:8: error: Permission 'android.permission.MY_PERMISSION2' is not defined by manifest TESTROOT/manifest.xml. [RequiresPermission]
                 """,
-            includeSystemApiAnnotations = true,
+            // TODO(b/412743564): Use includeSystemApiAnnotations = SystemApiType.PRIVILEGED_APPS
+            //   instead of the following.
+            extraArguments = arrayOf(ARG_SHOW_ANNOTATION, ANDROID_SYSTEM_SERVICE_CHECK),
             sourceFiles =
                 arrayOf(
                     java(
                         """
                     package test.pkg;
                     import android.annotation.RequiresPermission;
-                    @android.annotation.SystemService
+                    @android.annotation.SystemService("Myservice")
                     public class MyTest2 {
-                        @RequiresPermission(allOf={Manifest.permission.MY_PERMISSION,Manifest.permission.MY_PERMISSION2})
+                        public static final String MY_PERMISSION = "android.permission.MY_PERMISSION";
+                        public static final String MY_PERMISSION2 = "android.permission.MY_PERMISSION2";
+                        @RequiresPermission(allOf={MY_PERMISSION, MY_PERMISSION2})
                         public int test() { }
                     }
                     """
                     ),
                     systemServiceSource,
-                    requiresPermissionSource
+                    requiresPermissionSource,
+                    KnownSourceFiles.systemApiSource,
                 ),
             manifest =
                 """<?xml version="1.0" encoding="UTF-8"?>
@@ -315,7 +340,9 @@ class SystemServiceCheckTest : DriverTest() {
                 src/test/pkg/MyTest2.java:7: error: Method 'test' must be protected with a system permission. [RequiresPermission]
                 src/test/pkg/MyTest2.java:7: error: None of the permissions foo.bar.PERMISSION1, foo.bar.PERMISSION2 are defined by manifest TESTROOT/manifest.xml. [RequiresPermission]
                 """,
-            includeSystemApiAnnotations = true,
+            // TODO(b/412743564): Use includeSystemApiAnnotations = SystemApiType.PRIVILEGED_APPS
+            //   instead of the following.
+            extraArguments = arrayOf(ARG_SHOW_ANNOTATION, ANDROID_SYSTEM_SERVICE_CHECK),
             sourceFiles =
                 arrayOf(
                     java(
@@ -323,7 +350,7 @@ class SystemServiceCheckTest : DriverTest() {
                     package test.pkg;
                     import android.annotation.RequiresPermission;
                     @SuppressWarnings("WeakerAccess")
-                    @android.annotation.SystemService
+                    @android.annotation.SystemService("Myservice")
                     public class MyTest2 {
                         @RequiresPermission(anyOf={"foo.bar.PERMISSION1","foo.bar.PERMISSION2"})
                         public int test() { }
@@ -331,7 +358,8 @@ class SystemServiceCheckTest : DriverTest() {
                     """
                     ),
                     systemServiceSource,
-                    requiresPermissionSource
+                    requiresPermissionSource,
+                    KnownSourceFiles.systemApiSource,
                 ),
             manifest =
                 """<?xml version="1.0" encoding="UTF-8"?>
@@ -344,14 +372,16 @@ class SystemServiceCheckTest : DriverTest() {
     fun `Warning suppressed via annotation`() {
         check(
             expectedIssues = "", // OK (suppressed)
-            includeSystemApiAnnotations = true,
+            // TODO(b/412743564): Use includeSystemApiAnnotations = SystemApiType.PRIVILEGED_APPS
+            //   instead of the following.
+            extraArguments = arrayOf(ARG_SHOW_ANNOTATION, ANDROID_SYSTEM_SERVICE_CHECK),
             sourceFiles =
                 arrayOf(
                     java(
                         """
                     package test.pkg;
 
-                    @android.annotation.SystemService
+                    @android.annotation.SystemService("Myservice")
                     public class MyTest1 {
                         @android.annotation.SuppressLint({"RemovedField","RequiresPermission"})
                         @android.annotation.RequiresPermission(anyOf={"foo.bar.PERMISSION1","foo.bar.PERMISSION2"})
@@ -360,7 +390,8 @@ class SystemServiceCheckTest : DriverTest() {
                     }
                     """
                     ),
-                    systemServiceSource
+                    systemServiceSource,
+                    requiresPermissionSource,
                 ),
             manifest =
                 """<?xml version="1.0" encoding="UTF-8"?>
diff --git a/metalava/src/test/java/com/android/tools/metalava/UastTestBase.kt b/metalava/src/test/java/com/android/tools/metalava/UastTestBase.kt
index 5d203e03e..4d3ba7aed 100644
--- a/metalava/src/test/java/com/android/tools/metalava/UastTestBase.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/UastTestBase.kt
@@ -16,15 +16,18 @@
 
 package com.android.tools.metalava
 
+import com.android.tools.lint.checks.infrastructure.TestFiles.base64gzip
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.FilterAction.EXCLUDE
 import com.android.tools.metalava.model.testing.FilterByProvider
 import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.model.text.FileFormat
+import com.android.tools.metalava.model.text.stripBlankLines
 import com.android.tools.metalava.testing.createAndroidModuleDescription
 import com.android.tools.metalava.testing.createCommonModuleDescription
 import com.android.tools.metalava.testing.createModuleDescription
 import com.android.tools.metalava.testing.createProjectDescription
+import com.android.tools.metalava.testing.defaultJvmPlatforms
 import com.android.tools.metalava.testing.kotlin
 import org.junit.Test
 
@@ -215,7 +218,7 @@ abstract class UastTestBase : DriverTest() {
                     ctor public Foo(@test.pkg.MyAnnotation int p1, String p2);
                     method public int component1();
                     method public String component2();
-                    method public test.pkg.Foo copy(@test.pkg.MyAnnotation int p1, String p2);
+                    method public test.pkg.Foo copy(optional @test.pkg.MyAnnotation int p1, optional String p2);
                     method public int getP1();
                     method public String getP2();
                     property @test.pkg.MyAnnotation public int p1;
@@ -1815,7 +1818,7 @@ abstract class UastTestBase : DriverTest() {
     }
 
     @Test
-    fun `default parameter value from common, with android=false for common`() {
+    fun `default parameter value from common, without jvm platform set for common`() {
         val commonSource =
             kotlin(
                 "commonMain/src/test/pkg/Foo.kt",
@@ -1856,14 +1859,8 @@ abstract class UastTestBase : DriverTest() {
     }
 
     @Test
-    fun `default parameter value from common, with android=true for common`() {
-        // b/322156458
-        val modifier =
-            if (isK2) {
-                ""
-            } else {
-                "optional "
-            }
+    fun `default parameter value from common, with jvm platform set for common`() {
+        // Verifies that expect/actual linking works when only the JVM platform is used.
         val commonSource =
             kotlin(
                 "commonMain/src/test/pkg/Foo.kt",
@@ -1891,9 +1888,10 @@ abstract class UastTestBase : DriverTest() {
                     createAndroidModuleDescription(arrayOf(androidSource)),
                     createModuleDescription(
                         moduleName = "commonMain",
-                        android = true,
+                        android = false,
+                        kotlinPlatforms = defaultJvmPlatforms,
                         sourceFiles = arrayOf(commonSource),
-                        dependsOn = emptyList()
+                        dependsOn = emptyList(),
                     ),
                 ),
             api =
@@ -1901,7 +1899,7 @@ abstract class UastTestBase : DriverTest() {
                     package test.pkg {
                       public final class Foo {
                         ctor public Foo();
-                        method public int foo(${modifier}int i);
+                        method public int foo(optional int i);
                       }
                     }
                 """
@@ -1940,12 +1938,13 @@ abstract class UastTestBase : DriverTest() {
 
     @Test
     fun `Data class with value class type`() {
-        // b/388244267
-        val copySuffix =
+        // For K2, no UElement created for a method using a value class type (b/388244267).
+        // This will be resolved through b/406833486.
+        val copyEntry =
             if (isK2) {
                 ""
             } else {
-                "-Vxmw0xk"
+                "method public test.pkg.IntValueData copy-Vxmw0xk(int intValue);"
             }
         check(
             sourceFiles =
@@ -1956,7 +1955,7 @@ abstract class UastTestBase : DriverTest() {
                         @JvmInline
                         value class IntValue(val value: Int)
                         data class IntValueData(private val intValue: IntValue)
-                    """
+                        """
                     )
                 ),
             api =
@@ -1969,10 +1968,12 @@ abstract class UastTestBase : DriverTest() {
                   }
                   public final class IntValueData {
                     ctor public IntValueData(int intValue);
-                    method public test.pkg.IntValueData copy$copySuffix(int intValue);
+                    $copyEntry
                   }
                 }
-            """
+                """
+                    // The copyEntry might be blank, remove it if so.
+                    .stripBlankLines()
         )
     }
 
@@ -2052,4 +2053,371 @@ abstract class UastTestBase : DriverTest() {
                 """
         )
     }
+
+    @Test
+    fun `Data class value with type argument`() {
+        // Added to test that the nullability of the type argument in the copy method is correct.
+        // A K2 update to the source psi for the copy method changed how the kotlin context for the
+        // method parameters is computed.
+        check(
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                        package test.pkg
+                        data class Foo<T: Any>(val items: List<T>)
+                        """
+                    )
+                ),
+            api =
+                """
+                // Signature format: 5.0
+                package test.pkg {
+                  public final class Foo<T> {
+                    ctor public Foo(java.util.List<? extends T> items);
+                    method public java.util.List<T> component1();
+                    method public test.pkg.Foo<T> copy(optional java.util.List<? extends T> items);
+                    method public java.util.List<T> getItems();
+                    property public java.util.List<T> items;
+                  }
+                }
+                """
+        )
+    }
+
+    @Test
+    fun `Annotations on property of value class type`() {
+        // b/417181888 -- the accessor representation depends on if the type is specified in source
+        val extraAnno = if (isK2) "@test.pkg.Anno " else ""
+        check(
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                        package test.pkg
+                        annotation class Anno
+                        """
+                    ),
+                    kotlin(
+                        """
+                        package test.pkg
+                        @JvmInline value class IntValue(val value: Int) {
+                            companion object {
+                                @Anno val withValueClassTypeSpecified: IntValue = IntValue(0)
+                                @Anno val withValueClassTypeUnspecified = IntValue(0)
+                                @Anno val withNonValueClassTypeSpecified: Int = 0
+                            }
+                        }
+                        """
+                    ),
+                ),
+            api =
+                """
+                // Signature format: 5.0
+                package test.pkg {
+                  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) public @interface Anno {
+                  }
+                  @kotlin.jvm.JvmInline public final value class IntValue {
+                    ctor public IntValue(int value);
+                    method public int getValue();
+                    property public int value;
+                    field public static final test.pkg.IntValue.Companion Companion;
+                  }
+                  public static final class IntValue.Companion {
+                    method public int getWithNonValueClassTypeSpecified();
+                    method ${extraAnno}public int getWithValueClassTypeSpecified();
+                    method public int getWithValueClassTypeUnspecified();
+                    property @test.pkg.Anno public int withNonValueClassTypeSpecified;
+                    property @test.pkg.Anno public int withValueClassTypeSpecified;
+                    property @test.pkg.Anno public int withValueClassTypeUnspecified;
+                  }
+                }
+                """
+        )
+    }
+
+    @Test
+    fun `Inherited internal constructor property-parameter`() {
+        // b/417477089 -- the internal property and accessor should not be present
+        val internalAccessorName = if (isK2) "getInternalCtorVal\$src" else "getInternalCtorVal"
+        check(
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                        package test.pkg
+                        open class ParentClass(internal open val internalCtorVal: Int) {
+                            internal open fun internalFun() = Unit
+                            internal open val internalVal: Int = 0
+                        }
+                        class ChildClass(override val internalCtorVal: Int): ParentClass(internalCtorVal) {
+                            override fun internalFun() = Unit
+                            override val internalVal: Int = 0
+                        }
+                        """
+                    )
+                ),
+            api =
+                """
+                // Signature format: 5.0
+                package test.pkg {
+                  public final class ChildClass extends test.pkg.ParentClass {
+                    ctor public ChildClass(int internalCtorVal);
+                    method public int ${internalAccessorName}();
+                    property public int internalCtorVal;
+                  }
+                  public class ParentClass {
+                    ctor public ParentClass(int internalCtorVal);
+                  }
+                }
+                """
+        )
+    }
+
+    @Test
+    fun `Annotation on generated no-args constructor`() {
+        // b/417687416 the annotation is dropped from the no-args constructor with K2
+        val noArgsAnnotation = if (isK2) "" else "@test.pkg.Anno "
+        check(
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                        package test.pkg
+                        annotation class Anno
+                        class Foo @Anno constructor(i: Int = 0, s: String = "")
+                        """
+                    )
+                ),
+            api =
+                """
+                // Signature format: 5.0
+                package test.pkg {
+                  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) public @interface Anno {
+                  }
+                  public final class Foo {
+                    ctor ${noArgsAnnotation}public Foo();
+                    ctor @test.pkg.Anno public Foo(optional int i, optional String s);
+                  }
+                }
+                """
+        )
+    }
+
+    @Test
+    fun `JvmMultifileClass with files in common and android`() {
+        // b/417699607 the android method is dropped from K2 tracking
+        val androidMethod = if (isK2) "" else "method public static void fooAndroid();"
+        val commonSource =
+            kotlin(
+                "commonMain/src/test/pkg/Foo.kt",
+                """
+                @file:JvmMultifileClass
+                @file:JvmName("Foo")
+                package test.pkg
+                fun fooCommon() = Unit
+                """
+            )
+        val androidSource =
+            kotlin(
+                "androidMain/src/test/pkg/Foo.android.kt",
+                """
+                @file:JvmMultifileClass
+                @file:JvmName("Foo")
+                package test.pkg
+                fun fooAndroid() = Unit
+                """
+            )
+        check(
+            sourceFiles = arrayOf(commonSource, androidSource),
+            projectDescription =
+                createProjectDescription(
+                    // Set the common module to only list the jvm platform, since it requires jvm
+                    // annotations.
+                    createModuleDescription(
+                        moduleName = "commonMain",
+                        android = false,
+                        kotlinPlatforms = defaultJvmPlatforms,
+                        sourceFiles = arrayOf(commonSource),
+                        dependsOn = emptyList(),
+                    ),
+                    createAndroidModuleDescription(arrayOf(androidSource)),
+                ),
+            api =
+                """
+                // Signature format: 5.0
+                package test.pkg {
+                  public final class Foo {
+                    $androidMethod
+                    method public static void fooCommon();
+                  }
+                }
+                """
+                    .stripBlankLines()
+        )
+    }
+
+    @Test
+    fun `Test mapped collections methods`() {
+        val maybeExtends = if (isK2) "" else "? extends "
+        check(
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                        package test.pkg
+                        class EmptyStringList: List<String> {
+                            override val size = 0
+                            override fun get(index: Int) = error("empty")
+                            override fun indexOf(element: String) = -1
+                            override fun contains(element: String) = false
+                            override fun containsAll(elements: Collection<String>) = false
+                            override fun isEmpty() = true
+                            override fun iterator() = error("empty")
+                            override fun listIterator() = error("empty")
+                            override fun listIterator(index: Int) = error("empty")
+                            override fun subList(fromIndex: Int, toIndex: Int) = this
+                            override fun lastIndexOf(element: String): Int = -1
+                        }
+                        """,
+                    )
+                ),
+            // Compiled from the source above with [generateBase64gzipFromKotlin]
+            compiledSourceJar =
+                base64gzip(
+                    "test.jar",
+                    // kotlinc version info: kotlinc-jvm 1.9.23 (JRE 17.0.6+10-b802.1)
+                    "" +
+                        "H4sIAAAAAAAA/4WWezgT+h/Hl8I4UrkU6cJGmsx9lZAc1xGWudTMnbmNjW1I" +
+                        "Uwfhl3KPcq3VInfFkvtxXdrILXJJLsWWmDCHuXR0/vj96jzPOb/P93k/3+f7" +
+                        "PN/v6/P5/vdCWOzeIwEAAoEAAEAO8GNJAPYALI1tDaBwKxNVSwMruIkx0lbF" +
+                        "0mT7NQCwbMlkXLSAqvTutYAqdTPfVNqoDWhOfApWMbdUhlv2koqqbBbNoUFK" +
+                        "5kzmKfvFbtXOTub0p6lPfACEhSCwXBxSrr3T4MxOEP/Y/thOiF4Eoire31vV" +
+                        "OABPvIokBvsGel/0JRBVPLBuBEKp/YaDDF1yG8M/kr4fk5IQRSENtInyud98" +
+                        "9l5e1mPa1O8AFmvog+2jg6BhBiN2oQ4DVseD+kPTTrMZAf2hvDWIPnV25d35" +
+                        "Lu293KStx+HB3iE01rOiyDVgyEL3GCd7I0tn48O3rbkPAKsJjshW2cLL4dcd" +
+                        "qNVfa6bGnfEBrehszSMOAh49M4M0S6hjH5P2ZfN1rTO+oD6zyP/uczTUoWAy" +
+                        "siC/YOa0crXn/WFuV/CgmtP70zSbFyXDMrXzni61VDul8K+pYbnuiOzq5N7m" +
+                        "ivIgGelLsZNH+18jpB5pt2qN+caaYcIgkWdrp1hGUZTWBt+zIrsJ82TF4o+w" +
+                        "905qzv3856ylTOsryHzwL0kGLbtQIIXYrcxNvJNEhvJjsz3Wb66sokKcQh2w" +
+                        "XWq5JZisjOKaWOMlL0YDGppuNtcZgG607Ruq6uODsA8FSq4ID6UHJVOQszMQ" +
+                        "KU8EmqGZNnkB8xK2KkQ+HPcy21pjxQs11HCBfCJxl65xW+yVAVxKpXuOS0C0" +
+                        "3B9eDdR7pH47tTb8SeV9V9P8dUyaU9QvGsVkh7u1hq7EY/y9ciWkYzXmzYuG" +
+                        "mZd0ZejARA15R8mTYvwM4lXPUamIaEpxvgZSSf0IcyB9Qfv2I6eJAwezPCb9" +
+                        "a3rtPQr4L3ydnjx5tjNZ2HsmkmTke0tpSi066mHNQX5QphAky+hWkepx1isr" +
+                        "UswQOEY3rQC0oc897EgrDR63LvBft3GAgxtRwWDUMzPpd+Ncr/5Ce6WM+c/t" +
+                        "68If7paUnWogiNCj16smqYVR/btADX7Dvo5D8abQSqKOE3DTHi+XuFzfaJNJ" +
+                        "vhzI9klVAEF2wxIqSjxHlU9TFXzO6XR57H5YieiDxRMHBhmD+eO2Ftdf17g/" +
+                        "J2VFLVBuKkYkOMk+7c9fB8hUc83hp8ImwNyQcntLN9gT00rcNaEK7IHqQ8dK" +
+                        "D40ka9sX3dHU5bIibjpuvgMyQKK4IEPKLRFCdStlykcb+yn+xXzb5TXUgo8O" +
+                        "AzmJFnrKSkAqbgfzQXSbn6SfFmKeQWseqxHRiwSHxU4PiknR1VWk6/3i5k6X" +
+                        "5JqMBIoh0TGPUrFO99yWgsviut8exUTN6q45+MThj0oPMAWiw4Vm918PXFp9" +
+                        "gLskH4O8PyNcLX7/K3oDtaxe0u5ZqF1Ki6nwe5Kh4TF6GPb8IkZ7j7gGPbkb" +
+                        "ahWr1cNcmgLJsQxmradLhMdl41qsyu5wetjAOtwL0kG9fk9yklutZdoHSpdQ" +
+                        "feLxtq8Rm8llXMQDnsZkY+KLOqeRL0sejQxrqXD/D+b3WExJmANYpbBemsLR" +
+                        "7Diuvg2ICMP2bEKjm3rVM+LpUnPvazUP3uM9eUnNZ99wQdu8LOmRojxjHN/X" +
+                        "Xr3Q8zsLNthE8v4VHiL/JMg3J3eevOZsawOubCjSkE2gn3jkl2PCnmqt68Oa" +
+                        "z4sRhGDqCEOiy8WUhfNZHDmn9A4rSnFRA1p0sfCKsWWwFlydpD/0B1e0isW9" +
+                        "9VailAtbzMdsvJWAe+JtI1riuNcshkSfHkWHf5p8v/wx6ldRUeLJS3YzkZmu" +
+                        "uujOfJlgbHSWDV272Aza6N2txmW8XYoPVPU7pZB7JrT4YXqG1ugEZ/vjBK2I" +
+                        "fdhLDxd4ONEAqTnqgheJy3aIxuUI0N5FPcP4Bb490RLIqzqF7fEuajIgNxeN" +
+                        "8G8ZRzcdWVnPQK22qJ9rz11RBXfoTX94YMtvKN+vCNW7YY274gzSCkkcM/1D" +
+                        "3yx5UTDcpJ16U79PcxLiejzcyPjSMnbXN/EIzplIMMX1czW1vVmTKtf7bktO" +
+                        "oExRn7SPvRHGeyyQKsoLSr1bwErDs9VqWhYVXcpdEEiL1UKCVvBNjSym7u/3" +
+                        "B3xQd5nDGDs+e56R5LGtTM9M/qppUKJcVQpmhBXoo4jP4esx2hhWQ9XsnYfr" +
+                        "ms5xhObFu1beTPPrw9/w4KnnsjSpA15mwhpG99I5HIKn7DXbWHeSPE0ENqNQ" +
+                        "rdOyJgoMtTN0qnsqV8sf8VlzpSM7X2vJAPlOLEp1vlSALGb1y3mVXDm4n3ve" +
+                        "cBAphJN/p9uGFH41b9HjwLf9s+WKLvVJbyLktV50Tu26MqY4vXb7/HnTNTOZ" +
+                        "+lms3nYFp4Qun5JDx05MjN8PM7C4btAkL5W0caduuXTblZlChLBCpJsArWFi" +
+                        "jZI0Al56+dqdL5IHhouTmnniLYn+154bttnlym22jH9dcWxjXFuaXg5TWPS4" +
+                        "RZ1Lghw7U7F5X2nVjuyWlBcBqWDdvjvr+SombB+KULe3xhKiVyirl3bd5T+J" +
+                        "IuOGlJo5M1KH0W6PR42ODuzVUzzd5fPWwSv6lyMO5fZtgB87Xm6Iyx57BNwG" +
+                        "5SkPxupKJytuoRrNQyfIMktmCeQI3EeJSDh2D//nGGvKYnq1awxddtLFmQac" +
+                        "QQg1jzriQ+PLeWvIRoJ6XmT5C4VF9C3+sraoyhDhanLRbdrIEWmqP5sGfTWJ" +
+                        "LiWFn3uK5ByuMXegg5EbXD3Tb18UfQl83xKsyUfKL4DyZdZmpl1B66Qxocaz" +
+                        "9b9x75xosgydf3WwUYcH0Oc97HyW91uZIG6ia4J4wyK54VM29yLC2WgZgMNV" +
+                        "at2VkGZRwGvFUjfimnpfws9xepq/sTVAVzeVkx7Mfv1lM9VorGvaYQ1Ggwk2" +
+                        "NdcxzrIe0ptx7S73oqn7bQUbRDtidD+6tjTD5QraliuiwaJ5oWps1w6D7maI" +
+                        "YMHRnHWp77owmmRdMy0IAFQd+jddkNnJf20lwM03UMUfR8T6BroE4DxJWC8P" +
+                        "V1dXzE72uFsJnES497gD/lIRLqi+QXznpdRfKrKLTwLwP/qPmvLdhX6ufzKj" +
+                        "v1N+nP7YT4Qb/1dw/s76cVqZn1hlwH/9PcKCX+D7td07a3RnFxb6fvoTwPLm" +
+                        "GvsJAAA="
+                ),
+            // The mapped collection APIs shouldn't be bytecode only, but it is better that they are
+            // tracked that way than not tracked at all.
+            api =
+                """
+                // Signature format: 5.0
+                package test.pkg {
+                  public final class EmptyStringList implements kotlin.jvm.internal.markers.KMappedMarker java.util.List<java.lang.String> {
+                    ctor public EmptyStringList();
+                    method @BytecodeOnly public void add(int, String!);
+                    method @BytecodeOnly public boolean add(String!);
+                    method @BytecodeOnly public boolean addAll(int, java.util.Collection<? extends java.lang.String!>!);
+                    method @BytecodeOnly public boolean addAll(java.util.Collection<? extends java.lang.String!>!);
+                    method @BytecodeOnly public void clear();
+                    method @BytecodeOnly public boolean contains(Object!);
+                    method public boolean contains(String element);
+                    method public boolean containsAll(java.util.Collection<${maybeExtends}java.lang.String> elements);
+                    method public Void get(int index);
+                    method public int getSize();
+                    method @BytecodeOnly public int indexOf(Object!);
+                    method public int indexOf(String element);
+                    method public boolean isEmpty();
+                    method public Void iterator();
+                    method @BytecodeOnly public int lastIndexOf(Object!);
+                    method public int lastIndexOf(String element);
+                    method public Void listIterator();
+                    method public Void listIterator(int index);
+                    method @BytecodeOnly public String! remove(int);
+                    method @BytecodeOnly public boolean remove(Object!);
+                    method @BytecodeOnly public boolean removeAll(java.util.Collection<? extends java.lang.Object!>!);
+                    method @BytecodeOnly public void replaceAll(java.util.function.UnaryOperator<java.lang.String!>!);
+                    method @BytecodeOnly public boolean retainAll(java.util.Collection<? extends java.lang.Object!>!);
+                    method @BytecodeOnly public String! set(int, String!);
+                    method @BytecodeOnly public int size();
+                    method @BytecodeOnly public void sort(java.util.Comparator<? super java.lang.String!>!);
+                    method public test.pkg.EmptyStringList subList(int fromIndex, int toIndex);
+                    method @BytecodeOnly public Object![]! toArray();
+                    method @BytecodeOnly public <T> T![]! toArray(T![]!);
+                    property public int size;
+                  }
+                }
+                """
+        )
+    }
+
+    @Test
+    fun `Inner class with different number of type parameters than outer class`() {
+        check(
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                        package test.pkg
+                        class Outer<T> {
+                            inner class Middle<K, V> {
+                                inner class Inner<A, B, C>
+                            }
+                        }
+                        """
+                    )
+                ),
+            api =
+                """
+                // Signature format: 5.0
+                package test.pkg {
+                  public final class Outer<T> {
+                    ctor public Outer();
+                  }
+                  public final class Outer.Middle<K, V> {
+                    ctor public Outer.Middle();
+                  }
+                  public final class Outer.Middle.Inner<A, B, C> {
+                    ctor public Outer.Middle.Inner();
+                  }
+                }
+                """
+        )
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiGeneratorTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiGeneratorTest.kt
index f109e91ff..b09705993 100644
--- a/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiGeneratorTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiGeneratorTest.kt
@@ -33,7 +33,6 @@ import com.android.tools.metalava.KnownConfigFiles
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import com.android.tools.metalava.testing.signature
-import com.android.tools.metalava.testing.xml
 import com.google.common.truth.Truth.assertThat
 import com.google.gson.GsonBuilder
 import com.google.gson.JsonElement
@@ -934,4 +933,120 @@ class ApiGeneratorTest : DriverTest() {
             """
         )
     }
+
+    @Test
+    fun `Test deprecating SDK extension API`() {
+        val root = buildFileStructure {
+            dir("39") {
+                signature(
+                    "api.txt",
+                    """
+                        // Signature format: 2.0
+                        package test.pkg {
+                          public class Foo {
+                          }
+                        }
+                    """
+                )
+            }
+            dir("40") {
+                signature(
+                    "api.txt",
+                    """
+                        // Signature format: 2.0
+                        package test.pkg {
+                          @Deprecated public class Foo {
+                          }
+                        }
+                    """
+                )
+            }
+            dir("extensions") {
+                dir("102") {
+                    signature(
+                        "module.txt",
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Foo {
+                              }
+                            }
+                        """
+                    )
+                }
+                dir("103") {
+                    signature(
+                        "module.txt",
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              @Deprecated public class Foo {
+                              }
+                            }
+                        """
+                    )
+                }
+            }
+        }
+
+        val sdkExtensionsInfoXml =
+            temporaryFolder.newFile("sdk-extensions-info.xml").apply {
+                writeText(
+                    """
+                        <?xml version="1.0" encoding="utf-8"?>
+                        <sdk-extensions-info>
+                        <sdk id="39" shortname="J-ext" name="J Extensions" reference="VersionCode.J"/>
+                        <sdk id="40" shortname="K-ext" name="K Extensions" reference="VersionCode.K"/>
+                        <symbol jar="module" pattern="*" sdks="J-ext,K-ext" />
+                        </sdk-extensions-info>
+                    """
+                        .trimIndent()
+                )
+            }
+
+        val apiVersionsXml = temporaryFolder.newFile("api-versions.xml")
+
+        check(
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            /**
+                             * @deprecated Deprecated
+                             */
+                            @Deprecated public class Foo {
+                                private Foo() {}
+                            }
+                        """
+                    ),
+                ),
+            extraArguments =
+                arrayOf(
+                    ARG_GENERATE_API_LEVELS,
+                    apiVersionsXml.path,
+                    ARG_SDK_INFO_FILE,
+                    sdkExtensionsInfoXml.path,
+                    ARG_API_VERSION_SIGNATURE_PATTERN,
+                    "$root/{version:major.minor?}/api.txt",
+                    ARG_API_VERSION_SIGNATURE_PATTERN,
+                    "$root/extensions/{version:extension}/{module}.txt",
+                    ARG_CURRENT_VERSION,
+                    "41",
+                    ARG_REMOVE_MISSING_CLASS_REFERENCES_IN_API_LEVELS,
+                ),
+        )
+
+        apiVersionsXml.checkApiVersionsXmlContent(
+            """
+                <?xml version="1.0" encoding="utf-8"?>
+                <api version="3" min="39">
+                    <sdk id="39" shortname="J-ext" name="J Extensions" reference="VersionCode.J"/>
+                    <sdk id="40" shortname="K-ext" name="K Extensions" reference="VersionCode.K"/>
+                    <class name="test/pkg/Foo" module="module" since="39" sdks="39:102,0:39" deprecated="40">
+                    </class>
+                </api>
+            """
+        )
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiToExtensionsMapTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiToExtensionsMapTest.kt
index 540146f69..1c419b74f 100644
--- a/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiToExtensionsMapTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiToExtensionsMapTest.kt
@@ -94,7 +94,12 @@ class ApiToExtensionsMapTest {
         val sdk1 = sdkVersion(1)
         val sdk2 = sdkVersion(2)
 
-        val clazz = ApiClass("com/foo/Bar").apply { update(sdk1, false) }
+        val clazz =
+            ApiClass(
+                    "com/foo/Bar",
+                    isEnum = false,
+                )
+                .apply { update(sdk1, deprecated = false) }
         val method = ApiElement("method(Ljava.lang.String;I)V").apply { update(sdk2, false) }
         assertEquals(map.getExtensions(clazz), listOf("A"))
         assertEquals(map.getExtensions(clazz, method), listOf("A"))
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiUpdateConsistencyTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiUpdateConsistencyTest.kt
index a4f2de0a2..5b8e15de0 100644
--- a/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiUpdateConsistencyTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiUpdateConsistencyTest.kt
@@ -25,12 +25,17 @@ import com.android.tools.metalava.model.snapshot.EmittableDelegatingVisitor
 import com.android.tools.metalava.model.source.EnvironmentManager
 import com.android.tools.metalava.model.source.SourceSet
 import com.android.tools.metalava.reporter.ThrowingReporter
+import com.android.tools.metalava.testing.TestFileCache
+import com.android.tools.metalava.testing.TestFileCacheRule
+import com.android.tools.metalava.testing.cacheIn
 import com.android.tools.metalava.testing.getAndroidJar
+import com.android.tools.metalava.testing.jarFromSources
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.signature
 import java.io.PrintWriter
 import java.io.StringWriter
 import kotlin.test.assertEquals
+import org.junit.ClassRule
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TestRule
@@ -67,6 +72,25 @@ class ApiUpdateConsistencyTest : DriverTest() {
         }
     }
 
+    companion object {
+        /** Create a [TestFileCache] whose lifespan encompasses all the tests in this class. */
+        @ClassRule @JvmField val testFileCacheRule = TestFileCacheRule()
+
+        private val deprecatedEnumClass =
+            java(
+                """
+                    package test.pkg;
+                    /** @deprecated */
+                    @Deprecated public enum DeprecatedEnum {
+                        CONSTANT
+                    }
+                """
+            )
+
+        private val deprecatedEnumJarCached =
+            jarFromSources("deprecated-enum.jar", deprecatedEnumClass).cacheIn(testFileCacheRule)
+    }
+
     /**
      * The [EnvironmentManager] used by [versionedSourceApi].
      *
@@ -110,6 +134,7 @@ class ApiUpdateConsistencyTest : DriverTest() {
                     classPath,
                     apiPackages = null,
                     projectDescription = null,
+                    compiledSourceJar = null,
                 )
 
             val codebaseFragment = CodebaseFragment.create(codebase, ::EmittableDelegatingVisitor)
@@ -124,12 +149,21 @@ class ApiUpdateConsistencyTest : DriverTest() {
     private fun versionedJarApi(classFiles: Set<String>): VersionedApiFactory = { version ->
         VersionedJarApi(
             // `prebuilts/sdk/30/public/android.jar`
-            getAndroidJar(30),
+            listOf(getAndroidJar(30)),
             ApiHistoryUpdater.forApiVersion(version),
             filter = { it in classFiles },
         )
     }
 
+    private fun versionedJarApiFromTestFile(jar: TestFile): VersionedApiFactory = { version ->
+        // Create a new target dir every time just in case the same jar file is used multiple times.
+        val targetDir = temporaryFolder.newFolder()
+        VersionedJarApi(
+            listOf(jar.createFile(targetDir)),
+            ApiHistoryUpdater.forApiVersion(version),
+        )
+    }
+
     /**
      * Create an [Api] from a list of [VersionedApi]s, print it using [ApiXmlPrinter] and then
      * verify that the result matches [expectedXmlContents].
@@ -140,6 +174,8 @@ class ApiUpdateConsistencyTest : DriverTest() {
         message: String,
     ) {
         val api = createApiFromVersionedApis(useInternalNames = true, versionedApis)
+        // Clean the API as is done when generating it properly.
+        api.clean()
         val writer = StringWriter()
         val printer = ApiXmlPrinter(null, versionedApis)
         PrintWriter(writer).use { printWriter -> printer.print(api, printWriter) }
@@ -163,12 +199,12 @@ class ApiUpdateConsistencyTest : DriverTest() {
      * [versionedApiFactories] on [Api] in three different ways:
      * 1. It will create [VersionedApi]s in order with the version equal to 1 more than the index of
      *    the [VersionedApiFactory] in [versionedApiFactories]. They will then be applied in version
-     *    order, e.g. from 1 to `N`. The resulting XML will be compared with [expectedForward].
+     *    order, e.g. from 1 to `N`. The resulting XML will be compared with [expected].
      * 2. The list of [VersionedApi]s created in step #1 will be reversed. So, version `N` will be
      *    applied before version `N-1`. The resulting XML will be compared with
-     *    [expectedBackwardSameVersions].
+     *    [expectedReversedVersions].
      * 3. The list of [versionedApiFactories] will be reversed and then used as in step #1. The
-     *    resulting XML will be compared with [expectedBackwardIncludeVersions].
+     *    resulting XML will be compared with [expectedReversedFactories].
      *
      * Irrespective of which way the [Api] is constructed it should produce XML output that matches
      * [expected].
@@ -176,6 +212,8 @@ class ApiUpdateConsistencyTest : DriverTest() {
     private fun checkVersionedApiFactories(
         vararg versionedApiFactories: VersionedApiFactory,
         expected: String,
+        expectedReversedVersions: String = expected,
+        expectedReversedFactories: String = expected,
     ) {
         val versionedApis =
             versionedApiFactories.mapIndexed { index, factory ->
@@ -183,13 +221,13 @@ class ApiUpdateConsistencyTest : DriverTest() {
             }
 
         checkVersionedApis(versionedApis, expected, "forward")
-        checkVersionedApis(versionedApis.reversed(), expected, "reversed versions")
+        checkVersionedApis(versionedApis.reversed(), expectedReversedVersions, "reversed versions")
 
         checkVersionedApis(
             versionedApiFactories.reversed().mapIndexed { index, factory ->
                 factory(ApiVersion.fromLevel(index + 1))
             },
-            expected,
+            expectedReversedFactories,
             "reversed factories"
         )
     }
@@ -354,4 +392,36 @@ class ApiUpdateConsistencyTest : DriverTest() {
                 """,
         )
     }
+
+    @Test
+    fun `Test deprecated enum`() {
+        checkVersionedApiFactories(
+            versionedJarApiFromTestFile(deprecatedEnumJarCached),
+            versionedSignatureApi(
+                """
+                        // Signature format: 2.0
+                        package test.pkg {
+                          @Deprecated public enum DeprecatedEnum {
+                            enum_constant @Deprecated public test.pkg.DeprecatedEnum CONSTANT;
+                          }
+                        }
+                    """
+            ),
+            versionedSourceApi(deprecatedEnumClass),
+            // Emulates an extension jar being applied after the main API.
+            versionedJarApiFromTestFile(deprecatedEnumJarCached),
+            expected =
+                """
+                    <?xml version="1.0" encoding="utf-8"?>
+                    <api version="3">
+                        <class name="test/pkg/DeprecatedEnum" since="1" deprecated="1">
+                            <extends name="java/lang/Enum"/>
+                            <method name="valueOf(Ljava/lang/String;)Ltest/pkg/DeprecatedEnum;"/>
+                            <method name="values()[Ltest/pkg/DeprecatedEnum;"/>
+                            <field name="CONSTANT"/>
+                        </class>
+                    </api>
+                """,
+        )
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/PatternNodeTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/PatternNodeTest.kt
index 2537d682e..9a7f1b0f7 100644
--- a/metalava/src/test/java/com/android/tools/metalava/apilevels/PatternNodeTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/PatternNodeTest.kt
@@ -103,7 +103,7 @@ class PatternNodeTest : TemporaryFolderOwner {
         val exception =
             assertThrows(IllegalStateException::class.java) { PatternNode.parsePatterns(patterns) }
         assertEquals(
-            "Pattern 'prebuilts/sdk/{unknown}/public/android-{version:level}.jar' contains an unknown placeholder '{unknown}', expected one of '{version:level}', '{version:major.minor?}', '{version:major.minor.patch}', '{version:extension}', '{module}', '{surface}'",
+            "Pattern 'prebuilts/sdk/{unknown}/public/android-{version:level}.jar' contains an unknown placeholder '{unknown}', expected one of '{version:level}', '{version:major.minor?}', '{version:major.minor.patch}', '{version:extension}', '{library}', '{module}', '{surface}'",
             exception.message
         )
     }
@@ -471,6 +471,47 @@ class PatternNodeTest : TemporaryFolderOwner {
         )
     }
 
+    @Test
+    fun `Scan for library`() {
+        val rootDir = buildFileStructure {
+            dir("root") {
+                dir("1") { apiFile("android") }
+                dir("2") {
+                    apiFile("android")
+                    apiFile("android.test.base")
+                    apiFile("android.test.mock")
+                    apiFile("android.test.runtime")
+                }
+                dir("3") {
+                    apiFile("android")
+                    apiFile("android.test.base")
+                    apiFile("android.test.mock")
+                    apiFile("android.test.runtime")
+                }
+            }
+        }
+
+        val patterns =
+            listOf(
+                "root/{version:level}/{library}.txt",
+            )
+        val node = PatternNode.parsePatterns(patterns)
+        val files = node.scan(PatternNode.ScanConfig(rootDir))
+        files.assertMatchedPatternFiles(
+            """
+                MatchedPatternFile(file=TESTROOT/root/1/android.txt, version=1, library='android')
+                MatchedPatternFile(file=TESTROOT/root/2/android.txt, version=2, library='android')
+                MatchedPatternFile(file=TESTROOT/root/2/android.test.base.txt, version=2, library='android.test.base')
+                MatchedPatternFile(file=TESTROOT/root/2/android.test.mock.txt, version=2, library='android.test.mock')
+                MatchedPatternFile(file=TESTROOT/root/2/android.test.runtime.txt, version=2, library='android.test.runtime')
+                MatchedPatternFile(file=TESTROOT/root/3/android.txt, version=3, library='android')
+                MatchedPatternFile(file=TESTROOT/root/3/android.test.base.txt, version=3, library='android.test.base')
+                MatchedPatternFile(file=TESTROOT/root/3/android.test.mock.txt, version=3, library='android.test.mock')
+                MatchedPatternFile(file=TESTROOT/root/3/android.test.runtime.txt, version=3, library='android.test.runtime')
+            """
+        )
+    }
+
     @Test
     fun `Scan for extension and non-extension versions`() {
         val rootDir = buildFileStructure {
diff --git a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassFieldsTest.kt b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassFieldsTest.kt
index 1620d6a96..8b903ac92 100644
--- a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassFieldsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassFieldsTest.kt
@@ -26,8 +26,8 @@ class BinaryCompatibilityClassFieldsTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Field test.pkg.Foo.bar has changed type from java.lang.String to int [ChangedType]
-            """,
+                load-api.txt:4: error: Binary breaking change: Field test.pkg.Foo.bar has changed type from java.lang.String to int [ChangedType]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -52,8 +52,8 @@ class BinaryCompatibilityClassFieldsTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Field test.pkg.Foo.bar has changed value from 8 to 7 [ChangedValue]
-            """,
+                load-api.txt:4: error: Binary breaking change: Field test.pkg.Foo.bar has changed value from 8 to 7 [ChangedValue]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -78,9 +78,9 @@ class BinaryCompatibilityClassFieldsTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Field test.pkg.Foo.bar changed visibility from protected to private [ChangedScope]
-                load-api.txt:5: error: Field test.pkg.Foo.baz changed visibility from public to protected [ChangedScope]
-            """,
+                load-api.txt:4: error: Binary breaking change: Field test.pkg.Foo.bar changed visibility from protected to private [ChangedScope]
+                load-api.txt:5: error: Binary breaking change: Field test.pkg.Foo.baz changed visibility from public to protected [ChangedScope]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -151,15 +151,20 @@ class BinaryCompatibilityClassFieldsTest : DriverTest() {
     @Test
     fun `Change final to non-final, static with compile-time constant value (Incompatible)`() {
         check(
+            // The value change is caused by the removal of `final`. Removing `final` turns the
+            // field from one that always has a value of `0` which is inlined by the compiler to a
+            // field which is initialized with a value of `0` but may be changed and will not be
+            // inlined by the compiler.
             expectedIssues =
                 """
-                load-api.txt:4: error: Field test.pkg.Foo.bar has removed 'final' qualifier [RemovedFinal]
-            """,
+                    load-api.txt:4: error: Binary breaking change: Field test.pkg.Foo.bar has changed value from 0 to nothing/not constant [ChangedValue]
+                    load-api.txt:4: error: Binary breaking change: Field test.pkg.Foo.bar has removed 'final' qualifier [RemovedFinal]
+                """,
             signatureSource =
                 """
                 package test.pkg {
                   public class Foo {
-                    field public static int bar = 0;
+                    field public static int bar;
                   }
                 }
             """,
@@ -179,8 +184,8 @@ class BinaryCompatibilityClassFieldsTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Field test.pkg.Foo.bar has added 'final' qualifier [AddedFinal]
-            """,
+                load-api.txt:4: error: Binary breaking change: Field test.pkg.Foo.bar has added 'final' qualifier [AddedFinal]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -205,13 +210,13 @@ class BinaryCompatibilityClassFieldsTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Field test.pkg.Foo.bar has changed 'static' qualifier [ChangedStatic]
-            """,
+                load-api.txt:4: error: Binary breaking change: Field test.pkg.Foo.bar has changed 'static' qualifier [ChangedStatic]
+                """,
             signatureSource =
                 """
                 package test.pkg {
                   public class Foo {
-                    field public int bar = 0;
+                    field public int bar;
                   }
                 }
             """,
@@ -219,7 +224,7 @@ class BinaryCompatibilityClassFieldsTest : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    field public static int bar = 0;
+                    field public static int bar;
                   }
                 }
             """
@@ -231,13 +236,13 @@ class BinaryCompatibilityClassFieldsTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Field test.pkg.Foo.bar has changed 'static' qualifier [ChangedStatic]
-            """,
+                load-api.txt:4: error: Binary breaking change: Field test.pkg.Foo.bar has changed 'static' qualifier [ChangedStatic]
+                """,
             signatureSource =
                 """
                 package test.pkg {
                   public class Foo {
-                    field public static int bar = 0;
+                    field public static int bar;
                   }
                 }
             """,
@@ -245,7 +250,7 @@ class BinaryCompatibilityClassFieldsTest : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    field public int bar = 0;
+                    field public int bar;
                   }
                 }
             """
@@ -259,7 +264,7 @@ class BinaryCompatibilityClassFieldsTest : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    field public int bar = 0;
+                    field public int bar;
                   }
                 }
             """,
@@ -267,7 +272,7 @@ class BinaryCompatibilityClassFieldsTest : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    field public transient int bar = 0;
+                    field public transient int bar;
                   }
                 }
             """
@@ -281,7 +286,7 @@ class BinaryCompatibilityClassFieldsTest : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    field public transient int bar = 0;
+                    field public transient int bar;
                   }
                 }
             """,
@@ -289,7 +294,7 @@ class BinaryCompatibilityClassFieldsTest : DriverTest() {
                 """
                 package test.pkg {
                   public class Foo {
-                    field public int bar = 0;
+                    field public int bar;
                   }
                 }
             """
diff --git a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassMethodsAndConstructors.kt b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassMethodsAndConstructors.kt
index 06ee01663..d15525ead 100644
--- a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassMethodsAndConstructors.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassMethodsAndConstructors.kt
@@ -25,8 +25,8 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:4: error: Removed method test.pkg.Foo.bar(int) [RemovedMethod]
-            """,
+                released-api.txt:4: error: Binary breaking change: Removed method test.pkg.Foo.bar(int) [RemovedMethod]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -51,8 +51,8 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:4: error: Removed method test.pkg.Foo.bar(int) [RemovedMethod]
-            """,
+                released-api.txt:4: error: Binary breaking change: Removed method test.pkg.Foo.bar(int) [RemovedMethod]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -77,8 +77,8 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:4: error: Removed method test.pkg.Foo.bar(int) [RemovedMethod]
-            """,
+                released-api.txt:4: error: Binary breaking change: Removed method test.pkg.Foo.bar(int) [RemovedMethod]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -103,8 +103,8 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Method test.pkg.Foo.bar has changed return type from void to int [ChangedType]
-            """,
+                load-api.txt:4: error: Binary breaking change: Method test.pkg.Foo.bar has changed return type from void to int [ChangedType]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -129,8 +129,8 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Method test.pkg.Foo.bar added thrown exception java.lang.Throwable [ChangedThrows]
-            """,
+                load-api.txt:4: error: Binary breaking change: Method test.pkg.Foo.bar added thrown exception java.lang.Throwable [ChangedThrows]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -155,8 +155,8 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Method test.pkg.Foo.bar no longer throws exception java.lang.Throwable [ChangedThrows]
-            """,
+                load-api.txt:4: error: Binary breaking change: Method test.pkg.Foo.bar no longer throws exception java.lang.Throwable [ChangedThrows]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -197,17 +197,18 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
             """
         )
     }
-    /*
-    Decrease access; that is, from protected access to default or private access,
-    or from public access to protected, default, or private access
+
+    /**
+     * Decrease access; that is, from protected access to default or private access, or from public
+     * access to protected, default, or private access
      */
     @Test
     fun `Decrease access(Incompatible)`() {
         check(
             expectedIssues =
                 """
-               load-api.txt:4: error: Method test.pkg.Foo.bar changed visibility from public to protected [ChangedScope]
-            """,
+               load-api.txt:4: error: Binary breaking change: Method test.pkg.Foo.bar changed visibility from public to protected [ChangedScope]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -276,8 +277,8 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
         check(
             expectedIssues =
                 """
-               load-api.txt:4: error: Method test.pkg.Foo.bar has changed 'abstract' qualifier [ChangedAbstract]
-            """,
+               load-api.txt:4: error: Binary breaking change: Method test.pkg.Foo.bar has changed 'abstract' qualifier [ChangedAbstract]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -303,7 +304,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
             expectedIssues =
                 """
                load-api.txt:4: error: Method test.pkg.Foo.bar has removed 'final' qualifier [RemovedFinalStrict]
-            """,
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -350,7 +351,7 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
         check(
             expectedIssues =
                 """
-               load-api.txt:5: error: Method test.pkg.Foo.bar has added 'final' qualifier [AddedFinal]
+               load-api.txt:5: error: Binary breaking change: Method test.pkg.Foo.bar has added 'final' qualifier [AddedFinal]
             """,
             signatureSource =
                 """
@@ -378,8 +379,8 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Method test.pkg.Foo.bar has changed 'static' qualifier [ChangedStatic]
-            """,
+                load-api.txt:4: error: Binary breaking change: Method test.pkg.Foo.bar has changed 'static' qualifier [ChangedStatic]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -404,8 +405,8 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Method test.pkg.Foo.bar has changed 'static' qualifier [ChangedStatic]
-            """,
+                load-api.txt:4: error: Binary breaking change: Method test.pkg.Foo.bar has changed 'static' qualifier [ChangedStatic]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -659,8 +660,8 @@ class BinaryCompatibilityClassMethodsAndConstructors : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Changing from varargs to array is an incompatible change: parameter arg1 in test.pkg.Foo.bar(T[] arg1) [VarargRemoval]
-            """,
+                load-api.txt:4: error: Binary breaking change: Changing from varargs to array is an incompatible change: parameter arg1 in test.pkg.Foo.bar(T[] arg1) [VarargRemoval]
+                """,
             signatureSource =
                 """
                 package test.pkg {
diff --git a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassesTest.kt b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassesTest.kt
index e51dac7bc..41a5a90fc 100644
--- a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassesTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityClassesTest.kt
@@ -53,7 +53,7 @@ class BinaryCompatibilityClassesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:5: error: Added method test.pkg.Foo.bar() [AddedAbstractMethod]
+                load-api.txt:5: error: Binary breaking change: Added method test.pkg.Foo.bar() [AddedAbstractMethod]
             """,
             signatureSource =
                 """
@@ -80,7 +80,7 @@ class BinaryCompatibilityClassesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:4: error: Removed method test.pkg.Foo.bar() [RemovedMethod]
+                released-api.txt:4: error: Binary breaking change: Removed method test.pkg.Foo.bar() [RemovedMethod]
             """,
             signatureSource =
                 """
@@ -131,7 +131,7 @@ class BinaryCompatibilityClassesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:5: error: Added method test.pkg.Upper.foo() [AddedAbstractMethod]
+                load-api.txt:5: error: Binary breaking change: Added method test.pkg.Upper.foo() [AddedAbstractMethod]
             """,
             signatureSource =
                 """
@@ -165,7 +165,7 @@ class BinaryCompatibilityClassesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:4: error: Removed method test.pkg.Upper.foo() [RemovedMethod]
+                released-api.txt:4: error: Binary breaking change: Removed method test.pkg.Upper.foo() [RemovedMethod]
             """,
             signatureSource =
                 """
@@ -218,7 +218,7 @@ class BinaryCompatibilityClassesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:4: error: Removed constructor test.pkg.Foo() [RemovedMethod]
+                released-api.txt:4: error: Binary breaking change: Removed constructor test.pkg.Foo() [RemovedMethod]
             """,
             signatureSource =
                 """
@@ -246,7 +246,7 @@ class BinaryCompatibilityClassesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:4: error: Removed constructor test.pkg.Foo() [RemovedMethod]
+                released-api.txt:4: error: Binary breaking change: Removed constructor test.pkg.Foo() [RemovedMethod]
             """,
             signatureSource =
                 """
@@ -292,7 +292,7 @@ class BinaryCompatibilityClassesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:4: error: Removed field test.pkg.Foo.bar [RemovedField]
+                released-api.txt:4: error: Binary breaking change: Removed field test.pkg.Foo.bar [RemovedField]
             """,
             signatureSource =
                 """
@@ -345,7 +345,7 @@ class BinaryCompatibilityClassesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:7: error: Class test.pkg.Foo no longer implements test.pkg.Two [RemovedInterface]
+                load-api.txt:7: error: Binary breaking change: Class test.pkg.Foo no longer implements test.pkg.Two [RemovedInterface]
             """,
             signatureSource =
                 """
@@ -403,7 +403,7 @@ class BinaryCompatibilityClassesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:7: error: Class test.pkg.Foo superclass changed from test.pkg.Baz to test.pkg.Bar [ChangedSuperclass]
+                load-api.txt:7: error: Binary breaking change: Class test.pkg.Foo superclass changed from test.pkg.Baz to test.pkg.Bar [ChangedSuperclass]
             """,
             signatureSource =
                 """
@@ -457,7 +457,7 @@ class BinaryCompatibilityClassesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:5: error: Removed class test.pkg.Outer.Inner [RemovedClass]
+                released-api.txt:5: error: Binary breaking change: Removed class test.pkg.Outer.Inner [RemovedClass]
             """,
             signatureSource =
                 """
@@ -503,7 +503,7 @@ class BinaryCompatibilityClassesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:3: error: Class test.pkg.Foo changed 'abstract' qualifier [ChangedAbstract]
+                load-api.txt:3: error: Binary breaking change: Class test.pkg.Foo changed 'abstract' qualifier [ChangedAbstract]
             """,
             signatureSource =
                 """
@@ -553,7 +553,7 @@ class BinaryCompatibilityClassesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:3: error: Class test.pkg.Foo added 'final' qualifier [AddedFinal]
+                load-api.txt:3: error: Binary breaking change: Class test.pkg.Foo added 'final' qualifier [AddedFinal]
             """,
             signatureSource =
                 """
@@ -599,7 +599,7 @@ class BinaryCompatibilityClassesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:3: error: Class test.pkg.Foo changed number of type parameters from 1 to 2 [ChangedType]
+                load-api.txt:3: error: Binary breaking change: Class test.pkg.Foo changed number of type parameters from 1 to 2 [ChangedType]
             """,
             signatureSource =
                 """
@@ -623,8 +623,8 @@ class BinaryCompatibilityClassesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:3: error: Class test.pkg.Bar changed number of type parameters from 1 to 0 [ChangedType]
-                load-api.txt:5: error: Class test.pkg.Foo changed number of type parameters from 2 to 1 [ChangedType]
+                load-api.txt:3: error: Binary breaking change: Class test.pkg.Bar changed number of type parameters from 1 to 0 [ChangedType]
+                load-api.txt:5: error: Binary breaking change: Class test.pkg.Foo changed number of type parameters from 2 to 1 [ChangedType]
             """,
             signatureSource =
                 """
@@ -651,9 +651,10 @@ class BinaryCompatibilityClassesTest : DriverTest() {
     @Test
     fun `Reorder type parameters (Incompatible)`() {
         check(
-            expectedIssues = """
-                (expected issue for class Foo)
-            """,
+            expectedIssues =
+                """
+                    (expected issue for class Foo)
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -731,7 +732,7 @@ class BinaryCompatibilityClassesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:4: error: Removed enum constant test.pkg.Foo.OLD [RemovedField]
+                released-api.txt:4: error: Binary breaking change: Removed enum constant test.pkg.Foo.OLD [RemovedField]
             """,
             signatureSource =
                 """
@@ -780,7 +781,7 @@ class BinaryCompatibilityClassesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:5: error: Removed enum constant test.pkg.Foo.TWO [RemovedField]
+                released-api.txt:5: error: Binary breaking change: Removed enum constant test.pkg.Foo.TWO [RemovedField]
             """,
             signatureSource =
                 """
diff --git a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfaceFieldsTest.kt b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfaceFieldsTest.kt
index 11c5a0002..ab2ddc40b 100644
--- a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfaceFieldsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfaceFieldsTest.kt
@@ -26,9 +26,9 @@ class BinaryCompatibilityInterfaceFieldsTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Field test.pkg.Foo.bar has changed type from int to java.lang.String [ChangedType]
-                load-api.txt:4: error: Attempted to remove nullability from java.lang.String (was NONNULL) in field test.pkg.Foo.bar [InvalidNullConversion]
-            """,
+                load-api.txt:4: error: Binary breaking change: Field test.pkg.Foo.bar has changed type from int to java.lang.String [ChangedType]
+                load-api.txt:4: error: Source breaking change: Attempted to remove nullability from java.lang.String (was NONNULL) in field test.pkg.Foo.bar [InvalidNullConversion]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -53,8 +53,8 @@ class BinaryCompatibilityInterfaceFieldsTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Field test.pkg.Foo.bar has changed value from 8 to 7 [ChangedValue]
-            """,
+                load-api.txt:4: error: Binary breaking change: Field test.pkg.Foo.bar has changed value from 8 to 7 [ChangedValue]
+                """,
             signatureSource =
                 """
                 package test.pkg {
diff --git a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfaceMethodsTest.kt b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfaceMethodsTest.kt
index 515b2376d..aa0b337da 100644
--- a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfaceMethodsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfaceMethodsTest.kt
@@ -26,8 +26,8 @@ class BinaryCompatibilityInterfaceMethodsTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                    load-api.txt:4: error: Added method test.pkg.Foo.baz(int) [AddedAbstractMethod]
-                    released-api.txt:4: error: Removed method test.pkg.Foo.bar(int) [RemovedMethod]
+                    load-api.txt:4: error: Binary breaking change: Added method test.pkg.Foo.baz(int) [AddedAbstractMethod]
+                    released-api.txt:4: error: Binary breaking change: Removed method test.pkg.Foo.bar(int) [RemovedMethod]
                 """,
             signatureSource =
                 """
@@ -53,8 +53,8 @@ class BinaryCompatibilityInterfaceMethodsTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                    load-api.txt:4: error: Added method test.pkg.Foo.bar() [AddedAbstractMethod]
-                    released-api.txt:4: error: Removed method test.pkg.Foo.bar(int) [RemovedMethod]
+                    load-api.txt:4: error: Binary breaking change: Added method test.pkg.Foo.bar() [AddedAbstractMethod]
+                    released-api.txt:4: error: Binary breaking change: Removed method test.pkg.Foo.bar(int) [RemovedMethod]
                 """,
             signatureSource =
                 """
@@ -80,8 +80,8 @@ class BinaryCompatibilityInterfaceMethodsTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                    load-api.txt:4: error: Added method test.pkg.Foo.bar(Float) [AddedAbstractMethod]
-                    released-api.txt:4: error: Removed method test.pkg.Foo.bar(int) [RemovedMethod]
+                    load-api.txt:4: error: Binary breaking change: Added method test.pkg.Foo.bar(Float) [AddedAbstractMethod]
+                    released-api.txt:4: error: Binary breaking change: Removed method test.pkg.Foo.bar(int) [RemovedMethod]
                 """,
             signatureSource =
                 """
@@ -107,8 +107,8 @@ class BinaryCompatibilityInterfaceMethodsTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Method test.pkg.Foo.bar has changed return type from void to int [ChangedType]
-            """,
+                load-api.txt:4: error: Binary breaking change: Method test.pkg.Foo.bar has changed return type from void to int [ChangedType]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -133,8 +133,8 @@ class BinaryCompatibilityInterfaceMethodsTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Method test.pkg.Foo.bar added thrown exception java.lang.Throwable [ChangedThrows]
-            """,
+                load-api.txt:4: error: Binary breaking change: Method test.pkg.Foo.bar added thrown exception java.lang.Throwable [ChangedThrows]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -159,8 +159,8 @@ class BinaryCompatibilityInterfaceMethodsTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Method test.pkg.Foo.bar no longer throws exception java.lang.Throwable [ChangedThrows]
-            """,
+                load-api.txt:4: error: Binary breaking change: Method test.pkg.Foo.bar no longer throws exception java.lang.Throwable [ChangedThrows]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -207,8 +207,8 @@ class BinaryCompatibilityInterfaceMethodsTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Method test.pkg.Foo.bar has changed 'static' qualifier [ChangedStatic]
-            """,
+                load-api.txt:4: error: Binary breaking change: Method test.pkg.Foo.bar has changed 'static' qualifier [ChangedStatic]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -233,8 +233,8 @@ class BinaryCompatibilityInterfaceMethodsTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Method test.pkg.Foo.bar has changed 'static' qualifier [ChangedStatic]
-            """,
+                load-api.txt:4: error: Binary breaking change: Method test.pkg.Foo.bar has changed 'static' qualifier [ChangedStatic]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -259,8 +259,8 @@ class BinaryCompatibilityInterfaceMethodsTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Method test.pkg.Foo.bar has changed 'default' qualifier [ChangedDefault]
-            """,
+                load-api.txt:4: error: Binary breaking change: Method test.pkg.Foo.bar has changed 'default' qualifier [ChangedDefault]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -453,8 +453,8 @@ class BinaryCompatibilityInterfaceMethodsTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Changing from varargs to array is an incompatible change: parameter arg1 in test.pkg.Foo.bar(T[] arg1) [VarargRemoval]
-            """,
+                load-api.txt:4: error: Binary breaking change: Changing from varargs to array is an incompatible change: parameter arg1 in test.pkg.Foo.bar(T[] arg1) [VarargRemoval]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -481,7 +481,7 @@ class BinaryCompatibilityInterfaceMethodsTest : DriverTest() {
                 """
                 package test.pkg {
                   public @interface Foo {
-                    method public void bar(int) default 0;
+                    method public int bar(int) default 0;
                   }
                 }
             """,
@@ -489,7 +489,7 @@ class BinaryCompatibilityInterfaceMethodsTest : DriverTest() {
                 """
                 package test.pkg {
                   public @interface Foo {
-                    method public void bar(int);
+                    method public int bar(int);
                   }
                 }
             """
@@ -505,13 +505,13 @@ class BinaryCompatibilityInterfaceMethodsTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Method test.pkg.Foo.bar has changed value from 0 to 1 [ChangedValue]
-            """,
+                load-api.txt:4: error: Binary breaking change: Method test.pkg.Foo.bar has changed value from 0 to 1 [ChangedValue]
+                """,
             signatureSource =
                 """
                 package test.pkg {
                   public @interface Foo {
-                    method public void bar(int) default 1;
+                    method public int bar(int) default 1;
                   }
                 }
             """,
@@ -519,7 +519,7 @@ class BinaryCompatibilityInterfaceMethodsTest : DriverTest() {
                 """
                 package test.pkg {
                   public @interface Foo {
-                    method public void bar(int) default 0;
+                    method public int bar(int) default 0;
                   }
                 }
             """
@@ -531,13 +531,13 @@ class BinaryCompatibilityInterfaceMethodsTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Method test.pkg.Foo.bar has changed value from 0 to nothing [ChangedValue]
-            """,
+                load-api.txt:4: error: Binary breaking change: Method test.pkg.Foo.bar has changed value from 0 to nothing [ChangedValue]
+                """,
             signatureSource =
                 """
                 package test.pkg {
                   public @interface Foo {
-                    method public void bar(int);
+                    method public int bar(int);
                   }
                 }
             """,
@@ -545,7 +545,7 @@ class BinaryCompatibilityInterfaceMethodsTest : DriverTest() {
                 """
                 package test.pkg {
                   public @interface Foo {
-                    method public void bar(int) default 0;
+                    method public int bar(int) default 0;
                   }
                 }
             """
diff --git a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfacesTest.kt b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfacesTest.kt
index 2c2fbbef5..89ccb9c3b 100644
--- a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfacesTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityInterfacesTest.kt
@@ -52,8 +52,8 @@ class BinaryCompatibilityInterfacesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Added method test.pkg.Foo.bar() [AddedAbstractMethod]
-            """,
+                load-api.txt:4: error: Binary breaking change: Added method test.pkg.Foo.bar() [AddedAbstractMethod]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -98,9 +98,10 @@ class BinaryCompatibilityInterfacesTest : DriverTest() {
     @Test
     fun `Add default method, if interface implementable by clients (Incompatible)`() {
         check(
-            expectedIssues = """
-                (expected issue for interface Foo)
-            """,
+            expectedIssues =
+                """
+                    (expected issue for interface Foo)
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -145,10 +146,10 @@ class BinaryCompatibilityInterfacesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:4: error: Removed method test.pkg.Foo.bar() [RemovedMethod]
-                released-api.txt:5: error: Removed method test.pkg.Foo.baz() [RemovedMethod]
-                released-api.txt:6: error: Removed method test.pkg.Foo.bax() [RemovedMethod]
-            """,
+                released-api.txt:4: error: Binary breaking change: Removed method test.pkg.Foo.bar() [RemovedMethod]
+                released-api.txt:5: error: Binary breaking change: Removed method test.pkg.Foo.baz() [RemovedMethod]
+                released-api.txt:6: error: Binary breaking change: Removed method test.pkg.Foo.bax() [RemovedMethod]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -201,8 +202,8 @@ class BinaryCompatibilityInterfacesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Added method test.pkg.Upper.bar() [AddedAbstractMethod]
-            """,
+                load-api.txt:4: error: Binary breaking change: Added method test.pkg.Upper.bar() [AddedAbstractMethod]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -231,8 +232,8 @@ class BinaryCompatibilityInterfacesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:4: error: Removed method test.pkg.Upper.bar() [RemovedMethod]
-            """,
+                released-api.txt:4: error: Binary breaking change: Removed method test.pkg.Upper.bar() [RemovedMethod]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -282,8 +283,8 @@ class BinaryCompatibilityInterfacesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:4: error: Removed field test.pkg.Foo.BAR [RemovedField]
-            """,
+                released-api.txt:4: error: Binary breaking change: Removed field test.pkg.Foo.BAR [RemovedField]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -335,8 +336,8 @@ class BinaryCompatibilityInterfacesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:7: error: Class test.pkg.Foo no longer implements test.pkg.Two [RemovedInterface]
-            """,
+                load-api.txt:7: error: Binary breaking change: Class test.pkg.Foo no longer implements test.pkg.Two [RemovedInterface]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -389,8 +390,8 @@ class BinaryCompatibilityInterfacesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:5: error: Removed class test.pkg.Outer.Inner [RemovedInterface]
-            """,
+                released-api.txt:5: error: Binary breaking change: Removed class test.pkg.Outer.Inner [RemovedInterface]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -435,8 +436,8 @@ class BinaryCompatibilityInterfacesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:3: error: Class test.pkg.Foo changed number of type parameters from 1 to 2 [ChangedType]
-            """,
+                load-api.txt:3: error: Binary breaking change: Class test.pkg.Foo changed number of type parameters from 1 to 2 [ChangedType]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -459,8 +460,8 @@ class BinaryCompatibilityInterfacesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:3: error: Class test.pkg.Foo changed number of type parameters from 1 to 0 [ChangedType]
-            """,
+                load-api.txt:3: error: Binary breaking change: Class test.pkg.Foo changed number of type parameters from 1 to 0 [ChangedType]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -482,9 +483,10 @@ class BinaryCompatibilityInterfacesTest : DriverTest() {
     @Test
     fun `Re-order type parameters (Incompatible)`() {
         check(
-            expectedIssues = """
-                (expected issue for interface Foo)
-            """,
+            expectedIssues =
+                """
+                    (expected issue for interface Foo)
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -506,9 +508,10 @@ class BinaryCompatibilityInterfacesTest : DriverTest() {
     @Test
     fun `Rename type parameter (Incompatible)`() {
         check(
-            expectedIssues = """
-                (expected issue for interface Foo)
-            """,
+            expectedIssues =
+                """
+                    (expected issue for interface Foo)
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -587,8 +590,8 @@ class BinaryCompatibilityInterfacesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Added method test.pkg.Foo.bar() [AddedAbstractMethod]
-            """,
+                load-api.txt:4: error: Binary breaking change: Added method test.pkg.Foo.bar() [AddedAbstractMethod]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -612,9 +615,9 @@ class BinaryCompatibilityInterfacesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:4: error: Removed method test.pkg.Foo.bar() [RemovedMethod]
-                released-api.txt:5: error: Removed method test.pkg.Foo.baz() [RemovedMethod]
-            """,
+                released-api.txt:4: error: Binary breaking change: Removed method test.pkg.Foo.bar() [RemovedMethod]
+                released-api.txt:5: error: Binary breaking change: Removed method test.pkg.Foo.baz() [RemovedMethod]
+                """,
             signatureSource =
                 """
                 package test.pkg {
diff --git a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityPackagesTest.kt b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityPackagesTest.kt
index 7a76f6640..0e82e429b 100644
--- a/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityPackagesTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/binarycompatibility/BinaryCompatibilityPackagesTest.kt
@@ -53,9 +53,8 @@ class BinaryCompatibilityPackagesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:5: error: Removed package test.pkg.removed [RemovedPackage]
-            """
-                    .trimIndent(),
+                released-api.txt:5: error: Binary breaking change: Removed package test.pkg.removed [RemovedPackage]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -104,9 +103,8 @@ class BinaryCompatibilityPackagesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:4: error: Removed class test.pkg.Bar [RemovedClass]
-            """
-                    .trimIndent(),
+                released-api.txt:4: error: Binary breaking change: Removed class test.pkg.Bar [RemovedClass]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -157,9 +155,8 @@ class BinaryCompatibilityPackagesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:3: error: Class test.pkg.Foo changed visibility from public to private [ChangedScope]
-            """
-                    .trimIndent(),
+                load-api.txt:3: error: Binary breaking change: Class test.pkg.Foo changed visibility from public to private [ChangedScope]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -185,20 +182,19 @@ class BinaryCompatibilityPackagesTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:3: error: Class test.pkg.ClassToEnum changed class/interface declaration [ChangedClass]
-                load-api.txt:4: error: Class test.pkg.ClassToInterface changed class/interface declaration [ChangedClass]
-                load-api.txt:5: error: Class test.pkg.ClassToAnnotation changed class/interface declaration [ChangedClass]
-                load-api.txt:6: error: Class test.pkg.EnumToClass changed class/interface declaration [ChangedClass]
-                load-api.txt:7: error: Class test.pkg.EnumToInterface changed class/interface declaration [ChangedClass]
-                load-api.txt:8: error: Class test.pkg.EnumToAnnotation changed class/interface declaration [ChangedClass]
-                load-api.txt:9: error: Class test.pkg.InterfaceToClass changed class/interface declaration [ChangedClass]
-                load-api.txt:10: error: Class test.pkg.InterfaceToEnum changed class/interface declaration [ChangedClass]
-                load-api.txt:11: error: Class test.pkg.InterfaceToAnnotation changed class/interface declaration [ChangedClass]
-                load-api.txt:12: error: Class test.pkg.AnnotationToClass changed class/interface declaration [ChangedClass]
-                load-api.txt:13: error: Class test.pkg.AnnotationToInterface changed class/interface declaration [ChangedClass]
-                load-api.txt:14: error: Class test.pkg.AnnotationToEnum changed class/interface declaration [ChangedClass]
-            """
-                    .trimIndent(),
+                load-api.txt:3: error: Binary breaking change: Class test.pkg.ClassToEnum changed class/interface declaration [ChangedClass]
+                load-api.txt:4: error: Binary breaking change: Class test.pkg.ClassToInterface changed class/interface declaration [ChangedClass]
+                load-api.txt:5: error: Binary breaking change: Class test.pkg.ClassToAnnotation changed class/interface declaration [ChangedClass]
+                load-api.txt:6: error: Binary breaking change: Class test.pkg.EnumToClass changed class/interface declaration [ChangedClass]
+                load-api.txt:7: error: Binary breaking change: Class test.pkg.EnumToInterface changed class/interface declaration [ChangedClass]
+                load-api.txt:8: error: Binary breaking change: Class test.pkg.EnumToAnnotation changed class/interface declaration [ChangedClass]
+                load-api.txt:9: error: Binary breaking change: Class test.pkg.InterfaceToClass changed class/interface declaration [ChangedClass]
+                load-api.txt:10: error: Binary breaking change: Class test.pkg.InterfaceToEnum changed class/interface declaration [ChangedClass]
+                load-api.txt:11: error: Binary breaking change: Class test.pkg.InterfaceToAnnotation changed class/interface declaration [ChangedClass]
+                load-api.txt:12: error: Binary breaking change: Class test.pkg.AnnotationToClass changed class/interface declaration [ChangedClass]
+                load-api.txt:13: error: Binary breaking change: Class test.pkg.AnnotationToInterface changed class/interface declaration [ChangedClass]
+                load-api.txt:14: error: Binary breaking change: Class test.pkg.AnnotationToEnum changed class/interface declaration [ChangedClass]
+                """,
             signatureSource =
                 """
                 package test.pkg {
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/common/BaseCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/common/BaseCommandTest.kt
index 1c612209f..94611e726 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/common/BaseCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/common/BaseCommandTest.kt
@@ -131,6 +131,20 @@ class CommandTestConfig<C : CliktCommand>(private val test: BaseCommandTest<C>)
         args.mapTo(this) { it.toString() }
     }
 
+    /** Add an option and a [TestFile]. */
+    @JvmName("plusAssignOptionAndTestFile") // Prevent JVM signature clash with below.
+    operator fun MutableList<String>.plusAssign(flagWithFile: Pair<String, TestFile>) {
+        this += flagWithFile.first
+        this += flagWithFile.second
+    }
+
+    /** Add an option and anything else. */
+    @JvmName("plusAssignOptionAndAnything") // Prevent JVM signature clash with above.
+    operator fun MutableList<String>.plusAssign(flagWithFile: Pair<String, Any>) {
+        this += flagWithFile.first
+        this += flagWithFile.second
+    }
+
     /**
      * The expected output, defaults to an empty string.
      *
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/common/IssueReportingOptionsTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/common/IssueReportingOptionsTest.kt
index 5959df503..64bf88bbc 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/common/IssueReportingOptionsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/common/IssueReportingOptionsTest.kt
@@ -169,7 +169,7 @@ class IssueReportingOptionsTest :
         runTest(ARG_HIDE_CATEGORY, "compatibility") {
             assertEquals("", stdout)
             assertEquals(
-                "Option --hide-category is invalid: Unknown category: 'compatibility', expected one of Compatibility, Documentation, ApiLint, Unknown",
+                "Option --hide-category is invalid: Unknown category: 'compatibility', expected one of Documentation, ApiLint, Unknown, Compatibility, BinaryCompatibilityOnly, SourceCompatibilityOnly, BinaryAndSourceCompatibility, OtherCompatibility",
                 stderr
             )
         }
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/common/SourceOptionsTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/common/SourceOptionsTest.kt
index 7c4444dac..ce1d8a2c7 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/common/SourceOptionsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/common/SourceOptionsTest.kt
@@ -30,6 +30,9 @@ Sources:
                                              stubs; the --stub-packages name is historical.
 
                                              See `metalava help package-filters` for more information.
+  --compiled-sources <path>                  Jar file with the compiled version of --source-files, loaded in addition to
+                                             the source files. Used to include the bytecode version of Kotlin source
+                                             APIs.
     """
         .trimIndent()
 
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/flag/FlagReportCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/flag/FlagReportCommandTest.kt
new file mode 100644
index 000000000..5855a39d3
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/flag/FlagReportCommandTest.kt
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.cli.flag
+
+import com.android.tools.metalava.ARG_CONFIG_FILE
+import com.android.tools.metalava.cli.common.BaseCommandTest
+import com.android.tools.metalava.testing.signature
+import com.android.tools.metalava.testing.xml
+import kotlin.test.assertEquals
+import org.junit.Test
+
+class FlagReportCommandTest : BaseCommandTest<FlagReportCommand>({ FlagReportCommand() }) {
+    @Test
+    fun `Test basic report`() {
+        commandTest {
+            args += "flag-report"
+
+            args +=
+                ARG_CONFIG_FILE to
+                    xml(
+                        "config-empty-api-flags.xml",
+                        """
+                            <config xmlns="http://www.google.com/tools/metalava/config"
+                                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+                                xsi:schemaLocation="http://www.google.com/tools/metalava/config ../../../../../../../resources/schemas/config.xsd">
+                                <api-flags>
+                                    <api-flag package="test.pkg" name="kept_flag" mutability="mutable" status="disabled"/>
+                                    <api-flag package="test.pkg" name="finalized_flag" mutability="immutable" status="enabled"/>
+                                    <api-flag package="test.pkg" name="reverted_flag" mutability="immutable" status="disabled"/>
+                                </api-flags>
+                            </config>
+                        """
+                    )
+
+            val outputFile = outputFile("flag-report.csv")
+            args += "--output-file" to outputFile
+
+            args +=
+                signature(
+                    """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      @FlaggedApi("test.pkg.unknown_flag") public class FooWithUnknownFlag {
+                      }
+                      @FlaggedApi("test.pkg.kept_flag") public class FooWithKeptFlag {
+                      }
+                      @FlaggedApi("test.pkg.finalized_flag") public class FooWithFinalizedFlag {
+                      }
+                      @FlaggedApi("test.pkg.reverted_flag") public class FooWithRevertedFlag {
+                      }
+                    }
+                """
+                )
+
+            verify {
+                assertEquals(
+                    """
+                        test.pkg.finalized_flag,known,finalized
+                        test.pkg.kept_flag,known,kept
+                        test.pkg.reverted_flag,known,reverted
+                        test.pkg.unknown_flag,unknown,reverted
+                    """
+                        .trimIndent(),
+                    outputFile.readText().trimEnd()
+                )
+            }
+        }
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/flag/FlagReportOptionsTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/flag/FlagReportOptionsTest.kt
new file mode 100644
index 000000000..28d8bfaa1
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/flag/FlagReportOptionsTest.kt
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.cli.flag
+
+import com.android.tools.metalava.cli.common.BaseOptionGroupTest
+
+val FLAG_REPORT_OPTIONS_HELP =
+    """
+Flag Report:
+
+  Options that control the flag report file.
+
+  --output-file <file>                       A file into which Metalava will output a report about how flags provided by
+                                             a --config-file affect the signature files passed to this command.
+
+                                             The extension of the file determines the output. Currently, only `csv` is
+                                             supported and it will output a CSV file with three columns:
+
+                                             1. The qualified flag name.
+                                             2. Either "known" or "unknown".
+                                             3. Either "kept", "finalized", reverted"
+                                             (required)
+    """
+        .trimIndent()
+
+class FlagReportOptionsTest : BaseOptionGroupTest<FlagReportOptions>(FLAG_REPORT_OPTIONS_HELP) {
+    override fun createOptions() = FlagReportOptions()
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/help/HelpCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/help/HelpCommandTest.kt
index 154ee5ed0..507c0a299 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/help/HelpCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/help/HelpCommandTest.kt
@@ -190,6 +190,8 @@ Usage: metalava help historical-api-patterns
   Apart from the {version:extension} all placeholders for this will ignore versions that fall outside the range
   --first-version and --current-version, if provided.
 
+  * `library` - Optional property that stores the name of a library.
+
   * `module` - Optional property that stores the name of the SDK extension module.
 
   Patterns that use a placeholder for this are assumed to be matching files for SDK extensions.
@@ -213,6 +215,9 @@ Usage: metalava help historical-api-patterns
   A pattern that includes this must also include `{module}` as SDK extension APIs are stored in a file per extension
   module.
 
+  * `{library}` - Placeholder for property `library`. Matches a library name which must consist of lower case letters,
+  hyphens and `.`s.
+
   * `{module}` - Placeholder for property `module`. Matches a module name which must consist of lower case letters,
   hyphens and `.`s.
 
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/help/IssuesCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/help/IssuesCommandTest.kt
index f21e7517c..20f551b23 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/help/IssuesCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/help/IssuesCommandTest.kt
@@ -31,201 +31,204 @@ Usage: metalava help issues <issue>?
 
   Provides help related to issues and issue reporting
 
-Available Issues                             |  Category                |   Default Severity
----------------------------------------------+--------------------------+--------------------
-  AbstractInner                              |  api_lint                |   warning
-  AcronymName                                |  api_lint                |   warning
-  ActionValue                                |  api_lint                |   error
-  AddSealed                                  |  compatibility           |   error
-  AddedAbstractMethod                        |  compatibility           |   error
-  AddedAnnotation                            |  compatibility           |   error
-  AddedClass                                 |  compatibility           |   hidden
-  AddedField                                 |  compatibility           |   hidden
-  AddedFinal                                 |  compatibility           |   error
-  AddedFinalUninstantiable                   |  compatibility           |   hidden
-  AddedInterface                             |  compatibility           |   hidden
-  AddedMethod                                |  compatibility           |   hidden
-  AddedPackage                               |  compatibility           |   hidden
-  AddedReified                               |  compatibility           |   error
-  AllUpper                                   |  api_lint                |   error
-  AndroidUri                                 |  api_lint                |   error
-  AnnotationExtraction                       |  unknown                 |   error
-  ArrayReturn                                |  api_lint                |   warning
-  AsyncSuffixFuture                          |  api_lint                |   error
-  AutoBoxing                                 |  api_lint                |   error
-  BadFuture                                  |  api_lint                |   error
-  BannedThrow                                |  api_lint                |   error
-  BecameUnchecked                            |  compatibility           |   error
-  BothPackageInfoAndHtml                     |  documentation           |   warning
-  BroadcastBehavior                          |  documentation           |   error
-  BuilderSetStyle                            |  api_lint                |   warning
-  CallbackInterface                          |  api_lint                |   hidden
-  CallbackMethodName                         |  api_lint                |   error
-  CallbackName                               |  api_lint                |   warning
-  ChangedAbstract                            |  compatibility           |   error
-  ChangedClass                               |  compatibility           |   error
-  ChangedDefault                             |  compatibility           |   error
-  ChangedDeprecated                          |  compatibility           |   hidden
-  ChangedNative                              |  compatibility           |   hidden
-  ChangedScope                               |  compatibility           |   error
-  ChangedStatic                              |  compatibility           |   error
-  ChangedSuperclass                          |  compatibility           |   error
-  ChangedThrows                              |  compatibility           |   error
-  ChangedType                                |  compatibility           |   error
-  ChangedValue                               |  compatibility           |   error
-  ChangedVolatile                            |  compatibility           |   error
-  CompileTimeConstant                        |  api_lint                |   error
-  ConcreteCollection                         |  api_lint                |   error
-  ConditionalRequiresPermissionNotExplained  |  api_lint                |   hidden
-  ConfigFieldName                            |  api_lint                |   error
-  ContextFirst                               |  api_lint                |   error
-  ContextNameSuffix                          |  api_lint                |   error
-  DataClassDefinition                        |  api_lint                |   hidden
-  DefaultValueChange                         |  compatibility           |   error
-  Deprecated                                 |  documentation           |   hidden
-  DeprecationMismatch                        |  documentation           |   error
-  DocumentExceptions                         |  api_lint                |   error
-  DuplicateSourceClass                       |  unknown                 |   warning
-  EndsWithImpl                               |  api_lint                |   error
-  Enum                                       |  api_lint                |   error
-  EqualsAndHashCode                          |  api_lint                |   error
-  ExceptionName                              |  api_lint                |   error
-  ExecutorRegistration                       |  api_lint                |   warning
-  ExtendsDeprecated                          |  api_lint                |   hidden
-  ExtendsError                               |  api_lint                |   error
-  FlaggedApiLiteral                          |  api_lint                |   warning_error_when_new
-  ForbiddenSuperClass                        |  api_lint                |   error
-  ForbiddenTag                               |  documentation           |   error
-  FractionFloat                              |  api_lint                |   error
-  FunRemoval                                 |  compatibility           |   error
-  GenericCallbacks                           |  api_lint                |   error
-  GenericException                           |  api_lint                |   error
-  GetterOnBuilder                            |  api_lint                |   warning
-  GetterSetterNames                          |  api_lint                |   error
-  GetterSetterNullability                    |  api_lint                |   warning_error_when_new
-  HeavyBitSet                                |  api_lint                |   error
-  HiddenAbstractMethod                       |  api_lint                |   error
-  HiddenSuperclass                           |  documentation           |   warning
-  HiddenTypeParameter                        |  documentation           |   warning
-  HiddenTypedefConstant                      |  unknown                 |   error
-  IgnoringSymlink                            |  unknown                 |   info
-  InconsistentMergeAnnotation                |  api_lint                |   warning_error_when_new
-  InfixRemoval                               |  compatibility           |   error
-  InheritChangesSignature                    |  unknown                 |   warning_error_when_new
-  IntDef                                     |  documentation           |   hidden
-  IntentBuilderName                          |  api_lint                |   warning
-  IntentName                                 |  api_lint                |   error
-  InterfaceConstant                          |  api_lint                |   error
-  InternalClasses                            |  api_lint                |   error
-  InternalError                              |  unknown                 |   error
-  InternalField                              |  api_lint                |   error
-  InvalidEnvironmentInRestrictedForEnvironment
-                                             |  api_lint                |   error
-  InvalidFeatureEnforcement                  |  documentation           |   error
-  InvalidNullConversion                      |  compatibility           |   error
-  InvalidNullabilityAnnotation               |  unknown                 |   error
-  InvalidNullabilityAnnotationWarning        |  unknown                 |   warning
-  InvalidNullabilityOverride                 |  api_lint                |   error
-  InvalidPackage                             |  unknown                 |   error
-  InvalidSyntax                              |  unknown                 |   error
-  IoError                                    |  unknown                 |   error
-  KotlinDefaultParameterOrder                |  api_lint                |   error
-  KotlinKeyword                              |  api_lint                |   error
-  KotlinOperator                             |  api_lint                |   info
-  ListenerInterface                          |  api_lint                |   error
-  ListenerLast                               |  api_lint                |   warning
-  ManagerConstructor                         |  api_lint                |   error
-  ManagerLookup                              |  api_lint                |   error
-  MentionsGoogle                             |  api_lint                |   error
-  MethodNameTense                            |  api_lint                |   warning
-  MethodNameUnits                            |  api_lint                |   error
-  MinMaxConstant                             |  api_lint                |   warning
-  MissingBuildMethod                         |  api_lint                |   warning
-  MissingColumn                              |  documentation           |   warning
-  MissingFromValue                           |  api_lint                |   error
-  MissingGetterMatchingBuilder               |  api_lint                |   warning
-  MissingInnerNullability                    |  api_lint                |   hidden
-  MissingJvmstatic                           |  api_lint                |   warning
-  MissingNullability                         |  api_lint                |   error
-  MissingPermission                          |  documentation           |   error
-  MultipleThreadAnnotations                  |  documentation           |   error
-  MutableBareField                           |  api_lint                |   error
-  NoByteOrShort                              |  api_lint                |   warning
-  NoClone                                    |  api_lint                |   error
-  NoSettingsProvider                         |  api_lint                |   hidden
-  NotCloseable                               |  api_lint                |   warning
-  Nullable                                   |  documentation           |   hidden
-  NullableCollection                         |  api_lint                |   warning
-  NullableCollectionElement                  |  api_lint                |   warning
-  OnNameExpected                             |  api_lint                |   warning
-  OperatorRemoval                            |  compatibility           |   error
-  OptionalBuilderConstructorArgument         |  api_lint                |   warning
-  OverlappingConstants                       |  api_lint                |   warning
-  PackageLayering                            |  api_lint                |   warning
-  PairedRegistration                         |  api_lint                |   error
-  ParameterNameChange                        |  compatibility           |   error
-  ParcelConstructor                          |  api_lint                |   error
-  ParcelCreator                              |  api_lint                |   error
-  ParcelNotFinal                             |  api_lint                |   error
-  ParcelableList                             |  api_lint                |   warning
-  ParseError                                 |  unknown                 |   error
-  PercentageInt                              |  api_lint                |   error
-  PrivateSuperclass                          |  documentation           |   warning
-  ProtectedMember                            |  api_lint                |   error
-  PublicTypedef                              |  api_lint                |   error
-  RawAidl                                    |  api_lint                |   error
-  ReferencesDeprecated                       |  api_lint                |   hidden
-  ReferencesHidden                           |  api_lint                |   error
-  RemovedAnnotation                          |  compatibility           |   error
-  RemovedClass                               |  compatibility           |   error
-  RemovedDeprecatedClass                     |  compatibility           |   inherit
-  RemovedDeprecatedField                     |  compatibility           |   inherit
-  RemovedDeprecatedMethod                    |  compatibility           |   inherit
-  RemovedField                               |  compatibility           |   error
-  RemovedFinal                               |  compatibility           |   error
-  RemovedFinalStrict                         |  compatibility           |   error
-  RemovedInterface                           |  compatibility           |   error
-  RemovedJvmDefaultWithCompatibility         |  compatibility           |   error
-  RemovedMethod                              |  compatibility           |   error
-  RemovedPackage                             |  compatibility           |   error
-  RequiresPermission                         |  documentation           |   error
-  ResourceFieldName                          |  api_lint                |   error
-  ResourceStyleFieldName                     |  api_lint                |   error
-  ResourceValueFieldName                     |  api_lint                |   error
-  RethrowRemoteException                     |  api_lint                |   error
-  ReturningUnexpectedConstant                |  unknown                 |   warning
-  SamShouldBeLast                            |  api_lint                |   warning
-  SdkConstant                                |  documentation           |   error
-  ServiceName                                |  api_lint                |   error
-  SetterReturnsThis                          |  api_lint                |   warning
-  ShowingMemberInHiddenClass                 |  api_lint                |   error
-  SignatureFileError                         |  unknown                 |   error
-  SingleMethodInterface                      |  api_lint                |   error
-  SingletonConstructor                       |  api_lint                |   error
-  SingularCallback                           |  api_lint                |   error
-  StartWithLower                             |  api_lint                |   error
-  StartWithUpper                             |  api_lint                |   error
-  StaticFinalBuilder                         |  api_lint                |   warning
-  StaticUtils                                |  api_lint                |   error
-  StreamFiles                                |  api_lint                |   warning
-  SuperfluousPrefix                          |  unknown                 |   warning
-  Todo                                       |  documentation           |   error
-  TopLevelBuilder                            |  api_lint                |   warning
-  UnavailableSymbol                          |  documentation           |   warning
-  UnflaggedApi                               |  api_lint                |   hidden
-  UnhiddenSystemApi                          |  api_lint                |   error
-  UniqueKotlinOperator                       |  api_lint                |   error
-  UnmatchedMergeAnnotation                   |  api_lint                |   error
-  UnqualifiedTypeError                       |  unknown                 |   hidden
-  UnresolvedImport                           |  unknown                 |   info
-  UnresolvedLink                             |  documentation           |   error
-  UseIcu                                     |  api_lint                |   warning
-  UseParcelFileDescriptor                    |  api_lint                |   error
-  UserHandle                                 |  api_lint                |   warning
-  UserHandleName                             |  api_lint                |   warning
-  ValueClassDefinition                       |  api_lint                |   error
-  VarargRemoval                              |  compatibility           |   error
-  VisiblySynchronized                        |  api_lint                |   error
+Available Issues                             |  Category                             |   Default Severity
+---------------------------------------------+---------------------------------------+--------------------
+  AbstractInner                              |  api_lint                             |   warning
+  AcronymName                                |  api_lint                             |   warning
+  ActionValue                                |  api_lint                             |   error
+  AddSealed                                  |  source_compatibility_only            |   error
+  AddedAbstractMethod                        |  binary_and_source_compatibility      |   error
+  AddedAnnotation                            |  other_compatibility                  |   error
+  AddedClass                                 |  other_compatibility                  |   hidden
+  AddedField                                 |  other_compatibility                  |   hidden
+  AddedFinal                                 |  binary_and_source_compatibility      |   error
+  AddedFinalUninstantiable                   |  other_compatibility                  |   hidden
+  AddedInterface                             |  other_compatibility                  |   hidden
+  AddedMethod                                |  other_compatibility                  |   hidden
+  AddedPackage                               |  other_compatibility                  |   hidden
+  AddedReified                               |  binary_compatibility_only            |   error
+  AllUpper                                   |  api_lint                             |   error
+  AndroidUri                                 |  api_lint                             |   error
+  AnnotationExtraction                       |  unknown                              |   error
+  ArrayReturn                                |  api_lint                             |   warning
+  AsyncSuffixFuture                          |  api_lint                             |   error
+  AutoBoxing                                 |  api_lint                             |   error
+  BadFuture                                  |  api_lint                             |   error
+  BannedThrow                                |  api_lint                             |   error
+  BecameUnchecked                            |  other_compatibility                  |   error
+  BothPackageInfoAndHtml                     |  documentation                        |   warning
+  BroadcastBehavior                          |  documentation                        |   error
+  BuilderSetStyle                            |  api_lint                             |   warning
+  CallbackInterface                          |  api_lint                             |   hidden
+  CallbackMethodName                         |  api_lint                             |   error
+  CallbackName                               |  api_lint                             |   warning
+  ChangedAbstract                            |  binary_and_source_compatibility      |   error
+  ChangedClass                               |  binary_and_source_compatibility      |   error
+  ChangedDefault                             |  binary_and_source_compatibility      |   error
+  ChangedDeprecated                          |  source_compatibility_only            |   hidden
+  ChangedNative                              |  other_compatibility                  |   hidden
+  ChangedScope                               |  binary_and_source_compatibility      |   error
+  ChangedStatic                              |  binary_and_source_compatibility      |   error
+  ChangedSuperclass                          |  binary_and_source_compatibility      |   error
+  ChangedThrows                              |  binary_and_source_compatibility      |   error
+  ChangedType                                |  binary_and_source_compatibility      |   error
+  ChangedValue                               |  binary_compatibility_only            |   error
+  ChangedVolatile                            |  other_compatibility                  |   error
+  CompileTimeConstant                        |  api_lint                             |   error
+  ConcreteCollection                         |  api_lint                             |   error
+  ConditionalRequiresPermissionNotExplained  |  api_lint                             |   hidden
+  ConfigFieldName                            |  api_lint                             |   error
+  ContextFirst                               |  api_lint                             |   error
+  ContextNameSuffix                          |  api_lint                             |   error
+  DataClassDefinition                        |  api_lint                             |   hidden
+  DefaultValueChange                         |  source_compatibility_only            |   error
+  Deprecated                                 |  documentation                        |   hidden
+  DeprecationMismatch                        |  documentation                        |   error
+  DocumentExceptions                         |  api_lint                             |   error
+  DuplicateSourceClass                       |  unknown                              |   warning
+  EndsWithImpl                               |  api_lint                             |   error
+  Enum                                       |  api_lint                             |   error
+  EqualsAndHashCode                          |  api_lint                             |   error
+  ExceptionName                              |  api_lint                             |   error
+  ExecutorRegistration                       |  api_lint                             |   warning
+  ExtendsDeprecated                          |  api_lint                             |   hidden
+  ExtendsError                               |  api_lint                             |   error
+  FlaggedApiLiteral                          |  api_lint                             |   warning_error_when_new
+  ForbiddenSuperClass                        |  api_lint                             |   error
+  ForbiddenTag                               |  documentation                        |   error
+  FractionFloat                              |  api_lint                             |   error
+  FunRemoval                                 |  source_compatibility_only            |   error
+  GenericCallbacks                           |  api_lint                             |   error
+  GenericException                           |  api_lint                             |   error
+  GetterOnBuilder                            |  api_lint                             |   warning
+  GetterSetterNames                          |  api_lint                             |   error
+  GetterSetterNullability                    |  api_lint                             |   warning_error_when_new
+  HeavyBitSet                                |  api_lint                             |   error
+  HiddenAbstractMethod                       |  api_lint                             |   error
+  HiddenSuperclass                           |  documentation                        |   warning
+  HiddenTypeParameter                        |  documentation                        |   warning
+  HiddenTypedefConstant                      |  unknown                              |   error
+  IgnoringSymlink                            |  unknown                              |   info
+  InconsistentMergeAnnotation                |  api_lint                             |   warning_error_when_new
+  InfixRemoval                               |  source_compatibility_only            |   error
+  InheritChangesSignature                    |  unknown                              |   warning_error_when_new
+  IntDef                                     |  documentation                        |   hidden
+  IntentBuilderName                          |  api_lint                             |   warning
+  IntentName                                 |  api_lint                             |   error
+  InterfaceConstant                          |  api_lint                             |   error
+  InternalClasses                            |  api_lint                             |   error
+  InternalError                              |  unknown                              |   error
+  InternalField                              |  api_lint                             |   error
+  InvalidFeatureEnforcement                  |  documentation                        |   error
+  InvalidNullConversion                      |  source_compatibility_only            |   error
+  InvalidNullabilityAnnotation               |  unknown                              |   error
+  InvalidNullabilityAnnotationWarning        |  unknown                              |   warning
+  InvalidNullabilityOverride                 |  api_lint                             |   error
+  InvalidPackage                             |  unknown                              |   error
+  InvalidSyntax                              |  unknown                              |   error
+  IoError                                    |  unknown                              |   error
+  KotlinDefaultParameterOrder                |  api_lint                             |   error
+  KotlinKeyword                              |  api_lint                             |   error
+  KotlinOperator                             |  api_lint                             |   info
+  ListenerInterface                          |  api_lint                             |   error
+  ListenerLast                               |  api_lint                             |   warning
+  ManagerConstructor                         |  api_lint                             |   error
+  ManagerLookup                              |  api_lint                             |   error
+  MentionsGoogle                             |  api_lint                             |   error
+  MethodNameTense                            |  api_lint                             |   warning
+  MethodNameUnits                            |  api_lint                             |   error
+  MinMaxConstant                             |  api_lint                             |   warning
+  MissingBuildMethod                         |  api_lint                             |   warning
+  MissingColumn                              |  documentation                        |   warning
+  MissingEnvironmentsValue                   |  api_lint                             |   error
+  MissingFromValue                           |  api_lint                             |   error
+  MissingGetterMatchingBuilder               |  api_lint                             |   warning
+  MissingInnerNullability                    |  api_lint                             |   hidden
+  MissingJvmstatic                           |  api_lint                             |   warning
+  MissingNullability                         |  api_lint                             |   error
+  MissingPermission                          |  documentation                        |   error
+  MultipleThreadAnnotations                  |  documentation                        |   error
+  MutableBareField                           |  api_lint                             |   error
+  NoByteOrShort                              |  api_lint                             |   warning
+  NoClone                                    |  api_lint                             |   error
+  NoSettingsProvider                         |  api_lint                             |   hidden
+  NotCloseable                               |  api_lint                             |   warning
+  Nullable                                   |  documentation                        |   hidden
+  NullableCollection                         |  api_lint                             |   warning
+  NullableCollectionElement                  |  api_lint                             |   warning
+  OnNameExpected                             |  api_lint                             |   warning
+  OperatorRemoval                            |  source_compatibility_only            |   error
+  OptionalBuilderConstructorArgument         |  api_lint                             |   warning
+  OverlappingConstants                       |  api_lint                             |   warning
+  PackageLayering                            |  api_lint                             |   warning
+  PairedRegistration                         |  api_lint                             |   error
+  ParameterNameChange                        |  source_compatibility_only            |   error
+  ParcelConstructor                          |  api_lint                             |   error
+  ParcelCreator                              |  api_lint                             |   error
+  ParcelNotFinal                             |  api_lint                             |   error
+  ParcelableList                             |  api_lint                             |   warning
+  ParseError                                 |  unknown                              |   error
+  PercentageInt                              |  api_lint                             |   error
+  PrivateSuperclass                          |  documentation                        |   warning
+  ProtectedMember                            |  api_lint                             |   error
+  PublicTypedef                              |  api_lint                             |   error
+  RawAidl                                    |  api_lint                             |   error
+  ReferencesDeprecated                       |  api_lint                             |   hidden
+  ReferencesHidden                           |  api_lint                             |   error
+  RemovedAnnotation                          |  other_compatibility                  |   error
+  RemovedClass                               |  binary_and_source_compatibility      |   error
+  RemovedDeprecatedClass                     |  binary_and_source_compatibility      |   inherit
+  RemovedDeprecatedField                     |  binary_and_source_compatibility      |   inherit
+  RemovedDeprecatedMethod                    |  binary_and_source_compatibility      |   inherit
+  RemovedField                               |  binary_and_source_compatibility      |   error
+  RemovedFinal                               |  binary_compatibility_only            |   error
+  RemovedFinalStrict                         |  other_compatibility                  |   error
+  RemovedFromBytecode                        |  binary_compatibility_only            |   error
+  RemovedFromJava                            |  source_compatibility_only            |   error
+  RemovedFromKotlin                          |  source_compatibility_only            |   error
+  RemovedInterface                           |  binary_and_source_compatibility      |   error
+  RemovedJvmDefaultWithCompatibility         |  binary_compatibility_only            |   error
+  RemovedMethod                              |  binary_and_source_compatibility      |   error
+  RemovedPackage                             |  binary_and_source_compatibility      |   error
+  RequiresPermission                         |  documentation                        |   error
+  ResourceFieldName                          |  api_lint                             |   error
+  ResourceStyleFieldName                     |  api_lint                             |   error
+  ResourceValueFieldName                     |  api_lint                             |   error
+  RethrowRemoteException                     |  api_lint                             |   error
+  ReturningUnexpectedConstant                |  unknown                              |   warning
+  SamShouldBeLast                            |  api_lint                             |   warning
+  SdkConstant                                |  documentation                        |   error
+  ServiceName                                |  api_lint                             |   error
+  SetterReturnsThis                          |  api_lint                             |   warning
+  ShowingMemberInHiddenClass                 |  api_lint                             |   error
+  SignatureFileError                         |  unknown                              |   error
+  SingleMethodInterface                      |  api_lint                             |   error
+  SingletonConstructor                       |  api_lint                             |   error
+  SingularCallback                           |  api_lint                             |   error
+  StartWithLower                             |  api_lint                             |   error
+  StartWithUpper                             |  api_lint                             |   error
+  StaticFinalBuilder                         |  api_lint                             |   warning
+  StaticUtils                                |  api_lint                             |   error
+  StreamFiles                                |  api_lint                             |   warning
+  SuperfluousPrefix                          |  unknown                              |   warning
+  Todo                                       |  documentation                        |   error
+  TopLevelBuilder                            |  api_lint                             |   warning
+  TypeParseError                             |  unknown                              |   error
+  UnavailableSymbol                          |  documentation                        |   warning
+  UnflaggedApi                               |  api_lint                             |   hidden
+  UnhiddenSystemApi                          |  api_lint                             |   error
+  UniqueKotlinOperator                       |  api_lint                             |   error
+  UnmatchedMergeAnnotation                   |  api_lint                             |   error
+  UnqualifiedTypeError                       |  unknown                              |   hidden
+  UnresolvedImport                           |  unknown                              |   info
+  UnresolvedLink                             |  documentation                        |   error
+  UseIcu                                     |  api_lint                             |   warning
+  UseParcelFileDescriptor                    |  api_lint                             |   error
+  UserHandle                                 |  api_lint                             |   warning
+  UserHandleName                             |  api_lint                             |   warning
+  ValueClassDefinition                       |  api_lint                             |   error
+  VarargRemoval                              |  binary_and_source_compatibility      |   error
+  VisiblySynchronized                        |  api_lint                             |   error
 """
                     .trimIndent()
         }
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/signature/MergeSignaturesCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/signature/MergeSignaturesCommandTest.kt
index 06a9192f0..89579cbb9 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/signature/MergeSignaturesCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/signature/MergeSignaturesCommandTest.kt
@@ -408,9 +408,10 @@ Arguments:
             source1,
             source2,
             format = FileFormat.V4,
-            expectedOutput = """
-            // Signature format: 4.0
-            """,
+            expectedOutput =
+                """
+                    // Signature format: 4.0
+                """,
         )
     }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/signature/UpdateSignatureHeaderCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/signature/UpdateSignatureHeaderCommandTest.kt
index 3e53a129a..0b797752d 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/signature/UpdateSignatureHeaderCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/signature/UpdateSignatureHeaderCommandTest.kt
@@ -109,11 +109,13 @@ Arguments:
     @Test
     fun `Update signature (blank to v2)`() {
         checkUpdateSignatures(
-            contents = """
+            contents =
+                """
 
                 """,
             format = FileFormat.V2,
-            expectedOutput = """
+            expectedOutput =
+                """
 
                 """,
         )
@@ -150,7 +152,8 @@ Arguments:
     @Test
     fun `Update signature (wrong file to v3)`() {
         checkUpdateSignatures(
-            contents = """
+            contents =
+                """
                     Wrong file
                 """,
             format = FileFormat.V4,
diff --git a/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckAndroidApisTest.kt b/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckAndroidApisTest.kt
index c289821c1..a9af2d610 100644
--- a/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckAndroidApisTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckAndroidApisTest.kt
@@ -67,7 +67,7 @@ abstract class CompatibilityCheckAndroidApisTest(
                 ApiLevelCheck(
                     5,
                     """
-                        load-api.txt:14736: warning: Method android.view.Surface.lockCanvas added thrown exception java.lang.IllegalArgumentException [ChangedThrows]
+                        load-api.txt:14736: warning: Binary breaking change: Method android.view.Surface.lockCanvas added thrown exception java.lang.IllegalArgumentException [ChangedThrows]
                     """,
                     hide(
                         DEFAULT_HIDDEN_ISSUES_STRING,
@@ -77,9 +77,9 @@ abstract class CompatibilityCheckAndroidApisTest(
                 ApiLevelCheck(
                     6,
                     """
-                        load-api.txt:1321: warning: Method android.accounts.AbstractAccountAuthenticator.confirmCredentials added thrown exception android.accounts.NetworkErrorException [ChangedThrows]
-                        load-api.txt:1328: warning: Method android.accounts.AbstractAccountAuthenticator.updateCredentials added thrown exception android.accounts.NetworkErrorException [ChangedThrows]
-                        load-api.txt:15728: warning: Field android.view.WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL has changed value from 2008 to 2014 [ChangedValue]
+                        load-api.txt:1321: warning: Binary breaking change: Method android.accounts.AbstractAccountAuthenticator.confirmCredentials added thrown exception android.accounts.NetworkErrorException [ChangedThrows]
+                        load-api.txt:1328: warning: Binary breaking change: Method android.accounts.AbstractAccountAuthenticator.updateCredentials added thrown exception android.accounts.NetworkErrorException [ChangedThrows]
+                        load-api.txt:15728: warning: Binary breaking change: Field android.view.WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL has changed value from 2008 to 2014 [ChangedValue]
                     """,
                     hide(
                         DEFAULT_HIDDEN_ISSUES_STRING,
@@ -92,7 +92,7 @@ abstract class CompatibilityCheckAndroidApisTest(
                 ApiLevelCheck(
                     7,
                     """
-                        released-api.txt:15404: error: Removed field android.view.ViewGroup.FLAG_USE_CHILD_DRAWING_ORDER [RemovedField]
+                        released-api.txt:15404: error: Binary breaking change: Removed field android.view.ViewGroup.FLAG_USE_CHILD_DRAWING_ORDER [RemovedField]
                     """,
                     hide(
                         "AddedClass",
@@ -106,31 +106,31 @@ abstract class CompatibilityCheckAndroidApisTest(
                 ApiLevelCheck(
                     8,
                     """
-                        load-api.txt:2901: warning: Method android.content.ComponentName.clone no longer throws exception java.lang.CloneNotSupportedException [ChangedThrows]
-                        load-api.txt:2901: error: Method android.content.ComponentName.clone has changed return type from java.lang.Object to android.content.ComponentName [ChangedType]
-                        load-api.txt:5169: warning: Method android.gesture.Gesture.clone no longer throws exception java.lang.CloneNotSupportedException [ChangedThrows]
-                        load-api.txt:5281: warning: Method android.gesture.GesturePoint.clone no longer throws exception java.lang.CloneNotSupportedException [ChangedThrows]
-                        load-api.txt:5313: warning: Method android.gesture.GestureStroke.clone no longer throws exception java.lang.CloneNotSupportedException [ChangedThrows]
-                        load-api.txt:8395: warning: Constructor android.net.SSLCertificateSocketFactory no longer throws exception java.security.KeyManagementException [ChangedThrows]
-                        load-api.txt:8395: warning: Constructor android.net.SSLCertificateSocketFactory no longer throws exception java.security.NoSuchAlgorithmException [ChangedThrows]
-                        load-api.txt:24974: warning: Constructor java.nio.charset.Charset no longer throws exception java.nio.charset.IllegalCharsetNameException [ChangedThrows]
-                        load-api.txt:24987: warning: Method java.nio.charset.Charset.forName no longer throws exception java.nio.charset.IllegalCharsetNameException [ChangedThrows]
-                        load-api.txt:24987: warning: Method java.nio.charset.Charset.forName no longer throws exception java.nio.charset.UnsupportedCharsetException [ChangedThrows]
-                        load-api.txt:24990: warning: Method java.nio.charset.Charset.isSupported no longer throws exception java.nio.charset.IllegalCharsetNameException [ChangedThrows]
-                        load-api.txt:30437: warning: Method java.util.regex.Matcher.appendReplacement no longer throws exception java.lang.IllegalStateException [ChangedThrows]
-                        load-api.txt:30462: warning: Method java.util.regex.Matcher.start no longer throws exception java.lang.IllegalStateException [ChangedThrows]
-                        load-api.txt:30471: warning: Method java.util.regex.Pattern.compile no longer throws exception java.util.regex.PatternSyntaxException [ChangedThrows]
-                        load-api.txt:32652: warning: Class javax.xml.XMLConstants added 'final' qualifier [AddedFinal]
-                        load-api.txt:32849: warning: Method javax.xml.parsers.DocumentBuilder.isXIncludeAware no longer throws exception java.lang.UnsupportedOperationException [ChangedThrows]
-                        load-api.txt:32874: warning: Method javax.xml.parsers.DocumentBuilderFactory.newInstance no longer throws exception javax.xml.parsers.FactoryConfigurationError [ChangedThrows]
-                        load-api.txt:32908: warning: Method javax.xml.parsers.SAXParser.isXIncludeAware no longer throws exception java.lang.UnsupportedOperationException [ChangedThrows]
-                        load-api.txt:32930: warning: Method javax.xml.parsers.SAXParserFactory.newInstance no longer throws exception javax.xml.parsers.FactoryConfigurationError [ChangedThrows]
-                        load-api.txt:37246: warning: Method org.w3c.dom.Element.getAttributeNS added thrown exception org.w3c.dom.DOMException [ChangedThrows]
-                        load-api.txt:37248: warning: Method org.w3c.dom.Element.getAttributeNodeNS added thrown exception org.w3c.dom.DOMException [ChangedThrows]
-                        load-api.txt:37250: warning: Method org.w3c.dom.Element.getElementsByTagNameNS added thrown exception org.w3c.dom.DOMException [ChangedThrows]
-                        load-api.txt:37254: warning: Method org.w3c.dom.Element.hasAttributeNS added thrown exception org.w3c.dom.DOMException [ChangedThrows]
-                        load-api.txt:37290: warning: Method org.w3c.dom.NamedNodeMap.getNamedItemNS added thrown exception org.w3c.dom.DOMException [ChangedThrows]
-                        released-api.txt:31151: error: Removed constructor javax.xml.XMLConstants() [RemovedMethod]
+                        load-api.txt:2901: warning: Binary breaking change: Method android.content.ComponentName.clone no longer throws exception java.lang.CloneNotSupportedException [ChangedThrows]
+                        load-api.txt:2901: error: Binary breaking change: Method android.content.ComponentName.clone has changed return type from java.lang.Object to android.content.ComponentName [ChangedType]
+                        load-api.txt:5169: warning: Binary breaking change: Method android.gesture.Gesture.clone no longer throws exception java.lang.CloneNotSupportedException [ChangedThrows]
+                        load-api.txt:5281: warning: Binary breaking change: Method android.gesture.GesturePoint.clone no longer throws exception java.lang.CloneNotSupportedException [ChangedThrows]
+                        load-api.txt:5313: warning: Binary breaking change: Method android.gesture.GestureStroke.clone no longer throws exception java.lang.CloneNotSupportedException [ChangedThrows]
+                        load-api.txt:8395: warning: Binary breaking change: Constructor android.net.SSLCertificateSocketFactory no longer throws exception java.security.KeyManagementException [ChangedThrows]
+                        load-api.txt:8395: warning: Binary breaking change: Constructor android.net.SSLCertificateSocketFactory no longer throws exception java.security.NoSuchAlgorithmException [ChangedThrows]
+                        load-api.txt:24974: warning: Binary breaking change: Constructor java.nio.charset.Charset no longer throws exception java.nio.charset.IllegalCharsetNameException [ChangedThrows]
+                        load-api.txt:24987: warning: Binary breaking change: Method java.nio.charset.Charset.forName no longer throws exception java.nio.charset.IllegalCharsetNameException [ChangedThrows]
+                        load-api.txt:24987: warning: Binary breaking change: Method java.nio.charset.Charset.forName no longer throws exception java.nio.charset.UnsupportedCharsetException [ChangedThrows]
+                        load-api.txt:24990: warning: Binary breaking change: Method java.nio.charset.Charset.isSupported no longer throws exception java.nio.charset.IllegalCharsetNameException [ChangedThrows]
+                        load-api.txt:30437: warning: Binary breaking change: Method java.util.regex.Matcher.appendReplacement no longer throws exception java.lang.IllegalStateException [ChangedThrows]
+                        load-api.txt:30462: warning: Binary breaking change: Method java.util.regex.Matcher.start no longer throws exception java.lang.IllegalStateException [ChangedThrows]
+                        load-api.txt:30471: warning: Binary breaking change: Method java.util.regex.Pattern.compile no longer throws exception java.util.regex.PatternSyntaxException [ChangedThrows]
+                        load-api.txt:32652: warning: Binary breaking change: Class javax.xml.XMLConstants added 'final' qualifier [AddedFinal]
+                        load-api.txt:32849: warning: Binary breaking change: Method javax.xml.parsers.DocumentBuilder.isXIncludeAware no longer throws exception java.lang.UnsupportedOperationException [ChangedThrows]
+                        load-api.txt:32874: warning: Binary breaking change: Method javax.xml.parsers.DocumentBuilderFactory.newInstance no longer throws exception javax.xml.parsers.FactoryConfigurationError [ChangedThrows]
+                        load-api.txt:32908: warning: Binary breaking change: Method javax.xml.parsers.SAXParser.isXIncludeAware no longer throws exception java.lang.UnsupportedOperationException [ChangedThrows]
+                        load-api.txt:32930: warning: Binary breaking change: Method javax.xml.parsers.SAXParserFactory.newInstance no longer throws exception javax.xml.parsers.FactoryConfigurationError [ChangedThrows]
+                        load-api.txt:37246: warning: Binary breaking change: Method org.w3c.dom.Element.getAttributeNS added thrown exception org.w3c.dom.DOMException [ChangedThrows]
+                        load-api.txt:37248: warning: Binary breaking change: Method org.w3c.dom.Element.getAttributeNodeNS added thrown exception org.w3c.dom.DOMException [ChangedThrows]
+                        load-api.txt:37250: warning: Binary breaking change: Method org.w3c.dom.Element.getElementsByTagNameNS added thrown exception org.w3c.dom.DOMException [ChangedThrows]
+                        load-api.txt:37254: warning: Binary breaking change: Method org.w3c.dom.Element.hasAttributeNS added thrown exception org.w3c.dom.DOMException [ChangedThrows]
+                        load-api.txt:37290: warning: Binary breaking change: Method org.w3c.dom.NamedNodeMap.getNamedItemNS added thrown exception org.w3c.dom.DOMException [ChangedThrows]
+                        released-api.txt:31151: error: Binary breaking change: Removed constructor javax.xml.XMLConstants() [RemovedMethod]
                     """,
                     hide(
                         DEFAULT_HIDDEN_ISSUES_STRING,
@@ -144,11 +144,11 @@ abstract class CompatibilityCheckAndroidApisTest(
                 ApiLevelCheck(
                     18,
                     """
-                        load-api.txt:6910: error: Added method android.content.pm.PackageManager.getPackagesHoldingPermissions(String[],int) [AddedAbstractMethod]
-                        load-api.txt:29746: error: Added method android.widget.MediaController.MediaPlayerControl.getAudioSessionId() [AddedAbstractMethod]
-                        released-api.txt:16414: error: Removed field android.os.Process.BLUETOOTH_GID [RemovedField]
-                        released-api.txt:19681: error: Removed class android.renderscript.Program [RemovedClass]
-                        released-api.txt:19763: error: Removed class android.renderscript.ProgramStore [RemovedClass]
+                        load-api.txt:6910: error: Binary breaking change: Added method android.content.pm.PackageManager.getPackagesHoldingPermissions(String[],int) [AddedAbstractMethod]
+                        load-api.txt:29746: error: Binary breaking change: Added method android.widget.MediaController.MediaPlayerControl.getAudioSessionId() [AddedAbstractMethod]
+                        released-api.txt:16414: error: Binary breaking change: Removed field android.os.Process.BLUETOOTH_GID [RemovedField]
+                        released-api.txt:19681: error: Binary breaking change: Removed class android.renderscript.Program [RemovedClass]
+                        released-api.txt:19763: error: Binary breaking change: Removed class android.renderscript.ProgramStore [RemovedClass]
                     """,
                     hide(
                         "AddedClass",
@@ -167,19 +167,19 @@ abstract class CompatibilityCheckAndroidApisTest(
                 ApiLevelCheck(
                     19,
                     """
-                        load-api.txt:29409: warning: Field android.view.animation.Transformation.TYPE_ALPHA has added 'final' qualifier [AddedFinal]
-                        load-api.txt:29409: warning: Field android.view.animation.Transformation.TYPE_ALPHA has changed value from nothing/not constant to 1 [ChangedValue]
-                        load-api.txt:29410: warning: Field android.view.animation.Transformation.TYPE_BOTH has added 'final' qualifier [AddedFinal]
-                        load-api.txt:29410: warning: Field android.view.animation.Transformation.TYPE_BOTH has changed value from nothing/not constant to 3 [ChangedValue]
-                        load-api.txt:29411: warning: Field android.view.animation.Transformation.TYPE_IDENTITY has added 'final' qualifier [AddedFinal]
-                        load-api.txt:29411: warning: Field android.view.animation.Transformation.TYPE_IDENTITY has changed value from nothing/not constant to 0 [ChangedValue]
-                        load-api.txt:29412: warning: Field android.view.animation.Transformation.TYPE_MATRIX has added 'final' qualifier [AddedFinal]
-                        load-api.txt:29412: warning: Field android.view.animation.Transformation.TYPE_MATRIX has changed value from nothing/not constant to 2 [ChangedValue]
-                        load-api.txt:37259: warning: Method java.nio.CharBuffer.subSequence has changed return type from java.lang.CharSequence to java.nio.CharBuffer [ChangedType]
-                        released-api.txt:16986: error: Removed method android.os.Debug.MemoryInfo.getOtherLabel(int) [RemovedMethod]
-                        released-api.txt:16987: error: Removed method android.os.Debug.MemoryInfo.getOtherPrivateDirty(int) [RemovedMethod]
-                        released-api.txt:16988: error: Removed method android.os.Debug.MemoryInfo.getOtherPss(int) [RemovedMethod]
-                        released-api.txt:16989: error: Removed method android.os.Debug.MemoryInfo.getOtherSharedDirty(int) [RemovedMethod]
+                        load-api.txt:29409: warning: Binary breaking change: Field android.view.animation.Transformation.TYPE_ALPHA has added 'final' qualifier [AddedFinal]
+                        load-api.txt:29409: warning: Binary breaking change: Field android.view.animation.Transformation.TYPE_ALPHA has changed value from nothing/not constant to 1 [ChangedValue]
+                        load-api.txt:29410: warning: Binary breaking change: Field android.view.animation.Transformation.TYPE_BOTH has added 'final' qualifier [AddedFinal]
+                        load-api.txt:29410: warning: Binary breaking change: Field android.view.animation.Transformation.TYPE_BOTH has changed value from nothing/not constant to 3 [ChangedValue]
+                        load-api.txt:29411: warning: Binary breaking change: Field android.view.animation.Transformation.TYPE_IDENTITY has added 'final' qualifier [AddedFinal]
+                        load-api.txt:29411: warning: Binary breaking change: Field android.view.animation.Transformation.TYPE_IDENTITY has changed value from nothing/not constant to 0 [ChangedValue]
+                        load-api.txt:29412: warning: Binary breaking change: Field android.view.animation.Transformation.TYPE_MATRIX has added 'final' qualifier [AddedFinal]
+                        load-api.txt:29412: warning: Binary breaking change: Field android.view.animation.Transformation.TYPE_MATRIX has changed value from nothing/not constant to 2 [ChangedValue]
+                        load-api.txt:37259: warning: Binary breaking change: Method java.nio.CharBuffer.subSequence has changed return type from java.lang.CharSequence to java.nio.CharBuffer [ChangedType]
+                        released-api.txt:16986: error: Binary breaking change: Removed method android.os.Debug.MemoryInfo.getOtherLabel(int) [RemovedMethod]
+                        released-api.txt:16987: error: Binary breaking change: Removed method android.os.Debug.MemoryInfo.getOtherPrivateDirty(int) [RemovedMethod]
+                        released-api.txt:16988: error: Binary breaking change: Removed method android.os.Debug.MemoryInfo.getOtherPss(int) [RemovedMethod]
+                        released-api.txt:16989: error: Binary breaking change: Removed method android.os.Debug.MemoryInfo.getOtherSharedDirty(int) [RemovedMethod]
                     """,
                     // The last warning above is not right; seems to be a PSI jar loading bug. It
                     // returns the wrong return type!
@@ -196,9 +196,9 @@ abstract class CompatibilityCheckAndroidApisTest(
                 ApiLevelCheck(
                     20,
                     """
-                        load-api.txt:51010: warning: Method org.json.JSONObject.keys has changed return type from java.util.Iterator to java.util.Iterator<java.lang.String> [ChangedType]
-                        load-api.txt:52002: warning: Field org.xmlpull.v1.XmlPullParserFactory.features has changed type from java.util.HashMap to java.util.HashMap<java.lang.String,java.lang.Boolean> [ChangedType]
-                        released-api.txt:26148: error: Removed method android.util.TypedValue.complexToDimensionNoisy(int,android.util.DisplayMetrics) [RemovedMethod]
+                        load-api.txt:51010: warning: Binary breaking change: Method org.json.JSONObject.keys has changed return type from java.util.Iterator to java.util.Iterator<java.lang.String> [ChangedType]
+                        load-api.txt:52002: warning: Binary breaking change: Field org.xmlpull.v1.XmlPullParserFactory.features has changed type from java.util.HashMap to java.util.HashMap<java.lang.String,java.lang.Boolean> [ChangedType]
+                        released-api.txt:26148: error: Binary breaking change: Removed method android.util.TypedValue.complexToDimensionNoisy(int,android.util.DisplayMetrics) [RemovedMethod]
                     """,
                     hide(
                         DEFAULT_HIDDEN_ISSUES_STRING,
@@ -211,8 +211,8 @@ abstract class CompatibilityCheckAndroidApisTest(
                 ApiLevelCheck(
                     26,
                     """
-                        load-api.txt:3941: warning: Field android.app.ActivityManager.RunningAppProcessInfo.IMPORTANCE_PERCEPTIBLE has changed value from 130 to 230 [ChangedValue]
-                        load-api.txt:10848: warning: Field android.content.pm.PermissionInfo.PROTECTION_MASK_FLAGS has changed value from 4080 to 65520 [ChangedValue]
+                        load-api.txt:3941: warning: Binary breaking change: Field android.app.ActivityManager.RunningAppProcessInfo.IMPORTANCE_PERCEPTIBLE has changed value from 130 to 230 [ChangedValue]
+                        load-api.txt:10848: warning: Binary breaking change: Field android.content.pm.PermissionInfo.PROTECTION_MASK_FLAGS has changed value from 4080 to 65520 [ChangedValue]
                     """,
                     hide(
                         "AddedAbstractMethod",
@@ -272,7 +272,8 @@ abstract class CompatibilityCheckAndroidApisTest(
             val apiLevel = apiLevelCheck.apiLevel
             val expectedIssues = apiLevelCheck.expectedIssues
             val expectedFail =
-                if (expectedIssues.contains("error: ")) "Aborting: Found compatibility problems"
+                if (expectedIssues.contains("error: Binary breaking change: "))
+                    "Aborting: Found compatibility problems"
                 else ""
             val extraArgs = apiLevelCheck.extraArgs.toTypedArray()
 
diff --git a/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckBaselineTest.kt b/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckBaselineTest.kt
index dd429eea8..7e13ea1f4 100644
--- a/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckBaselineTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckBaselineTest.kt
@@ -26,7 +26,7 @@ class CompatibilityCheckBaselineTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:2: error: Removed package test.pkg [RemovedPackage]
+                released-api.txt:2: error: Binary breaking change: Removed package test.pkg [RemovedPackage]
                 """,
             errorMessageCheckCompatibilityReleased = "*** release-api check failed ***",
             checkCompatibilityApiReleased =
@@ -36,7 +36,8 @@ class CompatibilityCheckBaselineTest : DriverTest() {
                   }
                 }
                 """,
-            signatureSource = """
+            signatureSource =
+                """
                 """,
             expectedFail =
                 """
@@ -50,7 +51,8 @@ class CompatibilityCheckBaselineTest : DriverTest() {
     fun `Test released-API check, with global baseline`() {
         // Global baseline works on released api check.
         check(
-            expectedIssues = """
+            expectedIssues =
+                """
                 """,
             baselineTestInfo =
                 BaselineTestInfo(
@@ -82,7 +84,8 @@ class CompatibilityCheckBaselineTest : DriverTest() {
     fun `Test released-API check, with compatibility-released baseline`() {
         // Use released-API check baseline, which should work in released-API check.
         check(
-            expectedIssues = """
+            expectedIssues =
+                """
                 """,
             baselineCheckCompatibilityReleasedTestInfo =
                 BaselineTestInfo(
@@ -90,7 +93,7 @@ class CompatibilityCheckBaselineTest : DriverTest() {
                         """
                             // Baseline format: 1.0
                             ChangedScope: test.pkg.MyTest1:
-                                Class test.pkg.MyTest1 changed visibility from public to private
+                                Binary breaking change: Class test.pkg.MyTest1 changed visibility from public to private
                         """,
                 ),
             checkCompatibilityApiReleased =
@@ -122,7 +125,7 @@ class CompatibilityCheckBaselineTest : DriverTest() {
                         """
                             // Baseline format: 1.0
                             ChangedScope: test.pkg.MyTest1:
-                                Class test.pkg.MyTest1 changed visibility from public to private
+                                Binary breaking change: Class test.pkg.MyTest1 changed visibility from public to private
                         """,
                 ),
             checkCompatibilityApiReleased =
diff --git a/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckTest.kt b/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckTest.kt
index 5ab5badd3..264c64e54 100644
--- a/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckTest.kt
@@ -20,6 +20,7 @@ import com.android.tools.lint.checks.infrastructure.TestFiles.base64gzip
 import com.android.tools.metalava.ARG_SHOW_ANNOTATION
 import com.android.tools.metalava.ARG_SHOW_UNANNOTATED
 import com.android.tools.metalava.DriverTest
+import com.android.tools.metalava.SystemApiType
 import com.android.tools.metalava.androidxNonNullSource
 import com.android.tools.metalava.androidxNullableSource
 import com.android.tools.metalava.cli.common.ARG_ERROR_CATEGORY
@@ -45,8 +46,8 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:3: error: Class test.pkg.MyTest1 changed class/interface declaration [ChangedClass]
-                load-api.txt:5: error: Class test.pkg.MyTest2 changed class/interface declaration [ChangedClass]
+                load-api.txt:3: error: Binary breaking change: Class test.pkg.MyTest1 changed class/interface declaration [ChangedClass]
+                load-api.txt:5: error: Binary breaking change: Class test.pkg.MyTest2 changed class/interface declaration [ChangedClass]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -84,8 +85,8 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:3: error: Class test.pkg.MyTest1 changed class/interface declaration [ChangedClass]
-                load-api.txt:5: error: Class test.pkg.MyTest2 changed class/interface declaration [ChangedClass]
+                load-api.txt:3: error: Binary breaking change: Class test.pkg.MyTest1 changed class/interface declaration [ChangedClass]
+                load-api.txt:5: error: Binary breaking change: Class test.pkg.MyTest2 changed class/interface declaration [ChangedClass]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -123,9 +124,9 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:4: error: Removed method test.pkg.MyTest1.method(Float) [RemovedMethod]
-                released-api.txt:5: error: Removed field test.pkg.MyTest1.field [RemovedField]
-                released-api.txt:7: error: Removed class test.pkg.MyTest2 [RemovedClass]
+                released-api.txt:4: error: Binary breaking change: Removed method test.pkg.MyTest1.method(Float) [RemovedMethod]
+                released-api.txt:5: error: Binary breaking change: Removed field test.pkg.MyTest1.field [RemovedField]
+                released-api.txt:7: error: Binary breaking change: Removed class test.pkg.MyTest2 [RemovedClass]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -186,7 +187,7 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/Foo.kt:4: error: Cannot remove `operator` modifier from method test.pkg.Foo.plus(String): Incompatible change [OperatorRemoval]
+                src/test/pkg/Foo.kt:4: error: Source breaking change: Cannot remove `operator` modifier from method test.pkg.Foo.plus(String): Incompatible change [OperatorRemoval]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -219,7 +220,7 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/test.kt:3: error: Changing from varargs to array is an incompatible change: parameter x in test.pkg.TestKt.method2(int[] x) [VarargRemoval]
+                src/test/pkg/test.kt:3: error: Binary breaking change: Changing from varargs to array is an incompatible change: parameter x in test.pkg.TestKt.method2(int[] x) [VarargRemoval]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -342,11 +343,11 @@ class CompatibilityCheckTest : DriverTest() {
                 """,
             expectedIssues =
                 """
-                released-api.txt:3: error: Removed class test.pkg.FacetProvider [RemovedInterface]
-                released-api.txt:6: error: Removed class test.pkg.FacetProviderAdapter [RemovedInterface]
-                src/test/pkg/FacetProviderAdapterImpl.java:6: error: Attempted to remove nullability from test.pkg.FacetProvider (was NULLABLE) in method test.pkg.FacetProviderAdapterImpl.getFacetProvider(int) [InvalidNullConversion]
-                src/test/pkg/FacetProviderAdapterImpl.java:13: error: Attempted to remove nullability from java.lang.Class<?> (was NULLABLE) in parameter facetClass in test.pkg.FacetProviderAdapterImpl.FacetProviderImpl.getFacet(Class<?> facetClass) [InvalidNullConversion]
-                src/test/pkg/FacetProviderAdapterImpl.java:13: error: Attempted to remove nullability from java.lang.Object (was NULLABLE) in method test.pkg.FacetProviderAdapterImpl.FacetProviderImpl.getFacet(Class<?>) [InvalidNullConversion]
+                released-api.txt:3: error: Binary breaking change: Removed class test.pkg.FacetProvider [RemovedInterface]
+                released-api.txt:6: error: Binary breaking change: Removed class test.pkg.FacetProviderAdapter [RemovedInterface]
+                src/test/pkg/FacetProviderAdapterImpl.java:6: error: Source breaking change: Attempted to remove nullability from test.pkg.FacetProvider (was NULLABLE) in method test.pkg.FacetProviderAdapterImpl.getFacetProvider(int) [InvalidNullConversion]
+                src/test/pkg/FacetProviderAdapterImpl.java:13: error: Source breaking change: Attempted to remove nullability from java.lang.Class<?> (was NULLABLE) in parameter facetClass in test.pkg.FacetProviderAdapterImpl.FacetProviderImpl.getFacet(Class<?> facetClass) [InvalidNullConversion]
+                src/test/pkg/FacetProviderAdapterImpl.java:13: error: Source breaking change: Attempted to remove nullability from java.lang.Object (was NULLABLE) in method test.pkg.FacetProviderAdapterImpl.FacetProviderImpl.getFacet(Class<?>) [InvalidNullConversion]
             """
         )
     }
@@ -360,10 +361,10 @@ class CompatibilityCheckTest : DriverTest() {
             extraArguments = arrayOf("--error", Issues.ADDED_FINAL_UNINSTANTIABLE.name),
             expectedIssues =
                 """
-                src/test/pkg/Java.java:2: error: Class test.pkg.Java added 'final' qualifier [AddedFinal]
-                src/test/pkg/Java.java:4: error: Method test.pkg.Java.method has added 'final' qualifier [AddedFinal]
-                src/test/pkg/Kotlin.kt:3: error: Class test.pkg.Kotlin added 'final' qualifier [AddedFinal]
-                src/test/pkg/Kotlin.kt:4: error: Method test.pkg.Kotlin.method has added 'final' qualifier [AddedFinal]
+                src/test/pkg/Java.java:2: error: Binary breaking change: Class test.pkg.Java added 'final' qualifier [AddedFinal]
+                src/test/pkg/Java.java:4: error: Binary breaking change: Method test.pkg.Java.method has added 'final' qualifier [AddedFinal]
+                src/test/pkg/Kotlin.kt:3: error: Binary breaking change: Class test.pkg.Kotlin added 'final' qualifier [AddedFinal]
+                src/test/pkg/Kotlin.kt:4: error: Binary breaking change: Method test.pkg.Kotlin.method has added 'final' qualifier [AddedFinal]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -463,8 +464,8 @@ class CompatibilityCheckTest : DriverTest() {
             extraArguments = arrayOf("--error", Issues.ADDED_FINAL_UNINSTANTIABLE.name),
             expectedIssues =
                 """
-                src/test/pkg/Java.java:4: error: Method test.pkg.Java.method has added 'final' qualifier [AddedFinal]
-                src/test/pkg/Kotlin.kt:4: error: Method test.pkg.Kotlin.method has added 'final' qualifier [AddedFinal]
+                src/test/pkg/Java.java:4: error: Binary breaking change: Method test.pkg.Java.method has added 'final' qualifier [AddedFinal]
+                src/test/pkg/Kotlin.kt:4: error: Binary breaking change: Method test.pkg.Kotlin.method has added 'final' qualifier [AddedFinal]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -588,7 +589,8 @@ class CompatibilityCheckTest : DriverTest() {
         // Make sure that we correctly compare effectively final (inherited from surrounding class)
         // between the signature file codebase and the real codebase
         check(
-            expectedIssues = """
+            expectedIssues =
+                """
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -630,7 +632,8 @@ class CompatibilityCheckTest : DriverTest() {
         // abstract methods. We don't want to list these as having changed
         // their abstractness.
         check(
-            expectedIssues = """
+            expectedIssues =
+                """
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -669,7 +672,8 @@ class CompatibilityCheckTest : DriverTest() {
     @Test
     fun `Implicit modifiers from inherited super classes`() {
         check(
-            expectedIssues = """
+            expectedIssues =
+                """
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -722,7 +726,8 @@ class CompatibilityCheckTest : DriverTest() {
         // abstract methods. We don't want to list these as having changed
         // their abstractness.
         check(
-            expectedIssues = """
+            expectedIssues =
+                """
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -795,7 +800,7 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/Foo.kt:5: error: Cannot remove `infix` modifier from method test.pkg.Foo.add2(String): Incompatible change [InfixRemoval]
+                src/test/pkg/Foo.kt:5: error: Source breaking change: Cannot remove `infix` modifier from method test.pkg.Foo.add2(String): Incompatible change [InfixRemoval]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -832,7 +837,7 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/Foo.kt:2: error: Cannot add 'sealed' modifier to class test.pkg.Foo: Incompatible change [AddSealed]
+                src/test/pkg/Foo.kt:2: error: Source breaking change: Cannot add 'sealed' modifier to class test.pkg.Foo: Incompatible change [AddSealed]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -859,9 +864,8 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/Foo.kt:3: error: Attempted to remove default value from parameter s1 in test.pkg.Foo [DefaultValueChange]
-                src/test/pkg/Foo.kt:7: error: Attempted to remove default value from parameter s1 in test.pkg.Foo.method4 [DefaultValueChange]
-
+                src/test/pkg/Foo.kt:3: error: Source breaking change: Attempted to remove default value from parameter s1 in test.pkg.Foo [DefaultValueChange]
+                src/test/pkg/Foo.kt:7: error: Source breaking change: Attempted to remove default value from parameter s1 in test.pkg.Foo.method4 [DefaultValueChange]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -900,8 +904,8 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/Foo.kt:3: error: Attempted to remove default value from parameter s1 in test.pkg.Foo [DefaultValueChange]
-                src/test/pkg/Foo.kt:7: error: Attempted to remove default value from parameter s1 in test.pkg.Foo.method4 [DefaultValueChange]
+                src/test/pkg/Foo.kt:3: error: Source breaking change: Attempted to remove default value from parameter s1 in test.pkg.Foo [DefaultValueChange]
+                src/test/pkg/Foo.kt:7: error: Source breaking change: Attempted to remove default value from parameter s1 in test.pkg.Foo.method4 [DefaultValueChange]
                 """,
             format = FileFormat.V4,
             checkCompatibilityApiReleased =
@@ -938,7 +942,8 @@ class CompatibilityCheckTest : DriverTest() {
     @Test
     fun `Removing method or field when still available via inheritance is OK`() {
         check(
-            expectedIssues = """
+            expectedIssues =
+                """
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -991,12 +996,12 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/Parent.java:5: error: Field test.pkg.Parent.field2 has changed value from 2 to 42 [ChangedValue]
-                src/test/pkg/Parent.java:6: error: Field test.pkg.Parent.field3 has changed type from int to char [ChangedType]
-                src/test/pkg/Parent.java:7: error: Field test.pkg.Parent.field4 has added 'final' qualifier [AddedFinal]
-                src/test/pkg/Parent.java:8: error: Field test.pkg.Parent.field5 has changed 'static' qualifier [ChangedStatic]
+                src/test/pkg/Parent.java:5: error: Binary breaking change: Field test.pkg.Parent.field2 has changed value from 2 to 42 [ChangedValue]
+                src/test/pkg/Parent.java:6: error: Binary breaking change: Field test.pkg.Parent.field3 has changed type from int to char [ChangedType]
+                src/test/pkg/Parent.java:7: error: Binary breaking change: Field test.pkg.Parent.field4 has added 'final' qualifier [AddedFinal]
+                src/test/pkg/Parent.java:8: error: Binary breaking change: Field test.pkg.Parent.field5 has changed 'static' qualifier [ChangedStatic]
                 src/test/pkg/Parent.java:10: error: Field test.pkg.Parent.field7 has changed 'volatile' qualifier [ChangedVolatile]
-                src/test/pkg/Parent.java:20: error: Field test.pkg.Parent.field94 has changed value from 1 to 42 [ChangedValue]
+                src/test/pkg/Parent.java:20: error: Binary breaking change: Field test.pkg.Parent.field94 has changed value from 1 to 42 [ChangedValue]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -1006,7 +1011,7 @@ class CompatibilityCheckTest : DriverTest() {
                     field public static final int field1 = 1; // 0x1
                     field public static final int field2 = 2; // 0x2
                     field public int field3;
-                    field public int field4 = 4; // 0x4
+                    field public int field4;
                     field public int field5;
                     field public int field6;
                     field public int field7;
@@ -1037,11 +1042,11 @@ class CompatibilityCheckTest : DriverTest() {
                         /** @deprecated */ @Deprecated public int field9 = 8;  // ADDED DEPRECATED
                         @SuppressLint("ChangedValue")
                         public static final int field91 = 42;// CHANGED VALUE: Suppressed
-                        @SuppressLint("ChangedValue:Field test.pkg.Parent.field92 has changed value from 1 to 42")
+                        @SuppressLint("ChangedValue:Binary breaking change: Field test.pkg.Parent.field92 has changed value from 1 to 42")
                         public static final int field92 = 42;// CHANGED VALUE: Suppressed with same message
-                        @SuppressLint("ChangedValue: Field test.pkg.Parent.field93 has changed value from 1 to 42")
+                        @SuppressLint("ChangedValue:Binary breaking change: Field test.pkg.Parent.field93 has changed value from 1 to 42")
                         public static final int field93 = 42;// CHANGED VALUE: Suppressed with same message
-                        @SuppressLint("ChangedValue:Field test.pkg.Parent.field94 has changed value from 10 to 1")
+                        @SuppressLint("ChangedValue:Binary breaking change: Field test.pkg.Parent.field94 has changed value from 10 to 1")
                         public static final int field94 = 42;// CHANGED VALUE: Suppressed but with different message
                     }
                     """
@@ -1056,9 +1061,9 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/ExportedProperty.java:13: error: Method test.pkg.ExportedProperty.prefix has changed value from "" to "hello" [ChangedValue]
-                src/test/pkg/ExportedProperty.java:14: error: Method test.pkg.ExportedProperty.floating has changed value from 1.0f to 1.1f [ChangedValue]
-                src/test/pkg/ExportedProperty.java:15: error: Method test.pkg.ExportedProperty.category has changed value from "" to nothing [ChangedValue]
+                src/test/pkg/ExportedProperty.java:13: error: Binary breaking change: Method test.pkg.ExportedProperty.prefix has changed value from "" to "hello" [ChangedValue]
+                src/test/pkg/ExportedProperty.java:14: error: Binary breaking change: Method test.pkg.ExportedProperty.floating has changed value from 1.0f to 1.1f [ChangedValue]
+                src/test/pkg/ExportedProperty.java:15: error: Binary breaking change: Method test.pkg.ExportedProperty.category has changed value from "" to nothing [ChangedValue]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -1105,7 +1110,7 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/Parent.java:3: error: Class test.pkg.Parent changed class/interface declaration [ChangedClass]
+                src/test/pkg/Parent.java:3: error: Binary breaking change: Class test.pkg.Parent changed class/interface declaration [ChangedClass]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -1133,7 +1138,7 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/Parent.java:3: error: Class test.pkg.Parent no longer implements java.io.Closeable [RemovedInterface]
+                src/test/pkg/Parent.java:3: error: Binary breaking change: Class test.pkg.Parent no longer implements java.io.Closeable [RemovedInterface]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -1162,8 +1167,8 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/Parent.java:3: error: Class test.pkg.Parent changed 'abstract' qualifier [ChangedAbstract]
-                src/test/pkg/Parent.java:3: error: Class test.pkg.Parent changed 'static' qualifier [ChangedStatic]
+                src/test/pkg/Parent.java:3: error: Binary breaking change: Class test.pkg.Parent changed 'abstract' qualifier [ChangedAbstract]
+                src/test/pkg/Parent.java:3: error: Binary breaking change: Class test.pkg.Parent changed 'static' qualifier [ChangedStatic]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -1192,8 +1197,8 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:4: error: Removed constructor test.pkg.Class1() [RemovedMethod]
-                src/test/pkg/Class1.java:3: error: Class test.pkg.Class1 added 'final' qualifier [AddedFinal]
+                released-api.txt:4: error: Binary breaking change: Removed constructor test.pkg.Class1() [RemovedMethod]
+                src/test/pkg/Class1.java:3: error: Binary breaking change: Class test.pkg.Class1 added 'final' qualifier [AddedFinal]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -1245,8 +1250,8 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/Class1.java:3: error: Class test.pkg.Class1 changed visibility from protected to public [ChangedScope]
-                src/test/pkg/Class2.java:3: error: Class test.pkg.Class2 changed visibility from public to protected [ChangedScope]
+                src/test/pkg/Class1.java:3: error: Binary breaking change: Class test.pkg.Class1 changed visibility from protected to public [ChangedScope]
+                src/test/pkg/Class2.java:3: error: Binary breaking change: Class test.pkg.Class2 changed visibility from public to protected [ChangedScope]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -1286,7 +1291,7 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/Class3.java:3: error: Class test.pkg.Class3 superclass changed from java.lang.Char to java.lang.Number [ChangedSuperclass]
+                src/test/pkg/Class3.java:3: error: Binary breaking change: Class test.pkg.Class3 superclass changed from java.lang.Char to java.lang.Number [ChangedSuperclass]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -1357,8 +1362,8 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:3: error: Class test.pkg.Foo changed number of type parameters from 1 to 0 [ChangedType]
-            """,
+                load-api.txt:3: error: Binary breaking change: Class test.pkg.Foo changed number of type parameters from 1 to 0 [ChangedType]
+                """,
             checkCompatibilityApiReleased =
                 """
                 package test.pkg {
@@ -1381,8 +1386,8 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:3: error: Class test.pkg.Foo changed number of type parameters from 1 to 2 [ChangedType]
-            """,
+                load-api.txt:3: error: Binary breaking change: Class test.pkg.Foo changed number of type parameters from 1 to 2 [ChangedType]
+                """,
             checkCompatibilityApiReleased =
                 """
                 package test.pkg {
@@ -1405,8 +1410,8 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/MyClass.java:5: error: Method test.pkg.MyClass.myMethod2 has changed 'abstract' qualifier [ChangedAbstract]
-                src/test/pkg/MyClass.java:6: error: Method test.pkg.MyClass.myMethod3 has changed 'static' qualifier [ChangedStatic]
+                src/test/pkg/MyClass.java:5: error: Binary breaking change: Method test.pkg.MyClass.myMethod2 has changed 'abstract' qualifier [ChangedAbstract]
+                src/test/pkg/MyClass.java:6: error: Binary breaking change: Method test.pkg.MyClass.myMethod3 has changed 'static' qualifier [ChangedStatic]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -1441,7 +1446,7 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/Outer.java:7: error: Method test.pkg.Outer.Class1.method1 has added 'final' qualifier [AddedFinal]
+                src/test/pkg/Outer.java:7: error: Binary breaking change: Method test.pkg.Outer.Class1.method1 has added 'final' qualifier [AddedFinal]
                 src/test/pkg/Outer.java:19: error: Method test.pkg.Outer.Class4.method4 has removed 'final' qualifier [RemovedFinalStrict]
                 """,
             checkCompatibilityApiReleased =
@@ -1500,7 +1505,7 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/MyClass.java:6: error: Method test.pkg.MyClass.myMethod2 changed visibility from public to protected [ChangedScope]
+                src/test/pkg/MyClass.java:6: error: Binary breaking change: Method test.pkg.MyClass.myMethod2 changed visibility from public to protected [ChangedScope]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -1533,13 +1538,13 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/MyClass.java:5: error: Method test.pkg.MyClass.method1 has changed return type from float to int [ChangedType]
-                src/test/pkg/MyClass.java:6: error: Method test.pkg.MyClass.method2 has changed return type from java.util.List<java.lang.Number> to java.util.List<java.lang.Integer> [ChangedType]
-                src/test/pkg/MyClass.java:7: error: Method test.pkg.MyClass.method3 has changed return type from java.util.List<java.lang.Integer> to java.util.List<java.lang.Number> [ChangedType]
-                src/test/pkg/MyClass.java:8: error: Method test.pkg.MyClass.method4 has changed return type from java.lang.String to java.lang.String[] [ChangedType]
-                src/test/pkg/MyClass.java:9: error: Method test.pkg.MyClass.method5 has changed return type from java.lang.String[] to java.lang.String[][] [ChangedType]
-                src/test/pkg/MyClass.java:11: error: Method test.pkg.MyClass.method7 has changed return type from T (extends java.lang.Number) to java.lang.Number [ChangedType]
-                src/test/pkg/MyClass.java:13: error: Method test.pkg.MyClass.method9 has changed return type from X (extends java.lang.Throwable) to U (extends java.lang.Number) [ChangedType]
+                src/test/pkg/MyClass.java:5: error: Binary breaking change: Method test.pkg.MyClass.method1 has changed return type from float to int [ChangedType]
+                src/test/pkg/MyClass.java:6: error: Binary breaking change: Method test.pkg.MyClass.method2 has changed return type from java.util.List<java.lang.Number> to java.util.List<java.lang.Integer> [ChangedType]
+                src/test/pkg/MyClass.java:7: error: Binary breaking change: Method test.pkg.MyClass.method3 has changed return type from java.util.List<java.lang.Integer> to java.util.List<java.lang.Number> [ChangedType]
+                src/test/pkg/MyClass.java:8: error: Binary breaking change: Method test.pkg.MyClass.method4 has changed return type from java.lang.String to java.lang.String[] [ChangedType]
+                src/test/pkg/MyClass.java:9: error: Binary breaking change: Method test.pkg.MyClass.method5 has changed return type from java.lang.String[] to java.lang.String[][] [ChangedType]
+                src/test/pkg/MyClass.java:11: error: Binary breaking change: Method test.pkg.MyClass.method7 has changed return type from T (extends java.lang.Number) to java.lang.Number [ChangedType]
+                src/test/pkg/MyClass.java:13: error: Binary breaking change: Method test.pkg.MyClass.method9 has changed return type from X (extends java.lang.Throwable) to U (extends java.lang.Number) [ChangedType]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -1586,7 +1591,7 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/MyClass.java:6: error: Field test.pkg.MyClass.myField2 changed visibility from public to protected [ChangedScope]
+                src/test/pkg/MyClass.java:6: error: Binary breaking change: Field test.pkg.MyClass.myField2 changed visibility from public to protected [ChangedScope]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -1621,8 +1626,8 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:3: error: Removed class test.pkg.MyOldClass [RemovedClass]
-                released-api.txt:6: error: Removed package test.pkg3 [RemovedPackage]
+                released-api.txt:3: error: Binary breaking change: Removed class test.pkg.MyOldClass [RemovedClass]
+                released-api.txt:6: error: Binary breaking change: Removed package test.pkg3 [RemovedPackage]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -1672,7 +1677,7 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:4: error: Removed constructor test.pkg.MyClass() [RemovedMethod]
+                released-api.txt:4: error: Binary breaking change: Removed constructor test.pkg.MyClass() [RemovedMethod]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -1702,7 +1707,7 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/MyClass.java:8: error: Method test.pkg.MyClass.myMethod4 has changed return type from S (extends java.lang.Object) to S (extends java.lang.Float) [ChangedType]
+                src/test/pkg/MyClass.java:8: error: Binary breaking change: Method test.pkg.MyClass.myMethod4 has changed return type from S (extends java.lang.Object) to S (extends java.lang.Float) [ChangedType]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -1755,7 +1760,7 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/MyClass.java:5: error: Field test.pkg.MyClass.myField has changed type from String to java.lang.String [ChangedType]
+                src/test/pkg/MyClass.java:5: error: Binary breaking change: Field test.pkg.MyClass.myField has changed type from String to java.lang.String [ChangedType]
                 """,
             // If MyClass did not have a type parameter named String, myField would be parsed as
             // type java.lang.String
@@ -1876,7 +1881,8 @@ class CompatibilityCheckTest : DriverTest() {
     @Test
     fun `Test inherited methods`() {
         check(
-            expectedIssues = """
+            expectedIssues =
+                """
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -1978,10 +1984,10 @@ class CompatibilityCheckTest : DriverTest() {
         // from the base API. When parsing these code bases we need to gracefully handle
         // references to inner classes.
         check(
-            includeSystemApiAnnotations = true,
+            includeSystemApiAnnotations = SystemApiType.PRIVILEGED_APPS,
             expectedIssues =
                 """
-                released-api.txt:5: error: Removed method test.pkg.Bar.Inner1.Inner2.removedMethod() [RemovedMethod]
+                released-api.txt:5: error: Binary breaking change: Removed method test.pkg.Bar.Inner1.Inner2.removedMethod() [RemovedMethod]
                 """,
             sourceFiles =
                 arrayOf(
@@ -2027,11 +2033,6 @@ class CompatibilityCheckTest : DriverTest() {
                     ),
                     systemApiSource,
                 ),
-            extraArguments =
-                arrayOf(
-                    ARG_SHOW_ANNOTATION,
-                    "android.annotation.SystemApi",
-                ),
             checkCompatibilityApiReleased =
                 """
                 package test.pkg {
@@ -2049,11 +2050,11 @@ class CompatibilityCheckTest : DriverTest() {
         // Incompatible changes to a released System API should be detected
         // In this case removing final and changing value of constant
         check(
-            includeSystemApiAnnotations = true,
+            includeSystemApiAnnotations = SystemApiType.TEST,
             expectedIssues =
                 """
                 src/android/rolecontrollerservice/RoleControllerService.java:8: error: Method android.rolecontrollerservice.RoleControllerService.sendNetworkScore has removed 'final' qualifier [RemovedFinalStrict]
-                src/android/rolecontrollerservice/RoleControllerService.java:9: error: Field android.rolecontrollerservice.RoleControllerService.APP_RETURN_UNWANTED has changed value from 1 to 0 [ChangedValue]
+                src/android/rolecontrollerservice/RoleControllerService.java:9: error: Binary breaking change: Field android.rolecontrollerservice.RoleControllerService.APP_RETURN_UNWANTED has changed value from 1 to 0 [ChangedValue]
                 """,
             sourceFiles =
                 arrayOf(
@@ -2073,11 +2074,6 @@ class CompatibilityCheckTest : DriverTest() {
                     ),
                     systemApiSource,
                 ),
-            extraArguments =
-                arrayOf(
-                    ARG_SHOW_ANNOTATION,
-                    "android.annotation.TestApi",
-                ),
             checkCompatibilityApiReleased =
                 """
                 package android.rolecontrollerservice {
@@ -2100,7 +2096,7 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:7: error: Removed method test.view.ViewTreeObserver.registerFrameCommitCallback(Runnable) [RemovedMethod]
+                released-api.txt:7: error: Binary breaking change: Removed method test.view.ViewTreeObserver.registerFrameCommitCallback(Runnable) [RemovedMethod]
                 """,
             sourceFiles =
                 arrayOf(
@@ -2161,12 +2157,12 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:4: error: Removed constructor test.pkg.Class1() [RemovedMethod]
-                released-api.txt:15: error: Removed class test.pkg.MyOldClass [RemovedClass]
-                released-api.txt:18: error: Removed package test.pkg3 [RemovedPackage]
-                src/test/pkg/Class1.java:3: error: Class test.pkg.Class1 added 'final' qualifier [AddedFinal]
-                src/test/pkg/MyClass.java:5: error: Method test.pkg.MyClass.myMethod2 has changed 'abstract' qualifier [ChangedAbstract]
-                src/test/pkg/MyClass.java:6: error: Method test.pkg.MyClass.myMethod3 has changed 'static' qualifier [ChangedStatic]
+                released-api.txt:4: error: Binary breaking change: Removed constructor test.pkg.Class1() [RemovedMethod]
+                released-api.txt:15: error: Binary breaking change: Removed class test.pkg.MyOldClass [RemovedClass]
+                released-api.txt:18: error: Binary breaking change: Removed package test.pkg3 [RemovedPackage]
+                src/test/pkg/Class1.java:3: error: Binary breaking change: Class test.pkg.Class1 added 'final' qualifier [AddedFinal]
+                src/test/pkg/MyClass.java:5: error: Binary breaking change: Method test.pkg.MyClass.myMethod2 has changed 'abstract' qualifier [ChangedAbstract]
+                src/test/pkg/MyClass.java:6: error: Binary breaking change: Method test.pkg.MyClass.myMethod3 has changed 'static' qualifier [ChangedStatic]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -2251,9 +2247,9 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                released-api.txt:4: error: Removed deprecated constructor test.pkg.SomeClass() [RemovedDeprecatedMethod]
-                released-api.txt:5: error: Removed deprecated method test.pkg.SomeClass.deprecatedMethod() [RemovedDeprecatedMethod]
-                released-api.txt:7: error: Removed deprecated class test.pkg.DeprecatedClass [RemovedDeprecatedClass]
+                released-api.txt:4: error: Binary breaking change: Removed deprecated constructor test.pkg.SomeClass() [RemovedDeprecatedMethod]
+                released-api.txt:5: error: Binary breaking change: Removed deprecated method test.pkg.SomeClass.deprecatedMethod() [RemovedDeprecatedMethod]
+                released-api.txt:7: error: Binary breaking change: Removed deprecated class test.pkg.DeprecatedClass [RemovedDeprecatedClass]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -2430,8 +2426,8 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/test.kt:5: error: Method test.pkg.TestKt.add made type variable T reified: incompatible change [AddedReified]
-                src/test/pkg/test.kt:8: error: Method test.pkg.TestKt.two made type variable S reified: incompatible change [AddedReified]
+                src/test/pkg/test.kt:5: error: Binary breaking change: Method test.pkg.TestKt.add made type variable T reified: incompatible change [AddedReified]
+                src/test/pkg/test.kt:8: error: Binary breaking change: Method test.pkg.TestKt.two made type variable S reified: incompatible change [AddedReified]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -2467,7 +2463,8 @@ class CompatibilityCheckTest : DriverTest() {
     @Test
     fun `Empty prev api with @hide and --show-annotation`() {
         check(
-            checkCompatibilityApiReleased = """
+            checkCompatibilityApiReleased =
+                """
                 """,
             sourceFiles =
                 arrayOf(
@@ -2667,7 +2664,8 @@ class CompatibilityCheckTest : DriverTest() {
                     @libcore.util.Nullable public test.pkg.String getMessage() { throw new RuntimeException("Stub!"); }
                 }
             """,
-            expectedIssues = """
+            expectedIssues =
+                """
                 """
         )
     }
@@ -2709,7 +2707,8 @@ class CompatibilityCheckTest : DriverTest() {
                     """
                     )
                 ),
-            expectedIssues = """
+            expectedIssues =
+                """
                 """
         )
     }
@@ -2755,7 +2754,8 @@ class CompatibilityCheckTest : DriverTest() {
                     """
                     )
                 ),
-            expectedIssues = """
+            expectedIssues =
+                """
                 """
         )
     }
@@ -2814,7 +2814,7 @@ class CompatibilityCheckTest : DriverTest() {
                 ),
             expectedIssues =
                 """
-                released-api.txt:6: error: Removed method android.hardware.lights.LightsRequest.Builder.setLight() [RemovedMethod]
+                released-api.txt:6: error: Binary breaking change: Removed method android.hardware.lights.LightsRequest.Builder.setLight() [RemovedMethod]
                 """
         )
     }
@@ -2853,9 +2853,9 @@ class CompatibilityCheckTest : DriverTest() {
             showAnnotations = arrayOf(ANDROID_SYSTEM_API),
             expectedIssues =
                 """
-                src/android/foobar/Foo.java:8: error: Class android.foobar.Foo.Nested added 'final' qualifier [AddedFinal]
-                src/android/foobar/Foo.java:9: error: Method android.foobar.Foo.Nested.existing has added 'final' qualifier [AddedFinal]
-                src/android/foobar/Foo.java:9: error: Method android.foobar.Foo.Nested.existing has changed return type from void to int [ChangedType]
+                src/android/foobar/Foo.java:8: error: Binary breaking change: Class android.foobar.Foo.Nested added 'final' qualifier [AddedFinal]
+                src/android/foobar/Foo.java:9: error: Binary breaking change: Method android.foobar.Foo.Nested.existing has added 'final' qualifier [AddedFinal]
+                src/android/foobar/Foo.java:9: error: Binary breaking change: Method android.foobar.Foo.Nested.existing has changed return type from void to int [ChangedType]
                 """
         )
     }
@@ -2899,7 +2899,8 @@ class CompatibilityCheckTest : DriverTest() {
                     ARG_SHOW_ANNOTATION,
                     "android.annotation.SystemApi",
                 ),
-            expectedIssues = """
+            expectedIssues =
+                """
                 """
         )
     }
@@ -2934,7 +2935,7 @@ class CompatibilityCheckTest : DriverTest() {
             // saying that SomeInterface no longer implements wait()
             expectedIssues =
                 """
-                released-api.txt:2: error: Removed package java.lang [RemovedPackage]
+                released-api.txt:2: error: Binary breaking change: Removed package java.lang [RemovedPackage]
                 """
         )
     }
@@ -3112,7 +3113,8 @@ class CompatibilityCheckTest : DriverTest() {
     @Test
     fun `Ignore hidden references`() {
         check(
-            expectedIssues = """
+            expectedIssues =
+                """
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -3264,8 +3266,8 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-            load-api.txt:7: error: Method test.pkg.sample.SampleClass.convert1 has changed return type from Number (extends java.lang.Object) to java.lang.Number [ChangedType]
-            """,
+                load-api.txt:7: error: Binary breaking change: Method test.pkg.sample.SampleClass.convert1 has changed return type from Number (extends java.lang.Object) to java.lang.Number [ChangedType]
+                """,
             checkCompatibilityApiReleased =
                 """
                 // Signature format: 4.0
@@ -3295,7 +3297,8 @@ class CompatibilityCheckTest : DriverTest() {
     fun `Check generic type argument when showUnannotated is explicitly enabled`() {
         // Regression test for 130567941
         check(
-            expectedIssues = """
+            expectedIssues =
+                """
             """,
             checkCompatibilityApiReleased =
                 """
@@ -3364,8 +3367,8 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-            src/androidx/room/Relation.java:5: error: Added method androidx.room.Relation.IHaveNoDefault() [AddedAbstractMethod]
-            """,
+                src/androidx/room/Relation.java:5: error: Binary breaking change: Added method androidx.room.Relation.IHaveNoDefault() [AddedAbstractMethod]
+                """,
             checkCompatibilityApiReleased =
                 """
                 // Signature format: 4.0
@@ -3395,9 +3398,9 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:9: error: Class test.pkg.ParentClass.BadInnerClass changed 'static' qualifier [ChangedStatic]
-                load-api.txt:12: error: Class test.pkg.ParentClass.AnotherBadInnerClass changed 'static' qualifier [ChangedStatic]
-            """,
+                load-api.txt:9: error: Binary breaking change: Class test.pkg.ParentClass.BadInnerClass changed 'static' qualifier [ChangedStatic]
+                load-api.txt:12: error: Binary breaking change: Class test.pkg.ParentClass.AnotherBadInnerClass changed 'static' qualifier [ChangedStatic]
+                """,
             checkCompatibilityApiReleased =
                 """
                 package test.pkg {
@@ -3441,7 +3444,7 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/FunctionalInterface.kt:3: error: Cannot remove 'fun' modifier from class test.pkg.FunctionalInterface: source incompatible change [FunRemoval]
+                src/test/pkg/FunctionalInterface.kt:3: error: Source breaking change: Cannot remove 'fun' modifier from class test.pkg.FunctionalInterface: source incompatible change [FunRemoval]
                 """,
             format = FileFormat.V4,
             checkCompatibilityApiReleased =
@@ -3473,7 +3476,7 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:3: error: Cannot remove 'fun' modifier from class test.pkg.FunctionalInterface: source incompatible change [FunRemoval]
+                load-api.txt:3: error: Source breaking change: Cannot remove 'fun' modifier from class test.pkg.FunctionalInterface: source incompatible change [FunRemoval]
                 """,
             format = FileFormat.V4,
             checkCompatibilityApiReleased =
@@ -3532,10 +3535,10 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/JavaInterface.java:4: error: Added method test.pkg.JavaInterface.noDefault() [AddedAbstractMethod]
-                src/test/pkg/KotlinInterface.kt:4: error: Added method test.pkg.KotlinInterface.noDefault() [AddedAbstractMethod]
-                src/test/pkg/KotlinInterface.kt:5: error: Added method test.pkg.KotlinInterface.hasDefault() [AddedAbstractMethod]
-            """,
+                src/test/pkg/JavaInterface.java:4: error: Binary breaking change: Added method test.pkg.JavaInterface.noDefault() [AddedAbstractMethod]
+                src/test/pkg/KotlinInterface.kt:4: error: Binary breaking change: Added method test.pkg.KotlinInterface.noDefault() [AddedAbstractMethod]
+                src/test/pkg/KotlinInterface.kt:5: error: Binary breaking change: Added method test.pkg.KotlinInterface.hasDefault() [AddedAbstractMethod]
+                """,
             checkCompatibilityApiReleased =
                 """
                 // Signature format: 4.0
@@ -3580,9 +3583,8 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:3: error: Class test.pkg.Foo changed visibility from public to private [ChangedScope]
-            """
-                    .trimIndent(),
+                load-api.txt:3: error: Binary breaking change: Class test.pkg.Foo changed visibility from public to private [ChangedScope]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -3606,20 +3608,19 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:3: error: Class test.pkg.ClassToEnum changed class/interface declaration [ChangedClass]
-                load-api.txt:4: error: Class test.pkg.ClassToInterface changed class/interface declaration [ChangedClass]
-                load-api.txt:5: error: Class test.pkg.ClassToAnnotation changed class/interface declaration [ChangedClass]
-                load-api.txt:6: error: Class test.pkg.EnumToClass changed class/interface declaration [ChangedClass]
-                load-api.txt:7: error: Class test.pkg.EnumToInterface changed class/interface declaration [ChangedClass]
-                load-api.txt:8: error: Class test.pkg.EnumToAnnotation changed class/interface declaration [ChangedClass]
-                load-api.txt:9: error: Class test.pkg.InterfaceToClass changed class/interface declaration [ChangedClass]
-                load-api.txt:10: error: Class test.pkg.InterfaceToEnum changed class/interface declaration [ChangedClass]
-                load-api.txt:11: error: Class test.pkg.InterfaceToAnnotation changed class/interface declaration [ChangedClass]
-                load-api.txt:12: error: Class test.pkg.AnnotationToClass changed class/interface declaration [ChangedClass]
-                load-api.txt:13: error: Class test.pkg.AnnotationToInterface changed class/interface declaration [ChangedClass]
-                load-api.txt:14: error: Class test.pkg.AnnotationToEnum changed class/interface declaration [ChangedClass]
-            """
-                    .trimIndent(),
+                load-api.txt:3: error: Binary breaking change: Class test.pkg.ClassToEnum changed class/interface declaration [ChangedClass]
+                load-api.txt:4: error: Binary breaking change: Class test.pkg.ClassToInterface changed class/interface declaration [ChangedClass]
+                load-api.txt:5: error: Binary breaking change: Class test.pkg.ClassToAnnotation changed class/interface declaration [ChangedClass]
+                load-api.txt:6: error: Binary breaking change: Class test.pkg.EnumToClass changed class/interface declaration [ChangedClass]
+                load-api.txt:7: error: Binary breaking change: Class test.pkg.EnumToInterface changed class/interface declaration [ChangedClass]
+                load-api.txt:8: error: Binary breaking change: Class test.pkg.EnumToAnnotation changed class/interface declaration [ChangedClass]
+                load-api.txt:9: error: Binary breaking change: Class test.pkg.InterfaceToClass changed class/interface declaration [ChangedClass]
+                load-api.txt:10: error: Binary breaking change: Class test.pkg.InterfaceToEnum changed class/interface declaration [ChangedClass]
+                load-api.txt:11: error: Binary breaking change: Class test.pkg.InterfaceToAnnotation changed class/interface declaration [ChangedClass]
+                load-api.txt:12: error: Binary breaking change: Class test.pkg.AnnotationToClass changed class/interface declaration [ChangedClass]
+                load-api.txt:13: error: Binary breaking change: Class test.pkg.AnnotationToInterface changed class/interface declaration [ChangedClass]
+                load-api.txt:14: error: Binary breaking change: Class test.pkg.AnnotationToEnum changed class/interface declaration [ChangedClass]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -3691,10 +3692,10 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Field test.pkg.Foo.bar changed visibility from public to protected [ChangedScope]
-                load-api.txt:5: error: Field test.pkg.Foo.baz changed visibility from protected to private [ChangedScope]
-                load-api.txt:6: error: Field test.pkg.Foo.spam changed visibility from protected to internal [ChangedScope]
-            """,
+                load-api.txt:4: error: Binary breaking change: Field test.pkg.Foo.bar changed visibility from public to protected [ChangedScope]
+                load-api.txt:5: error: Binary breaking change: Field test.pkg.Foo.baz changed visibility from protected to private [ChangedScope]
+                load-api.txt:6: error: Binary breaking change: Field test.pkg.Foo.spam changed visibility from protected to internal [ChangedScope]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -3750,10 +3751,10 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Method test.pkg.Foo.bar changed visibility from public to protected [ChangedScope]
-                load-api.txt:5: error: Method test.pkg.Foo.baz changed visibility from protected to private [ChangedScope]
-                load-api.txt:6: error: Method test.pkg.Foo.spam changed visibility from protected to internal [ChangedScope]
-            """,
+                load-api.txt:4: error: Binary breaking change: Method test.pkg.Foo.bar changed visibility from public to protected [ChangedScope]
+                load-api.txt:5: error: Binary breaking change: Method test.pkg.Foo.baz changed visibility from protected to private [ChangedScope]
+                load-api.txt:6: error: Binary breaking change: Method test.pkg.Foo.spam changed visibility from protected to internal [ChangedScope]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -3806,9 +3807,9 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:3: error: Class test.pkg.Foo changed 'abstract' qualifier [ChangedAbstract]
-                load-api.txt:5: error: Method test.pkg.Foo.bar has changed 'abstract' qualifier [ChangedAbstract]
-            """,
+                load-api.txt:3: error: Binary breaking change: Class test.pkg.Foo changed 'abstract' qualifier [ChangedAbstract]
+                load-api.txt:5: error: Binary breaking change: Method test.pkg.Foo.bar has changed 'abstract' qualifier [ChangedAbstract]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -3859,8 +3860,8 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:4: error: Method test.pkg.Foo.bar has changed 'default' qualifier [ChangedDefault]
-            """,
+                load-api.txt:4: error: Binary breaking change: Method test.pkg.Foo.bar has changed 'default' qualifier [ChangedDefault]
+                """,
             signatureSource =
                 """
                 package test.pkg {
@@ -4149,9 +4150,8 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                load-api.txt:3: error: Class test.pkg.Foo no longer implements java.io.Closeable [RemovedInterface]
-            """
-                    .trimIndent(),
+                load-api.txt:3: error: Binary breaking change: Class test.pkg.Foo no longer implements java.io.Closeable [RemovedInterface]
+                """,
             checkCompatibilityApiReleased =
                 """
                 // Signature format: 4.0
@@ -4224,25 +4224,25 @@ class CompatibilityCheckTest : DriverTest() {
             // listed in the API file
             expectedIssues =
                 """
-                error: Method test.pkg.MyCollection.add has changed 'abstract' qualifier [ChangedAbstract]
-                error: Method test.pkg.MyCollection.addAll has changed 'abstract' qualifier [ChangedAbstract]
-                error: Method test.pkg.MyCollection.clear has changed 'abstract' qualifier [ChangedAbstract]
-                error: Method test.pkg.MyCollection.remove has changed 'abstract' qualifier [ChangedAbstract]
-                error: Method test.pkg.MyCollection.removeAll has changed 'abstract' qualifier [ChangedAbstract]
-                error: Method test.pkg.MyCollection.retainAll has changed 'abstract' qualifier [ChangedAbstract]
-                error: Method test.pkg.MyCollection.size has changed 'abstract' qualifier [ChangedAbstract]
-                error: Method test.pkg.MyCollection.toArray has changed 'abstract' qualifier [ChangedAbstract]
-                error: Method test.pkg.MyCollection.toArray has changed 'abstract' qualifier [ChangedAbstract]
-                error: Attempted to remove parameter name from parameter p in test.pkg.MyCollection.add [ParameterNameChange]
-                error: Attempted to remove parameter name from parameter p in test.pkg.MyCollection.addAll [ParameterNameChange]
-                error: Attempted to remove parameter name from parameter p in test.pkg.MyCollection.remove [ParameterNameChange]
-                error: Attempted to remove parameter name from parameter p in test.pkg.MyCollection.removeAll [ParameterNameChange]
-                error: Attempted to remove parameter name from parameter p in test.pkg.MyCollection.retainAll [ParameterNameChange]
-                error: Attempted to remove parameter name from parameter p in test.pkg.MyCollection.toArray [ParameterNameChange]
-                load-api.txt:5: error: Attempted to change parameter name from o to element in method test.pkg.MyCollection.contains [ParameterNameChange]
-                load-api.txt:5: error: Attempted to change parameter name from o to element in method test.pkg.MyCollection.contains [ParameterNameChange]
-                load-api.txt:6: error: Attempted to change parameter name from c to elements in method test.pkg.MyCollection.containsAll [ParameterNameChange]
-                load-api.txt:6: error: Attempted to change parameter name from c to elements in method test.pkg.MyCollection.containsAll [ParameterNameChange]
+                error: Binary breaking change: Method test.pkg.MyCollection.add has changed 'abstract' qualifier [ChangedAbstract]
+                error: Binary breaking change: Method test.pkg.MyCollection.addAll has changed 'abstract' qualifier [ChangedAbstract]
+                error: Binary breaking change: Method test.pkg.MyCollection.clear has changed 'abstract' qualifier [ChangedAbstract]
+                error: Binary breaking change: Method test.pkg.MyCollection.remove has changed 'abstract' qualifier [ChangedAbstract]
+                error: Binary breaking change: Method test.pkg.MyCollection.removeAll has changed 'abstract' qualifier [ChangedAbstract]
+                error: Binary breaking change: Method test.pkg.MyCollection.retainAll has changed 'abstract' qualifier [ChangedAbstract]
+                error: Binary breaking change: Method test.pkg.MyCollection.size has changed 'abstract' qualifier [ChangedAbstract]
+                error: Binary breaking change: Method test.pkg.MyCollection.toArray has changed 'abstract' qualifier [ChangedAbstract]
+                error: Binary breaking change: Method test.pkg.MyCollection.toArray has changed 'abstract' qualifier [ChangedAbstract]
+                error: Source breaking change: Attempted to remove parameter name from parameter p in test.pkg.MyCollection.add [ParameterNameChange]
+                error: Source breaking change: Attempted to remove parameter name from parameter p in test.pkg.MyCollection.addAll [ParameterNameChange]
+                error: Source breaking change: Attempted to remove parameter name from parameter p in test.pkg.MyCollection.remove [ParameterNameChange]
+                error: Source breaking change: Attempted to remove parameter name from parameter p in test.pkg.MyCollection.removeAll [ParameterNameChange]
+                error: Source breaking change: Attempted to remove parameter name from parameter p in test.pkg.MyCollection.retainAll [ParameterNameChange]
+                error: Source breaking change: Attempted to remove parameter name from parameter p in test.pkg.MyCollection.toArray [ParameterNameChange]
+                load-api.txt:5: error: Source breaking change: Attempted to change parameter name from o to element in method test.pkg.MyCollection.contains [ParameterNameChange]
+                load-api.txt:5: error: Source breaking change: Attempted to change parameter name from o to element in method test.pkg.MyCollection.contains [ParameterNameChange]
+                load-api.txt:6: error: Source breaking change: Attempted to change parameter name from c to elements in method test.pkg.MyCollection.containsAll [ParameterNameChange]
+                load-api.txt:6: error: Source breaking change: Attempted to change parameter name from c to elements in method test.pkg.MyCollection.containsAll [ParameterNameChange]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -4389,7 +4389,7 @@ class CompatibilityCheckTest : DriverTest() {
     fun `Removing @JvmDefaultWithCompatibility is an incompatible change`() {
         check(
             expectedIssues =
-                "load-api.txt:3: error: Cannot remove @kotlin.jvm.JvmDefaultWithCompatibility annotation from class test.pkg.AnnotationRemoved: Incompatible change [RemovedJvmDefaultWithCompatibility]",
+                "load-api.txt:3: error: Binary breaking change: Cannot remove @kotlin.jvm.JvmDefaultWithCompatibility annotation from class test.pkg.AnnotationRemoved: Incompatible change [RemovedJvmDefaultWithCompatibility]",
             checkCompatibilityApiReleased =
                 """
                 // Signature format: 4.0
@@ -4422,7 +4422,7 @@ class CompatibilityCheckTest : DriverTest() {
     fun `@JvmDefaultWithCompatibility check works with source files`() {
         check(
             expectedIssues =
-                "src/test/pkg/AnnotationRemoved.kt:3: error: Cannot remove @kotlin.jvm.JvmDefaultWithCompatibility annotation from class test.pkg.AnnotationRemoved: Incompatible change [RemovedJvmDefaultWithCompatibility]",
+                "src/test/pkg/AnnotationRemoved.kt:3: error: Binary breaking change: Cannot remove @kotlin.jvm.JvmDefaultWithCompatibility annotation from class test.pkg.AnnotationRemoved: Incompatible change [RemovedJvmDefaultWithCompatibility]",
             checkCompatibilityApiReleased =
                 """
                 // Signature format: 4.0
@@ -4490,9 +4490,9 @@ class CompatibilityCheckTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                src/test/pkg/Foo.java:4: error: Method test.pkg.Foo.getAnnotation has changed return type from A (extends java.lang.annotation.Annotation) to A (extends java.lang.String) [ChangedType]
-                src/test/pkg/Foo.java:5: error: Method test.pkg.Foo.getAnnotationArray has changed return type from A (extends java.lang.annotation.Annotation)[] to A (extends java.lang.String)[] [ChangedType]
-            """,
+                src/test/pkg/Foo.java:4: error: Binary breaking change: Method test.pkg.Foo.getAnnotation has changed return type from A (extends java.lang.annotation.Annotation) to A (extends java.lang.String) [ChangedType]
+                src/test/pkg/Foo.java:5: error: Binary breaking change: Method test.pkg.Foo.getAnnotationArray has changed return type from A (extends java.lang.annotation.Annotation)[] to A (extends java.lang.String)[] [ChangedType]
+                """,
             checkCompatibilityApiReleased =
                 """
                 // Signature format: 2.0
@@ -4610,7 +4610,7 @@ class CompatibilityCheckTest : DriverTest() {
     fun `Test removal of implicit no-args constructor is flagged`() {
         check(
             expectedIssues =
-                "released-api.txt:8: error: Removed constructor test.pkg.RemoveNoArgsCtor() [RemovedMethod]",
+                "released-api.txt:8: error: Binary breaking change: Removed constructor test.pkg.RemoveNoArgsCtor() [RemovedMethod]",
             checkCompatibilityApiReleased =
                 """
                     package test.pkg {
diff --git a/metalava/src/test/java/com/android/tools/metalava/compatibility/MultipleCompatibilityFilesTest.kt b/metalava/src/test/java/com/android/tools/metalava/compatibility/MultipleCompatibilityFilesTest.kt
index f0de9e46d..bd2c4c646 100644
--- a/metalava/src/test/java/com/android/tools/metalava/compatibility/MultipleCompatibilityFilesTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/compatibility/MultipleCompatibilityFilesTest.kt
@@ -16,9 +16,8 @@
 
 package com.android.tools.metalava.compatibility
 
-import com.android.tools.metalava.ARG_SHOW_ANNOTATION
 import com.android.tools.metalava.DriverTest
-import com.android.tools.metalava.model.ANDROID_SYSTEM_API
+import com.android.tools.metalava.SystemApiType
 import org.junit.Test
 
 class MultipleCompatibilityFilesTest : DriverTest() {
@@ -110,7 +109,7 @@ class MultipleCompatibilityFilesTest : DriverTest() {
     @Test
     fun `Test current system vs multiple released compatibility files`() {
         check(
-            extraArguments = arrayOf(ARG_SHOW_ANNOTATION, ANDROID_SYSTEM_API),
+            includeSystemApiAnnotations = SystemApiType.PRIVILEGED_APPS,
             checkCompatibilityApiReleasedList =
                 listOf(previouslyReleasedPublicApi, previouslyReleasedSystemApiDelta),
             signatureSource = currentCompleteSystemApi,
@@ -124,7 +123,7 @@ class MultipleCompatibilityFilesTest : DriverTest() {
     @Test
     fun `Test current system vs multiple released compatibility files (invalid first)`() {
         check(
-            extraArguments = arrayOf(ARG_SHOW_ANNOTATION, ANDROID_SYSTEM_API),
+            includeSystemApiAnnotations = SystemApiType.PRIVILEGED_APPS,
             checkCompatibilityApiReleasedList =
                 listOf("Invalid Signature File", previouslyReleasedSystemApiDelta),
             signatureSource = currentCompleteSystemApi,
@@ -138,7 +137,7 @@ class MultipleCompatibilityFilesTest : DriverTest() {
     @Test
     fun `Test current public vs multiple removed compatibility files (invalid first)`() {
         check(
-            extraArguments = arrayOf(ARG_SHOW_ANNOTATION, ANDROID_SYSTEM_API),
+            includeSystemApiAnnotations = SystemApiType.PRIVILEGED_APPS,
             checkCompatibilityRemovedApiReleasedList =
                 listOf("Invalid Signature File", previouslyReleasedPublicApi),
             signatureSource = currentCompletePublicApi,
diff --git a/metalava/src/test/java/com/android/tools/metalava/compatibility/NullnessCompatibilityTest.kt b/metalava/src/test/java/com/android/tools/metalava/compatibility/NullnessCompatibilityTest.kt
index 350e1dc52..551f9e446 100644
--- a/metalava/src/test/java/com/android/tools/metalava/compatibility/NullnessCompatibilityTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/compatibility/NullnessCompatibilityTest.kt
@@ -33,8 +33,8 @@ class NullnessCompatibilityTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                    load-api.txt:5: error: Attempted to remove nullability from java.lang.String (was NONNULL) in parameter str in test.pkg.Foo.method1(int p, Integer int2, int p1, String str, java.lang.String... args) [InvalidNullConversion]
-                    load-api.txt:7: error: Attempted to change nullability of java.lang.String (from NULLABLE to NONNULL) in parameter str in test.pkg.Foo.method3(String str, int p, int int2) [InvalidNullConversion]
+                    load-api.txt:5: error: Source breaking change: Attempted to remove nullability from java.lang.String (was NONNULL) in parameter str in test.pkg.Foo.method1(int p, Integer int2, int p1, String str, java.lang.String... args) [InvalidNullConversion]
+                    load-api.txt:7: error: Source breaking change: Attempted to change nullability of java.lang.String (from NULLABLE to NONNULL) in parameter str in test.pkg.Foo.method3(String str, int p, int int2) [InvalidNullConversion]
                 """,
             format = FileFormat.V4,
             checkCompatibilityApiReleased =
@@ -72,7 +72,7 @@ class NullnessCompatibilityTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                    src/test/pkg/test.kt:2: error: Attempted to change nullability of java.lang.String (from NULLABLE to NONNULL) in parameter str1 in test.pkg.TestKt.fun1(String str1, String str2, java.util.List<java.lang.String> list) [InvalidNullConversion]
+                    src/test/pkg/test.kt:2: error: Source breaking change: Attempted to change nullability of java.lang.String (from NULLABLE to NONNULL) in parameter str1 in test.pkg.TestKt.fun1(String str1, String str2, java.util.List<java.lang.String> list) [InvalidNullConversion]
                 """,
             format = FileFormat.V4,
             checkCompatibilityApiReleased =
@@ -101,12 +101,12 @@ class NullnessCompatibilityTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                    load-api.txt:6: error: Attempted to remove nullability from java.lang.Double (was NULLABLE) in method test.pkg.MyTest.convert3(Float) [InvalidNullConversion]
-                    load-api.txt:6: error: Attempted to remove nullability from java.lang.Float (was NULLABLE) in parameter arg1 in test.pkg.MyTest.convert3(Float arg1) [InvalidNullConversion]
-                    load-api.txt:7: error: Attempted to remove nullability from java.lang.Double (was NONNULL) in method test.pkg.MyTest.convert4(Float) [InvalidNullConversion]
-                    load-api.txt:7: error: Attempted to remove nullability from java.lang.Float (was NONNULL) in parameter arg1 in test.pkg.MyTest.convert4(Float arg1) [InvalidNullConversion]
-                    load-api.txt:8: error: Attempted to change nullability of java.lang.Float (from NULLABLE to NONNULL) in parameter arg1 in test.pkg.MyTest.convert5(Float arg1) [InvalidNullConversion]
-                    load-api.txt:9: error: Attempted to change nullability of java.lang.Double (from NONNULL to NULLABLE) in method test.pkg.MyTest.convert6(Float) [InvalidNullConversion]
+                    load-api.txt:6: error: Source breaking change: Attempted to remove nullability from java.lang.Double (was NULLABLE) in method test.pkg.MyTest.convert3(Float) [InvalidNullConversion]
+                    load-api.txt:6: error: Source breaking change: Attempted to remove nullability from java.lang.Float (was NULLABLE) in parameter arg1 in test.pkg.MyTest.convert3(Float arg1) [InvalidNullConversion]
+                    load-api.txt:7: error: Source breaking change: Attempted to remove nullability from java.lang.Double (was NONNULL) in method test.pkg.MyTest.convert4(Float) [InvalidNullConversion]
+                    load-api.txt:7: error: Source breaking change: Attempted to remove nullability from java.lang.Float (was NONNULL) in parameter arg1 in test.pkg.MyTest.convert4(Float arg1) [InvalidNullConversion]
+                    load-api.txt:8: error: Source breaking change: Attempted to change nullability of java.lang.Float (from NULLABLE to NONNULL) in parameter arg1 in test.pkg.MyTest.convert5(Float arg1) [InvalidNullConversion]
+                    load-api.txt:9: error: Source breaking change: Attempted to change nullability of java.lang.Double (from NONNULL to NULLABLE) in method test.pkg.MyTest.convert6(Float) [InvalidNullConversion]
                 """,
             format = FileFormat.V2,
             checkCompatibilityApiReleased =
@@ -151,12 +151,12 @@ class NullnessCompatibilityTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                    src/test/pkg/Outer.kt:5: error: Attempted to change nullability of java.lang.String (from NONNULL to NULLABLE) in method test.pkg.Outer.method2(String,String) [InvalidNullConversion]
-                    src/test/pkg/Outer.kt:5: error: Attempted to change nullability of java.lang.String (from NULLABLE to NONNULL) in parameter string in test.pkg.Outer.method2(String string, String maybeString) [InvalidNullConversion]
-                    src/test/pkg/Outer.kt:6: error: Attempted to change nullability of java.lang.String (from NULLABLE to NONNULL) in parameter string in test.pkg.Outer.method3(String maybeString, String string) [InvalidNullConversion]
-                    src/test/pkg/Outer.kt:8: error: Attempted to change nullability of java.lang.String (from NONNULL to NULLABLE) in method test.pkg.Outer.Inner.method2(String,String) [InvalidNullConversion]
-                    src/test/pkg/Outer.kt:8: error: Attempted to change nullability of java.lang.String (from NULLABLE to NONNULL) in parameter string in test.pkg.Outer.Inner.method2(String string, String maybeString) [InvalidNullConversion]
-                    src/test/pkg/Outer.kt:9: error: Attempted to change nullability of java.lang.String (from NULLABLE to NONNULL) in parameter string in test.pkg.Outer.Inner.method3(String maybeString, String string) [InvalidNullConversion]
+                    src/test/pkg/Outer.kt:5: error: Source breaking change: Attempted to change nullability of java.lang.String (from NONNULL to NULLABLE) in method test.pkg.Outer.method2(String,String) [InvalidNullConversion]
+                    src/test/pkg/Outer.kt:5: error: Source breaking change: Attempted to change nullability of java.lang.String (from NULLABLE to NONNULL) in parameter string in test.pkg.Outer.method2(String string, String maybeString) [InvalidNullConversion]
+                    src/test/pkg/Outer.kt:6: error: Source breaking change: Attempted to change nullability of java.lang.String (from NULLABLE to NONNULL) in parameter string in test.pkg.Outer.method3(String maybeString, String string) [InvalidNullConversion]
+                    src/test/pkg/Outer.kt:8: error: Source breaking change: Attempted to change nullability of java.lang.String (from NONNULL to NULLABLE) in method test.pkg.Outer.Inner.method2(String,String) [InvalidNullConversion]
+                    src/test/pkg/Outer.kt:8: error: Source breaking change: Attempted to change nullability of java.lang.String (from NULLABLE to NONNULL) in parameter string in test.pkg.Outer.Inner.method2(String string, String maybeString) [InvalidNullConversion]
+                    src/test/pkg/Outer.kt:9: error: Source breaking change: Attempted to change nullability of java.lang.String (from NULLABLE to NONNULL) in parameter string in test.pkg.Outer.Inner.method3(String maybeString, String string) [InvalidNullConversion]
                 """,
             format = FileFormat.V4,
             checkCompatibilityApiReleased =
@@ -237,10 +237,10 @@ class NullnessCompatibilityTest : DriverTest() {
                 ),
             expectedIssues =
                 """
-                    src/test/pkg/Foo.java:5: error: Attempted to change nullability of java.lang.String (from NONNULL to NULLABLE) in field test.pkg.Foo.changeNonNullToNullable [InvalidNullConversion]
-                    src/test/pkg/Foo.java:6: error: Attempted to remove nullability from java.lang.String (was NONNULL) in field test.pkg.Foo.changeNonNullToPlatform [InvalidNullConversion]
-                    src/test/pkg/Foo.java:7: error: Attempted to change nullability of java.lang.String (from NULLABLE to NONNULL) in field test.pkg.Foo.changeNullableToNonNull [InvalidNullConversion]
-                    src/test/pkg/Foo.java:8: error: Attempted to remove nullability from java.lang.String (was NULLABLE) in field test.pkg.Foo.changeNullableToPlatform [InvalidNullConversion]
+                    src/test/pkg/Foo.java:5: error: Source breaking change: Attempted to change nullability of java.lang.String (from NONNULL to NULLABLE) in field test.pkg.Foo.changeNonNullToNullable [InvalidNullConversion]
+                    src/test/pkg/Foo.java:6: error: Source breaking change: Attempted to remove nullability from java.lang.String (was NONNULL) in field test.pkg.Foo.changeNonNullToPlatform [InvalidNullConversion]
+                    src/test/pkg/Foo.java:7: error: Source breaking change: Attempted to change nullability of java.lang.String (from NULLABLE to NONNULL) in field test.pkg.Foo.changeNullableToNonNull [InvalidNullConversion]
+                    src/test/pkg/Foo.java:8: error: Source breaking change: Attempted to remove nullability from java.lang.String (was NULLABLE) in field test.pkg.Foo.changeNullableToPlatform [InvalidNullConversion]
                 """,
         )
     }
@@ -298,7 +298,7 @@ class NullnessCompatibilityTest : DriverTest() {
                 ),
             expectedIssues =
                 """
-                    api.txt:10: warning: Attempted to change nullability of java.lang.String (from NULLABLE to NONNULL) in method test.pkg.NonFinalClass.nonFinalMethod() (ErrorWhenNew) [InvalidNullConversion]
+                    api.txt:10: warning: Source breaking change: Attempted to change nullability of java.lang.String (from NULLABLE to NONNULL) in method test.pkg.NonFinalClass.nonFinalMethod() (ErrorWhenNew) [InvalidNullConversion]
                 """
         )
     }
@@ -356,7 +356,7 @@ class NullnessCompatibilityTest : DriverTest() {
                 ),
             expectedIssues =
                 """
-                    api.txt:10: warning: Attempted to change nullability of java.lang.String (from NONNULL to NULLABLE) in parameter arg1 in test.pkg.NonFinalClass.nonFinalMethod(String arg1) (ErrorWhenNew) [InvalidNullConversion]
+                    api.txt:10: warning: Source breaking change: Attempted to change nullability of java.lang.String (from NONNULL to NULLABLE) in parameter arg1 in test.pkg.NonFinalClass.nonFinalMethod(String arg1) (ErrorWhenNew) [InvalidNullConversion]
                 """
         )
     }
@@ -390,10 +390,10 @@ class NullnessCompatibilityTest : DriverTest() {
                 ),
             expectedIssues =
                 """
-                    api.txt:5: error: Attempted to change nullability of java.lang.String (from NONNULL to NULLABLE) in method test.pkg.Foo.foo(String[],String[],String[][]) [InvalidNullConversion]
-                    api.txt:5: error: Attempted to change nullability of java.lang.String (from NULLABLE to NONNULL) in parameter arg2 in test.pkg.Foo.foo(String[] arg1, String[] arg2, String[][] arg3) [InvalidNullConversion]
-                    api.txt:5: error: Attempted to change nullability of java.lang.String[] (from NULLABLE to NONNULL) in parameter arg3 in test.pkg.Foo.foo(String[] arg1, String[] arg2, String[][] arg3) [InvalidNullConversion]
-                    api.txt:5: error: Attempted to remove nullability from java.lang.String (was NULLABLE) in parameter arg3 in test.pkg.Foo.foo(String[] arg1, String[] arg2, String[][] arg3) [InvalidNullConversion]
+                    api.txt:5: error: Source breaking change: Attempted to change nullability of java.lang.String (from NONNULL to NULLABLE) in method test.pkg.Foo.foo(String[],String[],String[][]) [InvalidNullConversion]
+                    api.txt:5: error: Source breaking change: Attempted to change nullability of java.lang.String (from NULLABLE to NONNULL) in parameter arg2 in test.pkg.Foo.foo(String[] arg1, String[] arg2, String[][] arg3) [InvalidNullConversion]
+                    api.txt:5: error: Source breaking change: Attempted to change nullability of java.lang.String[] (from NULLABLE to NONNULL) in parameter arg3 in test.pkg.Foo.foo(String[] arg1, String[] arg2, String[][] arg3) [InvalidNullConversion]
+                    api.txt:5: error: Source breaking change: Attempted to remove nullability from java.lang.String (was NULLABLE) in parameter arg3 in test.pkg.Foo.foo(String[] arg1, String[] arg2, String[][] arg3) [InvalidNullConversion]
                 """,
         )
     }
@@ -427,8 +427,8 @@ class NullnessCompatibilityTest : DriverTest() {
                 ),
             expectedIssues =
                 """
-                    api.txt:5: error: Attempted to change nullability of java.lang.String (from NONNULL to NULLABLE) in method test.pkg.Foo.foo() [InvalidNullConversion]
-                    api.txt:5: error: Attempted to remove nullability from java.lang.Number (was NULLABLE) in method test.pkg.Foo.foo() [InvalidNullConversion]
+                    api.txt:5: error: Source breaking change: Attempted to change nullability of java.lang.String (from NONNULL to NULLABLE) in method test.pkg.Foo.foo() [InvalidNullConversion]
+                    api.txt:5: error: Source breaking change: Attempted to remove nullability from java.lang.Number (was NULLABLE) in method test.pkg.Foo.foo() [InvalidNullConversion]
                 """,
         )
     }
@@ -462,7 +462,7 @@ class NullnessCompatibilityTest : DriverTest() {
                 ),
             expectedIssues =
                 """
-                    api.txt:5: error: Attempted to change nullability of java.lang.String (from NONNULL to NULLABLE) in method test.pkg.Foo.foo() [InvalidNullConversion]
+                    api.txt:5: error: Source breaking change: Attempted to change nullability of java.lang.String (from NONNULL to NULLABLE) in method test.pkg.Foo.foo() [InvalidNullConversion]
                 """,
         )
     }
@@ -496,8 +496,8 @@ class NullnessCompatibilityTest : DriverTest() {
                 ),
             expectedIssues =
                 """
-                    api.txt:5: warning: Attempted to change nullability of java.lang.Number (from NULLABLE to NONNULL) in method test.pkg.Foo.foo() (ErrorWhenNew) [InvalidNullConversion]
-                    api.txt:5: error: Attempted to remove nullability from java.lang.String (was NONNULL) in method test.pkg.Foo.foo() [InvalidNullConversion]
+                    api.txt:5: warning: Source breaking change: Attempted to change nullability of java.lang.Number (from NULLABLE to NONNULL) in method test.pkg.Foo.foo() (ErrorWhenNew) [InvalidNullConversion]
+                    api.txt:5: error: Source breaking change: Attempted to remove nullability from java.lang.String (was NONNULL) in method test.pkg.Foo.foo() [InvalidNullConversion]
                 """,
         )
     }
diff --git a/metalava/src/test/java/com/android/tools/metalava/compatibility/ParameterNameChangeTest.kt b/metalava/src/test/java/com/android/tools/metalava/compatibility/ParameterNameChangeTest.kt
index 57c9e1069..6a6858f50 100644
--- a/metalava/src/test/java/com/android/tools/metalava/compatibility/ParameterNameChangeTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/compatibility/ParameterNameChangeTest.kt
@@ -30,7 +30,7 @@ class ParameterNameChangeTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                    load-api.txt:4: error: Attempted to change parameter name from bread to toast in method test.pkg.Foo.bar [ParameterNameChange]
+                    load-api.txt:4: error: Source breaking change: Attempted to change parameter name from bread to toast in method test.pkg.Foo.bar [ParameterNameChange]
                 """,
             signatureSource =
                 """
@@ -56,7 +56,7 @@ class ParameterNameChangeTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                    load-api.txt:4: error: Attempted to change parameter name from bread to toast in method test.pkg.Foo.bar [ParameterNameChange]
+                    load-api.txt:4: error: Source breaking change: Attempted to change parameter name from bread to toast in method test.pkg.Foo.bar [ParameterNameChange]
                 """,
             signatureSource =
                 """
@@ -83,7 +83,7 @@ class ParameterNameChangeTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                    src/test/pkg/KotlinClass.kt:4: error: Attempted to change parameter name from prevName to newName in method test.pkg.KotlinClass.method1 [ParameterNameChange]
+                    src/test/pkg/KotlinClass.kt:4: error: Source breaking change: Attempted to change parameter name from prevName to newName in method test.pkg.KotlinClass.method1 [ParameterNameChange]
                 """,
             format = FileFormat.V4,
             checkCompatibilityApiReleased =
diff --git a/metalava/src/test/java/com/android/tools/metalava/compatibility/TargetLanguageCompatibilityTest.kt b/metalava/src/test/java/com/android/tools/metalava/compatibility/TargetLanguageCompatibilityTest.kt
new file mode 100644
index 000000000..3e297518b
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/compatibility/TargetLanguageCompatibilityTest.kt
@@ -0,0 +1,327 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.compatibility
+
+import com.android.tools.metalava.DriverTest
+import org.junit.Test
+
+class TargetLanguageCompatibilityTest : DriverTest() {
+    @Test
+    fun `Test binary compatibility only issue with various target languages`() {
+        check(
+            checkCompatibilityApiReleased =
+                """
+                package test.pkg {
+                  public final class Foo {
+                    method public inline <T> void allLanguages();
+                    method @BytecodeOnly public inline <T> void bytecodeOnly();
+                    method @KotlinOnly public inline <T> void kotlinOnly();
+                  }
+                }
+                """,
+            signatureSource =
+                """
+                package test.pkg {
+                  public final class Foo {
+                    method public inline <reified T> void allLanguages();
+                    method @BytecodeOnly public inline <reified T> void bytecodeOnly();
+                    method @KotlinOnly public inline <reified T> void kotlinOnly();
+                  }
+                }
+                """,
+            expectedIssues =
+                """
+                load-api.txt:4: error: Binary breaking change: Method test.pkg.Foo.allLanguages made type variable T reified: incompatible change [AddedReified]
+                load-api.txt:5: error: Binary breaking change: Method test.pkg.Foo.bytecodeOnly made type variable T reified: incompatible change [AddedReified]
+                """,
+        )
+    }
+
+    @Test
+    fun `Test source compatibility only issue with various target languages`() {
+        check(
+            checkCompatibilityApiReleased =
+                """
+                package test.pkg {
+                  public class Foo {
+                    method public void allLanguages(int p0);
+                    method @BytecodeOnly public void bytecodeOnly(int p0);
+                    method @KotlinOnly public void kotlinOnly(int p0);
+                  }
+                }
+                """,
+            signatureSource =
+                """
+                package test.pkg {
+                  public class Foo {
+                    method public void allLanguages(int);
+                    method @BytecodeOnly public void bytecodeOnly(int);
+                    method @KotlinOnly public void kotlinOnly(int);
+                  }
+                }
+                """,
+            expectedIssues =
+                """
+                load-api.txt:4: error: Source breaking change: Attempted to remove parameter name from parameter arg1 in test.pkg.Foo.allLanguages [ParameterNameChange]
+                load-api.txt:6: error: Source breaking change: Attempted to remove parameter name from parameter arg1 in test.pkg.Foo.kotlinOnly [ParameterNameChange]
+                """,
+        )
+    }
+
+    @Test
+    fun `Test binary and source compatibility issue with different target languages`() {
+        check(
+            checkCompatibilityApiReleased =
+                """
+                package test.pkg {
+                  public class Foo {
+                    method public void allLanguages();
+                    method @BytecodeOnly public void bytecodeOnly();
+                    method @KotlinOnly public void kotlinOnly();
+                  }
+                }
+                """,
+            signatureSource =
+                """
+                package test.pkg {
+                  public class Foo {
+                    method public static void allLanguages();
+                    method @BytecodeOnly public static void bytecodeOnly();
+                    method @KotlinOnly public static void kotlinOnly();
+                  }
+                }
+                """,
+            expectedIssues =
+                """
+                load-api.txt:4: error: Binary breaking change: Method test.pkg.Foo.allLanguages has changed 'static' qualifier [ChangedStatic]
+                load-api.txt:5: error: Binary breaking change: Method test.pkg.Foo.bytecodeOnly has changed 'static' qualifier [ChangedStatic]
+                load-api.txt:6: error: Source breaking change: Method test.pkg.Foo.kotlinOnly has changed 'static' qualifier [ChangedStatic]
+                """,
+        )
+    }
+
+    @Test
+    fun `Test removal of elements with different target languages`() {
+        check(
+            checkCompatibilityApiReleased =
+                """
+                package test.pkg {
+                  public class Foo {
+                    method public void allLanguages();
+                    method @BytecodeOnly public void bytecodeOnly();
+                    method @KotlinOnly public void kotlinOnly();
+                  }
+                }
+                """,
+            signatureSource =
+                """
+                package test.pkg {
+                  public class Foo {
+                  }
+                }
+                """,
+            expectedIssues =
+                """
+                released-api.txt:4: error: Binary breaking change: Removed method test.pkg.Foo.allLanguages() [RemovedMethod]
+                released-api.txt:5: error: Binary breaking change: Removed method test.pkg.Foo.bytecodeOnly() [RemovedMethod]
+                released-api.txt:6: error: Source breaking change: Removed method test.pkg.Foo.kotlinOnly() [RemovedMethod]
+                """,
+        )
+    }
+
+    @Test
+    fun `Test switching method to bytecode-only while removing parameter name`() {
+        check(
+            checkCompatibilityApiReleased =
+                """
+                package test.pkg {
+                  public class Foo {
+                    method public void fooMethod(int p0);
+                  }
+                }
+                """,
+            signatureSource =
+                """
+                package test.pkg {
+                  public class Foo {
+                    method @BytecodeOnly public void fooMethod(int);
+                  }
+                }
+                """,
+            // No issue for removing the parameter name because the method is now bytecode-only.
+            expectedIssues =
+                """
+                released-api.txt:4: error: Source breaking change: method test.pkg.Foo.fooMethod(int) can no longer be resolved from Java source [RemovedFromJava]
+                released-api.txt:4: error: Source breaking change: method test.pkg.Foo.fooMethod(int) can no longer be resolved from Kotlin source [RemovedFromKotlin]
+                """,
+        )
+    }
+
+    @Test
+    fun `Test switching items from all target languages to kotlin only`() {
+        check(
+            checkCompatibilityApiReleased =
+                """
+                package test.pkg {
+                  public class Foo {
+                    ctor public Foo();
+                    method public void fooMethod();
+                    field public int fooField;
+                  }
+                }
+                """,
+            signatureSource =
+                """
+                package test.pkg {
+                  @KotlinOnly public class Foo {
+                    ctor @KotlinOnly public Foo();
+                    method @KotlinOnly public void fooMethod();
+                    field @KotlinOnly public int fooField;
+                  }
+                }
+                """,
+            expectedIssues =
+                """
+                released-api.txt:3: error: Binary breaking change: class test.pkg.Foo has been removed from bytecode [RemovedFromBytecode]
+                released-api.txt:3: error: Source breaking change: class test.pkg.Foo can no longer be resolved from Java source [RemovedFromJava]
+                released-api.txt:4: error: Binary breaking change: constructor test.pkg.Foo() has been removed from bytecode [RemovedFromBytecode]
+                released-api.txt:4: error: Source breaking change: constructor test.pkg.Foo() can no longer be resolved from Java source [RemovedFromJava]
+                released-api.txt:5: error: Binary breaking change: method test.pkg.Foo.fooMethod() has been removed from bytecode [RemovedFromBytecode]
+                released-api.txt:5: error: Source breaking change: method test.pkg.Foo.fooMethod() can no longer be resolved from Java source [RemovedFromJava]
+                released-api.txt:6: error: Binary breaking change: field test.pkg.Foo.fooField has been removed from bytecode [RemovedFromBytecode]
+                released-api.txt:6: error: Source breaking change: field test.pkg.Foo.fooField can no longer be resolved from Java source [RemovedFromJava]
+                """,
+        )
+    }
+
+    @Test
+    fun `Test switching items from all target languages to bytecode only`() {
+        check(
+            checkCompatibilityApiReleased =
+                """
+                package test.pkg {
+                  public class Foo {
+                    ctor public Foo();
+                    method public void fooMethod();
+                    field public int fooField;
+                  }
+                }
+                """,
+            signatureSource =
+                """
+                package test.pkg {
+                  @BytecodeOnly public class Foo {
+                    ctor @BytecodeOnly public Foo();
+                    method @BytecodeOnly public void fooMethod();
+                    field @BytecodeOnly public int fooField;
+                  }
+                }
+                """,
+            expectedIssues =
+                """
+                released-api.txt:3: error: Source breaking change: class test.pkg.Foo can no longer be resolved from Java source [RemovedFromJava]
+                released-api.txt:3: error: Source breaking change: class test.pkg.Foo can no longer be resolved from Kotlin source [RemovedFromKotlin]
+                released-api.txt:4: error: Source breaking change: constructor test.pkg.Foo() can no longer be resolved from Java source [RemovedFromJava]
+                released-api.txt:4: error: Source breaking change: constructor test.pkg.Foo() can no longer be resolved from Kotlin source [RemovedFromKotlin]
+                released-api.txt:5: error: Source breaking change: method test.pkg.Foo.fooMethod() can no longer be resolved from Java source [RemovedFromJava]
+                released-api.txt:5: error: Source breaking change: method test.pkg.Foo.fooMethod() can no longer be resolved from Kotlin source [RemovedFromKotlin]
+                released-api.txt:6: error: Source breaking change: field test.pkg.Foo.fooField can no longer be resolved from Java source [RemovedFromJava]
+                released-api.txt:6: error: Source breaking change: field test.pkg.Foo.fooField can no longer be resolved from Kotlin source [RemovedFromKotlin]
+                """,
+        )
+    }
+
+    @Test
+    fun `Test switching items from inaccessible from one source language to bytecode only`() {
+        check(
+            checkCompatibilityApiReleased =
+                """
+                package test.pkg {
+                  public class Foo {
+                    ctor @InaccessibleFromJava public Foo();
+                    method @InaccessibleFromKotlin public void fooMethod();
+                  }
+                }
+                """,
+            signatureSource =
+                """
+                package test.pkg {
+                  public class Foo {
+                    ctor @BytecodeOnly public Foo();
+                    method @BytecodeOnly public void fooMethod();
+                  }
+                }
+                """,
+            expectedIssues =
+                """
+                released-api.txt:4: error: Source breaking change: constructor test.pkg.Foo() can no longer be resolved from Kotlin source [RemovedFromKotlin]
+                released-api.txt:5: error: Source breaking change: method test.pkg.Foo.fooMethod() can no longer be resolved from Java source [RemovedFromJava]
+                """,
+        )
+    }
+
+    @Test
+    fun `Test expanding number of target languages`() {
+        check(
+            checkCompatibilityApiReleased =
+                """
+                package test.pkg {
+                  public class Foo {
+                    ctor @BytecodeOnly public Foo();
+                    method @KotlinOnly public void fooMethod();
+                    field @InaccessibleFromJava public int fooField;
+                  }
+                }
+                """,
+            signatureSource =
+                """
+                package test.pkg {
+                  public class Foo {
+                    ctor @InaccessibleFromKotlin public Foo();
+                    method @InaccessibleFromJava public void fooMethod();
+                    field public int fooField;
+                  }
+                }
+                """,
+            expectedIssues = "",
+        )
+    }
+
+    @Test
+    fun `Test both adding and removing target languages`() {
+        check(
+            checkCompatibilityApiReleased =
+                """
+                package test.pkg {
+                  @KotlinOnly public class Foo {
+                  }
+                }
+                """,
+            signatureSource =
+                """
+                package test.pkg {
+                  @InaccessibleFromKotlin public class Foo {
+                  }
+                }
+                """,
+            expectedIssues =
+                """
+                released-api.txt:3: error: Source breaking change: class test.pkg.Foo can no longer be resolved from Kotlin source [RemovedFromKotlin]
+                """,
+        )
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/compatibility/ThrowsCompatibilityTest.kt b/metalava/src/test/java/com/android/tools/metalava/compatibility/ThrowsCompatibilityTest.kt
index 97e61935d..c6dc138b9 100644
--- a/metalava/src/test/java/com/android/tools/metalava/compatibility/ThrowsCompatibilityTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/compatibility/ThrowsCompatibilityTest.kt
@@ -31,11 +31,11 @@ class ThrowsCompatibilityTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                    src/test/pkg/MyClass.java:7: error: Method test.pkg.MyClass.method1 added thrown exception java.io.IOException [ChangedThrows]
-                    src/test/pkg/MyClass.java:8: error: Method test.pkg.MyClass.method2 no longer throws exception java.io.IOException [ChangedThrows]
-                    src/test/pkg/MyClass.java:9: error: Method test.pkg.MyClass.method3 added thrown exception java.lang.UnsupportedOperationException [ChangedThrows]
-                    src/test/pkg/MyClass.java:9: error: Method test.pkg.MyClass.method3 no longer throws exception java.io.IOException [ChangedThrows]
-                    src/test/pkg/MyClass.java:9: error: Method test.pkg.MyClass.method3 no longer throws exception java.lang.NumberFormatException [ChangedThrows]
+                    src/test/pkg/MyClass.java:7: error: Binary breaking change: Method test.pkg.MyClass.method1 added thrown exception java.io.IOException [ChangedThrows]
+                    src/test/pkg/MyClass.java:8: error: Binary breaking change: Method test.pkg.MyClass.method2 no longer throws exception java.io.IOException [ChangedThrows]
+                    src/test/pkg/MyClass.java:9: error: Binary breaking change: Method test.pkg.MyClass.method3 added thrown exception java.lang.UnsupportedOperationException [ChangedThrows]
+                    src/test/pkg/MyClass.java:9: error: Binary breaking change: Method test.pkg.MyClass.method3 no longer throws exception java.io.IOException [ChangedThrows]
+                    src/test/pkg/MyClass.java:9: error: Binary breaking change: Method test.pkg.MyClass.method3 no longer throws exception java.lang.NumberFormatException [ChangedThrows]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -74,10 +74,10 @@ class ThrowsCompatibilityTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                    src/test/pkg/MyClass.kt:4: error: Constructor test.pkg.MyClass added thrown exception test.pkg.MyException [ChangedThrows]
-                    src/test/pkg/MyClass.kt:9: error: Method test.pkg.MyClass.method1 added thrown exception test.pkg.MyException [ChangedThrows]
-                    src/test/pkg/MyClass.kt:12: error: Method test.pkg.MyClass.getProperty1 added thrown exception test.pkg.MyException [ChangedThrows]
-                    src/test/pkg/MyClass.kt:15: error: Method test.pkg.MyClass.getProperty2 added thrown exception test.pkg.MyException [ChangedThrows]
+                    src/test/pkg/MyClass.kt:4: error: Binary breaking change: Constructor test.pkg.MyClass added thrown exception test.pkg.MyException [ChangedThrows]
+                    src/test/pkg/MyClass.kt:9: error: Binary breaking change: Method test.pkg.MyClass.method1 added thrown exception test.pkg.MyException [ChangedThrows]
+                    src/test/pkg/MyClass.kt:12: error: Binary breaking change: Method test.pkg.MyClass.getProperty1 added thrown exception test.pkg.MyException [ChangedThrows]
+                    src/test/pkg/MyClass.kt:15: error: Binary breaking change: Method test.pkg.MyClass.getProperty2 added thrown exception test.pkg.MyException [ChangedThrows]
                 """,
             checkCompatibilityApiReleased =
                 """
@@ -125,11 +125,11 @@ class ThrowsCompatibilityTest : DriverTest() {
         check(
             expectedIssues =
                 """
-                    src/test/pkg/MyClass.java:7: error: Method test.pkg.MyClass.method1 added thrown exception T (extends java.lang.Throwable)} [ChangedThrows]
-                    src/test/pkg/MyClass.java:8: error: Method test.pkg.MyClass.method2 no longer throws exception T (extends java.lang.Throwable)} [ChangedThrows]
-                    src/test/pkg/MyClass.java:9: error: Method test.pkg.MyClass.method3 added thrown exception X (extends java.io.FileNotFoundException)} [ChangedThrows]
-                    src/test/pkg/MyClass.java:10: error: Method test.pkg.MyClass.method4 added thrown exception X (extends java.io.IOException)} [ChangedThrows]
-                    src/test/pkg/MyClass.java:10: error: Method test.pkg.MyClass.method4 no longer throws exception X (extends java.io.FileNotFoundException)} [ChangedThrows]
+                    src/test/pkg/MyClass.java:7: error: Binary breaking change: Method test.pkg.MyClass.method1 added thrown exception T (extends java.lang.Throwable)} [ChangedThrows]
+                    src/test/pkg/MyClass.java:8: error: Binary breaking change: Method test.pkg.MyClass.method2 no longer throws exception T (extends java.lang.Throwable)} [ChangedThrows]
+                    src/test/pkg/MyClass.java:9: error: Binary breaking change: Method test.pkg.MyClass.method3 added thrown exception X (extends java.io.FileNotFoundException)} [ChangedThrows]
+                    src/test/pkg/MyClass.java:10: error: Binary breaking change: Method test.pkg.MyClass.method4 added thrown exception X (extends java.io.IOException)} [ChangedThrows]
+                    src/test/pkg/MyClass.java:10: error: Binary breaking change: Method test.pkg.MyClass.method4 no longer throws exception X (extends java.io.FileNotFoundException)} [ChangedThrows]
                 """,
             checkCompatibilityApiReleased =
                 """
diff --git a/metalava/src/test/java/com/android/tools/metalava/config/BuildPropertiesConfigTest.kt b/metalava/src/test/java/com/android/tools/metalava/config/BuildPropertiesConfigTest.kt
new file mode 100644
index 000000000..f5bf75901
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/config/BuildPropertiesConfigTest.kt
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.config
+
+import com.android.tools.metalava.testing.xml
+import org.junit.Test
+
+class BuildPropertiesConfigTest : BaseConfigParserTest() {
+    @Test
+    fun `Empty build-properties config should error`() {
+        runTest(
+            xml(
+                "config.xml",
+                """
+                    <config xmlns="http://www.google.com/tools/metalava/config">
+                      <build-properties>
+                      </build-properties>
+                    </config>
+                """
+            ),
+            expectedFail =
+                """
+                    Errors found while parsing configuration file(s):
+                        file:TESTROOT/config.xml:3: cvc-complex-type.2.4.b: The content of element 'build-properties' is not complete. One of '{"http://www.google.com/tools/metalava/config":build-property}' is expected.
+                """,
+        )
+    }
+
+    @Test
+    fun `Simple build-properties config`() {
+        roundTrip(
+            Config(
+                buildProperties =
+                    BuildPropertiesConfig(
+                        properties =
+                            listOf(BuildPropertyConfig(name = "BUILD_NUMBER", value = "51234"))
+                    )
+            ),
+            """
+                <config xmlns="http://www.google.com/tools/metalava/config">
+                  <build-properties>
+                    <build-property name="BUILD_NUMBER" value="51234"/>
+                  </build-properties>
+                </config>
+            """,
+        )
+    }
+
+    @Test
+    fun `Multiple properties build-properties config`() {
+        roundTrip(
+            Config(
+                buildProperties =
+                    BuildPropertiesConfig(
+                        properties =
+                            listOf(
+                                BuildPropertyConfig(name = "BUILD_NUMBER", value = "51234"),
+                                BuildPropertyConfig(name = "TARGET", value = "sdk"),
+                                BuildPropertyConfig(name = "MAKE_FILE", value = "Android.bp")
+                            )
+                    )
+            ),
+            """
+                <config xmlns="http://www.google.com/tools/metalava/config">
+                  <build-properties>
+                    <build-property name="BUILD_NUMBER" value="51234"/>
+                    <build-property name="TARGET" value="sdk"/>
+                    <build-property name="MAKE_FILE" value="Android.bp"/>
+                  </build-properties>
+                </config>
+            """,
+        )
+    }
+
+    @Test
+    fun `Duplicate property should error`() {
+        runTest(
+            xml(
+                "config.xml",
+                """
+                    <config xmlns="http://www.google.com/tools/metalava/config">
+                      <build-properties>
+                        <build-property name="BUILD_NUMBER" value="51234"/>
+                        <build-property name="BUILD_NUMBER" value="61234"/>
+                      </build-properties>
+                    </config>
+                """
+            ),
+            expectedFail =
+                """
+                    Errors found while parsing configuration file(s):
+                        file:TESTROOT/config.xml:4: cvc-identity-constraint.4.2.2: Duplicate key value [BUILD_NUMBER] declared for identity constraint "BuildPropertyName" of element "config".
+                """,
+        )
+    }
+
+    @Test
+    fun `Non-alphanumeric build-property name should error`() {
+        runTest(
+            xml(
+                "config.xml",
+                """
+                    <config xmlns="http://www.google.com/tools/metalava/config">
+                      <build-properties>
+                        <build-property name="BUILD_NUMBER_2" value="51234"/>
+                        <build-property name="<BUILD_NUMBER>" value="61234"/>
+                      </build-properties>
+                    </config>
+                """
+            ),
+            expectedFail =
+                """
+                    Errors found while parsing configuration file(s):
+                        file:TESTROOT/config.xml:4: The value of attribute "name" associated with an element type "build-property" must not contain the '<' character.
+                """,
+        )
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerRangeTest.kt b/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerRangeTest.kt
index b98aa7d40..ea3a5139b 100644
--- a/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerRangeTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerRangeTest.kt
@@ -19,6 +19,7 @@ package com.android.tools.metalava.doc
 import com.android.tools.metalava.DriverTest
 import com.android.tools.metalava.intDefAnnotationSource
 import com.android.tools.metalava.intRangeAnnotationSource
+import com.android.tools.metalava.testing.KnownSourceFiles.floatRangeAnnotationSource
 import com.android.tools.metalava.testing.java
 import org.junit.Test
 
@@ -134,7 +135,7 @@ class DocAnalyzerRangeTest : DriverTest() {
                     public class TypedefTest {
                     public TypedefTest() { throw new RuntimeException("Stub!"); }
                     /**
-                     * @param flags Value is either <code>0</code> or a combination of {@link test.pkg.TypedefTest#STYLE_NORMAL}, {@link test.pkg.TypedefTest#STYLE_NO_TITLE}, {@link test.pkg.TypedefTest#STYLE_NO_FRAME}, {@link test.pkg.TypedefTest#STYLE_NO_INPUT}, 2, and 3 + 1
+                     * @param flags Value is either <code>0</code> or a combination of {@link test.pkg.TypedefTest#STYLE_NORMAL}, {@link test.pkg.TypedefTest#STYLE_NO_TITLE}, {@link test.pkg.TypedefTest#STYLE_NO_FRAME}, {@link test.pkg.TypedefTest#STYLE_NO_INPUT}, 2, and 4
                      */
                     public void setFlags(java.lang.Object first, int flags) { throw new RuntimeException("Stub!"); }
                     /**
@@ -582,4 +583,56 @@ class DocAnalyzerRangeTest : DriverTest() {
                 )
         )
     }
+
+    @Test
+    fun `Test different values`() {
+        check(
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            import android.annotation.FloatRange;
+                            import android.annotation.IntRange;
+                            public class RangeTest {
+                                /**
+                                 * Blah.
+                                 */
+                                public int test1(
+                                    @IntRange(from = Integer.MIN_VALUE) int i1,
+                                    @IntRange(from = Integer.MAX_VALUE - 1) int i2,
+                                    @IntRange(from = 1L << 40) int i3,
+                                    @FloatRange(from = 10.5f) int f1,
+                                    @FloatRange(from = 10.0E112) int f2) { }
+                            }
+                        """
+                    ),
+                    floatRangeAnnotationSource,
+                    intRangeAnnotationSource,
+                ),
+            checkCompilation = true,
+            docStubs = true,
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public class RangeTest {
+                            public RangeTest() { throw new RuntimeException("Stub!"); }
+                            /**
+                             * Blah.
+                             * @param i1 Value is {@link java.lang.Integer#MIN_VALUE} or greater
+                             * @param i2 Value is 2147483646 or greater
+                             * @param i3 Value is 1099511627776L or greater
+                             * @param f1 Value is 10.5f or greater
+                             * @param f2 Value is 1.0E113 or greater
+                             */
+                            public int test1(int i1, int i2, int i3, int f1, int f2) { throw new RuntimeException("Stub!"); }
+                            }
+                        """
+                    ),
+                ),
+        )
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerTest.kt b/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerTest.kt
index 070168df3..a69d7055d 100644
--- a/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerTest.kt
@@ -20,6 +20,7 @@ import com.android.tools.lint.checks.infrastructure.TestFiles
 import com.android.tools.metalava.ARG_CURRENT_CODENAME
 import com.android.tools.metalava.ARG_CURRENT_VERSION
 import com.android.tools.metalava.DriverTest
+import com.android.tools.metalava.SystemApiType
 import com.android.tools.metalava.columnSource
 import com.android.tools.metalava.lint.DefaultLintErrorMessage
 import com.android.tools.metalava.model.provider.Capability
@@ -919,7 +920,7 @@ class DocAnalyzerTest : DriverTest() {
                     ARG_CURRENT_VERSION,
                     "35" // not real api level of Z
                 ),
-            includeSystemApiAnnotations = true,
+            includeSystemApiAnnotations = SystemApiType.PRIVILEGED_APPS,
             sourceFiles =
                 arrayOf(
                     java(
@@ -963,6 +964,7 @@ class DocAnalyzerTest : DriverTest() {
                     public static final java.lang.String UNIT_TEST_1 = "unit.test.1";
                     /**
                      * @hide
+                     * @apiSince Z
                      */
                     public static final java.lang.String UNIT_TEST_2 = "unit.test.2";
                     }
@@ -980,7 +982,6 @@ class DocAnalyzerTest : DriverTest() {
                     ARG_CURRENT_CODENAME,
                     "Z",
                 ),
-            includeSystemApiAnnotations = true,
             sourceFiles =
                 arrayOf(
                     java(
diff --git a/metalava/src/test/java/com/android/tools/metalava/doc/RestrictedForEnvironmentTest.kt b/metalava/src/test/java/com/android/tools/metalava/doc/RestrictedForEnvironmentTest.kt
index c361f4a00..85ad846bc 100644
--- a/metalava/src/test/java/com/android/tools/metalava/doc/RestrictedForEnvironmentTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/doc/RestrictedForEnvironmentTest.kt
@@ -54,16 +54,13 @@ class RestrictedForEnvironmentTest : DriverTest() {
             api =
                 """
                     package test.pkg {
-                      @RestrictedForEnvironment(environments=$packageName.RestrictedForEnvironment.Environment.SDK_SANDBOX, from=14) public class MyClass1 {
+                      @RestrictedForEnvironment(environments=$packageName.RestrictedForEnvironment.ENVIRONMENT_SDK_RUNTIME, from=14) public class MyClass1 {
                         ctor public MyClass1();
                       }
                     }
                 """,
             docStubs = true,
             skipEmitPackages = listOf(packageName),
-            // TODO(b/396346859): Resolve hidden environments field
-            expectedIssues =
-                "src/$packageDir/RestrictedForEnvironment.java:12: error: Typedef class references hidden field field RestrictedForEnvironment.Environment.SDK_SANDBOX: removed from typedef metadata [HiddenTypedefConstant]",
             extractAnnotations =
                 mapOf(
                     "test.pkg" to
@@ -72,6 +69,7 @@ class RestrictedForEnvironmentTest : DriverTest() {
                             <root>
                               <item name="test.pkg.MyClass1">
                                 <annotation name="androidx.annotation.RestrictedForEnvironment">
+                                  <val name="environments" val="&quot;SDK Runtime&quot;" />
                                   <val name="from" val="14" />
                                 </annotation>
                               </item>
@@ -101,8 +99,8 @@ class RestrictedForEnvironmentTest : DriverTest() {
     @Test
     fun `Check RestrictedForEnvironment handling for SDK_SANDBOX env - android`() {
         checkRestrictedForEnvironmentHandling(
-            "android.annotation.RestrictedForEnvironment.Environment.SDK_SANDBOX",
-            "SDK_SANDBOX",
+            "android.annotation.RestrictedForEnvironment.ENVIRONMENT_SDK_RUNTIME",
+            "ENVIRONMENT_SDK_RUNTIME",
             packageName = ANDROID_ANNOTATION_PACKAGE,
             restrictedForEnvironmentClass = androidRestrictedForEnvironment
         )
@@ -111,8 +109,8 @@ class RestrictedForEnvironmentTest : DriverTest() {
     @Test
     fun `Check RestrictedForEnvironment handling for SDK_SANDBOX env - androidx`() {
         checkRestrictedForEnvironmentHandling(
-            "androidx.annotation.RestrictedForEnvironment.Environment.SDK_SANDBOX",
-            "SDK_SANDBOX"
+            "androidx.annotation.RestrictedForEnvironment.ENVIRONMENT_SDK_RUNTIME",
+            "ENVIRONMENT_SDK_RUNTIME"
         )
     }
 
@@ -120,7 +118,7 @@ class RestrictedForEnvironmentTest : DriverTest() {
     fun `Check RestrictedForEnvironment handling for partial nested SDK_SANDBOX env - androidx`() {
         checkRestrictedForEnvironmentHandling(
             "androidx.annotation.RestrictedForEnvironment",
-            "RestrictedForEnvironment.Environment.SDK_SANDBOX"
+            "RestrictedForEnvironment.ENVIRONMENT_SDK_RUNTIME"
         )
     }
 
@@ -128,7 +126,7 @@ class RestrictedForEnvironmentTest : DriverTest() {
     fun `Check RestrictedForEnvironment handling for fully nested SDK_SANDBOX env - androidx`() {
         checkRestrictedForEnvironmentHandling(
             "androidx",
-            "androidx.annotation.RestrictedForEnvironment.Environment.SDK_SANDBOX"
+            "androidx.annotation.RestrictedForEnvironment.ENVIRONMENT_SDK_RUNTIME"
         )
     }
 
@@ -141,12 +139,12 @@ class RestrictedForEnvironmentTest : DriverTest() {
                         """
                             package test.pkg;
                             import androidx.annotation.RestrictedForEnvironment;
-                            import static androidx.annotation.RestrictedForEnvironment.Environment.SDK_SANDBOX;
+                            import static androidx.annotation.RestrictedForEnvironment.ENVIRONMENT_SDK_RUNTIME;
                             /**
                             * Javadoc for MyClass1
                             */
-                            @RestrictedForEnvironment(environments = SDK_SANDBOX, from = 14)
-                            @RestrictedForEnvironment(environments = SDK_SANDBOX, from = 16)
+                            @RestrictedForEnvironment(environments = ENVIRONMENT_SDK_RUNTIME, from = 14)
+                            @RestrictedForEnvironment(environments = ENVIRONMENT_SDK_RUNTIME, from = 16)
                             public class MyClass1 {
                             }
                         """
@@ -155,9 +153,6 @@ class RestrictedForEnvironmentTest : DriverTest() {
                 ),
             docStubs = true,
             skipEmitPackages = listOf("androidx.annotation"),
-            // TODO(b/396346859): Resolve hidden environments field
-            expectedIssues =
-                "src/androidx/annotation/RestrictedForEnvironment.java:12: error: Typedef class references hidden field field RestrictedForEnvironment.Environment.SDK_SANDBOX: removed from typedef metadata [HiddenTypedefConstant]\nsrc/androidx/annotation/RestrictedForEnvironment.java:12: error: Typedef class references hidden field field RestrictedForEnvironment.Environment.SDK_SANDBOX: removed from typedef metadata [HiddenTypedefConstant]",
             extractAnnotations =
                 mapOf(
                     "test.pkg" to
@@ -166,9 +161,11 @@ class RestrictedForEnvironmentTest : DriverTest() {
                             <root>
                               <item name="test.pkg.MyClass1">
                                 <annotation name="androidx.annotation.RestrictedForEnvironment">
+                                  <val name="environments" val="&quot;SDK Runtime&quot;" />
                                   <val name="from" val="14" />
                                 </annotation>
                                 <annotation name="androidx.annotation.RestrictedForEnvironment">
+                                  <val name="environments" val="&quot;SDK Runtime&quot;" />
                                   <val name="from" val="16" />
                                 </annotation>
                               </item>
diff --git a/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintBaselineTest.kt b/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintBaselineTest.kt
index 81e976395..82aaafed7 100644
--- a/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintBaselineTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintBaselineTest.kt
@@ -169,11 +169,13 @@ class ApiLintBaselineTest : DriverTest() {
                     """
                     )
                 ),
-            expectedFail = """
-                *** api-lint failed ***
-            """,
-            expectedOutput = """
-                *** api-lint failed ***
+            expectedFail =
+                """
+                    *** api-lint failed ***
+                """,
+            expectedOutput =
+                """
+                    *** api-lint failed ***
                 """
         )
     }
diff --git a/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintTest.kt b/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintTest.kt
index 79ffb3806..5554a6a6e 100644
--- a/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/lint/ApiLintTest.kt
@@ -16,6 +16,7 @@
 
 package com.android.tools.metalava.lint
 
+import com.android.tools.lint.checks.infrastructure.TestFiles.base64gzip
 import com.android.tools.metalava.DriverTest
 import com.android.tools.metalava.androidxNonNullSource
 import com.android.tools.metalava.androidxNullableSource
@@ -1580,7 +1581,8 @@ class ApiLintTest : DriverTest() {
         // TODO: This check is not yet hooked up
         check(
             apiLint = "", // enabled
-            expectedIssues = """
+            expectedIssues =
+                """
                 """,
             sourceFiles =
                 arrayOf(
@@ -3233,4 +3235,80 @@ src/android/pkg/Interface.kt:158: error: Parameter `default` has a default value
                 "src/test/pkg/Foo.kt:2: error: Exposing data classes as public API is discouraged because they are difficult to update while maintaining binary compatibility. [DataClassDefinition]"
         )
     }
+
+    @RequiresCapabilities(Capability.KOTLIN, Capability.JAR_WITH_SOURCES)
+    @Test
+    fun `Checks do not run on bytecode-only items`() {
+        check(
+            apiLint = "", // enabled
+            expectedFail = DefaultLintErrorMessage,
+            // Error is only on the source element, not the mangled version in bytecode.
+            expectedIssues =
+                "src/test/pkg/IntValue.kt:4: error: Method name must start with lowercase char: FunWithBadName [StartWithLower]",
+            extraArguments = arrayOf(ARG_HIDE, "ValueClassDefinition"),
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                        package test.pkg
+                        @JvmInline value class IntValue(val v: Int)
+                        class Foo {
+                            fun FunWithBadName(iv: IntValue) = Unit
+                        }
+                        """
+                    )
+                ),
+            // Compiled from the source above with [generateBase64gzipFromKotlin]
+            compiledSourceJar =
+                base64gzip(
+                    "test.jar",
+                    // kotlinc version info: kotlinc-jvm 1.9.23 (JRE 17.0.6+10-b802.1)
+                    "" +
+                        "H4sIAAAAAAAA/31VeTQUahufmBmyDsYu0vhKlhkNksmSO0bXDBljiwzGFsJg" +
+                        "ZoRLcxVuZrpXZUvKxRWR7HRlzT5mPpIlW7JkGcl6KVy56jvn+9T56nnP74/3" +
+                        "nPf5Pe/7nN/7/PA4XiAUwM/PDwAAlAH7AwoAAiwxtiaa5ufMEJYm58zNMDa2" +
+                        "cEuzj50AwJolh22B04T3COM01bo43eUErT7t8ekQONZSw9yyh1ZQQVjGagar" +
+                        "YTkcdfvlLgSLxZmanpzmAeBxfPzFEseL9fcK6O0B/83y0nugelGoiKBLFxHm" +
+                        "gVR7kj/NC+7hT6JQomxf2cjbQXdfpRf/2zs6/TmhLHMDPRKTcLTV6RE0J7OS" +
+                        "mWX30LqzVzy06Yey+CHL3IRaruv4NQRqa1xQFGUTXaotMplOT5wKW/RO1FKe" +
+                        "sggx7jKcvdy1eZ+ysUSn7/I2Ev1PqBiy10PWd0K6gmqzHX2dTmiBSy9WcZxb" +
+                        "qZ3VeSM/2bOYyi0Q+AWXW8pJLDmhQgwdjRbCKigER2yEBqSSKoIOUDJIHY8C" +
+                        "woRHjncP90fEToS0dUhFuAyTcy4/cK0arVA/bQ+LE4ub4x0prcMYx2THqRDU" +
+                        "gGay4oes0gauXmXn+A68TSlv1kqvnpvOnmpk1capy6Te8Y1jmYhlONy7yUgk" +
+                        "BE/vSrqmMshaqodEZOBeYM/iCbki3Ct509wh1VldIdL5f4WSxaNrcmtqCCOl" +
+                        "PDzNUMVk5SG0skhhmacfw5lWocs5/MhdrlwOudpyC1ZfWHzXu1U4sw1pltUw" +
+                        "vjY0K+TXO1RUt1ypU/vrw4p6NiQ/vMb+mjKth3GHjGYLiPL0B/FRxGd3QgUw" +
+                        "kiRHE+sC/aKXPim1TjB+HPfDBowj4qM+xCOqMogGv3PGhjNOeMggQS4NsFT9" +
+                        "JtWFl7WMd282nPpH/R75naLeepy2YFDomFHtEXGUFVYpmS1LColng/rebavQ" +
+                        "SWx5/fHTwL97uc9oyQmUZGYvb/IVZ1U1hyMVx3wSXhhZnHboqneRMza8MxVe" +
+                        "ZXCbIVC0Fjm30O5z/iCzowAOfdo+C82anwhOuZiwu1W1cxcyXABBE9I9OanC" +
+                        "ibEQmIoE0ZGQM5BItI090tOMtW3pqic5x2G5U6NJo2Pvr0cNKQrBQO4T5uVP" +
+                        "A3Qz0kYkcSmV9kh1TDmJ/dNhheFlzouPdx1FF+fNHg+pOib4h5sX6x3qLnLC" +
+                        "jFRy17Om+gx6y/OzbQPOgVLGbFZtTI45VvBnq2zeC9Q313h3Kz8VL8pttM7R" +
+                        "nRfUr18WjgSpzJn239QWk2nAya1q7gi4r8mkEjzOPl+H1R4tO/tnRIwefcXw" +
+                        "/ZkXYeyEaJa54JlAsJgq8qrE6PwT66e/+V7hSZe//3BdYtRoQfs69T6H2rtA" +
+                        "ub30hKuftcLvn0EILRv6i2v8rAGtQj0VJXAl5rLUX6ylad3Rmbc4J4/xFbrW" +
+                        "aJwCTDkNROroNczGgoOUlkDjZXCCOpz3rtGzSER2VbjB9R8zIinPpitAM8zo" +
+                        "ahTtRmx+/OvMj6iS0ACNSuaDLctGfkopbqb/Z/mi9+VNI5qwFx8AuOgNzUnT" +
+                        "+lbXaPJ8+/nFYgcDLWwnwp5ehyK2gan2cuofShANMUYrvO4Tv4uJrHf8BhnC" +
+                        "zVZjx//4eR6ouLkZ7L813718b4OIirLY9kDqVkGQJX7jErygwh4xK6GC9bwL" +
+                        "bnCj5i0pM6IP/KRzy9+0HswApgXT1xrlGpIw09l6jykrLSv9MnLiJnNi9/PM" +
+                        "seWKySCAAMAI3/dmjvj+mWNGJv9n3BCtLcm9ZyBRNecU2s1t8mJvg1WV6iqS" +
+                        "G32BxyDiGIYnlAHsMHxTYV4YKk/PXEC9kVmxGlcK4gk+Y/3nyh+Q8kAxJaPa" +
+                        "8DXvsYWurfbu4tcAg0Y4mngWu00+lncFwVZzExqrvnPQWIqbvxsSpvgrFSR1" +
+                        "bed8LsGYVLKx0YzqLCEm4UmqXO18GbmdBj5D98H5aW5838Wz7pEat+dcTlmN" +
+                        "0WYkkAugbWXeVG2wlJbOdqJFO3Ld1dTpRqyU5wyLky2P5LXjzXRZXa3Wcfxl" +
+                        "8MPNCc9qn5raVuKipjT8stBEUZYZJexS9dyqyGm1YqNh2/Cx1cKTS0lPqxxy" +
+                        "fei7TSmCasn3GLOFY2uMC6H2SqEozo0lJMVn6rWmzMndBdkcFDRYsSfqUsPm" +
+                        "Tnyu8O9eHn7EJbYOqiuRpBMFiztxXH7HX2USb/GAhcC8p6VYnbW2uuu5bZfh" +
+                        "l2aaZXu7wKpXp/cHtobdKWCetJ5SHrNH9PBoFkePjC6NXJbtysuOZD6Hmwo+" +
+                        "OfhWWvhh04NB08f4G5ukHqv0j2QNybbHzMkHPSW6Ovz6i9AdveBU94QkmtyS" +
+                        "sBvIBzzIXxKvbhqsmyn7EuwmoOkvircLkhwWqGpav1p4fBT/8Hgf/cAnVbQd" +
+                        "IUYOHAAAUnm+pwr5PfzXCANIvoHwS2Sqv2+gawDZk+bv5eHm5ua9B6D7ObAq" +
+                        "3v25O+Cz4taP1NZJ7GXKfHa5AzxQwP/Y9zvgJ5v9Mr5lul+z7Ne09BcM9G97" +
+                        "59ck+1sg/gXJGvD/fYav8/c/U/6L/IN8320bHgcCfzoG3FvQvQt48X3a/QMK" +
+                        "X7YyjwgAAA=="
+                )
+        )
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/snapshot/SnapshotTest.kt b/metalava/src/test/java/com/android/tools/metalava/snapshot/SnapshotTest.kt
new file mode 100644
index 000000000..bdc8109c4
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/snapshot/SnapshotTest.kt
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.snapshot
+
+import com.android.tools.metalava.DriverTest
+import com.android.tools.metalava.cli.common.CheckerContext
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.DelegatedVisitor
+import com.android.tools.metalava.model.ItemVisitor
+import com.android.tools.metalava.model.snapshot.CodebaseSnapshotTaker
+import com.android.tools.metalava.model.visitors.ApiFilters
+import com.android.tools.metalava.model.visitors.ApiPredicate
+import com.android.tools.metalava.model.visitors.ApiType
+import com.android.tools.metalava.model.visitors.FilteringApiVisitor
+import com.android.tools.metalava.testing.KnownSourceFiles
+import com.android.tools.metalava.testing.java
+import kotlin.test.assertNull
+import org.junit.Test
+
+/** Test [CodebaseSnapshotTaker] use within the main metalava code. */
+class SnapshotTest : DriverTest() {
+    private fun CheckerContext.takeSnapshotOfPublicApi(): Codebase {
+        val apiPredicateConfig = ApiPredicate.Config()
+        val apiFilters =
+            ApiFilters(
+                ApiType.PUBLIC_API.getEmitFilter(apiPredicateConfig),
+                ApiType.PUBLIC_API.getReferenceFilter(apiPredicateConfig)
+            )
+        val factory: (DelegatedVisitor) -> ItemVisitor = {
+            FilteringApiVisitor(
+                delegate = it,
+                preFiltered = false,
+                apiFilters = apiFilters,
+            )
+        }
+
+        val snapshot =
+            CodebaseSnapshotTaker.takeSnapshot(
+                codebase,
+                definitionVisitorFactory = factory,
+                referenceVisitorFactory = factory,
+            )
+        return snapshot
+    }
+
+    @Test
+    fun `Test reference to hidden class`() {
+        check(
+            sourceFiles =
+                arrayOf(
+                    KnownSourceFiles.sdkConstantSource,
+                    java(
+                        """
+                            package test.pkg;
+                            import android.annotation.SdkConstant;
+                            import android.annotation.SdkConstant.SdkConstantType;
+                            public class Foo {
+                                @SdkConstant(SdkConstantType.SERVICE_ACTION)
+                                public static final String CONSTANT = "something";
+                            }
+                        """
+                    ),
+                ),
+            api =
+                """
+                    // Signature format: 5.0
+                    package test.pkg {
+                      public class Foo {
+                        ctor public Foo();
+                        field public static final String CONSTANT = "something";
+                      }
+                    }
+                """,
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public class Foo {
+                            public Foo() { throw new RuntimeException("Stub!"); }
+                            @android.annotation.SdkConstant(android.annotation.SdkConstant.SdkConstantType.SERVICE_ACTION) public static final java.lang.String CONSTANT = "something";
+                            }
+                        """
+                    )
+                ),
+        ) {
+            // Take a snapshot of the public API.
+            val snapshot = takeSnapshotOfPublicApi()
+
+            // Attempt to resolve a class which was in the original codebase but is not in the
+            // snapshot because it is hidden. It should succeed but return null.
+            val resolved = snapshot.resolveClass("android.annotation.SdkConstant.SdkConstantType")
+            assertNull(resolved)
+        }
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/stub/AbstractStubsTest.kt b/metalava/src/test/java/com/android/tools/metalava/stub/AbstractStubsTest.kt
index f23d34846..26b50a289 100644
--- a/metalava/src/test/java/com/android/tools/metalava/stub/AbstractStubsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/stub/AbstractStubsTest.kt
@@ -39,6 +39,7 @@ abstract class AbstractStubsTest : DriverTest() {
         format: FileFormat = FileFormat.LATEST,
         sourceFiles: Array<TestFile> = emptyArray(),
         signatureSources: Array<String> = emptyArray(),
+        checkCompilation: Boolean = true,
         checkTextStubEquivalence: Boolean = false
     ) {
         val stubFilesArr = if (source.isNotEmpty()) arrayOf(java(source)) else stubFiles
@@ -48,7 +49,7 @@ abstract class AbstractStubsTest : DriverTest() {
             showAnnotations = showAnnotations,
             stubFiles = stubFilesArr,
             expectedIssues = warnings,
-            checkCompilation = true,
+            checkCompilation = checkCompilation,
             api = api,
             extraArguments = extraArguments,
             docStubs = docStubs,
@@ -75,7 +76,7 @@ abstract class AbstractStubsTest : DriverTest() {
                 showAnnotations = showAnnotations,
                 stubFiles = stubFilesArr,
                 expectedIssues = warnings,
-                checkCompilation = true,
+                checkCompilation = checkCompilation,
                 extraArguments = arrayOf(*extraArguments, ARG_EXCLUDE_ANNOTATION, ANDROIDX_NONNULL),
                 skipEmitPackages = skipEmitPackages,
                 format = format
diff --git a/metalava/src/test/java/com/android/tools/metalava/stub/StubsAnnotationTest.kt b/metalava/src/test/java/com/android/tools/metalava/stub/StubsAnnotationTest.kt
index 6f46602d3..8ca1c7781 100644
--- a/metalava/src/test/java/com/android/tools/metalava/stub/StubsAnnotationTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/stub/StubsAnnotationTest.kt
@@ -463,7 +463,7 @@ class StubsAnnotationTest : AbstractStubsTest() {
                     method public abstract float floating() default 1.0f;
                     method public abstract boolean formatToHexString() default false;
                     method public abstract double from() default java.lang.Double.NEGATIVE_INFINITY;
-                    method public abstract double fromWithCast() default (double)java.lang.Float.NEGATIVE_INFINITY;
+                    method public abstract double fromWithCast() default java.lang.Double.NEGATIVE_INFINITY;
                     method public abstract boolean hasAdjacentMapping() default false;
                     method public abstract int integer() default 1;
                     method public abstract double large_floating() default 1.0;
@@ -502,8 +502,8 @@ class StubsAnnotationTest : AbstractStubsTest() {
                 public java.lang.String category() default "";
                 public float floating() default 1.0f;
                 public boolean formatToHexString() default false;
-                public double from() default java.lang.Double.NEGATIVE_INFINITY;
-                public double fromWithCast() default (double)java.lang.Float.NEGATIVE_INFINITY;
+                public double from() default (-1.0/0.0);
+                public double fromWithCast() default (-1.0/0.0);
                 public boolean hasAdjacentMapping() default false;
                 public int integer() default 1;
                 public double large_floating() default 1.0;
@@ -826,7 +826,7 @@ class StubsAnnotationTest : AbstractStubsTest() {
                 @SuppressWarnings({"unchecked", "deprecation", "all"})
                 public class ActionBar {
                 public ActionBar() { throw new RuntimeException("Stub!"); }
-                @test.pkg.ViewDebug.ExportedProperty(category="layout", mapping={@test.pkg.ViewDebug.IntToString(from=0xffffffff, to="NONE"), @test.pkg.ViewDebug.IntToString(from=android.view.Gravity.NO_GRAVITY, to="NONE"), @test.pkg.ViewDebug.IntToString(from=android.view.Gravity.TOP, to="TOP"), @test.pkg.ViewDebug.IntToString(from=android.view.Gravity.BOTTOM, to="BOTTOM")}) public int gravity = 0; // 0x0
+                @test.pkg.ViewDebug.ExportedProperty(category="layout", mapping={@test.pkg.ViewDebug.IntToString(from=0xffffffff, to="NONE"), @test.pkg.ViewDebug.IntToString(from=android.view.Gravity.NO_GRAVITY, to="NONE"), @test.pkg.ViewDebug.IntToString(from=android.view.Gravity.TOP, to="TOP"), @test.pkg.ViewDebug.IntToString(from=android.view.Gravity.BOTTOM, to="BOTTOM")}) public int gravity;
                 }
                 """
         )
diff --git a/metalava/src/test/java/com/android/tools/metalava/stub/StubsEnumTest.kt b/metalava/src/test/java/com/android/tools/metalava/stub/StubsEnumTest.kt
index 5213cd432..a03f7f8eb 100644
--- a/metalava/src/test/java/com/android/tools/metalava/stub/StubsEnumTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/stub/StubsEnumTest.kt
@@ -97,8 +97,8 @@ class StubsEnumTest : AbstractStubsTest() {
                 /** My 2nd documentation */
                 DEF;
                 protected void foo() { throw new RuntimeException("Stub!"); }
-                public static int field1 = 1; // 0x1
-                public int field2 = 2; // 0x2
+                public static int field1;
+                public int field2;
                 }
                 """
         )
diff --git a/metalava/src/test/java/com/android/tools/metalava/stub/StubsFieldTest.kt b/metalava/src/test/java/com/android/tools/metalava/stub/StubsFieldTest.kt
new file mode 100644
index 000000000..8bdc34c2a
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/stub/StubsFieldTest.kt
@@ -0,0 +1,317 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.stub
+
+import com.android.tools.metalava.testing.java
+import org.junit.Test
+
+class StubsFieldTest : AbstractStubsTest() {
+    /**
+     * Test class that is used to test the behavior when a static final field is initialized with an
+     * unknown value.
+     */
+    private val hiddenClass =
+        java(
+            """
+                package test.pkg;
+                class Hidden {
+                    static boolean booleanMethod() { return true; }
+                    static byte byteMethod() { return 45; }
+                    static char charMethod() { return 'A'; }
+                    static float floatMethod() { return 0; }
+                    static String stringMethod() { return "unknown"; }
+                    static Runnable runnableMethod() { return () -> {}; }
+                }
+            """
+        )
+
+    @Test
+    fun `Test field with unknown value in annotation`() {
+        checkStubs(
+            sourceFiles =
+                arrayOf(
+                    hiddenClass,
+                    java(
+                        """
+                            package test.pkg;
+                            public @interface Foo {
+                                boolean BOOLEAN_FIELD = Hidden.booleanMethod();
+                                byte BYTE_FIELD = Hidden.byteMethod();
+                                char CHAR_FIELD = Hidden.charMethod();
+                                double DOUBLE_FIELD = Hidden.floatMethod();
+                                float FLOAT_FIELD = Hidden.floatMethod();
+                                int INT_FIELD = Hidden.byteMethod();
+                                long LONG_FIELD = Hidden.byteMethod();
+                                Runnable RUNNABLE_FIELD = Hidden.runnableMethod();
+                                short SHORT_FIELD = Hidden.byteMethod();
+                                String STRING_FIELD = Hidden.stringMethod();
+                            }
+                        """
+                    ),
+                ),
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS)
+                            public @interface Foo {
+                            public static final boolean BOOLEAN_FIELD = java.lang.Boolean.parseBoolean("false"); // Not compile-time constant
+                            public static final byte BYTE_FIELD = java.lang.Byte.parseByte("0"); // Not compile-time constant
+                            public static final char CHAR_FIELD = "A".charAt(0); // Not compile-time constant
+                            public static final double DOUBLE_FIELD = java.lang.Double.parseDouble("0"); // Not compile-time constant
+                            public static final float FLOAT_FIELD = java.lang.Float.parseFloat("0"); // Not compile-time constant
+                            public static final int INT_FIELD = java.lang.Integer.parseInt("0"); // Not compile-time constant
+                            public static final long LONG_FIELD = java.lang.Long.parseLong("0"); // Not compile-time constant
+                            public static final java.lang.Runnable RUNNABLE_FIELD = null; // Not compile-time constant
+                            public static final short SHORT_FIELD = java.lang.Short.parseShort("0"); // Not compile-time constant
+                            public static final java.lang.String STRING_FIELD = java.lang.String.valueOf(0); // Not compile-time constant
+                            }
+                        """
+                    ),
+                ),
+        )
+    }
+
+    @Test
+    fun `Test field with unknown value in class`() {
+        checkStubs(
+            sourceFiles =
+                arrayOf(
+                    hiddenClass,
+                    java(
+                        """
+                            package test.pkg;
+                            public class Foo {
+                                public static final boolean BOOLEAN_FIELD = Hidden.booleanMethod();
+                                public static final byte BYTE_FIELD = Hidden.byteMethod();
+                                public static final char CHAR_FIELD = Hidden.charMethod();
+                                public static final double DOUBLE_FIELD = Hidden.floatMethod();
+                                public static final float FLOAT_FIELD = Hidden.floatMethod();
+                                public static final int INT_FIELD = Hidden.byteMethod();
+                                public static final long LONG_FIELD = Hidden.byteMethod();
+                                public static final Runnable RUNNABLE_FIELD = Hidden.runnableMethod();
+                                public static final short SHORT_FIELD = Hidden.byteMethod();
+                                public static final String STRING_FIELD = Hidden.stringMethod();
+                            }
+                        """
+                    ),
+                ),
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public class Foo {
+                            public Foo() { throw new RuntimeException("Stub!"); }
+                            public static final boolean BOOLEAN_FIELD;
+                            static { BOOLEAN_FIELD = false; }
+                            public static final byte BYTE_FIELD;
+                            static { BYTE_FIELD = 0; }
+                            public static final char CHAR_FIELD;
+                            static { CHAR_FIELD = 0; }
+                            public static final double DOUBLE_FIELD;
+                            static { DOUBLE_FIELD = 0; }
+                            public static final float FLOAT_FIELD;
+                            static { FLOAT_FIELD = 0; }
+                            public static final int INT_FIELD;
+                            static { INT_FIELD = 0; }
+                            public static final long LONG_FIELD;
+                            static { LONG_FIELD = 0; }
+                            public static final java.lang.Runnable RUNNABLE_FIELD;
+                            static { RUNNABLE_FIELD = null; }
+                            public static final short SHORT_FIELD;
+                            static { SHORT_FIELD = 0; }
+                            public static final java.lang.String STRING_FIELD;
+                            static { STRING_FIELD = null; }
+                            }
+                        """
+                    ),
+                ),
+        )
+    }
+
+    @Test
+    fun `Test field with unknown value in enum`() {
+        checkStubs(
+            sourceFiles =
+                arrayOf(
+                    hiddenClass,
+                    java(
+                        """
+                            package test.pkg;
+                            public enum Foo {
+                                ;
+                                public static final boolean BOOLEAN_FIELD = Hidden.booleanMethod();
+                                public static final byte BYTE_FIELD = Hidden.byteMethod();
+                                public static final char CHAR_FIELD = Hidden.charMethod();
+                                public static final double DOUBLE_FIELD = Hidden.floatMethod();
+                                public static final float FLOAT_FIELD = Hidden.floatMethod();
+                                public static final int INT_FIELD = Hidden.byteMethod();
+                                public static final long LONG_FIELD = Hidden.byteMethod();
+                                public static final Runnable RUNNABLE_FIELD = Hidden.runnableMethod();
+                                public static final short SHORT_FIELD = Hidden.byteMethod();
+                                public static final String STRING_FIELD = Hidden.stringMethod();
+                            }
+                        """
+                    ),
+                ),
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public enum Foo {
+                            ;
+                            public static final boolean BOOLEAN_FIELD;
+                            static { BOOLEAN_FIELD = false; }
+                            public static final byte BYTE_FIELD;
+                            static { BYTE_FIELD = 0; }
+                            public static final char CHAR_FIELD;
+                            static { CHAR_FIELD = 0; }
+                            public static final double DOUBLE_FIELD;
+                            static { DOUBLE_FIELD = 0; }
+                            public static final float FLOAT_FIELD;
+                            static { FLOAT_FIELD = 0; }
+                            public static final int INT_FIELD;
+                            static { INT_FIELD = 0; }
+                            public static final long LONG_FIELD;
+                            static { LONG_FIELD = 0; }
+                            public static final java.lang.Runnable RUNNABLE_FIELD;
+                            static { RUNNABLE_FIELD = null; }
+                            public static final short SHORT_FIELD;
+                            static { SHORT_FIELD = 0; }
+                            public static final java.lang.String STRING_FIELD;
+                            static { STRING_FIELD = null; }
+                            }
+                        """
+                    ),
+                ),
+        )
+    }
+
+    @Test
+    fun `Test field with unknown value in interface`() {
+        checkStubs(
+            sourceFiles =
+                arrayOf(
+                    hiddenClass,
+                    java(
+                        """
+                            package test.pkg;
+                            public interface Foo {
+                                boolean BOOLEAN_FIELD = Hidden.booleanMethod();
+                                byte BYTE_FIELD = Hidden.byteMethod();
+                                char CHAR_FIELD = Hidden.charMethod();
+                                double DOUBLE_FIELD = Hidden.floatMethod();
+                                float FLOAT_FIELD = Hidden.floatMethod();
+                                int INT_FIELD = Hidden.byteMethod();
+                                long LONG_FIELD = Hidden.byteMethod();
+                                Runnable RUNNABLE_FIELD = Hidden.runnableMethod();
+                                short SHORT_FIELD = Hidden.byteMethod();
+                                String STRING_FIELD = Hidden.stringMethod();
+                            }
+                        """
+                    ),
+                ),
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public interface Foo {
+                            public static final boolean BOOLEAN_FIELD = java.lang.Boolean.parseBoolean("false"); // Not compile-time constant
+                            public static final byte BYTE_FIELD = java.lang.Byte.parseByte("0"); // Not compile-time constant
+                            public static final char CHAR_FIELD = "A".charAt(0); // Not compile-time constant
+                            public static final double DOUBLE_FIELD = java.lang.Double.parseDouble("0"); // Not compile-time constant
+                            public static final float FLOAT_FIELD = java.lang.Float.parseFloat("0"); // Not compile-time constant
+                            public static final int INT_FIELD = java.lang.Integer.parseInt("0"); // Not compile-time constant
+                            public static final long LONG_FIELD = java.lang.Long.parseLong("0"); // Not compile-time constant
+                            public static final java.lang.Runnable RUNNABLE_FIELD = null; // Not compile-time constant
+                            public static final short SHORT_FIELD = java.lang.Short.parseShort("0"); // Not compile-time constant
+                            public static final java.lang.String STRING_FIELD = java.lang.String.valueOf(0); // Not compile-time constant
+                            }
+                        """
+                    ),
+                ),
+        )
+    }
+
+    @Test
+    fun `Test field with non-constant value in class`() {
+        checkStubs(
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            public class Foo {
+                                public static final Class<?> FIELD = Integer.class;
+                            }
+                        """
+                    ),
+                ),
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public class Foo {
+                            public Foo() { throw new RuntimeException("Stub!"); }
+                            public static final java.lang.Class<?> FIELD;
+                            static { FIELD = null; }
+                            }
+                        """
+                    ),
+                ),
+        )
+    }
+
+    @Test
+    fun `Test field with non-constant value in interface`() {
+        checkStubs(
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            public interface Foo {
+                                Class<?> FIELD = Integer.class;
+                            }
+                        """
+                    ),
+                ),
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public interface Foo {
+                            public static final java.lang.Class<?> FIELD = null; // Not compile-time constant
+                            }
+                        """
+                    ),
+                ),
+        )
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/stub/StubsInterfaceTest.kt b/metalava/src/test/java/com/android/tools/metalava/stub/StubsInterfaceTest.kt
index b143212b1..5def183fe 100644
--- a/metalava/src/test/java/com/android/tools/metalava/stub/StubsInterfaceTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/stub/StubsInterfaceTest.kt
@@ -127,13 +127,13 @@ class StubsInterfaceTest : AbstractStubsTest() {
                 package test.pkg;
                 @SuppressWarnings({"unchecked", "deprecation", "all"})
                 public interface MyClass {
-                public static final java.lang.String[] CONSTANT1 = null;
-                public static final boolean CONSTANT2 = false;
-                public static final int CONSTANT3 = 0; // 0x0
-                public static final java.lang.String CONSTANT4 = null;
+                public static final java.lang.String[] CONSTANT1 = null; // Not compile-time constant
+                public static final boolean CONSTANT2 = java.lang.Boolean.parseBoolean("false"); // Not compile-time constant
+                public static final int CONSTANT3 = java.lang.Integer.parseInt("0"); // Not compile-time constant
+                public static final java.lang.String CONSTANT4 = java.lang.String.valueOf(0); // Not compile-time constant
                 }
                 """,
-            checkTextStubEquivalence = true
+            checkTextStubEquivalence = true,
         )
     }
 
diff --git a/metalava/src/test/java/com/android/tools/metalava/stub/StubsPackageInfoTest.kt b/metalava/src/test/java/com/android/tools/metalava/stub/StubsPackageInfoTest.kt
index c9eb8aff2..79c416cd1 100644
--- a/metalava/src/test/java/com/android/tools/metalava/stub/StubsPackageInfoTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/stub/StubsPackageInfoTest.kt
@@ -191,18 +191,20 @@ class StubsPackageInfoTest : AbstractStubsTest() {
                 """,
             stubFiles =
                 arrayOf(
-                    java("""
-                    package test.pkg;
-                    """),
                     java(
                         """
-                    package test.pkg;
-                    @SuppressWarnings({"unchecked", "deprecation", "all"})
-                    public abstract class Class1 {
-                    public Class1() { throw new RuntimeException("Stub!"); }
-                    }
-                    """
-                    )
+                            package test.pkg;
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public abstract class Class1 {
+                            public Class1() { throw new RuntimeException("Stub!"); }
+                            }
+                        """
+                    ),
                 ),
         )
     }
diff --git a/metalava/src/test/java/com/android/tools/metalava/stub/StubsTest.kt b/metalava/src/test/java/com/android/tools/metalava/stub/StubsTest.kt
index fb211dc23..2d80449c6 100644
--- a/metalava/src/test/java/com/android/tools/metalava/stub/StubsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/stub/StubsTest.kt
@@ -18,15 +18,8 @@ package com.android.tools.metalava.stub
 
 import com.android.tools.metalava.ARG_API_CLASS_RESOLUTION
 import com.android.tools.metalava.ARG_EXCLUDE_DOCUMENTATION_FROM_STUBS
-import com.android.tools.metalava.deprecatedForSdkSource
-import com.android.tools.metalava.lint.DefaultLintErrorMessage
-import com.android.tools.metalava.model.provider.Capability
-import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.model.text.FileFormat
-import com.android.tools.metalava.systemApiSource
-import com.android.tools.metalava.testApiSource
 import com.android.tools.metalava.testing.java
-import com.android.tools.metalava.testing.kotlin
 import org.junit.Test
 
 @SuppressWarnings("ALL")
@@ -1137,254 +1130,6 @@ class StubsTest : AbstractStubsTest() {
         )
     }
 
-    @Test
-    fun `Translate DeprecatedForSdk to Deprecated`() {
-        // See b/144111352
-        check(
-            expectedIssues =
-                """
-                src/test/pkg/PublicApi.java:30: error: Method test.pkg.PublicApi.method4(): Documentation contains `@deprecated` which implies this API is fully deprecated, not just @DeprecatedForSdk [DeprecationMismatch]
-            """,
-            expectedFail = DefaultLintErrorMessage,
-            sourceFiles =
-                arrayOf(
-                    java(
-                            """
-                    package test.pkg;
-                    import android.annotation.DeprecatedForSdk;
-                    import android.annotation.DeprecatedForSdk.*;
-
-                    public class PublicApi {
-                        private PublicApi() { }
-                        // Normal deprecation:
-                        /** @deprecated My deprecation reason 1 */
-                        @Deprecated
-                        public static void method1() { }
-
-                        // Deprecated in the SDK. No comment; make sure annotation comment
-                        // shows up in the doc stubs.
-                        @DeprecatedForSdk("My deprecation reason 2")
-                        public static void method2() { }
-
-                        // Deprecated in the SDK, and has comment: Make sure comments merged
-                        // in the doc stubs.
-                        /**
-                         * My docs here.
-                         * @return the value
-                         */
-                        @DeprecatedForSdk("My deprecation reason 3")
-                        public static void method3() { } // warn about missing annotation
-
-                        // Already implicitly deprecated everywhere (because of @deprecated
-                        // comment; complain if combined with @DeprecatedForSdk
-                        /** @deprecated Something */
-                        @DeprecatedForSdk("Something")
-                        public static void method4() { }
-
-                        // Test @DeprecatedForSdk with specific exemptions; none of these are
-                        // the current public SDK so make sure it's deprecated there.
-                        // A different test will check whath appens when generating the
-                        // system API or test API.
-                        @DeprecatedForSdk(value = "Explanation", allowIn = { SYSTEM_API, TEST_API })
-                        public static void method5() { }
-                    }
-                    """
-                        )
-                        .indented(),
-                    deprecatedForSdkSource
-                ),
-            api =
-                """
-                package test.pkg {
-                  public class PublicApi {
-                    method @Deprecated public static void method1();
-                    method @Deprecated public static void method2();
-                    method @Deprecated public static void method3();
-                    method @Deprecated public static void method4();
-                    method @Deprecated public static void method5();
-                  }
-                }
-                """,
-            stubFiles =
-                arrayOf(
-                    java(
-                        """
-                    package test.pkg;
-                    @SuppressWarnings({"unchecked", "deprecation", "all"})
-                    public class PublicApi {
-                    PublicApi() { throw new RuntimeException("Stub!"); }
-                    /** @deprecated My deprecation reason 1 */
-                    @Deprecated
-                    public static void method1() { throw new RuntimeException("Stub!"); }
-                    /**
-                     * @deprecated My deprecation reason 2
-                     */
-                    @Deprecated
-                    public static void method2() { throw new RuntimeException("Stub!"); }
-                    /**
-                     * My docs here.
-                     * @deprecated My deprecation reason 3
-                     * @return the value
-                     */
-                    @Deprecated
-                    public static void method3() { throw new RuntimeException("Stub!"); }
-                    /** @deprecated Something */
-                    @Deprecated
-                    public static void method4() { throw new RuntimeException("Stub!"); }
-                    /**
-                     * @deprecated Explanation
-                     */
-                    @Deprecated
-                    public static void method5() { throw new RuntimeException("Stub!"); }
-                    }
-                    """
-                    )
-                ),
-            docStubs = true
-        )
-    }
-
-    @RequiresCapabilities(Capability.KOTLIN)
-    @Test
-    fun `Translate DeprecatedForSdk with API Filtering`() {
-        // See b/144111352.
-        // Remaining: don't include @deprecated in the docs for allowed platforms!
-        check(
-            showAnnotations = arrayOf("android.annotation.SystemApi"),
-            sourceFiles =
-                arrayOf(
-                    java(
-                            """
-                    package test.pkg;
-
-                    import android.annotation.SystemApi;
-                    import android.annotation.TestApi;
-                    import android.annotation.DeprecatedForSdk;
-
-                    public class PublicApi2 {
-                        private PublicApi2() {
-                        }
-
-                        // This method should be deprecated in the SDK but *not* here in
-                        // the system API (this test runs with --show-annotations SystemApi)
-                        @DeprecatedForSdk(value = "My deprecation reason 1", allowIn = {SystemApi.class, TestApi.class})
-                        public static void method1() {
-                        }
-
-                        // Same as method 1 (here we're just using a different annotation
-                        // initializer form to test we're handling both types): *not* deprecated.
-
-                        /**
-                         * My docs.
-                         */
-                        @DeprecatedForSdk(value = "My deprecation reason 2", allowIn = SystemApi.class)
-                        public static void method2() {
-                        }
-
-                        // Finally, this method *is* deprecated in the system API and should
-                        // show up as such.
-
-                        /**
-                         * My docs.
-                         */
-                        @DeprecatedForSdk(value = "My deprecation reason 3", allowIn = TestApi.class)
-                        public static void method3() {
-                        }
-                    }
-                    """
-                        )
-                        .indented(),
-                    // Include some Kotlin files too to make sure we correctly handle
-                    // annotation lookup for Kotlin (which uses UAST instead of plain Java PSI
-                    // behind the scenes), even if android.util.ArrayMap is really implemented in
-                    // Java
-                    kotlin(
-                            """
-                    package android.util
-                    import android.annotation.DeprecatedForSdk
-                    import android.annotation.SystemApi;
-                    import android.annotation.TestApi;
-
-                    @DeprecatedForSdk(value = "Use androidx.collection.ArrayMap")
-                    class ArrayMap
-
-                    @DeprecatedForSdk(value = "Use androidx.collection.ArrayMap", allowIn = [SystemApi::class])
-                    class SystemArrayMap
-
-                    @DeprecatedForSdk("Use android.Manifest.permission.ACCESS_FINE_LOCATION instead")
-                    const val FINE_LOCATION =  "android.permission.ACCESS_FINE_LOCATION"
-                    """
-                        )
-                        .indented(),
-                    deprecatedForSdkSource,
-                    systemApiSource,
-                    testApiSource
-                ),
-            stubFiles =
-                arrayOf(
-                    java(
-                        """
-                    package test.pkg;
-                    @SuppressWarnings({"unchecked", "deprecation", "all"})
-                    public class PublicApi2 {
-                    PublicApi2() { throw new RuntimeException("Stub!"); }
-                    public static void method1() { throw new RuntimeException("Stub!"); }
-                    /**
-                     * My docs.
-                     */
-                    public static void method2() { throw new RuntimeException("Stub!"); }
-                    /**
-                     * My docs.
-                     * @deprecated My deprecation reason 3
-                     */
-                    @Deprecated
-                    public static void method3() { throw new RuntimeException("Stub!"); }
-                    }
-                    """
-                    ),
-                    java(
-                        """
-                    package android.util;
-                    /**
-                     * @deprecated Use androidx.collection.ArrayMap
-                     */
-                    @SuppressWarnings({"unchecked", "deprecation", "all"})
-                    @Deprecated
-                    public final class ArrayMap {
-                    @Deprecated
-                    public ArrayMap() { throw new RuntimeException("Stub!"); }
-                    }
-                    """
-                    ),
-                    // SystemArrayMap is like ArrayMap, but has allowedIn=SystemApi::class, so
-                    // it should not be deprecated here in the system api stubs
-                    java(
-                        """
-                    package android.util;
-                    @SuppressWarnings({"unchecked", "deprecation", "all"})
-                    public final class SystemArrayMap {
-                    public SystemArrayMap() { throw new RuntimeException("Stub!"); }
-                    }
-                    """
-                    ),
-                    java(
-                        """
-                    package android.util;
-                    @SuppressWarnings({"unchecked", "deprecation", "all"})
-                    public final class ArrayMapKt {
-                    ArrayMapKt() { throw new RuntimeException("Stub!"); }
-                    /**
-                     * @deprecated Use android.Manifest.permission.ACCESS_FINE_LOCATION instead
-                     */
-                    @Deprecated @androidx.annotation.NonNull public static final java.lang.String FINE_LOCATION = "android.permission.ACCESS_FINE_LOCATION";
-                    }
-                    """
-                    )
-                ),
-            docStubs = true
-        )
-    }
-
     @Test
     fun `From-text stubs can be generated from signature files with conflicting class definitions`() {
         check(
diff --git a/metalava/src/test/resources/source-model-provider-baseline.txt b/metalava/src/test/resources/source-model-provider-baseline.txt
index 62b916023..c8c71dd5c 100644
--- a/metalava/src/test/resources/source-model-provider-baseline.txt
+++ b/metalava/src/test/resources/source-model-provider-baseline.txt
@@ -1,11 +1,5 @@
-com.android.tools.metalava.AndroidApiChecksTest
-  Document Permissions[turbine]
-
 com.android.tools.metalava.AnnotationsMergerTest
-  Merge Contract and Language annotations from XML files[turbine]
-  Merge Contract and Language annotations from signature files[turbine]
   Merge type use qualifier annotations from Java stub files[turbine]
-  Signature files contain annotations[turbine]
 
 com.android.tools.metalava.ApiAnalyzerTest
   Test PrivateSuperclass for inner class[turbine]
@@ -13,7 +7,6 @@ com.android.tools.metalava.ApiAnalyzerTest
   Test that usage of effectively deprecated class is flagged[turbine]
 
 com.android.tools.metalava.ApiFileTest
-  Annotation value visibility[turbine]
   Check @remove class[turbine]
   Check basic @remove scenarios[turbine]
   Check generic type signature insertion[turbine]
@@ -29,16 +22,11 @@ com.android.tools.metalava.DuplicateClassTest
   Test duplicate classes[turbine]
 
 com.android.tools.metalava.ExtractAnnotationsTest
-  Check java typedef extraction and warning about non-source retention of typedefs[turbine]
   Check warning about unexpected returns from typedef method[turbine]
-  Extract annotations from class[turbine]
-  Extract permission annotations[turbine]
-  Include merged annotations in exported source annotations[turbine]
-  Inlining typedef signatures in api files[turbine]
-  Only including class retention annotations in stubs[turbine]
-  Test annotations on inherited methods[turbine]
-  Test generics in XML attributes are encoded[turbine]
-  Test string literal encoding[turbine]
+
+com.android.tools.metalava.FlaggedApiEdgeCasesTest
+  Test javadoc for flagged class includes @apiSince[turbine]
+  Test unresolvable flag field[turbine]
 
 com.android.tools.metalava.Java9LanguageFeaturesTest
   Basic class signature extraction[turbine]
@@ -61,36 +49,9 @@ com.android.tools.metalava.KeepFileTest
   Arrays with Inner class[turbine]
   Multi dimensional arrays[turbine]
 
-com.android.tools.metalava.NormalizeOutputAnnotationTest
-  Normalize nested permission annotations (java)[turbine]
-
 com.android.tools.metalava.NullabilityAnnotationsValidatorTest
   Using class list[turbine]
 
-com.android.tools.metalava.ParameterizedFlaggedApiTest
-  Basic test that FlaggedApi annotated items can be hidden[turbine,public finalize foo_bar]
-  Basic test that FlaggedApi annotated items can be hidden[turbine,public keep all]
-  Basic test that FlaggedApi annotated items can be hidden[turbine,system finalize foo_bar]
-  Basic test that FlaggedApi annotated items can be hidden[turbine,system keep all]
-  Test interface fields behave correctly when flagged[turbine,public finalize foo_bar]
-  Test interface fields behave correctly when flagged[turbine,public keep all]
-  Test that annotated class members are handled correctly when flagged APIs are hidden[turbine,system finalize foo_bar]
-  Test that annotated class members are handled correctly when flagged APIs are hidden[turbine,system keep all]
-  Test that cross references are handled correctly when flagged APIs are hidden[turbine,public finalize foo_bar]
-  Test that cross references are handled correctly when flagged APIs are hidden[turbine,public keep all]
-  Test that cross references are handled correctly when flagged APIs are hidden[turbine,system finalize foo_bar]
-  Test that cross references are handled correctly when flagged APIs are hidden[turbine,system keep all]
-  Test that method overrides are handled correctly when flagged APIs are hidden[turbine,public finalize foo_bar]
-  Test that method overrides are handled correctly when flagged APIs are hidden[turbine,public keep all]
-  Test that method overrides are handled correctly when flagged APIs are hidden[turbine,system finalize foo_bar]
-  Test that method overrides are handled correctly when flagged APIs are hidden[turbine,system keep all]
-  Test that previously released APIs which are now system and flagged are not removed[turbine,module_lib finalize foo_bar]
-  Test that previously released APIs which are now system and flagged are not removed[turbine,module_lib keep all]
-  Test that previously released APIs which are now system and flagged are not removed[turbine,system finalize foo_bar]
-  Test that previously released APIs which are now system and flagged are not removed[turbine,system keep all]
-  Test that pulling method up into super class can be reverted[turbine,public finalize foo_bar]
-  Test that pulling method up into super class can be reverted[turbine,public keep all]
-
 com.android.tools.metalava.PolymorphicMethodsTest
   Test MethodHandle[turbine]
   Test VarHandle[turbine]
@@ -102,39 +63,18 @@ com.android.tools.metalava.RequiresFeatureTest
   Check RequiresFeature handling - missing feature[turbine]
   Check RequiresFeature handling[turbine]
 
-com.android.tools.metalava.SdkFileWriterTest
-  Test generating activity actions[turbine]
-  Test generating broadcast actions[turbine]
-
 com.android.tools.metalava.ShowAnnotationTest
-  Can't expose item from a hidden parent[turbine]
   Testing parsing an annotation whose attribute references the annotated class[turbine]
-  showAnnotation with default parameters[turbine]
 
 com.android.tools.metalava.SyntaxErrorTest
   Invalid syntax[turbine]
 
-com.android.tools.metalava.SystemServiceCheckTest
-  Check SystemService -- can miss a permission with anyOf[turbine]
-  Check SystemService -- missing manifest permissions[turbine]
-  Check SystemService -- missing one permission with allOf[turbine]
-  Check SystemService -- must be system permission, not normal[turbine]
-  Check SystemService -- no permission annotation[turbine]
-  Check SystemService such that at least one permission must be defined with anyOf[turbine]
-  Invalid manifest[turbine]
-  SystemService OK, loaded from signature file[turbine]
-  SystemService OK, loaded from source[turbine]
-  Warning suppressed via annotation[turbine]
-
 com.android.tools.metalava.TypeUseAnnotationFilteringTest
   Keep type use annotations[turbine]
 
 com.android.tools.metalava.UnhideApisTest
   Including private interfaces from types[turbine]
 
-com.android.tools.metalava.VisibleForTestingTest
-  Test VisibleForTesting constants - java[turbine]
-
 com.android.tools.metalava.apilevels.ApiGeneratorTest
   APIs annotated with suppress-compatibility-meta-annotations appear in output[turbine]
   Generate API for system surface from jar[turbine]
@@ -156,6 +96,7 @@ com.android.tools.metalava.doc.DocAnalyzerRangeTest
   Add to existing parameter[turbine]
   Add to existing return value (ensuring it appears last)[turbine]
   Document ranges[turbine]
+  Test different values[turbine]
   Typedefs combined with ranges[turbine]
   Typedefs[turbine]
 
@@ -198,13 +139,7 @@ com.android.tools.metalava.lint.ApiLintTest
 com.android.tools.metalava.lint.CheckBuilderTest
   Check builders[turbine]
 
-com.android.tools.metalava.lint.FlaggedApiLintTest
-  Require @FlaggedApi on new APIs[turbine]
-  Require @FlaggedApi to reference generated fields[turbine]
-
 com.android.tools.metalava.stub.StubsAnnotationTest
-  Annotation default values[turbine]
-  Annotation nested rewriting[turbine]
   Pass through libcore annotations[turbine]
   Rewrite unknown nullability annotations as doc stubs[turbine]
 
@@ -238,4 +173,3 @@ com.android.tools.metalava.stub.StubsTest
   Missing overridden method[turbine]
   Picking super class throwables[turbine]
   Skip type variables in casts[turbine]
-  Translate DeprecatedForSdk to Deprecated[turbine]
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/FieldValue.kt b/metalava/src/testdata/prebuilts-sdk-test/extensions/3/ClassAddedInApi30.java
similarity index 50%
rename from metalava-model/src/main/java/com/android/tools/metalava/model/item/FieldValue.kt
rename to metalava/src/testdata/prebuilts-sdk-test/extensions/3/ClassAddedInApi30.java
index cd7b49ec5..bfa82deea 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/FieldValue.kt
+++ b/metalava/src/testdata/prebuilts-sdk-test/extensions/3/ClassAddedInApi30.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2024 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,18 +14,10 @@
  * limitations under the License.
  */
 
-package com.android.tools.metalava.model.item
+package android.test;
 
-import com.android.tools.metalava.model.FixedFieldValue
-
-interface FieldValue {
-    fun initialValue(requireConstant: Boolean): Any?
-
-    /**
-     * Creates a snapshot of this.
-     *
-     * The default implementation assumes that this is either dependent on a model or the codebase
-     * and so creates a new [FixedFieldValue] based on the functions above.
-     */
-    fun snapshot(): FieldValue = FixedFieldValue(initialValue(true), initialValue(false))
+public class ClassAddedInApi30 extends MarkerSuperClass implements MarkerInterface {
+    private ClassAddedInApi30() {}
+    public void methodAddedInApi30() { throw new RuntimeException("Stub!"); }
+    public void methodAddedInApi31() { throw new RuntimeException("Stub!"); }
 }
diff --git a/metalava/src/testdata/prebuilts-sdk-test/extensions/3/MarkerInterface.java b/metalava/src/testdata/prebuilts-sdk-test/extensions/3/MarkerInterface.java
new file mode 100644
index 000000000..71535cb07
--- /dev/null
+++ b/metalava/src/testdata/prebuilts-sdk-test/extensions/3/MarkerInterface.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.test;
+
+public interface MarkerInterface {
+}
diff --git a/metalava/src/testdata/prebuilts-sdk-test/extensions/3/MarkerSuperClass.java b/metalava/src/testdata/prebuilts-sdk-test/extensions/3/MarkerSuperClass.java
new file mode 100644
index 000000000..faf9e56eb
--- /dev/null
+++ b/metalava/src/testdata/prebuilts-sdk-test/extensions/3/MarkerSuperClass.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.test;
+
+public class MarkerSuperClass {
+}
diff --git a/metalava/src/testdata/prebuilts/sdk/extensions/3/public/framework-ext.txt b/metalava/src/testdata/prebuilts/sdk/extensions/3/public/framework-ext.txt
index ed69a935f..7b20518b6 100644
--- a/metalava/src/testdata/prebuilts/sdk/extensions/3/public/framework-ext.txt
+++ b/metalava/src/testdata/prebuilts/sdk/extensions/3/public/framework-ext.txt
@@ -1,5 +1,9 @@
 // Signature format: 2.0
 package android.test {
+  public class ClassAddedInApi30 extends android.test.MarkerSuperClass implements android.test.MarkerInterface {
+    method public void methodAddedInApi30();
+    method public void methodAddedInApi31();
+  }
   public class ClassAddedInApi31AndExt2 {
     field public static final int FIELD_ADDED_IN_API_31_AND_EXT_2 = 1;
     field public static final int FIELD_ADDED_IN_EXT_3 = 2;
diff --git a/scripts/gather-android-metalava-artifacts.py b/scripts/gather-android-metalava-artifacts.py
index dfd573754..464381933 100755
--- a/scripts/gather-android-metalava-artifacts.py
+++ b/scripts/gather-android-metalava-artifacts.py
@@ -82,15 +82,21 @@ def create_targets(files):
 
 def default_stub_files():
     """:return: A representative sample list of stub source jars generated by the Android build using Metalava"""
-    return create_targets([
-        f"out/soong/.intermediates/frameworks/base/api/{x}/android_common/everything/{x}-stubs.srcjar"
-        for x in [
-            "api-stubs-docs-non-updatable",
-            "system-api-stubs-docs-non-updatable",
-            "test-api-stubs-docs-non-updatable",
-            "module-lib-api-stubs-docs-non-updatable",
+    return create_targets(
+        [
+            f"out/soong/.intermediates/frameworks/base/api/{x}/android_common/everything/{x}-stubs.srcjar"
+            for x in [
+                "api-stubs-docs-non-updatable",
+                "system-api-stubs-docs-non-updatable",
+                "test-api-stubs-docs-non-updatable",
+                "module-lib-api-stubs-docs-non-updatable",
+            ]
         ]
-    ])
+        + [
+            # Use Metalava for host side API.
+            "out/soong/.intermediates/tools/tradefederation/core/tradefed-doc-stubs/linux_glibc_common/everything/tradefed-doc-stubs-stubs.srcjar",
+        ]
+    )
 
 
 def default_doc_stub_files():
@@ -104,6 +110,17 @@ def default_doc_stub_files():
     ])
 
 
+def default_sdk_values_metadata_zip_files():
+    """:return: A representative sample list of sdk values zip files generated by the Android build using Metalava"""
+    return create_targets([
+        f"out/soong/.intermediates/frameworks/base/api/{x}/android_common/exportable/{x}-metadata.zip"
+        for x in [
+            "android-non-updatable-doc-stubs",
+            "android-non-updatable-doc-stubs-system",
+        ]
+    ])
+
+
 def default_annotation_zip_files():
     """:return: A representative sample list of annotation zip files generated by the Android build using Metalava"""
     return create_targets([
@@ -198,6 +215,7 @@ def construct_target_list(args, top):
     if not targets:
         targets += default_stub_files()
         targets += default_doc_stub_files()
+        targets += default_sdk_values_metadata_zip_files()
         targets += default_annotation_zip_files()
         targets += default_jdiff_files()
         targets += default_api_version_files()
```

