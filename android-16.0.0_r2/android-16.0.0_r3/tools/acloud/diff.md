```diff
diff --git a/public/actions/remote_instance_trusty_device_factory.py b/public/actions/remote_instance_trusty_device_factory.py
index 2ecc090..fe70954 100644
--- a/public/actions/remote_instance_trusty_device_factory.py
+++ b/public/actions/remote_instance_trusty_device_factory.py
@@ -15,6 +15,7 @@
 """RemoteInstanceDeviceFactory provides basic interface to create a Trusty
 device factory."""
 
+import argparse
 import json
 import logging
 import os
@@ -39,34 +40,36 @@ _CONFIG_JSON_FILENAME = "config.json"
 # log files under REMOTE_LOG_FOLDER in order to
 # enable `acloud pull` to retrieve them
 _REMOTE_LOG_FOLDER = constants.REMOTE_LOG_FOLDER
-_REMOTE_STDOUT_PATH = f"{_REMOTE_LOG_FOLDER}/kernel.log"
+_REMOTE_STDOUT_PATH = f"{_REMOTE_LOG_FOLDER}/qemu_trusty_console.log"
 _REMOTE_STDERR_PATH = f"{_REMOTE_LOG_FOLDER}/qemu_trusty_err.log"
 
-# below Trusty image archive is generated by
-# branch:aosp-trusty-main / target: qemu_generic_arm64_gicv3* targets
-_TRUSTY_MANIFEST_TRUSTY_IMAGE_PACKAGE = "trusty_image_package.tar.gz"
-
 # below Trusty image archive is generated by:
-# branch: git_main-throttled-nightly / target: qemu_trusty_arm64
-_PLATFORM_MANIFEST_TRUSTY_IMAGE_PACKAGE = "trusty_tee_package_goog.tar.gz"
+_TRUSTY_IMAGE_PACKAGE = {
+    "git_default": "trusty_tee_package_goog.tar.gz",
+    "git_main-without-vendor": "trusty_tee_package.tar.gz",
+    "trusty_manifest": "trusty_image_package.tar.gz",
+}
 
-# below Trusty image archive is generated by:
-# aosp developers for --local-image usage
-_PLATFORM_MANIFEST_TRUSTY_IMAGE_PACKAGE_LOCAL = "trusty_tee_package.tar.gz"
+_DLKM_STAGING = "dlkm_staging"
+_KERNEL_STAGING = f"{_DLKM_STAGING}/flatten/lib/modules"
+_MODULES_LOAD = "modules.load"
 
 # below Host tools archive is generated by:
-# branch: git_main-throttled-nightly / target: qemu_trusty_arm64
+# branch: git_main / target: qemu_trusty_arm64
 _TRUSTY_HOST_PACKAGE_DIR = "trusty-host_package"
 _TRUSTY_HOST_TARBALL = "trusty-host_package.tar.gz"
 
-# Default Trusty image build. This does not depend on the android branch.
-_DEFAULT_TRUSTY_BUILD_BRANCH = "aosp-trusty-main"
+# Default Trusty build target. This does not depend on the android branch.
 _DEFAULT_TRUSTY_BUILD_TARGET = "qemu_generic_arm64_gicv3_test_debug"
 
 
-def _TrustyImagePackageFilename(build_target):
-    trusty_target = build_target.replace("_", "-")
-    return f"{trusty_target}.{_TRUSTY_MANIFEST_TRUSTY_IMAGE_PACKAGE}"
+def _TrustyImagePackageFilename(build_target, build_branch):
+    if build_branch == "trusty_manifest":
+        trusty_target = build_target.replace("_", "-")
+        return f"{trusty_target}.{_TRUSTY_IMAGE_PACKAGE[build_branch]}"
+    if build_branch in _TRUSTY_IMAGE_PACKAGE:
+        return _TRUSTY_IMAGE_PACKAGE[build_branch]
+    return _TRUSTY_IMAGE_PACKAGE["git_default"]
 
 
 def _FindHostPackage(package_path=None):
@@ -95,16 +98,13 @@ def _FindHostPackage(package_path=None):
 def _FindTrustyImagePackage():
     dist_dir = utils.GetDistDir()
     if dist_dir:
-        for name in [
-            _PLATFORM_MANIFEST_TRUSTY_IMAGE_PACKAGE,
-            _PLATFORM_MANIFEST_TRUSTY_IMAGE_PACKAGE_LOCAL,
-        ]:
+        for name in _TRUSTY_IMAGE_PACKAGE.values():
             trusty_image_package = os.path.join(dist_dir, name)
             if os.path.exists(trusty_image_package):
                 return trusty_image_package
     raise errors.GetTrustyLocalImagePackageError(
         "Can't find the trusty image package (Try lunching a trusty target "
-        "like qemu_trusty_arm64-trunk_staging-userdebug and running 'm dist trusty-tee_package')"
+        "such as qemu_trusty_arm64-trunk_staging-userdebug and running 'm dist trusty-tee_package')"
     )
 
 
@@ -114,6 +114,7 @@ class RemoteInstanceDeviceFactory(gce_device_factory.GCEDeviceFactory):
     def __init__(self, avd_spec, local_android_image_artifact=None):
         super().__init__(avd_spec, local_android_image_artifact)
         self._all_logs = {}
+        self._launch_args = self._ParseLaunchArgs()
 
     # pylint: disable=broad-except
     def CreateInstance(self):
@@ -133,10 +134,28 @@ class RemoteInstanceDeviceFactory(gce_device_factory.GCEDeviceFactory):
             self._SetFailures(instance, traceback.format_exception(e))
 
         self._FindLogFiles(
-            instance, instance in self.GetFailures() and not self._avd_spec.no_pull_log
+            instance,
+            instance in self.GetFailures() and not self._avd_spec.no_pull_log,
         )
         return instance
 
+    def _SshRun(self, cmd: str, local_substitution=False):
+        """run a command in the remote GCE, using single quotes by default
+        in order to ensure that substitution happens in the remote shell.
+        for example, $PATH or $(pwd) to be substituted in the remote GCE env,
+        which is the default desired behavior.
+
+        Some commands (such as input redirection <) however,
+        require substitution in the local environment.
+        In that case, local_substitution=True shall be used.
+        """
+
+        self._ssh.Run(
+            cmd if local_substitution else shlex.quote(cmd),
+            show_output=True,
+            timeout=constants.DEFAULT_SSH_TIMEOUT,
+        )
+
     def _ProcessArtifacts(self):
         """Process artifacts.
 
@@ -158,11 +177,7 @@ class RemoteInstanceDeviceFactory(gce_device_factory.GCEDeviceFactory):
             )
         elif avd_spec.image_source == constants.IMAGE_SRC_REMOTE:
             self._FetchBuild()
-            if self._compute_client.build_api.GetKernelBuild(
-                avd_spec.kernel_build_info
-            ):
-                self._ReplaceModules()
-            else:
+            if not self._TryUseGKIKernelModules():
                 # fetch the kernel image from the android build artifacts
                 self._FetchAndUploadKernelImage()
         if avd_spec.local_trusty_image:
@@ -185,13 +200,20 @@ class RemoteInstanceDeviceFactory(gce_device_factory.GCEDeviceFactory):
             "arch": "arm64",
             "adb": "bin/adb",
         }
-        with tempfile.NamedTemporaryFile(mode="w+t") as config_json_file:
+        with tempfile.NamedTemporaryFile(
+            mode="w+t", suffix=".json"
+        ) as config_json_file:
             json.dump(config, config_json_file)
             config_json_file.flush()
             remote_config_path = remote_path.join(
                 cvd_utils.GCE_BASE_DIR, _CONFIG_JSON_FILENAME
             )
             self._ssh.ScpPushFile(config_json_file.name, remote_config_path)
+            logger.debug(
+                "ScpPushFile from %s to %s\n",
+                config_json_file.name,
+                remote_config_path,
+            )
 
     # We are building our own command-line instead of using
     # self._compute_client.FetchBuild() because we need to use the host cvd
@@ -233,21 +255,7 @@ class RemoteInstanceDeviceFactory(gce_device_factory.GCEDeviceFactory):
             host_package,
         )
         fetch_cmd = constants.CMD_CVD_FETCH + ["-credential_source=gce"] + fetch_args
-        self._ssh.Run(" ".join(fetch_cmd), timeout=constants.DEFAULT_SSH_TIMEOUT)
-
-    def _ReplaceModules(self):
-        """Replace modules in android ramdisk with modules from the kernel build"""
-        android_ramdisk = remote_path.join(cvd_utils.GCE_BASE_DIR, "ramdisk.img")
-        kernel_ramdisk = remote_path.join(cvd_utils.GCE_BASE_DIR, "initramfs.img")
-        # We are switching to the bin/ directory so host tools are in the
-        # current directory for python to find.
-        self._ssh.Run(
-            f"cd {cvd_utils.GCE_BASE_DIR}/bin && ./replace_ramdisk_modules "
-            f"--android-ramdisk={android_ramdisk} "
-            f"--kernel-ramdisk={kernel_ramdisk} "
-            f"--output-ramdisk={android_ramdisk}",
-            timeout=constants.DEFAULT_SSH_TIMEOUT,
-        )
+        self._SshRun(" ".join(fetch_cmd))
 
     @utils.TimeExecute(function_description="Fetching & Uploading Trusty image")
     def _FetchAndUploadTrustyImages(self):
@@ -263,7 +271,9 @@ class RemoteInstanceDeviceFactory(gce_device_factory.GCEDeviceFactory):
             )
             if not build_id:
                 build_id = build_client.GetLKGB(build_target, build_branch)
-            trusty_image_package = _TrustyImagePackageFilename(build_target)
+            trusty_image_package = _TrustyImagePackageFilename(
+                build_target, "trusty_manifest"
+            )
         else:
             # if Trusty build_branch not specified, use the android build branch
             # get the Trusty image package from the android platform manifest
@@ -271,7 +281,7 @@ class RemoteInstanceDeviceFactory(gce_device_factory.GCEDeviceFactory):
             build_id = android_build_info[constants.BUILD_ID]
             build_branch = android_build_info[constants.BUILD_BRANCH]
             build_target = android_build_info[constants.BUILD_TARGET]
-            trusty_image_package = _PLATFORM_MANIFEST_TRUSTY_IMAGE_PACKAGE
+            trusty_image_package = _TrustyImagePackageFilename(None, build_branch)
         with tempfile.NamedTemporaryFile(suffix=".tar.gz") as image_local_file:
             image_local_path = image_local_file.name
             build_client.DownloadArtifact(
@@ -292,13 +302,13 @@ class RemoteInstanceDeviceFactory(gce_device_factory.GCEDeviceFactory):
         with tempfile.NamedTemporaryFile(prefix="kernel") as image_local_file:
             image_local_path = image_local_file.name
             logger.debug('DownloadArtifact "kernel" to %s\n', image_local_path)
-            ret = build_client.DownloadArtifact(
+            build_client.DownloadArtifact(
                 build_target,
                 build_id,
                 "kernel",
                 image_local_path,
             )
-            logger.debug("DownloadArtifact to %s Returned %d\n", image_local_path, ret)
+            logger.debug("DownloadArtifact (kernel image) to %s\n", image_local_path)
             self._ssh.ScpPushFile(image_local_path, f"{cvd_utils.GCE_BASE_DIR}/kernel")
             logger.debug(
                 "ScpPushFile from %s to %s\n",
@@ -306,24 +316,252 @@ class RemoteInstanceDeviceFactory(gce_device_factory.GCEDeviceFactory):
                 f"{cvd_utils.GCE_BASE_DIR}/kernel",
             )
 
+    @utils.TimeExecute(function_description="Fetching & Uploading GKI Artifacts")
+    def _FetchAndUploadGKIArtifacts(self):
+        """Fetch GKI Build artifacts from the kernel and its dynamic module Targets"""
+        kernel_build_info = self._avd_spec.kernel_build_info
+        build_branch = kernel_build_info[constants.BUILD_BRANCH]
+        if not build_branch:
+            # if kernel branch is not provided we use the kernel prebuilts in Android
+            return False
+        kernel_ko_dict = {
+            "kernel_aarch64": [
+                "virtio_blk.ko",
+                "virtio_console.ko",
+                "virtio_pci.ko",
+                "virtio_pci_modern_dev.ko",
+                "virtio_pci_legacy_dev.ko",
+            ],
+            "kernel_virt_aarch64": [
+                "failover.ko",
+                "net_failover.ko",
+                "virtio_mmio.ko",
+                "virtio_net.ko",
+                "system_heap.ko",
+            ],
+            "trusty_aarch64": [
+                "ffa-core.ko",
+                "ffa-module.ko",
+                "trusty-ffa.ko",
+                "trusty-smc.ko",
+                "trusty-core.ko",
+                "trusty-ipc.ko",
+                "trusty-log.ko",
+                "trusty-test.ko",
+                "trusty-virtio.ko",
+                "trusty-virtio-polling.ko",
+            ],
+        }
+        build_client = self._compute_client.build_api
+
+        build_id_list = [
+            value
+            for value in [
+                self._launch_args.kernel_trusty_build_id
+                or build_client.GetLKGB("trusty_aarch64", build_branch),
+                self._launch_args.kernel_virt_build_id
+                or build_client.GetLKGB("kernel_virt_aarch64", build_branch),
+                kernel_build_info[constants.BUILD_ID]
+                or build_client.GetLKGB("kernel_aarch64", build_branch),
+            ]
+            if value is not None
+        ]
+        # we use the oldest build_id in the hope that the oldest LKGB
+        # has all the necessary targets
+        build_id = min(build_id_list)
+        def _fetchAndUpload(
+            build_target, file_name, dest_dir=None, dest_file_name=None
+        ):
+            dest_file_path = dest_file_name if dest_file_name else file_name
+            dest_file_path = (
+                f"{dest_dir}/{dest_file_path}" if dest_dir else dest_file_path
+            )
+            with tempfile.NamedTemporaryFile(prefix=file_name) as image_local_file:
+                image_local_path = image_local_file.name
+                build_client.DownloadArtifact(
+                    build_target,
+                    build_id,
+                    file_name,
+                    image_local_path,
+                )
+                self._ssh.ScpPushFile(
+                    image_local_path, f"{cvd_utils.GCE_BASE_DIR}/{dest_file_path}"
+                )
+                logger.debug(
+                    "\n_fetchAndUpload %s & ScpPushFile to %s\n",
+                    file_name,
+                    dest_file_path,
+                )
+
+        dlkm_staging_path = remote_path.join(cvd_utils.GCE_BASE_DIR, _DLKM_STAGING)
+        self._SshRun(f"mkdir -p {dlkm_staging_path}")
+
+        def _uploadDlkm(build_target):
+            with tempfile.NamedTemporaryFile(
+                prefix="system_dlkm_staging_archive", suffix=".tar.gz"
+            ) as image_local_file:
+                image_local_path = image_local_file.name
+                build_client.DownloadArtifact(
+                    build_target,
+                    build_id,
+                    "system_dlkm_staging_archive.tar.gz",
+                    image_local_path,
+                )
+                # f"--wildcards ./flatten/lib/modules/*.ko --strip-components=4 "
+                self._SshRun(
+                    f"tar -xzf - -C {dlkm_staging_path} < {image_local_path}",
+                    local_substitution=True,
+                )
+                # self._SshRun(f"ls -l {dlkm_staging_path}/flatten/lib/modules")
+                logger.debug("\n_uploadDlkm done!\n")
+
+        def _uploadModulesLoad():
+            modules_load_path = remote_path.join(cvd_utils.GCE_BASE_DIR, _MODULES_LOAD)
+            # virtio devices need to be loaded in a determinitic order
+            # in order to have a determistic mount (on /dev/vport4p1)
+            # of the rpmb block device - see aosp/3473834 for an example on how
+            # adding a blk device changes the rpmb device uri
+            modules_load = [
+                "failover.ko",
+                "net_failover.ko",
+                "virtio_blk.ko",
+                "virtio_console.ko",
+                "virtio_mmio.ko",
+                "virtio_net.ko",
+                "virtio_pci.ko",
+                "system_heap.ko",
+                "ffa-core.ko",
+                "ffa-module.ko",
+                "trusty-ffa.ko",
+                "trusty-smc.ko",
+                "trusty-core.ko",
+                "trusty-ipc.ko",
+                "trusty-log.ko",
+                "trusty-test.ko",
+                "trusty-virtio.ko",
+                "virtio_pci_modern_dev.ko",
+                "virtio_pci_legacy_dev.ko",
+            ]
+            with tempfile.NamedTemporaryFile(
+                prefix=_MODULES_LOAD, mode="w+t"
+            ) as modules_load_file:
+                modules_load_file.write("\n".join(modules_load))
+                modules_load_file.flush()
+                self._ssh.ScpPushFile(modules_load_file.name, modules_load_path)
+            logger.debug("\n_uploadModulesLoad done!\n")
+
+        _fetchAndUpload("kernel_aarch64", "Image", dest_file_name="kernel")
+        _uploadDlkm("kernel_aarch64")
+        _uploadModulesLoad()
+        for build_target in ["kernel_virt_aarch64", "trusty_aarch64"]:
+            for _ko in kernel_ko_dict[build_target]:
+                _fetchAndUpload(build_target, _ko, dest_dir=_KERNEL_STAGING)
+
+        # self._SshRun(f"ls -l {kernel_staging_path}")
+        return True
+
+    def _TryUseGKIKernelModules(self):
+        """Use GKI modules from the kernel build."""
+
+        if not self._FetchAndUploadGKIArtifacts():
+            return False
+        # remove the inadequate modules files from the staging area
+        self._SshRun(f"rm {_KERNEL_STAGING}/modules.*")
+        # invoke replace_ramdisk_modules
+        # with option --override-modules-load to use
+        # the Trusty QEMU specific modules.load
+        self._SshRun(
+            "PATH=$(pwd)/bin:$PATH ./bin/replace_ramdisk_modules "
+            f"--android-ramdisk=ramdisk.img "
+            f"--kernel-ramdisk={_KERNEL_STAGING} "
+            f"--output-ramdisk=ramdisk.img "
+            f"--override-modules-load {_MODULES_LOAD}"
+        )
+        # self._SshRun("ls -lst .")
+        return True
+
     def _UploadBuildArchive(self, archive_path):
-        """Upload Build Artifact (Trusty images archive or Kernel image)"""
-        remote_cmd = f"tar -xzf - -C {cvd_utils.GCE_BASE_DIR} < " + archive_path
-        logger.debug("remote_cmd:\n %s", remote_cmd)
-        self._ssh.Run(remote_cmd)
+        self._SshRun(
+            f"tar -xzf - -C {cvd_utils.GCE_BASE_DIR} < {archive_path}",
+            local_substitution=True,
+        )
+
+    def _ParseLaunchArgs(self):
+        parser = argparse.ArgumentParser(prog="AVD Launch Args")
+        parser.add_argument(
+            "--extra-linux-args",
+            type=str,
+            default=None,
+            help="Trusty QEMU run.py option\n"
+            "allowing to add extra arguments to the linux kernel command line.\n",
+        )
+        parser.add_argument(
+            "--kernel-virt-build-id",
+            type=str,
+            default=None,
+            help="Trusty acloud driver option\n"
+            "provide an extra build id for the out-of-band kernel virtual driver modules.\n",
+        )
+        parser.add_argument(
+            "--kernel-trusty-build-id",
+            type=str,
+            default=None,
+            help="Trusty acloud driver option\n"
+            "provide an extra build id for the out-of-band kernel Trusty driver modules.\n",
+        )
+        # see CVD Launch Args
+        # exhaustive list at tools/acloud/internal/lib/cvd_utils.py
+        # not yet used by Trusty QEMU run.py
+        for arg_str in ["data_policy", "config"]:
+            parser.add_argument(
+                f"-{arg_str}",
+                type=str,
+                default=None,
+                help="CVD specific launch arg\n"
+                "not yet used by Trusty QEMU run.py.\n",
+            )
+        for arg_int in [
+            "memory_mb",
+            "blank_data_image_mb",
+            "x_res",
+            "y_res",
+            "dpi",
+            "cpus",
+            "num_AVD",
+            "base_instance_num",
+        ]:
+            parser.add_argument(
+                f"-{arg_int}",
+                type=int,
+                default=None,
+                help="CVD specific launch arg\n"
+                "not yet used by Trusty QEMU run.py.\n",
+            )
+        return parser.parse_args(self._avd_spec.launch_args.split())
 
     @utils.TimeExecute(function_description="Starting Trusty")
     def _StartTrusty(self):
         """Start the model on the GCE instance."""
-        self._ssh.Run(f"mkdir -p {_REMOTE_LOG_FOLDER}")
-
+        self._SshRun(f"mkdir -p {_REMOTE_LOG_FOLDER}")
+        # TODO(b/417379600): remove the ln commands when the broken symlink
+        # root cause is identified
+        self._SshRun("ln -rsf lk.bin atf/qemu/debug/bl32.bin")
+        self._SshRun(
+            "ln -rsf test-runner/external/trusty/bootloader/test-runner/test-runner.bin atf/qemu/debug/bl33.bin"
+        )
+        # prepare launch args
+        launch_args = (
+            f"--extra-linux-args {self._launch_args.extra_linux_args} "
+            if self._launch_args.extra_linux_args
+            else ""
+        )
         # We use an explicit subshell so we can run this command in the
         # background.
         cmd = "-- sh -c " + shlex.quote(
             shlex.quote(
                 f"{cvd_utils.GCE_BASE_DIR}/run.py "
                 f"--verbose --config={_CONFIG_JSON_FILENAME} "
-                f"{self._avd_spec.launch_args} "
+                f"{launch_args}"
                 f"> {_REMOTE_STDOUT_PATH} "
                 f"2> {_REMOTE_STDERR_PATH} &"
             )
```

