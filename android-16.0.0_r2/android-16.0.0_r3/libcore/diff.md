```diff
diff --git a/EXPECTED_UPSTREAM b/EXPECTED_UPSTREAM
index 56b60ddc102..76f1a10d2d6 100644
--- a/EXPECTED_UPSTREAM
+++ b/EXPECTED_UPSTREAM
@@ -29,237 +29,238 @@ ojluni/src/main/java/java/beans/PropertyChangeEvent.java,jdk8u/jdk8u121-b13,jdk/
 ojluni/src/main/java/java/beans/PropertyChangeListener.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/beans/PropertyChangeListener.java
 ojluni/src/main/java/java/beans/PropertyChangeListenerProxy.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/beans/PropertyChangeListenerProxy.java
 ojluni/src/main/java/java/beans/PropertyChangeSupport.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/beans/PropertyChangeSupport.java
-ojluni/src/main/java/java/io/Bits.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/io/Bits.java
-ojluni/src/main/java/java/io/BufferedInputStream.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/io/BufferedInputStream.java
-ojluni/src/main/java/java/io/BufferedOutputStream.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/io/BufferedOutputStream.java
-ojluni/src/main/java/java/io/BufferedReader.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/BufferedReader.java
-ojluni/src/main/java/java/io/BufferedWriter.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/BufferedWriter.java
-ojluni/src/main/java/java/io/ByteArrayInputStream.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/ByteArrayInputStream.java
-ojluni/src/main/java/java/io/ByteArrayOutputStream.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/ByteArrayOutputStream.java
-ojluni/src/main/java/java/io/CharArrayReader.java,jdk17u/jdk-17.0.10-ga,src/java.base/share/classes/java/io/CharArrayReader.java
-ojluni/src/main/java/java/io/CharArrayWriter.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/CharArrayWriter.java
-ojluni/src/main/java/java/io/CharConversionException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/io/CharConversionException.java
-ojluni/src/main/java/java/io/Closeable.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/io/Closeable.java
-ojluni/src/main/java/java/io/Console.java,jdk17u/jdk-17.0.10-ga,src/java.base/share/classes/java/io/Console.java
-ojluni/src/main/java/java/io/DataInput.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/DataInput.java
-ojluni/src/main/java/java/io/DataInputStream.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/DataInputStream.java
-ojluni/src/main/java/java/io/DataOutput.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/DataOutput.java
-ojluni/src/main/java/java/io/DataOutputStream.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/DataOutputStream.java
-ojluni/src/main/java/java/io/DefaultFileSystem.java,jdk17u/jdk-17.0.6-ga,src/java.base/unix/classes/java/io/DefaultFileSystem.java
-ojluni/src/main/java/java/io/DeleteOnExitHook.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/DeleteOnExitHook.java
-ojluni/src/main/java/java/io/EOFException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/io/EOFException.java
-ojluni/src/main/java/java/io/ExpiringCache.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/io/ExpiringCache.java
-ojluni/src/main/java/java/io/Externalizable.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/Externalizable.java
+ojluni/src/main/java/java/io/Bits.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/io/Bits.java
+ojluni/src/main/java/java/io/BufferedInputStream.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/io/BufferedInputStream.java
+ojluni/src/main/java/java/io/BufferedOutputStream.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/io/BufferedOutputStream.java
+ojluni/src/main/java/java/io/BufferedReader.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/BufferedReader.java
+ojluni/src/main/java/java/io/BufferedWriter.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/BufferedWriter.java
+ojluni/src/main/java/java/io/ByteArrayInputStream.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/ByteArrayInputStream.java
+ojluni/src/main/java/java/io/ByteArrayOutputStream.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/ByteArrayOutputStream.java
+ojluni/src/main/java/java/io/CharArrayReader.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/io/CharArrayReader.java
+ojluni/src/main/java/java/io/CharArrayWriter.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/CharArrayWriter.java
+ojluni/src/main/java/java/io/CharConversionException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/io/CharConversionException.java
+ojluni/src/main/java/java/io/Closeable.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/io/Closeable.java
+ojluni/src/main/java/java/io/Console.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/io/Console.java
+ojluni/src/main/java/java/io/DataInput.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/DataInput.java
+ojluni/src/main/java/java/io/DataInputStream.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/DataInputStream.java
+ojluni/src/main/java/java/io/DataOutput.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/DataOutput.java
+ojluni/src/main/java/java/io/DataOutputStream.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/DataOutputStream.java
+ojluni/src/main/java/java/io/DefaultFileSystem.java,jdk17u/jdk-17.0.14-ga,src/java.base/unix/classes/java/io/DefaultFileSystem.java
+ojluni/src/main/java/java/io/DeleteOnExitHook.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/DeleteOnExitHook.java
+ojluni/src/main/java/java/io/EOFException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/io/EOFException.java
+ojluni/src/main/java/java/io/ExpiringCache.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/io/ExpiringCache.java
+ojluni/src/main/java/java/io/Externalizable.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/Externalizable.java
 ojluni/src/main/java/java/io/File.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/io/File.java
 ojluni/src/main/java/java/io/FileDescriptor.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/java/io/FileDescriptor.java
-ojluni/src/main/java/java/io/FileFilter.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/FileFilter.java
-ojluni/src/main/java/java/io/FileInputStream.java,jdk17u/jdk-17.0.10-ga,src/java.base/share/classes/java/io/FileInputStream.java
-ojluni/src/main/java/java/io/FileNotFoundException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/io/FileNotFoundException.java
-ojluni/src/main/java/java/io/FileOutputStream.java,jdk17u/jdk-17.0.10-ga,src/java.base/share/classes/java/io/FileOutputStream.java
-ojluni/src/main/java/java/io/FilePermission.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/FilePermission.java
-ojluni/src/main/java/java/io/FileReader.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/FileReader.java
-ojluni/src/main/java/java/io/FileSystem.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/FileSystem.java
-ojluni/src/main/java/java/io/FileWriter.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/io/FileWriter.java
-ojluni/src/main/java/java/io/FilenameFilter.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/FilenameFilter.java
-ojluni/src/main/java/java/io/FilterInputStream.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/FilterInputStream.java
-ojluni/src/main/java/java/io/FilterOutputStream.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/FilterOutputStream.java
-ojluni/src/main/java/java/io/FilterReader.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/FilterReader.java
-ojluni/src/main/java/java/io/FilterWriter.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/FilterWriter.java
-ojluni/src/main/java/java/io/Flushable.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/io/Flushable.java
-ojluni/src/main/java/java/io/IOError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/io/IOError.java
-ojluni/src/main/java/java/io/IOException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/io/IOException.java
-ojluni/src/main/java/java/io/InputStream.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/io/InputStream.java
-ojluni/src/main/java/java/io/InputStreamReader.java,jdk17u/jdk-17.0.10-ga,src/java.base/share/classes/java/io/InputStreamReader.java
-ojluni/src/main/java/java/io/InterruptedIOException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/io/InterruptedIOException.java
-ojluni/src/main/java/java/io/InvalidClassException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/io/InvalidClassException.java
-ojluni/src/main/java/java/io/InvalidObjectException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/io/InvalidObjectException.java
-ojluni/src/main/java/java/io/LineNumberInputStream.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/LineNumberInputStream.java
-ojluni/src/main/java/java/io/LineNumberReader.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/LineNumberReader.java
-ojluni/src/main/java/java/io/NotActiveException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/io/NotActiveException.java
-ojluni/src/main/java/java/io/NotSerializableException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/io/NotSerializableException.java
-ojluni/src/main/java/java/io/ObjectInput.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/ObjectInput.java
+ojluni/src/main/java/java/io/FileFilter.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/FileFilter.java
+ojluni/src/main/java/java/io/FileInputStream.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/io/FileInputStream.java
+ojluni/src/main/java/java/io/FileNotFoundException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/io/FileNotFoundException.java
+ojluni/src/main/java/java/io/FileOutputStream.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/io/FileOutputStream.java
+ojluni/src/main/java/java/io/FilePermission.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/FilePermission.java
+ojluni/src/main/java/java/io/FileReader.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/FileReader.java
+ojluni/src/main/java/java/io/FileSystem.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/FileSystem.java
+ojluni/src/main/java/java/io/FileWriter.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/io/FileWriter.java
+ojluni/src/main/java/java/io/FilenameFilter.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/FilenameFilter.java
+ojluni/src/main/java/java/io/FilterInputStream.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/FilterInputStream.java
+ojluni/src/main/java/java/io/FilterOutputStream.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/FilterOutputStream.java
+ojluni/src/main/java/java/io/FilterReader.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/FilterReader.java
+ojluni/src/main/java/java/io/FilterWriter.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/FilterWriter.java
+ojluni/src/main/java/java/io/Flushable.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/io/Flushable.java
+ojluni/src/main/java/java/io/IOError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/io/IOError.java
+ojluni/src/main/java/java/io/IOException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/io/IOException.java
+ojluni/src/main/java/java/io/InputStream.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/io/InputStream.java
+ojluni/src/main/java/java/io/InputStreamReader.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/io/InputStreamReader.java
+ojluni/src/main/java/java/io/InterruptedIOException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/io/InterruptedIOException.java
+ojluni/src/main/java/java/io/InvalidClassException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/io/InvalidClassException.java
+ojluni/src/main/java/java/io/InvalidObjectException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/io/InvalidObjectException.java
+ojluni/src/main/java/java/io/LineNumberInputStream.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/LineNumberInputStream.java
+ojluni/src/main/java/java/io/LineNumberReader.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/LineNumberReader.java
+ojluni/src/main/java/java/io/NotActiveException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/io/NotActiveException.java
+ojluni/src/main/java/java/io/NotSerializableException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/io/NotSerializableException.java
+ojluni/src/main/java/java/io/ObjectInput.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/ObjectInput.java
 ojluni/src/main/java/java/io/ObjectInputStream.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/io/ObjectInputStream.java
-ojluni/src/main/java/java/io/ObjectInputValidation.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/ObjectInputValidation.java
-ojluni/src/main/java/java/io/ObjectOutput.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/ObjectOutput.java
+ojluni/src/main/java/java/io/ObjectInputValidation.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/ObjectInputValidation.java
+ojluni/src/main/java/java/io/ObjectOutput.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/ObjectOutput.java
 ojluni/src/main/java/java/io/ObjectOutputStream.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/io/ObjectOutputStream.java
 ojluni/src/main/java/java/io/ObjectStreamClass.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/io/ObjectStreamClass.java
 ojluni/src/main/java/java/io/ObjectStreamConstants.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/io/ObjectStreamConstants.java
-ojluni/src/main/java/java/io/ObjectStreamException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/io/ObjectStreamException.java
-ojluni/src/main/java/java/io/ObjectStreamField.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/io/ObjectStreamField.java
-ojluni/src/main/java/java/io/OptionalDataException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/io/OptionalDataException.java
-ojluni/src/main/java/java/io/OutputStream.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/io/OutputStream.java
-ojluni/src/main/java/java/io/OutputStreamWriter.java,jdk17u/jdk-17.0.10-ga,src/java.base/share/classes/java/io/OutputStreamWriter.java
-ojluni/src/main/java/java/io/PipedInputStream.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/PipedInputStream.java
-ojluni/src/main/java/java/io/PipedOutputStream.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/PipedOutputStream.java
-ojluni/src/main/java/java/io/PipedReader.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/PipedReader.java
-ojluni/src/main/java/java/io/PipedWriter.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/PipedWriter.java
-ojluni/src/main/java/java/io/PrintStream.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/io/PrintStream.java
-ojluni/src/main/java/java/io/PrintWriter.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/PrintWriter.java
-ojluni/src/main/java/java/io/PushbackInputStream.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/PushbackInputStream.java
-ojluni/src/main/java/java/io/PushbackReader.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/PushbackReader.java
+ojluni/src/main/java/java/io/ObjectStreamException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/io/ObjectStreamException.java
+ojluni/src/main/java/java/io/ObjectStreamField.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/io/ObjectStreamField.java
+ojluni/src/main/java/java/io/OptionalDataException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/io/OptionalDataException.java
+ojluni/src/main/java/java/io/OutputStream.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/io/OutputStream.java
+ojluni/src/main/java/java/io/OutputStreamWriter.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/io/OutputStreamWriter.java
+ojluni/src/main/java/java/io/PipedInputStream.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/PipedInputStream.java
+ojluni/src/main/java/java/io/PipedOutputStream.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/PipedOutputStream.java
+ojluni/src/main/java/java/io/PipedReader.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/PipedReader.java
+ojluni/src/main/java/java/io/PipedWriter.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/PipedWriter.java
+ojluni/src/main/java/java/io/PrintStream.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/io/PrintStream.java
+ojluni/src/main/java/java/io/PrintWriter.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/PrintWriter.java
+ojluni/src/main/java/java/io/PushbackInputStream.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/PushbackInputStream.java
+ojluni/src/main/java/java/io/PushbackReader.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/PushbackReader.java
 ojluni/src/main/java/java/io/RandomAccessFile.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/io/RandomAccessFile.java
-ojluni/src/main/java/java/io/Reader.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/Reader.java
-ojluni/src/main/java/java/io/SequenceInputStream.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/SequenceInputStream.java
-ojluni/src/main/java/java/io/Serial.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/io/Serial.java
-ojluni/src/main/java/java/io/SerialCallbackContext.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/io/SerialCallbackContext.java
-ojluni/src/main/java/java/io/Serializable.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/Serializable.java
-ojluni/src/main/java/java/io/SerializablePermission.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/SerializablePermission.java
-ojluni/src/main/java/java/io/StreamCorruptedException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/io/StreamCorruptedException.java
-ojluni/src/main/java/java/io/StreamTokenizer.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/StreamTokenizer.java
-ojluni/src/main/java/java/io/StringBufferInputStream.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/StringBufferInputStream.java
-ojluni/src/main/java/java/io/StringReader.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/StringReader.java
-ojluni/src/main/java/java/io/StringWriter.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/io/StringWriter.java
-ojluni/src/main/java/java/io/SyncFailedException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/io/SyncFailedException.java
-ojluni/src/main/java/java/io/UTFDataFormatException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/io/UTFDataFormatException.java
-ojluni/src/main/java/java/io/UncheckedIOException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/io/UncheckedIOException.java
-ojluni/src/main/java/java/io/UnixFileSystem.java,jdk11u/jdk-11.0.13-ga,src/java.base/unix/classes/java/io/UnixFileSystem.java
-ojluni/src/main/java/java/io/UnsupportedEncodingException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/io/UnsupportedEncodingException.java
-ojluni/src/main/java/java/io/WriteAbortedException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/io/WriteAbortedException.java
-ojluni/src/main/java/java/io/Writer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/io/Writer.java
-ojluni/src/main/java/java/io/package-info.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/io/package-info.java
-ojluni/src/main/java/java/lang/AbstractMethodError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/AbstractMethodError.java
-ojluni/src/main/java/java/lang/AbstractStringBuilder.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/AbstractStringBuilder.java
-ojluni/src/main/java/java/lang/Appendable.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/Appendable.java
-ojluni/src/main/java/java/lang/ArithmeticException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/ArithmeticException.java
-ojluni/src/main/java/java/lang/ArrayIndexOutOfBoundsException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/ArrayIndexOutOfBoundsException.java
-ojluni/src/main/java/java/lang/ArrayStoreException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/ArrayStoreException.java
-ojluni/src/main/java/java/lang/AssertionError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/AssertionError.java
-ojluni/src/main/java/java/lang/AutoCloseable.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/AutoCloseable.java
-ojluni/src/main/java/java/lang/BaseVirtualThread.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/BaseVirtualThread.java
-ojluni/src/main/java/java/lang/Boolean.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/Boolean.java
-ojluni/src/main/java/java/lang/BootstrapMethodError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/BootstrapMethodError.java
-ojluni/src/main/java/java/lang/Byte.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/Byte.java
-ojluni/src/main/java/java/lang/CharSequence.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/CharSequence.java
-ojluni/src/main/java/java/lang/Character.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/Character.java
-ojluni/src/main/java/java/lang/Class.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/Class.java
-ojluni/src/main/java/java/lang/ClassCastException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/ClassCastException.java
-ojluni/src/main/java/java/lang/ClassCircularityError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/ClassCircularityError.java
-ojluni/src/main/java/java/lang/ClassFormatError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/ClassFormatError.java
-ojluni/src/main/java/java/lang/ClassLoader.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/ClassLoader.java
-ojluni/src/main/java/java/lang/ClassNotFoundException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/ClassNotFoundException.java
-ojluni/src/main/java/java/lang/ClassValue.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/ClassValue.java
-ojluni/src/main/java/java/lang/CloneNotSupportedException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/CloneNotSupportedException.java
-ojluni/src/main/java/java/lang/Cloneable.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/Cloneable.java
-ojluni/src/main/java/java/lang/Comparable.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/Comparable.java
-ojluni/src/main/java/java/lang/Compiler.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/Compiler.java
-ojluni/src/main/java/java/lang/Deprecated.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/Deprecated.java
-ojluni/src/main/java/java/lang/Double.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/Double.java
-ojluni/src/main/java/java/lang/Enum.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/Enum.java
-ojluni/src/main/java/java/lang/EnumConstantNotPresentException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/EnumConstantNotPresentException.java
-ojluni/src/main/java/java/lang/Error.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/Error.java
-ojluni/src/main/java/java/lang/Exception.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/Exception.java
-ojluni/src/main/java/java/lang/ExceptionInInitializerError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/ExceptionInInitializerError.java
-ojluni/src/main/java/java/lang/Float.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/Float.java
-ojluni/src/main/java/java/lang/FunctionalInterface.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/FunctionalInterface.java
-ojluni/src/main/java/java/lang/IllegalAccessError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/IllegalAccessError.java
-ojluni/src/main/java/java/lang/IllegalAccessException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/IllegalAccessException.java
-ojluni/src/main/java/java/lang/IllegalArgumentException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/IllegalArgumentException.java
-ojluni/src/main/java/java/lang/IllegalCallerException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/IllegalCallerException.java
-ojluni/src/main/java/java/lang/IllegalMonitorStateException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/IllegalMonitorStateException.java
-ojluni/src/main/java/java/lang/IllegalStateException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/IllegalStateException.java
-ojluni/src/main/java/java/lang/IllegalThreadStateException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/IllegalThreadStateException.java
-ojluni/src/main/java/java/lang/IncompatibleClassChangeError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/IncompatibleClassChangeError.java
-ojluni/src/main/java/java/lang/IndexOutOfBoundsException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/IndexOutOfBoundsException.java
-ojluni/src/main/java/java/lang/InheritableThreadLocal.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/InheritableThreadLocal.java
-ojluni/src/main/java/java/lang/InstantiationError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/InstantiationError.java
-ojluni/src/main/java/java/lang/InstantiationException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/InstantiationException.java
-ojluni/src/main/java/java/lang/Integer.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/Integer.java
-ojluni/src/main/java/java/lang/InternalError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/InternalError.java
-ojluni/src/main/java/java/lang/InterruptedException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/InterruptedException.java
-ojluni/src/main/java/java/lang/Iterable.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/Iterable.java
+ojluni/src/main/java/java/io/Reader.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/Reader.java
+ojluni/src/main/java/java/io/SequenceInputStream.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/SequenceInputStream.java
+ojluni/src/main/java/java/io/Serial.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/io/Serial.java
+ojluni/src/main/java/java/io/SerialCallbackContext.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/io/SerialCallbackContext.java
+ojluni/src/main/java/java/io/Serializable.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/Serializable.java
+ojluni/src/main/java/java/io/SerializablePermission.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/SerializablePermission.java
+ojluni/src/main/java/java/io/StreamCorruptedException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/io/StreamCorruptedException.java
+ojluni/src/main/java/java/io/StreamTokenizer.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/StreamTokenizer.java
+ojluni/src/main/java/java/io/StringBufferInputStream.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/StringBufferInputStream.java
+ojluni/src/main/java/java/io/StringReader.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/StringReader.java
+ojluni/src/main/java/java/io/StringWriter.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/io/StringWriter.java
+ojluni/src/main/java/java/io/SyncFailedException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/io/SyncFailedException.java
+ojluni/src/main/java/java/io/UTFDataFormatException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/io/UTFDataFormatException.java
+ojluni/src/main/java/java/io/UncheckedIOException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/io/UncheckedIOException.java
+ojluni/src/main/java/java/io/UnixFileSystem.java,jdk11u/jdk-11.0.26-ga,src/java.base/unix/classes/java/io/UnixFileSystem.java
+ojluni/src/main/java/java/io/UnsupportedEncodingException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/io/UnsupportedEncodingException.java
+ojluni/src/main/java/java/io/WriteAbortedException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/io/WriteAbortedException.java
+ojluni/src/main/java/java/io/Writer.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/io/Writer.java
+ojluni/src/main/java/java/io/package-info.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/io/package-info.java
+ojluni/src/main/java/java/lang/AbstractMethodError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/AbstractMethodError.java
+ojluni/src/main/java/java/lang/AbstractStringBuilder.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/AbstractStringBuilder.java
+ojluni/src/main/java/java/lang/Appendable.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/Appendable.java
+ojluni/src/main/java/java/lang/ArithmeticException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/ArithmeticException.java
+ojluni/src/main/java/java/lang/ArrayIndexOutOfBoundsException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/ArrayIndexOutOfBoundsException.java
+ojluni/src/main/java/java/lang/ArrayStoreException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/ArrayStoreException.java
+ojluni/src/main/java/java/lang/AssertionError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/AssertionError.java
+ojluni/src/main/java/java/lang/AutoCloseable.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/AutoCloseable.java
+ojluni/src/main/java/java/lang/BaseVirtualThread.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/BaseVirtualThread.java
+ojluni/src/main/java/java/lang/Boolean.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/Boolean.java
+ojluni/src/main/java/java/lang/BootstrapMethodError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/BootstrapMethodError.java
+ojluni/src/main/java/java/lang/Byte.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/Byte.java
+ojluni/src/main/java/java/lang/CharSequence.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/CharSequence.java
+ojluni/src/main/java/java/lang/Character.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/Character.java
+ojluni/src/main/java/java/lang/Class.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/Class.java
+ojluni/src/main/java/java/lang/ClassCastException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/ClassCastException.java
+ojluni/src/main/java/java/lang/ClassCircularityError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/ClassCircularityError.java
+ojluni/src/main/java/java/lang/ClassFormatError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/ClassFormatError.java
+ojluni/src/main/java/java/lang/ClassLoader.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/ClassLoader.java
+ojluni/src/main/java/java/lang/ClassNotFoundException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/ClassNotFoundException.java
+ojluni/src/main/java/java/lang/ClassValue.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/ClassValue.java
+ojluni/src/main/java/java/lang/CloneNotSupportedException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/CloneNotSupportedException.java
+ojluni/src/main/java/java/lang/Cloneable.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/Cloneable.java
+ojluni/src/main/java/java/lang/Comparable.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/Comparable.java
+ojluni/src/main/java/java/lang/Compiler.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/Compiler.java
+ojluni/src/main/java/java/lang/Deprecated.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/Deprecated.java
+ojluni/src/main/java/java/lang/Double.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/Double.java
+ojluni/src/main/java/java/lang/Enum.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/Enum.java
+ojluni/src/main/java/java/lang/EnumConstantNotPresentException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/EnumConstantNotPresentException.java
+ojluni/src/main/java/java/lang/Error.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/Error.java
+ojluni/src/main/java/java/lang/Exception.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/Exception.java
+ojluni/src/main/java/java/lang/ExceptionInInitializerError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/ExceptionInInitializerError.java
+ojluni/src/main/java/java/lang/Float.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/Float.java
+ojluni/src/main/java/java/lang/FunctionalInterface.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/FunctionalInterface.java
+ojluni/src/main/java/java/lang/IllegalAccessError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/IllegalAccessError.java
+ojluni/src/main/java/java/lang/IllegalAccessException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/IllegalAccessException.java
+ojluni/src/main/java/java/lang/IllegalArgumentException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/IllegalArgumentException.java
+ojluni/src/main/java/java/lang/IllegalCallerException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/IllegalCallerException.java
+ojluni/src/main/java/java/lang/IllegalMonitorStateException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/IllegalMonitorStateException.java
+ojluni/src/main/java/java/lang/IllegalStateException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/IllegalStateException.java
+ojluni/src/main/java/java/lang/IllegalThreadStateException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/IllegalThreadStateException.java
+ojluni/src/main/java/java/lang/IncompatibleClassChangeError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/IncompatibleClassChangeError.java
+ojluni/src/main/java/java/lang/IndexOutOfBoundsException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/IndexOutOfBoundsException.java
+ojluni/src/main/java/java/lang/InheritableThreadLocal.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/InheritableThreadLocal.java
+ojluni/src/main/java/java/lang/InstantiationError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/InstantiationError.java
+ojluni/src/main/java/java/lang/InstantiationException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/InstantiationException.java
+ojluni/src/main/java/java/lang/Integer.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/Integer.java
+ojluni/src/main/java/java/lang/InternalError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/InternalError.java
+ojluni/src/main/java/java/lang/InterruptedException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/InterruptedException.java
+ojluni/src/main/java/java/lang/Iterable.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/Iterable.java
 ojluni/src/main/java/java/lang/JavaLangAccess.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/access/JavaLangAccess.java
-ojluni/src/main/java/java/lang/LinkageError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/LinkageError.java
-ojluni/src/main/java/java/lang/LiveStackFrame.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/LiveStackFrame.java
-ojluni/src/main/java/java/lang/LiveStackFrameInfo.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/LiveStackFrameInfo.java
-ojluni/src/main/java/java/lang/Long.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/Long.java
-ojluni/src/main/java/java/lang/MatchException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/MatchException.java
-ojluni/src/main/java/java/lang/Math.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/Math.java
-ojluni/src/main/java/java/lang/NegativeArraySizeException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/NegativeArraySizeException.java
-ojluni/src/main/java/java/lang/NoClassDefFoundError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/NoClassDefFoundError.java
-ojluni/src/main/java/java/lang/NoSuchFieldError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/NoSuchFieldError.java
-ojluni/src/main/java/java/lang/NoSuchFieldException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/NoSuchFieldException.java
-ojluni/src/main/java/java/lang/NoSuchMethodError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/NoSuchMethodError.java
-ojluni/src/main/java/java/lang/NoSuchMethodException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/NoSuchMethodException.java
-ojluni/src/main/java/java/lang/NullPointerException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/NullPointerException.java
-ojluni/src/main/java/java/lang/Number.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/Number.java
-ojluni/src/main/java/java/lang/NumberFormatException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/NumberFormatException.java
-ojluni/src/main/java/java/lang/Object.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/Object.java
-ojluni/src/main/java/java/lang/OutOfMemoryError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/OutOfMemoryError.java
-ojluni/src/main/java/java/lang/Override.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/Override.java
+ojluni/src/main/java/java/lang/LinkageError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/LinkageError.java
+ojluni/src/main/java/java/lang/LiveStackFrame.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/LiveStackFrame.java
+ojluni/src/main/java/java/lang/LiveStackFrameInfo.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/LiveStackFrameInfo.java
+ojluni/src/main/java/java/lang/Long.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/Long.java
+ojluni/src/main/java/java/lang/MatchException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/MatchException.java
+ojluni/src/main/java/java/lang/Math.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/Math.java
+ojluni/src/main/java/java/lang/NegativeArraySizeException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/NegativeArraySizeException.java
+ojluni/src/main/java/java/lang/NoClassDefFoundError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/NoClassDefFoundError.java
+ojluni/src/main/java/java/lang/NoSuchFieldError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/NoSuchFieldError.java
+ojluni/src/main/java/java/lang/NoSuchFieldException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/NoSuchFieldException.java
+ojluni/src/main/java/java/lang/NoSuchMethodError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/NoSuchMethodError.java
+ojluni/src/main/java/java/lang/NoSuchMethodException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/NoSuchMethodException.java
+ojluni/src/main/java/java/lang/NullPointerException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/NullPointerException.java
+ojluni/src/main/java/java/lang/Number.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/Number.java
+ojluni/src/main/java/java/lang/NumberFormatException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/NumberFormatException.java
+ojluni/src/main/java/java/lang/Object.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/Object.java
+ojluni/src/main/java/java/lang/OutOfMemoryError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/OutOfMemoryError.java
+ojluni/src/main/java/java/lang/Override.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/Override.java
 ojluni/src/main/java/java/lang/Package.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/lang/Package.java
 ojluni/src/main/java/java/lang/Process.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/lang/Process.java
 ojluni/src/main/java/java/lang/ProcessBuilder.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/lang/ProcessBuilder.java
 ojluni/src/main/java/java/lang/ProcessEnvironment.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/java/lang/ProcessEnvironment.java
 ojluni/src/main/java/java/lang/ProcessImpl.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/java/lang/ProcessImpl.java
-ojluni/src/main/java/java/lang/Readable.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/Readable.java
-ojluni/src/main/java/java/lang/ReflectiveOperationException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/ReflectiveOperationException.java
-ojluni/src/main/java/java/lang/Runnable.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/Runnable.java
-ojluni/src/main/java/java/lang/Runtime.java,jdk11u/jdk-11.0.2-ga,src/java.base/share/classes/java/lang/Runtime.java
-ojluni/src/main/java/java/lang/RuntimeException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/RuntimeException.java
-ojluni/src/main/java/java/lang/RuntimePermission.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/RuntimePermission.java
-ojluni/src/main/java/java/lang/SafeVarargs.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/SafeVarargs.java
-ojluni/src/main/java/java/lang/SecurityException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/SecurityException.java
-ojluni/src/main/java/java/lang/SecurityManager.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/SecurityManager.java
-ojluni/src/main/java/java/lang/Short.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/Short.java
-ojluni/src/main/java/java/lang/StackFrameInfo.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/StackFrameInfo.java
-ojluni/src/main/java/java/lang/StackOverflowError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/StackOverflowError.java
-ojluni/src/main/java/java/lang/StackStreamFactory.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/StackStreamFactory.java
-ojluni/src/main/java/java/lang/StackTraceElement.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/StackTraceElement.java
-ojluni/src/main/java/java/lang/StackWalker.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/StackWalker.java
-ojluni/src/main/java/java/lang/StrictMath.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/StrictMath.java
-ojluni/src/main/java/java/lang/String.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/String.java
-ojluni/src/main/java/java/lang/StringBuffer.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/StringBuffer.java
-ojluni/src/main/java/java/lang/StringBuilder.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/StringBuilder.java
-ojluni/src/main/java/java/lang/StringIndexOutOfBoundsException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/StringIndexOutOfBoundsException.java
-ojluni/src/main/java/java/lang/StringLatin1.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/StringLatin1.java
-ojluni/src/main/java/java/lang/StringUTF16.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/StringUTF16.java
-ojluni/src/main/java/java/lang/SuppressWarnings.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/SuppressWarnings.java
+ojluni/src/main/java/java/lang/Readable.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/Readable.java
+ojluni/src/main/java/java/lang/ReflectiveOperationException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/ReflectiveOperationException.java
+ojluni/src/main/java/java/lang/Runnable.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/Runnable.java
+ojluni/src/main/java/java/lang/Runtime.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/Runtime.java
+ojluni/src/main/java/java/lang/RuntimeException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/RuntimeException.java
+ojluni/src/main/java/java/lang/RuntimePermission.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/RuntimePermission.java
+ojluni/src/main/java/java/lang/SafeVarargs.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/SafeVarargs.java
+ojluni/src/main/java/java/lang/SecurityException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/SecurityException.java
+ojluni/src/main/java/java/lang/SecurityManager.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/SecurityManager.java
+ojluni/src/main/java/java/lang/Short.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/Short.java
+ojluni/src/main/java/java/lang/StackFrameInfo.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/StackFrameInfo.java
+ojluni/src/main/java/java/lang/StackOverflowError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/StackOverflowError.java
+ojluni/src/main/java/java/lang/StackStreamFactory.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/StackStreamFactory.java
+ojluni/src/main/java/java/lang/StackTraceElement.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/StackTraceElement.java
+ojluni/src/main/java/java/lang/StackWalker.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/StackWalker.java
+ojluni/src/main/java/java/lang/StrictMath.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/StrictMath.java
+ojluni/src/main/java/java/lang/String.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/String.java
+ojluni/src/main/java/java/lang/StringBuffer.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/StringBuffer.java
+ojluni/src/main/java/java/lang/StringBuilder.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/StringBuilder.java
+ojluni/src/main/java/java/lang/StringIndexOutOfBoundsException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/StringIndexOutOfBoundsException.java
+ojluni/src/main/java/java/lang/StringLatin1.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/StringLatin1.java
+ojluni/src/main/java/java/lang/StringUTF16.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/StringUTF16.java
+ojluni/src/main/java/java/lang/SuppressWarnings.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/SuppressWarnings.java
 ojluni/src/main/java/java/lang/System.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/lang/System.java
-ojluni/src/main/java/java/lang/Thread.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/Thread.java
-ojluni/src/main/java/java/lang/ThreadDeath.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/ThreadDeath.java
-ojluni/src/main/java/java/lang/ThreadGroup.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/ThreadGroup.java
-ojluni/src/main/java/java/lang/ThreadLocal.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/ThreadLocal.java
-ojluni/src/main/java/java/lang/Throwable.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/Throwable.java
-ojluni/src/main/java/java/lang/TypeNotPresentException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/TypeNotPresentException.java
+ojluni/src/main/java/java/lang/Thread.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/Thread.java
+ojluni/src/main/java/java/lang/ThreadDeath.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/ThreadDeath.java
+ojluni/src/main/java/java/lang/ThreadGroup.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/ThreadGroup.java
+ojluni/src/main/java/java/lang/ThreadLocal.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/ThreadLocal.java
+ojluni/src/main/java/java/lang/Throwable.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/Throwable.java
+ojluni/src/main/java/java/lang/TypeNotPresentException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/TypeNotPresentException.java
 ojluni/src/main/java/java/lang/UNIXProcess.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/java/lang/UNIXProcess.java
-ojluni/src/main/java/java/lang/UnknownError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/UnknownError.java
-ojluni/src/main/java/java/lang/UnsatisfiedLinkError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/UnsatisfiedLinkError.java
-ojluni/src/main/java/java/lang/UnsupportedClassVersionError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/UnsupportedClassVersionError.java
-ojluni/src/main/java/java/lang/UnsupportedOperationException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/UnsupportedOperationException.java
-ojluni/src/main/java/java/lang/VerifyError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/VerifyError.java
-ojluni/src/main/java/java/lang/VirtualMachineError.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/VirtualMachineError.java
-ojluni/src/main/java/java/lang/Void.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/Void.java
-ojluni/src/main/java/java/lang/annotation/Annotation.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/annotation/Annotation.java
-ojluni/src/main/java/java/lang/annotation/AnnotationFormatError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/annotation/AnnotationFormatError.java
-ojluni/src/main/java/java/lang/annotation/AnnotationTypeMismatchException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/annotation/AnnotationTypeMismatchException.java
-ojluni/src/main/java/java/lang/annotation/Documented.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/annotation/Documented.java
-ojluni/src/main/java/java/lang/annotation/ElementType.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/annotation/ElementType.java
-ojluni/src/main/java/java/lang/annotation/IncompleteAnnotationException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/annotation/IncompleteAnnotationException.java
-ojluni/src/main/java/java/lang/annotation/Inherited.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/annotation/Inherited.java
-ojluni/src/main/java/java/lang/annotation/Native.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/annotation/Native.java
-ojluni/src/main/java/java/lang/annotation/Repeatable.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/annotation/Repeatable.java
-ojluni/src/main/java/java/lang/annotation/Retention.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/annotation/Retention.java
-ojluni/src/main/java/java/lang/annotation/RetentionPolicy.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/annotation/RetentionPolicy.java
-ojluni/src/main/java/java/lang/annotation/Target.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/annotation/Target.java
-ojluni/src/main/java/java/lang/annotation/package-info.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/annotation/package-info.java
-ojluni/src/main/java/java/lang/constant/AsTypeMethodHandleDesc.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/constant/AsTypeMethodHandleDesc.java
-ojluni/src/main/java/java/lang/constant/ClassDesc.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/constant/ClassDesc.java
-ojluni/src/main/java/java/lang/constant/Constable.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/constant/Constable.java
-ojluni/src/main/java/java/lang/constant/ConstantDesc.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/constant/ConstantDesc.java
-ojluni/src/main/java/java/lang/constant/ConstantDescs.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/constant/ConstantDescs.java
-ojluni/src/main/java/java/lang/constant/ConstantUtils.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/constant/ConstantUtils.java
-ojluni/src/main/java/java/lang/constant/DirectMethodHandleDesc.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/constant/DirectMethodHandleDesc.java
-ojluni/src/main/java/java/lang/constant/DirectMethodHandleDescImpl.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/constant/DirectMethodHandleDescImpl.java
-ojluni/src/main/java/java/lang/constant/DynamicCallSiteDesc.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/constant/DynamicCallSiteDesc.java
-ojluni/src/main/java/java/lang/constant/DynamicConstantDesc.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/constant/DynamicConstantDesc.java
-ojluni/src/main/java/java/lang/constant/MethodHandleDesc.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/constant/MethodHandleDesc.java
-ojluni/src/main/java/java/lang/constant/MethodTypeDesc.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/constant/MethodTypeDesc.java
-ojluni/src/main/java/java/lang/constant/MethodTypeDescImpl.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/constant/MethodTypeDescImpl.java
-ojluni/src/main/java/java/lang/constant/PrimitiveClassDescImpl.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/constant/PrimitiveClassDescImpl.java
-ojluni/src/main/java/java/lang/constant/ReferenceClassDescImpl.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/constant/ReferenceClassDescImpl.java
-ojluni/src/main/java/java/lang/constant/package-info.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/constant/package-info.java
+ojluni/src/main/java/java/lang/UnknownError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/UnknownError.java
+ojluni/src/main/java/java/lang/UnsatisfiedLinkError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/UnsatisfiedLinkError.java
+ojluni/src/main/java/java/lang/UnsupportedClassVersionError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/UnsupportedClassVersionError.java
+ojluni/src/main/java/java/lang/UnsupportedOperationException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/UnsupportedOperationException.java
+ojluni/src/main/java/java/lang/VerifyError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/VerifyError.java
+ojluni/src/main/java/java/lang/VirtualMachineError.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/VirtualMachineError.java
+ojluni/src/main/java/java/lang/Void.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/Void.java
+ojluni/src/main/java/java/lang/WrongThreadException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/WrongThreadException.java
+ojluni/src/main/java/java/lang/annotation/Annotation.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/annotation/Annotation.java
+ojluni/src/main/java/java/lang/annotation/AnnotationFormatError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/annotation/AnnotationFormatError.java
+ojluni/src/main/java/java/lang/annotation/AnnotationTypeMismatchException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/annotation/AnnotationTypeMismatchException.java
+ojluni/src/main/java/java/lang/annotation/Documented.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/annotation/Documented.java
+ojluni/src/main/java/java/lang/annotation/ElementType.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/annotation/ElementType.java
+ojluni/src/main/java/java/lang/annotation/IncompleteAnnotationException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/annotation/IncompleteAnnotationException.java
+ojluni/src/main/java/java/lang/annotation/Inherited.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/annotation/Inherited.java
+ojluni/src/main/java/java/lang/annotation/Native.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/annotation/Native.java
+ojluni/src/main/java/java/lang/annotation/Repeatable.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/annotation/Repeatable.java
+ojluni/src/main/java/java/lang/annotation/Retention.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/annotation/Retention.java
+ojluni/src/main/java/java/lang/annotation/RetentionPolicy.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/annotation/RetentionPolicy.java
+ojluni/src/main/java/java/lang/annotation/Target.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/annotation/Target.java
+ojluni/src/main/java/java/lang/annotation/package-info.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/annotation/package-info.java
+ojluni/src/main/java/java/lang/constant/AsTypeMethodHandleDesc.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/constant/AsTypeMethodHandleDesc.java
+ojluni/src/main/java/java/lang/constant/ClassDesc.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/constant/ClassDesc.java
+ojluni/src/main/java/java/lang/constant/Constable.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/constant/Constable.java
+ojluni/src/main/java/java/lang/constant/ConstantDesc.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/constant/ConstantDesc.java
+ojluni/src/main/java/java/lang/constant/ConstantDescs.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/constant/ConstantDescs.java
+ojluni/src/main/java/java/lang/constant/ConstantUtils.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/constant/ConstantUtils.java
+ojluni/src/main/java/java/lang/constant/DirectMethodHandleDesc.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/constant/DirectMethodHandleDesc.java
+ojluni/src/main/java/java/lang/constant/DirectMethodHandleDescImpl.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/constant/DirectMethodHandleDescImpl.java
+ojluni/src/main/java/java/lang/constant/DynamicCallSiteDesc.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/constant/DynamicCallSiteDesc.java
+ojluni/src/main/java/java/lang/constant/DynamicConstantDesc.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/constant/DynamicConstantDesc.java
+ojluni/src/main/java/java/lang/constant/MethodHandleDesc.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/constant/MethodHandleDesc.java
+ojluni/src/main/java/java/lang/constant/MethodTypeDesc.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/constant/MethodTypeDesc.java
+ojluni/src/main/java/java/lang/constant/MethodTypeDescImpl.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/constant/MethodTypeDescImpl.java
+ojluni/src/main/java/java/lang/constant/PrimitiveClassDescImpl.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/constant/PrimitiveClassDescImpl.java
+ojluni/src/main/java/java/lang/constant/ReferenceClassDescImpl.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/constant/ReferenceClassDescImpl.java
+ojluni/src/main/java/java/lang/constant/package-info.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/constant/package-info.java
 ojluni/src/main/java/java/lang/invoke/CallSite.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/lang/invoke/CallSite.java
-ojluni/src/main/java/java/lang/invoke/ConstantBootstraps.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/invoke/ConstantBootstraps.java
+ojluni/src/main/java/java/lang/invoke/ConstantBootstraps.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/invoke/ConstantBootstraps.java
 ojluni/src/main/java/java/lang/invoke/ConstantCallSite.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/lang/invoke/ConstantCallSite.java
 ojluni/src/main/java/java/lang/invoke/LambdaConversionException.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/lang/invoke/LambdaConversionException.java
 ojluni/src/main/java/java/lang/invoke/MethodHandle.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/lang/invoke/MethodHandle.java
@@ -271,378 +272,379 @@ ojluni/src/main/java/java/lang/invoke/MethodHandles.java,jdk8u/jdk8u121-b13,jdk/
 ojluni/src/main/java/java/lang/invoke/MethodType.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/lang/invoke/MethodType.java
 ojluni/src/main/java/java/lang/invoke/MethodTypeForm.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/lang/invoke/MethodTypeForm.java
 ojluni/src/main/java/java/lang/invoke/MutableCallSite.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/lang/invoke/MutableCallSite.java
-ojluni/src/main/java/java/lang/invoke/StringConcatException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/invoke/StringConcatException.java
-ojluni/src/main/java/java/lang/invoke/TypeDescriptor.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/invoke/TypeDescriptor.java
+ojluni/src/main/java/java/lang/invoke/StringConcatException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/invoke/StringConcatException.java
+ojluni/src/main/java/java/lang/invoke/TypeDescriptor.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/invoke/TypeDescriptor.java
 # java.lang.invoke.Transformers isn't in the upstream OpenJDK
-ojluni/src/main/java/java/lang/invoke/VarHandle.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/invoke/VarHandle.java
+ojluni/src/main/java/java/lang/invoke/VarHandle.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/invoke/VarHandle.java
 ojluni/src/main/java/java/lang/invoke/VolatileCallSite.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/lang/invoke/VolatileCallSite.java
-ojluni/src/main/java/java/lang/invoke/WrongMethodTypeException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/invoke/WrongMethodTypeException.java
-ojluni/src/main/java/java/lang/package-info.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/package-info.java
-ojluni/src/main/java/java/lang/ref/Cleaner.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/ref/Cleaner.java
-ojluni/src/main/java/java/lang/ref/PhantomReference.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/ref/PhantomReference.java
+ojluni/src/main/java/java/lang/invoke/WrongMethodTypeException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/invoke/WrongMethodTypeException.java
+ojluni/src/main/java/java/lang/package-info.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/package-info.java
+ojluni/src/main/java/java/lang/ref/Cleaner.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/ref/Cleaner.java
+ojluni/src/main/java/java/lang/ref/PhantomReference.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/ref/PhantomReference.java
 ojluni/src/main/java/java/lang/ref/Reference.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/lang/ref/Reference.java
 ojluni/src/main/java/java/lang/ref/ReferenceQueue.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/lang/ref/ReferenceQueue.java
-ojluni/src/main/java/java/lang/ref/SoftReference.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/ref/SoftReference.java
-ojluni/src/main/java/java/lang/ref/WeakReference.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/ref/WeakReference.java
-ojluni/src/main/java/java/lang/ref/package-info.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/ref/package-info.java
+ojluni/src/main/java/java/lang/ref/SoftReference.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/ref/SoftReference.java
+ojluni/src/main/java/java/lang/ref/WeakReference.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/ref/WeakReference.java
+ojluni/src/main/java/java/lang/ref/package-info.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/ref/package-info.java
 ojluni/src/main/java/java/lang/reflect/AccessibleObject.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/lang/reflect/AccessibleObject.java
-ojluni/src/main/java/java/lang/reflect/AnnotatedElement.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/reflect/AnnotatedElement.java
-ojluni/src/main/java/java/lang/reflect/Array.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/reflect/Array.java
+ojluni/src/main/java/java/lang/reflect/AnnotatedElement.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/reflect/AnnotatedElement.java
+ojluni/src/main/java/java/lang/reflect/Array.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/reflect/Array.java
 ojluni/src/main/java/java/lang/reflect/Constructor.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/lang/reflect/Constructor.java
 ojluni/src/main/java/java/lang/reflect/Executable.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/lang/reflect/Executable.java
 ojluni/src/main/java/java/lang/reflect/Field.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/lang/reflect/Field.java
-ojluni/src/main/java/java/lang/reflect/GenericArrayType.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/reflect/GenericArrayType.java
-ojluni/src/main/java/java/lang/reflect/GenericDeclaration.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/reflect/GenericDeclaration.java
-ojluni/src/main/java/java/lang/reflect/GenericSignatureFormatError.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/reflect/GenericSignatureFormatError.java
-ojluni/src/main/java/java/lang/reflect/InvocationHandler.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/reflect/InvocationHandler.java
-ojluni/src/main/java/java/lang/reflect/InvocationTargetException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/reflect/InvocationTargetException.java
-ojluni/src/main/java/java/lang/reflect/MalformedParameterizedTypeException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/reflect/MalformedParameterizedTypeException.java
-ojluni/src/main/java/java/lang/reflect/MalformedParametersException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/reflect/MalformedParametersException.java
-ojluni/src/main/java/java/lang/reflect/Member.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/reflect/Member.java
+ojluni/src/main/java/java/lang/reflect/GenericArrayType.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/reflect/GenericArrayType.java
+ojluni/src/main/java/java/lang/reflect/GenericDeclaration.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/reflect/GenericDeclaration.java
+ojluni/src/main/java/java/lang/reflect/GenericSignatureFormatError.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/reflect/GenericSignatureFormatError.java
+ojluni/src/main/java/java/lang/reflect/InvocationHandler.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/reflect/InvocationHandler.java
+ojluni/src/main/java/java/lang/reflect/InvocationTargetException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/reflect/InvocationTargetException.java
+ojluni/src/main/java/java/lang/reflect/MalformedParameterizedTypeException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/reflect/MalformedParameterizedTypeException.java
+ojluni/src/main/java/java/lang/reflect/MalformedParametersException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/reflect/MalformedParametersException.java
+ojluni/src/main/java/java/lang/reflect/Member.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/reflect/Member.java
 ojluni/src/main/java/java/lang/reflect/Method.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/lang/reflect/Method.java
-ojluni/src/main/java/java/lang/reflect/Modifier.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/reflect/Modifier.java
-ojluni/src/main/java/java/lang/reflect/Parameter.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/reflect/Parameter.java
-ojluni/src/main/java/java/lang/reflect/ParameterizedType.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/reflect/ParameterizedType.java
+ojluni/src/main/java/java/lang/reflect/Modifier.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/reflect/Modifier.java
+ojluni/src/main/java/java/lang/reflect/Parameter.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/reflect/Parameter.java
+ojluni/src/main/java/java/lang/reflect/ParameterizedType.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/reflect/ParameterizedType.java
 ojluni/src/main/java/java/lang/reflect/Proxy.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/lang/reflect/Proxy.java
-ojluni/src/main/java/java/lang/reflect/RecordComponent.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/lang/reflect/RecordComponent.java
-ojluni/src/main/java/java/lang/reflect/ReflectPermission.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/reflect/ReflectPermission.java
-ojluni/src/main/java/java/lang/reflect/Type.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/reflect/Type.java
-ojluni/src/main/java/java/lang/reflect/TypeVariable.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/reflect/TypeVariable.java
-ojluni/src/main/java/java/lang/reflect/UndeclaredThrowableException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/reflect/UndeclaredThrowableException.java
+ojluni/src/main/java/java/lang/reflect/RecordComponent.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/reflect/RecordComponent.java
+ojluni/src/main/java/java/lang/reflect/ReflectPermission.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/reflect/ReflectPermission.java
+ojluni/src/main/java/java/lang/reflect/Type.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/reflect/Type.java
+ojluni/src/main/java/java/lang/reflect/TypeVariable.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/reflect/TypeVariable.java
+ojluni/src/main/java/java/lang/reflect/UndeclaredThrowableException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/reflect/UndeclaredThrowableException.java
 ojluni/src/main/java/java/lang/reflect/WeakCache.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/lang/reflect/WeakCache.java
-ojluni/src/main/java/java/lang/reflect/WildcardType.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/lang/reflect/WildcardType.java
+ojluni/src/main/java/java/lang/reflect/WildcardType.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/lang/reflect/WildcardType.java
 ojluni/src/main/java/java/lang/reflect/package-info.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/lang/reflect/package-info.java
-ojluni/src/main/java/java/lang/runtime/ObjectMethods.java,jdk17u/jdk-17.0.10-ga,src/java.base/share/classes/java/lang/runtime/ObjectMethods.java
-ojluni/src/main/java/java/lang/runtime/SwitchBootstraps.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/lang/runtime/SwitchBootstraps.java
-ojluni/src/main/java/java/math/BigDecimal.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/math/BigDecimal.java
-ojluni/src/main/java/java/math/BigInteger.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/math/BigInteger.java
-ojluni/src/main/java/java/math/BitSieve.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/math/BitSieve.java
-ojluni/src/main/java/java/math/MathContext.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/math/MathContext.java
-ojluni/src/main/java/java/math/MutableBigInteger.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/math/MutableBigInteger.java
-ojluni/src/main/java/java/math/RoundingMode.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/math/RoundingMode.java
-ojluni/src/main/java/java/math/SignedMutableBigInteger.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/math/SignedMutableBigInteger.java
-ojluni/src/main/java/java/math/package-info.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/math/package-info.java
+ojluni/src/main/java/java/lang/runtime/ObjectMethods.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/lang/runtime/ObjectMethods.java
+ojluni/src/main/java/java/lang/runtime/SwitchBootstraps.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/lang/runtime/SwitchBootstraps.java
+ojluni/src/main/java/java/math/BigDecimal.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/math/BigDecimal.java
+ojluni/src/main/java/java/math/BigInteger.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/math/BigInteger.java
+ojluni/src/main/java/java/math/BitSieve.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/math/BitSieve.java
+ojluni/src/main/java/java/math/MathContext.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/math/MathContext.java
+ojluni/src/main/java/java/math/MutableBigInteger.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/math/MutableBigInteger.java
+ojluni/src/main/java/java/math/RoundingMode.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/math/RoundingMode.java
+ojluni/src/main/java/java/math/SignedMutableBigInteger.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/math/SignedMutableBigInteger.java
+ojluni/src/main/java/java/math/package-info.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/math/package-info.java
 ojluni/src/main/java/java/net/AbstractPlainDatagramSocketImpl.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/net/AbstractPlainDatagramSocketImpl.java
 ojluni/src/main/java/java/net/AbstractPlainSocketImpl.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/net/AbstractPlainSocketImpl.java
 ojluni/src/main/java/java/net/Authenticator.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/net/Authenticator.java
-ojluni/src/main/java/java/net/BindException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/BindException.java
-ojluni/src/main/java/java/net/CacheRequest.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/CacheRequest.java
-ojluni/src/main/java/java/net/CacheResponse.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/CacheResponse.java
-ojluni/src/main/java/java/net/ConnectException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/ConnectException.java
+ojluni/src/main/java/java/net/BindException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/BindException.java
+ojluni/src/main/java/java/net/CacheRequest.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/CacheRequest.java
+ojluni/src/main/java/java/net/CacheResponse.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/CacheResponse.java
+ojluni/src/main/java/java/net/ConnectException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/ConnectException.java
 ojluni/src/main/java/java/net/ContentHandler.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/net/ContentHandler.java
-ojluni/src/main/java/java/net/ContentHandlerFactory.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/net/ContentHandlerFactory.java
-ojluni/src/main/java/java/net/CookieHandler.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/CookieHandler.java
-ojluni/src/main/java/java/net/CookieManager.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/CookieManager.java
-ojluni/src/main/java/java/net/CookiePolicy.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/net/CookiePolicy.java
-ojluni/src/main/java/java/net/CookieStore.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/net/CookieStore.java
-ojluni/src/main/java/java/net/DatagramPacket.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/DatagramPacket.java
-ojluni/src/main/java/java/net/DatagramSocket.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/DatagramSocket.java
-ojluni/src/main/java/java/net/DatagramSocketImpl.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/DatagramSocketImpl.java
-ojluni/src/main/java/java/net/DatagramSocketImplFactory.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/DatagramSocketImplFactory.java
+ojluni/src/main/java/java/net/ContentHandlerFactory.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/net/ContentHandlerFactory.java
+ojluni/src/main/java/java/net/CookieHandler.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/CookieHandler.java
+ojluni/src/main/java/java/net/CookieManager.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/CookieManager.java
+ojluni/src/main/java/java/net/CookiePolicy.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/net/CookiePolicy.java
+ojluni/src/main/java/java/net/CookieStore.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/net/CookieStore.java
+ojluni/src/main/java/java/net/DatagramPacket.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/DatagramPacket.java
+ojluni/src/main/java/java/net/DatagramSocket.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/DatagramSocket.java
+ojluni/src/main/java/java/net/DatagramSocketImpl.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/DatagramSocketImpl.java
+ojluni/src/main/java/java/net/DatagramSocketImplFactory.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/DatagramSocketImplFactory.java
 ojluni/src/main/java/java/net/DefaultDatagramSocketImplFactory.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/java/net/DefaultDatagramSocketImplFactory.java
-ojluni/src/main/java/java/net/DefaultInterface.java,jdk21u/jdk-21.0.4-ga,src/java.base/unix/classes/java/net/DefaultInterface.java
-ojluni/src/main/java/java/net/FileNameMap.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/net/FileNameMap.java
+ojluni/src/main/java/java/net/DefaultInterface.java,jdk21u/jdk-21.0.6-ga,src/java.base/unix/classes/java/net/DefaultInterface.java
+ojluni/src/main/java/java/net/FileNameMap.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/net/FileNameMap.java
 ojluni/src/main/java/java/net/HttpCookie.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/net/HttpCookie.java
-ojluni/src/main/java/java/net/HttpRetryException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/HttpRetryException.java
+ojluni/src/main/java/java/net/HttpRetryException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/HttpRetryException.java
 ojluni/src/main/java/java/net/HttpURLConnection.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/net/HttpURLConnection.java
 ojluni/src/main/java/java/net/IDN.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/net/IDN.java
-ojluni/src/main/java/java/net/InMemoryCookieStore.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/InMemoryCookieStore.java
-ojluni/src/main/java/java/net/Inet4Address.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/Inet4Address.java
+ojluni/src/main/java/java/net/InMemoryCookieStore.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/InMemoryCookieStore.java
+ojluni/src/main/java/java/net/Inet4Address.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/Inet4Address.java
 ojluni/src/main/java/java/net/Inet6Address.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/net/Inet6Address.java
 ojluni/src/main/java/java/net/Inet6AddressImpl.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/net/Inet6AddressImpl.java
 ojluni/src/main/java/java/net/InetAddress.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/net/InetAddress.java
-ojluni/src/main/java/java/net/InetAddressContainer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/net/InetAddressContainer.java
-ojluni/src/main/java/java/net/InetAddressImpl.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/net/InetAddressImpl.java
-ojluni/src/main/java/java/net/InetSocketAddress.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/net/InetSocketAddress.java
-ojluni/src/main/java/java/net/InterfaceAddress.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/InterfaceAddress.java
-ojluni/src/main/java/java/net/JarURLConnection.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/JarURLConnection.java
-ojluni/src/main/java/java/net/MalformedURLException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/MalformedURLException.java
-ojluni/src/main/java/java/net/MulticastSocket.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/MulticastSocket.java
-ojluni/src/main/java/java/net/NetPermission.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/NetPermission.java
+ojluni/src/main/java/java/net/InetAddressContainer.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/net/InetAddressContainer.java
+ojluni/src/main/java/java/net/InetAddressImpl.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/net/InetAddressImpl.java
+ojluni/src/main/java/java/net/InetSocketAddress.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/net/InetSocketAddress.java
+ojluni/src/main/java/java/net/InterfaceAddress.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/InterfaceAddress.java
+ojluni/src/main/java/java/net/JarURLConnection.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/JarURLConnection.java
+ojluni/src/main/java/java/net/MalformedURLException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/MalformedURLException.java
+ojluni/src/main/java/java/net/MulticastSocket.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/MulticastSocket.java
+ojluni/src/main/java/java/net/NetPermission.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/NetPermission.java
 ojluni/src/main/java/java/net/NetworkInterface.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/net/NetworkInterface.java
-ojluni/src/main/java/java/net/NoRouteToHostException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/NoRouteToHostException.java
-ojluni/src/main/java/java/net/PasswordAuthentication.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/net/PasswordAuthentication.java
+ojluni/src/main/java/java/net/NoRouteToHostException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/NoRouteToHostException.java
+ojluni/src/main/java/java/net/PasswordAuthentication.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/net/PasswordAuthentication.java
 ojluni/src/main/java/java/net/PlainDatagramSocketImpl.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/java/net/PlainDatagramSocketImpl.java
 ojluni/src/main/java/java/net/PlainSocketImpl.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/java/net/PlainSocketImpl.java
-ojluni/src/main/java/java/net/PortUnreachableException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/PortUnreachableException.java
-ojluni/src/main/java/java/net/ProtocolException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/ProtocolException.java
-ojluni/src/main/java/java/net/ProtocolFamily.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/net/ProtocolFamily.java
-ojluni/src/main/java/java/net/Proxy.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/Proxy.java
+ojluni/src/main/java/java/net/PortUnreachableException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/PortUnreachableException.java
+ojluni/src/main/java/java/net/ProtocolException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/ProtocolException.java
+ojluni/src/main/java/java/net/ProtocolFamily.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/net/ProtocolFamily.java
+ojluni/src/main/java/java/net/Proxy.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/Proxy.java
 ojluni/src/main/java/java/net/ProxySelector.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/net/ProxySelector.java
-ojluni/src/main/java/java/net/ResponseCache.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/ResponseCache.java
-ojluni/src/main/java/java/net/SecureCacheResponse.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/SecureCacheResponse.java
-ojluni/src/main/java/java/net/ServerSocket.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/ServerSocket.java
-ojluni/src/main/java/java/net/Socket.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/Socket.java
-ojluni/src/main/java/java/net/SocketAddress.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/net/SocketAddress.java
-ojluni/src/main/java/java/net/SocketException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/SocketException.java
-ojluni/src/main/java/java/net/SocketImpl.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/SocketImpl.java
-ojluni/src/main/java/java/net/SocketImplFactory.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/SocketImplFactory.java
-ojluni/src/main/java/java/net/SocketInputStream.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/SocketInputStream.java
-ojluni/src/main/java/java/net/SocketOption.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/net/SocketOption.java
-ojluni/src/main/java/java/net/SocketOptions.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/SocketOptions.java
-ojluni/src/main/java/java/net/SocketOutputStream.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/SocketOutputStream.java
-ojluni/src/main/java/java/net/SocketPermission.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/SocketPermission.java
+ojluni/src/main/java/java/net/ResponseCache.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/ResponseCache.java
+ojluni/src/main/java/java/net/SecureCacheResponse.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/SecureCacheResponse.java
+ojluni/src/main/java/java/net/ServerSocket.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/ServerSocket.java
+ojluni/src/main/java/java/net/Socket.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/Socket.java
+ojluni/src/main/java/java/net/SocketAddress.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/net/SocketAddress.java
+ojluni/src/main/java/java/net/SocketException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/SocketException.java
+ojluni/src/main/java/java/net/SocketImpl.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/SocketImpl.java
+ojluni/src/main/java/java/net/SocketImplFactory.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/SocketImplFactory.java
+ojluni/src/main/java/java/net/SocketInputStream.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/SocketInputStream.java
+ojluni/src/main/java/java/net/SocketOption.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/net/SocketOption.java
+ojluni/src/main/java/java/net/SocketOptions.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/SocketOptions.java
+ojluni/src/main/java/java/net/SocketOutputStream.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/SocketOutputStream.java
+ojluni/src/main/java/java/net/SocketPermission.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/SocketPermission.java
 ojluni/src/main/java/java/net/SocketSecrets.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/net/SocketSecrets.java
-ojluni/src/main/java/java/net/SocketTimeoutException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/SocketTimeoutException.java
-ojluni/src/main/java/java/net/SocksConsts.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/net/SocksConsts.java
+ojluni/src/main/java/java/net/SocketTimeoutException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/SocketTimeoutException.java
+ojluni/src/main/java/java/net/SocksConsts.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/net/SocksConsts.java
 ojluni/src/main/java/java/net/SocksSocketImpl.java,jdk8u/jdk8u222-b03,jdk/src/share/classes/java/net/SocksSocketImpl.java
-ojluni/src/main/java/java/net/StandardProtocolFamily.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/net/StandardProtocolFamily.java
-ojluni/src/main/java/java/net/StandardSocketOptions.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/StandardSocketOptions.java
+ojluni/src/main/java/java/net/StandardProtocolFamily.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/net/StandardProtocolFamily.java
+ojluni/src/main/java/java/net/StandardSocketOptions.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/StandardSocketOptions.java
 ojluni/src/main/java/java/net/URI.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/net/URI.java
-ojluni/src/main/java/java/net/URISyntaxException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/URISyntaxException.java
+ojluni/src/main/java/java/net/URISyntaxException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/URISyntaxException.java
 ojluni/src/main/java/java/net/URL.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/net/URL.java
 ojluni/src/main/java/java/net/URLClassLoader.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/net/URLClassLoader.java
 ojluni/src/main/java/java/net/URLConnection.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/net/URLConnection.java
-ojluni/src/main/java/java/net/URLDecoder.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/URLDecoder.java
-ojluni/src/main/java/java/net/URLEncoder.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/URLEncoder.java
+ojluni/src/main/java/java/net/URLDecoder.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/URLDecoder.java
+ojluni/src/main/java/java/net/URLEncoder.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/URLEncoder.java
 ojluni/src/main/java/java/net/URLStreamHandler.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/net/URLStreamHandler.java
-ojluni/src/main/java/java/net/URLStreamHandlerFactory.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/net/URLStreamHandlerFactory.java
-ojluni/src/main/java/java/net/UnixDomainSocketAddress.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/net/UnixDomainSocketAddress.java
-ojluni/src/main/java/java/net/UnknownHostException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/UnknownHostException.java
-ojluni/src/main/java/java/net/UnknownServiceException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/net/UnknownServiceException.java
+ojluni/src/main/java/java/net/URLStreamHandlerFactory.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/net/URLStreamHandlerFactory.java
+ojluni/src/main/java/java/net/UnixDomainSocketAddress.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/net/UnixDomainSocketAddress.java
+ojluni/src/main/java/java/net/UnknownHostException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/UnknownHostException.java
+ojluni/src/main/java/java/net/UnknownServiceException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/net/UnknownServiceException.java
 ojluni/src/main/java/java/net/package-info.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/net/package-info.java
 # Some java.nio Buffer and Exception classes are generated from templates, and thus has no direct mapping to an upstream file.
-ojluni/src/main/java/java/nio/Bits.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/Bits.java
-ojluni/src/main/java/java/nio/Buffer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/Buffer.java
-ojluni/src/main/java/java/nio/ByteBufferAs-X-Buffer.java.template,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/ByteBufferAs-X-Buffer.java.template
-ojluni/src/main/java/java/nio/ByteOrder.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/ByteOrder.java
-ojluni/src/main/java/java/nio/CharBufferSpliterator.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/CharBufferSpliterator.java
-ojluni/src/main/java/java/nio/Direct-X-Buffer-bin.java.template,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/Direct-X-Buffer-bin.java.template
-ojluni/src/main/java/java/nio/Direct-X-Buffer.java.template,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/Direct-X-Buffer.java.template
-ojluni/src/main/java/java/nio/Heap-X-Buffer.java.template,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/Heap-X-Buffer.java.template
-ojluni/src/main/java/java/nio/MappedByteBuffer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/MappedByteBuffer.java
-ojluni/src/main/java/java/nio/StringCharBuffer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/StringCharBuffer.java
-ojluni/src/main/java/java/nio/X-Buffer-bin.java.template,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/X-Buffer-bin.java.template
-ojluni/src/main/java/java/nio/X-Buffer.java.template,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/X-Buffer.java.template
-ojluni/src/main/java/java/nio/channels/AsynchronousByteChannel.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/channels/AsynchronousByteChannel.java
-ojluni/src/main/java/java/nio/channels/AsynchronousChannel.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/channels/AsynchronousChannel.java
-ojluni/src/main/java/java/nio/channels/AsynchronousChannelGroup.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/channels/AsynchronousChannelGroup.java
-ojluni/src/main/java/java/nio/channels/AsynchronousFileChannel.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/channels/AsynchronousFileChannel.java
-ojluni/src/main/java/java/nio/channels/AsynchronousServerSocketChannel.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/channels/AsynchronousServerSocketChannel.java
-ojluni/src/main/java/java/nio/channels/AsynchronousSocketChannel.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/channels/AsynchronousSocketChannel.java
-ojluni/src/main/java/java/nio/channels/ByteChannel.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/channels/ByteChannel.java
-ojluni/src/main/java/java/nio/channels/Channel.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/channels/Channel.java
-ojluni/src/main/java/java/nio/channels/Channels.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/channels/Channels.java
-ojluni/src/main/java/java/nio/channels/CompletionHandler.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/channels/CompletionHandler.java
-ojluni/src/main/java/java/nio/channels/DatagramChannel.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/channels/DatagramChannel.java
-ojluni/src/main/java/java/nio/channels/FileChannel.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/channels/FileChannel.java
-ojluni/src/main/java/java/nio/channels/FileLock.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/channels/FileLock.java
-ojluni/src/main/java/java/nio/channels/GatheringByteChannel.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/channels/GatheringByteChannel.java
-ojluni/src/main/java/java/nio/channels/InterruptibleChannel.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/channels/InterruptibleChannel.java
-ojluni/src/main/java/java/nio/channels/MembershipKey.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/channels/MembershipKey.java
-ojluni/src/main/java/java/nio/channels/MulticastChannel.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/channels/MulticastChannel.java
-ojluni/src/main/java/java/nio/channels/NetworkChannel.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/channels/NetworkChannel.java
-ojluni/src/main/java/java/nio/channels/Pipe.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/channels/Pipe.java
-ojluni/src/main/java/java/nio/channels/ReadableByteChannel.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/channels/ReadableByteChannel.java
-ojluni/src/main/java/java/nio/channels/ScatteringByteChannel.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/channels/ScatteringByteChannel.java
-ojluni/src/main/java/java/nio/channels/SeekableByteChannel.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/channels/SeekableByteChannel.java
-ojluni/src/main/java/java/nio/channels/SelectableChannel.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/channels/SelectableChannel.java
-ojluni/src/main/java/java/nio/channels/SelectionKey.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/channels/SelectionKey.java
-ojluni/src/main/java/java/nio/channels/Selector.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/channels/Selector.java
-ojluni/src/main/java/java/nio/channels/ServerSocketChannel.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/channels/ServerSocketChannel.java
-ojluni/src/main/java/java/nio/channels/SocketChannel.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/channels/SocketChannel.java
-ojluni/src/main/java/java/nio/channels/WritableByteChannel.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/channels/WritableByteChannel.java
-ojluni/src/main/java/java/nio/channels/package-info.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/channels/package-info.java
-ojluni/src/main/java/java/nio/channels/spi/AbstractInterruptibleChannel.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/channels/spi/AbstractInterruptibleChannel.java
-ojluni/src/main/java/java/nio/channels/spi/AbstractSelectableChannel.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/channels/spi/AbstractSelectableChannel.java
-ojluni/src/main/java/java/nio/channels/spi/AbstractSelectionKey.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/channels/spi/AbstractSelectionKey.java
-ojluni/src/main/java/java/nio/channels/spi/AbstractSelector.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/channels/spi/AbstractSelector.java
-ojluni/src/main/java/java/nio/channels/spi/AsynchronousChannelProvider.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/channels/spi/AsynchronousChannelProvider.java
-ojluni/src/main/java/java/nio/channels/spi/SelectorProvider.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/channels/spi/SelectorProvider.java
-ojluni/src/main/java/java/nio/channels/spi/package-info.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/channels/spi/package-info.java
-ojluni/src/main/java/java/nio/charset/Charset-X-Coder.java.template,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/charset/Charset-X-Coder.java.template
-ojluni/src/main/java/java/nio/charset/Charset.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/charset/Charset.java
-ojluni/src/main/java/java/nio/charset/CoderMalfunctionError.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/charset/CoderMalfunctionError.java
-ojluni/src/main/java/java/nio/charset/CoderResult.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/charset/CoderResult.java
-ojluni/src/main/java/java/nio/charset/CodingErrorAction.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/charset/CodingErrorAction.java
-ojluni/src/main/java/java/nio/charset/MalformedInputException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/charset/MalformedInputException.java
-ojluni/src/main/java/java/nio/charset/StandardCharsets.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/charset/StandardCharsets.java
-ojluni/src/main/java/java/nio/charset/UnmappableCharacterException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/charset/UnmappableCharacterException.java
-ojluni/src/main/java/java/nio/charset/exceptions,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/charset/exceptions
-ojluni/src/main/java/java/nio/charset/package-info.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/charset/package-info.java
-ojluni/src/main/java/java/nio/charset/spi/CharsetProvider.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/charset/spi/CharsetProvider.java
-ojluni/src/main/java/java/nio/charset/spi/package-info.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/charset/spi/package-info.java
-ojluni/src/main/java/java/nio/file/AccessDeniedException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/AccessDeniedException.java
-ojluni/src/main/java/java/nio/file/AccessMode.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/AccessMode.java
-ojluni/src/main/java/java/nio/file/AtomicMoveNotSupportedException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/AtomicMoveNotSupportedException.java
-ojluni/src/main/java/java/nio/file/ClosedDirectoryStreamException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/ClosedDirectoryStreamException.java
-ojluni/src/main/java/java/nio/file/ClosedFileSystemException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/ClosedFileSystemException.java
-ojluni/src/main/java/java/nio/file/ClosedWatchServiceException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/ClosedWatchServiceException.java
-ojluni/src/main/java/java/nio/file/CopyMoveHelper.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/file/CopyMoveHelper.java
-ojluni/src/main/java/java/nio/file/CopyOption.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/CopyOption.java
-ojluni/src/main/java/java/nio/file/DirectoryIteratorException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/DirectoryIteratorException.java
-ojluni/src/main/java/java/nio/file/DirectoryNotEmptyException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/DirectoryNotEmptyException.java
-ojluni/src/main/java/java/nio/file/DirectoryStream.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/DirectoryStream.java
-ojluni/src/main/java/java/nio/file/FileAlreadyExistsException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/FileAlreadyExistsException.java
-ojluni/src/main/java/java/nio/file/FileStore.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/nio/file/FileStore.java
-ojluni/src/main/java/java/nio/file/FileSystem.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/file/FileSystem.java
-ojluni/src/main/java/java/nio/file/FileSystemAlreadyExistsException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/FileSystemAlreadyExistsException.java
-ojluni/src/main/java/java/nio/file/FileSystemException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/FileSystemException.java
-ojluni/src/main/java/java/nio/file/FileSystemLoopException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/FileSystemLoopException.java
-ojluni/src/main/java/java/nio/file/FileSystemNotFoundException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/FileSystemNotFoundException.java
-ojluni/src/main/java/java/nio/file/FileSystems.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/nio/file/FileSystems.java
-ojluni/src/main/java/java/nio/file/FileTreeIterator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/file/FileTreeIterator.java
-ojluni/src/main/java/java/nio/file/FileTreeWalker.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/FileTreeWalker.java
-ojluni/src/main/java/java/nio/file/FileVisitOption.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/FileVisitOption.java
-ojluni/src/main/java/java/nio/file/FileVisitResult.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/FileVisitResult.java
-ojluni/src/main/java/java/nio/file/FileVisitor.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/file/FileVisitor.java
-ojluni/src/main/java/java/nio/file/Files.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/nio/file/Files.java
-ojluni/src/main/java/java/nio/file/InvalidPathException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/InvalidPathException.java
-ojluni/src/main/java/java/nio/file/LinkOption.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/LinkOption.java
-ojluni/src/main/java/java/nio/file/LinkPermission.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/LinkPermission.java
-ojluni/src/main/java/java/nio/file/NoSuchFileException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/NoSuchFileException.java
-ojluni/src/main/java/java/nio/file/NotDirectoryException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/NotDirectoryException.java
-ojluni/src/main/java/java/nio/file/NotLinkException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/NotLinkException.java
-ojluni/src/main/java/java/nio/file/OpenOption.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/OpenOption.java
-ojluni/src/main/java/java/nio/file/Path.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/nio/file/Path.java
-ojluni/src/main/java/java/nio/file/PathMatcher.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/PathMatcher.java
-ojluni/src/main/java/java/nio/file/Paths.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/nio/file/Paths.java
-ojluni/src/main/java/java/nio/file/ProviderMismatchException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/ProviderMismatchException.java
-ojluni/src/main/java/java/nio/file/ProviderNotFoundException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/ProviderNotFoundException.java
-ojluni/src/main/java/java/nio/file/ReadOnlyFileSystemException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/ReadOnlyFileSystemException.java
-ojluni/src/main/java/java/nio/file/SecureDirectoryStream.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/file/SecureDirectoryStream.java
-ojluni/src/main/java/java/nio/file/SimpleFileVisitor.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/SimpleFileVisitor.java
-ojluni/src/main/java/java/nio/file/StandardCopyOption.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/StandardCopyOption.java
-ojluni/src/main/java/java/nio/file/StandardOpenOption.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/StandardOpenOption.java
-ojluni/src/main/java/java/nio/file/StandardWatchEventKinds.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/StandardWatchEventKinds.java
+ojluni/src/main/java/java/nio/Bits.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/Bits.java
+ojluni/src/main/java/java/nio/Buffer.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/Buffer.java
+ojluni/src/main/java/java/nio/ByteBufferAs-X-Buffer.java.template,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/ByteBufferAs-X-Buffer.java.template
+ojluni/src/main/java/java/nio/ByteOrder.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/ByteOrder.java
+ojluni/src/main/java/java/nio/CharBufferSpliterator.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/CharBufferSpliterator.java
+ojluni/src/main/java/java/nio/Direct-X-Buffer-bin.java.template,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/Direct-X-Buffer-bin.java.template
+ojluni/src/main/java/java/nio/Direct-X-Buffer.java.template,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/Direct-X-Buffer.java.template
+ojluni/src/main/java/java/nio/Heap-X-Buffer.java.template,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/Heap-X-Buffer.java.template
+ojluni/src/main/java/java/nio/MappedByteBuffer.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/MappedByteBuffer.java
+ojluni/src/main/java/java/nio/StringCharBuffer.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/StringCharBuffer.java
+ojluni/src/main/java/java/nio/X-Buffer-bin.java.template,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/X-Buffer-bin.java.template
+ojluni/src/main/java/java/nio/X-Buffer.java.template,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/X-Buffer.java.template
+ojluni/src/main/java/java/nio/channels/AsynchronousByteChannel.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/channels/AsynchronousByteChannel.java
+ojluni/src/main/java/java/nio/channels/AsynchronousChannel.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/channels/AsynchronousChannel.java
+ojluni/src/main/java/java/nio/channels/AsynchronousChannelGroup.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/channels/AsynchronousChannelGroup.java
+ojluni/src/main/java/java/nio/channels/AsynchronousFileChannel.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/channels/AsynchronousFileChannel.java
+ojluni/src/main/java/java/nio/channels/AsynchronousServerSocketChannel.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/channels/AsynchronousServerSocketChannel.java
+ojluni/src/main/java/java/nio/channels/AsynchronousSocketChannel.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/channels/AsynchronousSocketChannel.java
+ojluni/src/main/java/java/nio/channels/ByteChannel.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/channels/ByteChannel.java
+ojluni/src/main/java/java/nio/channels/Channel.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/channels/Channel.java
+ojluni/src/main/java/java/nio/channels/Channels.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/channels/Channels.java
+ojluni/src/main/java/java/nio/channels/CompletionHandler.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/channels/CompletionHandler.java
+ojluni/src/main/java/java/nio/channels/DatagramChannel.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/channels/DatagramChannel.java
+ojluni/src/main/java/java/nio/channels/FileChannel.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/channels/FileChannel.java
+ojluni/src/main/java/java/nio/channels/FileLock.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/channels/FileLock.java
+ojluni/src/main/java/java/nio/channels/GatheringByteChannel.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/channels/GatheringByteChannel.java
+ojluni/src/main/java/java/nio/channels/InterruptibleChannel.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/channels/InterruptibleChannel.java
+ojluni/src/main/java/java/nio/channels/MembershipKey.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/channels/MembershipKey.java
+ojluni/src/main/java/java/nio/channels/MulticastChannel.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/channels/MulticastChannel.java
+ojluni/src/main/java/java/nio/channels/NetworkChannel.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/channels/NetworkChannel.java
+ojluni/src/main/java/java/nio/channels/Pipe.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/channels/Pipe.java
+ojluni/src/main/java/java/nio/channels/ReadableByteChannel.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/channels/ReadableByteChannel.java
+ojluni/src/main/java/java/nio/channels/ScatteringByteChannel.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/channels/ScatteringByteChannel.java
+ojluni/src/main/java/java/nio/channels/SeekableByteChannel.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/channels/SeekableByteChannel.java
+ojluni/src/main/java/java/nio/channels/SelectableChannel.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/channels/SelectableChannel.java
+ojluni/src/main/java/java/nio/channels/SelectionKey.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/channels/SelectionKey.java
+ojluni/src/main/java/java/nio/channels/Selector.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/channels/Selector.java
+ojluni/src/main/java/java/nio/channels/ServerSocketChannel.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/channels/ServerSocketChannel.java
+ojluni/src/main/java/java/nio/channels/SocketChannel.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/channels/SocketChannel.java
+ojluni/src/main/java/java/nio/channels/WritableByteChannel.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/channels/WritableByteChannel.java
+ojluni/src/main/java/java/nio/channels/package-info.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/channels/package-info.java
+ojluni/src/main/java/java/nio/channels/spi/AbstractInterruptibleChannel.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/channels/spi/AbstractInterruptibleChannel.java
+ojluni/src/main/java/java/nio/channels/spi/AbstractSelectableChannel.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/channels/spi/AbstractSelectableChannel.java
+ojluni/src/main/java/java/nio/channels/spi/AbstractSelectionKey.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/channels/spi/AbstractSelectionKey.java
+ojluni/src/main/java/java/nio/channels/spi/AbstractSelector.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/channels/spi/AbstractSelector.java
+ojluni/src/main/java/java/nio/channels/spi/AsynchronousChannelProvider.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/channels/spi/AsynchronousChannelProvider.java
+ojluni/src/main/java/java/nio/channels/spi/SelectorProvider.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/channels/spi/SelectorProvider.java
+ojluni/src/main/java/java/nio/channels/spi/package-info.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/channels/spi/package-info.java
+ojluni/src/main/java/java/nio/charset/Charset-X-Coder.java.template,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/charset/Charset-X-Coder.java.template
+ojluni/src/main/java/java/nio/charset/Charset.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/charset/Charset.java
+ojluni/src/main/java/java/nio/charset/CoderMalfunctionError.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/charset/CoderMalfunctionError.java
+ojluni/src/main/java/java/nio/charset/CoderResult.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/charset/CoderResult.java
+ojluni/src/main/java/java/nio/charset/CodingErrorAction.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/charset/CodingErrorAction.java
+ojluni/src/main/java/java/nio/charset/MalformedInputException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/charset/MalformedInputException.java
+ojluni/src/main/java/java/nio/charset/StandardCharsets.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/charset/StandardCharsets.java
+ojluni/src/main/java/java/nio/charset/UnmappableCharacterException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/charset/UnmappableCharacterException.java
+ojluni/src/main/java/java/nio/charset/exceptions,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/charset/exceptions
+ojluni/src/main/java/java/nio/charset/package-info.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/charset/package-info.java
+ojluni/src/main/java/java/nio/charset/spi/CharsetProvider.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/charset/spi/CharsetProvider.java
+ojluni/src/main/java/java/nio/charset/spi/package-info.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/charset/spi/package-info.java
+ojluni/src/main/java/java/nio/file/AccessDeniedException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/AccessDeniedException.java
+ojluni/src/main/java/java/nio/file/AccessMode.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/AccessMode.java
+ojluni/src/main/java/java/nio/file/AtomicMoveNotSupportedException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/AtomicMoveNotSupportedException.java
+ojluni/src/main/java/java/nio/file/ClosedDirectoryStreamException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/ClosedDirectoryStreamException.java
+ojluni/src/main/java/java/nio/file/ClosedFileSystemException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/ClosedFileSystemException.java
+ojluni/src/main/java/java/nio/file/ClosedWatchServiceException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/ClosedWatchServiceException.java
+ojluni/src/main/java/java/nio/file/CopyMoveHelper.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/file/CopyMoveHelper.java
+ojluni/src/main/java/java/nio/file/CopyOption.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/CopyOption.java
+ojluni/src/main/java/java/nio/file/DirectoryIteratorException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/DirectoryIteratorException.java
+ojluni/src/main/java/java/nio/file/DirectoryNotEmptyException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/DirectoryNotEmptyException.java
+ojluni/src/main/java/java/nio/file/DirectoryStream.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/DirectoryStream.java
+ojluni/src/main/java/java/nio/file/FileAlreadyExistsException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/FileAlreadyExistsException.java
+ojluni/src/main/java/java/nio/file/FileChannelLinesSpliterator.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/FileChannelLinesSpliterator.java
+ojluni/src/main/java/java/nio/file/FileStore.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/FileStore.java
+ojluni/src/main/java/java/nio/file/FileSystem.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/file/FileSystem.java
+ojluni/src/main/java/java/nio/file/FileSystemAlreadyExistsException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/FileSystemAlreadyExistsException.java
+ojluni/src/main/java/java/nio/file/FileSystemException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/FileSystemException.java
+ojluni/src/main/java/java/nio/file/FileSystemLoopException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/FileSystemLoopException.java
+ojluni/src/main/java/java/nio/file/FileSystemNotFoundException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/FileSystemNotFoundException.java
+ojluni/src/main/java/java/nio/file/FileSystems.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/FileSystems.java
+ojluni/src/main/java/java/nio/file/FileTreeIterator.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/file/FileTreeIterator.java
+ojluni/src/main/java/java/nio/file/FileTreeWalker.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/FileTreeWalker.java
+ojluni/src/main/java/java/nio/file/FileVisitOption.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/FileVisitOption.java
+ojluni/src/main/java/java/nio/file/FileVisitResult.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/FileVisitResult.java
+ojluni/src/main/java/java/nio/file/FileVisitor.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/file/FileVisitor.java
+ojluni/src/main/java/java/nio/file/Files.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/Files.java
+ojluni/src/main/java/java/nio/file/InvalidPathException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/InvalidPathException.java
+ojluni/src/main/java/java/nio/file/LinkOption.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/LinkOption.java
+ojluni/src/main/java/java/nio/file/LinkPermission.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/LinkPermission.java
+ojluni/src/main/java/java/nio/file/NoSuchFileException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/NoSuchFileException.java
+ojluni/src/main/java/java/nio/file/NotDirectoryException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/NotDirectoryException.java
+ojluni/src/main/java/java/nio/file/NotLinkException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/NotLinkException.java
+ojluni/src/main/java/java/nio/file/OpenOption.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/OpenOption.java
+ojluni/src/main/java/java/nio/file/Path.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/Path.java
+ojluni/src/main/java/java/nio/file/PathMatcher.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/PathMatcher.java
+ojluni/src/main/java/java/nio/file/Paths.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/Paths.java
+ojluni/src/main/java/java/nio/file/ProviderMismatchException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/ProviderMismatchException.java
+ojluni/src/main/java/java/nio/file/ProviderNotFoundException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/ProviderNotFoundException.java
+ojluni/src/main/java/java/nio/file/ReadOnlyFileSystemException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/ReadOnlyFileSystemException.java
+ojluni/src/main/java/java/nio/file/SecureDirectoryStream.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/file/SecureDirectoryStream.java
+ojluni/src/main/java/java/nio/file/SimpleFileVisitor.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/SimpleFileVisitor.java
+ojluni/src/main/java/java/nio/file/StandardCopyOption.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/StandardCopyOption.java
+ojluni/src/main/java/java/nio/file/StandardOpenOption.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/StandardOpenOption.java
+ojluni/src/main/java/java/nio/file/StandardWatchEventKinds.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/StandardWatchEventKinds.java
 ojluni/src/main/java/java/nio/file/TempFileHelper.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/nio/file/TempFileHelper.java
-ojluni/src/main/java/java/nio/file/WatchEvent.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/file/WatchEvent.java
-ojluni/src/main/java/java/nio/file/WatchKey.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/file/WatchKey.java
-ojluni/src/main/java/java/nio/file/WatchService.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/file/WatchService.java
-ojluni/src/main/java/java/nio/file/Watchable.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/file/Watchable.java
-ojluni/src/main/java/java/nio/file/attribute/AclEntry.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/attribute/AclEntry.java
-ojluni/src/main/java/java/nio/file/attribute/AclEntryFlag.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/attribute/AclEntryFlag.java
-ojluni/src/main/java/java/nio/file/attribute/AclEntryPermission.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/file/attribute/AclEntryPermission.java
-ojluni/src/main/java/java/nio/file/attribute/AclEntryType.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/attribute/AclEntryType.java
-ojluni/src/main/java/java/nio/file/attribute/AclFileAttributeView.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/file/attribute/AclFileAttributeView.java
-ojluni/src/main/java/java/nio/file/attribute/AttributeView.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/attribute/AttributeView.java
-ojluni/src/main/java/java/nio/file/attribute/BasicFileAttributeView.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/attribute/BasicFileAttributeView.java
-ojluni/src/main/java/java/nio/file/attribute/BasicFileAttributes.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/file/attribute/BasicFileAttributes.java
-ojluni/src/main/java/java/nio/file/attribute/DosFileAttributeView.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/attribute/DosFileAttributeView.java
-ojluni/src/main/java/java/nio/file/attribute/DosFileAttributes.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/file/attribute/DosFileAttributes.java
-ojluni/src/main/java/java/nio/file/attribute/FileAttribute.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/attribute/FileAttribute.java
-ojluni/src/main/java/java/nio/file/attribute/FileAttributeView.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/attribute/FileAttributeView.java
-ojluni/src/main/java/java/nio/file/attribute/FileOwnerAttributeView.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/attribute/FileOwnerAttributeView.java
-ojluni/src/main/java/java/nio/file/attribute/FileStoreAttributeView.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/attribute/FileStoreAttributeView.java
-ojluni/src/main/java/java/nio/file/attribute/FileTime.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/file/attribute/FileTime.java
-ojluni/src/main/java/java/nio/file/attribute/GroupPrincipal.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/attribute/GroupPrincipal.java
-ojluni/src/main/java/java/nio/file/attribute/PosixFileAttributeView.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/attribute/PosixFileAttributeView.java
-ojluni/src/main/java/java/nio/file/attribute/PosixFileAttributes.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/attribute/PosixFileAttributes.java
-ojluni/src/main/java/java/nio/file/attribute/PosixFilePermission.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/attribute/PosixFilePermission.java
-ojluni/src/main/java/java/nio/file/attribute/PosixFilePermissions.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/file/attribute/PosixFilePermissions.java
-ojluni/src/main/java/java/nio/file/attribute/UserDefinedFileAttributeView.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/attribute/UserDefinedFileAttributeView.java
-ojluni/src/main/java/java/nio/file/attribute/UserPrincipal.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/attribute/UserPrincipal.java
-ojluni/src/main/java/java/nio/file/attribute/UserPrincipalLookupService.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/nio/file/attribute/UserPrincipalLookupService.java
-ojluni/src/main/java/java/nio/file/attribute/UserPrincipalNotFoundException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/nio/file/attribute/UserPrincipalNotFoundException.java
-ojluni/src/main/java/java/nio/file/spi/FileSystemProvider.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/nio/file/spi/FileSystemProvider.java
-ojluni/src/main/java/java/nio/file/spi/FileTypeDetector.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/nio/file/spi/FileTypeDetector.java
-ojluni/src/main/java/java/nio/package-info.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/nio/package-info.java
-ojluni/src/main/java/java/security/AccessControlContext.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/AccessControlContext.java
-ojluni/src/main/java/java/security/AccessControlException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/AccessControlException.java
-ojluni/src/main/java/java/security/AccessController.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/AccessController.java
-ojluni/src/main/java/java/security/AlgorithmConstraints.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/security/AlgorithmConstraints.java
-ojluni/src/main/java/java/security/AlgorithmParameterGenerator.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/AlgorithmParameterGenerator.java
-ojluni/src/main/java/java/security/AlgorithmParameterGeneratorSpi.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/AlgorithmParameterGeneratorSpi.java
-ojluni/src/main/java/java/security/AlgorithmParameters.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/AlgorithmParameters.java
-ojluni/src/main/java/java/security/AlgorithmParametersSpi.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/AlgorithmParametersSpi.java
-ojluni/src/main/java/java/security/AllPermission.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/AllPermission.java
+ojluni/src/main/java/java/nio/file/WatchEvent.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/file/WatchEvent.java
+ojluni/src/main/java/java/nio/file/WatchKey.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/file/WatchKey.java
+ojluni/src/main/java/java/nio/file/WatchService.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/file/WatchService.java
+ojluni/src/main/java/java/nio/file/Watchable.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/file/Watchable.java
+ojluni/src/main/java/java/nio/file/attribute/AclEntry.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/attribute/AclEntry.java
+ojluni/src/main/java/java/nio/file/attribute/AclEntryFlag.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/attribute/AclEntryFlag.java
+ojluni/src/main/java/java/nio/file/attribute/AclEntryPermission.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/file/attribute/AclEntryPermission.java
+ojluni/src/main/java/java/nio/file/attribute/AclEntryType.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/attribute/AclEntryType.java
+ojluni/src/main/java/java/nio/file/attribute/AclFileAttributeView.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/file/attribute/AclFileAttributeView.java
+ojluni/src/main/java/java/nio/file/attribute/AttributeView.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/attribute/AttributeView.java
+ojluni/src/main/java/java/nio/file/attribute/BasicFileAttributeView.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/attribute/BasicFileAttributeView.java
+ojluni/src/main/java/java/nio/file/attribute/BasicFileAttributes.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/file/attribute/BasicFileAttributes.java
+ojluni/src/main/java/java/nio/file/attribute/DosFileAttributeView.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/attribute/DosFileAttributeView.java
+ojluni/src/main/java/java/nio/file/attribute/DosFileAttributes.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/file/attribute/DosFileAttributes.java
+ojluni/src/main/java/java/nio/file/attribute/FileAttribute.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/attribute/FileAttribute.java
+ojluni/src/main/java/java/nio/file/attribute/FileAttributeView.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/attribute/FileAttributeView.java
+ojluni/src/main/java/java/nio/file/attribute/FileOwnerAttributeView.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/attribute/FileOwnerAttributeView.java
+ojluni/src/main/java/java/nio/file/attribute/FileStoreAttributeView.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/attribute/FileStoreAttributeView.java
+ojluni/src/main/java/java/nio/file/attribute/FileTime.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/file/attribute/FileTime.java
+ojluni/src/main/java/java/nio/file/attribute/GroupPrincipal.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/attribute/GroupPrincipal.java
+ojluni/src/main/java/java/nio/file/attribute/PosixFileAttributeView.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/attribute/PosixFileAttributeView.java
+ojluni/src/main/java/java/nio/file/attribute/PosixFileAttributes.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/attribute/PosixFileAttributes.java
+ojluni/src/main/java/java/nio/file/attribute/PosixFilePermission.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/attribute/PosixFilePermission.java
+ojluni/src/main/java/java/nio/file/attribute/PosixFilePermissions.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/file/attribute/PosixFilePermissions.java
+ojluni/src/main/java/java/nio/file/attribute/UserDefinedFileAttributeView.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/attribute/UserDefinedFileAttributeView.java
+ojluni/src/main/java/java/nio/file/attribute/UserPrincipal.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/attribute/UserPrincipal.java
+ojluni/src/main/java/java/nio/file/attribute/UserPrincipalLookupService.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/nio/file/attribute/UserPrincipalLookupService.java
+ojluni/src/main/java/java/nio/file/attribute/UserPrincipalNotFoundException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/attribute/UserPrincipalNotFoundException.java
+ojluni/src/main/java/java/nio/file/spi/FileSystemProvider.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/spi/FileSystemProvider.java
+ojluni/src/main/java/java/nio/file/spi/FileTypeDetector.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/nio/file/spi/FileTypeDetector.java
+ojluni/src/main/java/java/nio/package-info.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/nio/package-info.java
+ojluni/src/main/java/java/security/AccessControlContext.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/AccessControlContext.java
+ojluni/src/main/java/java/security/AccessControlException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/AccessControlException.java
+ojluni/src/main/java/java/security/AccessController.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/AccessController.java
+ojluni/src/main/java/java/security/AlgorithmConstraints.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/AlgorithmConstraints.java
+ojluni/src/main/java/java/security/AlgorithmParameterGenerator.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/AlgorithmParameterGenerator.java
+ojluni/src/main/java/java/security/AlgorithmParameterGeneratorSpi.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/AlgorithmParameterGeneratorSpi.java
+ojluni/src/main/java/java/security/AlgorithmParameters.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/AlgorithmParameters.java
+ojluni/src/main/java/java/security/AlgorithmParametersSpi.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/AlgorithmParametersSpi.java
+ojluni/src/main/java/java/security/AllPermission.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/AllPermission.java
 ojluni/src/main/java/java/security/AuthProvider.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/AuthProvider.java
-ojluni/src/main/java/java/security/BasicPermission.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/BasicPermission.java
-ojluni/src/main/java/java/security/Certificate.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/Certificate.java
-ojluni/src/main/java/java/security/CodeSigner.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/CodeSigner.java
-ojluni/src/main/java/java/security/CodeSource.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/CodeSource.java
-ojluni/src/main/java/java/security/CryptoPrimitive.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/CryptoPrimitive.java
-ojluni/src/main/java/java/security/DigestException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/DigestException.java
-ojluni/src/main/java/java/security/DigestInputStream.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/DigestInputStream.java
-ojluni/src/main/java/java/security/DigestOutputStream.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/DigestOutputStream.java
-ojluni/src/main/java/java/security/DomainCombiner.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/DomainCombiner.java
-ojluni/src/main/java/java/security/DomainLoadStoreParameter.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/DomainLoadStoreParameter.java
-ojluni/src/main/java/java/security/DrbgParameters.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/security/DrbgParameters.java
-ojluni/src/main/java/java/security/GeneralSecurityException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/security/GeneralSecurityException.java
-ojluni/src/main/java/java/security/Guard.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/Guard.java
-ojluni/src/main/java/java/security/GuardedObject.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/GuardedObject.java
-ojluni/src/main/java/java/security/Identity.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/Identity.java
-ojluni/src/main/java/java/security/IdentityScope.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/IdentityScope.java
-ojluni/src/main/java/java/security/InvalidAlgorithmParameterException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/security/InvalidAlgorithmParameterException.java
-ojluni/src/main/java/java/security/InvalidKeyException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/InvalidKeyException.java
-ojluni/src/main/java/java/security/InvalidParameterException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/InvalidParameterException.java
-ojluni/src/main/java/java/security/Key.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/security/Key.java
-ojluni/src/main/java/java/security/KeyException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/KeyException.java
-ojluni/src/main/java/java/security/KeyFactory.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/KeyFactory.java
-ojluni/src/main/java/java/security/KeyFactorySpi.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/KeyFactorySpi.java
-ojluni/src/main/java/java/security/KeyManagementException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/KeyManagementException.java
-ojluni/src/main/java/java/security/KeyPair.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/KeyPair.java
-ojluni/src/main/java/java/security/KeyPairGenerator.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/KeyPairGenerator.java
-ojluni/src/main/java/java/security/KeyPairGeneratorSpi.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/KeyPairGeneratorSpi.java
-ojluni/src/main/java/java/security/KeyRep.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/KeyRep.java
-ojluni/src/main/java/java/security/KeyStore.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/KeyStore.java
-ojluni/src/main/java/java/security/KeyStoreException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/KeyStoreException.java
-ojluni/src/main/java/java/security/KeyStoreSpi.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/KeyStoreSpi.java
-ojluni/src/main/java/java/security/MessageDigest.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/MessageDigest.java
-ojluni/src/main/java/java/security/MessageDigestSpi.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/MessageDigestSpi.java
-ojluni/src/main/java/java/security/NoSuchAlgorithmException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/NoSuchAlgorithmException.java
-ojluni/src/main/java/java/security/NoSuchProviderException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/NoSuchProviderException.java
-ojluni/src/main/java/java/security/PKCS12Attribute.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/PKCS12Attribute.java
-ojluni/src/main/java/java/security/Permission.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/Permission.java
-ojluni/src/main/java/java/security/PermissionCollection.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/PermissionCollection.java
-ojluni/src/main/java/java/security/Permissions.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/Permissions.java
-ojluni/src/main/java/java/security/Policy.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/Policy.java
-ojluni/src/main/java/java/security/PolicySpi.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/PolicySpi.java
-ojluni/src/main/java/java/security/Principal.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/security/Principal.java
-ojluni/src/main/java/java/security/PrivateKey.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/security/PrivateKey.java
-ojluni/src/main/java/java/security/PrivilegedAction.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/PrivilegedAction.java
-ojluni/src/main/java/java/security/PrivilegedActionException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/PrivilegedActionException.java
-ojluni/src/main/java/java/security/PrivilegedExceptionAction.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/PrivilegedExceptionAction.java
-ojluni/src/main/java/java/security/ProtectionDomain.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/ProtectionDomain.java
+ojluni/src/main/java/java/security/BasicPermission.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/BasicPermission.java
+ojluni/src/main/java/java/security/Certificate.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/Certificate.java
+ojluni/src/main/java/java/security/CodeSigner.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/CodeSigner.java
+ojluni/src/main/java/java/security/CodeSource.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/CodeSource.java
+ojluni/src/main/java/java/security/CryptoPrimitive.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/CryptoPrimitive.java
+ojluni/src/main/java/java/security/DigestException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/DigestException.java
+ojluni/src/main/java/java/security/DigestInputStream.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/DigestInputStream.java
+ojluni/src/main/java/java/security/DigestOutputStream.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/DigestOutputStream.java
+ojluni/src/main/java/java/security/DomainCombiner.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/DomainCombiner.java
+ojluni/src/main/java/java/security/DomainLoadStoreParameter.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/DomainLoadStoreParameter.java
+ojluni/src/main/java/java/security/DrbgParameters.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/DrbgParameters.java
+ojluni/src/main/java/java/security/GeneralSecurityException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/GeneralSecurityException.java
+ojluni/src/main/java/java/security/Guard.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/Guard.java
+ojluni/src/main/java/java/security/GuardedObject.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/GuardedObject.java
+ojluni/src/main/java/java/security/Identity.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/Identity.java
+ojluni/src/main/java/java/security/IdentityScope.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/IdentityScope.java
+ojluni/src/main/java/java/security/InvalidAlgorithmParameterException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/InvalidAlgorithmParameterException.java
+ojluni/src/main/java/java/security/InvalidKeyException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/InvalidKeyException.java
+ojluni/src/main/java/java/security/InvalidParameterException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/InvalidParameterException.java
+ojluni/src/main/java/java/security/Key.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/Key.java
+ojluni/src/main/java/java/security/KeyException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/KeyException.java
+ojluni/src/main/java/java/security/KeyFactory.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/KeyFactory.java
+ojluni/src/main/java/java/security/KeyFactorySpi.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/KeyFactorySpi.java
+ojluni/src/main/java/java/security/KeyManagementException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/KeyManagementException.java
+ojluni/src/main/java/java/security/KeyPair.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/KeyPair.java
+ojluni/src/main/java/java/security/KeyPairGenerator.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/KeyPairGenerator.java
+ojluni/src/main/java/java/security/KeyPairGeneratorSpi.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/KeyPairGeneratorSpi.java
+ojluni/src/main/java/java/security/KeyRep.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/KeyRep.java
+ojluni/src/main/java/java/security/KeyStore.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/KeyStore.java
+ojluni/src/main/java/java/security/KeyStoreException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/KeyStoreException.java
+ojluni/src/main/java/java/security/KeyStoreSpi.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/KeyStoreSpi.java
+ojluni/src/main/java/java/security/MessageDigest.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/MessageDigest.java
+ojluni/src/main/java/java/security/MessageDigestSpi.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/MessageDigestSpi.java
+ojluni/src/main/java/java/security/NoSuchAlgorithmException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/NoSuchAlgorithmException.java
+ojluni/src/main/java/java/security/NoSuchProviderException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/NoSuchProviderException.java
+ojluni/src/main/java/java/security/PKCS12Attribute.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/PKCS12Attribute.java
+ojluni/src/main/java/java/security/Permission.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/Permission.java
+ojluni/src/main/java/java/security/PermissionCollection.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/PermissionCollection.java
+ojluni/src/main/java/java/security/Permissions.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/Permissions.java
+ojluni/src/main/java/java/security/Policy.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/Policy.java
+ojluni/src/main/java/java/security/PolicySpi.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/PolicySpi.java
+ojluni/src/main/java/java/security/Principal.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/Principal.java
+ojluni/src/main/java/java/security/PrivateKey.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/PrivateKey.java
+ojluni/src/main/java/java/security/PrivilegedAction.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/PrivilegedAction.java
+ojluni/src/main/java/java/security/PrivilegedActionException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/PrivilegedActionException.java
+ojluni/src/main/java/java/security/PrivilegedExceptionAction.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/PrivilegedExceptionAction.java
+ojluni/src/main/java/java/security/ProtectionDomain.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/ProtectionDomain.java
 ojluni/src/main/java/java/security/Provider.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/Provider.java
-ojluni/src/main/java/java/security/ProviderException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/ProviderException.java
-ojluni/src/main/java/java/security/PublicKey.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/security/PublicKey.java
+ojluni/src/main/java/java/security/ProviderException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/ProviderException.java
+ojluni/src/main/java/java/security/PublicKey.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/PublicKey.java
 ojluni/src/main/java/java/security/SecureClassLoader.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/SecureClassLoader.java
-ojluni/src/main/java/java/security/SecureRandom.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/security/SecureRandom.java
-ojluni/src/main/java/java/security/SecureRandomParameters.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/SecureRandomParameters.java
-ojluni/src/main/java/java/security/SecureRandomSpi.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/security/SecureRandomSpi.java
+ojluni/src/main/java/java/security/SecureRandom.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/SecureRandom.java
+ojluni/src/main/java/java/security/SecureRandomParameters.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/SecureRandomParameters.java
+ojluni/src/main/java/java/security/SecureRandomSpi.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/SecureRandomSpi.java
 ojluni/src/main/java/java/security/Security.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/Security.java
-ojluni/src/main/java/java/security/SecurityPermission.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/SecurityPermission.java
+ojluni/src/main/java/java/security/SecurityPermission.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/SecurityPermission.java
 ojluni/src/main/java/java/security/Signature.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/Signature.java
-ojluni/src/main/java/java/security/SignatureException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/SignatureException.java
+ojluni/src/main/java/java/security/SignatureException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/SignatureException.java
 ojluni/src/main/java/java/security/SignatureSpi.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/SignatureSpi.java
-ojluni/src/main/java/java/security/SignedObject.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/SignedObject.java
-ojluni/src/main/java/java/security/Signer.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/Signer.java
-ojluni/src/main/java/java/security/Timestamp.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/Timestamp.java
-ojluni/src/main/java/java/security/UnrecoverableEntryException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/UnrecoverableEntryException.java
-ojluni/src/main/java/java/security/UnrecoverableKeyException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/UnrecoverableKeyException.java
-ojluni/src/main/java/java/security/UnresolvedPermission.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/UnresolvedPermission.java
-ojluni/src/main/java/java/security/UnresolvedPermissionCollection.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/UnresolvedPermissionCollection.java
-ojluni/src/main/java/java/security/acl/Acl.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/acl/Acl.java
-ojluni/src/main/java/java/security/acl/AclEntry.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/acl/AclEntry.java
-ojluni/src/main/java/java/security/acl/AclNotFoundException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/acl/AclNotFoundException.java
-ojluni/src/main/java/java/security/acl/Group.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/acl/Group.java
-ojluni/src/main/java/java/security/acl/LastOwnerException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/acl/LastOwnerException.java
-ojluni/src/main/java/java/security/acl/NotOwnerException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/acl/NotOwnerException.java
-ojluni/src/main/java/java/security/acl/Owner.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/acl/Owner.java
-ojluni/src/main/java/java/security/acl/Permission.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/acl/Permission.java
+ojluni/src/main/java/java/security/SignedObject.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/SignedObject.java
+ojluni/src/main/java/java/security/Signer.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/Signer.java
+ojluni/src/main/java/java/security/Timestamp.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/Timestamp.java
+ojluni/src/main/java/java/security/UnrecoverableEntryException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/UnrecoverableEntryException.java
+ojluni/src/main/java/java/security/UnrecoverableKeyException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/UnrecoverableKeyException.java
+ojluni/src/main/java/java/security/UnresolvedPermission.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/UnresolvedPermission.java
+ojluni/src/main/java/java/security/UnresolvedPermissionCollection.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/UnresolvedPermissionCollection.java
+ojluni/src/main/java/java/security/acl/Acl.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/acl/Acl.java
+ojluni/src/main/java/java/security/acl/AclEntry.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/acl/AclEntry.java
+ojluni/src/main/java/java/security/acl/AclNotFoundException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/acl/AclNotFoundException.java
+ojluni/src/main/java/java/security/acl/Group.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/acl/Group.java
+ojluni/src/main/java/java/security/acl/LastOwnerException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/acl/LastOwnerException.java
+ojluni/src/main/java/java/security/acl/NotOwnerException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/acl/NotOwnerException.java
+ojluni/src/main/java/java/security/acl/Owner.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/acl/Owner.java
+ojluni/src/main/java/java/security/acl/Permission.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/acl/Permission.java
 ojluni/src/main/java/java/security/acl/package-info.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/acl/package-info.java
 ojluni/src/main/java/java/security/cert/CRL.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/CRL.java
 ojluni/src/main/java/java/security/cert/CRLException.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/CRLException.java
 ojluni/src/main/java/java/security/cert/CRLReason.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/CRLReason.java
-ojluni/src/main/java/java/security/cert/CRLSelector.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/cert/CRLSelector.java
+ojluni/src/main/java/java/security/cert/CRLSelector.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/cert/CRLSelector.java
 ojluni/src/main/java/java/security/cert/CertPath.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/CertPath.java
 ojluni/src/main/java/java/security/cert/CertPathBuilder.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/CertPathBuilder.java
-ojluni/src/main/java/java/security/cert/CertPathBuilderException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/cert/CertPathBuilderException.java
-ojluni/src/main/java/java/security/cert/CertPathBuilderResult.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/cert/CertPathBuilderResult.java
-ojluni/src/main/java/java/security/cert/CertPathBuilderSpi.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/cert/CertPathBuilderSpi.java
-ojluni/src/main/java/java/security/cert/CertPathChecker.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/cert/CertPathChecker.java
+ojluni/src/main/java/java/security/cert/CertPathBuilderException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/cert/CertPathBuilderException.java
+ojluni/src/main/java/java/security/cert/CertPathBuilderResult.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/cert/CertPathBuilderResult.java
+ojluni/src/main/java/java/security/cert/CertPathBuilderSpi.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/cert/CertPathBuilderSpi.java
+ojluni/src/main/java/java/security/cert/CertPathChecker.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/cert/CertPathChecker.java
 ojluni/src/main/java/java/security/cert/CertPathHelperImpl.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/CertPathHelperImpl.java
-ojluni/src/main/java/java/security/cert/CertPathParameters.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/cert/CertPathParameters.java
+ojluni/src/main/java/java/security/cert/CertPathParameters.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/cert/CertPathParameters.java
 ojluni/src/main/java/java/security/cert/CertPathValidator.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/CertPathValidator.java
-ojluni/src/main/java/java/security/cert/CertPathValidatorException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/cert/CertPathValidatorException.java
-ojluni/src/main/java/java/security/cert/CertPathValidatorResult.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/cert/CertPathValidatorResult.java
-ojluni/src/main/java/java/security/cert/CertPathValidatorSpi.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/cert/CertPathValidatorSpi.java
-ojluni/src/main/java/java/security/cert/CertSelector.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/cert/CertSelector.java
+ojluni/src/main/java/java/security/cert/CertPathValidatorException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/cert/CertPathValidatorException.java
+ojluni/src/main/java/java/security/cert/CertPathValidatorResult.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/cert/CertPathValidatorResult.java
+ojluni/src/main/java/java/security/cert/CertPathValidatorSpi.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/cert/CertPathValidatorSpi.java
+ojluni/src/main/java/java/security/cert/CertSelector.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/cert/CertSelector.java
 ojluni/src/main/java/java/security/cert/CertStore.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/CertStore.java
-ojluni/src/main/java/java/security/cert/CertStoreException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/cert/CertStoreException.java
-ojluni/src/main/java/java/security/cert/CertStoreParameters.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/cert/CertStoreParameters.java
-ojluni/src/main/java/java/security/cert/CertStoreSpi.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/cert/CertStoreSpi.java
+ojluni/src/main/java/java/security/cert/CertStoreException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/cert/CertStoreException.java
+ojluni/src/main/java/java/security/cert/CertStoreParameters.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/cert/CertStoreParameters.java
+ojluni/src/main/java/java/security/cert/CertStoreSpi.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/cert/CertStoreSpi.java
 ojluni/src/main/java/java/security/cert/Certificate.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/Certificate.java
 ojluni/src/main/java/java/security/cert/CertificateEncodingException.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/CertificateEncodingException.java
 ojluni/src/main/java/java/security/cert/CertificateException.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/CertificateException.java
@@ -653,19 +655,19 @@ ojluni/src/main/java/java/security/cert/CertificateNotYetValidException.java,jdk
 ojluni/src/main/java/java/security/cert/CertificateParsingException.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/CertificateParsingException.java
 ojluni/src/main/java/java/security/cert/CertificateRevokedException.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/CertificateRevokedException.java
 ojluni/src/main/java/java/security/cert/CollectionCertStoreParameters.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/CollectionCertStoreParameters.java
-ojluni/src/main/java/java/security/cert/Extension.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/cert/Extension.java
+ojluni/src/main/java/java/security/cert/Extension.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/cert/Extension.java
 ojluni/src/main/java/java/security/cert/LDAPCertStoreParameters.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/LDAPCertStoreParameters.java
 ojluni/src/main/java/java/security/cert/PKIXBuilderParameters.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/PKIXBuilderParameters.java
 ojluni/src/main/java/java/security/cert/PKIXCertPathBuilderResult.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/PKIXCertPathBuilderResult.java
-ojluni/src/main/java/java/security/cert/PKIXCertPathChecker.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/cert/PKIXCertPathChecker.java
+ojluni/src/main/java/java/security/cert/PKIXCertPathChecker.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/cert/PKIXCertPathChecker.java
 ojluni/src/main/java/java/security/cert/PKIXCertPathValidatorResult.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/PKIXCertPathValidatorResult.java
 ojluni/src/main/java/java/security/cert/PKIXParameters.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/PKIXParameters.java
 ojluni/src/main/java/java/security/cert/PKIXReason.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/PKIXReason.java
 ojluni/src/main/java/java/security/cert/PKIXRevocationChecker.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/PKIXRevocationChecker.java
-ojluni/src/main/java/java/security/cert/PolicyNode.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/cert/PolicyNode.java
+ojluni/src/main/java/java/security/cert/PolicyNode.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/cert/PolicyNode.java
 ojluni/src/main/java/java/security/cert/PolicyQualifierInfo.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/PolicyQualifierInfo.java
 ojluni/src/main/java/java/security/cert/TrustAnchor.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/TrustAnchor.java
-ojluni/src/main/java/java/security/cert/URICertStoreParameters.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/security/cert/URICertStoreParameters.java
+ojluni/src/main/java/java/security/cert/URICertStoreParameters.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/security/cert/URICertStoreParameters.java
 ojluni/src/main/java/java/security/cert/X509CRL.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/X509CRL.java
 ojluni/src/main/java/java/security/cert/X509CRLEntry.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/X509CRLEntry.java
 ojluni/src/main/java/java/security/cert/X509CRLSelector.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/X509CRLSelector.java
@@ -673,68 +675,68 @@ ojluni/src/main/java/java/security/cert/X509CertSelector.java,jdk8u/jdk8u121-b13
 ojluni/src/main/java/java/security/cert/X509Certificate.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/X509Certificate.java
 ojluni/src/main/java/java/security/cert/X509Extension.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/X509Extension.java
 ojluni/src/main/java/java/security/cert/package-info.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/cert/package-info.java
-ojluni/src/main/java/java/security/interfaces/DSAKey.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/security/interfaces/DSAKey.java
-ojluni/src/main/java/java/security/interfaces/DSAKeyPairGenerator.java,jdk17u/jdk-17.0.5-ga,src/java.base/share/classes/java/security/interfaces/DSAKeyPairGenerator.java
-ojluni/src/main/java/java/security/interfaces/DSAParams.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/security/interfaces/DSAParams.java
-ojluni/src/main/java/java/security/interfaces/DSAPrivateKey.java,jdk17u/jdk-17.0.5-ga,src/java.base/share/classes/java/security/interfaces/DSAPrivateKey.java
-ojluni/src/main/java/java/security/interfaces/DSAPublicKey.java,jdk17u/jdk-17.0.5-ga,src/java.base/share/classes/java/security/interfaces/DSAPublicKey.java
-ojluni/src/main/java/java/security/interfaces/ECKey.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/interfaces/ECKey.java
-ojluni/src/main/java/java/security/interfaces/ECPrivateKey.java,jdk17u/jdk-17.0.5-ga,src/java.base/share/classes/java/security/interfaces/ECPrivateKey.java
-ojluni/src/main/java/java/security/interfaces/ECPublicKey.java,jdk17u/jdk-17.0.5-ga,src/java.base/share/classes/java/security/interfaces/ECPublicKey.java
-ojluni/src/main/java/java/security/interfaces/EdECKey.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/interfaces/EdECKey.java
-ojluni/src/main/java/java/security/interfaces/EdECPrivateKey.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/interfaces/EdECPrivateKey.java
-ojluni/src/main/java/java/security/interfaces/EdECPublicKey.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/interfaces/EdECPublicKey.java
-ojluni/src/main/java/java/security/interfaces/RSAKey.java,jdk17u/jdk-17.0.5-ga,src/java.base/share/classes/java/security/interfaces/RSAKey.java
-ojluni/src/main/java/java/security/interfaces/RSAMultiPrimePrivateCrtKey.java,jdk17u/jdk-17.0.5-ga,src/java.base/share/classes/java/security/interfaces/RSAMultiPrimePrivateCrtKey.java
-ojluni/src/main/java/java/security/interfaces/RSAPrivateCrtKey.java,jdk17u/jdk-17.0.5-ga,src/java.base/share/classes/java/security/interfaces/RSAPrivateCrtKey.java
-ojluni/src/main/java/java/security/interfaces/RSAPrivateKey.java,jdk17u/jdk-17.0.5-ga,src/java.base/share/classes/java/security/interfaces/RSAPrivateKey.java
-ojluni/src/main/java/java/security/interfaces/RSAPublicKey.java,jdk17u/jdk-17.0.5-ga,src/java.base/share/classes/java/security/interfaces/RSAPublicKey.java
-ojluni/src/main/java/java/security/interfaces/XECKey.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/interfaces/XECKey.java
-ojluni/src/main/java/java/security/interfaces/XECPrivateKey.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/interfaces/XECPrivateKey.java
-ojluni/src/main/java/java/security/interfaces/XECPublicKey.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/interfaces/XECPublicKey.java
-ojluni/src/main/java/java/security/interfaces/package-info.java,jdk17u/jdk-17.0.5-ga,src/java.base/share/classes/java/security/interfaces/package-info.java
+ojluni/src/main/java/java/security/interfaces/DSAKey.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/interfaces/DSAKey.java
+ojluni/src/main/java/java/security/interfaces/DSAKeyPairGenerator.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/interfaces/DSAKeyPairGenerator.java
+ojluni/src/main/java/java/security/interfaces/DSAParams.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/interfaces/DSAParams.java
+ojluni/src/main/java/java/security/interfaces/DSAPrivateKey.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/interfaces/DSAPrivateKey.java
+ojluni/src/main/java/java/security/interfaces/DSAPublicKey.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/interfaces/DSAPublicKey.java
+ojluni/src/main/java/java/security/interfaces/ECKey.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/interfaces/ECKey.java
+ojluni/src/main/java/java/security/interfaces/ECPrivateKey.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/interfaces/ECPrivateKey.java
+ojluni/src/main/java/java/security/interfaces/ECPublicKey.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/interfaces/ECPublicKey.java
+ojluni/src/main/java/java/security/interfaces/EdECKey.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/interfaces/EdECKey.java
+ojluni/src/main/java/java/security/interfaces/EdECPrivateKey.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/interfaces/EdECPrivateKey.java
+ojluni/src/main/java/java/security/interfaces/EdECPublicKey.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/interfaces/EdECPublicKey.java
+ojluni/src/main/java/java/security/interfaces/RSAKey.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/interfaces/RSAKey.java
+ojluni/src/main/java/java/security/interfaces/RSAMultiPrimePrivateCrtKey.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/interfaces/RSAMultiPrimePrivateCrtKey.java
+ojluni/src/main/java/java/security/interfaces/RSAPrivateCrtKey.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/interfaces/RSAPrivateCrtKey.java
+ojluni/src/main/java/java/security/interfaces/RSAPrivateKey.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/interfaces/RSAPrivateKey.java
+ojluni/src/main/java/java/security/interfaces/RSAPublicKey.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/interfaces/RSAPublicKey.java
+ojluni/src/main/java/java/security/interfaces/XECKey.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/interfaces/XECKey.java
+ojluni/src/main/java/java/security/interfaces/XECPrivateKey.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/interfaces/XECPrivateKey.java
+ojluni/src/main/java/java/security/interfaces/XECPublicKey.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/interfaces/XECPublicKey.java
+ojluni/src/main/java/java/security/interfaces/package-info.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/interfaces/package-info.java
 ojluni/src/main/java/java/security/package-info.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/security/package-info.java
-ojluni/src/main/java/java/security/spec/AlgorithmParameterSpec.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/spec/AlgorithmParameterSpec.java
-ojluni/src/main/java/java/security/spec/DSAGenParameterSpec.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/spec/DSAGenParameterSpec.java
-ojluni/src/main/java/java/security/spec/DSAParameterSpec.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/spec/DSAParameterSpec.java
-ojluni/src/main/java/java/security/spec/DSAPrivateKeySpec.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/security/spec/DSAPrivateKeySpec.java
-ojluni/src/main/java/java/security/spec/DSAPublicKeySpec.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/security/spec/DSAPublicKeySpec.java
-ojluni/src/main/java/java/security/spec/ECField.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/security/spec/ECField.java
-ojluni/src/main/java/java/security/spec/ECFieldF2m.java,jdk17u/jdk-17.0.10-ga,src/java.base/share/classes/java/security/spec/ECFieldF2m.java
-ojluni/src/main/java/java/security/spec/ECFieldFp.java,jdk17u/jdk-17.0.10-ga,src/java.base/share/classes/java/security/spec/ECFieldFp.java
-ojluni/src/main/java/java/security/spec/ECGenParameterSpec.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/spec/ECGenParameterSpec.java
-ojluni/src/main/java/java/security/spec/ECParameterSpec.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/spec/ECParameterSpec.java
-ojluni/src/main/java/java/security/spec/ECPoint.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/spec/ECPoint.java
-ojluni/src/main/java/java/security/spec/ECPrivateKeySpec.java,jdk17u/jdk-17.0.10-ga,src/java.base/share/classes/java/security/spec/ECPrivateKeySpec.java
-ojluni/src/main/java/java/security/spec/ECPublicKeySpec.java,jdk17u/jdk-17.0.10-ga,src/java.base/share/classes/java/security/spec/ECPublicKeySpec.java
-ojluni/src/main/java/java/security/spec/EdDSAParameterSpec.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/security/spec/EdDSAParameterSpec.java
-ojluni/src/main/java/java/security/spec/EdECPoint.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/spec/EdECPoint.java
-ojluni/src/main/java/java/security/spec/EdECPrivateKeySpec.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/spec/EdECPrivateKeySpec.java
-ojluni/src/main/java/java/security/spec/EdECPublicKeySpec.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/spec/EdECPublicKeySpec.java
-ojluni/src/main/java/java/security/spec/EllipticCurve.java,jdk17u/jdk-17.0.10-ga,src/java.base/share/classes/java/security/spec/EllipticCurve.java
-ojluni/src/main/java/java/security/spec/EncodedKeySpec.java,jdk17u/jdk-17.0.10-ga,src/java.base/share/classes/java/security/spec/EncodedKeySpec.java
-ojluni/src/main/java/java/security/spec/InvalidKeySpecException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/spec/InvalidKeySpecException.java
-ojluni/src/main/java/java/security/spec/InvalidParameterSpecException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/spec/InvalidParameterSpecException.java
-ojluni/src/main/java/java/security/spec/KeySpec.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/spec/KeySpec.java
-ojluni/src/main/java/java/security/spec/MGF1ParameterSpec.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/security/spec/MGF1ParameterSpec.java
-ojluni/src/main/java/java/security/spec/NamedParameterSpec.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/security/spec/NamedParameterSpec.java
-ojluni/src/main/java/java/security/spec/PKCS8EncodedKeySpec.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/spec/PKCS8EncodedKeySpec.java
-ojluni/src/main/java/java/security/spec/PSSParameterSpec.java,jdk17u/jdk-17.0.10-ga,src/java.base/share/classes/java/security/spec/PSSParameterSpec.java
-ojluni/src/main/java/java/security/spec/RSAKeyGenParameterSpec.java,jdk17u/jdk-17.0.10-ga,src/java.base/share/classes/java/security/spec/RSAKeyGenParameterSpec.java
-ojluni/src/main/java/java/security/spec/RSAMultiPrimePrivateCrtKeySpec.java,jdk17u/jdk-17.0.10-ga,src/java.base/share/classes/java/security/spec/RSAMultiPrimePrivateCrtKeySpec.java
-ojluni/src/main/java/java/security/spec/RSAOtherPrimeInfo.java,jdk17u/jdk-17.0.10-ga,src/java.base/share/classes/java/security/spec/RSAOtherPrimeInfo.java
-ojluni/src/main/java/java/security/spec/RSAPrivateCrtKeySpec.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/spec/RSAPrivateCrtKeySpec.java
-ojluni/src/main/java/java/security/spec/RSAPrivateKeySpec.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/spec/RSAPrivateKeySpec.java
-ojluni/src/main/java/java/security/spec/RSAPublicKeySpec.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/spec/RSAPublicKeySpec.java
-ojluni/src/main/java/java/security/spec/X509EncodedKeySpec.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/spec/X509EncodedKeySpec.java
-ojluni/src/main/java/java/security/spec/XECPrivateKeySpec.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/spec/XECPrivateKeySpec.java
-ojluni/src/main/java/java/security/spec/XECPublicKeySpec.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/spec/XECPublicKeySpec.java
-ojluni/src/main/java/java/security/spec/package-info.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/security/spec/package-info.java
+ojluni/src/main/java/java/security/spec/AlgorithmParameterSpec.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/spec/AlgorithmParameterSpec.java
+ojluni/src/main/java/java/security/spec/DSAGenParameterSpec.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/spec/DSAGenParameterSpec.java
+ojluni/src/main/java/java/security/spec/DSAParameterSpec.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/spec/DSAParameterSpec.java
+ojluni/src/main/java/java/security/spec/DSAPrivateKeySpec.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/spec/DSAPrivateKeySpec.java
+ojluni/src/main/java/java/security/spec/DSAPublicKeySpec.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/spec/DSAPublicKeySpec.java
+ojluni/src/main/java/java/security/spec/ECField.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/spec/ECField.java
+ojluni/src/main/java/java/security/spec/ECFieldF2m.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/spec/ECFieldF2m.java
+ojluni/src/main/java/java/security/spec/ECFieldFp.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/spec/ECFieldFp.java
+ojluni/src/main/java/java/security/spec/ECGenParameterSpec.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/spec/ECGenParameterSpec.java
+ojluni/src/main/java/java/security/spec/ECParameterSpec.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/spec/ECParameterSpec.java
+ojluni/src/main/java/java/security/spec/ECPoint.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/spec/ECPoint.java
+ojluni/src/main/java/java/security/spec/ECPrivateKeySpec.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/spec/ECPrivateKeySpec.java
+ojluni/src/main/java/java/security/spec/ECPublicKeySpec.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/spec/ECPublicKeySpec.java
+ojluni/src/main/java/java/security/spec/EdDSAParameterSpec.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/spec/EdDSAParameterSpec.java
+ojluni/src/main/java/java/security/spec/EdECPoint.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/spec/EdECPoint.java
+ojluni/src/main/java/java/security/spec/EdECPrivateKeySpec.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/spec/EdECPrivateKeySpec.java
+ojluni/src/main/java/java/security/spec/EdECPublicKeySpec.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/spec/EdECPublicKeySpec.java
+ojluni/src/main/java/java/security/spec/EllipticCurve.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/spec/EllipticCurve.java
+ojluni/src/main/java/java/security/spec/EncodedKeySpec.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/spec/EncodedKeySpec.java
+ojluni/src/main/java/java/security/spec/InvalidKeySpecException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/spec/InvalidKeySpecException.java
+ojluni/src/main/java/java/security/spec/InvalidParameterSpecException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/spec/InvalidParameterSpecException.java
+ojluni/src/main/java/java/security/spec/KeySpec.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/spec/KeySpec.java
+ojluni/src/main/java/java/security/spec/MGF1ParameterSpec.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/spec/MGF1ParameterSpec.java
+ojluni/src/main/java/java/security/spec/NamedParameterSpec.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/spec/NamedParameterSpec.java
+ojluni/src/main/java/java/security/spec/PKCS8EncodedKeySpec.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/spec/PKCS8EncodedKeySpec.java
+ojluni/src/main/java/java/security/spec/PSSParameterSpec.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/spec/PSSParameterSpec.java
+ojluni/src/main/java/java/security/spec/RSAKeyGenParameterSpec.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/spec/RSAKeyGenParameterSpec.java
+ojluni/src/main/java/java/security/spec/RSAMultiPrimePrivateCrtKeySpec.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/spec/RSAMultiPrimePrivateCrtKeySpec.java
+ojluni/src/main/java/java/security/spec/RSAOtherPrimeInfo.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/security/spec/RSAOtherPrimeInfo.java
+ojluni/src/main/java/java/security/spec/RSAPrivateCrtKeySpec.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/spec/RSAPrivateCrtKeySpec.java
+ojluni/src/main/java/java/security/spec/RSAPrivateKeySpec.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/spec/RSAPrivateKeySpec.java
+ojluni/src/main/java/java/security/spec/RSAPublicKeySpec.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/spec/RSAPublicKeySpec.java
+ojluni/src/main/java/java/security/spec/X509EncodedKeySpec.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/spec/X509EncodedKeySpec.java
+ojluni/src/main/java/java/security/spec/XECPrivateKeySpec.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/spec/XECPrivateKeySpec.java
+ojluni/src/main/java/java/security/spec/XECPublicKeySpec.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/spec/XECPublicKeySpec.java
+ojluni/src/main/java/java/security/spec/package-info.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/security/spec/package-info.java
 ojluni/src/main/java/java/sql/Array.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/Array.java
 ojluni/src/main/java/java/sql/BatchUpdateException.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/BatchUpdateException.java
 ojluni/src/main/java/java/sql/Blob.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/Blob.java
 ojluni/src/main/java/java/sql/CallableStatement.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/CallableStatement.java
-ojluni/src/main/java/java/sql/ClientInfoStatus.java,jdk11u/jdk-11.0.13-ga,src/java.sql/share/classes/java/sql/ClientInfoStatus.java
+ojluni/src/main/java/java/sql/ClientInfoStatus.java,jdk11u/jdk-11.0.26-ga,src/java.sql/share/classes/java/sql/ClientInfoStatus.java
 ojluni/src/main/java/java/sql/Clob.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/Clob.java
 ojluni/src/main/java/java/sql/Connection.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/Connection.java
 ojluni/src/main/java/java/sql/DataTruncation.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/DataTruncation.java
@@ -744,15 +746,15 @@ ojluni/src/main/java/java/sql/Driver.java,jdk7u/jdk7u40-b60,jdk/src/share/classe
 ojluni/src/main/java/java/sql/DriverManager.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/DriverManager.java
 ojluni/src/main/java/java/sql/DriverPropertyInfo.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/DriverPropertyInfo.java
 ojluni/src/main/java/java/sql/NClob.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/NClob.java
-ojluni/src/main/java/java/sql/ParameterMetaData.java,jdk11u/jdk-11.0.13-ga,src/java.sql/share/classes/java/sql/ParameterMetaData.java
+ojluni/src/main/java/java/sql/ParameterMetaData.java,jdk11u/jdk-11.0.26-ga,src/java.sql/share/classes/java/sql/ParameterMetaData.java
 ojluni/src/main/java/java/sql/PreparedStatement.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/PreparedStatement.java
-ojluni/src/main/java/java/sql/Ref.java,jdk11u/jdk-11.0.13-ga,src/java.sql/share/classes/java/sql/Ref.java
+ojluni/src/main/java/java/sql/Ref.java,jdk11u/jdk-11.0.26-ga,src/java.sql/share/classes/java/sql/Ref.java
 ojluni/src/main/java/java/sql/ResultSet.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/ResultSet.java
 ojluni/src/main/java/java/sql/ResultSetMetaData.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/ResultSetMetaData.java
-ojluni/src/main/java/java/sql/RowId.java,jdk11u/jdk-11.0.13-ga,src/java.sql/share/classes/java/sql/RowId.java
-ojluni/src/main/java/java/sql/RowIdLifetime.java,jdk21u/jdk-21.0.4-ga,src/java.sql/share/classes/java/sql/RowIdLifetime.java
+ojluni/src/main/java/java/sql/RowId.java,jdk11u/jdk-11.0.26-ga,src/java.sql/share/classes/java/sql/RowId.java
+ojluni/src/main/java/java/sql/RowIdLifetime.java,jdk21u/jdk-21.0.6-ga,src/java.sql/share/classes/java/sql/RowIdLifetime.java
 ojluni/src/main/java/java/sql/SQLClientInfoException.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/SQLClientInfoException.java
-ojluni/src/main/java/java/sql/SQLData.java,jdk11u/jdk-11.0.13-ga,src/java.sql/share/classes/java/sql/SQLData.java
+ojluni/src/main/java/java/sql/SQLData.java,jdk11u/jdk-11.0.26-ga,src/java.sql/share/classes/java/sql/SQLData.java
 ojluni/src/main/java/java/sql/SQLDataException.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/SQLDataException.java
 ojluni/src/main/java/java/sql/SQLException.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/SQLException.java
 ojluni/src/main/java/java/sql/SQLFeatureNotSupportedException.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/SQLFeatureNotSupportedException.java
@@ -771,408 +773,409 @@ ojluni/src/main/java/java/sql/SQLTransientConnectionException.java,jdk7u/jdk7u40
 ojluni/src/main/java/java/sql/SQLTransientException.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/SQLTransientException.java
 ojluni/src/main/java/java/sql/SQLWarning.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/SQLWarning.java
 ojluni/src/main/java/java/sql/SQLXML.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/SQLXML.java
-ojluni/src/main/java/java/sql/Savepoint.java,jdk11u/jdk-11.0.13-ga,src/java.sql/share/classes/java/sql/Savepoint.java
+ojluni/src/main/java/java/sql/Savepoint.java,jdk11u/jdk-11.0.26-ga,src/java.sql/share/classes/java/sql/Savepoint.java
 ojluni/src/main/java/java/sql/Statement.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/Statement.java
 ojluni/src/main/java/java/sql/Struct.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/Struct.java
 ojluni/src/main/java/java/sql/Time.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/Time.java
 ojluni/src/main/java/java/sql/Timestamp.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/Timestamp.java
 ojluni/src/main/java/java/sql/Types.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/Types.java
 ojluni/src/main/java/java/sql/Wrapper.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/sql/Wrapper.java
-ojluni/src/main/java/java/text/Annotation.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/text/Annotation.java
-ojluni/src/main/java/java/text/AttributedCharacterIterator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/text/AttributedCharacterIterator.java
-ojluni/src/main/java/java/text/AttributedString.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/text/AttributedString.java
-ojluni/src/main/java/java/text/Bidi.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/text/Bidi.java
-ojluni/src/main/java/java/text/BreakIterator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/text/BreakIterator.java
-ojluni/src/main/java/java/text/CalendarBuilder.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/text/CalendarBuilder.java
-ojluni/src/main/java/java/text/CharacterIterator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/text/CharacterIterator.java
-ojluni/src/main/java/java/text/CharacterIteratorFieldDelegate.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/text/CharacterIteratorFieldDelegate.java
-ojluni/src/main/java/java/text/ChoiceFormat.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/text/ChoiceFormat.java
-ojluni/src/main/java/java/text/CollationElementIterator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/text/CollationElementIterator.java
-ojluni/src/main/java/java/text/CollationKey.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/text/CollationKey.java
-ojluni/src/main/java/java/text/Collator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/text/Collator.java
-ojluni/src/main/java/java/text/DateFormat.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/text/DateFormat.java
-ojluni/src/main/java/java/text/DateFormatSymbols.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/text/DateFormatSymbols.java
-ojluni/src/main/java/java/text/DecimalFormat.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/text/DecimalFormat.java
-ojluni/src/main/java/java/text/DecimalFormatSymbols.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/text/DecimalFormatSymbols.java
-ojluni/src/main/java/java/text/DontCareFieldPosition.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/text/DontCareFieldPosition.java
-ojluni/src/main/java/java/text/EntryPair.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/text/EntryPair.java
-ojluni/src/main/java/java/text/FieldPosition.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/text/FieldPosition.java
-ojluni/src/main/java/java/text/Format.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/text/Format.java
+ojluni/src/main/java/java/text/Annotation.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/text/Annotation.java
+ojluni/src/main/java/java/text/AttributedCharacterIterator.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/text/AttributedCharacterIterator.java
+ojluni/src/main/java/java/text/AttributedString.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/text/AttributedString.java
+ojluni/src/main/java/java/text/Bidi.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/text/Bidi.java
+ojluni/src/main/java/java/text/BreakIterator.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/text/BreakIterator.java
+ojluni/src/main/java/java/text/CalendarBuilder.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/text/CalendarBuilder.java
+ojluni/src/main/java/java/text/CharacterIterator.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/text/CharacterIterator.java
+ojluni/src/main/java/java/text/CharacterIteratorFieldDelegate.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/text/CharacterIteratorFieldDelegate.java
+ojluni/src/main/java/java/text/ChoiceFormat.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/text/ChoiceFormat.java
+ojluni/src/main/java/java/text/CollationElementIterator.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/text/CollationElementIterator.java
+ojluni/src/main/java/java/text/CollationKey.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/text/CollationKey.java
+ojluni/src/main/java/java/text/Collator.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/text/Collator.java
+ojluni/src/main/java/java/text/DateFormat.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/text/DateFormat.java
+ojluni/src/main/java/java/text/DateFormatSymbols.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/text/DateFormatSymbols.java
+ojluni/src/main/java/java/text/DecimalFormat.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/text/DecimalFormat.java
+ojluni/src/main/java/java/text/DecimalFormatSymbols.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/text/DecimalFormatSymbols.java
+ojluni/src/main/java/java/text/DontCareFieldPosition.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/text/DontCareFieldPosition.java
+ojluni/src/main/java/java/text/EntryPair.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/text/EntryPair.java
+ojluni/src/main/java/java/text/FieldPosition.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/text/FieldPosition.java
+ojluni/src/main/java/java/text/Format.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/text/Format.java
 # java.text.IcuIteratorWrapper doesn't come from the upstream OpenJDK.
-ojluni/src/main/java/java/text/MessageFormat.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/text/MessageFormat.java
-ojluni/src/main/java/java/text/Normalizer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/text/Normalizer.java
-ojluni/src/main/java/java/text/NumberFormat.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/text/NumberFormat.java
-ojluni/src/main/java/java/text/ParseException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/text/ParseException.java
-ojluni/src/main/java/java/text/ParsePosition.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/text/ParsePosition.java
-ojluni/src/main/java/java/text/RuleBasedCollator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/text/RuleBasedCollator.java
-ojluni/src/main/java/java/text/SimpleDateFormat.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/text/SimpleDateFormat.java
-ojluni/src/main/java/java/text/StringCharacterIterator.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/text/StringCharacterIterator.java
-ojluni/src/main/java/java/text/package-info.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/text/package-info.java
-ojluni/src/main/java/java/time/Clock.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/Clock.java
-ojluni/src/main/java/java/time/DateTimeException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/DateTimeException.java
-ojluni/src/main/java/java/time/DayOfWeek.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/DayOfWeek.java
-ojluni/src/main/java/java/time/Duration.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/Duration.java
-ojluni/src/main/java/java/time/Instant.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/Instant.java
-ojluni/src/main/java/java/time/InstantSource.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/InstantSource.java
-ojluni/src/main/java/java/time/LocalDate.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/LocalDate.java
-ojluni/src/main/java/java/time/LocalDateTime.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/LocalDateTime.java
-ojluni/src/main/java/java/time/LocalTime.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/LocalTime.java
-ojluni/src/main/java/java/time/Month.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/Month.java
-ojluni/src/main/java/java/time/MonthDay.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/MonthDay.java
-ojluni/src/main/java/java/time/OffsetDateTime.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/OffsetDateTime.java
-ojluni/src/main/java/java/time/OffsetTime.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/OffsetTime.java
-ojluni/src/main/java/java/time/Period.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/Period.java
-ojluni/src/main/java/java/time/Ser.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/Ser.java
-ojluni/src/main/java/java/time/Year.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/Year.java
-ojluni/src/main/java/java/time/YearMonth.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/YearMonth.java
-ojluni/src/main/java/java/time/ZoneId.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/ZoneId.java
-ojluni/src/main/java/java/time/ZoneOffset.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/ZoneOffset.java
-ojluni/src/main/java/java/time/ZoneRegion.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/ZoneRegion.java
-ojluni/src/main/java/java/time/ZonedDateTime.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/ZonedDateTime.java
-ojluni/src/main/java/java/time/chrono/AbstractChronology.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/chrono/AbstractChronology.java
-ojluni/src/main/java/java/time/chrono/ChronoLocalDate.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/chrono/ChronoLocalDate.java
-ojluni/src/main/java/java/time/chrono/ChronoLocalDateImpl.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/chrono/ChronoLocalDateImpl.java
-ojluni/src/main/java/java/time/chrono/ChronoLocalDateTime.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/chrono/ChronoLocalDateTime.java
-ojluni/src/main/java/java/time/chrono/ChronoLocalDateTimeImpl.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/chrono/ChronoLocalDateTimeImpl.java
-ojluni/src/main/java/java/time/chrono/ChronoPeriod.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/chrono/ChronoPeriod.java
-ojluni/src/main/java/java/time/chrono/ChronoPeriodImpl.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/chrono/ChronoPeriodImpl.java
-ojluni/src/main/java/java/time/chrono/ChronoZonedDateTime.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/chrono/ChronoZonedDateTime.java
-ojluni/src/main/java/java/time/chrono/ChronoZonedDateTimeImpl.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/chrono/ChronoZonedDateTimeImpl.java
-ojluni/src/main/java/java/time/chrono/Chronology.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/chrono/Chronology.java
-ojluni/src/main/java/java/time/chrono/Era.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/chrono/Era.java
-ojluni/src/main/java/java/time/chrono/HijrahChronology.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/chrono/HijrahChronology.java
-ojluni/src/main/java/java/time/chrono/HijrahDate.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/chrono/HijrahDate.java
-ojluni/src/main/java/java/time/chrono/HijrahEra.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/chrono/HijrahEra.java
-ojluni/src/main/java/java/time/chrono/IsoChronology.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/chrono/IsoChronology.java
-ojluni/src/main/java/java/time/chrono/IsoEra.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/chrono/IsoEra.java
-ojluni/src/main/java/java/time/chrono/JapaneseChronology.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/chrono/JapaneseChronology.java
-ojluni/src/main/java/java/time/chrono/JapaneseDate.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/chrono/JapaneseDate.java
-ojluni/src/main/java/java/time/chrono/JapaneseEra.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/chrono/JapaneseEra.java
-ojluni/src/main/java/java/time/chrono/MinguoChronology.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/chrono/MinguoChronology.java
-ojluni/src/main/java/java/time/chrono/MinguoDate.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/chrono/MinguoDate.java
-ojluni/src/main/java/java/time/chrono/MinguoEra.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/chrono/MinguoEra.java
-ojluni/src/main/java/java/time/chrono/Ser.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/chrono/Ser.java
-ojluni/src/main/java/java/time/chrono/ThaiBuddhistChronology.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/chrono/ThaiBuddhistChronology.java
-ojluni/src/main/java/java/time/chrono/ThaiBuddhistDate.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/chrono/ThaiBuddhistDate.java
-ojluni/src/main/java/java/time/chrono/ThaiBuddhistEra.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/chrono/ThaiBuddhistEra.java
-ojluni/src/main/java/java/time/chrono/package-info.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/chrono/package-info.java
-ojluni/src/main/java/java/time/format/DateTimeFormatter.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/format/DateTimeFormatter.java
-ojluni/src/main/java/java/time/format/DateTimeFormatterBuilder.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/format/DateTimeFormatterBuilder.java
-ojluni/src/main/java/java/time/format/DateTimeParseContext.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/format/DateTimeParseContext.java
-ojluni/src/main/java/java/time/format/DateTimeParseException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/format/DateTimeParseException.java
-ojluni/src/main/java/java/time/format/DateTimePrintContext.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/format/DateTimePrintContext.java
-ojluni/src/main/java/java/time/format/DateTimeTextProvider.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/format/DateTimeTextProvider.java
-ojluni/src/main/java/java/time/format/DecimalStyle.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/format/DecimalStyle.java
-ojluni/src/main/java/java/time/format/FormatStyle.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/format/FormatStyle.java
-ojluni/src/main/java/java/time/format/Parsed.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/format/Parsed.java
-ojluni/src/main/java/java/time/format/ResolverStyle.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/format/ResolverStyle.java
-ojluni/src/main/java/java/time/format/SignStyle.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/format/SignStyle.java
-ojluni/src/main/java/java/time/format/TextStyle.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/format/TextStyle.java
-ojluni/src/main/java/java/time/format/ZoneName.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/format/ZoneName.java.template
-ojluni/src/main/java/java/time/format/package-info.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/format/package-info.java
-ojluni/src/main/java/java/time/package-info.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/package-info.java
-ojluni/src/main/java/java/time/temporal/ChronoField.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/temporal/ChronoField.java
-ojluni/src/main/java/java/time/temporal/ChronoUnit.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/temporal/ChronoUnit.java
-ojluni/src/main/java/java/time/temporal/IsoFields.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/temporal/IsoFields.java
-ojluni/src/main/java/java/time/temporal/JulianFields.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/temporal/JulianFields.java
-ojluni/src/main/java/java/time/temporal/Temporal.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/temporal/Temporal.java
-ojluni/src/main/java/java/time/temporal/TemporalAccessor.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/temporal/TemporalAccessor.java
-ojluni/src/main/java/java/time/temporal/TemporalAdjuster.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/temporal/TemporalAdjuster.java
-ojluni/src/main/java/java/time/temporal/TemporalAdjusters.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/temporal/TemporalAdjusters.java
-ojluni/src/main/java/java/time/temporal/TemporalAmount.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/temporal/TemporalAmount.java
-ojluni/src/main/java/java/time/temporal/TemporalField.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/temporal/TemporalField.java
-ojluni/src/main/java/java/time/temporal/TemporalQueries.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/temporal/TemporalQueries.java
-ojluni/src/main/java/java/time/temporal/TemporalQuery.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/temporal/TemporalQuery.java
-ojluni/src/main/java/java/time/temporal/TemporalUnit.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/temporal/TemporalUnit.java
-ojluni/src/main/java/java/time/temporal/UnsupportedTemporalTypeException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/temporal/UnsupportedTemporalTypeException.java
-ojluni/src/main/java/java/time/temporal/ValueRange.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/temporal/ValueRange.java
-ojluni/src/main/java/java/time/temporal/WeekFields.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/temporal/WeekFields.java
-ojluni/src/main/java/java/time/temporal/package-info.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/temporal/package-info.java
+ojluni/src/main/java/java/text/MessageFormat.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/text/MessageFormat.java
+ojluni/src/main/java/java/text/Normalizer.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/text/Normalizer.java
+ojluni/src/main/java/java/text/NumberFormat.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/text/NumberFormat.java
+ojluni/src/main/java/java/text/ParseException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/text/ParseException.java
+ojluni/src/main/java/java/text/ParsePosition.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/text/ParsePosition.java
+ojluni/src/main/java/java/text/RuleBasedCollator.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/text/RuleBasedCollator.java
+ojluni/src/main/java/java/text/SimpleDateFormat.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/text/SimpleDateFormat.java
+ojluni/src/main/java/java/text/StringCharacterIterator.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/text/StringCharacterIterator.java
+ojluni/src/main/java/java/text/package-info.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/text/package-info.java
+ojluni/src/main/java/java/time/Clock.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/Clock.java
+ojluni/src/main/java/java/time/DateTimeException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/DateTimeException.java
+ojluni/src/main/java/java/time/DayOfWeek.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/DayOfWeek.java
+ojluni/src/main/java/java/time/Duration.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/Duration.java
+ojluni/src/main/java/java/time/Instant.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/Instant.java
+ojluni/src/main/java/java/time/InstantSource.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/InstantSource.java
+ojluni/src/main/java/java/time/LocalDate.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/LocalDate.java
+ojluni/src/main/java/java/time/LocalDateTime.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/LocalDateTime.java
+ojluni/src/main/java/java/time/LocalTime.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/LocalTime.java
+ojluni/src/main/java/java/time/Month.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/Month.java
+ojluni/src/main/java/java/time/MonthDay.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/MonthDay.java
+ojluni/src/main/java/java/time/OffsetDateTime.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/OffsetDateTime.java
+ojluni/src/main/java/java/time/OffsetTime.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/OffsetTime.java
+ojluni/src/main/java/java/time/Period.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/Period.java
+ojluni/src/main/java/java/time/Ser.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/Ser.java
+ojluni/src/main/java/java/time/Year.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/Year.java
+ojluni/src/main/java/java/time/YearMonth.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/YearMonth.java
+ojluni/src/main/java/java/time/ZoneId.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/ZoneId.java
+ojluni/src/main/java/java/time/ZoneOffset.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/ZoneOffset.java
+ojluni/src/main/java/java/time/ZoneRegion.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/ZoneRegion.java
+ojluni/src/main/java/java/time/ZonedDateTime.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/ZonedDateTime.java
+ojluni/src/main/java/java/time/chrono/AbstractChronology.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/chrono/AbstractChronology.java
+ojluni/src/main/java/java/time/chrono/ChronoLocalDate.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/chrono/ChronoLocalDate.java
+ojluni/src/main/java/java/time/chrono/ChronoLocalDateImpl.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/chrono/ChronoLocalDateImpl.java
+ojluni/src/main/java/java/time/chrono/ChronoLocalDateTime.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/chrono/ChronoLocalDateTime.java
+ojluni/src/main/java/java/time/chrono/ChronoLocalDateTimeImpl.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/chrono/ChronoLocalDateTimeImpl.java
+ojluni/src/main/java/java/time/chrono/ChronoPeriod.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/chrono/ChronoPeriod.java
+ojluni/src/main/java/java/time/chrono/ChronoPeriodImpl.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/chrono/ChronoPeriodImpl.java
+ojluni/src/main/java/java/time/chrono/ChronoZonedDateTime.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/chrono/ChronoZonedDateTime.java
+ojluni/src/main/java/java/time/chrono/ChronoZonedDateTimeImpl.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/chrono/ChronoZonedDateTimeImpl.java
+ojluni/src/main/java/java/time/chrono/Chronology.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/chrono/Chronology.java
+ojluni/src/main/java/java/time/chrono/Era.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/chrono/Era.java
+ojluni/src/main/java/java/time/chrono/HijrahChronology.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/chrono/HijrahChronology.java
+ojluni/src/main/java/java/time/chrono/HijrahDate.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/chrono/HijrahDate.java
+ojluni/src/main/java/java/time/chrono/HijrahEra.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/chrono/HijrahEra.java
+ojluni/src/main/java/java/time/chrono/IsoChronology.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/chrono/IsoChronology.java
+ojluni/src/main/java/java/time/chrono/IsoEra.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/chrono/IsoEra.java
+ojluni/src/main/java/java/time/chrono/JapaneseChronology.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/chrono/JapaneseChronology.java
+ojluni/src/main/java/java/time/chrono/JapaneseDate.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/chrono/JapaneseDate.java
+ojluni/src/main/java/java/time/chrono/JapaneseEra.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/chrono/JapaneseEra.java
+ojluni/src/main/java/java/time/chrono/MinguoChronology.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/chrono/MinguoChronology.java
+ojluni/src/main/java/java/time/chrono/MinguoDate.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/chrono/MinguoDate.java
+ojluni/src/main/java/java/time/chrono/MinguoEra.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/chrono/MinguoEra.java
+ojluni/src/main/java/java/time/chrono/Ser.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/chrono/Ser.java
+ojluni/src/main/java/java/time/chrono/ThaiBuddhistChronology.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/chrono/ThaiBuddhistChronology.java
+ojluni/src/main/java/java/time/chrono/ThaiBuddhistDate.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/chrono/ThaiBuddhistDate.java
+ojluni/src/main/java/java/time/chrono/ThaiBuddhistEra.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/chrono/ThaiBuddhistEra.java
+ojluni/src/main/java/java/time/chrono/package-info.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/chrono/package-info.java
+ojluni/src/main/java/java/time/format/DateTimeFormatter.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/format/DateTimeFormatter.java
+ojluni/src/main/java/java/time/format/DateTimeFormatterBuilder.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/format/DateTimeFormatterBuilder.java
+ojluni/src/main/java/java/time/format/DateTimeParseContext.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/format/DateTimeParseContext.java
+ojluni/src/main/java/java/time/format/DateTimeParseException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/format/DateTimeParseException.java
+ojluni/src/main/java/java/time/format/DateTimePrintContext.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/format/DateTimePrintContext.java
+ojluni/src/main/java/java/time/format/DateTimeTextProvider.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/format/DateTimeTextProvider.java
+ojluni/src/main/java/java/time/format/DecimalStyle.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/format/DecimalStyle.java
+ojluni/src/main/java/java/time/format/FormatStyle.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/format/FormatStyle.java
+ojluni/src/main/java/java/time/format/Parsed.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/format/Parsed.java
+ojluni/src/main/java/java/time/format/ResolverStyle.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/format/ResolverStyle.java
+ojluni/src/main/java/java/time/format/SignStyle.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/format/SignStyle.java
+ojluni/src/main/java/java/time/format/TextStyle.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/format/TextStyle.java
+ojluni/src/main/java/java/time/format/ZoneName.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/format/ZoneName.java.template
+ojluni/src/main/java/java/time/format/package-info.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/format/package-info.java
+ojluni/src/main/java/java/time/package-info.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/package-info.java
+ojluni/src/main/java/java/time/temporal/ChronoField.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/temporal/ChronoField.java
+ojluni/src/main/java/java/time/temporal/ChronoUnit.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/temporal/ChronoUnit.java
+ojluni/src/main/java/java/time/temporal/IsoFields.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/temporal/IsoFields.java
+ojluni/src/main/java/java/time/temporal/JulianFields.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/temporal/JulianFields.java
+ojluni/src/main/java/java/time/temporal/Temporal.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/temporal/Temporal.java
+ojluni/src/main/java/java/time/temporal/TemporalAccessor.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/temporal/TemporalAccessor.java
+ojluni/src/main/java/java/time/temporal/TemporalAdjuster.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/temporal/TemporalAdjuster.java
+ojluni/src/main/java/java/time/temporal/TemporalAdjusters.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/temporal/TemporalAdjusters.java
+ojluni/src/main/java/java/time/temporal/TemporalAmount.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/temporal/TemporalAmount.java
+ojluni/src/main/java/java/time/temporal/TemporalField.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/temporal/TemporalField.java
+ojluni/src/main/java/java/time/temporal/TemporalQueries.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/temporal/TemporalQueries.java
+ojluni/src/main/java/java/time/temporal/TemporalQuery.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/temporal/TemporalQuery.java
+ojluni/src/main/java/java/time/temporal/TemporalUnit.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/temporal/TemporalUnit.java
+ojluni/src/main/java/java/time/temporal/UnsupportedTemporalTypeException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/temporal/UnsupportedTemporalTypeException.java
+ojluni/src/main/java/java/time/temporal/ValueRange.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/temporal/ValueRange.java
+ojluni/src/main/java/java/time/temporal/WeekFields.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/temporal/WeekFields.java
+ojluni/src/main/java/java/time/temporal/package-info.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/temporal/package-info.java
 # java.time.zone.IcuZoneRulesProvider doesn't come from the upstream OpenJDK.
-ojluni/src/main/java/java/time/zone/Ser.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/zone/Ser.java
-ojluni/src/main/java/java/time/zone/ZoneOffsetTransition.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/zone/ZoneOffsetTransition.java
-ojluni/src/main/java/java/time/zone/ZoneOffsetTransitionRule.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/zone/ZoneOffsetTransitionRule.java
-ojluni/src/main/java/java/time/zone/ZoneRules.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/zone/ZoneRules.java
-ojluni/src/main/java/java/time/zone/ZoneRulesException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/zone/ZoneRulesException.java
-ojluni/src/main/java/java/time/zone/ZoneRulesProvider.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/time/zone/ZoneRulesProvider.java
-ojluni/src/main/java/java/time/zone/package-info.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/zone/package-info.java
-ojluni/src/main/java/java/util/AbstractCollection.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/AbstractCollection.java
-ojluni/src/main/java/java/util/AbstractList.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/AbstractList.java
-ojluni/src/main/java/java/util/AbstractMap.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/AbstractMap.java
-ojluni/src/main/java/java/util/AbstractQueue.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/AbstractQueue.java
-ojluni/src/main/java/java/util/AbstractSequentialList.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/AbstractSequentialList.java
-ojluni/src/main/java/java/util/AbstractSet.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/AbstractSet.java
-ojluni/src/main/java/java/util/ArrayDeque.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/ArrayDeque.java
-ojluni/src/main/java/java/util/ArrayList.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/ArrayList.java
-ojluni/src/main/java/java/util/ArrayPrefixHelpers.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/ArrayPrefixHelpers.java
-ojluni/src/main/java/java/util/Arrays.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Arrays.java
-ojluni/src/main/java/java/util/ArraysParallelSortHelpers.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/ArraysParallelSortHelpers.java
-ojluni/src/main/java/java/util/Base64.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Base64.java
-ojluni/src/main/java/java/util/BitSet.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/BitSet.java
-ojluni/src/main/java/java/util/Calendar.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Calendar.java
-ojluni/src/main/java/java/util/Collection.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Collection.java
-ojluni/src/main/java/java/util/Collections.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Collections.java
-ojluni/src/main/java/java/util/ComparableTimSort.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/ComparableTimSort.java
-ojluni/src/main/java/java/util/Comparator.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Comparator.java
-ojluni/src/main/java/java/util/Comparators.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Comparators.java
-ojluni/src/main/java/java/util/ConcurrentModificationException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/ConcurrentModificationException.java
-ojluni/src/main/java/java/util/Currency.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Currency.java
-ojluni/src/main/java/java/util/Date.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Date.java
-ojluni/src/main/java/java/util/Deque.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Deque.java
-ojluni/src/main/java/java/util/Dictionary.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Dictionary.java
-ojluni/src/main/java/java/util/DoubleSummaryStatistics.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/DoubleSummaryStatistics.java
-ojluni/src/main/java/java/util/DualPivotQuicksort.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/DualPivotQuicksort.java
-ojluni/src/main/java/java/util/DuplicateFormatFlagsException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/DuplicateFormatFlagsException.java
-ojluni/src/main/java/java/util/EmptyStackException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/EmptyStackException.java
-ojluni/src/main/java/java/util/EnumMap.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/EnumMap.java
-ojluni/src/main/java/java/util/EnumSet.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/EnumSet.java
-ojluni/src/main/java/java/util/Enumeration.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Enumeration.java
-ojluni/src/main/java/java/util/EventListener.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/EventListener.java
-ojluni/src/main/java/java/util/EventListenerProxy.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/EventListenerProxy.java
-ojluni/src/main/java/java/util/EventObject.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/EventObject.java
-ojluni/src/main/java/java/util/FormatFlagsConversionMismatchException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/FormatFlagsConversionMismatchException.java
-ojluni/src/main/java/java/util/Formattable.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Formattable.java
-ojluni/src/main/java/java/util/FormattableFlags.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/FormattableFlags.java
-ojluni/src/main/java/java/util/Formatter.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Formatter.java
-ojluni/src/main/java/java/util/FormatterClosedException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/FormatterClosedException.java
-ojluni/src/main/java/java/util/GregorianCalendar.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/GregorianCalendar.java
-ojluni/src/main/java/java/util/HashMap.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/HashMap.java
-ojluni/src/main/java/java/util/HashSet.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/HashSet.java
-ojluni/src/main/java/java/util/Hashtable.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Hashtable.java
-ojluni/src/main/java/java/util/HexFormat.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/HexFormat.java
-ojluni/src/main/java/java/util/IdentityHashMap.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/IdentityHashMap.java
-ojluni/src/main/java/java/util/IllegalFormatArgumentIndexException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/IllegalFormatArgumentIndexException.java
-ojluni/src/main/java/java/util/IllegalFormatCodePointException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/IllegalFormatCodePointException.java
-ojluni/src/main/java/java/util/IllegalFormatConversionException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/IllegalFormatConversionException.java
-ojluni/src/main/java/java/util/IllegalFormatException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/IllegalFormatException.java
-ojluni/src/main/java/java/util/IllegalFormatFlagsException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/IllegalFormatFlagsException.java
-ojluni/src/main/java/java/util/IllegalFormatPrecisionException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/IllegalFormatPrecisionException.java
-ojluni/src/main/java/java/util/IllegalFormatWidthException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/IllegalFormatWidthException.java
-ojluni/src/main/java/java/util/IllformedLocaleException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/IllformedLocaleException.java
-ojluni/src/main/java/java/util/ImmutableCollections.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/ImmutableCollections.java
-ojluni/src/main/java/java/util/InputMismatchException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/InputMismatchException.java
-ojluni/src/main/java/java/util/IntSummaryStatistics.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/IntSummaryStatistics.java
-ojluni/src/main/java/java/util/InvalidPropertiesFormatException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/InvalidPropertiesFormatException.java
-ojluni/src/main/java/java/util/Iterator.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Iterator.java
-ojluni/src/main/java/java/util/JapaneseImperialCalendar.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/JapaneseImperialCalendar.java
-ojluni/src/main/java/java/util/JumboEnumSet.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/JumboEnumSet.java
-ojluni/src/main/java/java/util/KeyValueHolder.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/KeyValueHolder.java
-ojluni/src/main/java/java/util/LinkedHashMap.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/LinkedHashMap.java
-ojluni/src/main/java/java/util/LinkedHashSet.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/LinkedHashSet.java
-ojluni/src/main/java/java/util/LinkedList.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/LinkedList.java
-ojluni/src/main/java/java/util/List.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/List.java
-ojluni/src/main/java/java/util/ListIterator.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/ListIterator.java
-ojluni/src/main/java/java/util/ListResourceBundle.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/ListResourceBundle.java
+ojluni/src/main/java/java/time/zone/Ser.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/zone/Ser.java
+ojluni/src/main/java/java/time/zone/ZoneOffsetTransition.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/zone/ZoneOffsetTransition.java
+ojluni/src/main/java/java/time/zone/ZoneOffsetTransitionRule.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/zone/ZoneOffsetTransitionRule.java
+ojluni/src/main/java/java/time/zone/ZoneRules.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/zone/ZoneRules.java
+ojluni/src/main/java/java/time/zone/ZoneRulesException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/zone/ZoneRulesException.java
+ojluni/src/main/java/java/time/zone/ZoneRulesProvider.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/time/zone/ZoneRulesProvider.java
+ojluni/src/main/java/java/time/zone/package-info.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/zone/package-info.java
+ojluni/src/main/java/java/util/AbstractCollection.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/AbstractCollection.java
+ojluni/src/main/java/java/util/AbstractList.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/AbstractList.java
+ojluni/src/main/java/java/util/AbstractMap.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/AbstractMap.java
+ojluni/src/main/java/java/util/AbstractQueue.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/AbstractQueue.java
+ojluni/src/main/java/java/util/AbstractSequentialList.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/AbstractSequentialList.java
+ojluni/src/main/java/java/util/AbstractSet.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/AbstractSet.java
+ojluni/src/main/java/java/util/ArrayDeque.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/ArrayDeque.java
+ojluni/src/main/java/java/util/ArrayList.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/ArrayList.java
+ojluni/src/main/java/java/util/ArrayPrefixHelpers.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/ArrayPrefixHelpers.java
+ojluni/src/main/java/java/util/Arrays.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Arrays.java
+ojluni/src/main/java/java/util/ArraysParallelSortHelpers.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/ArraysParallelSortHelpers.java
+ojluni/src/main/java/java/util/Base64.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/Base64.java
+ojluni/src/main/java/java/util/BitSet.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/BitSet.java
+ojluni/src/main/java/java/util/Calendar.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/Calendar.java
+ojluni/src/main/java/java/util/Collection.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Collection.java
+ojluni/src/main/java/java/util/Collections.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Collections.java
+ojluni/src/main/java/java/util/ComparableTimSort.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/ComparableTimSort.java
+ojluni/src/main/java/java/util/Comparator.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Comparator.java
+ojluni/src/main/java/java/util/Comparators.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Comparators.java
+ojluni/src/main/java/java/util/ConcurrentModificationException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/ConcurrentModificationException.java
+ojluni/src/main/java/java/util/Currency.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Currency.java
+ojluni/src/main/java/java/util/Date.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Date.java
+ojluni/src/main/java/java/util/Deque.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Deque.java
+ojluni/src/main/java/java/util/Dictionary.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/Dictionary.java
+ojluni/src/main/java/java/util/DoubleSummaryStatistics.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/DoubleSummaryStatistics.java
+ojluni/src/main/java/java/util/DualPivotQuicksort.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/DualPivotQuicksort.java
+ojluni/src/main/java/java/util/DuplicateFormatFlagsException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/DuplicateFormatFlagsException.java
+ojluni/src/main/java/java/util/EmptyStackException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/EmptyStackException.java
+ojluni/src/main/java/java/util/EnumMap.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/EnumMap.java
+ojluni/src/main/java/java/util/EnumSet.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/EnumSet.java
+ojluni/src/main/java/java/util/Enumeration.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Enumeration.java
+ojluni/src/main/java/java/util/EventListener.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/EventListener.java
+ojluni/src/main/java/java/util/EventListenerProxy.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/EventListenerProxy.java
+ojluni/src/main/java/java/util/EventObject.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/EventObject.java
+ojluni/src/main/java/java/util/FormatFlagsConversionMismatchException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/FormatFlagsConversionMismatchException.java
+ojluni/src/main/java/java/util/Formattable.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Formattable.java
+ojluni/src/main/java/java/util/FormattableFlags.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/FormattableFlags.java
+ojluni/src/main/java/java/util/Formatter.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/Formatter.java
+ojluni/src/main/java/java/util/FormatterClosedException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/FormatterClosedException.java
+ojluni/src/main/java/java/util/GregorianCalendar.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/GregorianCalendar.java
+ojluni/src/main/java/java/util/HashMap.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/HashMap.java
+ojluni/src/main/java/java/util/HashSet.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/HashSet.java
+ojluni/src/main/java/java/util/Hashtable.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Hashtable.java
+ojluni/src/main/java/java/util/HexFormat.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/HexFormat.java
+ojluni/src/main/java/java/util/IdentityHashMap.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/IdentityHashMap.java
+ojluni/src/main/java/java/util/IllegalFormatArgumentIndexException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/IllegalFormatArgumentIndexException.java
+ojluni/src/main/java/java/util/IllegalFormatCodePointException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/IllegalFormatCodePointException.java
+ojluni/src/main/java/java/util/IllegalFormatConversionException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/IllegalFormatConversionException.java
+ojluni/src/main/java/java/util/IllegalFormatException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/IllegalFormatException.java
+ojluni/src/main/java/java/util/IllegalFormatFlagsException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/IllegalFormatFlagsException.java
+ojluni/src/main/java/java/util/IllegalFormatPrecisionException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/IllegalFormatPrecisionException.java
+ojluni/src/main/java/java/util/IllegalFormatWidthException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/IllegalFormatWidthException.java
+ojluni/src/main/java/java/util/IllformedLocaleException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/IllformedLocaleException.java
+ojluni/src/main/java/java/util/ImmutableCollections.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/ImmutableCollections.java
+ojluni/src/main/java/java/util/InputMismatchException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/InputMismatchException.java
+ojluni/src/main/java/java/util/IntSummaryStatistics.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/IntSummaryStatistics.java
+ojluni/src/main/java/java/util/InvalidPropertiesFormatException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/InvalidPropertiesFormatException.java
+ojluni/src/main/java/java/util/Iterator.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Iterator.java
+ojluni/src/main/java/java/util/JapaneseImperialCalendar.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/JapaneseImperialCalendar.java
+ojluni/src/main/java/java/util/JumboEnumSet.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/JumboEnumSet.java
+ojluni/src/main/java/java/util/KeyValueHolder.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/KeyValueHolder.java
+ojluni/src/main/java/java/util/LinkedHashMap.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/LinkedHashMap.java
+ojluni/src/main/java/java/util/LinkedHashSet.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/LinkedHashSet.java
+ojluni/src/main/java/java/util/LinkedList.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/LinkedList.java
+ojluni/src/main/java/java/util/List.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/List.java
+ojluni/src/main/java/java/util/ListIterator.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/ListIterator.java
+ojluni/src/main/java/java/util/ListResourceBundle.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/ListResourceBundle.java
 ojluni/src/main/java/java/util/Locale.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Locale.java
-ojluni/src/main/java/java/util/LocaleISOData.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/LocaleISOData.java
-ojluni/src/main/java/java/util/LongSummaryStatistics.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/LongSummaryStatistics.java
-ojluni/src/main/java/java/util/Map.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Map.java
-ojluni/src/main/java/java/util/MissingFormatArgumentException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/MissingFormatArgumentException.java
-ojluni/src/main/java/java/util/MissingFormatWidthException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/MissingFormatWidthException.java
-ojluni/src/main/java/java/util/MissingResourceException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/MissingResourceException.java
-ojluni/src/main/java/java/util/NavigableMap.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/NavigableMap.java
-ojluni/src/main/java/java/util/NavigableSet.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/NavigableSet.java
-ojluni/src/main/java/java/util/NoSuchElementException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/NoSuchElementException.java
-ojluni/src/main/java/java/util/Objects.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Objects.java
-ojluni/src/main/java/java/util/Observable.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Observable.java
-ojluni/src/main/java/java/util/Observer.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Observer.java
-ojluni/src/main/java/java/util/Optional.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Optional.java
-ojluni/src/main/java/java/util/OptionalDouble.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/OptionalDouble.java
-ojluni/src/main/java/java/util/OptionalInt.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/OptionalInt.java
-ojluni/src/main/java/java/util/OptionalLong.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/OptionalLong.java
-ojluni/src/main/java/java/util/PrimitiveIterator.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/PrimitiveIterator.java
-ojluni/src/main/java/java/util/PriorityQueue.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/PriorityQueue.java
-ojluni/src/main/java/java/util/Properties.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Properties.java
-ojluni/src/main/java/java/util/PropertyPermission.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/PropertyPermission.java
-ojluni/src/main/java/java/util/PropertyResourceBundle.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/PropertyResourceBundle.java
-ojluni/src/main/java/java/util/Queue.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Queue.java
-ojluni/src/main/java/java/util/Random.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Random.java
-ojluni/src/main/java/java/util/RandomAccess.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/RandomAccess.java
-ojluni/src/main/java/java/util/RegularEnumSet.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/RegularEnumSet.java
-ojluni/src/main/java/java/util/ResourceBundle.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/util/ResourceBundle.java
-ojluni/src/main/java/java/util/ReverseOrderDequeView.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/ReverseOrderDequeView.java
-ojluni/src/main/java/java/util/ReverseOrderListView.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/ReverseOrderListView.java
-ojluni/src/main/java/java/util/ReverseOrderSortedMapView.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/ReverseOrderSortedMapView.java
-ojluni/src/main/java/java/util/ReverseOrderSortedSetView.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/ReverseOrderSortedSetView.java
-ojluni/src/main/java/java/util/Scanner.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/Scanner.java
-ojluni/src/main/java/java/util/SequencedCollection.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/SequencedCollection.java
-ojluni/src/main/java/java/util/SequencedMap.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/SequencedMap.java
-ojluni/src/main/java/java/util/SequencedSet.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/SequencedSet.java
-ojluni/src/main/java/java/util/ServiceConfigurationError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/ServiceConfigurationError.java
-ojluni/src/main/java/java/util/ServiceLoader.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/ServiceLoader.java
-ojluni/src/main/java/java/util/Set.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Set.java
-ojluni/src/main/java/java/util/SimpleTimeZone.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/SimpleTimeZone.java
-ojluni/src/main/java/java/util/SortedMap.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/SortedMap.java
-ojluni/src/main/java/java/util/SortedSet.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/SortedSet.java
-ojluni/src/main/java/java/util/Spliterator.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Spliterator.java
-ojluni/src/main/java/java/util/Spliterators.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Spliterators.java
-ojluni/src/main/java/java/util/SplittableRandom.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/SplittableRandom.java
-ojluni/src/main/java/java/util/Stack.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Stack.java
-ojluni/src/main/java/java/util/StringJoiner.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/util/StringJoiner.java
-ojluni/src/main/java/java/util/StringTokenizer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/StringTokenizer.java
-ojluni/src/main/java/java/util/TimSort.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/TimSort.java
-ojluni/src/main/java/java/util/TimeZone.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/TimeZone.java
-ojluni/src/main/java/java/util/Timer.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Timer.java
-ojluni/src/main/java/java/util/TimerTask.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/TimerTask.java
-ojluni/src/main/java/java/util/TooManyListenersException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/TooManyListenersException.java
-ojluni/src/main/java/java/util/TreeMap.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/TreeMap.java
-ojluni/src/main/java/java/util/TreeSet.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/TreeSet.java
-ojluni/src/main/java/java/util/Tripwire.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Tripwire.java
-ojluni/src/main/java/java/util/UUID.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/UUID.java
-ojluni/src/main/java/java/util/UnknownFormatConversionException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/UnknownFormatConversionException.java
-ojluni/src/main/java/java/util/UnknownFormatFlagsException.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/UnknownFormatFlagsException.java
-ojluni/src/main/java/java/util/Vector.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/Vector.java
-ojluni/src/main/java/java/util/WeakHashMap.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/WeakHashMap.java
+ojluni/src/main/java/java/util/LocaleISOData.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/LocaleISOData.java
+ojluni/src/main/java/java/util/LongSummaryStatistics.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/LongSummaryStatistics.java
+ojluni/src/main/java/java/util/Map.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Map.java
+ojluni/src/main/java/java/util/MissingFormatArgumentException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/MissingFormatArgumentException.java
+ojluni/src/main/java/java/util/MissingFormatWidthException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/MissingFormatWidthException.java
+ojluni/src/main/java/java/util/MissingResourceException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/MissingResourceException.java
+ojluni/src/main/java/java/util/NavigableMap.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/NavigableMap.java
+ojluni/src/main/java/java/util/NavigableSet.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/NavigableSet.java
+ojluni/src/main/java/java/util/NoSuchElementException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/NoSuchElementException.java
+ojluni/src/main/java/java/util/Objects.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Objects.java
+ojluni/src/main/java/java/util/Observable.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/Observable.java
+ojluni/src/main/java/java/util/Observer.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Observer.java
+ojluni/src/main/java/java/util/Optional.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Optional.java
+ojluni/src/main/java/java/util/OptionalDouble.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/OptionalDouble.java
+ojluni/src/main/java/java/util/OptionalInt.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/OptionalInt.java
+ojluni/src/main/java/java/util/OptionalLong.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/OptionalLong.java
+ojluni/src/main/java/java/util/PrimitiveIterator.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/PrimitiveIterator.java
+ojluni/src/main/java/java/util/PriorityQueue.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/PriorityQueue.java
+ojluni/src/main/java/java/util/Properties.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/Properties.java
+ojluni/src/main/java/java/util/PropertyPermission.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/PropertyPermission.java
+ojluni/src/main/java/java/util/PropertyResourceBundle.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/PropertyResourceBundle.java
+ojluni/src/main/java/java/util/Queue.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Queue.java
+ojluni/src/main/java/java/util/Random.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Random.java
+ojluni/src/main/java/java/util/RandomAccess.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/RandomAccess.java
+ojluni/src/main/java/java/util/RegularEnumSet.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/RegularEnumSet.java
+ojluni/src/main/java/java/util/ResourceBundle.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/util/ResourceBundle.java
+ojluni/src/main/java/java/util/ReverseOrderDequeView.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/ReverseOrderDequeView.java
+ojluni/src/main/java/java/util/ReverseOrderListView.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/ReverseOrderListView.java
+ojluni/src/main/java/java/util/ReverseOrderSortedMapView.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/ReverseOrderSortedMapView.java
+ojluni/src/main/java/java/util/ReverseOrderSortedSetView.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/ReverseOrderSortedSetView.java
+ojluni/src/main/java/java/util/Scanner.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/Scanner.java
+ojluni/src/main/java/java/util/SequencedCollection.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/SequencedCollection.java
+ojluni/src/main/java/java/util/SequencedMap.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/SequencedMap.java
+ojluni/src/main/java/java/util/SequencedSet.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/SequencedSet.java
+ojluni/src/main/java/java/util/ServiceConfigurationError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/ServiceConfigurationError.java
+ojluni/src/main/java/java/util/ServiceLoader.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/ServiceLoader.java
+ojluni/src/main/java/java/util/Set.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Set.java
+ojluni/src/main/java/java/util/SimpleTimeZone.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/SimpleTimeZone.java
+ojluni/src/main/java/java/util/SortedMap.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/SortedMap.java
+ojluni/src/main/java/java/util/SortedSet.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/SortedSet.java
+ojluni/src/main/java/java/util/Spliterator.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Spliterator.java
+ojluni/src/main/java/java/util/Spliterators.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Spliterators.java
+ojluni/src/main/java/java/util/SplittableRandom.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/SplittableRandom.java
+ojluni/src/main/java/java/util/Stack.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Stack.java
+ojluni/src/main/java/java/util/StringJoiner.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/util/StringJoiner.java
+ojluni/src/main/java/java/util/StringTokenizer.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/StringTokenizer.java
+ojluni/src/main/java/java/util/TimSort.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/TimSort.java
+ojluni/src/main/java/java/util/TimeZone.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/TimeZone.java
+ojluni/src/main/java/java/util/Timer.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Timer.java
+ojluni/src/main/java/java/util/TimerTask.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/TimerTask.java
+ojluni/src/main/java/java/util/TooManyListenersException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/TooManyListenersException.java
+ojluni/src/main/java/java/util/TreeMap.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/TreeMap.java
+ojluni/src/main/java/java/util/TreeSet.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/TreeSet.java
+ojluni/src/main/java/java/util/Tripwire.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Tripwire.java
+ojluni/src/main/java/java/util/UUID.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/UUID.java
+ojluni/src/main/java/java/util/UnknownFormatConversionException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/UnknownFormatConversionException.java
+ojluni/src/main/java/java/util/UnknownFormatFlagsException.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/UnknownFormatFlagsException.java
+ojluni/src/main/java/java/util/Vector.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/Vector.java
+ojluni/src/main/java/java/util/WeakHashMap.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/WeakHashMap.java
 ojluni/src/main/java/java/util/XMLUtils.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/java/util/XMLUtils.java
-ojluni/src/main/java/java/util/concurrent/AbstractExecutorService.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/AbstractExecutorService.java
-ojluni/src/main/java/java/util/concurrent/ArrayBlockingQueue.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/ArrayBlockingQueue.java
-ojluni/src/main/java/java/util/concurrent/BlockingDeque.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/BlockingDeque.java
-ojluni/src/main/java/java/util/concurrent/BlockingQueue.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/BlockingQueue.java
-ojluni/src/main/java/java/util/concurrent/BrokenBarrierException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/BrokenBarrierException.java
-ojluni/src/main/java/java/util/concurrent/Callable.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/Callable.java
-ojluni/src/main/java/java/util/concurrent/CancellationException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/CancellationException.java
-ojluni/src/main/java/java/util/concurrent/CompletableFuture.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/CompletableFuture.java
-ojluni/src/main/java/java/util/concurrent/CompletionException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/CompletionException.java
-ojluni/src/main/java/java/util/concurrent/CompletionService.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/CompletionService.java
-ojluni/src/main/java/java/util/concurrent/CompletionStage.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/CompletionStage.java
-ojluni/src/main/java/java/util/concurrent/ConcurrentHashMap.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java
-ojluni/src/main/java/java/util/concurrent/ConcurrentLinkedDeque.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/ConcurrentLinkedDeque.java
-ojluni/src/main/java/java/util/concurrent/ConcurrentLinkedQueue.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/ConcurrentLinkedQueue.java
-ojluni/src/main/java/java/util/concurrent/ConcurrentMap.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/ConcurrentMap.java
-ojluni/src/main/java/java/util/concurrent/ConcurrentNavigableMap.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/ConcurrentNavigableMap.java
-ojluni/src/main/java/java/util/concurrent/ConcurrentSkipListMap.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/ConcurrentSkipListMap.java
-ojluni/src/main/java/java/util/concurrent/ConcurrentSkipListSet.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/ConcurrentSkipListSet.java
-ojluni/src/main/java/java/util/concurrent/CopyOnWriteArrayList.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/CopyOnWriteArrayList.java
-ojluni/src/main/java/java/util/concurrent/CopyOnWriteArraySet.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/CopyOnWriteArraySet.java
-ojluni/src/main/java/java/util/concurrent/CountDownLatch.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/CountDownLatch.java
-ojluni/src/main/java/java/util/concurrent/CountedCompleter.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/CountedCompleter.java
-ojluni/src/main/java/java/util/concurrent/CyclicBarrier.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/CyclicBarrier.java
-ojluni/src/main/java/java/util/concurrent/DelayQueue.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/DelayQueue.java
-ojluni/src/main/java/java/util/concurrent/Delayed.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/Delayed.java
-ojluni/src/main/java/java/util/concurrent/Exchanger.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/Exchanger.java
-ojluni/src/main/java/java/util/concurrent/ExecutionException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/ExecutionException.java
-ojluni/src/main/java/java/util/concurrent/Executor.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/Executor.java
-ojluni/src/main/java/java/util/concurrent/ExecutorCompletionService.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/ExecutorCompletionService.java
-ojluni/src/main/java/java/util/concurrent/ExecutorService.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/ExecutorService.java
-ojluni/src/main/java/java/util/concurrent/Executors.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/Executors.java
-ojluni/src/main/java/java/util/concurrent/Flow.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/Flow.java
-ojluni/src/main/java/java/util/concurrent/ForkJoinPool.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/ForkJoinPool.java
-ojluni/src/main/java/java/util/concurrent/ForkJoinTask.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/ForkJoinTask.java
-ojluni/src/main/java/java/util/concurrent/ForkJoinWorkerThread.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/ForkJoinWorkerThread.java
-ojluni/src/main/java/java/util/concurrent/Future.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/Future.java
-ojluni/src/main/java/java/util/concurrent/FutureTask.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/FutureTask.java
-ojluni/src/main/java/java/util/concurrent/Helpers.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/Helpers.java
-ojluni/src/main/java/java/util/concurrent/LinkedBlockingDeque.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/LinkedBlockingDeque.java
-ojluni/src/main/java/java/util/concurrent/LinkedBlockingQueue.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/LinkedBlockingQueue.java
-ojluni/src/main/java/java/util/concurrent/LinkedTransferQueue.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/LinkedTransferQueue.java
-ojluni/src/main/java/java/util/concurrent/Phaser.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/Phaser.java
-ojluni/src/main/java/java/util/concurrent/PriorityBlockingQueue.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/PriorityBlockingQueue.java
-ojluni/src/main/java/java/util/concurrent/RecursiveAction.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/RecursiveAction.java
-ojluni/src/main/java/java/util/concurrent/RecursiveTask.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/RecursiveTask.java
-ojluni/src/main/java/java/util/concurrent/RejectedExecutionException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/RejectedExecutionException.java
-ojluni/src/main/java/java/util/concurrent/RejectedExecutionHandler.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/RejectedExecutionHandler.java
-ojluni/src/main/java/java/util/concurrent/RunnableFuture.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/RunnableFuture.java
-ojluni/src/main/java/java/util/concurrent/RunnableScheduledFuture.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/RunnableScheduledFuture.java
-ojluni/src/main/java/java/util/concurrent/ScheduledExecutorService.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/ScheduledExecutorService.java
-ojluni/src/main/java/java/util/concurrent/ScheduledFuture.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/ScheduledFuture.java
-ojluni/src/main/java/java/util/concurrent/ScheduledThreadPoolExecutor.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/ScheduledThreadPoolExecutor.java
-ojluni/src/main/java/java/util/concurrent/Semaphore.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/Semaphore.java
-ojluni/src/main/java/java/util/concurrent/SubmissionPublisher.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/SubmissionPublisher.java
-ojluni/src/main/java/java/util/concurrent/SynchronousQueue.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/SynchronousQueue.java
-ojluni/src/main/java/java/util/concurrent/ThreadFactory.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/ThreadFactory.java
-ojluni/src/main/java/java/util/concurrent/ThreadLocalRandom.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/ThreadLocalRandom.java
-ojluni/src/main/java/java/util/concurrent/ThreadPoolExecutor.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/ThreadPoolExecutor.java
-ojluni/src/main/java/java/util/concurrent/TimeUnit.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/TimeUnit.java
-ojluni/src/main/java/java/util/concurrent/TimeoutException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/TimeoutException.java
-ojluni/src/main/java/java/util/concurrent/TransferQueue.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/TransferQueue.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicBoolean.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicBoolean.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicInteger.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicInteger.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicIntegerArray.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicIntegerArray.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicIntegerFieldUpdater.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicIntegerFieldUpdater.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicLong.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicLong.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicLongArray.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicLongArray.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicLongFieldUpdater.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicLongFieldUpdater.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicMarkableReference.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicMarkableReference.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicReference.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicReference.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicReferenceArray.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicReferenceArray.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicReferenceFieldUpdater.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicReferenceFieldUpdater.java
-ojluni/src/main/java/java/util/concurrent/atomic/AtomicStampedReference.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicStampedReference.java
-ojluni/src/main/java/java/util/concurrent/atomic/DoubleAccumulator.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/atomic/DoubleAccumulator.java
-ojluni/src/main/java/java/util/concurrent/atomic/DoubleAdder.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/atomic/DoubleAdder.java
-ojluni/src/main/java/java/util/concurrent/atomic/LongAccumulator.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/atomic/LongAccumulator.java
-ojluni/src/main/java/java/util/concurrent/atomic/LongAdder.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/atomic/LongAdder.java
-ojluni/src/main/java/java/util/concurrent/atomic/Striped64.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/atomic/Striped64.java
-ojluni/src/main/java/java/util/concurrent/atomic/package-info.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/atomic/package-info.java
-ojluni/src/main/java/java/util/concurrent/locks/AbstractOwnableSynchronizer.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/locks/AbstractOwnableSynchronizer.java
-ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java
-ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedSynchronizer.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java
-ojluni/src/main/java/java/util/concurrent/locks/Condition.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/locks/Condition.java
-ojluni/src/main/java/java/util/concurrent/locks/Lock.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/locks/Lock.java
-ojluni/src/main/java/java/util/concurrent/locks/LockSupport.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/locks/LockSupport.java
-ojluni/src/main/java/java/util/concurrent/locks/ReadWriteLock.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/locks/ReadWriteLock.java
-ojluni/src/main/java/java/util/concurrent/locks/ReentrantLock.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/locks/ReentrantLock.java
-ojluni/src/main/java/java/util/concurrent/locks/ReentrantReadWriteLock.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/locks/ReentrantReadWriteLock.java
-ojluni/src/main/java/java/util/concurrent/locks/StampedLock.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/locks/StampedLock.java
-ojluni/src/main/java/java/util/concurrent/locks/package-info.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/locks/package-info.java
-ojluni/src/main/java/java/util/concurrent/package-info.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/concurrent/package-info.java
-ojluni/src/main/java/java/util/function/BiConsumer.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/BiConsumer.java
-ojluni/src/main/java/java/util/function/BiFunction.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/BiFunction.java
-ojluni/src/main/java/java/util/function/BiPredicate.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/BiPredicate.java
-ojluni/src/main/java/java/util/function/BinaryOperator.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/BinaryOperator.java
-ojluni/src/main/java/java/util/function/BooleanSupplier.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/BooleanSupplier.java
-ojluni/src/main/java/java/util/function/Consumer.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/Consumer.java
-ojluni/src/main/java/java/util/function/DoubleBinaryOperator.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/DoubleBinaryOperator.java
-ojluni/src/main/java/java/util/function/DoubleConsumer.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/DoubleConsumer.java
-ojluni/src/main/java/java/util/function/DoubleFunction.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/DoubleFunction.java
-ojluni/src/main/java/java/util/function/DoublePredicate.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/DoublePredicate.java
-ojluni/src/main/java/java/util/function/DoubleSupplier.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/DoubleSupplier.java
-ojluni/src/main/java/java/util/function/DoubleToIntFunction.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/DoubleToIntFunction.java
-ojluni/src/main/java/java/util/function/DoubleToLongFunction.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/DoubleToLongFunction.java
-ojluni/src/main/java/java/util/function/DoubleUnaryOperator.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/DoubleUnaryOperator.java
-ojluni/src/main/java/java/util/function/Function.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/Function.java
-ojluni/src/main/java/java/util/function/IntBinaryOperator.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/IntBinaryOperator.java
-ojluni/src/main/java/java/util/function/IntConsumer.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/IntConsumer.java
-ojluni/src/main/java/java/util/function/IntFunction.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/IntFunction.java
-ojluni/src/main/java/java/util/function/IntPredicate.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/IntPredicate.java
-ojluni/src/main/java/java/util/function/IntSupplier.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/IntSupplier.java
-ojluni/src/main/java/java/util/function/IntToDoubleFunction.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/IntToDoubleFunction.java
-ojluni/src/main/java/java/util/function/IntToLongFunction.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/IntToLongFunction.java
-ojluni/src/main/java/java/util/function/IntUnaryOperator.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/IntUnaryOperator.java
-ojluni/src/main/java/java/util/function/LongBinaryOperator.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/LongBinaryOperator.java
-ojluni/src/main/java/java/util/function/LongConsumer.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/LongConsumer.java
-ojluni/src/main/java/java/util/function/LongFunction.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/LongFunction.java
-ojluni/src/main/java/java/util/function/LongPredicate.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/LongPredicate.java
-ojluni/src/main/java/java/util/function/LongSupplier.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/LongSupplier.java
-ojluni/src/main/java/java/util/function/LongToDoubleFunction.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/LongToDoubleFunction.java
-ojluni/src/main/java/java/util/function/LongToIntFunction.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/LongToIntFunction.java
-ojluni/src/main/java/java/util/function/LongUnaryOperator.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/LongUnaryOperator.java
-ojluni/src/main/java/java/util/function/ObjDoubleConsumer.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/ObjDoubleConsumer.java
-ojluni/src/main/java/java/util/function/ObjIntConsumer.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/ObjIntConsumer.java
-ojluni/src/main/java/java/util/function/ObjLongConsumer.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/ObjLongConsumer.java
-ojluni/src/main/java/java/util/function/Predicate.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/Predicate.java
-ojluni/src/main/java/java/util/function/Supplier.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/Supplier.java
-ojluni/src/main/java/java/util/function/ToDoubleBiFunction.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/ToDoubleBiFunction.java
-ojluni/src/main/java/java/util/function/ToDoubleFunction.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/ToDoubleFunction.java
-ojluni/src/main/java/java/util/function/ToIntBiFunction.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/ToIntBiFunction.java
-ojluni/src/main/java/java/util/function/ToIntFunction.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/ToIntFunction.java
-ojluni/src/main/java/java/util/function/ToLongBiFunction.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/ToLongBiFunction.java
-ojluni/src/main/java/java/util/function/ToLongFunction.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/ToLongFunction.java
-ojluni/src/main/java/java/util/function/UnaryOperator.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/UnaryOperator.java
-ojluni/src/main/java/java/util/function/package-info.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/function/package-info.java
-ojluni/src/main/java/java/util/jar/Attributes.java,jdk17u/jdk-17.0.5-ga,src/java.base/share/classes/java/util/jar/Attributes.java
-ojluni/src/main/java/java/util/jar/JarEntry.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/util/jar/JarEntry.java
-ojluni/src/main/java/java/util/jar/JarException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/util/jar/JarException.java
+ojluni/src/main/java/java/util/concurrent/AbstractExecutorService.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/AbstractExecutorService.java
+ojluni/src/main/java/java/util/concurrent/ArrayBlockingQueue.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/ArrayBlockingQueue.java
+ojluni/src/main/java/java/util/concurrent/BlockingDeque.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/BlockingDeque.java
+ojluni/src/main/java/java/util/concurrent/BlockingQueue.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/BlockingQueue.java
+ojluni/src/main/java/java/util/concurrent/BrokenBarrierException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/BrokenBarrierException.java
+ojluni/src/main/java/java/util/concurrent/Callable.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/Callable.java
+ojluni/src/main/java/java/util/concurrent/CancellationException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/CancellationException.java
+ojluni/src/main/java/java/util/concurrent/CompletableFuture.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/CompletableFuture.java
+ojluni/src/main/java/java/util/concurrent/CompletionException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/CompletionException.java
+ojluni/src/main/java/java/util/concurrent/CompletionService.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/CompletionService.java
+ojluni/src/main/java/java/util/concurrent/CompletionStage.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/CompletionStage.java
+ojluni/src/main/java/java/util/concurrent/ConcurrentHashMap.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java
+ojluni/src/main/java/java/util/concurrent/ConcurrentLinkedDeque.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/ConcurrentLinkedDeque.java
+ojluni/src/main/java/java/util/concurrent/ConcurrentLinkedQueue.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/ConcurrentLinkedQueue.java
+ojluni/src/main/java/java/util/concurrent/ConcurrentMap.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/ConcurrentMap.java
+ojluni/src/main/java/java/util/concurrent/ConcurrentNavigableMap.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/ConcurrentNavigableMap.java
+ojluni/src/main/java/java/util/concurrent/ConcurrentSkipListMap.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/ConcurrentSkipListMap.java
+ojluni/src/main/java/java/util/concurrent/ConcurrentSkipListSet.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/ConcurrentSkipListSet.java
+ojluni/src/main/java/java/util/concurrent/CopyOnWriteArrayList.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/CopyOnWriteArrayList.java
+ojluni/src/main/java/java/util/concurrent/CopyOnWriteArraySet.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/CopyOnWriteArraySet.java
+ojluni/src/main/java/java/util/concurrent/CountDownLatch.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/CountDownLatch.java
+ojluni/src/main/java/java/util/concurrent/CountedCompleter.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/CountedCompleter.java
+ojluni/src/main/java/java/util/concurrent/CyclicBarrier.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/CyclicBarrier.java
+ojluni/src/main/java/java/util/concurrent/DelayQueue.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/DelayQueue.java
+ojluni/src/main/java/java/util/concurrent/Delayed.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/Delayed.java
+ojluni/src/main/java/java/util/concurrent/Exchanger.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/Exchanger.java
+ojluni/src/main/java/java/util/concurrent/ExecutionException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/ExecutionException.java
+ojluni/src/main/java/java/util/concurrent/Executor.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/Executor.java
+ojluni/src/main/java/java/util/concurrent/ExecutorCompletionService.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/ExecutorCompletionService.java
+ojluni/src/main/java/java/util/concurrent/ExecutorService.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/ExecutorService.java
+ojluni/src/main/java/java/util/concurrent/Executors.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/Executors.java
+ojluni/src/main/java/java/util/concurrent/Flow.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/Flow.java
+ojluni/src/main/java/java/util/concurrent/ForkJoinPool.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/ForkJoinPool.java
+ojluni/src/main/java/java/util/concurrent/ForkJoinTask.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/ForkJoinTask.java
+ojluni/src/main/java/java/util/concurrent/ForkJoinWorkerThread.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/ForkJoinWorkerThread.java
+ojluni/src/main/java/java/util/concurrent/Future.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/Future.java
+ojluni/src/main/java/java/util/concurrent/FutureTask.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/FutureTask.java
+ojluni/src/main/java/java/util/concurrent/Helpers.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/Helpers.java
+ojluni/src/main/java/java/util/concurrent/LinkedBlockingDeque.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/LinkedBlockingDeque.java
+ojluni/src/main/java/java/util/concurrent/LinkedBlockingQueue.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/LinkedBlockingQueue.java
+ojluni/src/main/java/java/util/concurrent/LinkedTransferQueue.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/LinkedTransferQueue.java
+ojluni/src/main/java/java/util/concurrent/Phaser.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/Phaser.java
+ojluni/src/main/java/java/util/concurrent/PriorityBlockingQueue.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/PriorityBlockingQueue.java
+ojluni/src/main/java/java/util/concurrent/RecursiveAction.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/RecursiveAction.java
+ojluni/src/main/java/java/util/concurrent/RecursiveTask.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/RecursiveTask.java
+ojluni/src/main/java/java/util/concurrent/RejectedExecutionException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/RejectedExecutionException.java
+ojluni/src/main/java/java/util/concurrent/RejectedExecutionHandler.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/RejectedExecutionHandler.java
+ojluni/src/main/java/java/util/concurrent/RunnableFuture.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/RunnableFuture.java
+ojluni/src/main/java/java/util/concurrent/RunnableScheduledFuture.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/RunnableScheduledFuture.java
+ojluni/src/main/java/java/util/concurrent/ScheduledExecutorService.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/ScheduledExecutorService.java
+ojluni/src/main/java/java/util/concurrent/ScheduledFuture.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/ScheduledFuture.java
+ojluni/src/main/java/java/util/concurrent/ScheduledThreadPoolExecutor.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/ScheduledThreadPoolExecutor.java
+ojluni/src/main/java/java/util/concurrent/Semaphore.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/Semaphore.java
+ojluni/src/main/java/java/util/concurrent/StructureViolationException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/StructureViolationException.java
+ojluni/src/main/java/java/util/concurrent/SubmissionPublisher.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/SubmissionPublisher.java
+ojluni/src/main/java/java/util/concurrent/SynchronousQueue.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/SynchronousQueue.java
+ojluni/src/main/java/java/util/concurrent/ThreadFactory.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/ThreadFactory.java
+ojluni/src/main/java/java/util/concurrent/ThreadLocalRandom.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/ThreadLocalRandom.java
+ojluni/src/main/java/java/util/concurrent/ThreadPoolExecutor.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/ThreadPoolExecutor.java
+ojluni/src/main/java/java/util/concurrent/TimeUnit.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/TimeUnit.java
+ojluni/src/main/java/java/util/concurrent/TimeoutException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/TimeoutException.java
+ojluni/src/main/java/java/util/concurrent/TransferQueue.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/TransferQueue.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicBoolean.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicBoolean.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicInteger.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicInteger.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicIntegerArray.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicIntegerArray.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicIntegerFieldUpdater.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicIntegerFieldUpdater.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicLong.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicLong.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicLongArray.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicLongArray.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicLongFieldUpdater.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicLongFieldUpdater.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicMarkableReference.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicMarkableReference.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicReference.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicReference.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicReferenceArray.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicReferenceArray.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicReferenceFieldUpdater.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicReferenceFieldUpdater.java
+ojluni/src/main/java/java/util/concurrent/atomic/AtomicStampedReference.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/AtomicStampedReference.java
+ojluni/src/main/java/java/util/concurrent/atomic/DoubleAccumulator.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/DoubleAccumulator.java
+ojluni/src/main/java/java/util/concurrent/atomic/DoubleAdder.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/DoubleAdder.java
+ojluni/src/main/java/java/util/concurrent/atomic/LongAccumulator.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/LongAccumulator.java
+ojluni/src/main/java/java/util/concurrent/atomic/LongAdder.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/LongAdder.java
+ojluni/src/main/java/java/util/concurrent/atomic/Striped64.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/Striped64.java
+ojluni/src/main/java/java/util/concurrent/atomic/package-info.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/atomic/package-info.java
+ojluni/src/main/java/java/util/concurrent/locks/AbstractOwnableSynchronizer.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/locks/AbstractOwnableSynchronizer.java
+ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java
+ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedSynchronizer.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java
+ojluni/src/main/java/java/util/concurrent/locks/Condition.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/locks/Condition.java
+ojluni/src/main/java/java/util/concurrent/locks/Lock.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/locks/Lock.java
+ojluni/src/main/java/java/util/concurrent/locks/LockSupport.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/locks/LockSupport.java
+ojluni/src/main/java/java/util/concurrent/locks/ReadWriteLock.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/locks/ReadWriteLock.java
+ojluni/src/main/java/java/util/concurrent/locks/ReentrantLock.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/locks/ReentrantLock.java
+ojluni/src/main/java/java/util/concurrent/locks/ReentrantReadWriteLock.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/locks/ReentrantReadWriteLock.java
+ojluni/src/main/java/java/util/concurrent/locks/StampedLock.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/locks/StampedLock.java
+ojluni/src/main/java/java/util/concurrent/locks/package-info.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/locks/package-info.java
+ojluni/src/main/java/java/util/concurrent/package-info.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/concurrent/package-info.java
+ojluni/src/main/java/java/util/function/BiConsumer.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/BiConsumer.java
+ojluni/src/main/java/java/util/function/BiFunction.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/BiFunction.java
+ojluni/src/main/java/java/util/function/BiPredicate.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/BiPredicate.java
+ojluni/src/main/java/java/util/function/BinaryOperator.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/BinaryOperator.java
+ojluni/src/main/java/java/util/function/BooleanSupplier.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/BooleanSupplier.java
+ojluni/src/main/java/java/util/function/Consumer.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/Consumer.java
+ojluni/src/main/java/java/util/function/DoubleBinaryOperator.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/DoubleBinaryOperator.java
+ojluni/src/main/java/java/util/function/DoubleConsumer.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/DoubleConsumer.java
+ojluni/src/main/java/java/util/function/DoubleFunction.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/DoubleFunction.java
+ojluni/src/main/java/java/util/function/DoublePredicate.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/DoublePredicate.java
+ojluni/src/main/java/java/util/function/DoubleSupplier.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/DoubleSupplier.java
+ojluni/src/main/java/java/util/function/DoubleToIntFunction.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/DoubleToIntFunction.java
+ojluni/src/main/java/java/util/function/DoubleToLongFunction.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/DoubleToLongFunction.java
+ojluni/src/main/java/java/util/function/DoubleUnaryOperator.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/DoubleUnaryOperator.java
+ojluni/src/main/java/java/util/function/Function.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/Function.java
+ojluni/src/main/java/java/util/function/IntBinaryOperator.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/IntBinaryOperator.java
+ojluni/src/main/java/java/util/function/IntConsumer.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/IntConsumer.java
+ojluni/src/main/java/java/util/function/IntFunction.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/IntFunction.java
+ojluni/src/main/java/java/util/function/IntPredicate.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/IntPredicate.java
+ojluni/src/main/java/java/util/function/IntSupplier.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/IntSupplier.java
+ojluni/src/main/java/java/util/function/IntToDoubleFunction.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/IntToDoubleFunction.java
+ojluni/src/main/java/java/util/function/IntToLongFunction.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/IntToLongFunction.java
+ojluni/src/main/java/java/util/function/IntUnaryOperator.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/IntUnaryOperator.java
+ojluni/src/main/java/java/util/function/LongBinaryOperator.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/LongBinaryOperator.java
+ojluni/src/main/java/java/util/function/LongConsumer.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/LongConsumer.java
+ojluni/src/main/java/java/util/function/LongFunction.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/LongFunction.java
+ojluni/src/main/java/java/util/function/LongPredicate.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/LongPredicate.java
+ojluni/src/main/java/java/util/function/LongSupplier.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/LongSupplier.java
+ojluni/src/main/java/java/util/function/LongToDoubleFunction.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/LongToDoubleFunction.java
+ojluni/src/main/java/java/util/function/LongToIntFunction.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/LongToIntFunction.java
+ojluni/src/main/java/java/util/function/LongUnaryOperator.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/LongUnaryOperator.java
+ojluni/src/main/java/java/util/function/ObjDoubleConsumer.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/ObjDoubleConsumer.java
+ojluni/src/main/java/java/util/function/ObjIntConsumer.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/ObjIntConsumer.java
+ojluni/src/main/java/java/util/function/ObjLongConsumer.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/ObjLongConsumer.java
+ojluni/src/main/java/java/util/function/Predicate.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/Predicate.java
+ojluni/src/main/java/java/util/function/Supplier.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/Supplier.java
+ojluni/src/main/java/java/util/function/ToDoubleBiFunction.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/ToDoubleBiFunction.java
+ojluni/src/main/java/java/util/function/ToDoubleFunction.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/ToDoubleFunction.java
+ojluni/src/main/java/java/util/function/ToIntBiFunction.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/ToIntBiFunction.java
+ojluni/src/main/java/java/util/function/ToIntFunction.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/ToIntFunction.java
+ojluni/src/main/java/java/util/function/ToLongBiFunction.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/ToLongBiFunction.java
+ojluni/src/main/java/java/util/function/ToLongFunction.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/ToLongFunction.java
+ojluni/src/main/java/java/util/function/UnaryOperator.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/UnaryOperator.java
+ojluni/src/main/java/java/util/function/package-info.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/function/package-info.java
+ojluni/src/main/java/java/util/jar/Attributes.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/jar/Attributes.java
+ojluni/src/main/java/java/util/jar/JarEntry.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/util/jar/JarEntry.java
+ojluni/src/main/java/java/util/jar/JarException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/util/jar/JarException.java
 ojluni/src/main/java/java/util/jar/JarFile.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/jar/JarFile.java
 ojluni/src/main/java/java/util/jar/JarInputStream.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/jar/JarInputStream.java
-ojluni/src/main/java/java/util/jar/JarOutputStream.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/java/util/jar/JarOutputStream.java
+ojluni/src/main/java/java/util/jar/JarOutputStream.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/java/util/jar/JarOutputStream.java
 ojluni/src/main/java/java/util/jar/JarVerifier.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/jar/JarVerifier.java
-ojluni/src/main/java/java/util/jar/Manifest.java,jdk17u/jdk-17.0.5-ga,src/java.base/share/classes/java/util/jar/Manifest.java
+ojluni/src/main/java/java/util/jar/Manifest.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/jar/Manifest.java
 ojluni/src/main/java/java/util/jar/Pack200.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/jar/Pack200.java
-ojluni/src/main/java/java/util/jar/package-info.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/jar/package-info.java
+ojluni/src/main/java/java/util/jar/package-info.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/jar/package-info.java
 ojluni/src/main/java/java/util/logging/ConsoleHandler.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/logging/ConsoleHandler.java
-ojluni/src/main/java/java/util/logging/ErrorManager.java,jdk11u/jdk-11.0.13-ga,src/java.logging/share/classes/java/util/logging/ErrorManager.java
+ojluni/src/main/java/java/util/logging/ErrorManager.java,jdk11u/jdk-11.0.26-ga,src/java.logging/share/classes/java/util/logging/ErrorManager.java
 ojluni/src/main/java/java/util/logging/FileHandler.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/logging/FileHandler.java
-ojluni/src/main/java/java/util/logging/Filter.java,jdk21u/jdk-21.0.4-ga,src/java.logging/share/classes/java/util/logging/Filter.java
+ojluni/src/main/java/java/util/logging/Filter.java,jdk21u/jdk-21.0.6-ga,src/java.logging/share/classes/java/util/logging/Filter.java
 ojluni/src/main/java/java/util/logging/Formatter.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/logging/Formatter.java
 ojluni/src/main/java/java/util/logging/Handler.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/logging/Handler.java
 ojluni/src/main/java/java/util/logging/Level.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/logging/Level.java
@@ -1181,195 +1184,199 @@ ojluni/src/main/java/java/util/logging/LogRecord.java,jdk8u/jdk8u121-b13,jdk/src
 ojluni/src/main/java/java/util/logging/Logger.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/logging/Logger.java
 ojluni/src/main/java/java/util/logging/Logging.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/logging/Logging.java
 ojluni/src/main/java/java/util/logging/LoggingMXBean.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/logging/LoggingMXBean.java
-ojluni/src/main/java/java/util/logging/LoggingPermission.java,jdk21u/jdk-21.0.4-ga,src/java.logging/share/classes/java/util/logging/LoggingPermission.java
+ojluni/src/main/java/java/util/logging/LoggingPermission.java,jdk21u/jdk-21.0.6-ga,src/java.logging/share/classes/java/util/logging/LoggingPermission.java
 ojluni/src/main/java/java/util/logging/LoggingProxyImpl.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/logging/LoggingProxyImpl.java
 ojluni/src/main/java/java/util/logging/MemoryHandler.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/logging/MemoryHandler.java
 ojluni/src/main/java/java/util/logging/SimpleFormatter.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/logging/SimpleFormatter.java
 ojluni/src/main/java/java/util/logging/SocketHandler.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/logging/SocketHandler.java
 ojluni/src/main/java/java/util/logging/StreamHandler.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/logging/StreamHandler.java
 ojluni/src/main/java/java/util/logging/XMLFormatter.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/logging/XMLFormatter.java
-ojluni/src/main/java/java/util/logging/package-info.java,jdk21u/jdk-21.0.4-ga,src/java.logging/share/classes/java/util/logging/package-info.java
-ojluni/src/main/java/java/util/package-info.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/package-info.java
+ojluni/src/main/java/java/util/logging/package-info.java,jdk21u/jdk-21.0.6-ga,src/java.logging/share/classes/java/util/logging/package-info.java
+ojluni/src/main/java/java/util/package-info.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/package-info.java
 ojluni/src/main/java/java/util/prefs/AbstractPreferences.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/prefs/AbstractPreferences.java
-ojluni/src/main/java/java/util/prefs/BackingStoreException.java,jdk21u/jdk-21.0.4-ga,src/java.prefs/share/classes/java/util/prefs/BackingStoreException.java
+ojluni/src/main/java/java/util/prefs/BackingStoreException.java,jdk21u/jdk-21.0.6-ga,src/java.prefs/share/classes/java/util/prefs/BackingStoreException.java
 ojluni/src/main/java/java/util/prefs/Base64.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/prefs/Base64.java
 ojluni/src/main/java/java/util/prefs/FileSystemPreferences.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/java/util/prefs/FileSystemPreferences.java
 ojluni/src/main/java/java/util/prefs/FileSystemPreferencesFactory.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/java/util/prefs/FileSystemPreferencesFactory.java
-ojluni/src/main/java/java/util/prefs/InvalidPreferencesFormatException.java,jdk21u/jdk-21.0.4-ga,src/java.prefs/share/classes/java/util/prefs/InvalidPreferencesFormatException.java
+ojluni/src/main/java/java/util/prefs/InvalidPreferencesFormatException.java,jdk21u/jdk-21.0.6-ga,src/java.prefs/share/classes/java/util/prefs/InvalidPreferencesFormatException.java
 ojluni/src/main/java/java/util/prefs/NodeChangeEvent.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/prefs/NodeChangeEvent.java
-ojluni/src/main/java/java/util/prefs/NodeChangeListener.java,jdk21u/jdk-21.0.4-ga,src/java.prefs/share/classes/java/util/prefs/NodeChangeListener.java
+ojluni/src/main/java/java/util/prefs/NodeChangeListener.java,jdk21u/jdk-21.0.6-ga,src/java.prefs/share/classes/java/util/prefs/NodeChangeListener.java
 ojluni/src/main/java/java/util/prefs/PreferenceChangeEvent.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/prefs/PreferenceChangeEvent.java
 ojluni/src/main/java/java/util/prefs/PreferenceChangeListener.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/prefs/PreferenceChangeListener.java
 ojluni/src/main/java/java/util/prefs/Preferences.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/prefs/Preferences.java
 ojluni/src/main/java/java/util/prefs/PreferencesFactory.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/prefs/PreferencesFactory.java
 ojluni/src/main/java/java/util/prefs/XmlSupport.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/java/util/prefs/XmlSupport.java
-ojluni/src/main/java/java/util/prefs/package-info.java,jdk21u/jdk-21.0.4-ga,src/java.prefs/share/classes/java/util/prefs/package-info.java
-ojluni/src/main/java/java/util/random/RandomGenerator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/random/RandomGenerator.java
-ojluni/src/main/java/java/util/random/RandomGeneratorFactory.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/random/RandomGeneratorFactory.java
-ojluni/src/main/java/java/util/random/package-info.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/random/package-info.java
-ojluni/src/main/java/java/util/regex/ASCII.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/regex/ASCII.java
-ojluni/src/main/java/java/util/regex/MatchResult.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/regex/MatchResult.java
-ojluni/src/main/java/java/util/regex/Matcher.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/regex/Matcher.java
-ojluni/src/main/java/java/util/regex/Pattern.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/regex/Pattern.java
-ojluni/src/main/java/java/util/regex/PatternSyntaxException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/regex/PatternSyntaxException.java
-ojluni/src/main/java/java/util/regex/package-info.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/regex/package-info.java
-ojluni/src/main/java/java/util/stream/AbstractPipeline.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/AbstractPipeline.java
-ojluni/src/main/java/java/util/stream/AbstractShortCircuitTask.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/AbstractShortCircuitTask.java
-ojluni/src/main/java/java/util/stream/AbstractSpinedBuffer.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/AbstractSpinedBuffer.java
-ojluni/src/main/java/java/util/stream/AbstractTask.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/AbstractTask.java
-ojluni/src/main/java/java/util/stream/BaseStream.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/BaseStream.java
-ojluni/src/main/java/java/util/stream/Collector.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/Collector.java
-ojluni/src/main/java/java/util/stream/Collectors.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/Collectors.java
-ojluni/src/main/java/java/util/stream/DistinctOps.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/DistinctOps.java
-ojluni/src/main/java/java/util/stream/DoublePipeline.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/DoublePipeline.java
-ojluni/src/main/java/java/util/stream/DoubleStream.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/DoubleStream.java
-ojluni/src/main/java/java/util/stream/FindOps.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/FindOps.java
-ojluni/src/main/java/java/util/stream/ForEachOps.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/ForEachOps.java
-ojluni/src/main/java/java/util/stream/IntPipeline.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/IntPipeline.java
-ojluni/src/main/java/java/util/stream/IntStream.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/IntStream.java
-ojluni/src/main/java/java/util/stream/LongPipeline.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/LongPipeline.java
-ojluni/src/main/java/java/util/stream/LongStream.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/LongStream.java
-ojluni/src/main/java/java/util/stream/MatchOps.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/MatchOps.java
-ojluni/src/main/java/java/util/stream/Node.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/Node.java
-ojluni/src/main/java/java/util/stream/Nodes.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/Nodes.java
-ojluni/src/main/java/java/util/stream/PipelineHelper.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/PipelineHelper.java
-ojluni/src/main/java/java/util/stream/ReduceOps.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/ReduceOps.java
-ojluni/src/main/java/java/util/stream/ReferencePipeline.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/ReferencePipeline.java
-ojluni/src/main/java/java/util/stream/Sink.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/Sink.java
-ojluni/src/main/java/java/util/stream/SliceOps.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/SliceOps.java
-ojluni/src/main/java/java/util/stream/SortedOps.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/SortedOps.java
-ojluni/src/main/java/java/util/stream/SpinedBuffer.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/SpinedBuffer.java
-ojluni/src/main/java/java/util/stream/Stream.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/Stream.java
-ojluni/src/main/java/java/util/stream/StreamOpFlag.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/StreamOpFlag.java
-ojluni/src/main/java/java/util/stream/StreamShape.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/StreamShape.java
-ojluni/src/main/java/java/util/stream/StreamSpliterators.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/StreamSpliterators.java
-ojluni/src/main/java/java/util/stream/StreamSupport.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/StreamSupport.java
-ojluni/src/main/java/java/util/stream/Streams.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/Streams.java
-ojluni/src/main/java/java/util/stream/TerminalOp.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/TerminalOp.java
-ojluni/src/main/java/java/util/stream/TerminalSink.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/TerminalSink.java
-ojluni/src/main/java/java/util/stream/Tripwire.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/Tripwire.java
-ojluni/src/main/java/java/util/stream/package-info.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/stream/package-info.java
-ojluni/src/main/java/java/util/zip/Adler32.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/zip/Adler32.java
-ojluni/src/main/java/java/util/zip/CRC32.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/zip/CRC32.java
-ojluni/src/main/java/java/util/zip/CRC32C.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/zip/CRC32C.java
-ojluni/src/main/java/java/util/zip/CheckedInputStream.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/zip/CheckedInputStream.java
-ojluni/src/main/java/java/util/zip/CheckedOutputStream.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/zip/CheckedOutputStream.java
-ojluni/src/main/java/java/util/zip/Checksum.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/zip/Checksum.java
-ojluni/src/main/java/java/util/zip/DataFormatException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/zip/DataFormatException.java
-ojluni/src/main/java/java/util/zip/Deflater.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/zip/Deflater.java
-ojluni/src/main/java/java/util/zip/DeflaterInputStream.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/zip/DeflaterInputStream.java
-ojluni/src/main/java/java/util/zip/DeflaterOutputStream.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/zip/DeflaterOutputStream.java
-ojluni/src/main/java/java/util/zip/GZIPInputStream.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/zip/GZIPInputStream.java
-ojluni/src/main/java/java/util/zip/GZIPOutputStream.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/zip/GZIPOutputStream.java
-ojluni/src/main/java/java/util/zip/Inflater.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/zip/Inflater.java
-ojluni/src/main/java/java/util/zip/InflaterInputStream.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/zip/InflaterInputStream.java
-ojluni/src/main/java/java/util/zip/InflaterOutputStream.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/zip/InflaterOutputStream.java
-ojluni/src/main/java/java/util/zip/ZipCoder.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/zip/ZipCoder.java
-ojluni/src/main/java/java/util/zip/ZipConstants.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/zip/ZipConstants.java
-ojluni/src/main/java/java/util/zip/ZipConstants64.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/zip/ZipConstants64.java
-ojluni/src/main/java/java/util/zip/ZipEntry.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/zip/ZipEntry.java
-ojluni/src/main/java/java/util/zip/ZipError.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/zip/ZipError.java
-ojluni/src/main/java/java/util/zip/ZipException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/util/zip/ZipException.java
-ojluni/src/main/java/java/util/zip/ZipFile.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/zip/ZipFile.java
-ojluni/src/main/java/java/util/zip/ZipInputStream.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/zip/ZipInputStream.java
-ojluni/src/main/java/java/util/zip/ZipOutputStream.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/zip/ZipOutputStream.java
-ojluni/src/main/java/java/util/zip/ZipUtils.java,jdk17u/jdk-17.0.5-ga,src/java.base/share/classes/java/util/zip/ZipUtils.java
-ojluni/src/main/java/java/util/zip/package-info.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/java/util/zip/package-info.java
-ojluni/src/main/java/javax/crypto/AEADBadTagException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/crypto/AEADBadTagException.java
-ojluni/src/main/java/javax/crypto/BadPaddingException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/crypto/BadPaddingException.java
+ojluni/src/main/java/java/util/prefs/package-info.java,jdk21u/jdk-21.0.6-ga,src/java.prefs/share/classes/java/util/prefs/package-info.java
+ojluni/src/main/java/java/util/random/RandomGenerator.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/random/RandomGenerator.java
+ojluni/src/main/java/java/util/random/RandomGeneratorFactory.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/random/RandomGeneratorFactory.java
+ojluni/src/main/java/java/util/random/package-info.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/random/package-info.java
+ojluni/src/main/java/java/util/regex/ASCII.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/regex/ASCII.java
+ojluni/src/main/java/java/util/regex/MatchResult.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/regex/MatchResult.java
+ojluni/src/main/java/java/util/regex/Matcher.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/regex/Matcher.java
+ojluni/src/main/java/java/util/regex/Pattern.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/regex/Pattern.java
+ojluni/src/main/java/java/util/regex/PatternSyntaxException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/regex/PatternSyntaxException.java
+ojluni/src/main/java/java/util/regex/package-info.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/regex/package-info.java
+ojluni/src/main/java/java/util/stream/AbstractPipeline.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/AbstractPipeline.java
+ojluni/src/main/java/java/util/stream/AbstractShortCircuitTask.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/AbstractShortCircuitTask.java
+ojluni/src/main/java/java/util/stream/AbstractSpinedBuffer.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/AbstractSpinedBuffer.java
+ojluni/src/main/java/java/util/stream/AbstractTask.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/AbstractTask.java
+ojluni/src/main/java/java/util/stream/BaseStream.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/BaseStream.java
+ojluni/src/main/java/java/util/stream/Collector.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/Collector.java
+ojluni/src/main/java/java/util/stream/Collectors.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/Collectors.java
+ojluni/src/main/java/java/util/stream/DistinctOps.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/DistinctOps.java
+ojluni/src/main/java/java/util/stream/DoublePipeline.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/DoublePipeline.java
+ojluni/src/main/java/java/util/stream/DoubleStream.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/DoubleStream.java
+ojluni/src/main/java/java/util/stream/FindOps.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/FindOps.java
+ojluni/src/main/java/java/util/stream/ForEachOps.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/ForEachOps.java
+ojluni/src/main/java/java/util/stream/Gatherer.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/Gatherer.java
+ojluni/src/main/java/java/util/stream/GathererOp.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/GathererOp.java
+ojluni/src/main/java/java/util/stream/Gatherers.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/Gatherers.java
+ojluni/src/main/java/java/util/stream/IntPipeline.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/IntPipeline.java
+ojluni/src/main/java/java/util/stream/IntStream.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/IntStream.java
+ojluni/src/main/java/java/util/stream/LongPipeline.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/LongPipeline.java
+ojluni/src/main/java/java/util/stream/LongStream.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/LongStream.java
+ojluni/src/main/java/java/util/stream/MatchOps.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/MatchOps.java
+ojluni/src/main/java/java/util/stream/Node.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/Node.java
+ojluni/src/main/java/java/util/stream/Nodes.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/Nodes.java
+ojluni/src/main/java/java/util/stream/PipelineHelper.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/PipelineHelper.java
+ojluni/src/main/java/java/util/stream/ReduceOps.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/ReduceOps.java
+ojluni/src/main/java/java/util/stream/ReferencePipeline.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/ReferencePipeline.java
+ojluni/src/main/java/java/util/stream/Sink.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/Sink.java
+ojluni/src/main/java/java/util/stream/SliceOps.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/SliceOps.java
+ojluni/src/main/java/java/util/stream/SortedOps.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/SortedOps.java
+ojluni/src/main/java/java/util/stream/SpinedBuffer.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/SpinedBuffer.java
+ojluni/src/main/java/java/util/stream/Stream.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/Stream.java
+ojluni/src/main/java/java/util/stream/StreamOpFlag.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/StreamOpFlag.java
+ojluni/src/main/java/java/util/stream/StreamShape.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/StreamShape.java
+ojluni/src/main/java/java/util/stream/StreamSpliterators.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/StreamSpliterators.java
+ojluni/src/main/java/java/util/stream/StreamSupport.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/StreamSupport.java
+ojluni/src/main/java/java/util/stream/Streams.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/Streams.java
+ojluni/src/main/java/java/util/stream/TerminalOp.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/TerminalOp.java
+ojluni/src/main/java/java/util/stream/TerminalSink.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/TerminalSink.java
+ojluni/src/main/java/java/util/stream/Tripwire.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/Tripwire.java
+ojluni/src/main/java/java/util/stream/WhileOps.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/WhileOps.java
+ojluni/src/main/java/java/util/stream/package-info.java,jdk/jdk-25+26,src/java.base/share/classes/java/util/stream/package-info.java
+ojluni/src/main/java/java/util/zip/Adler32.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/zip/Adler32.java
+ojluni/src/main/java/java/util/zip/CRC32.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/zip/CRC32.java
+ojluni/src/main/java/java/util/zip/CRC32C.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/zip/CRC32C.java
+ojluni/src/main/java/java/util/zip/CheckedInputStream.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/zip/CheckedInputStream.java
+ojluni/src/main/java/java/util/zip/CheckedOutputStream.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/zip/CheckedOutputStream.java
+ojluni/src/main/java/java/util/zip/Checksum.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/zip/Checksum.java
+ojluni/src/main/java/java/util/zip/DataFormatException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/zip/DataFormatException.java
+ojluni/src/main/java/java/util/zip/Deflater.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/zip/Deflater.java
+ojluni/src/main/java/java/util/zip/DeflaterInputStream.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/zip/DeflaterInputStream.java
+ojluni/src/main/java/java/util/zip/DeflaterOutputStream.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/zip/DeflaterOutputStream.java
+ojluni/src/main/java/java/util/zip/GZIPInputStream.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/zip/GZIPInputStream.java
+ojluni/src/main/java/java/util/zip/GZIPOutputStream.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/zip/GZIPOutputStream.java
+ojluni/src/main/java/java/util/zip/Inflater.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/zip/Inflater.java
+ojluni/src/main/java/java/util/zip/InflaterInputStream.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/zip/InflaterInputStream.java
+ojluni/src/main/java/java/util/zip/InflaterOutputStream.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/zip/InflaterOutputStream.java
+ojluni/src/main/java/java/util/zip/ZipCoder.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/zip/ZipCoder.java
+ojluni/src/main/java/java/util/zip/ZipConstants.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/zip/ZipConstants.java
+ojluni/src/main/java/java/util/zip/ZipConstants64.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/zip/ZipConstants64.java
+ojluni/src/main/java/java/util/zip/ZipEntry.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/zip/ZipEntry.java
+ojluni/src/main/java/java/util/zip/ZipError.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/zip/ZipError.java
+ojluni/src/main/java/java/util/zip/ZipException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/util/zip/ZipException.java
+ojluni/src/main/java/java/util/zip/ZipFile.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/zip/ZipFile.java
+ojluni/src/main/java/java/util/zip/ZipInputStream.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/zip/ZipInputStream.java
+ojluni/src/main/java/java/util/zip/ZipOutputStream.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/zip/ZipOutputStream.java
+ojluni/src/main/java/java/util/zip/ZipUtils.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/zip/ZipUtils.java
+ojluni/src/main/java/java/util/zip/package-info.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/java/util/zip/package-info.java
+ojluni/src/main/java/javax/crypto/AEADBadTagException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/crypto/AEADBadTagException.java
+ojluni/src/main/java/javax/crypto/BadPaddingException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/crypto/BadPaddingException.java
 ojluni/src/main/java/javax/crypto/Cipher.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/crypto/Cipher.java
 ojluni/src/main/java/javax/crypto/CipherInputStream.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/crypto/CipherInputStream.java
 ojluni/src/main/java/javax/crypto/CipherOutputStream.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/crypto/CipherOutputStream.java
 ojluni/src/main/java/javax/crypto/CipherSpi.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/crypto/CipherSpi.java
-ojluni/src/main/java/javax/crypto/CryptoAllPermission.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/crypto/CryptoAllPermission.java
+ojluni/src/main/java/javax/crypto/CryptoAllPermission.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/crypto/CryptoAllPermission.java
 ojluni/src/main/java/javax/crypto/CryptoPermission.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/crypto/CryptoPermission.java
 ojluni/src/main/java/javax/crypto/CryptoPermissions.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/crypto/CryptoPermissions.java
 ojluni/src/main/java/javax/crypto/CryptoPolicyParser.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/crypto/CryptoPolicyParser.java
 ojluni/src/main/java/javax/crypto/EncryptedPrivateKeyInfo.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/crypto/EncryptedPrivateKeyInfo.java
 ojluni/src/main/java/javax/crypto/ExemptionMechanism.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/crypto/ExemptionMechanism.java
-ojluni/src/main/java/javax/crypto/ExemptionMechanismException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/crypto/ExemptionMechanismException.java
-ojluni/src/main/java/javax/crypto/ExemptionMechanismSpi.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/crypto/ExemptionMechanismSpi.java
-ojluni/src/main/java/javax/crypto/IllegalBlockSizeException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/crypto/IllegalBlockSizeException.java
+ojluni/src/main/java/javax/crypto/ExemptionMechanismException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/crypto/ExemptionMechanismException.java
+ojluni/src/main/java/javax/crypto/ExemptionMechanismSpi.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/crypto/ExemptionMechanismSpi.java
+ojluni/src/main/java/javax/crypto/IllegalBlockSizeException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/crypto/IllegalBlockSizeException.java
 ojluni/src/main/java/javax/crypto/JarVerifier.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/crypto/JarVerifier.java
 ojluni/src/main/java/javax/crypto/JceSecurity.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/crypto/JceSecurity.java
 ojluni/src/main/java/javax/crypto/JceSecurityManager.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/crypto/JceSecurityManager.java
 ojluni/src/main/java/javax/crypto/KeyAgreement.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/crypto/KeyAgreement.java
-ojluni/src/main/java/javax/crypto/KeyAgreementSpi.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/crypto/KeyAgreementSpi.java
+ojluni/src/main/java/javax/crypto/KeyAgreementSpi.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/crypto/KeyAgreementSpi.java
 ojluni/src/main/java/javax/crypto/KeyGenerator.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/crypto/KeyGenerator.java
 ojluni/src/main/java/javax/crypto/KeyGeneratorSpi.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/crypto/KeyGeneratorSpi.java
 ojluni/src/main/java/javax/crypto/Mac.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/crypto/Mac.java
-ojluni/src/main/java/javax/crypto/MacSpi.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/crypto/MacSpi.java
-ojluni/src/main/java/javax/crypto/NoSuchPaddingException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/crypto/NoSuchPaddingException.java
-ojluni/src/main/java/javax/crypto/NullCipher.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/javax/crypto/NullCipher.java
-ojluni/src/main/java/javax/crypto/NullCipherSpi.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/javax/crypto/NullCipherSpi.java
+ojluni/src/main/java/javax/crypto/MacSpi.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/crypto/MacSpi.java
+ojluni/src/main/java/javax/crypto/NoSuchPaddingException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/crypto/NoSuchPaddingException.java
+ojluni/src/main/java/javax/crypto/NullCipher.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/javax/crypto/NullCipher.java
+ojluni/src/main/java/javax/crypto/NullCipherSpi.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/javax/crypto/NullCipherSpi.java
 ojluni/src/main/java/javax/crypto/SealedObject.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/crypto/SealedObject.java
-ojluni/src/main/java/javax/crypto/SecretKey.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/crypto/SecretKey.java
+ojluni/src/main/java/javax/crypto/SecretKey.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/crypto/SecretKey.java
 ojluni/src/main/java/javax/crypto/SecretKeyFactory.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/crypto/SecretKeyFactory.java
-ojluni/src/main/java/javax/crypto/SecretKeyFactorySpi.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/crypto/SecretKeyFactorySpi.java
-ojluni/src/main/java/javax/crypto/ShortBufferException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/crypto/ShortBufferException.java
-ojluni/src/main/java/javax/crypto/interfaces/DHKey.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/javax/crypto/interfaces/DHKey.java
-ojluni/src/main/java/javax/crypto/interfaces/DHPrivateKey.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/crypto/interfaces/DHPrivateKey.java
-ojluni/src/main/java/javax/crypto/interfaces/DHPublicKey.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/crypto/interfaces/DHPublicKey.java
-ojluni/src/main/java/javax/crypto/interfaces/PBEKey.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/crypto/interfaces/PBEKey.java
-ojluni/src/main/java/javax/crypto/spec/ChaCha20ParameterSpec.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/javax/crypto/spec/ChaCha20ParameterSpec.java
-ojluni/src/main/java/javax/crypto/spec/DESKeySpec.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/javax/crypto/spec/DESKeySpec.java
-ojluni/src/main/java/javax/crypto/spec/DESedeKeySpec.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/javax/crypto/spec/DESedeKeySpec.java
-ojluni/src/main/java/javax/crypto/spec/DHGenParameterSpec.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/javax/crypto/spec/DHGenParameterSpec.java
-ojluni/src/main/java/javax/crypto/spec/DHParameterSpec.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/javax/crypto/spec/DHParameterSpec.java
-ojluni/src/main/java/javax/crypto/spec/DHPrivateKeySpec.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/javax/crypto/spec/DHPrivateKeySpec.java
-ojluni/src/main/java/javax/crypto/spec/DHPublicKeySpec.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/javax/crypto/spec/DHPublicKeySpec.java
-ojluni/src/main/java/javax/crypto/spec/GCMParameterSpec.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/javax/crypto/spec/GCMParameterSpec.java
-ojluni/src/main/java/javax/crypto/spec/IvParameterSpec.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/javax/crypto/spec/IvParameterSpec.java
+ojluni/src/main/java/javax/crypto/SecretKeyFactorySpi.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/crypto/SecretKeyFactorySpi.java
+ojluni/src/main/java/javax/crypto/ShortBufferException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/crypto/ShortBufferException.java
+ojluni/src/main/java/javax/crypto/interfaces/DHKey.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/javax/crypto/interfaces/DHKey.java
+ojluni/src/main/java/javax/crypto/interfaces/DHPrivateKey.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/crypto/interfaces/DHPrivateKey.java
+ojluni/src/main/java/javax/crypto/interfaces/DHPublicKey.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/crypto/interfaces/DHPublicKey.java
+ojluni/src/main/java/javax/crypto/interfaces/PBEKey.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/crypto/interfaces/PBEKey.java
+ojluni/src/main/java/javax/crypto/spec/ChaCha20ParameterSpec.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/javax/crypto/spec/ChaCha20ParameterSpec.java
+ojluni/src/main/java/javax/crypto/spec/DESKeySpec.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/javax/crypto/spec/DESKeySpec.java
+ojluni/src/main/java/javax/crypto/spec/DESedeKeySpec.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/javax/crypto/spec/DESedeKeySpec.java
+ojluni/src/main/java/javax/crypto/spec/DHGenParameterSpec.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/javax/crypto/spec/DHGenParameterSpec.java
+ojluni/src/main/java/javax/crypto/spec/DHParameterSpec.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/javax/crypto/spec/DHParameterSpec.java
+ojluni/src/main/java/javax/crypto/spec/DHPrivateKeySpec.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/javax/crypto/spec/DHPrivateKeySpec.java
+ojluni/src/main/java/javax/crypto/spec/DHPublicKeySpec.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/javax/crypto/spec/DHPublicKeySpec.java
+ojluni/src/main/java/javax/crypto/spec/GCMParameterSpec.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/javax/crypto/spec/GCMParameterSpec.java
+ojluni/src/main/java/javax/crypto/spec/IvParameterSpec.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/javax/crypto/spec/IvParameterSpec.java
 ojluni/src/main/java/javax/crypto/spec/OAEPParameterSpec.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/crypto/spec/OAEPParameterSpec.java
-ojluni/src/main/java/javax/crypto/spec/PBEKeySpec.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/javax/crypto/spec/PBEKeySpec.java
-ojluni/src/main/java/javax/crypto/spec/PBEParameterSpec.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/javax/crypto/spec/PBEParameterSpec.java
+ojluni/src/main/java/javax/crypto/spec/PBEKeySpec.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/javax/crypto/spec/PBEKeySpec.java
+ojluni/src/main/java/javax/crypto/spec/PBEParameterSpec.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/javax/crypto/spec/PBEParameterSpec.java
 ojluni/src/main/java/javax/crypto/spec/PSource.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/crypto/spec/PSource.java
 ojluni/src/main/java/javax/crypto/spec/RC2ParameterSpec.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/crypto/spec/RC2ParameterSpec.java
 ojluni/src/main/java/javax/crypto/spec/RC5ParameterSpec.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/crypto/spec/RC5ParameterSpec.java
 ojluni/src/main/java/javax/crypto/spec/SecretKeySpec.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/crypto/spec/SecretKeySpec.java
-ojluni/src/main/java/javax/net/ServerSocketFactory.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/javax/net/ServerSocketFactory.java
-ojluni/src/main/java/javax/net/SocketFactory.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/javax/net/SocketFactory.java
-ojluni/src/main/java/javax/net/ssl/CertPathTrustManagerParameters.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/javax/net/ssl/CertPathTrustManagerParameters.java
+ojluni/src/main/java/javax/net/ServerSocketFactory.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/javax/net/ServerSocketFactory.java
+ojluni/src/main/java/javax/net/SocketFactory.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/javax/net/SocketFactory.java
+ojluni/src/main/java/javax/net/ssl/CertPathTrustManagerParameters.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/javax/net/ssl/CertPathTrustManagerParameters.java
 ojluni/src/main/java/javax/net/ssl/ExtendedSSLSession.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/net/ssl/ExtendedSSLSession.java
 ojluni/src/main/java/javax/net/ssl/HandshakeCompletedEvent.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/net/ssl/HandshakeCompletedEvent.java
-ojluni/src/main/java/javax/net/ssl/HandshakeCompletedListener.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/javax/net/ssl/HandshakeCompletedListener.java
-ojluni/src/main/java/javax/net/ssl/HostnameVerifier.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/javax/net/ssl/HostnameVerifier.java
+ojluni/src/main/java/javax/net/ssl/HandshakeCompletedListener.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/javax/net/ssl/HandshakeCompletedListener.java
+ojluni/src/main/java/javax/net/ssl/HostnameVerifier.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/javax/net/ssl/HostnameVerifier.java
 ojluni/src/main/java/javax/net/ssl/HttpsURLConnection.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/net/ssl/HttpsURLConnection.java
-ojluni/src/main/java/javax/net/ssl/KeyManager.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/javax/net/ssl/KeyManager.java
+ojluni/src/main/java/javax/net/ssl/KeyManager.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/javax/net/ssl/KeyManager.java
 ojluni/src/main/java/javax/net/ssl/KeyManagerFactory.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/net/ssl/KeyManagerFactory.java
-ojluni/src/main/java/javax/net/ssl/KeyManagerFactorySpi.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/net/ssl/KeyManagerFactorySpi.java
-ojluni/src/main/java/javax/net/ssl/KeyStoreBuilderParameters.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/javax/net/ssl/KeyStoreBuilderParameters.java
-ojluni/src/main/java/javax/net/ssl/ManagerFactoryParameters.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/javax/net/ssl/ManagerFactoryParameters.java
+ojluni/src/main/java/javax/net/ssl/KeyManagerFactorySpi.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/net/ssl/KeyManagerFactorySpi.java
+ojluni/src/main/java/javax/net/ssl/KeyStoreBuilderParameters.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/javax/net/ssl/KeyStoreBuilderParameters.java
+ojluni/src/main/java/javax/net/ssl/ManagerFactoryParameters.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/javax/net/ssl/ManagerFactoryParameters.java
 ojluni/src/main/java/javax/net/ssl/SNIHostName.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/net/ssl/SNIHostName.java
-ojluni/src/main/java/javax/net/ssl/SNIMatcher.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/javax/net/ssl/SNIMatcher.java
+ojluni/src/main/java/javax/net/ssl/SNIMatcher.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/javax/net/ssl/SNIMatcher.java
 ojluni/src/main/java/javax/net/ssl/SNIServerName.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/net/ssl/SNIServerName.java
 ojluni/src/main/java/javax/net/ssl/SSLContext.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/net/ssl/SSLContext.java
 ojluni/src/main/java/javax/net/ssl/SSLContextSpi.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/net/ssl/SSLContextSpi.java
 ojluni/src/main/java/javax/net/ssl/SSLEngine.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/net/ssl/SSLEngine.java
 ojluni/src/main/java/javax/net/ssl/SSLEngineResult.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/net/ssl/SSLEngineResult.java
 ojluni/src/main/java/javax/net/ssl/SSLException.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/net/ssl/SSLException.java
-ojluni/src/main/java/javax/net/ssl/SSLHandshakeException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/net/ssl/SSLHandshakeException.java
-ojluni/src/main/java/javax/net/ssl/SSLKeyException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/net/ssl/SSLKeyException.java
+ojluni/src/main/java/javax/net/ssl/SSLHandshakeException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/net/ssl/SSLHandshakeException.java
+ojluni/src/main/java/javax/net/ssl/SSLKeyException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/net/ssl/SSLKeyException.java
 ojluni/src/main/java/javax/net/ssl/SSLParameters.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/net/ssl/SSLParameters.java
-ojluni/src/main/java/javax/net/ssl/SSLPeerUnverifiedException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/net/ssl/SSLPeerUnverifiedException.java
+ojluni/src/main/java/javax/net/ssl/SSLPeerUnverifiedException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/net/ssl/SSLPeerUnverifiedException.java
 ojluni/src/main/java/javax/net/ssl/SSLPermission.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/net/ssl/SSLPermission.java
-ojluni/src/main/java/javax/net/ssl/SSLProtocolException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/net/ssl/SSLProtocolException.java
+ojluni/src/main/java/javax/net/ssl/SSLProtocolException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/net/ssl/SSLProtocolException.java
 ojluni/src/main/java/javax/net/ssl/SSLServerSocket.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/net/ssl/SSLServerSocket.java
 ojluni/src/main/java/javax/net/ssl/SSLServerSocketFactory.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/net/ssl/SSLServerSocketFactory.java
 ojluni/src/main/java/javax/net/ssl/SSLSession.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/net/ssl/SSLSession.java
-ojluni/src/main/java/javax/net/ssl/SSLSessionBindingEvent.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/net/ssl/SSLSessionBindingEvent.java
-ojluni/src/main/java/javax/net/ssl/SSLSessionBindingListener.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/javax/net/ssl/SSLSessionBindingListener.java
-ojluni/src/main/java/javax/net/ssl/SSLSessionContext.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/net/ssl/SSLSessionContext.java
+ojluni/src/main/java/javax/net/ssl/SSLSessionBindingEvent.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/net/ssl/SSLSessionBindingEvent.java
+ojluni/src/main/java/javax/net/ssl/SSLSessionBindingListener.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/javax/net/ssl/SSLSessionBindingListener.java
+ojluni/src/main/java/javax/net/ssl/SSLSessionContext.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/net/ssl/SSLSessionContext.java
 ojluni/src/main/java/javax/net/ssl/SSLSocket.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/net/ssl/SSLSocket.java
 ojluni/src/main/java/javax/net/ssl/SSLSocketFactory.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/net/ssl/SSLSocketFactory.java
-ojluni/src/main/java/javax/net/ssl/StandardConstants.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/javax/net/ssl/StandardConstants.java
-ojluni/src/main/java/javax/net/ssl/TrustManager.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/javax/net/ssl/TrustManager.java
+ojluni/src/main/java/javax/net/ssl/StandardConstants.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/javax/net/ssl/StandardConstants.java
+ojluni/src/main/java/javax/net/ssl/TrustManager.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/javax/net/ssl/TrustManager.java
 ojluni/src/main/java/javax/net/ssl/TrustManagerFactory.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/net/ssl/TrustManagerFactory.java
-ojluni/src/main/java/javax/net/ssl/TrustManagerFactorySpi.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/net/ssl/TrustManagerFactorySpi.java
-ojluni/src/main/java/javax/net/ssl/X509ExtendedKeyManager.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/javax/net/ssl/X509ExtendedKeyManager.java
+ojluni/src/main/java/javax/net/ssl/TrustManagerFactorySpi.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/net/ssl/TrustManagerFactorySpi.java
+ojluni/src/main/java/javax/net/ssl/X509ExtendedKeyManager.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/javax/net/ssl/X509ExtendedKeyManager.java
 ojluni/src/main/java/javax/net/ssl/X509ExtendedTrustManager.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/net/ssl/X509ExtendedTrustManager.java
 ojluni/src/main/java/javax/net/ssl/X509KeyManager.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/net/ssl/X509KeyManager.java
-ojluni/src/main/java/javax/net/ssl/X509TrustManager.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/javax/net/ssl/X509TrustManager.java
+ojluni/src/main/java/javax/net/ssl/X509TrustManager.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/javax/net/ssl/X509TrustManager.java
 ojluni/src/main/java/javax/security/auth/AuthPermission.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/security/auth/AuthPermission.java
 ojluni/src/main/java/javax/security/auth/DestroyFailedException.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/security/auth/DestroyFailedException.java
 ojluni/src/main/java/javax/security/auth/Destroyable.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/security/auth/Destroyable.java
@@ -1385,7 +1392,7 @@ ojluni/src/main/java/javax/security/auth/login/LoginException.java,jdk8u/jdk8u12
 ojluni/src/main/java/javax/security/auth/login/package-info.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/security/auth/login/package-info.java
 ojluni/src/main/java/javax/security/auth/package-info.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/security/auth/package-info.java
 ojluni/src/main/java/javax/security/auth/x500/X500Principal.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/security/auth/x500/X500Principal.java
-ojluni/src/main/java/javax/security/auth/x500/X500PrivateCredential.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/javax/security/auth/x500/X500PrivateCredential.java
+ojluni/src/main/java/javax/security/auth/x500/X500PrivateCredential.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/javax/security/auth/x500/X500PrivateCredential.java
 ojluni/src/main/java/javax/security/auth/x500/package-info.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/security/auth/x500/package-info.java
 ojluni/src/main/java/javax/security/cert/Certificate.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/security/cert/Certificate.java
 ojluni/src/main/java/javax/security/cert/CertificateEncodingException.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/security/cert/CertificateEncodingException.java
@@ -1396,88 +1403,101 @@ ojluni/src/main/java/javax/security/cert/CertificateParsingException.java,jdk8u/
 ojluni/src/main/java/javax/security/cert/X509Certificate.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/security/cert/X509Certificate.java
 ojluni/src/main/java/javax/security/cert/package-info.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/javax/security/cert/package-info.java
 ojluni/src/main/java/javax/sql/CommonDataSource.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/javax/sql/CommonDataSource.java
-ojluni/src/main/java/javax/sql/ConnectionEvent.java,jdk11u/jdk-11.0.13-ga,src/java.sql/share/classes/javax/sql/ConnectionEvent.java
-ojluni/src/main/java/javax/sql/ConnectionEventListener.java,jdk11u/jdk-11.0.13-ga,src/java.sql/share/classes/javax/sql/ConnectionEventListener.java
+ojluni/src/main/java/javax/sql/ConnectionEvent.java,jdk11u/jdk-11.0.26-ga,src/java.sql/share/classes/javax/sql/ConnectionEvent.java
+ojluni/src/main/java/javax/sql/ConnectionEventListener.java,jdk11u/jdk-11.0.26-ga,src/java.sql/share/classes/javax/sql/ConnectionEventListener.java
 ojluni/src/main/java/javax/sql/ConnectionPoolDataSource.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/javax/sql/ConnectionPoolDataSource.java
 ojluni/src/main/java/javax/sql/DataSource.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/javax/sql/DataSource.java
 ojluni/src/main/java/javax/sql/PooledConnection.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/javax/sql/PooledConnection.java
 ojluni/src/main/java/javax/sql/RowSet.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/javax/sql/RowSet.java
-ojluni/src/main/java/javax/sql/RowSetEvent.java,jdk11u/jdk-11.0.13-ga,src/java.sql/share/classes/javax/sql/RowSetEvent.java
-ojluni/src/main/java/javax/sql/RowSetInternal.java,jdk11u/jdk-11.0.13-ga,src/java.sql/share/classes/javax/sql/RowSetInternal.java
-ojluni/src/main/java/javax/sql/RowSetListener.java,jdk11u/jdk-11.0.13-ga,src/java.sql/share/classes/javax/sql/RowSetListener.java
-ojluni/src/main/java/javax/sql/RowSetMetaData.java,jdk11u/jdk-11.0.13-ga,src/java.sql/share/classes/javax/sql/RowSetMetaData.java
-ojluni/src/main/java/javax/sql/RowSetReader.java,jdk11u/jdk-11.0.13-ga,src/java.sql/share/classes/javax/sql/RowSetReader.java
-ojluni/src/main/java/javax/sql/RowSetWriter.java,jdk11u/jdk-11.0.13-ga,src/java.sql/share/classes/javax/sql/RowSetWriter.java
+ojluni/src/main/java/javax/sql/RowSetEvent.java,jdk11u/jdk-11.0.26-ga,src/java.sql/share/classes/javax/sql/RowSetEvent.java
+ojluni/src/main/java/javax/sql/RowSetInternal.java,jdk11u/jdk-11.0.26-ga,src/java.sql/share/classes/javax/sql/RowSetInternal.java
+ojluni/src/main/java/javax/sql/RowSetListener.java,jdk11u/jdk-11.0.26-ga,src/java.sql/share/classes/javax/sql/RowSetListener.java
+ojluni/src/main/java/javax/sql/RowSetMetaData.java,jdk11u/jdk-11.0.26-ga,src/java.sql/share/classes/javax/sql/RowSetMetaData.java
+ojluni/src/main/java/javax/sql/RowSetReader.java,jdk11u/jdk-11.0.26-ga,src/java.sql/share/classes/javax/sql/RowSetReader.java
+ojluni/src/main/java/javax/sql/RowSetWriter.java,jdk11u/jdk-11.0.26-ga,src/java.sql/share/classes/javax/sql/RowSetWriter.java
 ojluni/src/main/java/javax/sql/StatementEvent.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/javax/sql/StatementEvent.java
 ojluni/src/main/java/javax/sql/StatementEventListener.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/javax/sql/StatementEventListener.java
-ojluni/src/main/java/jdk/internal/HotSpotIntrinsicCandidate.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/jdk/internal/HotSpotIntrinsicCandidate.java
-ojluni/src/main/java/jdk/internal/ValueBased.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/ValueBased.java
-ojluni/src/main/java/jdk/internal/access/JavaIOFileDescriptorAccess.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/access/JavaIOFileDescriptorAccess.java
-ojluni/src/main/java/jdk/internal/access/JavaObjectInputStreamAccess.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/jdk/internal/access/JavaObjectInputStreamAccess.java
-ojluni/src/main/java/jdk/internal/access/JavaUtilCollectionAccess.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/access/JavaUtilCollectionAccess.java
-ojluni/src/main/java/jdk/internal/access/SharedSecrets.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/jdk/internal/access/SharedSecrets.java
-ojluni/src/main/java/jdk/internal/event/Event.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/event/Event.java
-ojluni/src/main/java/jdk/internal/event/VirtualThreadEndEvent.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/event/VirtualThreadEndEvent.java
-ojluni/src/main/java/jdk/internal/event/VirtualThreadPinnedEvent.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/event/VirtualThreadPinnedEvent.java
-ojluni/src/main/java/jdk/internal/event/VirtualThreadStartEvent.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/event/VirtualThreadStartEvent.java
-ojluni/src/main/java/jdk/internal/event/VirtualThreadSubmitFailedEvent.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/event/VirtualThreadSubmitFailedEvent.java
-ojluni/src/main/java/jdk/internal/math/DoubleConsts.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/math/DoubleConsts.java
-ojluni/src/main/java/jdk/internal/math/DoubleToDecimal.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/math/DoubleToDecimal.java
-ojluni/src/main/java/jdk/internal/math/FDBigInteger.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/math/FDBigInteger.java
-ojluni/src/main/java/jdk/internal/math/FloatConsts.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/math/FloatConsts.java
-ojluni/src/main/java/jdk/internal/math/FloatToDecimal.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/math/FloatToDecimal.java
-ojluni/src/main/java/jdk/internal/math/FloatingDecimal.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/math/FloatingDecimal.java
-ojluni/src/main/java/jdk/internal/math/FormattedFPDecimal.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/math/FormattedFPDecimal.java
-ojluni/src/main/java/jdk/internal/math/FormattedFloatingDecimal.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/jdk/internal/math/FormattedFloatingDecimal.java
-ojluni/src/main/java/jdk/internal/math/MathUtils.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/math/MathUtils.java
-ojluni/src/main/java/jdk/internal/misc/InnocuousThread.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/jdk/internal/misc/InnocuousThread.java
-ojluni/src/main/java/jdk/internal/misc/TerminatingThreadLocal.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/jdk/internal/misc/TerminatingThreadLocal.java
-ojluni/src/main/java/jdk/internal/misc/Unsafe.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/jdk/internal/misc/Unsafe.java
-ojluni/src/main/java/jdk/internal/misc/UnsafeConstants.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/misc/UnsafeConstants.java
-ojluni/src/main/java/jdk/internal/misc/VM.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/jdk/internal/misc/VM.java
-ojluni/src/main/java/jdk/internal/misc/VirtualThreads.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/misc/VirtualThreads.java
-ojluni/src/main/java/jdk/internal/ref/Cleaner.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/jdk/internal/ref/Cleaner.java
-ojluni/src/main/java/jdk/internal/ref/CleanerFactory.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/jdk/internal/ref/CleanerFactory.java
-ojluni/src/main/java/jdk/internal/ref/CleanerImpl.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/jdk/internal/ref/CleanerImpl.java
-ojluni/src/main/java/jdk/internal/ref/PhantomCleanable.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/jdk/internal/ref/PhantomCleanable.java
-ojluni/src/main/java/jdk/internal/reflect/CallerSensitive.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/reflect/CallerSensitive.java
-ojluni/src/main/java/jdk/internal/reflect/Reflection.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/jdk/internal/reflect/Reflection.java
-ojluni/src/main/java/jdk/internal/util/ArraysSupport.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/util/ArraysSupport.java
-ojluni/src/main/java/jdk/internal/util/NullableKeyValueHolder.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/util/NullableKeyValueHolder.java
-ojluni/src/main/java/jdk/internal/util/Preconditions.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/jdk/internal/util/Preconditions.java
-ojluni/src/main/java/jdk/internal/util/ReferenceKey.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/util/ReferenceKey.java
+ojluni/src/main/java/jdk/internal/HotSpotIntrinsicCandidate.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/jdk/internal/HotSpotIntrinsicCandidate.java
+ojluni/src/main/java/jdk/internal/ValueBased.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/ValueBased.java
+ojluni/src/main/java/jdk/internal/access/JavaIOFileDescriptorAccess.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/access/JavaIOFileDescriptorAccess.java
+ojluni/src/main/java/jdk/internal/access/JavaObjectInputStreamAccess.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/jdk/internal/access/JavaObjectInputStreamAccess.java
+ojluni/src/main/java/jdk/internal/access/JavaUtilCollectionAccess.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/access/JavaUtilCollectionAccess.java
+ojluni/src/main/java/jdk/internal/access/SharedSecrets.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/jdk/internal/access/SharedSecrets.java
+ojluni/src/main/java/jdk/internal/event/Event.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/event/Event.java
+ojluni/src/main/java/jdk/internal/event/ThreadSleepEvent.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/event/ThreadSleepEvent.java
+ojluni/src/main/java/jdk/internal/event/VirtualThreadEndEvent.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/event/VirtualThreadEndEvent.java
+ojluni/src/main/java/jdk/internal/event/VirtualThreadPinnedEvent.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/event/VirtualThreadPinnedEvent.java
+ojluni/src/main/java/jdk/internal/event/VirtualThreadStartEvent.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/event/VirtualThreadStartEvent.java
+ojluni/src/main/java/jdk/internal/event/VirtualThreadSubmitFailedEvent.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/event/VirtualThreadSubmitFailedEvent.java
+ojluni/src/main/java/jdk/internal/invoke/MhUtil.java,jdk/jdk-25+26,src/java.base/share/classes/jdk/internal/invoke/MhUtil.java
+ojluni/src/main/java/jdk/internal/math/DoubleConsts.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/math/DoubleConsts.java
+ojluni/src/main/java/jdk/internal/math/DoubleToDecimal.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/math/DoubleToDecimal.java
+ojluni/src/main/java/jdk/internal/math/FDBigInteger.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/math/FDBigInteger.java
+ojluni/src/main/java/jdk/internal/math/FloatConsts.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/math/FloatConsts.java
+ojluni/src/main/java/jdk/internal/math/FloatToDecimal.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/math/FloatToDecimal.java
+ojluni/src/main/java/jdk/internal/math/FloatingDecimal.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/math/FloatingDecimal.java
+ojluni/src/main/java/jdk/internal/math/FormattedFPDecimal.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/math/FormattedFPDecimal.java
+ojluni/src/main/java/jdk/internal/math/FormattedFloatingDecimal.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/jdk/internal/math/FormattedFloatingDecimal.java
+ojluni/src/main/java/jdk/internal/math/MathUtils.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/math/MathUtils.java
+ojluni/src/main/java/jdk/internal/misc/CarrierThread.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/misc/CarrierThread.java
+ojluni/src/main/java/jdk/internal/misc/CarrierThreadLocal.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/misc/CarrierThreadLocal.java
+ojluni/src/main/java/jdk/internal/misc/InnocuousThread.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/misc/InnocuousThread.java
+ojluni/src/main/java/jdk/internal/misc/TerminatingThreadLocal.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/misc/TerminatingThreadLocal.java
+ojluni/src/main/java/jdk/internal/misc/ThreadTracker.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/misc/ThreadTracker.java
+ojluni/src/main/java/jdk/internal/misc/Unsafe.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/jdk/internal/misc/Unsafe.java
+ojluni/src/main/java/jdk/internal/misc/UnsafeConstants.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/misc/UnsafeConstants.java
+ojluni/src/main/java/jdk/internal/misc/VM.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/jdk/internal/misc/VM.java
+ojluni/src/main/java/jdk/internal/misc/VirtualThreads.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/misc/VirtualThreads.java
+ojluni/src/main/java/jdk/internal/ref/Cleaner.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/jdk/internal/ref/Cleaner.java
+ojluni/src/main/java/jdk/internal/ref/CleanerFactory.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/jdk/internal/ref/CleanerFactory.java
+ojluni/src/main/java/jdk/internal/ref/CleanerImpl.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/jdk/internal/ref/CleanerImpl.java
+ojluni/src/main/java/jdk/internal/ref/PhantomCleanable.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/jdk/internal/ref/PhantomCleanable.java
+ojluni/src/main/java/jdk/internal/reflect/CallerSensitive.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/reflect/CallerSensitive.java
+ojluni/src/main/java/jdk/internal/reflect/Reflection.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/jdk/internal/reflect/Reflection.java
+ojluni/src/main/java/jdk/internal/util/ArraysSupport.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/util/ArraysSupport.java
+ojluni/src/main/java/jdk/internal/util/NullableKeyValueHolder.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/util/NullableKeyValueHolder.java
+ojluni/src/main/java/jdk/internal/util/Preconditions.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/jdk/internal/util/Preconditions.java
+ojluni/src/main/java/jdk/internal/util/ReferenceKey.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/util/ReferenceKey.java
 ojluni/src/main/java/jdk/internal/util/ReferencedKeyMap.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/util/ReferencedKeyMap.java
-ojluni/src/main/java/jdk/internal/util/ReferencedKeySet.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/util/ReferencedKeySet.java
-ojluni/src/main/java/jdk/internal/util/SoftReferenceKey.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/util/SoftReferenceKey.java
-ojluni/src/main/java/jdk/internal/util/StaticProperty.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/jdk/internal/util/StaticProperty.java
-ojluni/src/main/java/jdk/internal/util/StrongReferenceKey.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/util/StrongReferenceKey.java
-ojluni/src/main/java/jdk/internal/util/WeakReferenceKey.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/util/WeakReferenceKey.java
-ojluni/src/main/java/jdk/internal/util/jar/JarIndex.java,jdk17u/jdk-17.0.5-ga,src/java.base/share/classes/jdk/internal/util/jar/JarIndex.java
-ojluni/src/main/java/jdk/internal/util/random/RandomSupport.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/jdk/internal/util/random/RandomSupport.java
+ojluni/src/main/java/jdk/internal/util/ReferencedKeySet.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/util/ReferencedKeySet.java
+ojluni/src/main/java/jdk/internal/util/SoftReferenceKey.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/util/SoftReferenceKey.java
+ojluni/src/main/java/jdk/internal/util/StaticProperty.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/jdk/internal/util/StaticProperty.java
+ojluni/src/main/java/jdk/internal/util/StrongReferenceKey.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/util/StrongReferenceKey.java
+ojluni/src/main/java/jdk/internal/util/WeakReferenceKey.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/util/WeakReferenceKey.java
+ojluni/src/main/java/jdk/internal/util/jar/JarIndex.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/jdk/internal/util/jar/JarIndex.java
+ojluni/src/main/java/jdk/internal/util/random/RandomSupport.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/jdk/internal/util/random/RandomSupport.java
 ojluni/src/main/java/jdk/internal/vm/Continuation.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/vm/Continuation.java
 ojluni/src/main/java/jdk/internal/vm/ContinuationScope.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/vm/ContinuationScope.java
+ojluni/src/main/java/jdk/internal/vm/ContinuationSupport.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/vm/ContinuationSupport.java
+ojluni/src/main/java/jdk/internal/vm/SharedThreadContainer.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/vm/SharedThreadContainer.java
 ojluni/src/main/java/jdk/internal/vm/StackChunk.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/vm/StackChunk.java
-ojluni/src/main/java/jdk/internal/vm/annotation/Contended.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/vm/annotation/Contended.java
+ojluni/src/main/java/jdk/internal/vm/StackableScope.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/vm/StackableScope.java
+ojluni/src/main/java/jdk/internal/vm/ThreadContainer.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/vm/ThreadContainer.java
+ojluni/src/main/java/jdk/internal/vm/ThreadContainers.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/vm/ThreadContainers.java
+ojluni/src/main/java/jdk/internal/vm/ThreadDumper.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/vm/ThreadDumper.java
+ojluni/src/main/java/jdk/internal/vm/annotation/ChangesCurrentThread.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/vm/annotation/ChangesCurrentThread.java
+ojluni/src/main/java/jdk/internal/vm/annotation/Contended.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/vm/annotation/Contended.java
 ojluni/src/main/java/jdk/internal/vm/annotation/DontInline.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/vm/annotation/DontInline.java
-ojluni/src/main/java/jdk/internal/vm/annotation/ForceInline.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/vm/annotation/ForceInline.java
+ojluni/src/main/java/jdk/internal/vm/annotation/ForceInline.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/vm/annotation/ForceInline.java
 ojluni/src/main/java/jdk/internal/vm/annotation/Hidden.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/vm/annotation/Hidden.java
-ojluni/src/main/java/jdk/internal/vm/annotation/IntrinsicCandidate.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/vm/annotation/IntrinsicCandidate.java
-ojluni/src/main/java/jdk/internal/vm/annotation/ReservedStackAccess.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/vm/annotation/ReservedStackAccess.java
-ojluni/src/main/java/jdk/internal/vm/annotation/Stable.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/jdk/internal/vm/annotation/Stable.java
-ojluni/src/main/java/jdk/net/ExtendedSocketOptions.java,jdk11u/jdk-11.0.13-ga,src/jdk.net/share/classes/jdk/net/ExtendedSocketOptions.java
+ojluni/src/main/java/jdk/internal/vm/annotation/IntrinsicCandidate.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/vm/annotation/IntrinsicCandidate.java
+ojluni/src/main/java/jdk/internal/vm/annotation/JvmtiMountTransition.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/vm/annotation/JvmtiMountTransition.java
+ojluni/src/main/java/jdk/internal/vm/annotation/ReservedStackAccess.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/vm/annotation/ReservedStackAccess.java
+ojluni/src/main/java/jdk/internal/vm/annotation/Stable.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/jdk/internal/vm/annotation/Stable.java
+ojluni/src/main/java/jdk/net/ExtendedSocketOptions.java,jdk11u/jdk-11.0.26-ga,src/jdk.net/share/classes/jdk/net/ExtendedSocketOptions.java
 ojluni/src/main/java/jdk/net/NetworkPermission.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/jdk/net/NetworkPermission.java
-ojluni/src/main/java/jdk/net/SocketFlow.java,jdk11u/jdk-11.0.13-ga,src/jdk.net/share/classes/jdk/net/SocketFlow.java
+ojluni/src/main/java/jdk/net/SocketFlow.java,jdk11u/jdk-11.0.26-ga,src/jdk.net/share/classes/jdk/net/SocketFlow.java
 ojluni/src/main/java/jdk/net/Sockets.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/jdk/net/Sockets.java
-ojluni/src/main/java/jdk/random/L128X1024MixRandom.java,jdk17u/jdk-17.0.6-ga,src/jdk.random/share/classes/jdk/random/L128X1024MixRandom.java
-ojluni/src/main/java/jdk/random/L128X128MixRandom.java,jdk17u/jdk-17.0.6-ga,src/jdk.random/share/classes/jdk/random/L128X128MixRandom.java
-ojluni/src/main/java/jdk/random/L128X256MixRandom.java,jdk17u/jdk-17.0.6-ga,src/jdk.random/share/classes/jdk/random/L128X256MixRandom.java
-ojluni/src/main/java/jdk/random/L32X64MixRandom.java,jdk21u/jdk-21.0.4-ga,src/jdk.random/share/classes/jdk/random/L32X64MixRandom.java
-ojluni/src/main/java/jdk/random/L64X1024MixRandom.java,jdk21u/jdk-21.0.4-ga,src/jdk.random/share/classes/jdk/random/L64X1024MixRandom.java
-ojluni/src/main/java/jdk/random/L64X128MixRandom.java,jdk21u/jdk-21.0.4-ga,src/jdk.random/share/classes/jdk/random/L64X128MixRandom.java
-ojluni/src/main/java/jdk/random/L64X128StarStarRandom.java,jdk21u/jdk-21.0.4-ga,src/jdk.random/share/classes/jdk/random/L64X128StarStarRandom.java
-ojluni/src/main/java/jdk/random/L64X256MixRandom.java,jdk21u/jdk-21.0.4-ga,src/jdk.random/share/classes/jdk/random/L64X256MixRandom.java
-ojluni/src/main/java/jdk/random/Xoroshiro128PlusPlus.java,jdk21u/jdk-21.0.4-ga,src/jdk.random/share/classes/jdk/random/Xoroshiro128PlusPlus.java
-ojluni/src/main/java/jdk/random/Xoshiro256PlusPlus.java,jdk21u/jdk-21.0.4-ga,src/jdk.random/share/classes/jdk/random/Xoshiro256PlusPlus.java
+ojluni/src/main/java/jdk/random/L128X1024MixRandom.java,jdk17u/jdk-17.0.14-ga,src/jdk.random/share/classes/jdk/random/L128X1024MixRandom.java
+ojluni/src/main/java/jdk/random/L128X128MixRandom.java,jdk17u/jdk-17.0.14-ga,src/jdk.random/share/classes/jdk/random/L128X128MixRandom.java
+ojluni/src/main/java/jdk/random/L128X256MixRandom.java,jdk17u/jdk-17.0.14-ga,src/jdk.random/share/classes/jdk/random/L128X256MixRandom.java
+ojluni/src/main/java/jdk/random/L32X64MixRandom.java,jdk21u/jdk-21.0.6-ga,src/jdk.random/share/classes/jdk/random/L32X64MixRandom.java
+ojluni/src/main/java/jdk/random/L64X1024MixRandom.java,jdk21u/jdk-21.0.6-ga,src/jdk.random/share/classes/jdk/random/L64X1024MixRandom.java
+ojluni/src/main/java/jdk/random/L64X128MixRandom.java,jdk21u/jdk-21.0.6-ga,src/jdk.random/share/classes/jdk/random/L64X128MixRandom.java
+ojluni/src/main/java/jdk/random/L64X128StarStarRandom.java,jdk21u/jdk-21.0.6-ga,src/jdk.random/share/classes/jdk/random/L64X128StarStarRandom.java
+ojluni/src/main/java/jdk/random/L64X256MixRandom.java,jdk21u/jdk-21.0.6-ga,src/jdk.random/share/classes/jdk/random/L64X256MixRandom.java
+ojluni/src/main/java/jdk/random/Xoroshiro128PlusPlus.java,jdk21u/jdk-21.0.6-ga,src/jdk.random/share/classes/jdk/random/Xoroshiro128PlusPlus.java
+ojluni/src/main/java/jdk/random/Xoshiro256PlusPlus.java,jdk21u/jdk-21.0.6-ga,src/jdk.random/share/classes/jdk/random/Xoshiro256PlusPlus.java
 ojluni/src/main/java/sun/invoke/util/BytecodeDescriptor.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/invoke/util/BytecodeDescriptor.java
 ojluni/src/main/java/sun/invoke/util/VerifyAccess.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/invoke/util/VerifyAccess.java
 ojluni/src/main/java/sun/invoke/util/Wrapper.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/invoke/util/Wrapper.java
@@ -1502,36 +1522,36 @@ ojluni/src/main/java/sun/misc/URLClassPath.java,jdk8u/jdk8u121-b13,jdk/src/share
 ojluni/src/main/java/sun/misc/Unsafe.java,jdk7u/jdk7u40-b60,jdk/src/share/classes/sun/misc/Unsafe.java
 ojluni/src/main/java/sun/misc/VM.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/misc/VM.java
 ojluni/src/main/java/sun/misc/Version.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/misc/Version.java.template
-ojluni/src/main/java/sun/net/ApplicationProxy.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/net/ApplicationProxy.java
-ojluni/src/main/java/sun/net/ConnectionResetException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/sun/net/ConnectionResetException.java
+ojluni/src/main/java/sun/net/ApplicationProxy.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/net/ApplicationProxy.java
+ojluni/src/main/java/sun/net/ConnectionResetException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/net/ConnectionResetException.java
 ojluni/src/main/java/sun/net/ExtendedOptionsImpl.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/net/ExtendedOptionsImpl.java
 ojluni/src/main/java/sun/net/NetHooks.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/net/NetHooks.java
 ojluni/src/main/java/sun/net/NetProperties.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/net/NetProperties.java
 ojluni/src/main/java/sun/net/NetworkClient.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/net/NetworkClient.java
-ojluni/src/main/java/sun/net/ProgressEvent.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/net/ProgressEvent.java
-ojluni/src/main/java/sun/net/ProgressListener.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/net/ProgressListener.java
-ojluni/src/main/java/sun/net/ProgressMeteringPolicy.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/net/ProgressMeteringPolicy.java
+ojluni/src/main/java/sun/net/ProgressEvent.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/net/ProgressEvent.java
+ojluni/src/main/java/sun/net/ProgressListener.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/net/ProgressListener.java
+ojluni/src/main/java/sun/net/ProgressMeteringPolicy.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/net/ProgressMeteringPolicy.java
 ojluni/src/main/java/sun/net/ProgressMonitor.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/net/ProgressMonitor.java
-ojluni/src/main/java/sun/net/ProgressSource.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/net/ProgressSource.java
+ojluni/src/main/java/sun/net/ProgressSource.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/net/ProgressSource.java
 ojluni/src/main/java/sun/net/ResourceManager.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/net/ResourceManager.java
-ojluni/src/main/java/sun/net/SocksProxy.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/net/SocksProxy.java
+ojluni/src/main/java/sun/net/SocksProxy.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/net/SocksProxy.java
 ojluni/src/main/java/sun/net/TelnetInputStream.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/net/TelnetInputStream.java
 ojluni/src/main/java/sun/net/TelnetOutputStream.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/net/TelnetOutputStream.java
-ojluni/src/main/java/sun/net/TelnetProtocolException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/sun/net/TelnetProtocolException.java
-ojluni/src/main/java/sun/net/ext/ExtendedSocketOptions.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/sun/net/ext/ExtendedSocketOptions.java
+ojluni/src/main/java/sun/net/TelnetProtocolException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/net/TelnetProtocolException.java
+ojluni/src/main/java/sun/net/ext/ExtendedSocketOptions.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/net/ext/ExtendedSocketOptions.java
 ojluni/src/main/java/sun/net/ftp/FtpClient.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/net/ftp/FtpClient.java
 ojluni/src/main/java/sun/net/ftp/FtpClientProvider.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/net/ftp/FtpClientProvider.java
-ojluni/src/main/java/sun/net/ftp/FtpDirEntry.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/net/ftp/FtpDirEntry.java
-ojluni/src/main/java/sun/net/ftp/FtpDirParser.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/net/ftp/FtpDirParser.java
-ojluni/src/main/java/sun/net/ftp/FtpLoginException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/sun/net/ftp/FtpLoginException.java
-ojluni/src/main/java/sun/net/ftp/FtpProtocolException.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/sun/net/ftp/FtpProtocolException.java
-ojluni/src/main/java/sun/net/ftp/FtpReplyCode.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/net/ftp/FtpReplyCode.java
-ojluni/src/main/java/sun/net/ftp/impl/DefaultFtpClientProvider.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/net/ftp/impl/DefaultFtpClientProvider.java
+ojluni/src/main/java/sun/net/ftp/FtpDirEntry.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/net/ftp/FtpDirEntry.java
+ojluni/src/main/java/sun/net/ftp/FtpDirParser.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/net/ftp/FtpDirParser.java
+ojluni/src/main/java/sun/net/ftp/FtpLoginException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/net/ftp/FtpLoginException.java
+ojluni/src/main/java/sun/net/ftp/FtpProtocolException.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/net/ftp/FtpProtocolException.java
+ojluni/src/main/java/sun/net/ftp/FtpReplyCode.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/net/ftp/FtpReplyCode.java
+ojluni/src/main/java/sun/net/ftp/impl/DefaultFtpClientProvider.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/net/ftp/impl/DefaultFtpClientProvider.java
 ojluni/src/main/java/sun/net/ftp/impl/FtpClient.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/net/ftp/impl/FtpClient.java
 ojluni/src/main/java/sun/net/spi/DefaultProxySelector.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/net/spi/DefaultProxySelector.java
 ojluni/src/main/java/sun/net/spi/nameservice/NameService.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/net/spi/nameservice/NameService.java
 ojluni/src/main/java/sun/net/util/IPAddressUtil.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/net/util/IPAddressUtil.java
-ojluni/src/main/java/sun/net/util/URLUtil.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/net/util/URLUtil.java
+ojluni/src/main/java/sun/net/util/URLUtil.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/net/util/URLUtil.java
 ojluni/src/main/java/sun/net/www/MessageHeader.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/net/www/MessageHeader.java
 ojluni/src/main/java/sun/net/www/MeteredStream.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/net/www/MeteredStream.java
 ojluni/src/main/java/sun/net/www/ParseUtil.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/net/www/ParseUtil.java
@@ -1539,152 +1559,153 @@ ojluni/src/main/java/sun/net/www/URLConnection.java,jdk8u/jdk8u121-b13,jdk/src/s
 ojluni/src/main/java/sun/net/www/protocol/file/FileURLConnection.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/net/www/protocol/file/FileURLConnection.java
 ojluni/src/main/java/sun/net/www/protocol/file/Handler.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/net/www/protocol/file/Handler.java
 ojluni/src/main/java/sun/net/www/protocol/ftp/FtpURLConnection.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/net/www/protocol/ftp/FtpURLConnection.java
-ojluni/src/main/java/sun/net/www/protocol/ftp/Handler.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/sun/net/www/protocol/ftp/Handler.java
+ojluni/src/main/java/sun/net/www/protocol/ftp/Handler.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/net/www/protocol/ftp/Handler.java
 ojluni/src/main/java/sun/net/www/protocol/jar/Handler.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/net/www/protocol/jar/Handler.java
 ojluni/src/main/java/sun/net/www/protocol/jar/JarFileFactory.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/net/www/protocol/jar/JarFileFactory.java
 ojluni/src/main/java/sun/net/www/protocol/jar/JarURLConnection.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/net/www/protocol/jar/JarURLConnection.java
 ojluni/src/main/java/sun/net/www/protocol/jar/URLJarFile.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/net/www/protocol/jar/URLJarFile.java
-ojluni/src/main/java/sun/nio/ByteBuffered.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ByteBuffered.java
+ojluni/src/main/java/sun/nio/ByteBuffered.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/nio/ByteBuffered.java
 ojluni/src/main/java/sun/nio/ch/AbstractPollArrayWrapper.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/AbstractPollArrayWrapper.java
 ojluni/src/main/java/sun/nio/ch/AbstractPollSelectorImpl.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/AbstractPollSelectorImpl.java
-ojluni/src/main/java/sun/nio/ch/AllocatedNativeObject.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/nio/ch/AllocatedNativeObject.java
+ojluni/src/main/java/sun/nio/ch/AllocatedNativeObject.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/nio/ch/AllocatedNativeObject.java
 ojluni/src/main/java/sun/nio/ch/AsynchronousChannelGroupImpl.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/AsynchronousChannelGroupImpl.java
 ojluni/src/main/java/sun/nio/ch/AsynchronousFileChannelImpl.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/AsynchronousFileChannelImpl.java
 ojluni/src/main/java/sun/nio/ch/AsynchronousServerSocketChannelImpl.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/AsynchronousServerSocketChannelImpl.java
 ojluni/src/main/java/sun/nio/ch/AsynchronousSocketChannelImpl.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/AsynchronousSocketChannelImpl.java
-ojluni/src/main/java/sun/nio/ch/Cancellable.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/nio/ch/Cancellable.java
-ojluni/src/main/java/sun/nio/ch/ChannelInputStream.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/nio/ch/ChannelInputStream.java
-ojluni/src/main/java/sun/nio/ch/CompletedFuture.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/nio/ch/CompletedFuture.java
+ojluni/src/main/java/sun/nio/ch/Cancellable.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/nio/ch/Cancellable.java
+ojluni/src/main/java/sun/nio/ch/ChannelInputStream.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/nio/ch/ChannelInputStream.java
+ojluni/src/main/java/sun/nio/ch/CompletedFuture.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/nio/ch/CompletedFuture.java
 ojluni/src/main/java/sun/nio/ch/DatagramChannelImpl.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/DatagramChannelImpl.java
-ojluni/src/main/java/sun/nio/ch/DatagramDispatcher.java,jdk11u/jdk-11.0.13-ga,src/java.base/unix/classes/sun/nio/ch/DatagramDispatcher.java
+ojluni/src/main/java/sun/nio/ch/DatagramDispatcher.java,jdk11u/jdk-11.0.26-ga,src/java.base/unix/classes/sun/nio/ch/DatagramDispatcher.java
 ojluni/src/main/java/sun/nio/ch/DatagramSocketAdaptor.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/DatagramSocketAdaptor.java
 ojluni/src/main/java/sun/nio/ch/DefaultAsynchronousChannelProvider.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/ch/DefaultAsynchronousChannelProvider.java
 ojluni/src/main/java/sun/nio/ch/DefaultSelectorProvider.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/ch/DefaultSelectorProvider.java
 ojluni/src/main/java/sun/nio/ch/DirectBuffer.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/DirectBuffer.java
 ojluni/src/main/java/sun/nio/ch/EPoll.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/ch/EPoll.java
 ojluni/src/main/java/sun/nio/ch/EPollPort.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/ch/EPollPort.java
-ojluni/src/main/java/sun/nio/ch/ExtendedSocketOption.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/nio/ch/ExtendedSocketOption.java
+ojluni/src/main/java/sun/nio/ch/ExtendedSocketOption.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/nio/ch/ExtendedSocketOption.java
 ojluni/src/main/java/sun/nio/ch/FileChannelImpl.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/FileChannelImpl.java
 # sun.nio.ch.FileDescriptorHolderSocketImpl doesnt come from the upstream OpenJDK.
 ojluni/src/main/java/sun/nio/ch/FileDispatcher.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/FileDispatcher.java
 ojluni/src/main/java/sun/nio/ch/FileDispatcherImpl.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/ch/FileDispatcherImpl.java
-ojluni/src/main/java/sun/nio/ch/FileKey.java,jdk21u/jdk-21.0.4-ga,src/java.base/unix/classes/sun/nio/ch/FileKey.java
-ojluni/src/main/java/sun/nio/ch/FileLockImpl.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/nio/ch/FileLockImpl.java
+ojluni/src/main/java/sun/nio/ch/FileKey.java,jdk21u/jdk-21.0.6-ga,src/java.base/unix/classes/sun/nio/ch/FileKey.java
+ojluni/src/main/java/sun/nio/ch/FileLockImpl.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/nio/ch/FileLockImpl.java
 ojluni/src/main/java/sun/nio/ch/FileLockTable.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/FileLockTable.java
-ojluni/src/main/java/sun/nio/ch/Groupable.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/nio/ch/Groupable.java
-ojluni/src/main/java/sun/nio/ch/IOStatus.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/sun/nio/ch/IOStatus.java
+ojluni/src/main/java/sun/nio/ch/Groupable.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/nio/ch/Groupable.java
+ojluni/src/main/java/sun/nio/ch/IOStatus.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/nio/ch/IOStatus.java
 ojluni/src/main/java/sun/nio/ch/IOUtil.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/IOUtil.java
 ojluni/src/main/java/sun/nio/ch/IOVecWrapper.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/IOVecWrapper.java
-ojluni/src/main/java/sun/nio/ch/Interruptible.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/nio/ch/Interruptible.java
-ojluni/src/main/java/sun/nio/ch/Invoker.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/sun/nio/ch/Invoker.java
-ojluni/src/main/java/sun/nio/ch/LinuxAsynchronousChannelProvider.java,jdk21u/jdk-21.0.4-ga,src/java.base/linux/classes/sun/nio/ch/LinuxAsynchronousChannelProvider.java
-ojluni/src/main/java/sun/nio/ch/MembershipKeyImpl.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/nio/ch/MembershipKeyImpl.java
-ojluni/src/main/java/sun/nio/ch/MembershipRegistry.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/sun/nio/ch/MembershipRegistry.java
-ojluni/src/main/java/sun/nio/ch/NativeDispatcher.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/sun/nio/ch/NativeDispatcher.java
+ojluni/src/main/java/sun/nio/ch/Interruptible.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/nio/ch/Interruptible.java
+ojluni/src/main/java/sun/nio/ch/Invoker.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/nio/ch/Invoker.java
+ojluni/src/main/java/sun/nio/ch/LinuxAsynchronousChannelProvider.java,jdk21u/jdk-21.0.6-ga,src/java.base/linux/classes/sun/nio/ch/LinuxAsynchronousChannelProvider.java
+ojluni/src/main/java/sun/nio/ch/MembershipKeyImpl.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/nio/ch/MembershipKeyImpl.java
+ojluni/src/main/java/sun/nio/ch/MembershipRegistry.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/nio/ch/MembershipRegistry.java
+ojluni/src/main/java/sun/nio/ch/NativeDispatcher.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/nio/ch/NativeDispatcher.java
 ojluni/src/main/java/sun/nio/ch/NativeObject.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/NativeObject.java
-ojluni/src/main/java/sun/nio/ch/NativeThread.java,jdk17u/jdk-17.0.6-ga,src/java.base/unix/classes/sun/nio/ch/NativeThread.java
-ojluni/src/main/java/sun/nio/ch/NativeThreadSet.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/nio/ch/NativeThreadSet.java
+ojluni/src/main/java/sun/nio/ch/NativeThread.java,jdk17u/jdk-17.0.14-ga,src/java.base/unix/classes/sun/nio/ch/NativeThread.java
+ojluni/src/main/java/sun/nio/ch/NativeThreadSet.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/nio/ch/NativeThreadSet.java
 ojluni/src/main/java/sun/nio/ch/Net.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/Net.java
-ojluni/src/main/java/sun/nio/ch/OptionKey.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/nio/ch/OptionKey.java
+ojluni/src/main/java/sun/nio/ch/OptionKey.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/nio/ch/OptionKey.java
 ojluni/src/main/java/sun/nio/ch/PendingFuture.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/PendingFuture.java
-ojluni/src/main/java/sun/nio/ch/PipeImpl.java,jdk21u/jdk-21.0.4-ga,src/java.base/unix/classes/sun/nio/ch/PipeImpl.java
+ojluni/src/main/java/sun/nio/ch/PipeImpl.java,jdk21u/jdk-21.0.6-ga,src/java.base/unix/classes/sun/nio/ch/PipeImpl.java
 ojluni/src/main/java/sun/nio/ch/PollArrayWrapper.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/ch/PollArrayWrapper.java
 ojluni/src/main/java/sun/nio/ch/PollSelectorImpl.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/ch/PollSelectorImpl.java
-ojluni/src/main/java/sun/nio/ch/PollSelectorProvider.java,jdk21u/jdk-21.0.4-ga,src/java.base/unix/classes/sun/nio/ch/PollSelectorProvider.java
-ojluni/src/main/java/sun/nio/ch/Port.java,jdk21u/jdk-21.0.4-ga,src/java.base/unix/classes/sun/nio/ch/Port.java
+ojluni/src/main/java/sun/nio/ch/PollSelectorProvider.java,jdk21u/jdk-21.0.6-ga,src/java.base/unix/classes/sun/nio/ch/PollSelectorProvider.java
+ojluni/src/main/java/sun/nio/ch/Port.java,jdk21u/jdk-21.0.6-ga,src/java.base/unix/classes/sun/nio/ch/Port.java
 ojluni/src/main/java/sun/nio/ch/SelChImpl.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/SelChImpl.java
 ojluni/src/main/java/sun/nio/ch/SelectionKeyImpl.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/SelectionKeyImpl.java
 ojluni/src/main/java/sun/nio/ch/SelectorImpl.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/SelectorImpl.java
-ojluni/src/main/java/sun/nio/ch/SelectorProviderImpl.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/sun/nio/ch/SelectorProviderImpl.java
+ojluni/src/main/java/sun/nio/ch/SelectorProviderImpl.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/nio/ch/SelectorProviderImpl.java
 ojluni/src/main/java/sun/nio/ch/ServerSocketAdaptor.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/ServerSocketAdaptor.java
 ojluni/src/main/java/sun/nio/ch/ServerSocketChannelImpl.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/ServerSocketChannelImpl.java
-ojluni/src/main/java/sun/nio/ch/SimpleAsynchronousFileChannelImpl.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/nio/ch/SimpleAsynchronousFileChannelImpl.java
+ojluni/src/main/java/sun/nio/ch/SimpleAsynchronousFileChannelImpl.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/nio/ch/SimpleAsynchronousFileChannelImpl.java
 ojluni/src/main/java/sun/nio/ch/SinkChannelImpl.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/ch/SinkChannelImpl.java
 ojluni/src/main/java/sun/nio/ch/SocketAdaptor.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/SocketAdaptor.java
 ojluni/src/main/java/sun/nio/ch/SocketChannelImpl.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/SocketChannelImpl.java
 ojluni/src/main/java/sun/nio/ch/SocketDispatcher.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/ch/SocketDispatcher.java
 # sun.nio.ch.SocketOptionRegistry was generated by C code and Make file in 8u121-b13. In the future, we can map this file to
 # src/java.base/share/classes/sun/nio/ch/SocketOptionRegistry.java.template when the file is upgraded to OpenJDK 11
-# ojluni/src/main/java/sun/nio/ch/SocketOptionRegistry.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/sun/nio/ch/SocketOptionRegistry.java.template
+# ojluni/src/main/java/sun/nio/ch/SocketOptionRegistry.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/nio/ch/SocketOptionRegistry.java.template
 ojluni/src/main/java/sun/nio/ch/SourceChannelImpl.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/ch/SourceChannelImpl.java
 ojluni/src/main/java/sun/nio/ch/ThreadPool.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/ThreadPool.java
-ojluni/src/main/java/sun/nio/ch/UnixAsynchronousServerSocketChannelImpl.java,jdk11u/jdk-11.0.13-ga,src/java.base/unix/classes/sun/nio/ch/UnixAsynchronousServerSocketChannelImpl.java
+ojluni/src/main/java/sun/nio/ch/UnixAsynchronousServerSocketChannelImpl.java,jdk11u/jdk-11.0.26-ga,src/java.base/unix/classes/sun/nio/ch/UnixAsynchronousServerSocketChannelImpl.java
 ojluni/src/main/java/sun/nio/ch/UnixAsynchronousSocketChannelImpl.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/ch/UnixAsynchronousSocketChannelImpl.java
-ojluni/src/main/java/sun/nio/ch/UnixDomainSockets.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/nio/ch/UnixDomainSockets.java
-ojluni/src/main/java/sun/nio/ch/UnixDomainSocketsUtil.java,jdk21u/jdk-21.0.4-ga,src/java.base/unix/classes/sun/nio/ch/UnixDomainSocketsUtil.java
+ojluni/src/main/java/sun/nio/ch/UnixDomainSockets.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/nio/ch/UnixDomainSockets.java
+ojluni/src/main/java/sun/nio/ch/UnixDomainSocketsUtil.java,jdk21u/jdk-21.0.6-ga,src/java.base/unix/classes/sun/nio/ch/UnixDomainSocketsUtil.java
 ojluni/src/main/java/sun/nio/ch/Util.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/ch/Util.java
 ojluni/src/main/java/sun/nio/cs/ArrayDecoder.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/cs/ArrayDecoder.java
 ojluni/src/main/java/sun/nio/cs/ArrayEncoder.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/cs/ArrayEncoder.java
-ojluni/src/main/java/sun/nio/cs/HistoricallyNamedCharset.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/nio/cs/HistoricallyNamedCharset.java
+ojluni/src/main/java/sun/nio/cs/HistoricallyNamedCharset.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/nio/cs/HistoricallyNamedCharset.java
 ojluni/src/main/java/sun/nio/cs/StreamDecoder.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/cs/StreamDecoder.java
 ojluni/src/main/java/sun/nio/cs/StreamEncoder.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/cs/StreamEncoder.java
 ojluni/src/main/java/sun/nio/cs/ThreadLocalCoders.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/cs/ThreadLocalCoders.java
-ojluni/src/main/java/sun/nio/fs/AbstractBasicFileAttributeView.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/nio/fs/AbstractBasicFileAttributeView.java
-ojluni/src/main/java/sun/nio/fs/AbstractFileSystemProvider.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/nio/fs/AbstractFileSystemProvider.java
-ojluni/src/main/java/sun/nio/fs/AbstractFileTypeDetector.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/fs/AbstractFileTypeDetector.java
+ojluni/src/main/java/sun/nio/fs/AbstractBasicFileAttributeView.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/nio/fs/AbstractBasicFileAttributeView.java
+ojluni/src/main/java/sun/nio/fs/AbstractFileSystemProvider.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/nio/fs/AbstractFileSystemProvider.java
+ojluni/src/main/java/sun/nio/fs/AbstractFileTypeDetector.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/nio/fs/AbstractFileTypeDetector.java
 ojluni/src/main/java/sun/nio/fs/AbstractPath.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/fs/AbstractPath.java
-ojluni/src/main/java/sun/nio/fs/AbstractPoller.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/fs/AbstractPoller.java
-ojluni/src/main/java/sun/nio/fs/AbstractUserDefinedFileAttributeView.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/sun/nio/fs/AbstractUserDefinedFileAttributeView.java
-ojluni/src/main/java/sun/nio/fs/AbstractWatchKey.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/fs/AbstractWatchKey.java
-ojluni/src/main/java/sun/nio/fs/AbstractWatchService.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/nio/fs/AbstractWatchService.java
-ojluni/src/main/java/sun/nio/fs/BasicFileAttributesHolder.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/nio/fs/BasicFileAttributesHolder.java
-ojluni/src/main/java/sun/nio/fs/Cancellable.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/fs/Cancellable.java
-ojluni/src/main/java/sun/nio/fs/DefaultFileSystemProvider.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/fs/DefaultFileSystemProvider.java
-ojluni/src/main/java/sun/nio/fs/DefaultFileTypeDetector.java,jdk21u/jdk-21.0.4-ga,src/java.base/unix/classes/sun/nio/fs/DefaultFileTypeDetector.java
-ojluni/src/main/java/sun/nio/fs/DynamicFileAttributeView.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/nio/fs/DynamicFileAttributeView.java
-ojluni/src/main/java/sun/nio/fs/FileOwnerAttributeViewImpl.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/nio/fs/FileOwnerAttributeViewImpl.java
-ojluni/src/main/java/sun/nio/fs/Globs.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/nio/fs/Globs.java
-ojluni/src/main/java/sun/nio/fs/LinuxDosFileAttributeView.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/fs/LinuxDosFileAttributeView.java
-ojluni/src/main/java/sun/nio/fs/LinuxFileStore.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/fs/LinuxFileStore.java
-ojluni/src/main/java/sun/nio/fs/LinuxFileSystem.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/fs/LinuxFileSystem.java
-ojluni/src/main/java/sun/nio/fs/LinuxFileSystemProvider.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/fs/LinuxFileSystemProvider.java
-ojluni/src/main/java/sun/nio/fs/LinuxNativeDispatcher.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/fs/LinuxNativeDispatcher.java
-ojluni/src/main/java/sun/nio/fs/LinuxUserDefinedFileAttributeView.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/fs/LinuxUserDefinedFileAttributeView.java
-ojluni/src/main/java/sun/nio/fs/LinuxWatchService.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/fs/LinuxWatchService.java
-ojluni/src/main/java/sun/nio/fs/MimeTypesFileTypeDetector.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/fs/MimeTypesFileTypeDetector.java
-ojluni/src/main/java/sun/nio/fs/NativeBuffer.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/fs/NativeBuffer.java
-ojluni/src/main/java/sun/nio/fs/NativeBuffers.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/fs/NativeBuffers.java
-ojluni/src/main/java/sun/nio/fs/PollingWatchService.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/fs/PollingWatchService.java
+ojluni/src/main/java/sun/nio/fs/AbstractPoller.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/nio/fs/AbstractPoller.java
+ojluni/src/main/java/sun/nio/fs/AbstractUserDefinedFileAttributeView.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/nio/fs/AbstractUserDefinedFileAttributeView.java
+ojluni/src/main/java/sun/nio/fs/AbstractWatchKey.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/nio/fs/AbstractWatchKey.java
+ojluni/src/main/java/sun/nio/fs/AbstractWatchService.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/nio/fs/AbstractWatchService.java
+ojluni/src/main/java/sun/nio/fs/BasicFileAttributesHolder.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/nio/fs/BasicFileAttributesHolder.java
+ojluni/src/main/java/sun/nio/fs/Cancellable.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/nio/fs/Cancellable.java
+ojluni/src/main/java/sun/nio/fs/DefaultFileSystemProvider.java,jdk11u/jdk-11.0.26-ga,src/java.base/linux/classes/sun/nio/fs/DefaultFileSystemProvider.java
+ojluni/src/main/java/sun/nio/fs/DefaultFileTypeDetector.java,jdk21u/jdk-21.0.6-ga,src/java.base/unix/classes/sun/nio/fs/DefaultFileTypeDetector.java
+ojluni/src/main/java/sun/nio/fs/DynamicFileAttributeView.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/nio/fs/DynamicFileAttributeView.java
+ojluni/src/main/java/sun/nio/fs/ExtendedOptions.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/nio/fs/ExtendedOptions.java
+ojluni/src/main/java/sun/nio/fs/FileOwnerAttributeViewImpl.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/nio/fs/FileOwnerAttributeViewImpl.java
+ojluni/src/main/java/sun/nio/fs/Globs.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/nio/fs/Globs.java
+ojluni/src/main/java/sun/nio/fs/LinuxDosFileAttributeView.java,jdk11u/jdk-11.0.26-ga,src/java.base/linux/classes/sun/nio/fs/LinuxDosFileAttributeView.java
+ojluni/src/main/java/sun/nio/fs/LinuxFileStore.java,jdk11u/jdk-11.0.26-ga,src/java.base/linux/classes/sun/nio/fs/LinuxFileStore.java
+ojluni/src/main/java/sun/nio/fs/LinuxFileSystem.java,jdk11u/jdk-11.0.26-ga,src/java.base/linux/classes/sun/nio/fs/LinuxFileSystem.java
+ojluni/src/main/java/sun/nio/fs/LinuxFileSystemProvider.java,jdk11u/jdk-11.0.26-ga,src/java.base/linux/classes/sun/nio/fs/LinuxFileSystemProvider.java
+ojluni/src/main/java/sun/nio/fs/LinuxNativeDispatcher.java,jdk11u/jdk-11.0.26-ga,src/java.base/linux/classes/sun/nio/fs/LinuxNativeDispatcher.java
+ojluni/src/main/java/sun/nio/fs/LinuxUserDefinedFileAttributeView.java,jdk11u/jdk-11.0.26-ga,src/java.base/linux/classes/sun/nio/fs/LinuxUserDefinedFileAttributeView.java
+ojluni/src/main/java/sun/nio/fs/LinuxWatchService.java,jdk11u/jdk-11.0.26-ga,src/java.base/linux/classes/sun/nio/fs/LinuxWatchService.java
+ojluni/src/main/java/sun/nio/fs/MimeTypesFileTypeDetector.java,jdk11u/jdk-11.0.26-ga,src/java.base/unix/classes/sun/nio/fs/MimeTypesFileTypeDetector.java
+ojluni/src/main/java/sun/nio/fs/NativeBuffer.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/nio/fs/NativeBuffer.java
+ojluni/src/main/java/sun/nio/fs/NativeBuffers.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/nio/fs/NativeBuffers.java
+ojluni/src/main/java/sun/nio/fs/PollingWatchService.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/nio/fs/PollingWatchService.java
 ojluni/src/main/java/sun/nio/fs/UnixChannelFactory.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/fs/UnixChannelFactory.java
 # sun.nio.fs.UnixConstants was generated by C code and Make-like file in jdk8u/jdk8u121. But in a later version, the file
 # is generated by a template file, and we can map to the template when the file is upgraded to OpenJDK 11.
-# ojluni/src/main/java/sun/nio/fs/UnixConstants.java,jdk11u/jdk-11.0.13-ga,src/java.base/unix/classes/sun/nio/fs/UnixConstants.java.template
-ojluni/src/main/java/sun/nio/fs/UnixCopyFile.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/fs/UnixCopyFile.java
-ojluni/src/main/java/sun/nio/fs/UnixDirectoryStream.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/fs/UnixDirectoryStream.java
-ojluni/src/main/java/sun/nio/fs/UnixException.java,jdk11u/jdk-11.0.13-ga,src/java.base/unix/classes/sun/nio/fs/UnixException.java
-ojluni/src/main/java/sun/nio/fs/UnixFileAttributeViews.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/fs/UnixFileAttributeViews.java
-ojluni/src/main/java/sun/nio/fs/UnixFileAttributes.java,jdk11u/jdk-11.0.13-ga,src/java.base/unix/classes/sun/nio/fs/UnixFileAttributes.java
-ojluni/src/main/java/sun/nio/fs/UnixFileKey.java,jdk21u/jdk-21.0.4-ga,src/java.base/unix/classes/sun/nio/fs/UnixFileKey.java
-ojluni/src/main/java/sun/nio/fs/UnixFileModeAttribute.java,jdk21u/jdk-21.0.4-ga,src/java.base/unix/classes/sun/nio/fs/UnixFileModeAttribute.java
-ojluni/src/main/java/sun/nio/fs/UnixFileStore.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/fs/UnixFileStore.java
-ojluni/src/main/java/sun/nio/fs/UnixFileStoreAttributes.java,jdk21u/jdk-21.0.4-ga,src/java.base/unix/classes/sun/nio/fs/UnixFileStoreAttributes.java
-ojluni/src/main/java/sun/nio/fs/UnixFileSystem.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/fs/UnixFileSystem.java
-ojluni/src/main/java/sun/nio/fs/UnixFileSystemProvider.java,jdk17u/jdk-17.0.6-ga,src/java.base/unix/classes/sun/nio/fs/UnixFileSystemProvider.java
-ojluni/src/main/java/sun/nio/fs/UnixMountEntry.java,jdk21u/jdk-21.0.4-ga,src/java.base/unix/classes/sun/nio/fs/UnixMountEntry.java
-ojluni/src/main/java/sun/nio/fs/UnixNativeDispatcher.java,jdk17u/jdk-17.0.6-ga,src/java.base/unix/classes/sun/nio/fs/UnixNativeDispatcher.java
-ojluni/src/main/java/sun/nio/fs/UnixPath.java,jdk17u/jdk-17.0.6-ga,src/java.base/unix/classes/sun/nio/fs/UnixPath.java
-ojluni/src/main/java/sun/nio/fs/UnixSecureDirectoryStream.java,jdk11u/jdk-11.0.13-ga,src/java.base/unix/classes/sun/nio/fs/UnixSecureDirectoryStream.java
-ojluni/src/main/java/sun/nio/fs/UnixUriUtils.java,jdk8u/jdk8u121-b13,jdk/src/solaris/classes/sun/nio/fs/UnixUriUtils.java
-ojluni/src/main/java/sun/nio/fs/UnixUserPrincipals.java,jdk11u/jdk-11.0.13-ga,src/java.base/unix/classes/sun/nio/fs/UnixUserPrincipals.java
-ojluni/src/main/java/sun/nio/fs/Util.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/nio/fs/Util.java
+ojluni/src/main/java/sun/nio/fs/UnixConstants.java,jdk11u/jdk-11.0.26-ga,src/java.base/unix/classes/sun/nio/fs/UnixConstants.java.template
+ojluni/src/main/java/sun/nio/fs/UnixCopyFile.java,jdk11u/jdk-11.0.26-ga,src/java.base/unix/classes/sun/nio/fs/UnixCopyFile.java
+ojluni/src/main/java/sun/nio/fs/UnixDirectoryStream.java,jdk11u/jdk-11.0.26-ga,src/java.base/unix/classes/sun/nio/fs/UnixDirectoryStream.java
+ojluni/src/main/java/sun/nio/fs/UnixException.java,jdk11u/jdk-11.0.26-ga,src/java.base/unix/classes/sun/nio/fs/UnixException.java
+ojluni/src/main/java/sun/nio/fs/UnixFileAttributeViews.java,jdk11u/jdk-11.0.26-ga,src/java.base/unix/classes/sun/nio/fs/UnixFileAttributeViews.java
+ojluni/src/main/java/sun/nio/fs/UnixFileAttributes.java,jdk11u/jdk-11.0.26-ga,src/java.base/unix/classes/sun/nio/fs/UnixFileAttributes.java
+ojluni/src/main/java/sun/nio/fs/UnixFileKey.java,jdk21u/jdk-21.0.6-ga,src/java.base/unix/classes/sun/nio/fs/UnixFileKey.java
+ojluni/src/main/java/sun/nio/fs/UnixFileModeAttribute.java,jdk21u/jdk-21.0.6-ga,src/java.base/unix/classes/sun/nio/fs/UnixFileModeAttribute.java
+ojluni/src/main/java/sun/nio/fs/UnixFileStore.java,jdk11u/jdk-11.0.26-ga,src/java.base/unix/classes/sun/nio/fs/UnixFileStore.java
+ojluni/src/main/java/sun/nio/fs/UnixFileStoreAttributes.java,jdk21u/jdk-21.0.6-ga,src/java.base/unix/classes/sun/nio/fs/UnixFileStoreAttributes.java
+ojluni/src/main/java/sun/nio/fs/UnixFileSystem.java,jdk11u/jdk-11.0.26-ga,src/java.base/unix/classes/sun/nio/fs/UnixFileSystem.java
+ojluni/src/main/java/sun/nio/fs/UnixFileSystemProvider.java,jdk17u/jdk-17.0.14-ga,src/java.base/unix/classes/sun/nio/fs/UnixFileSystemProvider.java
+ojluni/src/main/java/sun/nio/fs/UnixMountEntry.java,jdk21u/jdk-21.0.6-ga,src/java.base/unix/classes/sun/nio/fs/UnixMountEntry.java
+ojluni/src/main/java/sun/nio/fs/UnixNativeDispatcher.java,jdk11u/jdk-11.0.26-ga,src/java.base/unix/classes/sun/nio/fs/UnixNativeDispatcher.java
+ojluni/src/main/java/sun/nio/fs/UnixPath.java,jdk11u/jdk-11.0.26-ga,src/java.base/unix/classes/sun/nio/fs/UnixPath.java
+ojluni/src/main/java/sun/nio/fs/UnixSecureDirectoryStream.java,jdk11u/jdk-11.0.26-ga,src/java.base/unix/classes/sun/nio/fs/UnixSecureDirectoryStream.java
+ojluni/src/main/java/sun/nio/fs/UnixUriUtils.java,jdk11u/jdk-11.0.26-ga,src/java.base/unix/classes/sun/nio/fs/UnixUriUtils.java
+ojluni/src/main/java/sun/nio/fs/UnixUserPrincipals.java,jdk11u/jdk-11.0.26-ga,src/java.base/unix/classes/sun/nio/fs/UnixUserPrincipals.java
+ojluni/src/main/java/sun/nio/fs/Util.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/nio/fs/Util.java
 ojluni/src/main/java/sun/reflect/CallerSensitive.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/reflect/CallerSensitive.java
 ojluni/src/main/java/sun/reflect/Reflection.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/reflect/Reflection.java
 ojluni/src/main/java/sun/reflect/misc/ReflectUtil.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/reflect/misc/ReflectUtil.java
-ojluni/src/main/java/sun/security/action/GetBooleanAction.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/action/GetBooleanAction.java
-ojluni/src/main/java/sun/security/action/GetIntegerAction.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/action/GetIntegerAction.java
-ojluni/src/main/java/sun/security/action/GetPropertyAction.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/action/GetPropertyAction.java
-ojluni/src/main/java/sun/security/jca/GetInstance.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/jca/GetInstance.java
+ojluni/src/main/java/sun/security/action/GetBooleanAction.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/action/GetBooleanAction.java
+ojluni/src/main/java/sun/security/action/GetIntegerAction.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/action/GetIntegerAction.java
+ojluni/src/main/java/sun/security/action/GetPropertyAction.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/action/GetPropertyAction.java
+ojluni/src/main/java/sun/security/jca/GetInstance.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/jca/GetInstance.java
 ojluni/src/main/java/sun/security/jca/JCAUtil.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/jca/JCAUtil.java
 ojluni/src/main/java/sun/security/jca/ProviderConfig.java,jdk8u/jdk8u60-b31,jdk/src/share/classes/sun/security/jca/ProviderConfig.java
 ojluni/src/main/java/sun/security/jca/ProviderList.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/jca/ProviderList.java
 ojluni/src/main/java/sun/security/jca/Providers.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/jca/Providers.java
-ojluni/src/main/java/sun/security/jca/ServiceId.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/security/jca/ServiceId.java
+ojluni/src/main/java/sun/security/jca/ServiceId.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/security/jca/ServiceId.java
 ojluni/src/main/java/sun/security/pkcs/ContentInfo.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/pkcs/ContentInfo.java
 ojluni/src/main/java/sun/security/pkcs/PKCS7.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/pkcs/PKCS7.java
 ojluni/src/main/java/sun/security/pkcs/PKCS8Key.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/pkcs/PKCS8Key.java
 ojluni/src/main/java/sun/security/pkcs/PKCS9Attribute.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/pkcs/PKCS9Attribute.java
-ojluni/src/main/java/sun/security/pkcs/PKCS9Attributes.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/pkcs/PKCS9Attributes.java
-ojluni/src/main/java/sun/security/pkcs/ParsingException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/security/pkcs/ParsingException.java
+ojluni/src/main/java/sun/security/pkcs/PKCS9Attributes.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/pkcs/PKCS9Attributes.java
+ojluni/src/main/java/sun/security/pkcs/ParsingException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/security/pkcs/ParsingException.java
 ojluni/src/main/java/sun/security/pkcs/SignerInfo.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/pkcs/SignerInfo.java
 ojluni/src/main/java/sun/security/pkcs/SigningCertificateInfo.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/pkcs/SigningCertificateInfo.java
 # CertPathProvider was introduced in bf0403930ae8d1e86b3914d18b9711eeeec0adb9. Apparently, it came from SunEntries in the upstream.
@@ -1698,64 +1719,64 @@ ojluni/src/main/java/sun/security/provider/certpath/BasicChecker.java,jdk8u/jdk8
 ojluni/src/main/java/sun/security/provider/certpath/BuildStep.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/provider/certpath/BuildStep.java
 ojluni/src/main/java/sun/security/provider/certpath/Builder.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/provider/certpath/Builder.java
 ojluni/src/main/java/sun/security/provider/certpath/CertId.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/provider/certpath/CertId.java
-ojluni/src/main/java/sun/security/provider/certpath/CertPathHelper.java,jdk11u/jdk-11+28,src/java.base/share/classes/sun/security/provider/certpath/CertPathHelper.java
+ojluni/src/main/java/sun/security/provider/certpath/CertPathHelper.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/security/provider/certpath/CertPathHelper.java
 ojluni/src/main/java/sun/security/provider/certpath/CertStoreHelper.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/provider/certpath/CertStoreHelper.java
-ojluni/src/main/java/sun/security/provider/certpath/ConstraintsChecker.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/provider/certpath/ConstraintsChecker.java
+ojluni/src/main/java/sun/security/provider/certpath/ConstraintsChecker.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/provider/certpath/ConstraintsChecker.java
 ojluni/src/main/java/sun/security/provider/certpath/DistributionPointFetcher.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/provider/certpath/DistributionPointFetcher.java
-ojluni/src/main/java/sun/security/provider/certpath/ForwardBuilder.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/sun/security/provider/certpath/ForwardBuilder.java
+ojluni/src/main/java/sun/security/provider/certpath/ForwardBuilder.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/security/provider/certpath/ForwardBuilder.java
 ojluni/src/main/java/sun/security/provider/certpath/ForwardState.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/provider/certpath/ForwardState.java
-ojluni/src/main/java/sun/security/provider/certpath/KeyChecker.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/provider/certpath/KeyChecker.java
+ojluni/src/main/java/sun/security/provider/certpath/KeyChecker.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/provider/certpath/KeyChecker.java
 ojluni/src/main/java/sun/security/provider/certpath/OCSP.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/provider/certpath/OCSP.java
 ojluni/src/main/java/sun/security/provider/certpath/OCSPRequest.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/provider/certpath/OCSPRequest.java
 ojluni/src/main/java/sun/security/provider/certpath/OCSPResponse.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/provider/certpath/OCSPResponse.java
 ojluni/src/main/java/sun/security/provider/certpath/PKIX.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/provider/certpath/PKIX.java
 ojluni/src/main/java/sun/security/provider/certpath/PKIXCertPathValidator.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/provider/certpath/PKIXCertPathValidator.java
-ojluni/src/main/java/sun/security/provider/certpath/PKIXMasterCertPathValidator.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/provider/certpath/PKIXMasterCertPathValidator.java
+ojluni/src/main/java/sun/security/provider/certpath/PKIXMasterCertPathValidator.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/provider/certpath/PKIXMasterCertPathValidator.java
 ojluni/src/main/java/sun/security/provider/certpath/PolicyChecker.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/provider/certpath/PolicyChecker.java
 ojluni/src/main/java/sun/security/provider/certpath/PolicyNodeImpl.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/provider/certpath/PolicyNodeImpl.java
 ojluni/src/main/java/sun/security/provider/certpath/RevocationChecker.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/provider/certpath/RevocationChecker.java
 ojluni/src/main/java/sun/security/provider/certpath/State.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/provider/certpath/State.java
 ojluni/src/main/java/sun/security/provider/certpath/SunCertPathBuilder.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/provider/certpath/SunCertPathBuilder.java
 ojluni/src/main/java/sun/security/provider/certpath/SunCertPathBuilderException.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/provider/certpath/SunCertPathBuilderException.java
-ojluni/src/main/java/sun/security/provider/certpath/SunCertPathBuilderResult.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/provider/certpath/SunCertPathBuilderResult.java
+ojluni/src/main/java/sun/security/provider/certpath/SunCertPathBuilderResult.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/provider/certpath/SunCertPathBuilderResult.java
 ojluni/src/main/java/sun/security/provider/certpath/URICertStore.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/provider/certpath/URICertStore.java
 ojluni/src/main/java/sun/security/provider/certpath/Vertex.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/provider/certpath/Vertex.java
-ojluni/src/main/java/sun/security/provider/certpath/X509CertPath.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/sun/security/provider/certpath/X509CertPath.java
+ojluni/src/main/java/sun/security/provider/certpath/X509CertPath.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/security/provider/certpath/X509CertPath.java
 ojluni/src/main/java/sun/security/provider/certpath/X509CertificatePair.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/provider/certpath/X509CertificatePair.java
 ojluni/src/main/java/sun/security/timestamp/TimestampToken.java,jdk8u/jdk8u60-b31,jdk/src/share/classes/sun/security/timestamp/TimestampToken.java
 ojluni/src/main/java/sun/security/util/AbstractAlgorithmConstraints.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/util/AbstractAlgorithmConstraints.java
-ojluni/src/main/java/sun/security/util/AlgorithmDecomposer.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/util/AlgorithmDecomposer.java
-ojluni/src/main/java/sun/security/util/AnchorCertificates.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/util/AnchorCertificates.java
-ojluni/src/main/java/sun/security/util/BitArray.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/util/BitArray.java
-ojluni/src/main/java/sun/security/util/ByteArrayLexOrder.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/security/util/ByteArrayLexOrder.java
-ojluni/src/main/java/sun/security/util/ByteArrayTagOrder.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/security/util/ByteArrayTagOrder.java
-ojluni/src/main/java/sun/security/util/Cache.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/util/Cache.java
+ojluni/src/main/java/sun/security/util/AlgorithmDecomposer.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/util/AlgorithmDecomposer.java
+ojluni/src/main/java/sun/security/util/AnchorCertificates.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/util/AnchorCertificates.java
+ojluni/src/main/java/sun/security/util/BitArray.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/util/BitArray.java
+ojluni/src/main/java/sun/security/util/ByteArrayLexOrder.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/security/util/ByteArrayLexOrder.java
+ojluni/src/main/java/sun/security/util/ByteArrayTagOrder.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/security/util/ByteArrayTagOrder.java
+ojluni/src/main/java/sun/security/util/Cache.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/util/Cache.java
 ojluni/src/main/java/sun/security/util/CertConstraintParameters.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/util/CertConstraintParameters.java
-ojluni/src/main/java/sun/security/util/ConstraintsParameters.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/security/util/ConstraintsParameters.java
+ojluni/src/main/java/sun/security/util/ConstraintsParameters.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/security/util/ConstraintsParameters.java
 ojluni/src/main/java/sun/security/util/Debug.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/util/Debug.java
-ojluni/src/main/java/sun/security/util/DerEncoder.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/util/DerEncoder.java
+ojluni/src/main/java/sun/security/util/DerEncoder.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/util/DerEncoder.java
 ojluni/src/main/java/sun/security/util/DerIndefLenConverter.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/util/DerIndefLenConverter.java
 ojluni/src/main/java/sun/security/util/DerInputBuffer.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/util/DerInputBuffer.java
 ojluni/src/main/java/sun/security/util/DerInputStream.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/util/DerInputStream.java
 ojluni/src/main/java/sun/security/util/DerOutputStream.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/util/DerOutputStream.java
 ojluni/src/main/java/sun/security/util/DerValue.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/util/DerValue.java
 ojluni/src/main/java/sun/security/util/DisabledAlgorithmConstraints.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/util/DisabledAlgorithmConstraints.java
-ojluni/src/main/java/sun/security/util/FilePaths.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/security/util/FilePaths.java
+ojluni/src/main/java/sun/security/util/FilePaths.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/security/util/FilePaths.java
 ojluni/src/main/java/sun/security/util/KeyUtil.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/util/KeyUtil.java
-ojluni/src/main/java/sun/security/util/Length.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/util/Length.java
+ojluni/src/main/java/sun/security/util/Length.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/util/Length.java
 ojluni/src/main/java/sun/security/util/ManifestDigester.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/util/ManifestDigester.java
 ojluni/src/main/java/sun/security/util/ManifestEntryVerifier.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/util/ManifestEntryVerifier.java
 ojluni/src/main/java/sun/security/util/ObjectIdentifier.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/util/ObjectIdentifier.java
 ojluni/src/main/java/sun/security/util/PropertyExpander.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/util/PropertyExpander.java
 ojluni/src/main/java/sun/security/util/Resources.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/util/Resources.java
 ojluni/src/main/java/sun/security/util/ResourcesMgr.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/util/ResourcesMgr.java
-ojluni/src/main/java/sun/security/util/SecurityConstants.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/util/SecurityConstants.java
-ojluni/src/main/java/sun/security/util/SecurityProperties.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/security/util/SecurityProperties.java
+ojluni/src/main/java/sun/security/util/SecurityConstants.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/util/SecurityConstants.java
+ojluni/src/main/java/sun/security/util/SecurityProperties.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/security/util/SecurityProperties.java
 ojluni/src/main/java/sun/security/util/SignatureFileVerifier.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/util/SignatureFileVerifier.java
 ojluni/src/main/java/sun/security/x509/AVA.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/AVA.java
 ojluni/src/main/java/sun/security/x509/AccessDescription.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/AccessDescription.java
 ojluni/src/main/java/sun/security/x509/AlgorithmId.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/AlgorithmId.java
-ojluni/src/main/java/sun/security/x509/AttributeNameEnumeration.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/sun/security/x509/AttributeNameEnumeration.java
+ojluni/src/main/java/sun/security/x509/AttributeNameEnumeration.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/security/x509/AttributeNameEnumeration.java
 ojluni/src/main/java/sun/security/x509/AuthorityInfoAccessExtension.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/AuthorityInfoAccessExtension.java
 ojluni/src/main/java/sun/security/x509/AuthorityKeyIdentifierExtension.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/AuthorityKeyIdentifierExtension.java
 ojluni/src/main/java/sun/security/x509/BasicConstraintsExtension.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/BasicConstraintsExtension.java
@@ -1763,20 +1784,20 @@ ojluni/src/main/java/sun/security/x509/CRLDistributionPointsExtension.java,jdk8u
 ojluni/src/main/java/sun/security/x509/CRLExtensions.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/CRLExtensions.java
 ojluni/src/main/java/sun/security/x509/CRLNumberExtension.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/CRLNumberExtension.java
 ojluni/src/main/java/sun/security/x509/CRLReasonCodeExtension.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/CRLReasonCodeExtension.java
-ojluni/src/main/java/sun/security/x509/CertAttrSet.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/x509/CertAttrSet.java
-ojluni/src/main/java/sun/security/x509/CertificateAlgorithmId.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/x509/CertificateAlgorithmId.java
+ojluni/src/main/java/sun/security/x509/CertAttrSet.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/x509/CertAttrSet.java
+ojluni/src/main/java/sun/security/x509/CertificateAlgorithmId.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/x509/CertificateAlgorithmId.java
 ojluni/src/main/java/sun/security/x509/CertificateExtensions.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/CertificateExtensions.java
 ojluni/src/main/java/sun/security/x509/CertificateIssuerExtension.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/CertificateIssuerExtension.java
-ojluni/src/main/java/sun/security/x509/CertificateIssuerName.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/x509/CertificateIssuerName.java
+ojluni/src/main/java/sun/security/x509/CertificateIssuerName.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/x509/CertificateIssuerName.java
 ojluni/src/main/java/sun/security/x509/CertificatePoliciesExtension.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/CertificatePoliciesExtension.java
 ojluni/src/main/java/sun/security/x509/CertificatePolicyId.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/CertificatePolicyId.java
-ojluni/src/main/java/sun/security/x509/CertificatePolicyMap.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/x509/CertificatePolicyMap.java
+ojluni/src/main/java/sun/security/x509/CertificatePolicyMap.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/x509/CertificatePolicyMap.java
 ojluni/src/main/java/sun/security/x509/CertificatePolicySet.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/CertificatePolicySet.java
 ojluni/src/main/java/sun/security/x509/CertificateSerialNumber.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/CertificateSerialNumber.java
-ojluni/src/main/java/sun/security/x509/CertificateSubjectName.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/x509/CertificateSubjectName.java
+ojluni/src/main/java/sun/security/x509/CertificateSubjectName.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/x509/CertificateSubjectName.java
 ojluni/src/main/java/sun/security/x509/CertificateValidity.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/CertificateValidity.java
 ojluni/src/main/java/sun/security/x509/CertificateVersion.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/CertificateVersion.java
-ojluni/src/main/java/sun/security/x509/CertificateX509Key.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/x509/CertificateX509Key.java
+ojluni/src/main/java/sun/security/x509/CertificateX509Key.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/x509/CertificateX509Key.java
 ojluni/src/main/java/sun/security/x509/DNSName.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/DNSName.java
 ojluni/src/main/java/sun/security/x509/DeltaCRLIndicatorExtension.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/DeltaCRLIndicatorExtension.java
 ojluni/src/main/java/sun/security/x509/DistributionPoint.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/DistributionPoint.java
@@ -1796,10 +1817,10 @@ ojluni/src/main/java/sun/security/x509/InvalidityDateExtension.java,jdk8u/jdk8u1
 ojluni/src/main/java/sun/security/x509/IssuerAlternativeNameExtension.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/IssuerAlternativeNameExtension.java
 ojluni/src/main/java/sun/security/x509/IssuingDistributionPointExtension.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/IssuingDistributionPointExtension.java
 ojluni/src/main/java/sun/security/x509/KeyIdentifier.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/KeyIdentifier.java
-ojluni/src/main/java/sun/security/x509/KeyUsageExtension.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/x509/KeyUsageExtension.java
+ojluni/src/main/java/sun/security/x509/KeyUsageExtension.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/x509/KeyUsageExtension.java
 ojluni/src/main/java/sun/security/x509/NameConstraintsExtension.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/NameConstraintsExtension.java
 ojluni/src/main/java/sun/security/x509/NetscapeCertTypeExtension.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/NetscapeCertTypeExtension.java
-ojluni/src/main/java/sun/security/x509/OCSPNoCheckExtension.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/x509/OCSPNoCheckExtension.java
+ojluni/src/main/java/sun/security/x509/OCSPNoCheckExtension.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/x509/OCSPNoCheckExtension.java
 ojluni/src/main/java/sun/security/x509/OIDMap.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/OIDMap.java
 ojluni/src/main/java/sun/security/x509/OIDName.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/OIDName.java
 ojluni/src/main/java/sun/security/x509/OtherName.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/OtherName.java
@@ -1812,63 +1833,63 @@ ojluni/src/main/java/sun/security/x509/RDN.java,jdk8u/jdk8u121-b13,jdk/src/share
 ojluni/src/main/java/sun/security/x509/RFC822Name.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/RFC822Name.java
 ojluni/src/main/java/sun/security/x509/ReasonFlags.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/ReasonFlags.java
 ojluni/src/main/java/sun/security/x509/SerialNumber.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/SerialNumber.java
-ojluni/src/main/java/sun/security/x509/SubjectAlternativeNameExtension.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/x509/SubjectAlternativeNameExtension.java
+ojluni/src/main/java/sun/security/x509/SubjectAlternativeNameExtension.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/x509/SubjectAlternativeNameExtension.java
 ojluni/src/main/java/sun/security/x509/SubjectInfoAccessExtension.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/SubjectInfoAccessExtension.java
 ojluni/src/main/java/sun/security/x509/SubjectKeyIdentifierExtension.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/SubjectKeyIdentifierExtension.java
 ojluni/src/main/java/sun/security/x509/URIName.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/URIName.java
 ojluni/src/main/java/sun/security/x509/UniqueIdentity.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/UniqueIdentity.java
 ojluni/src/main/java/sun/security/x509/X400Address.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/X400Address.java
 ojluni/src/main/java/sun/security/x509/X500Name.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/X500Name.java
-ojluni/src/main/java/sun/security/x509/X509AttributeName.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/security/x509/X509AttributeName.java
+ojluni/src/main/java/sun/security/x509/X509AttributeName.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/security/x509/X509AttributeName.java
 ojluni/src/main/java/sun/security/x509/X509CRLEntryImpl.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/X509CRLEntryImpl.java
 ojluni/src/main/java/sun/security/x509/X509CRLImpl.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/X509CRLImpl.java
 ojluni/src/main/java/sun/security/x509/X509CertImpl.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/X509CertImpl.java
 ojluni/src/main/java/sun/security/x509/X509CertInfo.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/X509CertInfo.java
 ojluni/src/main/java/sun/security/x509/X509Key.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/security/x509/X509Key.java
-ojluni/src/main/java/sun/util/PropertyResourceBundleCharset.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/util/PropertyResourceBundleCharset.java
-ojluni/src/main/java/sun/util/ResourceBundleEnumeration.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/util/ResourceBundleEnumeration.java
-ojluni/src/main/java/sun/util/calendar/AbstractCalendar.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/util/calendar/AbstractCalendar.java
-ojluni/src/main/java/sun/util/calendar/BaseCalendar.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/util/calendar/BaseCalendar.java
-ojluni/src/main/java/sun/util/calendar/CalendarDate.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/util/calendar/CalendarDate.java
+ojluni/src/main/java/sun/util/PropertyResourceBundleCharset.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/util/PropertyResourceBundleCharset.java
+ojluni/src/main/java/sun/util/ResourceBundleEnumeration.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/util/ResourceBundleEnumeration.java
+ojluni/src/main/java/sun/util/calendar/AbstractCalendar.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/util/calendar/AbstractCalendar.java
+ojluni/src/main/java/sun/util/calendar/BaseCalendar.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/util/calendar/BaseCalendar.java
+ojluni/src/main/java/sun/util/calendar/CalendarDate.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/util/calendar/CalendarDate.java
 ojluni/src/main/java/sun/util/calendar/CalendarSystem.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/util/calendar/CalendarSystem.java
-ojluni/src/main/java/sun/util/calendar/CalendarUtils.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/util/calendar/CalendarUtils.java
+ojluni/src/main/java/sun/util/calendar/CalendarUtils.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/util/calendar/CalendarUtils.java
 ojluni/src/main/java/sun/util/calendar/Era.java,jdk8u/jdk8u212-b01,jdk/src/share/classes/sun/util/calendar/Era.java
-ojluni/src/main/java/sun/util/calendar/Gregorian.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/util/calendar/Gregorian.java
-ojluni/src/main/java/sun/util/calendar/ImmutableGregorianDate.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/util/calendar/ImmutableGregorianDate.java
-ojluni/src/main/java/sun/util/calendar/JulianCalendar.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/util/calendar/JulianCalendar.java
+ojluni/src/main/java/sun/util/calendar/Gregorian.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/util/calendar/Gregorian.java
+ojluni/src/main/java/sun/util/calendar/ImmutableGregorianDate.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/util/calendar/ImmutableGregorianDate.java
+ojluni/src/main/java/sun/util/calendar/JulianCalendar.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/util/calendar/JulianCalendar.java
 ojluni/src/main/java/sun/util/calendar/LocalGregorianCalendar.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/util/calendar/LocalGregorianCalendar.java
-ojluni/src/main/java/sun/util/locale/BaseLocale.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/util/locale/BaseLocale.java
-ojluni/src/main/java/sun/util/locale/Extension.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/util/locale/Extension.java
-ojluni/src/main/java/sun/util/locale/InternalLocaleBuilder.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/util/locale/InternalLocaleBuilder.java
-ojluni/src/main/java/sun/util/locale/LanguageTag.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/util/locale/LanguageTag.java
+ojluni/src/main/java/sun/util/locale/BaseLocale.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/util/locale/BaseLocale.java
+ojluni/src/main/java/sun/util/locale/Extension.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/util/locale/Extension.java
+ojluni/src/main/java/sun/util/locale/InternalLocaleBuilder.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/util/locale/InternalLocaleBuilder.java
+ojluni/src/main/java/sun/util/locale/LanguageTag.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/util/locale/LanguageTag.java
 ojluni/src/main/java/sun/util/locale/LocaleEquivalentMaps.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/util/locale/LocaleEquivalentMaps.java
-ojluni/src/main/java/sun/util/locale/LocaleExtensions.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/util/locale/LocaleExtensions.java
-ojluni/src/main/java/sun/util/locale/LocaleMatcher.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/util/locale/LocaleMatcher.java
-ojluni/src/main/java/sun/util/locale/LocaleObjectCache.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/util/locale/LocaleObjectCache.java
-ojluni/src/main/java/sun/util/locale/LocaleSyntaxException.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/util/locale/LocaleSyntaxException.java
-ojluni/src/main/java/sun/util/locale/LocaleUtils.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/util/locale/LocaleUtils.java
-ojluni/src/main/java/sun/util/locale/ParseStatus.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/util/locale/ParseStatus.java
-ojluni/src/main/java/sun/util/locale/StringTokenIterator.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/util/locale/StringTokenIterator.java
-ojluni/src/main/java/sun/util/locale/UnicodeLocaleExtension.java,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/sun/util/locale/UnicodeLocaleExtension.java
-ojluni/src/main/java/sun/util/locale/provider/CalendarDataUtility.java,jdk11u/jdk-11.0.13-ga,src/java.base/share/classes/sun/util/locale/provider/CalendarDataUtility.java
+ojluni/src/main/java/sun/util/locale/LocaleExtensions.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/util/locale/LocaleExtensions.java
+ojluni/src/main/java/sun/util/locale/LocaleMatcher.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/util/locale/LocaleMatcher.java
+ojluni/src/main/java/sun/util/locale/LocaleObjectCache.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/util/locale/LocaleObjectCache.java
+ojluni/src/main/java/sun/util/locale/LocaleSyntaxException.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/util/locale/LocaleSyntaxException.java
+ojluni/src/main/java/sun/util/locale/LocaleUtils.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/util/locale/LocaleUtils.java
+ojluni/src/main/java/sun/util/locale/ParseStatus.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/util/locale/ParseStatus.java
+ojluni/src/main/java/sun/util/locale/StringTokenIterator.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/util/locale/StringTokenIterator.java
+ojluni/src/main/java/sun/util/locale/UnicodeLocaleExtension.java,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/sun/util/locale/UnicodeLocaleExtension.java
+ojluni/src/main/java/sun/util/locale/provider/CalendarDataUtility.java,jdk11u/jdk-11.0.26-ga,src/java.base/share/classes/sun/util/locale/provider/CalendarDataUtility.java
 ojluni/src/main/java/sun/util/logging/LoggingProxy.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/util/logging/LoggingProxy.java
 ojluni/src/main/java/sun/util/logging/LoggingSupport.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/util/logging/LoggingSupport.java
 ojluni/src/main/java/sun/util/logging/PlatformLogger.java,jdk8u/jdk8u121-b13,jdk/src/share/classes/sun/util/logging/PlatformLogger.java
-ojluni/src/main/java/sun/util/resources/OpenListResourceBundle.java,jdk17u/jdk-17.0.6-ga,src/java.base/share/classes/sun/util/resources/OpenListResourceBundle.java
-ojluni/src/main/native/Adler32.c,jdk21u/jdk-21.0.4-ga,src/java.base/share/native/libzip/Adler32.c
-ojluni/src/main/native/CRC32.c,jdk21u/jdk-21.0.4-ga,src/java.base/share/native/libzip/CRC32.c
+ojluni/src/main/java/sun/util/resources/OpenListResourceBundle.java,jdk17u/jdk-17.0.14-ga,src/java.base/share/classes/sun/util/resources/OpenListResourceBundle.java
+ojluni/src/main/native/Adler32.c,jdk21u/jdk-21.0.6-ga,src/java.base/share/native/libzip/Adler32.c
+ojluni/src/main/native/CRC32.c,jdk21u/jdk-21.0.6-ga,src/java.base/share/native/libzip/CRC32.c
 # Character.cpp doesnt come from the upstream OpenJDK.
 ojluni/src/main/native/Console_md.c,jdk8u/jdk8u121-b13,jdk/src/solaris/native/java/io/Console_md.c
 ojluni/src/main/native/DatagramChannelImpl.c,jdk8u/jdk8u121-b13,jdk/src/solaris/native/sun/nio/ch/DatagramChannelImpl.c
 ojluni/src/main/native/DatagramDispatcher.c,jdk8u/jdk8u121-b13,jdk/src/solaris/native/sun/nio/ch/DatagramDispatcher.c
-ojluni/src/main/native/Deflater.c,jdk21u/jdk-21.0.4-ga,src/java.base/share/native/libzip/Deflater.c
+ojluni/src/main/native/Deflater.c,jdk21u/jdk-21.0.6-ga,src/java.base/share/native/libzip/Deflater.c
 ojluni/src/main/native/Double.c,jdk8u/jdk8u121-b13,jdk/src/share/native/java/lang/Double.c
 ojluni/src/main/native/EPoll.c,jdk8u/jdk8u121-b13,jdk/src/solaris/native/sun/nio/ch/EPoll.c
 ojluni/src/main/native/EPollPort.c,jdk8u/jdk8u121-b13,jdk/src/solaris/native/sun/nio/ch/EPollPort.c
 ojluni/src/main/native/FileChannelImpl.c,jdk8u/jdk8u121-b13,jdk/src/solaris/native/sun/nio/ch/FileChannelImpl.c
 ojluni/src/main/native/FileDescriptor_md.c,jdk7u/jdk7u40-b60,jdk/src/solaris/native/java/io/FileDescriptor_md.c
 ojluni/src/main/native/FileDispatcherImpl.c,jdk8u/jdk8u121-b13,jdk/src/solaris/native/sun/nio/ch/FileDispatcherImpl.c
-ojluni/src/main/native/FileInputStream.c,jdk21u/jdk-21.0.4-ga,src/java.base/share/native/libjava/FileInputStream.c
+ojluni/src/main/native/FileInputStream.c,jdk21u/jdk-21.0.6-ga,src/java.base/share/native/libjava/FileInputStream.c
 ojluni/src/main/native/FileKey.c,jdk7u/jdk7u40-b60,jdk/src/solaris/native/sun/nio/ch/FileKey.c
 ojluni/src/main/native/FileSystemPreferences.c,jdk7u/jdk7u40-b60,jdk/src/solaris/native/java/util/FileSystemPreferences.c
 ojluni/src/main/native/Float.c,jdk8u/jdk8u121-b13,jdk/src/share/native/java/lang/Float.c
@@ -1876,9 +1897,9 @@ ojluni/src/main/native/IOUtil.c,jdk8u/jdk8u121-b13,jdk/src/solaris/native/sun/ni
 ojluni/src/main/native/Inet4Address.c,jdk7u/jdk7u40-b60,jdk/src/share/native/java/net/Inet4Address.c
 ojluni/src/main/native/Inet6Address.c,jdk8u/jdk8u121-b13,jdk/src/share/native/java/net/Inet6Address.c
 ojluni/src/main/native/InetAddress.c,jdk8u/jdk8u60-b31,jdk/src/share/native/java/net/InetAddress.c
-ojluni/src/main/native/Inflater.c,jdk21u/jdk-21.0.4-ga,src/java.base/share/native/libzip/Inflater.c
+ojluni/src/main/native/Inflater.c,jdk21u/jdk-21.0.6-ga,src/java.base/share/native/libzip/Inflater.c
 # JniConstants.cpp doesnt come from the upstream OpenJDK.
-ojluni/src/main/native/LinuxNativeDispatcher.c,jdk8u/jdk8u121-b13,jdk/src/solaris/native/sun/nio/fs/LinuxNativeDispatcher.c
+ojluni/src/main/native/LinuxNativeDispatcher.c,jdk11u/jdk-11.0.26-ga,src/java.base/linux/native/libnio/fs/LinuxNativeDispatcher.c
 ojluni/src/main/native/LinuxWatchService.c,jdk8u/jdk8u121-b13,jdk/src/solaris/native/sun/nio/fs/LinuxWatchService.c
 ojluni/src/main/native/MappedByteBuffer.c,jdk8u/jdk8u121-b13,jdk/src/solaris/native/java/nio/MappedByteBuffer.c
 # Math.c doesnt come from the upstream OpenJDK.
@@ -1901,852 +1922,850 @@ ojluni/src/main/native/UNIXProcess_md.c,jdk7u/jdk7u40-b60,jdk/src/solaris/native
 ojluni/src/main/native/UnixAsynchronousServerSocketChannelImpl.c,jdk8u/jdk8u121-b13,jdk/src/solaris/native/sun/nio/ch/UnixAsynchronousServerSocketChannelImpl.c
 ojluni/src/main/native/UnixAsynchronousSocketChannelImpl.c,jdk8u/jdk8u121-b13,jdk/src/solaris/native/sun/nio/ch/UnixAsynchronousSocketChannelImpl.c
 ojluni/src/main/native/UnixCopyFile.c,jdk8u/jdk8u121-b13,jdk/src/solaris/native/sun/nio/fs/UnixCopyFile.c
-ojluni/src/main/native/UnixDomainSockets.c,jdk17u/jdk-17.0.6-ga,src/java.base/unix/native/libnio/ch/UnixDomainSockets.c
-ojluni/src/main/native/UnixFileSystem_md.c,jdk11u/jdk-11.0.13-ga,src/java.base/unix/native/libjava/UnixFileSystem_md.c
-ojluni/src/main/native/UnixNativeDispatcher.c,jdk8u/jdk8u60-b31,jdk/src/solaris/native/sun/nio/fs/UnixNativeDispatcher.c
-ojluni/src/main/native/ZipFile.c,jdk8u/jdk8u60-b31,jdk/src/share/native/java/util/zip/ZipFile.c
+ojluni/src/main/native/UnixDomainSockets.c,jdk17u/jdk-17.0.14-ga,src/java.base/unix/native/libnio/ch/UnixDomainSockets.c
+ojluni/src/main/native/UnixFileSystem_md.c,jdk11u/jdk-11.0.26-ga,src/java.base/unix/native/libjava/UnixFileSystem_md.c
+ojluni/src/main/native/UnixNativeDispatcher.c,jdk11u/jdk-11.0.26-ga,src/java.base/unix/native/libnio/fs/UnixNativeDispatcher.c
 ojluni/src/main/native/canonicalize_md.c,jdk7u/jdk7u40-b60,jdk/src/solaris/native/java/io/canonicalize_md.c
 ojluni/src/main/native/io_util.c,jdk7u/jdk7u40-b60,jdk/src/share/native/java/io/io_util.c
-ojluni/src/main/native/io_util_md.c,jdk17u/jdk-17.0.10-ga,src/java.base/unix/native/libjava/io_util_md.c
-ojluni/src/main/native/io_util_md.h,jdk21u/jdk-21.0.4-ga,src/java.base/unix/native/libjava/io_util_md.h
-ojluni/src/main/native/jlong.h,jdk21u/jdk-21.0.4-ga,src/java.base/share/native/libjava/jlong.h
-ojluni/src/main/native/jlong_md.h,jdk21u/jdk-21.0.4-ga,src/java.base/unix/native/libjava/jlong_md.h
+ojluni/src/main/native/io_util_md.c,jdk17u/jdk-17.0.14-ga,src/java.base/unix/native/libjava/io_util_md.c
+ojluni/src/main/native/io_util_md.h,jdk21u/jdk-21.0.6-ga,src/java.base/unix/native/libjava/io_util_md.h
+ojluni/src/main/native/jlong.h,jdk21u/jdk-21.0.6-ga,src/java.base/share/native/libjava/jlong.h
+ojluni/src/main/native/jlong_md.h,jdk21u/jdk-21.0.6-ga,src/java.base/unix/native/libjava/jlong_md.h
 ojluni/src/main/native/jni_util.c,jdk8u/jdk8u60-b31,jdk/src/share/native/common/jni_util.c
-ojluni/src/main/native/jni_util_md.c,jdk17u/jdk-17.0.6-ga,src/java.base/unix/native/libjava/jni_util_md.c
+ojluni/src/main/native/jni_util_md.c,jdk17u/jdk-17.0.14-ga,src/java.base/unix/native/libjava/jni_util_md.c
 ojluni/src/main/native/linux_close.cpp,jdk7u/jdk7u40-b60,jdk/src/solaris/native/java/net/linux_close.c
 ojluni/src/main/native/net_util.c,jdk8u/jdk8u121-b13,jdk/src/share/native/java/net/net_util.c
 ojluni/src/main/native/net_util_md.c,jdk7u/jdk7u40-b60,jdk/src/solaris/native/java/net/net_util_md.c
 # socket_tagger_util.cpp doesnt come from the upstream OpenJDK.
-ojluni/src/main/native/zip_util.c,jdk17u/jdk-17.0.6-ga,src/java.base/share/native/libzip/zip_util.c
-ojluni/src/main/native/zip_util.h,jdk17u/jdk-17.0.6-ga,src/java.base/share/native/libzip/zip_util.h
 ojluni/src/main/resources/calendars.properties,jdk8u/jdk8u212-b01,jdk/src/share/lib/calendars.properties
-ojluni/src/main/resources/java/time/chrono/hijrah-config-Hijrah-umalqura_islamic-umalqura.properties,jdk21u/jdk-21.0.4-ga,src/java.base/share/classes/java/time/chrono/hijrah-config-Hijrah-umalqura_islamic-umalqura.properties
-ojluni/src/test/java/io/CharArrayReader/ReadCharBuffer.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/io/CharArrayReader/ReadCharBuffer.java
+ojluni/src/main/resources/java/time/chrono/hijrah-config-Hijrah-umalqura_islamic-umalqura.properties,jdk21u/jdk-21.0.6-ga,src/java.base/share/classes/java/time/chrono/hijrah-config-Hijrah-umalqura_islamic-umalqura.properties
+ojluni/src/test/java/io/CharArrayReader/ReadCharBuffer.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/io/CharArrayReader/ReadCharBuffer.java
 ojluni/src/test/java/io/FileInputStream/ReadXBytes.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/io/FileInputStream/ReadXBytes.java
-ojluni/src/test/java/io/InputStreamReader/ReadCharBuffer.java,jdk17u/jdk-17.0.10-ga,test/jdk/java/io/InputStreamReader/ReadCharBuffer.java
-ojluni/src/test/java/io/Reader/NullReader.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/io/Reader/NullReader.java
-ojluni/src/test/java/io/Reader/TransferTo.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/io/Reader/TransferTo.java
-ojluni/src/test/java/io/Serializable/records/AbsentStreamValuesTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/io/Serializable/records/AbsentStreamValuesTest.java
-ojluni/src/test/java/io/Serializable/records/BadValues.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/io/Serializable/records/BadValues.java
-ojluni/src/test/java/io/Serializable/records/BasicRecordSer.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/io/Serializable/records/BasicRecordSer.java
-ojluni/src/test/java/io/Serializable/records/ConstructorAccessTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/io/Serializable/records/ConstructorAccessTest.java
-ojluni/src/test/java/io/Serializable/records/CycleTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/io/Serializable/records/CycleTest.java
-ojluni/src/test/java/io/Serializable/records/ReadResolveTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/io/Serializable/records/ReadResolveTest.java
-ojluni/src/test/java/io/Serializable/records/RecordClassTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/io/Serializable/records/RecordClassTest.java
-ojluni/src/test/java/io/Serializable/records/SerialVersionUIDTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/io/Serializable/records/SerialVersionUIDTest.java
-ojluni/src/test/java/io/Serializable/records/StreamRefTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/io/Serializable/records/StreamRefTest.java
-ojluni/src/test/java/io/Serializable/records/ThrowingConstructorTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/io/Serializable/records/ThrowingConstructorTest.java
-ojluni/src/test/java/io/Serializable/records/UnsharedTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/io/Serializable/records/UnsharedTest.java
-ojluni/src/test/java/io/Serializable/records/WriteReplaceTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/io/Serializable/records/WriteReplaceTest.java
-ojluni/src/test/java/io/Writer/Append.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/io/Writer/Append.java
-ojluni/src/test/java/io/Writer/NullWriter.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/io/Writer/NullWriter.java
-ojluni/src/test/java/lang/AbstractCompressExpandTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/AbstractCompressExpandTest.java
-ojluni/src/test/java/lang/CharSequence/Emptiness.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/CharSequence/Emptiness.java
-ojluni/src/test/java/lang/Character/CharacterName.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Character/CharacterName.java
-ojluni/src/test/java/lang/Character/Supplementary.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/lang/Character/Supplementary.java
-ojluni/src/test/java/lang/Character/UnicodeBlock/CheckBlocks.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Character/UnicodeBlock/CheckBlocks.java
-ojluni/src/test/java/lang/CompressExpandSanityTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/CompressExpandSanityTest.java
-ojluni/src/test/java/lang/CompressExpandTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/CompressExpandTest.java
-ojluni/src/test/java/lang/Double/BitwiseConversion.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Double/BitwiseConversion.java
-ojluni/src/test/java/lang/Double/Constants.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Double/Constants.java
-ojluni/src/test/java/lang/Double/Extrema.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Double/Extrema.java
-ojluni/src/test/java/lang/Double/NaNInfinityParsing.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Double/NaNInfinityParsing.java
-ojluni/src/test/java/lang/Double/ParseDouble.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Double/ParseDouble.java
-ojluni/src/test/java/lang/Double/ParseHexFloatingPoint.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Double/ParseHexFloatingPoint.java
-ojluni/src/test/java/lang/Double/ToHexString.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Double/ToHexString.java
-ojluni/src/test/java/lang/Double/ToString.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Double/ToString.java
-ojluni/src/test/java/lang/Float/Binary16Conversion.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Float/Binary16Conversion.java
-ojluni/src/test/java/lang/Float/Binary16ConversionNaN.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Float/Binary16ConversionNaN.java
-ojluni/src/test/java/lang/Float/BitwiseConversion.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Float/BitwiseConversion.java
-ojluni/src/test/java/lang/Float/Constants.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Float/Constants.java
-ojluni/src/test/java/lang/Float/Extrema.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Float/Extrema.java
-ojluni/src/test/java/lang/Float/NaNInfinityParsing.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Float/NaNInfinityParsing.java
-ojluni/src/test/java/lang/Float/ParseFloat.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Float/ParseFloat.java
-ojluni/src/test/java/lang/Integer/BitTwiddle.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Integer/BitTwiddle.java
-ojluni/src/test/java/lang/Integer/Decode.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Integer/Decode.java
-ojluni/src/test/java/lang/Integer/GetInteger.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Integer/GetInteger.java
-ojluni/src/test/java/lang/Integer/ParsingTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Integer/ParsingTest.java
-ojluni/src/test/java/lang/Integer/ToString.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Integer/ToString.java
-ojluni/src/test/java/lang/Integer/Unsigned.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Integer/Unsigned.java
-ojluni/src/test/java/lang/Integer/ValueOf.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Integer/ValueOf.java
-ojluni/src/test/java/lang/Long/BitTwiddle.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Long/BitTwiddle.java
-ojluni/src/test/java/lang/Long/Decode.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Long/Decode.java
-ojluni/src/test/java/lang/Long/GetLong.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Long/GetLong.java
-ojluni/src/test/java/lang/Long/ParsingTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Long/ParsingTest.java
-ojluni/src/test/java/lang/Long/ToString.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Long/ToString.java
-ojluni/src/test/java/lang/Long/Unsigned.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Long/Unsigned.java
-ojluni/src/test/java/lang/Math/Clamp.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Math/Clamp.java
-ojluni/src/test/java/lang/Math/DivModTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Math/DivModTests.java
-ojluni/src/test/java/lang/Math/ExactArithTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Math/ExactArithTests.java
-ojluni/src/test/java/lang/Math/MultiplicationTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/Math/MultiplicationTests.java
-ojluni/src/test/java/lang/StackWalker/AcrossThreads.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StackWalker/AcrossThreads.java
-ojluni/src/test/java/lang/StackWalker/Basic.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StackWalker/Basic.java
-ojluni/src/test/java/lang/StackWalker/CallerFromMain.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/lang/StackWalker/CallerFromMain.java
-ojluni/src/test/java/lang/StackWalker/DumpStackTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/lang/StackWalker/DumpStackTest.java
-ojluni/src/test/java/lang/StackWalker/EmbeddedStackWalkTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StackWalker/EmbeddedStackWalkTest.java
-ojluni/src/test/java/lang/StackWalker/GetCallerClassTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StackWalker/GetCallerClassTest.java
-ojluni/src/test/java/lang/StackWalker/HiddenFrames.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/lang/StackWalker/HiddenFrames.java
-ojluni/src/test/java/lang/StackWalker/LocalsAndOperands.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StackWalker/LocalsAndOperands.java
-ojluni/src/test/java/lang/StackWalker/MultiThreadStackWalk.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StackWalker/MultiThreadStackWalk.java
-ojluni/src/test/java/lang/StackWalker/NativeMethod.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/lang/StackWalker/NativeMethod.java
-ojluni/src/test/java/lang/StackWalker/ReflectionFrames.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/lang/StackWalker/ReflectionFrames.java
-ojluni/src/test/java/lang/StackWalker/SanityTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StackWalker/SanityTest.java
-ojluni/src/test/java/lang/StackWalker/SecurityExceptions.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StackWalker/SecurityExceptions.java
-ojluni/src/test/java/lang/StackWalker/StackRecorderUtil.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StackWalker/StackRecorderUtil.java
-ojluni/src/test/java/lang/StackWalker/StackStreamState.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StackWalker/StackStreamState.java
-ojluni/src/test/java/lang/StackWalker/StackStreamTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/lang/StackWalker/StackStreamTest.java
-ojluni/src/test/java/lang/StackWalker/StackWalkTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/lang/StackWalker/StackWalkTest.java
+ojluni/src/test/java/io/InputStreamReader/ReadCharBuffer.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/io/InputStreamReader/ReadCharBuffer.java
+ojluni/src/test/java/io/Reader/NullReader.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/io/Reader/NullReader.java
+ojluni/src/test/java/io/Reader/TransferTo.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/io/Reader/TransferTo.java
+ojluni/src/test/java/io/Serializable/records/AbsentStreamValuesTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/io/Serializable/records/AbsentStreamValuesTest.java
+ojluni/src/test/java/io/Serializable/records/BadValues.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/io/Serializable/records/BadValues.java
+ojluni/src/test/java/io/Serializable/records/BasicRecordSer.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/io/Serializable/records/BasicRecordSer.java
+ojluni/src/test/java/io/Serializable/records/ConstructorAccessTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/io/Serializable/records/ConstructorAccessTest.java
+ojluni/src/test/java/io/Serializable/records/CycleTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/io/Serializable/records/CycleTest.java
+ojluni/src/test/java/io/Serializable/records/ReadResolveTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/io/Serializable/records/ReadResolveTest.java
+ojluni/src/test/java/io/Serializable/records/RecordClassTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/io/Serializable/records/RecordClassTest.java
+ojluni/src/test/java/io/Serializable/records/SerialVersionUIDTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/io/Serializable/records/SerialVersionUIDTest.java
+ojluni/src/test/java/io/Serializable/records/StreamRefTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/io/Serializable/records/StreamRefTest.java
+ojluni/src/test/java/io/Serializable/records/ThrowingConstructorTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/io/Serializable/records/ThrowingConstructorTest.java
+ojluni/src/test/java/io/Serializable/records/UnsharedTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/io/Serializable/records/UnsharedTest.java
+ojluni/src/test/java/io/Serializable/records/WriteReplaceTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/io/Serializable/records/WriteReplaceTest.java
+ojluni/src/test/java/io/Writer/Append.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/io/Writer/Append.java
+ojluni/src/test/java/io/Writer/NullWriter.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/io/Writer/NullWriter.java
+ojluni/src/test/java/lang/AbstractCompressExpandTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/AbstractCompressExpandTest.java
+ojluni/src/test/java/lang/CharSequence/Emptiness.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/CharSequence/Emptiness.java
+ojluni/src/test/java/lang/Character/CharacterName.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Character/CharacterName.java
+ojluni/src/test/java/lang/Character/Supplementary.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/lang/Character/Supplementary.java
+ojluni/src/test/java/lang/Character/UnicodeBlock/CheckBlocks.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Character/UnicodeBlock/CheckBlocks.java
+ojluni/src/test/java/lang/CompressExpandSanityTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/CompressExpandSanityTest.java
+ojluni/src/test/java/lang/CompressExpandTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/CompressExpandTest.java
+ojluni/src/test/java/lang/Double/BitwiseConversion.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Double/BitwiseConversion.java
+ojluni/src/test/java/lang/Double/Constants.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Double/Constants.java
+ojluni/src/test/java/lang/Double/Extrema.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Double/Extrema.java
+ojluni/src/test/java/lang/Double/NaNInfinityParsing.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Double/NaNInfinityParsing.java
+ojluni/src/test/java/lang/Double/ParseDouble.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Double/ParseDouble.java
+ojluni/src/test/java/lang/Double/ParseHexFloatingPoint.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Double/ParseHexFloatingPoint.java
+ojluni/src/test/java/lang/Double/ToHexString.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Double/ToHexString.java
+ojluni/src/test/java/lang/Double/ToString.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Double/ToString.java
+ojluni/src/test/java/lang/Float/Binary16Conversion.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Float/Binary16Conversion.java
+ojluni/src/test/java/lang/Float/Binary16ConversionNaN.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Float/Binary16ConversionNaN.java
+ojluni/src/test/java/lang/Float/BitwiseConversion.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Float/BitwiseConversion.java
+ojluni/src/test/java/lang/Float/Constants.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Float/Constants.java
+ojluni/src/test/java/lang/Float/Extrema.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Float/Extrema.java
+ojluni/src/test/java/lang/Float/NaNInfinityParsing.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Float/NaNInfinityParsing.java
+ojluni/src/test/java/lang/Float/ParseFloat.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Float/ParseFloat.java
+ojluni/src/test/java/lang/Integer/BitTwiddle.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Integer/BitTwiddle.java
+ojluni/src/test/java/lang/Integer/Decode.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Integer/Decode.java
+ojluni/src/test/java/lang/Integer/GetInteger.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Integer/GetInteger.java
+ojluni/src/test/java/lang/Integer/ParsingTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Integer/ParsingTest.java
+ojluni/src/test/java/lang/Integer/ToString.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Integer/ToString.java
+ojluni/src/test/java/lang/Integer/Unsigned.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Integer/Unsigned.java
+ojluni/src/test/java/lang/Integer/ValueOf.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Integer/ValueOf.java
+ojluni/src/test/java/lang/Long/BitTwiddle.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Long/BitTwiddle.java
+ojluni/src/test/java/lang/Long/Decode.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Long/Decode.java
+ojluni/src/test/java/lang/Long/GetLong.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Long/GetLong.java
+ojluni/src/test/java/lang/Long/ParsingTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Long/ParsingTest.java
+ojluni/src/test/java/lang/Long/ToString.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Long/ToString.java
+ojluni/src/test/java/lang/Long/Unsigned.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Long/Unsigned.java
+ojluni/src/test/java/lang/Math/Clamp.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Math/Clamp.java
+ojluni/src/test/java/lang/Math/DivModTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Math/DivModTests.java
+ojluni/src/test/java/lang/Math/ExactArithTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Math/ExactArithTests.java
+ojluni/src/test/java/lang/Math/MultiplicationTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/Math/MultiplicationTests.java
+ojluni/src/test/java/lang/StackWalker/AcrossThreads.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StackWalker/AcrossThreads.java
+ojluni/src/test/java/lang/StackWalker/Basic.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StackWalker/Basic.java
+ojluni/src/test/java/lang/StackWalker/CallerFromMain.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/StackWalker/CallerFromMain.java
+ojluni/src/test/java/lang/StackWalker/DumpStackTest.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/lang/StackWalker/DumpStackTest.java
+ojluni/src/test/java/lang/StackWalker/EmbeddedStackWalkTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StackWalker/EmbeddedStackWalkTest.java
+ojluni/src/test/java/lang/StackWalker/GetCallerClassTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StackWalker/GetCallerClassTest.java
+ojluni/src/test/java/lang/StackWalker/HiddenFrames.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/lang/StackWalker/HiddenFrames.java
+ojluni/src/test/java/lang/StackWalker/LocalsAndOperands.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StackWalker/LocalsAndOperands.java
+ojluni/src/test/java/lang/StackWalker/MultiThreadStackWalk.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StackWalker/MultiThreadStackWalk.java
+ojluni/src/test/java/lang/StackWalker/NativeMethod.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/lang/StackWalker/NativeMethod.java
+ojluni/src/test/java/lang/StackWalker/ReflectionFrames.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/lang/StackWalker/ReflectionFrames.java
+ojluni/src/test/java/lang/StackWalker/SanityTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StackWalker/SanityTest.java
+ojluni/src/test/java/lang/StackWalker/SecurityExceptions.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StackWalker/SecurityExceptions.java
+ojluni/src/test/java/lang/StackWalker/StackRecorderUtil.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StackWalker/StackRecorderUtil.java
+ojluni/src/test/java/lang/StackWalker/StackStreamState.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StackWalker/StackStreamState.java
+ojluni/src/test/java/lang/StackWalker/StackStreamTest.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/lang/StackWalker/StackStreamTest.java
+ojluni/src/test/java/lang/StackWalker/StackWalkTest.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/lang/StackWalker/StackWalkTest.java
 # The test TestBCI analyses .class files, but Android runs dex codes.
-# ojluni/src/test/java/lang/StackWalker/TestBCI.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/lang/StackWalker/TestBCI.java
-ojluni/src/test/java/lang/StackWalker/VerifyStackTrace.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/lang/StackWalker/VerifyStackTrace.java
-ojluni/src/test/java/lang/StackWalker/WalkFunction.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StackWalker/WalkFunction.java
-ojluni/src/test/java/lang/String/Transform.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/String/Transform.java
-ojluni/src/test/java/lang/StringBuffer/AppendCharSequence.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/StringBuffer/AppendCharSequence.java
-ojluni/src/test/java/lang/StringBuffer/AppendSB.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StringBuffer/AppendSB.java
-ojluni/src/test/java/lang/StringBuffer/AppendStringBuilder.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StringBuffer/AppendStringBuilder.java
-ojluni/src/test/java/lang/StringBuffer/BufferForwarding.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StringBuffer/BufferForwarding.java
-ojluni/src/test/java/lang/StringBuffer/Capacity.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StringBuffer/Capacity.java
-ojluni/src/test/java/lang/StringBuffer/CompactStringBuffer.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/StringBuffer/CompactStringBuffer.java
-ojluni/src/test/java/lang/StringBuffer/Comparison.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StringBuffer/Comparison.java
-ojluni/src/test/java/lang/StringBuffer/GetCharsOverLength.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StringBuffer/GetCharsOverLength.java
-ojluni/src/test/java/lang/StringBuffer/GetCharsSrcEndLarger.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StringBuffer/GetCharsSrcEndLarger.java
-ojluni/src/test/java/lang/StringBuffer/IndexOf.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StringBuffer/IndexOf.java
-ojluni/src/test/java/lang/StringBuffer/InsertMaxValue.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StringBuffer/InsertMaxValue.java
-ojluni/src/test/java/lang/StringBuffer/InsertNullString.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StringBuffer/InsertNullString.java
-ojluni/src/test/java/lang/StringBuffer/Replace.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StringBuffer/Replace.java
-ojluni/src/test/java/lang/StringBuffer/SetLength.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StringBuffer/SetLength.java
-ojluni/src/test/java/lang/StringBuffer/Substring.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StringBuffer/Substring.java
-ojluni/src/test/java/lang/StringBuffer/Supplementary.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/StringBuffer/Supplementary.java
-ojluni/src/test/java/lang/StringBuffer/Trim.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StringBuffer/Trim.java
-ojluni/src/test/java/lang/StringBuilder/AppendStringBuffer.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StringBuilder/AppendStringBuffer.java
-ojluni/src/test/java/lang/StringBuilder/BuilderForwarding.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StringBuilder/BuilderForwarding.java
-ojluni/src/test/java/lang/StringBuilder/CompactStringBuilder.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/lang/StringBuilder/CompactStringBuilder.java
-ojluni/src/test/java/lang/StringBuilder/Comparison.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StringBuilder/Comparison.java
-ojluni/src/test/java/lang/StringBuilder/EnsureCapacity.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StringBuilder/EnsureCapacity.java
-ojluni/src/test/java/lang/StringBuilder/Insert.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/StringBuilder/Insert.java
-ojluni/src/test/java/lang/StringBuilder/Supplementary.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/StringBuilder/Supplementary.java
-ojluni/src/test/java/lang/UCDFiles.java,jdk21u/jdk-21.0.4-ga,test/jdk/lib/testlibrary/java/lang/UCDFiles.java
-ojluni/src/test/java/lang/constant/ConvertTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/constant/ConvertTest.java
-ojluni/src/test/java/lang/constant/DynamicConstantDescTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/constant/DynamicConstantDescTest.java
-ojluni/src/test/java/lang/constant/NameValidationTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/constant/NameValidationTest.java
-ojluni/src/test/java/lang/constant/access_test/pkg1/MethodTypeDescriptorAccessTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/lang/constant/access_test/pkg1/MethodTypeDescriptorAccessTest.java
-ojluni/src/test/java/lang/constant/access_test/pkg2/NonPublicClass.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/constant/access_test/pkg2/NonPublicClass.java
-ojluni/src/test/java/lang/constant/access_test/pkg2/PublicClass.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/constant/access_test/pkg2/PublicClass.java
-ojluni/src/test/java/lang/invoke/ClassValueTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/invoke/ClassValueTest.java
-ojluni/src/test/java/lang/invoke/MethodHandlesGeneralTest.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/MethodHandlesGeneralTest.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleBaseByteArrayTest.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleBaseByteArrayTest.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleBaseTest.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleBaseTest.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleMethodReferenceTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleMethodReferenceTest.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessBoolean.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestAccessBoolean.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessByte.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestAccessByte.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessChar.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestAccessChar.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessDouble.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestAccessDouble.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessFloat.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestAccessFloat.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessInt.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestAccessInt.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessLong.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestAccessLong.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessModeMethodNames.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestAccessModeMethodNames.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessShort.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestAccessShort.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessString.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestAccessString.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsChar.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsChar.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsDouble.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsDouble.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsFloat.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsFloat.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsInt.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsInt.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsLong.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsLong.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsShort.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsShort.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessBoolean.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessBoolean.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessByte.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessByte.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessChar.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessChar.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessDouble.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessDouble.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessFloat.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessFloat.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessInt.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessInt.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessLong.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessLong.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessShort.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessShort.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessString.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessString.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodTypeBoolean.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodTypeBoolean.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodTypeByte.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodTypeByte.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodTypeChar.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodTypeChar.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodTypeDouble.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodTypeDouble.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodTypeFloat.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodTypeFloat.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodTypeInt.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodTypeInt.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodTypeLong.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodTypeLong.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodTypeShort.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodTypeShort.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodTypeString.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodTypeString.java
-ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestReflection.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestReflection.java
-ojluni/src/test/java/lang/invoke/VarHandles/X-VarHandleTestAccess.java.template,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/X-VarHandleTestAccess.java.template
-ojluni/src/test/java/lang/invoke/VarHandles/X-VarHandleTestByteArrayView.java.template,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/X-VarHandleTestByteArrayView.java.template
-ojluni/src/test/java/lang/invoke/VarHandles/X-VarHandleTestMethodHandleAccess.java.template,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/X-VarHandleTestMethodHandleAccess.java.template
-ojluni/src/test/java/lang/invoke/VarHandles/X-VarHandleTestMethodType.java.template,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/X-VarHandleTestMethodType.java.template
-ojluni/src/test/java/lang/invoke/VarHandles/accessibility/TestFieldLookupAccessibility.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/accessibility/TestFieldLookupAccessibility.java
-ojluni/src/test/java/lang/invoke/VarHandles/accessibility/pkg/A.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/invoke/VarHandles/accessibility/pkg/A.java
-ojluni/src/test/java/lang/invoke/VarHandles/accessibility/pkg/B_extends_A.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/invoke/VarHandles/accessibility/pkg/B_extends_A.java
-ojluni/src/test/java/lang/invoke/VarHandles/accessibility/pkg/C.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/invoke/VarHandles/accessibility/pkg/C.java
-ojluni/src/test/java/lang/invoke/VarHandles/accessibility/pkg/subpkg/B_extends_A.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/invoke/VarHandles/accessibility/pkg/subpkg/B_extends_A.java
-ojluni/src/test/java/lang/invoke/VarHandles/accessibility/pkg/subpkg/C.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/invoke/VarHandles/accessibility/pkg/subpkg/C.java
-ojluni/src/test/java/lang/invoke/VarHandles/generate-vh-tests.sh,jdk11u/jdk-11.0.13-ga,test/jdk/java/lang/invoke/VarHandles/generate-vh-tests.sh
-ojluni/src/test/java/lang/ref/CleanerTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/ref/CleanerTest.java
-ojluni/src/test/java/lang/reflect/records/CheckEqualityIsBasedOnFields.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/reflect/records/CheckEqualityIsBasedOnFields.java
-ojluni/src/test/java/lang/reflect/records/RecordReflectionTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/lang/reflect/records/RecordReflectionTest.java
-ojluni/src/test/java/lang/runtime/ObjectMethodsTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/runtime/ObjectMethodsTest.java
-ojluni/src/test/java/lang/runtime/SwitchBootstrapsTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/lang/runtime/SwitchBootstrapsTest.java
-ojluni/src/test/java/math/BigDecimal/AddTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigDecimal/AddTests.java
-ojluni/src/test/java/math/BigDecimal/CompareToTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigDecimal/CompareToTests.java
-ojluni/src/test/java/math/BigDecimal/Constructor.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigDecimal/Constructor.java
-ojluni/src/test/java/math/BigDecimal/ConstructorUnscaledValue.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigDecimal/ConstructorUnscaledValue.java
-ojluni/src/test/java/math/BigDecimal/DivideMcTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigDecimal/DivideMcTests.java
-ojluni/src/test/java/math/BigDecimal/DivideTests.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/math/BigDecimal/DivideTests.java
-ojluni/src/test/java/math/BigDecimal/EqualsTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigDecimal/EqualsTests.java
-ojluni/src/test/java/math/BigDecimal/FloatDoubleValueTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigDecimal/FloatDoubleValueTests.java
-ojluni/src/test/java/math/BigDecimal/IntValueExactTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigDecimal/IntValueExactTests.java
-ojluni/src/test/java/math/BigDecimal/IntegralDivisionTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigDecimal/IntegralDivisionTests.java
-ojluni/src/test/java/math/BigDecimal/IntegralValueTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigDecimal/IntegralValueTests.java
-ojluni/src/test/java/math/BigDecimal/LongValueExactTests.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/math/BigDecimal/LongValueExactTests.java
-ojluni/src/test/java/math/BigDecimal/MultiplyTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigDecimal/MultiplyTests.java
-ojluni/src/test/java/math/BigDecimal/NegateTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigDecimal/NegateTests.java
-ojluni/src/test/java/math/BigDecimal/PowTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigDecimal/PowTests.java
-ojluni/src/test/java/math/BigDecimal/PrecisionTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigDecimal/PrecisionTests.java
-ojluni/src/test/java/math/BigDecimal/RangeTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigDecimal/RangeTests.java
-ojluni/src/test/java/math/BigDecimal/RoundingTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigDecimal/RoundingTests.java
-ojluni/src/test/java/math/BigDecimal/ScaleByPowerOfTenTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigDecimal/ScaleByPowerOfTenTests.java
-ojluni/src/test/java/math/BigDecimal/SerializationTests.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/math/BigDecimal/SerializationTests.java
-ojluni/src/test/java/math/BigDecimal/SquareRootTests.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/math/BigDecimal/SquareRootTests.java
-ojluni/src/test/java/math/BigDecimal/StringConstructor.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/math/BigDecimal/StringConstructor.java
-ojluni/src/test/java/math/BigDecimal/StrippingZerosTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigDecimal/StrippingZerosTest.java
-ojluni/src/test/java/math/BigDecimal/ToPlainStringTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigDecimal/ToPlainStringTests.java
-ojluni/src/test/java/math/BigDecimal/ZeroScalingTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigDecimal/ZeroScalingTests.java
-ojluni/src/test/java/math/BigInteger/BigIntegerTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/math/BigInteger/BigIntegerTest.java
-ojluni/src/test/java/math/BigInteger/BitLengthOverflow.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigInteger/BitLengthOverflow.java
-ojluni/src/test/java/math/BigInteger/CompareToTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigInteger/CompareToTests.java
-ojluni/src/test/java/math/BigInteger/DoubleValueOverflow.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigInteger/DoubleValueOverflow.java
-ojluni/src/test/java/math/BigInteger/ExtremeShiftingTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigInteger/ExtremeShiftingTests.java
-ojluni/src/test/java/math/BigInteger/LargeValueExceptions.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/math/BigInteger/LargeValueExceptions.java
-ojluni/src/test/java/math/BigInteger/ModInvTime.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigInteger/ModInvTime.java
-ojluni/src/test/java/math/BigInteger/ModPow.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigInteger/ModPow.java
-ojluni/src/test/java/math/BigInteger/ModPow65537.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigInteger/ModPow65537.java
-ojluni/src/test/java/math/BigInteger/ModPowPowersof2.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigInteger/ModPowPowersof2.java
-ojluni/src/test/java/math/BigInteger/OperatorNpeTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigInteger/OperatorNpeTests.java
-ojluni/src/test/java/math/BigInteger/PrimeTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/math/BigInteger/PrimeTest.java
-ojluni/src/test/java/math/BigInteger/PrimitiveConversionTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigInteger/PrimitiveConversionTests.java
-ojluni/src/test/java/math/BigInteger/ProbablePrime.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigInteger/ProbablePrime.java
-ojluni/src/test/java/math/BigInteger/SerializationTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigInteger/SerializationTests.java
-ojluni/src/test/java/math/BigInteger/StringConstructor.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigInteger/StringConstructor.java
-ojluni/src/test/java/math/BigInteger/TestValueExact.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigInteger/TestValueExact.java
-ojluni/src/test/java/math/BigInteger/UnicodeConstructor.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/math/BigInteger/UnicodeConstructor.java
-ojluni/src/test/java/net/InetAddress/B5087907.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/net/InetAddress/B5087907.java
-ojluni/src/test/java/net/InetAddress/B6246242.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/net/InetAddress/B6246242.java
-ojluni/src/test/java/net/InetAddress/B6296240.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/net/InetAddress/B6296240.java
-ojluni/src/test/java/net/InetAddress/BadDottedIPAddress.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/net/InetAddress/BadDottedIPAddress.java
-ojluni/src/test/java/net/InetAddress/CachedUnknownHostName.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/net/InetAddress/CachedUnknownHostName.java
-ojluni/src/test/java/net/InetAddress/GetLoopbackAddress.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/net/InetAddress/GetLoopbackAddress.java
-ojluni/src/test/java/net/InetAddress/HashSpread.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/net/InetAddress/HashSpread.java
-ojluni/src/test/java/net/InetAddress/InternalNameServiceWithNoHostsFileTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/net/InetAddress/InternalNameServiceWithNoHostsFileTest.java
-ojluni/src/test/java/net/InetAddress/IsReachable.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/net/InetAddress/IsReachable.java
-ojluni/src/test/java/net/InetAddress/WhiteSpaceHostTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/net/InetAddress/WhiteSpaceHostTest.java
-ojluni/src/test/java/net/InetSocketAddress/B4849451.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/net/InetSocketAddress/B4849451.java
-ojluni/src/test/java/net/InetSocketAddress/B6469803.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/net/InetSocketAddress/B6469803.java
-ojluni/src/test/java/net/InetSocketAddress/CreateUnresolved.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/net/InetSocketAddress/CreateUnresolved.java
-ojluni/src/test/java/net/InetSocketAddress/ToString.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/net/InetSocketAddress/ToString.java
+# ojluni/src/test/java/lang/StackWalker/TestBCI.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/lang/StackWalker/TestBCI.java
+ojluni/src/test/java/lang/StackWalker/VerifyStackTrace.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/lang/StackWalker/VerifyStackTrace.java
+ojluni/src/test/java/lang/StackWalker/WalkFunction.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StackWalker/WalkFunction.java
+ojluni/src/test/java/lang/String/Transform.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/String/Transform.java
+ojluni/src/test/java/lang/StringBuffer/AppendCharSequence.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/StringBuffer/AppendCharSequence.java
+ojluni/src/test/java/lang/StringBuffer/AppendSB.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StringBuffer/AppendSB.java
+ojluni/src/test/java/lang/StringBuffer/AppendStringBuilder.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StringBuffer/AppendStringBuilder.java
+ojluni/src/test/java/lang/StringBuffer/BufferForwarding.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StringBuffer/BufferForwarding.java
+ojluni/src/test/java/lang/StringBuffer/Capacity.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StringBuffer/Capacity.java
+ojluni/src/test/java/lang/StringBuffer/CompactStringBuffer.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/StringBuffer/CompactStringBuffer.java
+ojluni/src/test/java/lang/StringBuffer/Comparison.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StringBuffer/Comparison.java
+ojluni/src/test/java/lang/StringBuffer/GetCharsOverLength.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StringBuffer/GetCharsOverLength.java
+ojluni/src/test/java/lang/StringBuffer/GetCharsSrcEndLarger.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StringBuffer/GetCharsSrcEndLarger.java
+ojluni/src/test/java/lang/StringBuffer/IndexOf.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StringBuffer/IndexOf.java
+ojluni/src/test/java/lang/StringBuffer/InsertMaxValue.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StringBuffer/InsertMaxValue.java
+ojluni/src/test/java/lang/StringBuffer/InsertNullString.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StringBuffer/InsertNullString.java
+ojluni/src/test/java/lang/StringBuffer/Replace.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StringBuffer/Replace.java
+ojluni/src/test/java/lang/StringBuffer/SetLength.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StringBuffer/SetLength.java
+ojluni/src/test/java/lang/StringBuffer/Substring.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StringBuffer/Substring.java
+ojluni/src/test/java/lang/StringBuffer/Supplementary.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/StringBuffer/Supplementary.java
+ojluni/src/test/java/lang/StringBuffer/Trim.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StringBuffer/Trim.java
+ojluni/src/test/java/lang/StringBuilder/AppendStringBuffer.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StringBuilder/AppendStringBuffer.java
+ojluni/src/test/java/lang/StringBuilder/BuilderForwarding.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StringBuilder/BuilderForwarding.java
+ojluni/src/test/java/lang/StringBuilder/CompactStringBuilder.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/lang/StringBuilder/CompactStringBuilder.java
+ojluni/src/test/java/lang/StringBuilder/Comparison.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StringBuilder/Comparison.java
+ojluni/src/test/java/lang/StringBuilder/EnsureCapacity.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StringBuilder/EnsureCapacity.java
+ojluni/src/test/java/lang/StringBuilder/Insert.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/StringBuilder/Insert.java
+ojluni/src/test/java/lang/StringBuilder/Supplementary.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/StringBuilder/Supplementary.java
+ojluni/src/test/java/lang/UCDFiles.java,jdk21u/jdk-21.0.6-ga,test/jdk/lib/testlibrary/java/lang/UCDFiles.java
+ojluni/src/test/java/lang/constant/ConvertTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/constant/ConvertTest.java
+ojluni/src/test/java/lang/constant/DynamicConstantDescTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/constant/DynamicConstantDescTest.java
+ojluni/src/test/java/lang/constant/NameValidationTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/constant/NameValidationTest.java
+ojluni/src/test/java/lang/constant/access_test/pkg1/MethodTypeDescriptorAccessTest.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/lang/constant/access_test/pkg1/MethodTypeDescriptorAccessTest.java
+ojluni/src/test/java/lang/constant/access_test/pkg2/NonPublicClass.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/constant/access_test/pkg2/NonPublicClass.java
+ojluni/src/test/java/lang/constant/access_test/pkg2/PublicClass.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/constant/access_test/pkg2/PublicClass.java
+ojluni/src/test/java/lang/invoke/ClassValueTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/invoke/ClassValueTest.java
+ojluni/src/test/java/lang/invoke/MethodHandlesGeneralTest.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/MethodHandlesGeneralTest.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleBaseByteArrayTest.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleBaseByteArrayTest.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleBaseTest.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleBaseTest.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleMethodReferenceTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleMethodReferenceTest.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessBoolean.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestAccessBoolean.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessByte.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestAccessByte.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessChar.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestAccessChar.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessDouble.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestAccessDouble.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessFloat.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestAccessFloat.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessInt.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestAccessInt.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessLong.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestAccessLong.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessModeMethodNames.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestAccessModeMethodNames.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessShort.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestAccessShort.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessString.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestAccessString.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsChar.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsChar.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsDouble.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsDouble.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsFloat.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsFloat.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsInt.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsInt.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsLong.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsLong.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsShort.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsShort.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessBoolean.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessBoolean.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessByte.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessByte.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessChar.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessChar.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessDouble.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessDouble.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessFloat.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessFloat.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessInt.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessInt.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessLong.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessLong.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessShort.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessShort.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessString.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessString.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodTypeBoolean.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodTypeBoolean.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodTypeByte.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodTypeByte.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodTypeChar.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodTypeChar.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodTypeDouble.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodTypeDouble.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodTypeFloat.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodTypeFloat.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodTypeInt.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodTypeInt.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodTypeLong.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodTypeLong.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodTypeShort.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodTypeShort.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodTypeString.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodTypeString.java
+ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestReflection.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/invoke/VarHandles/VarHandleTestReflection.java
+ojluni/src/test/java/lang/invoke/VarHandles/X-VarHandleTestAccess.java.template,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/X-VarHandleTestAccess.java.template
+ojluni/src/test/java/lang/invoke/VarHandles/X-VarHandleTestByteArrayView.java.template,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/X-VarHandleTestByteArrayView.java.template
+ojluni/src/test/java/lang/invoke/VarHandles/X-VarHandleTestMethodHandleAccess.java.template,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/X-VarHandleTestMethodHandleAccess.java.template
+ojluni/src/test/java/lang/invoke/VarHandles/X-VarHandleTestMethodType.java.template,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/X-VarHandleTestMethodType.java.template
+ojluni/src/test/java/lang/invoke/VarHandles/accessibility/TestFieldLookupAccessibility.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/accessibility/TestFieldLookupAccessibility.java
+ojluni/src/test/java/lang/invoke/VarHandles/accessibility/pkg/A.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/invoke/VarHandles/accessibility/pkg/A.java
+ojluni/src/test/java/lang/invoke/VarHandles/accessibility/pkg/B_extends_A.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/invoke/VarHandles/accessibility/pkg/B_extends_A.java
+ojluni/src/test/java/lang/invoke/VarHandles/accessibility/pkg/C.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/invoke/VarHandles/accessibility/pkg/C.java
+ojluni/src/test/java/lang/invoke/VarHandles/accessibility/pkg/subpkg/B_extends_A.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/invoke/VarHandles/accessibility/pkg/subpkg/B_extends_A.java
+ojluni/src/test/java/lang/invoke/VarHandles/accessibility/pkg/subpkg/C.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/invoke/VarHandles/accessibility/pkg/subpkg/C.java
+ojluni/src/test/java/lang/invoke/VarHandles/generate-vh-tests.sh,jdk11u/jdk-11.0.26-ga,test/jdk/java/lang/invoke/VarHandles/generate-vh-tests.sh
+ojluni/src/test/java/lang/ref/CleanerTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/ref/CleanerTest.java
+ojluni/src/test/java/lang/reflect/records/CheckEqualityIsBasedOnFields.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/reflect/records/CheckEqualityIsBasedOnFields.java
+ojluni/src/test/java/lang/reflect/records/RecordReflectionTest.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/lang/reflect/records/RecordReflectionTest.java
+ojluni/src/test/java/lang/runtime/ObjectMethodsTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/runtime/ObjectMethodsTest.java
+ojluni/src/test/java/lang/runtime/SwitchBootstrapsTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/lang/runtime/SwitchBootstrapsTest.java
+ojluni/src/test/java/math/BigDecimal/AddTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigDecimal/AddTests.java
+ojluni/src/test/java/math/BigDecimal/CompareToTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigDecimal/CompareToTests.java
+ojluni/src/test/java/math/BigDecimal/Constructor.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigDecimal/Constructor.java
+ojluni/src/test/java/math/BigDecimal/ConstructorUnscaledValue.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigDecimal/ConstructorUnscaledValue.java
+ojluni/src/test/java/math/BigDecimal/DivideMcTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigDecimal/DivideMcTests.java
+ojluni/src/test/java/math/BigDecimal/DivideTests.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/math/BigDecimal/DivideTests.java
+ojluni/src/test/java/math/BigDecimal/EqualsTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigDecimal/EqualsTests.java
+ojluni/src/test/java/math/BigDecimal/FloatDoubleValueTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigDecimal/FloatDoubleValueTests.java
+ojluni/src/test/java/math/BigDecimal/IntValueExactTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigDecimal/IntValueExactTests.java
+ojluni/src/test/java/math/BigDecimal/IntegralDivisionTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigDecimal/IntegralDivisionTests.java
+ojluni/src/test/java/math/BigDecimal/IntegralValueTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigDecimal/IntegralValueTests.java
+ojluni/src/test/java/math/BigDecimal/LongValueExactTests.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/math/BigDecimal/LongValueExactTests.java
+ojluni/src/test/java/math/BigDecimal/MultiplyTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigDecimal/MultiplyTests.java
+ojluni/src/test/java/math/BigDecimal/NegateTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigDecimal/NegateTests.java
+ojluni/src/test/java/math/BigDecimal/PowTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigDecimal/PowTests.java
+ojluni/src/test/java/math/BigDecimal/PrecisionTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigDecimal/PrecisionTests.java
+ojluni/src/test/java/math/BigDecimal/RangeTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigDecimal/RangeTests.java
+ojluni/src/test/java/math/BigDecimal/RoundingTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigDecimal/RoundingTests.java
+ojluni/src/test/java/math/BigDecimal/ScaleByPowerOfTenTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigDecimal/ScaleByPowerOfTenTests.java
+ojluni/src/test/java/math/BigDecimal/SerializationTests.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/math/BigDecimal/SerializationTests.java
+ojluni/src/test/java/math/BigDecimal/SquareRootTests.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/math/BigDecimal/SquareRootTests.java
+ojluni/src/test/java/math/BigDecimal/StringConstructor.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/math/BigDecimal/StringConstructor.java
+ojluni/src/test/java/math/BigDecimal/StrippingZerosTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigDecimal/StrippingZerosTest.java
+ojluni/src/test/java/math/BigDecimal/ToPlainStringTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigDecimal/ToPlainStringTests.java
+ojluni/src/test/java/math/BigDecimal/ZeroScalingTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigDecimal/ZeroScalingTests.java
+ojluni/src/test/java/math/BigInteger/BigIntegerTest.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/math/BigInteger/BigIntegerTest.java
+ojluni/src/test/java/math/BigInteger/BitLengthOverflow.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigInteger/BitLengthOverflow.java
+ojluni/src/test/java/math/BigInteger/CompareToTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigInteger/CompareToTests.java
+ojluni/src/test/java/math/BigInteger/DoubleValueOverflow.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigInteger/DoubleValueOverflow.java
+ojluni/src/test/java/math/BigInteger/ExtremeShiftingTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigInteger/ExtremeShiftingTests.java
+ojluni/src/test/java/math/BigInteger/LargeValueExceptions.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/math/BigInteger/LargeValueExceptions.java
+ojluni/src/test/java/math/BigInteger/ModInvTime.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigInteger/ModInvTime.java
+ojluni/src/test/java/math/BigInteger/ModPow.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigInteger/ModPow.java
+ojluni/src/test/java/math/BigInteger/ModPow65537.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigInteger/ModPow65537.java
+ojluni/src/test/java/math/BigInteger/ModPowPowersof2.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigInteger/ModPowPowersof2.java
+ojluni/src/test/java/math/BigInteger/OperatorNpeTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigInteger/OperatorNpeTests.java
+ojluni/src/test/java/math/BigInteger/PrimeTest.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/math/BigInteger/PrimeTest.java
+ojluni/src/test/java/math/BigInteger/PrimitiveConversionTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigInteger/PrimitiveConversionTests.java
+ojluni/src/test/java/math/BigInteger/ProbablePrime.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigInteger/ProbablePrime.java
+ojluni/src/test/java/math/BigInteger/SerializationTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigInteger/SerializationTests.java
+ojluni/src/test/java/math/BigInteger/StringConstructor.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigInteger/StringConstructor.java
+ojluni/src/test/java/math/BigInteger/TestValueExact.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigInteger/TestValueExact.java
+ojluni/src/test/java/math/BigInteger/UnicodeConstructor.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/math/BigInteger/UnicodeConstructor.java
+ojluni/src/test/java/net/InetAddress/B5087907.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/net/InetAddress/B5087907.java
+ojluni/src/test/java/net/InetAddress/B6246242.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/net/InetAddress/B6246242.java
+ojluni/src/test/java/net/InetAddress/B6296240.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/net/InetAddress/B6296240.java
+ojluni/src/test/java/net/InetAddress/BadDottedIPAddress.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/net/InetAddress/BadDottedIPAddress.java
+ojluni/src/test/java/net/InetAddress/CachedUnknownHostName.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/net/InetAddress/CachedUnknownHostName.java
+ojluni/src/test/java/net/InetAddress/GetLoopbackAddress.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/net/InetAddress/GetLoopbackAddress.java
+ojluni/src/test/java/net/InetAddress/HashSpread.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/net/InetAddress/HashSpread.java
+ojluni/src/test/java/net/InetAddress/InternalNameServiceWithNoHostsFileTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/net/InetAddress/InternalNameServiceWithNoHostsFileTest.java
+ojluni/src/test/java/net/InetAddress/IsReachable.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/net/InetAddress/IsReachable.java
+ojluni/src/test/java/net/InetAddress/WhiteSpaceHostTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/net/InetAddress/WhiteSpaceHostTest.java
+ojluni/src/test/java/net/InetSocketAddress/B4849451.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/net/InetSocketAddress/B4849451.java
+ojluni/src/test/java/net/InetSocketAddress/B6469803.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/net/InetSocketAddress/B6469803.java
+ojluni/src/test/java/net/InetSocketAddress/CreateUnresolved.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/net/InetSocketAddress/CreateUnresolved.java
+ojluni/src/test/java/net/InetSocketAddress/ToString.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/net/InetSocketAddress/ToString.java
 ojluni/src/test/java/net/Socks/SocksIPv6Test.java,jdk8u/jdk8u222-b03,jdk/test/java/net/Socks/SocksIPv6Test.java
 ojluni/src/test/java/net/Socks/SocksServer.java,jdk8u/jdk8u222-b03,jdk/test/java/net/Socks/SocksServer.java
-ojluni/src/test/java/net/UnixDomainSocketAddress/LengthTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/net/UnixDomainSocketAddress/LengthTest.java
-ojluni/src/test/java/net/UnixDomainSocketAddress/UnixDomainSocketAddressSerializationTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/net/UnixDomainSocketAddress/UnixDomainSocketAddressSerializationTest.java
-ojluni/src/test/java/nio/Buffer/AllocateDirectInit.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/nio/Buffer/AllocateDirectInit.java
-ojluni/src/test/java/nio/Buffer/Basic-X.java.template,jdk17u/jdk-17.0.6-ga,test/jdk/java/nio/Buffer/Basic-X.java.template
-ojluni/src/test/java/nio/Buffer/Basic.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/nio/Buffer/Basic.java
-ojluni/src/test/java/nio/Buffer/BulkPutBuffer.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/nio/Buffer/BulkPutBuffer.java
-ojluni/src/test/java/nio/Buffer/ByteBufferViews.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/nio/Buffer/ByteBufferViews.java
-ojluni/src/test/java/nio/Buffer/Chars.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/nio/Buffer/Chars.java
-ojluni/src/test/java/nio/Buffer/Chew.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/nio/Buffer/Chew.java
-ojluni/src/test/java/nio/Buffer/CopyDirect-X-Memory.java.template,jdk21u/jdk-21.0.4-ga,test/jdk/java/nio/Buffer/CopyDirect-X-Memory.java.template
-ojluni/src/test/java/nio/Buffer/EqualsCompareTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/nio/Buffer/EqualsCompareTest.java
-ojluni/src/test/java/nio/Buffer/Order-X.java.template,jdk21u/jdk-21.0.4-ga,test/jdk/java/nio/Buffer/Order-X.java.template
-ojluni/src/test/java/nio/Buffer/Order.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/nio/Buffer/Order.java
-ojluni/src/test/java/nio/Buffer/StringCharBufferSliceTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/nio/Buffer/StringCharBufferSliceTest.java
-ojluni/src/test/java/nio/Buffer/genBasic.sh,jdk21u/jdk-21.0.4-ga,test/jdk/java/nio/Buffer/genBasic.sh
-ojluni/src/test/java/nio/Buffer/genCopyDirectMemory.sh,jdk21u/jdk-21.0.4-ga,test/jdk/java/nio/Buffer/genCopyDirectMemory.sh
-ojluni/src/test/java/nio/Buffer/genOrder.sh,jdk21u/jdk-21.0.4-ga,test/jdk/java/nio/Buffer/genOrder.sh
+ojluni/src/test/java/net/UnixDomainSocketAddress/LengthTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/net/UnixDomainSocketAddress/LengthTest.java
+ojluni/src/test/java/net/UnixDomainSocketAddress/UnixDomainSocketAddressSerializationTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/net/UnixDomainSocketAddress/UnixDomainSocketAddressSerializationTest.java
+ojluni/src/test/java/nio/Buffer/AllocateDirectInit.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/nio/Buffer/AllocateDirectInit.java
+ojluni/src/test/java/nio/Buffer/Basic-X.java.template,jdk17u/jdk-17.0.14-ga,test/jdk/java/nio/Buffer/Basic-X.java.template
+ojluni/src/test/java/nio/Buffer/Basic.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/nio/Buffer/Basic.java
+ojluni/src/test/java/nio/Buffer/BulkPutBuffer.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/nio/Buffer/BulkPutBuffer.java
+ojluni/src/test/java/nio/Buffer/ByteBufferViews.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/nio/Buffer/ByteBufferViews.java
+ojluni/src/test/java/nio/Buffer/Chars.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/nio/Buffer/Chars.java
+ojluni/src/test/java/nio/Buffer/Chew.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/nio/Buffer/Chew.java
+ojluni/src/test/java/nio/Buffer/CopyDirect-X-Memory.java.template,jdk21u/jdk-21.0.6-ga,test/jdk/java/nio/Buffer/CopyDirect-X-Memory.java.template
+ojluni/src/test/java/nio/Buffer/EqualsCompareTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/nio/Buffer/EqualsCompareTest.java
+ojluni/src/test/java/nio/Buffer/Order-X.java.template,jdk21u/jdk-21.0.6-ga,test/jdk/java/nio/Buffer/Order-X.java.template
+ojluni/src/test/java/nio/Buffer/Order.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/nio/Buffer/Order.java
+ojluni/src/test/java/nio/Buffer/StringCharBufferSliceTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/nio/Buffer/StringCharBufferSliceTest.java
+ojluni/src/test/java/nio/Buffer/genBasic.sh,jdk21u/jdk-21.0.6-ga,test/jdk/java/nio/Buffer/genBasic.sh
+ojluni/src/test/java/nio/Buffer/genCopyDirectMemory.sh,jdk21u/jdk-21.0.6-ga,test/jdk/java/nio/Buffer/genCopyDirectMemory.sh
+ojluni/src/test/java/nio/Buffer/genOrder.sh,jdk21u/jdk-21.0.6-ga,test/jdk/java/nio/Buffer/genOrder.sh
 ojluni/src/test/java/nio/MappedByteBuffer/ForceViews.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/nio/MappedByteBuffer/ForceViews.java
-ojluni/src/test/java/nio/channels/SelectionKey/AtomicUpdates.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/nio/channels/SelectionKey/AtomicUpdates.java
-ojluni/src/test/java/nio/channels/Selector/ByteServer.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/nio/channels/Selector/ByteServer.java
-ojluni/src/test/java/nio/channels/Selector/SelectAfterRead.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/nio/channels/Selector/SelectAfterRead.java
-ojluni/src/test/java/nio/channels/Selector/SelectWithConsumer.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/nio/channels/Selector/SelectWithConsumer.java
-ojluni/src/test/java/nio/charset/Charset/Contains.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/nio/charset/Charset/Contains.java
-ojluni/src/test/java/nio/charset/Charset/Default.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/nio/charset/Charset/Default.java
-ojluni/src/test/java/nio/charset/Charset/EmptyCharsetName.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/nio/charset/Charset/EmptyCharsetName.java
-ojluni/src/test/java/nio/charset/Charset/EncDec.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/nio/charset/Charset/EncDec.java
-ojluni/src/test/java/nio/charset/Charset/IllegalCharsetName.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/nio/charset/Charset/IllegalCharsetName.java
-ojluni/src/test/java/nio/charset/Charset/NullCharsetName.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/nio/charset/Charset/NullCharsetName.java
-ojluni/src/test/java/nio/file/Path/Misc.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/nio/file/Path/Misc.java
-ojluni/src/test/java/nio/file/Path/PathOps.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/nio/file/Path/PathOps.java
-ojluni/src/test/java/nio/file/Path/UriImportExport.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/nio/file/Path/UriImportExport.java
-ojluni/src/test/java/security/cert/CertPathEncodingTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/security/cert/CertPathEncodingTest.java
-ojluni/src/test/java/security/cert/GetInstance.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/security/cert/GetInstance.java
-ojluni/src/test/java/security/cert/URICertStoreParameters/TestBasic.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/security/cert/URICertStoreParameters/TestBasic.java
-ojluni/src/test/java/security/cert/X509CertSelectorTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/security/cert/X509CertSelectorTest.java
-ojluni/src/test/java/text/AttributedCharacterIterator/Attribute/ReadResolve.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/text/AttributedCharacterIterator/Attribute/ReadResolve.java
-ojluni/src/test/java/text/AttributedString/AttributedStringTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/text/AttributedString/AttributedStringTest.java
-ojluni/src/test/java/text/AttributedString/TestAttributedStringCtor.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/text/AttributedString/TestAttributedStringCtor.java
-ojluni/src/test/java/text/AttributedString/getRunStartLimitTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/text/AttributedString/getRunStartLimitTest.java
-ojluni/src/test/java/text/BreakIterator/Bug4533872.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/text/BreakIterator/Bug4533872.java
-ojluni/src/test/java/text/BreakIterator/Bug4740757.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/text/BreakIterator/Bug4740757.java
-ojluni/src/test/java/text/BreakIterator/Bug4912404.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/text/BreakIterator/Bug4912404.java
-ojluni/src/test/java/text/BreakIterator/Bug4932583.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/text/BreakIterator/Bug4932583.java
-ojluni/src/test/java/text/BreakIterator/Bug7104012.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/text/BreakIterator/Bug7104012.java
-ojluni/src/test/java/text/BreakIterator/Bug8032446.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/text/BreakIterator/Bug8032446.java
-ojluni/src/test/java/text/BreakIterator/ExceptionTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/text/BreakIterator/ExceptionTest.java
-ojluni/src/test/java/text/BreakIterator/MirroredBreakIterator.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/text/BreakIterator/MirroredBreakIterator.java
-ojluni/src/test/java/text/CharacterIterator/CharacterIteratorTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/text/CharacterIterator/CharacterIteratorTest.java
-ojluni/src/test/java/text/Collator/Bug5047314.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/text/Collator/Bug5047314.java
-ojluni/src/test/java/text/Collator/Bug7200119.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/text/Collator/Bug7200119.java
-ojluni/src/test/java/text/Collator/CollatorTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/text/Collator/CollatorTest.java
-ojluni/src/test/java/text/Collator/MonkeyTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/text/Collator/MonkeyTest.java
-ojluni/src/test/java/text/Format/ChoiceFormat/Bug4387255.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/text/Format/ChoiceFormat/Bug4387255.java
-ojluni/src/test/java/text/Format/ChoiceFormat/Bug8001209.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/text/Format/ChoiceFormat/Bug8001209.java
-ojluni/src/test/java/text/Format/DateFormat/SimpleDateFormatPatternTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/text/Format/DateFormat/SimpleDateFormatPatternTest.java
-ojluni/src/test/java/text/Format/DecimalFormat/Bug8165466.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/text/Format/DecimalFormat/Bug8165466.java
-ojluni/src/test/java/text/Format/DecimalFormat/GoldenFormattedValues.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/text/Format/DecimalFormat/GoldenFormattedValues.java
-ojluni/src/test/java/text/Format/DecimalFormat/SetGroupingSizeTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/text/Format/DecimalFormat/SetGroupingSizeTest.java
-ojluni/src/test/java/text/Format/MessageFormat/Bug6481179.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/text/Format/MessageFormat/Bug6481179.java
-ojluni/src/test/java/text/Format/MessageFormat/Bug7003643.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/text/Format/MessageFormat/Bug7003643.java
-ojluni/src/test/java/text/Format/MessageFormat/MessageFormatsByArgumentIndex.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/text/Format/MessageFormat/MessageFormatsByArgumentIndex.java
-ojluni/src/test/java/text/Format/MessageFormat/MessageRegression.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/text/Format/MessageFormat/MessageRegression.java
-ojluni/src/test/java/text/Format/MessageFormat/MessageTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/text/Format/MessageFormat/MessageTest.java
-ojluni/src/test/java/text/Format/MessageFormat/bug4492719.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/text/Format/MessageFormat/bug4492719.java
-ojluni/src/test/java/text/Format/NumberFormat/BigDecimalFormat.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/text/Format/NumberFormat/BigDecimalFormat.java
-ojluni/src/test/java/text/Format/NumberFormat/BigDecimalParse.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/text/Format/NumberFormat/BigDecimalParse.java
-ojluni/src/test/java/text/Format/NumberFormat/DFSDeserialization142.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/text/Format/NumberFormat/DFSDeserialization142.java
-ojluni/src/test/java/text/Format/NumberFormat/DFSExponential.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/text/Format/NumberFormat/DFSExponential.java
-ojluni/src/test/java/text/Format/NumberFormat/DFSSerialization142.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/text/Format/NumberFormat/DFSSerialization142.java
-ojluni/src/test/java/text/Format/NumberFormat/PositionTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/text/Format/NumberFormat/PositionTest.java
-ojluni/src/test/java/text/Format/NumberFormat/SerializationLoadTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/text/Format/NumberFormat/SerializationLoadTest.java
-ojluni/src/test/java/text/Format/NumberFormat/SerializationSaveTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/text/Format/NumberFormat/SerializationSaveTest.java
-ojluni/src/test/java/text/testlib/HexDumpReader.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/text/testlib/HexDumpReader.java
-ojluni/src/test/java/text/testlib/IntlTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/text/testlib/IntlTest.java
-ojluni/src/test/java/text/testlib/TestUtils.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/text/testlib/TestUtils.java
-ojluni/src/test/java/time/jdk/testlibrary/RandomFactory.java,jdk21u/jdk-21.0.4-ga,test/lib/jdk/test/lib/RandomFactory.java
-ojluni/src/test/java/time/tck/java/time/AbstractDateTimeTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/AbstractDateTimeTest.java
-ojluni/src/test/java/time/tck/java/time/AbstractTCKTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/AbstractTCKTest.java
-ojluni/src/test/java/time/tck/java/time/MockSimplePeriod.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/MockSimplePeriod.java
-ojluni/src/test/java/time/tck/java/time/TCKClock.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/TCKClock.java
-ojluni/src/test/java/time/tck/java/time/TCKClock_Fixed.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/TCKClock_Fixed.java
-ojluni/src/test/java/time/tck/java/time/TCKClock_Offset.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/TCKClock_Offset.java
-ojluni/src/test/java/time/tck/java/time/TCKClock_System.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/TCKClock_System.java
-ojluni/src/test/java/time/tck/java/time/TCKClock_Tick.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/TCKClock_Tick.java
-ojluni/src/test/java/time/tck/java/time/TCKDayOfWeek.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/TCKDayOfWeek.java
-ojluni/src/test/java/time/tck/java/time/TCKDuration.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/tck/java/time/TCKDuration.java
-ojluni/src/test/java/time/tck/java/time/TCKInstant.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/tck/java/time/TCKInstant.java
-ojluni/src/test/java/time/tck/java/time/TCKLocalDate.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/TCKLocalDate.java
-ojluni/src/test/java/time/tck/java/time/TCKLocalDateTime.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/TCKLocalDateTime.java
-ojluni/src/test/java/time/tck/java/time/TCKLocalTime.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/TCKLocalTime.java
-ojluni/src/test/java/time/tck/java/time/TCKMonth.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/TCKMonth.java
-ojluni/src/test/java/time/tck/java/time/TCKMonthDay.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/TCKMonthDay.java
-ojluni/src/test/java/time/tck/java/time/TCKOffsetDateTime.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/TCKOffsetDateTime.java
-ojluni/src/test/java/time/tck/java/time/TCKOffsetTime.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/TCKOffsetTime.java
-ojluni/src/test/java/time/tck/java/time/TCKPeriod.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/TCKPeriod.java
-ojluni/src/test/java/time/tck/java/time/TCKYear.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/TCKYear.java
-ojluni/src/test/java/time/tck/java/time/TCKYearMonth.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/TCKYearMonth.java
-ojluni/src/test/java/time/tck/java/time/TCKZoneId.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/TCKZoneId.java
-ojluni/src/test/java/time/tck/java/time/TCKZoneOffset.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/TCKZoneOffset.java
-ojluni/src/test/java/time/tck/java/time/TCKZonedDateTime.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/TCKZonedDateTime.java
-ojluni/src/test/java/time/tck/java/time/TestIsoChronology.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/TestIsoChronology.java
-ojluni/src/test/java/time/tck/java/time/chrono/CopticChronology.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/chrono/CopticChronology.java
-ojluni/src/test/java/time/tck/java/time/chrono/CopticDate.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/chrono/CopticDate.java
-ojluni/src/test/java/time/tck/java/time/chrono/CopticEra.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/chrono/CopticEra.java
-ojluni/src/test/java/time/tck/java/time/chrono/TCKChronoLocalDate.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/chrono/TCKChronoLocalDate.java
-ojluni/src/test/java/time/tck/java/time/chrono/TCKChronoLocalDateTime.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/chrono/TCKChronoLocalDateTime.java
-ojluni/src/test/java/time/tck/java/time/chrono/TCKChronoPeriod.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/chrono/TCKChronoPeriod.java
-ojluni/src/test/java/time/tck/java/time/chrono/TCKChronoZonedDateTime.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/chrono/TCKChronoZonedDateTime.java
-ojluni/src/test/java/time/tck/java/time/chrono/TCKChronology.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/tck/java/time/chrono/TCKChronology.java
-ojluni/src/test/java/time/tck/java/time/chrono/TCKHijrahChronology.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/chrono/TCKHijrahChronology.java
-ojluni/src/test/java/time/tck/java/time/chrono/TCKHijrahEra.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/chrono/TCKHijrahEra.java
-ojluni/src/test/java/time/tck/java/time/chrono/TCKIsoChronology.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/chrono/TCKIsoChronology.java
-ojluni/src/test/java/time/tck/java/time/chrono/TCKIsoEra.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/chrono/TCKIsoEra.java
-ojluni/src/test/java/time/tck/java/time/chrono/TCKJapaneseChronology.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/tck/java/time/chrono/TCKJapaneseChronology.java
-ojluni/src/test/java/time/tck/java/time/chrono/TCKJapaneseEra.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/chrono/TCKJapaneseEra.java
-ojluni/src/test/java/time/tck/java/time/chrono/TCKMinguoChronology.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/chrono/TCKMinguoChronology.java
-ojluni/src/test/java/time/tck/java/time/chrono/TCKMinguoEra.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/chrono/TCKMinguoEra.java
-ojluni/src/test/java/time/tck/java/time/chrono/TCKTestServiceLoader.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/tck/java/time/chrono/TCKTestServiceLoader.java
-ojluni/src/test/java/time/tck/java/time/chrono/TCKThaiBuddhistChronology.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/tck/java/time/chrono/TCKThaiBuddhistChronology.java
-ojluni/src/test/java/time/tck/java/time/chrono/TCKThaiBuddhistEra.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/chrono/TCKThaiBuddhistEra.java
-ojluni/src/test/java/time/tck/java/time/chrono/serial/TCKChronoLocalDateSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/chrono/serial/TCKChronoLocalDateSerialization.java
-ojluni/src/test/java/time/tck/java/time/chrono/serial/TCKChronoLocalDateTimeSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/chrono/serial/TCKChronoLocalDateTimeSerialization.java
-ojluni/src/test/java/time/tck/java/time/chrono/serial/TCKChronoZonedDateTimeSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/chrono/serial/TCKChronoZonedDateTimeSerialization.java
-ojluni/src/test/java/time/tck/java/time/chrono/serial/TCKChronologySerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/chrono/serial/TCKChronologySerialization.java
-ojluni/src/test/java/time/tck/java/time/chrono/serial/TCKCopticSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/chrono/serial/TCKCopticSerialization.java
-ojluni/src/test/java/time/tck/java/time/chrono/serial/TCKEraSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/chrono/serial/TCKEraSerialization.java
-ojluni/src/test/java/time/tck/java/time/format/TCKChronoPrinterParser.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/format/TCKChronoPrinterParser.java
-ojluni/src/test/java/time/tck/java/time/format/TCKDTFParsedInstant.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/format/TCKDTFParsedInstant.java
-ojluni/src/test/java/time/tck/java/time/format/TCKDateTimeFormatter.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/format/TCKDateTimeFormatter.java
-ojluni/src/test/java/time/tck/java/time/format/TCKDateTimeFormatterBuilder.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/format/TCKDateTimeFormatterBuilder.java
-ojluni/src/test/java/time/tck/java/time/format/TCKDateTimeFormatters.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/format/TCKDateTimeFormatters.java
-ojluni/src/test/java/time/tck/java/time/format/TCKDateTimeParseResolver.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/format/TCKDateTimeParseResolver.java
-ojluni/src/test/java/time/tck/java/time/format/TCKDateTimeTextPrinting.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/format/TCKDateTimeTextPrinting.java
-ojluni/src/test/java/time/tck/java/time/format/TCKDecimalStyle.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/format/TCKDecimalStyle.java
-ojluni/src/test/java/time/tck/java/time/format/TCKFormatStyle.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/tck/java/time/format/TCKFormatStyle.java
-ojluni/src/test/java/time/tck/java/time/format/TCKInstantPrinterParser.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/format/TCKInstantPrinterParser.java
-ojluni/src/test/java/time/tck/java/time/format/TCKLocalizedFieldParser.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/format/TCKLocalizedFieldParser.java
-ojluni/src/test/java/time/tck/java/time/format/TCKLocalizedFieldPrinter.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/format/TCKLocalizedFieldPrinter.java
-ojluni/src/test/java/time/tck/java/time/format/TCKLocalizedOffsetIdPrinterParser.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/format/TCKLocalizedOffsetIdPrinterParser.java
-ojluni/src/test/java/time/tck/java/time/format/TCKLocalizedPrinterParser.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/format/TCKLocalizedPrinterParser.java
-ojluni/src/test/java/time/tck/java/time/format/TCKOffsetPrinterParser.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/format/TCKOffsetPrinterParser.java
-ojluni/src/test/java/time/tck/java/time/format/TCKPadPrinterParser.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/format/TCKPadPrinterParser.java
-ojluni/src/test/java/time/tck/java/time/format/TCKResolverStyle.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/format/TCKResolverStyle.java
-ojluni/src/test/java/time/tck/java/time/format/TCKSignStyle.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/format/TCKSignStyle.java
-ojluni/src/test/java/time/tck/java/time/format/TCKTextStyle.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/format/TCKTextStyle.java
-ojluni/src/test/java/time/tck/java/time/format/TCKZoneIdPrinterParser.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/format/TCKZoneIdPrinterParser.java
-ojluni/src/test/java/time/tck/java/time/serial/TCKClockSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/serial/TCKClockSerialization.java
-ojluni/src/test/java/time/tck/java/time/serial/TCKDurationSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/serial/TCKDurationSerialization.java
-ojluni/src/test/java/time/tck/java/time/serial/TCKInstantSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/serial/TCKInstantSerialization.java
-ojluni/src/test/java/time/tck/java/time/serial/TCKLocalDateSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/serial/TCKLocalDateSerialization.java
-ojluni/src/test/java/time/tck/java/time/serial/TCKLocalDateTimeSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/serial/TCKLocalDateTimeSerialization.java
-ojluni/src/test/java/time/tck/java/time/serial/TCKLocalTimeSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/serial/TCKLocalTimeSerialization.java
-ojluni/src/test/java/time/tck/java/time/serial/TCKMonthDaySerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/serial/TCKMonthDaySerialization.java
-ojluni/src/test/java/time/tck/java/time/serial/TCKOffsetDateTimeSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/serial/TCKOffsetDateTimeSerialization.java
-ojluni/src/test/java/time/tck/java/time/serial/TCKOffsetTimeSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/serial/TCKOffsetTimeSerialization.java
-ojluni/src/test/java/time/tck/java/time/serial/TCKPeriodSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/serial/TCKPeriodSerialization.java
-ojluni/src/test/java/time/tck/java/time/serial/TCKYearMonthSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/serial/TCKYearMonthSerialization.java
-ojluni/src/test/java/time/tck/java/time/serial/TCKYearSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/serial/TCKYearSerialization.java
-ojluni/src/test/java/time/tck/java/time/serial/TCKZoneIdSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/serial/TCKZoneIdSerialization.java
-ojluni/src/test/java/time/tck/java/time/serial/TCKZoneOffsetSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/serial/TCKZoneOffsetSerialization.java
-ojluni/src/test/java/time/tck/java/time/serial/TCKZonedDateTimeSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/serial/TCKZonedDateTimeSerialization.java
-ojluni/src/test/java/time/tck/java/time/temporal/TCKChronoField.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/temporal/TCKChronoField.java
-ojluni/src/test/java/time/tck/java/time/temporal/TCKChronoUnit.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/temporal/TCKChronoUnit.java
-ojluni/src/test/java/time/tck/java/time/temporal/TCKIsoFields.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/tck/java/time/temporal/TCKIsoFields.java
-ojluni/src/test/java/time/tck/java/time/temporal/TCKJulianFields.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/temporal/TCKJulianFields.java
-ojluni/src/test/java/time/tck/java/time/temporal/TCKTemporalAdjusters.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/temporal/TCKTemporalAdjusters.java
-ojluni/src/test/java/time/tck/java/time/temporal/TCKWeekFields.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/temporal/TCKWeekFields.java
-ojluni/src/test/java/time/tck/java/time/temporal/serial/TCKChronoFieldSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/temporal/serial/TCKChronoFieldSerialization.java
-ojluni/src/test/java/time/tck/java/time/temporal/serial/TCKChronoUnitSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/temporal/serial/TCKChronoUnitSerialization.java
-ojluni/src/test/java/time/tck/java/time/temporal/serial/TCKJulianFieldsSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/temporal/serial/TCKJulianFieldsSerialization.java
-ojluni/src/test/java/time/tck/java/time/temporal/serial/TCKValueRangeSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/temporal/serial/TCKValueRangeSerialization.java
-ojluni/src/test/java/time/tck/java/time/temporal/serial/TCKWeekFieldsSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/temporal/serial/TCKWeekFieldsSerialization.java
-ojluni/src/test/java/time/tck/java/time/zone/TCKFixedZoneRules.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/zone/TCKFixedZoneRules.java
-ojluni/src/test/java/time/tck/java/time/zone/TCKZoneOffsetTransition.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/zone/TCKZoneOffsetTransition.java
-ojluni/src/test/java/time/tck/java/time/zone/TCKZoneOffsetTransitionRule.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/zone/TCKZoneOffsetTransitionRule.java
-ojluni/src/test/java/time/tck/java/time/zone/TCKZoneRules.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/tck/java/time/zone/TCKZoneRules.java
-ojluni/src/test/java/time/tck/java/time/zone/TCKZoneRulesProvider.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/zone/TCKZoneRulesProvider.java
-ojluni/src/test/java/time/tck/java/time/zone/serial/TCKFixedZoneRulesSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/zone/serial/TCKFixedZoneRulesSerialization.java
-ojluni/src/test/java/time/tck/java/time/zone/serial/TCKZoneOffsetTransitionRuleSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/zone/serial/TCKZoneOffsetTransitionRuleSerialization.java
-ojluni/src/test/java/time/tck/java/time/zone/serial/TCKZoneOffsetTransitionSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/zone/serial/TCKZoneOffsetTransitionSerialization.java
-ojluni/src/test/java/time/tck/java/time/zone/serial/TCKZoneRulesSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/tck/java/time/zone/serial/TCKZoneRulesSerialization.java
-ojluni/src/test/java/time/test/java/time/AbstractTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/time/AbstractTest.java
-ojluni/src/test/java/time/test/java/time/MockSimplePeriod.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/MockSimplePeriod.java
-ojluni/src/test/java/time/test/java/time/TestClock_Fixed.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/TestClock_Fixed.java
-ojluni/src/test/java/time/test/java/time/TestClock_Offset.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/TestClock_Offset.java
-ojluni/src/test/java/time/test/java/time/TestClock_System.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/time/TestClock_System.java
-ojluni/src/test/java/time/test/java/time/TestClock_Tick.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/TestClock_Tick.java
-ojluni/src/test/java/time/test/java/time/TestDuration.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/TestDuration.java
-ojluni/src/test/java/time/test/java/time/TestInstant.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/time/TestInstant.java
-ojluni/src/test/java/time/test/java/time/TestInstantSource.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/TestInstantSource.java
-ojluni/src/test/java/time/test/java/time/TestLocalDate.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/time/TestLocalDate.java
-ojluni/src/test/java/time/test/java/time/TestLocalDateTime.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/TestLocalDateTime.java
-ojluni/src/test/java/time/test/java/time/TestLocalTime.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/TestLocalTime.java
-ojluni/src/test/java/time/test/java/time/TestMonthDay.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/TestMonthDay.java
-ojluni/src/test/java/time/test/java/time/TestOffsetDateTime.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/TestOffsetDateTime.java
-ojluni/src/test/java/time/test/java/time/TestOffsetDateTime_instants.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/TestOffsetDateTime_instants.java
-ojluni/src/test/java/time/test/java/time/TestOffsetTime.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/TestOffsetTime.java
-ojluni/src/test/java/time/test/java/time/TestPeriod.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/TestPeriod.java
-ojluni/src/test/java/time/test/java/time/TestYear.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/TestYear.java
-ojluni/src/test/java/time/test/java/time/TestYearMonth.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/TestYearMonth.java
-ojluni/src/test/java/time/test/java/time/TestZoneId.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/TestZoneId.java
-ojluni/src/test/java/time/test/java/time/TestZoneOffset.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/time/TestZoneOffset.java
-ojluni/src/test/java/time/test/java/time/TestZonedDateTime.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/TestZonedDateTime.java
-ojluni/src/test/java/time/test/java/time/chrono/TestChronoLocalDate.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/chrono/TestChronoLocalDate.java
-ojluni/src/test/java/time/test/java/time/chrono/TestChronologyPerf.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/chrono/TestChronologyPerf.java
-ojluni/src/test/java/time/test/java/time/chrono/TestEraDisplayName.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/time/chrono/TestEraDisplayName.java
-ojluni/src/test/java/time/test/java/time/chrono/TestExampleCode.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/time/chrono/TestExampleCode.java
-ojluni/src/test/java/time/test/java/time/chrono/TestIsoChronoImpl.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/chrono/TestIsoChronoImpl.java
-ojluni/src/test/java/time/test/java/time/chrono/TestJapaneseChronoImpl.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/chrono/TestJapaneseChronoImpl.java
-ojluni/src/test/java/time/test/java/time/chrono/TestJapaneseChronology.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/chrono/TestJapaneseChronology.java
-ojluni/src/test/java/time/test/java/time/chrono/TestServiceLoader.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/time/chrono/TestServiceLoader.java
-ojluni/src/test/java/time/test/java/time/chrono/TestThaiBuddhistChronoImpl.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/chrono/TestThaiBuddhistChronoImpl.java
-ojluni/src/test/java/time/test/java/time/chrono/TestUmmAlQuraChronology.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/chrono/TestUmmAlQuraChronology.java
-ojluni/src/test/java/time/test/java/time/format/AbstractTestPrinterParser.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/format/AbstractTestPrinterParser.java
-ojluni/src/test/java/time/test/java/time/format/MockIOExceptionAppendable.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/format/MockIOExceptionAppendable.java
-ojluni/src/test/java/time/test/java/time/format/TestCharLiteralParser.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/format/TestCharLiteralParser.java
-ojluni/src/test/java/time/test/java/time/format/TestCharLiteralPrinter.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/format/TestCharLiteralPrinter.java
-ojluni/src/test/java/time/test/java/time/format/TestDateTimeFormatter.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/time/format/TestDateTimeFormatter.java
-ojluni/src/test/java/time/test/java/time/format/TestDateTimeFormatterBuilder.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/time/format/TestDateTimeFormatterBuilder.java
-ojluni/src/test/java/time/test/java/time/format/TestDateTimeFormatterBuilderWithLocale.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/time/format/TestDateTimeFormatterBuilderWithLocale.java
+ojluni/src/test/java/nio/channels/SelectionKey/AtomicUpdates.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/nio/channels/SelectionKey/AtomicUpdates.java
+ojluni/src/test/java/nio/channels/Selector/ByteServer.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/nio/channels/Selector/ByteServer.java
+ojluni/src/test/java/nio/channels/Selector/SelectAfterRead.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/nio/channels/Selector/SelectAfterRead.java
+ojluni/src/test/java/nio/channels/Selector/SelectWithConsumer.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/nio/channels/Selector/SelectWithConsumer.java
+ojluni/src/test/java/nio/charset/Charset/Contains.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/nio/charset/Charset/Contains.java
+ojluni/src/test/java/nio/charset/Charset/Default.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/nio/charset/Charset/Default.java
+ojluni/src/test/java/nio/charset/Charset/EmptyCharsetName.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/nio/charset/Charset/EmptyCharsetName.java
+ojluni/src/test/java/nio/charset/Charset/EncDec.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/nio/charset/Charset/EncDec.java
+ojluni/src/test/java/nio/charset/Charset/IllegalCharsetName.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/nio/charset/Charset/IllegalCharsetName.java
+ojluni/src/test/java/nio/charset/Charset/NullCharsetName.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/nio/charset/Charset/NullCharsetName.java
+ojluni/src/test/java/nio/file/Files/ReadWriteString.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/nio/file/Files/ReadWriteString.java
+ojluni/src/test/java/nio/file/Path/Misc.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/nio/file/Path/Misc.java
+ojluni/src/test/java/nio/file/Path/PathOps.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/nio/file/Path/PathOps.java
+ojluni/src/test/java/nio/file/Path/UriImportExport.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/nio/file/Path/UriImportExport.java
+ojluni/src/test/java/security/cert/CertPathEncodingTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/security/cert/CertPathEncodingTest.java
+ojluni/src/test/java/security/cert/GetInstance.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/security/cert/GetInstance.java
+ojluni/src/test/java/security/cert/URICertStoreParameters/TestBasic.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/security/cert/URICertStoreParameters/TestBasic.java
+ojluni/src/test/java/security/cert/X509CertSelectorTest.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/security/cert/X509CertSelectorTest.java
+ojluni/src/test/java/text/AttributedCharacterIterator/Attribute/ReadResolve.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/text/AttributedCharacterIterator/Attribute/ReadResolve.java
+ojluni/src/test/java/text/AttributedString/AttributedStringTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/text/AttributedString/AttributedStringTest.java
+ojluni/src/test/java/text/AttributedString/TestAttributedStringCtor.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/text/AttributedString/TestAttributedStringCtor.java
+ojluni/src/test/java/text/AttributedString/getRunStartLimitTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/text/AttributedString/getRunStartLimitTest.java
+ojluni/src/test/java/text/BreakIterator/Bug4533872.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/text/BreakIterator/Bug4533872.java
+ojluni/src/test/java/text/BreakIterator/Bug4740757.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/text/BreakIterator/Bug4740757.java
+ojluni/src/test/java/text/BreakIterator/Bug4912404.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/text/BreakIterator/Bug4912404.java
+ojluni/src/test/java/text/BreakIterator/Bug4932583.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/text/BreakIterator/Bug4932583.java
+ojluni/src/test/java/text/BreakIterator/Bug7104012.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/text/BreakIterator/Bug7104012.java
+ojluni/src/test/java/text/BreakIterator/Bug8032446.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/text/BreakIterator/Bug8032446.java
+ojluni/src/test/java/text/BreakIterator/ExceptionTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/text/BreakIterator/ExceptionTest.java
+ojluni/src/test/java/text/BreakIterator/MirroredBreakIterator.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/text/BreakIterator/MirroredBreakIterator.java
+ojluni/src/test/java/text/CharacterIterator/CharacterIteratorTest.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/text/CharacterIterator/CharacterIteratorTest.java
+ojluni/src/test/java/text/Collator/Bug5047314.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/text/Collator/Bug5047314.java
+ojluni/src/test/java/text/Collator/Bug7200119.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/text/Collator/Bug7200119.java
+ojluni/src/test/java/text/Collator/CollatorTest.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/text/Collator/CollatorTest.java
+ojluni/src/test/java/text/Collator/MonkeyTest.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/text/Collator/MonkeyTest.java
+ojluni/src/test/java/text/Format/ChoiceFormat/Bug4387255.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/text/Format/ChoiceFormat/Bug4387255.java
+ojluni/src/test/java/text/Format/ChoiceFormat/Bug8001209.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/text/Format/ChoiceFormat/Bug8001209.java
+ojluni/src/test/java/text/Format/DateFormat/SimpleDateFormatPatternTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/text/Format/DateFormat/SimpleDateFormatPatternTest.java
+ojluni/src/test/java/text/Format/DecimalFormat/Bug8165466.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/text/Format/DecimalFormat/Bug8165466.java
+ojluni/src/test/java/text/Format/DecimalFormat/GoldenFormattedValues.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/text/Format/DecimalFormat/GoldenFormattedValues.java
+ojluni/src/test/java/text/Format/DecimalFormat/SetGroupingSizeTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/text/Format/DecimalFormat/SetGroupingSizeTest.java
+ojluni/src/test/java/text/Format/MessageFormat/Bug6481179.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/text/Format/MessageFormat/Bug6481179.java
+ojluni/src/test/java/text/Format/MessageFormat/Bug7003643.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/text/Format/MessageFormat/Bug7003643.java
+ojluni/src/test/java/text/Format/MessageFormat/MessageFormatsByArgumentIndex.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/text/Format/MessageFormat/MessageFormatsByArgumentIndex.java
+ojluni/src/test/java/text/Format/MessageFormat/MessageRegression.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/text/Format/MessageFormat/MessageRegression.java
+ojluni/src/test/java/text/Format/MessageFormat/MessageTest.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/text/Format/MessageFormat/MessageTest.java
+ojluni/src/test/java/text/Format/MessageFormat/bug4492719.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/text/Format/MessageFormat/bug4492719.java
+ojluni/src/test/java/text/Format/NumberFormat/BigDecimalFormat.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/text/Format/NumberFormat/BigDecimalFormat.java
+ojluni/src/test/java/text/Format/NumberFormat/BigDecimalParse.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/text/Format/NumberFormat/BigDecimalParse.java
+ojluni/src/test/java/text/Format/NumberFormat/DFSDeserialization142.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/text/Format/NumberFormat/DFSDeserialization142.java
+ojluni/src/test/java/text/Format/NumberFormat/DFSExponential.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/text/Format/NumberFormat/DFSExponential.java
+ojluni/src/test/java/text/Format/NumberFormat/DFSSerialization142.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/text/Format/NumberFormat/DFSSerialization142.java
+ojluni/src/test/java/text/Format/NumberFormat/PositionTest.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/text/Format/NumberFormat/PositionTest.java
+ojluni/src/test/java/text/Format/NumberFormat/SerializationLoadTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/text/Format/NumberFormat/SerializationLoadTest.java
+ojluni/src/test/java/text/Format/NumberFormat/SerializationSaveTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/text/Format/NumberFormat/SerializationSaveTest.java
+ojluni/src/test/java/text/testlib/HexDumpReader.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/text/testlib/HexDumpReader.java
+ojluni/src/test/java/text/testlib/IntlTest.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/text/testlib/IntlTest.java
+ojluni/src/test/java/text/testlib/TestUtils.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/text/testlib/TestUtils.java
+ojluni/src/test/java/time/jdk/testlibrary/RandomFactory.java,jdk21u/jdk-21.0.6-ga,test/lib/jdk/test/lib/RandomFactory.java
+ojluni/src/test/java/time/tck/java/time/AbstractDateTimeTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/AbstractDateTimeTest.java
+ojluni/src/test/java/time/tck/java/time/AbstractTCKTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/AbstractTCKTest.java
+ojluni/src/test/java/time/tck/java/time/MockSimplePeriod.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/MockSimplePeriod.java
+ojluni/src/test/java/time/tck/java/time/TCKClock.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/TCKClock.java
+ojluni/src/test/java/time/tck/java/time/TCKClock_Fixed.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/TCKClock_Fixed.java
+ojluni/src/test/java/time/tck/java/time/TCKClock_Offset.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/TCKClock_Offset.java
+ojluni/src/test/java/time/tck/java/time/TCKClock_System.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/TCKClock_System.java
+ojluni/src/test/java/time/tck/java/time/TCKClock_Tick.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/TCKClock_Tick.java
+ojluni/src/test/java/time/tck/java/time/TCKDayOfWeek.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/TCKDayOfWeek.java
+ojluni/src/test/java/time/tck/java/time/TCKDuration.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/tck/java/time/TCKDuration.java
+ojluni/src/test/java/time/tck/java/time/TCKInstant.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/tck/java/time/TCKInstant.java
+ojluni/src/test/java/time/tck/java/time/TCKLocalDate.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/TCKLocalDate.java
+ojluni/src/test/java/time/tck/java/time/TCKLocalDateTime.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/TCKLocalDateTime.java
+ojluni/src/test/java/time/tck/java/time/TCKLocalTime.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/TCKLocalTime.java
+ojluni/src/test/java/time/tck/java/time/TCKMonth.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/TCKMonth.java
+ojluni/src/test/java/time/tck/java/time/TCKMonthDay.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/TCKMonthDay.java
+ojluni/src/test/java/time/tck/java/time/TCKOffsetDateTime.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/TCKOffsetDateTime.java
+ojluni/src/test/java/time/tck/java/time/TCKOffsetTime.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/TCKOffsetTime.java
+ojluni/src/test/java/time/tck/java/time/TCKPeriod.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/TCKPeriod.java
+ojluni/src/test/java/time/tck/java/time/TCKYear.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/TCKYear.java
+ojluni/src/test/java/time/tck/java/time/TCKYearMonth.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/TCKYearMonth.java
+ojluni/src/test/java/time/tck/java/time/TCKZoneId.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/TCKZoneId.java
+ojluni/src/test/java/time/tck/java/time/TCKZoneOffset.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/TCKZoneOffset.java
+ojluni/src/test/java/time/tck/java/time/TCKZonedDateTime.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/TCKZonedDateTime.java
+ojluni/src/test/java/time/tck/java/time/TestIsoChronology.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/TestIsoChronology.java
+ojluni/src/test/java/time/tck/java/time/chrono/CopticChronology.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/chrono/CopticChronology.java
+ojluni/src/test/java/time/tck/java/time/chrono/CopticDate.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/chrono/CopticDate.java
+ojluni/src/test/java/time/tck/java/time/chrono/CopticEra.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/chrono/CopticEra.java
+ojluni/src/test/java/time/tck/java/time/chrono/TCKChronoLocalDate.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/chrono/TCKChronoLocalDate.java
+ojluni/src/test/java/time/tck/java/time/chrono/TCKChronoLocalDateTime.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/chrono/TCKChronoLocalDateTime.java
+ojluni/src/test/java/time/tck/java/time/chrono/TCKChronoPeriod.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/chrono/TCKChronoPeriod.java
+ojluni/src/test/java/time/tck/java/time/chrono/TCKChronoZonedDateTime.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/chrono/TCKChronoZonedDateTime.java
+ojluni/src/test/java/time/tck/java/time/chrono/TCKChronology.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/tck/java/time/chrono/TCKChronology.java
+ojluni/src/test/java/time/tck/java/time/chrono/TCKHijrahChronology.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/chrono/TCKHijrahChronology.java
+ojluni/src/test/java/time/tck/java/time/chrono/TCKHijrahEra.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/chrono/TCKHijrahEra.java
+ojluni/src/test/java/time/tck/java/time/chrono/TCKIsoChronology.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/chrono/TCKIsoChronology.java
+ojluni/src/test/java/time/tck/java/time/chrono/TCKIsoEra.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/chrono/TCKIsoEra.java
+ojluni/src/test/java/time/tck/java/time/chrono/TCKJapaneseChronology.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/tck/java/time/chrono/TCKJapaneseChronology.java
+ojluni/src/test/java/time/tck/java/time/chrono/TCKJapaneseEra.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/chrono/TCKJapaneseEra.java
+ojluni/src/test/java/time/tck/java/time/chrono/TCKMinguoChronology.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/chrono/TCKMinguoChronology.java
+ojluni/src/test/java/time/tck/java/time/chrono/TCKMinguoEra.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/chrono/TCKMinguoEra.java
+ojluni/src/test/java/time/tck/java/time/chrono/TCKTestServiceLoader.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/tck/java/time/chrono/TCKTestServiceLoader.java
+ojluni/src/test/java/time/tck/java/time/chrono/TCKThaiBuddhistChronology.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/tck/java/time/chrono/TCKThaiBuddhistChronology.java
+ojluni/src/test/java/time/tck/java/time/chrono/TCKThaiBuddhistEra.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/chrono/TCKThaiBuddhistEra.java
+ojluni/src/test/java/time/tck/java/time/chrono/serial/TCKChronoLocalDateSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/chrono/serial/TCKChronoLocalDateSerialization.java
+ojluni/src/test/java/time/tck/java/time/chrono/serial/TCKChronoLocalDateTimeSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/chrono/serial/TCKChronoLocalDateTimeSerialization.java
+ojluni/src/test/java/time/tck/java/time/chrono/serial/TCKChronoZonedDateTimeSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/chrono/serial/TCKChronoZonedDateTimeSerialization.java
+ojluni/src/test/java/time/tck/java/time/chrono/serial/TCKChronologySerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/chrono/serial/TCKChronologySerialization.java
+ojluni/src/test/java/time/tck/java/time/chrono/serial/TCKCopticSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/chrono/serial/TCKCopticSerialization.java
+ojluni/src/test/java/time/tck/java/time/chrono/serial/TCKEraSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/chrono/serial/TCKEraSerialization.java
+ojluni/src/test/java/time/tck/java/time/format/TCKChronoPrinterParser.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/format/TCKChronoPrinterParser.java
+ojluni/src/test/java/time/tck/java/time/format/TCKDTFParsedInstant.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/format/TCKDTFParsedInstant.java
+ojluni/src/test/java/time/tck/java/time/format/TCKDateTimeFormatter.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/format/TCKDateTimeFormatter.java
+ojluni/src/test/java/time/tck/java/time/format/TCKDateTimeFormatterBuilder.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/format/TCKDateTimeFormatterBuilder.java
+ojluni/src/test/java/time/tck/java/time/format/TCKDateTimeFormatters.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/format/TCKDateTimeFormatters.java
+ojluni/src/test/java/time/tck/java/time/format/TCKDateTimeParseResolver.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/format/TCKDateTimeParseResolver.java
+ojluni/src/test/java/time/tck/java/time/format/TCKDateTimeTextPrinting.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/format/TCKDateTimeTextPrinting.java
+ojluni/src/test/java/time/tck/java/time/format/TCKDecimalStyle.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/format/TCKDecimalStyle.java
+ojluni/src/test/java/time/tck/java/time/format/TCKFormatStyle.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/tck/java/time/format/TCKFormatStyle.java
+ojluni/src/test/java/time/tck/java/time/format/TCKInstantPrinterParser.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/format/TCKInstantPrinterParser.java
+ojluni/src/test/java/time/tck/java/time/format/TCKLocalizedFieldParser.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/format/TCKLocalizedFieldParser.java
+ojluni/src/test/java/time/tck/java/time/format/TCKLocalizedFieldPrinter.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/format/TCKLocalizedFieldPrinter.java
+ojluni/src/test/java/time/tck/java/time/format/TCKLocalizedOffsetIdPrinterParser.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/format/TCKLocalizedOffsetIdPrinterParser.java
+ojluni/src/test/java/time/tck/java/time/format/TCKLocalizedPrinterParser.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/format/TCKLocalizedPrinterParser.java
+ojluni/src/test/java/time/tck/java/time/format/TCKOffsetPrinterParser.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/format/TCKOffsetPrinterParser.java
+ojluni/src/test/java/time/tck/java/time/format/TCKPadPrinterParser.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/format/TCKPadPrinterParser.java
+ojluni/src/test/java/time/tck/java/time/format/TCKResolverStyle.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/format/TCKResolverStyle.java
+ojluni/src/test/java/time/tck/java/time/format/TCKSignStyle.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/format/TCKSignStyle.java
+ojluni/src/test/java/time/tck/java/time/format/TCKTextStyle.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/format/TCKTextStyle.java
+ojluni/src/test/java/time/tck/java/time/format/TCKZoneIdPrinterParser.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/format/TCKZoneIdPrinterParser.java
+ojluni/src/test/java/time/tck/java/time/serial/TCKClockSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/serial/TCKClockSerialization.java
+ojluni/src/test/java/time/tck/java/time/serial/TCKDurationSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/serial/TCKDurationSerialization.java
+ojluni/src/test/java/time/tck/java/time/serial/TCKInstantSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/serial/TCKInstantSerialization.java
+ojluni/src/test/java/time/tck/java/time/serial/TCKLocalDateSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/serial/TCKLocalDateSerialization.java
+ojluni/src/test/java/time/tck/java/time/serial/TCKLocalDateTimeSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/serial/TCKLocalDateTimeSerialization.java
+ojluni/src/test/java/time/tck/java/time/serial/TCKLocalTimeSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/serial/TCKLocalTimeSerialization.java
+ojluni/src/test/java/time/tck/java/time/serial/TCKMonthDaySerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/serial/TCKMonthDaySerialization.java
+ojluni/src/test/java/time/tck/java/time/serial/TCKOffsetDateTimeSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/serial/TCKOffsetDateTimeSerialization.java
+ojluni/src/test/java/time/tck/java/time/serial/TCKOffsetTimeSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/serial/TCKOffsetTimeSerialization.java
+ojluni/src/test/java/time/tck/java/time/serial/TCKPeriodSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/serial/TCKPeriodSerialization.java
+ojluni/src/test/java/time/tck/java/time/serial/TCKYearMonthSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/serial/TCKYearMonthSerialization.java
+ojluni/src/test/java/time/tck/java/time/serial/TCKYearSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/serial/TCKYearSerialization.java
+ojluni/src/test/java/time/tck/java/time/serial/TCKZoneIdSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/serial/TCKZoneIdSerialization.java
+ojluni/src/test/java/time/tck/java/time/serial/TCKZoneOffsetSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/serial/TCKZoneOffsetSerialization.java
+ojluni/src/test/java/time/tck/java/time/serial/TCKZonedDateTimeSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/serial/TCKZonedDateTimeSerialization.java
+ojluni/src/test/java/time/tck/java/time/temporal/TCKChronoField.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/temporal/TCKChronoField.java
+ojluni/src/test/java/time/tck/java/time/temporal/TCKChronoUnit.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/temporal/TCKChronoUnit.java
+ojluni/src/test/java/time/tck/java/time/temporal/TCKIsoFields.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/tck/java/time/temporal/TCKIsoFields.java
+ojluni/src/test/java/time/tck/java/time/temporal/TCKJulianFields.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/temporal/TCKJulianFields.java
+ojluni/src/test/java/time/tck/java/time/temporal/TCKTemporalAdjusters.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/temporal/TCKTemporalAdjusters.java
+ojluni/src/test/java/time/tck/java/time/temporal/TCKWeekFields.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/temporal/TCKWeekFields.java
+ojluni/src/test/java/time/tck/java/time/temporal/serial/TCKChronoFieldSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/temporal/serial/TCKChronoFieldSerialization.java
+ojluni/src/test/java/time/tck/java/time/temporal/serial/TCKChronoUnitSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/temporal/serial/TCKChronoUnitSerialization.java
+ojluni/src/test/java/time/tck/java/time/temporal/serial/TCKJulianFieldsSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/temporal/serial/TCKJulianFieldsSerialization.java
+ojluni/src/test/java/time/tck/java/time/temporal/serial/TCKValueRangeSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/temporal/serial/TCKValueRangeSerialization.java
+ojluni/src/test/java/time/tck/java/time/temporal/serial/TCKWeekFieldsSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/temporal/serial/TCKWeekFieldsSerialization.java
+ojluni/src/test/java/time/tck/java/time/zone/TCKFixedZoneRules.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/zone/TCKFixedZoneRules.java
+ojluni/src/test/java/time/tck/java/time/zone/TCKZoneOffsetTransition.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/zone/TCKZoneOffsetTransition.java
+ojluni/src/test/java/time/tck/java/time/zone/TCKZoneOffsetTransitionRule.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/zone/TCKZoneOffsetTransitionRule.java
+ojluni/src/test/java/time/tck/java/time/zone/TCKZoneRules.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/tck/java/time/zone/TCKZoneRules.java
+ojluni/src/test/java/time/tck/java/time/zone/TCKZoneRulesProvider.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/zone/TCKZoneRulesProvider.java
+ojluni/src/test/java/time/tck/java/time/zone/serial/TCKFixedZoneRulesSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/zone/serial/TCKFixedZoneRulesSerialization.java
+ojluni/src/test/java/time/tck/java/time/zone/serial/TCKZoneOffsetTransitionRuleSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/zone/serial/TCKZoneOffsetTransitionRuleSerialization.java
+ojluni/src/test/java/time/tck/java/time/zone/serial/TCKZoneOffsetTransitionSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/zone/serial/TCKZoneOffsetTransitionSerialization.java
+ojluni/src/test/java/time/tck/java/time/zone/serial/TCKZoneRulesSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/tck/java/time/zone/serial/TCKZoneRulesSerialization.java
+ojluni/src/test/java/time/test/java/time/AbstractTest.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/test/java/time/AbstractTest.java
+ojluni/src/test/java/time/test/java/time/MockSimplePeriod.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/MockSimplePeriod.java
+ojluni/src/test/java/time/test/java/time/TestClock_Fixed.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/TestClock_Fixed.java
+ojluni/src/test/java/time/test/java/time/TestClock_Offset.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/TestClock_Offset.java
+ojluni/src/test/java/time/test/java/time/TestClock_System.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/test/java/time/TestClock_System.java
+ojluni/src/test/java/time/test/java/time/TestClock_Tick.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/TestClock_Tick.java
+ojluni/src/test/java/time/test/java/time/TestDuration.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/TestDuration.java
+ojluni/src/test/java/time/test/java/time/TestInstant.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/test/java/time/TestInstant.java
+ojluni/src/test/java/time/test/java/time/TestInstantSource.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/TestInstantSource.java
+ojluni/src/test/java/time/test/java/time/TestLocalDate.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/test/java/time/TestLocalDate.java
+ojluni/src/test/java/time/test/java/time/TestLocalDateTime.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/TestLocalDateTime.java
+ojluni/src/test/java/time/test/java/time/TestLocalTime.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/TestLocalTime.java
+ojluni/src/test/java/time/test/java/time/TestMonthDay.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/TestMonthDay.java
+ojluni/src/test/java/time/test/java/time/TestOffsetDateTime.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/TestOffsetDateTime.java
+ojluni/src/test/java/time/test/java/time/TestOffsetDateTime_instants.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/TestOffsetDateTime_instants.java
+ojluni/src/test/java/time/test/java/time/TestOffsetTime.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/TestOffsetTime.java
+ojluni/src/test/java/time/test/java/time/TestPeriod.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/TestPeriod.java
+ojluni/src/test/java/time/test/java/time/TestYear.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/TestYear.java
+ojluni/src/test/java/time/test/java/time/TestYearMonth.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/TestYearMonth.java
+ojluni/src/test/java/time/test/java/time/TestZoneId.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/TestZoneId.java
+ojluni/src/test/java/time/test/java/time/TestZoneOffset.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/test/java/time/TestZoneOffset.java
+ojluni/src/test/java/time/test/java/time/TestZonedDateTime.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/TestZonedDateTime.java
+ojluni/src/test/java/time/test/java/time/chrono/TestChronoLocalDate.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/chrono/TestChronoLocalDate.java
+ojluni/src/test/java/time/test/java/time/chrono/TestChronologyPerf.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/chrono/TestChronologyPerf.java
+ojluni/src/test/java/time/test/java/time/chrono/TestEraDisplayName.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/test/java/time/chrono/TestEraDisplayName.java
+ojluni/src/test/java/time/test/java/time/chrono/TestExampleCode.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/test/java/time/chrono/TestExampleCode.java
+ojluni/src/test/java/time/test/java/time/chrono/TestIsoChronoImpl.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/chrono/TestIsoChronoImpl.java
+ojluni/src/test/java/time/test/java/time/chrono/TestJapaneseChronoImpl.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/chrono/TestJapaneseChronoImpl.java
+ojluni/src/test/java/time/test/java/time/chrono/TestJapaneseChronology.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/chrono/TestJapaneseChronology.java
+ojluni/src/test/java/time/test/java/time/chrono/TestServiceLoader.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/test/java/time/chrono/TestServiceLoader.java
+ojluni/src/test/java/time/test/java/time/chrono/TestThaiBuddhistChronoImpl.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/chrono/TestThaiBuddhistChronoImpl.java
+ojluni/src/test/java/time/test/java/time/chrono/TestUmmAlQuraChronology.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/chrono/TestUmmAlQuraChronology.java
+ojluni/src/test/java/time/test/java/time/format/AbstractTestPrinterParser.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/format/AbstractTestPrinterParser.java
+ojluni/src/test/java/time/test/java/time/format/MockIOExceptionAppendable.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/format/MockIOExceptionAppendable.java
+ojluni/src/test/java/time/test/java/time/format/TestCharLiteralParser.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/format/TestCharLiteralParser.java
+ojluni/src/test/java/time/test/java/time/format/TestCharLiteralPrinter.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/format/TestCharLiteralPrinter.java
+ojluni/src/test/java/time/test/java/time/format/TestDateTimeFormatter.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/test/java/time/format/TestDateTimeFormatter.java
+ojluni/src/test/java/time/test/java/time/format/TestDateTimeFormatterBuilder.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/test/java/time/format/TestDateTimeFormatterBuilder.java
+ojluni/src/test/java/time/test/java/time/format/TestDateTimeFormatterBuilderWithLocale.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/test/java/time/format/TestDateTimeFormatterBuilderWithLocale.java
 ojluni/src/test/java/time/test/java/time/format/TestDateTimeParsing.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/format/TestDateTimeParsing.java
-ojluni/src/test/java/time/test/java/time/format/TestDateTimeTextProvider.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/time/format/TestDateTimeTextProvider.java
-ojluni/src/test/java/time/test/java/time/format/TestDateTimeTextProviderWithLocale.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/time/format/TestDateTimeTextProviderWithLocale.java
-ojluni/src/test/java/time/test/java/time/format/TestDecimalStyle.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/format/TestDecimalStyle.java
-ojluni/src/test/java/time/test/java/time/format/TestFractionPrinterParser.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/time/format/TestFractionPrinterParser.java
-ojluni/src/test/java/time/test/java/time/format/TestNarrowMonthNamesAndDayNames.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/time/format/TestNarrowMonthNamesAndDayNames.java
-ojluni/src/test/java/time/test/java/time/format/TestNonIsoFormatter.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/time/format/TestNonIsoFormatter.java
-ojluni/src/test/java/time/test/java/time/format/TestNumberParser.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/format/TestNumberParser.java
-ojluni/src/test/java/time/test/java/time/format/TestNumberPrinter.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/format/TestNumberPrinter.java
-ojluni/src/test/java/time/test/java/time/format/TestPadPrinterDecorator.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/format/TestPadPrinterDecorator.java
-ojluni/src/test/java/time/test/java/time/format/TestReducedParser.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/format/TestReducedParser.java
-ojluni/src/test/java/time/test/java/time/format/TestReducedPrinter.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/format/TestReducedPrinter.java
-ojluni/src/test/java/time/test/java/time/format/TestSettingsParser.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/format/TestSettingsParser.java
-ojluni/src/test/java/time/test/java/time/format/TestStringLiteralParser.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/format/TestStringLiteralParser.java
-ojluni/src/test/java/time/test/java/time/format/TestStringLiteralPrinter.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/format/TestStringLiteralPrinter.java
-ojluni/src/test/java/time/test/java/time/format/TestTextParser.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/format/TestTextParser.java
-ojluni/src/test/java/time/test/java/time/format/TestTextParserWithLocale.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/time/format/TestTextParserWithLocale.java
-ojluni/src/test/java/time/test/java/time/format/TestTextPrinter.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/format/TestTextPrinter.java
-ojluni/src/test/java/time/test/java/time/format/TestTextPrinterWithLocale.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/time/format/TestTextPrinterWithLocale.java
-ojluni/src/test/java/time/test/java/time/format/TestUnicodeExtension.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/time/format/TestUnicodeExtension.java
-ojluni/src/test/java/time/test/java/time/format/TestZoneOffsetParser.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/format/TestZoneOffsetParser.java
-ojluni/src/test/java/time/test/java/time/format/TestZoneOffsetPrinter.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/format/TestZoneOffsetPrinter.java
-ojluni/src/test/java/time/test/java/time/format/TestZoneTextPrinterParser.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/time/format/TestZoneTextPrinterParser.java
-ojluni/src/test/java/time/test/java/time/format/ZoneName.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/format/ZoneName.java
-ojluni/src/test/java/time/test/java/time/temporal/MockFieldNoValue.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/temporal/MockFieldNoValue.java
-ojluni/src/test/java/time/test/java/time/temporal/MockFieldValue.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/temporal/MockFieldValue.java
-ojluni/src/test/java/time/test/java/time/temporal/TestChronoField.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/temporal/TestChronoField.java
-ojluni/src/test/java/time/test/java/time/temporal/TestChronoUnit.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/temporal/TestChronoUnit.java
-ojluni/src/test/java/time/test/java/time/temporal/TestDateTimeBuilderCombinations.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/temporal/TestDateTimeBuilderCombinations.java
-ojluni/src/test/java/time/test/java/time/temporal/TestDateTimeValueRange.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/temporal/TestDateTimeValueRange.java
-ojluni/src/test/java/time/test/java/time/temporal/TestIsoWeekFields.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/time/test/java/time/temporal/TestIsoWeekFields.java
-ojluni/src/test/java/time/test/java/time/temporal/TestJulianFields.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/temporal/TestJulianFields.java
-ojluni/src/test/java/time/test/java/time/zone/TestFixedZoneRules.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/zone/TestFixedZoneRules.java
-ojluni/src/test/java/time/test/java/time/zone/TestZoneRules.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/time/zone/TestZoneRules.java
-ojluni/src/test/java/time/test/java/util/TestFormatter.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/time/test/java/util/TestFormatter.java
-ojluni/src/test/java/util/AbstractCollection/ToArrayTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/AbstractCollection/ToArrayTest.java
-ojluni/src/test/java/util/AbstractCollection/ToString.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/AbstractCollection/ToString.java
-ojluni/src/test/java/util/AbstractList/CheckForComodification.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/AbstractList/CheckForComodification.java
-ojluni/src/test/java/util/AbstractList/CheckForIndexOutOfBoundsException.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/AbstractList/CheckForIndexOutOfBoundsException.java
-ojluni/src/test/java/util/AbstractList/FailFastIterator.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/AbstractList/FailFastIterator.java
-ojluni/src/test/java/util/AbstractList/HasNextAfterException.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/AbstractList/HasNextAfterException.java
-ojluni/src/test/java/util/AbstractMap/AbstractMapClone.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/AbstractMap/AbstractMapClone.java
-ojluni/src/test/java/util/AbstractMap/Equals.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/AbstractMap/Equals.java
-ojluni/src/test/java/util/AbstractMap/SimpleEntries.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/AbstractMap/SimpleEntries.java
-ojluni/src/test/java/util/AbstractMap/ToString.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/AbstractMap/ToString.java
-ojluni/src/test/java/util/AbstractSequentialList/AddAll.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/AbstractSequentialList/AddAll.java
-ojluni/src/test/java/util/ArrayList/AddAll.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/ArrayList/AddAll.java
-ojluni/src/test/java/util/ArrayList/ArrayManagement.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/ArrayList/ArrayManagement.java
-ojluni/src/test/java/util/ArrayList/Bug6533203.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/ArrayList/Bug6533203.java
-ojluni/src/test/java/util/ArrayList/EnsureCapacity.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/ArrayList/EnsureCapacity.java
-ojluni/src/test/java/util/ArrayList/SubListModCount.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/ArrayList/SubListModCount.java
-ojluni/src/test/java/util/Arrays/ArrayObjectMethods.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Arrays/ArrayObjectMethods.java
-ojluni/src/test/java/util/Arrays/ArraysEqCmpTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Arrays/ArraysEqCmpTest.java
-ojluni/src/test/java/util/Arrays/AsList.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Arrays/AsList.java
-ojluni/src/test/java/util/Arrays/CopyMethods.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Arrays/CopyMethods.java
-ojluni/src/test/java/util/Arrays/Correct.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Arrays/Correct.java
-ojluni/src/test/java/util/Arrays/Fill.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Arrays/Fill.java
-ojluni/src/test/java/util/Arrays/FloatDoubleOrder.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Arrays/FloatDoubleOrder.java
-ojluni/src/test/java/util/Arrays/HashCode.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Arrays/HashCode.java
-ojluni/src/test/java/util/Arrays/SetAllTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Arrays/SetAllTest.java
-ojluni/src/test/java/util/Arrays/Sorting.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Arrays/Sorting.java
-ojluni/src/test/java/util/Arrays/SortingHelper.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Arrays/java.base/java/util/SortingHelper.java
-ojluni/src/test/java/util/Arrays/SortingNearlySortedPrimitive.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Arrays/SortingNearlySortedPrimitive.java
-ojluni/src/test/java/util/Arrays/StreamAndSpliterator.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Arrays/StreamAndSpliterator.java
-ojluni/src/test/java/util/Arrays/TimSortStackSize.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Arrays/TimSortStackSize.java
-ojluni/src/test/java/util/Arrays/TimSortStackSize2.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Arrays/TimSortStackSize2.java
-ojluni/src/test/java/util/Base64/Base64GetEncoderTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Base64/Base64GetEncoderTest.java
-ojluni/src/test/java/util/Base64/TestBase64.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/util/Base64/TestBase64.java
-ojluni/src/test/java/util/Base64/TestBase64Golden.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Base64/TestBase64Golden.java
-ojluni/src/test/java/util/Base64/baseEncode.txt,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Base64/baseEncode.txt
-ojluni/src/test/java/util/Base64/mimeEncode.txt,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Base64/mimeEncode.txt
-ojluni/src/test/java/util/Base64/plain.txt,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Base64/plain.txt
-ojluni/src/test/java/util/Base64/urlEncode.txt,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Base64/urlEncode.txt
-ojluni/src/test/java/util/BitSet/And.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/BitSet/And.java
-ojluni/src/test/java/util/BitSet/BSMethods.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/BitSet/BSMethods.java
-ojluni/src/test/java/util/BitSet/ImportExport.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/BitSet/ImportExport.java
-ojluni/src/test/java/util/BitSet/MemoryLeak.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/BitSet/MemoryLeak.java
-ojluni/src/test/java/util/BitSet/PreviousBits.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/BitSet/PreviousBits.java
-ojluni/src/test/java/util/BitSet/StickySize.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/BitSet/StickySize.java
-ojluni/src/test/java/util/BitSet/stream/BitSetStreamTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/BitSet/stream/BitSetStreamTest.java
-ojluni/src/test/java/util/Collection/MOAT.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collection/MOAT.java
-ojluni/src/test/java/util/Collections/AddAll.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/AddAll.java
-ojluni/src/test/java/util/Collections/AsLifoQueue.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/AsLifoQueue.java
-ojluni/src/test/java/util/Collections/BigBinarySearch.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/BigBinarySearch.java
-ojluni/src/test/java/util/Collections/BinarySearchNullComparator.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/BinarySearchNullComparator.java
-ojluni/src/test/java/util/Collections/CheckedIdentityMap.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/CheckedIdentityMap.java
-ojluni/src/test/java/util/Collections/CheckedListBash.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/CheckedListBash.java
-ojluni/src/test/java/util/Collections/CheckedListReplaceAll.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/CheckedListReplaceAll.java
-ojluni/src/test/java/util/Collections/CheckedMapBash.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/CheckedMapBash.java
-ojluni/src/test/java/util/Collections/CheckedMapReplaceAll.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/CheckedMapReplaceAll.java
-ojluni/src/test/java/util/Collections/CheckedNull.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/CheckedNull.java
-ojluni/src/test/java/util/Collections/CheckedQueue.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/CheckedQueue.java
-ojluni/src/test/java/util/Collections/CheckedSetBash.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/CheckedSetBash.java
-ojluni/src/test/java/util/Collections/DelegatingIteratorForEachRemaining.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/DelegatingIteratorForEachRemaining.java
-ojluni/src/test/java/util/Collections/Disjoint.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/Disjoint.java
-ojluni/src/test/java/util/Collections/EmptyCollectionSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/EmptyCollectionSerialization.java
-ojluni/src/test/java/util/Collections/EmptyIterator.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/EmptyIterator.java
-ojluni/src/test/java/util/Collections/EmptyNavigableMap.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/EmptyNavigableMap.java
-ojluni/src/test/java/util/Collections/EmptyNavigableSet.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/EmptyNavigableSet.java
-ojluni/src/test/java/util/Collections/Enum.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/Enum.java
-ojluni/src/test/java/util/Collections/EnumerationAsIterator.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/EnumerationAsIterator.java
-ojluni/src/test/java/util/Collections/EqualsTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/EqualsTest.java
-ojluni/src/test/java/util/Collections/FindSubList.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/FindSubList.java
-ojluni/src/test/java/util/Collections/Frequency.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/Frequency.java
-ojluni/src/test/java/util/Collections/MinMax.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/MinMax.java
-ojluni/src/test/java/util/Collections/NCopies.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/NCopies.java
-ojluni/src/test/java/util/Collections/NullComparator.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/NullComparator.java
-ojluni/src/test/java/util/Collections/RacingCollections.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/RacingCollections.java
-ojluni/src/test/java/util/Collections/ReplaceAll.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/ReplaceAll.java
-ojluni/src/test/java/util/Collections/ReverseOrder.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/ReverseOrder.java
-ojluni/src/test/java/util/Collections/ReverseOrder2.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/ReverseOrder2.java
-ojluni/src/test/java/util/Collections/Rotate.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/Rotate.java
-ojluni/src/test/java/util/Collections/RotateEmpty.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/RotateEmpty.java
-ojluni/src/test/java/util/Collections/Ser.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/Ser.java
-ojluni/src/test/java/util/Collections/SetFromMap.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/SetFromMap.java
-ojluni/src/test/java/util/Collections/SingletonIterator.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/SingletonIterator.java
-ojluni/src/test/java/util/Collections/Swap.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/Swap.java
-ojluni/src/test/java/util/Collections/SyncSubMutexes.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/SyncSubMutexes.java
-ojluni/src/test/java/util/Collections/T6433170.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/T6433170.java
-ojluni/src/test/java/util/Collections/UnmodifiableMapEntrySet.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/UnmodifiableMapEntrySet.java
-ojluni/src/test/java/util/Collections/ViewSynch.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/ViewSynch.java
-ojluni/src/test/java/util/Collections/WrappedNull.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/WrappedNull.java
-ojluni/src/test/java/util/Collections/WrappedUnmodifiableCollections.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/WrappedUnmodifiableCollections.java
-ojluni/src/test/java/util/Collections/Wrappers.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Collections/Wrappers.java
-ojluni/src/test/java/util/Comparator/BasicTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Comparator/BasicTest.java
-ojluni/src/test/java/util/Comparator/TypeTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Comparator/TypeTest.java
-ojluni/src/test/java/util/DoubleStreamSums/CompensatedSums.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/DoubleStreamSums/CompensatedSums.java
-ojluni/src/test/java/util/DoubleSummaryStatistics/NegativeCompensation.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/DoubleSummaryStatistics/NegativeCompensation.java
-ojluni/src/test/java/util/EnumMap/DistinctEntrySetElements.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/EnumMap/DistinctEntrySetElements.java
-ojluni/src/test/java/util/EnumMap/EntrySetIteratorRemoveInvalidatesEntry.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/EnumMap/EntrySetIteratorRemoveInvalidatesEntry.java
-ojluni/src/test/java/util/EnumMap/EnumMapBash.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/EnumMap/EnumMapBash.java
-ojluni/src/test/java/util/EnumMap/ProperEntrySetOnClone.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/EnumMap/ProperEntrySetOnClone.java
-ojluni/src/test/java/util/EnumMap/SimpleSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/EnumMap/SimpleSerialization.java
-ojluni/src/test/java/util/EnumMap/ToArray.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/EnumMap/ToArray.java
-ojluni/src/test/java/util/EnumMap/UniqueNullValue.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/EnumMap/UniqueNullValue.java
-ojluni/src/test/java/util/EnumSet/AllOf.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/EnumSet/AllOf.java
-ojluni/src/test/java/util/EnumSet/BogusEnumSet.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/EnumSet/BogusEnumSet.java
-ojluni/src/test/java/util/EnumSet/ComplementOf.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/EnumSet/ComplementOf.java
-ojluni/src/test/java/util/EnumSet/EnumSetBash.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/EnumSet/EnumSetBash.java
-ojluni/src/test/java/util/EnumSet/EnumSetClassSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/EnumSet/EnumSetClassSerialization.java
-ojluni/src/test/java/util/EnumSet/InsertWrongType.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/EnumSet/InsertWrongType.java
-ojluni/src/test/java/util/EnumSet/JumboRange.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/EnumSet/JumboRange.java
-ojluni/src/test/java/util/EnumSet/LargeEnumIteratorRemoveResilience.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/EnumSet/LargeEnumIteratorRemoveResilience.java
-ojluni/src/test/java/util/EnumSet/OneUniverse.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/EnumSet/OneUniverse.java
-ojluni/src/test/java/util/EnumSet/Range.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/EnumSet/Range.java
-ojluni/src/test/java/util/EnumSet/RetainAll.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/EnumSet/RetainAll.java
-ojluni/src/test/java/util/EnumSet/SmallEnumIteratorRemoveResilience.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/EnumSet/SmallEnumIteratorRemoveResilience.java
-ojluni/src/test/java/util/HashMap/HashMapCloneLeak.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/HashMap/HashMapCloneLeak.java
-ojluni/src/test/java/util/HashMap/KeySetRemove.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/HashMap/KeySetRemove.java
-ojluni/src/test/java/util/HashMap/NullKeyAtResize.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/HashMap/NullKeyAtResize.java
-ojluni/src/test/java/util/HashMap/OverrideIsEmpty.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/HashMap/OverrideIsEmpty.java
-ojluni/src/test/java/util/HashMap/PutNullKey.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/HashMap/PutNullKey.java
-ojluni/src/test/java/util/HashMap/ReplaceExisting.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/HashMap/ReplaceExisting.java
-ojluni/src/test/java/util/HashMap/SetValue.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/HashMap/SetValue.java
-ojluni/src/test/java/util/HashMap/ToArray.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/HashMap/ToArray.java
-ojluni/src/test/java/util/HashMap/ToString.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/HashMap/ToString.java
-ojluni/src/test/java/util/HashMap/TreeBinAssert.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/HashMap/TreeBinAssert.java
+ojluni/src/test/java/time/test/java/time/format/TestDateTimeTextProvider.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/test/java/time/format/TestDateTimeTextProvider.java
+ojluni/src/test/java/time/test/java/time/format/TestDateTimeTextProviderWithLocale.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/test/java/time/format/TestDateTimeTextProviderWithLocale.java
+ojluni/src/test/java/time/test/java/time/format/TestDecimalStyle.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/format/TestDecimalStyle.java
+ojluni/src/test/java/time/test/java/time/format/TestFractionPrinterParser.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/test/java/time/format/TestFractionPrinterParser.java
+ojluni/src/test/java/time/test/java/time/format/TestNarrowMonthNamesAndDayNames.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/test/java/time/format/TestNarrowMonthNamesAndDayNames.java
+ojluni/src/test/java/time/test/java/time/format/TestNonIsoFormatter.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/test/java/time/format/TestNonIsoFormatter.java
+ojluni/src/test/java/time/test/java/time/format/TestNumberParser.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/format/TestNumberParser.java
+ojluni/src/test/java/time/test/java/time/format/TestNumberPrinter.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/format/TestNumberPrinter.java
+ojluni/src/test/java/time/test/java/time/format/TestPadPrinterDecorator.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/format/TestPadPrinterDecorator.java
+ojluni/src/test/java/time/test/java/time/format/TestReducedParser.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/format/TestReducedParser.java
+ojluni/src/test/java/time/test/java/time/format/TestReducedPrinter.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/format/TestReducedPrinter.java
+ojluni/src/test/java/time/test/java/time/format/TestSettingsParser.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/format/TestSettingsParser.java
+ojluni/src/test/java/time/test/java/time/format/TestStringLiteralParser.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/format/TestStringLiteralParser.java
+ojluni/src/test/java/time/test/java/time/format/TestStringLiteralPrinter.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/format/TestStringLiteralPrinter.java
+ojluni/src/test/java/time/test/java/time/format/TestTextParser.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/format/TestTextParser.java
+ojluni/src/test/java/time/test/java/time/format/TestTextParserWithLocale.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/test/java/time/format/TestTextParserWithLocale.java
+ojluni/src/test/java/time/test/java/time/format/TestTextPrinter.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/format/TestTextPrinter.java
+ojluni/src/test/java/time/test/java/time/format/TestTextPrinterWithLocale.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/test/java/time/format/TestTextPrinterWithLocale.java
+ojluni/src/test/java/time/test/java/time/format/TestUnicodeExtension.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/test/java/time/format/TestUnicodeExtension.java
+ojluni/src/test/java/time/test/java/time/format/TestZoneOffsetParser.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/format/TestZoneOffsetParser.java
+ojluni/src/test/java/time/test/java/time/format/TestZoneOffsetPrinter.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/format/TestZoneOffsetPrinter.java
+ojluni/src/test/java/time/test/java/time/format/TestZoneTextPrinterParser.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/test/java/time/format/TestZoneTextPrinterParser.java
+ojluni/src/test/java/time/test/java/time/format/ZoneName.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/format/ZoneName.java
+ojluni/src/test/java/time/test/java/time/temporal/MockFieldNoValue.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/temporal/MockFieldNoValue.java
+ojluni/src/test/java/time/test/java/time/temporal/MockFieldValue.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/temporal/MockFieldValue.java
+ojluni/src/test/java/time/test/java/time/temporal/TestChronoField.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/temporal/TestChronoField.java
+ojluni/src/test/java/time/test/java/time/temporal/TestChronoUnit.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/temporal/TestChronoUnit.java
+ojluni/src/test/java/time/test/java/time/temporal/TestDateTimeBuilderCombinations.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/temporal/TestDateTimeBuilderCombinations.java
+ojluni/src/test/java/time/test/java/time/temporal/TestDateTimeValueRange.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/temporal/TestDateTimeValueRange.java
+ojluni/src/test/java/time/test/java/time/temporal/TestIsoWeekFields.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/time/test/java/time/temporal/TestIsoWeekFields.java
+ojluni/src/test/java/time/test/java/time/temporal/TestJulianFields.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/temporal/TestJulianFields.java
+ojluni/src/test/java/time/test/java/time/zone/TestFixedZoneRules.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/zone/TestFixedZoneRules.java
+ojluni/src/test/java/time/test/java/time/zone/TestZoneRules.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/time/zone/TestZoneRules.java
+ojluni/src/test/java/time/test/java/util/TestFormatter.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/time/test/java/util/TestFormatter.java
+ojluni/src/test/java/util/AbstractCollection/ToArrayTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/AbstractCollection/ToArrayTest.java
+ojluni/src/test/java/util/AbstractCollection/ToString.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/AbstractCollection/ToString.java
+ojluni/src/test/java/util/AbstractList/CheckForComodification.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/AbstractList/CheckForComodification.java
+ojluni/src/test/java/util/AbstractList/CheckForIndexOutOfBoundsException.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/AbstractList/CheckForIndexOutOfBoundsException.java
+ojluni/src/test/java/util/AbstractList/FailFastIterator.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/AbstractList/FailFastIterator.java
+ojluni/src/test/java/util/AbstractList/HasNextAfterException.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/AbstractList/HasNextAfterException.java
+ojluni/src/test/java/util/AbstractMap/AbstractMapClone.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/AbstractMap/AbstractMapClone.java
+ojluni/src/test/java/util/AbstractMap/Equals.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/AbstractMap/Equals.java
+ojluni/src/test/java/util/AbstractMap/SimpleEntries.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/AbstractMap/SimpleEntries.java
+ojluni/src/test/java/util/AbstractMap/ToString.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/AbstractMap/ToString.java
+ojluni/src/test/java/util/AbstractSequentialList/AddAll.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/AbstractSequentialList/AddAll.java
+ojluni/src/test/java/util/ArrayList/AddAll.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/ArrayList/AddAll.java
+ojluni/src/test/java/util/ArrayList/ArrayManagement.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/ArrayList/ArrayManagement.java
+ojluni/src/test/java/util/ArrayList/Bug6533203.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/ArrayList/Bug6533203.java
+ojluni/src/test/java/util/ArrayList/EnsureCapacity.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/ArrayList/EnsureCapacity.java
+ojluni/src/test/java/util/ArrayList/SubListModCount.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/ArrayList/SubListModCount.java
+ojluni/src/test/java/util/Arrays/ArrayObjectMethods.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Arrays/ArrayObjectMethods.java
+ojluni/src/test/java/util/Arrays/ArraysEqCmpTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Arrays/ArraysEqCmpTest.java
+ojluni/src/test/java/util/Arrays/AsList.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Arrays/AsList.java
+ojluni/src/test/java/util/Arrays/CopyMethods.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Arrays/CopyMethods.java
+ojluni/src/test/java/util/Arrays/Correct.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Arrays/Correct.java
+ojluni/src/test/java/util/Arrays/Fill.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Arrays/Fill.java
+ojluni/src/test/java/util/Arrays/FloatDoubleOrder.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Arrays/FloatDoubleOrder.java
+ojluni/src/test/java/util/Arrays/HashCode.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Arrays/HashCode.java
+ojluni/src/test/java/util/Arrays/SetAllTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Arrays/SetAllTest.java
+ojluni/src/test/java/util/Arrays/Sorting.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Arrays/Sorting.java
+ojluni/src/test/java/util/Arrays/SortingHelper.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Arrays/java.base/java/util/SortingHelper.java
+ojluni/src/test/java/util/Arrays/SortingNearlySortedPrimitive.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Arrays/SortingNearlySortedPrimitive.java
+ojluni/src/test/java/util/Arrays/StreamAndSpliterator.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Arrays/StreamAndSpliterator.java
+ojluni/src/test/java/util/Arrays/TimSortStackSize.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Arrays/TimSortStackSize.java
+ojluni/src/test/java/util/Arrays/TimSortStackSize2.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Arrays/TimSortStackSize2.java
+ojluni/src/test/java/util/Base64/Base64GetEncoderTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Base64/Base64GetEncoderTest.java
+ojluni/src/test/java/util/Base64/TestBase64.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/util/Base64/TestBase64.java
+ojluni/src/test/java/util/Base64/TestBase64Golden.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Base64/TestBase64Golden.java
+ojluni/src/test/java/util/Base64/baseEncode.txt,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Base64/baseEncode.txt
+ojluni/src/test/java/util/Base64/mimeEncode.txt,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Base64/mimeEncode.txt
+ojluni/src/test/java/util/Base64/plain.txt,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Base64/plain.txt
+ojluni/src/test/java/util/Base64/urlEncode.txt,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Base64/urlEncode.txt
+ojluni/src/test/java/util/BitSet/And.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/BitSet/And.java
+ojluni/src/test/java/util/BitSet/BSMethods.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/BitSet/BSMethods.java
+ojluni/src/test/java/util/BitSet/ImportExport.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/BitSet/ImportExport.java
+ojluni/src/test/java/util/BitSet/MemoryLeak.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/BitSet/MemoryLeak.java
+ojluni/src/test/java/util/BitSet/PreviousBits.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/BitSet/PreviousBits.java
+ojluni/src/test/java/util/BitSet/StickySize.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/BitSet/StickySize.java
+ojluni/src/test/java/util/BitSet/stream/BitSetStreamTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/BitSet/stream/BitSetStreamTest.java
+ojluni/src/test/java/util/Collection/MOAT.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collection/MOAT.java
+ojluni/src/test/java/util/Collections/AddAll.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/AddAll.java
+ojluni/src/test/java/util/Collections/AsLifoQueue.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/AsLifoQueue.java
+ojluni/src/test/java/util/Collections/BigBinarySearch.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/BigBinarySearch.java
+ojluni/src/test/java/util/Collections/BinarySearchNullComparator.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/BinarySearchNullComparator.java
+ojluni/src/test/java/util/Collections/CheckedIdentityMap.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/CheckedIdentityMap.java
+ojluni/src/test/java/util/Collections/CheckedListBash.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/CheckedListBash.java
+ojluni/src/test/java/util/Collections/CheckedListReplaceAll.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/CheckedListReplaceAll.java
+ojluni/src/test/java/util/Collections/CheckedMapBash.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/CheckedMapBash.java
+ojluni/src/test/java/util/Collections/CheckedMapReplaceAll.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/CheckedMapReplaceAll.java
+ojluni/src/test/java/util/Collections/CheckedNull.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/CheckedNull.java
+ojluni/src/test/java/util/Collections/CheckedQueue.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/CheckedQueue.java
+ojluni/src/test/java/util/Collections/CheckedSetBash.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/CheckedSetBash.java
+ojluni/src/test/java/util/Collections/DelegatingIteratorForEachRemaining.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/DelegatingIteratorForEachRemaining.java
+ojluni/src/test/java/util/Collections/Disjoint.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/Disjoint.java
+ojluni/src/test/java/util/Collections/EmptyCollectionSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/EmptyCollectionSerialization.java
+ojluni/src/test/java/util/Collections/EmptyIterator.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/EmptyIterator.java
+ojluni/src/test/java/util/Collections/EmptyNavigableMap.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/EmptyNavigableMap.java
+ojluni/src/test/java/util/Collections/EmptyNavigableSet.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/EmptyNavigableSet.java
+ojluni/src/test/java/util/Collections/Enum.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/Enum.java
+ojluni/src/test/java/util/Collections/EnumerationAsIterator.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/EnumerationAsIterator.java
+ojluni/src/test/java/util/Collections/EqualsTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/EqualsTest.java
+ojluni/src/test/java/util/Collections/FindSubList.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/FindSubList.java
+ojluni/src/test/java/util/Collections/Frequency.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/Frequency.java
+ojluni/src/test/java/util/Collections/MinMax.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/MinMax.java
+ojluni/src/test/java/util/Collections/NCopies.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/NCopies.java
+ojluni/src/test/java/util/Collections/NullComparator.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/NullComparator.java
+ojluni/src/test/java/util/Collections/RacingCollections.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/RacingCollections.java
+ojluni/src/test/java/util/Collections/ReplaceAll.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/ReplaceAll.java
+ojluni/src/test/java/util/Collections/ReverseOrder.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/ReverseOrder.java
+ojluni/src/test/java/util/Collections/ReverseOrder2.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/ReverseOrder2.java
+ojluni/src/test/java/util/Collections/Rotate.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/Rotate.java
+ojluni/src/test/java/util/Collections/RotateEmpty.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/RotateEmpty.java
+ojluni/src/test/java/util/Collections/Ser.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/Ser.java
+ojluni/src/test/java/util/Collections/SetFromMap.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/SetFromMap.java
+ojluni/src/test/java/util/Collections/SingletonIterator.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/SingletonIterator.java
+ojluni/src/test/java/util/Collections/Swap.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/Swap.java
+ojluni/src/test/java/util/Collections/SyncSubMutexes.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/SyncSubMutexes.java
+ojluni/src/test/java/util/Collections/T6433170.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/T6433170.java
+ojluni/src/test/java/util/Collections/UnmodifiableMapEntrySet.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/UnmodifiableMapEntrySet.java
+ojluni/src/test/java/util/Collections/ViewSynch.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/ViewSynch.java
+ojluni/src/test/java/util/Collections/WrappedNull.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/WrappedNull.java
+ojluni/src/test/java/util/Collections/WrappedUnmodifiableCollections.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/WrappedUnmodifiableCollections.java
+ojluni/src/test/java/util/Collections/Wrappers.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Collections/Wrappers.java
+ojluni/src/test/java/util/Comparator/BasicTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Comparator/BasicTest.java
+ojluni/src/test/java/util/Comparator/TypeTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Comparator/TypeTest.java
+ojluni/src/test/java/util/DoubleStreamSums/CompensatedSums.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/DoubleStreamSums/CompensatedSums.java
+ojluni/src/test/java/util/DoubleSummaryStatistics/NegativeCompensation.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/DoubleSummaryStatistics/NegativeCompensation.java
+ojluni/src/test/java/util/EnumMap/DistinctEntrySetElements.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/EnumMap/DistinctEntrySetElements.java
+ojluni/src/test/java/util/EnumMap/EntrySetIteratorRemoveInvalidatesEntry.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/EnumMap/EntrySetIteratorRemoveInvalidatesEntry.java
+ojluni/src/test/java/util/EnumMap/EnumMapBash.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/EnumMap/EnumMapBash.java
+ojluni/src/test/java/util/EnumMap/ProperEntrySetOnClone.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/EnumMap/ProperEntrySetOnClone.java
+ojluni/src/test/java/util/EnumMap/SimpleSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/EnumMap/SimpleSerialization.java
+ojluni/src/test/java/util/EnumMap/ToArray.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/EnumMap/ToArray.java
+ojluni/src/test/java/util/EnumMap/UniqueNullValue.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/EnumMap/UniqueNullValue.java
+ojluni/src/test/java/util/EnumSet/AllOf.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/EnumSet/AllOf.java
+ojluni/src/test/java/util/EnumSet/BogusEnumSet.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/EnumSet/BogusEnumSet.java
+ojluni/src/test/java/util/EnumSet/ComplementOf.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/EnumSet/ComplementOf.java
+ojluni/src/test/java/util/EnumSet/EnumSetBash.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/EnumSet/EnumSetBash.java
+ojluni/src/test/java/util/EnumSet/EnumSetClassSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/EnumSet/EnumSetClassSerialization.java
+ojluni/src/test/java/util/EnumSet/InsertWrongType.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/EnumSet/InsertWrongType.java
+ojluni/src/test/java/util/EnumSet/JumboRange.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/EnumSet/JumboRange.java
+ojluni/src/test/java/util/EnumSet/LargeEnumIteratorRemoveResilience.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/EnumSet/LargeEnumIteratorRemoveResilience.java
+ojluni/src/test/java/util/EnumSet/OneUniverse.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/EnumSet/OneUniverse.java
+ojluni/src/test/java/util/EnumSet/Range.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/EnumSet/Range.java
+ojluni/src/test/java/util/EnumSet/RetainAll.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/EnumSet/RetainAll.java
+ojluni/src/test/java/util/EnumSet/SmallEnumIteratorRemoveResilience.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/EnumSet/SmallEnumIteratorRemoveResilience.java
+ojluni/src/test/java/util/HashMap/HashMapCloneLeak.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/HashMap/HashMapCloneLeak.java
+ojluni/src/test/java/util/HashMap/KeySetRemove.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/HashMap/KeySetRemove.java
+ojluni/src/test/java/util/HashMap/NullKeyAtResize.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/HashMap/NullKeyAtResize.java
+ojluni/src/test/java/util/HashMap/OverrideIsEmpty.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/HashMap/OverrideIsEmpty.java
+ojluni/src/test/java/util/HashMap/PutNullKey.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/HashMap/PutNullKey.java
+ojluni/src/test/java/util/HashMap/ReplaceExisting.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/HashMap/ReplaceExisting.java
+ojluni/src/test/java/util/HashMap/SetValue.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/HashMap/SetValue.java
+ojluni/src/test/java/util/HashMap/ToArray.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/HashMap/ToArray.java
+ojluni/src/test/java/util/HashMap/ToString.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/HashMap/ToString.java
+ojluni/src/test/java/util/HashMap/TreeBinAssert.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/HashMap/TreeBinAssert.java
 ojluni/src/test/java/util/HashMap/WhiteBoxResizeTest.java,jdk21u/jdk-21.0.2-ga,test/jdk/java/util/HashMap/WhiteBoxResizeTest.java
-ojluni/src/test/java/util/HashSet/Serialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/HashSet/Serialization.java
-ojluni/src/test/java/util/HexFormat/HexFormatTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/HexFormat/HexFormatTest.java
-ojluni/src/test/java/util/IdentityHashMap/Basic.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/IdentityHashMap/Basic.java
-ojluni/src/test/java/util/IdentityHashMap/Capacity.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/IdentityHashMap/Capacity.java
-ojluni/src/test/java/util/IdentityHashMap/DistinctEntrySetElements.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/IdentityHashMap/DistinctEntrySetElements.java
-ojluni/src/test/java/util/IdentityHashMap/EntrySetIteratorRemoveInvalidatesEntry.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/IdentityHashMap/EntrySetIteratorRemoveInvalidatesEntry.java
-ojluni/src/test/java/util/IdentityHashMap/ToArray.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/IdentityHashMap/ToArray.java
-ojluni/src/test/java/util/IdentityHashMap/ToString.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/IdentityHashMap/ToString.java
-ojluni/src/test/java/util/LinkedHashMap/Basic.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/LinkedHashMap/Basic.java
-ojluni/src/test/java/util/LinkedHashMap/Cache.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/LinkedHashMap/Cache.java
-ojluni/src/test/java/util/LinkedHashMap/ComputeIfAbsentAccessOrder.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/LinkedHashMap/ComputeIfAbsentAccessOrder.java
-ojluni/src/test/java/util/LinkedHashMap/EmptyMapIterator.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/LinkedHashMap/EmptyMapIterator.java
-ojluni/src/test/java/util/LinkedHashSet/Basic.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/LinkedHashSet/Basic.java
-ojluni/src/test/java/util/Locale/AvailableLocalesTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Locale/AvailableLocalesTest.java
-ojluni/src/test/java/util/Locale/TestOf.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Locale/TestOf.java
-ojluni/src/test/java/util/Objects/BasicObjectsTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Objects/BasicObjectsTest.java
-ojluni/src/test/java/util/Optional/Basic.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Optional/Basic.java
-ojluni/src/test/java/util/Optional/BasicDouble.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Optional/BasicDouble.java
-ojluni/src/test/java/util/Optional/BasicInt.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Optional/BasicInt.java
-ojluni/src/test/java/util/Optional/BasicLong.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Optional/BasicLong.java
-ojluni/src/test/java/util/Optional/ObscureException.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Optional/ObscureException.java
-ojluni/src/test/java/util/PriorityQueue/AddNonComparable.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/PriorityQueue/AddNonComparable.java
-ojluni/src/test/java/util/PriorityQueue/ForgetMeNot.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/PriorityQueue/ForgetMeNot.java
-ojluni/src/test/java/util/PriorityQueue/NoNulls.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/PriorityQueue/NoNulls.java
-ojluni/src/test/java/util/PriorityQueue/PriorityQueueSort.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/PriorityQueue/PriorityQueueSort.java
-ojluni/src/test/java/util/PriorityQueue/RemoveContains.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/PriorityQueue/RemoveContains.java
-ojluni/src/test/java/util/Properties/BlankLines.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/BlankLines.java
-ojluni/src/test/java/util/Properties/Bug6609431.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/Bug6609431.java
-ojluni/src/test/java/util/Properties/Bug6609431.properties,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Properties/Bug6609431.properties
-ojluni/src/test/java/util/Properties/CheckOverrides.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/CheckOverrides.java
-ojluni/src/test/java/util/Properties/CheckUnsynchronized.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/CheckUnsynchronized.java
-ojluni/src/test/java/util/Properties/CloseXMLStream.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/CloseXMLStream.java
-ojluni/src/test/java/util/Properties/CompatibilityTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/CompatibilityTest.java
-ojluni/src/test/java/util/Properties/ConcurrentLoadAndStoreXML.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Properties/ConcurrentLoadAndStoreXML.java
-ojluni/src/test/java/util/Properties/EncodingTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/EncodingTest.java
-ojluni/src/test/java/util/Properties/EscapeSpace.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/EscapeSpace.java
-ojluni/src/test/java/util/Properties/InitialCapacity.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/InitialCapacity.java
-ojluni/src/test/java/util/Properties/LoadAndStoreNPE.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/LoadAndStoreNPE.java
-ojluni/src/test/java/util/Properties/LoadAndStoreXML.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Properties/LoadAndStoreXML.java
-ojluni/src/test/java/util/Properties/LoadAndStoreXMLWithDefaults.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/LoadAndStoreXMLWithDefaults.java
-ojluni/src/test/java/util/Properties/LoadParsing.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/LoadParsing.java
-ojluni/src/test/java/util/Properties/LoadParsing2.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/LoadParsing2.java
-ojluni/src/test/java/util/Properties/LoadSeparators.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/LoadSeparators.java
-ojluni/src/test/java/util/Properties/PropertiesEntrySetTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/PropertiesEntrySetTest.java
-ojluni/src/test/java/util/Properties/PropertiesSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/PropertiesSerialization.java
-ojluni/src/test/java/util/Properties/PropertiesTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/PropertiesTest.java
-ojluni/src/test/java/util/Properties/Save.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/Save.java
-ojluni/src/test/java/util/Properties/SaveClose.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/SaveClose.java
-ojluni/src/test/java/util/Properties/SaveComments.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/SaveComments.java
-ojluni/src/test/java/util/Properties/SaveEncoding.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/SaveEncoding.java
-ojluni/src/test/java/util/Properties/SaveLoadBasher.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/SaveLoadBasher.java
-ojluni/src/test/java/util/Properties/SaveSeparator.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/SaveSeparator.java
-ojluni/src/test/java/util/Properties/StoreDeadlock.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/StoreDeadlock.java
-ojluni/src/test/java/util/Properties/StringPropertyNames.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/StringPropertyNames.java
-ojluni/src/test/java/util/Properties/UnicodeEscape.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/UnicodeEscape.java
-ojluni/src/test/java/util/Properties/XMLSaveLoadBasher.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/XMLSaveLoadBasher.java
-ojluni/src/test/java/util/Properties/input.txt,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/input.txt
-ojluni/src/test/java/util/Properties/invalidxml/BadCase.xml,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/invalidxml/BadCase.xml
-ojluni/src/test/java/util/Properties/invalidxml/BadDocType.xml,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/invalidxml/BadDocType.xml
-ojluni/src/test/java/util/Properties/invalidxml/DTDRootNotMatch.xml,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/invalidxml/DTDRootNotMatch.xml
-ojluni/src/test/java/util/Properties/invalidxml/IllegalComment.xml,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/invalidxml/IllegalComment.xml
-ojluni/src/test/java/util/Properties/invalidxml/IllegalElement.xml,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/invalidxml/IllegalElement.xml
-ojluni/src/test/java/util/Properties/invalidxml/IllegalEntry.xml,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/invalidxml/IllegalEntry.xml
-ojluni/src/test/java/util/Properties/invalidxml/IllegalEntry1.xml,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/invalidxml/IllegalEntry1.xml
-ojluni/src/test/java/util/Properties/invalidxml/IllegalKeyAttribute.xml,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/invalidxml/IllegalKeyAttribute.xml
-ojluni/src/test/java/util/Properties/invalidxml/NoClosingTag.xml,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/invalidxml/NoClosingTag.xml
-ojluni/src/test/java/util/Properties/invalidxml/NoDocType.xml,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/invalidxml/NoDocType.xml
-ojluni/src/test/java/util/Properties/invalidxml/NoNamespaceSupport.xml,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/invalidxml/NoNamespaceSupport.xml
-ojluni/src/test/java/util/Properties/invalidxml/NoRoot.xml,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/invalidxml/NoRoot.xml
-ojluni/src/test/java/util/Properties/invalidxml/NotQuoted.xml,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/invalidxml/NotQuoted.xml
-ojluni/src/test/java/util/Properties/invalidxml/README.txt,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/invalidxml/README.txt
-ojluni/src/test/java/util/Properties/invalidxml/invalidDTD.xml,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/invalidxml/invalidDTD.xml
-ojluni/src/test/java/util/Properties/testData1,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/testData1
-ojluni/src/test/java/util/Properties/testData1.dos,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/testData1.dos
-ojluni/src/test/java/util/Properties/testData2,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/testData2
-ojluni/src/test/java/util/Properties/testData2.dos,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/testData2.dos
-ojluni/src/test/java/util/Properties/testData3.dos,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Properties/testData3.dos
-ojluni/src/test/java/util/Random/DistinctSeeds.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Random/DistinctSeeds.java
-ojluni/src/test/java/util/Random/NextBytes.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Random/NextBytes.java
-ojluni/src/test/java/util/Random/NextIntPowerOfTwoMod.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Random/NextIntPowerOfTwoMod.java
-ojluni/src/test/java/util/Random/RandomCanaryPi.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Random/RandomCanaryPi.java
-ojluni/src/test/java/util/Random/RandomExponentialTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Random/RandomExponentialTest.java
-ojluni/src/test/java/util/Random/RandomNextDoubleBoundary.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Random/RandomNextDoubleBoundary.java
-ojluni/src/test/java/util/Random/RandomStreamTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Random/RandomStreamTest.java
-ojluni/src/test/java/util/Random/RandomTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Random/RandomTest.java
-ojluni/src/test/java/util/Random/RandomTestBsi1999.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Random/RandomTestBsi1999.java
-ojluni/src/test/java/util/Random/RandomTestChiSquared.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Random/RandomTestChiSquared.java
-ojluni/src/test/java/util/Random/RandomTestCoverage.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Random/RandomTestCoverage.java
-ojluni/src/test/java/util/Random/RandomTestMoments.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Random/RandomTestMoments.java
-ojluni/src/test/java/util/Scanner/EncodingTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Scanner/EncodingTest.java
-ojluni/src/test/java/util/Scanner/FailingConstructors.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Scanner/FailingConstructors.java
-ojluni/src/test/java/util/Scanner/ScanTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/Scanner/ScanTest.java
-ojluni/src/test/java/util/Scanner/ScannerStreamTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Scanner/ScannerStreamTest.java
-ojluni/src/test/java/util/Scanner/input.txt,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Scanner/input.txt
-ojluni/src/test/java/util/SequencedCollection/Basic.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/SequencedCollection/Basic.java
-ojluni/src/test/java/util/SequencedCollection/BasicMap.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/SequencedCollection/BasicMap.java
-ojluni/src/test/java/util/SequencedCollection/SimpleDeque.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/SequencedCollection/SimpleDeque.java
-ojluni/src/test/java/util/SequencedCollection/SimpleList.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/SequencedCollection/SimpleList.java
-ojluni/src/test/java/util/SequencedCollection/SimpleSortedMap.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/SequencedCollection/SimpleSortedMap.java
-ojluni/src/test/java/util/SequencedCollection/SimpleSortedSet.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/SequencedCollection/SimpleSortedSet.java
-ojluni/src/test/java/util/ServiceLoader/basic/Basic.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/ServiceLoader/basic/Basic.java
-ojluni/src/test/java/util/ServiceLoader/basic/FooProvider1.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/ServiceLoader/basic/FooProvider1.java
-ojluni/src/test/java/util/ServiceLoader/basic/FooProvider2.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/ServiceLoader/basic/FooProvider2.java
-ojluni/src/test/java/util/ServiceLoader/basic/FooProvider3.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/ServiceLoader/basic/FooProvider3.java
-ojluni/src/test/java/util/ServiceLoader/basic/FooService.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/ServiceLoader/basic/FooService.java
-ojluni/src/test/java/util/StringJoiner/MergeTest.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/util/StringJoiner/MergeTest.java
-ojluni/src/test/java/util/StringJoiner/StringJoinerTest.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/util/StringJoiner/StringJoinerTest.java
-ojluni/src/test/java/util/Timer/Args.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Timer/Args.java
-ojluni/src/test/java/util/Timer/AutoStop.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Timer/AutoStop.java
-ojluni/src/test/java/util/Timer/DelayOverflow.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Timer/DelayOverflow.java
-ojluni/src/test/java/util/Timer/KillThread.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Timer/KillThread.java
-ojluni/src/test/java/util/Timer/NameConstructors.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Timer/NameConstructors.java
-ojluni/src/test/java/util/Timer/Purge.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Timer/Purge.java
-ojluni/src/test/java/util/UUID/Serial.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/UUID/Serial.java
-ojluni/src/test/java/util/UUID/UUIDTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/UUID/UUIDTest.java
-ojluni/src/test/java/util/Vector/ArrayManagement.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Vector/ArrayManagement.java
-ojluni/src/test/java/util/Vector/ComodifiedRemoveAllElements.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Vector/ComodifiedRemoveAllElements.java
-ojluni/src/test/java/util/Vector/CopyInto.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Vector/CopyInto.java
-ojluni/src/test/java/util/Vector/IllegalConstructorArgs.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Vector/IllegalConstructorArgs.java
-ojluni/src/test/java/util/Vector/LastIndexOf.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Vector/LastIndexOf.java
-ojluni/src/test/java/util/Vector/SerializationDeadlock.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Vector/SerializationDeadlock.java
-ojluni/src/test/java/util/Vector/SimpleSerialization.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Vector/SimpleSerialization.java
-ojluni/src/test/java/util/Vector/SyncLastIndexOf.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/Vector/SyncLastIndexOf.java
-ojluni/src/test/java/util/WeakHashMap/GCDuringIteration.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/WeakHashMap/GCDuringIteration.java
-ojluni/src/test/java/util/WeakHashMap/Iteration.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/WeakHashMap/Iteration.java
-ojluni/src/test/java/util/WeakHashMap/ZeroInitCap.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/WeakHashMap/ZeroInitCap.java
-ojluni/src/test/java/util/concurrent/tck/CompletableFutureTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/concurrent/tck/CompletableFutureTest.java
-ojluni/src/test/java/util/concurrent/tck/ForkJoinPool19Test.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/concurrent/tck/ForkJoinPool19Test.java
-ojluni/src/test/java/util/concurrent/tck/ForkJoinPool20Test.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/concurrent/tck/ForkJoinPool20Test.java
-ojluni/src/test/java/util/concurrent/tck/ForkJoinTaskTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/concurrent/tck/ForkJoinTaskTest.java
-ojluni/src/test/java/util/concurrent/tck/SplittableRandomTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/concurrent/tck/SplittableRandomTest.java
-ojluni/src/test/java/util/function/BiFunction/BiFunctionTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/function/BiFunction/BiFunctionTest.java
-ojluni/src/test/java/util/function/BinaryOperator/BasicTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/function/BinaryOperator/BasicTest.java
-ojluni/src/test/java/util/function/PredicateNotTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/function/PredicateNotTest.java
-ojluni/src/test/java/util/regex/BMPTestCases.txt,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/regex/BMPTestCases.txt
-ojluni/src/test/java/util/regex/GraphemeTestCases.txt,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/regex/GraphemeTestCases.txt
-ojluni/src/test/java/util/regex/POSIX_ASCII.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/regex/POSIX_ASCII.java
-ojluni/src/test/java/util/regex/POSIX_Unicode.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/regex/POSIX_Unicode.java
-ojluni/src/test/java/util/regex/PatternStreamTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/regex/PatternStreamTest.java
-ojluni/src/test/java/util/regex/RegExTest.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/regex/RegExTest.java
-ojluni/src/test/java/util/regex/SupplementaryTestCases.txt,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/regex/SupplementaryTestCases.txt
-ojluni/src/test/java/util/regex/TestCases.txt,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/regex/TestCases.txt
-ojluni/src/test/java/util/stream/TestDoubleSumAverage.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/TestDoubleSumAverage.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectAndSummaryStatisticsTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectAndSummaryStatisticsTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectionAndMapModifyStreamTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectionAndMapModifyStreamTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorExample.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorExample.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorToUnmodListTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorToUnmodListTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorsTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorsTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ConcatOpTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ConcatOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ConcatTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ConcatTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CountLargeTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CountLargeTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CountTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CountTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/DistinctOpTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/DistinctOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/DoublePrimitiveOpsTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/DoublePrimitiveOpsTests.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/FilterOpTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/FilterOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/FindAnyOpTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/FindAnyOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/FindFirstOpTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/FindFirstOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/FlatMapOpTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/FlatMapOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ForEachOpTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ForEachOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/GroupByOpTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/GroupByOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IntPrimitiveOpsTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/IntPrimitiveOpsTests.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IntReduceTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/IntReduceTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IntSliceOpTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/IntSliceOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IntUniqOpTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/IntUniqOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IterateTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/IterateTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/LongPrimitiveOpsTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/LongPrimitiveOpsTests.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/MapMultiOpTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/mapMultiOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/MapOpTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/MapOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/MatchOpTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/MatchOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/MinMaxTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/MinMaxTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/PrimitiveAverageOpTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/PrimitiveAverageOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/PrimitiveSumTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/PrimitiveSumTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/RangeTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/RangeTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ReduceByOpTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ReduceByOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ReduceTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ReduceTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/SegmentTestDataProvider.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SegmentTestDataProvider.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/SequentialOpTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SequentialOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/SliceOpTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SliceOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/SortedOpTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SortedOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/SpliteratorTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SpliteratorTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamBuilderTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamBuilderTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamCloseTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamCloseTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamLinkTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamLinkTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamParSeqTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamParSeqTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamSpliteratorTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamSpliteratorTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/TeeOpTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/TeeOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ToArrayOpTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ToArrayOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ToListOpTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ToListOpTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/WhileOpStatefulTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/WhileOpStatefulTest.java
-ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/WhileOpTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/WhileOpTest.java
-ojluni/src/test/java/util/stream/testlib/org/openjdk/testlib/java/util/SpliteratorOfIntDataBuilder.java,jdk21u/jdk-21.0.4-ga,test/jdk/lib/testlibrary/bootlib/java.base/java/util/SpliteratorOfIntDataBuilder.java
-ojluni/src/test/java/util/stream/testlib/org/openjdk/testlib/java/util/SpliteratorTestHelper.java,jdk21u/jdk-21.0.4-ga,test/jdk/lib/testlibrary/bootlib/java.base/java/util/SpliteratorTestHelper.java
-ojluni/src/test/java/util/stream/testlib/org/openjdk/testlib/java/util/stream/DefaultMethodStreams.java,jdk21u/jdk-21.0.4-ga,test/jdk/lib/testlibrary/bootlib/java.base/java/util/stream/DefaultMethodStreams.java
-ojluni/src/test/java/util/stream/testlib/org/openjdk/testlib/java/util/stream/ThrowableHelper.java,jdk21u/jdk-21.0.4-ga,test/jdk/lib/testlibrary/bootlib/java.base/java/util/stream/ThrowableHelper.java
-ojluni/src/test/java/util/zip/ChecksumBase.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/zip/ChecksumBase.java
-ojluni/src/test/java/util/zip/CloseInflaterDeflaterTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/zip/CloseInflaterDeflaterTest.java
-ojluni/src/test/java/util/zip/DeInflate.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/zip/DeInflate.java
+ojluni/src/test/java/util/HashSet/Serialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/HashSet/Serialization.java
+ojluni/src/test/java/util/HexFormat/HexFormatTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/HexFormat/HexFormatTest.java
+ojluni/src/test/java/util/IdentityHashMap/Basic.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/IdentityHashMap/Basic.java
+ojluni/src/test/java/util/IdentityHashMap/Capacity.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/IdentityHashMap/Capacity.java
+ojluni/src/test/java/util/IdentityHashMap/DistinctEntrySetElements.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/IdentityHashMap/DistinctEntrySetElements.java
+ojluni/src/test/java/util/IdentityHashMap/EntrySetIteratorRemoveInvalidatesEntry.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/IdentityHashMap/EntrySetIteratorRemoveInvalidatesEntry.java
+ojluni/src/test/java/util/IdentityHashMap/ToArray.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/IdentityHashMap/ToArray.java
+ojluni/src/test/java/util/IdentityHashMap/ToString.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/IdentityHashMap/ToString.java
+ojluni/src/test/java/util/LinkedHashMap/Basic.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/LinkedHashMap/Basic.java
+ojluni/src/test/java/util/LinkedHashMap/Cache.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/LinkedHashMap/Cache.java
+ojluni/src/test/java/util/LinkedHashMap/ComputeIfAbsentAccessOrder.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/LinkedHashMap/ComputeIfAbsentAccessOrder.java
+ojluni/src/test/java/util/LinkedHashMap/EmptyMapIterator.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/LinkedHashMap/EmptyMapIterator.java
+ojluni/src/test/java/util/LinkedHashSet/Basic.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/LinkedHashSet/Basic.java
+ojluni/src/test/java/util/Locale/AvailableLocalesTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Locale/AvailableLocalesTest.java
+ojluni/src/test/java/util/Locale/TestOf.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Locale/TestOf.java
+ojluni/src/test/java/util/Objects/BasicObjectsTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Objects/BasicObjectsTest.java
+ojluni/src/test/java/util/Optional/Basic.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Optional/Basic.java
+ojluni/src/test/java/util/Optional/BasicDouble.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Optional/BasicDouble.java
+ojluni/src/test/java/util/Optional/BasicInt.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Optional/BasicInt.java
+ojluni/src/test/java/util/Optional/BasicLong.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Optional/BasicLong.java
+ojluni/src/test/java/util/Optional/ObscureException.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Optional/ObscureException.java
+ojluni/src/test/java/util/PriorityQueue/AddNonComparable.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/PriorityQueue/AddNonComparable.java
+ojluni/src/test/java/util/PriorityQueue/ForgetMeNot.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/PriorityQueue/ForgetMeNot.java
+ojluni/src/test/java/util/PriorityQueue/NoNulls.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/PriorityQueue/NoNulls.java
+ojluni/src/test/java/util/PriorityQueue/PriorityQueueSort.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/PriorityQueue/PriorityQueueSort.java
+ojluni/src/test/java/util/PriorityQueue/RemoveContains.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/PriorityQueue/RemoveContains.java
+ojluni/src/test/java/util/Properties/BlankLines.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/BlankLines.java
+ojluni/src/test/java/util/Properties/Bug6609431.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/Bug6609431.java
+ojluni/src/test/java/util/Properties/Bug6609431.properties,jdk17u/jdk-17.0.14-ga,test/jdk/java/util/Properties/Bug6609431.properties
+ojluni/src/test/java/util/Properties/CheckOverrides.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/CheckOverrides.java
+ojluni/src/test/java/util/Properties/CheckUnsynchronized.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/CheckUnsynchronized.java
+ojluni/src/test/java/util/Properties/CloseXMLStream.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/CloseXMLStream.java
+ojluni/src/test/java/util/Properties/CompatibilityTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/CompatibilityTest.java
+ojluni/src/test/java/util/Properties/ConcurrentLoadAndStoreXML.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/util/Properties/ConcurrentLoadAndStoreXML.java
+ojluni/src/test/java/util/Properties/EncodingTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/EncodingTest.java
+ojluni/src/test/java/util/Properties/EscapeSpace.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/EscapeSpace.java
+ojluni/src/test/java/util/Properties/InitialCapacity.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/InitialCapacity.java
+ojluni/src/test/java/util/Properties/LoadAndStoreNPE.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/LoadAndStoreNPE.java
+ojluni/src/test/java/util/Properties/LoadAndStoreXML.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/util/Properties/LoadAndStoreXML.java
+ojluni/src/test/java/util/Properties/LoadAndStoreXMLWithDefaults.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/LoadAndStoreXMLWithDefaults.java
+ojluni/src/test/java/util/Properties/LoadParsing.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/LoadParsing.java
+ojluni/src/test/java/util/Properties/LoadParsing2.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/LoadParsing2.java
+ojluni/src/test/java/util/Properties/LoadSeparators.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/LoadSeparators.java
+ojluni/src/test/java/util/Properties/PropertiesEntrySetTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/PropertiesEntrySetTest.java
+ojluni/src/test/java/util/Properties/PropertiesSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/PropertiesSerialization.java
+ojluni/src/test/java/util/Properties/PropertiesTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/PropertiesTest.java
+ojluni/src/test/java/util/Properties/Save.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/Save.java
+ojluni/src/test/java/util/Properties/SaveClose.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/SaveClose.java
+ojluni/src/test/java/util/Properties/SaveComments.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/SaveComments.java
+ojluni/src/test/java/util/Properties/SaveEncoding.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/SaveEncoding.java
+ojluni/src/test/java/util/Properties/SaveLoadBasher.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/SaveLoadBasher.java
+ojluni/src/test/java/util/Properties/SaveSeparator.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/SaveSeparator.java
+ojluni/src/test/java/util/Properties/StoreDeadlock.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/StoreDeadlock.java
+ojluni/src/test/java/util/Properties/StringPropertyNames.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/StringPropertyNames.java
+ojluni/src/test/java/util/Properties/UnicodeEscape.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/UnicodeEscape.java
+ojluni/src/test/java/util/Properties/XMLSaveLoadBasher.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/XMLSaveLoadBasher.java
+ojluni/src/test/java/util/Properties/input.txt,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/input.txt
+ojluni/src/test/java/util/Properties/invalidxml/BadCase.xml,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/invalidxml/BadCase.xml
+ojluni/src/test/java/util/Properties/invalidxml/BadDocType.xml,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/invalidxml/BadDocType.xml
+ojluni/src/test/java/util/Properties/invalidxml/DTDRootNotMatch.xml,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/invalidxml/DTDRootNotMatch.xml
+ojluni/src/test/java/util/Properties/invalidxml/IllegalComment.xml,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/invalidxml/IllegalComment.xml
+ojluni/src/test/java/util/Properties/invalidxml/IllegalElement.xml,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/invalidxml/IllegalElement.xml
+ojluni/src/test/java/util/Properties/invalidxml/IllegalEntry.xml,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/invalidxml/IllegalEntry.xml
+ojluni/src/test/java/util/Properties/invalidxml/IllegalEntry1.xml,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/invalidxml/IllegalEntry1.xml
+ojluni/src/test/java/util/Properties/invalidxml/IllegalKeyAttribute.xml,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/invalidxml/IllegalKeyAttribute.xml
+ojluni/src/test/java/util/Properties/invalidxml/NoClosingTag.xml,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/invalidxml/NoClosingTag.xml
+ojluni/src/test/java/util/Properties/invalidxml/NoDocType.xml,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/invalidxml/NoDocType.xml
+ojluni/src/test/java/util/Properties/invalidxml/NoNamespaceSupport.xml,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/invalidxml/NoNamespaceSupport.xml
+ojluni/src/test/java/util/Properties/invalidxml/NoRoot.xml,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/invalidxml/NoRoot.xml
+ojluni/src/test/java/util/Properties/invalidxml/NotQuoted.xml,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/invalidxml/NotQuoted.xml
+ojluni/src/test/java/util/Properties/invalidxml/README.txt,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/invalidxml/README.txt
+ojluni/src/test/java/util/Properties/invalidxml/invalidDTD.xml,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/invalidxml/invalidDTD.xml
+ojluni/src/test/java/util/Properties/testData1,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/testData1
+ojluni/src/test/java/util/Properties/testData1.dos,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/testData1.dos
+ojluni/src/test/java/util/Properties/testData2,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/testData2
+ojluni/src/test/java/util/Properties/testData2.dos,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/testData2.dos
+ojluni/src/test/java/util/Properties/testData3.dos,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Properties/testData3.dos
+ojluni/src/test/java/util/Random/DistinctSeeds.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Random/DistinctSeeds.java
+ojluni/src/test/java/util/Random/NextBytes.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Random/NextBytes.java
+ojluni/src/test/java/util/Random/NextIntPowerOfTwoMod.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Random/NextIntPowerOfTwoMod.java
+ojluni/src/test/java/util/Random/RandomCanaryPi.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Random/RandomCanaryPi.java
+ojluni/src/test/java/util/Random/RandomExponentialTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Random/RandomExponentialTest.java
+ojluni/src/test/java/util/Random/RandomNextDoubleBoundary.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/util/Random/RandomNextDoubleBoundary.java
+ojluni/src/test/java/util/Random/RandomStreamTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Random/RandomStreamTest.java
+ojluni/src/test/java/util/Random/RandomTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Random/RandomTest.java
+ojluni/src/test/java/util/Random/RandomTestBsi1999.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/util/Random/RandomTestBsi1999.java
+ojluni/src/test/java/util/Random/RandomTestChiSquared.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Random/RandomTestChiSquared.java
+ojluni/src/test/java/util/Random/RandomTestCoverage.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Random/RandomTestCoverage.java
+ojluni/src/test/java/util/Random/RandomTestMoments.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Random/RandomTestMoments.java
+ojluni/src/test/java/util/Scanner/EncodingTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Scanner/EncodingTest.java
+ojluni/src/test/java/util/Scanner/FailingConstructors.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Scanner/FailingConstructors.java
+ojluni/src/test/java/util/Scanner/ScanTest.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/util/Scanner/ScanTest.java
+ojluni/src/test/java/util/Scanner/ScannerStreamTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Scanner/ScannerStreamTest.java
+ojluni/src/test/java/util/Scanner/input.txt,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Scanner/input.txt
+ojluni/src/test/java/util/SequencedCollection/Basic.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/SequencedCollection/Basic.java
+ojluni/src/test/java/util/SequencedCollection/BasicMap.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/SequencedCollection/BasicMap.java
+ojluni/src/test/java/util/SequencedCollection/SimpleDeque.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/SequencedCollection/SimpleDeque.java
+ojluni/src/test/java/util/SequencedCollection/SimpleList.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/SequencedCollection/SimpleList.java
+ojluni/src/test/java/util/SequencedCollection/SimpleSortedMap.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/SequencedCollection/SimpleSortedMap.java
+ojluni/src/test/java/util/SequencedCollection/SimpleSortedSet.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/SequencedCollection/SimpleSortedSet.java
+ojluni/src/test/java/util/ServiceLoader/basic/Basic.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/ServiceLoader/basic/Basic.java
+ojluni/src/test/java/util/ServiceLoader/basic/FooProvider1.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/ServiceLoader/basic/FooProvider1.java
+ojluni/src/test/java/util/ServiceLoader/basic/FooProvider2.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/ServiceLoader/basic/FooProvider2.java
+ojluni/src/test/java/util/ServiceLoader/basic/FooProvider3.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/ServiceLoader/basic/FooProvider3.java
+ojluni/src/test/java/util/ServiceLoader/basic/FooService.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/ServiceLoader/basic/FooService.java
+ojluni/src/test/java/util/StringJoiner/MergeTest.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/util/StringJoiner/MergeTest.java
+ojluni/src/test/java/util/StringJoiner/StringJoinerTest.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/util/StringJoiner/StringJoinerTest.java
+ojluni/src/test/java/util/Timer/Args.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Timer/Args.java
+ojluni/src/test/java/util/Timer/AutoStop.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Timer/AutoStop.java
+ojluni/src/test/java/util/Timer/DelayOverflow.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Timer/DelayOverflow.java
+ojluni/src/test/java/util/Timer/KillThread.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Timer/KillThread.java
+ojluni/src/test/java/util/Timer/NameConstructors.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Timer/NameConstructors.java
+ojluni/src/test/java/util/Timer/Purge.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Timer/Purge.java
+ojluni/src/test/java/util/UUID/Serial.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/UUID/Serial.java
+ojluni/src/test/java/util/UUID/UUIDTest.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/util/UUID/UUIDTest.java
+ojluni/src/test/java/util/Vector/ArrayManagement.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Vector/ArrayManagement.java
+ojluni/src/test/java/util/Vector/ComodifiedRemoveAllElements.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Vector/ComodifiedRemoveAllElements.java
+ojluni/src/test/java/util/Vector/CopyInto.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Vector/CopyInto.java
+ojluni/src/test/java/util/Vector/IllegalConstructorArgs.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Vector/IllegalConstructorArgs.java
+ojluni/src/test/java/util/Vector/LastIndexOf.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Vector/LastIndexOf.java
+ojluni/src/test/java/util/Vector/SerializationDeadlock.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Vector/SerializationDeadlock.java
+ojluni/src/test/java/util/Vector/SimpleSerialization.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Vector/SimpleSerialization.java
+ojluni/src/test/java/util/Vector/SyncLastIndexOf.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/Vector/SyncLastIndexOf.java
+ojluni/src/test/java/util/WeakHashMap/GCDuringIteration.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/WeakHashMap/GCDuringIteration.java
+ojluni/src/test/java/util/WeakHashMap/Iteration.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/WeakHashMap/Iteration.java
+ojluni/src/test/java/util/WeakHashMap/ZeroInitCap.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/WeakHashMap/ZeroInitCap.java
+ojluni/src/test/java/util/concurrent/tck/CompletableFutureTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/concurrent/tck/CompletableFutureTest.java
+ojluni/src/test/java/util/concurrent/tck/ForkJoinPool19Test.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/concurrent/tck/ForkJoinPool19Test.java
+ojluni/src/test/java/util/concurrent/tck/ForkJoinPool20Test.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/concurrent/tck/ForkJoinPool20Test.java
+ojluni/src/test/java/util/concurrent/tck/ForkJoinTaskTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/concurrent/tck/ForkJoinTaskTest.java
+ojluni/src/test/java/util/concurrent/tck/SplittableRandomTest.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/util/concurrent/tck/SplittableRandomTest.java
+ojluni/src/test/java/util/function/BiFunction/BiFunctionTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/function/BiFunction/BiFunctionTest.java
+ojluni/src/test/java/util/function/BinaryOperator/BasicTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/function/BinaryOperator/BasicTest.java
+ojluni/src/test/java/util/function/PredicateNotTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/function/PredicateNotTest.java
+ojluni/src/test/java/util/regex/BMPTestCases.txt,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/regex/BMPTestCases.txt
+ojluni/src/test/java/util/regex/GraphemeTestCases.txt,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/regex/GraphemeTestCases.txt
+ojluni/src/test/java/util/regex/POSIX_ASCII.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/regex/POSIX_ASCII.java
+ojluni/src/test/java/util/regex/POSIX_Unicode.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/regex/POSIX_Unicode.java
+ojluni/src/test/java/util/regex/PatternStreamTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/regex/PatternStreamTest.java
+ojluni/src/test/java/util/regex/RegExTest.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/util/regex/RegExTest.java
+ojluni/src/test/java/util/regex/SupplementaryTestCases.txt,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/regex/SupplementaryTestCases.txt
+ojluni/src/test/java/util/regex/TestCases.txt,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/regex/TestCases.txt
+ojluni/src/test/java/util/stream/TestDoubleSumAverage.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/TestDoubleSumAverage.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectAndSummaryStatisticsTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectAndSummaryStatisticsTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectionAndMapModifyStreamTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectionAndMapModifyStreamTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorExample.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorExample.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorToUnmodListTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorToUnmodListTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorsTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorsTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ConcatOpTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ConcatOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ConcatTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ConcatTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CountLargeTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CountLargeTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/CountTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CountTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/DistinctOpTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/DistinctOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/DoublePrimitiveOpsTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/DoublePrimitiveOpsTests.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/FilterOpTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/FilterOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/FindAnyOpTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/FindAnyOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/FindFirstOpTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/FindFirstOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/FlatMapOpTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/FlatMapOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ForEachOpTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ForEachOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/GroupByOpTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/GroupByOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IntPrimitiveOpsTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/IntPrimitiveOpsTests.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IntReduceTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/IntReduceTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IntSliceOpTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/IntSliceOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IntUniqOpTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/IntUniqOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/IterateTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/IterateTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/LongPrimitiveOpsTests.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/LongPrimitiveOpsTests.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/MapMultiOpTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/mapMultiOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/MapOpTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/MapOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/MatchOpTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/MatchOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/MinMaxTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/MinMaxTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/PrimitiveAverageOpTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/PrimitiveAverageOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/PrimitiveSumTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/PrimitiveSumTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/RangeTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/RangeTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ReduceByOpTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ReduceByOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ReduceTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ReduceTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/SegmentTestDataProvider.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SegmentTestDataProvider.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/SequentialOpTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SequentialOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/SliceOpTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SliceOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/SortedOpTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SortedOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/SpliteratorTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SpliteratorTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamBuilderTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamBuilderTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamCloseTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamCloseTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamLinkTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamLinkTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamParSeqTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamParSeqTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamSpliteratorTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/StreamSpliteratorTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/TeeOpTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/TeeOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ToArrayOpTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ToArrayOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/ToListOpTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/ToListOpTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/WhileOpStatefulTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/WhileOpStatefulTest.java
+ojluni/src/test/java/util/stream/test/org/openjdk/tests/java/util/stream/WhileOpTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/WhileOpTest.java
+ojluni/src/test/java/util/stream/testlib/org/openjdk/testlib/java/util/SpliteratorOfIntDataBuilder.java,jdk21u/jdk-21.0.6-ga,test/jdk/lib/testlibrary/bootlib/java.base/java/util/SpliteratorOfIntDataBuilder.java
+ojluni/src/test/java/util/stream/testlib/org/openjdk/testlib/java/util/SpliteratorTestHelper.java,jdk21u/jdk-21.0.6-ga,test/jdk/lib/testlibrary/bootlib/java.base/java/util/SpliteratorTestHelper.java
+ojluni/src/test/java/util/stream/testlib/org/openjdk/testlib/java/util/stream/DefaultMethodStreams.java,jdk21u/jdk-21.0.6-ga,test/jdk/lib/testlibrary/bootlib/java.base/java/util/stream/DefaultMethodStreams.java
+ojluni/src/test/java/util/stream/testlib/org/openjdk/testlib/java/util/stream/ThrowableHelper.java,jdk21u/jdk-21.0.6-ga,test/jdk/lib/testlibrary/bootlib/java.base/java/util/stream/ThrowableHelper.java
+ojluni/src/test/java/util/zip/ChecksumBase.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/zip/ChecksumBase.java
+ojluni/src/test/java/util/zip/CloseInflaterDeflaterTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/zip/CloseInflaterDeflaterTest.java
+ojluni/src/test/java/util/zip/DeInflate.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/zip/DeInflate.java
 ojluni/src/test/java/util/zip/DeflaterDictionaryTests.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/zip/DeflaterDictionaryTests.java
-ojluni/src/test/java/util/zip/TestCRC32.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/zip/TestCRC32.java
-ojluni/src/test/java/util/zip/TestCRC32C.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/zip/TestCRC32C.java
-ojluni/src/test/java/util/zip/TestChecksum.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/zip/TestChecksum.java
-ojluni/src/test/java/util/zip/TestExtraTime.java,jdk17u/jdk-17.0.6-ga,test/jdk/java/util/zip/TestExtraTime.java
-ojluni/src/test/java/util/zip/TestLocalTime.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/zip/TestLocalTime.java
-ojluni/src/test/java/util/zip/ZipFile/TestCleaner.java,jdk21u/jdk-21.0.4-ga,test/jdk/java/util/zip/ZipFile/TestCleaner.java
-ojluni/src/test/java/util/zip/ZipFile/Zip64SizeTest.java,jdk11u/jdk-11.0.13-ga,test/jdk/java/util/zip/ZipFile/Zip64SizeTest.java
-ojluni/src/test/jdk/internal/math/FloatingDecimal/TestFDBigInteger.java,jdk21u/jdk-21.0.4-ga,test/jdk/jdk/internal/math/FloatingDecimal/TestFDBigInteger.java
-ojluni/src/test/jdk/internal/math/FloatingDecimal/TestFloatingDecimal.java,jdk21u/jdk-21.0.4-ga,test/jdk/jdk/internal/math/FloatingDecimal/TestFloatingDecimal.java
-ojluni/src/test/jdk/internal/math/ToDecimal/FloatToDecimalTest.java,jdk21u/jdk-21.0.4-ga,test/jdk/jdk/internal/math/ToDecimal/FloatToDecimalTest.java
-ojluni/src/test/jdk/internal/math/ToString.java,jdk21u/jdk-21.0.4-ga,test/jdk/jdk/internal/math/ToString.java
-ojluni/src/test/resources/data/unicodedata/Blocks.txt,jdk21u/jdk-21.0.4-ga,src/java.base/share/data/unicodedata/Blocks.txt
-ojluni/src/test/resources/data/unicodedata/DerivedCoreProperties.txt,jdk21u/jdk-21.0.4-ga,src/java.base/share/data/unicodedata/DerivedCoreProperties.txt
-ojluni/src/test/resources/data/unicodedata/NormalizationTest.txt,jdk21u/jdk-21.0.4-ga,src/java.base/share/data/unicodedata/NormalizationTest.txt
-ojluni/src/test/resources/data/unicodedata/PropList.txt,jdk21u/jdk-21.0.4-ga,src/java.base/share/data/unicodedata/PropList.txt
-ojluni/src/test/resources/data/unicodedata/PropertyValueAliases.txt,jdk21u/jdk-21.0.4-ga,src/java.base/share/data/unicodedata/PropertyValueAliases.txt
-ojluni/src/test/resources/data/unicodedata/ReadMe.txt,jdk21u/jdk-21.0.4-ga,src/java.base/share/data/unicodedata/ReadMe.txt
-ojluni/src/test/resources/data/unicodedata/Scripts.txt,jdk21u/jdk-21.0.4-ga,src/java.base/share/data/unicodedata/Scripts.txt
-ojluni/src/test/resources/data/unicodedata/SpecialCasing.txt,jdk21u/jdk-21.0.4-ga,src/java.base/share/data/unicodedata/SpecialCasing.txt
-ojluni/src/test/resources/data/unicodedata/UnicodeData.txt,jdk21u/jdk-21.0.4-ga,src/java.base/share/data/unicodedata/UnicodeData.txt
-ojluni/src/test/resources/data/unicodedata/auxiliary/GraphemeBreakProperty.txt,jdk21u/jdk-21.0.4-ga,src/java.base/share/data/unicodedata/auxiliary/GraphemeBreakProperty.txt
-ojluni/src/test/resources/data/unicodedata/auxiliary/GraphemeBreakTest.txt,jdk21u/jdk-21.0.4-ga,src/java.base/share/data/unicodedata/auxiliary/GraphemeBreakTest.txt
-ojluni/src/test/resources/data/unicodedata/emoji/emoji-data.txt,jdk21u/jdk-21.0.4-ga,src/java.base/share/data/unicodedata/emoji/emoji-data.txt
-ojluni/src/tools/make/gensrc/GensrcBuffer.gmk,jdk17u/jdk-17.0.6-ga,make/modules/java.base/gensrc/GensrcBuffer.gmk
-ojluni/src/tools/make/gensrc/GensrcCharsetCoder.gmk,jdk17u/jdk-17.0.6-ga,make/modules/java.base/gensrc/GensrcCharsetCoder.gmk
-ojluni/src/tools/scripts/addNotices.sh,jdk21u/jdk-21.0.4-ga,make/scripts/addNotices.sh
-ojluni/src/tools/scripts/genExceptions.sh,jdk21u/jdk-21.0.4-ga,make/scripts/genExceptions.sh
+ojluni/src/test/java/util/zip/TestCRC32.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/zip/TestCRC32.java
+ojluni/src/test/java/util/zip/TestCRC32C.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/zip/TestCRC32C.java
+ojluni/src/test/java/util/zip/TestChecksum.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/zip/TestChecksum.java
+ojluni/src/test/java/util/zip/TestExtraTime.java,jdk17u/jdk-17.0.14-ga,test/jdk/java/util/zip/TestExtraTime.java
+ojluni/src/test/java/util/zip/TestLocalTime.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/zip/TestLocalTime.java
+ojluni/src/test/java/util/zip/ZipFile/TestCleaner.java,jdk21u/jdk-21.0.6-ga,test/jdk/java/util/zip/ZipFile/TestCleaner.java
+ojluni/src/test/java/util/zip/ZipFile/Zip64SizeTest.java,jdk11u/jdk-11.0.26-ga,test/jdk/java/util/zip/ZipFile/Zip64SizeTest.java
+ojluni/src/test/jdk/internal/math/FloatingDecimal/TestFDBigInteger.java,jdk21u/jdk-21.0.6-ga,test/jdk/jdk/internal/math/FloatingDecimal/TestFDBigInteger.java
+ojluni/src/test/jdk/internal/math/FloatingDecimal/TestFloatingDecimal.java,jdk21u/jdk-21.0.6-ga,test/jdk/jdk/internal/math/FloatingDecimal/TestFloatingDecimal.java
+ojluni/src/test/jdk/internal/math/ToDecimal/FloatToDecimalTest.java,jdk21u/jdk-21.0.6-ga,test/jdk/jdk/internal/math/ToDecimal/FloatToDecimalTest.java
+ojluni/src/test/jdk/internal/math/ToString.java,jdk21u/jdk-21.0.6-ga,test/jdk/jdk/internal/math/ToString.java
+ojluni/src/test/resources/data/unicodedata/Blocks.txt,jdk21u/jdk-21.0.6-ga,src/java.base/share/data/unicodedata/Blocks.txt
+ojluni/src/test/resources/data/unicodedata/DerivedCoreProperties.txt,jdk21u/jdk-21.0.6-ga,src/java.base/share/data/unicodedata/DerivedCoreProperties.txt
+ojluni/src/test/resources/data/unicodedata/NormalizationTest.txt,jdk21u/jdk-21.0.6-ga,src/java.base/share/data/unicodedata/NormalizationTest.txt
+ojluni/src/test/resources/data/unicodedata/PropList.txt,jdk21u/jdk-21.0.6-ga,src/java.base/share/data/unicodedata/PropList.txt
+ojluni/src/test/resources/data/unicodedata/PropertyValueAliases.txt,jdk21u/jdk-21.0.6-ga,src/java.base/share/data/unicodedata/PropertyValueAliases.txt
+ojluni/src/test/resources/data/unicodedata/ReadMe.txt,jdk21u/jdk-21.0.6-ga,src/java.base/share/data/unicodedata/ReadMe.txt
+ojluni/src/test/resources/data/unicodedata/Scripts.txt,jdk21u/jdk-21.0.6-ga,src/java.base/share/data/unicodedata/Scripts.txt
+ojluni/src/test/resources/data/unicodedata/SpecialCasing.txt,jdk21u/jdk-21.0.6-ga,src/java.base/share/data/unicodedata/SpecialCasing.txt
+ojluni/src/test/resources/data/unicodedata/UnicodeData.txt,jdk21u/jdk-21.0.6-ga,src/java.base/share/data/unicodedata/UnicodeData.txt
+ojluni/src/test/resources/data/unicodedata/auxiliary/GraphemeBreakProperty.txt,jdk21u/jdk-21.0.6-ga,src/java.base/share/data/unicodedata/auxiliary/GraphemeBreakProperty.txt
+ojluni/src/test/resources/data/unicodedata/auxiliary/GraphemeBreakTest.txt,jdk21u/jdk-21.0.6-ga,src/java.base/share/data/unicodedata/auxiliary/GraphemeBreakTest.txt
+ojluni/src/test/resources/data/unicodedata/emoji/emoji-data.txt,jdk21u/jdk-21.0.6-ga,src/java.base/share/data/unicodedata/emoji/emoji-data.txt
+ojluni/src/tools/make/gensrc/GensrcBuffer.gmk,jdk17u/jdk-17.0.14-ga,make/modules/java.base/gensrc/GensrcBuffer.gmk
+ojluni/src/tools/make/gensrc/GensrcCharsetCoder.gmk,jdk17u/jdk-17.0.14-ga,make/modules/java.base/gensrc/GensrcCharsetCoder.gmk
+ojluni/src/tools/scripts/addNotices.sh,jdk21u/jdk-21.0.6-ga,make/scripts/addNotices.sh
+ojluni/src/tools/scripts/genExceptions.sh,jdk21u/jdk-21.0.6-ga,make/scripts/genExceptions.sh
diff --git a/JavaLibrary.bp b/JavaLibrary.bp
index a7e23325c53..6a6a77dadf3 100644
--- a/JavaLibrary.bp
+++ b/JavaLibrary.bp
@@ -107,11 +107,32 @@ rewrite_openjdk_doc_links = "sed -E 's" +
 gensrcs {
     name: "core_oj_api_files",
     cmd: rewrite_openjdk_doc_links,
-    srcs: [":openjdk_javadoc_files"],
+    srcs: [
+        ":openjdk_javadoc_files",
+        ":openjdk_api_only_files",
+    ],
+    exclude_srcs: [
+        // OpenJDK 11 changed some methods in Path from abstract to default, and affects app compat.
+        // b/236956396 explains how an Android app could be broken on older Android versions.
+        // We can't simply remove the default modifier because other OpenJDK codes depend on it.
+        // The temp workaround here is to publish the abstract methods in the SDK, but keep default
+        // method implementation in the libcore.
+        // See "openjdk_api_only_files" for the published API surface.
+        "ojluni/src/main/java/java/nio/file/Path.java",
+    ],
     output_extension: "java",
 }
 
-// The source files that go into core-libart.l
+filegroup {
+    name: "openjdk_api_only_files",
+    licenses: ["libcore_ojluni_src_main_license"],
+    srcs: [
+        "ojluni/src/main/api_only/java/nio/file/Path.java",
+    ],
+    path: "ojluni/src/main/api_only/",
+}
+
+// The source files that go into core-libart.
 filegroup {
     name: "core_libart_java_files",
     visibility: [
@@ -622,6 +643,7 @@ java_library_static {
     visibility: [
         "//art/build/sdk",
         "//cts/apps/CtsVerifier",
+        "//cts/tests/libcore/net",
         "//cts/tests/tests/keystore",
         "//cts/tests/tests/net",
         "//cts/hostsidetests/statsdatom/apps/statsdapp",
@@ -692,6 +714,7 @@ java_test {
             "-Xep:ModifyingCollectionWithItself:WARN",
             "-Xep:ReturnValueIgnored:WARN",
             "-Xep:HashtableContains:WARN",
+            "-Xep:BoxedPrimitiveEquality:WARN",
         ],
     },
 }
@@ -1146,6 +1169,21 @@ java_aconfig_library {
     ],
 }
 
+cc_aconfig_library {
+    name: "libcore-aconfig-flags-native-lib",
+    aconfig_declarations: "libcore-aconfig-flags",
+    host_supported: true,
+    min_sdk_version: "31",
+    apex_available: [
+        "//apex_available:platform",
+        "//apex_available:anyapex",
+    ],
+    visibility: [
+        "//art:__subpackages__",
+        "//libcore:__subpackages__",
+    ],
+}
+
 // Define the public SDK API provided by the ART module.
 java_sdk_library {
     name: "art.module.public.api",
diff --git a/NativeCode.bp b/NativeCode.bp
index 08e98a4fe25..9046a2bebc8 100644
--- a/NativeCode.bp
+++ b/NativeCode.bp
@@ -208,6 +208,8 @@ cc_library_shared {
     host_supported: true,
 
     srcs: [
+        "luni/src/test/native/libcore_android_system_OsConstantsTest.cpp",
+        "luni/src/test/native/libcore_android_system_OsTest.cpp",
         "luni/src/test/native/libcore_dalvik_system_JniTest.cpp",
         "luni/src/test/native/libcore_java_io_FileTest.cpp",
         "luni/src/test/native/libcore_java_lang_OldStackTraceElementTest.cpp",
@@ -251,6 +253,9 @@ cc_test {
     ],
 
     static_libs: ["libnativehelper_compat_libc++"],
+    visibility: [
+        "//platform_testing:__subpackages__",
+    ],
 }
 
 // Set of benchmarks for libjavacore functions.
@@ -274,4 +279,7 @@ cc_benchmark {
         "liblog",
         "libnativehelper",
     ],
+    visibility: [
+        "//platform_testing:__subpackages__",
+    ],
 }
diff --git a/api/current.txt b/api/current.txt
index 3d62805a232..8aabc432873 100644
--- a/api/current.txt
+++ b/api/current.txt
@@ -111,6 +111,7 @@ package android.system {
     method public static void close(java.io.FileDescriptor) throws android.system.ErrnoException;
     method public static void connect(java.io.FileDescriptor, java.net.InetAddress, int) throws android.system.ErrnoException, java.net.SocketException;
     method public static void connect(@NonNull java.io.FileDescriptor, @NonNull java.net.SocketAddress) throws android.system.ErrnoException, java.net.SocketException;
+    method @FlaggedApi("com.android.libcore.openjdk_21_v2_apis") public static android.system.StructDlInfo dladdr(long);
     method public static java.io.FileDescriptor dup(java.io.FileDescriptor) throws android.system.ErrnoException;
     method public static java.io.FileDescriptor dup2(java.io.FileDescriptor, int) throws android.system.ErrnoException;
     method public static String[] environ();
@@ -770,6 +771,14 @@ package android.system {
     field public final int cmsg_type;
   }
 
+  @FlaggedApi("com.android.libcore.openjdk_21_v2_apis") public final class StructDlInfo {
+    ctor public StructDlInfo(String, long, String, long);
+    field public final long dli_fbase;
+    field public final String dli_fname;
+    field public final long dli_saddr;
+    field public final String dli_sname;
+  }
+
   public final class StructMsghdr {
     ctor public StructMsghdr(@Nullable java.net.SocketAddress, @NonNull java.nio.ByteBuffer[], @Nullable android.system.StructCmsghdr[], int);
     field @Nullable public android.system.StructCmsghdr[] msg_control;
@@ -4570,8 +4579,8 @@ package java.lang {
     method public int activeCount();
     method public int activeGroupCount();
     method @Deprecated public boolean allowThreadSuspension(boolean);
-    method public final void checkAccess();
-    method public final void destroy();
+    method @Deprecated @FlaggedApi("com.android.libcore.openjdk_25_v1_apis") public final void checkAccess();
+    method @Deprecated @FlaggedApi("com.android.libcore.openjdk_25_v1_apis") public final void destroy();
     method public int enumerate(Thread[]);
     method public int enumerate(Thread[], boolean);
     method public int enumerate(ThreadGroup[]);
@@ -4580,12 +4589,12 @@ package java.lang {
     method public final String getName();
     method public final ThreadGroup getParent();
     method public final void interrupt();
-    method public final boolean isDaemon();
-    method public boolean isDestroyed();
+    method @Deprecated @FlaggedApi("com.android.libcore.openjdk_25_v1_apis") public final boolean isDaemon();
+    method @Deprecated @FlaggedApi("com.android.libcore.openjdk_25_v1_apis") public boolean isDestroyed();
     method public void list();
     method public final boolean parentOf(ThreadGroup);
     method @Deprecated public final void resume();
-    method public final void setDaemon(boolean);
+    method @Deprecated @FlaggedApi("com.android.libcore.openjdk_25_v1_apis") public final void setDaemon(boolean);
     method public final void setMaxPriority(int);
     method @Deprecated public final void stop();
     method @Deprecated public final void suspend();
@@ -7480,6 +7489,9 @@ package java.nio.file {
     method public static java.nio.file.FileSystem newFileSystem(java.net.URI, java.util.Map<java.lang.String,?>) throws java.io.IOException;
     method public static java.nio.file.FileSystem newFileSystem(java.net.URI, java.util.Map<java.lang.String,?>, ClassLoader) throws java.io.IOException;
     method public static java.nio.file.FileSystem newFileSystem(java.nio.file.Path, ClassLoader) throws java.io.IOException;
+    method @FlaggedApi("com.android.libcore.openjdk_21_v2_apis") public static java.nio.file.FileSystem newFileSystem(java.nio.file.Path, java.util.Map<java.lang.String,?>) throws java.io.IOException;
+    method @FlaggedApi("com.android.libcore.openjdk_21_v2_apis") public static java.nio.file.FileSystem newFileSystem(java.nio.file.Path) throws java.io.IOException;
+    method @FlaggedApi("com.android.libcore.openjdk_21_v2_apis") public static java.nio.file.FileSystem newFileSystem(java.nio.file.Path, java.util.Map<java.lang.String,?>, ClassLoader) throws java.io.IOException;
   }
 
   public enum FileVisitOption {
@@ -7553,6 +7565,8 @@ package java.nio.file {
     method public static java.util.List<java.lang.String> readAllLines(java.nio.file.Path) throws java.io.IOException;
     method public static <A extends java.nio.file.attribute.BasicFileAttributes> A readAttributes(java.nio.file.Path, Class<A>, java.nio.file.LinkOption...) throws java.io.IOException;
     method public static java.util.Map<java.lang.String,java.lang.Object> readAttributes(java.nio.file.Path, String, java.nio.file.LinkOption...) throws java.io.IOException;
+    method @FlaggedApi("com.android.libcore.openjdk_21_v2_apis") public static String readString(java.nio.file.Path) throws java.io.IOException;
+    method @FlaggedApi("com.android.libcore.openjdk_21_v2_apis") public static String readString(java.nio.file.Path, java.nio.charset.Charset) throws java.io.IOException;
     method public static java.nio.file.Path readSymbolicLink(java.nio.file.Path) throws java.io.IOException;
     method public static java.nio.file.Path setAttribute(java.nio.file.Path, String, Object, java.nio.file.LinkOption...) throws java.io.IOException;
     method public static java.nio.file.Path setLastModifiedTime(java.nio.file.Path, java.nio.file.attribute.FileTime) throws java.io.IOException;
@@ -7566,6 +7580,8 @@ package java.nio.file {
     method public static java.nio.file.Path write(java.nio.file.Path, byte[], java.nio.file.OpenOption...) throws java.io.IOException;
     method public static java.nio.file.Path write(java.nio.file.Path, Iterable<? extends java.lang.CharSequence>, java.nio.charset.Charset, java.nio.file.OpenOption...) throws java.io.IOException;
     method public static java.nio.file.Path write(java.nio.file.Path, Iterable<? extends java.lang.CharSequence>, java.nio.file.OpenOption...) throws java.io.IOException;
+    method @FlaggedApi("com.android.libcore.openjdk_21_v2_apis") public static java.nio.file.Path writeString(java.nio.file.Path, CharSequence, java.nio.file.OpenOption...) throws java.io.IOException;
+    method @FlaggedApi("com.android.libcore.openjdk_21_v2_apis") public static java.nio.file.Path writeString(java.nio.file.Path, CharSequence, java.nio.charset.Charset, java.nio.file.OpenOption...) throws java.io.IOException;
   }
 
   public class InvalidPathException extends java.lang.IllegalArgumentException {
diff --git a/api/module-lib-current.txt b/api/module-lib-current.txt
index 064d35bc17f..9360183d6a3 100644
--- a/api/module-lib-current.txt
+++ b/api/module-lib-current.txt
@@ -275,7 +275,7 @@ package dalvik.system {
     method @FlaggedApi("com.android.art.flags.always_enable_profile_code") public static void dumpLowOverheadTrace(@NonNull dalvik.system.VMDebug.TraceDestination);
     method public static void dumpReferenceTables();
     method public static int getAllocCount(int);
-    method @FlaggedApi("com.android.art.flags.executable_method_file_offsets") @Nullable public static dalvik.system.VMDebug.ExecutableMethodFileOffsets getExecutableMethodFileOffsets(@NonNull java.lang.reflect.Method);
+    method @Deprecated @FlaggedApi("com.android.art.flags.executable_method_file_offsets_deprecation") @Nullable public static dalvik.system.VMDebug.ExecutableMethodFileOffsets getExecutableMethodFileOffsets(@NonNull java.lang.reflect.Method);
     method @FlaggedApi("com.android.art.flags.executable_method_file_offsets_v2") @Nullable public static dalvik.system.VMDebug.ExecutableMethodFileOffsets getExecutableMethodFileOffsets(@NonNull java.lang.reflect.Executable);
     method public static int getLoadedClassCount();
     method public static int getMethodTracingMode();
@@ -338,6 +338,7 @@ package dalvik.system {
     method public static String getInstructionSet(String);
     method public static dalvik.system.VMRuntime getRuntime();
     method public int getTargetSdkVersion();
+    method @FlaggedApi("com.android.libcore.niceness_apis") public int getThreadNiceness(Thread);
     method public boolean is64Bit();
     method public static boolean is64BitAbi(String);
     method public static boolean is64BitInstructionSet(String);
@@ -366,6 +367,7 @@ package dalvik.system {
     method public static void setProcessDataDirectory(String);
     method public static void setProcessPackageName(String);
     method public void setTargetSdkVersion(int);
+    method @FlaggedApi("com.android.libcore.niceness_apis") public boolean setThreadNiceness(Thread, int);
     method public void updateProcessState(int);
     method public String vmInstructionSet();
     method public String vmLibrary();
diff --git a/dalvik/src/main/java/dalvik/annotation/compat/VersionCodes.java b/dalvik/src/main/java/dalvik/annotation/compat/VersionCodes.java
index 47fc838c275..a781f581f3d 100644
--- a/dalvik/src/main/java/dalvik/annotation/compat/VersionCodes.java
+++ b/dalvik/src/main/java/dalvik/annotation/compat/VersionCodes.java
@@ -101,4 +101,11 @@ public class VersionCodes {
      */
     @IntraCoreApi
     public static final int BAKLAVA = 36;
+
+    /**
+     * C.
+     * C comes after B. Not yet announced Android release.
+     * @hide
+     */
+    public static final int C = CUR_DEVELOPMENT;
 }
diff --git a/dalvik/src/main/java/dalvik/system/VMDebug.java b/dalvik/src/main/java/dalvik/system/VMDebug.java
index 04bb8cb3d8d..10056e71bc6 100644
--- a/dalvik/src/main/java/dalvik/system/VMDebug.java
+++ b/dalvik/src/main/java/dalvik/system/VMDebug.java
@@ -469,6 +469,7 @@ public final class VMDebug {
      * @hide
      */
     @SystemApi(client = MODULE_LIBRARIES)
+    @Deprecated
     public static @Nullable ExecutableMethodFileOffsets getExecutableMethodFileOffsets(
             @NonNull Method javaMethod) {
         return getExecutableMethodFileOffsetsNative(javaMethod);
diff --git a/expectations/skippedCtsTest.txt b/expectations/skippedCtsTest.txt
index e44771a914f..2b9171bbefd 100644
--- a/expectations/skippedCtsTest.txt
+++ b/expectations/skippedCtsTest.txt
@@ -36,6 +36,15 @@
       "org.apache.harmony.tests.javax.security.OldSHA1PRNGSecureRandomTest#testGenerateSeedint01"
     ]
   },
+  {
+    "bug": 270694545,
+    "description": "The test asserts buggy or non-breaking behaviors, but the behavior has been fixed in a new mainline module version.",
+    "names": [
+      "libcore.java.nio.file.DefaultFileSystemProvider2Test#test_getPath",
+      "libcore.java.nio.file.LinuxPathTest#test_get_URI",
+      "libcore.java.nio.file.PathsTest#test_get_URI"
+    ]
+  },
   {
     "bug": 286802267,
     "description": "Test for internal APIs.",
@@ -169,5 +178,12 @@
       "libcore.java.util.TimeZoneTest#testCustomZoneIds",
       "libcore.libcore.io.BlockGuardOsTest#test_checkNewMethodsInPosix"
     ]
+  },
+  {
+    "bug": 415048615,
+    "description": "The test asserts buggy or non-breaking behaviors, but the behavior has been fixed in a new mainline module version.",
+    "names": [
+      "test.java.util.Timer.Args#main"
+    ]
   }
 ]
\ No newline at end of file
diff --git a/libart/src/main/java/dalvik/system/VMRuntime.java b/libart/src/main/java/dalvik/system/VMRuntime.java
index 88cf8a3d30e..03f21f44ac8 100644
--- a/libart/src/main/java/dalvik/system/VMRuntime.java
+++ b/libart/src/main/java/dalvik/system/VMRuntime.java
@@ -28,6 +28,7 @@ import android.compat.annotation.UnsupportedAppUsage;
 import com.android.libcore.Flags;
 
 import dalvik.annotation.compat.VersionCodes;
+import dalvik.annotation.optimization.CriticalNative;
 import dalvik.annotation.optimization.FastNative;
 
 import java.lang.ref.FinalizerReference;
@@ -800,6 +801,43 @@ public final class VMRuntime {
         }
     }
 
+    /**
+     * Returns t's Posix niceness, as cached by {@code Thread}. Only reflects values
+     * set via java's Thread API, or via {@code setThreadNiceness()} below. Does not reflect
+     * values set directly using Posix calls in JNI code or by another process.
+     *
+     * @param t the threaad being queried
+     * @return Linux niceness value for t
+     *
+     * @hide
+     */
+    @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_NICENESS_APIS)
+    @SystemApi(client = MODULE_LIBRARIES)
+    public int getThreadNiceness(Thread t) {
+      return t.getPosixNicenessInternal();
+    }
+
+    /**
+     * Sets t's Posix niceness, updating {@code Thread}'s cache. Subsequently t's
+     * Java thread priority will appear to be the nearest corresponding Java thread priority.
+     *
+     * @param t the thread whose niceness is to be set
+     * @param newNiceness new Linux niceness value, in the range of -20 to 19
+     * @return true on success. Attempts to set niceness on unstarted threads succeed
+     *         even if the deferred system call later fails.         .
+     *
+     * @hide
+     */
+    @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_NICENESS_APIS)
+    @SystemApi(client = MODULE_LIBRARIES)
+    public boolean setThreadNiceness(Thread t, int newNiceness) {
+      if (newNiceness < -20 || newNiceness > 19) {
+        return false;
+      }
+      return t.setPosixNicenessInternal(newNiceness) == 0;
+    }
+
+
     /**
      * Request that a garbage collection gets started on a different thread.
      *
@@ -1025,7 +1063,8 @@ public final class VMRuntime {
      *
      * @hide
      */
-    public static native void setSystemDaemonThreadPriority();
+    @CriticalNative
+    public static native int getSystemDaemonNiceness();
 
     /**
      * Sets a callback that the runtime can call whenever a usage of a non SDK API is detected.
@@ -1145,6 +1184,10 @@ public final class VMRuntime {
     public static boolean isArtTestFlagEnabled() {
         return com.android.art.flags.Flags.test();
     }
+    /**
+     * @hide for internal testing.
+     */
+    public static native boolean isArtTestRwFlagEnabled();
 
     /**
      * Returns the full GC count - how many times did full GC happen
diff --git a/libart/src/main/java/dalvik/system/VirtualThreadContext.java b/libart/src/main/java/dalvik/system/VirtualThreadContext.java
new file mode 100644
index 00000000000..a79dcab2c9a
--- /dev/null
+++ b/libart/src/main/java/dalvik/system/VirtualThreadContext.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dalvik.system;
+
+import java.util.Objects;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+
+import jdk.internal.misc.Unsafe;
+
+/**
+ * {@link Thread} holds this object to indicate that the thread is running a virtual
+ * thread.
+ *
+ * @hide
+ */
+public final class VirtualThreadContext implements Runnable {
+
+    private final static Unsafe UNSAFE = Unsafe.getUnsafe();
+
+    /**
+     * Currently, id is only used for debugging purpose, and the carrier thread name.
+     * When {@link Thread} represents a virtual thread in a future implementation,
+     * this id can be accessed via {@link Thread#threadId()}.
+     */
+    public final long id;
+
+    /**
+     * The name of the carrier thread. The name is cached here and re-used for all carrier threads.
+     */
+    public final String carrierName;
+    /**
+     * The object whose run() method gets called
+     */
+    public final Runnable target;
+    /**
+     * parkedStates stores the stack frames when a virtual thread is parked.
+     * For simplicity, other platform threads read this field to determine if a virtual thread
+     * is parked or unparked, and thus we use volatile to ensure the memory order here.
+     */
+    public volatile VirtualThreadParkedStates parkedStates;
+
+    /**
+     * If the virtual thread is parked and pinned, this field references the carrier thread object.
+     * For simplicity, other platform thread reads this field to determine if a virtual thread
+     * is pinned or not, and thus we use volatile to ensure the memory order here.
+     * A single state machine will likely be used instead in the future implementation to keep track
+     * the status of a virtual thread.
+     */
+    public volatile Thread pinnedCarrierThread;
+
+    private VirtualThreadContext(Runnable target, long id) {
+        Objects.requireNonNull(target);
+        this.id = id;
+        this.target = target;
+        this.carrierName = "VirtualThread-" + id;
+    }
+
+    public VirtualThreadContext(Runnable target) {
+        this(target, nextVirtualThreadId());
+    }
+
+
+    private static final AtomicLong NEXT_ID = new AtomicLong(0L);
+    public static long nextVirtualThreadId() {
+        return NEXT_ID.incrementAndGet();
+    }
+
+    @Override
+    public void run() {
+        target.run();
+    }
+
+    public boolean isParked() {
+        return parkedStates != null || pinnedCarrierThread != null;
+    }
+
+    public boolean isPinned() {
+        return pinnedCarrierThread != null;
+    }
+
+    public void parkOnCarrierThreadIfPinned() {
+        if (!isPinned()) {
+            return;
+        }
+
+        UNSAFE.park(false, 0L);
+    }
+
+    public Thread unparkOnCarrierThread() {
+        Thread t = pinnedCarrierThread;
+        pinnedCarrierThread = null;
+        UNSAFE.unpark(t);
+        return t;
+    }
+}
diff --git a/libart/src/main/java/dalvik/system/VirtualThreadFrame.java b/libart/src/main/java/dalvik/system/VirtualThreadFrame.java
new file mode 100644
index 00000000000..02b9ece5e61
--- /dev/null
+++ b/libart/src/main/java/dalvik/system/VirtualThreadFrame.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dalvik.system;
+
+/**
+ * @hide
+ */
+public final class VirtualThreadFrame {
+
+    /** art::ShadowFrame */
+    public byte[] frame;
+    /**
+     * Objects referenced in the frame. Stored separately from the frame in order to be traced
+     * by the GC properly.
+     */
+    public Object[] refs;
+
+    /** The declaring class of the invoked method.  */
+    public Class<?> declaringClass;
+
+    // private because an instance is created by ART.
+    private VirtualThreadFrame() {}
+}
diff --git a/libart/src/main/java/dalvik/system/VirtualThreadParkedStates.java b/libart/src/main/java/dalvik/system/VirtualThreadParkedStates.java
new file mode 100644
index 00000000000..1a5231be99d
--- /dev/null
+++ b/libart/src/main/java/dalvik/system/VirtualThreadParkedStates.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dalvik.system;
+
+/**
+ * Any values kept for a parked virtual thread should be stored in the VirtualThreadParkedStates.
+ * When a virtual thread is fully un-parked, this object should not be referenced and can be GC-ed.
+ *
+ * @hide
+ */
+public class VirtualThreadParkedStates {
+
+    public VirtualThreadFrame[] frames;
+
+    public VirtualThreadParkedStates() {}
+
+
+}
diff --git a/libart/src/main/java/dalvik/system/VirtualThreadParkingError.java b/libart/src/main/java/dalvik/system/VirtualThreadParkingError.java
new file mode 100644
index 00000000000..7fac396d552
--- /dev/null
+++ b/libart/src/main/java/dalvik/system/VirtualThreadParkingError.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dalvik.system;
+
+// TODO(b/346542404): Avoid using a java object to pop the interpreter's frames.
+/**
+ * Used by ART to pop the interpreter's frames.
+ * @hide
+ */
+public class VirtualThreadParkingError extends VirtualMachineError {
+    @SuppressWarnings("StaticAssignmentOfThrowable")
+    public final static VirtualThreadParkingError INSTANCE = new VirtualThreadParkingError();
+
+    private VirtualThreadParkingError() {
+        super();
+    }
+}
\ No newline at end of file
diff --git a/libart/src/main/java/java/lang/Daemons.java b/libart/src/main/java/java/lang/Daemons.java
index ba38844ebab..c9f0bd567e2 100644
--- a/libart/src/main/java/java/lang/Daemons.java
+++ b/libart/src/main/java/java/lang/Daemons.java
@@ -125,7 +125,8 @@ public final class Daemons {
                 // Thread.start() will call SetNativePriority and overwrite the desired native
                 // priority. We (may) use a native priority that doesn't have a corresponding
                 // java.lang.Thread-level priority (native priorities are more coarse-grained.)
-                VMRuntime.getRuntime().setSystemDaemonThreadPriority();
+                Thread.currentThread().setPosixNicenessInternal(
+                    VMRuntime.getRuntime().getSystemDaemonNiceness());
             }
             zygoteStartLatch.countDown();
             try {
diff --git a/libcore.aconfig b/libcore.aconfig
index 51c49b71a1e..54def95d903 100644
--- a/libcore.aconfig
+++ b/libcore.aconfig
@@ -53,7 +53,7 @@ flag {
     name: "openjdk_21_v2_apis"
     is_exported: true
     description: "This flag includes OpenJDK APIs released after 25Q2."
-    bug: "292585625"
+    bug: "414798911"
     is_fixed_read_only: true
 }
 
@@ -135,3 +135,23 @@ flag {
     # APIs provided by a mainline module can only use a frozen flag.
     is_fixed_read_only: true
 }
+
+flag {
+    namespace: "core_libraries"
+    name: "niceness_apis"
+    is_exported: true
+    description: "Java APIs get/set niceness"
+    bug: "417492941"
+    # APIs provided by a mainline module can only use a frozen flag.
+    is_fixed_read_only: true
+}
+
+flag {
+    namespace: "core_libraries"
+    name: "openjdk_25_v1_apis"
+    is_exported: true
+    description: "This flag includes OpenJDK APIs released in 26Q2."
+    bug: "417667799"
+    is_fixed_read_only: true
+}
+
diff --git a/luni/annotations/flagged_api/dalvik/system/VMDebug.annotated.java b/luni/annotations/flagged_api/dalvik/system/VMDebug.annotated.java
index 04e34a1ce82..5b02e36fd4f 100644
--- a/luni/annotations/flagged_api/dalvik/system/VMDebug.annotated.java
+++ b/luni/annotations/flagged_api/dalvik/system/VMDebug.annotated.java
@@ -124,7 +124,7 @@ public static class ExecutableMethodFileOffsets {
   public long getMethodOffset();
 }
 
-@android.annotation.FlaggedApi(com.android.art.flags.Flags.FLAG_EXECUTABLE_METHOD_FILE_OFFSETS)
+@android.annotation.FlaggedApi(com.android.art.flags.Flags.FLAG_EXECUTABLE_METHOD_FILE_OFFSETS_DEPRECATION)
 public static VMDebug.ExecutableMethodFileOffsets getExecutableMethodFileOffsets(
         @NonNull java.lang.reflect.Method javaMethod);
 
diff --git a/luni/src/main/java/android/compat/Compatibility.java b/luni/src/main/java/android/compat/Compatibility.java
index 5340c87ef0d..300fef4cd89 100644
--- a/luni/src/main/java/android/compat/Compatibility.java
+++ b/luni/src/main/java/android/compat/Compatibility.java
@@ -50,10 +50,6 @@ public final class Compatibility {
      * regardless of the process it's running in. When called in a non-app process, this method is
      * a no-op.
      *
-     * <p>Note: for changes that are gated using {@link #isChangeEnabled(long)}, you do not need to
-     * call this API directly. The change will be reported for you in the case that
-     * {@link #isChangeEnabled(long)} returns {@code true}.
-     *
      * @param changeId The ID of the compatibility change taking effect.
      *
      * @hide
diff --git a/luni/src/main/java/android/system/Os.java b/luni/src/main/java/android/system/Os.java
index cd16bfb5774..0ab875b6b98 100644
--- a/luni/src/main/java/android/system/Os.java
+++ b/luni/src/main/java/android/system/Os.java
@@ -138,6 +138,14 @@ public final class Os {
      */
     public static void connect(@NonNull FileDescriptor fd, @NonNull SocketAddress address) throws ErrnoException, SocketException { Libcore.os.connect(fd, address); }
 
+    /**
+     * See <a href="https://man7.org/linux/man-pages/man3/dladdr.3.html">dladdr(3)</>
+     *
+     * @return null if the underlying native {@code dladdr} call fails.
+     */
+    @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_OPENJDK_21_V2_APIS)
+    public static StructDlInfo dladdr(long addr) { return Libcore.os.dladdr(addr); }
+
     /**
      * See <a href="http://man7.org/linux/man-pages/man2/dup.2.html">dup(2)</a>.
      */
diff --git a/luni/src/main/java/android/system/OsConstants.java b/luni/src/main/java/android/system/OsConstants.java
index 807f2761222..4a251de7acb 100644
--- a/luni/src/main/java/android/system/OsConstants.java
+++ b/luni/src/main/java/android/system/OsConstants.java
@@ -126,11 +126,25 @@ public final class OsConstants {
      */
     public static boolean WIFSIGNALED(int status) { return (WTERMSIG(status + 1) >= 2); }
 
-    public static final int AF_INET = placeholder();
-    public static final int AF_INET6 = placeholder();
-    public static final int AF_NETLINK = placeholder();
-    public static final int AF_PACKET = placeholder();
-    public static final int AF_UNIX = placeholder();
+    /*
+     * Public fields of this class are defined in native and are part of ABI. However, in certain
+     * cases, bionic and glibc disagree so it is not always possible to set field to an exact value
+     * and it has to be obtained using JNI.
+     *
+     * Creating a native method per each field is not viable: there are more than 500 fields. But
+     * static final fields have to be initialized in java code. Previously they were set to 0 and
+     * overwritten using JNI's SetStaticIntField method. That, however, is an undefined
+     * behaviour [1].
+     *
+     * And hence this inelegant workaround.
+     *
+     * [1] https://openjdk.org/jeps/8349536#Mutating-final-fields-from-native-code
+     */
+    public static final int AF_INET;
+    public static final int AF_INET6;
+    public static final int AF_NETLINK;
+    public static final int AF_PACKET;
+    public static final int AF_UNIX;
 
     /**
      * The virt-vsock address family, linux specific.
@@ -139,16 +153,16 @@ public final class OsConstants {
      * @see <a href="https://man7.org/linux/man-pages/man7/vsock.7.html">vsock(7)</a>
      * @see VmSocketAddress
      */
-    public static final int AF_VSOCK = placeholder();
-    public static final int AF_UNSPEC = placeholder();
-    public static final int AI_ADDRCONFIG = placeholder();
-    public static final int AI_ALL = placeholder();
-    public static final int AI_CANONNAME = placeholder();
-    public static final int AI_NUMERICHOST = placeholder();
-    public static final int AI_NUMERICSERV = placeholder();
-    public static final int AI_PASSIVE = placeholder();
-    public static final int AI_V4MAPPED = placeholder();
-    public static final int ARPHRD_ETHER = placeholder();
+    public static final int AF_VSOCK;
+    public static final int AF_UNSPEC;
+    public static final int AI_ADDRCONFIG = OsConstantsHolder.AI_ADDRCONFIG;
+    public static final int AI_ALL = OsConstantsHolder.AI_ALL;
+    public static final int AI_CANONNAME = OsConstantsHolder.AI_CANONNAME;
+    public static final int AI_NUMERICHOST = OsConstantsHolder.AI_NUMERICHOST;
+    public static final int AI_NUMERICSERV = OsConstantsHolder.AI_NUMERICSERV;
+    public static final int AI_PASSIVE = OsConstantsHolder.AI_PASSIVE;
+    public static final int AI_V4MAPPED = OsConstantsHolder.AI_V4MAPPED;
+    public static final int ARPHRD_ETHER;
 
     /**
       * The virtio-vsock {@code svmPort} value to bind for any available port.
@@ -156,7 +170,7 @@ public final class OsConstants {
       * @see <a href="https://man7.org/linux/man-pages/man7/vsock.7.html">vsock(7)</a>
       * @see VmSocketAddress
       */
-    public static final int VMADDR_PORT_ANY = placeholder();
+    public static final int VMADDR_PORT_ANY;
 
     /**
       * The virtio-vsock {@code svmCid} value to listens for all CIDs.
@@ -164,7 +178,7 @@ public final class OsConstants {
       * @see <a href="https://man7.org/linux/man-pages/man7/vsock.7.html">vsock(7)</a>
       * @see VmSocketAddress
       */
-    public static final int VMADDR_CID_ANY = placeholder();
+    public static final int VMADDR_CID_ANY;
 
     /**
       * The virtio-vsock {@code svmCid} value for host communication.
@@ -172,7 +186,7 @@ public final class OsConstants {
       * @see <a href="https://man7.org/linux/man-pages/man7/vsock.7.html">vsock(7)</a>
       * @see VmSocketAddress
       */
-    public static final int VMADDR_CID_LOCAL = placeholder();
+    public static final int VMADDR_CID_LOCAL;
 
     /**
       * The virtio-vsock {@code svmCid} value for loopback communication.
@@ -180,7 +194,7 @@ public final class OsConstants {
       * @see <a href="https://man7.org/linux/man-pages/man7/vsock.7.html">vsock(7)</a>
       * @see VmSocketAddress
       */
-    public static final int VMADDR_CID_HOST = placeholder();
+    public static final int VMADDR_CID_HOST;
 
     /**
      * ARP protocol loopback device identifier.
@@ -189,138 +203,138 @@ public final class OsConstants {
      */
     @UnsupportedAppUsage
     @SystemApi(client = MODULE_LIBRARIES)
-    public static final int ARPHRD_LOOPBACK = placeholder();
-    public static final int CAP_AUDIT_CONTROL = placeholder();
-    public static final int CAP_AUDIT_WRITE = placeholder();
-    public static final int CAP_BLOCK_SUSPEND = placeholder();
-    public static final int CAP_CHOWN = placeholder();
-    public static final int CAP_DAC_OVERRIDE = placeholder();
-    public static final int CAP_DAC_READ_SEARCH = placeholder();
-    public static final int CAP_FOWNER = placeholder();
-    public static final int CAP_FSETID = placeholder();
-    public static final int CAP_IPC_LOCK = placeholder();
-    public static final int CAP_IPC_OWNER = placeholder();
-    public static final int CAP_KILL = placeholder();
-    public static final int CAP_LAST_CAP = placeholder();
-    public static final int CAP_LEASE = placeholder();
-    public static final int CAP_LINUX_IMMUTABLE = placeholder();
-    public static final int CAP_MAC_ADMIN = placeholder();
-    public static final int CAP_MAC_OVERRIDE = placeholder();
-    public static final int CAP_MKNOD = placeholder();
-    public static final int CAP_NET_ADMIN = placeholder();
-    public static final int CAP_NET_BIND_SERVICE = placeholder();
-    public static final int CAP_NET_BROADCAST = placeholder();
-    public static final int CAP_NET_RAW = placeholder();
-    public static final int CAP_SETFCAP = placeholder();
-    public static final int CAP_SETGID = placeholder();
-    public static final int CAP_SETPCAP = placeholder();
-    public static final int CAP_SETUID = placeholder();
-    public static final int CAP_SYS_ADMIN = placeholder();
-    public static final int CAP_SYS_BOOT = placeholder();
-    public static final int CAP_SYS_CHROOT = placeholder();
-    public static final int CAP_SYSLOG = placeholder();
-    public static final int CAP_SYS_MODULE = placeholder();
-    public static final int CAP_SYS_NICE = placeholder();
-    public static final int CAP_SYS_PACCT = placeholder();
-    public static final int CAP_SYS_PTRACE = placeholder();
-    public static final int CAP_SYS_RAWIO = placeholder();
-    public static final int CAP_SYS_RESOURCE = placeholder();
-    public static final int CAP_SYS_TIME = placeholder();
-    public static final int CAP_SYS_TTY_CONFIG = placeholder();
-    public static final int CAP_WAKE_ALARM = placeholder();
-    public static final int E2BIG = placeholder();
-    public static final int EACCES = placeholder();
-    public static final int EADDRINUSE = placeholder();
-    public static final int EADDRNOTAVAIL = placeholder();
-    public static final int EAFNOSUPPORT = placeholder();
-    public static final int EAGAIN = placeholder();
-    public static final int EAI_AGAIN = placeholder();
-    public static final int EAI_BADFLAGS = placeholder();
-    public static final int EAI_FAIL = placeholder();
-    public static final int EAI_FAMILY = placeholder();
-    public static final int EAI_MEMORY = placeholder();
-    public static final int EAI_NODATA = placeholder();
-    public static final int EAI_NONAME = placeholder();
-    public static final int EAI_OVERFLOW = placeholder();
-    public static final int EAI_SERVICE = placeholder();
-    public static final int EAI_SOCKTYPE = placeholder();
-    public static final int EAI_SYSTEM = placeholder();
-    public static final int EALREADY = placeholder();
-    public static final int EBADF = placeholder();
-    public static final int EBADMSG = placeholder();
-    public static final int EBUSY = placeholder();
-    public static final int ECANCELED = placeholder();
-    public static final int ECHILD = placeholder();
-    public static final int ECONNABORTED = placeholder();
-    public static final int ECONNREFUSED = placeholder();
-    public static final int ECONNRESET = placeholder();
-    public static final int EDEADLK = placeholder();
-    public static final int EDESTADDRREQ = placeholder();
-    public static final int EDOM = placeholder();
-    public static final int EDQUOT = placeholder();
-    public static final int EEXIST = placeholder();
-    public static final int EFAULT = placeholder();
-    public static final int EFBIG = placeholder();
-    public static final int EHOSTUNREACH = placeholder();
-    public static final int EIDRM = placeholder();
-    public static final int EILSEQ = placeholder();
-    public static final int EINPROGRESS = placeholder();
-    public static final int EINTR = placeholder();
-    public static final int EINVAL = placeholder();
-    public static final int EIO = placeholder();
-    public static final int EISCONN = placeholder();
-    public static final int EISDIR = placeholder();
-    public static final int ELOOP = placeholder();
-    public static final int EMFILE = placeholder();
-    public static final int EMLINK = placeholder();
-    public static final int EMSGSIZE = placeholder();
-    public static final int EMULTIHOP = placeholder();
-    public static final int ENAMETOOLONG = placeholder();
-    public static final int ENETDOWN = placeholder();
-    public static final int ENETRESET = placeholder();
-    public static final int ENETUNREACH = placeholder();
-    public static final int ENFILE = placeholder();
-    public static final int ENOBUFS = placeholder();
-    public static final int ENODATA = placeholder();
-    public static final int ENODEV = placeholder();
-    public static final int ENOENT = placeholder();
-    public static final int ENOEXEC = placeholder();
-    public static final int ENOLCK = placeholder();
-    public static final int ENOLINK = placeholder();
-    public static final int ENOMEM = placeholder();
-    public static final int ENOMSG = placeholder();
-    public static final int ENONET = placeholder();
-    public static final int ENOPROTOOPT = placeholder();
-    public static final int ENOSPC = placeholder();
-    public static final int ENOSR = placeholder();
-    public static final int ENOSTR = placeholder();
-    public static final int ENOSYS = placeholder();
-    public static final int ENOTCONN = placeholder();
-    public static final int ENOTDIR = placeholder();
-    public static final int ENOTEMPTY = placeholder();
-    public static final int ENOTSOCK = placeholder();
-    public static final int ENOTSUP = placeholder();
-    public static final int ENOTTY = placeholder();
-    public static final int ENXIO = placeholder();
-    public static final int EOPNOTSUPP = placeholder();
-    public static final int EOVERFLOW = placeholder();
-    public static final int EPERM = placeholder();
-    public static final int EPIPE = placeholder();
-    public static final int EPROTO = placeholder();
-    public static final int EPROTONOSUPPORT = placeholder();
-    public static final int EPROTOTYPE = placeholder();
-    public static final int ERANGE = placeholder();
-    public static final int EROFS = placeholder();
-    public static final int ESPIPE = placeholder();
-    public static final int ESRCH = placeholder();
-    public static final int ESTALE = placeholder();
-    public static final int ETH_P_ALL = placeholder();
-    public static final int ETH_P_ARP = placeholder();
-    public static final int ETH_P_IP = placeholder();
-    public static final int ETH_P_IPV6 = placeholder();
-    public static final int ETIME = placeholder();
-    public static final int ETIMEDOUT = placeholder();
-    public static final int ETXTBSY = placeholder();
+    public static final int ARPHRD_LOOPBACK;
+    public static final int CAP_AUDIT_CONTROL;
+    public static final int CAP_AUDIT_WRITE;
+    public static final int CAP_BLOCK_SUSPEND;
+    public static final int CAP_CHOWN;
+    public static final int CAP_DAC_OVERRIDE;
+    public static final int CAP_DAC_READ_SEARCH;
+    public static final int CAP_FOWNER;
+    public static final int CAP_FSETID;
+    public static final int CAP_IPC_LOCK;
+    public static final int CAP_IPC_OWNER;
+    public static final int CAP_KILL;
+    public static final int CAP_LAST_CAP;
+    public static final int CAP_LEASE;
+    public static final int CAP_LINUX_IMMUTABLE;
+    public static final int CAP_MAC_ADMIN;
+    public static final int CAP_MAC_OVERRIDE;
+    public static final int CAP_MKNOD;
+    public static final int CAP_NET_ADMIN;
+    public static final int CAP_NET_BIND_SERVICE;
+    public static final int CAP_NET_BROADCAST;
+    public static final int CAP_NET_RAW;
+    public static final int CAP_SETFCAP;
+    public static final int CAP_SETGID;
+    public static final int CAP_SETPCAP;
+    public static final int CAP_SETUID;
+    public static final int CAP_SYS_ADMIN;
+    public static final int CAP_SYS_BOOT;
+    public static final int CAP_SYS_CHROOT;
+    public static final int CAP_SYSLOG;
+    public static final int CAP_SYS_MODULE;
+    public static final int CAP_SYS_NICE;
+    public static final int CAP_SYS_PACCT;
+    public static final int CAP_SYS_PTRACE;
+    public static final int CAP_SYS_RAWIO;
+    public static final int CAP_SYS_RESOURCE;
+    public static final int CAP_SYS_TIME;
+    public static final int CAP_SYS_TTY_CONFIG;
+    public static final int CAP_WAKE_ALARM;
+    public static final int EAI_AGAIN = OsConstantsHolder.EAI_AGAIN;
+    public static final int EAI_BADFLAGS = OsConstantsHolder.EAI_BADFLAGS;
+    public static final int EAI_FAIL = OsConstantsHolder.EAI_FAIL;
+    public static final int EAI_FAMILY = OsConstantsHolder.EAI_FAMILY;
+    public static final int EAI_MEMORY = OsConstantsHolder.EAI_MEMORY;
+    public static final int EAI_NODATA = OsConstantsHolder.EAI_NODATA;
+    public static final int EAI_NONAME = OsConstantsHolder.EAI_NONAME;
+    public static final int EAI_OVERFLOW = OsConstantsHolder.EAI_OVERFLOW;
+    public static final int EAI_SERVICE = OsConstantsHolder.EAI_SERVICE;
+    public static final int EAI_SOCKTYPE = OsConstantsHolder.EAI_SOCKTYPE;
+    public static final int EAI_SYSTEM = OsConstantsHolder.EAI_SYSTEM;
+    public static final int E2BIG;
+    public static final int EACCES;
+    public static final int EADDRINUSE;
+    public static final int EADDRNOTAVAIL;
+    public static final int EAFNOSUPPORT;
+    public static final int EAGAIN;
+    public static final int EALREADY;
+    public static final int EBADF;
+    public static final int EBADMSG;
+    public static final int EBUSY;
+    public static final int ECANCELED;
+    public static final int ECHILD;
+    public static final int ECONNABORTED;
+    public static final int ECONNREFUSED;
+    public static final int ECONNRESET;
+    public static final int EDEADLK;
+    public static final int EDESTADDRREQ;
+    public static final int EDOM;
+    public static final int EDQUOT;
+    public static final int EEXIST;
+    public static final int EFAULT;
+    public static final int EFBIG;
+    public static final int EHOSTUNREACH;
+    public static final int EIDRM;
+    public static final int EILSEQ;
+    public static final int EINPROGRESS;
+    public static final int EINTR;
+    public static final int EINVAL;
+    public static final int EIO;
+    public static final int EISCONN;
+    public static final int EISDIR;
+    public static final int ELOOP;
+    public static final int EMFILE;
+    public static final int EMLINK;
+    public static final int EMSGSIZE;
+    public static final int EMULTIHOP;
+    public static final int ENAMETOOLONG;
+    public static final int ENETDOWN;
+    public static final int ENETRESET;
+    public static final int ENETUNREACH;
+    public static final int ENFILE;
+    public static final int ENOBUFS;
+    public static final int ENODATA;
+    public static final int ENODEV;
+    public static final int ENOENT;
+    public static final int ENOEXEC;
+    public static final int ENOLCK;
+    public static final int ENOLINK;
+    public static final int ENOMEM;
+    public static final int ENOMSG;
+    public static final int ENONET;
+    public static final int ENOPROTOOPT;
+    public static final int ENOSPC;
+    public static final int ENOSR;
+    public static final int ENOSTR;
+    public static final int ENOSYS;
+    public static final int ENOTCONN;
+    public static final int ENOTDIR;
+    public static final int ENOTEMPTY;
+    public static final int ENOTSOCK;
+    public static final int ENOTSUP;
+    public static final int ENOTTY;
+    public static final int ENXIO;
+    public static final int EOPNOTSUPP;
+    public static final int EOVERFLOW;
+    public static final int EPERM;
+    public static final int EPIPE;
+    public static final int EPROTO;
+    public static final int EPROTONOSUPPORT;
+    public static final int EPROTOTYPE;
+    public static final int ERANGE;
+    public static final int EROFS;
+    public static final int ESPIPE;
+    public static final int ESRCH;
+    public static final int ESTALE;
+    public static final int ETIME;
+    public static final int ETIMEDOUT;
+    public static final int ETXTBSY;
+    public static final int ETH_P_ALL;
+    public static final int ETH_P_ARP;
+    public static final int ETH_P_IP;
+    public static final int ETH_P_IPV6;
     /**
      * "Too many users" error.
      * See <a href="https://man7.org/linux/man-pages/man3/errno.3.html">errno(3)</a>.
@@ -329,152 +343,151 @@ public final class OsConstants {
      */
     @UnsupportedAppUsage
     @SystemApi(client = MODULE_LIBRARIES)
-    public static final int EUSERS = placeholder();
+    public static final int EUSERS;
     // On Linux, EWOULDBLOCK == EAGAIN. Use EAGAIN instead, to reduce confusion.
-    public static final int EXDEV = placeholder();
-    public static final int EXIT_FAILURE = placeholder();
-    public static final int EXIT_SUCCESS = placeholder();
-    public static final int FD_CLOEXEC = placeholder();
-    public static final int FIONREAD = placeholder();
-    public static final int F_DUPFD = placeholder();
-    public static final int F_DUPFD_CLOEXEC = placeholder();
-    public static final int F_GETFD = placeholder();
-    public static final int F_GETFL = placeholder();
-    public static final int F_GETLK = placeholder();
-    public static final int F_GETLK64 = placeholder();
-    public static final int F_GETOWN = placeholder();
-    public static final int F_OK = placeholder();
-    public static final int F_RDLCK = placeholder();
-    public static final int F_SETFD = placeholder();
-    public static final int F_SETFL = placeholder();
-    public static final int F_SETLK = placeholder();
-    public static final int F_SETLK64 = placeholder();
-    public static final int F_SETLKW = placeholder();
-    public static final int F_SETLKW64 = placeholder();
-    public static final int F_SETOWN = placeholder();
-    public static final int F_UNLCK = placeholder();
-    public static final int F_WRLCK = placeholder();
-    public static final int ICMP_ECHO = placeholder();
-    public static final int ICMP_ECHOREPLY = placeholder();
-    public static final int ICMP6_ECHO_REQUEST = placeholder();
-    public static final int ICMP6_ECHO_REPLY = placeholder();
-    public static final int IFA_F_DADFAILED = placeholder();
-    public static final int IFA_F_DEPRECATED = placeholder();
-    public static final int IFA_F_HOMEADDRESS = placeholder();
-    public static final int IFA_F_MANAGETEMPADDR = placeholder();
-    public static final int IFA_F_NODAD = placeholder();
-    public static final int IFA_F_NOPREFIXROUTE = placeholder();
-    public static final int IFA_F_OPTIMISTIC = placeholder();
-    public static final int IFA_F_PERMANENT = placeholder();
-    public static final int IFA_F_SECONDARY = placeholder();
-    public static final int IFA_F_TEMPORARY = placeholder();
-    public static final int IFA_F_TENTATIVE = placeholder();
-    public static final int IFF_ALLMULTI = placeholder();
-    public static final int IFF_AUTOMEDIA = placeholder();
-    public static final int IFF_BROADCAST = placeholder();
-    public static final int IFF_DEBUG = placeholder();
-    public static final int IFF_DYNAMIC = placeholder();
-    public static final int IFF_LOOPBACK = placeholder();
-    public static final int IFF_MASTER = placeholder();
-    public static final int IFF_MULTICAST = placeholder();
-    public static final int IFF_NOARP = placeholder();
-    public static final int IFF_NOTRAILERS = placeholder();
-    public static final int IFF_POINTOPOINT = placeholder();
-    public static final int IFF_PORTSEL = placeholder();
-    public static final int IFF_PROMISC = placeholder();
-    public static final int IFF_RUNNING = placeholder();
-    public static final int IFF_SLAVE = placeholder();
-    public static final int IFF_UP = placeholder();
-    public static final int IPPROTO_ICMP = placeholder();
-    public static final int IPPROTO_ICMPV6 = placeholder();
-    public static final int IPPROTO_IP = placeholder();
-    public static final int IPPROTO_IPV6 = placeholder();
-    public static final int IPPROTO_RAW = placeholder();
-    public static final int IPPROTO_TCP = placeholder();
-    public static final int IPPROTO_UDP = placeholder();
+    public static final int EXDEV;
+    public static final int EXIT_FAILURE;
+    public static final int EXIT_SUCCESS;
+    public static final int FD_CLOEXEC;
+    public static final int FIONREAD;
+    public static final int F_DUPFD;
+    public static final int F_DUPFD_CLOEXEC;
+    public static final int F_GETFD;
+    public static final int F_GETFL;
+    public static final int F_GETLK = OsConstantsHolder.F_GETLK;
+    public static final int F_GETLK64 = OsConstantsHolder.F_GETLK64;
+    public static final int F_GETOWN;
+    public static final int F_OK;
+    public static final int F_RDLCK;
+    public static final int F_SETFD;
+    public static final int F_SETFL;
+    public static final int F_SETLK = OsConstantsHolder.F_SETLK;
+    public static final int F_SETLK64 = OsConstantsHolder.F_SETLK64;
+    public static final int F_SETLKW = OsConstantsHolder.F_SETLKW;
+    public static final int F_SETLKW64 = OsConstantsHolder.F_SETLKW64;
+    public static final int F_SETOWN;
+    public static final int F_UNLCK;
+    public static final int F_WRLCK;
+    public static final int ICMP_ECHO;
+    public static final int ICMP_ECHOREPLY;
+    public static final int ICMP6_ECHO_REQUEST;
+    public static final int ICMP6_ECHO_REPLY;
+    public static final int IFA_F_DADFAILED;
+    public static final int IFA_F_DEPRECATED;
+    public static final int IFA_F_HOMEADDRESS;
+    public static final int IFA_F_MANAGETEMPADDR;
+    public static final int IFA_F_NODAD;
+    public static final int IFA_F_NOPREFIXROUTE;
+    public static final int IFA_F_OPTIMISTIC;
+    public static final int IFA_F_PERMANENT;
+    public static final int IFA_F_SECONDARY;
+    public static final int IFA_F_TEMPORARY;
+    public static final int IFA_F_TENTATIVE;
+    public static final int IFF_ALLMULTI;
+    public static final int IFF_AUTOMEDIA;
+    public static final int IFF_BROADCAST;
+    public static final int IFF_DEBUG;
+    public static final int IFF_DYNAMIC;
+    public static final int IFF_LOOPBACK;
+    public static final int IFF_MASTER;
+    public static final int IFF_MULTICAST;
+    public static final int IFF_NOARP;
+    public static final int IFF_NOTRAILERS;
+    public static final int IFF_POINTOPOINT;
+    public static final int IFF_PORTSEL;
+    public static final int IFF_PROMISC;
+    public static final int IFF_RUNNING;
+    public static final int IFF_SLAVE;
+    public static final int IFF_UP;
+    public static final int IPPROTO_ICMP;
+    public static final int IPPROTO_ICMPV6;
+    public static final int IPPROTO_IP;
+    public static final int IPPROTO_IPV6;
+    public static final int IPPROTO_RAW;
+    public static final int IPPROTO_TCP;
+    public static final int IPPROTO_UDP;
 
     /**
      * Encapsulation Security Payload protocol
      *
      * <p>Defined in /uapi/linux/in.h
      */
-    public static final int IPPROTO_ESP = placeholder();
-
-    public static final int IPV6_CHECKSUM = placeholder();
-    public static final int IPV6_MULTICAST_HOPS = placeholder();
-    public static final int IPV6_MULTICAST_IF = placeholder();
-    public static final int IPV6_MULTICAST_LOOP = placeholder();
-    public static final int IPV6_PKTINFO = placeholder();
-    public static final int IPV6_RECVDSTOPTS = placeholder();
-    public static final int IPV6_RECVHOPLIMIT = placeholder();
-    public static final int IPV6_RECVHOPOPTS = placeholder();
-    public static final int IPV6_RECVPKTINFO = placeholder();
-    public static final int IPV6_RECVRTHDR = placeholder();
-    public static final int IPV6_RECVTCLASS = placeholder();
-    public static final int IPV6_TCLASS = placeholder();
-    public static final int IPV6_UNICAST_HOPS = placeholder();
-    public static final int IPV6_V6ONLY = placeholder();
+    public static final int IPPROTO_ESP;
+
+    public static final int IPV6_CHECKSUM;
+    public static final int IPV6_MULTICAST_HOPS;
+    public static final int IPV6_MULTICAST_IF;
+    public static final int IPV6_MULTICAST_LOOP;
+    public static final int IPV6_PKTINFO;
+    public static final int IPV6_RECVDSTOPTS;
+    public static final int IPV6_RECVHOPLIMIT;
+    public static final int IPV6_RECVHOPOPTS;
+    public static final int IPV6_RECVPKTINFO;
+    public static final int IPV6_RECVRTHDR;
+    public static final int IPV6_RECVTCLASS;
+    public static final int IPV6_TCLASS;
+    public static final int IPV6_UNICAST_HOPS;
+    public static final int IPV6_V6ONLY;
     /** @hide */
     @UnsupportedAppUsage
-    public static final int IP_MULTICAST_ALL = placeholder();
-    public static final int IP_MULTICAST_IF = placeholder();
-    public static final int IP_MULTICAST_LOOP = placeholder();
-    public static final int IP_MULTICAST_TTL = placeholder();
+    public static final int IP_MULTICAST_ALL;
+    public static final int IP_MULTICAST_IF;
+    public static final int IP_MULTICAST_LOOP;
+    public static final int IP_MULTICAST_TTL;
     /** @hide */
     @UnsupportedAppUsage
-    public static final int IP_RECVTOS = placeholder();
-    public static final int IP_TOS = placeholder();
-    public static final int IP_TTL = placeholder();
+    public static final int IP_RECVTOS;
+    public static final int IP_TOS;
+    public static final int IP_TTL;
 
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_NORMAL = placeholder();
+    public static final int MADV_NORMAL;
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_RANDOM = placeholder();
+    public static final int MADV_RANDOM;
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_SEQUENTIAL = placeholder();
+    public static final int MADV_SEQUENTIAL;
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_WILLNEED = placeholder();
+    public static final int MADV_WILLNEED;
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_DONTNEED = placeholder();
+    public static final int MADV_DONTNEED;
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_REMOVE = placeholder();
+    public static final int MADV_REMOVE;
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_DONTFORK = placeholder();
+    public static final int MADV_DONTFORK;
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_DOFORK = placeholder();
+    public static final int MADV_DOFORK;
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_HWPOISON = placeholder();
+    public static final int MADV_HWPOISON;
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_MERGEABLE = placeholder();
+    public static final int MADV_MERGEABLE;
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_UNMERGEABLE = placeholder();
+    public static final int MADV_UNMERGEABLE;
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_SOFT_OFFLINE = placeholder();
+    public static final int MADV_SOFT_OFFLINE;
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_HUGEPAGE = placeholder();
+    public static final int MADV_HUGEPAGE;
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_NOHUGEPAGE = placeholder();
+    public static final int MADV_NOHUGEPAGE;
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_COLLAPSE = placeholder();
+    public static final int MADV_COLLAPSE;
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_DONTDUMP = placeholder();
+    public static final int MADV_DONTDUMP;
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_DODUMP = placeholder();
+    public static final int MADV_DODUMP;
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_FREE = placeholder();
+    public static final int MADV_FREE;
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_WIPEONFORK = placeholder();
+    public static final int MADV_WIPEONFORK;
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_KEEPONFORK = placeholder();
+    public static final int MADV_KEEPONFORK;
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_COLD = placeholder();
+    public static final int MADV_COLD;
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_PAGEOUT = placeholder();
+    public static final int MADV_PAGEOUT;
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_POPULATE_READ = placeholder();
+    public static final int MADV_POPULATE_READ;
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_MADVISE_API)
-    public static final int MADV_POPULATE_WRITE = placeholder();
-
+    public static final int MADV_POPULATE_WRITE;
     /**
      * Version constant to be used in {@link StructCapUserHeader} with
      * {@link Os#capset(StructCapUserHeader, StructCapUserData[])} and
@@ -486,9 +499,9 @@ public final class OsConstants {
      */
     @UnsupportedAppUsage
     @SystemApi(client = MODULE_LIBRARIES)
-    public static final int _LINUX_CAPABILITY_VERSION_3 = placeholder();
-    public static final int MAP_FIXED = placeholder();
-    public static final int MAP_ANONYMOUS = placeholder();
+    public static final int _LINUX_CAPABILITY_VERSION_3;
+    public static final int MAP_FIXED;
+    public static final int MAP_ANONYMOUS;
     /**
      * Flag argument for {@code mmap(long, long, int, int, FileDescriptor, long)}.
      *
@@ -498,51 +511,51 @@ public final class OsConstants {
      */
     @UnsupportedAppUsage
     @SystemApi(client = MODULE_LIBRARIES)
-    public static final int MAP_POPULATE = placeholder();
-    public static final int MAP_PRIVATE = placeholder();
-    public static final int MAP_SHARED = placeholder();
-    public static final int MCAST_JOIN_GROUP = placeholder();
-    public static final int MCAST_LEAVE_GROUP = placeholder();
-    public static final int MCAST_JOIN_SOURCE_GROUP = placeholder();
-    public static final int MCAST_LEAVE_SOURCE_GROUP = placeholder();
-    public static final int MCAST_BLOCK_SOURCE = placeholder();
-    public static final int MCAST_UNBLOCK_SOURCE = placeholder();
-    public static final int MCL_CURRENT = placeholder();
-    public static final int MCL_FUTURE = placeholder();
-    public static final int MFD_CLOEXEC = placeholder();
-    public static final int MSG_CTRUNC = placeholder();
-    public static final int MSG_DONTROUTE = placeholder();
-    public static final int MSG_EOR = placeholder();
-    public static final int MSG_OOB = placeholder();
-    public static final int MSG_PEEK = placeholder();
-    public static final int MSG_TRUNC = placeholder();
-    public static final int MSG_WAITALL = placeholder();
-    public static final int MS_ASYNC = placeholder();
-    public static final int MS_INVALIDATE = placeholder();
-    public static final int MS_SYNC = placeholder();
-    public static final int NETLINK_NETFILTER = placeholder();
-    public static final int NETLINK_ROUTE = placeholder();
+    public static final int MAP_POPULATE;
+    public static final int MAP_PRIVATE;
+    public static final int MAP_SHARED;
+    public static final int MCAST_JOIN_GROUP;
+    public static final int MCAST_LEAVE_GROUP;
+    public static final int MCAST_JOIN_SOURCE_GROUP;
+    public static final int MCAST_LEAVE_SOURCE_GROUP;
+    public static final int MCAST_BLOCK_SOURCE;
+    public static final int MCAST_UNBLOCK_SOURCE;
+    public static final int MCL_CURRENT;
+    public static final int MCL_FUTURE;
+    public static final int MFD_CLOEXEC;
+    public static final int MSG_CTRUNC;
+    public static final int MSG_DONTROUTE;
+    public static final int MSG_EOR;
+    public static final int MSG_OOB;
+    public static final int MSG_PEEK;
+    public static final int MSG_TRUNC;
+    public static final int MSG_WAITALL;
+    public static final int MS_ASYNC;
+    public static final int MS_INVALIDATE;
+    public static final int MS_SYNC;
+    public static final int NETLINK_NETFILTER;
+    public static final int NETLINK_ROUTE;
     /**
      * SELinux enforces that only system_server and netd may use this netlink socket type.
      */
-    public static final int NETLINK_INET_DIAG = placeholder();
+    public static final int NETLINK_INET_DIAG;
 
     /**
      * SELinux enforces that only system_server and netd may use this netlink socket type.
      *
      * @see <a href="https://man7.org/linux/man-pages/man7/netlink.7.html">netlink(7)</a>
      */
-    public static final int NETLINK_XFRM = placeholder();
-
-    public static final int NI_DGRAM = placeholder();
-    public static final int NI_NAMEREQD = placeholder();
-    public static final int NI_NOFQDN = placeholder();
-    public static final int NI_NUMERICHOST = placeholder();
-    public static final int NI_NUMERICSERV = placeholder();
-    public static final int O_ACCMODE = placeholder();
-    public static final int O_APPEND = placeholder();
-    public static final int O_CLOEXEC = placeholder();
-    public static final int O_CREAT = placeholder();
+    public static final int NETLINK_XFRM;
+
+    public static final int NI_DGRAM;
+    public static final int NI_NAMEREQD = OsConstantsHolder.NI_NAMEREQD;
+    public static final int NI_NOFQDN = OsConstantsHolder.NI_NOFQDN;
+    public static final int NI_NUMERICHOST = OsConstantsHolder.NI_NUMERICHOST;
+    public static final int NI_NUMERICSERV = OsConstantsHolder.NI_NUMERICSERV;
+    public static final int O_ACCMODE;
+    public static final int O_APPEND;
+    public static final int O_CLOEXEC;
+    public static final int O_CREAT;
     /**
      * Flag for {@code Os#open(String, int, int)}.
      *
@@ -562,27 +575,27 @@ public final class OsConstants {
      */
     @UnsupportedAppUsage
     @SystemApi(client = MODULE_LIBRARIES)
-    public static final int O_DIRECT = placeholder();
-    public static final int O_EXCL = placeholder();
-    public static final int O_NOCTTY = placeholder();
-    public static final int O_NOFOLLOW = placeholder();
-    public static final int O_NONBLOCK = placeholder();
-    public static final int O_RDONLY = placeholder();
-    public static final int O_RDWR = placeholder();
-    public static final int O_SYNC = placeholder();
-    public static final int O_DSYNC = placeholder();
-    public static final int O_TRUNC = placeholder();
-    public static final int O_WRONLY = placeholder();
-    public static final int POLLERR = placeholder();
-    public static final int POLLHUP = placeholder();
-    public static final int POLLIN = placeholder();
-    public static final int POLLNVAL = placeholder();
-    public static final int POLLOUT = placeholder();
-    public static final int POLLPRI = placeholder();
-    public static final int POLLRDBAND = placeholder();
-    public static final int POLLRDNORM = placeholder();
-    public static final int POLLWRBAND = placeholder();
-    public static final int POLLWRNORM = placeholder();
+    public static final int O_DIRECT = OsConstantsHolder.O_DIRECT;
+    public static final int O_EXCL;
+    public static final int O_NOCTTY;
+    public static final int O_NOFOLLOW = OsConstantsHolder.O_NOFOLLOW;
+    public static final int O_NONBLOCK;
+    public static final int O_RDONLY;
+    public static final int O_RDWR;
+    public static final int O_SYNC;
+    public static final int O_DSYNC;
+    public static final int O_TRUNC;
+    public static final int O_WRONLY;
+    public static final int POLLERR;
+    public static final int POLLHUP;
+    public static final int POLLIN;
+    public static final int POLLNVAL;
+    public static final int POLLOUT;
+    public static final int POLLPRI;
+    public static final int POLLRDBAND;
+    public static final int POLLRDNORM;
+    public static final int POLLWRBAND;
+    public static final int POLLWRNORM;
     /**
      * Reads or changes the ambient capability set of the calling thread.
      * Has to be used as a first argument for {@link Os#prctl(int, long, long, long, long)}.
@@ -593,7 +606,7 @@ public final class OsConstants {
      */
     @UnsupportedAppUsage
     @SystemApi(client = MODULE_LIBRARIES)
-    public static final int PR_CAP_AMBIENT = placeholder();
+    public static final int PR_CAP_AMBIENT;
     /**
      * The capability specified in {@code arg3} of {@link Os#prctl(int, long, long, long, long)}
      * is added to the ambient set. The specified capability must already
@@ -605,15 +618,15 @@ public final class OsConstants {
      */
     @UnsupportedAppUsage
     @SystemApi(client = MODULE_LIBRARIES)
-    public static final int PR_CAP_AMBIENT_RAISE = placeholder();
-    public static final int PR_GET_DUMPABLE = placeholder();
-    public static final int PR_SET_DUMPABLE = placeholder();
-    public static final int PR_SET_NO_NEW_PRIVS = placeholder();
-    public static final int PROT_EXEC = placeholder();
-    public static final int PROT_NONE = placeholder();
-    public static final int PROT_READ = placeholder();
-    public static final int PROT_WRITE = placeholder();
-    public static final int R_OK = placeholder();
+    public static final int PR_CAP_AMBIENT_RAISE;
+    public static final int PR_GET_DUMPABLE;
+    public static final int PR_SET_DUMPABLE;
+    public static final int PR_SET_NO_NEW_PRIVS;
+    public static final int PROT_EXEC;
+    public static final int PROT_NONE;
+    public static final int PROT_READ;
+    public static final int PROT_WRITE;
+    public static final int R_OK;
     /**
      * Specifies a value one greater than the maximum file
      * descriptor number that can be opened by this process.
@@ -628,16 +641,16 @@ public final class OsConstants {
      */
     @UnsupportedAppUsage
     @SystemApi(client = MODULE_LIBRARIES)
-    public static final int RLIMIT_NOFILE = placeholder();
+    public static final int RLIMIT_NOFILE;
     /** @hide */
     @android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_OPENJDK_21_V1_APIS)
     @SystemApi(client = MODULE_LIBRARIES)
-    public static final int RLIMIT_RTPRIO = placeholder();
-    public static final int RT_SCOPE_HOST = placeholder();
-    public static final int RT_SCOPE_LINK = placeholder();
-    public static final int RT_SCOPE_NOWHERE = placeholder();
-    public static final int RT_SCOPE_SITE = placeholder();
-    public static final int RT_SCOPE_UNIVERSE = placeholder();
+    public static final int RLIMIT_RTPRIO;
+    public static final int RT_SCOPE_HOST;
+    public static final int RT_SCOPE_LINK;
+    public static final int RT_SCOPE_NOWHERE;
+    public static final int RT_SCOPE_SITE;
+    public static final int RT_SCOPE_UNIVERSE;
     /**
      * Bitmask for IPv4 addresses add/delete events multicast groups mask.
      * Used in {@link NetlinkSocketAddress}.
@@ -648,84 +661,84 @@ public final class OsConstants {
      */
     @UnsupportedAppUsage
     @SystemApi(client = MODULE_LIBRARIES)
-    public static final int RTMGRP_IPV4_IFADDR = placeholder();
+    public static final int RTMGRP_IPV4_IFADDR;
     /** @hide */
     @UnsupportedAppUsage
-    public static final int RTMGRP_IPV4_MROUTE = placeholder();
+    public static final int RTMGRP_IPV4_MROUTE;
     /** @hide */
     @UnsupportedAppUsage
-    public static final int RTMGRP_IPV4_ROUTE = placeholder();
+    public static final int RTMGRP_IPV4_ROUTE;
     /** @hide */
     @UnsupportedAppUsage
-    public static final int RTMGRP_IPV4_RULE = placeholder();
+    public static final int RTMGRP_IPV4_RULE;
     /** @hide */
     @UnsupportedAppUsage
-    public static final int RTMGRP_IPV6_IFADDR = placeholder();
+    public static final int RTMGRP_IPV6_IFADDR;
     /** @hide */
     @UnsupportedAppUsage
-    public static final int RTMGRP_IPV6_IFINFO = placeholder();
+    public static final int RTMGRP_IPV6_IFINFO;
     /** @hide */
     @UnsupportedAppUsage
-    public static final int RTMGRP_IPV6_MROUTE = placeholder();
+    public static final int RTMGRP_IPV6_MROUTE;
     /** @hide */
     @UnsupportedAppUsage
-    public static final int RTMGRP_IPV6_PREFIX = placeholder();
+    public static final int RTMGRP_IPV6_PREFIX;
     /** @hide */
     @UnsupportedAppUsage
-    public static final int RTMGRP_IPV6_ROUTE = placeholder();
+    public static final int RTMGRP_IPV6_ROUTE;
     /** @hide */
     @UnsupportedAppUsage
-    public static final int RTMGRP_LINK = placeholder();
-    public static final int RTMGRP_NEIGH = placeholder();
+    public static final int RTMGRP_LINK;
+    public static final int RTMGRP_NEIGH;
     /** @hide */
     @UnsupportedAppUsage
-    public static final int RTMGRP_NOTIFY = placeholder();
+    public static final int RTMGRP_NOTIFY;
     /** @hide */
     @UnsupportedAppUsage
-    public static final int RTMGRP_TC = placeholder();
-    public static final int SEEK_CUR = placeholder();
-    public static final int SEEK_END = placeholder();
-    public static final int SEEK_SET = placeholder();
-    public static final int SHUT_RD = placeholder();
-    public static final int SHUT_RDWR = placeholder();
-    public static final int SHUT_WR = placeholder();
-    public static final int SIGABRT = placeholder();
-    public static final int SIGALRM = placeholder();
-    public static final int SIGBUS = placeholder();
-    public static final int SIGCHLD = placeholder();
-    public static final int SIGCONT = placeholder();
-    public static final int SIGFPE = placeholder();
-    public static final int SIGHUP = placeholder();
-    public static final int SIGILL = placeholder();
-    public static final int SIGINT = placeholder();
-    public static final int SIGIO = placeholder();
-    public static final int SIGKILL = placeholder();
-    public static final int SIGPIPE = placeholder();
-    public static final int SIGPROF = placeholder();
-    public static final int SIGPWR = placeholder();
-    public static final int SIGQUIT = placeholder();
-    public static final int SIGRTMAX = placeholder();
-    public static final int SIGRTMIN = placeholder();
-    public static final int SIGSEGV = placeholder();
-    public static final int SIGSTKFLT = placeholder();
-    public static final int SIGSTOP = placeholder();
-    public static final int SIGSYS = placeholder();
-    public static final int SIGTERM = placeholder();
-    public static final int SIGTRAP = placeholder();
-    public static final int SIGTSTP = placeholder();
-    public static final int SIGTTIN = placeholder();
-    public static final int SIGTTOU = placeholder();
-    public static final int SIGURG = placeholder();
-    public static final int SIGUSR1 = placeholder();
-    public static final int SIGUSR2 = placeholder();
-    public static final int SIGVTALRM = placeholder();
-    public static final int SIGWINCH = placeholder();
-    public static final int SIGXCPU = placeholder();
-    public static final int SIGXFSZ = placeholder();
-    public static final int SIOCGIFADDR = placeholder();
-    public static final int SIOCGIFBRDADDR = placeholder();
-    public static final int SIOCGIFDSTADDR = placeholder();
-    public static final int SIOCGIFNETMASK = placeholder();
+    public static final int RTMGRP_TC;
+    public static final int SEEK_CUR;
+    public static final int SEEK_END;
+    public static final int SEEK_SET;
+    public static final int SHUT_RD;
+    public static final int SHUT_RDWR;
+    public static final int SHUT_WR;
+    public static final int SIGABRT;
+    public static final int SIGALRM;
+    public static final int SIGBUS;
+    public static final int SIGCHLD;
+    public static final int SIGCONT;
+    public static final int SIGFPE;
+    public static final int SIGHUP;
+    public static final int SIGILL;
+    public static final int SIGINT;
+    public static final int SIGIO;
+    public static final int SIGKILL;
+    public static final int SIGPIPE;
+    public static final int SIGPROF;
+    public static final int SIGPWR;
+    public static final int SIGQUIT;
+    public static final int SIGRTMAX;
+    public static final int SIGRTMIN = OsConstantsHolder.SIGRTMIN;
+    public static final int SIGSEGV;
+    public static final int SIGSTKFLT;
+    public static final int SIGSTOP;
+    public static final int SIGSYS;
+    public static final int SIGTERM;
+    public static final int SIGTRAP;
+    public static final int SIGTSTP;
+    public static final int SIGTTIN;
+    public static final int SIGTTOU;
+    public static final int SIGURG;
+    public static final int SIGUSR1;
+    public static final int SIGUSR2;
+    public static final int SIGVTALRM;
+    public static final int SIGWINCH;
+    public static final int SIGXCPU;
+    public static final int SIGXFSZ;
+    public static final int SIOCGIFADDR;
+    public static final int SIOCGIFBRDADDR;
+    public static final int SIOCGIFDSTADDR;
+    public static final int SIOCGIFNETMASK;
 
     /**
      * Set the close-on-exec ({@code FD_CLOEXEC}) flag on the new file
@@ -739,8 +752,8 @@ public final class OsConstants {
      * may use {@link #O_CLOEXEC} instead. On Android, {@code O_CLOEXEC} and
      * {@code SOCK_CLOEXEC} are the same value.
      */
-    public static final int SOCK_CLOEXEC = placeholder();
-    public static final int SOCK_DGRAM = placeholder();
+    public static final int SOCK_CLOEXEC;
+    public static final int SOCK_DGRAM;
 
     /**
      * Set the O_NONBLOCK file status flag on the file descriptor
@@ -751,38 +764,38 @@ public final class OsConstants {
      * may use {@link #O_NONBLOCK} instead. On Android, {@code O_NONBLOCK}
      * and {@code SOCK_NONBLOCK} are the same value.
      */
-    public static final int SOCK_NONBLOCK = placeholder();
-    public static final int SOCK_RAW = placeholder();
-    public static final int SOCK_SEQPACKET = placeholder();
-    public static final int SOCK_STREAM = placeholder();
-    public static final int SOL_SOCKET = placeholder();
-    public static final int SOL_UDP = placeholder();
-    public static final int SOL_PACKET = placeholder();
-    public static final int SO_BINDTODEVICE = placeholder();
-    public static final int SO_BROADCAST = placeholder();
-    public static final int SO_DEBUG = placeholder();
+    public static final int SOCK_NONBLOCK;
+    public static final int SOCK_RAW;
+    public static final int SOCK_SEQPACKET;
+    public static final int SOCK_STREAM;
+    public static final int SOL_SOCKET;
+    public static final int SOL_UDP;
+    public static final int SOL_PACKET;
+    public static final int SO_BINDTODEVICE;
+    public static final int SO_BROADCAST;
+    public static final int SO_DEBUG;
     /** @hide */
     @UnsupportedAppUsage
-    public static final int SO_DOMAIN = placeholder();
-    public static final int SO_DONTROUTE = placeholder();
-    public static final int SO_ERROR = placeholder();
-    public static final int SO_KEEPALIVE = placeholder();
-    public static final int SO_LINGER = placeholder();
-    public static final int SO_OOBINLINE = placeholder();
-    public static final int SO_PASSCRED = placeholder();
-    public static final int SO_PEERCRED = placeholder();
+    public static final int SO_DOMAIN;
+    public static final int SO_DONTROUTE;
+    public static final int SO_ERROR;
+    public static final int SO_KEEPALIVE;
+    public static final int SO_LINGER;
+    public static final int SO_OOBINLINE;
+    public static final int SO_PASSCRED;
+    public static final int SO_PEERCRED;
     /** @hide */
     @UnsupportedAppUsage
-    public static final int SO_PROTOCOL = placeholder();
-    public static final int SO_RCVBUF = placeholder();
-    public static final int SO_RCVLOWAT = placeholder();
-    public static final int SO_RCVTIMEO = placeholder();
-    public static final int SO_REUSEADDR = placeholder();
-    public static final int SO_SNDBUF = placeholder();
-    public static final int SO_SNDLOWAT = placeholder();
-    public static final int SO_SNDTIMEO = placeholder();
-    public static final int SO_TYPE = placeholder();
-    public static final int PACKET_IGNORE_OUTGOING = placeholder();
+    public static final int SO_PROTOCOL;
+    public static final int SO_RCVBUF;
+    public static final int SO_RCVLOWAT;
+    public static final int SO_RCVTIMEO;
+    public static final int SO_REUSEADDR;
+    public static final int SO_SNDBUF;
+    public static final int SO_SNDLOWAT;
+    public static final int SO_SNDTIMEO;
+    public static final int SO_TYPE;
+    public static final int PACKET_IGNORE_OUTGOING;
     /**
      * Bitmask for flags argument of
      * {@link splice(java.io.FileDescriptor, Int64Ref, FileDescriptor, Int64Ref, long, int)}.
@@ -798,10 +811,10 @@ public final class OsConstants {
      */
     @UnsupportedAppUsage
     @SystemApi(client = MODULE_LIBRARIES)
-    public static final int SPLICE_F_MOVE = placeholder();
+    public static final int SPLICE_F_MOVE;
     /** @hide */
     @UnsupportedAppUsage
-    public static final int SPLICE_F_NONBLOCK = placeholder();
+    public static final int SPLICE_F_NONBLOCK;
     /**
      * Bitmask for flags argument of
      * {@link splice(java.io.FileDescriptor, Int64Ref, FileDescriptor, Int64Ref, long, int)}.
@@ -815,46 +828,46 @@ public final class OsConstants {
      */
     @UnsupportedAppUsage
     @SystemApi(client = MODULE_LIBRARIES)
-    public static final int SPLICE_F_MORE = placeholder();
-    public static final int STDERR_FILENO = placeholder();
-    public static final int STDIN_FILENO = placeholder();
-    public static final int STDOUT_FILENO = placeholder();
-    public static final int ST_MANDLOCK = placeholder();
-    public static final int ST_NOATIME = placeholder();
-    public static final int ST_NODEV = placeholder();
-    public static final int ST_NODIRATIME = placeholder();
-    public static final int ST_NOEXEC = placeholder();
-    public static final int ST_NOSUID = placeholder();
-    public static final int ST_RDONLY = placeholder();
-    public static final int ST_RELATIME = placeholder();
-    public static final int ST_SYNCHRONOUS = placeholder();
-    public static final int S_IFBLK = placeholder();
-    public static final int S_IFCHR = placeholder();
-    public static final int S_IFDIR = placeholder();
-    public static final int S_IFIFO = placeholder();
-    public static final int S_IFLNK = placeholder();
-    public static final int S_IFMT = placeholder();
-    public static final int S_IFREG = placeholder();
-    public static final int S_IFSOCK = placeholder();
-    public static final int S_IRGRP = placeholder();
-    public static final int S_IROTH = placeholder();
-    public static final int S_IRUSR = placeholder();
-    public static final int S_IRWXG = placeholder();
-    public static final int S_IRWXO = placeholder();
-    public static final int S_IRWXU = placeholder();
-    public static final int S_ISGID = placeholder();
-    public static final int S_ISUID = placeholder();
-    public static final int S_ISVTX = placeholder();
-    public static final int S_IWGRP = placeholder();
-    public static final int S_IWOTH = placeholder();
-    public static final int S_IWUSR = placeholder();
-    public static final int S_IXGRP = placeholder();
-    public static final int S_IXOTH = placeholder();
-    public static final int S_IXUSR = placeholder();
-    public static final int TCP_NODELAY = placeholder();
-    public static final int TCP_USER_TIMEOUT = placeholder();
-    public static final int UDP_GRO = placeholder();
-    public static final int UDP_SEGMENT = placeholder();
+    public static final int SPLICE_F_MORE;
+    public static final int STDERR_FILENO;
+    public static final int STDIN_FILENO;
+    public static final int STDOUT_FILENO;
+    public static final int ST_MANDLOCK;
+    public static final int ST_NOATIME;
+    public static final int ST_NODEV;
+    public static final int ST_NODIRATIME;
+    public static final int ST_NOEXEC;
+    public static final int ST_NOSUID;
+    public static final int ST_RDONLY;
+    public static final int ST_RELATIME;
+    public static final int ST_SYNCHRONOUS;
+    public static final int S_IFBLK;
+    public static final int S_IFCHR;
+    public static final int S_IFDIR;
+    public static final int S_IFIFO;
+    public static final int S_IFLNK;
+    public static final int S_IFMT;
+    public static final int S_IFREG;
+    public static final int S_IFSOCK;
+    public static final int S_IRGRP;
+    public static final int S_IROTH;
+    public static final int S_IRUSR;
+    public static final int S_IRWXG;
+    public static final int S_IRWXO;
+    public static final int S_IRWXU;
+    public static final int S_ISGID;
+    public static final int S_ISUID;
+    public static final int S_ISVTX;
+    public static final int S_IWGRP;
+    public static final int S_IWOTH;
+    public static final int S_IWUSR;
+    public static final int S_IXGRP;
+    public static final int S_IXOTH;
+    public static final int S_IXUSR;
+    public static final int TCP_NODELAY;
+    public static final int TCP_USER_TIMEOUT;
+    public static final int UDP_GRO;
+    public static final int UDP_SEGMENT;
     /**
      * Get the number of bytes in the output buffer.
      *
@@ -864,7 +877,7 @@ public final class OsConstants {
      */
     @UnsupportedAppUsage
     @SystemApi(client = MODULE_LIBRARIES)
-    public static final int TIOCOUTQ = placeholder();
+    public static final int TIOCOUTQ;
     /**
      * Sockopt option to encapsulate ESP packets in UDP.
      *
@@ -872,24 +885,24 @@ public final class OsConstants {
      */
     @UnsupportedAppUsage
     @SystemApi(client = MODULE_LIBRARIES)
-    public static final int UDP_ENCAP = placeholder();
+    public static final int UDP_ENCAP;
     /** @hide */
     @UnsupportedAppUsage
-    public static final int UDP_ENCAP_ESPINUDP_NON_IKE = placeholder();
+    public static final int UDP_ENCAP_ESPINUDP_NON_IKE;
     /** @hide */
     @UnsupportedAppUsage
     @SystemApi(client = MODULE_LIBRARIES)
-    public static final int UDP_ENCAP_ESPINUDP = placeholder();
+    public static final int UDP_ENCAP_ESPINUDP;
     /** @hide */
     @UnsupportedAppUsage
-    public static final int UNIX_PATH_MAX = placeholder();
-    public static final int WCONTINUED = placeholder();
-    public static final int WEXITED = placeholder();
-    public static final int WNOHANG = placeholder();
-    public static final int WNOWAIT = placeholder();
-    public static final int WSTOPPED = placeholder();
-    public static final int WUNTRACED = placeholder();
-    public static final int W_OK = placeholder();
+    public static final int UNIX_PATH_MAX;
+    public static final int WCONTINUED;
+    public static final int WEXITED;
+    public static final int WNOHANG;
+    public static final int WNOWAIT;
+    public static final int WSTOPPED;
+    public static final int WUNTRACED;
+    public static final int W_OK;
     /**
      * {@code flags} option for {@link Os#setxattr(String, String, byte[], int)}.
      *
@@ -901,7 +914,7 @@ public final class OsConstants {
      */
     @UnsupportedAppUsage
     @SystemApi(client = MODULE_LIBRARIES)
-    public static final int XATTR_CREATE = placeholder();
+    public static final int XATTR_CREATE;
     /**
      * {@code flags} option for {@link Os#setxattr(String, String, byte[], int)}.
      *
@@ -914,98 +927,98 @@ public final class OsConstants {
      */
     @UnsupportedAppUsage
     @SystemApi(client = MODULE_LIBRARIES)
-    public static final int XATTR_REPLACE = placeholder();
-    public static final int X_OK = placeholder();
-    public static final int _SC_2_CHAR_TERM = placeholder();
-    public static final int _SC_2_C_BIND = placeholder();
-    public static final int _SC_2_C_DEV = placeholder();
-    public static final int _SC_2_C_VERSION = placeholder();
-    public static final int _SC_2_FORT_DEV = placeholder();
-    public static final int _SC_2_FORT_RUN = placeholder();
-    public static final int _SC_2_LOCALEDEF = placeholder();
-    public static final int _SC_2_SW_DEV = placeholder();
-    public static final int _SC_2_UPE = placeholder();
-    public static final int _SC_2_VERSION = placeholder();
-    public static final int _SC_AIO_LISTIO_MAX = placeholder();
-    public static final int _SC_AIO_MAX = placeholder();
-    public static final int _SC_AIO_PRIO_DELTA_MAX = placeholder();
-    public static final int _SC_ARG_MAX = placeholder();
-    public static final int _SC_ASYNCHRONOUS_IO = placeholder();
-    public static final int _SC_ATEXIT_MAX = placeholder();
-    public static final int _SC_AVPHYS_PAGES = placeholder();
-    public static final int _SC_BC_BASE_MAX = placeholder();
-    public static final int _SC_BC_DIM_MAX = placeholder();
-    public static final int _SC_BC_SCALE_MAX = placeholder();
-    public static final int _SC_BC_STRING_MAX = placeholder();
-    public static final int _SC_CHILD_MAX = placeholder();
-    public static final int _SC_CLK_TCK = placeholder();
-    public static final int _SC_COLL_WEIGHTS_MAX = placeholder();
-    public static final int _SC_DELAYTIMER_MAX = placeholder();
-    public static final int _SC_EXPR_NEST_MAX = placeholder();
-    public static final int _SC_FSYNC = placeholder();
-    public static final int _SC_GETGR_R_SIZE_MAX = placeholder();
-    public static final int _SC_GETPW_R_SIZE_MAX = placeholder();
-    public static final int _SC_IOV_MAX = placeholder();
-    public static final int _SC_JOB_CONTROL = placeholder();
-    public static final int _SC_LINE_MAX = placeholder();
-    public static final int _SC_LOGIN_NAME_MAX = placeholder();
-    public static final int _SC_MAPPED_FILES = placeholder();
-    public static final int _SC_MEMLOCK = placeholder();
-    public static final int _SC_MEMLOCK_RANGE = placeholder();
-    public static final int _SC_MEMORY_PROTECTION = placeholder();
-    public static final int _SC_MESSAGE_PASSING = placeholder();
-    public static final int _SC_MQ_OPEN_MAX = placeholder();
-    public static final int _SC_MQ_PRIO_MAX = placeholder();
-    public static final int _SC_NGROUPS_MAX = placeholder();
-    public static final int _SC_NPROCESSORS_CONF = placeholder();
-    public static final int _SC_NPROCESSORS_ONLN = placeholder();
-    public static final int _SC_OPEN_MAX = placeholder();
-    public static final int _SC_PAGESIZE = placeholder();
-    public static final int _SC_PAGE_SIZE = placeholder();
-    public static final int _SC_PASS_MAX = placeholder();
-    public static final int _SC_PHYS_PAGES = placeholder();
-    public static final int _SC_PRIORITIZED_IO = placeholder();
-    public static final int _SC_PRIORITY_SCHEDULING = placeholder();
-    public static final int _SC_REALTIME_SIGNALS = placeholder();
-    public static final int _SC_RE_DUP_MAX = placeholder();
-    public static final int _SC_RTSIG_MAX = placeholder();
-    public static final int _SC_SAVED_IDS = placeholder();
-    public static final int _SC_SEMAPHORES = placeholder();
-    public static final int _SC_SEM_NSEMS_MAX = placeholder();
-    public static final int _SC_SEM_VALUE_MAX = placeholder();
-    public static final int _SC_SHARED_MEMORY_OBJECTS = placeholder();
-    public static final int _SC_SIGQUEUE_MAX = placeholder();
-    public static final int _SC_STREAM_MAX = placeholder();
-    public static final int _SC_SYNCHRONIZED_IO = placeholder();
-    public static final int _SC_THREADS = placeholder();
-    public static final int _SC_THREAD_ATTR_STACKADDR = placeholder();
-    public static final int _SC_THREAD_ATTR_STACKSIZE = placeholder();
-    public static final int _SC_THREAD_DESTRUCTOR_ITERATIONS = placeholder();
-    public static final int _SC_THREAD_KEYS_MAX = placeholder();
-    public static final int _SC_THREAD_PRIORITY_SCHEDULING = placeholder();
-    public static final int _SC_THREAD_PRIO_INHERIT = placeholder();
-    public static final int _SC_THREAD_PRIO_PROTECT = placeholder();
-    public static final int _SC_THREAD_SAFE_FUNCTIONS = placeholder();
-    public static final int _SC_THREAD_STACK_MIN = placeholder();
-    public static final int _SC_THREAD_THREADS_MAX = placeholder();
-    public static final int _SC_TIMERS = placeholder();
-    public static final int _SC_TIMER_MAX = placeholder();
-    public static final int _SC_TTY_NAME_MAX = placeholder();
-    public static final int _SC_TZNAME_MAX = placeholder();
-    public static final int _SC_VERSION = placeholder();
-    public static final int _SC_XBS5_ILP32_OFF32 = placeholder();
-    public static final int _SC_XBS5_ILP32_OFFBIG = placeholder();
-    public static final int _SC_XBS5_LP64_OFF64 = placeholder();
-    public static final int _SC_XBS5_LPBIG_OFFBIG = placeholder();
-    public static final int _SC_XOPEN_CRYPT = placeholder();
-    public static final int _SC_XOPEN_ENH_I18N = placeholder();
-    public static final int _SC_XOPEN_LEGACY = placeholder();
-    public static final int _SC_XOPEN_REALTIME = placeholder();
-    public static final int _SC_XOPEN_REALTIME_THREADS = placeholder();
-    public static final int _SC_XOPEN_SHM = placeholder();
-    public static final int _SC_XOPEN_UNIX = placeholder();
-    public static final int _SC_XOPEN_VERSION = placeholder();
-    public static final int _SC_XOPEN_XCU_VERSION = placeholder();
+    public static final int XATTR_REPLACE;
+    public static final int X_OK;
+    public static final int _SC_2_CHAR_TERM = OsConstantsHolder._SC_2_CHAR_TERM;
+    public static final int _SC_2_C_BIND = OsConstantsHolder._SC_2_C_BIND;
+    public static final int _SC_2_C_DEV = OsConstantsHolder._SC_2_C_DEV;
+    public static final int _SC_2_C_VERSION = OsConstantsHolder._SC_2_C_VERSION;
+    public static final int _SC_2_FORT_DEV = OsConstantsHolder._SC_2_FORT_DEV;
+    public static final int _SC_2_FORT_RUN = OsConstantsHolder._SC_2_FORT_RUN;
+    public static final int _SC_2_LOCALEDEF = OsConstantsHolder._SC_2_LOCALEDEF;
+    public static final int _SC_2_SW_DEV = OsConstantsHolder._SC_2_SW_DEV;
+    public static final int _SC_2_UPE = OsConstantsHolder._SC_2_UPE;
+    public static final int _SC_2_VERSION = OsConstantsHolder._SC_2_VERSION;
+    public static final int _SC_AIO_LISTIO_MAX = OsConstantsHolder._SC_AIO_LISTIO_MAX;
+    public static final int _SC_AIO_MAX = OsConstantsHolder._SC_AIO_MAX;
+    public static final int _SC_AIO_PRIO_DELTA_MAX = OsConstantsHolder._SC_AIO_PRIO_DELTA_MAX;
+    public static final int _SC_ARG_MAX = OsConstantsHolder._SC_ARG_MAX;
+    public static final int _SC_ASYNCHRONOUS_IO = OsConstantsHolder._SC_ASYNCHRONOUS_IO;
+    public static final int _SC_ATEXIT_MAX = OsConstantsHolder._SC_ATEXIT_MAX;
+    public static final int _SC_AVPHYS_PAGES = OsConstantsHolder._SC_AVPHYS_PAGES;
+    public static final int _SC_BC_BASE_MAX = OsConstantsHolder._SC_BC_BASE_MAX;
+    public static final int _SC_BC_DIM_MAX = OsConstantsHolder._SC_BC_DIM_MAX;
+    public static final int _SC_BC_SCALE_MAX = OsConstantsHolder._SC_BC_SCALE_MAX;
+    public static final int _SC_BC_STRING_MAX = OsConstantsHolder._SC_BC_STRING_MAX;
+    public static final int _SC_CHILD_MAX = OsConstantsHolder._SC_CHILD_MAX;
+    public static final int _SC_CLK_TCK = OsConstantsHolder._SC_CLK_TCK;
+    public static final int _SC_COLL_WEIGHTS_MAX = OsConstantsHolder._SC_COLL_WEIGHTS_MAX;
+    public static final int _SC_DELAYTIMER_MAX = OsConstantsHolder._SC_DELAYTIMER_MAX;
+    public static final int _SC_EXPR_NEST_MAX = OsConstantsHolder._SC_EXPR_NEST_MAX;
+    public static final int _SC_FSYNC = OsConstantsHolder._SC_FSYNC;
+    public static final int _SC_GETGR_R_SIZE_MAX = OsConstantsHolder._SC_GETGR_R_SIZE_MAX;
+    public static final int _SC_GETPW_R_SIZE_MAX = OsConstantsHolder._SC_GETPW_R_SIZE_MAX;
+    public static final int _SC_IOV_MAX = OsConstantsHolder._SC_IOV_MAX;
+    public static final int _SC_JOB_CONTROL = OsConstantsHolder._SC_JOB_CONTROL;
+    public static final int _SC_LINE_MAX = OsConstantsHolder._SC_LINE_MAX;
+    public static final int _SC_LOGIN_NAME_MAX = OsConstantsHolder._SC_LOGIN_NAME_MAX;
+    public static final int _SC_MAPPED_FILES = OsConstantsHolder._SC_MAPPED_FILES;
+    public static final int _SC_MEMLOCK = OsConstantsHolder._SC_MEMLOCK;
+    public static final int _SC_MEMLOCK_RANGE = OsConstantsHolder._SC_MEMLOCK_RANGE;
+    public static final int _SC_MEMORY_PROTECTION = OsConstantsHolder._SC_MEMORY_PROTECTION;
+    public static final int _SC_MESSAGE_PASSING = OsConstantsHolder._SC_MESSAGE_PASSING;
+    public static final int _SC_MQ_OPEN_MAX = OsConstantsHolder._SC_MQ_OPEN_MAX;
+    public static final int _SC_MQ_PRIO_MAX = OsConstantsHolder._SC_MQ_PRIO_MAX;
+    public static final int _SC_NGROUPS_MAX = OsConstantsHolder._SC_NGROUPS_MAX;
+    public static final int _SC_NPROCESSORS_CONF = OsConstantsHolder._SC_NPROCESSORS_CONF;
+    public static final int _SC_NPROCESSORS_ONLN = OsConstantsHolder._SC_NPROCESSORS_ONLN;
+    public static final int _SC_OPEN_MAX = OsConstantsHolder._SC_OPEN_MAX;
+    public static final int _SC_PAGESIZE = OsConstantsHolder._SC_PAGESIZE;
+    public static final int _SC_PAGE_SIZE = OsConstantsHolder._SC_PAGE_SIZE;
+    public static final int _SC_PASS_MAX = OsConstantsHolder._SC_PASS_MAX;
+    public static final int _SC_PHYS_PAGES = OsConstantsHolder._SC_PHYS_PAGES;
+    public static final int _SC_PRIORITIZED_IO = OsConstantsHolder._SC_PRIORITIZED_IO;
+    public static final int _SC_PRIORITY_SCHEDULING = OsConstantsHolder._SC_PRIORITY_SCHEDULING;
+    public static final int _SC_REALTIME_SIGNALS = OsConstantsHolder._SC_REALTIME_SIGNALS;
+    public static final int _SC_RE_DUP_MAX = OsConstantsHolder._SC_RE_DUP_MAX;
+    public static final int _SC_RTSIG_MAX = OsConstantsHolder._SC_RTSIG_MAX;
+    public static final int _SC_SAVED_IDS = OsConstantsHolder._SC_SAVED_IDS;
+    public static final int _SC_SEMAPHORES = OsConstantsHolder._SC_SEMAPHORES;
+    public static final int _SC_SEM_NSEMS_MAX = OsConstantsHolder._SC_SEM_NSEMS_MAX;
+    public static final int _SC_SEM_VALUE_MAX = OsConstantsHolder._SC_SEM_VALUE_MAX;
+    public static final int _SC_SHARED_MEMORY_OBJECTS = OsConstantsHolder._SC_SHARED_MEMORY_OBJECTS;
+    public static final int _SC_SIGQUEUE_MAX = OsConstantsHolder._SC_SIGQUEUE_MAX;
+    public static final int _SC_STREAM_MAX = OsConstantsHolder._SC_STREAM_MAX;
+    public static final int _SC_SYNCHRONIZED_IO = OsConstantsHolder._SC_SYNCHRONIZED_IO;
+    public static final int _SC_THREADS = OsConstantsHolder._SC_THREADS;
+    public static final int _SC_THREAD_ATTR_STACKADDR = OsConstantsHolder._SC_THREAD_ATTR_STACKADDR;
+    public static final int _SC_THREAD_ATTR_STACKSIZE = OsConstantsHolder._SC_THREAD_ATTR_STACKSIZE;
+    public static final int _SC_THREAD_DESTRUCTOR_ITERATIONS = OsConstantsHolder._SC_THREAD_DESTRUCTOR_ITERATIONS;
+    public static final int _SC_THREAD_KEYS_MAX = OsConstantsHolder._SC_THREAD_KEYS_MAX;
+    public static final int _SC_THREAD_PRIORITY_SCHEDULING = OsConstantsHolder._SC_THREAD_PRIORITY_SCHEDULING;
+    public static final int _SC_THREAD_PRIO_INHERIT = OsConstantsHolder._SC_THREAD_PRIO_INHERIT;
+    public static final int _SC_THREAD_PRIO_PROTECT = OsConstantsHolder._SC_THREAD_PRIO_PROTECT;
+    public static final int _SC_THREAD_SAFE_FUNCTIONS = OsConstantsHolder._SC_THREAD_SAFE_FUNCTIONS;
+    public static final int _SC_THREAD_STACK_MIN = OsConstantsHolder._SC_THREAD_STACK_MIN;
+    public static final int _SC_THREAD_THREADS_MAX = OsConstantsHolder._SC_THREAD_THREADS_MAX;
+    public static final int _SC_TIMERS = OsConstantsHolder._SC_TIMERS;
+    public static final int _SC_TIMER_MAX = OsConstantsHolder._SC_TIMER_MAX;
+    public static final int _SC_TTY_NAME_MAX = OsConstantsHolder._SC_TTY_NAME_MAX;
+    public static final int _SC_TZNAME_MAX = OsConstantsHolder._SC_TZNAME_MAX;
+    public static final int _SC_VERSION = OsConstantsHolder._SC_VERSION;
+    public static final int _SC_XBS5_ILP32_OFF32 = OsConstantsHolder._SC_XBS5_ILP32_OFF32;
+    public static final int _SC_XBS5_ILP32_OFFBIG = OsConstantsHolder._SC_XBS5_ILP32_OFFBIG;
+    public static final int _SC_XBS5_LP64_OFF64 = OsConstantsHolder._SC_XBS5_LP64_OFF64;
+    public static final int _SC_XBS5_LPBIG_OFFBIG = OsConstantsHolder._SC_XBS5_LPBIG_OFFBIG;
+    public static final int _SC_XOPEN_CRYPT = OsConstantsHolder._SC_XOPEN_CRYPT;
+    public static final int _SC_XOPEN_ENH_I18N = OsConstantsHolder._SC_XOPEN_ENH_I18N;
+    public static final int _SC_XOPEN_LEGACY = OsConstantsHolder._SC_XOPEN_LEGACY;
+    public static final int _SC_XOPEN_REALTIME = OsConstantsHolder._SC_XOPEN_REALTIME;
+    public static final int _SC_XOPEN_REALTIME_THREADS = OsConstantsHolder._SC_XOPEN_REALTIME_THREADS;
+    public static final int _SC_XOPEN_SHM = OsConstantsHolder._SC_XOPEN_SHM;
+    public static final int _SC_XOPEN_UNIX = OsConstantsHolder._SC_XOPEN_UNIX;
+    public static final int _SC_XOPEN_VERSION = OsConstantsHolder._SC_XOPEN_VERSION;
+    public static final int _SC_XOPEN_XCU_VERSION = OsConstantsHolder._SC_XOPEN_XCU_VERSION;
 
     /**
      * Returns the string name of a getaddrinfo(3) error value.
@@ -1293,14 +1306,512 @@ public final class OsConstants {
         return null;
     }
 
-    @UnsupportedAppUsage
-    private static native void initConstants();
-
-    // A hack to avoid these constants being inlined by javac...
-    @UnsupportedAppUsage
-    private static int placeholder() { return 0; }
-    // ...because we want to initialize them at runtime.
     static {
-        initConstants();
+        // Setting values of these fields at their definition site will make metalava expose them
+        // in the APIs. A sensible Linux port is unlikely to change values of these constants.
+        // However, on macOS AF_INET6 is 30. macOS support was dropped, but I am using that as an
+        // excuse to not promise more than we currently do.
+
+        // These values are taken from include/linux/socket.h
+        AF_INET = 2;
+        AF_INET6 = 10;
+        AF_NETLINK = 16;
+        AF_PACKET = 17;
+        AF_UNIX = 1;
+        AF_VSOCK = 40;
+        AF_UNSPEC = 0;
+
+        ARPHRD_ETHER = 1;
+        ARPHRD_LOOPBACK = 772;
+
+        VMADDR_PORT_ANY = -1;
+        VMADDR_CID_ANY = -1;
+        VMADDR_CID_LOCAL = 1;
+        VMADDR_CID_HOST = 2;
+
+        CAP_AUDIT_CONTROL = 30;
+        CAP_AUDIT_WRITE = 29;
+        CAP_BLOCK_SUSPEND = 36;
+        CAP_CHOWN = 0;
+        CAP_DAC_OVERRIDE = 1;
+        CAP_DAC_READ_SEARCH = 2;
+        CAP_FOWNER = 3;
+        CAP_FSETID = 4;
+        CAP_IPC_LOCK = 14;
+        CAP_IPC_OWNER = 15;
+        CAP_KILL = 5;
+        CAP_LAST_CAP = 40;
+        CAP_LEASE = 28;
+        CAP_LINUX_IMMUTABLE = 9;
+        CAP_MAC_ADMIN = 33;
+        CAP_MAC_OVERRIDE = 32;
+        CAP_MKNOD = 27;
+        CAP_NET_ADMIN = 12;
+        CAP_NET_BIND_SERVICE = 10;
+        CAP_NET_BROADCAST = 11;
+        CAP_NET_RAW = 13;
+        CAP_SETFCAP = 31;
+        CAP_SETGID = 6;
+        CAP_SETPCAP = 8;
+        CAP_SETUID = 7;
+        CAP_SYS_ADMIN = 21;
+        CAP_SYS_BOOT = 22;
+        CAP_SYS_CHROOT = 18;
+        CAP_SYSLOG = 34;
+        CAP_SYS_MODULE = 16;
+        CAP_SYS_NICE = 23;
+        CAP_SYS_PACCT = 20;
+        CAP_SYS_PTRACE = 19;
+        CAP_SYS_RAWIO = 17;
+        CAP_SYS_RESOURCE = 24;
+        CAP_SYS_TIME = 25;
+        CAP_SYS_TTY_CONFIG = 26;
+        CAP_WAKE_ALARM = 35;
+        _LINUX_CAPABILITY_VERSION_3 = 0x20080522;
+
+        // Defined in POSIX: https://pubs.opengroup.org/onlinepubs/9799919799/functions/stdin.html
+        STDIN_FILENO = 0;
+        STDOUT_FILENO = 1;
+        STDERR_FILENO = 2;
+
+        // include/uapi/asm-generic/errno.h and include/uapi/asm-generic/errno-base.h
+        // ENOTSUP is not mentioned there, but on Linux it is the same as EOPNOTSUPP.
+        E2BIG = 7;
+        EACCES = 13;
+        EADDRINUSE = 98;
+        EADDRNOTAVAIL = 99;
+        EAFNOSUPPORT = 97;
+        EAGAIN = 11;
+        EALREADY = 114;
+        EBADF = 9;
+        EBADMSG = 74;
+        EBUSY = 16;
+        ECANCELED = 125;
+        ECHILD = 10;
+        ECONNABORTED = 103;
+        ECONNREFUSED = 111;
+        ECONNRESET = 104;
+        EDEADLK = 35;
+        EDESTADDRREQ = 89;
+        EDOM = 33;
+        EDQUOT = 122;
+        EEXIST = 17;
+        EFAULT = 14;
+        EFBIG = 27;
+        EHOSTUNREACH = 113;
+        EIDRM = 43;
+        EILSEQ = 84;
+        EINPROGRESS = 115;
+        EINTR = 4;
+        EINVAL = 22;
+        EIO = 5;
+        EISCONN = 106;
+        EISDIR = 21;
+        ELOOP = 40;
+        EMFILE = 24;
+        EMLINK = 31;
+        EMSGSIZE = 90;
+        EMULTIHOP = 72;
+        ENAMETOOLONG = 36;
+        ENETDOWN = 100;
+        ENETRESET = 102;
+        ENETUNREACH = 101;
+        ENFILE = 23;
+        ENOBUFS = 105;
+        ENODATA = 61;
+        ENODEV = 19;
+        ENOENT = 2;
+        ENOEXEC = 8;
+        ENOLCK = 37;
+        ENOLINK = 67;
+        ENOMEM = 12;
+        ENOMSG = 42;
+        ENONET = 64;
+        ENOPROTOOPT = 92;
+        ENOSPC = 28;
+        ENOSR = 63;
+        ENOSTR = 60;
+        ENOSYS = 38;
+        ENOTCONN = 107;
+        ENOTDIR = 20;
+        ENOTEMPTY = 39;
+        ENOTSOCK = 88;
+        ENOTSUP = 95;
+        ENOTTY = 25;
+        ENXIO = 6;
+        EOPNOTSUPP = 95;
+        EOVERFLOW = 75;
+        EPERM = 1;
+        EPIPE = 32;
+        EPROTO = 71;
+        EPROTONOSUPPORT = 93;
+        EPROTOTYPE = 91;
+        ERANGE = 34;
+        EROFS = 30;
+        ESPIPE = 29;
+        ESRCH = 3;
+        ESTALE = 116;
+        ETIME = 62;
+        ETIMEDOUT = 110;
+        ETXTBSY = 26;
+        EUSERS = 87;
+        EXDEV = 18;
+
+        // Defined in POSIX.
+        EXIT_SUCCESS = 0;
+        // POSIX only says that it is "between 1 and 255", but in practice it is always 1.
+        EXIT_FAILURE = 1;
+
+        ETH_P_ALL = 0x0003;
+        ETH_P_ARP = 0x0806;
+        ETH_P_IP = 0x0800;
+        ETH_P_IPV6 = 0x86DD;
+
+        FD_CLOEXEC = 1;
+        FIONREAD = 21531;
+        F_DUPFD = 0;
+        F_DUPFD_CLOEXEC = 1030;
+        F_GETFD = 1;
+        F_GETFL = 3;
+        F_GETOWN = 9;
+        F_OK = 0;
+        R_OK = 4;
+        F_RDLCK = 0;
+        F_SETFD = 2;
+        F_SETFL = 4;
+        F_SETOWN = 8;
+        F_UNLCK = 2;
+        F_WRLCK = 1;
+
+        ICMP_ECHO = 8;
+        ICMP_ECHOREPLY = 0;
+        // These valued are defined in https://datatracker.ietf.org/doc/html/rfc2463.
+        ICMP6_ECHO_REQUEST = 128;
+        ICMP6_ECHO_REPLY = 129;
+
+        IFA_F_DADFAILED = 8;
+        IFA_F_DEPRECATED = 32;
+        IFA_F_HOMEADDRESS = 16;
+        IFA_F_MANAGETEMPADDR = 256;
+        IFA_F_NODAD = 2;
+        IFA_F_NOPREFIXROUTE = 512;
+        IFA_F_OPTIMISTIC = 4;
+        IFA_F_PERMANENT = 128;
+        IFA_F_SECONDARY = 1;
+        IFA_F_TEMPORARY = 1;
+        IFA_F_TENTATIVE = 64;
+
+        IFF_ALLMULTI = 512;
+        IFF_AUTOMEDIA = 16384;
+        IFF_BROADCAST = 2;
+        IFF_DEBUG = 4;
+        IFF_DYNAMIC = 32768;
+        IFF_LOOPBACK = 8;
+        IFF_MASTER = 1024;
+        IFF_MULTICAST = 4096;
+        IFF_NOARP = 128;
+        IFF_NOTRAILERS = 32;
+        IFF_POINTOPOINT = 16;
+        IFF_PORTSEL = 8192;
+        IFF_PROMISC = 256;
+        IFF_RUNNING = 64;
+        IFF_SLAVE = 2048;
+        IFF_UP = 1;
+
+        IPPROTO_ICMP = 1;
+        IPPROTO_ICMPV6 = 58;
+        IPPROTO_IP = 0;
+        IPPROTO_IPV6 = 41;
+        IPPROTO_RAW = 255;
+        IPPROTO_TCP = 6;
+        IPPROTO_UDP = 17;
+        IPPROTO_ESP = 50;
+        IPV6_CHECKSUM = 7;
+        IPV6_MULTICAST_HOPS = 18;
+        IPV6_MULTICAST_IF = 17;
+        IPV6_MULTICAST_LOOP = 19;
+        IPV6_PKTINFO = 50;
+        IPV6_RECVDSTOPTS = 58;
+        IPV6_RECVHOPLIMIT = 51;
+        IPV6_RECVHOPOPTS = 53;
+        IPV6_RECVPKTINFO = 49;
+        IPV6_RECVRTHDR = 56;
+        IPV6_RECVTCLASS = 66;
+        IPV6_TCLASS = 67;
+        IPV6_UNICAST_HOPS = 16;
+        IPV6_V6ONLY = 26;
+        IP_MULTICAST_ALL = 49;
+        IP_MULTICAST_IF = 32;
+        IP_MULTICAST_LOOP = 34;
+        IP_MULTICAST_TTL = 33;
+        IP_RECVTOS = 13;
+        IP_TOS = 1;
+        IP_TTL = 2;
+
+        MADV_NORMAL = 0;
+        MADV_RANDOM = 1;
+        MADV_SEQUENTIAL = 2;
+        MADV_WILLNEED = 3;
+        MADV_DONTNEED = 4;
+        MADV_REMOVE = 9;
+        MADV_DONTFORK = 10;
+        MADV_DOFORK = 11;
+        MADV_HWPOISON = 100;
+        MADV_MERGEABLE = 12;
+        MADV_UNMERGEABLE = 13;
+        MADV_SOFT_OFFLINE = 101;
+        MADV_HUGEPAGE = 14;
+        MADV_NOHUGEPAGE = 15;
+        MADV_COLLAPSE = 25;
+        MADV_DONTDUMP = 16;
+        MADV_DODUMP = 17;
+        MADV_FREE = 8;
+        MADV_WIPEONFORK = 18;
+        MADV_KEEPONFORK = 19;
+        MADV_COLD = 20;
+        MADV_PAGEOUT = 21;
+        MADV_POPULATE_READ = 22;
+        MADV_POPULATE_WRITE = 23;
+
+        MAP_FIXED = 16;
+        MAP_ANONYMOUS = 32;
+        MAP_POPULATE = 32768;
+        MAP_PRIVATE = 2;
+        MAP_SHARED = 1;
+
+        MCAST_JOIN_GROUP = 42;
+        MCAST_LEAVE_GROUP = 45;
+        MCAST_JOIN_SOURCE_GROUP = 46;
+        MCAST_LEAVE_SOURCE_GROUP = 47;
+        MCAST_BLOCK_SOURCE = 43;
+        MCAST_UNBLOCK_SOURCE = 44;
+
+        MCL_CURRENT = 1;
+        MCL_FUTURE = 2;
+
+        MFD_CLOEXEC = 1;
+
+        MSG_CTRUNC = 8;
+        MSG_DONTROUTE = 4;
+        MSG_EOR = 128;
+        MSG_OOB = 1;
+        MSG_PEEK = 2;
+        MSG_TRUNC = 32;
+        MSG_WAITALL = 256;
+
+        MS_ASYNC = 1;
+        MS_INVALIDATE = 2;
+        MS_SYNC = 4;
+
+        NETLINK_NETFILTER = 12;
+        NETLINK_ROUTE = 0;
+        NETLINK_INET_DIAG = 4;
+        NETLINK_XFRM = 6;
+
+        NI_DGRAM = 16;
+
+        O_ACCMODE = 3;
+        O_APPEND = 1024;
+        O_CLOEXEC = 524288;
+        O_CREAT = 64;
+        O_EXCL = 128;
+        O_NOCTTY = 256;
+        O_NONBLOCK = 2048;
+        O_RDONLY = 0;
+        O_RDWR = 2;
+        O_SYNC = 1052672;
+        O_DSYNC = 4096;
+        O_TRUNC = 512;
+        O_WRONLY = 1;
+
+        POLLERR = 8;
+        POLLHUP = 16;
+        POLLIN = 1;
+        POLLNVAL = 32;
+        POLLOUT = 4;
+        POLLPRI = 2;
+        POLLRDBAND = 128;
+        POLLRDNORM = 64;
+        POLLWRBAND = 512;
+        POLLWRNORM = 256;
+
+        PR_CAP_AMBIENT = 47;
+        PR_CAP_AMBIENT_RAISE = 2;
+        PR_GET_DUMPABLE = 3;
+        PR_SET_DUMPABLE = 4;
+        PR_SET_NO_NEW_PRIVS = 38;
+
+        PROT_EXEC = 4;
+        PROT_NONE = 0;
+        PROT_READ = 1;
+        PROT_WRITE = 2;
+
+        RLIMIT_NOFILE = 7;
+        RLIMIT_RTPRIO = 14;
+
+        RT_SCOPE_HOST = 254;
+        RT_SCOPE_LINK = 253;
+        RT_SCOPE_NOWHERE = 255;
+        RT_SCOPE_SITE = 200;
+        RT_SCOPE_UNIVERSE = 0;
+
+        RTMGRP_IPV4_IFADDR = 16;
+        RTMGRP_IPV4_MROUTE = 32;
+        RTMGRP_IPV4_ROUTE = 64;
+        RTMGRP_IPV4_RULE = 128;
+        RTMGRP_IPV6_IFADDR = 256;
+        RTMGRP_IPV6_IFINFO = 2048;
+        RTMGRP_IPV6_MROUTE = 512;
+        RTMGRP_IPV6_PREFIX = 131072;
+        RTMGRP_IPV6_ROUTE = 1024;
+        RTMGRP_LINK = 1;
+        RTMGRP_NEIGH = 4;
+        RTMGRP_NOTIFY = 2;
+        RTMGRP_TC = 8;
+
+        SEEK_CUR = 1;
+        SEEK_END = 2;
+        SEEK_SET = 0;
+
+        SHUT_RD = 0;
+        SHUT_RDWR = 2;
+        SHUT_WR = 1;
+
+        SIGABRT = 6;
+        SIGALRM = 14;
+        SIGBUS = 7;
+        SIGCHLD = 17;
+        SIGCONT = 18;
+        SIGFPE = 8;
+        SIGHUP = 1;
+        SIGILL = 4;
+        SIGINT = 2;
+        SIGIO = 29;
+        SIGKILL = 9;
+        SIGPIPE = 13;
+        SIGPROF = 27;
+        SIGPWR = 30;
+        SIGQUIT = 3;
+        SIGRTMAX = 64;
+        SIGSEGV = 11;
+        SIGSTKFLT = 16;
+        SIGSTOP = 19;
+        SIGSYS = 31;
+        SIGTERM = 15;
+        SIGTRAP = 5;
+        SIGTSTP = 20;
+        SIGTTIN = 21;
+        SIGTTOU = 22;
+        SIGURG = 23;
+        SIGUSR1 = 10;
+        SIGUSR2 = 12;
+        SIGVTALRM = 26;
+        SIGWINCH = 28;
+        SIGXCPU = 24;
+        SIGXFSZ = 25;
+
+        SIOCGIFADDR = 35093;
+        SIOCGIFBRDADDR = 35097;
+        SIOCGIFDSTADDR = 35095;
+        SIOCGIFNETMASK = 35099;
+
+        SOCK_CLOEXEC = 524288;
+        SOCK_DGRAM = 2;
+        SOCK_NONBLOCK = 2048;
+        SOCK_RAW = 3;
+        SOCK_SEQPACKET = 5;
+        SOCK_STREAM = 1;
+
+        SOL_SOCKET = 1;
+        SOL_UDP = 17;
+        SOL_PACKET = 263;
+
+        SO_BINDTODEVICE = 25;
+        SO_BROADCAST = 6;
+        SO_DEBUG = 1;
+        SO_DOMAIN = 39;
+        SO_DONTROUTE = 5;
+        SO_ERROR = 4;
+        SO_KEEPALIVE = 9;
+        SO_LINGER = 13;
+        SO_OOBINLINE = 10;
+        SO_PASSCRED = 16;
+        SO_PEERCRED = 17;
+        SO_PROTOCOL = 38;
+        SO_RCVBUF = 8;
+        SO_RCVLOWAT = 18;
+        SO_RCVTIMEO = 20;
+        SO_REUSEADDR = 2;
+        SO_SNDBUF = 7;
+        SO_SNDLOWAT = 19;
+        SO_SNDTIMEO = 21;
+        SO_TYPE = 3;
+
+        PACKET_IGNORE_OUTGOING = 23;
+
+        SPLICE_F_MOVE = 1;
+        SPLICE_F_NONBLOCK = 2;
+        SPLICE_F_MORE = 4;
+
+        ST_MANDLOCK = 64;
+        ST_NOATIME = 1024;
+        ST_NODEV = 4;
+        ST_NODIRATIME = 2048;
+        ST_NOEXEC = 8;
+        ST_NOSUID = 2;
+        ST_RDONLY = 1;
+        ST_RELATIME = 4096;
+        ST_SYNCHRONOUS = 16;
+
+        S_IFBLK = 24576;
+        S_IFCHR = 8192;
+        S_IFDIR = 16384;
+        S_IFIFO = 4096;
+        S_IFLNK = 40960;
+        S_IFMT = 61440;
+        S_IFREG = 32768;
+        S_IFSOCK = 49152;
+        S_IRGRP = 32;
+        S_IROTH = 4;
+        S_IRUSR = 256;
+        S_IRWXG = 56;
+        S_IRWXO = 7;
+        S_IRWXU = 448;
+        S_ISGID = 1024;
+        S_ISUID = 2048;
+        S_ISVTX = 512;
+        S_IWGRP = 16;
+        S_IWOTH = 2;
+        S_IWUSR = 128;
+        S_IXGRP = 8;
+        S_IXOTH = 1;
+        S_IXUSR = 64;
+
+        TCP_NODELAY = 1;
+        TCP_USER_TIMEOUT = 18;
+
+        UDP_GRO = 104;
+        UDP_SEGMENT = 103;
+
+        TIOCOUTQ = 21521;
+
+        UDP_ENCAP = 100;
+        UDP_ENCAP_ESPINUDP_NON_IKE = 1;
+        UDP_ENCAP_ESPINUDP = 2;
+
+        // sizeof(sockaddr_un::sun_path).
+        UNIX_PATH_MAX = 108;
+
+        WCONTINUED = 8;
+        WEXITED = 4;
+        WNOHANG = 1;
+        WNOWAIT = 16777216;
+        WSTOPPED = 2;
+        WUNTRACED = 2;
+        W_OK = 2;
+
+        XATTR_CREATE = 1;
+        XATTR_REPLACE = 2;
+        X_OK = 1;
     }
 }
diff --git a/luni/src/main/java/android/system/OsConstantsHolder.java b/luni/src/main/java/android/system/OsConstantsHolder.java
new file mode 100644
index 00000000000..39e93086334
--- /dev/null
+++ b/luni/src/main/java/android/system/OsConstantsHolder.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.system;
+
+/**
+ * To see why this class exists read the comment near {@link OsConstants#AF_INET}
+ * (the first field of that class).
+ *
+ * @hide
+ */
+final class OsConstantsHolder {
+
+    static int AI_ADDRCONFIG;
+    static int AI_ALL;
+    static int AI_CANONNAME;
+    static int AI_NUMERICHOST;
+    static int AI_NUMERICSERV;
+    static int AI_PASSIVE;
+    static int AI_V4MAPPED;
+
+    static int EAI_AGAIN;
+    static int EAI_BADFLAGS;
+    static int EAI_FAIL;
+    static int EAI_FAMILY;
+    static int EAI_MEMORY;
+    static int EAI_NODATA;
+    static int EAI_NONAME;
+    static int EAI_OVERFLOW;
+    static int EAI_SERVICE;
+    static int EAI_SOCKTYPE;
+    static int EAI_SYSTEM;
+
+    static int F_GETLK;
+    static int F_GETLK64;
+    static int F_SETLK;
+    static int F_SETLK64;
+    static int F_SETLKW;
+    static int F_SETLKW64;
+
+    static int NI_NAMEREQD;
+    static int NI_NOFQDN;
+    static int NI_NUMERICHOST;
+    static int NI_NUMERICSERV;
+
+    static int O_DIRECT;
+    static int O_NOFOLLOW;
+
+    static int SIGRTMIN;
+
+    static int _SC_2_CHAR_TERM;
+    static int _SC_2_C_BIND;
+    static int _SC_2_C_DEV;
+    static int _SC_2_C_VERSION;
+    static int _SC_2_FORT_DEV;
+    static int _SC_2_FORT_RUN;
+    static int _SC_2_LOCALEDEF;
+    static int _SC_2_SW_DEV;
+    static int _SC_2_UPE;
+    static int _SC_2_VERSION;
+    static int _SC_AIO_LISTIO_MAX;
+    static int _SC_AIO_MAX;
+    static int _SC_AIO_PRIO_DELTA_MAX;
+    static int _SC_ARG_MAX;
+    static int _SC_ASYNCHRONOUS_IO;
+    static int _SC_ATEXIT_MAX;
+    static int _SC_AVPHYS_PAGES;
+    static int _SC_BC_BASE_MAX;
+    static int _SC_BC_DIM_MAX;
+    static int _SC_BC_SCALE_MAX;
+    static int _SC_BC_STRING_MAX;
+    static int _SC_CHILD_MAX;
+    static int _SC_CLK_TCK;
+    static int _SC_COLL_WEIGHTS_MAX;
+    static int _SC_DELAYTIMER_MAX;
+    static int _SC_EXPR_NEST_MAX;
+    static int _SC_FSYNC;
+    static int _SC_GETGR_R_SIZE_MAX;
+    static int _SC_GETPW_R_SIZE_MAX;
+    static int _SC_IOV_MAX;
+    static int _SC_JOB_CONTROL;
+    static int _SC_LINE_MAX;
+    static int _SC_LOGIN_NAME_MAX;
+    static int _SC_MAPPED_FILES;
+    static int _SC_MEMLOCK;
+    static int _SC_MEMLOCK_RANGE;
+    static int _SC_MEMORY_PROTECTION;
+    static int _SC_MESSAGE_PASSING;
+    static int _SC_MQ_OPEN_MAX;
+    static int _SC_MQ_PRIO_MAX;
+    static int _SC_NGROUPS_MAX;
+    static int _SC_NPROCESSORS_CONF;
+    static int _SC_NPROCESSORS_ONLN;
+    static int _SC_OPEN_MAX;
+    static int _SC_PAGESIZE;
+    static int _SC_PAGE_SIZE;
+    static int _SC_PASS_MAX;
+    static int _SC_PHYS_PAGES;
+    static int _SC_PRIORITIZED_IO;
+    static int _SC_PRIORITY_SCHEDULING;
+    static int _SC_REALTIME_SIGNALS;
+    static int _SC_RE_DUP_MAX;
+    static int _SC_RTSIG_MAX;
+    static int _SC_SAVED_IDS;
+    static int _SC_SEMAPHORES;
+    static int _SC_SEM_NSEMS_MAX;
+    static int _SC_SEM_VALUE_MAX;
+    static int _SC_SHARED_MEMORY_OBJECTS;
+    static int _SC_SIGQUEUE_MAX;
+    static int _SC_STREAM_MAX;
+    static int _SC_SYNCHRONIZED_IO;
+    static int _SC_THREADS;
+    static int _SC_THREAD_ATTR_STACKADDR;
+    static int _SC_THREAD_ATTR_STACKSIZE;
+    static int _SC_THREAD_DESTRUCTOR_ITERATIONS;
+    static int _SC_THREAD_KEYS_MAX;
+    static int _SC_THREAD_PRIORITY_SCHEDULING;
+    static int _SC_THREAD_PRIO_INHERIT;
+    static int _SC_THREAD_PRIO_PROTECT;
+    static int _SC_THREAD_SAFE_FUNCTIONS;
+    static int _SC_THREAD_STACK_MIN;
+    static int _SC_THREAD_THREADS_MAX;
+    static int _SC_TIMERS;
+    static int _SC_TIMER_MAX;
+    static int _SC_TTY_NAME_MAX;
+    static int _SC_TZNAME_MAX;
+    static int _SC_VERSION;
+    static int _SC_XBS5_ILP32_OFF32;
+    static int _SC_XBS5_ILP32_OFFBIG;
+    static int _SC_XBS5_LP64_OFF64;
+    static int _SC_XBS5_LPBIG_OFFBIG;
+    static int _SC_XOPEN_CRYPT;
+    static int _SC_XOPEN_ENH_I18N;
+    static int _SC_XOPEN_LEGACY;
+    static int _SC_XOPEN_REALTIME;
+    static int _SC_XOPEN_REALTIME_THREADS;
+    static int _SC_XOPEN_SHM;
+    static int _SC_XOPEN_UNIX;
+    static int _SC_XOPEN_VERSION;
+    static int _SC_XOPEN_XCU_VERSION;
+
+    private static native void initConstants();
+
+    static {
+        initConstants();
+    }
+}
diff --git a/luni/src/main/java/android/system/StructDlInfo.java b/luni/src/main/java/android/system/StructDlInfo.java
new file mode 100644
index 00000000000..a7f6279ff48
--- /dev/null
+++ b/luni/src/main/java/android/system/StructDlInfo.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.system;
+
+import libcore.util.Objects;
+
+/**
+ * Corresponds to C's {@code struct Dl_info}.
+ */
+@android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_OPENJDK_21_V2_APIS)
+public final class StructDlInfo {
+    /** Pathname of shared object that contains address */
+    public final String dli_fname;
+    /** Base address at which shared object is loaded */
+    public final long dli_fbase;
+    /** Name of symbol whose definition overlaps addr */
+    public final String dli_sname;
+    /** Exact address of symbol named in dli_sname */
+    public final long dli_saddr;
+
+    public StructDlInfo(String dli_fname, long dli_fbase, String dli_sname, long dli_saddr) {
+        this.dli_fname = dli_fname;
+        this.dli_fbase = dli_fbase;
+        this.dli_sname = dli_sname;
+        this.dli_saddr = dli_saddr;
+    }
+
+    @Override
+    public String toString() {
+        return Objects.toString(this);
+    }
+}
diff --git a/luni/src/main/java/libcore/io/ForwardingOs.java b/luni/src/main/java/libcore/io/ForwardingOs.java
index 91fb57661b8..c086bbd3fa7 100644
--- a/luni/src/main/java/libcore/io/ForwardingOs.java
+++ b/luni/src/main/java/libcore/io/ForwardingOs.java
@@ -25,6 +25,7 @@ import android.system.Int64Ref;
 import android.system.StructAddrinfo;
 import android.system.StructCapUserData;
 import android.system.StructCapUserHeader;
+import android.system.StructDlInfo;
 import android.system.StructGroupReq;
 import android.system.StructIfaddrs;
 import android.system.StructLinger;
@@ -205,6 +206,11 @@ public class ForwardingOs implements Os {
      */
     public void connect(FileDescriptor fd, SocketAddress address) throws ErrnoException, SocketException { os.connect(fd, address); }
 
+    /**
+     * @hide
+     */
+    public StructDlInfo dladdr(long addr) { return os.dladdr(addr); }
+
     /**
      * @hide
      */
diff --git a/luni/src/main/java/libcore/io/Linux.java b/luni/src/main/java/libcore/io/Linux.java
index 6c759376dc9..c0ff5e1cf35 100644
--- a/luni/src/main/java/libcore/io/Linux.java
+++ b/luni/src/main/java/libcore/io/Linux.java
@@ -23,6 +23,7 @@ import android.system.Int64Ref;
 import android.system.StructAddrinfo;
 import android.system.StructCapUserData;
 import android.system.StructCapUserHeader;
+import android.system.StructDlInfo;
 import android.system.StructGroupReq;
 import android.system.StructIfaddrs;
 import android.system.StructLinger;
@@ -71,6 +72,7 @@ public final class Linux implements Os {
 
     public native void connect(FileDescriptor fd, InetAddress address, int port) throws ErrnoException, SocketException;
     public native void connect(FileDescriptor fd, SocketAddress address) throws ErrnoException, SocketException;
+    public native StructDlInfo dladdr(long addr);
     public native FileDescriptor dup(FileDescriptor oldFd) throws ErrnoException;
     public native FileDescriptor dup2(FileDescriptor oldFd, int newFd) throws ErrnoException;
     public native String[] environ();
diff --git a/luni/src/main/java/libcore/io/Os.java b/luni/src/main/java/libcore/io/Os.java
index 7a6b69b581b..6e7d4b3d11f 100644
--- a/luni/src/main/java/libcore/io/Os.java
+++ b/luni/src/main/java/libcore/io/Os.java
@@ -25,6 +25,7 @@ import android.system.Int64Ref;
 import android.system.StructAddrinfo;
 import android.system.StructCapUserData;
 import android.system.StructCapUserHeader;
+import android.system.StructDlInfo;
 import android.system.StructGroupReq;
 import android.system.StructIfaddrs;
 import android.system.StructLinger;
@@ -145,6 +146,11 @@ public interface Os {
      */
     public void connect(FileDescriptor fd, SocketAddress address) throws ErrnoException, SocketException;
 
+    /**
+     * @hide
+     */
+    public StructDlInfo dladdr(long addr);
+
     /**
      * @hide
      */
diff --git a/luni/src/main/java/libcore/util/NativeAllocationRegistry.java b/luni/src/main/java/libcore/util/NativeAllocationRegistry.java
index ed1053d1f45..7985080a92b 100644
--- a/luni/src/main/java/libcore/util/NativeAllocationRegistry.java
+++ b/luni/src/main/java/libcore/util/NativeAllocationRegistry.java
@@ -549,7 +549,7 @@ public class NativeAllocationRegistry {
 
         // Only for error reporting.
         @Override public String toString() {
-            return super.toString() + "(freeFunction = 0x" + Long.toHexString(freeFunction)
+            return super.toString() + "(freeFunction = " + dlAddr(freeFunction)
                 + ", nativePtr = 0x" + Long.toHexString(nativePtr) + ", size = " + size + ")";
         }
     }
@@ -611,5 +611,11 @@ public class NativeAllocationRegistry {
      */
     @SystemApi(client = MODULE_LIBRARIES)
     public static native void applyFreeFunction(long freeFunction, long nativePtr);
+
+    /**
+     * Return a String description of freeFunction, preferring a symbolic representation when
+     * possible.
+     */
+    private static native String dlAddr(long freeFunction);
 }
 
diff --git a/luni/src/main/native/Android.bp b/luni/src/main/native/Android.bp
index 8c83f3b60ff..b6c6efd1528 100644
--- a/luni/src/main/native/Android.bp
+++ b/luni/src/main/native/Android.bp
@@ -33,10 +33,8 @@ filegroup {
         "JniException.cpp",
         "NetworkUtilities.cpp",
         "Register.cpp",
-        "ZipUtilities.cpp",
-        "android_system_OsConstants.cpp",
+        "android_system_OsConstantsHolder.cpp",
         "cbigint.cpp",
-        "java_lang_StringToReal.cpp",
         "java_lang_invoke_MethodHandle.cpp",
         "java_lang_invoke_VarHandle.cpp",
         "libcore_math_NativeBN.cpp",
@@ -46,8 +44,6 @@ filegroup {
         "libcore_io_Memory.cpp",
         "libcore_util_NativeAllocationRegistry.cpp",
         "org_apache_harmony_xml_ExpatParser.cpp",
-        "sun_misc_Unsafe.cpp",
-        "valueOf.cpp",
     ],
 }
 
diff --git a/luni/src/main/native/JniConstants.cpp b/luni/src/main/native/JniConstants.cpp
index 0992e553dd8..45e1bb0110e 100644
--- a/luni/src/main/native/JniConstants.cpp
+++ b/luni/src/main/native/JniConstants.cpp
@@ -67,6 +67,7 @@ static bool g_constants_valid = false;
     V(StringClass, "java/lang/String")                                                      \
     V(StructAddrinfoClass, "android/system/StructAddrinfo")                                 \
     V(StructCmsghdrClass, "android/system/StructCmsghdr")                                   \
+    V(StructDlInfoClass, "android/system/StructDlInfo")                                     \
     V(StructGroupReqClass, "android/system/StructGroupReq")                                 \
     V(StructIfaddrsClass, "android/system/StructIfaddrs")                                   \
     V(StructLingerClass, "android/system/StructLinger")                                     \
diff --git a/luni/src/main/native/JniConstants.h b/luni/src/main/native/JniConstants.h
index bf824b85de4..b34524f0681 100644
--- a/luni/src/main/native/JniConstants.h
+++ b/luni/src/main/native/JniConstants.h
@@ -51,6 +51,7 @@ struct JniConstants {
     static jclass GetStringClass(JNIEnv* env);
     static jclass GetStructAddrinfoClass(JNIEnv* env);
     static jclass GetStructCmsghdrClass(JNIEnv* env);
+    static jclass GetStructDlInfoClass(JNIEnv* env);
     static jclass GetStructFlockClass(JNIEnv* env);
     static jclass GetStructGroupReqClass(JNIEnv* env);
     static jclass GetStructIfaddrsClass(JNIEnv* env);
diff --git a/luni/src/main/native/Register.cpp b/luni/src/main/native/Register.cpp
index 91cabf79f20..0950a450206 100644
--- a/luni/src/main/native/Register.cpp
+++ b/luni/src/main/native/Register.cpp
@@ -35,8 +35,7 @@ jint JNI_OnLoad(JavaVM* vm, void*) {
     ScopedLocalFrame localFrame(env);
 
 #define REGISTER(FN) extern void FN(JNIEnv*); FN(env)
-    REGISTER(register_android_system_OsConstants);
-    //    REGISTER(register_java_lang_StringToReal);
+    REGISTER(register_android_system_OsConstantsHolder);
     REGISTER(register_java_lang_invoke_MethodHandle);
     REGISTER(register_java_lang_invoke_VarHandle);
     REGISTER(register_libcore_icu_ICU);
@@ -46,7 +45,6 @@ jint JNI_OnLoad(JavaVM* vm, void*) {
     REGISTER(register_libcore_math_NativeBN);
     REGISTER(register_libcore_util_NativeAllocationRegistry);
     REGISTER(register_org_apache_harmony_xml_ExpatParser);
-    REGISTER(register_sun_misc_Unsafe);
 #undef REGISTER
 
     JniConstants::Initialize(env);
diff --git a/luni/src/main/native/ZipUtilities.cpp b/luni/src/main/native/ZipUtilities.cpp
deleted file mode 100644
index 28a86e2c9a4..00000000000
--- a/luni/src/main/native/ZipUtilities.cpp
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "ZipUtilities.h"
-
-#include <nativehelper/JNIHelp.h>
-
-#include "JniException.h"
-
-void throwExceptionForZlibError(JNIEnv* env, const char* exceptionClassName, int error,
-    NativeZipStream* stream) {
-  if (error == Z_MEM_ERROR) {
-    jniThrowOutOfMemoryError(env, NULL);
-  } else if (stream != NULL && stream->stream.msg != NULL) {
-    jniThrowException(env, exceptionClassName, stream->stream.msg);
-  } else {
-    jniThrowException(env, exceptionClassName, zError(error));
-  }
-}
-
-NativeZipStream::NativeZipStream() : inCap(0), totalIn(0), totalOut(0) {
-  // Let zlib use its default allocator.
-  stream.opaque = Z_NULL;
-  stream.zalloc = Z_NULL;
-  stream.zfree = Z_NULL;
-}
-
-NativeZipStream::~NativeZipStream() {
-}
-
-void NativeZipStream::setDictionary(JNIEnv* env, jbyteArray javaDictionary, int off, int len,
-    bool inflate) {
-  std::unique_ptr<jbyte[]> dictionaryBytes(new(std::nothrow) jbyte[len]);
-  if (dictionaryBytes.get() == NULL) {
-    jniThrowOutOfMemoryError(env, NULL);
-    return;
-  }
-  env->GetByteArrayRegion(javaDictionary, off, len, &dictionaryBytes[0]);
-  const Bytef* dictionary = reinterpret_cast<const Bytef*>(&dictionaryBytes[0]);
-  int err;
-  if (inflate) {
-    err = inflateSetDictionary(&stream, dictionary, len);
-  } else {
-    err = deflateSetDictionary(&stream, dictionary, len);
-  }
-  if (err != Z_OK) {
-    throwExceptionForZlibError(env, "java/lang/IllegalArgumentException", err, NULL);
-    return;
-  }
-  mDict.reset(dictionaryBytes.release());
-}
-
-void NativeZipStream::setInput(JNIEnv* env, jbyteArray buf, jint off, jint len) {
-  input.reset(new(std::nothrow) jbyte[len]);
-  if (input.get() == NULL) {
-    inCap = 0;
-    jniThrowOutOfMemoryError(env, NULL);
-    return;
-  }
-  inCap = len;
-  if (buf != NULL) {
-    env->GetByteArrayRegion(buf, off, len, &input[0]);
-  }
-  stream.next_in = reinterpret_cast<Bytef*>(&input[0]);
-  stream.avail_in = len;
-}
-
-NativeZipStream* toNativeZipStream(jlong address) {
-  return reinterpret_cast<NativeZipStream*>(static_cast<uintptr_t>(address));
-}
diff --git a/luni/src/main/native/ZipUtilities.h b/luni/src/main/native/ZipUtilities.h
deleted file mode 100644
index 08f491a9fd8..00000000000
--- a/luni/src/main/native/ZipUtilities.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ZIP_UTILITIES_H_included
-#define ZIP_UTILITIES_H_included
-
-#include <cstdint>
-#include <memory>
-#include "jni.h"
-#include "zlib.h"
-
-class NativeZipStream {
-public:
-    std::unique_ptr<jbyte[]> input;
-    int inCap;
-    z_stream stream;
-    uint64_t totalIn;
-    uint64_t totalOut;
-
-    NativeZipStream();
-    ~NativeZipStream();
-    void setDictionary(JNIEnv* env, jbyteArray javaDictionary, int off, int len, bool inflate);
-    void setInput(JNIEnv* env, jbyteArray buf, jint off, jint len);
-
-private:
-    std::unique_ptr<jbyte[]> mDict;
-
-    // Disallow copy and assignment.
-    NativeZipStream(const NativeZipStream&);
-    void operator=(const NativeZipStream&);
-};
-
-NativeZipStream* toNativeZipStream(jlong address);
-
-void throwExceptionForZlibError(JNIEnv* env, const char* exceptionClassName, int error,
-        NativeZipStream* stream);
-
-#endif  // ZIP_UTILITIES_H_included
diff --git a/luni/src/main/native/android_system_OsConstants.cpp b/luni/src/main/native/android_system_OsConstants.cpp
deleted file mode 100644
index cb3ac21abbd..00000000000
--- a/luni/src/main/native/android_system_OsConstants.cpp
+++ /dev/null
@@ -1,641 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "OsConstants"
-
-#include <errno.h>
-#include <fcntl.h>
-#include <netdb.h>
-#include <netinet/icmp6.h>
-#include <netinet/if_ether.h>
-#include <netinet/in.h>
-#include <netinet/ip_icmp.h>
-#include <netinet/tcp.h>
-#include <netinet/udp.h>
-#include <netpacket/packet.h>
-#include <net/if.h>
-#include <net/if_arp.h>
-#include <poll.h>
-#include <signal.h>
-#include <stdlib.h>
-#include <sys/capability.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/prctl.h>
-#include <sys/resource.h>
-#include <sys/socket.h>
-#include <sys/stat.h>
-#include <sys/un.h>
-#include <sys/wait.h>
-#include <sys/xattr.h>
-#include <unistd.h>
-
-#include <linux/if_addr.h>
-#include <linux/rtnetlink.h>
-
-#include <nativehelper/JNIHelp.h>
-#include <nativehelper/jni_macros.h>
-
-#if defined(__GLIBC__)
-// MADV_SOFT_OFFLINE is otherwise unavailable from glibc.
-#include <asm-generic/mman-common.h>
-#endif
-
-#include "Portability.h"
-
-static void initConstant(JNIEnv* env, jclass c, const char* fieldName, int value) {
-    jfieldID field = env->GetStaticFieldID(c, fieldName, "I");
-    env->SetStaticIntField(c, field, value);
-}
-
-static void OsConstants_initConstants(JNIEnv* env, jclass c) {
-    initConstant(env, c, "AF_INET", AF_INET);
-    initConstant(env, c, "AF_INET6", AF_INET6);
-    initConstant(env, c, "AF_PACKET", AF_PACKET);
-    initConstant(env, c, "AF_NETLINK", AF_NETLINK);
-    initConstant(env, c, "AF_UNIX", AF_UNIX);
-    initConstant(env, c, "AF_VSOCK", AF_VSOCK);
-    initConstant(env, c, "AF_UNSPEC", AF_UNSPEC);
-    initConstant(env, c, "AI_ADDRCONFIG", AI_ADDRCONFIG);
-    initConstant(env, c, "AI_ALL", AI_ALL);
-    initConstant(env, c, "AI_CANONNAME", AI_CANONNAME);
-    initConstant(env, c, "AI_NUMERICHOST", AI_NUMERICHOST);
-    initConstant(env, c, "AI_NUMERICSERV", AI_NUMERICSERV);
-    initConstant(env, c, "AI_PASSIVE", AI_PASSIVE);
-    initConstant(env, c, "AI_V4MAPPED", AI_V4MAPPED);
-    initConstant(env, c, "ARPHRD_ETHER", ARPHRD_ETHER);
-    initConstant(env, c, "VMADDR_PORT_ANY", VMADDR_PORT_ANY);
-    initConstant(env, c, "VMADDR_CID_ANY", VMADDR_CID_ANY);
-    initConstant(env, c, "VMADDR_CID_LOCAL", VMADDR_CID_LOCAL);
-    initConstant(env, c, "VMADDR_CID_HOST", VMADDR_CID_HOST);
-    initConstant(env, c, "ARPHRD_LOOPBACK", ARPHRD_LOOPBACK);
-    initConstant(env, c, "CAP_AUDIT_CONTROL", CAP_AUDIT_CONTROL);
-    initConstant(env, c, "CAP_AUDIT_WRITE", CAP_AUDIT_WRITE);
-    initConstant(env, c, "CAP_BLOCK_SUSPEND", CAP_BLOCK_SUSPEND);
-    initConstant(env, c, "CAP_CHOWN", CAP_CHOWN);
-    initConstant(env, c, "CAP_DAC_OVERRIDE", CAP_DAC_OVERRIDE);
-    initConstant(env, c, "CAP_DAC_READ_SEARCH", CAP_DAC_READ_SEARCH);
-    initConstant(env, c, "CAP_FOWNER", CAP_FOWNER);
-    initConstant(env, c, "CAP_FSETID", CAP_FSETID);
-    initConstant(env, c, "CAP_IPC_LOCK", CAP_IPC_LOCK);
-    initConstant(env, c, "CAP_IPC_OWNER", CAP_IPC_OWNER);
-    initConstant(env, c, "CAP_KILL", CAP_KILL);
-    initConstant(env, c, "CAP_LAST_CAP", CAP_LAST_CAP);
-    initConstant(env, c, "CAP_LEASE", CAP_LEASE);
-    initConstant(env, c, "CAP_LINUX_IMMUTABLE", CAP_LINUX_IMMUTABLE);
-    initConstant(env, c, "CAP_MAC_ADMIN", CAP_MAC_ADMIN);
-    initConstant(env, c, "CAP_MAC_OVERRIDE", CAP_MAC_OVERRIDE);
-    initConstant(env, c, "CAP_MKNOD", CAP_MKNOD);
-    initConstant(env, c, "CAP_NET_ADMIN", CAP_NET_ADMIN);
-    initConstant(env, c, "CAP_NET_BIND_SERVICE", CAP_NET_BIND_SERVICE);
-    initConstant(env, c, "CAP_NET_BROADCAST", CAP_NET_BROADCAST);
-    initConstant(env, c, "CAP_NET_RAW", CAP_NET_RAW);
-    initConstant(env, c, "CAP_SETFCAP", CAP_SETFCAP);
-    initConstant(env, c, "CAP_SETGID", CAP_SETGID);
-    initConstant(env, c, "CAP_SETPCAP", CAP_SETPCAP);
-    initConstant(env, c, "CAP_SETUID", CAP_SETUID);
-    initConstant(env, c, "CAP_SYS_ADMIN", CAP_SYS_ADMIN);
-    initConstant(env, c, "CAP_SYS_BOOT", CAP_SYS_BOOT);
-    initConstant(env, c, "CAP_SYS_CHROOT", CAP_SYS_CHROOT);
-    initConstant(env, c, "CAP_SYSLOG", CAP_SYSLOG);
-    initConstant(env, c, "CAP_SYS_MODULE", CAP_SYS_MODULE);
-    initConstant(env, c, "CAP_SYS_NICE", CAP_SYS_NICE);
-    initConstant(env, c, "CAP_SYS_PACCT", CAP_SYS_PACCT);
-    initConstant(env, c, "CAP_SYS_PTRACE", CAP_SYS_PTRACE);
-    initConstant(env, c, "CAP_SYS_RAWIO", CAP_SYS_RAWIO);
-    initConstant(env, c, "CAP_SYS_RESOURCE", CAP_SYS_RESOURCE);
-    initConstant(env, c, "CAP_SYS_TIME", CAP_SYS_TIME);
-    initConstant(env, c, "CAP_SYS_TTY_CONFIG", CAP_SYS_TTY_CONFIG);
-    initConstant(env, c, "CAP_WAKE_ALARM", CAP_WAKE_ALARM);
-    initConstant(env, c, "E2BIG", E2BIG);
-    initConstant(env, c, "EACCES", EACCES);
-    initConstant(env, c, "EADDRINUSE", EADDRINUSE);
-    initConstant(env, c, "EADDRNOTAVAIL", EADDRNOTAVAIL);
-    initConstant(env, c, "EAFNOSUPPORT", EAFNOSUPPORT);
-    initConstant(env, c, "EAGAIN", EAGAIN);
-    initConstant(env, c, "EAI_AGAIN", EAI_AGAIN);
-    initConstant(env, c, "EAI_BADFLAGS", EAI_BADFLAGS);
-    initConstant(env, c, "EAI_FAIL", EAI_FAIL);
-    initConstant(env, c, "EAI_FAMILY", EAI_FAMILY);
-    initConstant(env, c, "EAI_MEMORY", EAI_MEMORY);
-    initConstant(env, c, "EAI_NODATA", EAI_NODATA);
-    initConstant(env, c, "EAI_NONAME", EAI_NONAME);
-    initConstant(env, c, "EAI_OVERFLOW", EAI_OVERFLOW);
-    initConstant(env, c, "EAI_SERVICE", EAI_SERVICE);
-    initConstant(env, c, "EAI_SOCKTYPE", EAI_SOCKTYPE);
-    initConstant(env, c, "EAI_SYSTEM", EAI_SYSTEM);
-    initConstant(env, c, "EALREADY", EALREADY);
-    initConstant(env, c, "EBADF", EBADF);
-    initConstant(env, c, "EBADMSG", EBADMSG);
-    initConstant(env, c, "EBUSY", EBUSY);
-    initConstant(env, c, "ECANCELED", ECANCELED);
-    initConstant(env, c, "ECHILD", ECHILD);
-    initConstant(env, c, "ECONNABORTED", ECONNABORTED);
-    initConstant(env, c, "ECONNREFUSED", ECONNREFUSED);
-    initConstant(env, c, "ECONNRESET", ECONNRESET);
-    initConstant(env, c, "EDEADLK", EDEADLK);
-    initConstant(env, c, "EDESTADDRREQ", EDESTADDRREQ);
-    initConstant(env, c, "EDOM", EDOM);
-    initConstant(env, c, "EDQUOT", EDQUOT);
-    initConstant(env, c, "EEXIST", EEXIST);
-    initConstant(env, c, "EFAULT", EFAULT);
-    initConstant(env, c, "EFBIG", EFBIG);
-    initConstant(env, c, "EHOSTUNREACH", EHOSTUNREACH);
-    initConstant(env, c, "EIDRM", EIDRM);
-    initConstant(env, c, "EILSEQ", EILSEQ);
-    initConstant(env, c, "EINPROGRESS", EINPROGRESS);
-    initConstant(env, c, "EINTR", EINTR);
-    initConstant(env, c, "EINVAL", EINVAL);
-    initConstant(env, c, "EIO", EIO);
-    initConstant(env, c, "EISCONN", EISCONN);
-    initConstant(env, c, "EISDIR", EISDIR);
-    initConstant(env, c, "ELOOP", ELOOP);
-    initConstant(env, c, "EMFILE", EMFILE);
-    initConstant(env, c, "EMLINK", EMLINK);
-    initConstant(env, c, "EMSGSIZE", EMSGSIZE);
-    initConstant(env, c, "EMULTIHOP", EMULTIHOP);
-    initConstant(env, c, "ENAMETOOLONG", ENAMETOOLONG);
-    initConstant(env, c, "ENETDOWN", ENETDOWN);
-    initConstant(env, c, "ENETRESET", ENETRESET);
-    initConstant(env, c, "ENETUNREACH", ENETUNREACH);
-    initConstant(env, c, "ENFILE", ENFILE);
-    initConstant(env, c, "ENOBUFS", ENOBUFS);
-    initConstant(env, c, "ENODATA", ENODATA);
-    initConstant(env, c, "ENODEV", ENODEV);
-    initConstant(env, c, "ENOENT", ENOENT);
-    initConstant(env, c, "ENOEXEC", ENOEXEC);
-    initConstant(env, c, "ENOLCK", ENOLCK);
-    initConstant(env, c, "ENOLINK", ENOLINK);
-    initConstant(env, c, "ENOMEM", ENOMEM);
-    initConstant(env, c, "ENOMSG", ENOMSG);
-    initConstant(env, c, "ENONET", ENONET);
-    initConstant(env, c, "ENOPROTOOPT", ENOPROTOOPT);
-    initConstant(env, c, "ENOSPC", ENOSPC);
-    initConstant(env, c, "ENOSR", ENOSR);
-    initConstant(env, c, "ENOSTR", ENOSTR);
-    initConstant(env, c, "ENOSYS", ENOSYS);
-    initConstant(env, c, "ENOTCONN", ENOTCONN);
-    initConstant(env, c, "ENOTDIR", ENOTDIR);
-    initConstant(env, c, "ENOTEMPTY", ENOTEMPTY);
-    initConstant(env, c, "ENOTSOCK", ENOTSOCK);
-    initConstant(env, c, "ENOTSUP", ENOTSUP);
-    initConstant(env, c, "ENOTTY", ENOTTY);
-    initConstant(env, c, "ENXIO", ENXIO);
-    initConstant(env, c, "EOPNOTSUPP", EOPNOTSUPP);
-    initConstant(env, c, "EOVERFLOW", EOVERFLOW);
-    initConstant(env, c, "EPERM", EPERM);
-    initConstant(env, c, "EPIPE", EPIPE);
-    initConstant(env, c, "EPROTO", EPROTO);
-    initConstant(env, c, "EPROTONOSUPPORT", EPROTONOSUPPORT);
-    initConstant(env, c, "EPROTOTYPE", EPROTOTYPE);
-    initConstant(env, c, "ERANGE", ERANGE);
-    initConstant(env, c, "EROFS", EROFS);
-    initConstant(env, c, "ESPIPE", ESPIPE);
-    initConstant(env, c, "ESRCH", ESRCH);
-    initConstant(env, c, "ESTALE", ESTALE);
-    initConstant(env, c, "ETH_P_ALL", ETH_P_ALL);
-    initConstant(env, c, "ETH_P_ARP", ETH_P_ARP);
-    initConstant(env, c, "ETH_P_IP", ETH_P_IP);
-    initConstant(env, c, "ETH_P_IPV6", ETH_P_IPV6);
-    initConstant(env, c, "ETIME", ETIME);
-    initConstant(env, c, "ETIMEDOUT", ETIMEDOUT);
-    initConstant(env, c, "ETXTBSY", ETXTBSY);
-    initConstant(env, c, "EUSERS", EUSERS);
-    initConstant(env, c, "EXDEV", EXDEV);
-    initConstant(env, c, "EXIT_FAILURE", EXIT_FAILURE);
-    initConstant(env, c, "EXIT_SUCCESS", EXIT_SUCCESS);
-    initConstant(env, c, "FD_CLOEXEC", FD_CLOEXEC);
-    initConstant(env, c, "FIONREAD", FIONREAD);
-    initConstant(env, c, "F_DUPFD", F_DUPFD);
-    initConstant(env, c, "F_DUPFD_CLOEXEC", F_DUPFD_CLOEXEC);
-    initConstant(env, c, "F_GETFD", F_GETFD);
-    initConstant(env, c, "F_GETFL", F_GETFL);
-    initConstant(env, c, "F_GETLK", F_GETLK);
-    initConstant(env, c, "F_GETLK64", F_GETLK64);
-    initConstant(env, c, "F_GETOWN", F_GETOWN);
-    initConstant(env, c, "F_OK", F_OK);
-    initConstant(env, c, "F_RDLCK", F_RDLCK);
-    initConstant(env, c, "F_SETFD", F_SETFD);
-    initConstant(env, c, "F_SETFL", F_SETFL);
-    initConstant(env, c, "F_SETLK", F_SETLK);
-    initConstant(env, c, "F_SETLK64", F_SETLK64);
-    initConstant(env, c, "F_SETLKW", F_SETLKW);
-    initConstant(env, c, "F_SETLKW64", F_SETLKW64);
-    initConstant(env, c, "F_SETOWN", F_SETOWN);
-    initConstant(env, c, "F_UNLCK", F_UNLCK);
-    initConstant(env, c, "F_WRLCK", F_WRLCK);
-    initConstant(env, c, "ICMP_ECHO", ICMP_ECHO);
-    initConstant(env, c, "ICMP_ECHOREPLY", ICMP_ECHOREPLY);
-    initConstant(env, c, "ICMP6_ECHO_REQUEST", ICMP6_ECHO_REQUEST);
-    initConstant(env, c, "ICMP6_ECHO_REPLY", ICMP6_ECHO_REPLY);
-    initConstant(env, c, "IFA_F_DADFAILED", IFA_F_DADFAILED);
-    initConstant(env, c, "IFA_F_DEPRECATED", IFA_F_DEPRECATED);
-    initConstant(env, c, "IFA_F_HOMEADDRESS", IFA_F_HOMEADDRESS);
-    initConstant(env, c, "IFA_F_MANAGETEMPADDR", IFA_F_MANAGETEMPADDR);
-    initConstant(env, c, "IFA_F_NODAD", IFA_F_NODAD);
-    initConstant(env, c, "IFA_F_NOPREFIXROUTE", IFA_F_NOPREFIXROUTE);
-    initConstant(env, c, "IFA_F_OPTIMISTIC", IFA_F_OPTIMISTIC);
-    initConstant(env, c, "IFA_F_PERMANENT", IFA_F_PERMANENT);
-    initConstant(env, c, "IFA_F_SECONDARY", IFA_F_SECONDARY);
-    initConstant(env, c, "IFA_F_TEMPORARY", IFA_F_TEMPORARY);
-    initConstant(env, c, "IFA_F_TENTATIVE", IFA_F_TENTATIVE);
-    initConstant(env, c, "IFF_ALLMULTI", IFF_ALLMULTI);
-    initConstant(env, c, "IFF_AUTOMEDIA", IFF_AUTOMEDIA);
-    initConstant(env, c, "IFF_BROADCAST", IFF_BROADCAST);
-    initConstant(env, c, "IFF_DEBUG", IFF_DEBUG);
-    initConstant(env, c, "IFF_DYNAMIC", IFF_DYNAMIC);
-    initConstant(env, c, "IFF_LOOPBACK", IFF_LOOPBACK);
-    initConstant(env, c, "IFF_MASTER", IFF_MASTER);
-    initConstant(env, c, "IFF_MULTICAST", IFF_MULTICAST);
-    initConstant(env, c, "IFF_NOARP", IFF_NOARP);
-    initConstant(env, c, "IFF_NOTRAILERS", IFF_NOTRAILERS);
-    initConstant(env, c, "IFF_POINTOPOINT", IFF_POINTOPOINT);
-    initConstant(env, c, "IFF_PORTSEL", IFF_PORTSEL);
-    initConstant(env, c, "IFF_PROMISC", IFF_PROMISC);
-    initConstant(env, c, "IFF_RUNNING", IFF_RUNNING);
-    initConstant(env, c, "IFF_SLAVE", IFF_SLAVE);
-    initConstant(env, c, "IFF_UP", IFF_UP);
-    initConstant(env, c, "IPPROTO_ICMP", IPPROTO_ICMP);
-    initConstant(env, c, "IPPROTO_ICMPV6", IPPROTO_ICMPV6);
-    initConstant(env, c, "IPPROTO_IP", IPPROTO_IP);
-    initConstant(env, c, "IPPROTO_IPV6", IPPROTO_IPV6);
-    initConstant(env, c, "IPPROTO_RAW", IPPROTO_RAW);
-    initConstant(env, c, "IPPROTO_TCP", IPPROTO_TCP);
-    initConstant(env, c, "IPPROTO_UDP", IPPROTO_UDP);
-    initConstant(env, c, "IPPROTO_ESP", IPPROTO_ESP);
-    initConstant(env, c, "IPV6_CHECKSUM", IPV6_CHECKSUM);
-    initConstant(env, c, "IPV6_MULTICAST_HOPS", IPV6_MULTICAST_HOPS);
-    initConstant(env, c, "IPV6_MULTICAST_IF", IPV6_MULTICAST_IF);
-    initConstant(env, c, "IPV6_MULTICAST_LOOP", IPV6_MULTICAST_LOOP);
-    initConstant(env, c, "IPV6_PKTINFO", IPV6_PKTINFO);
-    initConstant(env, c, "IPV6_RECVDSTOPTS", IPV6_RECVDSTOPTS);
-    initConstant(env, c, "IPV6_RECVHOPLIMIT", IPV6_RECVHOPLIMIT);
-    initConstant(env, c, "IPV6_RECVHOPOPTS", IPV6_RECVHOPOPTS);
-    initConstant(env, c, "IPV6_RECVPKTINFO", IPV6_RECVPKTINFO);
-    initConstant(env, c, "IPV6_RECVRTHDR", IPV6_RECVRTHDR);
-    initConstant(env, c, "IPV6_RECVTCLASS", IPV6_RECVTCLASS);
-    initConstant(env, c, "IPV6_TCLASS", IPV6_TCLASS);
-    initConstant(env, c, "IPV6_UNICAST_HOPS", IPV6_UNICAST_HOPS);
-    initConstant(env, c, "IPV6_V6ONLY", IPV6_V6ONLY);
-    initConstant(env, c, "IP_MULTICAST_ALL", IP_MULTICAST_ALL);
-    initConstant(env, c, "IP_MULTICAST_IF", IP_MULTICAST_IF);
-    initConstant(env, c, "IP_MULTICAST_LOOP", IP_MULTICAST_LOOP);
-    initConstant(env, c, "IP_MULTICAST_TTL", IP_MULTICAST_TTL);
-    initConstant(env, c, "IP_RECVTOS", IP_RECVTOS);
-    initConstant(env, c, "IP_TOS", IP_TOS);
-    initConstant(env, c, "IP_TTL", IP_TTL);
-    initConstant(env, c, "_LINUX_CAPABILITY_VERSION_3", _LINUX_CAPABILITY_VERSION_3);
-    initConstant(env, c, "MADV_NORMAL", MADV_NORMAL);
-    initConstant(env, c, "MADV_RANDOM", MADV_RANDOM);
-    initConstant(env, c, "MADV_SEQUENTIAL", MADV_SEQUENTIAL);
-    initConstant(env, c, "MADV_WILLNEED", MADV_WILLNEED);
-    initConstant(env, c, "MADV_DONTNEED", MADV_DONTNEED);
-    initConstant(env, c, "MADV_REMOVE", MADV_REMOVE);
-    initConstant(env, c, "MADV_DONTFORK", MADV_DONTFORK);
-    initConstant(env, c, "MADV_DOFORK", MADV_DOFORK);
-    initConstant(env, c, "MADV_HWPOISON", MADV_HWPOISON);
-    initConstant(env, c, "MADV_MERGEABLE", MADV_MERGEABLE);
-    initConstant(env, c, "MADV_UNMERGEABLE", MADV_UNMERGEABLE);
-    initConstant(env, c, "MADV_SOFT_OFFLINE", MADV_SOFT_OFFLINE);
-    initConstant(env, c, "MADV_HUGEPAGE", MADV_HUGEPAGE);
-    initConstant(env, c, "MADV_NOHUGEPAGE", MADV_NOHUGEPAGE);
-    initConstant(env, c, "MADV_COLLAPSE", MADV_COLLAPSE);
-    initConstant(env, c, "MADV_DONTDUMP", MADV_DONTDUMP);
-    initConstant(env, c, "MADV_DODUMP", MADV_DODUMP);
-    initConstant(env, c, "MADV_FREE", MADV_FREE);
-    initConstant(env, c, "MADV_WIPEONFORK", MADV_WIPEONFORK);
-    initConstant(env, c, "MADV_KEEPONFORK", MADV_KEEPONFORK);
-    initConstant(env, c, "MADV_COLD", MADV_COLD);
-    initConstant(env, c, "MADV_PAGEOUT", MADV_PAGEOUT);
-    initConstant(env, c, "MADV_POPULATE_READ", MADV_POPULATE_READ);
-    initConstant(env, c, "MADV_POPULATE_WRITE", MADV_POPULATE_WRITE);
-    initConstant(env, c, "MAP_FIXED", MAP_FIXED);
-    initConstant(env, c, "MAP_ANONYMOUS", MAP_ANONYMOUS);
-    initConstant(env, c, "MAP_POPULATE", MAP_POPULATE);
-    initConstant(env, c, "MAP_PRIVATE", MAP_PRIVATE);
-    initConstant(env, c, "MAP_SHARED", MAP_SHARED);
-    initConstant(env, c, "MCAST_JOIN_GROUP", MCAST_JOIN_GROUP);
-    initConstant(env, c, "MCAST_LEAVE_GROUP", MCAST_LEAVE_GROUP);
-    initConstant(env, c, "MCAST_JOIN_SOURCE_GROUP", MCAST_JOIN_SOURCE_GROUP);
-    initConstant(env, c, "MCAST_LEAVE_SOURCE_GROUP", MCAST_LEAVE_SOURCE_GROUP);
-    initConstant(env, c, "MCAST_BLOCK_SOURCE", MCAST_BLOCK_SOURCE);
-    initConstant(env, c, "MCAST_UNBLOCK_SOURCE", MCAST_UNBLOCK_SOURCE);
-    initConstant(env, c, "MCL_CURRENT", MCL_CURRENT);
-    initConstant(env, c, "MCL_FUTURE", MCL_FUTURE);
-    initConstant(env, c, "MFD_CLOEXEC", MFD_CLOEXEC);
-    initConstant(env, c, "MSG_CTRUNC", MSG_CTRUNC);
-    initConstant(env, c, "MSG_DONTROUTE", MSG_DONTROUTE);
-    initConstant(env, c, "MSG_EOR", MSG_EOR);
-    initConstant(env, c, "MSG_OOB", MSG_OOB);
-    initConstant(env, c, "MSG_PEEK", MSG_PEEK);
-    initConstant(env, c, "MSG_TRUNC", MSG_TRUNC);
-    initConstant(env, c, "MSG_WAITALL", MSG_WAITALL);
-    initConstant(env, c, "MS_ASYNC", MS_ASYNC);
-    initConstant(env, c, "MS_INVALIDATE", MS_INVALIDATE);
-    initConstant(env, c, "MS_SYNC", MS_SYNC);
-    initConstant(env, c, "NETLINK_NETFILTER", NETLINK_NETFILTER);
-    initConstant(env, c, "NETLINK_ROUTE", NETLINK_ROUTE);
-    initConstant(env, c, "NETLINK_INET_DIAG", NETLINK_INET_DIAG);
-    initConstant(env, c, "NETLINK_XFRM", NETLINK_XFRM);
-    initConstant(env, c, "NI_DGRAM", NI_DGRAM);
-    initConstant(env, c, "NI_NAMEREQD", NI_NAMEREQD);
-    initConstant(env, c, "NI_NOFQDN", NI_NOFQDN);
-    initConstant(env, c, "NI_NUMERICHOST", NI_NUMERICHOST);
-    initConstant(env, c, "NI_NUMERICSERV", NI_NUMERICSERV);
-    initConstant(env, c, "O_ACCMODE", O_ACCMODE);
-    initConstant(env, c, "O_APPEND", O_APPEND);
-    initConstant(env, c, "O_CLOEXEC", O_CLOEXEC);
-    initConstant(env, c, "O_CREAT", O_CREAT);
-    initConstant(env, c, "O_DIRECT", O_DIRECT);
-    initConstant(env, c, "O_EXCL", O_EXCL);
-    initConstant(env, c, "O_NOCTTY", O_NOCTTY);
-    initConstant(env, c, "O_NOFOLLOW", O_NOFOLLOW);
-    initConstant(env, c, "O_NONBLOCK", O_NONBLOCK);
-    initConstant(env, c, "O_RDONLY", O_RDONLY);
-    initConstant(env, c, "O_RDWR", O_RDWR);
-    initConstant(env, c, "O_SYNC", O_SYNC);
-    initConstant(env, c, "O_DSYNC", O_DSYNC);
-    initConstant(env, c, "O_TRUNC", O_TRUNC);
-    initConstant(env, c, "O_WRONLY", O_WRONLY);
-    initConstant(env, c, "POLLERR", POLLERR);
-    initConstant(env, c, "POLLHUP", POLLHUP);
-    initConstant(env, c, "POLLIN", POLLIN);
-    initConstant(env, c, "POLLNVAL", POLLNVAL);
-    initConstant(env, c, "POLLOUT", POLLOUT);
-    initConstant(env, c, "POLLPRI", POLLPRI);
-    initConstant(env, c, "POLLRDBAND", POLLRDBAND);
-    initConstant(env, c, "POLLRDNORM", POLLRDNORM);
-    initConstant(env, c, "POLLWRBAND", POLLWRBAND);
-    initConstant(env, c, "POLLWRNORM", POLLWRNORM);
-    initConstant(env, c, "PR_CAP_AMBIENT", PR_CAP_AMBIENT);
-    initConstant(env, c, "PR_CAP_AMBIENT_RAISE", PR_CAP_AMBIENT_RAISE);
-    initConstant(env, c, "PR_GET_DUMPABLE", PR_GET_DUMPABLE);
-    initConstant(env, c, "PR_SET_DUMPABLE", PR_SET_DUMPABLE);
-    initConstant(env, c, "PR_SET_NO_NEW_PRIVS", PR_SET_NO_NEW_PRIVS);
-    initConstant(env, c, "PROT_EXEC", PROT_EXEC);
-    initConstant(env, c, "PROT_NONE", PROT_NONE);
-    initConstant(env, c, "PROT_READ", PROT_READ);
-    initConstant(env, c, "PROT_WRITE", PROT_WRITE);
-    initConstant(env, c, "R_OK", R_OK);
-    initConstant(env, c, "RLIMIT_NOFILE", RLIMIT_NOFILE);
-    initConstant(env, c, "RLIMIT_RTPRIO", RLIMIT_RTPRIO);
-    initConstant(env, c, "RT_SCOPE_HOST", RT_SCOPE_HOST);
-    initConstant(env, c, "RT_SCOPE_LINK", RT_SCOPE_LINK);
-    initConstant(env, c, "RT_SCOPE_NOWHERE", RT_SCOPE_NOWHERE);
-    initConstant(env, c, "RT_SCOPE_SITE", RT_SCOPE_SITE);
-    initConstant(env, c, "RT_SCOPE_UNIVERSE", RT_SCOPE_UNIVERSE);
-    initConstant(env, c, "RTMGRP_IPV4_IFADDR", RTMGRP_IPV4_IFADDR);
-    initConstant(env, c, "RTMGRP_IPV4_MROUTE", RTMGRP_IPV4_MROUTE);
-    initConstant(env, c, "RTMGRP_IPV4_ROUTE", RTMGRP_IPV4_ROUTE);
-    initConstant(env, c, "RTMGRP_IPV4_RULE", RTMGRP_IPV4_RULE);
-    initConstant(env, c, "RTMGRP_IPV6_IFADDR", RTMGRP_IPV6_IFADDR);
-    initConstant(env, c, "RTMGRP_IPV6_IFINFO", RTMGRP_IPV6_IFINFO);
-    initConstant(env, c, "RTMGRP_IPV6_MROUTE", RTMGRP_IPV6_MROUTE);
-    initConstant(env, c, "RTMGRP_IPV6_PREFIX", RTMGRP_IPV6_PREFIX);
-    initConstant(env, c, "RTMGRP_IPV6_ROUTE", RTMGRP_IPV6_ROUTE);
-    initConstant(env, c, "RTMGRP_LINK", RTMGRP_LINK);
-    initConstant(env, c, "RTMGRP_NEIGH", RTMGRP_NEIGH);
-    initConstant(env, c, "RTMGRP_NOTIFY", RTMGRP_NOTIFY);
-    initConstant(env, c, "RTMGRP_TC", RTMGRP_TC);
-    initConstant(env, c, "SEEK_CUR", SEEK_CUR);
-    initConstant(env, c, "SEEK_END", SEEK_END);
-    initConstant(env, c, "SEEK_SET", SEEK_SET);
-    initConstant(env, c, "SHUT_RD", SHUT_RD);
-    initConstant(env, c, "SHUT_RDWR", SHUT_RDWR);
-    initConstant(env, c, "SHUT_WR", SHUT_WR);
-    initConstant(env, c, "SIGABRT", SIGABRT);
-    initConstant(env, c, "SIGALRM", SIGALRM);
-    initConstant(env, c, "SIGBUS", SIGBUS);
-    initConstant(env, c, "SIGCHLD", SIGCHLD);
-    initConstant(env, c, "SIGCONT", SIGCONT);
-    initConstant(env, c, "SIGFPE", SIGFPE);
-    initConstant(env, c, "SIGHUP", SIGHUP);
-    initConstant(env, c, "SIGILL", SIGILL);
-    initConstant(env, c, "SIGINT", SIGINT);
-    initConstant(env, c, "SIGIO", SIGIO);
-    initConstant(env, c, "SIGKILL", SIGKILL);
-    initConstant(env, c, "SIGPIPE", SIGPIPE);
-    initConstant(env, c, "SIGPROF", SIGPROF);
-    initConstant(env, c, "SIGPWR", SIGPWR);
-    initConstant(env, c, "SIGQUIT", SIGQUIT);
-    initConstant(env, c, "SIGRTMAX", SIGRTMAX);
-    initConstant(env, c, "SIGRTMIN", SIGRTMIN);
-    initConstant(env, c, "SIGSEGV", SIGSEGV);
-    initConstant(env, c, "SIGSTKFLT", SIGSTKFLT);
-    initConstant(env, c, "SIGSTOP", SIGSTOP);
-    initConstant(env, c, "SIGSYS", SIGSYS);
-    initConstant(env, c, "SIGTERM", SIGTERM);
-    initConstant(env, c, "SIGTRAP", SIGTRAP);
-    initConstant(env, c, "SIGTSTP", SIGTSTP);
-    initConstant(env, c, "SIGTTIN", SIGTTIN);
-    initConstant(env, c, "SIGTTOU", SIGTTOU);
-    initConstant(env, c, "SIGURG", SIGURG);
-    initConstant(env, c, "SIGUSR1", SIGUSR1);
-    initConstant(env, c, "SIGUSR2", SIGUSR2);
-    initConstant(env, c, "SIGVTALRM", SIGVTALRM);
-    initConstant(env, c, "SIGWINCH", SIGWINCH);
-    initConstant(env, c, "SIGXCPU", SIGXCPU);
-    initConstant(env, c, "SIGXFSZ", SIGXFSZ);
-    initConstant(env, c, "SIOCGIFADDR", SIOCGIFADDR);
-    initConstant(env, c, "SIOCGIFBRDADDR", SIOCGIFBRDADDR);
-    initConstant(env, c, "SIOCGIFDSTADDR", SIOCGIFDSTADDR);
-    initConstant(env, c, "SIOCGIFNETMASK", SIOCGIFNETMASK);
-    initConstant(env, c, "SOCK_CLOEXEC", SOCK_CLOEXEC);
-    initConstant(env, c, "SOCK_DGRAM", SOCK_DGRAM);
-    initConstant(env, c, "SOCK_NONBLOCK", SOCK_NONBLOCK);
-    initConstant(env, c, "SOCK_RAW", SOCK_RAW);
-    initConstant(env, c, "SOCK_SEQPACKET", SOCK_SEQPACKET);
-    initConstant(env, c, "SOCK_STREAM", SOCK_STREAM);
-    initConstant(env, c, "SOL_SOCKET", SOL_SOCKET);
-    initConstant(env, c, "SOL_UDP", SOL_UDP);
-    initConstant(env, c, "SOL_PACKET", SOL_PACKET);
-    initConstant(env, c, "SO_BINDTODEVICE", SO_BINDTODEVICE);
-    initConstant(env, c, "SO_BROADCAST", SO_BROADCAST);
-    initConstant(env, c, "SO_DEBUG", SO_DEBUG);
-    initConstant(env, c, "SO_DOMAIN", SO_DOMAIN);
-    initConstant(env, c, "SO_DONTROUTE", SO_DONTROUTE);
-    initConstant(env, c, "SO_ERROR", SO_ERROR);
-    initConstant(env, c, "SO_KEEPALIVE", SO_KEEPALIVE);
-    initConstant(env, c, "SO_LINGER", SO_LINGER);
-    initConstant(env, c, "SO_OOBINLINE", SO_OOBINLINE);
-    initConstant(env, c, "SO_PASSCRED", SO_PASSCRED);
-    initConstant(env, c, "SO_PEERCRED", SO_PEERCRED);
-    initConstant(env, c, "SO_PROTOCOL", SO_PROTOCOL);
-    initConstant(env, c, "SO_RCVBUF", SO_RCVBUF);
-    initConstant(env, c, "SO_RCVLOWAT", SO_RCVLOWAT);
-    initConstant(env, c, "SO_RCVTIMEO", SO_RCVTIMEO);
-    initConstant(env, c, "SO_REUSEADDR", SO_REUSEADDR);
-    initConstant(env, c, "SO_SNDBUF", SO_SNDBUF);
-    initConstant(env, c, "SO_SNDLOWAT", SO_SNDLOWAT);
-    initConstant(env, c, "SO_SNDTIMEO", SO_SNDTIMEO);
-    initConstant(env, c, "SO_TYPE", SO_TYPE);
-    initConstant(env, c, "PACKET_IGNORE_OUTGOING", PACKET_IGNORE_OUTGOING);
-    initConstant(env, c, "SPLICE_F_MOVE", SPLICE_F_MOVE);
-    initConstant(env, c, "SPLICE_F_NONBLOCK", SPLICE_F_NONBLOCK);
-    initConstant(env, c, "SPLICE_F_MORE", SPLICE_F_MORE);
-    initConstant(env, c, "STDERR_FILENO", STDERR_FILENO);
-    initConstant(env, c, "STDIN_FILENO", STDIN_FILENO);
-    initConstant(env, c, "STDOUT_FILENO", STDOUT_FILENO);
-    initConstant(env, c, "ST_MANDLOCK", ST_MANDLOCK);
-    initConstant(env, c, "ST_NOATIME", ST_NOATIME);
-    initConstant(env, c, "ST_NODEV", ST_NODEV);
-    initConstant(env, c, "ST_NODIRATIME", ST_NODIRATIME);
-    initConstant(env, c, "ST_NOEXEC", ST_NOEXEC);
-    initConstant(env, c, "ST_NOSUID", ST_NOSUID);
-    initConstant(env, c, "ST_RDONLY", ST_RDONLY);
-    initConstant(env, c, "ST_RELATIME", ST_RELATIME);
-    initConstant(env, c, "ST_SYNCHRONOUS", ST_SYNCHRONOUS);
-    initConstant(env, c, "S_IFBLK", S_IFBLK);
-    initConstant(env, c, "S_IFCHR", S_IFCHR);
-    initConstant(env, c, "S_IFDIR", S_IFDIR);
-    initConstant(env, c, "S_IFIFO", S_IFIFO);
-    initConstant(env, c, "S_IFLNK", S_IFLNK);
-    initConstant(env, c, "S_IFMT", S_IFMT);
-    initConstant(env, c, "S_IFREG", S_IFREG);
-    initConstant(env, c, "S_IFSOCK", S_IFSOCK);
-    initConstant(env, c, "S_IRGRP", S_IRGRP);
-    initConstant(env, c, "S_IROTH", S_IROTH);
-    initConstant(env, c, "S_IRUSR", S_IRUSR);
-    initConstant(env, c, "S_IRWXG", S_IRWXG);
-    initConstant(env, c, "S_IRWXO", S_IRWXO);
-    initConstant(env, c, "S_IRWXU", S_IRWXU);
-    initConstant(env, c, "S_ISGID", S_ISGID);
-    initConstant(env, c, "S_ISUID", S_ISUID);
-    initConstant(env, c, "S_ISVTX", S_ISVTX);
-    initConstant(env, c, "S_IWGRP", S_IWGRP);
-    initConstant(env, c, "S_IWOTH", S_IWOTH);
-    initConstant(env, c, "S_IWUSR", S_IWUSR);
-    initConstant(env, c, "S_IXGRP", S_IXGRP);
-    initConstant(env, c, "S_IXOTH", S_IXOTH);
-    initConstant(env, c, "S_IXUSR", S_IXUSR);
-    initConstant(env, c, "TCP_NODELAY", TCP_NODELAY);
-    initConstant(env, c, "TCP_USER_TIMEOUT", TCP_USER_TIMEOUT);
-    initConstant(env, c, "TIOCOUTQ", TIOCOUTQ);
-    initConstant(env, c, "UDP_ENCAP", UDP_ENCAP);
-    initConstant(env, c, "UDP_ENCAP_ESPINUDP_NON_IKE", UDP_ENCAP_ESPINUDP_NON_IKE);
-    initConstant(env, c, "UDP_ENCAP_ESPINUDP", UDP_ENCAP_ESPINUDP);
-    initConstant(env, c, "UDP_GRO", UDP_GRO);
-    initConstant(env, c, "UDP_SEGMENT", UDP_SEGMENT);
-    // UNIX_PATH_MAX is mentioned in some versions of unix(7), but not actually declared.
-    initConstant(env, c, "UNIX_PATH_MAX", sizeof(sockaddr_un::sun_path));
-    initConstant(env, c, "WCONTINUED", WCONTINUED);
-    initConstant(env, c, "WEXITED", WEXITED);
-    initConstant(env, c, "WNOHANG", WNOHANG);
-    initConstant(env, c, "WNOWAIT", WNOWAIT);
-    initConstant(env, c, "WSTOPPED", WSTOPPED);
-    initConstant(env, c, "WUNTRACED", WUNTRACED);
-    initConstant(env, c, "W_OK", W_OK);
-    initConstant(env, c, "XATTR_CREATE", XATTR_CREATE);
-    initConstant(env, c, "XATTR_REPLACE", XATTR_REPLACE);
-    initConstant(env, c, "X_OK", X_OK);
-    initConstant(env, c, "_SC_2_CHAR_TERM", _SC_2_CHAR_TERM);
-    initConstant(env, c, "_SC_2_C_BIND", _SC_2_C_BIND);
-    initConstant(env, c, "_SC_2_C_DEV", _SC_2_C_DEV);
-    initConstant(env, c, "_SC_2_C_VERSION", _SC_2_C_VERSION);
-    initConstant(env, c, "_SC_2_FORT_DEV", _SC_2_FORT_DEV);
-    initConstant(env, c, "_SC_2_FORT_RUN", _SC_2_FORT_RUN);
-    initConstant(env, c, "_SC_2_LOCALEDEF", _SC_2_LOCALEDEF);
-    initConstant(env, c, "_SC_2_SW_DEV", _SC_2_SW_DEV);
-    initConstant(env, c, "_SC_2_UPE", _SC_2_UPE);
-    initConstant(env, c, "_SC_2_VERSION", _SC_2_VERSION);
-    initConstant(env, c, "_SC_AIO_LISTIO_MAX", _SC_AIO_LISTIO_MAX);
-    initConstant(env, c, "_SC_AIO_MAX", _SC_AIO_MAX);
-    initConstant(env, c, "_SC_AIO_PRIO_DELTA_MAX", _SC_AIO_PRIO_DELTA_MAX);
-    initConstant(env, c, "_SC_ARG_MAX", _SC_ARG_MAX);
-    initConstant(env, c, "_SC_ASYNCHRONOUS_IO", _SC_ASYNCHRONOUS_IO);
-    initConstant(env, c, "_SC_ATEXIT_MAX", _SC_ATEXIT_MAX);
-    initConstant(env, c, "_SC_AVPHYS_PAGES", _SC_AVPHYS_PAGES);
-    initConstant(env, c, "_SC_BC_BASE_MAX", _SC_BC_BASE_MAX);
-    initConstant(env, c, "_SC_BC_DIM_MAX", _SC_BC_DIM_MAX);
-    initConstant(env, c, "_SC_BC_SCALE_MAX", _SC_BC_SCALE_MAX);
-    initConstant(env, c, "_SC_BC_STRING_MAX", _SC_BC_STRING_MAX);
-    initConstant(env, c, "_SC_CHILD_MAX", _SC_CHILD_MAX);
-    initConstant(env, c, "_SC_CLK_TCK", _SC_CLK_TCK);
-    initConstant(env, c, "_SC_COLL_WEIGHTS_MAX", _SC_COLL_WEIGHTS_MAX);
-    initConstant(env, c, "_SC_DELAYTIMER_MAX", _SC_DELAYTIMER_MAX);
-    initConstant(env, c, "_SC_EXPR_NEST_MAX", _SC_EXPR_NEST_MAX);
-    initConstant(env, c, "_SC_FSYNC", _SC_FSYNC);
-    initConstant(env, c, "_SC_GETGR_R_SIZE_MAX", _SC_GETGR_R_SIZE_MAX);
-    initConstant(env, c, "_SC_GETPW_R_SIZE_MAX", _SC_GETPW_R_SIZE_MAX);
-    initConstant(env, c, "_SC_IOV_MAX", _SC_IOV_MAX);
-    initConstant(env, c, "_SC_JOB_CONTROL", _SC_JOB_CONTROL);
-    initConstant(env, c, "_SC_LINE_MAX", _SC_LINE_MAX);
-    initConstant(env, c, "_SC_LOGIN_NAME_MAX", _SC_LOGIN_NAME_MAX);
-    initConstant(env, c, "_SC_MAPPED_FILES", _SC_MAPPED_FILES);
-    initConstant(env, c, "_SC_MEMLOCK", _SC_MEMLOCK);
-    initConstant(env, c, "_SC_MEMLOCK_RANGE", _SC_MEMLOCK_RANGE);
-    initConstant(env, c, "_SC_MEMORY_PROTECTION", _SC_MEMORY_PROTECTION);
-    initConstant(env, c, "_SC_MESSAGE_PASSING", _SC_MESSAGE_PASSING);
-    initConstant(env, c, "_SC_MQ_OPEN_MAX", _SC_MQ_OPEN_MAX);
-    initConstant(env, c, "_SC_MQ_PRIO_MAX", _SC_MQ_PRIO_MAX);
-    initConstant(env, c, "_SC_NGROUPS_MAX", _SC_NGROUPS_MAX);
-    initConstant(env, c, "_SC_NPROCESSORS_CONF", _SC_NPROCESSORS_CONF);
-    initConstant(env, c, "_SC_NPROCESSORS_ONLN", _SC_NPROCESSORS_ONLN);
-    initConstant(env, c, "_SC_OPEN_MAX", _SC_OPEN_MAX);
-    initConstant(env, c, "_SC_PAGESIZE", _SC_PAGESIZE);
-    initConstant(env, c, "_SC_PAGE_SIZE", _SC_PAGE_SIZE);
-    initConstant(env, c, "_SC_PASS_MAX", _SC_PASS_MAX);
-    initConstant(env, c, "_SC_PHYS_PAGES", _SC_PHYS_PAGES);
-    initConstant(env, c, "_SC_PRIORITIZED_IO", _SC_PRIORITIZED_IO);
-    initConstant(env, c, "_SC_PRIORITY_SCHEDULING", _SC_PRIORITY_SCHEDULING);
-    initConstant(env, c, "_SC_REALTIME_SIGNALS", _SC_REALTIME_SIGNALS);
-    initConstant(env, c, "_SC_RE_DUP_MAX", _SC_RE_DUP_MAX);
-    initConstant(env, c, "_SC_RTSIG_MAX", _SC_RTSIG_MAX);
-    initConstant(env, c, "_SC_SAVED_IDS", _SC_SAVED_IDS);
-    initConstant(env, c, "_SC_SEMAPHORES", _SC_SEMAPHORES);
-    initConstant(env, c, "_SC_SEM_NSEMS_MAX", _SC_SEM_NSEMS_MAX);
-    initConstant(env, c, "_SC_SEM_VALUE_MAX", _SC_SEM_VALUE_MAX);
-    initConstant(env, c, "_SC_SHARED_MEMORY_OBJECTS", _SC_SHARED_MEMORY_OBJECTS);
-    initConstant(env, c, "_SC_SIGQUEUE_MAX", _SC_SIGQUEUE_MAX);
-    initConstant(env, c, "_SC_STREAM_MAX", _SC_STREAM_MAX);
-    initConstant(env, c, "_SC_SYNCHRONIZED_IO", _SC_SYNCHRONIZED_IO);
-    initConstant(env, c, "_SC_THREADS", _SC_THREADS);
-    initConstant(env, c, "_SC_THREAD_ATTR_STACKADDR", _SC_THREAD_ATTR_STACKADDR);
-    initConstant(env, c, "_SC_THREAD_ATTR_STACKSIZE", _SC_THREAD_ATTR_STACKSIZE);
-    initConstant(env, c, "_SC_THREAD_DESTRUCTOR_ITERATIONS", _SC_THREAD_DESTRUCTOR_ITERATIONS);
-    initConstant(env, c, "_SC_THREAD_KEYS_MAX", _SC_THREAD_KEYS_MAX);
-    initConstant(env, c, "_SC_THREAD_PRIORITY_SCHEDULING", _SC_THREAD_PRIORITY_SCHEDULING);
-    initConstant(env, c, "_SC_THREAD_PRIO_INHERIT", _SC_THREAD_PRIO_INHERIT);
-    initConstant(env, c, "_SC_THREAD_PRIO_PROTECT", _SC_THREAD_PRIO_PROTECT);
-    initConstant(env, c, "_SC_THREAD_SAFE_FUNCTIONS", _SC_THREAD_SAFE_FUNCTIONS);
-    initConstant(env, c, "_SC_THREAD_STACK_MIN", _SC_THREAD_STACK_MIN);
-    initConstant(env, c, "_SC_THREAD_THREADS_MAX", _SC_THREAD_THREADS_MAX);
-    initConstant(env, c, "_SC_TIMERS", _SC_TIMERS);
-    initConstant(env, c, "_SC_TIMER_MAX", _SC_TIMER_MAX);
-    initConstant(env, c, "_SC_TTY_NAME_MAX", _SC_TTY_NAME_MAX);
-    initConstant(env, c, "_SC_TZNAME_MAX", _SC_TZNAME_MAX);
-    initConstant(env, c, "_SC_VERSION", _SC_VERSION);
-    initConstant(env, c, "_SC_XBS5_ILP32_OFF32", _SC_XBS5_ILP32_OFF32);
-    initConstant(env, c, "_SC_XBS5_ILP32_OFFBIG", _SC_XBS5_ILP32_OFFBIG);
-    initConstant(env, c, "_SC_XBS5_LP64_OFF64", _SC_XBS5_LP64_OFF64);
-    initConstant(env, c, "_SC_XBS5_LPBIG_OFFBIG", _SC_XBS5_LPBIG_OFFBIG);
-    initConstant(env, c, "_SC_XOPEN_CRYPT", _SC_XOPEN_CRYPT);
-    initConstant(env, c, "_SC_XOPEN_ENH_I18N", _SC_XOPEN_ENH_I18N);
-    initConstant(env, c, "_SC_XOPEN_LEGACY", _SC_XOPEN_LEGACY);
-    initConstant(env, c, "_SC_XOPEN_REALTIME", _SC_XOPEN_REALTIME);
-    initConstant(env, c, "_SC_XOPEN_REALTIME_THREADS", _SC_XOPEN_REALTIME_THREADS);
-    initConstant(env, c, "_SC_XOPEN_SHM", _SC_XOPEN_SHM);
-    initConstant(env, c, "_SC_XOPEN_UNIX", _SC_XOPEN_UNIX);
-    initConstant(env, c, "_SC_XOPEN_VERSION", _SC_XOPEN_VERSION);
-    initConstant(env, c, "_SC_XOPEN_XCU_VERSION", _SC_XOPEN_XCU_VERSION);
-}
-
-static JNINativeMethod gMethods[] = {
-    NATIVE_METHOD(OsConstants, initConstants, "()V"),
-};
-void register_android_system_OsConstants(JNIEnv* env) {
-    jniRegisterNativeMethods(env, "android/system/OsConstants", gMethods, NELEM(gMethods));
-}
diff --git a/luni/src/main/native/android_system_OsConstantsHolder.cpp b/luni/src/main/native/android_system_OsConstantsHolder.cpp
new file mode 100644
index 00000000000..36d9ec6f2e4
--- /dev/null
+++ b/luni/src/main/native/android_system_OsConstantsHolder.cpp
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "OsConstantsHolder"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <netdb.h>
+#include <netinet/icmp6.h>
+#include <netinet/if_ether.h>
+#include <netinet/in.h>
+#include <netinet/ip_icmp.h>
+#include <netinet/tcp.h>
+#include <netinet/udp.h>
+#include <netpacket/packet.h>
+#include <net/if.h>
+#include <net/if_arp.h>
+#include <poll.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <sys/capability.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/prctl.h>
+#include <sys/resource.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/un.h>
+#include <sys/wait.h>
+#include <sys/xattr.h>
+#include <unistd.h>
+
+#include <linux/if_addr.h>
+#include <linux/rtnetlink.h>
+
+#include <nativehelper/JNIHelp.h>
+#include <nativehelper/jni_macros.h>
+
+#if defined(__GLIBC__)
+// MADV_SOFT_OFFLINE is otherwise unavailable from glibc.
+#include <asm-generic/mman-common.h>
+#endif
+
+#include "Portability.h"
+
+static void initConstant(JNIEnv* env, jclass c, const char* fieldName, int value) {
+    jfieldID field = env->GetStaticFieldID(c, fieldName, "I");
+    env->SetStaticIntField(c, field, value);
+}
+
+static void OsConstantsHolder_initConstants(JNIEnv* env, jclass c) {
+    initConstant(env, c, "AI_ADDRCONFIG", AI_ADDRCONFIG);
+    initConstant(env, c, "AI_ALL", AI_ALL);
+    initConstant(env, c, "AI_CANONNAME", AI_CANONNAME);
+    initConstant(env, c, "AI_NUMERICHOST", AI_NUMERICHOST);
+    initConstant(env, c, "AI_NUMERICSERV", AI_NUMERICSERV);
+    initConstant(env, c, "AI_PASSIVE", AI_PASSIVE);
+    initConstant(env, c, "AI_V4MAPPED", AI_V4MAPPED);
+
+    initConstant(env, c, "EAI_AGAIN", EAI_AGAIN);
+    initConstant(env, c, "EAI_BADFLAGS", EAI_BADFLAGS);
+    initConstant(env, c, "EAI_FAIL", EAI_FAIL);
+    initConstant(env, c, "EAI_FAMILY", EAI_FAMILY);
+    initConstant(env, c, "EAI_MEMORY", EAI_MEMORY);
+    initConstant(env, c, "EAI_NODATA", EAI_NODATA);
+    initConstant(env, c, "EAI_NONAME", EAI_NONAME);
+    initConstant(env, c, "EAI_OVERFLOW", EAI_OVERFLOW);
+    initConstant(env, c, "EAI_SERVICE", EAI_SERVICE);
+    initConstant(env, c, "EAI_SOCKTYPE", EAI_SOCKTYPE);
+    initConstant(env, c, "EAI_SYSTEM", EAI_SYSTEM);
+
+    initConstant(env, c, "F_GETLK", F_GETLK);
+    initConstant(env, c, "F_GETLK64", F_GETLK64);
+    initConstant(env, c, "F_SETLK", F_SETLK);
+    initConstant(env, c, "F_SETLK64", F_SETLK64);
+    initConstant(env, c, "F_SETLKW", F_SETLKW);
+    initConstant(env, c, "F_SETLKW64", F_SETLKW64);
+
+    initConstant(env, c, "NI_NAMEREQD", NI_NAMEREQD);
+    initConstant(env, c, "NI_NOFQDN", NI_NOFQDN);
+    initConstant(env, c, "NI_NUMERICHOST", NI_NUMERICHOST);
+    initConstant(env, c, "NI_NUMERICSERV", NI_NUMERICSERV);
+
+    initConstant(env, c, "O_DIRECT", O_DIRECT);
+    initConstant(env, c, "O_NOFOLLOW", O_NOFOLLOW);
+
+    initConstant(env, c, "SIGRTMIN", SIGRTMIN);
+
+    initConstant(env, c, "_SC_2_CHAR_TERM", _SC_2_CHAR_TERM);
+    initConstant(env, c, "_SC_2_C_BIND", _SC_2_C_BIND);
+    initConstant(env, c, "_SC_2_C_DEV", _SC_2_C_DEV);
+    initConstant(env, c, "_SC_2_C_VERSION", _SC_2_C_VERSION);
+    initConstant(env, c, "_SC_2_FORT_DEV", _SC_2_FORT_DEV);
+    initConstant(env, c, "_SC_2_FORT_RUN", _SC_2_FORT_RUN);
+    initConstant(env, c, "_SC_2_LOCALEDEF", _SC_2_LOCALEDEF);
+    initConstant(env, c, "_SC_2_SW_DEV", _SC_2_SW_DEV);
+    initConstant(env, c, "_SC_2_UPE", _SC_2_UPE);
+    initConstant(env, c, "_SC_2_VERSION", _SC_2_VERSION);
+    initConstant(env, c, "_SC_AIO_LISTIO_MAX", _SC_AIO_LISTIO_MAX);
+    initConstant(env, c, "_SC_AIO_MAX", _SC_AIO_MAX);
+    initConstant(env, c, "_SC_AIO_PRIO_DELTA_MAX", _SC_AIO_PRIO_DELTA_MAX);
+    initConstant(env, c, "_SC_ARG_MAX", _SC_ARG_MAX);
+    initConstant(env, c, "_SC_ASYNCHRONOUS_IO", _SC_ASYNCHRONOUS_IO);
+    initConstant(env, c, "_SC_ATEXIT_MAX", _SC_ATEXIT_MAX);
+    initConstant(env, c, "_SC_AVPHYS_PAGES", _SC_AVPHYS_PAGES);
+    initConstant(env, c, "_SC_BC_BASE_MAX", _SC_BC_BASE_MAX);
+    initConstant(env, c, "_SC_BC_DIM_MAX", _SC_BC_DIM_MAX);
+    initConstant(env, c, "_SC_BC_SCALE_MAX", _SC_BC_SCALE_MAX);
+    initConstant(env, c, "_SC_BC_STRING_MAX", _SC_BC_STRING_MAX);
+    initConstant(env, c, "_SC_CHILD_MAX", _SC_CHILD_MAX);
+    initConstant(env, c, "_SC_CLK_TCK", _SC_CLK_TCK);
+    initConstant(env, c, "_SC_COLL_WEIGHTS_MAX", _SC_COLL_WEIGHTS_MAX);
+    initConstant(env, c, "_SC_DELAYTIMER_MAX", _SC_DELAYTIMER_MAX);
+    initConstant(env, c, "_SC_EXPR_NEST_MAX", _SC_EXPR_NEST_MAX);
+    initConstant(env, c, "_SC_FSYNC", _SC_FSYNC);
+    initConstant(env, c, "_SC_GETGR_R_SIZE_MAX", _SC_GETGR_R_SIZE_MAX);
+    initConstant(env, c, "_SC_GETPW_R_SIZE_MAX", _SC_GETPW_R_SIZE_MAX);
+    initConstant(env, c, "_SC_IOV_MAX", _SC_IOV_MAX);
+    initConstant(env, c, "_SC_JOB_CONTROL", _SC_JOB_CONTROL);
+    initConstant(env, c, "_SC_LINE_MAX", _SC_LINE_MAX);
+    initConstant(env, c, "_SC_LOGIN_NAME_MAX", _SC_LOGIN_NAME_MAX);
+    initConstant(env, c, "_SC_MAPPED_FILES", _SC_MAPPED_FILES);
+    initConstant(env, c, "_SC_MEMLOCK", _SC_MEMLOCK);
+    initConstant(env, c, "_SC_MEMLOCK_RANGE", _SC_MEMLOCK_RANGE);
+    initConstant(env, c, "_SC_MEMORY_PROTECTION", _SC_MEMORY_PROTECTION);
+    initConstant(env, c, "_SC_MESSAGE_PASSING", _SC_MESSAGE_PASSING);
+    initConstant(env, c, "_SC_MQ_OPEN_MAX", _SC_MQ_OPEN_MAX);
+    initConstant(env, c, "_SC_MQ_PRIO_MAX", _SC_MQ_PRIO_MAX);
+    initConstant(env, c, "_SC_NGROUPS_MAX", _SC_NGROUPS_MAX);
+    initConstant(env, c, "_SC_NPROCESSORS_CONF", _SC_NPROCESSORS_CONF);
+    initConstant(env, c, "_SC_NPROCESSORS_ONLN", _SC_NPROCESSORS_ONLN);
+    initConstant(env, c, "_SC_OPEN_MAX", _SC_OPEN_MAX);
+    initConstant(env, c, "_SC_PAGESIZE", _SC_PAGESIZE);
+    initConstant(env, c, "_SC_PAGE_SIZE", _SC_PAGE_SIZE);
+    initConstant(env, c, "_SC_PASS_MAX", _SC_PASS_MAX);
+    initConstant(env, c, "_SC_PHYS_PAGES", _SC_PHYS_PAGES);
+    initConstant(env, c, "_SC_PRIORITIZED_IO", _SC_PRIORITIZED_IO);
+    initConstant(env, c, "_SC_PRIORITY_SCHEDULING", _SC_PRIORITY_SCHEDULING);
+    initConstant(env, c, "_SC_REALTIME_SIGNALS", _SC_REALTIME_SIGNALS);
+    initConstant(env, c, "_SC_RE_DUP_MAX", _SC_RE_DUP_MAX);
+    initConstant(env, c, "_SC_RTSIG_MAX", _SC_RTSIG_MAX);
+    initConstant(env, c, "_SC_SAVED_IDS", _SC_SAVED_IDS);
+    initConstant(env, c, "_SC_SEMAPHORES", _SC_SEMAPHORES);
+    initConstant(env, c, "_SC_SEM_NSEMS_MAX", _SC_SEM_NSEMS_MAX);
+    initConstant(env, c, "_SC_SEM_VALUE_MAX", _SC_SEM_VALUE_MAX);
+    initConstant(env, c, "_SC_SHARED_MEMORY_OBJECTS", _SC_SHARED_MEMORY_OBJECTS);
+    initConstant(env, c, "_SC_SIGQUEUE_MAX", _SC_SIGQUEUE_MAX);
+    initConstant(env, c, "_SC_STREAM_MAX", _SC_STREAM_MAX);
+    initConstant(env, c, "_SC_SYNCHRONIZED_IO", _SC_SYNCHRONIZED_IO);
+    initConstant(env, c, "_SC_THREADS", _SC_THREADS);
+    initConstant(env, c, "_SC_THREAD_ATTR_STACKADDR", _SC_THREAD_ATTR_STACKADDR);
+    initConstant(env, c, "_SC_THREAD_ATTR_STACKSIZE", _SC_THREAD_ATTR_STACKSIZE);
+    initConstant(env, c, "_SC_THREAD_DESTRUCTOR_ITERATIONS", _SC_THREAD_DESTRUCTOR_ITERATIONS);
+    initConstant(env, c, "_SC_THREAD_KEYS_MAX", _SC_THREAD_KEYS_MAX);
+    initConstant(env, c, "_SC_THREAD_PRIORITY_SCHEDULING", _SC_THREAD_PRIORITY_SCHEDULING);
+    initConstant(env, c, "_SC_THREAD_PRIO_INHERIT", _SC_THREAD_PRIO_INHERIT);
+    initConstant(env, c, "_SC_THREAD_PRIO_PROTECT", _SC_THREAD_PRIO_PROTECT);
+    initConstant(env, c, "_SC_THREAD_SAFE_FUNCTIONS", _SC_THREAD_SAFE_FUNCTIONS);
+    initConstant(env, c, "_SC_THREAD_STACK_MIN", _SC_THREAD_STACK_MIN);
+    initConstant(env, c, "_SC_THREAD_THREADS_MAX", _SC_THREAD_THREADS_MAX);
+    initConstant(env, c, "_SC_TIMERS", _SC_TIMERS);
+    initConstant(env, c, "_SC_TIMER_MAX", _SC_TIMER_MAX);
+    initConstant(env, c, "_SC_TTY_NAME_MAX", _SC_TTY_NAME_MAX);
+    initConstant(env, c, "_SC_TZNAME_MAX", _SC_TZNAME_MAX);
+    initConstant(env, c, "_SC_VERSION", _SC_VERSION);
+    initConstant(env, c, "_SC_XBS5_ILP32_OFF32", _SC_XBS5_ILP32_OFF32);
+    initConstant(env, c, "_SC_XBS5_ILP32_OFFBIG", _SC_XBS5_ILP32_OFFBIG);
+    initConstant(env, c, "_SC_XBS5_LP64_OFF64", _SC_XBS5_LP64_OFF64);
+    initConstant(env, c, "_SC_XBS5_LPBIG_OFFBIG", _SC_XBS5_LPBIG_OFFBIG);
+    initConstant(env, c, "_SC_XOPEN_CRYPT", _SC_XOPEN_CRYPT);
+    initConstant(env, c, "_SC_XOPEN_ENH_I18N", _SC_XOPEN_ENH_I18N);
+    initConstant(env, c, "_SC_XOPEN_LEGACY", _SC_XOPEN_LEGACY);
+    initConstant(env, c, "_SC_XOPEN_REALTIME", _SC_XOPEN_REALTIME);
+    initConstant(env, c, "_SC_XOPEN_REALTIME_THREADS", _SC_XOPEN_REALTIME_THREADS);
+    initConstant(env, c, "_SC_XOPEN_SHM", _SC_XOPEN_SHM);
+    initConstant(env, c, "_SC_XOPEN_UNIX", _SC_XOPEN_UNIX);
+    initConstant(env, c, "_SC_XOPEN_VERSION", _SC_XOPEN_VERSION);
+    initConstant(env, c, "_SC_XOPEN_XCU_VERSION", _SC_XOPEN_XCU_VERSION);
+}
+
+static JNINativeMethod gMethods[] = {
+    NATIVE_METHOD(OsConstantsHolder, initConstants, "()V"),
+};
+void register_android_system_OsConstantsHolder(JNIEnv* env) {
+    jniRegisterNativeMethods(env, "android/system/OsConstantsHolder", gMethods, NELEM(gMethods));
+}
diff --git a/luni/src/main/native/java_lang_StringToReal.cpp b/luni/src/main/native/java_lang_StringToReal.cpp
deleted file mode 100644
index d712708d90e..00000000000
--- a/luni/src/main/native/java_lang_StringToReal.cpp
+++ /dev/null
@@ -1,901 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-#include <nativehelper/JNIHelp.h>
-#include <nativehelper/ScopedUtfChars.h>
-#include <nativehelper/jni_macros.h>
-
-#include "cbigint.h"
-
-#include "JniException.h"
-
-/* ************************* Defines ************************* */
-
-#define LOW_I32_FROM_VAR(u64)     LOW_I32_FROM_LONG64(u64)
-#define LOW_I32_FROM_PTR(u64ptr)  LOW_I32_FROM_LONG64_PTR(u64ptr)
-#define HIGH_I32_FROM_VAR(u64)    HIGH_I32_FROM_LONG64(u64)
-#define HIGH_I32_FROM_PTR(u64ptr) HIGH_I32_FROM_LONG64_PTR(u64ptr)
-
-#define MAX_DOUBLE_ACCURACY_WIDTH 17
-
-#define DEFAULT_DOUBLE_WIDTH MAX_DOUBLE_ACCURACY_WIDTH
-
-#define DOUBLE_INFINITE_LONGBITS (0x7FF0000000000000LL)
-
-#define DOUBLE_MINIMUM_LONGBITS (0x1)
-
-#define DOUBLE_MANTISSA_MASK (0x000FFFFFFFFFFFFFLL)
-#define DOUBLE_EXPONENT_MASK (0x7FF0000000000000LL)
-#define DOUBLE_NORMAL_MASK   (0x0010000000000000LL)
-
-#define allocateU64(x, n) if (!((x) = reinterpret_cast<uint64_t*>(malloc((n) * sizeof(uint64_t))))) goto OutOfMemory;
-
-/* *********************************************************** */
-
-/* ************************ local data ************************ */
-static const jdouble double_tens[] = {
-  1.0,
-  1.0e1,
-  1.0e2,
-  1.0e3,
-  1.0e4,
-  1.0e5,
-  1.0e6,
-  1.0e7,
-  1.0e8,
-  1.0e9,
-  1.0e10,
-  1.0e11,
-  1.0e12,
-  1.0e13,
-  1.0e14,
-  1.0e15,
-  1.0e16,
-  1.0e17,
-  1.0e18,
-  1.0e19,
-  1.0e20,
-  1.0e21,
-  1.0e22
-};
-/* *********************************************************** */
-
-/* ************** private function declarations ************** */
-static jdouble createDouble1   (JNIEnv* env, uint64_t * f, int32_t length, jint e);
-static jdouble doubleAlgorithm (JNIEnv* env, uint64_t * f, int32_t length, jint e,
-                                jdouble z);
-/* *********************************************************** */
-
-#define doubleTenToTheE(e) (*(double_tens + (e)))
-#define DOUBLE_LOG5_OF_TWO_TO_THE_N 23
-
-#define sizeOfTenToTheE(e) (((e) / 19) + 1)
-
-static jdouble createDouble(JNIEnv* env, const char* s, jint e) {
-  /* assumes s is a null terminated string with at least one
-   * character in it */
-  uint64_t def[DEFAULT_DOUBLE_WIDTH];
-  uint64_t defBackup[DEFAULT_DOUBLE_WIDTH];
-  uint64_t* f;
-  uint64_t* fNoOverflow;
-  uint64_t* g;
-  uint64_t* tempBackup;
-  uint32_t overflow;
-  jdouble result;
-  int32_t index = 1;
-  int unprocessedDigits = 0;
-
-  f = def;
-  fNoOverflow = defBackup;
-  *f = 0;
-  tempBackup = g = 0;
-  do
-    {
-      if (*s >= '0' && *s <= '9')
-        {
-          /* Make a back up of f before appending, so that we can
-           * back out of it if there is no more room, i.e. index >
-           * MAX_DOUBLE_ACCURACY_WIDTH.
-           */
-          memcpy (fNoOverflow, f, sizeof (uint64_t) * index);
-          overflow =
-            simpleAppendDecimalDigitHighPrecision (f, index, *s - '0');
-          if (overflow)
-            {
-              f[index++] = overflow;
-              /* There is an overflow, but there is no more room
-               * to store the result. We really only need the top 52
-               * bits anyway, so we must back out of the overflow,
-               * and ignore the rest of the string.
-               */
-              if (index >= MAX_DOUBLE_ACCURACY_WIDTH)
-                {
-                  index--;
-                  memcpy (f, fNoOverflow, sizeof (uint64_t) * index);
-                  break;
-                }
-              if (tempBackup)
-                {
-                  fNoOverflow = tempBackup;
-                }
-            }
-        }
-      else
-        index = -1;
-    }
-  while (index > 0 && *(++s) != '\0');
-
-  /* We've broken out of the parse loop either because we've reached
-   * the end of the string or we've overflowed the maximum accuracy
-   * limit of a double. If we still have unprocessed digits in the
-   * given string, then there are three possible results:
-   *   1. (unprocessed digits + e) == 0, in which case we simply
-   *      convert the existing bits that are already parsed
-   *   2. (unprocessed digits + e) < 0, in which case we simply
-   *      convert the existing bits that are already parsed along
-   *      with the given e
-   *   3. (unprocessed digits + e) > 0 indicates that the value is
-   *      simply too big to be stored as a double, so return Infinity
-   */
-  if ((unprocessedDigits = strlen (s)) > 0)
-    {
-      e += unprocessedDigits;
-      if (index > -1)
-        {
-          if (e == 0)
-            result = toDoubleHighPrecision (f, index);
-          else if (e < 0)
-            result = createDouble1 (env, f, index, e);
-          else
-            {
-              DOUBLE_TO_LONGBITS (result) = DOUBLE_INFINITE_LONGBITS;
-            }
-        }
-      else
-        {
-          LOW_I32_FROM_VAR  (result) = -1;
-          HIGH_I32_FROM_VAR (result) = -1;
-        }
-    }
-  else
-    {
-      if (index > -1)
-        {
-          if (e == 0)
-            result = toDoubleHighPrecision (f, index);
-          else
-            result = createDouble1 (env, f, index, e);
-        }
-      else
-        {
-          LOW_I32_FROM_VAR  (result) = -1;
-          HIGH_I32_FROM_VAR (result) = -1;
-        }
-    }
-
-  return result;
-}
-
-static jdouble createDouble1(JNIEnv* env, uint64_t* f, int32_t length, jint e) {
-  int32_t numBits;
-  jdouble result;
-
-  static const jint APPROX_MIN_MAGNITUDE = -309;
-  static const jint APPROX_MAX_MAGNITUDE = 309;
-
-  numBits = highestSetBitHighPrecision (f, length) + 1;
-  numBits -= lowestSetBitHighPrecision (f, length);
-  if (numBits < 54 && e >= 0 && e < DOUBLE_LOG5_OF_TWO_TO_THE_N)
-    {
-      return toDoubleHighPrecision (f, length) * doubleTenToTheE (e);
-    }
-  else if (numBits < 54 && e < 0 && (-e) < DOUBLE_LOG5_OF_TWO_TO_THE_N)
-    {
-      return toDoubleHighPrecision (f, length) / doubleTenToTheE (-e);
-    }
-  else if (e >= 0 && e < APPROX_MAX_MAGNITUDE)
-    {
-      result = toDoubleHighPrecision (f, length) * pow (10.0, e);
-    }
-  else if (e >= APPROX_MAX_MAGNITUDE)
-    {
-      /* Convert the partial result to make sure that the
-       * non-exponential part is not zero. This check fixes the case
-       * where the user enters 0.0e309! */
-      result = toDoubleHighPrecision (f, length);
-      /* Don't go straight to zero as the fact that x*0 = 0 independent of x might
-         cause the algorithm to produce an incorrect result.  Instead try the min value
-         first and let it fall to zero if need be. */
-
-      if (result == 0.0)
-        {
-          DOUBLE_TO_LONGBITS (result) = DOUBLE_MINIMUM_LONGBITS;
-        }
-      else
-        {
-          DOUBLE_TO_LONGBITS (result) = DOUBLE_INFINITE_LONGBITS;
-          return result;
-        }
-    }
-  else if (e > APPROX_MIN_MAGNITUDE)
-    {
-      result = toDoubleHighPrecision (f, length) / pow (10.0, -e);
-    }
-
-  if (e <= APPROX_MIN_MAGNITUDE)
-    {
-
-      result = toDoubleHighPrecision (f, length) * pow (10.0, e + 52);
-      result = result * pow (10.0, -52);
-
-    }
-
-  /* Don't go straight to zero as the fact that x*0 = 0 independent of x might
-     cause the algorithm to produce an incorrect result.  Instead try the min value
-     first and let it fall to zero if need be. */
-
-  if (result == 0.0)
-    DOUBLE_TO_LONGBITS (result) = DOUBLE_MINIMUM_LONGBITS;
-
-  return doubleAlgorithm (env, f, length, e, result);
-}
-
-/* The algorithm for the function doubleAlgorithm() below can be found
- * in:
- *
- *      "How to Read Floating-Point Numbers Accurately", William D.
- *      Clinger, Proceedings of the ACM SIGPLAN '90 Conference on
- *      Programming Language Design and Implementation, June 20-22,
- *      1990, pp. 92-101.
- */
-static jdouble doubleAlgorithm(JNIEnv* env, uint64_t* f, int32_t length, jint e, jdouble z) {
-  uint64_t m;
-  int32_t k, comparison, comparison2;
-  uint64_t* x;
-  uint64_t* y;
-  uint64_t* D;
-  uint64_t* D2;
-  int32_t xLength, yLength, DLength, D2Length;
-
-  x = y = D = D2 = 0;
-  xLength = yLength = DLength = D2Length = 0;
-
-  do
-    {
-      m = doubleMantissa (z);
-      k = doubleExponent (z);
-
-      if (x && x != f)
-          free(x);
-
-      free(y);
-      free(D);
-      free(D2);
-      y = D = D2 = NULL;
-
-      if (e >= 0 && k >= 0)
-        {
-          xLength = sizeOfTenToTheE (e) + length;
-          allocateU64 (x, xLength);
-          memset (x + length, 0, sizeof (uint64_t) * (xLength - length));
-          memcpy (x, f, sizeof (uint64_t) * length);
-          timesTenToTheEHighPrecision (x, xLength, e);
-
-          yLength = (k >> 6) + 2;
-          allocateU64 (y, yLength);
-          memset (y + 1, 0, sizeof (uint64_t) * (yLength - 1));
-          *y = m;
-          simpleShiftLeftHighPrecision (y, yLength, k);
-        }
-      else if (e >= 0)
-        {
-          xLength = sizeOfTenToTheE (e) + length + ((-k) >> 6) + 1;
-          allocateU64 (x, xLength);
-          memset (x + length, 0, sizeof (uint64_t) * (xLength - length));
-          memcpy (x, f, sizeof (uint64_t) * length);
-          timesTenToTheEHighPrecision (x, xLength, e);
-          simpleShiftLeftHighPrecision (x, xLength, -k);
-
-          yLength = 1;
-          allocateU64 (y, 1);
-          *y = m;
-        }
-      else if (k >= 0)
-        {
-          xLength = length;
-          x = f;
-
-          yLength = sizeOfTenToTheE (-e) + 2 + (k >> 6);
-          allocateU64 (y, yLength);
-          memset (y + 1, 0, sizeof (uint64_t) * (yLength - 1));
-          *y = m;
-          timesTenToTheEHighPrecision (y, yLength, -e);
-          simpleShiftLeftHighPrecision (y, yLength, k);
-        }
-      else
-        {
-          xLength = length + ((-k) >> 6) + 1;
-          allocateU64 (x, xLength);
-          memset (x + length, 0, sizeof (uint64_t) * (xLength - length));
-          memcpy (x, f, sizeof (uint64_t) * length);
-          simpleShiftLeftHighPrecision (x, xLength, -k);
-
-          yLength = sizeOfTenToTheE (-e) + 1;
-          allocateU64 (y, yLength);
-          memset (y + 1, 0, sizeof (uint64_t) * (yLength - 1));
-          *y = m;
-          timesTenToTheEHighPrecision (y, yLength, -e);
-        }
-
-      comparison = compareHighPrecision (x, xLength, y, yLength);
-      if (comparison > 0)
-        {                       /* x > y */
-          DLength = xLength;
-          allocateU64 (D, DLength);
-          memcpy (D, x, DLength * sizeof (uint64_t));
-          subtractHighPrecision (D, DLength, y, yLength);
-        }
-      else if (comparison)
-        {                       /* y > x */
-          DLength = yLength;
-          allocateU64 (D, DLength);
-          memcpy (D, y, DLength * sizeof (uint64_t));
-          subtractHighPrecision (D, DLength, x, xLength);
-        }
-      else
-        {                       /* y == x */
-          DLength = 1;
-          allocateU64 (D, 1);
-          *D = 0;
-        }
-
-      D2Length = DLength + 1;
-      allocateU64 (D2, D2Length);
-      m <<= 1;
-      multiplyHighPrecision (D, DLength, &m, 1, D2, D2Length);
-      m >>= 1;
-
-      comparison2 = compareHighPrecision (D2, D2Length, y, yLength);
-      if (comparison2 < 0)
-        {
-          if (comparison < 0 && m == DOUBLE_NORMAL_MASK
-              && DOUBLE_TO_LONGBITS(z) != DOUBLE_NORMAL_MASK)
-            {
-              simpleShiftLeftHighPrecision (D2, D2Length, 1);
-              if (compareHighPrecision (D2, D2Length, y, yLength) > 0)
-                {
-                  --DOUBLE_TO_LONGBITS (z);
-                }
-              else
-                {
-                  break;
-                }
-            }
-          else
-            {
-              break;
-            }
-        }
-      else if (comparison2 == 0)
-        {
-          if ((LOW_U32_FROM_VAR (m) & 1) == 0)
-            {
-              if (comparison < 0 && m == DOUBLE_NORMAL_MASK)
-                {
-                  --DOUBLE_TO_LONGBITS (z);
-                }
-              else
-                {
-                  break;
-                }
-            }
-          else if (comparison < 0)
-            {
-              --DOUBLE_TO_LONGBITS (z);
-              break;
-            }
-          else
-            {
-              ++DOUBLE_TO_LONGBITS (z);
-              break;
-            }
-        }
-      else if (comparison < 0)
-        {
-          --DOUBLE_TO_LONGBITS (z);
-        }
-      else
-        {
-          if (DOUBLE_TO_LONGBITS (z) == DOUBLE_INFINITE_LONGBITS)
-            break;
-          ++DOUBLE_TO_LONGBITS (z);
-        }
-    }
-  while (1);
-
-  if (x && x != f)
-     free(x);
-  free(y);
-  free(D);
-  free(D2);
-  return z;
-
-OutOfMemory:
-  if (x && x != f)
-      free(x);
-  free(y);
-  free(D);
-  free(D2);
-  jniThrowOutOfMemoryError(env, NULL);
-  return z;
-}
-
-
-
-#define MAX_FLOAT_ACCURACY_WIDTH 8
-
-#define DEFAULT_FLOAT_WIDTH MAX_FLOAT_ACCURACY_WIDTH
-
-static jfloat createFloat1(JNIEnv* env, uint64_t* f, int32_t length, jint e);
-static jfloat floatAlgorithm(JNIEnv* env, uint64_t* f, int32_t length, jint e, jfloat z);
-
-static const uint32_t float_tens[] = {
-  0x3f800000,
-  0x41200000,
-  0x42c80000,
-  0x447a0000,
-  0x461c4000,
-  0x47c35000,
-  0x49742400,
-  0x4b189680,
-  0x4cbebc20,
-  0x4e6e6b28,
-  0x501502f9                    /* 10 ^ 10 in float */
-};
-
-#define floatTenToTheE(e) (*reinterpret_cast<const jfloat*>(float_tens + (e)))
-#define FLOAT_LOG5_OF_TWO_TO_THE_N 11
-
-#define FLOAT_INFINITE_INTBITS (0x7F800000)
-#define FLOAT_MINIMUM_INTBITS (1)
-
-#define FLOAT_MANTISSA_MASK (0x007FFFFF)
-#define FLOAT_EXPONENT_MASK (0x7F800000)
-#define FLOAT_NORMAL_MASK   (0x00800000)
-
-static jfloat createFloat(JNIEnv* env, const char* s, jint e) {
-  /* assumes s is a null terminated string with at least one
-   * character in it */
-  uint64_t def[DEFAULT_FLOAT_WIDTH];
-  uint64_t defBackup[DEFAULT_FLOAT_WIDTH];
-  uint64_t* f;
-  uint64_t* fNoOverflow;
-  uint64_t* g;
-  uint64_t* tempBackup;
-  uint32_t overflow;
-  jfloat result;
-  int32_t index = 1;
-  int unprocessedDigits = 0;
-
-  f = def;
-  fNoOverflow = defBackup;
-  *f = 0;
-  tempBackup = g = 0;
-  do
-    {
-      if (*s >= '0' && *s <= '9')
-        {
-          /* Make a back up of f before appending, so that we can
-           * back out of it if there is no more room, i.e. index >
-           * MAX_FLOAT_ACCURACY_WIDTH.
-           */
-          memcpy (fNoOverflow, f, sizeof (uint64_t) * index);
-          overflow =
-            simpleAppendDecimalDigitHighPrecision (f, index, *s - '0');
-          if (overflow)
-            {
-
-              f[index++] = overflow;
-              /* There is an overflow, but there is no more room
-               * to store the result. We really only need the top 52
-               * bits anyway, so we must back out of the overflow,
-               * and ignore the rest of the string.
-               */
-              if (index >= MAX_FLOAT_ACCURACY_WIDTH)
-                {
-                  index--;
-                  memcpy (f, fNoOverflow, sizeof (uint64_t) * index);
-                  break;
-                }
-              if (tempBackup)
-                {
-                  fNoOverflow = tempBackup;
-                }
-            }
-        }
-      else
-        index = -1;
-    }
-  while (index > 0 && *(++s) != '\0');
-
-  /* We've broken out of the parse loop either because we've reached
-   * the end of the string or we've overflowed the maximum accuracy
-   * limit of a double. If we still have unprocessed digits in the
-   * given string, then there are three possible results:
-   *   1. (unprocessed digits + e) == 0, in which case we simply
-   *      convert the existing bits that are already parsed
-   *   2. (unprocessed digits + e) < 0, in which case we simply
-   *      convert the existing bits that are already parsed along
-   *      with the given e
-   *   3. (unprocessed digits + e) > 0 indicates that the value is
-   *      simply too big to be stored as a double, so return Infinity
-   */
-  if ((unprocessedDigits = strlen (s)) > 0)
-    {
-      e += unprocessedDigits;
-      if (index > -1)
-        {
-          if (e <= 0)
-            {
-              result = createFloat1 (env, f, index, e);
-            }
-          else
-            {
-              FLOAT_TO_INTBITS (result) = FLOAT_INFINITE_INTBITS;
-            }
-        }
-      else
-        {
-          result = INTBITS_TO_FLOAT(index);
-        }
-    }
-  else
-    {
-      if (index > -1)
-        {
-          result = createFloat1 (env, f, index, e);
-        }
-      else
-        {
-          result = INTBITS_TO_FLOAT(index);
-        }
-    }
-
-  return result;
-}
-
-static jfloat createFloat1 (JNIEnv* env, uint64_t* f, int32_t length, jint e) {
-  int32_t numBits;
-  jdouble dresult;
-  jfloat result;
-
-  numBits = highestSetBitHighPrecision (f, length) + 1;
-  if (numBits < 25 && e >= 0 && e < FLOAT_LOG5_OF_TWO_TO_THE_N)
-    {
-      return ((jfloat) LOW_I32_FROM_PTR (f)) * floatTenToTheE (e);
-    }
-  else if (numBits < 25 && e < 0 && (-e) < FLOAT_LOG5_OF_TWO_TO_THE_N)
-    {
-      return ((jfloat) LOW_I32_FROM_PTR (f)) / floatTenToTheE (-e);
-    }
-  else if (e >= 0 && e < 39)
-    {
-      result = (jfloat) (toDoubleHighPrecision (f, length) * pow (10.0, (double) e));
-    }
-  else if (e >= 39)
-    {
-      /* Convert the partial result to make sure that the
-       * non-exponential part is not zero. This check fixes the case
-       * where the user enters 0.0e309! */
-      result = (jfloat) toDoubleHighPrecision (f, length);
-
-      if (result == 0.0)
-
-        FLOAT_TO_INTBITS (result) = FLOAT_MINIMUM_INTBITS;
-      else
-        FLOAT_TO_INTBITS (result) = FLOAT_INFINITE_INTBITS;
-    }
-  else if (e > -309)
-    {
-      int dexp;
-      uint32_t fmant, fovfl;
-      uint64_t dmant;
-      dresult = toDoubleHighPrecision (f, length) / pow (10.0, (double) -e);
-      if (IS_DENORMAL_DBL (dresult))
-        {
-          FLOAT_TO_INTBITS (result) = 0;
-          return result;
-        }
-      dexp = doubleExponent (dresult) + 51;
-      dmant = doubleMantissa (dresult);
-      /* Is it too small to be represented by a single-precision
-       * float? */
-      if (dexp <= -155)
-        {
-          FLOAT_TO_INTBITS (result) = 0;
-          return result;
-        }
-      /* Is it a denormalized single-precision float? */
-      if ((dexp <= -127) && (dexp > -155))
-        {
-          /* Only interested in 24 msb bits of the 53-bit double mantissa */
-          fmant = (uint32_t) (dmant >> 29);
-          fovfl = ((uint32_t) (dmant & 0x1FFFFFFF)) << 3;
-          while ((dexp < -127) && ((fmant | fovfl) != 0))
-            {
-              if ((fmant & 1) != 0)
-                {
-                  fovfl |= 0x80000000;
-                }
-              fovfl >>= 1;
-              fmant >>= 1;
-              dexp++;
-            }
-          if ((fovfl & 0x80000000) != 0)
-            {
-              if ((fovfl & 0x7FFFFFFC) != 0)
-                {
-                  fmant++;
-                }
-              else if ((fmant & 1) != 0)
-                {
-                  fmant++;
-                }
-            }
-          else if ((fovfl & 0x40000000) != 0)
-            {
-              if ((fovfl & 0x3FFFFFFC) != 0)
-                {
-                  fmant++;
-                }
-            }
-          FLOAT_TO_INTBITS (result) = fmant;
-        }
-      else
-        {
-          result = (jfloat) dresult;
-        }
-    }
-
-  /* Don't go straight to zero as the fact that x*0 = 0 independent
-   * of x might cause the algorithm to produce an incorrect result.
-   * Instead try the min  value first and let it fall to zero if need
-   * be.
-   */
-  if (e <= -309 || FLOAT_TO_INTBITS (result) == 0)
-    FLOAT_TO_INTBITS (result) = FLOAT_MINIMUM_INTBITS;
-
-  return floatAlgorithm (env, f, length, e, (jfloat) result);
-}
-
-/* The algorithm for the function floatAlgorithm() below can be found
- * in:
- *
- *      "How to Read Floating-Point Numbers Accurately", William D.
- *      Clinger, Proceedings of the ACM SIGPLAN '90 Conference on
- *      Programming Language Design and Implementation, June 20-22,
- *      1990, pp. 92-101.
- */
-static jfloat floatAlgorithm(JNIEnv* env, uint64_t* f, int32_t length, jint e, jfloat z) {
-  uint64_t m;
-  int32_t k, comparison, comparison2;
-  uint64_t* x;
-  uint64_t* y;
-  uint64_t* D;
-  uint64_t* D2;
-  int32_t xLength, yLength, DLength, D2Length;
-
-  x = y = D = D2 = 0;
-  xLength = yLength = DLength = D2Length = 0;
-
-  do
-    {
-      m = floatMantissa (z);
-      k = floatExponent (z);
-
-      if (x && x != f)
-          free(x);
-
-      free(y);
-      free(D);
-      free(D2);
-      y = D = D2 = NULL;
-
-      if (e >= 0 && k >= 0)
-        {
-          xLength = sizeOfTenToTheE (e) + length;
-          allocateU64 (x, xLength);
-          memset (x + length, 0, sizeof (uint64_t) * (xLength - length));
-          memcpy (x, f, sizeof (uint64_t) * length);
-          timesTenToTheEHighPrecision (x, xLength, e);
-
-          yLength = (k >> 6) + 2;
-          allocateU64 (y, yLength);
-          memset (y + 1, 0, sizeof (uint64_t) * (yLength - 1));
-          *y = m;
-          simpleShiftLeftHighPrecision (y, yLength, k);
-        }
-      else if (e >= 0)
-        {
-          xLength = sizeOfTenToTheE (e) + length + ((-k) >> 6) + 1;
-          allocateU64 (x, xLength);
-          memset (x + length, 0, sizeof (uint64_t) * (xLength - length));
-          memcpy (x, f, sizeof (uint64_t) * length);
-          timesTenToTheEHighPrecision (x, xLength, e);
-          simpleShiftLeftHighPrecision (x, xLength, -k);
-
-          yLength = 1;
-          allocateU64 (y, 1);
-          *y = m;
-        }
-      else if (k >= 0)
-        {
-          xLength = length;
-          x = f;
-
-          yLength = sizeOfTenToTheE (-e) + 2 + (k >> 6);
-          allocateU64 (y, yLength);
-          memset (y + 1, 0, sizeof (uint64_t) * (yLength - 1));
-          *y = m;
-          timesTenToTheEHighPrecision (y, yLength, -e);
-          simpleShiftLeftHighPrecision (y, yLength, k);
-        }
-      else
-        {
-          xLength = length + ((-k) >> 6) + 1;
-          allocateU64 (x, xLength);
-          memset (x + length, 0, sizeof (uint64_t) * (xLength - length));
-          memcpy (x, f, sizeof (uint64_t) * length);
-          simpleShiftLeftHighPrecision (x, xLength, -k);
-
-          yLength = sizeOfTenToTheE (-e) + 1;
-          allocateU64 (y, yLength);
-          memset (y + 1, 0, sizeof (uint64_t) * (yLength - 1));
-          *y = m;
-          timesTenToTheEHighPrecision (y, yLength, -e);
-        }
-
-      comparison = compareHighPrecision (x, xLength, y, yLength);
-      if (comparison > 0)
-        {                       /* x > y */
-          DLength = xLength;
-          allocateU64 (D, DLength);
-          memcpy (D, x, DLength * sizeof (uint64_t));
-          subtractHighPrecision (D, DLength, y, yLength);
-        }
-      else if (comparison)
-        {                       /* y > x */
-          DLength = yLength;
-          allocateU64 (D, DLength);
-          memcpy (D, y, DLength * sizeof (uint64_t));
-          subtractHighPrecision (D, DLength, x, xLength);
-        }
-      else
-        {                       /* y == x */
-          DLength = 1;
-          allocateU64 (D, 1);
-          *D = 0;
-        }
-
-      D2Length = DLength + 1;
-      allocateU64 (D2, D2Length);
-      m <<= 1;
-      multiplyHighPrecision (D, DLength, &m, 1, D2, D2Length);
-      m >>= 1;
-
-      comparison2 = compareHighPrecision (D2, D2Length, y, yLength);
-      if (comparison2 < 0)
-        {
-          if (comparison < 0 && m == FLOAT_NORMAL_MASK
-              && FLOAT_TO_INTBITS(z) != FLOAT_NORMAL_MASK)
-            {
-              simpleShiftLeftHighPrecision (D2, D2Length, 1);
-              if (compareHighPrecision (D2, D2Length, y, yLength) > 0)
-                {
-                  --FLOAT_TO_INTBITS (z);
-                }
-              else
-                {
-                  break;
-                }
-            }
-          else
-            {
-              break;
-            }
-        }
-      else if (comparison2 == 0)
-        {
-          if ((m & 1) == 0)
-            {
-              if (comparison < 0 && m == FLOAT_NORMAL_MASK)
-                {
-                  --FLOAT_TO_INTBITS (z);
-                }
-              else
-                {
-                  break;
-                }
-            }
-          else if (comparison < 0)
-            {
-              --FLOAT_TO_INTBITS (z);
-              break;
-            }
-          else
-            {
-              ++FLOAT_TO_INTBITS (z);
-              break;
-            }
-        }
-      else if (comparison < 0)
-        {
-          --FLOAT_TO_INTBITS (z);
-        }
-      else
-        {
-          if (FLOAT_TO_INTBITS (z) == FLOAT_EXPONENT_MASK)
-            break;
-          ++FLOAT_TO_INTBITS (z);
-        }
-    }
-  while (1);
-
-  if (x && x != f)
-      free(x);
-  free(y);
-  free(D);
-  free(D2);
-  return z;
-
-OutOfMemory:
-  if (x && x != f)
-      free(x);
-  free(y);
-  free(D);
-  free(D2);
-  jniThrowOutOfMemoryError(env, NULL);
-  return z;
-}
-
-static jfloat StringToReal_parseFltImpl(JNIEnv* env, jclass, jstring s, jint e) {
-    ScopedUtfChars str(env, s);
-    if (str.c_str() == NULL) {
-        return 0.0;
-    }
-    return createFloat(env, str.c_str(), e);
-}
-
-static jdouble StringToReal_parseDblImpl(JNIEnv* env, jclass, jstring s, jint e) {
-    ScopedUtfChars str(env, s);
-    if (str.c_str() == NULL) {
-        return 0.0;
-    }
-    return createDouble(env, str.c_str(), e);
-}
-
-static JNINativeMethod gMethods[] = {
-    NATIVE_METHOD(StringToReal, parseFltImpl, "(Ljava/lang/String;I)F"),
-    NATIVE_METHOD(StringToReal, parseDblImpl, "(Ljava/lang/String;I)D"),
-};
-void register_java_lang_StringToReal(JNIEnv* env) {
-    jniRegisterNativeMethods(env, "java/lang/StringToReal", gMethods, NELEM(gMethods));
-}
diff --git a/luni/src/main/native/libcore_io_Linux.cpp b/luni/src/main/native/libcore_io_Linux.cpp
index 78b1788981c..78f1834cd52 100644
--- a/luni/src/main/native/libcore_io_Linux.cpp
+++ b/luni/src/main/native/libcore_io_Linux.cpp
@@ -18,6 +18,7 @@
 
 #include <arpa/inet.h>
 #include <errno.h>
+#include <dlfcn.h>
 #include <fcntl.h>
 #include <ifaddrs.h>
 #include <linux/rtnetlink.h>
@@ -697,7 +698,7 @@ static bool javaUnixSocketAddressToSockaddr(
             JniConstants::GetUnixSocketAddressClass(env), "sun_path", "[B");
 
     struct sockaddr_un* un_addr = reinterpret_cast<struct sockaddr_un*>(&ss);
-    memset (un_addr, 0, sizeof(sockaddr_un));
+    memset(un_addr, 0, sizeof(sockaddr_un));
     un_addr->sun_family = AF_UNIX;
 
     jbyteArray javaSunPath = (jbyteArray) env->GetObjectField(javaUnixSocketAddress, sunPathFid);
@@ -813,10 +814,9 @@ static jobject doStat(JNIEnv* env, jstring javaPath, bool isLstat) {
 
 static jobject doGetSockName(JNIEnv* env, jobject javaFd, bool is_sockname) {
   int fd = jniGetFDFromFileDescriptor(env, javaFd);
-  sockaddr_storage ss;
+  sockaddr_storage ss = {};
   sockaddr* sa = reinterpret_cast<sockaddr*>(&ss);
   socklen_t byteCount = sizeof(ss);
-  memset(&ss, 0, byteCount);
   int rc = is_sockname ? TEMP_FAILURE_RETRY(getsockname(fd, sa, &byteCount))
       : TEMP_FAILURE_RETRY(getpeername(fd, sa, &byteCount));
   if (rc == -1) {
@@ -1016,9 +1016,8 @@ static size_t GetCapUserDataLength(uint32_t version) {
 }
 
 static jobject Linux_accept(JNIEnv* env, jobject, jobject javaFd, jobject javaSocketAddress) {
-    sockaddr_storage ss;
+    sockaddr_storage ss = {};
     socklen_t sl = sizeof(ss);
-    memset(&ss, 0, sizeof(ss));
     sockaddr* peer = (javaSocketAddress != NULL) ? reinterpret_cast<sockaddr*>(&ss) : NULL;
     socklen_t* peerLength = (javaSocketAddress != NULL) ? &sl : 0;
     jint clientFd = NET_FAILURE_RETRY(env, int, accept, javaFd, peer, peerLength);
@@ -1253,6 +1252,34 @@ static void Linux_connectSocketAddress(
     (void) NET_FAILURE_RETRY(env, int, connect, javaFd, sa, sa_len);
 }
 
+static jobject makeStructDlInfo(JNIEnv* env, const Dl_info& dl_info) {
+    jclass dlInfoClass = JniConstants::GetStructDlInfoClass(env);
+    static jmethodID ctor = env->GetMethodID(dlInfoClass,
+                                             "<init>",
+                                             "(Ljava/lang/String;JLjava/lang/String;J)V");
+    if (ctor == nullptr) {
+        return nullptr;
+    }
+    TO_JAVA_STRING(dli_fname, dl_info.dli_fname);
+    jlong dli_fbase = reinterpret_cast<jlong>(dl_info.dli_fbase);
+    TO_JAVA_STRING(dli_sname, dl_info.dli_sname);
+    jlong dli_saddr = reinterpret_cast<jlong>(dl_info.dli_saddr);
+
+    return env->NewObject(dlInfoClass, ctor, dli_fname, dli_fbase, dli_sname, dli_saddr);
+}
+
+static jobject Linux_dladdr(JNIEnv* env, jobject, jlong jaddr) {
+    void* addr = reinterpret_cast<void*>(jaddr);
+    Dl_info info;
+    int ret = dladdr(addr, &info);
+
+    if (ret == 0) {
+        return nullptr;
+    }
+
+    return makeStructDlInfo(env, info);
+}
+
 static jobject Linux_dup(JNIEnv* env, jobject, jobject javaOldFd) {
     int oldFd = jniGetFDFromFileDescriptor(env, javaOldFd);
     int newFd = throwIfMinusOne(env, "dup", TEMP_FAILURE_RETRY(dup(oldFd)));
@@ -1368,8 +1395,7 @@ static jobjectArray Linux_android_getaddrinfo(JNIEnv* env, jobject, jstring java
     static jfieldID socktypeFid = env->GetFieldID(JniConstants::GetStructAddrinfoClass(env), "ai_socktype", "I");
     static jfieldID protocolFid = env->GetFieldID(JniConstants::GetStructAddrinfoClass(env), "ai_protocol", "I");
 
-    addrinfo hints;
-    memset(&hints, 0, sizeof(hints));
+    addrinfo hints= {};
     hints.ai_flags = env->GetIntField(javaHints, flagsFid);
     hints.ai_family = env->GetIntField(javaHints, familyFid);
     hints.ai_socktype = env->GetIntField(javaHints, socktypeFid);
@@ -1517,8 +1543,7 @@ static jint Linux_getsockoptByte(JNIEnv* env, jobject, jobject javaFd, jint leve
 
 static jobject Linux_getsockoptInAddr(JNIEnv* env, jobject, jobject javaFd, jint level, jint option) {
     int fd = jniGetFDFromFileDescriptor(env, javaFd);
-    sockaddr_storage ss;
-    memset(&ss, 0, sizeof(ss));
+    sockaddr_storage ss = {};
     ss.ss_family = AF_INET; // This is only for the IPv4-only IP_MULTICAST_IF.
     sockaddr_in* sa = reinterpret_cast<sockaddr_in*>(&ss);
     socklen_t size = sizeof(sa->sin_addr);
@@ -1540,9 +1565,8 @@ static jint Linux_getsockoptInt(JNIEnv* env, jobject, jobject javaFd, jint level
 
 static jobject Linux_getsockoptLinger(JNIEnv* env, jobject, jobject javaFd, jint level, jint option) {
     int fd = jniGetFDFromFileDescriptor(env, javaFd);
-    struct linger l;
+    struct linger l = {};
     socklen_t size = sizeof(l);
-    memset(&l, 0, size);
     int rc = TEMP_FAILURE_RETRY(getsockopt(fd, level, option, &l, &size));
     if (rc == -1) {
         throwErrnoException(env, "getsockopt");
@@ -1553,9 +1577,8 @@ static jobject Linux_getsockoptLinger(JNIEnv* env, jobject, jobject javaFd, jint
 
 static jobject Linux_getsockoptTimeval(JNIEnv* env, jobject, jobject javaFd, jint level, jint option) {
     int fd = jniGetFDFromFileDescriptor(env, javaFd);
-    struct timeval tv;
+    struct timeval tv = {};
     socklen_t size = sizeof(tv);
-    memset(&tv, 0, size);
     int rc = TEMP_FAILURE_RETRY(getsockopt(fd, level, option, &tv, &size));
     if (rc == -1) {
         throwErrnoException(env, "getsockopt");
@@ -1573,9 +1596,8 @@ static jobject Linux_getsockoptTimeval(JNIEnv* env, jobject, jobject javaFd, jin
 
 static jobject Linux_getsockoptUcred(JNIEnv* env, jobject, jobject javaFd, jint level, jint option) {
   int fd = jniGetFDFromFileDescriptor(env, javaFd);
-  struct ucred u;
+  struct ucred u = {};
   socklen_t size = sizeof(u);
-  memset(&u, 0, size);
   int rc = TEMP_FAILURE_RETRY(getsockopt(fd, level, option, &u, &size));
   if (rc == -1) {
     throwErrnoException(env, "getsockopt");
@@ -1759,8 +1781,7 @@ static jobject Linux_inet_pton(JNIEnv* env, jobject, jint family, jstring javaNa
     if (name.c_str() == NULL) {
         return NULL;
     }
-    sockaddr_storage ss;
-    memset(&ss, 0, sizeof(ss));
+    sockaddr_storage ss = {};
     void* dst;
     if (family == AF_INET) {
       dst = &reinterpret_cast<sockaddr_in*>(&ss)->sin_addr;
@@ -2163,9 +2184,8 @@ static jint Linux_recvfromBytes(JNIEnv* env, jobject, jobject javaFd, jobject ja
     if (bytes.get() == NULL) {
         return -1;
     }
-    sockaddr_storage ss;
+    sockaddr_storage ss = {};
     socklen_t sl = sizeof(ss);
-    memset(&ss, 0, sizeof(ss));
     sockaddr* from = (javaInetSocketAddress != NULL) ? reinterpret_cast<sockaddr*>(&ss) : NULL;
     socklen_t* fromLength = (javaInetSocketAddress != NULL) ? &sl : 0;
     jint recvCount = NET_FAILURE_RETRY(env, ssize_t, recvfrom, javaFd, bytes.get() + byteOffset, byteCount, flags, from, fromLength);
@@ -2462,17 +2482,13 @@ static void Linux_setsockoptInt(JNIEnv* env, jobject, jobject javaFd, jint level
 }
 
 static void Linux_setsockoptIpMreqn(JNIEnv* env, jobject, jobject javaFd, jint level, jint option, jint value) {
-    ip_mreqn req;
-    memset(&req, 0, sizeof(req));
-    req.imr_ifindex = value;
+    ip_mreqn req = { .imr_ifindex = value };
     int fd = jniGetFDFromFileDescriptor(env, javaFd);
     throwIfMinusOne(env, "setsockopt", TEMP_FAILURE_RETRY(setsockopt(fd, level, option, &req, sizeof(req))));
 }
 
 static void Linux_setsockoptGroupReq(JNIEnv* env, jobject, jobject javaFd, jint level, jint option, jobject javaGroupReq) {
-    struct group_req req;
-    memset(&req, 0, sizeof(req));
-
+    struct group_req req = {};
     static jfieldID grInterfaceFid = env->GetFieldID(JniConstants::GetStructGroupReqClass(env), "gr_interface", "I");
     req.gr_interface = env->GetIntField(javaGroupReq, grInterfaceFid);
     // Get the IPv4 or IPv6 multicast address to join or leave.
@@ -2770,6 +2786,7 @@ static JNINativeMethod gMethods[] = {
     NATIVE_METHOD(Linux, close, "(Ljava/io/FileDescriptor;)V"),
     NATIVE_METHOD(Linux, connect, "(Ljava/io/FileDescriptor;Ljava/net/InetAddress;I)V"),
     NATIVE_METHOD_OVERLOAD(Linux, connect, "(Ljava/io/FileDescriptor;Ljava/net/SocketAddress;)V", SocketAddress),
+    NATIVE_METHOD(Linux, dladdr, "(J)Landroid/system/StructDlInfo;"),
     NATIVE_METHOD(Linux, dup, "(Ljava/io/FileDescriptor;)Ljava/io/FileDescriptor;"),
     NATIVE_METHOD(Linux, dup2, "(Ljava/io/FileDescriptor;I)Ljava/io/FileDescriptor;"),
     NATIVE_METHOD(Linux, environ, "()[Ljava/lang/String;"),
diff --git a/luni/src/main/native/libcore_util_NativeAllocationRegistry.cpp b/luni/src/main/native/libcore_util_NativeAllocationRegistry.cpp
index ded578a9580..675e3367a70 100644
--- a/luni/src/main/native/libcore_util_NativeAllocationRegistry.cpp
+++ b/luni/src/main/native/libcore_util_NativeAllocationRegistry.cpp
@@ -14,6 +14,10 @@
  * limitations under the License.
  */
 
+#include <dlfcn.h>
+#include <ios>
+#include <sstream>
+
 #include <nativehelper/JNIHelp.h>
 #include <nativehelper/jni_macros.h>
 
@@ -29,8 +33,25 @@ static void NativeAllocationRegistry_applyFreeFunction(JNIEnv*,
     nativeFreeFunction(nativePtr);
 }
 
+static jstring NativeAllocationRegistry_dlAddr(JNIEnv* env, jclass, jlong freeFunction) {
+    uintptr_t ff = static_cast<uintptr_t>(freeFunction);
+    Dl_info info;
+    int ret = dladdr(reinterpret_cast<void*>(ff), &info);
+    std::stringstream result;
+    if (ret == 0 /* failed */ || info.dli_fname == nullptr || strlen(info.dli_fname) == 0) {
+      result << "0x" << std::hex << ff;
+    } else if (info.dli_sname == nullptr) {
+      result << info.dli_fname << "+" << (ff - reinterpret_cast<uintptr_t>(info.dli_fbase));
+    } else {
+      result << info.dli_sname << "+" << (ff - reinterpret_cast<uintptr_t>(info.dli_saddr));
+    }
+    return env->NewStringUTF(result.str().c_str());
+}
+
+
 static JNINativeMethod gMethods[] = {
     NATIVE_METHOD(NativeAllocationRegistry, applyFreeFunction, "(JJ)V"),
+    NATIVE_METHOD(NativeAllocationRegistry, dlAddr, "(J)Ljava/lang/String;"),
 };
 
 void register_libcore_util_NativeAllocationRegistry(JNIEnv* env) {
diff --git a/luni/src/main/native/valueOf.cpp b/luni/src/main/native/valueOf.cpp
deleted file mode 100644
index aa5893c059b..00000000000
--- a/luni/src/main/native/valueOf.cpp
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "valueOf"
-
-#include "valueOf.h"
-
-#include <nativehelper/JNIHelp.h>
-
-#include "JniConstants.h"
-
-template <typename T>
-static jobject valueOf(JNIEnv* env, jclass c, const char* signature, const T& value) {
-    static jmethodID valueOfMethod = env->GetStaticMethodID(c, "valueOf", signature);
-    if (env->ExceptionCheck()) {
-        return NULL;
-    }
-    jobject result = env->CallStaticObjectMethod(c, valueOfMethod, value);
-    if (env->ExceptionCheck()) {
-        return NULL;
-    }
-    return result;
-}
-
-jobject booleanValueOf(JNIEnv* env, jboolean value) {
-    return valueOf(env, JniConstants::GetBooleanClass(env), "(Z)Ljava/lang/Boolean;", value);
-}
-
-jobject doubleValueOf(JNIEnv* env, jdouble value) {
-    return valueOf(env, JniConstants::GetDoubleClass(env), "(D)Ljava/lang/Double;", value);
-}
-
-jobject integerValueOf(JNIEnv* env, jint value) {
-    return valueOf(env, JniConstants::GetIntegerClass(env), "(I)Ljava/lang/Integer;", value);
-}
-
-jobject longValueOf(JNIEnv* env, jlong value) {
-    return valueOf(env, JniConstants::GetLongClass(env), "(J)Ljava/lang/Long;", value);
-}
-
-jboolean booleanValue(JNIEnv* env, jobject javaLangBoolean) {
-    static jfieldID fid = env->GetFieldID(JniConstants::GetBooleanClass(env), "value", "Z");
-    return env->GetBooleanField(javaLangBoolean, fid);
-}
-
-jint intValue(JNIEnv* env, jobject javaLangInteger) {
-    static jfieldID fid = env->GetFieldID(JniConstants::GetIntegerClass(env), "value", "I");
-    return env->GetIntField(javaLangInteger, fid);
-}
diff --git a/luni/src/main/native/valueOf.h b/luni/src/main/native/valueOf.h
deleted file mode 100644
index 5c93b7c3a6c..00000000000
--- a/luni/src/main/native/valueOf.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef VALUE_OF_H_included
-#define VALUE_OF_H_included
-
-#include <nativehelper/JNIHelp.h>
-
-jobject booleanValueOf(JNIEnv* env, jboolean b);
-jobject doubleValueOf(JNIEnv* env, jdouble d);
-jobject integerValueOf(JNIEnv* env, jint i);
-jobject longValueOf(JNIEnv* env, jlong l);
-
-// Note that these aren't equivalent to the Number methods: the jobject MUST be of the exact
-// type specified. This is less general but faster (and currently sufficient).
-jboolean booleanValue(JNIEnv* env, jobject javaLangBoolean);
-jint intValue(JNIEnv* env, jobject javaLangInteger);
-
-#endif  // VALUE_OF_H_included
diff --git a/luni/src/test/java/crossvmtest/java/lang/RecordTest.java b/luni/src/test/java/crossvmtest/java/lang/RecordTest.java
index c440c2704b3..e90346b24d7 100644
--- a/luni/src/test/java/crossvmtest/java/lang/RecordTest.java
+++ b/luni/src/test/java/crossvmtest/java/lang/RecordTest.java
@@ -191,6 +191,30 @@ public class RecordTest {
         assertEquals(1, fieldB.getInt(null));
     }
 
+    @Test
+    public void testMethodHandlesUnreflectInstanceField() throws Throwable {
+        Field field = RecordInteger.class.getDeclaredField("x");
+
+        MethodHandles.Lookup lookup = MethodHandles.lookup();
+
+        assertThrows(IllegalAccessException.class, () -> lookup.unreflectSetter(field));
+
+        field.setAccessible(true);
+        assertThrows(IllegalAccessException.class, () -> lookup.unreflectSetter(field));
+    }
+
+    @Test
+    public void testMethodHandlesUnreflectStaticField() throws Throwable {
+        Field field = RecordString.class.getDeclaredField("A");
+
+        MethodHandles.Lookup lookup = MethodHandles.lookup();
+
+        assertThrows(IllegalAccessException.class, () -> lookup.unreflectSetter(field));
+
+        field.setAccessible(true);
+        assertThrows(IllegalAccessException.class, () -> lookup.unreflectSetter(field));
+    }
+
     @Test
     public void testVarHandleWrite() throws ReflectiveOperationException {
         NonRecordInteger a = new NonRecordInteger(8);
diff --git a/luni/src/test/java/libcore/android/system/OsConstantsTest.java b/luni/src/test/java/libcore/android/system/OsConstantsTest.java
index f95011de679..03af53b8449 100644
--- a/luni/src/test/java/libcore/android/system/OsConstantsTest.java
+++ b/luni/src/test/java/libcore/android/system/OsConstantsTest.java
@@ -443,4 +443,30 @@ public class OsConstantsTest {
     public void errno_returnsNull_onUnknown() {
         assertNull(OsConstants.errnoName(99999999));
     }
+
+    @Test
+    public void check_consistency() {
+        checkConsistency();
+    }
+
+    @Test
+    public void check_no_field_is_missing_in_macro() throws Exception {
+        Class<?> osConstantsHolderClass = Class.forName("android.system.OsConstantsHolder");
+        Class<?> osConstantsClass = Class.forName("android.system.OsConstants");
+        int countInHolder = osConstantsHolderClass.getDeclaredFields().length;
+        int countInOsConstants = osConstantsClass.getDeclaredFields().length;
+
+        // A constant in OsConstants is either initialized in Java code and hence should be listed
+        // in JAVA_INITIALIZED_FIELDS or is taken from native and will appear in OsConstantsHolder.
+        // JAVA_INITIALIZED_FIELDS is used to validate Java-initialized constants and not listing
+        // a constant there might lead to wrong values being passed to native methods.
+        assertEquals(countInOsConstants, countInHolder + initializedInJavaCount());
+    }
+
+    static {
+        System.loadLibrary("javacoretests");
+    }
+
+    private static native void checkConsistency();
+    private static native int initializedInJavaCount();
 }
diff --git a/luni/src/test/java/libcore/android/system/OsTest.java b/luni/src/test/java/libcore/android/system/OsTest.java
index f78d1a17163..7b504809f9b 100644
--- a/luni/src/test/java/libcore/android/system/OsTest.java
+++ b/luni/src/test/java/libcore/android/system/OsTest.java
@@ -23,6 +23,7 @@ import android.system.Os;
 import android.system.OsConstants;
 import android.system.PacketSocketAddress;
 import android.system.StructCmsghdr;
+import android.system.StructDlInfo;
 import android.system.StructMsghdr;
 import android.system.StructRlimit;
 import android.system.StructStat;
@@ -2334,6 +2335,44 @@ public class OsTest {
         }
     }
 
+    @Test
+    public void test_structDlInfo_constructor() {
+        String fname = "fname";
+        long fbase = 1;
+        String sname = "sname";
+        long saddr = 2;
+
+        StructDlInfo dlInfo = new StructDlInfo(fname, fbase, sname, saddr);
+
+        assertEquals(fname, dlInfo.dli_fname);
+        assertEquals(fbase, dlInfo.dli_fbase);
+        assertEquals(sname, dlInfo.dli_sname);
+        assertEquals(saddr, dlInfo.dli_saddr);
+    }
+
+    @Test
+    public void dladdr_returnsNull_whenAddrIsNotValid() {
+        // Expectation is that there won't be any symbol at address 0.
+        assertNull(Os.dladdr(0));
+    }
+
+    @Test
+    public void dladdr_shouldFindMktime() {
+        StructDlInfo dladdr = Os.dladdr(findMktime());
+
+        assertEquals(dladdr.dli_sname, "mktime", dladdr.dli_sname);
+        assertTrue(dladdr.dli_fname, dladdr.dli_fname.contains("libc.so"));
+        assertTrue(dladdr.dli_fbase != 0);
+        assertTrue(dladdr.dli_saddr != 0);
+    }
+
+    static {
+        System.loadLibrary("javacoretests");
+    }
+
+    // Returns address of libc's mktime symbol. Decided not to expose dlsym in androd.system.Os yet.
+    private static native long findMktime();
+
     /*
      * Checks that all ways of accessing the environment are consistent by collecting:
      * osEnvironment      - The environment returned by Os.environ()
diff --git a/luni/src/test/java/libcore/dalvik/system/VMRuntimeTest.java b/luni/src/test/java/libcore/dalvik/system/VMRuntimeTest.java
index 605d4e7ad15..c3d0d15fd07 100644
--- a/luni/src/test/java/libcore/dalvik/system/VMRuntimeTest.java
+++ b/luni/src/test/java/libcore/dalvik/system/VMRuntimeTest.java
@@ -158,6 +158,12 @@ public final class VMRuntimeTest {
         assertTrue(VMRuntime.isArtTestFlagEnabled());
     }
 
+    @Test
+    public void testIsArtTestRwFlagEnabled() {
+        Assume.assumeTrue(VMRuntime.isArtTestRwFlagEnabled());
+    }
+
+
     @Test
     public void testGetFullGcCount() {
         long gcCount = VMRuntime.getFullGcCount();
diff --git a/luni/src/test/java/libcore/java/lang/RecordTest.java b/luni/src/test/java/libcore/java/lang/RecordTest.java
index b12e105b28d..d2ea7e8f1e2 100644
--- a/luni/src/test/java/libcore/java/lang/RecordTest.java
+++ b/luni/src/test/java/libcore/java/lang/RecordTest.java
@@ -19,9 +19,19 @@ package libcore.java.lang;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assume.assumeTrue;
 
+import dalvik.annotation.compat.VersionCodes;
+import dalvik.system.VMRuntime;
+
+import libcore.junit.util.SwitchTargetSdkVersionRule;
+import libcore.junit.util.SwitchTargetSdkVersionRule.TargetSdkVersion;
+
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.TestRule;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
@@ -29,6 +39,9 @@ import java.util.Arrays;
 
 public class RecordTest {
 
+    @Rule
+    public TestRule switchTargetSdkVersionRule = SwitchTargetSdkVersionRule.getInstance();
+
     public record RecordInteger(int x) {};
 
     @Test
@@ -77,4 +90,21 @@ public class RecordTest {
         assertEquals(Arrays.deepToString(a.getClass().getRecordComponents()),
                 1, a.getClass().getRecordComponents().length);
     }
+
+    @Test
+    @TargetSdkVersion(VersionCodes.C)
+    public void gettingRecordFieldOffset_shouldThrow_afterBaklava() throws Throwable {
+        // Check is for C+ only. For compat purposes on older OS version this is allowed.
+        assumeTrue(VMRuntime.getSdkVersion() > VersionCodes.BAKLAVA);
+
+        Class<?> unsafeClass = Class.forName("sun.misc.Unsafe");
+        Field theUnsafeField = unsafeClass.getDeclaredField("theUnsafe");
+        theUnsafeField.setAccessible(true);
+        sun.misc.Unsafe unsafe = (sun.misc.Unsafe) theUnsafeField.get(null);
+
+        Field xField = RecordInteger.class.getDeclaredField("x");
+        assertThrows(
+                UnsupportedOperationException.class,
+                () -> unsafe.objectFieldOffset(xField));
+    }
 }
diff --git a/luni/src/test/java/libcore/java/lang/ThreadTest.java b/luni/src/test/java/libcore/java/lang/ThreadTest.java
index 7b0dec9425f..85853f4e1c6 100644
--- a/luni/src/test/java/libcore/java/lang/ThreadTest.java
+++ b/luni/src/test/java/libcore/java/lang/ThreadTest.java
@@ -23,24 +23,37 @@ import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assume.assumeTrue;
 
+import dalvik.annotation.compat.VersionCodes;
 import dalvik.system.InMemoryDexClassLoader;
+import dalvik.system.VMRuntime;
 
 import java.io.InputStream;
 import java.lang.reflect.Method;
 import java.lang.Thread.UncaughtExceptionHandler;
 import java.nio.ByteBuffer;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.locks.LockSupport;
 import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Function;
 
 import junit.framework.Assert;
 import junit.framework.TestCase;
 
+import org.junit.Assume;
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.TestRule;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 import org.mockito.InOrder;
@@ -48,6 +61,9 @@ import org.mockito.Mockito;
 
 import libcore.io.Streams;
 import libcore.java.lang.ref.FinalizationTester;
+import libcore.junit.util.compat.CoreCompatChangeRule;
+import libcore.test.annotation.NonCts;
+import libcore.test.reasons.NonCtsReasons;
 
 @RunWith(JUnit4.class)
 public final class ThreadTest {
@@ -55,6 +71,9 @@ public final class ThreadTest {
         System.loadLibrary("javacoretests");
     }
 
+    @Rule
+    public final TestRule compatChangeRule = new CoreCompatChangeRule();
+
     /**
      * getContextClassLoader returned a non-application class loader.
      * http://code.google.com/p/android/issues/detail?id=5697
@@ -179,6 +198,7 @@ public final class ThreadTest {
         Thread thread = new Thread("starting thread") {
             @Override public void run() { try { latch.await(); } catch (Exception e) { } }
         };
+        assertEquals(Thread.currentThread().getPriority(), thread.getPriority());
         // priority set while thread was not started should carry over to started thread
         int priority = thread.getPriority() + 1;
         if (priority > Thread.MAX_PRIORITY) {
@@ -652,4 +672,58 @@ public final class ThreadTest {
             done = true;
         }
     }
+
+    @Test
+    @CoreCompatChangeRule.EnableCompatChanges({Thread.OVERRIDDEN_THREAD_START_METHOD})
+    public void testOverriddenThreadStartMethod_changeEnabled() {
+        assumeTrue(VMRuntime.getSdkVersion() >= VersionCodes.C);
+
+        assertOverriddenStartMethodCalled(Executors::newSingleThreadExecutor, false);
+        assertOverriddenStartMethodCalled(Executors::newCachedThreadPool, false);
+    }
+
+    /** Regression test for b/419271726 */
+    @Test
+    @CoreCompatChangeRule.DisableCompatChanges({Thread.OVERRIDDEN_THREAD_START_METHOD})
+    public void testOverriddenThreadStartMethod_changeDisabled() {
+        assertOverriddenStartMethodCalled(Executors::newSingleThreadExecutor, true);
+        assertOverriddenStartMethodCalled(Executors::newCachedThreadPool, true);
+    }
+
+    private void assertOverriddenStartMethodCalled(
+            Function<ThreadFactory, ExecutorService> executorFuc, boolean expectedIsCalled) {
+        AtomicReference<ThreadWithOverriddenStartMethod> ref = new AtomicReference<>();
+        ThreadFactory factory = (r) -> {
+            ThreadWithOverriddenStartMethod t = new ThreadWithOverriddenStartMethod(r);
+            ref.set(t);
+            return t;
+        };
+
+        try (var executor = executorFuc.apply(factory)) {
+            executor.submit(() -> assertEquals(Thread.currentThread(), ref.get()));
+        }
+
+        ThreadWithOverriddenStartMethod t = ref.get();
+        assertNotNull(t);
+        assertEquals(expectedIsCalled, t.isCalled());
+    }
+
+    private static class ThreadWithOverriddenStartMethod extends Thread {
+        private final AtomicBoolean mIsCalled = new AtomicBoolean(false);
+
+        public ThreadWithOverriddenStartMethod(Runnable runnable) {
+            super(runnable);
+        }
+
+        @Override
+        public synchronized void start() {
+            super.start();
+            mIsCalled.set(true);
+        }
+
+        public boolean isCalled() {
+            return mIsCalled.get();
+        }
+    }
+
 }
diff --git a/luni/src/test/java/libcore/java/lang/invoke/MethodHandlesTest.java b/luni/src/test/java/libcore/java/lang/invoke/MethodHandlesTest.java
index 9984f1e522c..f083107ec9c 100644
--- a/luni/src/test/java/libcore/java/lang/invoke/MethodHandlesTest.java
+++ b/luni/src/test/java/libcore/java/lang/invoke/MethodHandlesTest.java
@@ -440,17 +440,29 @@ public class MethodHandlesTest extends TestCase {
         } catch (IllegalAccessException e) {}
 
         // Check doing invokeSpecial on abstract interface methods gets appropriate errors. We
-        // expect it to throw an IllegalAccessError.
-        MethodHandle mh2 =
+        // expect it to throw an IllegalAccessException.
+        try {
             MethodHandles.lookup().findSpecial(
                     Foo.class /* refC */,
                     "foo",
                     methodType(String.class),
                     Bar.class /* specialCaller */);
+            fail("findSpecial can't target abstract interface methods");
+        } catch (IllegalAccessException expected) {
+            assertTrue(expected.toString(), expected.getMessage().contains("no such method"));
+        }
+
         try {
-          mh2.invoke(new BarImpl());
-          fail();
-        } catch (IllegalAccessException e) {}
+            MethodHandles.privateLookupIn(BarAbstractSuper.class, MethodHandles.lookup())
+                    .findSpecial(
+                            BarAbstractSuper.class,
+                            "abstractSuperPublicMethod",
+                            methodType(String.class),
+                            BarAbstractSuper.class);
+            fail("findSpecial can't target abstract methods");
+        } catch (IllegalAccessException expected) {
+            assertTrue(expected.toString(), expected.getMessage().contains("no such method"));
+        }
     }
 
     public void testfindSpecial_invokeDirectBehaviour() throws Throwable {
diff --git a/luni/src/test/java/libcore/java/lang/reflect/FieldTest.java b/luni/src/test/java/libcore/java/lang/reflect/FieldTest.java
index 75665db3741..10b118da2b2 100644
--- a/luni/src/test/java/libcore/java/lang/reflect/FieldTest.java
+++ b/luni/src/test/java/libcore/java/lang/reflect/FieldTest.java
@@ -16,20 +16,101 @@
 
 package libcore.java.lang.reflect;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeTrue;
+
+import dalvik.annotation.compat.VersionCodes;
+import dalvik.system.VMRuntime;
+
+import libcore.junit.util.SwitchTargetSdkVersionRule;
+import libcore.junit.util.SwitchTargetSdkVersionRule.TargetSdkVersion;
+
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 
-import junit.framework.TestCase;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
-public final class FieldTest extends TestCase {
+@RunWith(JUnit4.class)
+public final class FieldTest {
     private static final long MY_LONG = 5073258162644648461L;
+    private static final Object MY_REF = new Object();
+
+    @Rule
+    public TestRule switchTargetSdkVersionRule = SwitchTargetSdkVersionRule.getInstance();
 
     // Reflection for static long fields was broken http://b/1120750
+    @Test
     public void testLongFieldReflection() throws Exception {
         Field field = getClass().getDeclaredField("MY_LONG");
         assertEquals(5073258162644648461L, field.getLong(null));
     }
 
+    @Test
+    @TargetSdkVersion(VersionCodes.C)
+    public void testSetStaticFinalField_shouldThrow_afterBaklava() throws Exception {
+        // Prior to Android C it was possible to override static final fields.
+        assumeTrue(VMRuntime.getSdkVersion() >= VersionCodes.C);
+        Field longField = getClass().getDeclaredField("MY_LONG");
+        longField.setAccessible(true);
+
+        try {
+            longField.set(null, 1001L);
+            fail("Should fail to override static final field");
+        } catch (IllegalAccessException expected) {}
+
+        try {
+            longField.setLong(null, 1001L);
+            fail("Should fail to override static final field");
+        } catch (IllegalAccessException expected) {}
+
+        Field refField = getClass().getDeclaredField("MY_REF");
+        refField.setAccessible(true);
+
+        try {
+            refField.set(null, new Object());
+            fail("Should fail to override static final field");
+        } catch (IllegalAccessException expected) {}
+    }
+
+    @Test
+    @TargetSdkVersion(VersionCodes.C)
+    public void setWriteProtectedField_shouldThrow_afterBaklava() throws Exception {
+        // Prior to Android C it was possible to override static final fields.
+        assumeTrue(VMRuntime.getSdkVersion() >= VersionCodes.C);
+
+        Field systemIn = System.class.getDeclaredField("in");
+        systemIn.setAccessible(true);
+
+        try {
+            systemIn.set(null, null);
+            fail("Should fail to set System.in");
+        } catch (IllegalAccessException expected) {}
+
+        Field systemOut = System.class.getDeclaredField("out");
+        systemOut.setAccessible(true);
+
+        try {
+            systemOut.set(null, null);
+            fail("Should fail to set System.out");
+        } catch (IllegalAccessException expected) {}
+
+        Field systemErr = System.class.getDeclaredField("err");
+        systemErr.setAccessible(true);
+
+        try {
+            systemErr.set(null, null);
+            fail("Should fail to set System.err");
+        } catch (IllegalAccessException expected) {}
+    }
+
+    @Test
     public void testEqualConstructorEqualsAndHashCode() throws Exception {
         Field f1 = FieldTestHelper.class.getField("a");
         Field f2 = FieldTestHelper.class.getField("a");
@@ -37,11 +118,13 @@ public final class FieldTest extends TestCase {
         assertEquals(f1.hashCode(), f2.hashCode());
     }
 
+    @Test
     public void testHashCodeSpec() throws Exception {
         Field f1 = FieldTestHelper.class.getField("a");
         assertEquals(FieldTestHelper.class.getName().hashCode() ^ "a".hashCode(), f1.hashCode());
     }
 
+    @Test
     public void testDifferentConstructorEqualsAndHashCode() throws Exception {
         Field f1 = FieldTestHelper.class.getField("a");
         Field f2 = FieldTestHelper.class.getField("b");
@@ -50,6 +133,7 @@ public final class FieldTest extends TestCase {
 
     // Tests that the "synthetic" modifier is handled correctly.
     // It's supposed to be present but not shown in toString.
+    @Test
     public void testSyntheticModifier() throws NoSuchFieldException {
         Field valuesField = Thread.State.class.getDeclaredField("$VALUES");
         // Check that this test makes sense.
@@ -60,6 +144,7 @@ public final class FieldTest extends TestCase {
     }
 
     // Ensure that the "enum constant" bit is not returned in toString.
+    @Test
     public void testEnumValueField() throws NoSuchFieldException {
         Field blockedField = Thread.State.class.getDeclaredField("BLOCKED");
         assertTrue(Thread.State.class.getDeclaredField("BLOCKED").isEnumConstant());
@@ -76,6 +161,7 @@ public final class FieldTest extends TestCase {
     // Tests that the "transient" modifier is handled correctly.
     // The underlying constant value for it is the same as for the "varargs" method modifier.
     // http://b/18488857
+    @Test
     public void testTransientModifier() throws NoSuchFieldException {
         Field transientField = ClassWithATransientField.class.getDeclaredField("transientField");
         // Check that this test makes sense.
@@ -87,6 +173,7 @@ public final class FieldTest extends TestCase {
                 transientField.toString());
     }
 
+    @Test
     public void testToGenericString() throws NoSuchFieldException {
         Field transientField = ClassWithATransientField.class.getDeclaredField("transientField");
         // Check that this test makes sense.
diff --git a/luni/src/test/java/libcore/java/net/OldSocketTest.java b/luni/src/test/java/libcore/java/net/OldSocketTest.java
index 272019eec16..913a272cd7e 100644
--- a/luni/src/test/java/libcore/java/net/OldSocketTest.java
+++ b/luni/src/test/java/libcore/java/net/OldSocketTest.java
@@ -39,6 +39,7 @@ import java.net.UnknownHostException;
 import java.nio.channels.IllegalBlockingModeException;
 import java.nio.channels.SocketChannel;
 import java.security.Permission;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicReference;
 import libcore.junit.util.ResourceLeakageDetector.DisableResourceLeakageDetection;
 import tests.support.Support_Configuration;
@@ -1150,14 +1151,14 @@ public class OldSocketTest extends OldSocketTestCase {
             } catch (ConnectException ce) {
                 // some networks will quickly reset the TCP connection attempt to this fake IP
                 assertTrue(
-                        "Wrong exception when connecting to address nobody listening on with short timeout 200: "
-                                + ce.toString(),
-                        (ce.getMessage() != null && ce.getMessage().contains("ECONNREFUSED")));
+                    "Wrong exception when connecting to address nobody listening on with short timeout 200: "
+                        + ce.toString(),
+                    (ce.getMessage() != null && ce.getMessage().contains("ECONNREFUSED")));
             } catch (Exception e) {
                 assertTrue(
-                        "Wrong exception when connecting to address nobody listening on with short timeout 200: "
-                                + e.toString(),
-                        (e instanceof SocketTimeoutException));
+                    "Wrong exception when connecting to address nobody listening on with short timeout 200: "
+                        + e.toString(),
+                    (e instanceof SocketTimeoutException));
             }
         }
 
@@ -1171,14 +1172,14 @@ public class OldSocketTest extends OldSocketTestCase {
             } catch (ConnectException ce) {
                 // some networks will quickly reset the TCP connection attempt to this fake IP
                 assertTrue(
-                        "Wrong exception when connecting to address nobody listening on with short timeout 40: "
-                                + ce.toString(),
-                        (ce.getMessage() != null && ce.getMessage().contains("ECONNREFUSED")));
+                    "Wrong exception when connecting to address nobody listening on with short timeout 40: "
+                        + ce.toString(),
+                    (ce.getMessage() != null && ce.getMessage().contains("ECONNREFUSED")));
             } catch (Exception e) {
                 assertTrue(
-                        "Wrong exception when connecting to address nobody listening on with short timeout 40: "
-                                + e.toString(),
-                        (e instanceof SocketTimeoutException));
+                    "Wrong exception when connecting to address nobody listening on with short timeout 40: "
+                        + e.toString(),
+                    (e instanceof SocketTimeoutException));
             }
         }
 
@@ -1276,10 +1277,12 @@ public class OldSocketTest extends OldSocketTestCase {
             private final int timeout;
             private final Socket theSocket;
             private final SocketAddress address;
+            private final CountDownLatch latch = new CountDownLatch(1);
 
             @Override
             public void run() {
                 try {
+                    latch.countDown();
                     theSocket.connect(address, timeout);
                 } catch (Exception e) {
                     exceptionRef.set(e);
@@ -1291,6 +1294,15 @@ public class OldSocketTest extends OldSocketTestCase {
                 this.theSocket = theSocket;
                 this.address = address;
             }
+
+            public void await() {
+                try {
+                    latch.await();
+                } catch (InterruptedException e) {
+                    Thread.currentThread().interrupt();
+                    exceptionRef.set(e);
+                }
+            }
         }
 
         // Now try to set options while we are connecting
@@ -1301,11 +1313,20 @@ public class OldSocketTest extends OldSocketTestCase {
             final SocketConnector connector
                 = new SocketConnector(5000, theSocket, UNREACHABLE_ADDRESS);
             connector.start();
+            connector.await();
             theSocket.setSoTimeout(1000);
             Thread.sleep(10);
+            // The socket would still try to reach UNREACHABLE_ADDRESS, unless the network is
+            // unavailable.
+            assertFalse("Socket closed early, network probably unavailable",
+                theSocket.isClosed());
             assertTrue("Socket option not set during connect: 10 ",
                     Math.abs(1000 - theSocket.getSoTimeout()) <= 10);
             Thread.sleep(50);
+            // The socket would still try to reach UNREACHABLE_ADDRESS, unless the network is
+            // unavailable.
+            assertFalse("Socket closed early, network probably unavailable",
+                theSocket.isClosed());
             theSocket.setSoTimeout(2000);
             assertTrue("Socket option not set during connect: 50 ",
                     Math.abs(2000 - theSocket.getSoTimeout()) <= 10);
diff --git a/luni/src/test/java/libcore/java/nio/file/DefaultFileSystemProvider2Test.java b/luni/src/test/java/libcore/java/nio/file/DefaultFileSystemProvider2Test.java
index 508e907e55c..dfe348ff962 100644
--- a/luni/src/test/java/libcore/java/nio/file/DefaultFileSystemProvider2Test.java
+++ b/luni/src/test/java/libcore/java/nio/file/DefaultFileSystemProvider2Test.java
@@ -76,6 +76,9 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.fail;
 
+import libcore.test.annotation.NonCts;
+import libcore.test.reasons.NonCtsReasons;
+
 @RunWith(JUnitParamsRunner.class)
 public class DefaultFileSystemProvider2Test {
 
@@ -606,6 +609,7 @@ public class DefaultFileSystemProvider2Test {
         } catch (NullPointerException expected) {}
     }
 
+    @NonCts(bug = 270694545, reason = NonCtsReasons.NON_BREAKING_BEHAVIOR_FIX)
     @Test
     public void test_getPath() throws Exception {
         List<LinuxFileSystemTestData.TestData> inputOutputTestCases = getPath_URI_InputOutputTestData();
diff --git a/luni/src/test/java/libcore/java/nio/file/FileSystemsTest.java b/luni/src/test/java/libcore/java/nio/file/FileSystemsTest.java
index a2cd8fc10c5..64fc5824d9f 100644
--- a/luni/src/test/java/libcore/java/nio/file/FileSystemsTest.java
+++ b/luni/src/test/java/libcore/java/nio/file/FileSystemsTest.java
@@ -26,6 +26,7 @@ import dalvik.system.PathClassLoader;
 
 import libcore.io.Streams;
 
+import org.junit.Assume;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -81,12 +82,12 @@ public class FileSystemsTest {
         } catch (FileSystemAlreadyExistsException expected) {}
 
         try {
-            FileSystems.newFileSystem(null, stubEnv);
+            FileSystems.newFileSystem((URI) null, stubEnv);
             fail();
         } catch (NullPointerException expected) {}
 
         try {
-            FileSystems.newFileSystem(testPath, null);
+            FileSystems.newFileSystem(testPath, (ClassLoader) null);
             fail();
         } catch (ProviderNotFoundException expected) {}
     }
@@ -101,7 +102,7 @@ public class FileSystemsTest {
         } catch (FileSystemAlreadyExistsException expected) {}
 
         try {
-            FileSystems.newFileSystem(null, stubEnv,
+            FileSystems.newFileSystem((URI) null, stubEnv,
                     Thread.currentThread().getContextClassLoader());
             fail();
         } catch (NullPointerException expected) {}
@@ -151,19 +152,51 @@ public class FileSystemsTest {
         } catch (NullPointerException expected) {}
 
         try {
-            FileSystems.newFileSystem(testPath, null);
+            FileSystems.newFileSystem(testPath, (ClassLoader) null);
             fail();
         } catch (ProviderNotFoundException expected) {}
     }
 
+    private static void assumeOpenjdk21V2ApisFlagTrue() {
+        try {
+            Assume.assumeTrue(com.android.libcore.Flags.openjdk21V2Apis());
+        } catch (NoSuchMethodError e) {
+            System.logE("flag isn't found.", e);
+            // Continue running tests as if the flag value was true, because in this case
+            // it's likely that the APIs have been fully published and the flag has been removed.
+            // Ideally, we should use the exported / test version of java_aconfig_library to read
+            // the flag from the aconfig flag storage via frameworks, but ART test infra can't have
+            // direct dependency on frameworks. We will need to add an abstraction or indirect
+            // dependency to support both CTS infra and ART test infra.
+        }
+    }
+
     @Test
-    public void test_newFileSystem$Path$ClassLoader_customClassLoader() throws Exception  {
-        // Verify that the Thread's classloader cannot load mypackage.MockFileSystem.
+    public void test_newFileSystem$Path() throws Exception {
+        assumeOpenjdk21V2ApisFlagTrue();
+        assertMockFileSystemNotLoaded();
+        Path testPath = Paths.get("/");
         try {
-            Thread.currentThread().getContextClassLoader().loadClass(
-                    "mypackage.MockFileSystem");
+            FileSystems.newFileSystem(testPath);
             fail();
-        } catch (ClassNotFoundException expected) {}
+        } catch (ProviderNotFoundException expected) {}
+    }
+
+    @Test
+    public void test_newFileSystem$Path$Map() throws Exception {
+        assumeOpenjdk21V2ApisFlagTrue();
+        assertMockFileSystemNotLoaded();
+        Path testPath = Paths.get("/");
+        Map<String, String> env = Map.of("myEnv1", "myValue1");
+        try {
+            FileSystems.newFileSystem(testPath, env);
+            fail();
+        } catch (ProviderNotFoundException expected) {}
+    }
+
+    @Test
+    public void test_newFileSystem$Path$ClassLoader_customClassLoader() throws Exception  {
+        assertMockFileSystemNotLoaded();
 
         ClassLoader fileSystemsClassLoader = createClassLoaderForTestFileSystems();
         FileSystem fs = FileSystems.newFileSystem(filesSetup.getDataFilePath(),
@@ -175,6 +208,35 @@ public class FileSystemsTest {
         assertEquals(filesSetup.getDataFilePath(), pathValue);
     }
 
+    @Test
+    public void test_newFileSystem$Path$Map$ClassLoader_customClassLoader() throws Exception  {
+        assumeOpenjdk21V2ApisFlagTrue();
+        assertMockFileSystemNotLoaded();
+
+        ClassLoader fileSystemsClassLoader = createClassLoaderForTestFileSystems();
+        Map<String, String> env = Map.of("myEnv1", "myValue1");
+        FileSystem fs = FileSystems.newFileSystem(filesSetup.getDataFilePath(), env,
+                fileSystemsClassLoader);
+
+        assertEquals("mypackage.MockFileSystem", fs.getClass().getName());
+
+        Path pathValue = (Path)fs.getClass().getDeclaredMethod("getPath").invoke(fs);
+        assertEquals(filesSetup.getDataFilePath(), pathValue);
+
+        Map<String, String> mapValue = (Map<String, String>) fs.getClass()
+                .getDeclaredMethod("getEnv").invoke(fs);
+        assertSame(env, mapValue);
+    }
+
+    private static void assertMockFileSystemNotLoaded() {
+        // Verify that the Thread's classloader cannot load mypackage.MockFileSystem.
+        try {
+            Thread.currentThread().getContextClassLoader().loadClass(
+                    "mypackage.MockFileSystem");
+            fail();
+        } catch (ClassNotFoundException expected) {}
+    }
+
     /**
      * The method creates a custom classloader for the mock FileSystem and FileSystemProvider
      * classes. The custom classloader is created by providing filesystemtest.jar which contains
diff --git a/luni/src/test/java/libcore/java/nio/file/LinuxFileSystemTestData.java b/luni/src/test/java/libcore/java/nio/file/LinuxFileSystemTestData.java
index dceddf64d1f..65535d24805 100644
--- a/luni/src/test/java/libcore/java/nio/file/LinuxFileSystemTestData.java
+++ b/luni/src/test/java/libcore/java/nio/file/LinuxFileSystemTestData.java
@@ -55,7 +55,7 @@ class LinuxFileSystemTestData {
         List<TestData> inputOutputTestCases = new ArrayList<>();
         inputOutputTestCases.add(new TestData("/d1", "file:///d1"));
         inputOutputTestCases.add(new TestData("/", "file:///"));
-        inputOutputTestCases.add(new TestData("/d1//d2/d3", "file:///d1//d2/d3"));
+        inputOutputTestCases.add(new TestData("/d1/d2/d3", "file:///d1//d2/d3"));
         return inputOutputTestCases;
     }
 
diff --git a/luni/src/test/java/libcore/java/nio/file/LinuxPathTest.java b/luni/src/test/java/libcore/java/nio/file/LinuxPathTest.java
index 76bb4503d47..e207cf4fdde 100644
--- a/luni/src/test/java/libcore/java/nio/file/LinuxPathTest.java
+++ b/luni/src/test/java/libcore/java/nio/file/LinuxPathTest.java
@@ -16,14 +16,19 @@
 
 package libcore.java.nio.file;
 
-import com.sun.nio.file.ExtendedWatchEventModifier;
+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;
+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;
+import static junit.framework.TestCase.assertFalse;
+import static junit.framework.TestCase.assertNull;
+import static junit.framework.TestCase.assertTrue;
+import static libcore.java.nio.file.LinuxFileSystemTestData.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
 
-import java.nio.file.WatchEvent.Kind;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
+import libcore.test.annotation.NonCts;
+import libcore.test.reasons.NonCtsReasons;
 
+import com.sun.nio.file.ExtendedWatchEventModifier;
 import java.io.File;
 import java.io.IOException;
 import java.net.URI;
@@ -37,20 +42,18 @@ import java.nio.file.NotDirectoryException;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.nio.file.WatchEvent;
+import java.nio.file.WatchEvent.Kind;
 import java.nio.file.WatchKey;
 import java.nio.file.WatchService;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
-import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;
-import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;
-import static junit.framework.TestCase.assertFalse;
-import static junit.framework.TestCase.assertNull;
-import static junit.framework.TestCase.assertTrue;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
+@RunWith(JUnit4.class)
 public class LinuxPathTest {
 
     @Rule
@@ -577,8 +580,48 @@ public class LinuxPathTest {
         assertEquals("/dir", p.toString());
     }
 
-    private static class NonStandardEvent<T> implements WatchEvent.Kind<T> {
+    @Test
+    public void test_ofString() {
+        List<TestData> inputOutputTestCases = getPathInputOutputTestData();
+        for (TestData inputOutputTestCase : inputOutputTestCases) {
+            assertEquals(inputOutputTestCase.output, Path.of(inputOutputTestCase.input,
+                inputOutputTestCase.inputArray).toString());
+        }
 
+        List<TestData> exceptionTestCases = getPathExceptionTestData();
+        for (TestData exceptionTestCase : exceptionTestCases) {
+            try {
+                Path.of(exceptionTestCase.input, exceptionTestCase.inputArray);
+                fail();
+            } catch (Exception expected) {
+                assertEquals(exceptionTestCase.exceptionClass, expected.getClass());
+            }
+        }
+
+    }
+
+    @NonCts(bug = 270694545, reason = NonCtsReasons.NON_BREAKING_BEHAVIOR_FIX)
+    @Test
+    public void test_get_URI() throws URISyntaxException {
+        List<TestData> inputOutputTestCases = getPath_URI_InputOutputTestData();
+        for (TestData inputOutputTestCase : inputOutputTestCases) {
+            assertEquals(inputOutputTestCase.output, Path.of(new URI(inputOutputTestCase.input)).
+                toString());
+        }
+
+        List<TestData> exceptionTestCases = getPath_URI_ExceptionTestData();
+        for (TestData exceptionTestCase : exceptionTestCases) {
+            try {
+                Path.of(new URI(exceptionTestCase.input));
+                fail();
+            } catch (Exception expected) {
+                assertEquals(exceptionTestCase.exceptionClass, expected.getClass());
+            }
+        }
+    }
+
+
+    private static class NonStandardEvent<T> implements WatchEvent.Kind<T> {
         @Override
         public String name() {
             return null;
diff --git a/luni/src/test/java/libcore/java/nio/file/PathsTest.java b/luni/src/test/java/libcore/java/nio/file/PathsTest.java
index 1bfa1b7cc94..306ab863f3d 100644
--- a/luni/src/test/java/libcore/java/nio/file/PathsTest.java
+++ b/luni/src/test/java/libcore/java/nio/file/PathsTest.java
@@ -29,6 +29,9 @@ import static libcore.java.nio.file.LinuxFileSystemTestData.getPathInputOutputTe
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
+import libcore.test.annotation.NonCts;
+import libcore.test.reasons.NonCtsReasons;
+
 
 public class PathsTest {
 
@@ -51,6 +54,7 @@ public class PathsTest {
         }
     }
 
+    @NonCts(bug = 270694545, reason = NonCtsReasons.NON_BREAKING_BEHAVIOR_FIX)
     @Test
     public void test_get_URI() throws URISyntaxException {
         List<TestData> inputOutputTestCases = getPath_URI_InputOutputTestData();
diff --git a/luni/src/test/java/libcore/java/security/cert/X509CertificateTest.java b/luni/src/test/java/libcore/java/security/cert/X509CertificateTest.java
index ac21b398927..08476364197 100644
--- a/luni/src/test/java/libcore/java/security/cert/X509CertificateTest.java
+++ b/luni/src/test/java/libcore/java/security/cert/X509CertificateTest.java
@@ -125,6 +125,9 @@ public class X509CertificateTest extends TestCaseWithRules {
 
     private static final String CERTS_X509_PEM = "x509/certs.pem";
 
+    private static final String CERTS_X509_PEM_WITH_COMMENT =
+        "x509/certs_with_comment.pem";
+
     private static final String CERTS_X509_DER = "x509/certs.der";
 
     private static final String CERTS_PKCS7_PEM = "x509/certs-pk7.pem";
@@ -301,6 +304,7 @@ public class X509CertificateTest extends TestCaseWithRules {
                 generateCertificate_PEM_TrailingData(f);
                 generateCertificate_DER_TrailingData(f);
                 generateCertificates_X509_PEM(f);
+                generateCertificates_X509_PEM_WITH_COMMENT(f);
                 generateCertificates_X509_DER(f);
                 generateCertificates_PKCS7_PEM(f);
                 generateCertificates_PKCS7_DER(f);
@@ -1153,6 +1157,14 @@ public class X509CertificateTest extends TestCaseWithRules {
         assertEquals(2, certs.size());
     }
 
+    private void generateCertificates_X509_PEM_WITH_COMMENT(CertificateFactory f)
+        throws Exception {
+        /* PEM-encoded list of certificates */
+        Collection<? extends X509Certificate> certs = getCertificates(f, CERTS_X509_PEM_WITH_COMMENT);
+        assertNotNull(certs);
+        assertEquals(4, certs.size());
+    }
+
     private void generateCertificates_PKCS7_PEM(CertificateFactory f) throws Exception {
         /* PEM-encoded PKCS7 bag of certificates */
         Collection<? extends X509Certificate> certs = getCertificates(f, CERTS_PKCS7_PEM);
diff --git a/luni/src/test/java/libcore/java/util/concurrent/ForkJoinPoolTest.java b/luni/src/test/java/libcore/java/util/concurrent/ForkJoinPoolTest.java
index d47bb7369f3..c40c035d48b 100644
--- a/luni/src/test/java/libcore/java/util/concurrent/ForkJoinPoolTest.java
+++ b/luni/src/test/java/libcore/java/util/concurrent/ForkJoinPoolTest.java
@@ -17,19 +17,34 @@
 package libcore.java.util.concurrent;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
+import libcore.test.annotation.NonCts;
+import libcore.test.reasons.NonCtsReasons;
+
+import java.util.List;
+import java.util.Optional;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ForkJoinPool;
 import java.util.concurrent.ForkJoinTask;
+import java.util.concurrent.ForkJoinWorkerThread;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.junit.Assert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import jdk.internal.vm.ThreadContainer;
+import jdk.internal.vm.ThreadContainers;
+
 @RunWith(JUnit4.class)
 public class ForkJoinPoolTest {
 
@@ -77,6 +92,39 @@ public class ForkJoinPoolTest {
         }
     }
 
+    @NonCts(reason = NonCtsReasons.INTERNAL_APIS)
+    @Test
+    public void testThreadContainerTracking() throws Exception {
+        final ForkJoinPool pool = new ForkJoinPool();
+        try (ExecutorServiceAutoCloseable cleaner = new ExecutorServiceAutoCloseable(pool)) {
+            final AtomicReference<Thread> result = new AtomicReference<>(null);
+            ForkJoinTask<AtomicReference<Thread>> task = pool.submit(() -> {
+                Thread cur = Thread.currentThread();
+                // Avoid using lambda. http://b/417565895
+                List<ThreadContainer> list = ThreadContainers.root().children().toList();
+                for (ThreadContainer c : list) {
+                    if (!c.name().startsWith("ForkJoinPool-")) {
+                        continue;
+                    }
+                    List<Thread> threads = c.threads().toList();
+                    for (Thread th : threads) {
+                        if (cur.equals(th)) {
+                            result.set(cur);
+                            break;
+                        }
+                    }
+                    if (result.get() != null) {
+                        break;
+                    }
+                }
+            }, result);
+            assertSame(result, task.get());
+            Thread th = result.get();
+            assertNotNull("ForkJoinWorkerThread wasn't found in the shared container", th);
+            assertTrue(th instanceof ForkJoinWorkerThread);
+        }
+    }
+
     @Test
     public void testConstructor_withKeepAliveTime() {
 
diff --git a/luni/src/test/java/libcore/java/util/concurrent/ThreadPoolExecutorTest.java b/luni/src/test/java/libcore/java/util/concurrent/ThreadPoolExecutorTest.java
index 071bf68e9e6..261db2ead4a 100644
--- a/luni/src/test/java/libcore/java/util/concurrent/ThreadPoolExecutorTest.java
+++ b/luni/src/test/java/libcore/java/util/concurrent/ThreadPoolExecutorTest.java
@@ -16,15 +16,31 @@
 
 package libcore.java.util.concurrent;
 
-import junit.framework.TestCase;
+import static org.junit.Assert.assertNotNull;
 
+import libcore.test.annotation.NonCts;
+import libcore.test.reasons.NonCtsReasons;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.util.List;
+import java.util.Optional;
 import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
 
-public class ThreadPoolExecutorTest extends TestCase {
+import jdk.internal.vm.ThreadContainer;
+import jdk.internal.vm.ThreadContainers;
+
+@RunWith(JUnit4.class)
+public class ThreadPoolExecutorTest {
 
     // http://b/27702221
+    @Test
     public void testCorePoolSizeGreaterThanMax() {
         ThreadPoolExecutor tp = new ThreadPoolExecutor(
                 1 /* core pool size */, 1 /* max pool size */,
@@ -37,4 +53,37 @@ public class ThreadPoolExecutorTest extends TestCase {
         tp.setCorePoolSize(5);
         tp.setMaximumPoolSize(5);
     }
+
+    @NonCts(reason = NonCtsReasons.INTERNAL_APIS)
+    @Test
+    public void testThreadContainerTracking() throws InterruptedException {
+        try (ThreadPoolExecutor tp = new ThreadPoolExecutor(
+                1 /* core pool size */, 1 /* max pool size */,
+                1000, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<>(10))) {
+
+            CountDownLatch latch = new CountDownLatch(1);
+            final AtomicReference<Thread> result = new AtomicReference<>(null);
+            tp.execute(() -> {
+                Thread cur = Thread.currentThread();
+                // Avoid using lambda. http://b/417565895
+                List<ThreadContainer> list = ThreadContainers.root().children().toList();
+                for (ThreadContainer c : list) {
+                    List<Thread> threads = c.threads().toList();
+                    for (Thread th : threads) {
+                        if (cur.equals(th)) {
+                            result.set(cur);
+                            break;
+                        }
+                    }
+                    if (result.get() != null) {
+                        break;
+                    }
+                }
+                latch.countDown();
+            });
+            latch.await();
+            Thread th = result.get();
+            assertNotNull("The pooled thread isn't found in the thread container", th);
+        }
+    }
 }
diff --git a/luni/src/test/java/libcore/libcore/io/BlockGuardOsTest.java b/luni/src/test/java/libcore/libcore/io/BlockGuardOsTest.java
index e8d6e4222ee..8a59ee42081 100644
--- a/luni/src/test/java/libcore/libcore/io/BlockGuardOsTest.java
+++ b/luni/src/test/java/libcore/libcore/io/BlockGuardOsTest.java
@@ -240,6 +240,7 @@ public class BlockGuardOsTest {
                 "bind(java.io.FileDescriptor,java.net.SocketAddress)",
                 "capget(android.system.StructCapUserHeader)",
                 "capset(android.system.StructCapUserHeader,android.system.StructCapUserData[])",
+                "dladdr(long)",
                 "dup(java.io.FileDescriptor)",
                 "dup2(java.io.FileDescriptor,int)",
                 "environ()",
diff --git a/luni/src/test/native/libcore_android_system_OsConstantsTest.cpp b/luni/src/test/native/libcore_android_system_OsConstantsTest.cpp
new file mode 100644
index 00000000000..54b6cf2e988
--- /dev/null
+++ b/luni/src/test/native/libcore_android_system_OsConstantsTest.cpp
@@ -0,0 +1,563 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "OsConstantsTest"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <netdb.h>
+#include <netinet/icmp6.h>
+#include <netinet/if_ether.h>
+#include <netinet/in.h>
+#include <netinet/ip_icmp.h>
+#include <netinet/tcp.h>
+#include <netinet/udp.h>
+#include <netpacket/packet.h>
+#include <net/if.h>
+#include <net/if_arp.h>
+#include <poll.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <sys/capability.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/prctl.h>
+#include <sys/resource.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/statvfs.h>
+#include <sys/un.h>
+#include <sys/wait.h>
+#include <sys/xattr.h>
+#include <unistd.h>
+
+#include <linux/if_addr.h>
+#include <linux/rtnetlink.h>
+
+#include <nativehelper/JNIHelp.h>
+#include <nativehelper/jni_macros.h>
+
+#include "android-base/logging.h"
+
+#if defined(__GLIBC__)
+// MADV_SOFT_OFFLINE is otherwise unavailable from glibc.
+#include <asm-generic/mman-common.h>
+#endif
+
+// Taken from Portability.h
+#if __has_include(<linux/vm_sockets.h>)
+#include <linux/vm_sockets.h>
+#else  // __has_include(<linux/vm_sockets.h>)
+// the platform does not support virtio-vsock
+#define AF_VSOCK (-1)
+#define VMADDR_PORT_ANY (-1)
+#define VMADDR_CID_ANY (-1)
+#define VMADDR_CID_LOCAL (-1)
+#define VMADDR_CID_HOST (-1)
+#endif  // __has_include(<linux/vm_sockets.h>)
+
+
+// Constants whose value does not depend on architecture and is set in Java code.
+#define JAVA_INITIALIZED_FIELDS(V) \
+  V(AF_INET) \
+  V(AF_INET6) \
+  V(AF_NETLINK) \
+  V(AF_PACKET) \
+  V(AF_UNIX) \
+  V(AF_VSOCK) \
+  V(AF_UNSPEC) \
+  V(ARPHRD_ETHER) \
+  V(ARPHRD_LOOPBACK) \
+  V(VMADDR_PORT_ANY) \
+  V(VMADDR_CID_ANY) \
+  V(VMADDR_CID_LOCAL) \
+  V(VMADDR_CID_HOST) \
+  V(CAP_AUDIT_CONTROL) \
+  V(CAP_AUDIT_WRITE) \
+  V(CAP_BLOCK_SUSPEND) \
+  V(CAP_CHOWN) \
+  V(CAP_DAC_OVERRIDE) \
+  V(CAP_DAC_READ_SEARCH) \
+  V(CAP_FOWNER) \
+  V(CAP_FSETID) \
+  V(CAP_IPC_LOCK) \
+  V(CAP_IPC_OWNER) \
+  V(CAP_KILL) \
+  V(CAP_LAST_CAP) \
+  V(CAP_LEASE) \
+  V(CAP_LINUX_IMMUTABLE) \
+  V(CAP_MAC_ADMIN) \
+  V(CAP_MAC_OVERRIDE) \
+  V(CAP_MKNOD) \
+  V(CAP_NET_ADMIN) \
+  V(CAP_NET_BIND_SERVICE) \
+  V(CAP_NET_BROADCAST) \
+  V(CAP_NET_RAW) \
+  V(CAP_SETFCAP) \
+  V(CAP_SETGID) \
+  V(CAP_SETPCAP) \
+  V(CAP_SETUID) \
+  V(CAP_SYS_ADMIN) \
+  V(CAP_SYS_BOOT) \
+  V(CAP_SYS_CHROOT) \
+  V(CAP_SYSLOG) \
+  V(CAP_SYS_MODULE) \
+  V(CAP_SYS_NICE) \
+  V(CAP_SYS_PACCT) \
+  V(CAP_SYS_PTRACE) \
+  V(CAP_SYS_RAWIO) \
+  V(CAP_SYS_RESOURCE) \
+  V(CAP_SYS_TIME) \
+  V(CAP_SYS_TTY_CONFIG) \
+  V(CAP_WAKE_ALARM) \
+  V(_LINUX_CAPABILITY_VERSION_3) \
+  V(STDIN_FILENO) \
+  V(STDOUT_FILENO) \
+  V(STDERR_FILENO) \
+  V(E2BIG) \
+  V(EACCES) \
+  V(EADDRINUSE) \
+  V(EADDRNOTAVAIL) \
+  V(EAFNOSUPPORT) \
+  V(EAGAIN) \
+  V(EALREADY) \
+  V(EBADF) \
+  V(EBADMSG) \
+  V(EBUSY) \
+  V(ECANCELED) \
+  V(ECHILD) \
+  V(ECONNABORTED) \
+  V(ECONNREFUSED) \
+  V(ECONNRESET) \
+  V(EDEADLK) \
+  V(EDESTADDRREQ) \
+  V(EDOM) \
+  V(EDQUOT) \
+  V(EEXIST) \
+  V(EFAULT) \
+  V(EFBIG) \
+  V(EHOSTUNREACH) \
+  V(EIDRM) \
+  V(EILSEQ) \
+  V(EINPROGRESS) \
+  V(EINTR) \
+  V(EINVAL) \
+  V(EIO) \
+  V(EISCONN) \
+  V(EISDIR) \
+  V(ELOOP) \
+  V(EMFILE) \
+  V(EMLINK) \
+  V(EMSGSIZE) \
+  V(EMULTIHOP) \
+  V(ENAMETOOLONG) \
+  V(ENETDOWN) \
+  V(ENETRESET) \
+  V(ENETUNREACH) \
+  V(ENFILE) \
+  V(ENOBUFS) \
+  V(ENODATA) \
+  V(ENODEV) \
+  V(ENOENT) \
+  V(ENOEXEC) \
+  V(ENOLCK) \
+  V(ENOLINK) \
+  V(ENOMEM) \
+  V(ENOMSG) \
+  V(ENONET) \
+  V(ENOPROTOOPT) \
+  V(ENOSPC) \
+  V(ENOSR) \
+  V(ENOSTR) \
+  V(ENOSYS) \
+  V(ENOTCONN) \
+  V(ENOTDIR) \
+  V(ENOTEMPTY) \
+  V(ENOTSOCK) \
+  V(ENOTSUP) \
+  V(ENOTTY) \
+  V(ENXIO) \
+  V(EOPNOTSUPP) \
+  V(EOVERFLOW) \
+  V(EPERM) \
+  V(EPIPE) \
+  V(EPROTO) \
+  V(EPROTONOSUPPORT) \
+  V(EPROTOTYPE) \
+  V(ERANGE) \
+  V(EROFS) \
+  V(ESPIPE) \
+  V(ESRCH) \
+  V(ESTALE) \
+  V(ETIME) \
+  V(ETIMEDOUT) \
+  V(ETXTBSY) \
+  V(EUSERS) \
+  V(EXDEV) \
+  V(EXIT_FAILURE) \
+  V(EXIT_SUCCESS) \
+  V(ETH_P_ALL) \
+  V(ETH_P_ARP) \
+  V(ETH_P_IP) \
+  V(ETH_P_IPV6) \
+  V(FD_CLOEXEC) \
+  V(FIONREAD) \
+  V(F_DUPFD) \
+  V(F_DUPFD_CLOEXEC) \
+  V(F_GETFD) \
+  V(F_GETFL) \
+  V(F_GETOWN) \
+  V(F_OK) \
+  V(R_OK) \
+  V(F_RDLCK) \
+  V(F_SETFD) \
+  V(F_SETFL) \
+  V(F_SETOWN) \
+  V(F_UNLCK) \
+  V(F_WRLCK) \
+  V(ICMP_ECHO) \
+  V(ICMP_ECHOREPLY) \
+  V(ICMP6_ECHO_REQUEST) \
+  V(ICMP6_ECHO_REPLY) \
+  V(IFA_F_DADFAILED) \
+  V(IFA_F_DEPRECATED) \
+  V(IFA_F_HOMEADDRESS) \
+  V(IFA_F_MANAGETEMPADDR) \
+  V(IFA_F_NODAD) \
+  V(IFA_F_NOPREFIXROUTE) \
+  V(IFA_F_OPTIMISTIC) \
+  V(IFA_F_PERMANENT) \
+  V(IFA_F_SECONDARY) \
+  V(IFA_F_TEMPORARY) \
+  V(IFA_F_TENTATIVE) \
+  V(IFF_ALLMULTI) \
+  V(IFF_AUTOMEDIA) \
+  V(IFF_BROADCAST) \
+  V(IFF_DEBUG) \
+  V(IFF_DYNAMIC) \
+  V(IFF_LOOPBACK) \
+  V(IFF_MASTER) \
+  V(IFF_MULTICAST) \
+  V(IFF_NOARP) \
+  V(IFF_NOTRAILERS) \
+  V(IFF_POINTOPOINT) \
+  V(IFF_PORTSEL) \
+  V(IFF_PROMISC) \
+  V(IFF_RUNNING) \
+  V(IFF_SLAVE) \
+  V(IFF_UP) \
+  V(IPPROTO_ICMP) \
+  V(IPPROTO_ICMPV6) \
+  V(IPPROTO_IP) \
+  V(IPPROTO_IPV6) \
+  V(IPPROTO_RAW) \
+  V(IPPROTO_TCP) \
+  V(IPPROTO_UDP) \
+  V(IPPROTO_ESP) \
+  V(IPV6_CHECKSUM) \
+  V(IPV6_MULTICAST_HOPS) \
+  V(IPV6_MULTICAST_IF) \
+  V(IPV6_MULTICAST_LOOP) \
+  V(IPV6_PKTINFO) \
+  V(IPV6_RECVDSTOPTS) \
+  V(IPV6_RECVHOPLIMIT) \
+  V(IPV6_RECVHOPOPTS) \
+  V(IPV6_RECVPKTINFO) \
+  V(IPV6_RECVRTHDR) \
+  V(IPV6_RECVTCLASS) \
+  V(IPV6_TCLASS) \
+  V(IPV6_UNICAST_HOPS) \
+  V(IPV6_V6ONLY) \
+  V(IP_MULTICAST_ALL) \
+  V(IP_MULTICAST_IF) \
+  V(IP_MULTICAST_LOOP) \
+  V(IP_MULTICAST_TTL) \
+  V(IP_RECVTOS) \
+  V(IP_TOS) \
+  V(IP_TTL) \
+  V(MADV_NORMAL) \
+  V(MADV_RANDOM) \
+  V(MADV_SEQUENTIAL) \
+  V(MADV_WILLNEED) \
+  V(MADV_DONTNEED) \
+  V(MADV_REMOVE) \
+  V(MADV_DONTFORK) \
+  V(MADV_DOFORK) \
+  V(MADV_HWPOISON) \
+  V(MADV_MERGEABLE) \
+  V(MADV_UNMERGEABLE) \
+  V(MADV_SOFT_OFFLINE) \
+  V(MADV_HUGEPAGE) \
+  V(MADV_NOHUGEPAGE) \
+  V(MADV_COLLAPSE) \
+  V(MADV_DONTDUMP) \
+  V(MADV_DODUMP) \
+  V(MADV_FREE) \
+  V(MADV_WIPEONFORK) \
+  V(MADV_KEEPONFORK) \
+  V(MADV_COLD) \
+  V(MADV_PAGEOUT) \
+  V(MADV_POPULATE_READ) \
+  V(MADV_POPULATE_WRITE) \
+  V(MAP_FIXED) \
+  V(MAP_ANONYMOUS) \
+  V(MAP_POPULATE) \
+  V(MAP_PRIVATE) \
+  V(MAP_SHARED) \
+  V(MCAST_JOIN_GROUP) \
+  V(MCAST_LEAVE_GROUP) \
+  V(MCAST_JOIN_SOURCE_GROUP) \
+  V(MCAST_LEAVE_SOURCE_GROUP) \
+  V(MCAST_BLOCK_SOURCE) \
+  V(MCAST_UNBLOCK_SOURCE) \
+  V(MCL_CURRENT) \
+  V(MCL_FUTURE) \
+  V(MFD_CLOEXEC) \
+  V(MSG_CTRUNC) \
+  V(MSG_DONTROUTE) \
+  V(MSG_EOR) \
+  V(MSG_OOB) \
+  V(MSG_PEEK) \
+  V(MSG_TRUNC) \
+  V(MSG_WAITALL) \
+  V(MS_ASYNC) \
+  V(MS_INVALIDATE) \
+  V(MS_SYNC) \
+  V(NETLINK_NETFILTER) \
+  V(NETLINK_ROUTE) \
+  V(NETLINK_INET_DIAG) \
+  V(NETLINK_XFRM) \
+  V(NI_DGRAM) \
+  V(O_ACCMODE) \
+  V(O_APPEND) \
+  V(O_CLOEXEC) \
+  V(O_CREAT) \
+  V(O_EXCL) \
+  V(O_NOCTTY) \
+  V(O_NONBLOCK) \
+  V(O_RDONLY) \
+  V(O_RDWR) \
+  V(O_SYNC) \
+  V(O_DSYNC) \
+  V(O_TRUNC) \
+  V(O_WRONLY) \
+  V(POLLERR) \
+  V(POLLHUP) \
+  V(POLLIN) \
+  V(POLLNVAL) \
+  V(POLLOUT) \
+  V(POLLPRI) \
+  V(POLLRDBAND) \
+  V(POLLRDNORM) \
+  V(POLLWRBAND) \
+  V(POLLWRNORM) \
+  V(PR_CAP_AMBIENT) \
+  V(PR_CAP_AMBIENT_RAISE) \
+  V(PR_GET_DUMPABLE) \
+  V(PR_SET_DUMPABLE) \
+  V(PR_SET_NO_NEW_PRIVS) \
+  V(PROT_EXEC) \
+  V(PROT_NONE) \
+  V(PROT_READ) \
+  V(PROT_WRITE) \
+  V(RLIMIT_NOFILE) \
+  V(RLIMIT_RTPRIO) \
+  V(RT_SCOPE_HOST) \
+  V(RT_SCOPE_LINK) \
+  V(RT_SCOPE_NOWHERE) \
+  V(RT_SCOPE_SITE) \
+  V(RT_SCOPE_UNIVERSE) \
+  V(RTMGRP_IPV4_IFADDR) \
+  V(RTMGRP_IPV4_MROUTE) \
+  V(RTMGRP_IPV4_ROUTE) \
+  V(RTMGRP_IPV4_RULE) \
+  V(RTMGRP_IPV6_IFADDR) \
+  V(RTMGRP_IPV6_IFINFO) \
+  V(RTMGRP_IPV6_MROUTE) \
+  V(RTMGRP_IPV6_PREFIX) \
+  V(RTMGRP_IPV6_ROUTE) \
+  V(RTMGRP_LINK) \
+  V(RTMGRP_NEIGH) \
+  V(RTMGRP_NOTIFY) \
+  V(RTMGRP_TC) \
+  V(SEEK_CUR) \
+  V(SEEK_END) \
+  V(SEEK_SET) \
+  V(SHUT_RD) \
+  V(SHUT_RDWR) \
+  V(SHUT_WR) \
+  V(SIGABRT) \
+  V(SIGALRM) \
+  V(SIGBUS) \
+  V(SIGCHLD) \
+  V(SIGCONT) \
+  V(SIGFPE) \
+  V(SIGHUP) \
+  V(SIGILL) \
+  V(SIGINT) \
+  V(SIGIO) \
+  V(SIGKILL) \
+  V(SIGPIPE) \
+  V(SIGPROF) \
+  V(SIGPWR) \
+  V(SIGQUIT) \
+  V(SIGRTMAX) \
+  V(SIGSEGV) \
+  V(SIGSTKFLT) \
+  V(SIGSTOP) \
+  V(SIGSYS) \
+  V(SIGTERM) \
+  V(SIGTRAP) \
+  V(SIGTSTP) \
+  V(SIGTTIN) \
+  V(SIGTTOU) \
+  V(SIGURG) \
+  V(SIGUSR1) \
+  V(SIGUSR2) \
+  V(SIGVTALRM) \
+  V(SIGWINCH) \
+  V(SIGXCPU) \
+  V(SIGXFSZ) \
+  V(SIOCGIFADDR) \
+  V(SIOCGIFBRDADDR) \
+  V(SIOCGIFDSTADDR) \
+  V(SIOCGIFNETMASK) \
+  V(SOCK_CLOEXEC) \
+  V(SOCK_DGRAM) \
+  V(SOCK_NONBLOCK) \
+  V(SOCK_RAW) \
+  V(SOCK_SEQPACKET) \
+  V(SOCK_STREAM) \
+  V(SOL_SOCKET) \
+  V(SOL_UDP) \
+  V(SOL_PACKET) \
+  V(SO_BINDTODEVICE) \
+  V(SO_BROADCAST) \
+  V(SO_DEBUG) \
+  V(SO_DOMAIN) \
+  V(SO_DONTROUTE) \
+  V(SO_ERROR) \
+  V(SO_KEEPALIVE) \
+  V(SO_LINGER) \
+  V(SO_OOBINLINE) \
+  V(SO_PASSCRED) \
+  V(SO_PEERCRED) \
+  V(SO_PROTOCOL) \
+  V(SO_RCVBUF) \
+  V(SO_RCVLOWAT) \
+  V(SO_RCVTIMEO) \
+  V(SO_REUSEADDR) \
+  V(SO_SNDBUF) \
+  V(SO_SNDLOWAT) \
+  V(SO_SNDTIMEO) \
+  V(SO_TYPE) \
+  V(PACKET_IGNORE_OUTGOING) \
+  V(SPLICE_F_MOVE) \
+  V(SPLICE_F_NONBLOCK) \
+  V(SPLICE_F_MORE) \
+  V(ST_MANDLOCK) \
+  V(ST_NOATIME) \
+  V(ST_NODEV) \
+  V(ST_NODIRATIME) \
+  V(ST_NOEXEC) \
+  V(ST_NOSUID) \
+  V(ST_RDONLY) \
+  V(ST_RELATIME) \
+  V(ST_SYNCHRONOUS) \
+  V(S_IFBLK) \
+  V(S_IFCHR) \
+  V(S_IFDIR) \
+  V(S_IFIFO) \
+  V(S_IFLNK) \
+  V(S_IFMT) \
+  V(S_IFREG) \
+  V(S_IFSOCK) \
+  V(S_IRGRP) \
+  V(S_IROTH) \
+  V(S_IRUSR) \
+  V(S_IRWXG) \
+  V(S_IRWXO) \
+  V(S_IRWXU) \
+  V(S_ISGID) \
+  V(S_ISUID) \
+  V(S_ISVTX) \
+  V(S_IWGRP) \
+  V(S_IWOTH) \
+  V(S_IWUSR) \
+  V(S_IXGRP) \
+  V(S_IXOTH) \
+  V(S_IXUSR) \
+  V(TCP_NODELAY) \
+  V(TCP_USER_TIMEOUT) \
+  V(UDP_GRO) \
+  V(UDP_SEGMENT) \
+  V(TIOCOUTQ) \
+  V(UDP_ENCAP) \
+  V(UDP_ENCAP_ESPINUDP_NON_IKE) \
+  V(UDP_ENCAP_ESPINUDP) \
+  V(UNIX_PATH_MAX) \
+  V(WCONTINUED) \
+  V(WEXITED) \
+  V(WNOHANG) \
+  V(WNOWAIT) \
+  V(WSTOPPED) \
+  V(WUNTRACED) \
+  V(W_OK) \
+  V(XATTR_CREATE) \
+  V(XATTR_REPLACE) \
+  V(X_OK) \
+
+// glibc's sys/un.h does not have UNIX_MAX_PATH and just hardcodes 108 in the sockaddr_un struct.
+#ifndef UNIX_PATH_MAX
+#define UNIX_PATH_MAX sizeof(sockaddr_un::sun_path)
+#endif
+
+static void validateConstant(JNIEnv* env, jclass c, const char* fieldName, int value) {
+    jfieldID field = env->GetStaticFieldID(c, fieldName, "I");
+    int actual = env->GetStaticIntField(c, field);
+    if (actual != value) {
+        LOG(FATAL) << "Value of " << fieldName << " is wrong. "
+                   << "Expected " << value << ", got " << actual;
+    }
+}
+
+static void validateConstants(JNIEnv* env, jclass c) {
+#define VALIDATE_CONSTANTS(Name) \
+    validateConstant(env, c, # Name, Name);
+    JAVA_INITIALIZED_FIELDS(VALIDATE_CONSTANTS)
+#undef VALIDATE_CONSTANTS
+}
+
+extern "C"
+JNIEXPORT void JNICALL Java_libcore_android_system_OsConstantsTest_checkConsistency(JNIEnv* env,
+                                                                                    jclass) {
+    jclass os_constants_class = env->FindClass("android/system/OsConstants");
+    if (os_constants_class == nullptr) {
+        LOG(FATAL) << "Could not find OsConstants";
+    }
+    validateConstants(env, os_constants_class);
+}
+
+#define ONE_PLUS(Name) 1 +
+static constexpr size_t kJavaInitializedFieldsCount = JAVA_INITIALIZED_FIELDS(ONE_PLUS) 0;
+#undef ONE_PLUS
+
+extern "C"
+JNIEXPORT jint JNICALL Java_libcore_android_system_OsConstantsTest_initializedInJavaCount(
+        JNIEnv*,
+        jclass) {
+    return kJavaInitializedFieldsCount;
+}
diff --git a/luni/src/main/native/sun_misc_Unsafe.cpp b/luni/src/test/native/libcore_android_system_OsTest.cpp
similarity index 59%
rename from luni/src/main/native/sun_misc_Unsafe.cpp
rename to luni/src/test/native/libcore_android_system_OsTest.cpp
index 49848a2db2b..61e754dff2f 100644
--- a/luni/src/main/native/sun_misc_Unsafe.cpp
+++ b/luni/src/test/native/libcore_android_system_OsTest.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 The Android Open Source Project
+ * Copyright (C) 2011 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,18 +14,20 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "Unsafe"
+#include <dlfcn.h>
 
 #include <nativehelper/JNIHelp.h>
 #include <nativehelper/jni_macros.h>
 
-static jobject Unsafe_allocateInstance(JNIEnv* env, jclass, jclass c) {
-  return env->AllocObject(c);
-}
+#include "android-base/logging.h"
+
+extern "C"
+JNIEXPORT jlong JNICALL Java_libcore_android_system_OsTest_findMktime(JNIEnv*, jclass) {
+    void* mktime_func = dlsym(RTLD_DEFAULT, "mktime");
+    if (mktime_func == nullptr) {
+        LOG(FATAL) << "Can't find mktime. dlerror=" << dlerror();
+        return 0;
+    }
 
-static JNINativeMethod gMethods[] = {
-  NATIVE_METHOD(Unsafe, allocateInstance, "(Ljava/lang/Class;)Ljava/lang/Object;"),
-};
-void register_sun_misc_Unsafe(JNIEnv* env) {
-  jniRegisterNativeMethods(env, "sun/misc/Unsafe", gMethods, NELEM(gMethods));
+    return reinterpret_cast<jlong>(mktime_func);
 }
diff --git a/luni/src/test/native/libcore_java_io_FileTest.cpp b/luni/src/test/native/libcore_java_io_FileTest.cpp
index a9e595d34e3..3f8d7f45d82 100644
--- a/luni/src/test/native/libcore_java_io_FileTest.cpp
+++ b/luni/src/test/native/libcore_java_io_FileTest.cpp
@@ -59,13 +59,10 @@ extern "C" void Java_libcore_java_io_FileTest_nativeTestFilesWithSurrogatePairs(
 extern "C" int Java_libcore_java_io_FileTest_installSeccompFilter(JNIEnv* , jclass /* clazz */) {
     struct sock_filter filter[] = {
         BPF_STMT(BPF_LD|BPF_W|BPF_ABS, offsetof(struct seccomp_data, nr)),
-
-// for arm, x86.
-#ifdef __NR_fstatat64
-        BPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_fstatat64, 0, 1),
-#else
-// for arm64, x86_64.
+#ifdef __LP64__
         BPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_newfstatat, 0, 1),
+#else
+        BPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_fstatat64, 0, 1),
 #endif
         BPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ERRNO | EPERM),
         BPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),
diff --git a/non_openjdk_java_files.bp b/non_openjdk_java_files.bp
index a08f1a3c261..dba8ceca0a5 100644
--- a/non_openjdk_java_files.bp
+++ b/non_openjdk_java_files.bp
@@ -88,6 +88,10 @@ filegroup {
         "libart/src/main/java/dalvik/system/AnnotatedStackTraceElement.java",
         "libart/src/main/java/dalvik/system/ClassExt.java",
         "libart/src/main/java/dalvik/system/TransactionAbortError.java",
+        "libart/src/main/java/dalvik/system/VirtualThreadContext.java",
+        "libart/src/main/java/dalvik/system/VirtualThreadParkedStates.java",
+        "libart/src/main/java/dalvik/system/VirtualThreadParkingError.java",
+        "libart/src/main/java/dalvik/system/VirtualThreadFrame.java",
         "libart/src/main/java/dalvik/system/VMRuntime.java",
         "libart/src/main/java/dalvik/system/VMStack.java",
         "libart/src/main/java/java/lang/AndroidHardcodedSystemProperties.java",
@@ -113,6 +117,7 @@ filegroup {
         "luni/src/main/java/libcore/api/Hide.java",
         "luni/src/main/java/libcore/api/IntraCoreApi.java",
     ],
+    visibility: ["//external/conscrypt"],
 }
 
 // The set of annotations used for defining the hidden API surface.
@@ -146,11 +151,13 @@ filegroup {
         "luni/src/main/java/android/system/NetlinkSocketAddress.java",
         "luni/src/main/java/android/system/Os.java",
         "luni/src/main/java/android/system/OsConstants.java",
+        "luni/src/main/java/android/system/OsConstantsHolder.java",
         "luni/src/main/java/android/system/PacketSocketAddress.java",
         "luni/src/main/java/android/system/StructAddrinfo.java",
         "luni/src/main/java/android/system/StructCapUserData.java",
         "luni/src/main/java/android/system/StructCapUserHeader.java",
         "luni/src/main/java/android/system/StructCmsghdr.java",
+        "luni/src/main/java/android/system/StructDlInfo.java",
         "luni/src/main/java/android/system/StructGroupReq.java",
         "luni/src/main/java/android/system/StructIfaddrs.java",
         "luni/src/main/java/android/system/StructLinger.java",
diff --git a/ojluni/annotations/flagged_api/java/lang/ThreadGroup.annotated.java b/ojluni/annotations/flagged_api/java/lang/ThreadGroup.annotated.java
new file mode 100644
index 00000000000..f8b69c60577
--- /dev/null
+++ b/ojluni/annotations/flagged_api/java/lang/ThreadGroup.annotated.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ * Copyright (c) 1995, 2021, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+
+package java.lang;
+
+@SuppressWarnings({"unchecked", "deprecation", "all"})
+public class ThreadGroup implements java.lang.Thread.UncaughtExceptionHandler {
+
+public ThreadGroup(java.lang.String name) { throw new RuntimeException("Stub!"); }
+
+public ThreadGroup(java.lang.ThreadGroup parent, java.lang.String name) { throw new RuntimeException("Stub!"); }
+
+public int activeCount() { throw new RuntimeException("Stub!"); }
+
+public int activeGroupCount() { throw new RuntimeException("Stub!"); }
+
+@Deprecated
+public boolean allowThreadSuspension(boolean b) { throw new RuntimeException("Stub!"); }
+
+@android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_OPENJDK_25_V1_APIS)
+@Deprecated
+public final void checkAccess() { throw new RuntimeException("Stub!"); }
+
+@android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_OPENJDK_25_V1_APIS)
+@Deprecated
+public final void destroy() { throw new RuntimeException("Stub!"); }
+
+public int enumerate(java.lang.Thread[] list) { throw new RuntimeException("Stub!"); }
+
+public int enumerate(java.lang.Thread[] list, boolean recurse) { throw new RuntimeException("Stub!"); }
+
+public int enumerate(java.lang.ThreadGroup[] list) { throw new RuntimeException("Stub!"); }
+
+public int enumerate(java.lang.ThreadGroup[] list, boolean recurse) { throw new RuntimeException("Stub!"); }
+
+public final int getMaxPriority() { throw new RuntimeException("Stub!"); }
+
+public final java.lang.String getName() { throw new RuntimeException("Stub!"); }
+
+public final java.lang.ThreadGroup getParent() { throw new RuntimeException("Stub!"); }
+
+public final void interrupt() { throw new RuntimeException("Stub!"); }
+
+@android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_OPENJDK_25_V1_APIS)
+@Deprecated
+public final boolean isDaemon() { throw new RuntimeException("Stub!"); }
+
+@android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_OPENJDK_25_V1_APIS)
+@Deprecated
+public synchronized boolean isDestroyed() { throw new RuntimeException("Stub!"); }
+
+public void list() { throw new RuntimeException("Stub!"); }
+
+public final boolean parentOf(java.lang.ThreadGroup g) { throw new RuntimeException("Stub!"); }
+
+@Deprecated
+public final void resume() { throw new RuntimeException("Stub!"); }
+
+@android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_OPENJDK_25_V1_APIS)
+@Deprecated
+public final void setDaemon(boolean daemon) { throw new RuntimeException("Stub!"); }
+
+public final void setMaxPriority(int pri) { throw new RuntimeException("Stub!"); }
+
+@Deprecated
+public final void stop() { throw new RuntimeException("Stub!"); }
+
+@Deprecated
+public final void suspend() { throw new RuntimeException("Stub!"); }
+
+public java.lang.String toString() { throw new RuntimeException("Stub!"); }
+
+public void uncaughtException(java.lang.Thread t, java.lang.Throwable e) { throw new RuntimeException("Stub!"); }
+}
+
diff --git a/ojluni/annotations/flagged_api/java/nio/file/FileSystems.annotated.java b/ojluni/annotations/flagged_api/java/nio/file/FileSystems.annotated.java
new file mode 100644
index 00000000000..0e0f283dd7b
--- /dev/null
+++ b/ojluni/annotations/flagged_api/java/nio/file/FileSystems.annotated.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2007, 2021, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+
+package java.nio.file;
+
+@SuppressWarnings({"unchecked", "deprecation", "all"})
+public final class FileSystems {
+
+FileSystems() { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.FileSystem getDefault() { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.FileSystem getFileSystem(java.net.URI uri) { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.FileSystem newFileSystem(java.net.URI uri, java.util.Map<java.lang.String,?> env) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.FileSystem newFileSystem(java.net.URI uri, java.util.Map<java.lang.String,?> env, java.lang.ClassLoader loader) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+@android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_OPENJDK_21_V2_APIS)
+public static java.nio.file.FileSystem newFileSystem(java.nio.file.Path path) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.FileSystem newFileSystem(java.nio.file.Path path, java.lang.ClassLoader loader) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+@android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_OPENJDK_21_V2_APIS)
+public static java.nio.file.FileSystem newFileSystem(java.nio.file.Path path, java.util.Map<java.lang.String,?> env) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+@android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_OPENJDK_21_V2_APIS)
+public static java.nio.file.FileSystem newFileSystem(java.nio.file.Path path, java.util.Map<java.lang.String,?> env, java.lang.ClassLoader loader) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+}
+
diff --git a/ojluni/annotations/flagged_api/java/nio/file/Files.annotated.java b/ojluni/annotations/flagged_api/java/nio/file/Files.annotated.java
new file mode 100644
index 00000000000..ef8e5f2addc
--- /dev/null
+++ b/ojluni/annotations/flagged_api/java/nio/file/Files.annotated.java
@@ -0,0 +1,176 @@
+/*
+ * Copyright (c) 2007, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+
+package java.nio.file;
+
+@SuppressWarnings({"unchecked", "deprecation", "all"})
+public final class Files {
+
+Files() { throw new RuntimeException("Stub!"); }
+
+public static long copy(java.io.InputStream in, java.nio.file.Path target, java.nio.file.CopyOption... options) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static long copy(java.nio.file.Path source, java.io.OutputStream out) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.Path copy(java.nio.file.Path source, java.nio.file.Path target, java.nio.file.CopyOption... options) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.Path createDirectories(java.nio.file.Path dir, java.nio.file.attribute.FileAttribute<?>... attrs) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.Path createDirectory(java.nio.file.Path dir, java.nio.file.attribute.FileAttribute<?>... attrs) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.Path createFile(java.nio.file.Path path, java.nio.file.attribute.FileAttribute<?>... attrs) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.Path createLink(java.nio.file.Path link, java.nio.file.Path existing) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.Path createSymbolicLink(java.nio.file.Path link, java.nio.file.Path target, java.nio.file.attribute.FileAttribute<?>... attrs) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.Path createTempDirectory(java.lang.String prefix, java.nio.file.attribute.FileAttribute<?>... attrs) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.Path createTempDirectory(java.nio.file.Path dir, java.lang.String prefix, java.nio.file.attribute.FileAttribute<?>... attrs) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.Path createTempFile(java.lang.String prefix, java.lang.String suffix, java.nio.file.attribute.FileAttribute<?>... attrs) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.Path createTempFile(java.nio.file.Path dir, java.lang.String prefix, java.lang.String suffix, java.nio.file.attribute.FileAttribute<?>... attrs) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static void delete(java.nio.file.Path path) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static boolean deleteIfExists(java.nio.file.Path path) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static boolean exists(java.nio.file.Path path, java.nio.file.LinkOption... options) { throw new RuntimeException("Stub!"); }
+
+public static java.util.stream.Stream<java.nio.file.Path> find(java.nio.file.Path start, int maxDepth, java.util.function.BiPredicate<java.nio.file.Path,java.nio.file.attribute.BasicFileAttributes> matcher, java.nio.file.FileVisitOption... options) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.lang.Object getAttribute(java.nio.file.Path path, java.lang.String attribute, java.nio.file.LinkOption... options) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static <V extends java.nio.file.attribute.FileAttributeView> V getFileAttributeView(java.nio.file.Path path, java.lang.Class<V> type, java.nio.file.LinkOption... options) { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.FileStore getFileStore(java.nio.file.Path path) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.attribute.FileTime getLastModifiedTime(java.nio.file.Path path, java.nio.file.LinkOption... options) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.attribute.UserPrincipal getOwner(java.nio.file.Path path, java.nio.file.LinkOption... options) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.util.Set<java.nio.file.attribute.PosixFilePermission> getPosixFilePermissions(java.nio.file.Path path, java.nio.file.LinkOption... options) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static boolean isDirectory(java.nio.file.Path path, java.nio.file.LinkOption... options) { throw new RuntimeException("Stub!"); }
+
+public static boolean isExecutable(java.nio.file.Path path) { throw new RuntimeException("Stub!"); }
+
+public static boolean isHidden(java.nio.file.Path path) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static boolean isReadable(java.nio.file.Path path) { throw new RuntimeException("Stub!"); }
+
+public static boolean isRegularFile(java.nio.file.Path path, java.nio.file.LinkOption... options) { throw new RuntimeException("Stub!"); }
+
+public static boolean isSameFile(java.nio.file.Path path, java.nio.file.Path path2) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static boolean isSymbolicLink(java.nio.file.Path path) { throw new RuntimeException("Stub!"); }
+
+public static boolean isWritable(java.nio.file.Path path) { throw new RuntimeException("Stub!"); }
+
+public static java.util.stream.Stream<java.lang.String> lines(java.nio.file.Path path) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.util.stream.Stream<java.lang.String> lines(java.nio.file.Path path, java.nio.charset.Charset cs) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.util.stream.Stream<java.nio.file.Path> list(java.nio.file.Path dir) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.Path move(java.nio.file.Path source, java.nio.file.Path target, java.nio.file.CopyOption... options) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.io.BufferedReader newBufferedReader(java.nio.file.Path path) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.io.BufferedReader newBufferedReader(java.nio.file.Path path, java.nio.charset.Charset cs) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.io.BufferedWriter newBufferedWriter(java.nio.file.Path path, java.nio.charset.Charset cs, java.nio.file.OpenOption... options) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.io.BufferedWriter newBufferedWriter(java.nio.file.Path path, java.nio.file.OpenOption... options) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.channels.SeekableByteChannel newByteChannel(java.nio.file.Path path, java.nio.file.OpenOption... options) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.channels.SeekableByteChannel newByteChannel(java.nio.file.Path path, java.util.Set<? extends java.nio.file.OpenOption> options, java.nio.file.attribute.FileAttribute<?>... attrs) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.DirectoryStream<java.nio.file.Path> newDirectoryStream(java.nio.file.Path dir) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.DirectoryStream<java.nio.file.Path> newDirectoryStream(java.nio.file.Path dir, java.lang.String glob) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.DirectoryStream<java.nio.file.Path> newDirectoryStream(java.nio.file.Path dir, java.nio.file.DirectoryStream.Filter<? super java.nio.file.Path> filter) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.io.InputStream newInputStream(java.nio.file.Path path, java.nio.file.OpenOption... options) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.io.OutputStream newOutputStream(java.nio.file.Path path, java.nio.file.OpenOption... options) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static boolean notExists(java.nio.file.Path path, java.nio.file.LinkOption... options) { throw new RuntimeException("Stub!"); }
+
+public static java.lang.String probeContentType(java.nio.file.Path path) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static byte[] readAllBytes(java.nio.file.Path path) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.util.List<java.lang.String> readAllLines(java.nio.file.Path path) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.util.List<java.lang.String> readAllLines(java.nio.file.Path path, java.nio.charset.Charset cs) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static <A extends java.nio.file.attribute.BasicFileAttributes> A readAttributes(java.nio.file.Path path, java.lang.Class<A> type, java.nio.file.LinkOption... options) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.util.Map<java.lang.String,java.lang.Object> readAttributes(java.nio.file.Path path, java.lang.String attributes, java.nio.file.LinkOption... options) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+@android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_OPENJDK_21_V2_APIS)
+public static java.lang.String readString(java.nio.file.Path path) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+@android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_OPENJDK_21_V2_APIS)
+public static java.lang.String readString(java.nio.file.Path path, java.nio.charset.Charset cs) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.Path readSymbolicLink(java.nio.file.Path link) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.Path setAttribute(java.nio.file.Path path, java.lang.String attribute, java.lang.Object value, java.nio.file.LinkOption... options) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.Path setLastModifiedTime(java.nio.file.Path path, java.nio.file.attribute.FileTime time) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.Path setOwner(java.nio.file.Path path, java.nio.file.attribute.UserPrincipal owner) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.Path setPosixFilePermissions(java.nio.file.Path path, java.util.Set<java.nio.file.attribute.PosixFilePermission> perms) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static long size(java.nio.file.Path path) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.util.stream.Stream<java.nio.file.Path> walk(java.nio.file.Path start, int maxDepth, java.nio.file.FileVisitOption... options) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.util.stream.Stream<java.nio.file.Path> walk(java.nio.file.Path start, java.nio.file.FileVisitOption... options) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.Path walkFileTree(java.nio.file.Path start, java.nio.file.FileVisitor<? super java.nio.file.Path> visitor) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.Path walkFileTree(java.nio.file.Path start, java.util.Set<java.nio.file.FileVisitOption> options, int maxDepth, java.nio.file.FileVisitor<? super java.nio.file.Path> visitor) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.Path write(java.nio.file.Path path, byte[] bytes, java.nio.file.OpenOption... options) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.Path write(java.nio.file.Path path, java.lang.Iterable<? extends java.lang.CharSequence> lines, java.nio.charset.Charset cs, java.nio.file.OpenOption... options) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+public static java.nio.file.Path write(java.nio.file.Path path, java.lang.Iterable<? extends java.lang.CharSequence> lines, java.nio.file.OpenOption... options) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+@android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_OPENJDK_21_V2_APIS)
+public static java.nio.file.Path writeString(java.nio.file.Path path, java.lang.CharSequence csq, java.nio.charset.Charset cs, java.nio.file.OpenOption... options) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+
+@android.annotation.FlaggedApi(com.android.libcore.Flags.FLAG_OPENJDK_21_V2_APIS)
+public static java.nio.file.Path writeString(java.nio.file.Path path, java.lang.CharSequence csq, java.nio.file.OpenOption... options) throws java.io.IOException { throw new RuntimeException("Stub!"); }
+}
+
diff --git a/ojluni/annotations/hiddenapi/java/lang/Thread.java b/ojluni/annotations/hiddenapi/java/lang/Thread.java
index 235743c9c1e..a7cb283fb56 100644
--- a/ojluni/annotations/hiddenapi/java/lang/Thread.java
+++ b/ojluni/annotations/hiddenapi/java/lang/Thread.java
@@ -183,10 +183,18 @@ public class Thread implements java.lang.Runnable {
         throw new RuntimeException("Stub!");
     }
 
+    public final int setPosixNicenessInternal(int newNiceness) {
+        throw new RuntimeException("Stub!");
+    }
+
     public final int getPriority() {
         throw new RuntimeException("Stub!");
     }
 
+    public final int getPosixNicenessInternal() {
+        throw new RuntimeException("Stub!");
+    }
+
     public final synchronized void setName(java.lang.String name) {
         throw new RuntimeException("Stub!");
     }
@@ -319,7 +327,13 @@ public class Thread implements java.lang.Runnable {
         throw new RuntimeException("Stub!");
     }
 
-    private native void setPriority0(int newPriority);
+    native void setPriority0(int newPriority);
+
+    private native int setNiceness0(int niceness);
+
+    public static native int priorityForNiceness(int niceness);
+
+    public static native int nicenessForPriority(int priority);
 
     private native void interrupt0();
 
@@ -402,6 +416,8 @@ public class Thread implements java.lang.Runnable {
     @UnsupportedAppUsage
     private volatile long nativePeer;
 
+    private int niceness;
+
     @UnsupportedAppUsage
     volatile java.lang.Object parkBlocker;
 
diff --git a/ojluni/src/main/api_only/java/nio/file/Path.java b/ojluni/src/main/api_only/java/nio/file/Path.java
new file mode 100644
index 00000000000..5df35c275fd
--- /dev/null
+++ b/ojluni/src/main/api_only/java/nio/file/Path.java
@@ -0,0 +1,915 @@
+/*
+ * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package java.nio.file;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URI;
+import java.nio.file.spi.FileSystemProvider;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ * An object that may be used to locate a file in a file system. It will
+ * typically represent a system dependent file path.
+ *
+ * <p> A {@code Path} represents a path that is hierarchical and composed of a
+ * sequence of directory and file name elements separated by a special separator
+ * or delimiter. A <em>root component</em>, that identifies a file system
+ * hierarchy, may also be present. The name element that is <em>farthest</em>
+ * from the root of the directory hierarchy is the name of a file or directory.
+ * The other name elements are directory names. A {@code Path} can represent a
+ * root, a root and a sequence of names, or simply one or more name elements.
+ * A {@code Path} is considered to be an <i>empty path</i> if it consists
+ * solely of one name element that is empty. Accessing a file using an
+ * <i>empty path</i> is equivalent to accessing the default directory of the
+ * file system. {@code Path} defines the {@link #getFileName() getFileName},
+ * {@link #getParent getParent}, {@link #getRoot getRoot}, and {@link #subpath
+ * subpath} methods to access the path components or a subsequence of its name
+ * elements.
+ *
+ * <p> In addition to accessing the components of a path, a {@code Path} also
+ * defines the {@link #resolve(Path) resolve} and {@link #resolveSibling(Path)
+ * resolveSibling} methods to combine paths. The {@link #relativize relativize}
+ * method that can be used to construct a relative path between two paths.
+ * Paths can be {@link #compareTo compared}, and tested against each other using
+ * the {@link #startsWith startsWith} and {@link #endsWith endsWith} methods.
+ *
+ * <p> This interface extends {@link Watchable} interface so that a directory
+ * located by a path can be {@link #register registered} with a {@link
+ * WatchService} and entries in the directory watched. </p>
+ *
+ * <p> <b>WARNING:</b> This interface is only intended to be implemented by
+ * those developing custom file system implementations. Methods may be added to
+ * this interface in future releases. </p>
+ *
+ * <h2>Accessing Files</h2>
+ * <p> Paths may be used with the {@link Files} class to operate on files,
+ * directories, and other types of files. For example, suppose we want a {@link
+ * java.io.BufferedReader} to read text from a file "{@code access.log}". The
+ * file is located in a directory "{@code logs}" relative to the current working
+ * directory and is UTF-8 encoded.
+ * <pre>
+ *     Path path = FileSystems.getDefault().getPath("logs", "access.log");
+ *     BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8);
+ * </pre>
+ *
+ * <a id="interop"></a><h2>Interoperability</h2>
+ * <p> Paths associated with the default {@link
+ * java.nio.file.spi.FileSystemProvider provider} are generally interoperable
+ * with the {@link java.io.File java.io.File} class. Paths created by other
+ * providers are unlikely to be interoperable with the abstract path names
+ * represented by {@code java.io.File}. The {@link java.io.File#toPath toPath}
+ * method may be used to obtain a {@code Path} from the abstract path name
+ * represented by a {@code java.io.File} object. The resulting {@code Path} can
+ * be used to operate on the same file as the {@code java.io.File} object. In
+ * addition, the {@link #toFile toFile} method is useful to construct a {@code
+ * File} from the {@code String} representation of a {@code Path}.
+ *
+ * <h2>Concurrency</h2>
+ * <p> Implementations of this interface are immutable and safe for use by
+ * multiple concurrent threads.
+ *
+ * @since 1.7
+ */
+
+public interface Path
+    extends Comparable<Path>, Iterable<Path>, Watchable
+{
+    /**
+     * Returns a {@code Path} by converting a path string, or a sequence of
+     * strings that when joined form a path string. If {@code more} does not
+     * specify any elements then the value of the {@code first} parameter is
+     * the path string to convert. If {@code more} specifies one or more
+     * elements then each non-empty string, including {@code first}, is
+     * considered to be a sequence of name elements and is joined to form a
+     * path string. The details as to how the Strings are joined is provider
+     * specific but typically they will be joined using the
+     * {@link FileSystem#getSeparator name-separator} as the separator.
+     * For example, if the name separator is "{@code /}" and
+     * {@code getPath("/foo","bar","gus")} is invoked, then the path string
+     * {@code "/foo/bar/gus"} is converted to a {@code Path}. A {@code Path}
+     * representing an empty path is returned if {@code first} is the empty
+     * string and {@code more} does not contain any non-empty strings.
+     *
+     * <p> The {@code Path} is obtained by invoking the {@link FileSystem#getPath
+     * getPath} method of the {@link FileSystems#getDefault default} {@link
+     * FileSystem}.
+     *
+     * <p> Note that while this method is very convenient, using it will imply
+     * an assumed reference to the default {@code FileSystem} and limit the
+     * utility of the calling code. Hence it should not be used in library code
+     * intended for flexible reuse. A more flexible alternative is to use an
+     * existing {@code Path} instance as an anchor, such as:
+     * <pre>{@code
+     *     Path dir = ...
+     *     Path path = dir.resolve("file");
+     * }</pre>
+     *
+     * @param   first
+     *          the path string or initial part of the path string
+     * @param   more
+     *          additional strings to be joined to form the path string
+     *
+     * @return  the resulting {@code Path}
+     *
+     * @throws  InvalidPathException
+     *          if the path string cannot be converted to a {@code Path}
+     *
+     * @see FileSystem#getPath
+     *
+     * @since 11
+     */
+    public static Path of(String first, String... more) {
+        return FileSystems.getDefault().getPath(first, more);
+    }
+
+    /**
+     * Returns a {@code Path} by converting a URI.
+     *
+     * <p> This method iterates over the {@link FileSystemProvider#installedProviders()
+     * installed} providers to locate the provider that is identified by the
+     * URI {@link URI#getScheme scheme} of the given URI. URI schemes are
+     * compared without regard to case. If the provider is found then its {@link
+     * FileSystemProvider#getPath getPath} method is invoked to convert the
+     * URI.
+     *
+     * <p> In the case of the default provider, identified by the URI scheme
+     * "file", the given URI has a non-empty path component, and undefined query
+     * and fragment components. Whether the authority component may be present
+     * is platform specific. The returned {@code Path} is associated with the
+     * {@link FileSystems#getDefault default} file system.
+     *
+     * <p> The default provider provides a similar <em>round-trip</em> guarantee
+     * to the {@link java.io.File} class. For a given {@code Path} <i>p</i> it
+     * is guaranteed that
+     * <blockquote>{@code
+     * Path.of(}<i>p</i>{@code .}{@link Path#toUri() toUri}{@code ()).equals(}
+     * <i>p</i>{@code .}{@link Path#toAbsolutePath() toAbsolutePath}{@code ())}
+     * </blockquote>
+     * so long as the original {@code Path}, the {@code URI}, and the new {@code
+     * Path} are all created in (possibly different invocations of) the same
+     * Java virtual machine. Whether other providers make any guarantees is
+     * provider specific and therefore unspecified.
+     *
+     * @param   uri
+     *          the URI to convert
+     *
+     * @return  the resulting {@code Path}
+     *
+     * @throws  IllegalArgumentException
+     *          if preconditions on the {@code uri} parameter do not hold. The
+     *          format of the URI is provider specific.
+     * @throws  FileSystemNotFoundException
+     *          The file system, identified by the URI, does not exist and
+     *          cannot be created automatically, or the provider identified by
+     *          the URI's scheme component is not installed
+     * @throws  SecurityException
+     *          if a security manager is installed and it denies an unspecified
+     *          permission to access the file system
+     *
+     * @since 11
+     */
+    public static Path of(URI uri) {
+        String scheme =  uri.getScheme();
+        if (scheme == null)
+            throw new IllegalArgumentException("Missing scheme");
+
+        // check for default provider to avoid loading of installed providers
+        if (scheme.equalsIgnoreCase("file"))
+            return FileSystems.getDefault().provider().getPath(uri);
+
+        // try to find provider
+        for (FileSystemProvider provider: FileSystemProvider.installedProviders()) {
+            if (provider.getScheme().equalsIgnoreCase(scheme)) {
+                return provider.getPath(uri);
+            }
+        }
+
+        throw new FileSystemNotFoundException("Provider \"" + scheme + "\" not installed");
+    }
+
+    /**
+     * Returns the file system that created this object.
+     *
+     * @return  the file system that created this object
+     */
+    FileSystem getFileSystem();
+
+    /**
+     * Tells whether or not this path is absolute.
+     *
+     * <p> An absolute path is complete in that it doesn't need to be combined
+     * with other path information in order to locate a file.
+     *
+     * @return  {@code true} if, and only if, this path is absolute
+     */
+    boolean isAbsolute();
+
+    /**
+     * Returns the root component of this path as a {@code Path} object,
+     * or {@code null} if this path does not have a root component.
+     *
+     * @return  a path representing the root component of this path,
+     *          or {@code null}
+     */
+    Path getRoot();
+
+    /**
+     * Returns the name of the file or directory denoted by this path as a
+     * {@code Path} object. The file name is the <em>farthest</em> element from
+     * the root in the directory hierarchy.
+     *
+     * @return  a path representing the name of the file or directory, or
+     *          {@code null} if this path has zero elements
+     */
+    Path getFileName();
+
+    /**
+     * Returns the <em>parent path</em>, or {@code null} if this path does not
+     * have a parent.
+     *
+     * <p> The parent of this path object consists of this path's root
+     * component, if any, and each element in the path except for the
+     * <em>farthest</em> from the root in the directory hierarchy. This method
+     * does not access the file system; the path or its parent may not exist.
+     * Furthermore, this method does not eliminate special names such as "."
+     * and ".." that may be used in some implementations. On UNIX for example,
+     * the parent of "{@code /a/b/c}" is "{@code /a/b}", and the parent of
+     * {@code "x/y/.}" is "{@code x/y}". This method may be used with the {@link
+     * #normalize normalize} method, to eliminate redundant names, for cases where
+     * <em>shell-like</em> navigation is required.
+     *
+     * <p> If this path has one or more elements, and no root component, then
+     * this method is equivalent to evaluating the expression:
+     * <blockquote><pre>
+     * subpath(0,&nbsp;getNameCount()-1);
+     * </pre></blockquote>
+     *
+     * @return  a path representing the path's parent
+     */
+    Path getParent();
+
+    /**
+     * Returns the number of name elements in the path.
+     *
+     * @return  the number of elements in the path, or {@code 0} if this path
+     *          only represents a root component
+     */
+    int getNameCount();
+
+    /**
+     * Returns a name element of this path as a {@code Path} object.
+     *
+     * <p> The {@code index} parameter is the index of the name element to return.
+     * The element that is <em>closest</em> to the root in the directory hierarchy
+     * has index {@code 0}. The element that is <em>farthest</em> from the root
+     * has index {@link #getNameCount count}{@code -1}.
+     *
+     * @param   index
+     *          the index of the element
+     *
+     * @return  the name element
+     *
+     * @throws  IllegalArgumentException
+     *          if {@code index} is negative, {@code index} is greater than or
+     *          equal to the number of elements, or this path has zero name
+     *          elements
+     */
+    Path getName(int index);
+
+    /**
+     * Returns a relative {@code Path} that is a subsequence of the name
+     * elements of this path.
+     *
+     * <p> The {@code beginIndex} and {@code endIndex} parameters specify the
+     * subsequence of name elements. The name that is <em>closest</em> to the root
+     * in the directory hierarchy has index {@code 0}. The name that is
+     * <em>farthest</em> from the root has index {@link #getNameCount
+     * count}{@code -1}. The returned {@code Path} object has the name elements
+     * that begin at {@code beginIndex} and extend to the element at index {@code
+     * endIndex-1}.
+     *
+     * @param   beginIndex
+     *          the index of the first element, inclusive
+     * @param   endIndex
+     *          the index of the last element, exclusive
+     *
+     * @return  a new {@code Path} object that is a subsequence of the name
+     *          elements in this {@code Path}
+     *
+     * @throws  IllegalArgumentException
+     *          if {@code beginIndex} is negative, or greater than or equal to
+     *          the number of elements. If {@code endIndex} is less than or
+     *          equal to {@code beginIndex}, or larger than the number of elements.
+     */
+    Path subpath(int beginIndex, int endIndex);
+
+    /**
+     * Tests if this path starts with the given path.
+     *
+     * <p> This path <em>starts</em> with the given path if this path's root
+     * component <em>starts</em> with the root component of the given path,
+     * and this path starts with the same name elements as the given path.
+     * If the given path has more name elements than this path then {@code false}
+     * is returned.
+     *
+     * <p> Whether or not the root component of this path starts with the root
+     * component of the given path is file system specific. If this path does
+     * not have a root component and the given path has a root component then
+     * this path does not start with the given path.
+     *
+     * <p> If the given path is associated with a different {@code FileSystem}
+     * to this path then {@code false} is returned.
+     *
+     * @param   other
+     *          the given path
+     *
+     * @return  {@code true} if this path starts with the given path; otherwise
+     *          {@code false}
+     */
+    boolean startsWith(Path other);
+
+    /**
+     * Tests if this path starts with a {@code Path}, constructed by converting
+     * the given path string, in exactly the manner specified by the {@link
+     * #startsWith(Path) startsWith(Path)} method. On UNIX for example, the path
+     * "{@code foo/bar}" starts with "{@code foo}" and "{@code foo/bar}". It
+     * does not start with "{@code f}" or "{@code fo}".
+     *
+     * @param   other
+     *          the given path string
+     *
+     * @return  {@code true} if this path starts with the given path; otherwise
+     *          {@code false}
+     *
+     * @throws  InvalidPathException
+     *          If the path string cannot be converted to a Path.
+     */
+    boolean startsWith(String other);
+
+    /**
+     * Tests if this path ends with the given path.
+     *
+     * <p> If the given path has <em>N</em> elements, and no root component,
+     * and this path has <em>N</em> or more elements, then this path ends with
+     * the given path if the last <em>N</em> elements of each path, starting at
+     * the element farthest from the root, are equal.
+     *
+     * <p> If the given path has a root component then this path ends with the
+     * given path if the root component of this path <em>ends with</em> the root
+     * component of the given path, and the corresponding elements of both paths
+     * are equal. Whether or not the root component of this path ends with the
+     * root component of the given path is file system specific. If this path
+     * does not have a root component and the given path has a root component
+     * then this path does not end with the given path.
+     *
+     * <p> If the given path is associated with a different {@code FileSystem}
+     * to this path then {@code false} is returned.
+     *
+     * @param   other
+     *          the given path
+     *
+     * @return  {@code true} if this path ends with the given path; otherwise
+     *          {@code false}
+     */
+    boolean endsWith(Path other);
+
+    /**
+     * Tests if this path ends with a {@code Path}, constructed by converting
+     * the given path string, in exactly the manner specified by the {@link
+     * #endsWith(Path) endsWith(Path)} method. On UNIX for example, the path
+     * "{@code foo/bar}" ends with "{@code foo/bar}" and "{@code bar}". It does
+     * not end with "{@code r}" or "{@code /bar}". Note that trailing separators
+     * are not taken into account, and so invoking this method on the {@code
+     * Path}"{@code foo/bar}" with the {@code String} "{@code bar/}" returns
+     * {@code true}.
+     *
+     * @param   other
+     *          the given path string
+     *
+     * @return  {@code true} if this path ends with the given path; otherwise
+     *          {@code false}
+     *
+     * @throws  InvalidPathException
+     *          If the path string cannot be converted to a Path.
+     */
+    boolean endsWith(String other);
+
+    /**
+     * Returns a path that is this path with redundant name elements eliminated.
+     *
+     * <p> The precise definition of this method is implementation dependent but
+     * in general it derives from this path, a path that does not contain
+     * <em>redundant</em> name elements. In many file systems, the "{@code .}"
+     * and "{@code ..}" are special names used to indicate the current directory
+     * and parent directory. In such file systems all occurrences of "{@code .}"
+     * are considered redundant. If a "{@code ..}" is preceded by a
+     * non-"{@code ..}" name then both names are considered redundant (the
+     * process to identify such names is repeated until it is no longer
+     * applicable).
+     *
+     * <p> This method does not access the file system; the path may not locate
+     * a file that exists. Eliminating "{@code ..}" and a preceding name from a
+     * path may result in the path that locates a different file than the original
+     * path. This can arise when the preceding name is a symbolic link.
+     *
+     * @return  the resulting path or this path if it does not contain
+     *          redundant name elements; an empty path is returned if this path
+     *          does have a root component and all name elements are redundant
+     *
+     * @see #getParent
+     * @see #toRealPath
+     */
+    Path normalize();
+
+    // -- resolution and relativization --
+
+    /**
+     * Resolve the given path against this path.
+     *
+     * <p> If the {@code other} parameter is an {@link #isAbsolute() absolute}
+     * path then this method trivially returns {@code other}. If {@code other}
+     * is an <i>empty path</i> then this method trivially returns this path.
+     * Otherwise this method considers this path to be a directory and resolves
+     * the given path against this path. In the simplest case, the given path
+     * does not have a {@link #getRoot root} component, in which case this method
+     * <em>joins</em> the given path to this path and returns a resulting path
+     * that {@link #endsWith ends} with the given path. Where the given path has
+     * a root component then resolution is highly implementation dependent and
+     * therefore unspecified.
+     *
+     * @param   other
+     *          the path to resolve against this path
+     *
+     * @return  the resulting path
+     *
+     * @see #relativize
+     */
+    Path resolve(Path other);
+
+    /**
+     * Converts a given path string to a {@code Path} and resolves it against
+     * this {@code Path} in exactly the manner specified by the {@link
+     * #resolve(Path) resolve} method. For example, suppose that the name
+     * separator is "{@code /}" and a path represents "{@code foo/bar}", then
+     * invoking this method with the path string "{@code gus}" will result in
+     * the {@code Path} "{@code foo/bar/gus}".
+     *
+     * @param   other
+     *          the path string to resolve against this path
+     *
+     * @return  the resulting path
+     *
+     * @throws  InvalidPathException
+     *          if the path string cannot be converted to a Path.
+     *
+     * @see FileSystem#getPath
+     */
+    Path resolve(String other);
+
+    /**
+     * Resolves the given path against this path's {@link #getParent parent}
+     * path. This is useful where a file name needs to be <i>replaced</i> with
+     * another file name. For example, suppose that the name separator is
+     * "{@code /}" and a path represents "{@code dir1/dir2/foo}", then invoking
+     * this method with the {@code Path} "{@code bar}" will result in the {@code
+     * Path} "{@code dir1/dir2/bar}". If this path does not have a parent path,
+     * or {@code other} is {@link #isAbsolute() absolute}, then this method
+     * returns {@code other}. If {@code other} is an empty path then this method
+     * returns this path's parent, or where this path doesn't have a parent, the
+     * empty path.
+     *
+     * @param   other
+     *          the path to resolve against this path's parent
+     *
+     * @return  the resulting path
+     *
+     * @see #resolve(Path)
+     */
+    Path resolveSibling(Path other);
+
+    /**
+     * Converts a given path string to a {@code Path} and resolves it against
+     * this path's {@link #getParent parent} path in exactly the manner
+     * specified by the {@link #resolveSibling(Path) resolveSibling} method.
+     *
+     * @param   other
+     *          the path string to resolve against this path's parent
+     *
+     * @return  the resulting path
+     *
+     * @throws  InvalidPathException
+     *          if the path string cannot be converted to a Path.
+     *
+     * @see FileSystem#getPath
+     */
+    Path resolveSibling(String other);
+
+    /**
+     * Constructs a relative path between this path and a given path.
+     *
+     * <p> Relativization is the inverse of {@link #resolve(Path) resolution}.
+     * This method attempts to construct a {@link #isAbsolute relative} path
+     * that when {@link #resolve(Path) resolved} against this path, yields a
+     * path that locates the same file as the given path. For example, on UNIX,
+     * if this path is {@code "/a/b"} and the given path is {@code "/a/b/c/d"}
+     * then the resulting relative path would be {@code "c/d"}. Where this
+     * path and the given path do not have a {@link #getRoot root} component,
+     * then a relative path can be constructed. A relative path cannot be
+     * constructed if only one of the paths have a root component. Where both
+     * paths have a root component then it is implementation dependent if a
+     * relative path can be constructed. If this path and the given path are
+     * {@link #equals equal} then an <i>empty path</i> is returned.
+     *
+     * <p> For any two {@link #normalize normalized} paths <i>p</i> and
+     * <i>q</i>, where <i>q</i> does not have a root component,
+     * <blockquote>
+     *   <i>p</i><tt>.relativize(</tt><i>p</i><tt>.resolve(</tt><i>q</i><tt>)).equals(</tt><i>q</i><tt>)</tt>
+     * </blockquote>
+     *
+     * <p> When symbolic links are supported, then whether the resulting path,
+     * when resolved against this path, yields a path that can be used to locate
+     * the {@link Files#isSameFile same} file as {@code other} is implementation
+     * dependent. For example, if this path is  {@code "/a/b"} and the given
+     * path is {@code "/a/x"} then the resulting relative path may be {@code
+     * "../x"}. If {@code "b"} is a symbolic link then is implementation
+     * dependent if {@code "a/b/../x"} would locate the same file as {@code "/a/x"}.
+     *
+     * @param   other
+     *          the path to relativize against this path
+     *
+     * @return  the resulting relative path, or an empty path if both paths are
+     *          equal
+     *
+     * @throws  IllegalArgumentException
+     *          if {@code other} is not a {@code Path} that can be relativized
+     *          against this path
+     */
+    Path relativize(Path other);
+
+    /**
+     * Returns a URI to represent this path.
+     *
+     * <p> This method constructs an absolute {@link URI} with a {@link
+     * URI#getScheme() scheme} equal to the URI scheme that identifies the
+     * provider. The exact form of the scheme specific part is highly provider
+     * dependent.
+     *
+     * <p> In the case of the default provider, the URI is hierarchical with
+     * a {@link URI#getPath() path} component that is absolute. The query and
+     * fragment components are undefined. Whether the authority component is
+     * defined or not is implementation dependent. There is no guarantee that
+     * the {@code URI} may be used to construct a {@link java.io.File java.io.File}.
+     * In particular, if this path represents a Universal Naming Convention (UNC)
+     * path, then the UNC server name may be encoded in the authority component
+     * of the resulting URI. In the case of the default provider, and the file
+     * exists, and it can be determined that the file is a directory, then the
+     * resulting {@code URI} will end with a slash.
+     *
+     * <p> The default provider provides a similar <em>round-trip</em> guarantee
+     * to the {@link java.io.File} class. For a given {@code Path} <i>p</i> it
+     * is guaranteed that
+     * <blockquote><tt>
+     * {@link Paths#get(URI) Paths.get}(</tt><i>p</i><tt>.toUri()).equals(</tt><i>p</i>
+     * <tt>.{@link #toAbsolutePath() toAbsolutePath}())</tt>
+     * </blockquote>
+     * so long as the original {@code Path}, the {@code URI}, and the new {@code
+     * Path} are all created in (possibly different invocations of) the same
+     * Java virtual machine. Whether other providers make any guarantees is
+     * provider specific and therefore unspecified.
+     *
+     * <p> When a file system is constructed to access the contents of a file
+     * as a file system then it is highly implementation specific if the returned
+     * URI represents the given path in the file system or it represents a
+     * <em>compound</em> URI that encodes the URI of the enclosing file system.
+     * A format for compound URIs is not defined in this release; such a scheme
+     * may be added in a future release.
+     *
+     * @return  the URI representing this path
+     *
+     * @throws  java.io.IOError
+     *          if an I/O error occurs obtaining the absolute path, or where a
+     *          file system is constructed to access the contents of a file as
+     *          a file system, and the URI of the enclosing file system cannot be
+     *          obtained
+     *
+     * @throws  SecurityException
+     *          In the case of the default provider, and a security manager
+     *          is installed, the {@link #toAbsolutePath toAbsolutePath} method
+     *          throws a security exception.
+     */
+    URI toUri();
+
+    /**
+     * Returns a {@code Path} object representing the absolute path of this
+     * path.
+     *
+     * <p> If this path is already {@link Path#isAbsolute absolute} then this
+     * method simply returns this path. Otherwise, this method resolves the path
+     * in an implementation dependent manner, typically by resolving the path
+     * against a file system default directory. Depending on the implementation,
+     * this method may throw an I/O error if the file system is not accessible.
+     *
+     * @return  a {@code Path} object representing the absolute path
+     *
+     * @throws  java.io.IOError
+     *          if an I/O error occurs
+     * @throws  SecurityException
+     *          In the case of the default provider, a security manager
+     *          is installed, and this path is not absolute, then the security
+     *          manager's {@link SecurityManager#checkPropertyAccess(String)
+     *          checkPropertyAccess} method is invoked to check access to the
+     *          system property {@code user.dir}
+     */
+    Path toAbsolutePath();
+
+    /**
+     * Returns the <em>real</em> path of an existing file.
+     *
+     * <p> The precise definition of this method is implementation dependent but
+     * in general it derives from this path, an {@link #isAbsolute absolute}
+     * path that locates the {@link Files#isSameFile same} file as this path, but
+     * with name elements that represent the actual name of the directories
+     * and the file. For example, where filename comparisons on a file system
+     * are case insensitive then the name elements represent the names in their
+     * actual case. Additionally, the resulting path has redundant name
+     * elements removed.
+     *
+     * <p> If this path is relative then its absolute path is first obtained,
+     * as if by invoking the {@link #toAbsolutePath toAbsolutePath} method.
+     *
+     * <p> The {@code options} array may be used to indicate how symbolic links
+     * are handled. By default, symbolic links are resolved to their final
+     * target. If the option {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} is
+     * present then this method does not resolve symbolic links.
+     *
+     * Some implementations allow special names such as "{@code ..}" to refer to
+     * the parent directory. When deriving the <em>real path</em>, and a
+     * "{@code ..}" (or equivalent) is preceded by a non-"{@code ..}" name then
+     * an implementation will typically cause both names to be removed. When
+     * not resolving symbolic links and the preceding name is a symbolic link
+     * then the names are only removed if it guaranteed that the resulting path
+     * will locate the same file as this path.
+     *
+     * @param   options
+     *          options indicating how symbolic links are handled
+     *
+     * @return  an absolute path represent the <em>real</em> path of the file
+     *          located by this object
+     *
+     * @throws  IOException
+     *          if the file does not exist or an I/O error occurs
+     * @throws  SecurityException
+     *          In the case of the default provider, and a security manager
+     *          is installed, its {@link SecurityManager#checkRead(String) checkRead}
+     *          method is invoked to check read access to the file, and where
+     *          this path is not absolute, its {@link SecurityManager#checkPropertyAccess(String)
+     *          checkPropertyAccess} method is invoked to check access to the
+     *          system property {@code user.dir}
+     */
+    Path toRealPath(LinkOption... options) throws IOException;
+
+    /**
+     * Returns a {@link File} object representing this path. Where this {@code
+     * Path} is associated with the default provider, then this method is
+     * equivalent to returning a {@code File} object constructed with the
+     * {@code String} representation of this path.
+     *
+     * <p> If this path was created by invoking the {@code File} {@link
+     * File#toPath toPath} method then there is no guarantee that the {@code
+     * File} object returned by this method is {@link #equals equal} to the
+     * original {@code File}.
+     *
+     * @return  a {@code File} object representing this path
+     *
+     * @throws  UnsupportedOperationException
+     *          if this {@code Path} is not associated with the default provider
+     */
+    File toFile();
+
+    // -- watchable --
+
+    /**
+     * Registers the file located by this path with a watch service.
+     *
+     * <p> In this release, this path locates a directory that exists. The
+     * directory is registered with the watch service so that entries in the
+     * directory can be watched. The {@code events} parameter is the events to
+     * register and may contain the following events:
+     * <ul>
+     *   <li>{@link StandardWatchEventKinds#ENTRY_CREATE ENTRY_CREATE} -
+     *       entry created or moved into the directory</li>
+     *   <li>{@link StandardWatchEventKinds#ENTRY_DELETE ENTRY_DELETE} -
+     *        entry deleted or moved out of the directory</li>
+     *   <li>{@link StandardWatchEventKinds#ENTRY_MODIFY ENTRY_MODIFY} -
+     *        entry in directory was modified</li>
+     * </ul>
+     *
+     * <p> The {@link WatchEvent#context context} for these events is the
+     * relative path between the directory located by this path, and the path
+     * that locates the directory entry that is created, deleted, or modified.
+     *
+     * <p> The set of events may include additional implementation specific
+     * event that are not defined by the enum {@link StandardWatchEventKinds}
+     *
+     * <p> The {@code modifiers} parameter specifies <em>modifiers</em> that
+     * qualify how the directory is registered. This release does not define any
+     * <em>standard</em> modifiers. It may contain implementation specific
+     * modifiers.
+     *
+     * <p> Where a file is registered with a watch service by means of a symbolic
+     * link then it is implementation specific if the watch continues to depend
+     * on the existence of the symbolic link after it is registered.
+     *
+     * @param   watcher
+     *          the watch service to which this object is to be registered
+     * @param   events
+     *          the events for which this object should be registered
+     * @param   modifiers
+     *          the modifiers, if any, that modify how the object is registered
+     *
+     * @return  a key representing the registration of this object with the
+     *          given watch service
+     *
+     * @throws  UnsupportedOperationException
+     *          if unsupported events or modifiers are specified
+     * @throws  IllegalArgumentException
+     *          if an invalid combination of events or modifiers is specified
+     * @throws  ClosedWatchServiceException
+     *          if the watch service is closed
+     * @throws  NotDirectoryException
+     *          if the file is registered to watch the entries in a directory
+     *          and the file is not a directory  <i>(optional specific exception)</i>
+     * @throws  IOException
+     *          if an I/O error occurs
+     * @throws  SecurityException
+     *          In the case of the default provider, and a security manager is
+     *          installed, the {@link SecurityManager#checkRead(String) checkRead}
+     *          method is invoked to check read access to the file.
+     */
+    @Override
+    WatchKey register(WatchService watcher,
+                      WatchEvent.Kind<?>[] events,
+                      WatchEvent.Modifier... modifiers)
+        throws IOException;
+
+    /**
+     * Registers the file located by this path with a watch service.
+     *
+     * <p> An invocation of this method behaves in exactly the same way as the
+     * invocation
+     * <pre>
+     *     watchable.{@link #register(WatchService,WatchEvent.Kind[],WatchEvent.Modifier[]) register}(watcher, events, new WatchEvent.Modifier[0]);
+     * </pre>
+     *
+     * <p> <b>Usage Example:</b>
+     * Suppose we wish to register a directory for entry create, delete, and modify
+     * events:
+     * <pre>
+     *     Path dir = ...
+     *     WatchService watcher = ...
+     *
+     *     WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);
+     * </pre>
+     * @param   watcher
+     *          The watch service to which this object is to be registered
+     * @param   events
+     *          The events for which this object should be registered
+     *
+     * @return  A key representing the registration of this object with the
+     *          given watch service
+     *
+     * @throws  UnsupportedOperationException
+     *          If unsupported events are specified
+     * @throws  IllegalArgumentException
+     *          If an invalid combination of events is specified
+     * @throws  ClosedWatchServiceException
+     *          If the watch service is closed
+     * @throws  NotDirectoryException
+     *          If the file is registered to watch the entries in a directory
+     *          and the file is not a directory  <i>(optional specific exception)</i>
+     * @throws  IOException
+     *          If an I/O error occurs
+     * @throws  SecurityException
+     *          In the case of the default provider, and a security manager is
+     *          installed, the {@link SecurityManager#checkRead(String) checkRead}
+     *          method is invoked to check read access to the file.
+     */
+    @Override
+    WatchKey register(WatchService watcher,
+                      WatchEvent.Kind<?>... events)
+        throws IOException;
+
+    // -- Iterable --
+
+    /**
+     * Returns an iterator over the name elements of this path.
+     *
+     * <p> The first element returned by the iterator represents the name
+     * element that is closest to the root in the directory hierarchy, the
+     * second element is the next closest, and so on. The last element returned
+     * is the name of the file or directory denoted by this path. The {@link
+     * #getRoot root} component, if present, is not returned by the iterator.
+     *
+     * @return  an iterator over the name elements of this path.
+     */
+    @Override
+    Iterator<Path> iterator();
+
+    // -- compareTo/equals/hashCode --
+
+    /**
+     * Compares two abstract paths lexicographically. The ordering defined by
+     * this method is provider specific, and in the case of the default
+     * provider, platform specific. This method does not access the file system
+     * and neither file is required to exist.
+     *
+     * <p> This method may not be used to compare paths that are associated
+     * with different file system providers.
+     *
+     * @param   other  the path compared to this path.
+     *
+     * @return  zero if the argument is {@link #equals equal} to this path, a
+     *          value less than zero if this path is lexicographically less than
+     *          the argument, or a value greater than zero if this path is
+     *          lexicographically greater than the argument
+     *
+     * @throws  ClassCastException
+     *          if the paths are associated with different providers
+     */
+    @Override
+    int compareTo(Path other);
+
+    /**
+     * Tests this path for equality with the given object.
+     *
+     * <p> If the given object is not a Path, or is a Path associated with a
+     * different {@code FileSystem}, then this method returns {@code false}.
+     *
+     * <p> Whether or not two path are equal depends on the file system
+     * implementation. In some cases the paths are compared without regard
+     * to case, and others are case sensitive. This method does not access the
+     * file system and the file is not required to exist. Where required, the
+     * {@link Files#isSameFile isSameFile} method may be used to check if two
+     * paths locate the same file.
+     *
+     * <p> This method satisfies the general contract of the {@link
+     * java.lang.Object#equals(Object) Object.equals} method. </p>
+     *
+     * @param   other
+     *          the object to which this object is to be compared
+     *
+     * @return  {@code true} if, and only if, the given object is a {@code Path}
+     *          that is identical to this {@code Path}
+     */
+    boolean equals(Object other);
+
+    /**
+     * Computes a hash code for this path.
+     *
+     * <p> The hash code is based upon the components of the path, and
+     * satisfies the general contract of the {@link Object#hashCode
+     * Object.hashCode} method.
+     *
+     * @return  the hash-code value for this path
+     */
+    int hashCode();
+
+    /**
+     * Returns the string representation of this path.
+     *
+     * <p> If this path was created by converting a path string using the
+     * {@link FileSystem#getPath getPath} method then the path string returned
+     * by this method may differ from the original String used to create the path.
+     *
+     * <p> The returned path string uses the default name {@link
+     * FileSystem#getSeparator separator} to separate names in the path.
+     *
+     * @return  the string representation of this path
+     */
+    String toString();
+}
diff --git a/ojluni/src/main/java/java/io/Console.java b/ojluni/src/main/java/java/io/Console.java
index 5a21ff52904..f6a46025bf5 100644
--- a/ojluni/src/main/java/java/io/Console.java
+++ b/ojluni/src/main/java/java/io/Console.java
@@ -336,8 +336,17 @@ public final class Console implements Flushable
                         else
                             ioe.addSuppressed(x);
                     }
-                    if (ioe != null)
+                    if (ioe != null) {
+                        Arrays.fill(passwd, ' ');
+                        try {
+                            if (reader instanceof LineReader lr) {
+                                lr.zeroOut();
+                            }
+                        } catch (IOException x) {
+                            // ignore
+                        }
                         throw ioe;
+                    }
                 }
                 pw.println();
             }
@@ -450,6 +459,9 @@ public final class Console implements Flushable
             System.arraycopy(rcb, 0, b, 0, len);
             if (zeroOut) {
                 Arrays.fill(rcb, 0, len, ' ');
+                if (reader instanceof LineReader lr) {
+                    lr.zeroOut();
+                }
             }
         }
         return b;
@@ -474,6 +486,11 @@ public final class Console implements Flushable
             nextChar = nChars = 0;
             leftoverLF = false;
         }
+        public void zeroOut() throws IOException {
+            if (in instanceof StreamDecoder sd) {
+                sd.fillZeroToPosition();
+            }
+        }
         public void close () {}
         public boolean ready() throws IOException {
             //in.ready synchronizes on readLock already
diff --git a/ojluni/src/main/java/java/io/FileSystem.java b/ojluni/src/main/java/java/io/FileSystem.java
index 584c085f698..5cda5fe136c 100644
--- a/ojluni/src/main/java/java/io/FileSystem.java
+++ b/ojluni/src/main/java/java/io/FileSystem.java
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2014 The Android Open Source Project
- * Copyright (c) 1998, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -88,6 +88,11 @@ abstract class FileSystem {
      */
     public abstract boolean isAbsolute(File f);
 
+    /**
+     * Tell whether the given abstract pathname is invalid.
+     */
+    public abstract boolean isInvalid(File f);
+
     /**
      * Resolve the given abstract pathname into absolute form.  Invoked by the
      * getAbsolutePath and getCanonicalPath methods in the File class.
diff --git a/ojluni/src/main/java/java/io/UnixFileSystem.java b/ojluni/src/main/java/java/io/UnixFileSystem.java
index 32840973328..2f9121c4df9 100644
--- a/ojluni/src/main/java/java/io/UnixFileSystem.java
+++ b/ojluni/src/main/java/java/io/UnixFileSystem.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -166,6 +166,11 @@ class UnixFileSystem extends FileSystem {
         return (f.getPrefixLength() != 0);
     }
 
+    @Override
+    public boolean isInvalid(File f) {
+        return f.getPath().indexOf('\u0000') < 0 ? false : true;
+    }
+
     public String resolve(File f) {
         if (isAbsolute(f)) return f.getPath();
         SecurityManager sm = System.getSecurityManager();
diff --git a/ojluni/src/main/java/java/lang/Class.java b/ojluni/src/main/java/java/lang/Class.java
index 2b263dc7fa5..c731f1b2b40 100644
--- a/ojluni/src/main/java/java/lang/Class.java
+++ b/ojluni/src/main/java/java/lang/Class.java
@@ -316,12 +316,6 @@ public final class Class<T> implements java.io.Serializable,
     /** State of class initialization */
     private transient int status;
 
-    /** Offset of the first virtual method copied from an interface in the methods array. */
-    private transient short copiedMethodsOffset;
-
-    /** Offset of the first virtual method defined in this class in the methods array. */
-    private transient short virtualMethodsOffset;
-
     /*
      * Private constructor. Only the Java Virtual Machine creates Class objects.
      * This constructor is not used and prevents the default constructor being
@@ -4069,12 +4063,13 @@ public final class Class<T> implements java.io.Serializable,
     // Fetches the factory for reflective objects
     @SuppressWarnings("removal")
     private static ReflectionFactory getReflectionFactory() {
-        if (reflectionFactory == null) {
-            reflectionFactory =
-                java.security.AccessController.doPrivileged
-                    (new ReflectionFactory.GetReflectionFactoryAction());
+        var factory = reflectionFactory;
+        if (factory != null) {
+            return factory;
         }
-        return reflectionFactory;
+        return reflectionFactory =
+                java.security.AccessController.doPrivileged
+                        (new ReflectionFactory.GetReflectionFactoryAction());
     }
     private static ReflectionFactory reflectionFactory;
     */
@@ -4903,10 +4898,8 @@ public final class Class<T> implements java.io.Serializable,
      * @see MethodHandles.Lookup#defineHiddenClass
      * @hide
      */
-    // Android-changed: Android doesn't support hidden classes yet.
-    // public native boolean isHidden();
     @IntrinsicCandidate
-    // Android-changed: Android has not implemented the hidden class feature yet.
+    // Android-changed: Android doesn't support hidden classes yet.
     // public native boolean isHidden();
     public boolean isHidden() {
         return false;
diff --git a/ojluni/src/main/java/java/lang/ClassLoader.java b/ojluni/src/main/java/java/lang/ClassLoader.java
index 685328925f4..40fea68ee78 100644
--- a/ojluni/src/main/java/java/lang/ClassLoader.java
+++ b/ojluni/src/main/java/java/lang/ClassLoader.java
@@ -455,6 +455,11 @@ public abstract class ClassLoader {
         }
         return nid;
     }
+
+    // Returns nameAndId string for exception message printing
+    String nameAndId() {
+        return nameAndId;
+    }
     */
 
     /**
diff --git a/ojluni/src/main/java/java/lang/InheritableThreadLocal.java b/ojluni/src/main/java/java/lang/InheritableThreadLocal.java
index 23f395c7f51..3fdd49b8004 100644
--- a/ojluni/src/main/java/java/lang/InheritableThreadLocal.java
+++ b/ojluni/src/main/java/java/lang/InheritableThreadLocal.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,7 +24,6 @@
  */
 
 package java.lang;
-import java.lang.ref.*;
 
 /**
  * This class extends {@code ThreadLocal} to provide inheritance of values
@@ -44,13 +43,21 @@ import java.lang.ref.*;
  * Thread#Thread(ThreadGroup,Runnable,String,long,boolean) thread}, it is
  * possible to <i>opt out</i> of receiving initial values for inheritable
  * thread-local variables.
+ * @param <T> the type of the inheritable thread local's value
  *
  * @author  Josh Bloch and Doug Lea
  * @see     ThreadLocal
  * @since   1.2
  */
+// Android-changed: TODO(b/346542404): Revert this change when Thread.Builder is exposed as an API.
+// @see Thread.Builder#inheritInheritableThreadLocals(boolean)
 
 public class InheritableThreadLocal<T> extends ThreadLocal<T> {
+    /**
+     * Creates an inheritable thread local variable.
+     */
+    public InheritableThreadLocal() {}
+
     /**
      * Computes the child's initial value for this inheritable thread-local
      * variable as a function of the parent's value at the time the child
@@ -72,8 +79,9 @@ public class InheritableThreadLocal<T> extends ThreadLocal<T> {
      *
      * @param t the current thread
      */
+    @Override
     ThreadLocalMap getMap(Thread t) {
-       return t.inheritableThreadLocals;
+        return t.inheritableThreadLocals;
     }
 
     /**
@@ -82,6 +90,7 @@ public class InheritableThreadLocal<T> extends ThreadLocal<T> {
      * @param t the current thread
      * @param firstValue value for the initial entry of the table.
      */
+    @Override
     void createMap(Thread t, T firstValue) {
         t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue);
     }
diff --git a/ojluni/src/main/java/java/lang/JavaLangAccess.java b/ojluni/src/main/java/java/lang/JavaLangAccess.java
index e1b87683592..e9612f0b458 100644
--- a/ojluni/src/main/java/java/lang/JavaLangAccess.java
+++ b/ojluni/src/main/java/java/lang/JavaLangAccess.java
@@ -25,6 +25,13 @@
 
 package java.lang;
 
+import java.nio.charset.CharacterCodingException;
+import java.nio.charset.Charset;
+
+import jdk.internal.misc.CarrierThreadLocal;
+import jdk.internal.vm.StackableScope;
+import jdk.internal.vm.ThreadContainer;
+
 // Android-changed: Make JavaLangAccess a final class. http://b/399374716
 // public interface JavaLangAccess {
 public final class JavaLangAccess {
@@ -286,26 +293,25 @@ public final class JavaLangAccess {
      * Count the number of leading positive bytes in the range.
      * /
     int countPositives(byte[] ba, int off, int len);
+    */
 
     /**
      * Constructs a new {@code String} by decoding the specified subarray of
      * bytes using the specified {@linkplain java.nio.charset.Charset charset}.
      *
-     * The caller of this method shall relinquish and transfer the ownership of
-     * the byte array to the callee since the later will not make a copy.
-     *
      * @param bytes the byte array source
      * @param cs the Charset
      * @return the newly created string
      * @throws CharacterCodingException for malformed or unmappable bytes
-     * /
-    String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException;
+     */
+    public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException {
+        return String.newStringNoRepl(bytes, cs);
+    }
 
     /**
      * Encode the given string into a sequence of bytes using the specified Charset.
      *
-     * This method avoids copying the String's internal representation if the input
-     * is ASCII.
+     * Android note: It returns a copy of bytes, not the internal representation.
      *
      * This method throws CharacterCodingException instead of replacing when
      * malformed input or unmappable characters are encountered.
@@ -314,9 +320,12 @@ public final class JavaLangAccess {
      * @param cs the charset
      * @return the encoded bytes
      * @throws CharacterCodingException for malformed input or unmappable characters
-     * /
-    byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException;
+     */
+    public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {
+        return String.getBytesNoRepl(s, cs);
+    }
 
+    /*
     /**
      * Returns a new string by decoding from the given utf8 bytes array.
      *
@@ -445,63 +454,86 @@ public final class JavaLangAccess {
      * @param statusCode the status code
      * /
     void exit(int statusCode);
+    */
 
     /**
      * Returns an array of all platform threads.
-     * /
-    Thread[] getAllThreads();
+     */
+    public Thread[] getAllThreads() {
+        return Thread.getAllThreads();
+    }
 
     /**
      * Returns the ThreadContainer for a thread, may be null.
-     * /
-    ThreadContainer threadContainer(Thread thread);
+     */
+    public ThreadContainer threadContainer(Thread thread) {
+        return thread.threadContainer();
+    }
 
     /**
      * Starts a thread in the given ThreadContainer.
-     * /
-    void start(Thread thread, ThreadContainer container);
+     */
+    public void start(Thread thread, ThreadContainer container) {
+        thread.start(container);
+    }
 
     /**
      * Returns the top of the given thread's stackable scope stack.
-     * /
-    StackableScope headStackableScope(Thread thread);
+     */
+    public StackableScope headStackableScope(Thread thread) {
+        return thread.headStackableScopes();
+    }
 
     /**
      * Sets the top of the current thread's stackable scope stack.
-     * /
-    void setHeadStackableScope(StackableScope scope);
+     */
+    public void setHeadStackableScope(StackableScope scope) {
+        Thread.setHeadStackableScope(scope);
+    }
 
     /**
      * Returns the Thread object for the current platform thread. If the
      * current thread is a virtual thread then this method returns the carrier.
-     * /
-    Thread currentCarrierThread();
+     */
+    public Thread currentCarrierThread() {
+        return Thread.currentCarrierThread();
+    }
 
+    /*
     /**
      * Executes the given value returning task on the current carrier thread.
      * /
     <V> V executeOnCarrierThread(Callable<V> task) throws Exception;
+    */
 
     /**
      * Returns the value of the current carrier thread's copy of a thread-local.
-     * /
-    <T> T getCarrierThreadLocal(CarrierThreadLocal<T> local);
+     */
+    public <T> T getCarrierThreadLocal(CarrierThreadLocal<T> local) {
+        return ((ThreadLocal<T>)local).getCarrierThreadLocal();
+    }
 
     /**
      * Sets the value of the current carrier thread's copy of a thread-local.
-     * /
-    <T> void setCarrierThreadLocal(CarrierThreadLocal<T> local, T value);
+     */
+    public <T> void setCarrierThreadLocal(CarrierThreadLocal<T> local, T value) {
+        ((ThreadLocal<T>)local).setCarrierThreadLocal(value);
+    }
 
     /**
      * Removes the value of the current carrier thread's copy of a thread-local.
-     * /
-    void removeCarrierThreadLocal(CarrierThreadLocal<?> local);
+     */
+    public void removeCarrierThreadLocal(CarrierThreadLocal<?> local) {
+        ((ThreadLocal<?>)local).removeCarrierThreadLocal();
+    }
 
     /**
      * Returns {@code true} if there is a value in the current carrier thread's copy of
      * thread-local, even if that values is {@code null}.
-     * /
-    boolean isCarrierThreadLocalPresent(CarrierThreadLocal<?> local);
+     */
+    public boolean isCarrierThreadLocalPresent(CarrierThreadLocal<?> local) {
+        return ((ThreadLocal<?>)local).isCarrierThreadLocalPresent();
+    }
 
     /**
      * Returns the current thread's scoped values cache
diff --git a/ojluni/src/main/java/java/lang/LiveStackFrame.java b/ojluni/src/main/java/java/lang/LiveStackFrame.java
index 7507bbc8877..77a02d083c8 100644
--- a/ojluni/src/main/java/java/lang/LiveStackFrame.java
+++ b/ojluni/src/main/java/java/lang/LiveStackFrame.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,8 @@ package java.lang;
 import java.lang.StackWalker.StackFrame;
 import java.util.EnumSet;
 import java.util.Set;
+import jdk.internal.vm.Continuation;
+import jdk.internal.vm.ContinuationScope;
 
 import static java.lang.StackWalker.ExtendedOption.LOCALS_AND_OPERANDS;
 
@@ -177,11 +179,74 @@ interface LiveStackFrame extends StackFrame {
      * and it denies access to {@code RuntimePermission("getStackWalkerWithClassReference")}.
      */
     public static StackWalker getStackWalker(Set<StackWalker.Option> options) {
+        return getStackWalker(options, null);
+    }
+
+    /**
+     * Gets a {@code StackWalker} instance with the given options specifying
+     * the stack frame information it can access, and which will traverse at most
+     * the given {@code maxDepth} number of stack frames.  If no option is
+     * specified, this {@code StackWalker} obtains the method name and
+     * the class name with all
+     * {@linkplain StackWalker.Option#SHOW_HIDDEN_FRAMES hidden frames} skipped.
+     * The returned {@code StackWalker} can get locals and operands.
+     *
+     * @param options stack walk {@link StackWalker.Option options}
+     * @param contScope the continuation scope up to which (inclusive) to walk the stack
+     *
+     * @throws SecurityException if the security manager is present and
+     * it denies access to {@code RuntimePermission("liveStackFrames")}; or
+     * or if the given {@code options} contains
+     * {@link StackWalker.Option#RETAIN_CLASS_REFERENCE Option.RETAIN_CLASS_REFERENCE}
+     * and it denies access to {@code RuntimePermission("getStackWalkerWithClassReference")}.
+     */
+    public static StackWalker getStackWalker(Set<StackWalker.Option> options, ContinuationScope contScope) {
+        @SuppressWarnings("removal")
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null) {
+            sm.checkPermission(new RuntimePermission("liveStackFrames"));
+        }
+        return StackWalker.newInstance(options, LOCALS_AND_OPERANDS, contScope);
+    }
+
+    /**
+     * Gets {@code StackWalker} of the given unmounted continuation, that can get locals and operands.
+     *
+     * @param continuation the continuation to walk
+     *
+     * @throws SecurityException if the security manager is present and
+     * denies access to {@code RuntimePermission("liveStackFrames")}
+     */
+    public static StackWalker getStackWalker(Continuation continuation) {
+        return getStackWalker(EnumSet.noneOf(StackWalker.Option.class), continuation.getScope(), continuation);
+    }
+
+    /**
+     * Gets a {@code StackWalker} instance with the given options specifying
+     * the stack frame information it can access, and which will traverse at most
+     * the given {@code maxDepth} number of stack frames.  If no option is
+     * specified, this {@code StackWalker} obtains the method name and
+     * the class name with all
+     * {@linkplain StackWalker.Option#SHOW_HIDDEN_FRAMES hidden frames} skipped.
+     * The returned {@code StackWalker} can get locals and operands.
+     *
+     * @param options stack walk {@link StackWalker.Option options}
+     * @param continuation the continuation to walk
+     *
+     * @throws SecurityException if the security manager is present and
+     * it denies access to {@code RuntimePermission("liveStackFrames")}; or
+     * or if the given {@code options} contains
+     * {@link StackWalker.Option#RETAIN_CLASS_REFERENCE Option.RETAIN_CLASS_REFERENCE}
+     * and it denies access to {@code RuntimePermission("getStackWalkerWithClassReference")}.
+     */
+    public static StackWalker getStackWalker(Set<StackWalker.Option> options,
+                                             ContinuationScope contScope,
+                                             Continuation continuation) {
         @SuppressWarnings("removal")
         SecurityManager sm = System.getSecurityManager();
         if (sm != null) {
             sm.checkPermission(new RuntimePermission("liveStackFrames"));
         }
-        return StackWalker.newInstance(options, LOCALS_AND_OPERANDS);
+        return StackWalker.newInstance(options, LOCALS_AND_OPERANDS, contScope, continuation);
     }
 }
diff --git a/ojluni/src/main/java/java/lang/Runtime.java b/ojluni/src/main/java/java/lang/Runtime.java
index 90a06568d8b..01faed6d7bf 100644
--- a/ojluni/src/main/java/java/lang/Runtime.java
+++ b/ojluni/src/main/java/java/lang/Runtime.java
@@ -1,6 +1,7 @@
 /*
  * Copyright (C) 2014 The Android Open Source Project
  * Copyright (c) 1995, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, Azul Systems, Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -523,7 +524,7 @@ public class Runtime {
      */
     public Process exec(String command, String[] envp, File dir)
         throws IOException {
-        if (command.length() == 0)
+        if (command.isEmpty())
             throw new IllegalArgumentException("Empty command");
 
         StringTokenizer st = new StringTokenizer(command);
@@ -919,6 +920,12 @@ public class Runtime {
 
     // BEGIN Android-changed: Different implementation of load0(Class, String).
     synchronized void load0(Class<?> fromClass, String filename) {
+        /*
+        SecurityManager security = System.getSecurityManager();
+        if (security != null) {
+            security.checkLink(filename);
+        }
+        */
         File file = new File(filename);
         if (!(file.isAbsolute())) {
             throw new UnsatisfiedLinkError(
@@ -995,14 +1002,14 @@ public class Runtime {
 
     // BEGIN Android-changed: Different implementation of loadLibrary0(Class, String).
     /*
-    synchronized void loadLibrary0(Class<?> fromClass, String libname) {
+    void loadLibrary0(Class<?> fromClass, String libname) {
         SecurityManager security = System.getSecurityManager();
         if (security != null) {
             security.checkLink(libname);
         }
         if (libname.indexOf((int)File.separatorChar) != -1) {
             throw new UnsatisfiedLinkError(
-    "Directory separator should not appear in library name: " + libname);
+                "Directory separator should not appear in library name: " + libname);
         }
         ClassLoader.loadLibrary(fromClass, libname, false);
     }
diff --git a/ojluni/src/main/java/java/lang/StackFrameInfo.java b/ojluni/src/main/java/java/lang/StackFrameInfo.java
index 743c21741c5..755aef917dd 100644
--- a/ojluni/src/main/java/java/lang/StackFrameInfo.java
+++ b/ojluni/src/main/java/java/lang/StackFrameInfo.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,6 +24,8 @@
  */
 package java.lang;
 
+import jdk.internal.access.SharedSecrets;
+import jdk.internal.vm.ContinuationScope;
 
 import java.lang.StackWalker.StackFrame;
 import java.lang.invoke.MethodType;
@@ -36,8 +38,9 @@ class StackFrameInfo implements StackFrame {
 
     private final boolean retainClassRef;
     // Android-removed: Unused internal fields.
-    // private final Object memberName;    // MemberName initialized by VM
-    private int bci;                    // initialized by VM to >= 0
+    // private Object memberName;    // MemberName initialized by VM
+    private int bci;              // initialized by VM to >= 0
+    // private ContinuationScope contScope;
     private volatile StackTraceElement ste;
 
     // Android-added: Add Android-specific internal fields.
@@ -145,6 +148,11 @@ class StackFrameInfo implements StackFrame {
         return lineNumber == -2;
     }
 
+    // Android-removed: Dead code or only used by upstream JVM.
+    // private String getContinuationScopeName() {
+    //     return contScope != null ? contScope.getName() : null;
+    // }
+
     @Override
     public String toString() {
         return toStackTraceElement().toString();
diff --git a/ojluni/src/main/java/java/lang/StackStreamFactory.java b/ojluni/src/main/java/java/lang/StackStreamFactory.java
index 3423101d8c4..aba09333878 100644
--- a/ojluni/src/main/java/java/lang/StackStreamFactory.java
+++ b/ojluni/src/main/java/java/lang/StackStreamFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -40,6 +40,8 @@ import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
+import jdk.internal.vm.Continuation;
+import jdk.internal.vm.ContinuationScope;
 import libcore.util.NonNull;
 import sun.security.action.GetPropertyAction;
 
@@ -118,7 +120,7 @@ final class StackStreamFactory {
      *            For example, StackFrameInfo for StackWalker::walk or
      *            Class<?> for StackWalker::getCallerClass
      */
-    static abstract class AbstractStackWalker<R, T> {
+    abstract static class AbstractStackWalker<R, T> {
         protected final StackWalker walker;
         protected final Thread thread;
         protected final int maxDepth;
@@ -128,6 +130,8 @@ final class StackStreamFactory {
         // Android-changed: Android uses a different anchor.
         // protected long anchor;
         protected Object anchor;
+        protected final ContinuationScope contScope;
+        protected Continuation continuation;
 
         // buffers to fill in stack frame information
         protected AbstractStackWalker(StackWalker walker, int mode) {
@@ -139,6 +143,14 @@ final class StackStreamFactory {
             this.walker = walker;
             this.maxDepth = maxDepth;
             this.depth = 0;
+            ContinuationScope scope = walker.getContScope();
+            if (scope == null && thread.isVirtual()) {
+                this.contScope = VirtualThread.continuationScope();
+                this.continuation = null;
+            } else {
+                this.contScope = scope;
+                this.continuation = walker.getContinuation();
+            }
         }
 
         private int toStackWalkMode(StackWalker walker, int mode) {
@@ -244,6 +256,12 @@ final class StackStreamFactory {
          */
         final R walk() {
             checkState(NEW);
+            return (continuation != null)
+                ? Continuation.wrapWalk(continuation, contScope, this::walkHelper)
+                : walkHelper();
+        }
+
+        private final R walkHelper() {
             try {
                 // VM will need to stabilize the stack before walking.  It will invoke
                 // the AbstractStackWalker::doStackWalk method once it fetches the first batch.
@@ -321,7 +339,10 @@ final class StackStreamFactory {
          */
         private int getNextBatch() {
             int nextBatchSize = Math.min(maxDepth - depth, getNextBatchSize());
-            if (!frameBuffer.isActive() || nextBatchSize <= 0) {
+
+            if (!frameBuffer.isActive()
+                    || (nextBatchSize <= 0)
+                    || (frameBuffer.isAtBottom() && !hasMoreContinuations())) {
                 if (isDebug) {
                     System.out.format("  more stack walk done%n");
                 }
@@ -329,7 +350,26 @@ final class StackStreamFactory {
                 return 0;
             }
 
-            return fetchStackFrames(nextBatchSize);
+            if (frameBuffer.isAtBottom() && hasMoreContinuations()) {
+                setContinuation(continuation.getParent());
+            }
+
+            int numFrames = fetchStackFrames(nextBatchSize);
+            if (numFrames == 0 && !hasMoreContinuations()) {
+                frameBuffer.freeze(); // done stack walking
+            }
+            return numFrames;
+        }
+
+        private boolean hasMoreContinuations() {
+            return (continuation != null)
+                    && (continuation.getScope() != contScope)
+                    && (continuation.getParent() != null);
+        }
+
+        private void setContinuation(Continuation cont) {
+            this.continuation = cont;
+            setContinuation(anchor, frameBuffer.frames(), cont);
         }
 
         /*
@@ -378,6 +418,7 @@ final class StackStreamFactory {
             initFrameBuffer();
 
             return callStackWalk(mode, 0,
+                                 contScope, continuation,
                                  frameBuffer.curBatchFrameCount(),
                                  frameBuffer.startIndex(),
                                  frameBuffer.frames());
@@ -386,8 +427,8 @@ final class StackStreamFactory {
         /*
          * Fetches stack frames.
          *
-         * @params batchSize number of elements of the frame  buffers for this batch
-         * @returns number of frames fetched in this batch
+         * @param batchSize number of elements of the frame buffers for this batch
+         * @return number of frames fetched in this batch
          */
         private int fetchStackFrames(int batchSize) {
             int startIndex = frameBuffer.startIndex();
@@ -400,10 +441,10 @@ final class StackStreamFactory {
                 System.out.format("  more stack walk requesting %d got %d to %d frames%n",
                                   batchSize, frameBuffer.startIndex(), endIndex);
             }
+
             int numFrames = endIndex - startIndex;
-            if (numFrames == 0) {
-                frameBuffer.freeze(); // done stack walking
-            } else {
+
+            if (numFrames > 0) {
                 frameBuffer.setBatch(depth, startIndex, endIndex);
             }
             return numFrames;
@@ -415,6 +456,8 @@ final class StackStreamFactory {
          *
          * @param mode        mode of stack walking
          * @param skipframes  number of frames to be skipped before filling the frame buffer.
+         * @param contScope   the continuation scope to walk.
+         * @param continuation the continuation to walk, or {@code null} if walking a thread.
          * @param batchSize   the batch size, max. number of elements to be filled in the frame buffers.
          * @param startIndex  start index of the frame buffers to be filled.
          * @param frames      Either a Class<?> array, if mode is {@link #FILL_CLASS_REFS_ONLY}
@@ -424,6 +467,7 @@ final class StackStreamFactory {
         // Android-changed: Not a native method.
         // private native R callStackWalk(long mode, int skipframes,
         private R callStackWalk(long mode, int skipframes,
+                                       ContinuationScope contScope, Continuation continuation,
                                        int batchSize, int startIndex,
                                        T[] frames) {
             checkFrameType(mode, frames);
@@ -431,6 +475,7 @@ final class StackStreamFactory {
             if (nativeAnchor == null) {
                 return null;
             }
+            // TODO: Implement continuation support.
             Object anchor = new LibcoreAnchor(nativeAnchor);
             int endIndex = fetchStackFrames(mode, anchor, batchSize, startIndex, frames);
             return doStackWalk(anchor, skipframes, batchSize, startIndex, endIndex);
@@ -484,7 +529,7 @@ final class StackStreamFactory {
         // Android-changed: Uses a different anchor.
         // private native int fetchStackFrames(long mode, long anchor,
         //                                     int batchSize, int startIndex,
-        //                                     T[] frames) {
+        //                                     T[] frames);
         private int fetchStackFrames(long mode, @NonNull Object anchor, int batchSize,
                                      int startIndex, T[] frames) {
             Objects.requireNonNull(anchor, "internal anchor can't be null");
@@ -497,6 +542,12 @@ final class StackStreamFactory {
             stacks.stackLevel += endIndex - startIndex;
             return endIndex;
         }
+
+        // Android-changed: Android uses a different anchor.
+        // private native void setContinuation(long anchor, T[] frames, Continuation cont);
+        private void setContinuation(Object anchor, T[] frames, Continuation cont) {
+            // TODO: Implement this for continuation support.
+        }
     }
 
     /*
@@ -564,6 +615,12 @@ final class StackStreamFactory {
             final Class<?> at(int index) {
                 return stackFrames[index].declaringClass();
             }
+
+            @Override
+            final boolean filter(int index) {
+                return stackFrames[index].declaringClass() == Continuation.class
+                        && "yield0".equals(stackFrames[index].getMethodName());
+            }
         }
 
         final Function<? super Stream<StackFrame>, ? extends T> function;  // callback
@@ -700,6 +757,9 @@ final class StackStreamFactory {
             @Override
             final Class<?> at(int index) { return classes[index];}
 
+            @Override
+            final boolean filter(int index) { return false; }
+
 
             // ------ subclass may override the following methods -------
             /**
@@ -832,6 +892,12 @@ final class StackStreamFactory {
             final Class<?> at(int index) {
                 return stackFrames[index].declaringClass();
             }
+
+            @Override
+            final boolean filter(int index) {
+                return stackFrames[index].declaringClass() == Continuation.class
+                        && "yield0".equals(stackFrames[index].getMethodName());
+            }
         }
 
         LiveStackInfoTraverser(StackWalker walker,
@@ -850,7 +916,7 @@ final class StackStreamFactory {
      *
      * Each specialized AbstractStackWalker subclass may subclass the FrameBuffer.
      */
-    static abstract class FrameBuffer<F> {
+    abstract static class FrameBuffer<F> {
         static final int START_POS = 2;     // 0th and 1st elements are reserved
 
         // buffers for VM to fill stack frame info
@@ -901,6 +967,13 @@ final class StackStreamFactory {
          */
         abstract Class<?> at(int index);
 
+        /**
+         * Filter out frames at the top of a batch
+         * @param index the position of the frame.
+         * @return true if the frame should be skipped
+         */
+        abstract boolean filter(int index);
+
         // ------ subclass may override the following methods -------
 
         /*
@@ -948,7 +1021,15 @@ final class StackStreamFactory {
          * it is done for traversal.  All stack frames have been traversed.
          */
         final boolean isActive() {
-            return origin > 0 && (fence == 0 || origin < fence || fence == currentBatchSize);
+            return origin > 0; //  && (fence == 0 || origin < fence || fence == currentBatchSize);
+        }
+
+        /*
+         * Tests if this frame buffer is at the end of the stack
+         * and all frames have been traversed.
+         */
+        final boolean isAtBottom() {
+            return origin > 0 && origin >= fence && fence < currentBatchSize;
         }
 
         /**
@@ -996,16 +1077,13 @@ final class StackStreamFactory {
 
             this.origin = startIndex;
             this.fence = endIndex;
-            if (depth == 0 && fence > 0) {
-                // filter the frames due to the stack stream implementation
-                for (int i = START_POS; i < fence; i++) {
-                    Class<?> c = at(i);
-                    if (isDebug) System.err.format("  frame %d: %s%n", i, c);
-                    if (filterStackWalkImpl(c)) {
-                        origin++;
-                    } else {
-                        break;
-                    }
+            for (int i = START_POS; i < fence; i++) {
+                if (isDebug) System.err.format("  frame %d: %s%n", i, at(i));
+                if ((depth == 0 && filterStackWalkImpl(at(i))) // filter the frames due to the stack stream implementation
+                        || filter(i)) {
+                    origin++;
+                } else {
+                    break;
                 }
             }
         }
diff --git a/ojluni/src/main/java/java/lang/StackWalker.java b/ojluni/src/main/java/java/lang/StackWalker.java
index 056b9946a8d..6da53766a7e 100644
--- a/ojluni/src/main/java/java/lang/StackWalker.java
+++ b/ojluni/src/main/java/java/lang/StackWalker.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,6 +33,8 @@ import java.util.Set;
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.stream.Stream;
+import jdk.internal.vm.Continuation;
+import jdk.internal.vm.ContinuationScope;
 
 /**
  * A stack walker.
@@ -297,6 +299,8 @@ public final class StackWalker {
     private static final StackWalker DEFAULT_WALKER =
         new StackWalker(DEFAULT_EMPTY_OPTION);
 
+    private final Continuation continuation;
+    private final ContinuationScope contScope;
     private final Set<Option> options;
     private final ExtendedOption extendedOption;
     private final int estimateDepth;
@@ -319,6 +323,24 @@ public final class StackWalker {
         return DEFAULT_WALKER;
     }
 
+    /**
+     * Returns a {@code StackWalker} instance.
+     *
+     * <p> This {@code StackWalker} is configured to skip all
+     * {@linkplain Option#SHOW_HIDDEN_FRAMES hidden frames} and
+     * no {@linkplain Option#RETAIN_CLASS_REFERENCE class reference} is retained.
+     *
+     * @param contScope the continuation scope up to which (inclusive) to walk the stack
+     *
+     * @return a {@code StackWalker} configured to skip all
+     * {@linkplain Option#SHOW_HIDDEN_FRAMES hidden frames} and
+     * no {@linkplain Option#RETAIN_CLASS_REFERENCE class reference} is retained.
+     *
+     */
+    static StackWalker getInstance(ContinuationScope contScope) {
+        return getInstance(EnumSet.noneOf(Option.class), contScope);
+    }
+
     /**
      * Returns a {@code StackWalker} instance with the given option specifying
      * the stack frame information it can access.
@@ -340,6 +362,28 @@ public final class StackWalker {
         return getInstance(EnumSet.of(Objects.requireNonNull(option)));
     }
 
+    /**
+     * Returns a {@code StackWalker} instance with the given option specifying
+     * the stack frame information it can access.
+     *
+     * <p>
+     * If a security manager is present and the given {@code option} is
+     * {@link Option#RETAIN_CLASS_REFERENCE Option.RETAIN_CLASS_REFERENCE},
+     * it calls its {@link SecurityManager#checkPermission checkPermission}
+     * method for {@code RuntimePermission("getStackWalkerWithClassReference")}.
+     *
+     * @param option {@link Option stack walking option}
+     * @param contScope the continuation scope up to which (inclusive) to walk the stack
+     *
+     * @return a {@code StackWalker} configured with the given option
+     *
+     * @throws SecurityException if a security manager exists and its
+     *         {@code checkPermission} method denies access.
+     */
+    static StackWalker getInstance(Option option, ContinuationScope contScope) {
+        return getInstance(EnumSet.of(Objects.requireNonNull(option)), contScope);
+    }
+
     /**
      * Returns a {@code StackWalker} instance with the given {@code options} specifying
      * the stack frame information it can access.  If the given {@code options}
@@ -361,13 +405,38 @@ public final class StackWalker {
      *         {@code checkPermission} method denies access.
      */
     public static StackWalker getInstance(Set<Option> options) {
-        if (options.isEmpty()) {
+        return getInstance(options, null);
+    }
+
+    /**
+     * Returns a {@code StackWalker} instance with the given {@code options} specifying
+     * the stack frame information it can access.  If the given {@code options}
+     * is empty, this {@code StackWalker} is configured to skip all
+     * {@linkplain Option#SHOW_HIDDEN_FRAMES hidden frames} and no
+     * {@linkplain Option#RETAIN_CLASS_REFERENCE class reference} is retained.
+     *
+     * <p>
+     * If a security manager is present and the given {@code options} contains
+     * {@link Option#RETAIN_CLASS_REFERENCE Option.RETAIN_CLASS_REFERENCE},
+     * it calls its {@link SecurityManager#checkPermission checkPermission}
+     * method for {@code RuntimePermission("getStackWalkerWithClassReference")}.
+     *
+     * @param options {@link Option stack walking option}
+     * @param contScope the continuation scope up to which (inclusive) to walk the stack
+     *
+     * @return a {@code StackWalker} configured with the given options
+     *
+     * @throws SecurityException if a security manager exists and its
+     *         {@code checkPermission} method denies access.
+     */
+    static StackWalker getInstance(Set<Option> options, ContinuationScope contScope) {
+        if (options.isEmpty() && contScope == null) {
             return DEFAULT_WALKER;
         }
 
         EnumSet<Option> optionSet = toEnumSet(options);
         checkPermission(optionSet);
-        return new StackWalker(optionSet);
+        return new StackWalker(optionSet, contScope);
     }
 
     /**
@@ -408,16 +477,37 @@ public final class StackWalker {
 
     // ----- private constructors ------
     private StackWalker(EnumSet<Option> options) {
-        this(options, 0, null);
+        this(options, 0, null, null, null);
+    }
+    private StackWalker(EnumSet<Option> options, ContinuationScope contScope) {
+        this(options, 0, null, contScope, null);
+    }
+    private StackWalker(EnumSet<Option> options, ContinuationScope contScope, Continuation continuation) {
+        this(options, 0, null, contScope, continuation);
     }
     private StackWalker(EnumSet<Option> options, int estimateDepth) {
-        this(options, estimateDepth, null);
+        this(options, estimateDepth, null, null, null);
     }
-    private StackWalker(EnumSet<Option> options, int estimateDepth, ExtendedOption extendedOption) {
+    private StackWalker(EnumSet<Option> options, int estimateDepth, ContinuationScope contScope) {
+        this(options, estimateDepth, null, contScope, null);
+    }
+    private StackWalker(EnumSet<Option> options,
+                        int estimateDepth,
+                        ContinuationScope contScope,
+                        Continuation continuation) {
+        this(options, estimateDepth, null, contScope, continuation);
+    }
+    private StackWalker(EnumSet<Option> options,
+                        int estimateDepth,
+                        ExtendedOption extendedOption,
+                        ContinuationScope contScope,
+                        Continuation continuation) {
         this.options = options;
         this.estimateDepth = estimateDepth;
         this.extendedOption = extendedOption;
         this.retainClassRef = hasOption(Option.RETAIN_CLASS_REFERENCE);
+        this.contScope = contScope;
+        this.continuation = continuation;
     }
 
     private static void checkPermission(Set<Option> options) {
@@ -601,6 +691,9 @@ public final class StackWalker {
             throw new UnsupportedOperationException("This stack walker " +
                     "does not have RETAIN_CLASS_REFERENCE access");
         }
+        if (continuation != null) {
+            throw new UnsupportedOperationException("This stack walker walks a continuation");
+        }
 
         return StackStreamFactory.makeCallerFinder(this).findCaller();
     }
@@ -608,9 +701,19 @@ public final class StackWalker {
     // ---- package access ----
 
     static StackWalker newInstance(Set<Option> options, ExtendedOption extendedOption) {
+        return newInstance(options, extendedOption, null);
+    }
+
+    static StackWalker newInstance(Set<Option> options, ExtendedOption extendedOption, ContinuationScope contScope) {
+        EnumSet<Option> optionSet = toEnumSet(options);
+        checkPermission(optionSet);
+        return new StackWalker(optionSet, 0, extendedOption, contScope, null);
+    }
+
+    static StackWalker newInstance(Set<Option> options, ExtendedOption extendedOption, ContinuationScope contScope, Continuation continuation) {
         EnumSet<Option> optionSet = toEnumSet(options);
         checkPermission(optionSet);
-        return new StackWalker(optionSet, 0, extendedOption);
+        return new StackWalker(optionSet, 0, extendedOption, contScope, continuation);
     }
 
     int estimateDepth() {
@@ -624,4 +727,12 @@ public final class StackWalker {
     boolean hasLocalsOperandsOption() {
         return extendedOption == ExtendedOption.LOCALS_AND_OPERANDS;
     }
+
+    ContinuationScope getContScope() {
+        return contScope;
+    }
+
+    Continuation getContinuation() {
+        return continuation;
+    }
 }
diff --git a/ojluni/src/main/java/java/lang/String.java b/ojluni/src/main/java/java/lang/String.java
index 9d2201384dc..ac5a69ffb1e 100644
--- a/ojluni/src/main/java/java/lang/String.java
+++ b/ojluni/src/main/java/java/lang/String.java
@@ -34,8 +34,17 @@ import java.lang.annotation.Native;
 import java.lang.invoke.MethodHandles;
 import java.lang.constant.Constable;
 import java.lang.constant.ConstantDesc;
+import java.nio.CharBuffer;
+import java.nio.charset.CharacterCodingException;
 import java.nio.charset.Charset;
 import java.nio.ByteBuffer;
+import java.nio.charset.CharsetDecoder;
+import java.nio.charset.CharsetEncoder;
+import java.nio.charset.CoderResult;
+import java.nio.charset.CodingErrorAction;
+import java.nio.charset.MalformedInputException;
+import java.nio.charset.UnmappableCharacterException;
+import java.util.Arrays;
 import java.util.Comparator;
 import java.util.Formatter;
 import java.util.List;
@@ -582,10 +591,163 @@ public final class String
         if (charset == null)
             throw new NullPointerException("charset");
         checkBoundsOffCount(offset, length, bytes.length);
-        StringCoding.Result ret =
-            StringCoding.decode(charset, bytes, offset, length);
-        this.value = ret.value;
-        this.coder = ret.coder;
+        if (length == 0) {
+            this.value = "".value;
+            this.coder = "".coder;
+        } else if (charset == UTF_8.INSTANCE) {
+            if (COMPACT_STRINGS && !StringCoding.hasNegatives(bytes, offset, length)) {
+                this.value = Arrays.copyOfRange(bytes, offset, offset + length);
+                this.coder = LATIN1;
+            } else {
+                int sl = offset + length;
+                int dp = 0;
+                byte[] dst = null;
+                if (COMPACT_STRINGS) {
+                    dst = new byte[length];
+                    while (offset < sl) {
+                        int b1 = bytes[offset];
+                        if (b1 >= 0) {
+                            dst[dp++] = (byte)b1;
+                            offset++;
+                            continue;
+                        }
+                        if ((b1 & 0xfe) == 0xc2 && offset + 1 < sl) { // b1 either 0xc2 or 0xc3
+                            int b2 = bytes[offset + 1];
+                            if (!isNotContinuation(b2)) {
+                                dst[dp++] = (byte)decode2(b1, b2);
+                                offset += 2;
+                                continue;
+                            }
+                        }
+                        // anything not a latin1, including the repl
+                        // we have to go with the utf16
+                        break;
+                    }
+                    if (offset == sl) {
+                        if (dp != dst.length) {
+                            dst = Arrays.copyOf(dst, dp);
+                        }
+                        this.value = dst;
+                        this.coder = LATIN1;
+                        return;
+                    }
+                }
+                if (dp == 0 || dst == null) {
+                    dst = StringUTF16.newBytesFor(length);
+                } else {
+                    byte[] buf = StringUTF16.newBytesFor(length);
+                    StringLatin1.inflate(dst, 0, buf, 0, dp);
+                    dst = buf;
+                }
+                dp = decodeUTF8_UTF16(bytes, offset, sl, dst, dp, true);
+                if (dp != length) {
+                    dst = Arrays.copyOf(dst, dp << 1);
+                }
+                this.value = dst;
+                this.coder = UTF16;
+            }
+        } else if (charset == ISO_8859_1.INSTANCE) {
+            if (COMPACT_STRINGS) {
+                this.value = Arrays.copyOfRange(bytes, offset, offset + length);
+                this.coder = LATIN1;
+            } else {
+                this.value = StringLatin1.inflate(bytes, offset, length);
+                this.coder = UTF16;
+            }
+        } else if (charset == US_ASCII.INSTANCE) {
+            if (COMPACT_STRINGS && !StringCoding.hasNegatives(bytes, offset, length)) {
+                this.value = Arrays.copyOfRange(bytes, offset, offset + length);
+                this.coder = LATIN1;
+            } else {
+                byte[] dst = StringUTF16.newBytesFor(length);
+                int dp = 0;
+                while (dp < length) {
+                    int b = bytes[offset++];
+                    StringUTF16.putChar(dst, dp++, (b >= 0) ? (char) b : REPL);
+                }
+                this.value = dst;
+                this.coder = UTF16;
+            }
+        } else {
+            // (1)We never cache the "external" cs, the only benefit of creating
+            // an additional StringDe/Encoder object to wrap it is to share the
+            // de/encode() method. These SD/E objects are short-lived, the young-gen
+            // gc should be able to take care of them well. But the best approach
+            // is still not to generate them if not really necessary.
+            // (2)The defensive copy of the input byte/char[] has a big performance
+            // impact, as well as the outgoing result byte/char[]. Need to do the
+            // optimization check of (sm==null && classLoader0==null) for both.
+            CharsetDecoder cd = charset.newDecoder();
+            // ArrayDecoder fastpaths
+            if (cd instanceof ArrayDecoder ad) {
+                // ascii
+                if (ad.isASCIICompatible() && !StringCoding.hasNegatives(bytes, offset, length)) {
+                    if (COMPACT_STRINGS) {
+                        this.value = Arrays.copyOfRange(bytes, offset, offset + length);
+                        this.coder = LATIN1;
+                        return;
+                    }
+                    this.value = StringLatin1.inflate(bytes, offset, length);
+                    this.coder = UTF16;
+                    return;
+                }
+
+                // fastpath for always Latin1 decodable single byte
+                if (COMPACT_STRINGS && ad.isLatin1Decodable()) {
+                    byte[] dst = new byte[length];
+                    ad.decodeToLatin1(bytes, offset, length, dst);
+                    this.value = dst;
+                    this.coder = LATIN1;
+                    return;
+                }
+
+                int en = scale(length, cd.maxCharsPerByte());
+                cd.onMalformedInput(CodingErrorAction.REPLACE)
+                        .onUnmappableCharacter(CodingErrorAction.REPLACE);
+                char[] ca = new char[en];
+                int clen = ad.decode(bytes, offset, length, ca);
+                if (COMPACT_STRINGS) {
+                    byte[] bs = StringUTF16.compress(ca, 0, clen);
+                    if (bs != null) {
+                        value = bs;
+                        coder = LATIN1;
+                        return;
+                    }
+                }
+                coder = UTF16;
+                value = StringUTF16.toBytes(ca, 0, clen);
+                return;
+            }
+
+            // decode using CharsetDecoder
+            int en = scale(length, cd.maxCharsPerByte());
+            cd.onMalformedInput(CodingErrorAction.REPLACE)
+                    .onUnmappableCharacter(CodingErrorAction.REPLACE);
+            char[] ca = new char[en];
+            if (charset.getClass().getClassLoader0() != null &&
+                    System.getSecurityManager() != null) {
+                bytes = Arrays.copyOfRange(bytes, offset, offset + length);
+                offset = 0;
+            }
+
+            int caLen;
+            try {
+                caLen = decodeWithDecoder(cd, ca, bytes, offset, length);
+            } catch (CharacterCodingException x) {
+                // Substitution is enabled, so this shouldn't happen
+                throw new Error(x);
+            }
+            if (COMPACT_STRINGS) {
+                byte[] bs = StringUTF16.compress(ca, 0, caLen);
+                if (bs != null) {
+                    value = bs;
+                    coder = LATIN1;
+                    return;
+                }
+            }
+            coder = UTF16;
+            value = StringUTF16.toBytes(ca, 0, caLen);
+        }
         */
         throw new UnsupportedOperationException("Use StringFactory instead.");
         // END Android-changed: Implemented as compiler and runtime intrinsics.
@@ -786,6 +948,255 @@ public final class String
     }
     // END Android-added: Constructor for internal use.
 
+    // BEGIN Android-changed: Cherry-pick NoRepl encoder and decoder for Files.read/writeString API.
+    static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {
+        try {
+            return newStringNoRepl1(src, cs);
+        } catch (IllegalArgumentException e) {
+            //newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause
+            Throwable cause = e.getCause();
+            if (cause instanceof MalformedInputException mie) {
+                throw mie;
+            }
+            throw (CharacterCodingException)cause;
+        }
+    }
+
+    @SuppressWarnings("removal")
+    private static String newStringNoRepl1(byte[] src, Charset cs) {
+        int len = src.length;
+        if (len == 0) {
+            return "";
+        }
+        // TODO: Implement a fast decoder that throws for malformed byte sequences.
+        // Android-changed: Need a fast decoder.
+        /*
+        if (cs == UTF_8.INSTANCE) {
+            return newStringUTF8NoRepl(src, 0, src.length, false);
+        }
+        if (cs == ISO_8859_1.INSTANCE) {
+            if (COMPACT_STRINGS)
+                return new String(src, LATIN1);
+            return new String(StringLatin1.inflate(src, 0, src.length), UTF16);
+        }
+        if (cs == US_ASCII.INSTANCE) {
+            if (!StringCoding.hasNegatives(src, 0, src.length)) {
+                if (COMPACT_STRINGS)
+                    return new String(src, LATIN1);
+                return new String(StringLatin1.inflate(src, 0, src.length), UTF16);
+            } else {
+                throwMalformed(src);
+            }
+        }
+        */
+
+        CharsetDecoder cd = cs.newDecoder();
+        // Android-changed: Android has no ArrayDecoder.
+        /*
+        // ascii fastpath
+        if (cd instanceof ArrayDecoder ad &&
+                ad.isASCIICompatible() &&
+                !StringCoding.hasNegatives(src, 0, src.length)) {
+            if (COMPACT_STRINGS)
+                return new String(src, LATIN1);
+            return new String(src, 0, src.length, ISO_8859_1.INSTANCE);
+        }
+        */
+        int en = scale(len, cd.maxCharsPerByte());
+        char[] ca = new char[en];
+        // Android-removed: Android has no security manager.
+        /*
+        if (cs.getClass().getClassLoader0() != null &&
+                System.getSecurityManager() != null) {
+            src = Arrays.copyOf(src, len);
+        }
+        */
+        int caLen;
+        try {
+            caLen = decodeWithDecoder(cd, ca, src, 0, src.length);
+        } catch (CharacterCodingException x) {
+            // throw via IAE
+            throw new IllegalArgumentException(x);
+        }
+        // Android-removed: On ART, `new String` will compress the underlying structure if possible.
+        /*
+        if (COMPACT_STRINGS) {
+            byte[] bs = StringUTF16.compress(ca, 0, caLen);
+            if (bs != null) {
+                return new String(bs, LATIN1);
+            }
+        }
+        return new String(StringUTF16.toBytes(ca, 0, caLen), UTF16);
+        */
+        return new String(ca, 0, caLen);
+    }
+
+    private static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length)
+            throws CharacterCodingException {
+        ByteBuffer bb = ByteBuffer.wrap(src, offset, length);
+        CharBuffer cb = CharBuffer.wrap(dst, 0, dst.length);
+        CoderResult cr = cd.decode(bb, cb, true);
+        if (!cr.isUnderflow())
+            cr.throwException();
+        cr = cd.flush(cb);
+        if (!cr.isUnderflow())
+            cr.throwException();
+        return cb.position();
+    }
+
+    /*
+     * Throws CCE, instead of replacing, if unmappable.
+     */
+    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {
+        try {
+            return getBytesNoRepl1(s, cs);
+        } catch (IllegalArgumentException e) {
+            //getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause
+            Throwable cause = e.getCause();
+            if (cause instanceof UnmappableCharacterException) {
+                throw (UnmappableCharacterException)cause;
+            }
+            throw (CharacterCodingException)cause;
+        }
+    }
+
+    private static byte[] getBytesNoRepl1(String s, Charset cs) {
+        // TODO: Implement a fast encoder that throws for malformed byte sequences.
+        // Android-changed: Need a fast encoder.
+        /*
+        byte[] val = s.value();
+        byte coder = s.coder();
+        if (cs == UTF_8.INSTANCE) {
+            if (coder == LATIN1 && isASCII(val)) {
+                return val;
+            }
+            return encodeUTF8(coder, val, false);
+        }
+        if (cs == ISO_8859_1.INSTANCE) {
+            if (coder == LATIN1) {
+                return val;
+            }
+            return encode8859_1(coder, val, false);
+        }
+        if (cs == US_ASCII.INSTANCE) {
+            if (coder == LATIN1) {
+                if (isASCII(val)) {
+                    return val;x
+                } else {
+                    throwUnmappable(val);
+                }
+            }
+        }
+        return encodeWithEncoder(cs, coder, val, false);
+        */
+        return encodeWithEncoder(cs, s, false);
+    }
+
+    private static int scale(int len, float expansionFactor) {
+        // We need to perform double, not float, arithmetic; otherwise
+        // we lose low order bits when len is larger than 2**24.
+        return (int)(len * (double)expansionFactor);
+    }
+
+    /*
+    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val, boolean doReplace) {
+        CharsetEncoder ce = cs.newEncoder();
+        int len = val.length >> coder;  // assume LATIN1=0/UTF16=1;
+        int en = scale(len, ce.maxBytesPerChar());
+        // fastpath with ArrayEncoder implies `doReplace`.
+        if (doReplace && ce instanceof ArrayEncoder ae) {
+            // fastpath for ascii compatible
+            if (coder == LATIN1 &&
+                    ae.isASCIICompatible() &&
+                    !StringCoding.hasNegatives(val, 0, val.length)) {
+                return val.clone();
+            }
+            byte[] ba = new byte[en];
+            if (len == 0) {
+                return ba;
+            }
+
+            int blen = (coder == LATIN1) ? ae.encodeFromLatin1(val, 0, len, ba)
+                    : ae.encodeFromUTF16(val, 0, len, ba);
+            if (blen != -1) {
+                return safeTrim(ba, blen, true);
+            }
+        }
+
+        byte[] ba = new byte[en];
+        if (len == 0) {
+            return ba;
+        }
+        if (doReplace) {
+            ce.onMalformedInput(CodingErrorAction.REPLACE)
+                    .onUnmappableCharacter(CodingErrorAction.REPLACE);
+        }
+        char[] ca = (coder == LATIN1 ) ? StringLatin1.toChars(val)
+                : StringUTF16.toChars(val);
+        ByteBuffer bb = ByteBuffer.wrap(ba);
+        CharBuffer cb = CharBuffer.wrap(ca, 0, len);
+        try {
+            CoderResult cr = ce.encode(cb, bb, true);
+            if (!cr.isUnderflow())
+                cr.throwException();
+            cr = ce.flush(bb);
+            if (!cr.isUnderflow())
+                cr.throwException();
+        } catch (CharacterCodingException x) {
+            if (!doReplace) {
+                throw new IllegalArgumentException(x);
+            } else {
+                throw new Error(x);
+            }
+        }
+        return safeTrim(ba, bb.position(), cs.getClass().getClassLoader0() == null);
+    }
+    */
+
+    private static byte[] encodeWithEncoder(Charset cs, String str, boolean doReplace) {
+        CharsetEncoder ce = cs.newEncoder();
+        int len = str.length();
+        int en = scale(len, ce.maxBytesPerChar());
+
+        byte[] ba = new byte[en];
+        if (len == 0) {
+            return ba;
+        }
+        if (doReplace) {
+            ce.onMalformedInput(CodingErrorAction.REPLACE)
+                    .onUnmappableCharacter(CodingErrorAction.REPLACE);
+        }
+        char[] ca = str.toCharArray();
+        ByteBuffer bb = ByteBuffer.wrap(ba);
+        CharBuffer cb = CharBuffer.wrap(ca, 0, len);
+        try {
+            CoderResult cr = ce.encode(cb, bb, true);
+            if (!cr.isUnderflow())
+                cr.throwException();
+            cr = ce.flush(bb);
+            if (!cr.isUnderflow())
+                cr.throwException();
+        } catch (CharacterCodingException x) {
+            if (!doReplace) {
+                throw new IllegalArgumentException(x);
+            } else {
+                throw new Error(x);
+            }
+        }
+        return safeTrim(ba, bb.position(), cs.getClass().getClassLoader() == null);
+    }
+
+    // Trim the given byte array to the given length
+    @SuppressWarnings("removal")
+    private static byte[] safeTrim(byte[] ba, int len, boolean isTrusted) {
+        if (len == ba.length && (isTrusted || System.getSecurityManager() == null)) {
+            return ba;
+        } else {
+            return Arrays.copyOf(ba, len);
+        }
+    }
+    // END Android-changed: Cherry-pick NoRepl encoder and decoder for Files.read/writeString API.
+
     /**
      * Returns the length of this string.
      * The length is equal to the number of <a href="Character.html#unicode">Unicode
diff --git a/ojluni/src/main/java/java/lang/StringBuffer.java b/ojluni/src/main/java/java/lang/StringBuffer.java
index 7c5332f77fc..4da97bc7ffe 100644
--- a/ojluni/src/main/java/java/lang/StringBuffer.java
+++ b/ojluni/src/main/java/java/lang/StringBuffer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1994, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,12 @@ package java.lang;
 
 import dalvik.annotation.optimization.NeverInline;
 import java.util.Arrays;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.ObjectStreamField;
+import java.io.Serializable;
+import java.io.StreamCorruptedException;
 import jdk.internal.HotSpotIntrinsicCandidate;
 
 /**
@@ -106,7 +112,7 @@ import jdk.internal.HotSpotIntrinsicCandidate;
  */
  public final class StringBuffer
     extends AbstractStringBuilder
-    implements java.io.Serializable, Comparable<StringBuffer>, CharSequence
+    implements Serializable, Comparable<StringBuffer>, CharSequence
 {
 
     /**
@@ -737,20 +743,20 @@ import jdk.internal.HotSpotIntrinsicCandidate;
      *              A flag indicating whether the backing array is shared.
      *              The value is ignored upon deserialization.
      */
-    private static final java.io.ObjectStreamField[] serialPersistentFields =
+    private static final ObjectStreamField[] serialPersistentFields =
     {
-        new java.io.ObjectStreamField("value", char[].class),
-        new java.io.ObjectStreamField("count", Integer.TYPE),
-        new java.io.ObjectStreamField("shared", Boolean.TYPE),
+        new ObjectStreamField("value", char[].class),
+        new ObjectStreamField("count", Integer.TYPE),
+        new ObjectStreamField("shared", Boolean.TYPE),
     };
 
     /**
-     * readObject is called to restore the state of the StringBuffer from
-     * a stream.
+     * The {@code writeObject} method is called to write the state of the
+     * {@code StringBuffer} to a stream.
      */
-    private synchronized void writeObject(java.io.ObjectOutputStream s)
-        throws java.io.IOException {
-        java.io.ObjectOutputStream.PutField fields = s.putFields();
+    private synchronized void writeObject(ObjectOutputStream s)
+        throws IOException {
+        ObjectOutputStream.PutField fields = s.putFields();
         char[] val = new char[capacity()];
         if (isLatin1()) {
             StringLatin1.getChars(value, 0, count, val, 0);
@@ -764,15 +770,20 @@ import jdk.internal.HotSpotIntrinsicCandidate;
     }
 
     /**
-     * readObject is called to restore the state of the StringBuffer from
-     * a stream.
+     * The {@code readObject} method is called to restore the state of the
+     * {@code StringBuffer} from a stream.
      */
-    private void readObject(java.io.ObjectInputStream s)
-        throws java.io.IOException, ClassNotFoundException {
-        java.io.ObjectInputStream.GetField fields = s.readFields();
+    private void readObject(ObjectInputStream s)
+        throws IOException, ClassNotFoundException {
+        ObjectInputStream.GetField fields = s.readFields();
         char[] val = (char[])fields.get("value", null);
+        int c = fields.get("count", 0);
+        if (c < 0 || c > val.length) {
+            throw new StreamCorruptedException("count value invalid");
+        }
         initBytes(val, 0, val.length);
-        count = fields.get("count", 0);
+        count = c;
+        // ignore shared field
     }
 
     synchronized void getBytes(byte dst[], int dstBegin, byte coder) {
diff --git a/ojluni/src/main/java/java/lang/StringBuilder.java b/ojluni/src/main/java/java/lang/StringBuilder.java
index 4740afc9d1b..ee9011458f5 100644
--- a/ojluni/src/main/java/java/lang/StringBuilder.java
+++ b/ojluni/src/main/java/java/lang/StringBuilder.java
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2014 The Android Open Source Project
- * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,10 @@
 package java.lang;
 
 import dalvik.annotation.optimization.NeverInline;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.StreamCorruptedException;
 import jdk.internal.HotSpotIntrinsicCandidate;
 
 /**
@@ -486,8 +490,7 @@ public final class StringBuilder
      *             characters currently stored in the string builder, in which
      *             case extra characters are ignored.
      */
-    private void writeObject(java.io.ObjectOutputStream s)
-        throws java.io.IOException {
+    private void writeObject(ObjectOutputStream s) throws IOException {
         s.defaultWriteObject();
         s.writeInt(count);
         char[] val = new char[capacity()];
@@ -500,15 +503,19 @@ public final class StringBuilder
     }
 
     /**
-     * readObject is called to restore the state of the StringBuffer from
+     * readObject is called to restore the state of the StringBuilder from
      * a stream.
      */
-    private void readObject(java.io.ObjectInputStream s)
-        throws java.io.IOException, ClassNotFoundException {
+    private void readObject(ObjectInputStream s)
+        throws IOException, ClassNotFoundException {
         s.defaultReadObject();
-        count = s.readInt();
+        int c = s.readInt();
         char[] val = (char[]) s.readObject();
+        if (c < 0 || c > val.length) {
+            throw new StreamCorruptedException("count value invalid");
+        }
         initBytes(val, 0, val.length);
+        count = c;
     }
 
 }
diff --git a/ojluni/src/main/java/java/lang/System.java b/ojluni/src/main/java/java/lang/System.java
index e7c1d59e30f..e1b044cff1e 100644
--- a/ojluni/src/main/java/java/lang/System.java
+++ b/ojluni/src/main/java/java/lang/System.java
@@ -1201,7 +1201,7 @@ public final class System {
      * <tr><td>java.ext.dirs</td>      <td>(Not useful on Android)</td>           <td>Empty</td></tr>
      * <tr><td>java.home</td>          <td>Location of the VM on the file system</td> <td>{@code /apex/com.android.art/}</td></tr>
      * <tr><td>java.io.tmpdir</td>     <td>Location of a temporary directory.<br>The location varies by application.<br>See {@link java.io.File#createTempFile}</td> <td>{@code /data/user/0/com.android.app/cache}</td></tr>
-     * <tr><td>java.library.path</td>  <td>Search path for JNI libraries</td>     <td>{@code /vendor/lib:/system/lib}</td></tr>
+     * <tr><td>java.library.path</td>  <td>Search path for JNI libraries</td>     <td>{@code /system/lib:/system_ext/lib}</td></tr>
      * <tr><td>java.vendor</td>        <td>Human-readable VM vendor</td>          <td>{@code The Android Project}</td></tr>
      * <tr><td>java.vendor.url</td>    <td>URL for VM vendor's web site</td>      <td>{@code http://www.android.com/}</td></tr>
      * <tr><td>java.version</td>       <td>(Not useful on Android)</td>           <td>{@code 0}</td></tr>
diff --git a/ojluni/src/main/java/java/lang/Thread.java b/ojluni/src/main/java/java/lang/Thread.java
index effb7c8ff0a..914c522c868 100644
--- a/ojluni/src/main/java/java/lang/Thread.java
+++ b/ojluni/src/main/java/java/lang/Thread.java
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2014 The Android Open Source Project
- * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1994, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,7 +26,9 @@
 
 package java.lang;
 
+import dalvik.annotation.optimization.CriticalNative;
 import dalvik.annotation.optimization.FastNative;
+import dalvik.annotation.compat.VersionCodes;
 import java.lang.ref.Reference;
 import java.lang.ref.ReferenceQueue;
 import java.lang.ref.WeakReference;
@@ -35,16 +37,37 @@ import java.security.AccessControlContext;
 import java.security.PrivilegedAction;
 import java.util.Map;
 import java.util.HashMap;
+import java.util.Objects;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.LockSupport;
+
+import jdk.internal.misc.TerminatingThreadLocal;
 import jdk.internal.misc.Unsafe;
+import jdk.internal.reflect.CallerSensitive;
+import jdk.internal.reflect.Reflection;
+import jdk.internal.vm.annotation.IntrinsicCandidate;
+import jdk.internal.vm.StackableScope;
+import jdk.internal.vm.ThreadContainer;
+import jdk.internal.vm.annotation.Stable;
 import sun.nio.ch.Interruptible;
-import sun.reflect.CallerSensitive;
+import sun.security.util.SecurityConstants;
+
+import dalvik.annotation.optimization.NeverInline;
+import dalvik.system.VMRuntime;
+import dalvik.system.VirtualThreadContext;
+import dalvik.system.VirtualThreadParkingError;
+import dalvik.system.VirtualThreadParkedStates;
 import dalvik.system.VMStack;
+
 import libcore.util.EmptyArray;
-import jdk.internal.vm.annotation.IntrinsicCandidate;
 
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
+
+import android.compat.Compatibility;
+import android.compat.annotation.ChangeId;
+import android.compat.annotation.EnabledSince;
 
 /**
  * A <i>thread</i> is a thread of execution in a program. The Java
@@ -134,15 +157,13 @@ import jdk.internal.vm.annotation.IntrinsicCandidate;
  * or method in this class will cause a {@link NullPointerException} to be
  * thrown.
  *
- * @author  unascribed
  * @see     Runnable
  * @see     Runtime#exit(int)
  * @see     #run()
  * @see     #stop()
  * @since   1.0
  */
-public
-class Thread implements Runnable {
+public class Thread implements Runnable {
     // Android-removed: registerNatives() not used on Android.
     /*
     /* Make sure registerNatives is the first thing <clinit> does. *
@@ -167,7 +188,15 @@ class Thread implements Runnable {
     // END Android-added: Android specific fields lock, nativePeer.
 
     private volatile String name;
-    private int priority;
+
+    // Android-changed: Cache Posix niceness instead of managed thread priority.
+    private int niceness;
+
+    private int priority;  // Only for reading via reflection and for unstarted threads. Avoid.
+
+    // cachedPriorityForNiceness[n + PFN_INDEX_OFFSET] = 0 or Java priority for niceness n.
+    private static final byte[] cachedPriorityForNiceness = new byte[40];
+    static final int PFN_INDEX_OFFSET = 20;
 
     /* Whether or not to single_step this thread. */
     private boolean     single_step;
@@ -175,9 +204,20 @@ class Thread implements Runnable {
     /* Whether or not the thread is a daemon thread. */
     private boolean daemon = false;
 
+    /* Interrupt state of the thread - read/written directly by JVM */
+    // Android-removed: Remove unused field.
+    // private volatile boolean interrupted;
+
     /* Fields reserved for exclusive use by the JVM */
     private boolean stillborn = false;
-    private long eetop;
+
+    /*
+     * Reserved for exclusive use by the JVM. The historically named
+     * `eetop` holds the address of the underlying VM JavaThread, and is set to
+     * non-zero when the thread is started, and reset to zero when the thread terminates.
+     * A non-zero value indicates this thread isAlive().
+     */
+    private volatile long eetop;
 
     /* What will be run. */
     private Runnable target;
@@ -189,6 +229,7 @@ class Thread implements Runnable {
     private ClassLoader contextClassLoader;
 
     /* The inherited AccessControlContext of this thread */
+    @SuppressWarnings("removal")
     private AccessControlContext inheritedAccessControlContext;
 
     /* For autonumbering anonymous threads. */
@@ -281,9 +322,93 @@ class Thread implements Runnable {
     private volatile Interruptible blocker;
     private final Object blockerLock = new Object();
 
+    /**
+     * Starts a virtual thread. Compared to {@linkplain startVirtualThread(Runnable)}, it returns
+     * the carrier thread. This is useful for internal testing and verifying the states of a
+     * carrier thread.
+     *
+     * @hide
+     */
+    public static Thread startVirtual(Runnable task) {
+        Objects.requireNonNull(task);
+        VirtualThreadContext vContext = new VirtualThreadContext(task);
+        return Thread.startVirtual(vContext);
+    }
+
+    /**
+     * Unpark a virtual thread if it's parked.
+     * Start a new carrier thread if the virtual thread is pinned.
+     *
+     * @throws IllegalStateException if the virtual thread isn't parked.
+     * @hide
+     */
+    public static Thread unparkVirtual(VirtualThreadContext context) {
+        if (!context.isParked()) {
+            throw new IllegalStateException("This virtual thread isn't parked.");
+        }
+        if (context.isPinned()) {
+            return context.unparkOnCarrierThread();
+        } else {
+            return Thread.startVirtual(context);
+        }
+    }
+
+    private static Thread startVirtual(VirtualThreadContext context) {
+        if (!com.android.art.flags.Flags.virtualThreadImplV1()) {
+            throw new UnsupportedOperationException("Virtual Thread isn't supported.");
+        }
+        Thread carrier = new Thread(context, context.carrierName);
+        carrier.start();
+        return carrier;
+    }
+
+    /**
+     * @hide
+     */
+    public static void parkVirtual() {
+        // The bytecode generated for this method may keep a reference to the carrier
+        // java.lang.Thread object for the lifetime of this method. To avoid this, we invoke
+        // getCurrentVirtualThreadContext() to get the context, and mark this method as
+        // @NeverInline, which ensures this method is not inlined by dexers / JIT / AOT.
+        VirtualThreadContext context = getCurrentVirtualThreadContext();
+        VirtualThreadParkedStates parkedStates = new VirtualThreadParkedStates();
+        // TODO: Consider avoiding passing from java, but getting the static instance from ART.
+        VirtualThreadParkingError error = VirtualThreadParkingError.INSTANCE;
+        parkVirtualInternal(context, parkedStates, error);
+        // If the virtual thread is pinned, ART sets the state in VirtualThreadContext.
+        // Now, we call the regular java code to park the carrier thread.
+        context.parkOnCarrierThreadIfPinned();
+    }
+
+    private static native void parkVirtualInternal(VirtualThreadContext context,
+            VirtualThreadParkedStates parkedStates, VirtualThreadParkingError error);
+
+    /**
+     *
+     * Annotated with @NeverInline to avoid the reference to carrier java.lang.thread object.
+     * @hide
+     */
+    @NeverInline
+    public static VirtualThreadContext getCurrentVirtualThreadContext() {
+        Thread t = Thread.currentThread();
+        return t.getVirtualThreadContext();
+    }
+
+    /**
+     * @hide
+     */
+    public VirtualThreadContext getVirtualThreadContext() {
+        if (!(target instanceof VirtualThreadContext context)) {
+            throw new IllegalThreadStateException(
+                    "getVirtualThreadContext() can't be called on a regular thread.");
+        }
+        return context;
+    }
+
     // Android-changed: Make blockedOn() @hide public, for internal use.
     // Changed comment to reflect usage on Android
-    /* Set the blocker field; used by java.nio.channels.spi.AbstractInterruptibleChannel
+    /* Set the blocker field; invoked via jdk.internal.access.SharedSecrets
+     * from java.nio code
      */
     /** @hide */
     public void blockedOn(Interruptible b) {
@@ -307,6 +432,19 @@ class Thread implements Runnable {
      */
     public static final int MAX_PRIORITY = 10;
 
+    /**
+     * Returns the Thread object for the current platform thread. If the
+     * current thread is a virtual thread then this method returns the carrier.
+     * @hide
+     */
+    @IntrinsicCandidate
+    // Android-changed: Android has a different implementation.
+    // static native Thread currentCarrierThread();
+    public static Thread currentCarrierThread() {
+        // TODO: Simple use currentThread() until java.lang.VirtualThread is supported.
+        return currentThread();
+    }
+
     /**
      * Returns a reference to the currently executing thread object.
      *
@@ -409,9 +547,9 @@ class Thread implements Runnable {
 
         // BEGIN Android-changed: Implement sleep() methods using a shared native implementation.
         // Attempt nanosecond rather than millisecond accuracy for sleep();
-        // RI code rounds to the nearest millisecond.
+        // RI code rounds up by 1 millisecond.
         /*
-        if (nanos >= 500000 || (nanos != 0 && millis == 0)) {
+        if (nanos > 0 && millis < Long.MAX_VALUE) {
             millis++;
         }
 
@@ -506,6 +644,7 @@ class Thread implements Runnable {
      * @param inheritThreadLocals if {@code true}, inherit initial values for
      *            inheritable thread-locals from the constructing thread
      */
+    @SuppressWarnings("removal")
     private Thread(ThreadGroup g, Runnable target, String name,
                    long stackSize, AccessControlContext acc,
                    boolean inheritThreadLocals) {
@@ -558,7 +697,8 @@ class Thread implements Runnable {
 
         this.group = g;
         this.daemon = parent.isDaemon();
-        this.priority = parent.getPriority();
+        this.niceness = parent.getPosixNicenessInternal();
+        this.priority = parent.priority;
         // Android-changed: Moved into init2(Thread, boolean) helper method.
         /*
         if (security == null || isCCLOverridden(parent.getClass()))
@@ -718,7 +858,7 @@ class Thread implements Runnable {
      * but thread-local variables are not inherited.
      * This is not a public constructor.
      */
-    Thread(Runnable target, AccessControlContext acc) {
+    Thread(Runnable target, @SuppressWarnings("removal") AccessControlContext acc) {
         this(null, target, "Thread-" + nextThreadNum(), 0, acc, false);
     }
 
@@ -787,7 +927,7 @@ class Thread implements Runnable {
 
     // BEGIN Android-added: Private constructor - used by the runtime.
     /** @hide */
-    Thread(ThreadGroup group, String name, int priority, boolean daemon) {
+    Thread(ThreadGroup group, String name, int niceness, boolean daemon) {
         this.group = group;
         this.group.addUnstarted();
         // Must be tolerant of threads without a name.
@@ -800,7 +940,8 @@ class Thread implements Runnable {
         // undesirable to clobber their natively set name.
         this.name = name;
 
-        this.priority = priority;
+        this.niceness = niceness;
+        this.priority = cachingPriorityForNiceness(niceness);
         this.daemon = daemon;
         init2(currentThread(), true);
         this.stackSize = 0;
@@ -1030,9 +1171,9 @@ class Thread implements Runnable {
      * @since 21
      */
     public final boolean isVirtual() {
-        // Android-changed: Virtual threads are not supported in Android.
+        // Android-changed: Android has its own implementation.
         // return (this instanceof BaseVirtualThread);
-        return false;
+        return target instanceof VirtualThreadContext;
     }
 
     /**
@@ -1048,6 +1189,9 @@ class Thread implements Runnable {
      * In particular, a thread may not be restarted once it has completed
      * execution.
      *
+     * <p><strong>WARNING:</strong> Do not override this method, because the runtime may
+     * treat this method {@code final} in the future, because it works closely with the runtime.</p>
+     *
      * @throws     IllegalThreadStateException  if the thread was already started.
      * @see        #run()
      * @see        #stop()
@@ -1094,6 +1238,108 @@ class Thread implements Runnable {
         }
     }
 
+    // Android-added: Thread.start() is overridden in ThreadPoolExecutor. http://b/418924588
+    /**
+     * {@link Thread#start()} is no longer invoked for threads used by
+     * {@link java.util.concurrent.ThreadPoolExecutor} and
+     * {@link java.util.concurrent.ForkJoinPool}.
+     *
+     * Don't override {@link Thread#start()} in this case when the app targets SDK level
+     * corresponding to 26Q2, or the overridden method won't be invoked by the
+     * runtime.
+     *
+     * @hide
+     */
+    @ChangeId
+    @EnabledSince(targetSdkVersion = VersionCodes.C)
+    public static final long OVERRIDDEN_THREAD_START_METHOD = 418924588L;
+
+    /**
+     * Schedules this thread to begin execution in the given thread container.
+     * @throws IllegalStateException if the container is shutdown or closed
+     * @throws IllegalThreadStateException if the thread has already been started
+     */
+    void start(ThreadContainer container) {
+        // Android-changed: App compat with overridden Thread.start() method. http://b/418924588
+        if (!isVirtual() && !(VMRuntime.getSdkVersion() >= VersionCodes.C
+                && Compatibility.isChangeEnabled(Thread.OVERRIDDEN_THREAD_START_METHOD))) {
+            synchronized (this) {
+                if (started) {
+                    throw new IllegalThreadStateException();
+                }
+
+                // bind thread to container
+                if (this.container != null)
+                    throw new IllegalThreadStateException();
+
+                setThreadContainer(container);
+                container.onStart(this);
+                // Release the monitor for better app compatibility, because an app may not assume
+                // the monitor being held.
+            }
+            try {
+                this.start();
+            } finally {
+                synchronized (this) {
+                    if (!started) {
+                        container.onExit(this);
+                    }
+                }
+            }
+            return;
+        }
+
+        // TODO: Minimize code duplication in start().
+        synchronized (this) {
+            // zero status corresponds to state "NEW".
+            // Android-changed: Replace unused threadStatus field with started field.
+            // if (holder.threadStatus != 0)
+            //     throw new IllegalThreadStateException();
+            if (started)
+                throw new IllegalThreadStateException();
+
+            // bind thread to container
+            if (this.container != null)
+                throw new IllegalThreadStateException();
+
+            // Android-added: Add this to the thread group until ART does so in the native side.
+            /* Notify the group that this thread is about to be started
+             * so that it can be added to the group's list of threads
+             * and the group's unstarted count can be decremented. */
+            group.add(this);
+
+            setThreadContainer(container);
+
+            // start thread
+            // Android-changed: Use field instead of local variable.
+            started = false;
+            container.onStart(this);  // may throw
+            try {
+                // scoped values may be inherited
+                // Android-removed: ScopedValue isn't supported yet.
+                // inheritScopedValueBindings(container);
+
+                // Android-changed: Use Android specific nativeCreate() method to start thread.
+                // start0();
+                nativeCreate(this, stackSize, daemon);
+                started = true;
+            } finally {
+                if (!started) {
+                    container.onExit(this);
+                }
+                // Android-added: Report start failure until ART does so in the native side.
+                try {
+                    if (!started) {
+                        group.threadStartFailed(this);
+                    }
+                } catch (Throwable ignore) {
+                    /* do nothing. If start0 threw a Throwable then
+                      it will be passed up the call stack */
+                }
+            }
+        }
+    }
+
     // Android-changed: Use Android specific nativeCreate() method to create/start thread.
     // The upstream native method start0() only takes a reference to this object and so must obtain
     // the stack size and daemon status directly from the field whereas Android supplies the values
@@ -1167,6 +1413,7 @@ class Thread implements Runnable {
     @Deprecated(since="1.2")
     public final void stop() {
         /*
+        @SuppressWarnings("removal")
         SecurityManager security = System.getSecurityManager();
         if (security != null) {
             checkAccess();
@@ -1218,7 +1465,7 @@ class Thread implements Runnable {
      * Object#wait() wait()}, {@link Object#wait(long) wait(long)}, or {@link
      * Object#wait(long, int) wait(long, int)} methods of the {@link Object}
      * class, or of the {@link #join()}, {@link #join(long)}, {@link
-     * #join(long, int)}, {@link #sleep(long)}, or {@link #sleep(long, int)},
+     * #join(long, int)}, {@link #sleep(long)}, or {@link #sleep(long, int)}
      * methods of this class, then its interrupt status will be cleared and it
      * will receive an {@link InterruptedException}.
      *
@@ -1239,11 +1486,14 @@ class Thread implements Runnable {
      *
      * <p> Interrupting a thread that is not alive need not have any effect.
      *
+     * @implNote In the JDK Reference Implementation, interruption of a thread
+     * that is not alive still records that the interrupt request was made and
+     * will report it via {@link #interrupted} and {@link #isInterrupted()}.
+     *
      * @throws  SecurityException
      *          if the current thread cannot modify this thread
      *
-     * @revised 6.0
-     * @spec JSR-51
+     * @revised 6.0, 14
      */
     public void interrupt() {
         if (this != Thread.currentThread()) {
@@ -1253,14 +1503,17 @@ class Thread implements Runnable {
             synchronized (blockerLock) {
                 Interruptible b = blocker;
                 if (b != null) {
-                    interrupt0();  // set interrupt status
+                    // Android-removed: Remove unused the interrupted field.
+                    // interrupted = true;
+                    interrupt0();  // inform VM of interrupt
                     b.interrupt(this);
                     return;
                 }
             }
         }
-
-        // set interrupt status
+        // Android-removed: Remove unused the interrupted field.
+        // interrupted = true;
+        // inform VM of interrupt
         interrupt0();
     }
 
@@ -1272,14 +1525,10 @@ class Thread implements Runnable {
      * interrupted again, after the first call had cleared its interrupted
      * status and before the second call had examined it).
      *
-     * <p>A thread interruption ignored because a thread was not alive
-     * at the time of the interrupt will be reflected by this method
-     * returning false.
-     *
      * @return  {@code true} if the current thread has been interrupted;
      *          {@code false} otherwise.
      * @see #isInterrupted()
-     * @revised 6.0
+     * @revised 6.0, 14
      */
     // Android-changed: Use native interrupted()/isInterrupted() methods.
     // Upstream has one native method for both these methods that takes a boolean parameter that
@@ -1291,9 +1540,20 @@ class Thread implements Runnable {
     // * Updating the interrupted flag is more complex than simply reading it. Knowing that only
     //   the current thread can clear the interrupted status makes the code simpler as it does not
     //   need to be concerned about multiple threads trying to clear the status simultaneously.
-    // public static boolean interrupted() {
-    //     return currentThread().isInterrupted(true);
-    // }
+    /*
+    public static boolean interrupted() {
+        Thread t = currentThread();
+        boolean interrupted = t.interrupted;
+        // We may have been interrupted the moment after we read the field,
+        // so only clear the field if we saw that it was set and will return
+        // true; otherwise we could lose an interrupt.
+        if (interrupted) {
+            t.interrupted = false;
+            clearInterruptEvent();
+        }
+        return interrupted;
+    }
+    */
     @FastNative
     public static native boolean interrupted();
 
@@ -1301,18 +1561,14 @@ class Thread implements Runnable {
      * Tests whether this thread has been interrupted.  The <i>interrupted
      * status</i> of the thread is unaffected by this method.
      *
-     * <p>A thread interruption ignored because a thread was not alive
-     * at the time of the interrupt will be reflected by this method
-     * returning false.
-     *
      * @return  {@code true} if this thread has been interrupted;
      *          {@code false} otherwise.
      * @see     #interrupted()
-     * @revised 6.0
+     * @revised 6.0, 14
      */
     // Android-changed: Use native interrupted()/isInterrupted() methods.
     // public boolean isInterrupted() {
-    //     return isInterrupted(false);
+    //     return interrupted;
     // }
     @FastNative
     public native boolean isInterrupted();
@@ -1347,7 +1603,7 @@ class Thread implements Runnable {
      * @removed
      * @throws UnsupportedOperationException always
      */
-    @Deprecated
+    @Deprecated(since="16", forRemoval=true)
     public void destroy() {
         throw new UnsupportedOperationException();
     }
@@ -1361,7 +1617,9 @@ class Thread implements Runnable {
      *          {@code false} otherwise.
      */
     // Android-changed: Provide pure Java implementation of isAlive().
-    // public final native boolean isAlive();
+    // public final boolean isAlive() {
+    //     return eetop != 0;
+    // }
     public final boolean isAlive() {
         return nativePeer != 0;
     }
@@ -1383,7 +1641,7 @@ class Thread implements Runnable {
      * @removed
      * @throws UnsupportedOperationException always
      */
-    @Deprecated(since="1.2")
+    @Deprecated(since="1.2", forRemoval=true)
     public final void suspend() {
         // Android-changed: Unsupported on Android.
         // checkAccess();
@@ -1404,7 +1662,7 @@ class Thread implements Runnable {
      * @removed
      * @throws UnsupportedOperationException always
      */
-    @Deprecated(since="1.2")
+    @Deprecated(since="1.2", forRemoval=true)
     public final void resume() {
         // Android-changed: Unsupported on Android.
         // checkAccess();
@@ -1449,14 +1707,53 @@ class Thread implements Runnable {
             // Android-changed: Avoid native call if Thread is not yet started.
             // setPriority0(priority = newPriority);
             synchronized(this) {
-                this.priority = newPriority;
+                this.priority = newPriority;  // Ignored by us if already started.
                 if (isAlive()) {
-                    setPriority0(newPriority);
+                    this.niceness = setPriority0(newPriority);
+                } else {
+                    this.niceness = nicenessForPriority(newPriority);
                 }
             }
         }
     }
 
+    /**
+     * Android-added: An internal version of setPriority that takes niceness rather than priority.
+     * We do not bounds check. This does affect getPriority() calls. The results of such
+     * getPriority() will be limited to [MIN_PRIORITY, MAX_PRIORITY] even if the actual niceness
+     * value is outside that range. Such a value may be outside the ThreadGroup limit.
+     *
+     * @return  Linux errno, 0 on success or if thread has not yet been started.
+     *
+     * @hide
+     */
+    public final int setPosixNicenessInternal(int newNiceness) {
+        synchronized(this) {
+            this.niceness = newNiceness;
+            // Don't bother setting priority field here; it's only for backward compatibility, and
+            // historically we didn't set priority in this case.
+            if (isAlive()) {
+                return setNiceness0(newNiceness);
+            }
+        }
+        return 0;
+    }
+
+    /**
+     * Android-added: Fast niceness to priority conversion.
+     * Return Java priority for Posix niceness `n`, caching previously computed results.
+     */
+    private int cachingPriorityForNiceness(int n) {
+        byte[] pfn = cachedPriorityForNiceness;
+        int p = cachedPriorityForNiceness[n + PFN_INDEX_OFFSET];
+        if (p == 0) {
+            p = priorityForNiceness(n);
+            // Data race here is OK by Java rules.
+            cachedPriorityForNiceness[n + PFN_INDEX_OFFSET] = (byte) p;
+        }
+        return p;
+    }
+
     /**
      * Returns this thread's priority.
      *
@@ -1464,7 +1761,18 @@ class Thread implements Runnable {
      * @see     #setPriority
      */
     public final int getPriority() {
-        return priority;
+        // Android-changed: Convert from stored niceness.
+        return cachingPriorityForNiceness(niceness);
+    }
+
+    /**
+     * Android-added: Access to cached niceness value.
+     * Returns this thread's cached niceness value.
+     *
+     * @hide
+     */
+    public final int getPosixNicenessInternal() {
+      return niceness;
     }
 
     /**
@@ -1576,21 +1884,21 @@ class Thread implements Runnable {
     }
 
     /**
-     * Counts the number of stack frames in this thread. The thread must
-     * be suspended.
+     * Throws {@code UnsupportedOperationException}.
      *
-     * @return     the number of stack frames in this thread.
-     * @throws     IllegalThreadStateException  if this thread is not
-     *             suspended.
-     * @deprecated The definition of this call depends on {@link #suspend},
-     *             which is deprecated.  Further, the results of this call
-     *             were never well-defined.
+     * @return     nothing
+     *
+     * @deprecated This method was originally designed to count the number of
+     *             stack frames but the results were never well-defined and it
+     *             depended on thread-suspension.
      *             This method is subject to removal in a future version of Java SE.
      * @removed
      */
     @Deprecated(since="1.2", forRemoval=true)
     // Android-changed: Provide non-native implementation of countStackFrames().
-    // public native int countStackFrames();
+    // public int countStackFrames() {
+    //     throw new UnsupportedOperationException();
+    // }
     public int countStackFrames() {
         return getStackTrace().length;
     }
@@ -1616,37 +1924,35 @@ class Thread implements Runnable {
      *          <i>interrupted status</i> of the current thread is
      *          cleared when this exception is thrown.
      */
-    // BEGIN Android-changed: Synchronize on separate lock object not this Thread.
-    // nativePeer and hence isAlive() can change asynchronously, but Thread::Destroy
-    // will always acquire and notify lock after isAlive() changes to false.
-    // public final synchronized void join(long millis)
-    public final void join(long millis)
-    throws InterruptedException {
-        synchronized(lock) {
-        long base = System.currentTimeMillis();
-        long now = 0;
-
+    public final void join(long millis) throws InterruptedException {
         if (millis < 0) {
             throw new IllegalArgumentException("timeout value is negative");
         }
 
-        if (millis == 0) {
-            while (isAlive()) {
-                lock.wait(0);
-            }
-        } else {
-            while (isAlive()) {
-                long delay = millis - now;
-                if (delay <= 0) {
-                    break;
+        // BEGIN Android-changed: Synchronize on separate lock object not this Thread.
+        // nativePeer and hence isAlive() can change asynchronously, but Thread::Destroy
+        // will always acquire and notify lock after isAlive() changes to false.
+        // synchronized (this) {
+        synchronized(lock) {
+            if (millis > 0) {
+                if (isAlive()) {
+                    final long startTime = System.nanoTime();
+                    long delay = millis;
+                    do {
+                        // wait(delay);
+                        lock.wait(delay);
+                    } while (isAlive() && (delay = millis -
+                            NANOSECONDS.toMillis(System.nanoTime() - startTime)) > 0);
+                }
+            } else {
+                while (isAlive()) {
+                    // wait(0);
+                    lock.wait(0);
                 }
-                lock.wait(delay);
-                now = System.currentTimeMillis() - base;
             }
         }
-        }
+        // END Android-changed: Synchronize on separate lock object not this Thread.
     }
-    // END Android-changed: Synchronize on separate lock object not this Thread.
 
     /**
      * Waits at most {@code millis} milliseconds plus
@@ -1689,7 +1995,7 @@ class Thread implements Runnable {
                                 "nanosecond timeout value out of range");
         }
 
-        if (nanos >= 500000 || (nanos != 0 && millis == 0)) {
+        if (nanos > 0 && millis < Long.MAX_VALUE) {
             millis++;
         }
 
@@ -1784,6 +2090,7 @@ class Thread implements Runnable {
     @Deprecated(since="17", forRemoval=true)
     public final void checkAccess() {
         // Android-removed: SecurityManager stubbed out on Android.
+        // @SuppressWarnings("removal")
         // SecurityManager security = System.getSecurityManager();
         // if (security != null) {
         //     security.checkAccess(this);
@@ -1833,6 +2140,7 @@ class Thread implements Runnable {
         /*
         if (contextClassLoader == null)
             return null;
+        @SuppressWarnings("removal")
         SecurityManager sm = System.getSecurityManager();
         if (sm != null) {
             ClassLoader.checkClassLoaderPermission(contextClassLoader,
@@ -1866,6 +2174,7 @@ class Thread implements Runnable {
      */
     public void setContextClassLoader(ClassLoader cl) {
         // Android-removed: SecurityManager stubbed out on Android.
+        // @SuppressWarnings("removal")
         // SecurityManager sm = System.getSecurityManager();
         // if (sm != null) {
         //     sm.checkPermission(new RuntimePermission("setContextClassLoader"));
@@ -1935,6 +2244,7 @@ class Thread implements Runnable {
         /*
         if (this != Thread.currentThread()) {
             // check for getStackTrace permission
+            @SuppressWarnings("removal")
             SecurityManager security = System.getSecurityManager();
             if (security != null) {
                 security.checkPermission(
@@ -1992,6 +2302,7 @@ class Thread implements Runnable {
         // Android-removed: SecurityManager stubbed out on Android.
         /*
         // check for getStackTrace permission
+        @SuppressWarnings("removal")
         SecurityManager security = System.getSecurityManager();
         if (security != null) {
             security.checkPermission(
@@ -2016,11 +2327,9 @@ class Thread implements Runnable {
             // else terminated so we don't put it in the map
         }
         */
-        int count = ThreadGroup.systemThreadGroup.activeCount();
-        Thread[] threads = new Thread[count + count / 2];
-
-        // Enumerate the threads.
-        count = ThreadGroup.systemThreadGroup.enumerate(threads);
+        AllThreadsRecord r = getAllThreadsInternal();
+        int count = r.count;
+        Thread[] threads = r.threads;
 
         // Collect the stacktraces
         Map<Thread, StackTraceElement[]> m = new HashMap<Thread, StackTraceElement[]>();
@@ -2076,6 +2385,7 @@ class Thread implements Runnable {
      * subclass overrides any of the methods, false otherwise.
      */
     private static boolean auditSubclass(final Class<?> subcl) {
+        @SuppressWarnings("removal")
         Boolean result = AccessController.doPrivileged(
             new PrivilegedAction<>() {
                 public Boolean run() {
@@ -2102,6 +2412,38 @@ class Thread implements Runnable {
         return result.booleanValue();
     }
 
+    /**
+     * Return an array of all live threads.
+     */
+    static Thread[] getAllThreads() {
+        // Android-changed: Use ThreadGroup and getStackTrace() instead of native methods.
+        // return getThreads();
+        AllThreadsRecord r = getAllThreadsInternal();
+        int count = r.count;
+        Thread[] threads = new Thread[count];
+        System.arraycopy(r.threads, 0, threads, 0, count);
+        return threads;
+    }
+
+    // BEGIN Android-added: Use ThreadGroup and getStackTrace() instead of native methods.
+    /**
+     * @return an AllThreadsRecord object that has some unused space at the tail of the array, and
+     *         an actual count of threads.
+     */
+    private static AllThreadsRecord getAllThreadsInternal() {
+        // Allocate a bit more space than needed, in case new ones are just being created.
+        int count = ThreadGroup.systemThreadGroup.activeCount();
+        Thread[] threads = new Thread[count + count / 2];
+
+        // Enumerate the threads.
+        count = ThreadGroup.systemThreadGroup.enumerate(threads);
+        return new AllThreadsRecord(threads, count);
+    }
+
+    @SuppressWarnings("ArrayRecordComponent")
+    private record AllThreadsRecord(Thread[] threads, int count) {}
+    // END Android-added: Use ThreadGroup and getStackTrace() instead of native methods.
+
     // Android-removed: Native methods that are unused on Android.
     // private static native StackTraceElement[][] dumpThreads(Thread[] threads);
     // private static native Thread[] getThreads();
@@ -2329,6 +2671,7 @@ class Thread implements Runnable {
     public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh) {
         // Android-removed: SecurityManager stubbed out on Android.
         /*
+        @SuppressWarnings("removal")
         SecurityManager sm = System.getSecurityManager();
         if (sm != null) {
             sm.checkPermission(
@@ -2532,9 +2875,9 @@ class Thread implements Runnable {
                 return true;
 
             if (obj instanceof WeakClassKey) {
-                Object referent = get();
+                Class<?> referent = get();
                 return (referent != null) &&
-                       (referent == ((WeakClassKey) obj).get());
+                        (((WeakClassKey) obj).refersTo(referent));
             } else {
                 return false;
             }
@@ -2562,9 +2905,45 @@ class Thread implements Runnable {
 
     /* Some private helper methods */
     /**
-     * Android-changed: Make accessible to Daemons.java for internal use.
+     * Android-changed: Make accessible to Daemons.java for internal use. Return signed niceness
+     * value corresponding to newPriority. The argument is still a Java priority.
+     *
+     * Equivalent to
+     *
+     *   int n = nicenessForPriority(newPriority);
+     *   setNiceness0(nicenessForPriority(n));
+     *   return n;
+     *
+     * But it allows us to implement Thread.setPriority() with a single native call.
+     * (On Android S, this equivalence is approximate. See implementation.)
+     */
+    native int setPriority0(int newPriority);
+
+    /**
+     * Android-added: Helper methods allowing us to understand the priority to niceness mapping,
+     * so that we can process franeworks requests trafficking in niceness as well.
+     */
+
+    /**
+     * setPriority0, but with nicenes argument and returns an errno value.
+     */
+    private native int setNiceness0(int niceness);
+
+    /**
+     * A somewhat inefficient way to map Linux niceness to Java priority. We cache the results here.
+     * @hide
      */
-    native void setPriority0(int newPriority);
+    // VisibleForTesting
+    @CriticalNative
+    public static native int priorityForNiceness(int niceness);
+
+    /**
+     * A more efficient way to map Java priority to Posix niceness.
+     * @hide
+     */
+    // VisibleForTesting
+    @CriticalNative
+    public static native int nicenessForPriority(int priority);
 
     // BEGIN Android-removed: Native methods that are unused on Android.
     /*
@@ -2574,8 +2953,30 @@ class Thread implements Runnable {
     */
     // END Android-removed: Native methods that are unused on Android.
 
+
+    /** The thread container that this thread is in */
+    private @Stable ThreadContainer container;
+    ThreadContainer threadContainer() {
+        return container;
+    }
+    void setThreadContainer(ThreadContainer container) {
+        // assert this.container == null;
+        this.container = container;
+    }
+
+    /** The top of this stack of stackable scopes owned by this thread */
+    private volatile StackableScope headStackableScopes;
+    StackableScope headStackableScopes() {
+        return headStackableScopes;
+    }
+    static void setHeadStackableScope(StackableScope scope) {
+        currentThread().headStackableScopes = scope;
+    }
+
     @FastNative
     private native void interrupt0();
+    // Android-removed: This native method is replaced by the native interrupted() method.
+    // private static native void clearInterruptEvent();
     private native void setNativeName(String name);
 
     // Android-added: Android specific nativeGetStatus() method.
diff --git a/ojluni/src/main/java/java/lang/ThreadGroup.java b/ojluni/src/main/java/java/lang/ThreadGroup.java
index b5dd88f5a52..b3716893662 100644
--- a/ojluni/src/main/java/java/lang/ThreadGroup.java
+++ b/ojluni/src/main/java/java/lang/ThreadGroup.java
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2014 The Android Open Source Project
- * Copyright (c) 1995, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,7 +28,6 @@ package java.lang;
 
 import java.io.PrintStream;
 import java.util.Arrays;
-import jdk.internal.misc.VM;
 
 /**
  * A thread group represents a set of threads. In addition, a thread
@@ -40,7 +39,6 @@ import jdk.internal.misc.VM;
  * group, but not to access information about its thread group's
  * parent thread group or any other thread groups.
  *
- * @author  unascribed
  * @since   1.0
  */
 /* The locking strategy for this code is to try to lock only one level of the
@@ -54,8 +52,7 @@ import jdk.internal.misc.VM;
  * and working off of that snapshot, rather than holding the thread group locked
  * while we work on the children.
  */
-public
-class ThreadGroup implements Thread.UncaughtExceptionHandler {
+public class ThreadGroup implements Thread.UncaughtExceptionHandler {
     /* the runtime uses these directly; do not rename */
     static final ThreadGroup systemThreadGroup = new ThreadGroup();
 
@@ -194,7 +191,13 @@ class ThreadGroup implements Thread.UncaughtExceptionHandler {
      * @return  {@code true} if this thread group is a daemon thread group;
      *          {@code false} otherwise.
      * @since   1.0
+     *
+     * @deprecated The API and mechanism for destroying a ThreadGroup is inherently
+     *             flawed. The ability to explicitly or automatically destroy a
+     *             thread group, and the concept of daemon thread group, will be
+     *             removed in a future release.
      */
+    @Deprecated(since="16", forRemoval=true)
     public final boolean isDaemon() {
         return daemon;
     }
@@ -204,7 +207,12 @@ class ThreadGroup implements Thread.UncaughtExceptionHandler {
      *
      * @return  true if this object is destroyed
      * @since   1.1
+     *
+     * @deprecated The API and mechanism for destroying a ThreadGroup is inherently
+     *             flawed. The ability to explicitly or automatically destroy a
+     *             thread group will be removed in a future release.
      */
+    @Deprecated(since="16", forRemoval=true)
     public synchronized boolean isDestroyed() {
         return destroyed;
     }
@@ -226,7 +234,13 @@ class ThreadGroup implements Thread.UncaughtExceptionHandler {
      * @see        java.lang.SecurityException
      * @see        java.lang.ThreadGroup#checkAccess()
      * @since      1.0
+     *
+     * @deprecated The API and mechanism for destroying a ThreadGroup is inherently
+     *             flawed. The ability to explicitly or automatically destroy a
+     *             thread group, and the concept of daemon thread group, will be
+     *             removed in a future release.
      */
+    @Deprecated(since="16", forRemoval=true)
     public final void setDaemon(boolean daemon) {
         checkAccess();
         this.daemon = daemon;
@@ -321,9 +335,17 @@ class ThreadGroup implements Thread.UncaughtExceptionHandler {
      *               access this thread group.
      * @see        java.lang.SecurityManager#checkAccess(java.lang.ThreadGroup)
      * @since      1.0
+     * @deprecated This method is only useful in conjunction with
+     *       {@linkplain SecurityManager the Security Manager}, which is
+     *       deprecated and subject to removal in a future release.
+     *       Consequently, this method is also deprecated and subject to
+     *       removal. There is no replacement for the Security Manager or this
+     *       method.
      */
+    @Deprecated(since="17", forRemoval=true)
     public final void checkAccess() {
         // Android-removed: SecurityManager stubbed out on Android.
+        // @SuppressWarnings("removal")
         // SecurityManager security = System.getSecurityManager();
         // if (security != null) {
         //     security.checkAccess(this);
@@ -441,7 +463,7 @@ class ThreadGroup implements Thread.UncaughtExceptionHandler {
         ThreadGroup[] groupsSnapshot = null;
         synchronized (this) {
             if (destroyed) {
-                return 0;
+                return n;
             }
             int nt = nthreads;
             if (nt > list.length - n) {
@@ -575,7 +597,7 @@ class ThreadGroup implements Thread.UncaughtExceptionHandler {
         ThreadGroup[] groupsSnapshot = null;
         synchronized (this) {
             if (destroyed) {
-                return 0;
+                return n;
             }
             int ng = ngroups;
             if (ng > list.length - n) {
@@ -621,7 +643,7 @@ class ThreadGroup implements Thread.UncaughtExceptionHandler {
      * @deprecated    This method is inherently unsafe.  See
      *     {@link Thread#stop} for details.
      */
-    @Deprecated(since="1.2")
+    @Deprecated(since="1.2", forRemoval=true)
     public final void stop() {
         if (stopOrSuspend(false))
             Thread.currentThread().stop();
@@ -683,8 +705,8 @@ class ThreadGroup implements Thread.UncaughtExceptionHandler {
      * @deprecated    This method is inherently deadlock-prone.  See
      *     {@link Thread#suspend} for details.
      */
-    @Deprecated(since="1.2")
-    @SuppressWarnings("deprecation")
+    @Deprecated(since="1.2", forRemoval=true)
+    @SuppressWarnings("removal")
     public final void suspend() {
         if (stopOrSuspend(true))
             Thread.currentThread().suspend();
@@ -697,7 +719,7 @@ class ThreadGroup implements Thread.UncaughtExceptionHandler {
      * if (and only if) the current thread is found to be in this thread
      * group or one of its subgroups.
      */
-    @SuppressWarnings("deprecation")
+    @SuppressWarnings({"deprecation", "removal"})
     private boolean stopOrSuspend(boolean suspend) {
         boolean suicide = false;
         Thread us = Thread.currentThread();
@@ -746,8 +768,8 @@ class ThreadGroup implements Thread.UncaughtExceptionHandler {
      *       both of which have been deprecated, as they are inherently
      *       deadlock-prone.  See {@link Thread#suspend} for details.
      */
-    @Deprecated(since="1.2")
-    @SuppressWarnings("deprecation")
+    @Deprecated(since="1.2", forRemoval=true)
+    @SuppressWarnings("removal")
     public final void resume() {
         int ngroupsSnapshot;
         ThreadGroup[] groupsSnapshot;
@@ -782,7 +804,12 @@ class ThreadGroup implements Thread.UncaughtExceptionHandler {
      *               thread group.
      * @see        java.lang.ThreadGroup#checkAccess()
      * @since      1.0
+     *
+     * @deprecated The API and mechanism for destroying a ThreadGroup is inherently
+     *             flawed. The ability to explicitly or automatically destroy a
+     *             thread group will be removed in a future release.
      */
+    @Deprecated(since="16", forRemoval=true)
     public final void destroy() {
         int ngroupsSnapshot;
         ThreadGroup[] groupsSnapshot;
@@ -1087,7 +1114,7 @@ class ThreadGroup implements Thread.UncaughtExceptionHandler {
      *             which is deprecated.  Further, the behavior of this call
      *             was never specified.
      */
-    @Deprecated(since="1.2")
+    @Deprecated(since="1.2", forRemoval=true)
     public boolean allowThreadSuspension(boolean b) {
         return true;
     }
diff --git a/ojluni/src/main/java/java/lang/ThreadLocal.java b/ojluni/src/main/java/java/lang/ThreadLocal.java
index fa2a8aa32d1..f01cfa325a1 100644
--- a/ojluni/src/main/java/java/lang/ThreadLocal.java
+++ b/ojluni/src/main/java/java/lang/ThreadLocal.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,12 +24,16 @@
  */
 
 package java.lang;
-import jdk.internal.misc.TerminatingThreadLocal;
 
-import java.lang.ref.*;
+import java.lang.ref.WeakReference;
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Supplier;
+import java.util.stream.Collectors;
+
+import jdk.internal.misc.CarrierThreadLocal;
+import jdk.internal.misc.TerminatingThreadLocal;
+import sun.security.action.GetPropertyAction;
 
 /**
  * This class provides thread-local variables.  These variables differ from
@@ -69,11 +73,14 @@ import java.util.function.Supplier;
  * instance is accessible; after a thread goes away, all of its copies of
  * thread-local instances are subject to garbage collection (unless other
  * references to these copies exist).
+ * @param <T> the type of the thread local's value
  *
  * @author  Josh Bloch and Doug Lea
  * @since   1.2
  */
 public class ThreadLocal<T> {
+    private static final boolean TRACE_VTHREAD_LOCALS = traceVirtualThreadLocals();
+
     /**
      * ThreadLocals rely on per-thread linear-probe hash maps attached
      * to each thread (Thread.threadLocals and
@@ -90,7 +97,7 @@ public class ThreadLocal<T> {
      * The next hash code to be given out. Updated atomically. Starts at
      * zero.
      */
-    private static AtomicInteger nextHashCode =
+    private static final AtomicInteger nextHashCode =
         new AtomicInteger();
 
     /**
@@ -117,13 +124,16 @@ public class ThreadLocal<T> {
      * most once per thread, but it may be invoked again in case of
      * subsequent invocations of {@link #remove} followed by {@link #get}.
      *
-     * <p>This implementation simply returns {@code null}; if the
+     * @implSpec
+     * This implementation simply returns {@code null}; if the
      * programmer desires thread-local variables to have an initial
-     * value other than {@code null}, {@code ThreadLocal} must be
-     * subclassed, and this method overridden.  Typically, an
-     * anonymous inner class will be used.
+     * value other than {@code null}, then either {@code ThreadLocal}
+     * can be subclassed and this method overridden or the method
+     * {@link ThreadLocal#withInitial(Supplier)} can be used to
+     * construct a {@code ThreadLocal}.
      *
      * @return the initial value for this thread-local
+     * @see #withInitial(java.util.function.Supplier)
      */
     protected T initialValue() {
         return null;
@@ -159,30 +169,50 @@ public class ThreadLocal<T> {
      * @return the current thread's value of this thread-local
      */
     public T get() {
-        Thread t = Thread.currentThread();
+        return get(Thread.currentThread());
+    }
+
+    /**
+     * Returns the value in the current carrier thread's copy of this
+     * thread-local variable.
+     */
+    T getCarrierThreadLocal() {
+        assert this instanceof CarrierThreadLocal<T>;
+        return get(Thread.currentCarrierThread());
+    }
+
+    private T get(Thread t) {
         ThreadLocalMap map = getMap(t);
         if (map != null) {
             ThreadLocalMap.Entry e = map.getEntry(this);
             if (e != null) {
                 @SuppressWarnings("unchecked")
-                T result = (T)e.value;
+                T result = (T) e.value;
                 return result;
             }
         }
-        return setInitialValue();
+        return setInitialValue(t);
     }
 
     /**
-     * Returns {@code true} if there is a value in the current thread's copy of
+     * Returns {@code true} if there is a value in the current carrier thread's copy of
      * this thread-local variable, even if that values is {@code null}.
      *
-     * @return {@code true} if current thread has associated value in this
+     * @return {@code true} if current carrier thread has associated value in this
      *         thread-local variable; {@code false} if not
      */
-    boolean isPresent() {
-        Thread t = Thread.currentThread();
+    boolean isCarrierThreadLocalPresent() {
+        assert this instanceof CarrierThreadLocal<T>;
+        return isPresent(Thread.currentCarrierThread());
+    }
+
+    private boolean isPresent(Thread t) {
         ThreadLocalMap map = getMap(t);
-        return map != null && map.getEntry(this) != null;
+        if (map != null) {
+            return map.getEntry(this) != null;
+        } else {
+            return false;
+        }
     }
 
     /**
@@ -191,17 +221,19 @@ public class ThreadLocal<T> {
      *
      * @return the initial value
      */
-    private T setInitialValue() {
+    private T setInitialValue(Thread t) {
         T value = initialValue();
-        Thread t = Thread.currentThread();
         ThreadLocalMap map = getMap(t);
         if (map != null) {
             map.set(this, value);
         } else {
             createMap(t, value);
         }
-        if (this instanceof TerminatingThreadLocal) {
-            TerminatingThreadLocal.register((TerminatingThreadLocal<?>) this);
+        if (this instanceof TerminatingThreadLocal<?> ttl) {
+            TerminatingThreadLocal.register(ttl);
+        }
+        if (TRACE_VTHREAD_LOCALS) {
+            dumpStackIfVirtualThread();
         }
         return value;
     }
@@ -216,7 +248,18 @@ public class ThreadLocal<T> {
      *        this thread-local.
      */
     public void set(T value) {
-        Thread t = Thread.currentThread();
+        set(Thread.currentThread(), value);
+        if (TRACE_VTHREAD_LOCALS) {
+            dumpStackIfVirtualThread();
+        }
+    }
+
+    void setCarrierThreadLocal(T value) {
+        assert this instanceof CarrierThreadLocal<T>;
+        set(Thread.currentCarrierThread(), value);
+    }
+
+    private void set(Thread t, T value) {
         ThreadLocalMap map = getMap(t);
         if (map != null) {
             map.set(this, value);
@@ -237,7 +280,16 @@ public class ThreadLocal<T> {
      * @since 1.5
      */
      public void remove() {
-         ThreadLocalMap m = getMap(Thread.currentThread());
+         remove(Thread.currentThread());
+     }
+
+     void removeCarrierThreadLocal() {
+         assert this instanceof CarrierThreadLocal<T>;
+         remove(Thread.currentCarrierThread());
+     }
+
+     private void remove(Thread t) {
+         ThreadLocalMap m = getMap(t);
          if (m != null) {
              m.remove(this);
          }
@@ -378,6 +430,12 @@ public class ThreadLocal<T> {
             return ((i - 1 >= 0) ? i - 1 : len - 1);
         }
 
+        /**
+         * Construct a new map without a table.
+         */
+        private ThreadLocalMap() {
+        }
+
         /**
          * Construct a new map initially containing (firstKey, firstValue).
          * ThreadLocalMaps are constructed lazily, so we only create
@@ -440,7 +498,6 @@ public class ThreadLocal<T> {
         private Entry getEntry(ThreadLocal<?> key) {
             int i = key.threadLocalHashCode & (table.length - 1);
             Entry e = table[i];
-            // Android-changed: Use refersTo().
             if (e != null && e.refersTo(key))
                 return e;
             else
@@ -461,7 +518,6 @@ public class ThreadLocal<T> {
             int len = tab.length;
 
             while (e != null) {
-                // Android-changed: Use refersTo() (twice).
                 if (e.refersTo(key))
                     return e;
                 if (e.refersTo(null))
@@ -493,10 +549,6 @@ public class ThreadLocal<T> {
             for (Entry e = tab[i];
                  e != null;
                  e = tab[i = nextIndex(i, len)]) {
-
-                // Android-changed: Use refersTo() (twice).
-                // ThreadLocal<?> k = e.get();
-                // if (k == key) { ... } if (k == null) { ... }
                 if (e.refersTo(key)) {
                     e.value = value;
                     return;
@@ -524,7 +576,6 @@ public class ThreadLocal<T> {
             for (Entry e = tab[i];
                  e != null;
                  e = tab[i = nextIndex(i, len)]) {
-                // Android-changed: Use refersTo().
                 if (e.refersTo(key)) {
                     e.clear();
                     expungeStaleEntry(i);
@@ -562,7 +613,6 @@ public class ThreadLocal<T> {
             for (int i = prevIndex(staleSlot, len);
                  (e = tab[i]) != null;
                  i = prevIndex(i, len))
-                // Android-changed: Use refersTo().
                 if (e.refersTo(null))
                     slotToExpunge = i;
 
@@ -571,14 +621,11 @@ public class ThreadLocal<T> {
             for (int i = nextIndex(staleSlot, len);
                  (e = tab[i]) != null;
                  i = nextIndex(i, len)) {
-                // ThreadLocal<?> k = e.get();
-
                 // If we find key, then we need to swap it
                 // with the stale entry to maintain hash table order.
                 // The newly stale slot, or any other stale slot
                 // encountered above it, can then be sent to expungeStaleEntry
                 // to remove or rehash all of the other entries in run.
-                // Android-changed: Use refersTo().
                 if (e.refersTo(key)) {
                     e.value = value;
 
@@ -595,7 +642,6 @@ public class ThreadLocal<T> {
                 // If we didn't find stale entry on backward scan, the
                 // first stale entry seen while scanning for key is the
                 // first still present in the run.
-                // Android-changed: Use refersTo().
                 if (e.refersTo(null) && slotToExpunge == staleSlot)
                     slotToExpunge = i;
             }
@@ -687,7 +733,6 @@ public class ThreadLocal<T> {
             do {
                 i = nextIndex(i, len);
                 Entry e = tab[i];
-                // Android-changed: Use refersTo().
                 if (e != null && e.refersTo(null)) {
                     n = len;
                     removed = true;
@@ -748,10 +793,58 @@ public class ThreadLocal<T> {
             int len = tab.length;
             for (int j = 0; j < len; j++) {
                 Entry e = tab[j];
-                // Android-changed: Use refersTo().
                 if (e != null && e.refersTo(null))
                     expungeStaleEntry(j);
             }
         }
     }
+
+
+    /**
+     * Reads the value of the jdk.traceVirtualThreadLocals property to determine if
+     * a stack trace should be printed when a virtual thread sets a thread local.
+     */
+    private static boolean traceVirtualThreadLocals() {
+        // Android-changed: The tracing is always disabled on Android.
+        /*
+        String propValue = GetPropertyAction.privilegedGetProperty("jdk.traceVirtualThreadLocals");
+        return (propValue != null)
+                && (propValue.isEmpty() || Boolean.parseBoolean(propValue));
+        */
+        return false;
+    }
+
+    /**
+     * Print a stack trace if the current thread is a virtual thread.
+     */
+    static void dumpStackIfVirtualThread() {
+        // Android-removed: The tracing is always disabled on Android.
+        /*
+        if (Thread.currentThread() instanceof VirtualThread vthread) {
+            try {
+                var stack = StackWalkerHolder.STACK_WALKER.walk(s ->
+                        s.skip(1)  // skip caller
+                         .collect(Collectors.toList()));
+
+                // switch to carrier thread to avoid recursive use of thread-locals
+                vthread.executeOnCarrierThread(() -> {
+                    System.out.println(vthread);
+                    for (StackWalker.StackFrame frame : stack) {
+                        System.out.format("    %s%n", frame.toStackTraceElement());
+                    }
+                    return null;
+                });
+            } catch (Exception e) {
+                throw new InternalError(e);
+            }
+        }
+        */
+    }
+
+    // Android-removed: The tracing is always disabled on Android.
+    /*
+    private static class StackWalkerHolder {
+        static final StackWalker STACK_WALKER = StackWalker.getInstance();
+    }
+    */
 }
diff --git a/ojluni/src/main/java/java/lang/VirtualThread.java b/ojluni/src/main/java/java/lang/VirtualThread.java
new file mode 100644
index 00000000000..4ec6ca2e38e
--- /dev/null
+++ b/ojluni/src/main/java/java/lang/VirtualThread.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2018, 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package java.lang;
+
+import jdk.internal.vm.ContinuationScope;
+
+final class VirtualThread {
+    private static final ContinuationScope VTHREAD_SCOPE = new ContinuationScope("VirtualThreads");
+
+    /**
+     * Returns the continuation scope used for virtual threads.
+     */
+    static ContinuationScope continuationScope() {
+        return VTHREAD_SCOPE;
+    }
+}
diff --git a/ojluni/src/main/java/java/lang/WrongThreadException.java b/ojluni/src/main/java/java/lang/WrongThreadException.java
new file mode 100644
index 00000000000..a982b878566
--- /dev/null
+++ b/ojluni/src/main/java/java/lang/WrongThreadException.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2021, 2022, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package java.lang;
+
+/**
+ * Thrown to indicate that a method has been called on the wrong thread.
+ *
+ * @since 19
+ */
+public final class WrongThreadException extends RuntimeException {
+    @java.io.Serial
+    static final long serialVersionUID = 4676498871006316905L;
+
+    /**
+     * Constructs a WrongThreadException with no detail message.
+     */
+    public WrongThreadException() {
+        super();
+    }
+
+    /**
+     * Constructs a WrongThreadException with the given detail message.
+     *
+     * @param s the String that contains a detailed message, can be null
+     */
+    public WrongThreadException(String s) {
+        super(s);
+    }
+
+    /**
+     * Constructs a WrongThreadException with the given detail message and cause.
+     *
+     * @param  message the detail message, can be null
+     * @param  cause the cause, can be null
+     */
+    public WrongThreadException(String message, Throwable cause) {
+        super(message, cause);
+    }
+
+    /**
+     * Constructs a WrongThreadException with the given cause and a detail
+     * message of {@code (cause==null ? null : cause.toString())} (which
+     * typically contains the class and detail message of {@code cause}).
+     *
+     * @param  cause the cause, can be null
+     */
+    public WrongThreadException(Throwable cause) {
+        super(cause);
+    }
+}
diff --git a/ojluni/src/main/java/java/lang/constant/MethodTypeDesc.java b/ojluni/src/main/java/java/lang/constant/MethodTypeDesc.java
index 4750231ce37..24d510770c4 100644
--- a/ojluni/src/main/java/java/lang/constant/MethodTypeDesc.java
+++ b/ojluni/src/main/java/java/lang/constant/MethodTypeDesc.java
@@ -90,7 +90,7 @@ public sealed interface MethodTypeDesc
      * @param index the index of the parameter to retrieve
      * @return a {@link ClassDesc} describing the desired parameter type
      * @throws IndexOutOfBoundsException if the index is outside the half-open
-     * range {[0, parameterCount())}
+     * range {@code [0, parameterCount())}
      */
     ClassDesc parameterType(int index);
 
@@ -127,7 +127,7 @@ public sealed interface MethodTypeDesc
      * @return a {@linkplain MethodTypeDesc} describing the desired method type
      * @throws NullPointerException if any argument is {@code null}
      * @throws IndexOutOfBoundsException if the index is outside the half-open
-     * range {[0, parameterCount)}
+     * range {@code [0, parameterCount)}
      */
     MethodTypeDesc changeParameterType(int index, ClassDesc paramType);
 
@@ -154,7 +154,7 @@ public sealed interface MethodTypeDesc
      * @return a {@linkplain MethodTypeDesc} describing the desired method type
      * @throws NullPointerException if any argument or its contents are {@code null}
      * @throws IndexOutOfBoundsException if {@code pos} is outside the closed
-     * range {[0, parameterCount]}
+     * range {@code [0, parameterCount]}
      * @throws IllegalArgumentException if any element of {@code paramTypes}
      * is a {@link ClassDesc} for {@code void}
      */
diff --git a/ojluni/src/main/java/java/lang/invoke/MethodHandle.java b/ojluni/src/main/java/java/lang/invoke/MethodHandle.java
index b03b769eeb5..98d0f96742e 100644
--- a/ojluni/src/main/java/java/lang/invoke/MethodHandle.java
+++ b/ojluni/src/main/java/java/lang/invoke/MethodHandle.java
@@ -699,7 +699,7 @@ public abstract class MethodHandle {
         // BEGIN Android-changed: Android specific implementation.
         // return invocationType.invokers().spreadInvoker(0).invokeExact(asType(invocationType), arguments);
         MethodHandle invoker = cachedSpreadInvoker;
-        if (invoker == null || !invoker.type().equals(invocationType)) {
+        if (invoker == null || invoker.type() != invocationType) {
             invoker = MethodHandles.spreadInvoker(invocationType, 0);
             cachedSpreadInvoker = invoker;
         }
@@ -830,8 +830,7 @@ public abstract class MethodHandle {
     public MethodHandle asType(MethodType newType) {
         // Fast path alternative to a heavyweight {@code asType} call.
         // Return 'this' if the conversion will be a no-op.
-        // Android-changed: use equals() rather than = since MethodTypes are not interned.
-        if (newType.equals(type)) {
+        if (newType == type) {
             return this;
         }
         // Return 'this.asTypeCache' if the conversion is already memoized.
@@ -844,8 +843,7 @@ public abstract class MethodHandle {
 
     private MethodHandle asTypeCached(MethodType newType) {
         MethodHandle atc = asTypeCache;
-        // Android-changed: use equals() rather than = since MethodTypes are not interned.
-        if (atc != null && newType.equals(atc.type)) {
+        if (atc != null && newType == atc.type) {
             return atc;
         }
         return null;
diff --git a/ojluni/src/main/java/java/lang/invoke/MethodHandleImpl.java b/ojluni/src/main/java/java/lang/invoke/MethodHandleImpl.java
index 8a2fa8bf622..9aa1692ab1e 100644
--- a/ojluni/src/main/java/java/lang/invoke/MethodHandleImpl.java
+++ b/ojluni/src/main/java/java/lang/invoke/MethodHandleImpl.java
@@ -43,14 +43,16 @@ public class MethodHandleImpl extends MethodHandle implements Cloneable {
     // TODO(b/297147201): create separate AccessorMethodHandle class and move target and field
     // into it.
     // Used by runtime only.
-    private final long target;
+    // For compat reasons this field is named in such a way that offsets of existing fields in
+    // the class's memory layout are the same as before.
+    private final long targetMethodEntry;
     private Object targetClassOrMethodHandleInfo;
     Field field;
 
     MethodHandleImpl(long artFieldOrMethod, int handleKind, MethodType type) {
         super(artFieldOrMethod, handleKind, type);
         this.targetClassOrMethodHandleInfo = getMemberInternal().getDeclaringClass();
-        this.target = 0;
+        this.targetMethodEntry = 0;
     }
 
     MethodHandleImpl(Field field, int handleKind, MethodType type) {
@@ -60,7 +62,7 @@ public class MethodHandleImpl extends MethodHandle implements Cloneable {
         MethodHandleStatics.UNSAFE.ensureClassInitialized(field.getDeclaringClass());
         this.targetClassOrMethodHandleInfo = getMemberInternal().getDeclaringClass();
         this.field = field;
-        this.target = resolveTarget(handleKind, field);
+        this.targetMethodEntry = resolveTarget(handleKind, field);
     }
 
     private static long resolveTarget(int handleKind, Field field) {
diff --git a/ojluni/src/main/java/java/lang/invoke/MethodHandles.java b/ojluni/src/main/java/java/lang/invoke/MethodHandles.java
index 7bd59b2de6b..23466bc1c4a 100644
--- a/ojluni/src/main/java/java/lang/invoke/MethodHandles.java
+++ b/ojluni/src/main/java/java/lang/invoke/MethodHandles.java
@@ -1468,7 +1468,7 @@ assertEquals(""+l, (String) MH_this.invokeExact(subl)); // Listie method
                 // either.
                 if (refc != lookupClass()) {
                     throw new IllegalAccessException("no private access for invokespecial : "
-                            + refc + ", from" + this);
+                            + refc + ", from " + this);
                 }
 
                 // This is a private method, so there's nothing special to do.
@@ -1483,6 +1483,10 @@ assertEquals(""+l, (String) MH_this.invokeExact(subl)); // Listie method
                 throw new IllegalAccessException(refc + "is not assignable from " + specialCaller);
             }
 
+            if (Modifier.isAbstract(method.getModifiers())) {
+                throw new IllegalAccessException("no such method: " + method + "/invokeSpecial");
+            }
+
             // Note that we restrict the receiver to "specialCaller" instances.
             MethodType handleType = type.insertParameterTypes(0, specialCaller);
             return createMethodHandle(method, MethodHandle.INVOKE_SUPER, handleType);
@@ -1528,6 +1532,10 @@ assertEquals(""+l, (String) MH_this.invokeExact(subl)); // Listie method
                 }
             }
 
+            if (isSetterKind && field.isMonotonic()) {
+                throw new IllegalAccessException("Field " + field + " can't be overwritten");
+            }
+
             final MethodType methodType;
             switch (kind) {
                 case MethodHandle.SGET:
@@ -2258,7 +2266,7 @@ return mh1;
                                          refc.isAssignableFrom(specialCaller));
             if (!hasPrivateAccess() || (specialCaller != lookupClass() && !isInterfaceLookup)) {
                 throw new IllegalAccessException("no private access for invokespecial : "
-                        + specialCaller + ", from" + this);
+                        + specialCaller + ", from " + this);
             }
         }
 
@@ -4213,7 +4221,7 @@ assertEquals("boojum", (String) catTrace.invokeExact("boo", "jum"));
         MethodType gtype = test.type();
         MethodType ttype = target.type();
         MethodType ftype = fallback.type();
-        if (!ttype.equals(ftype))
+        if (ttype != ftype)
             throw misMatchedTypes("target and fallback types", ttype, ftype);
         if (gtype.returnType() != boolean.class)
             throw newIllegalArgumentException("guard type is not a predicate "+gtype);
@@ -5867,9 +5875,7 @@ assertEquals("boojum", (String) catTrace.invokeExact("boo", "jum"));
 
         for (MethodHandle mh : caseActions) {
             Objects.requireNonNull(mh);
-            // Android-changed: MethodType's not interned.
-            // if (mh.type() != expectedType)
-            if (!mh.type().equals(expectedType))
+            if (mh.type() != expectedType)
                 throw new IllegalArgumentException(
                     "Case actions must have the same type: " + Arrays.toString(caseActions));
         }
diff --git a/ojluni/src/main/java/java/lang/reflect/Field.java b/ojluni/src/main/java/java/lang/reflect/Field.java
index 54394f8b082..87f7d9d1401 100644
--- a/ojluni/src/main/java/java/lang/reflect/Field.java
+++ b/ojluni/src/main/java/java/lang/reflect/Field.java
@@ -941,6 +941,23 @@ class Field extends AccessibleObject implements Member {
     public native Annotation[] getDeclaredAnnotations();
 
     // BEGIN Android-added: Methods for use by Android-specific code.
+    /**
+     * Returns true if value of the field can be set only once. Write-protected fields are assumed
+     * to be unmodifiable here.
+     *
+     * @hide
+     */
+    public boolean isMonotonic() {
+        if (declaringClass == System.class) {
+            String name = getName();
+            return name.equals("in") || name.equals("out") || name.equals("err");
+        }
+
+        return isMonotonic0();
+    }
+
+    private native boolean isMonotonic0();
+
     /**
      * Returns the offset of the field within an instance, or for static fields, the class.
      *
diff --git a/ojluni/src/main/java/java/math/MutableBigInteger.java b/ojluni/src/main/java/java/math/MutableBigInteger.java
index f0dae7a07f7..7d0ccbf1e09 100644
--- a/ojluni/src/main/java/java/math/MutableBigInteger.java
+++ b/ojluni/src/main/java/java/math/MutableBigInteger.java
@@ -2106,6 +2106,7 @@ class MutableBigInteger {
 
         oddPart.leftShift(powersOf2);
         oddPart.multiply(y1, result);
+        oddPart.clear();
 
         evenPart.multiply(oddMod, temp1);
         temp1.multiply(y2, temp2);
diff --git a/ojluni/src/main/java/java/net/SocketPermission.java b/ojluni/src/main/java/java/net/SocketPermission.java
index 97346cd285d..8cac1b0ba04 100644
--- a/ojluni/src/main/java/java/net/SocketPermission.java
+++ b/ojluni/src/main/java/java/net/SocketPermission.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,14 +33,19 @@ import java.security.Permission;
 /**
  * Legacy security code; do not use.
  */
-
 public final class SocketPermission extends Permission
-implements java.io.Serializable
-{
+implements java.io.Serializable {
+
+    public SocketPermission(String host, String action) {
+        super("");
+    }
 
-    public SocketPermission(String host, String action) { super(""); }
+    public boolean implies(Permission p) {
+        return true;
+    }
 
-    public boolean implies(Permission p) { return true; }
+    public String getActions() {
+        return null;
+    }
 
-    public String getActions() { return null; }
 }
diff --git a/ojluni/src/main/java/java/nio/Direct-X-Buffer.java.template b/ojluni/src/main/java/java/nio/Direct-X-Buffer.java.template
index 4c540d324a0..91ad40b7b7e 100644
--- a/ojluni/src/main/java/java/nio/Direct-X-Buffer.java.template
+++ b/ojluni/src/main/java/java/nio/Direct-X-Buffer.java.template
@@ -134,7 +134,14 @@ class Direct$Type$Buffer$RW$$BO$
         } else {
             address = base;
         }
-        cleaner = Cleaner.create(this, new Deallocator(base, size, cap));
+        try {
+            cleaner = Cleaner.create(this, new Deallocator(base, size, cap));
+        } catch (Throwable t) {
+            // Prevent leak if the Deallocator or Cleaner fail for any reason
+            UNSAFE.freeMemory(base);
+            Bits.unreserveMemory(size, cap);
+            throw t;
+        }
         att = null;
 #else[rw]
         super(cap);
diff --git a/ojluni/src/main/java/java/nio/DirectByteBuffer.java b/ojluni/src/main/java/java/nio/DirectByteBuffer.java
index 717c2f4dc36..49a4d947a69 100644
--- a/ojluni/src/main/java/java/nio/DirectByteBuffer.java
+++ b/ojluni/src/main/java/java/nio/DirectByteBuffer.java
@@ -128,6 +128,21 @@ public class DirectByteBuffer extends MappedByteBuffer implements DirectBuffer {
         memoryRef = new MemoryRef(addr, null);
         address = addr;
         cleaner = Cleaner.create(memoryRef, unmapper);
+        // TODO: Consider unmapping the memory if OOME is thrown. See JDK-8294717.
+        // However, this constructor is a @SystemApi and existing client code may handle OOME and
+        // unmap the memory. If we incorporate this change, the memory could be unmapped twice.
+        // We need to guard this change with an platform compat flag.
+        /*
+        try {
+            memoryRef = new MemoryRef(addr, null);
+            cleaner = Cleaner.create(memoryRef, unmapper);
+        } catch (Throwable t) {
+            if (unmapper != null) {
+                unmapper.run();
+            }
+            throw t;
+        }
+        */
     }
     // END Android-changed: Remove MemorySegmentProxy and merge with read-only buffer.
 
diff --git a/ojluni/src/main/java/java/nio/file/FileChannelLinesSpliterator.java b/ojluni/src/main/java/java/nio/file/FileChannelLinesSpliterator.java
new file mode 100644
index 00000000000..0d3d8c2ab96
--- /dev/null
+++ b/ojluni/src/main/java/java/nio/file/FileChannelLinesSpliterator.java
@@ -0,0 +1,271 @@
+/*
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package java.nio.file;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.UncheckedIOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.Channels;
+import java.nio.channels.FileChannel;
+import java.nio.channels.ReadableByteChannel;
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.Spliterator;
+import java.util.function.Consumer;
+
+/**
+ * A file-based lines spliterator, leveraging a shared mapped byte buffer and
+ * associated file channel, covering lines of a file for character encodings
+ * where line feed characters can be easily identified from character encoded
+ * bytes.
+ *
+ * <p>
+ * When the root spliterator is first split a mapped byte buffer will be created
+ * over the file for it's size that was observed when the stream was created.
+ * Thus a mapped byte buffer is only required for parallel stream execution.
+ * Sub-spliterators will share that mapped byte buffer.  Splitting will use the
+ * mapped byte buffer to find the closest line feed characters(s) to the left or
+ * right of the mid-point of covered range of bytes of the file.  If a line feed
+ * is found then the spliterator is split with returned spliterator containing
+ * the identified line feed characters(s) at the end of it's covered range of
+ * bytes.
+ *
+ * <p>
+ * Traversing will create a buffered reader, derived from the file channel, for
+ * the range of bytes of the file.  The lines are then read from that buffered
+ * reader.  Once traversing commences no further splitting can be performed and
+ * the reference to the mapped byte buffer will be set to null.
+ */
+final class FileChannelLinesSpliterator implements Spliterator<String> {
+
+    static final Set<String> SUPPORTED_CHARSET_NAMES;
+    static {
+        SUPPORTED_CHARSET_NAMES = new HashSet<>();
+        // Android-changed: Use StandardCharsets.
+        // SUPPORTED_CHARSET_NAMES.add(UTF_8.INSTANCE.name());
+        // SUPPORTED_CHARSET_NAMES.add(ISO_8859_1.INSTANCE.name());
+        // SUPPORTED_CHARSET_NAMES.add(US_ASCII.INSTANCE.name());
+        SUPPORTED_CHARSET_NAMES.add(StandardCharsets.UTF_8.name());
+        SUPPORTED_CHARSET_NAMES.add(StandardCharsets.ISO_8859_1.name());
+        SUPPORTED_CHARSET_NAMES.add(StandardCharsets.US_ASCII.name());
+    }
+
+    private final FileChannel fc;
+    private final Charset cs;
+    private int index;
+    private final int fence;
+
+    // Null before first split, non-null when splitting, null when traversing
+    private ByteBuffer buffer;
+    // Non-null when traversing
+    private BufferedReader reader;
+
+    FileChannelLinesSpliterator(FileChannel fc, Charset cs, int index, int fence) {
+        this.fc = fc;
+        this.cs = cs;
+        this.index = index;
+        this.fence = fence;
+    }
+
+    private FileChannelLinesSpliterator(FileChannel fc, Charset cs, int index, int fence, ByteBuffer buffer) {
+        this.fc = fc;
+        this.buffer = buffer;
+        this.cs = cs;
+        this.index = index;
+        this.fence = fence;
+    }
+
+    @Override
+    public boolean tryAdvance(Consumer<? super String> action) {
+        String line = readLine();
+        if (line != null) {
+            action.accept(line);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public void forEachRemaining(Consumer<? super String> action) {
+        String line;
+        while ((line = readLine()) != null) {
+            action.accept(line);
+        }
+    }
+
+    private BufferedReader getBufferedReader() {
+        /**
+         * A readable byte channel that reads bytes from an underlying
+         * file channel over a specified range.
+         */
+        ReadableByteChannel rrbc = new ReadableByteChannel() {
+            @Override
+            public int read(ByteBuffer dst) throws IOException {
+                int bytesToRead = fence - index;
+                if (bytesToRead == 0)
+                    return -1;
+
+                int bytesRead;
+                if (bytesToRead < dst.remaining()) {
+                    // The number of bytes to read is less than remaining
+                    // bytes in the buffer
+                    // Snapshot the limit, reduce it, read, then restore
+                    int oldLimit = dst.limit();
+                    dst.limit(dst.position() + bytesToRead);
+                    bytesRead = fc.read(dst, index);
+                    dst.limit(oldLimit);
+                } else {
+                    bytesRead = fc.read(dst, index);
+                }
+                if (bytesRead == -1) {
+                    index = fence;
+                    return bytesRead;
+                }
+
+                index += bytesRead;
+                return bytesRead;
+            }
+
+            @Override
+            public boolean isOpen() {
+                return fc.isOpen();
+            }
+
+            @Override
+            public void close() throws IOException {
+                fc.close();
+            }
+        };
+        return new BufferedReader(Channels.newReader(rrbc, cs.newDecoder(), -1));
+    }
+
+    private String readLine() {
+        if (reader == null) {
+            reader = getBufferedReader();
+            buffer = null;
+        }
+
+        try {
+            return reader.readLine();
+        } catch (IOException e) {
+            throw new UncheckedIOException(e);
+        }
+    }
+
+    private ByteBuffer getMappedByteBuffer() {
+        // TODO can the mapped byte buffer be explicitly unmapped?
+        // It's possible, via a shared-secret mechanism, when either
+        // 1) the spliterator starts traversing, although traversal can
+        //    happen concurrently for mulitple spliterators, so care is
+        //    needed in this case; or
+        // 2) when the stream is closed using some shared holder to pass
+        //    the mapped byte buffer when it is created.
+        try {
+            return fc.map(FileChannel.MapMode.READ_ONLY, 0, fence);
+        } catch (IOException e) {
+            throw new UncheckedIOException(e);
+        }
+    }
+
+    @Override
+    public Spliterator<String> trySplit() {
+        // Cannot split after partial traverse
+        if (reader != null)
+            return null;
+
+        ByteBuffer b;
+        if ((b = buffer) == null) {
+            b = buffer = getMappedByteBuffer();
+        }
+
+        final int hi = fence, lo = index;
+
+        // Check if line separator hits the mid point
+        int mid = (lo + hi) >>> 1;
+        int c =  b.get(mid);
+        if (c == '\n') {
+            mid++;
+        } else if (c == '\r') {
+            // Check if a line separator of "\r\n"
+            if (++mid < hi && b.get(mid) == '\n') {
+                mid++;
+            }
+        } else {
+            // TODO give up after a certain distance from the mid point?
+            // Scan to the left and right of the mid point
+            int midL = mid - 1;
+            int midR = mid + 1;
+            mid = 0;
+            while (midL > lo && midR < hi) {
+                // Sample to the left
+                c = b.get(midL--);
+                if (c == '\n' || c == '\r') {
+                    // If c is "\r" then no need to check for "\r\n"
+                    // since the subsequent value was previously checked
+                    mid = midL + 2;
+                    break;
+                }
+
+                // Sample to the right
+                c = b.get(midR++);
+                if (c == '\n' || c == '\r') {
+                    mid = midR;
+                    // Check if line-separator is "\r\n"
+                    if (c == '\r' && mid < hi && b.get(mid) == '\n') {
+                        mid++;
+                    }
+                    break;
+                }
+            }
+        }
+
+        // The left spliterator will have the line-separator at the end
+        return (mid > lo && mid < hi)
+               ? new FileChannelLinesSpliterator(fc, cs, lo, index = mid, b)
+               : null;
+    }
+
+    @Override
+    public long estimateSize() {
+        // Use the number of bytes as an estimate.
+        // We could divide by a constant that is the average number of
+        // characters per-line, but that constant will be factored out.
+        return fence - index;
+    }
+
+    @Override
+    public long getExactSizeIfKnown() {
+        return -1;
+    }
+
+    @Override
+    public int characteristics() {
+        return Spliterator.ORDERED | Spliterator.NONNULL;
+    }
+}
diff --git a/ojluni/src/main/java/java/nio/file/FileSystems.java b/ojluni/src/main/java/java/nio/file/FileSystems.java
index a38aaae63b6..1b9cdc5895e 100644
--- a/ojluni/src/main/java/java/nio/file/FileSystems.java
+++ b/ojluni/src/main/java/java/nio/file/FileSystems.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -30,8 +30,14 @@ import java.net.URI;
 import java.io.IOException;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
-import java.util.*;
 import java.lang.reflect.Constructor;
+import java.util.Collections;
+import java.util.Map;
+import java.util.ServiceConfigurationError;
+import java.util.ServiceLoader;
+
+import jdk.internal.misc.VM;
+import sun.nio.fs.DefaultFileSystemProvider;
 
 /**
  * Factory methods for file systems. This class defines the {@link #getDefault
@@ -45,16 +51,15 @@ import java.lang.reflect.Constructor;
  * machine. If the process of loading or initializing the default provider fails
  * then an unspecified error is thrown.
  *
- * <p> The first invocation of the {@link FileSystemProvider#installedProviders
+ * <p> The first invocation of the {@link FileSystemProvider#installedProviders()
  * installedProviders} method, by way of invoking any of the {@code
  * newFileSystem} methods defined by this class, locates and loads all
  * installed file system providers. Installed providers are loaded using the
  * service-provider loading facility defined by the {@link ServiceLoader} class.
  * Installed providers are loaded using the system class loader. If the
- * system class loader cannot be found then the extension class loader is used;
- * if there is no extension class loader then the bootstrap class loader is used.
+ * system class loader cannot be found then the platform class loader is used.
  * Providers are typically installed by placing them in a JAR file on the
- * application class path or in the extension directory, the JAR file contains a
+ * application class path, the JAR file contains a
  * provider-configuration file named {@code java.nio.file.spi.FileSystemProvider}
  * in the resource directory {@code META-INF/services}, and the file lists one or
  * more fully-qualified names of concrete subclass of {@link FileSystemProvider}
@@ -82,9 +87,9 @@ import java.lang.reflect.Constructor;
  */
 
 public final class FileSystems {
-    private FileSystems() {
-    }
-
+    private FileSystems() { }
+    // Android-removed: java.nio.file.spi.DefaultFileSystemProvider property isn't supported.
+    /*
     // lazy initialization of default file system
     private static class DefaultFileSystemHolder {
         static final FileSystem defaultFileSystem = defaultFileSystem();
@@ -92,8 +97,9 @@ public final class FileSystems {
         // returns default file system
         private static FileSystem defaultFileSystem() {
             // load default provider
+            @SuppressWarnings("removal")
             FileSystemProvider provider = AccessController
-                .doPrivileged(new PrivilegedAction<FileSystemProvider>() {
+                .doPrivileged(new PrivilegedAction<>() {
                     public FileSystemProvider run() {
                         return getDefaultProvider();
                     }
@@ -105,12 +111,13 @@ public final class FileSystems {
 
         // returns default provider
         private static FileSystemProvider getDefaultProvider() {
-            FileSystemProvider provider = sun.nio.fs.DefaultFileSystemProvider.create();
+            // start with the platform's default file system provider
+            FileSystemProvider provider = DefaultFileSystemProvider.instance();
 
             // if the property java.nio.file.spi.DefaultFileSystemProvider is
             // set then its value is the name of the default provider (or a list)
-            String propValue = System
-                .getProperty("java.nio.file.spi.DefaultFileSystemProvider");
+            String prop = "java.nio.file.spi.DefaultFileSystemProvider";
+            String propValue = System.getProperty(prop);
             if (propValue != null) {
                 for (String cn: propValue.split(",")) {
                     try {
@@ -132,6 +139,7 @@ public final class FileSystems {
             return provider;
         }
     }
+    */
 
     /**
      * Returns the default {@code FileSystem}. The default file system creates
@@ -173,7 +181,16 @@ public final class FileSystems {
      * @return  the default file system
      */
     public static FileSystem getDefault() {
-        return DefaultFileSystemHolder.defaultFileSystem;
+        // Android-changed: java.nio.file.spi.DefaultFileSystemProvider property isn't supported.
+        /*
+        if (VM.isModuleSystemInited()) {
+            return DefaultFileSystemHolder.defaultFileSystem;
+        } else {
+            // always use the platform's default file system during startup
+            return DefaultFileSystemProvider.theFileSystem();
+        }
+        */
+        return DefaultFileSystemProvider.theFileSystem();
     }
 
     /**
@@ -216,6 +233,9 @@ public final class FileSystems {
      */
     public static FileSystem getFileSystem(URI uri) {
         String scheme = uri.getScheme();
+        if (scheme == null) {
+            throw new IllegalArgumentException(uri.toString());
+        }
         for (FileSystemProvider provider: FileSystemProvider.installedProviders()) {
             if (scheme.equalsIgnoreCase(provider.getScheme())) {
                 return provider.getFileSystem(uri);
@@ -242,10 +262,8 @@ public final class FileSystems {
      * Suppose there is a provider identified by the scheme {@code "memory"}
      * installed:
      * <pre>
-     *   Map&lt;String,String&gt; env = new HashMap&lt;&gt;();
-     *   env.put("capacity", "16G");
-     *   env.put("blockSize", "4k");
-     *   FileSystem fs = FileSystems.newFileSystem(URI.create("memory:///?name=logfs"), env);
+     *  FileSystem fs = FileSystems.newFileSystem(URI.create("memory:///?name=logfs"),
+     *                                            Map.of("capacity", "16G", "blockSize", "4k"));
      * </pre>
      *
      * @param   uri
@@ -321,9 +339,12 @@ public final class FileSystems {
         String scheme = uri.getScheme();
 
         // check installed providers
-        for (FileSystemProvider provider: FileSystemProvider.installedProviders()) {
+        for (FileSystemProvider provider : FileSystemProvider.installedProviders()) {
             if (scheme.equalsIgnoreCase(provider.getScheme())) {
-                return provider.newFileSystem(uri, env);
+                try {
+                    return provider.newFileSystem(uri, env);
+                } catch (UnsupportedOperationException uoe) {
+                }
             }
         }
 
@@ -331,9 +352,12 @@ public final class FileSystems {
         if (loader != null) {
             ServiceLoader<FileSystemProvider> sl = ServiceLoader
                 .load(FileSystemProvider.class, loader);
-            for (FileSystemProvider provider: sl) {
+            for (FileSystemProvider provider : sl) {
                 if (scheme.equalsIgnoreCase(provider.getScheme())) {
-                    return provider.newFileSystem(uri, env);
+                    try {
+                        return provider.newFileSystem(uri, env);
+                    } catch (UnsupportedOperationException uoe) {
+                    }
                 }
             }
         }
@@ -341,6 +365,122 @@ public final class FileSystems {
         throw new ProviderNotFoundException("Provider \"" + scheme + "\" not found");
     }
 
+    /**
+     * Constructs a new {@code FileSystem} to access the contents of a file as a
+     * file system.
+     *
+     * <p> This method makes use of specialized providers that create pseudo file
+     * systems where the contents of one or more files is treated as a file
+     * system.
+     *
+     * <p> This method first attempts to locate an installed provider in exactly
+     * the same manner as the {@link #newFileSystem(Path, Map, ClassLoader)
+     * newFileSystem(Path, Map, ClassLoader)} method with an empty map. If none
+     * of the installed providers return a {@code FileSystem} then an attempt is
+     * made to locate the provider using the given class loader. If a provider
+     * returns a file system then the lookup terminates and the file system is
+     * returned.
+     *
+     * @param   path
+     *          the path to the file
+     * @param   loader
+     *          the class loader to locate the provider or {@code null} to only
+     *          attempt to locate an installed provider
+     *
+     * @return  a new file system
+     *
+     * @throws  ProviderNotFoundException
+     *          if a provider supporting this file type cannot be located
+     * @throws  ServiceConfigurationError
+     *          when an error occurs while loading a service provider
+     * @throws  IOException
+     *          if an I/O error occurs
+     * @throws  SecurityException
+     *          if a security manager is installed and it denies an unspecified
+     *          permission
+     */
+    public static FileSystem newFileSystem(Path path,
+                                           ClassLoader loader)
+        throws IOException
+    {
+        return newFileSystem(path, Map.of(), loader);
+    }
+
+    /**
+     * Constructs a new {@code FileSystem} to access the contents of a file as a
+     * file system.
+     *
+     * <p> This method makes use of specialized providers that create pseudo file
+     * systems where the contents of one or more files is treated as a file
+     * system.
+     *
+     * <p> This method first attempts to locate an installed provider in exactly
+     * the same manner as the {@link #newFileSystem(Path,Map,ClassLoader)
+     * newFileSystem(Path, Map, ClassLoader)} method. If found, the provider's
+     * {@link FileSystemProvider#newFileSystem(Path, Map) newFileSystem(Path, Map)}
+     * method is invoked to construct the new file system.
+     *
+     * @param   path
+     *          the path to the file
+     * @param   env
+     *          a map of provider specific properties to configure the file system;
+     *          may be empty
+     *
+     * @return  a new file system
+     *
+     * @throws  ProviderNotFoundException
+     *          if a provider supporting this file type cannot be located
+     * @throws  ServiceConfigurationError
+     *          when an error occurs while loading a service provider
+     * @throws  IOException
+     *          if an I/O error occurs
+     * @throws  SecurityException
+     *          if a security manager is installed and it denies an unspecified
+     *          permission
+     *
+     * @since 13
+     */
+    public static FileSystem newFileSystem(Path path, Map<String,?> env)
+        throws IOException
+    {
+        return newFileSystem(path, env, null);
+    }
+
+    /**
+     * Constructs a new {@code FileSystem} to access the contents of a file as a
+     * file system.
+     *
+     * <p> This method makes use of specialized providers that create pseudo file
+     * systems where the contents of one or more files is treated as a file
+     * system.
+     *
+     * <p> This method first attempts to locate an installed provider in exactly
+     * the same manner as the {@link #newFileSystem(Path,Map,ClassLoader)
+     * newFileSystem(Path, Map, ClassLoader)} method. If found, the provider's
+     * {@link FileSystemProvider#newFileSystem(Path, Map) newFileSystem(Path, Map)}
+     * method is invoked with an empty map to construct the new file system.
+     *
+     * @param   path
+     *          the path to the file
+     *
+     * @return  a new file system
+     *
+     * @throws  ProviderNotFoundException
+     *          if a provider supporting this file type cannot be located
+     * @throws  ServiceConfigurationError
+     *          when an error occurs while loading a service provider
+     * @throws  IOException
+     *          if an I/O error occurs
+     * @throws  SecurityException
+     *          if a security manager is installed and it denies an unspecified
+     *          permission
+     *
+     * @since 13
+     */
+    public static FileSystem newFileSystem(Path path) throws IOException {
+        return newFileSystem(path, Map.of(), null);
+    }
+
     /**
      * Constructs a new {@code FileSystem} to access the contents of a file as a
      * file system.
@@ -351,15 +491,19 @@ public final class FileSystems {
      *
      * <p> This method iterates over the {@link FileSystemProvider#installedProviders()
      * installed} providers. It invokes, in turn, each provider's {@link
-     * FileSystemProvider#newFileSystem(Path,Map) newFileSystem(Path,Map)} method
-     * with an empty map. If a provider returns a file system then the iteration
-     * terminates and the file system is returned. If none of the installed
-     * providers return a {@code FileSystem} then an attempt is made to locate
-     * the provider using the given class loader. If a provider returns a file
-     * system then the lookup terminates and the file system is returned.
+     * FileSystemProvider#newFileSystem(Path,Map) newFileSystem(Path,Map)}
+     * method. If a provider returns a file system then the iteration
+     * terminates and the file system is returned.
+     * If none of the installed providers return a {@code FileSystem} then
+     * an attempt is made to locate the provider using the given class loader.
+     * If a provider returns a file
+     * system, then the lookup terminates and the file system is returned.
      *
      * @param   path
      *          the path to the file
+     * @param   env
+     *          a map of provider specific properties to configure the file system;
+     *          may be empty
      * @param   loader
      *          the class loader to locate the provider or {@code null} to only
      *          attempt to locate an installed provider
@@ -375,15 +519,15 @@ public final class FileSystems {
      * @throws  SecurityException
      *          if a security manager is installed and it denies an unspecified
      *          permission
+     *
+     * @since 13
      */
-    public static FileSystem newFileSystem(Path path,
+    public static FileSystem newFileSystem(Path path, Map<String,?> env,
                                            ClassLoader loader)
         throws IOException
     {
         if (path == null)
             throw new NullPointerException();
-        Map<String,?> env = Collections.emptyMap();
-
         // check installed providers
         for (FileSystemProvider provider: FileSystemProvider.installedProviders()) {
             try {
diff --git a/ojluni/src/main/java/java/nio/file/Files.java b/ojluni/src/main/java/java/nio/file/Files.java
index 012118c60f6..f9f341345ad 100644
--- a/ojluni/src/main/java/java/nio/file/Files.java
+++ b/ojluni/src/main/java/java/nio/file/Files.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -77,6 +77,10 @@ import java.util.function.BiPredicate;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 
+import jdk.internal.access.SharedSecrets;
+import sun.nio.ch.FileChannelImpl;
+import sun.nio.fs.AbstractFileSystemProvider;
+
 /**
  * This class consists exclusively of static methods that operate on files,
  * directories, or other types of files.
@@ -231,10 +235,14 @@ public final class Files {
      * <p> In the addition to {@code READ} and {@code WRITE}, the following
      * options may be present:
      *
-     * <table border=1 cellpadding=5 summary="Options">
-     * <tr> <th>Option</th> <th>Description</th> </tr>
+     * <table class="striped">
+     * <caption style="display:none">Options</caption>
+     * <thead>
+     * <tr> <th scope="col">Option</th> <th scope="col">Description</th> </tr>
+     * </thead>
+     * <tbody>
      * <tr>
-     *   <td> {@link StandardOpenOption#APPEND APPEND} </td>
+     *   <th scope="row"> {@link StandardOpenOption#APPEND APPEND} </th>
      *   <td> If this option is present then the file is opened for writing and
      *     each invocation of the channel's {@code write} method first advances
      *     the position to the end of the file and then writes the requested
@@ -244,13 +252,13 @@ public final class Files {
      *     with the {@code READ} or {@code TRUNCATE_EXISTING} options. </td>
      * </tr>
      * <tr>
-     *   <td> {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} </td>
+     *   <th scope="row"> {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} </th>
      *   <td> If this option is present then the existing file is truncated to
      *   a size of 0 bytes. This option is ignored when the file is opened only
      *   for reading. </td>
      * </tr>
      * <tr>
-     *   <td> {@link StandardOpenOption#CREATE_NEW CREATE_NEW} </td>
+     *   <th scope="row"> {@link StandardOpenOption#CREATE_NEW CREATE_NEW} </th>
      *   <td> If this option is present then a new file is created, failing if
      *   the file already exists or is a symbolic link. When creating a file the
      *   check for the existence of the file and the creation of the file if it
@@ -258,14 +266,14 @@ public final class Files {
      *   This option is ignored when the file is opened only for reading. </td>
      * </tr>
      * <tr>
-     *   <td > {@link StandardOpenOption#CREATE CREATE} </td>
+     *   <th scope="row" > {@link StandardOpenOption#CREATE CREATE} </th>
      *   <td> If this option is present then an existing file is opened if it
      *   exists, otherwise a new file is created. This option is ignored if the
      *   {@code CREATE_NEW} option is also present or the file is opened only
      *   for reading. </td>
      * </tr>
      * <tr>
-     *   <td > {@link StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} </td>
+     *   <th scope="row" > {@link StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} </th>
      *   <td> When this option is present then the implementation makes a
      *   <em>best effort</em> attempt to delete the file when closed by the
      *   {@link SeekableByteChannel#close close} method. If the {@code close}
@@ -273,25 +281,26 @@ public final class Files {
      *   delete the file when the Java virtual machine terminates. </td>
      * </tr>
      * <tr>
-     *   <td>{@link StandardOpenOption#SPARSE SPARSE} </td>
+     *   <th scope="row">{@link StandardOpenOption#SPARSE SPARSE} </th>
      *   <td> When creating a new file this option is a <em>hint</em> that the
      *   new file will be sparse. This option is ignored when not creating
      *   a new file. </td>
      * </tr>
      * <tr>
-     *   <td> {@link StandardOpenOption#SYNC SYNC} </td>
+     *   <th scope="row"> {@link StandardOpenOption#SYNC SYNC} </th>
      *   <td> Requires that every update to the file's content or metadata be
      *   written synchronously to the underlying storage device. (see <a
      *   href="package-summary.html#integrity"> Synchronized I/O file
      *   integrity</a>). </td>
      * </tr>
      * <tr>
-     *   <td> {@link StandardOpenOption#DSYNC DSYNC} </td>
+     *   <th scope="row"> {@link StandardOpenOption#DSYNC DSYNC} </th>
      *   <td> Requires that every update to the file's content be written
      *   synchronously to the underlying storage device. (see <a
      *   href="package-summary.html#integrity"> Synchronized I/O file
      *   integrity</a>). </td>
      * </tr>
+     * </tbody>
      * </table>
      *
      * <p> An implementation may also support additional implementation specific
@@ -304,7 +313,7 @@ public final class Files {
      * is a {@link java.nio.channels.FileChannel}.
      *
      * <p> <b>Usage Examples:</b>
-     * <pre>
+     * <pre>{@code
      *     Path path = ...
      *
      *     // open file for reading
@@ -315,9 +324,10 @@ public final class Files {
      *     WritableByteChannel wbc = Files.newByteChannel(path, EnumSet.of(CREATE,APPEND));
      *
      *     // create file with initial permissions, opening it for both reading and writing
-     *     {@code FileAttribute<Set<PosixFilePermission>> perms = ...}
-     *     SeekableByteChannel sbc = Files.newByteChannel(path, EnumSet.of(CREATE_NEW,READ,WRITE), perms);
-     * </pre>
+     *     FileAttribute<Set<PosixFilePermission>> perms = ...
+     *     SeekableByteChannel sbc =
+     *         Files.newByteChannel(path, EnumSet.of(CREATE_NEW,READ,WRITE), perms);
+     * }</pre>
      *
      * @param   path
      *          the path to the file to open or create
@@ -402,8 +412,13 @@ public final class Files {
     public static SeekableByteChannel newByteChannel(Path path, OpenOption... options)
         throws IOException
     {
-        Set<OpenOption> set = new HashSet<OpenOption>(options.length);
-        Collections.addAll(set, options);
+        Set<OpenOption> set;
+        if (options.length == 0) {
+            set = Collections.emptySet();
+        } else {
+            set = new HashSet<>();
+            Collections.addAll(set, options);
+        }
         return newByteChannel(path, set);
     }
 
@@ -516,7 +531,7 @@ public final class Files {
         // create a matcher and return a filter that uses it.
         FileSystem fs = dir.getFileSystem();
         final PathMatcher matcher = fs.getPathMatcher("glob:" + glob);
-        DirectoryStream.Filter<Path> filter = new DirectoryStream.Filter<Path>() {
+        DirectoryStream.Filter<Path> filter = new DirectoryStream.Filter<>() {
             @Override
             public boolean accept(Path entry)  {
                 return matcher.matches(entry.getFileName());
@@ -591,6 +606,9 @@ public final class Files {
 
     // -- Creation and deletion --
 
+    private static final Set<OpenOption> DEFAULT_CREATE_OPTIONS =
+        Set.of(StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE);
+
     /**
      * Creates a new and empty file, failing if the file already exists. The
      * check for the existence of the file and the creation of the new file if
@@ -627,9 +645,7 @@ public final class Files {
     public static Path createFile(Path path, FileAttribute<?>... attrs)
         throws IOException
     {
-        EnumSet<StandardOpenOption> options =
-            EnumSet.<StandardOpenOption>of(StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE);
-        newByteChannel(path, options, attrs).close();
+        newByteChannel(path, DEFAULT_CREATE_OPTIONS, attrs).close();
         return path;
     }
 
@@ -739,7 +755,7 @@ public final class Files {
             // don't have permission to get absolute path
             se = x;
         }
-        // find a decendent that exists
+        // find a descendant that exists
         Path parent = dir.getParent();
         while (parent != null) {
             try {
@@ -1032,7 +1048,7 @@ public final class Files {
      *          if an I/O error occurs
      * @throws  SecurityException
      *          In the case of the default provider, and a security manager
-     *          is installed, it denies {@link LinkPermission}<tt>("symbolic")</tt>
+     *          is installed, it denies {@link LinkPermission}{@code ("symbolic")}
      *          or its {@link SecurityManager#checkWrite(String) checkWrite}
      *          method denies write access to the path of the symbolic link.
      */
@@ -1077,7 +1093,7 @@ public final class Files {
      *          if an I/O error occurs
      * @throws  SecurityException
      *          In the case of the default provider, and a security manager
-     *          is installed, it denies {@link LinkPermission}<tt>("hard")</tt>
+     *          is installed, it denies {@link LinkPermission}{@code ("hard")}
      *          or its {@link SecurityManager#checkWrite(String) checkWrite}
      *          method denies write access to either the link or the
      *          existing file.
@@ -1185,17 +1201,21 @@ public final class Files {
      *
      * <p> The {@code options} parameter may include any of the following:
      *
-     * <table border=1 cellpadding=5 summary="">
-     * <tr> <th>Option</th> <th>Description</th> </tr>
+     * <table class="striped">
+     * <caption style="display:none">Options</caption>
+     * <thead>
+     * <tr> <th scope="col">Option</th> <th scope="col">Description</th> </tr>
+     * </thead>
+     * <tbody>
      * <tr>
-     *   <td> {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} </td>
+     *   <th scope="row"> {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} </th>
      *   <td> If the target file exists, then the target file is replaced if it
      *     is not a non-empty directory. If the target file exists and is a
      *     symbolic link, then the symbolic link itself, not the target of
      *     the link, is replaced. </td>
      * </tr>
      * <tr>
-     *   <td> {@link StandardCopyOption#COPY_ATTRIBUTES COPY_ATTRIBUTES} </td>
+     *   <th scope="row"> {@link StandardCopyOption#COPY_ATTRIBUTES COPY_ATTRIBUTES} </th>
      *   <td> Attempts to copy the file attributes associated with this file to
      *     the target file. The exact file attributes that are copied is platform
      *     and file system dependent and therefore unspecified. Minimally, the
@@ -1205,13 +1225,14 @@ public final class Files {
      *     loss. </td>
      * </tr>
      * <tr>
-     *   <td> {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} </td>
+     *   <th scope="row"> {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} </th>
      *   <td> Symbolic links are not followed. If the file is a symbolic link,
      *     then the symbolic link itself, not the target of the link, is copied.
      *     It is implementation specific if file attributes can be copied to the
      *     new link. In other words, the {@code COPY_ATTRIBUTES} option may be
      *     ignored when copying a symbolic link. </td>
      * </tr>
+     * </tbody>
      * </table>
      *
      * <p> An implementation of this interface may support additional
@@ -1303,17 +1324,21 @@ public final class Files {
      *
      * <p> The {@code options} parameter may include any of the following:
      *
-     * <table border=1 cellpadding=5 summary="">
-     * <tr> <th>Option</th> <th>Description</th> </tr>
+     * <table class="striped">
+     * <caption style="display:none">Options</caption>
+     * <thead>
+     * <tr> <th scope="col">Option</th> <th scope="col">Description</th> </tr>
+     * </thead>
+     * <tbody>
      * <tr>
-     *   <td> {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} </td>
+     *   <th scope="row"> {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} </th>
      *   <td> If the target file exists, then the target file is replaced if it
      *     is not a non-empty directory. If the target file exists and is a
      *     symbolic link, then the symbolic link itself, not the target of
      *     the link, is replaced. </td>
      * </tr>
      * <tr>
-     *   <td> {@link StandardCopyOption#ATOMIC_MOVE ATOMIC_MOVE} </td>
+     *   <th scope="row"> {@link StandardCopyOption#ATOMIC_MOVE ATOMIC_MOVE} </th>
      *   <td> The move is performed as an atomic file system operation and all
      *     other options are ignored. If the target file exists then it is
      *     implementation specific if the existing file is replaced or this method
@@ -1323,6 +1348,7 @@ public final class Files {
      *     example, when the target location is on a different {@code FileStore}
      *     and would require that the file be copied, or target location is
      *     associated with a different provider to this object. </td>
+     * </tbody>
      * </table>
      *
      * <p> An implementation of this interface may support additional
@@ -1373,8 +1399,9 @@ public final class Files {
      *          specific exception)</i>
      * @throws  DirectoryNotEmptyException
      *          the {@code REPLACE_EXISTING} option is specified but the file
-     *          cannot be replaced because it is a non-empty directory
-     *          <i>(optional specific exception)</i>
+     *          cannot be replaced because it is a non-empty directory, or the
+     *          source is a non-empty directory containing entries that would
+     *          be required to be moved <i>(optional specific exceptions)</i>
      * @throws  AtomicMoveNotSupportedException
      *          if the options array contains the {@code ATOMIC_MOVE} option but
      *          the file cannot be moved as an atomic file system operation.
@@ -1400,7 +1427,7 @@ public final class Files {
         return target;
     }
 
-    // -- Miscellenous --
+    // -- Miscellaneous --
 
     /**
      * Reads the target of a symbolic link <i>(optional operation)</i>.
@@ -1454,8 +1481,8 @@ public final class Files {
      *          In the case of the default provider, and a security manager is
      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
      *          method is invoked to check read access to the file, and in
-     *          addition it checks {@link RuntimePermission}<tt>
-     *          ("getFileStoreAttributes")</tt>
+     *          addition it checks
+     *          {@link RuntimePermission}{@code ("getFileStoreAttributes")}
      */
     public static FileStore getFileStore(Path path) throws IOException {
         return provider(path).getFileStore(path);
@@ -1481,7 +1508,7 @@ public final class Files {
      * <li>It is <i>transitive</i>: for three {@code Paths}
      *     {@code f}, {@code g}, and {@code h}, if {@code isSameFile(f,g)} returns
      *     {@code true} and {@code isSameFile(g,h)} returns {@code true}, then
-     *     {@code isSameFile(f,h)} will return return {@code true}.
+     *     {@code isSameFile(f,h)} will return {@code true}.
      * </ul>
      *
      * @param   path
@@ -1535,13 +1562,13 @@ public final class Files {
     private static class FileTypeDetectors{
         static final FileTypeDetector defaultFileTypeDetector =
             createDefaultFileTypeDetector();
-        static final List<FileTypeDetector> installeDetectors =
+        static final List<FileTypeDetector> installedDetectors =
             loadInstalledDetectors();
 
         // creates the default file type detector
         private static FileTypeDetector createDefaultFileTypeDetector() {
             return AccessController
-                .doPrivileged(new PrivilegedAction<FileTypeDetector>() {
+                .doPrivileged(new PrivilegedAction<>() {
                     @Override public FileTypeDetector run() {
                         return sun.nio.fs.DefaultFileTypeDetector.create();
                 }});
@@ -1550,7 +1577,7 @@ public final class Files {
         // loads all installed file type detectors
         private static List<FileTypeDetector> loadInstalledDetectors() {
             return AccessController
-                .doPrivileged(new PrivilegedAction<List<FileTypeDetector>>() {
+                .doPrivileged(new PrivilegedAction<>() {
                     @Override public List<FileTypeDetector> run() {
                         List<FileTypeDetector> list = new ArrayList<>();
                         ServiceLoader<FileTypeDetector> loader = ServiceLoader
@@ -1578,11 +1605,10 @@ public final class Files {
      * list of file type detectors. Installed file type detectors are loaded
      * using the service-provider loading facility defined by the {@link ServiceLoader}
      * class. Installed file type detectors are loaded using the system class
-     * loader. If the system class loader cannot be found then the extension class
-     * loader is used; If the extension class loader cannot be found then the
-     * bootstrap class loader is used. File type detectors are typically installed
-     * by placing them in a JAR file on the application class path or in the
-     * extension directory, the JAR file contains a provider-configuration file
+     * loader. If the system class loader cannot be found then the platform class
+     * loader is used. File type detectors are typically installed
+     * by placing them in a JAR file on the application class path,
+     * the JAR file contains a provider-configuration file
      * named {@code java.nio.file.spi.FileTypeDetector} in the resource directory
      * {@code META-INF/services}, and the file lists one or more fully-qualified
      * names of concrete subclass of {@code FileTypeDetector } that have a zero
@@ -1614,7 +1640,7 @@ public final class Files {
         throws IOException
     {
         // try installed file type detectors
-        for (FileTypeDetector detector: FileTypeDetectors.installeDetectors) {
+        for (FileTypeDetector detector: FileTypeDetectors.installedDetectors) {
             String result = detector.probeContentType(path);
             if (result != null)
                 return result;
@@ -1703,7 +1729,8 @@ public final class Files {
      * Alternatively, suppose we want to read file's POSIX attributes without
      * following symbolic links:
      * <pre>
-     *    PosixFileAttributes attrs = Files.readAttributes(path, PosixFileAttributes.class, NOFOLLOW_LINKS);
+     *    PosixFileAttributes attrs =
+     *        Files.readAttributes(path, PosixFileAttributes.class, NOFOLLOW_LINKS);
      * </pre>
      *
      * @param   <A>
@@ -1777,7 +1804,7 @@ public final class Files {
      * @param   options
      *          options indicating how symbolic links are handled
      *
-     * @return  the {@code path} parameter
+     * @return  the given path
      *
      * @throws  UnsupportedOperationException
      *          if the attribute view is not available
@@ -1896,7 +1923,7 @@ public final class Files {
      * many file systems.
      *
      * <p> The <i>attribute-list</i> component is a comma separated list of
-     * zero or more names of attributes to read. If the list contains the value
+     * one or more names of attributes to read. If the list contains the value
      * {@code "*"} then all attributes are read. Attributes that are not supported
      * are ignored and will not be present in the returned map. It is
      * implementation specific if all attributes are read as an atomic operation
@@ -1905,27 +1932,33 @@ public final class Files {
      * <p> The following examples demonstrate possible values for the {@code
      * attributes} parameter:
      *
-     * <blockquote>
-     * <table border="0" summary="Possible values">
+     * <table class="striped" style="text-align: left; margin-left:2em">
+     * <caption style="display:none">Possible values</caption>
+     * <thead>
      * <tr>
-     *   <td> {@code "*"} </td>
+     *  <th scope="col">Example
+     *  <th scope="col">Description
+     * </thead>
+     * <tbody>
+     * <tr>
+     *   <th scope="row"> {@code "*"} </th>
      *   <td> Read all {@link BasicFileAttributes basic-file-attributes}. </td>
      * </tr>
      * <tr>
-     *   <td> {@code "size,lastModifiedTime,lastAccessTime"} </td>
+     *   <th scope="row"> {@code "size,lastModifiedTime,lastAccessTime"} </th>
      *   <td> Reads the file size, last modified time, and last access time
      *     attributes. </td>
      * </tr>
      * <tr>
-     *   <td> {@code "posix:*"} </td>
+     *   <th scope="row"> {@code "posix:*"} </th>
      *   <td> Read all {@link PosixFileAttributes POSIX-file-attributes}. </td>
      * </tr>
      * <tr>
-     *   <td> {@code "posix:permissions,owner,size"} </td>
-     *   <td> Reads the POSX file permissions, owner, and file size. </td>
+     *   <th scope="row"> {@code "posix:permissions,owner,size"} </th>
+     *   <td> Reads the POSIX file permissions, owner, and file size. </td>
      * </tr>
+     * </tbody>
      * </table>
-     * </blockquote>
      *
      * <p> The {@code options} array may be used to indicate how symbolic links
      * are handled for the case that the file is a symbolic link. By default,
@@ -1946,7 +1979,7 @@ public final class Files {
      * @throws  UnsupportedOperationException
      *          if the attribute view is not available
      * @throws  IllegalArgumentException
-     *          if no attributes are specified or an unrecognized attributes is
+     *          if no attributes are specified or an unrecognized attribute is
      *          specified
      * @throws  IOException
      *          if an I/O error occurs
@@ -1993,7 +2026,8 @@ public final class Files {
      *          if an I/O error occurs
      * @throws  SecurityException
      *          In the case of the default provider, a security manager is
-     *          installed, and it denies {@link RuntimePermission}<tt>("accessUserInformation")</tt>
+     *          installed, and it denies
+     *          {@link RuntimePermission}{@code ("accessUserInformation")}
      *          or its {@link SecurityManager#checkRead(String) checkRead} method
      *          denies read access to the file.
      */
@@ -2018,7 +2052,7 @@ public final class Files {
      * @param   perms
      *          The new set of permissions
      *
-     * @return  The path
+     * @return  The given path
      *
      * @throws  UnsupportedOperationException
      *          if the associated file system does not support the {@code
@@ -2030,7 +2064,8 @@ public final class Files {
      *          if an I/O error occurs
      * @throws  SecurityException
      *          In the case of the default provider, and a security manager is
-     *          installed, it denies {@link RuntimePermission}<tt>("accessUserInformation")</tt>
+     *          installed, it denies
+     *          {@link RuntimePermission}{@code ("accessUserInformation")}
      *          or its {@link SecurityManager#checkWrite(String) checkWrite}
      *          method denies write access to the file.
      */
@@ -2067,7 +2102,8 @@ public final class Files {
      *          if an I/O error occurs
      * @throws  SecurityException
      *          In the case of the default provider, and a security manager is
-     *          installed, it denies {@link RuntimePermission}<tt>("accessUserInformation")</tt>
+     *          installed, it denies
+     *          {@link RuntimePermission}{@code ("accessUserInformation")}
      *          or its {@link SecurityManager#checkRead(String) checkRead} method
      *          denies read access to the file.
      */
@@ -2101,7 +2137,7 @@ public final class Files {
      * @param   owner
      *          The new file owner
      *
-     * @return  The path
+     * @return  The given path
      *
      * @throws  UnsupportedOperationException
      *          if the associated file system does not support the {@code
@@ -2110,7 +2146,8 @@ public final class Files {
      *          if an I/O error occurs
      * @throws  SecurityException
      *          In the case of the default provider, and a security manager is
-     *          installed, it denies {@link RuntimePermission}<tt>("accessUserInformation")</tt>
+     *          installed, it denies
+     *          {@link RuntimePermission}{@code ("accessUserInformation")}
      *          or its {@link SecurityManager#checkWrite(String) checkWrite}
      *          method denies write access to the file.
      *
@@ -2188,6 +2225,12 @@ public final class Files {
      *          method denies read access to the file.
      */
     public static boolean isDirectory(Path path, LinkOption... options) {
+        if (options.length == 0) {
+            FileSystemProvider provider = provider(path);
+            if (provider instanceof AbstractFileSystemProvider)
+                return ((AbstractFileSystemProvider)provider).isDirectory(path);
+        }
+
         try {
             return readAttributes(path, BasicFileAttributes.class, options).isDirectory();
         } catch (IOException ioe) {
@@ -2225,6 +2268,12 @@ public final class Files {
      *          method denies read access to the file.
      */
     public static boolean isRegularFile(Path path, LinkOption... options) {
+        if (options.length == 0) {
+            FileSystemProvider provider = provider(path);
+            if (provider instanceof AbstractFileSystemProvider)
+                return ((AbstractFileSystemProvider)provider).isRegularFile(path);
+        }
+
         try {
             return readAttributes(path, BasicFileAttributes.class, options).isRegularFile();
         } catch (IOException ioe) {
@@ -2288,22 +2337,27 @@ public final class Files {
      * @param   time
      *          the new last modified time
      *
-     * @return  the path
+     * @return  the given path
      *
      * @throws  IOException
      *          if an I/O error occurs
      * @throws  SecurityException
-     *          In the case of the default provider, the security manager's {@link
-     *          SecurityManager#checkWrite(String) checkWrite} method is invoked
-     *          to check write access to file
+     *          In the case of the default provider, and a security manager is
+     *          installed, its {@link SecurityManager#checkWrite(String)
+     *          checkWrite} method denies write access to the file.
      *
      * @see BasicFileAttributeView#setTimes
      */
     public static Path setLastModifiedTime(Path path, FileTime time)
         throws IOException
     {
-        getFileAttributeView(path, BasicFileAttributeView.class)
-            .setTimes(time, null, null);
+        // Android-added: App compat. Android ignores null time instead of throwing NPE.
+        // getFileAttributeView(path, BasicFileAttributeView.class)
+        //         .setTimes(Objects.requireNonNull(time), null, null);
+        if (time != null) {
+            getFileAttributeView(path, BasicFileAttributeView.class)
+                    .setTimes(time, null, null);
+        }
         return path;
     }
 
@@ -2361,7 +2415,7 @@ public final class Files {
      *
      * <p> Note that the result of this method is immediately outdated. If this
      * method indicates the file exists then there is no guarantee that a
-     * subsequence access will succeed. Care should be taken when using this
+     * subsequent access will succeed. Care should be taken when using this
      * method in security sensitive applications.
      *
      * @param   path
@@ -2380,6 +2434,12 @@ public final class Files {
      * @see #notExists
      */
     public static boolean exists(Path path, LinkOption... options) {
+        if (options.length == 0) {
+            FileSystemProvider provider = provider(path);
+            if (provider instanceof AbstractFileSystemProvider)
+                return ((AbstractFileSystemProvider)provider).exists(path);
+        }
+
         try {
             if (followLinks(options)) {
                 provider(path).checkAccess(path);
@@ -2412,7 +2472,7 @@ public final class Files {
      * or not then both methods return {@code false}. As with the {@code exists}
      * method, the result of this method is immediately outdated. If this
      * method indicates the file does exist then there is no guarantee that a
-     * subsequence attempt to create the file will succeed. Care should be taken
+     * subsequent attempt to create the file will succeed. Care should be taken
      * when using this method in security sensitive applications.
      *
      * @param   path
@@ -2448,7 +2508,7 @@ public final class Files {
     }
 
     /**
-     * Used by isReadbale, isWritable, isExecutable to test access to a file.
+     * Used by isReadable, isWritable, isExecutable to test access to a file.
      */
     private static boolean isAccessible(Path path, AccessMode... modes) {
         try {
@@ -2813,13 +2873,15 @@ public final class Files {
      * @since 1.8
      */
     public static BufferedReader newBufferedReader(Path path) throws IOException {
+        // Android-changed: use StandardCharsets.
+        // return newBufferedReader(path, UTF_8.INSTANCE);
         return newBufferedReader(path, StandardCharsets.UTF_8);
     }
 
     /**
      * Opens or creates a file for writing, returning a {@code BufferedWriter}
      * that may be used to write text to the file in an efficient manner.
-     * The {@code options} parameter specifies how the the file is created or
+     * The {@code options} parameter specifies how the file is created or
      * opened. If no options are present then this method works as if the {@link
      * StandardOpenOption#CREATE CREATE}, {@link
      * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link
@@ -2841,6 +2903,8 @@ public final class Files {
      * @return  a new buffered writer, with default buffer size, to write text
      *          to the file
      *
+     * @throws  IllegalArgumentException
+     *          if {@code options} contains an invalid combination of options
      * @throws  IOException
      *          if an I/O error occurs opening or creating the file
      * @throws  UnsupportedOperationException
@@ -2848,7 +2912,10 @@ public final class Files {
      * @throws  SecurityException
      *          In the case of the default provider, and a security manager is
      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
-     *          method is invoked to check write access to the file.
+     *          method is invoked to check write access to the file. The {@link
+     *          SecurityManager#checkDelete(String) checkDelete} method is
+     *          invoked to check delete access if the file is opened with the
+     *          {@code DELETE_ON_CLOSE} option.
      *
      * @see #write(Path,Iterable,Charset,OpenOption[])
      */
@@ -2881,6 +2948,8 @@ public final class Files {
      * @return  a new buffered writer, with default buffer size, to write text
      *          to the file
      *
+     * @throws  IllegalArgumentException
+     *          if {@code options} contains an invalid combination of options
      * @throws  IOException
      *          if an I/O error occurs opening or creating the file
      * @throws  UnsupportedOperationException
@@ -2888,28 +2957,19 @@ public final class Files {
      * @throws  SecurityException
      *          In the case of the default provider, and a security manager is
      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
-     *          method is invoked to check write access to the file.
+     *          method is invoked to check write access to the file. The {@link
+     *          SecurityManager#checkDelete(String) checkDelete} method is
+     *          invoked to check delete access if the file is opened with the
+     *          {@code DELETE_ON_CLOSE} option.
      *
      * @since 1.8
      */
-    public static BufferedWriter newBufferedWriter(Path path, OpenOption... options) throws IOException {
-        return newBufferedWriter(path, StandardCharsets.UTF_8, options);
-    }
-
-    /**
-     * Reads all bytes from an input stream and writes them to an output stream.
-     */
-    private static long copy(InputStream source, OutputStream sink)
+    public static BufferedWriter newBufferedWriter(Path path, OpenOption... options)
         throws IOException
     {
-        long nread = 0L;
-        byte[] buf = new byte[BUFFER_SIZE];
-        int n;
-        while ((n = source.read(buf)) > 0) {
-            sink.write(buf, 0, n);
-            nread += n;
-        }
-        return nread;
+        // Android-changed: use StandardCharsets.
+        //return newBufferedWriter(path, UTF_8.INSTANCE, options);
+        return newBufferedWriter(path, StandardCharsets.UTF_8, options);
     }
 
     /**
@@ -3024,7 +3084,7 @@ public final class Files {
 
         // do the copy
         try (OutputStream out = ostream) {
-            return copy(in, out);
+            return in.transferTo(out);
         }
     }
 
@@ -3066,7 +3126,7 @@ public final class Files {
         Objects.requireNonNull(out);
 
         try (InputStream in = newInputStream(source)) {
-            return copy(in, out);
+            return in.transferTo(out);
         }
     }
 
@@ -3078,6 +3138,8 @@ public final class Files {
      */
     private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;
 
+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+
     /**
      * Reads all the bytes from an input stream. Uses {@code initialSize} as a hint
      * about how many bytes the stream will have.
@@ -3151,14 +3213,91 @@ public final class Files {
     public static byte[] readAllBytes(Path path) throws IOException {
         try (SeekableByteChannel sbc = Files.newByteChannel(path);
              InputStream in = Channels.newInputStream(sbc)) {
+            if (sbc instanceof FileChannelImpl)
+                ((FileChannelImpl) sbc).setUninterruptible();
             long size = sbc.size();
-            if (size > (long)MAX_BUFFER_SIZE)
+            if (size > (long) MAX_BUFFER_SIZE)
                 throw new OutOfMemoryError("Required array size too large");
-
             return read(in, (int)size);
         }
     }
 
+    /**
+     * Reads all content from a file into a string, decoding from bytes to characters
+     * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.
+     * The method ensures that the file is closed when all content have been read
+     * or an I/O error, or other runtime exception, is thrown.
+     *
+     * <p> This method is equivalent to:
+     * {@code readString(path, StandardCharsets.UTF_8) }
+     *
+     * @param   path the path to the file
+     *
+     * @return  a String containing the content read from the file
+     *
+     * @throws  IOException
+     *          if an I/O error occurs reading from the file or a malformed or
+     *          unmappable byte sequence is read
+     * @throws  OutOfMemoryError
+     *          if the file is extremely large, for example larger than {@code 2GB}
+     * @throws  SecurityException
+     *          In the case of the default provider, and a security manager is
+     *          installed, the {@link SecurityManager#checkRead(String) checkRead}
+     *          method is invoked to check read access to the file.
+     *
+     * @since 11
+     */
+    public static String readString(Path path) throws IOException {
+        // Android-changed: use StandardCharsets.
+        //return readString(path, UTF_8.INSTANCE);
+        return readString(path, StandardCharsets.UTF_8);
+    }
+
+    /**
+     * Reads all characters from a file into a string, decoding from bytes to characters
+     * using the specified {@linkplain Charset charset}.
+     * The method ensures that the file is closed when all content have been read
+     * or an I/O error, or other runtime exception, is thrown.
+     *
+     * <p> This method reads all content including the line separators in the middle
+     * and/or at the end. The resulting string will contain line separators as they
+     * appear in the file.
+     *
+     * @apiNote
+     * This method is intended for simple cases where it is appropriate and convenient
+     * to read the content of a file into a String. It is not intended for reading
+     * very large files.
+     *
+     *
+     *
+     * @param   path the path to the file
+     * @param   cs the charset to use for decoding
+     *
+     * @return  a String containing the content read from the file
+     *
+     * @throws  IOException
+     *          if an I/O error occurs reading from the file or a malformed or
+     *          unmappable byte sequence is read
+     * @throws  OutOfMemoryError
+     *          if the file is extremely large, for example larger than {@code 2GB}
+     * @throws  SecurityException
+     *          In the case of the default provider, and a security manager is
+     *          installed, the {@link SecurityManager#checkRead(String) checkRead}
+     *          method is invoked to check read access to the file.
+     *
+     * @since 11
+     */
+    public static String readString(Path path, Charset cs) throws IOException {
+        Objects.requireNonNull(path);
+        Objects.requireNonNull(cs);
+
+        byte[] ba = readAllBytes(path);
+        // Android-changed: Android's JLA.newStringNoRepl doesn't take ownership of the byte[].
+        // if (path.getClass().getModule() != Object.class.getModule())
+        //     ba = ba.clone();
+        return JLA.newStringNoRepl(ba, cs);
+    }
+
     /**
      * Read all lines from a file. This method ensures that the file is
      * closed when all bytes have been read or an I/O error, or other runtime
@@ -3239,11 +3378,13 @@ public final class Files {
      * @since 1.8
      */
     public static List<String> readAllLines(Path path) throws IOException {
+        // Android-changed: use StandardCharsets.
+        //return readAllLines(path, UTF_8.INSTANCE);
         return readAllLines(path, StandardCharsets.UTF_8);
     }
 
     /**
-     * Writes bytes to a file. The {@code options} parameter specifies how the
+     * Writes bytes to a file. The {@code options} parameter specifies how
      * the file is created or opened. If no options are present then this method
      * works as if the {@link StandardOpenOption#CREATE CREATE}, {@link
      * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link
@@ -3253,8 +3394,8 @@ public final class Files {
      * a size of {@code 0}. All bytes in the byte array are written to the file.
      * The method ensures that the file is closed when all bytes have been
      * written (or an I/O error or other runtime exception is thrown). If an I/O
-     * error occurs then it may do so after the file has created or truncated,
-     * or after some bytes have been written to the file.
+     * error occurs then it may do so after the file has been created or
+     * truncated, or after some bytes have been written to the file.
      *
      * <p> <b>Usage example</b>: By default the method creates a new file or
      * overwrites an existing file. Suppose you instead want to append bytes
@@ -3274,6 +3415,8 @@ public final class Files {
      *
      * @return  the path
      *
+     * @throws  IllegalArgumentException
+     *          if {@code options} contains an invalid combination of options
      * @throws  IOException
      *          if an I/O error occurs writing to or creating the file
      * @throws  UnsupportedOperationException
@@ -3281,7 +3424,10 @@ public final class Files {
      * @throws  SecurityException
      *          In the case of the default provider, and a security manager is
      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
-     *          method is invoked to check write access to the file.
+     *          method is invoked to check write access to the file. The {@link
+     *          SecurityManager#checkDelete(String) checkDelete} method is
+     *          invoked to check delete access if the file is opened with the
+     *          {@code DELETE_ON_CLOSE} option.
      */
     public static Path write(Path path, byte[] bytes, OpenOption... options)
         throws IOException
@@ -3308,7 +3454,7 @@ public final class Files {
      * line.separator}. Characters are encoded into bytes using the specified
      * charset.
      *
-     * <p> The {@code options} parameter specifies how the the file is created
+     * <p> The {@code options} parameter specifies how the file is created
      * or opened. If no options are present then this method works as if the
      * {@link StandardOpenOption#CREATE CREATE}, {@link
      * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link
@@ -3318,7 +3464,8 @@ public final class Files {
      * a size of {@code 0}. The method ensures that the file is closed when all
      * lines have been written (or an I/O error or other runtime exception is
      * thrown). If an I/O error occurs then it may do so after the file has
-     * created or truncated, or after some bytes have been written to the file.
+     * been created or truncated, or after some bytes have been written to the
+     * file.
      *
      * @param   path
      *          the path to the file
@@ -3331,6 +3478,8 @@ public final class Files {
      *
      * @return  the path
      *
+     * @throws  IllegalArgumentException
+     *          if {@code options} contains an invalid combination of options
      * @throws  IOException
      *          if an I/O error occurs writing to or creating the file, or the
      *          text cannot be encoded using the specified charset
@@ -3339,7 +3488,10 @@ public final class Files {
      * @throws  SecurityException
      *          In the case of the default provider, and a security manager is
      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
-     *          method is invoked to check write access to the file.
+     *          method is invoked to check write access to the file. The {@link
+     *          SecurityManager#checkDelete(String) checkDelete} method is
+     *          invoked to check delete access if the file is opened with the
+     *          {@code DELETE_ON_CLOSE} option.
      */
     public static Path write(Path path, Iterable<? extends CharSequence> lines,
                              Charset cs, OpenOption... options)
@@ -3348,8 +3500,8 @@ public final class Files {
         // ensure lines is not null before opening file
         Objects.requireNonNull(lines);
         CharsetEncoder encoder = cs.newEncoder();
-        OutputStream out = newOutputStream(path, options);
-        try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out, encoder))) {
+        try (OutputStream out = newOutputStream(path, options);
+             BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out, encoder))) {
             for (CharSequence line: lines) {
                 writer.append(line);
                 writer.newLine();
@@ -3377,6 +3529,8 @@ public final class Files {
      *
      * @return  the path
      *
+     * @throws  IllegalArgumentException
+     *          if {@code options} contains an invalid combination of options
      * @throws  IOException
      *          if an I/O error occurs writing to or creating the file, or the
      *          text cannot be encoded as {@code UTF-8}
@@ -3385,7 +3539,10 @@ public final class Files {
      * @throws  SecurityException
      *          In the case of the default provider, and a security manager is
      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
-     *          method is invoked to check write access to the file.
+     *          method is invoked to check write access to the file. The {@link
+     *          SecurityManager#checkDelete(String) checkDelete} method is
+     *          invoked to check delete access if the file is opened with the
+     *          {@code DELETE_ON_CLOSE} option.
      *
      * @since 1.8
      */
@@ -3394,9 +3551,117 @@ public final class Files {
                              OpenOption... options)
         throws IOException
     {
+        // Android-changed: use StandardCharsets.
+        //return write(path, lines, UTF_8.INSTANCE, options);
         return write(path, lines, StandardCharsets.UTF_8, options);
     }
 
+    /**
+     * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.
+     * Characters are encoded into bytes using the
+     * {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.
+     *
+     * <p> This method is equivalent to:
+     * {@code writeString(path, test, StandardCharsets.UTF_8, options) }
+     *
+     * @param   path
+     *          the path to the file
+     * @param   csq
+     *          the CharSequence to be written
+     * @param   options
+     *          options specifying how the file is opened
+     *
+     * @return  the path
+     *
+     * @throws  IllegalArgumentException
+     *          if {@code options} contains an invalid combination of options
+     * @throws  IOException
+     *          if an I/O error occurs writing to or creating the file, or the
+     *          text cannot be encoded using the specified charset
+     * @throws  UnsupportedOperationException
+     *          if an unsupported option is specified
+     * @throws  SecurityException
+     *          In the case of the default provider, and a security manager is
+     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
+     *          method is invoked to check write access to the file. The {@link
+     *          SecurityManager#checkDelete(String) checkDelete} method is
+     *          invoked to check delete access if the file is opened with the
+     *          {@code DELETE_ON_CLOSE} option.
+     *
+     * @since 11
+     */
+    public static Path writeString(Path path, CharSequence csq, OpenOption... options)
+            throws IOException
+    {
+        // Android-changed: use StandardCharsets.
+        //return writeString(path, csq, UTF_8.INSTANCE, options);
+        return writeString(path, csq, StandardCharsets.UTF_8, options);
+    }
+
+    /**
+     * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.
+     * Characters are encoded into bytes using the specified
+     * {@linkplain java.nio.charset.Charset charset}.
+     *
+     * <p> All characters are written as they are, including the line separators in
+     * the char sequence. No extra characters are added.
+     *
+     * <p> The {@code options} parameter specifies how the file is created
+     * or opened. If no options are present then this method works as if the
+     * {@link StandardOpenOption#CREATE CREATE}, {@link
+     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link
+     * StandardOpenOption#WRITE WRITE} options are present. In other words, it
+     * opens the file for writing, creating the file if it doesn't exist, or
+     * initially truncating an existing {@link #isRegularFile regular-file} to
+     * a size of {@code 0}.
+     *
+     *
+     * @param   path
+     *          the path to the file
+     * @param   csq
+     *          the CharSequence to be written
+     * @param   cs
+     *          the charset to use for encoding
+     * @param   options
+     *          options specifying how the file is opened
+     *
+     * @return  the path
+     *
+     * @throws  IllegalArgumentException
+     *          if {@code options} contains an invalid combination of options
+     * @throws  IOException
+     *          if an I/O error occurs writing to or creating the file, or the
+     *          text cannot be encoded using the specified charset
+     * @throws  UnsupportedOperationException
+     *          if an unsupported option is specified
+     * @throws  SecurityException
+     *          In the case of the default provider, and a security manager is
+     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
+     *          method is invoked to check write access to the file. The {@link
+     *          SecurityManager#checkDelete(String) checkDelete} method is
+     *          invoked to check delete access if the file is opened with the
+     *          {@code DELETE_ON_CLOSE} option.
+     *
+     * @since 11
+     */
+    public static Path writeString(Path path, CharSequence csq, Charset cs, OpenOption... options)
+            throws IOException
+    {
+        // ensure the text is not null before opening file
+        Objects.requireNonNull(path);
+        Objects.requireNonNull(csq);
+        Objects.requireNonNull(cs);
+
+        byte[] bytes = JLA.getBytesNoRepl(String.valueOf(csq), cs);
+
+        // Android-changed: Android's JLA.getBytesNoRepl returns a copy.
+        // if (path.getClass().getModule() != Object.class.getModule())
+        //     bytes = bytes.clone();
+        write(path, bytes, options);
+
+        return path;
+    }
+
     // -- Stream APIs --
 
     /**
@@ -3414,11 +3679,8 @@ public final class Files {
      * reflect updates to the directory that occur after returning from this
      * method.
      *
-     * <p> The returned stream encapsulates a {@link DirectoryStream}.
-     * If timely disposal of file system resources is required, the
-     * {@code try}-with-resources construct should be used to ensure that the
-     * stream's {@link Stream#close close} method is invoked after the stream
-     * operations are completed.
+     * <p> The returned stream contains a reference to an open directory.
+     * The directory is closed by closing the stream.
      *
      * <p> Operating on a closed stream behaves as if the end of stream
      * has been reached. Due to read-ahead, one or more elements may be
@@ -3429,6 +3691,11 @@ public final class Files {
      * UncheckedIOException} which will be thrown from the method that caused
      * the access to take place.
      *
+     * @apiNote
+     * This method must be used within a try-with-resources statement or similar
+     * control structure to ensure that the stream's open directory is closed
+     * promptly after the stream's operations have completed.
+     *
      * @param   dir  The path to the directory
      *
      * @return  The {@code Stream} describing the content of the
@@ -3453,7 +3720,7 @@ public final class Files {
             final Iterator<Path> delegate = ds.iterator();
 
             // Re-wrap DirectoryIteratorException to UncheckedIOException
-            Iterator<Path> it = new Iterator<Path>() {
+            Iterator<Path> iterator = new Iterator<>() {
                 @Override
                 public boolean hasNext() {
                     try {
@@ -3472,7 +3739,9 @@ public final class Files {
                 }
             };
 
-            return StreamSupport.stream(Spliterators.spliteratorUnknownSize(it, Spliterator.DISTINCT), false)
+            Spliterator<Path> spliterator =
+                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);
+            return StreamSupport.stream(spliterator, false)
                                 .onClose(asUncheckedRunnable(ds));
         } catch (Error|RuntimeException e) {
             try {
@@ -3534,18 +3803,19 @@ public final class Files {
      * <p> When a security manager is installed and it denies access to a file
      * (or directory), then it is ignored and not included in the stream.
      *
-     * <p> The returned stream encapsulates one or more {@link DirectoryStream}s.
-     * If timely disposal of file system resources is required, the
-     * {@code try}-with-resources construct should be used to ensure that the
-     * stream's {@link Stream#close close} method is invoked after the stream
-     * operations are completed.  Operating on a closed stream will result in an
-     * {@link java.lang.IllegalStateException}.
+     * <p> The returned stream contains references to one or more open directories.
+     * The directories are closed by closing the stream.
      *
      * <p> If an {@link IOException} is thrown when accessing the directory
      * after this method has returned, it is wrapped in an {@link
      * UncheckedIOException} which will be thrown from the method that caused
      * the access to take place.
      *
+     * @apiNote
+     * This method must be used within a try-with-resources statement or similar
+     * control structure to ensure that the stream's open directories are closed
+     * promptly after the stream's operations have completed.
+     *
      * @param   start
      *          the starting file
      * @param   maxDepth
@@ -3573,7 +3843,9 @@ public final class Files {
     {
         FileTreeIterator iterator = new FileTreeIterator(start, maxDepth, options);
         try {
-            return StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT), false)
+            Spliterator<FileTreeWalker.Event> spliterator =
+                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);
+            return StreamSupport.stream(spliterator, false)
                                 .onClose(iterator::close)
                                 .map(entry -> entry.file());
         } catch (Error|RuntimeException e) {
@@ -3596,12 +3868,13 @@ public final class Files {
      * </pre></blockquote>
      * In other words, it visits all levels of the file tree.
      *
-     * <p> The returned stream encapsulates one or more {@link DirectoryStream}s.
-     * If timely disposal of file system resources is required, the
-     * {@code try}-with-resources construct should be used to ensure that the
-     * stream's {@link Stream#close close} method is invoked after the stream
-     * operations are completed.  Operating on a closed stream will result in an
-     * {@link java.lang.IllegalStateException}.
+     * <p> The returned stream contains references to one or more open directories.
+     * The directories are closed by closing the stream.
+     *
+     * @apiNote
+     * This method must be used within a try-with-resources statement or similar
+     * control structure to ensure that the stream's open directories are closed
+     * promptly after the stream's operations have completed.
      *
      * @param   start
      *          the starting file
@@ -3641,18 +3914,19 @@ public final class Files {
      * returned by {@code walk} method, this method may be more efficient by
      * avoiding redundant retrieval of the {@code BasicFileAttributes}.
      *
-     * <p> The returned stream encapsulates one or more {@link DirectoryStream}s.
-     * If timely disposal of file system resources is required, the
-     * {@code try}-with-resources construct should be used to ensure that the
-     * stream's {@link Stream#close close} method is invoked after the stream
-     * operations are completed.  Operating on a closed stream will result in an
-     * {@link java.lang.IllegalStateException}.
+     * <p> The returned stream contains references to one or more open directories.
+     * The directories are closed by closing the stream.
      *
      * <p> If an {@link IOException} is thrown when accessing the directory
      * after returned from this method, it is wrapped in an {@link
      * UncheckedIOException} which will be thrown from the method that caused
      * the access to take place.
      *
+     * @apiNote
+     * This method must be used within a try-with-resources statement or similar
+     * control structure to ensure that the stream's open directories are closed
+     * promptly after the stream's operations have completed.
+     *
      * @param   start
      *          the starting file
      * @param   maxDepth
@@ -3686,7 +3960,9 @@ public final class Files {
     {
         FileTreeIterator iterator = new FileTreeIterator(start, maxDepth, options);
         try {
-            return StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT), false)
+            Spliterator<FileTreeWalker.Event> spliterator =
+                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);
+            return StreamSupport.stream(spliterator, false)
                                 .onClose(iterator::close)
                                 .filter(entry -> matcher.test(entry.file(), entry.attributes()))
                                 .map(entry -> entry.file());
@@ -3696,6 +3972,7 @@ public final class Files {
         }
     }
 
+
     /**
      * Read all lines from a file as a {@code Stream}. Unlike {@link
      * #readAllLines(Path, Charset) readAllLines}, this method does not read
@@ -3706,6 +3983,13 @@ public final class Files {
      * charset and the same line terminators as specified by {@code
      * readAllLines} are supported.
      *
+     * <p> The returned stream contains a reference to an open file. The file
+     * is closed by closing the stream.
+     *
+     * <p> The file contents should not be modified during the execution of the
+     * terminal stream operation. Otherwise, the result of the terminal stream
+     * operation is undefined.
+     *
      * <p> After this method returns, then any subsequent I/O exception that
      * occurs while reading from the file or when a malformed or unmappable byte
      * sequence is read, is wrapped in an {@link UncheckedIOException} that will
@@ -3714,12 +3998,34 @@ public final class Files {
      * place. In case an {@code IOException} is thrown when closing the file,
      * it is also wrapped as an {@code UncheckedIOException}.
      *
-     * <p> The returned stream encapsulates a {@link Reader}.  If timely
-     * disposal of file system resources is required, the try-with-resources
-     * construct should be used to ensure that the stream's
-     * {@link Stream#close close} method is invoked after the stream operations
-     * are completed.
-     *
+     * @apiNote
+     * This method must be used within a try-with-resources statement or similar
+     * control structure to ensure that the stream's open file is closed promptly
+     * after the stream's operations have completed.
+     *
+     * @implNote
+     * This implementation supports good parallel stream performance for the
+     * standard charsets {@link StandardCharsets#UTF_8 UTF-8},
+     * {@link StandardCharsets#US_ASCII US-ASCII} and
+     * {@link StandardCharsets#ISO_8859_1 ISO-8859-1}.  Such
+     * <em>line-optimal</em> charsets have the property that the encoded bytes
+     * of a line feed ('\n') or a carriage return ('\r') are efficiently
+     * identifiable from other encoded characters when randomly accessing the
+     * bytes of the file.
+     *
+     * <p> For non-<em>line-optimal</em> charsets the stream source's
+     * spliterator has poor splitting properties, similar to that of a
+     * spliterator associated with an iterator or that associated with a stream
+     * returned from {@link BufferedReader#lines()}.  Poor splitting properties
+     * can result in poor parallel stream performance.
+     *
+     * <p> For <em>line-optimal</em> charsets the stream source's spliterator
+     * has good splitting properties, assuming the file contains a regular
+     * sequence of lines.  Good splitting properties can result in good parallel
+     * stream performance.  The spliterator for a <em>line-optimal</em> charset
+     * takes advantage of the charset properties (a line feed or a carriage
+     * return being efficient identifiable) such that when splitting it can
+     * approximately divide the number of covered lines in half.
      *
      * @param   path
      *          the path to the file
@@ -3741,7 +4047,52 @@ public final class Files {
      * @since   1.8
      */
     public static Stream<String> lines(Path path, Charset cs) throws IOException {
-        BufferedReader br = Files.newBufferedReader(path, cs);
+        // Use the good splitting spliterator if:
+        // 1) the path is associated with the default file system;
+        // 2) the character set is supported; and
+        // 3) the file size is such that all bytes can be indexed by int values
+        //    (this limitation is imposed by ByteBuffer)
+        if (path.getFileSystem() == FileSystems.getDefault() &&
+            FileChannelLinesSpliterator.SUPPORTED_CHARSET_NAMES.contains(cs.name())) {
+            FileChannel fc = FileChannel.open(path, StandardOpenOption.READ);
+
+            Stream<String> fcls = createFileChannelLinesStream(fc, cs);
+            if (fcls != null) {
+                return fcls;
+            }
+            fc.close();
+        }
+
+        return createBufferedReaderLinesStream(Files.newBufferedReader(path, cs));
+    }
+
+    private static Stream<String> createFileChannelLinesStream(FileChannel fc, Charset cs) throws IOException {
+        try {
+            // Obtaining the size from the FileChannel is much faster
+            // than obtaining using path.toFile().length()
+            long length = fc.size();
+            // FileChannel.size() may in certain circumstances return zero
+            // for a non-zero length file so disallow this case.
+            if (length > 0 && length <= Integer.MAX_VALUE) {
+                Spliterator<String> s = new FileChannelLinesSpliterator(fc, cs, 0, (int) length);
+                return StreamSupport.stream(s, false)
+                        .onClose(Files.asUncheckedRunnable(fc));
+            }
+        } catch (Error|RuntimeException|IOException e) {
+            try {
+                fc.close();
+            } catch (IOException ex) {
+                try {
+                    e.addSuppressed(ex);
+                } catch (Throwable ignore) {
+                }
+            }
+            throw e;
+        }
+        return null;
+    }
+
+    private static Stream<String> createBufferedReaderLinesStream(BufferedReader br) {
         try {
             return br.lines().onClose(asUncheckedRunnable(br));
         } catch (Error|RuntimeException e) {
@@ -3750,7 +4101,8 @@ public final class Files {
             } catch (IOException ex) {
                 try {
                     e.addSuppressed(ex);
-                } catch (Throwable ignore) {}
+                } catch (Throwable ignore) {
+                }
             }
             throw e;
         }
@@ -3761,12 +4113,24 @@ public final class Files {
      * decoded into characters using the {@link StandardCharsets#UTF_8 UTF-8}
      * {@link Charset charset}.
      *
+     * <p> The returned stream contains a reference to an open file. The file
+     * is closed by closing the stream.
+     *
+     * <p> The file contents should not be modified during the execution of the
+     * terminal stream operation. Otherwise, the result of the terminal stream
+     * operation is undefined.
+     *
      * <p> This method works as if invoking it were equivalent to evaluating the
      * expression:
      * <pre>{@code
      * Files.lines(path, StandardCharsets.UTF_8)
      * }</pre>
      *
+     * @apiNote
+     * This method must be used within a try-with-resources statement or similar
+     * control structure to ensure that the stream's open file is closed promptly
+     * after the stream's operations have completed.
+     *
      * @param   path
      *          the path to the file
      *
@@ -3782,6 +4146,8 @@ public final class Files {
      * @since 1.8
      */
     public static Stream<String> lines(Path path) throws IOException {
+        // Android-changed: use StandardCharsets.
+        //return lines(path, UTF_8.INSTANCE);
         return lines(path, StandardCharsets.UTF_8);
     }
 }
diff --git a/ojluni/src/main/java/java/nio/file/Path.java b/ojluni/src/main/java/java/nio/file/Path.java
index 5df35c275fd..296c48d3e8c 100644
--- a/ojluni/src/main/java/java/nio/file/Path.java
+++ b/ojluni/src/main/java/java/nio/file/Path.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -263,7 +263,7 @@ public interface Path
      * #normalize normalize} method, to eliminate redundant names, for cases where
      * <em>shell-like</em> navigation is required.
      *
-     * <p> If this path has one or more elements, and no root component, then
+     * <p> If this path has more than one element, and no root component, then
      * this method is equivalent to evaluating the expression:
      * <blockquote><pre>
      * subpath(0,&nbsp;getNameCount()-1);
@@ -360,6 +360,12 @@ public interface Path
      * "{@code foo/bar}" starts with "{@code foo}" and "{@code foo/bar}". It
      * does not start with "{@code f}" or "{@code fo}".
      *
+     * @implSpec
+     * The default implementation is equivalent for this path to:
+     * <pre>{@code
+     *     startsWith(getFileSystem().getPath(other));
+     * }</pre>
+     *
      * @param   other
      *          the given path string
      *
@@ -369,7 +375,9 @@ public interface Path
      * @throws  InvalidPathException
      *          If the path string cannot be converted to a Path.
      */
-    boolean startsWith(String other);
+    default boolean startsWith(String other) {
+        return startsWith(getFileSystem().getPath(other));
+    }
 
     /**
      * Tests if this path ends with the given path.
@@ -408,6 +416,12 @@ public interface Path
      * Path}"{@code foo/bar}" with the {@code String} "{@code bar/}" returns
      * {@code true}.
      *
+     * @implSpec
+     * The default implementation is equivalent for this path to:
+     * <pre>{@code
+     *     endsWith(getFileSystem().getPath(other));
+     * }</pre>
+     *
      * @param   other
      *          the given path string
      *
@@ -417,7 +431,9 @@ public interface Path
      * @throws  InvalidPathException
      *          If the path string cannot be converted to a Path.
      */
-    boolean endsWith(String other);
+    default boolean endsWith(String other) {
+        return endsWith(getFileSystem().getPath(other));
+    }
 
     /**
      * Returns a path that is this path with redundant name elements eliminated.
@@ -439,7 +455,7 @@ public interface Path
      *
      * @return  the resulting path or this path if it does not contain
      *          redundant name elements; an empty path is returned if this path
-     *          does have a root component and all name elements are redundant
+     *          does not have a root component and all name elements are redundant
      *
      * @see #getParent
      * @see #toRealPath
@@ -479,6 +495,12 @@ public interface Path
      * invoking this method with the path string "{@code gus}" will result in
      * the {@code Path} "{@code foo/bar/gus}".
      *
+     * @implSpec
+     * The default implementation is equivalent for this path to:
+     * <pre>{@code
+     *     resolve(getFileSystem().getPath(other));
+     * }</pre>
+     *
      * @param   other
      *          the path string to resolve against this path
      *
@@ -489,7 +511,9 @@ public interface Path
      *
      * @see FileSystem#getPath
      */
-    Path resolve(String other);
+    default Path resolve(String other) {
+        return resolve(getFileSystem().getPath(other));
+    }
 
     /**
      * Resolves the given path against this path's {@link #getParent parent}
@@ -503,6 +527,14 @@ public interface Path
      * returns this path's parent, or where this path doesn't have a parent, the
      * empty path.
      *
+     * @implSpec
+     * The default implementation is equivalent for this path to:
+     * <pre>{@code
+     *     (getParent() == null) ? other : getParent().resolve(other);
+     * }</pre>
+     * unless {@code other == null}, in which case a
+     * {@code NullPointerException} is thrown.
+     *
      * @param   other
      *          the path to resolve against this path's parent
      *
@@ -510,13 +542,24 @@ public interface Path
      *
      * @see #resolve(Path)
      */
-    Path resolveSibling(Path other);
+    default Path resolveSibling(Path other) {
+        if (other == null)
+            throw new NullPointerException();
+        Path parent = getParent();
+        return (parent == null) ? other : parent.resolve(other);
+    }
 
     /**
      * Converts a given path string to a {@code Path} and resolves it against
      * this path's {@link #getParent parent} path in exactly the manner
      * specified by the {@link #resolveSibling(Path) resolveSibling} method.
      *
+     * @implSpec
+     * The default implementation is equivalent for this path to:
+     * <pre>{@code
+     *     resolveSibling(getFileSystem().getPath(other));
+     * }</pre>
+     *
      * @param   other
      *          the path string to resolve against this path's parent
      *
@@ -527,7 +570,9 @@ public interface Path
      *
      * @see FileSystem#getPath
      */
-    Path resolveSibling(String other);
+    default Path resolveSibling(String other) {
+        return resolveSibling(getFileSystem().getPath(other));
+    }
 
     /**
      * Constructs a relative path between this path and a given path.
@@ -548,7 +593,8 @@ public interface Path
      * <p> For any two {@link #normalize normalized} paths <i>p</i> and
      * <i>q</i>, where <i>q</i> does not have a root component,
      * <blockquote>
-     *   <i>p</i><tt>.relativize(</tt><i>p</i><tt>.resolve(</tt><i>q</i><tt>)).equals(</tt><i>q</i><tt>)</tt>
+     *   <i>p</i>{@code .relativize(}<i>p</i>
+     *   {@code .resolve(}<i>q</i>{@code )).equals(}<i>q</i>{@code )}
      * </blockquote>
      *
      * <p> When symbolic links are supported, then whether the resulting path,
@@ -593,9 +639,9 @@ public interface Path
      * <p> The default provider provides a similar <em>round-trip</em> guarantee
      * to the {@link java.io.File} class. For a given {@code Path} <i>p</i> it
      * is guaranteed that
-     * <blockquote><tt>
-     * {@link Paths#get(URI) Paths.get}(</tt><i>p</i><tt>.toUri()).equals(</tt><i>p</i>
-     * <tt>.{@link #toAbsolutePath() toAbsolutePath}())</tt>
+     * <blockquote>
+     * {@link Path#of(URI) Path.of}{@code (}<i>p</i>{@code .toUri()).equals(}<i>p</i>
+     * {@code .}{@link #toAbsolutePath() toAbsolutePath}{@code ())}
      * </blockquote>
      * so long as the original {@code Path}, the {@code URI}, and the new {@code
      * Path} are all created in (possibly different invocations of) the same
@@ -704,12 +750,28 @@ public interface Path
      * File} object returned by this method is {@link #equals equal} to the
      * original {@code File}.
      *
+     * @implSpec
+     * The default implementation is equivalent for this path to:
+     * <pre>{@code
+     *     new File(toString());
+     * }</pre>
+     * if the {@code FileSystem} which created this {@code Path} is the default
+     * file system; otherwise an {@code UnsupportedOperationException} is
+     * thrown.
+     *
      * @return  a {@code File} object representing this path
      *
      * @throws  UnsupportedOperationException
      *          if this {@code Path} is not associated with the default provider
      */
-    File toFile();
+    default File toFile() {
+        if (getFileSystem() == FileSystems.getDefault()) {
+            return new File(toString());
+        } else {
+            throw new UnsupportedOperationException("Path not associated with "
+                    + "default file system.");
+        }
+    }
 
     // -- watchable --
 
@@ -795,6 +857,13 @@ public interface Path
      *
      *     WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);
      * </pre>
+     *
+     * @implSpec
+     * The default implementation is equivalent for this path to:
+     * <pre>{@code
+     *     register(watcher, events, new WatchEvent.Modifier[0]);
+     * }</pre>
+     *
      * @param   watcher
      *          The watch service to which this object is to be registered
      * @param   events
@@ -820,9 +889,10 @@ public interface Path
      *          method is invoked to check read access to the file.
      */
     @Override
-    WatchKey register(WatchService watcher,
-                      WatchEvent.Kind<?>... events)
-        throws IOException;
+    default WatchKey register(WatchService watcher,
+                      WatchEvent.Kind<?>... events) throws IOException {
+        return register(watcher, events, new WatchEvent.Modifier[0]);
+    }
 
     // -- Iterable --
 
@@ -835,10 +905,36 @@ public interface Path
      * is the name of the file or directory denoted by this path. The {@link
      * #getRoot root} component, if present, is not returned by the iterator.
      *
+     * @implSpec
+     * The default implementation returns an {@code Iterator<Path>} which, for
+     * this path, traverses the {@code Path}s returned by
+     * {@code getName(index)}, where {@code index} ranges from zero to
+     * {@code getNameCount() - 1}, inclusive.
+     *
      * @return  an iterator over the name elements of this path.
      */
     @Override
-    Iterator<Path> iterator();
+    default Iterator<Path> iterator() {
+        return new Iterator<>() {
+            private int i = 0;
+
+            @Override
+            public boolean hasNext() {
+                return (i < getNameCount());
+            }
+
+            @Override
+            public Path next() {
+                if (i < getNameCount()) {
+                    Path result = getName(i);
+                    i++;
+                    return result;
+                } else {
+                    throw new NoSuchElementException();
+                }
+            }
+        };
+    }
 
     // -- compareTo/equals/hashCode --
 
diff --git a/ojluni/src/main/java/java/nio/file/Paths.java b/ojluni/src/main/java/java/nio/file/Paths.java
index bb49f99121e..4f177bac5c0 100644
--- a/ojluni/src/main/java/java/nio/file/Paths.java
+++ b/ojluni/src/main/java/java/nio/file/Paths.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -32,7 +32,13 @@ import java.net.URI;
  * This class consists exclusively of static methods that return a {@link Path}
  * by converting a path string or {@link URI}.
  *
+ * @apiNote
+ * It is recommended to obtain a {@code Path} via the {@code Path.of} methods
+ * instead of via the {@code get} methods defined in this class as this class
+ * may be deprecated in a future release.
+ *
  * @since 1.7
+ * @see Path
  */
 
 public final class Paths {
@@ -40,33 +46,11 @@ public final class Paths {
 
     /**
      * Converts a path string, or a sequence of strings that when joined form
-     * a path string, to a {@code Path}. If {@code more} does not specify any
-     * elements then the value of the {@code first} parameter is the path string
-     * to convert. If {@code more} specifies one or more elements then each
-     * non-empty string, including {@code first}, is considered to be a sequence
-     * of name elements (see {@link Path}) and is joined to form a path string.
-     * The details as to how the Strings are joined is provider specific but
-     * typically they will be joined using the {@link FileSystem#getSeparator
-     * name-separator} as the separator. For example, if the name separator is
-     * "{@code /}" and {@code getPath("/foo","bar","gus")} is invoked, then the
-     * path string {@code "/foo/bar/gus"} is converted to a {@code Path}.
-     * A {@code Path} representing an empty path is returned if {@code first}
-     * is the empty string and {@code more} does not contain any non-empty
-     * strings.
-     *
-     * <p> The {@code Path} is obtained by invoking the {@link FileSystem#getPath
-     * getPath} method of the {@link FileSystems#getDefault default} {@link
-     * FileSystem}.
+     * a path string, to a {@code Path}.
      *
-     * <p> Note that while this method is very convenient, using it will imply
-     * an assumed reference to the default {@code FileSystem} and limit the
-     * utility of the calling code. Hence it should not be used in library code
-     * intended for flexible reuse. A more flexible alternative is to use an
-     * existing {@code Path} instance as an anchor, such as:
-     * <pre>
-     *     Path dir = ...
-     *     Path path = dir.resolve("file");
-     * </pre>
+     * @implSpec
+     * This method simply invokes {@link Path#of(String,String...)
+     * Path.of(String, String...)} with the given parameters.
      *
      * @param   first
      *          the path string or initial part of the path string
@@ -79,38 +63,17 @@ public final class Paths {
      *          if the path string cannot be converted to a {@code Path}
      *
      * @see FileSystem#getPath
+     * @see Path#of(String,String...)
      */
     public static Path get(String first, String... more) {
-        return FileSystems.getDefault().getPath(first, more);
+        return Path.of(first, more);
     }
 
     /**
      * Converts the given URI to a {@link Path} object.
      *
-     * <p> This method iterates over the {@link FileSystemProvider#installedProviders()
-     * installed} providers to locate the provider that is identified by the
-     * URI {@link URI#getScheme scheme} of the given URI. URI schemes are
-     * compared without regard to case. If the provider is found then its {@link
-     * FileSystemProvider#getPath getPath} method is invoked to convert the
-     * URI.
-     *
-     * <p> In the case of the default provider, identified by the URI scheme
-     * "file", the given URI has a non-empty path component, and undefined query
-     * and fragment components. Whether the authority component may be present
-     * is platform specific. The returned {@code Path} is associated with the
-     * {@link FileSystems#getDefault default} file system.
-     *
-     * <p> The default provider provides a similar <em>round-trip</em> guarantee
-     * to the {@link java.io.File} class. For a given {@code Path} <i>p</i> it
-     * is guaranteed that
-     * <blockquote><tt>
-     * Paths.get(</tt><i>p</i><tt>.{@link Path#toUri() toUri}()).equals(</tt>
-     * <i>p</i><tt>.{@link Path#toAbsolutePath() toAbsolutePath}())</tt>
-     * </blockquote>
-     * so long as the original {@code Path}, the {@code URI}, and the new {@code
-     * Path} are all created in (possibly different invocations of) the same
-     * Java virtual machine. Whether other providers make any guarantees is
-     * provider specific and therefore unspecified.
+     * @implSpec
+     * This method simply invokes {@link Path#of(URI) * Path.of(URI)} with the given parameter.
      *
      * @param   uri
      *          the URI to convert
@@ -127,23 +90,10 @@ public final class Paths {
      * @throws  SecurityException
      *          if a security manager is installed and it denies an unspecified
      *          permission to access the file system
+     *
+     * @see Path#of(URI)
      */
     public static Path get(URI uri) {
-        String scheme =  uri.getScheme();
-        if (scheme == null)
-            throw new IllegalArgumentException("Missing scheme");
-
-        // check for default provider to avoid loading of installed providers
-        if (scheme.equalsIgnoreCase("file"))
-            return FileSystems.getDefault().provider().getPath(uri);
-
-        // try to find provider
-        for (FileSystemProvider provider: FileSystemProvider.installedProviders()) {
-            if (provider.getScheme().equalsIgnoreCase(scheme)) {
-                return provider.getPath(uri);
-            }
-        }
-
-        throw new FileSystemNotFoundException("Provider \"" + scheme + "\" not installed");
+        return Path.of(uri);
     }
 }
diff --git a/ojluni/src/main/java/java/nio/file/spi/FileSystemProvider.java b/ojluni/src/main/java/java/nio/file/spi/FileSystemProvider.java
index bed84168cef..51b6fe39f52 100644
--- a/ojluni/src/main/java/java/nio/file/spi/FileSystemProvider.java
+++ b/ojluni/src/main/java/java/nio/file/spi/FileSystemProvider.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,18 +25,54 @@
 
 package java.nio.file.spi;
 
-import java.nio.file.*;
-import java.nio.file.attribute.*;
-import java.nio.channels.*;
+import java.nio.channels.AsynchronousFileChannel;
+import java.nio.channels.Channels;
+import java.nio.channels.FileChannel;
+import java.nio.channels.ReadableByteChannel;
+import java.nio.channels.SeekableByteChannel;
+import java.nio.channels.WritableByteChannel;
+import java.nio.file.AccessDeniedException;
+import java.nio.file.AccessMode;
+import java.nio.file.AtomicMoveNotSupportedException;
+import java.nio.file.CopyOption;
+import java.nio.file.DirectoryNotEmptyException;
+import java.nio.file.DirectoryStream;
+import java.nio.file.FileAlreadyExistsException;
+import java.nio.file.FileStore;
+import java.nio.file.FileSystem;
+import java.nio.file.FileSystemAlreadyExistsException;
+import java.nio.file.FileSystemNotFoundException;
+import java.nio.file.FileSystems;
+import java.nio.file.Files;
+import java.nio.file.LinkOption;
+import java.nio.file.LinkPermission;
+import java.nio.file.NoSuchFileException;
+import java.nio.file.NotDirectoryException;
+import java.nio.file.NotLinkException;
+import java.nio.file.OpenOption;
+import java.nio.file.Path;
+import java.nio.file.StandardOpenOption;
 import java.net.URI;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.IOException;
-import java.util.*;
+import java.nio.file.attribute.BasicFileAttributes;
+import java.nio.file.attribute.FileAttribute;
+import java.nio.file.attribute.FileAttributeView;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.ServiceConfigurationError;
+import java.util.ServiceLoader;
+import java.util.Set;
 import java.util.concurrent.ExecutorService;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 
+import sun.nio.ch.FileChannelImpl;
+
 /**
  * Service-provider class for file systems. The methods defined by the {@link
  * java.nio.file.Files} class will typically delegate to an instance of this
@@ -81,7 +117,7 @@ public abstract class FileSystemProvider {
     // installed providers
     private static volatile List<FileSystemProvider> installedProviders;
 
-    // used to avoid recursive loading of instaled providers
+    // used to avoid recursive loading of installed providers
     private static boolean loadingProviders  = false;
 
     private static Void checkPermission() {
@@ -102,7 +138,7 @@ public abstract class FileSystemProvider {
      *
      * @throws  SecurityException
      *          If a security manager has been installed and it denies
-     *          {@link RuntimePermission}<tt>("fileSystemProvider")</tt>
+     *          {@link RuntimePermission}{@code ("fileSystemProvider")}
      */
     protected FileSystemProvider() {
         this(checkPermission());
@@ -110,7 +146,7 @@ public abstract class FileSystemProvider {
 
     // loads all installed providers
     private static List<FileSystemProvider> loadInstalledProviders() {
-        List<FileSystemProvider> list = new ArrayList<FileSystemProvider>();
+        List<FileSystemProvider> list = new ArrayList<>();
 
         ServiceLoader<FileSystemProvider> sl = ServiceLoader
             .load(FileSystemProvider.class, ClassLoader.getSystemClassLoader());
@@ -163,7 +199,7 @@ public abstract class FileSystemProvider {
                     loadingProviders = true;
 
                     List<FileSystemProvider> list = AccessController
-                        .doPrivileged(new PrivilegedAction<List<FileSystemProvider>>() {
+                        .doPrivileged(new PrivilegedAction<>() {
                             @Override
                             public List<FileSystemProvider> run() {
                                 return loadInstalledProviders();
@@ -381,9 +417,17 @@ public abstract class FileSystemProvider {
                     throw new UnsupportedOperationException("'" + opt + "' not allowed");
             }
         }
-        return Channels.newInputStream(Files.newByteChannel(path, options));
+        ReadableByteChannel rbc = Files.newByteChannel(path, options);
+        if (rbc instanceof FileChannelImpl) {
+            ((FileChannelImpl) rbc).setUninterruptible();
+        }
+        return Channels.newInputStream(rbc);
     }
 
+    private static final Set<OpenOption> DEFAULT_OPEN_OPTIONS =
+        Set.of(StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING,
+            StandardOpenOption.WRITE);
+
     /**
      * Opens or creates a file, returning an output stream that may be used to
      * write bytes to the file. This method works in exactly the manner
@@ -419,19 +463,23 @@ public abstract class FileSystemProvider {
         throws IOException
     {
         int len = options.length;
-        Set<OpenOption> opts = new HashSet<OpenOption>(len + 3);
+        Set<OpenOption> opts ;
         if (len == 0) {
-            opts.add(StandardOpenOption.CREATE);
-            opts.add(StandardOpenOption.TRUNCATE_EXISTING);
+            opts = DEFAULT_OPEN_OPTIONS;
         } else {
+            opts = new HashSet<>();
             for (OpenOption opt: options) {
                 if (opt == StandardOpenOption.READ)
                     throw new IllegalArgumentException("READ not allowed");
                 opts.add(opt);
             }
+            opts.add(StandardOpenOption.WRITE);
+        }
+        WritableByteChannel wbc = newByteChannel(path, opts);
+        if (wbc instanceof FileChannelImpl) {
+            ((FileChannelImpl) wbc).setUninterruptible();
         }
-        opts.add(StandardOpenOption.WRITE);
-        return Channels.newOutputStream(newByteChannel(path, opts));
+        return Channels.newOutputStream(wbc);
     }
 
     /**
@@ -644,7 +692,7 @@ public abstract class FileSystemProvider {
      *          if an I/O error occurs
      * @throws  SecurityException
      *          In the case of the default provider, and a security manager
-     *          is installed, it denies {@link LinkPermission}<tt>("symbolic")</tt>
+     *          is installed, it denies {@link LinkPermission}{@code ("symbolic")}
      *          or its {@link SecurityManager#checkWrite(String) checkWrite}
      *          method denies write access to the path of the symbolic link.
      */
@@ -677,7 +725,7 @@ public abstract class FileSystemProvider {
      *          if an I/O error occurs
      * @throws  SecurityException
      *          In the case of the default provider, and a security manager
-     *          is installed, it denies {@link LinkPermission}<tt>("hard")</tt>
+     *          is installed, it denies {@link LinkPermission}{@code ("hard")}
      *          or its {@link SecurityManager#checkWrite(String) checkWrite}
      *          method denies write access to either the  link or the
      *          existing file.
@@ -902,8 +950,8 @@ public abstract class FileSystemProvider {
      *          In the case of the default provider, and a security manager is
      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
      *          method is invoked to check read access to the file, and in
-     *          addition it checks {@link RuntimePermission}<tt>
-     *          ("getFileStoreAttributes")</tt>
+     *          addition it checks
+     *          {@link RuntimePermission}{@code ("getFileStoreAttributes")}
      */
     public abstract FileStore getFileStore(Path path) throws IOException;
 
@@ -919,20 +967,24 @@ public abstract class FileSystemProvider {
      * according to all of access modes specified in the {@code modes} parameter
      * as follows:
      *
-     * <table border=1 cellpadding=5 summary="">
-     * <tr> <th>Value</th> <th>Description</th> </tr>
+     * <table class="striped">
+     * <caption style="display:none">Access Modes</caption>
+     * <thead>
+     * <tr> <th scope="col">Value</th> <th scope="col">Description</th> </tr>
+     * </thead>
+     * <tbody>
      * <tr>
-     *   <td> {@link AccessMode#READ READ} </td>
+     *   <th scope="row"> {@link AccessMode#READ READ} </th>
      *   <td> Checks that the file exists and that the Java virtual machine has
      *     permission to read the file. </td>
      * </tr>
      * <tr>
-     *   <td> {@link AccessMode#WRITE WRITE} </td>
+     *   <th scope="row"> {@link AccessMode#WRITE WRITE} </th>
      *   <td> Checks that the file exists and that the Java virtual machine has
      *     permission to write to the file, </td>
      * </tr>
      * <tr>
-     *   <td> {@link AccessMode#EXECUTE EXECUTE} </td>
+     *   <th scope="row"> {@link AccessMode#EXECUTE EXECUTE} </th>
      *   <td> Checks that the file exists and that the Java virtual machine has
      *     permission to {@link Runtime#exec execute} the file. The semantics
      *     may differ when checking access to a directory. For example, on UNIX
@@ -940,6 +992,7 @@ public abstract class FileSystemProvider {
      *     virtual machine has permission to search the directory in order to
      *     access file or subdirectories. </td>
      * </tr>
+     * </tbody>
      * </table>
      *
      * <p> If the {@code modes} parameter is of length zero, then the existence
diff --git a/ojluni/src/main/java/java/nio/file/spi/FileTypeDetector.java b/ojluni/src/main/java/java/nio/file/spi/FileTypeDetector.java
index ee118d63129..1e06a119331 100644
--- a/ojluni/src/main/java/java/nio/file/spi/FileTypeDetector.java
+++ b/ojluni/src/main/java/java/nio/file/spi/FileTypeDetector.java
@@ -62,7 +62,7 @@ public abstract class FileTypeDetector {
      *
      * @throws  SecurityException
      *          If a security manager has been installed and it denies
-     *          {@link RuntimePermission}<tt>("fileTypeDetector")</tt>
+     *          {@link RuntimePermission}{@code ("fileTypeDetector")}
      */
     protected FileTypeDetector() {
         this(checkPermission());
diff --git a/ojluni/src/main/java/java/security/AlgorithmParameterGenerator.java b/ojluni/src/main/java/java/security/AlgorithmParameterGenerator.java
index 39aef17fd46..03fbaba6f9c 100644
--- a/ojluni/src/main/java/java/security/AlgorithmParameterGenerator.java
+++ b/ojluni/src/main/java/java/security/AlgorithmParameterGenerator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -30,6 +30,7 @@ import dalvik.system.VMRuntime;
 
 import java.security.spec.AlgorithmParameterSpec;
 import java.util.Objects;
+import sun.security.jca.JCAUtil;
 
 /**
  * The {@code AlgorithmParameterGenerator} class is used to generate a
@@ -320,7 +321,7 @@ public class AlgorithmParameterGenerator {
      * @param size the size (number of bits).
      */
     public final void init(int size) {
-        paramGenSpi.engineInit(size, new SecureRandom());
+        paramGenSpi.engineInit(size, JCAUtil.getDefSecureRandom());
     }
 
     /**
@@ -351,7 +352,7 @@ public class AlgorithmParameterGenerator {
      */
     public final void init(AlgorithmParameterSpec genParamSpec)
         throws InvalidAlgorithmParameterException {
-            paramGenSpi.engineInit(genParamSpec, new SecureRandom());
+            paramGenSpi.engineInit(genParamSpec, JCAUtil.getDefSecureRandom());
     }
 
     /**
diff --git a/ojluni/src/main/java/java/security/CodeSigner.java b/ojluni/src/main/java/java/security/CodeSigner.java
index a1d37ee208a..26793a7c15d 100644
--- a/ojluni/src/main/java/java/security/CodeSigner.java
+++ b/ojluni/src/main/java/java/security/CodeSigner.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -156,9 +156,9 @@ public final class CodeSigner implements Serializable {
     public String toString() {
         StringBuilder sb = new StringBuilder();
         sb.append("(");
-        sb.append("Signer: " + signerCertPath.getCertificates().get(0));
+        sb.append("Signer: ").append(signerCertPath.getCertificates().get(0));
         if (timestamp != null) {
-            sb.append("timestamp: " + timestamp);
+            sb.append("timestamp: ").append(timestamp);
         }
         sb.append(")");
         return sb.toString();
@@ -166,8 +166,11 @@ public final class CodeSigner implements Serializable {
 
     // Explicitly reset hash code value to -1
     private void readObject(ObjectInputStream ois)
-        throws IOException, ClassNotFoundException {
-     ois.defaultReadObject();
-     myhash = -1;
+            throws IOException, ClassNotFoundException {
+        ois.defaultReadObject();
+        if (signerCertPath == null) {
+            throw new InvalidObjectException("signerCertPath is null");
+        }
+        myhash = -1;
     }
 }
diff --git a/ojluni/src/main/java/java/security/KeyPairGenerator.java b/ojluni/src/main/java/java/security/KeyPairGenerator.java
index 03de315ff78..a62208b1ea7 100644
--- a/ojluni/src/main/java/java/security/KeyPairGenerator.java
+++ b/ojluni/src/main/java/java/security/KeyPairGenerator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -398,7 +398,7 @@ public abstract class KeyPairGenerator extends KeyPairGeneratorSpi {
      * supported by this KeyPairGenerator object.
      */
     public void initialize(int keysize) {
-        initialize(keysize, JCAUtil.getSecureRandom());
+        initialize(keysize, JCAUtil.getDefSecureRandom());
     }
 
     /**
@@ -458,7 +458,7 @@ public abstract class KeyPairGenerator extends KeyPairGeneratorSpi {
      */
     public void initialize(AlgorithmParameterSpec params)
             throws InvalidAlgorithmParameterException {
-        initialize(params, JCAUtil.getSecureRandom());
+        initialize(params, JCAUtil.getDefSecureRandom());
     }
 
     /**
diff --git a/ojluni/src/main/java/java/security/PKCS12Attribute.java b/ojluni/src/main/java/java/security/PKCS12Attribute.java
index 4a8ebfb64c0..d0cfde08621 100644
--- a/ojluni/src/main/java/java/security/PKCS12Attribute.java
+++ b/ojluni/src/main/java/java/security/PKCS12Attribute.java
@@ -76,6 +76,8 @@ public final class PKCS12Attribute implements KeyStore.Entry.Attribute {
         // Validate name
         ObjectIdentifier type;
         try {
+            // Android-change: Temporary patch until ObjectIdentifier is updated to 11.
+            // type = ObjectIdentifier.of(name);
             type = new ObjectIdentifier(name);
         } catch (IOException e) {
             throw new IllegalArgumentException("Incorrect format: name", e);
diff --git a/ojluni/src/main/java/java/security/UnresolvedPermission.java b/ojluni/src/main/java/java/security/UnresolvedPermission.java
index 7e535dac207..c71adc18f8d 100644
--- a/ojluni/src/main/java/java/security/UnresolvedPermission.java
+++ b/ojluni/src/main/java/java/security/UnresolvedPermission.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -41,13 +41,12 @@ import java.security.cert.*;
  */
 
 public final class UnresolvedPermission extends Permission
-implements java.io.Serializable
-{
+implements java.io.Serializable {
 
     public UnresolvedPermission(String type,
-                                String name,
-                                String actions,
-                                java.security.cert.Certificate certs[]) { super(""); }
+            String name,
+            String actions,
+            java.security.cert.Certificate certs[]) { super(""); }
 
     public boolean implies(Permission p) { return false; }
 
diff --git a/ojluni/src/main/java/java/text/MessageFormat.java b/ojluni/src/main/java/java/text/MessageFormat.java
index 64e653ec575..1f8bcb89a9c 100644
--- a/ojluni/src/main/java/java/text/MessageFormat.java
+++ b/ojluni/src/main/java/java/text/MessageFormat.java
@@ -42,6 +42,7 @@ package java.text;
 import java.io.InvalidObjectException;
 import java.io.IOException;
 import java.io.ObjectInputStream;
+import java.io.ObjectStreamException;
 import java.text.DecimalFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -983,6 +984,8 @@ public class MessageFormat extends Format {
                 maximumArgumentNumber = argumentNumbers[i];
             }
         }
+
+        // Constructors/applyPattern ensure that resultArray.length < MAX_ARGUMENT_INDEX
         Object[] resultArray = new Object[maximumArgumentNumber + 1];
 
         int patternOffset = 0;
@@ -1235,6 +1238,9 @@ public class MessageFormat extends Format {
      * @serial
      */
     private int[] argumentNumbers = new int[INITIAL_FORMATS];
+    // Implementation limit for ArgumentIndex pattern element. Valid indices must
+    // be less than this value
+    private static final int MAX_ARGUMENT_INDEX = 10000;
 
     /**
      * One less than the number of entries in {@code offsets}.  Can also be thought of
@@ -1459,6 +1465,11 @@ public class MessageFormat extends Format {
                                                + argumentNumber);
         }
 
+        if (argumentNumber >= MAX_ARGUMENT_INDEX) {
+            throw new IllegalArgumentException(
+                    argumentNumber + " exceeds the ArgumentIndex implementation limit");
+        }
+
         // resize format information arrays if necessary
         if (offsetNumber >= formats.length) {
             int newLength = formats.length * 2;
@@ -1606,24 +1617,53 @@ public class MessageFormat extends Format {
      */
     @java.io.Serial
     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
-        in.defaultReadObject();
-        boolean isValid = maxOffset >= -1
-                && formats.length > maxOffset
-                && offsets.length > maxOffset
-                && argumentNumbers.length > maxOffset;
+        ObjectInputStream.GetField fields = in.readFields();
+        if (fields.defaulted("argumentNumbers") || fields.defaulted("offsets")
+                || fields.defaulted("formats") || fields.defaulted("locale")
+                || fields.defaulted("pattern") || fields.defaulted("maxOffset")){
+            throw new InvalidObjectException("Stream has missing data");
+        }
+
+        locale = (Locale) fields.get("locale", null);
+        String patt = (String) fields.get("pattern", null);
+        int maxOff = fields.get("maxOffset", -2);
+        int[] argNums = ((int[]) fields.get("argumentNumbers", null)).clone();
+        int[] offs = ((int[]) fields.get("offsets", null)).clone();
+        Format[] fmts = ((Format[]) fields.get("formats", null)).clone();
+
+        // Check arrays/maxOffset have correct value/length
+        boolean isValid = maxOff >= -1 && argNums.length > maxOff
+                && offs.length > maxOff && fmts.length > maxOff;
+
+        // Check the correctness of arguments and offsets
         if (isValid) {
-            int lastOffset = pattern.length() + 1;
-            for (int i = maxOffset; i >= 0; --i) {
-                if ((offsets[i] < 0) || (offsets[i] > lastOffset)) {
+            int lastOffset = patt.length() + 1;
+            for (int i = maxOff; i >= 0; --i) {
+                if (argNums[i] < 0 || argNums[i] >= MAX_ARGUMENT_INDEX
+                        || offs[i] < 0 || offs[i] > lastOffset) {
                     isValid = false;
                     break;
                 } else {
-                    lastOffset = offsets[i];
+                    lastOffset = offs[i];
                 }
             }
         }
+
         if (!isValid) {
-            throw new InvalidObjectException("Could not reconstruct MessageFormat from corrupt stream.");
+            throw new InvalidObjectException("Stream has invalid data");
         }
+        maxOffset = maxOff;
+        pattern = patt;
+        offsets = offs;
+        formats = fmts;
+        argumentNumbers = argNums;
+    }
+
+    /**
+     * Serialization without data not supported for this class.
+     */
+    @java.io.Serial
+    private void readObjectNoData() throws ObjectStreamException {
+        throw new InvalidObjectException("Deserialized MessageFormat objects need data");
     }
 }
diff --git a/ojluni/src/main/java/java/time/ZoneId.java b/ojluni/src/main/java/java/time/ZoneId.java
index 5a836514943..017e26f7983 100644
--- a/ojluni/src/main/java/java/time/ZoneId.java
+++ b/ojluni/src/main/java/java/time/ZoneId.java
@@ -83,6 +83,8 @@ import java.util.Objects;
 import java.util.Set;
 import java.util.TimeZone;
 
+import libcore.util.ZoneInfo;
+
 import static java.util.Map.entry;
 
 // Android-changed: removed ValueBased paragraph.
@@ -265,7 +267,15 @@ public abstract class ZoneId implements Serializable {
      * @throws ZoneRulesException if the converted zone region ID cannot be found
      */
     public static ZoneId systemDefault() {
-        return TimeZone.getDefault().toZoneId();
+        // BEGIN Android-changed: don't call TimeZone.clone() if possible.
+        // return TimeZone.getDefault().toZoneId();
+        TimeZone defaultTimeZone = TimeZone.getDefaultRef();
+        if (defaultTimeZone instanceof ZoneInfo) {
+            return defaultTimeZone.toZoneId();
+        } else {
+            return ((TimeZone) defaultTimeZone.clone()).toZoneId();
+        }
+        // END Android-changed: don't call TimeZone.clone() if possible.
     }
 
     /**
diff --git a/ojluni/src/main/java/java/time/format/DateTimeFormatter.java b/ojluni/src/main/java/java/time/format/DateTimeFormatter.java
index c065e777d68..3e635bc16b7 100644
--- a/ojluni/src/main/java/java/time/format/DateTimeFormatter.java
+++ b/ojluni/src/main/java/java/time/format/DateTimeFormatter.java
@@ -2238,29 +2238,23 @@ public final class DateTimeFormatter {
             DateTimeParseContext context;
             try {
                 context = formatter.parseUnresolved0(text, pos);
-            } catch (IndexOutOfBoundsException ex) {
-                if (pos.getErrorIndex() < 0) {
-                    pos.setErrorIndex(0);
-                }
-                return null;
-            }
-            if (context == null) {
-                if (pos.getErrorIndex() < 0) {
-                    pos.setErrorIndex(0);
+                if (context == null) {
+                    if (pos.getErrorIndex() < 0) {
+                        pos.setErrorIndex(0);
+                    }
+                    return null;
                 }
-                return null;
-            }
-            try {
                 TemporalAccessor resolved = context.toResolved(formatter.resolverStyle, formatter.resolverFields);
                 if (parseType == null) {
                     return resolved;
                 }
                 return resolved.query(parseType);
             } catch (RuntimeException ex) {
-                pos.setErrorIndex(0);
+                if (pos.getErrorIndex() < 0) {
+                    pos.setErrorIndex(0);
+                }
                 return null;
             }
         }
     }
-
 }
diff --git a/ojluni/src/main/java/java/time/format/DateTimeFormatterBuilder.java b/ojluni/src/main/java/java/time/format/DateTimeFormatterBuilder.java
index 4028d225732..9ca5b962fa8 100644
--- a/ojluni/src/main/java/java/time/format/DateTimeFormatterBuilder.java
+++ b/ojluni/src/main/java/java/time/format/DateTimeFormatterBuilder.java
@@ -4263,11 +4263,12 @@ public final class DateTimeFormatterBuilder {
             return true;
         }
 
-        // cache per instance for now
+        // Cache per instance for now. These HashMaps normally contain a single
+        // element, initialize them with initial capacity = 2 to avoid resizes due to load factor.
         private final Map<Locale, Entry<Integer, SoftReference<PrefixTree>>>
-            cachedTree = new HashMap<>();
+            cachedTree = new HashMap<>(2);
         private final Map<Locale, Entry<Integer, SoftReference<PrefixTree>>>
-            cachedTreeCI = new HashMap<>();
+            cachedTreeCI = new HashMap<>(2);
 
         @Override
         protected PrefixTree getTree(DateTimeParseContext context) {
@@ -4276,8 +4277,10 @@ public final class DateTimeFormatterBuilder {
             }
             Locale locale = context.getLocale();
             boolean isCaseSensitive = context.isCaseSensitive();
-            Set<String> regionIds = new HashSet<>(ZoneRulesProvider.getAvailableZoneIds());
-            Set<String> nonRegionIds = new HashSet<>(64);
+            // Android-changed: Renamed to regionIds to avoid an extra HashSet object.
+            //Set<String> availableZoneIds = ZoneRulesProvider.getAvailableZoneIds();
+            //int regionIdsSize = availableZoneIds.size();
+            Set<String> regionIds = ZoneRulesProvider.getAvailableZoneIds();
             int regionIdsSize = regionIds.size();
 
             Map<Locale, Entry<Integer, SoftReference<PrefixTree>>> cached =
@@ -4293,6 +4296,8 @@ public final class DateTimeFormatterBuilder {
                 // BEGIN Android-changed: use ICU TimeZoneNames to get Zone names.
                 /*
                 zoneStrings = TimeZoneNameUtility.getZoneStrings(locale);
+                Set<String> nonRegionIds = new HashSet<>(64);
+                Set<String> regionIds = new HashSet<>(availableZoneIds);
                 for (String[] names : zoneStrings) {
                     String zid = names[0];
                     if (!regionIds.remove(zid)) {
@@ -4452,8 +4457,10 @@ public final class DateTimeFormatterBuilder {
                     if (length >= position + 3 && context.charEquals(text.charAt(position + 2), 'C')) {
                         // There are localized zone texts that start with "UTC", e.g.
                         // "UTC\u221210:00" (MINUS SIGN instead of HYPHEN-MINUS) in French.
-                        // Exclude those ZoneText cases.
-                        if (!(this instanceof ZoneTextPrinterParser)) {
+                        // Exclude those cases.
+                        if (length == position + 3 ||
+                                context.charEquals(text.charAt(position + 3), '+') ||
+                                context.charEquals(text.charAt(position + 3), '-')) {
                             return parseOffsetBased(context, text, position, position + 3, OffsetIdPrinterParser.INSTANCE_ID_ZERO);
                         }
                     } else {
diff --git a/ojluni/src/main/java/java/util/Formatter.java b/ojluni/src/main/java/java/util/Formatter.java
index c968530d7ef..116fbd3c047 100644
--- a/ojluni/src/main/java/java/util/Formatter.java
+++ b/ojluni/src/main/java/java/util/Formatter.java
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2014 The Android Open Source Project
- * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -4713,10 +4713,9 @@ public final class Formatter implements Closeable, Flushable {
             }
 
             // apply zero padding
-            if (width != -1 && f.contains(Flags.ZERO_PAD)) {
-                for (int k = sb.length(); k < width; k++) {
-                    sb.insert(begin, zero);
-                }
+            if (width > sb.length() && f.contains(Flags.ZERO_PAD)) {
+                String zeros = String.valueOf(zero).repeat(width - sb.length());
+                sb.insert(begin, zeros);
             }
 
             return sb;
diff --git a/ojluni/src/main/java/java/util/ImmutableCollections.java b/ojluni/src/main/java/java/util/ImmutableCollections.java
index 93bdda42702..ba75a97740e 100644
--- a/ojluni/src/main/java/java/util/ImmutableCollections.java
+++ b/ojluni/src/main/java/java/util/ImmutableCollections.java
@@ -49,44 +49,53 @@ import jdk.internal.vm.annotation.Stable;
  */
 @SuppressWarnings("serial")
 class ImmutableCollections {
-    /**
-     * A "salt" value used for randomizing iteration order. This is initialized once
-     * and stays constant for the lifetime of the JVM. It need not be truly random, but
-     * it needs to vary sufficiently from one run to the next so that iteration order
-     * will vary between JVM runs.
-     */
-    private static final long SALT32L;
 
+    // BEGIN Android-changed: allow ImmutableCollections initialization in Zygote.
     /**
-     * For set and map iteration, we will iterate in "reverse" stochastically,
-     * decided at bootstrap time.
+     * A holder class for static fields that should be randomized after device reboot,
+     * and thus shouldn't be initialized in the ART boot image (dex2oat).
      */
-    private static final boolean REVERSE;
-    static {
-        // to generate a reasonably random and well-mixed SALT, use an arbitrary
-        // value (a slice of pi), multiply with a random seed, then pick
-        // the mid 32-bits from the product. By picking a SALT value in the
-        // [0 ... 0xFFFF_FFFFL == 2^32-1] range, we ensure that for any positive
-        // int N, (SALT32L * N) >> 32 is a number in the [0 ... N-1] range. This
-        // property will be used to avoid more expensive modulo-based
-        // calculations.
-        long color = 0x243F_6A88_85A3_08D3L; // slice of pi
-
-        // BEGIN Android-changed: set seed directly, as CDS is not available.
-        // When running with -Xshare:dump, the VM will supply a "random" seed that's
-        // derived from the JVM build/version, so can we generate the exact same
-        // CDS archive for the same JDK build. This makes it possible to verify the
-        // consistency of the JDK build.
-        // long seed = CDS.getRandomSeedForDumping();
-        // if (seed == 0) {
-        //   seed = System.nanoTime();
-        // }
-        long seed = System.nanoTime();
-        // END Android-changed: set seed directly, as CDS is not available.
-        SALT32L = (int)((color * seed) >> 16) & 0xFFFF_FFFFL;
-        // use the lowest bit to determine if we should reverse iteration
-        REVERSE = (SALT32L & 1) == 0;
+    private static class NoPreloadHolder {
+        /**
+         * A "salt" value used for randomizing iteration order. This is initialized once
+         * and stays constant for the lifetime of the JVM. It need not be truly random, but
+         * it needs to vary sufficiently from one run to the next so that iteration order
+         * will vary between JVM runs.
+         */
+        private static final long SALT32L;
+
+        /**
+         * For set and map iteration, we will iterate in "reverse" stochastically,
+         * decided at bootstrap time.
+         */
+        private static final boolean REVERSE;
+        static {
+            // to generate a reasonably random and well-mixed SALT, use an arbitrary
+            // value (a slice of pi), multiply with a random seed, then pick
+            // the mid 32-bits from the product. By picking a SALT value in the
+            // [0 ... 0xFFFF_FFFFL == 2^32-1] range, we ensure that for any positive
+            // int N, (SALT32L * N) >> 32 is a number in the [0 ... N-1] range. This
+            // property will be used to avoid more expensive modulo-based
+            // calculations.
+            long color = 0x243F_6A88_85A3_08D3L; // slice of pi
+
+            // BEGIN Android-changed: set seed directly, as CDS is not available.
+            // When running with -Xshare:dump, the VM will supply a "random" seed that's
+            // derived from the JVM build/version, so can we generate the exact same
+            // CDS archive for the same JDK build. This makes it possible to verify the
+            // consistency of the JDK build.
+            // long seed = CDS.getRandomSeedForDumping();
+            // if (seed == 0) {
+            //   seed = System.nanoTime();
+            // }
+            long seed = System.nanoTime();
+            // END Android-changed: set seed directly, as CDS is not available.
+            SALT32L = (int)((color * seed) >> 16) & 0xFFFF_FFFFL;
+            // use the lowest bit to determine if we should reverse iteration
+            REVERSE = (SALT32L & 1) == 0;
+        }
     }
+    // END Android-changed: allow ImmutableCollections initialization in Zygote.
 
     // BEGIN Android-changed: always initialize empty collections.
     /*
@@ -844,10 +853,10 @@ class ImmutableCollections {
                 public E next() {
                     if (idx == 1) {
                         idx = 0;
-                        return (REVERSE || e1 == EMPTY) ? e0 : (E)e1;
+                        return (NoPreloadHolder.REVERSE || e1 == EMPTY) ? e0 : (E)e1;
                     } else if (idx == 2) {
                         idx = 1;
-                        return REVERSE ? (E)e1 : e0;
+                        return NoPreloadHolder.REVERSE ? (E)e1 : e0;
                     } else {
                         throw new NoSuchElementException();
                     }
@@ -873,7 +882,7 @@ class ImmutableCollections {
         public Object[] toArray() {
             if (e1 == EMPTY) {
                 return new Object[] { e0 };
-            } else if (REVERSE) {
+            } else if (NoPreloadHolder.REVERSE) {
                 return new Object[] { e1, e0 };
             } else {
                 return new Object[] { e0, e1 };
@@ -888,7 +897,7 @@ class ImmutableCollections {
                     (T[])Array.newInstance(a.getClass().getComponentType(), size);
             if (size == 1) {
                 array[0] = (T)e0;
-            } else if (REVERSE) {
+            } else if (NoPreloadHolder.REVERSE) {
                 array[0] = (T)e1;
                 array[1] = (T)e0;
             } else {
@@ -962,7 +971,7 @@ class ImmutableCollections {
                 remaining = size;
                 // pick a starting index in the [0 .. element.length-1] range
                 // randomly based on SALT32L
-                idx = (int) ((SALT32L * elements.length) >>> 32);
+                idx = (int) ((NoPreloadHolder.SALT32L * elements.length) >>> 32);
             }
 
             @Override
@@ -978,7 +987,7 @@ class ImmutableCollections {
                     int len = elements.length;
                     // step to the next element; skip null elements
                     do {
-                        if (REVERSE) {
+                        if (NoPreloadHolder.REVERSE) {
                             if (++idx >= len) {
                                 idx = 0;
                             }
@@ -1274,7 +1283,7 @@ class ImmutableCollections {
                 remaining = size;
                 // pick an even starting index in the [0 .. table.length-1]
                 // range randomly based on SALT32L
-                idx = (int) ((SALT32L * (table.length >> 1)) >>> 32) << 1;
+                idx = (int) ((NoPreloadHolder.SALT32L * (table.length >> 1)) >>> 32) << 1;
             }
 
             @Override
@@ -1284,7 +1293,7 @@ class ImmutableCollections {
 
             private int nextIndex() {
                 int idx = this.idx;
-                if (REVERSE) {
+                if (NoPreloadHolder.REVERSE) {
                     if ((idx += 2) >= table.length) {
                         idx = 0;
                     }
diff --git a/ojluni/src/main/java/java/util/TimeZone.java b/ojluni/src/main/java/java/util/TimeZone.java
index 64e3b298115..315e4a1989f 100644
--- a/ojluni/src/main/java/java/util/TimeZone.java
+++ b/ojluni/src/main/java/java/util/TimeZone.java
@@ -777,11 +777,14 @@ public abstract class TimeZone implements Serializable, Cloneable {
         return (TimeZone) getDefaultRef().clone();
     }
 
+    // Made public and hidden to be accessible from java.time package.
     /**
      * Returns the reference to the default TimeZone object. This
      * method doesn't create a clone.
+     *
+     * @hide
      */
-    static synchronized TimeZone getDefaultRef() {
+    public static synchronized TimeZone getDefaultRef() {
         if (defaultTimeZone == null) {
             Supplier<String> tzGetter = RuntimeHooks.getTimeZoneIdSupplier();
             String zoneName = (tzGetter != null) ? tzGetter.get() : null;
diff --git a/ojluni/src/main/java/java/util/concurrent/ForkJoinPool.java b/ojluni/src/main/java/java/util/concurrent/ForkJoinPool.java
index 677f55246e1..e66b06eadfc 100644
--- a/ojluni/src/main/java/java/util/concurrent/ForkJoinPool.java
+++ b/ojluni/src/main/java/java/util/concurrent/ForkJoinPool.java
@@ -52,7 +52,10 @@ import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.locks.LockSupport;
 import java.util.concurrent.locks.ReentrantLock;
 import java.util.concurrent.locks.Condition;
+
+import jdk.internal.access.SharedSecrets;
 import jdk.internal.misc.Unsafe;
+import jdk.internal.vm.SharedThreadContainer;
 
 // Android-changed: Substituted @systemProperty tag with @code.
 /**
@@ -989,11 +992,9 @@ public class ForkJoinPool extends AbstractExecutorService {
         implements ForkJoinWorkerThreadFactory {
         public final ForkJoinWorkerThread newThread(ForkJoinPool pool) {
             boolean isCommon = (pool.workerNamePrefix == null);
-            @SuppressWarnings("removal")
-            SecurityManager sm = System.getSecurityManager();
-            if (sm == null)
-                return new ForkJoinWorkerThread(null, pool, true, false);
-            else if (isCommon)
+            // Android-changed: Android has no real SecurityManager and policy.
+            // if (isCommon && JLA.allowSecurityManager())
+            if (isCommon)
                 return newCommonWithACC(pool);
             else
                 return newRegularWithACC(pool);
@@ -1010,6 +1011,8 @@ public class ForkJoinPool extends AbstractExecutorService {
         @SuppressWarnings("removal")
         static volatile AccessControlContext regularACC, commonACC;
 
+        private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+
         @SuppressWarnings("removal")
         static ForkJoinWorkerThread newRegularWithACC(ForkJoinPool pool) {
             AccessControlContext acc = regularACC;
@@ -1525,9 +1528,7 @@ public class ForkJoinPool extends AbstractExecutorService {
     final ForkJoinWorkerThreadFactory factory;
     final UncaughtExceptionHandler ueh;  // per-worker UEH
     final Predicate<? super ForkJoinPool> saturate;
-    // Android-removed: SharedThreadContainer not available.
-    // TODO(b/346542404): Use SharedThreadContainer once VirtualThread is available
-    // final SharedThreadContainer container;
+    final SharedThreadContainer container;
 
     @jdk.internal.vm.annotation.Contended("fjpctl") // segregate
     volatile long ctl;                   // main pool control
@@ -1584,10 +1585,7 @@ public class ForkJoinPool extends AbstractExecutorService {
         try {
             if (runState >= 0 &&  // avoid construction if terminating
                 fac != null && (wt = fac.newThread(this)) != null) {
-                // Android-changed: SharedThreadContainer not available.
-                // TODO(b/346542404): Use SharedThreadContainer once VirtualThread is available
-                // container.start(wt);
-                wt.start();
+                container.start(wt);
                 return true;
             }
         } catch (Throwable rex) {
@@ -2547,9 +2545,7 @@ public class ForkJoinPool extends AbstractExecutorService {
             if ((cond = termination) != null)
                 cond.signalAll();
             lock.unlock();
-            // Android-removed: SharedThreadContainer not available.
-            // TODO(b/346542404): Use SharedThreadContainer once VirtualThread is available
-            // container.close();
+            container.close();
         }
         return true;
     }
@@ -2742,9 +2738,7 @@ public class ForkJoinPool extends AbstractExecutorService {
         String pid = Integer.toString(getAndAddPoolIds(1) + 1);
         String name = "ForkJoinPool-" + pid;
         this.workerNamePrefix = name + "-worker-";
-        // Android-removed: SharedThreadContainer not available.
-        // TODO(b/346542404): Use SharedThreadContainer once VirtualThread is available
-        // this.container = SharedThreadContainer.create(name);
+        this.container = SharedThreadContainer.create(name);
     }
 
     /**
@@ -2796,9 +2790,7 @@ public class ForkJoinPool extends AbstractExecutorService {
         this.workerNamePrefix = null;
         this.registrationLock = new ReentrantLock();
         this.queues = new WorkQueue[size];
-        // Android-removed: SharedThreadContainer not available.
-        // TODO(b/346542404): Use SharedThreadContainer once VirtualThread is available
-        // this.container = SharedThreadContainer.create("ForkJoinPool.commonPool");
+        this.container = SharedThreadContainer.create("ForkJoinPool.commonPool");
     }
 
     /**
diff --git a/ojluni/src/main/java/java/util/concurrent/StructureViolationException.java b/ojluni/src/main/java/java/util/concurrent/StructureViolationException.java
new file mode 100644
index 00000000000..5120fb417ea
--- /dev/null
+++ b/ojluni/src/main/java/java/util/concurrent/StructureViolationException.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2021, 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package java.util.concurrent;
+
+/**
+ * Thrown when a structure violation is detected.
+ *
+ * @see StructuredTaskScope#close()
+ *
+ * @since 21
+ */
+// @PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)
+public final class StructureViolationException extends RuntimeException {
+    @java.io.Serial
+    private static final long serialVersionUID = -7705327650798235468L;
+
+    /**
+     * Constructs a {@code StructureViolationException} with no detail message.
+     */
+    public StructureViolationException() {
+        super();
+    }
+
+    /**
+     * Constructs a {@code StructureViolationException} with the specified
+     * detail message.
+     *
+     * @param  message the detail message, can be null
+     */
+    public StructureViolationException(String message) {
+        super(message);
+    }
+}
diff --git a/ojluni/src/main/java/java/util/concurrent/SynchronousQueue.java b/ojluni/src/main/java/java/util/concurrent/SynchronousQueue.java
index 32f7840ef04..6d6d9efad03 100644
--- a/ojluni/src/main/java/java/util/concurrent/SynchronousQueue.java
+++ b/ojluni/src/main/java/java/util/concurrent/SynchronousQueue.java
@@ -194,6 +194,8 @@ public class SynchronousQueue<E> extends AbstractQueue<E>
                     if ((m = s.await(e, ns, this,  // spin if (nearly) empty
                                      p == null || p.waiter == null)) == e)
                         unspliceLifo(s);           // cancelled
+                    else if (m != null)
+                        s.selfLinkItem();
                     break;
                 }
             }
diff --git a/ojluni/src/main/java/java/util/concurrent/ThreadPoolExecutor.java b/ojluni/src/main/java/java/util/concurrent/ThreadPoolExecutor.java
index 62711c359f2..f6dde0355b4 100644
--- a/ojluni/src/main/java/java/util/concurrent/ThreadPoolExecutor.java
+++ b/ojluni/src/main/java/java/util/concurrent/ThreadPoolExecutor.java
@@ -47,6 +47,8 @@ import java.util.concurrent.locks.AbstractQueuedSynchronizer;
 import java.util.concurrent.locks.Condition;
 import java.util.concurrent.locks.ReentrantLock;
 
+import jdk.internal.vm.SharedThreadContainer;
+
 // BEGIN android-note
 // removed security manager docs
 // END android-note
@@ -490,8 +492,7 @@ public class ThreadPoolExecutor extends AbstractExecutorService {
     /**
      * The thread container for the worker threads.
      */
-    // Android-removed: SharedThreadContainer not available.
-    // private final SharedThreadContainer container;
+    private final SharedThreadContainer container;
 
     /**
      * Tracks largest attained pool size. Accessed only under
@@ -742,8 +743,7 @@ public class ThreadPoolExecutor extends AbstractExecutorService {
                     } finally {
                         ctl.set(ctlOf(TERMINATED, 0));
                         termination.signalAll();
-                        // Android-removed: SharedThreadContainer not available.
-                        // container.close();
+                        container.close();
                     }
                     return;
                 }
@@ -960,9 +960,7 @@ public class ThreadPoolExecutor extends AbstractExecutorService {
                     mainLock.unlock();
                 }
                 if (workerAdded) {
-                    // Android-changed: SharedThreadContainer not available.
-                    // container.start(t);
-                    t.start();
+                    container.start(t);
                     workerStarted = true;
                 }
             }
@@ -1330,9 +1328,8 @@ public class ThreadPoolExecutor extends AbstractExecutorService {
         this.threadFactory = threadFactory;
         this.handler = handler;
 
-        // Android-removed: SharedThreadContainer not available.
-        // String name = Objects.toIdentityString(this);
-        // this.container = SharedThreadContainer.create(name);
+        String name = Objects.toIdentityString(this);
+        this.container = SharedThreadContainer.create(name);
     }
 
     /**
diff --git a/ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java b/ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java
index 55d4ea37af4..4e546cd3604 100644
--- a/ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java
+++ b/ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java
@@ -1129,13 +1129,18 @@ public abstract class AbstractQueuedLongSynchronizer
         private void doSignal(ConditionNode first, boolean all) {
             while (first != null) {
                 ConditionNode next = first.nextWaiter;
+
                 if ((firstWaiter = next) == null)
                     lastWaiter = null;
+                else
+                    first.nextWaiter = null; // GC assistance
+
                 if ((first.getAndUnsetStatus(COND) & COND) != 0) {
                     enqueue(first);
                     if (!all)
                         break;
                 }
+
                 first = next;
             }
         }
diff --git a/ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedSynchronizer.java b/ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedSynchronizer.java
index 36d21d3fcfc..1f51419f94c 100644
--- a/ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedSynchronizer.java
+++ b/ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedSynchronizer.java
@@ -1506,13 +1506,18 @@ public abstract class AbstractQueuedSynchronizer
         private void doSignal(ConditionNode first, boolean all) {
             while (first != null) {
                 ConditionNode next = first.nextWaiter;
+
                 if ((firstWaiter = next) == null)
                     lastWaiter = null;
+                else
+                    first.nextWaiter = null; // GC assistance
+
                 if ((first.getAndUnsetStatus(COND) & COND) != 0) {
                     enqueue(first);
                     if (!all)
                         break;
                 }
+
                 first = next;
             }
         }
diff --git a/ojluni/src/main/java/java/util/regex/Pattern.java b/ojluni/src/main/java/java/util/regex/Pattern.java
index 43fa23389df..8ad5307c66d 100644
--- a/ojluni/src/main/java/java/util/regex/Pattern.java
+++ b/ojluni/src/main/java/java/util/regex/Pattern.java
@@ -53,6 +53,7 @@ import libcore.util.EmptyArray;
 // Android-changed: Remove "Compatibility Properties of Unicode Regular Expression" table.
 // Android-changed: Remove supported \b{g} Unicode extended grapheme cluster boundary.
 // Android-changed: Prefix "Is" is supported since Android 10. http://b/110364810
+// Android-changed: \u000b and \u000c are recognized as line terminators. http://b/418109879
 /**
  * A compiled representation of a regular expression.
  *
@@ -459,23 +460,16 @@ import libcore.util.EmptyArray;
  * <h2><a id="lt">Line terminators</a></h2>
  *
  * <p> A <i>line terminator</i> is a one- or two-character sequence that marks
- * the end of a line of the input character sequence.  The following are
- * recognized as line terminators:
+ * the end of a line of the input character sequence.
+ * Any Unicode linebreak sequence <a href="#any_unicode_linebreak">{@code '\R'}</a> is recognized
+ * as <i>line terminator</i>. In particular, on Android, the following are also recognized
+ * as line terminators:
  *
  * <ul>
  *
- *   <li> A newline (line feed) character ({@code '\n'}),
+ *   <li> A vertical tabulation character (<code>'&#92;u000B'</code>), or
  *
- *   <li> A carriage-return character followed immediately by a newline
- *   character ({@code "\r\n"}),
- *
- *   <li> A standalone carriage-return character ({@code '\r'}),
- *
- *   <li> A next-line character (<code>'&#92;u0085'</code>),
- *
- *   <li> A line-separator character (<code>'&#92;u2028'</code>), or
- *
- *   <li> A paragraph-separator character (<code>'&#92;u2029'</code>).
+ *   <li> A form-feed character (<code>'&#92;u000C'</code>).
  *
  * </ul>
  * <p>If {@link #UNIX_LINES} mode is activated, then the only line terminators
diff --git a/ojluni/src/main/java/java/util/stream/AbstractPipeline.java b/ojluni/src/main/java/java/util/stream/AbstractPipeline.java
index 7d03ae34f79..f56d79056f4 100644
--- a/ojluni/src/main/java/java/util/stream/AbstractPipeline.java
+++ b/ojluni/src/main/java/java/util/stream/AbstractPipeline.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -87,7 +87,7 @@ public abstract class AbstractPipeline<E_IN, E_OUT, S extends BaseStream<E_OUT,
      * The "upstream" pipeline, or null if this is the source stage.
      */
     @SuppressWarnings("rawtypes")
-    private final AbstractPipeline previousStage;
+    protected final AbstractPipeline previousStage;
 
     /**
      * The operation flags for the intermediate operation represented by this
@@ -136,12 +136,6 @@ public abstract class AbstractPipeline<E_IN, E_OUT, S extends BaseStream<E_OUT,
      */
     private boolean linkedOrConsumed;
 
-    /**
-     * True if there are any stateful ops in the pipeline; only valid for the
-     * source stage.
-     */
-    private boolean sourceAnyStateful;
-
     private Runnable sourceCloseAction;
 
     /**
@@ -196,9 +190,13 @@ public abstract class AbstractPipeline<E_IN, E_OUT, S extends BaseStream<E_OUT,
      * Constructor for appending an intermediate operation stage onto an
      * existing pipeline.
      *
+     * The previous stage must be unlinked and unconsumed.
+     *
      * @param previousStage the upstream pipeline stage
      * @param opFlags the operation flags for the new stage, described in
      * {@link StreamOpFlag}
+     * @throws IllegalStateException if previousStage is already linked or
+     * consumed
      */
     AbstractPipeline(AbstractPipeline<?, E_IN, ?> previousStage, int opFlags) {
         if (previousStage.linkedOrConsumed)
@@ -210,11 +208,44 @@ public abstract class AbstractPipeline<E_IN, E_OUT, S extends BaseStream<E_OUT,
         this.sourceOrOpFlags = opFlags & StreamOpFlag.OP_MASK;
         this.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);
         this.sourceStage = previousStage.sourceStage;
-        if (opIsStateful())
-            sourceStage.sourceAnyStateful = true;
         this.depth = previousStage.depth + 1;
     }
 
+    /**
+     * Constructor for replacing an intermediate operation stage onto an
+     * existing pipeline.
+     *
+     * @param previousPreviousStage the upstream pipeline stage of the upstream pipeline stage
+     * @param previousStage the upstream pipeline stage
+     * @param opFlags the operation flags for the new stage, described in
+     * {@link StreamOpFlag}
+     * @throws IllegalStateException if previousStage is already linked or
+     * consumed
+     */
+    protected AbstractPipeline(AbstractPipeline<?, E_IN, ?> previousPreviousStage, AbstractPipeline<?, E_IN, ?> previousStage, int opFlags) {
+        if (previousStage.linkedOrConsumed || !previousPreviousStage.linkedOrConsumed || previousPreviousStage.nextStage != previousStage || previousStage.previousStage != previousPreviousStage)
+            throw new IllegalStateException(MSG_STREAM_LINKED);
+
+        previousStage.linkedOrConsumed = true;
+
+        previousPreviousStage.nextStage = this;
+
+        this.previousStage = previousPreviousStage;
+        this.sourceOrOpFlags = opFlags & StreamOpFlag.OP_MASK;
+        this.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousPreviousStage.combinedFlags);
+        this.sourceStage = previousPreviousStage.sourceStage;
+        this.depth = previousPreviousStage.depth + 1;
+    }
+
+    /**
+     * Checks that the current stage has not been already linked or consumed,
+     * and then sets this stage as being linked or consumed.
+     */
+    protected void linkOrConsume() {
+        if (linkedOrConsumed)
+            throw new IllegalStateException(MSG_STREAM_LINKED);
+        linkedOrConsumed = true;
+    }
 
     // Terminal evaluation methods
 
@@ -273,8 +304,9 @@ public abstract class AbstractPipeline<E_IN, E_OUT, S extends BaseStream<E_OUT,
      * @throws IllegalStateException if this pipeline stage is not the source
      *         stage.
      */
-    @SuppressWarnings("unchecked")
+
     final Spliterator<E_OUT> sourceStageSpliterator() {
+        // Ensures that this method is only ever called on the sourceStage
         if (this != sourceStage)
             throw new IllegalStateException();
 
@@ -282,16 +314,16 @@ public abstract class AbstractPipeline<E_IN, E_OUT, S extends BaseStream<E_OUT,
             throw new IllegalStateException(MSG_STREAM_LINKED);
         linkedOrConsumed = true;
 
-        if (sourceStage.sourceSpliterator != null) {
+        if (sourceSpliterator != null) {
             @SuppressWarnings("unchecked")
-            Spliterator<E_OUT> s = sourceStage.sourceSpliterator;
-            sourceStage.sourceSpliterator = null;
+            Spliterator<E_OUT> s = (Spliterator<E_OUT>)sourceSpliterator;
+            sourceSpliterator = null;
             return s;
         }
-        else if (sourceStage.sourceSupplier != null) {
+        else if (sourceSupplier != null) {
             @SuppressWarnings("unchecked")
-            Spliterator<E_OUT> s = (Spliterator<E_OUT>) sourceStage.sourceSupplier.get();
-            sourceStage.sourceSupplier = null;
+            Spliterator<E_OUT> s = (Spliterator<E_OUT>)sourceSupplier.get();
+            sourceSupplier = null;
             return s;
         }
         else {
@@ -320,8 +352,8 @@ public abstract class AbstractPipeline<E_IN, E_OUT, S extends BaseStream<E_OUT,
         linkedOrConsumed = true;
         sourceSupplier = null;
         sourceSpliterator = null;
-        if (sourceStage.sourceCloseAction != null) {
-            Runnable closeAction = sourceStage.sourceCloseAction;
+        Runnable closeAction = sourceStage.sourceCloseAction;
+        if (closeAction != null) {
             sourceStage.sourceCloseAction = null;
             closeAction.run();
         }
@@ -390,6 +422,35 @@ public abstract class AbstractPipeline<E_IN, E_OUT, S extends BaseStream<E_OUT,
         return StreamOpFlag.toStreamFlags(combinedFlags);
     }
 
+    /**
+     * Returns whether any of the stages of the current segment is stateful
+     * or not.
+     * @return {@code true} if any stage in this segment is stateful,
+     *         {@code false} if not.
+     */
+    protected final boolean hasAnyStateful() {
+         var result = false;
+         for (var u = sourceStage.nextStage;
+              u != null && !(result = u.opIsStateful()) && u != this;
+              u = u.nextStage) {
+         }
+         return result;
+     }
+
+    /**
+     * Returns whether any of the stages in the (entire) pipeline is short-circuiting
+     * or not.
+     * @return {@code true} if any stage in this pipeline is short-circuiting,
+     *         {@code false} if not.
+     */
+    protected final boolean isShortCircuitingPipeline() {
+        for (var u = sourceStage.nextStage; u != null; u = u.nextStage) {
+            if (StreamOpFlag.SHORT_CIRCUIT.isKnown(u.combinedFlags))
+                return true;
+        }
+        return false;
+    }
+
     /**
      * Get the source spliterator for this pipeline stage.  For a sequential or
      * stateless parallel pipeline, this is the source spliterator.  For a
@@ -398,7 +459,7 @@ public abstract class AbstractPipeline<E_IN, E_OUT, S extends BaseStream<E_OUT,
      * operation.
      */
     @SuppressWarnings("unchecked")
-    private Spliterator<?> sourceSpliterator(int terminalFlags) {
+    protected Spliterator<?> sourceSpliterator(int terminalFlags) {
         // Get the source spliterator of the pipeline
         Spliterator<?> spliterator = null;
         if (sourceStage.sourceSpliterator != null) {
@@ -413,7 +474,7 @@ public abstract class AbstractPipeline<E_IN, E_OUT, S extends BaseStream<E_OUT,
             throw new IllegalStateException(MSG_CONSUMED);
         }
 
-        if (isParallel() && sourceStage.sourceAnyStateful) {
+        if (isParallel() && hasAnyStateful()) {
             // Adapt the source spliterator, evaluating each stateful op
             // in the pipeline up to and including this pipeline stage.
             // The depth and flags of each pipeline stage are adjusted accordingly.
@@ -521,7 +582,7 @@ public abstract class AbstractPipeline<E_IN, E_OUT, S extends BaseStream<E_OUT,
     @Override
     @SuppressWarnings("unchecked")
     final <P_IN> boolean copyIntoWithCancel(Sink<P_IN> wrappedSink, Spliterator<P_IN> spliterator) {
-        @SuppressWarnings({"rawtypes","unchecked"})
+        @SuppressWarnings("rawtypes")
         AbstractPipeline p = AbstractPipeline.this;
         while (p.depth > 0) {
             p = p.previousStage;
@@ -567,7 +628,6 @@ public abstract class AbstractPipeline<E_IN, E_OUT, S extends BaseStream<E_OUT,
     }
 
     @Override
-    @SuppressWarnings("unchecked")
     // Android-changed: Made public for CTS tests only.
     public final <P_IN> Node<E_OUT> evaluate(Spliterator<P_IN> spliterator,
                                       boolean flatten,
@@ -745,10 +805,9 @@ public abstract class AbstractPipeline<E_IN, E_OUT, S extends BaseStream<E_OUT,
      * @param spliterator the source {@code Spliterator}
      * @return a {@code Spliterator} describing the result of the evaluation
      */
-    @SuppressWarnings("unchecked")
     // Android-changed: Made public for CTS tests only.
     public <P_IN> Spliterator<E_OUT> opEvaluateParallelLazy(PipelineHelper<E_OUT> helper,
                                                      Spliterator<P_IN> spliterator) {
-        return opEvaluateParallel(helper, spliterator, i -> (E_OUT[]) new Object[i]).spliterator();
+        return opEvaluateParallel(helper, spliterator, Nodes.castingArray()).spliterator();
     }
 }
diff --git a/ojluni/src/main/java/java/util/stream/AbstractTask.java b/ojluni/src/main/java/java/util/stream/AbstractTask.java
index 9a61729f68d..04a64fdd346 100644
--- a/ojluni/src/main/java/java/util/stream/AbstractTask.java
+++ b/ojluni/src/main/java/java/util/stream/AbstractTask.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -222,7 +222,7 @@ abstract class AbstractTask<P_IN, P_OUT, R,
 
     /**
      * Does nothing; instead, subclasses should use
-     * {@link #setLocalResult(Object)}} to manage results.
+     * {@link #setLocalResult(Object)} to manage results.
      *
      * @param result must be null, or an exception is thrown (this is a safety
      *        tripwire to detect when {@code setRawResult()} is being used
diff --git a/ojluni/src/main/java/java/util/stream/BaseStream.java b/ojluni/src/main/java/java/util/stream/BaseStream.java
index 28e0541efdb..b403ee06377 100644
--- a/ojluni/src/main/java/java/util/stream/BaseStream.java
+++ b/ojluni/src/main/java/java/util/stream/BaseStream.java
@@ -24,15 +24,8 @@
  */
 package java.util.stream;
 
-import java.nio.charset.Charset;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.util.Collection;
 import java.util.Iterator;
 import java.util.Spliterator;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.function.IntConsumer;
-import java.util.function.Predicate;
 
 /**
  * Base interface for streams, which are sequences of elements supporting
diff --git a/ojluni/src/main/java/java/util/stream/Collectors.java b/ojluni/src/main/java/java/util/stream/Collectors.java
index bbb0982fac3..61dc00a4c5a 100644
--- a/ojluni/src/main/java/java/util/stream/Collectors.java
+++ b/ojluni/src/main/java/java/util/stream/Collectors.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -280,7 +280,7 @@ public final class Collectors {
      */
     public static <T, C extends Collection<T>>
     Collector<T, ?, C> toCollection(Supplier<C> collectionFactory) {
-        return new CollectorImpl<>(collectionFactory, Collection<T>::add,
+        return new CollectorImpl<>(collectionFactory, Collection::add,
                                    (r1, r2) -> { r1.addAll(r2); return r1; },
                                    CH_ID);
     }
@@ -394,9 +394,12 @@ public final class Collectors {
      * {@code String}, in encounter order
      */
     public static Collector<CharSequence, ?, String> joining() {
-        return new CollectorImpl<CharSequence, StringBuilder, String>(
+        return new CollectorImpl<>(
                 StringBuilder::new, StringBuilder::append,
-                (r1, r2) -> { r1.append(r2); return r1; },
+                (r1, r2) -> {
+                    r1.append(r2);
+                    return r1;
+                },
                 StringBuilder::toString, CH_NOID);
     }
 
@@ -888,7 +891,7 @@ public final class Collectors {
      * The {@code reducing()} collectors are most useful when used in a
      * multi-level reduction, downstream of {@code groupingBy} or
      * {@code partitioningBy}.  To perform a simple reduction on a stream,
-     * use {@link Stream#reduce(Object, BinaryOperator)}} instead.
+     * use {@link Stream#reduce(Object, BinaryOperator)} instead.
      *
      * @param <T> element type for the input and output of the reduction
      * @param identity the identity value for the reduction (also, the value
@@ -960,9 +963,12 @@ public final class Collectors {
             }
         }
 
-        return new CollectorImpl<T, OptionalBox, Optional<T>>(
+        return new CollectorImpl<>(
                 OptionalBox::new, OptionalBox::accept,
-                (a, b) -> { if (b.present) a.accept(b.value); return a; },
+                (a, b) -> {
+                    if (b.present) a.accept(b.value);
+                    return a;
+                },
                 a -> Optional.ofNullable(a.value), CH_NOID);
     }
 
@@ -1140,13 +1146,13 @@ public final class Collectors {
      *
      * @param <T> the type of the input elements
      * @param <K> the type of the keys
-     * @param <A> the intermediate accumulation type of the downstream collector
      * @param <D> the result type of the downstream reduction
+     * @param <A> the intermediate accumulation type of the downstream collector
      * @param <M> the type of the resulting {@code Map}
      * @param classifier a classifier function mapping input elements to keys
-     * @param downstream a {@code Collector} implementing the downstream reduction
      * @param mapFactory a supplier providing a new empty {@code Map}
      *                   into which the results will be inserted
+     * @param downstream a {@code Collector} implementing the downstream reduction
      * @return a {@code Collector} implementing the cascaded group-by operation
      *
      * @see #groupingBy(Function, Collector)
@@ -1164,7 +1170,7 @@ public final class Collectors {
             A container = m.computeIfAbsent(key, k -> downstreamSupplier.get());
             downstreamAccumulator.accept(container, t);
         };
-        BinaryOperator<Map<K, A>> merger = Collectors.<K, A, Map<K, A>>mapMerger(downstream.combiner());
+        BinaryOperator<Map<K, A>> merger = Collectors.mapMerger(downstream.combiner());
         @SuppressWarnings("unchecked")
         Supplier<Map<K, A>> mangledFactory = (Supplier<Map<K, A>>) mapFactory;
 
@@ -1302,9 +1308,9 @@ public final class Collectors {
      * @param <D> the result type of the downstream reduction
      * @param <M> the type of the resulting {@code ConcurrentMap}
      * @param classifier a classifier function mapping input elements to keys
-     * @param downstream a {@code Collector} implementing the downstream reduction
      * @param mapFactory a supplier providing a new empty {@code ConcurrentMap}
      *                   into which the results will be inserted
+     * @param downstream a {@code Collector} implementing the downstream reduction
      * @return a concurrent, unordered {@code Collector} implementing the cascaded group-by operation
      *
      * @see #groupingByConcurrent(Function)
@@ -1317,7 +1323,7 @@ public final class Collectors {
                                             Collector<? super T, A, D> downstream) {
         Supplier<A> downstreamSupplier = downstream.supplier();
         BiConsumer<A, ? super T> downstreamAccumulator = downstream.accumulator();
-        BinaryOperator<ConcurrentMap<K, A>> merger = Collectors.<K, A, ConcurrentMap<K, A>>mapMerger(downstream.combiner());
+        BinaryOperator<ConcurrentMap<K, A>> merger = Collectors.mapMerger(downstream.combiner());
         @SuppressWarnings("unchecked")
         Supplier<ConcurrentMap<K, A>> mangledFactory = (Supplier<ConcurrentMap<K, A>>) mapFactory;
         BiConsumer<ConcurrentMap<K, A>, T> accumulator;
@@ -1399,8 +1405,8 @@ public final class Collectors {
      * applying the finisher function.
      *
      * @param <T> the type of the input elements
-     * @param <A> the intermediate accumulation type of the downstream collector
      * @param <D> the result type of the downstream reduction
+     * @param <A> the intermediate accumulation type of the downstream collector
      * @param predicate a predicate used for classifying input elements
      * @param downstream a {@code Collector} implementing the downstream
      *                   reduction
@@ -1874,10 +1880,13 @@ public final class Collectors {
      */
     public static <T>
     Collector<T, ?, IntSummaryStatistics> summarizingInt(ToIntFunction<? super T> mapper) {
-        return new CollectorImpl<T, IntSummaryStatistics, IntSummaryStatistics>(
+        return new CollectorImpl<>(
                 IntSummaryStatistics::new,
                 (r, t) -> r.accept(mapper.applyAsInt(t)),
-                (l, r) -> { l.combine(r); return l; }, CH_ID);
+                (l, r) -> {
+                    l.combine(r);
+                    return l;
+                }, CH_ID);
     }
 
     /**
@@ -1894,10 +1903,13 @@ public final class Collectors {
      */
     public static <T>
     Collector<T, ?, LongSummaryStatistics> summarizingLong(ToLongFunction<? super T> mapper) {
-        return new CollectorImpl<T, LongSummaryStatistics, LongSummaryStatistics>(
+        return new CollectorImpl<>(
                 LongSummaryStatistics::new,
                 (r, t) -> r.accept(mapper.applyAsLong(t)),
-                (l, r) -> { l.combine(r); return l; }, CH_ID);
+                (l, r) -> {
+                    l.combine(r);
+                    return l;
+                }, CH_ID);
     }
 
     /**
@@ -1914,10 +1926,13 @@ public final class Collectors {
      */
     public static <T>
     Collector<T, ?, DoubleSummaryStatistics> summarizingDouble(ToDoubleFunction<? super T> mapper) {
-        return new CollectorImpl<T, DoubleSummaryStatistics, DoubleSummaryStatistics>(
+        return new CollectorImpl<>(
                 DoubleSummaryStatistics::new,
                 (r, t) -> r.accept(mapper.applyAsDouble(t)),
-                (l, r) -> { l.combine(r); return l; }, CH_ID);
+                (l, r) -> {
+                    l.combine(r);
+                    return l;
+                }, CH_ID);
     }
 
     /**
diff --git a/ojluni/src/main/java/java/util/stream/DistinctOps.java b/ojluni/src/main/java/java/util/stream/DistinctOps.java
index e299b75fa48..a6cd326c678 100644
--- a/ojluni/src/main/java/java/util/stream/DistinctOps.java
+++ b/ojluni/src/main/java/java/util/stream/DistinctOps.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -125,7 +125,7 @@ final class DistinctOps {
                 if (StreamOpFlag.DISTINCT.isKnown(flags)) {
                     return sink;
                 } else if (StreamOpFlag.SORTED.isKnown(flags)) {
-                    return new Sink.ChainedReference<T, T>(sink) {
+                    return new Sink.ChainedReference<>(sink) {
                         boolean seenNull;
                         T lastSeen;
 
@@ -156,7 +156,7 @@ final class DistinctOps {
                         }
                     };
                 } else {
-                    return new Sink.ChainedReference<T, T>(sink) {
+                    return new Sink.ChainedReference<>(sink) {
                         Set<T> seen;
 
                         @Override
diff --git a/ojluni/src/main/java/java/util/stream/DoublePipeline.java b/ojluni/src/main/java/java/util/stream/DoublePipeline.java
index e3c89b5f663..91d07832118 100644
--- a/ojluni/src/main/java/java/util/stream/DoublePipeline.java
+++ b/ojluni/src/main/java/java/util/stream/DoublePipeline.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -39,6 +39,7 @@ import java.util.function.DoublePredicate;
 import java.util.function.DoubleToIntFunction;
 import java.util.function.DoubleToLongFunction;
 import java.util.function.DoubleUnaryOperator;
+import java.util.function.IntConsumer;
 import java.util.function.IntFunction;
 import java.util.function.ObjDoubleConsumer;
 import java.util.function.Supplier;
@@ -175,11 +176,11 @@ public abstract class DoublePipeline<E_IN>
     }
 
     private <U> Stream<U> mapToObj(DoubleFunction<? extends U> mapper, int opFlags) {
-        return new ReferencePipeline.StatelessOp<Double, U>(this, StreamShape.DOUBLE_VALUE, opFlags) {
+        return new ReferencePipeline.StatelessOp<>(this, StreamShape.DOUBLE_VALUE, opFlags) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Double> opWrapSink(int flags, Sink<U> sink) {
-                return new Sink.ChainedDouble<U>(sink) {
+                return new Sink.ChainedDouble<>(sink) {
                     @Override
                     public void accept(double t) {
                         downstream.accept(mapper.apply(t));
@@ -211,12 +212,12 @@ public abstract class DoublePipeline<E_IN>
     @Override
     public final DoubleStream map(DoubleUnaryOperator mapper) {
         Objects.requireNonNull(mapper);
-        return new StatelessOp<Double>(this, StreamShape.DOUBLE_VALUE,
-                                       StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+        return new StatelessOp<>(this, StreamShape.DOUBLE_VALUE,
+                StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Double> opWrapSink(int flags, Sink<Double> sink) {
-                return new Sink.ChainedDouble<Double>(sink) {
+                return new Sink.ChainedDouble<>(sink) {
                     @Override
                     public void accept(double t) {
                         downstream.accept(mapper.applyAsDouble(t));
@@ -235,12 +236,12 @@ public abstract class DoublePipeline<E_IN>
     @Override
     public final IntStream mapToInt(DoubleToIntFunction mapper) {
         Objects.requireNonNull(mapper);
-        return new IntPipeline.StatelessOp<Double>(this, StreamShape.DOUBLE_VALUE,
-                                                   StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+        return new IntPipeline.StatelessOp<>(this, StreamShape.DOUBLE_VALUE,
+                StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Double> opWrapSink(int flags, Sink<Integer> sink) {
-                return new Sink.ChainedDouble<Integer>(sink) {
+                return new Sink.ChainedDouble<>(sink) {
                     @Override
                     public void accept(double t) {
                         downstream.accept(mapper.applyAsInt(t));
@@ -253,12 +254,12 @@ public abstract class DoublePipeline<E_IN>
     @Override
     public final LongStream mapToLong(DoubleToLongFunction mapper) {
         Objects.requireNonNull(mapper);
-        return new LongPipeline.StatelessOp<Double>(this, StreamShape.DOUBLE_VALUE,
-                                                    StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+        return new LongPipeline.StatelessOp<>(this, StreamShape.DOUBLE_VALUE,
+                StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Double> opWrapSink(int flags, Sink<Long> sink) {
-                return new Sink.ChainedDouble<Long>(sink) {
+                return new Sink.ChainedDouble<>(sink) {
                     @Override
                     public void accept(double t) {
                         downstream.accept(mapper.applyAsLong(t));
@@ -271,48 +272,51 @@ public abstract class DoublePipeline<E_IN>
     @Override
     public final DoubleStream flatMap(DoubleFunction<? extends DoubleStream> mapper) {
         Objects.requireNonNull(mapper);
-        return new StatelessOp<Double>(this, StreamShape.DOUBLE_VALUE,
-                                        StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
+        return new StatelessOp<>(this, StreamShape.DOUBLE_VALUE,
+                StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Double> opWrapSink(int flags, Sink<Double> sink) {
-                return new Sink.ChainedDouble<Double>(sink) {
-                    // true if cancellationRequested() has been called
-                    boolean cancellationRequestedCalled;
-
-                    // cache the consumer to avoid creation on every accepted element
-                    DoubleConsumer downstreamAsDouble = downstream::accept;
+                final DoubleConsumer fastPath =
+                        isShortCircuitingPipeline()
+                                ? null
+                                : (sink instanceof DoubleConsumer dc)
+                                ? dc
+                                : sink::accept;
+                final class FlatMap implements Sink.OfDouble, DoublePredicate {
+                    boolean cancel;
+
+                    @Override public void begin(long size) { sink.begin(-1); }
+                    @Override public void end() { sink.end(); }
 
                     @Override
-                    public void begin(long size) {
-                        downstream.begin(-1);
-                    }
-
-                    @Override
-                    public void accept(double t) {
-                        try (DoubleStream result = mapper.apply(t)) {
+                    public void accept(double e) {
+                        try (DoubleStream result = mapper.apply(e)) {
                             if (result != null) {
-                                if (!cancellationRequestedCalled) {
-                                    result.sequential().forEach(downstreamAsDouble);
-                                }
-                                else {
-                                    var s = result.sequential().spliterator();
-                                    do { } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsDouble));
-                                }
+                                if (fastPath == null)
+                                    result.sequential().allMatch(this);
+                                else
+                                    result.sequential().forEach(fastPath);
                             }
                         }
                     }
 
                     @Override
                     public boolean cancellationRequested() {
-                        // If this method is called then an operation within the stream
-                        // pipeline is short-circuiting (see AbstractPipeline.copyInto).
-                        // Note that we cannot differentiate between an upstream or
-                        // downstream operation
-                        cancellationRequestedCalled = true;
-                        return downstream.cancellationRequested();
+                        return cancel || (cancel |= sink.cancellationRequested());
                     }
-                };
+
+                    @Override
+                    public boolean test(double output) {
+                        if (!cancel) {
+                            sink.accept(output);
+                            return !(cancel |= sink.cancellationRequested());
+                        } else {
+                            return false;
+                        }
+                    }
+                }
+                return new FlatMap();
             }
         };
     }
@@ -334,7 +338,6 @@ public abstract class DoublePipeline<E_IN>
                     }
 
                     @Override
-                    @SuppressWarnings("unchecked")
                     public void accept(double t) {
                             mapper.accept(t, (DoubleConsumer) downstream);
                     }
@@ -347,7 +350,7 @@ public abstract class DoublePipeline<E_IN>
     public DoubleStream unordered() {
         if (!isOrdered())
             return this;
-        return new StatelessOp<Double>(this, StreamShape.DOUBLE_VALUE, StreamOpFlag.NOT_ORDERED) {
+        return new StatelessOp<>(this, StreamShape.DOUBLE_VALUE, StreamOpFlag.NOT_ORDERED) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Double> opWrapSink(int flags, Sink<Double> sink) {
@@ -359,12 +362,12 @@ public abstract class DoublePipeline<E_IN>
     @Override
     public final DoubleStream filter(DoublePredicate predicate) {
         Objects.requireNonNull(predicate);
-        return new StatelessOp<Double>(this, StreamShape.DOUBLE_VALUE,
-                                       StreamOpFlag.NOT_SIZED) {
+        return new StatelessOp<>(this, StreamShape.DOUBLE_VALUE,
+                StreamOpFlag.NOT_SIZED) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Double> opWrapSink(int flags, Sink<Double> sink) {
-                return new Sink.ChainedDouble<Double>(sink) {
+                return new Sink.ChainedDouble<>(sink) {
                     @Override
                     public void begin(long size) {
                         downstream.begin(-1);
@@ -383,12 +386,12 @@ public abstract class DoublePipeline<E_IN>
     @Override
     public final DoubleStream peek(DoubleConsumer action) {
         Objects.requireNonNull(action);
-        return new StatelessOp<Double>(this, StreamShape.DOUBLE_VALUE,
-                                       0) {
+        return new StatelessOp<>(this, StreamShape.DOUBLE_VALUE,
+                0) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Double> opWrapSink(int flags, Sink<Double> sink) {
-                return new Sink.ChainedDouble<Double>(sink) {
+                return new Sink.ChainedDouble<>(sink) {
                     @Override
                     public void accept(double t) {
                         action.accept(t);
@@ -405,7 +408,7 @@ public abstract class DoublePipeline<E_IN>
     public final DoubleStream limit(long maxSize) {
         if (maxSize < 0)
             throw new IllegalArgumentException(Long.toString(maxSize));
-        return SliceOps.makeDouble(this, (long) 0, maxSize);
+        return SliceOps.makeDouble(this, 0L, maxSize);
     }
 
     @Override
@@ -439,7 +442,7 @@ public abstract class DoublePipeline<E_IN>
     public final DoubleStream distinct() {
         // While functional and quick to implement, this approach is not very efficient.
         // An efficient version requires a double-specific map/set implementation.
-        return boxed().distinct().mapToDouble(i -> (double) i);
+        return boxed().distinct().mapToDouble(i -> i);
     }
 
     // Terminal ops from DoubleStream
diff --git a/ojluni/src/main/java/java/util/stream/FindOps.java b/ojluni/src/main/java/java/util/stream/FindOps.java
index 131eec06236..5d678351400 100644
--- a/ojluni/src/main/java/java/util/stream/FindOps.java
+++ b/ojluni/src/main/java/java/util/stream/FindOps.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2024, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -194,13 +194,16 @@ final class FindOps {
                 return hasValue ? Optional.of(value) : null;
             }
 
-            static final TerminalOp<?, ?> OP_FIND_FIRST = new FindOp<>(true,
-                    StreamShape.REFERENCE, Optional.empty(),
-                    Optional::isPresent, FindSink.OfRef::new);
-
-            static final TerminalOp<?, ?> OP_FIND_ANY = new FindOp<>(false,
-                    StreamShape.REFERENCE, Optional.empty(),
-                    Optional::isPresent, FindSink.OfRef::new);
+            static final TerminalOp<?, ?> OP_FIND_FIRST, OP_FIND_ANY;
+            static {
+                Predicate<Optional<Object>> isPresent = Optional::isPresent;
+                Supplier<TerminalSink<Object, Optional<Object>>> newSink
+                        = FindSink.OfRef::new;
+                OP_FIND_FIRST = new FindOp<>(true, StreamShape.REFERENCE,
+                        Optional.empty(), isPresent, newSink);
+                OP_FIND_ANY = new FindOp<>(false, StreamShape.REFERENCE,
+                        Optional.empty(), isPresent, newSink);
+            }
         }
 
         /** Specialization of {@code FindSink} for int streams */
@@ -217,12 +220,16 @@ final class FindOps {
                 return hasValue ? OptionalInt.of(value) : null;
             }
 
-            static final TerminalOp<Integer, OptionalInt> OP_FIND_FIRST = new FindOp<>(true,
-                    StreamShape.INT_VALUE, OptionalInt.empty(),
-                    OptionalInt::isPresent, FindSink.OfInt::new);
-            static final TerminalOp<Integer, OptionalInt> OP_FIND_ANY = new FindOp<>(false,
-                    StreamShape.INT_VALUE, OptionalInt.empty(),
-                    OptionalInt::isPresent, FindSink.OfInt::new);
+            static final TerminalOp<Integer, OptionalInt> OP_FIND_FIRST, OP_FIND_ANY;
+            static {
+                Predicate<OptionalInt> isPresent = OptionalInt::isPresent;
+                Supplier<TerminalSink<Integer, OptionalInt>> newSink
+                        = FindSink.OfInt::new;
+                OP_FIND_FIRST = new FindOp<>(true, StreamShape.INT_VALUE,
+                        OptionalInt.empty(), isPresent, newSink);
+                OP_FIND_ANY = new FindOp<>(false, StreamShape.INT_VALUE,
+                        OptionalInt.empty(), isPresent, newSink);
+            }
         }
 
         /** Specialization of {@code FindSink} for long streams */
@@ -239,12 +246,16 @@ final class FindOps {
                 return hasValue ? OptionalLong.of(value) : null;
             }
 
-            static final TerminalOp<Long, OptionalLong> OP_FIND_FIRST = new FindOp<>(true,
-                    StreamShape.LONG_VALUE, OptionalLong.empty(),
-                    OptionalLong::isPresent, FindSink.OfLong::new);
-            static final TerminalOp<Long, OptionalLong> OP_FIND_ANY = new FindOp<>(false,
-                    StreamShape.LONG_VALUE, OptionalLong.empty(),
-                    OptionalLong::isPresent, FindSink.OfLong::new);
+            static final TerminalOp<Long, OptionalLong> OP_FIND_FIRST, OP_FIND_ANY;
+            static {
+                Predicate<OptionalLong> isPresent = OptionalLong::isPresent;
+                Supplier<TerminalSink<Long, OptionalLong>> newSink
+                        = FindSink.OfLong::new;
+                OP_FIND_FIRST = new FindOp<>(true, StreamShape.LONG_VALUE,
+                        OptionalLong.empty(), isPresent, newSink);
+                OP_FIND_ANY = new FindOp<>(false, StreamShape.LONG_VALUE,
+                        OptionalLong.empty(), isPresent, newSink);
+            }
         }
 
         /** Specialization of {@code FindSink} for double streams */
@@ -261,12 +272,16 @@ final class FindOps {
                 return hasValue ? OptionalDouble.of(value) : null;
             }
 
-            static final TerminalOp<Double, OptionalDouble> OP_FIND_FIRST = new FindOp<>(true,
-                    StreamShape.DOUBLE_VALUE, OptionalDouble.empty(),
-                    OptionalDouble::isPresent, FindSink.OfDouble::new);
-            static final TerminalOp<Double, OptionalDouble> OP_FIND_ANY = new FindOp<>(false,
-                    StreamShape.DOUBLE_VALUE, OptionalDouble.empty(),
-                    OptionalDouble::isPresent, FindSink.OfDouble::new);
+            static final TerminalOp<Double, OptionalDouble> OP_FIND_FIRST, OP_FIND_ANY;
+            static {
+                Predicate<OptionalDouble> isPresent = OptionalDouble::isPresent;
+                Supplier<TerminalSink<Double, OptionalDouble>> newSink
+                        = FindSink.OfDouble::new;
+                OP_FIND_FIRST = new FindOp<>(true, StreamShape.DOUBLE_VALUE,
+                        OptionalDouble.empty(), isPresent, newSink);
+                OP_FIND_ANY = new FindOp<>(false, StreamShape.DOUBLE_VALUE,
+                        OptionalDouble.empty(), isPresent, newSink);
+            }
         }
     }
 
diff --git a/ojluni/src/main/java/java/util/stream/ForEachOps.java b/ojluni/src/main/java/java/util/stream/ForEachOps.java
index 0c6b8aa665a..6163ed4061e 100644
--- a/ojluni/src/main/java/java/util/stream/ForEachOps.java
+++ b/ojluni/src/main/java/java/util/stream/ForEachOps.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2023, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2024, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,6 +24,8 @@
  */
 package java.util.stream;
 
+import jdk.internal.invoke.MhUtil;
+
 import java.util.Objects;
 import java.util.Spliterator;
 import java.util.concurrent.CountedCompleter;
@@ -370,15 +372,8 @@ final class ForEachOps {
         private Node<T> node;
 
         private ForEachOrderedTask<S, T> next;
-        private static final VarHandle NEXT;
-        static {
-            try {
-                MethodHandles.Lookup l = MethodHandles.lookup();
-                NEXT = l.findVarHandle(ForEachOrderedTask.class, "next", ForEachOrderedTask.class);
-            } catch (Exception e) {
-                throw new InternalError(e);
-            }
-        }
+        private static final VarHandle NEXT = MhUtil.findVarHandle(
+                MethodHandles.lookup(), "next", ForEachOrderedTask.class);
 
         protected ForEachOrderedTask(PipelineHelper<T> helper,
                                      Spliterator<S> spliterator,
@@ -510,6 +505,7 @@ final class ForEachOps {
             // "happens-before" completion of the associated left-most leaf task
             // of right subtree (if any, which can be this task's right sibling)
             //
+            @SuppressWarnings("unchecked")
             var leftDescendant = (ForEachOrderedTask<S, T>)NEXT.getAndSet(this, null);
             if (leftDescendant != null)
                 leftDescendant.tryComplete();
diff --git a/ojluni/src/main/java/java/util/stream/Gatherer.java b/ojluni/src/main/java/java/util/stream/Gatherer.java
new file mode 100644
index 00000000000..267ec62b931
--- /dev/null
+++ b/ojluni/src/main/java/java/util/stream/Gatherer.java
@@ -0,0 +1,588 @@
+/*
+ * Copyright (c) 2023, 2024, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package java.util.stream;
+
+import jdk.internal.vm.annotation.ForceInline;
+
+import java.util.*;
+import java.util.function.BiConsumer;
+import java.util.function.BinaryOperator;
+import java.util.function.Supplier;
+
+
+/**
+ * An intermediate operation that transforms a stream of input elements into a
+ * stream of output elements, optionally applying a final action when the end of
+ * the upstream is reached. The transformation may be stateless or stateful,
+ * and may buffer input before producing any output.
+ *
+ * <p>Gatherer operations can be performed either sequentially,
+ * or be parallelized -- if a combiner function is supplied.
+ *
+ * <p>There are many examples of gathering operations, including but not
+ * limited to:
+ * grouping elements into batches (windowing functions);
+ * de-duplicating consecutively similar elements; incremental accumulation
+ * functions (prefix scan); incremental reordering functions, etc.  The class
+ * {@link java.util.stream.Gatherers} provides implementations of common
+ * gathering operations.
+ *
+ * @apiNote
+ * <p>A {@code Gatherer} is specified by four functions that work together to
+ * process input elements, optionally using intermediate state, and optionally
+ * perform a final action at the end of input.  They are: <ul>
+ *     <li>creating a new, potentially mutable, state ({@link #initializer()})</li>
+ *     <li>integrating a new input element ({@link #integrator()})</li>
+ *     <li>combining two states into one ({@link #combiner()})</li>
+ *     <li>performing an optional final action ({@link #finisher()})</li>
+ * </ul>
+ *
+ * <p>Each invocation of {@link #initializer()}, {@link #integrator()},
+ * {@link #combiner()}, and {@link #finisher()} must return a semantically
+ * identical result.
+ *
+ * <p>Implementations of Gatherer must not capture, retain, or expose to
+ * other threads, the references to the state instance, or the downstream
+ * {@link Downstream} for longer than the invocation duration of the method
+ * which they are passed to.
+ *
+ * <p>Performing a gathering operation with a {@code Gatherer} should produce a
+ * result equivalent to:
+ *
+ * {@snippet lang = java:
+ * Gatherer.Downstream<? super R> downstream = ...;
+ * A state = gatherer.initializer().get();
+ * for (T t : data) {
+ *     gatherer.integrator().integrate(state, t, downstream);
+ * }
+ * gatherer.finisher().accept(state, downstream);
+ * }
+ *
+ * <p>However, the library is free to partition the input, perform the
+ * integrations on the partitions, and then use the combiner function to
+ * combine the partial results to achieve a gathering operation.  (Depending
+ * on the specific gathering operation, this may perform better or worse,
+ * depending on the relative cost of the integrator and combiner functions.)
+ *
+ * <p>In addition to the predefined implementations in {@link Gatherers}, the
+ * static factory methods {@code of(...)} and {@code ofSequential(...)}
+ * can be used to construct gatherers.  For example, you could create a gatherer
+ * that implements the equivalent of
+ * {@link java.util.stream.Stream#map(java.util.function.Function)} with:
+ *
+ * {@snippet lang = java:
+ * public static <T, R> Gatherer<T, ?, R> map(Function<? super T, ? extends R> mapper) {
+ *     return Gatherer.of(
+ *         (unused, element, downstream) -> // integrator
+ *             downstream.push(mapper.apply(element))
+ *     );
+ * }
+ * }
+ *
+ * <p>Gatherers are designed to be <em>composed</em>; two or more Gatherers can
+ * be composed into a single Gatherer using the {@link #andThen(Gatherer)}
+ * method.
+ *
+ * {@snippet lang = java:
+ * // using the implementation of `map` as seen above
+ * Gatherer<Integer, ?, Integer> increment = map(i -> i + 1);
+ *
+ * Gatherer<Object, ?, String> toString = map(i -> i.toString());
+ *
+ * Gatherer<Integer, ?, String> incrementThenToString = increment.andThen(toString);
+ * }
+ *
+ * <p>As an example, a Gatherer implementing a sequential Prefix Scan could
+ * be done the following way:
+ *
+ * {@snippet lang = java:
+ * public static <T, R> Gatherer<T, ?, R> scan(
+ *     Supplier<R> initial,
+ *     BiFunction<? super R, ? super T, ? extends R> scanner) {
+ *
+ *     class State {
+ *         R current = initial.get();
+ *     }
+ *
+ *     return Gatherer.<T, State, R>ofSequential(
+ *          State::new,
+ *          Gatherer.Integrator.ofGreedy((state, element, downstream) -> {
+ *              state.current = scanner.apply(state.current, element);
+ *              return downstream.push(state.current);
+ *          })
+ *     );
+ * }
+ * }
+ *
+ * <p>Example of usage:
+ *
+ * {@snippet lang = java:
+ * // will contain: ["1", "12", "123", "1234", "12345", "123456", "1234567", "12345678", "123456789"]
+ * List<String> numberStrings =
+ *     Stream.of(1,2,3,4,5,6,7,8,9)
+ *           .gather(
+ *               scan(() -> "", (string, number) -> string + number)
+ *            )
+ *           .toList();
+ * }
+ *
+ * @implSpec Libraries that implement transformations based on {@code Gatherer},
+ * such as {@link Stream#gather(Gatherer)}, must adhere to the following
+ * constraints:
+ * <ul>
+ *     <li>Gatherers whose initializer is {@link #defaultInitializer()} are
+ *     considered to be stateless, and invoking their initializer is optional.
+ *     </li>
+ *     <li>Gatherers whose integrator is an instance of {@link Integrator.Greedy}
+ *     can be assumed not to short-circuit, and the return value of invoking
+ *     {@link Integrator#integrate(Object, Object, Downstream)} does not need to
+ *     be inspected.</li>
+ *     <li>The first argument passed to the integration function, both
+ *     arguments passed to the combiner function, and the argument passed to the
+ *     finisher function must be the result of a previous invocation of the
+ *     initializer or combiner functions.</li>
+ *     <li>The implementation should not do anything with the result of any of
+ *     the initializer or combiner functions other than to
+ *     pass them again to the integrator, combiner, or finisher functions.</li>
+ *     <li>Once a state object is passed to the combiner or finisher function,
+ *     it is never passed to the integrator function again.</li>
+ *     <li>When the integrator function returns {@code false},
+ *     it shall be interpreted just as if there were no more elements to pass
+ *     it.</li>
+ *     <li>For parallel evaluation, the gathering implementation must manage
+ *     that the input is properly partitioned, that partitions are processed
+ *     in isolation, and combining happens only after integration is complete
+ *     for both partitions.</li>
+ *     <li>Gatherers whose combiner is {@link #defaultCombiner()} may only be
+ *     evaluated sequentially. All other combiners allow the operation to be
+ *     parallelized by initializing each partition in separation, invoking
+ *     the integrator until it returns {@code false}, and then joining each
+ *     partitions state using the combiner, and then invoking the finisher on
+ *     the joined state. Outputs and state later in the input sequence will
+ *     be discarded if processing an earlier partition short-circuits.</li>
+ *     <li>Gatherers whose finisher is {@link #defaultFinisher()} are considered
+ *     to not have an end-of-stream hook and invoking their finisher is
+ *     optional.</li>
+ * </ul>
+ *
+ * @see Stream#gather(Gatherer)
+ * @see Gatherers
+ *
+ * @param <T> the type of input elements to the gatherer operation
+ * @param <A> the potentially mutable state type of the gatherer operation
+ *            (often hidden as an implementation detail)
+ * @param <R> the type of output elements from the gatherer operation
+ * @since 24
+ */
+public interface Gatherer<T, A, R> {
+    /**
+     * A function that produces an instance of the intermediate state used for
+     * this gathering operation.
+     *
+     * @implSpec The implementation in this interface returns
+     *           {@link #defaultInitializer()}.
+     *
+     * @return A function that produces an instance of the intermediate state
+     * used for this gathering operation
+     */
+    default Supplier<A> initializer() {
+        return defaultInitializer();
+    };
+
+    /**
+     * A function which integrates provided elements, potentially using
+     * the provided intermediate state, optionally producing output to the
+     * provided {@link Downstream}.
+     *
+     * @return a function which integrates provided elements, potentially using
+     *         the provided state, optionally producing output to the provided
+     *         Downstream
+     */
+    Integrator<A, T, R> integrator();
+
+    /**
+     * A function which accepts two intermediate states and combines them into
+     * one.
+     *
+     * @implSpec The implementation in this interface returns
+     *           {@link #defaultCombiner()}.
+     *
+     * @return a function which accepts two intermediate states and combines
+     *         them into one
+     */
+    default BinaryOperator<A> combiner() {
+        return defaultCombiner();
+    }
+
+    /**
+     * A function which accepts the final intermediate state
+     * and a {@link Downstream} object, allowing to perform a final action at
+     * the end of input elements.
+     *
+     * @implSpec The implementation in this interface returns
+     *           {@link #defaultFinisher()}.
+     *
+     * @return a function which transforms the intermediate result to the final
+     *         result(s) which are then passed on to the provided Downstream
+     */
+    default BiConsumer<A, Downstream<? super R>> finisher() {
+        return defaultFinisher();
+    }
+
+    /**
+     * Returns a composed Gatherer which connects the output of this Gatherer
+     * to the input of that Gatherer.
+     *
+     * @implSpec The implementation in this interface returns a new Gatherer
+     *           which is semantically equivalent to the combination of
+     *           {@code this} and {@code that} gatherer.
+     *
+     * @param that the other gatherer
+     * @param <RR> The type of output of that Gatherer
+     * @throws NullPointerException if the argument is {@code null}
+     * @return returns a composed Gatherer which connects the output of this
+     *         Gatherer as input that Gatherer
+     */
+    default <RR> Gatherer<T, ?, RR> andThen(Gatherer<? super R, ?, ? extends RR> that) {
+        Objects.requireNonNull(that);
+        return Gatherers.Composite.of(this, that);
+    }
+
+    /**
+     * Returns an initializer which is the default initializer of a Gatherer.
+     * The returned initializer identifies that the owner Gatherer is stateless.
+     *
+     * @implSpec This method always returns the same instance.
+     *
+     * @see Gatherer#initializer()
+     * @return the instance of the default initializer
+     * @param <A> the type of the state of the returned initializer
+     */
+    static <A> Supplier<A> defaultInitializer() {
+        return Gatherers.Value.DEFAULT.initializer();
+    }
+
+    /**
+     * Returns a combiner which is the default combiner of a Gatherer.
+     * The returned combiner identifies that the owning Gatherer must only
+     * be evaluated sequentially.
+     *
+     * @implSpec This method always returns the same instance.
+     *
+     * @see Gatherer#combiner()
+     * @return the instance of the default combiner
+     * @param <A> the type of the state of the returned combiner
+     */
+    static <A> BinaryOperator<A> defaultCombiner() {
+        return Gatherers.Value.DEFAULT.combiner();
+    }
+
+    /**
+     * Returns a {@code finisher} which is the default finisher of
+     * a {@code Gatherer}.
+     * The returned finisher identifies that the owning Gatherer performs
+     * no additional actions at the end of input.
+     *
+     * @implSpec This method always returns the same instance.
+     *
+     * @see Gatherer#finisher()
+     * @return the instance of the default finisher
+     * @param <A> the type of the state of the returned finisher
+     * @param <R> the type of the Downstream of the returned finisher
+     */
+    static <A, R> BiConsumer<A, Downstream<? super R>> defaultFinisher() {
+        return Gatherers.Value.DEFAULT.finisher();
+    }
+
+    /**
+     * Returns a new, sequential, and stateless {@code Gatherer} described by
+     * the given {@code integrator}.
+     *
+     * @param integrator the integrator function for the new gatherer
+     * @param <T> the type of input elements for the new gatherer
+     * @param <R> the type of results for the new gatherer
+     * @throws NullPointerException if the argument is {@code null}
+     * @return the new {@code Gatherer}
+     */
+    static <T, R> Gatherer<T, Void, R> ofSequential(
+            Integrator<Void, T, R> integrator) {
+        return of(
+                defaultInitializer(),
+                integrator,
+                defaultCombiner(),
+                defaultFinisher()
+        );
+    }
+
+    /**
+     * Returns a new, sequential, and stateless {@code Gatherer} described by
+     * the given {@code integrator} and {@code finisher}.
+     *
+     * @param integrator the integrator function for the new gatherer
+     * @param finisher the finisher function for the new gatherer
+     * @param <T> the type of input elements for the new gatherer
+     * @param <R> the type of results for the new gatherer
+     * @throws NullPointerException if any argument is {@code null}
+     * @return the new {@code Gatherer}
+     */
+    static <T, R> Gatherer<T, Void, R> ofSequential(
+            Integrator<Void, T, R> integrator,
+            BiConsumer<Void, Downstream<? super R>> finisher) {
+        return of(
+                defaultInitializer(),
+                integrator,
+                defaultCombiner(),
+                finisher
+        );
+    }
+
+    /**
+     * Returns a new, sequential, {@code Gatherer} described by the given
+     * {@code initializer} and {@code integrator}.
+     *
+     * @param initializer the initializer function for the new gatherer
+     * @param integrator the integrator function for the new gatherer
+     * @param <T> the type of input elements for the new gatherer
+     * @param <A> the type of state for the new gatherer
+     * @param <R> the type of results for the new gatherer
+     * @throws NullPointerException if any argument is {@code null}
+     * @return the new {@code Gatherer}
+     */
+    static <T, A, R> Gatherer<T, A, R> ofSequential(
+            Supplier<A> initializer,
+            Integrator<A, T, R> integrator) {
+        return of(
+                initializer,
+                integrator,
+                defaultCombiner(),
+                defaultFinisher()
+        );
+    }
+
+    /**
+     * Returns a new, sequential, {@code Gatherer} described by the given
+     * {@code initializer}, {@code integrator}, and {@code finisher}.
+     *
+     * @param initializer the initializer function for the new gatherer
+     * @param integrator the integrator function for the new gatherer
+     * @param finisher the finisher function for the new gatherer
+     * @param <T> the type of input elements for the new gatherer
+     * @param <A> the type of state for the new gatherer
+     * @param <R> the type of results for the new gatherer
+     * @throws NullPointerException if any argument is {@code null}
+     * @return the new {@code Gatherer}
+     */
+    static <T, A, R> Gatherer<T, A, R> ofSequential(
+            Supplier<A> initializer,
+            Integrator<A, T, R> integrator,
+            BiConsumer<A, Downstream<? super R>> finisher) {
+        return of(
+                initializer,
+                integrator,
+                defaultCombiner(),
+                finisher
+        );
+    }
+
+    /**
+     * Returns a new, parallelizable, and stateless {@code Gatherer} described
+     * by the given {@code integrator}.
+     *
+     * @param integrator the integrator function for the new gatherer
+     * @param <T> the type of input elements for the new gatherer
+     * @param <R> the type of results for the new gatherer
+     * @throws NullPointerException if any argument is {@code null}
+     * @return the new {@code Gatherer}
+     */
+    static <T, R> Gatherer<T, Void, R> of(Integrator<Void, T, R> integrator) {
+        return of(
+                defaultInitializer(),
+                integrator,
+                Gatherers.Value.DEFAULT.statelessCombiner,
+                defaultFinisher()
+        );
+    }
+
+    /**
+     * Returns a new, parallelizable, and stateless {@code Gatherer} described
+     * by the given {@code integrator} and {@code finisher}.
+     *
+     * @param integrator the integrator function for the new gatherer
+     * @param finisher the finisher function for the new gatherer
+     * @param <T> the type of input elements for the new gatherer
+     * @param <R> the type of results for the new gatherer
+     * @throws NullPointerException if any argument is {@code null}
+     * @return the new {@code Gatherer}
+     */
+    static <T, R> Gatherer<T, Void, R> of(
+            Integrator<Void, T, R> integrator,
+            BiConsumer<Void, Downstream<? super R>> finisher) {
+        return of(
+                defaultInitializer(),
+                integrator,
+                Gatherers.Value.DEFAULT.statelessCombiner,
+                finisher
+        );
+    }
+
+    /**
+     * Returns a new, parallelizable, {@code Gatherer} described by the given
+     * {@code initializer}, {@code integrator}, {@code combiner} and
+     * {@code finisher}.
+     *
+     * @param initializer the initializer function for the new gatherer
+     * @param integrator the integrator function for the new gatherer
+     * @param combiner the combiner function for the new gatherer
+     * @param finisher the finisher function for the new gatherer
+     * @param <T> the type of input elements for the new gatherer
+     * @param <A> the type of state for the new gatherer
+     * @param <R> the type of results for the new gatherer
+     * @throws NullPointerException if any argument is {@code null}
+     * @return the new {@code Gatherer}
+     */
+    static <T, A, R> Gatherer<T, A, R> of(
+            Supplier<A> initializer,
+            Integrator<A, T, R> integrator,
+            BinaryOperator<A> combiner,
+            BiConsumer<A, Downstream<? super R>> finisher) {
+        return new Gatherers.GathererImpl<>(
+                Objects.requireNonNull(initializer),
+                Objects.requireNonNull(integrator),
+                Objects.requireNonNull(combiner),
+                Objects.requireNonNull(finisher)
+        );
+    }
+
+    /**
+     * A Downstream object is the next stage in a pipeline of operations,
+     * to which elements can be sent.
+     * @param <T> the type of elements this downstream accepts
+     * @since 24
+     */
+    @FunctionalInterface
+    interface Downstream<T> {
+
+        /**
+         * Pushes, if possible, the provided element downstream -- to the next
+         * stage in the pipeline.
+         *
+         * @implSpec If this method returns {@code false} then no further
+         * elements will be accepted and subsequent invocations of this method
+         * will return {@code false}.
+         *
+         * @param element the element to push downstream
+         * @return {@code true} if more elements can be sent,
+         *         and {@code false} if not.
+         */
+        boolean push(T element);
+
+        /**
+         * Checks whether the next stage is known to not want
+         * any more elements sent to it.
+         *
+         * @apiNote This is best-effort only, once this returns {@code true} it
+         * should never return {@code false} again for the same instance.
+         *
+         * @implSpec The implementation in this interface returns {@code false}.
+         *
+         * @return {@code true} if this Downstream is known not to want any
+         *         more elements sent to it, {@code false} if otherwise
+         */
+        default boolean isRejecting() { return false; }
+    }
+
+    /**
+     * An Integrator receives elements and processes them,
+     * optionally using the supplied state, and optionally sends incremental
+     * results downstream.
+     *
+     * @param <A> the type of state used by this integrator
+     * @param <T> the type of elements this integrator consumes
+     * @param <R> the type of results this integrator can produce
+     * @since 24
+     */
+    @FunctionalInterface
+    interface Integrator<A, T, R> {
+        /**
+         * Performs an action given: the current state, the next element, and
+         * a downstream object; potentially inspecting and/or updating
+         * the state, optionally sending any number of elements downstream
+         * -- and then returns whether more elements are to be consumed or not.
+         *
+         * @param state The state to integrate into
+         * @param element The element to integrate
+         * @param downstream The downstream object of this integration
+         * @return {@code true} if subsequent integration is desired,
+         *         {@code false} if not
+         */
+        boolean integrate(A state, T element, Downstream<? super R> downstream);
+
+        /**
+         * Factory method for turning Integrator-shaped lambdas into
+         * Integrators.
+         *
+         * @param integrator a lambda to create as Integrator
+         * @return the given lambda as an Integrator
+         * @param <A> the type of state used by this integrator
+         * @param <T> the type of elements this integrator receives
+         * @param <R> the type of results this integrator can produce
+         */
+        @ForceInline
+        static <A, T, R> Integrator<A, T, R> of(Integrator<A, T, R> integrator) {
+            return integrator;
+        }
+
+        /**
+         * Factory method for turning Integrator-shaped lambdas into
+         * {@link Greedy} Integrators.
+         *
+         * @param greedy a lambda to create as Integrator.Greedy
+         * @return the given lambda as a Greedy Integrator
+         * @param <A> the type of state used by this integrator
+         * @param <T> the type of elements this integrator receives
+         * @param <R> the type of results this integrator can produce
+         */
+        @ForceInline
+        static <A, T, R> Greedy<A, T, R> ofGreedy(Greedy<A, T, R> greedy) {
+            return greedy;
+        }
+
+        /**
+         * Greedy Integrators consume all their input, and may only relay that
+         * the downstream does not want more elements.
+         *
+         * @implSpec This interface is used to communicate that no
+         * short-circuiting will be <i>initiated</i> by this Integrator, and that
+         * information can then be used to optimize evaluation.
+         *
+         * @param <A> the type of state used by this integrator
+         * @param <T> the type of elements this greedy integrator receives
+         * @param <R> the type of results this greedy integrator can produce
+         * @since 24
+         */
+        @FunctionalInterface
+        interface Greedy<A, T, R> extends Integrator<A, T, R> { }
+    }
+}
diff --git a/ojluni/src/main/java/java/util/stream/GathererOp.java b/ojluni/src/main/java/java/util/stream/GathererOp.java
new file mode 100644
index 00000000000..451271cb052
--- /dev/null
+++ b/ojluni/src/main/java/java/util/stream/GathererOp.java
@@ -0,0 +1,744 @@
+/*
+ * Copyright (c) 2023, 2024, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package java.util.stream;
+
+import jdk.internal.invoke.MhUtil;
+import jdk.internal.vm.annotation.ForceInline;
+
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.VarHandle;
+import java.util.Spliterator;
+import java.util.concurrent.CountedCompleter;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.BiConsumer;
+import java.util.function.BinaryOperator;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.IntFunction;
+import java.util.function.Supplier;
+import java.util.stream.Gatherer.Integrator;
+
+/**
+ * Runtime machinery for evaluating Gatherers under different modes.
+ * The performance-critical code below contains some more complicated encodings:
+ * therefore, make sure to run benchmarks to verify changes to prevent regressions.
+ *
+ * @since 24
+ */
+final class GathererOp<T, A, R> extends ReferencePipeline<T, R> {
+    @SuppressWarnings("unchecked")
+    static <P_IN, P_OUT extends T, T, A, R> Stream<R> of(
+            ReferencePipeline<P_IN, P_OUT> upstream,
+            Gatherer<T, A, R> gatherer) {
+        // When attaching a gather-operation onto another gather-operation,
+        // we can fuse them into one
+        if (upstream.getClass() == GathererOp.class) {
+            return new GathererOp<>(
+                    ((GathererOp<P_IN, Object, P_OUT>) upstream).gatherer.andThen(gatherer),
+                    (GathererOp<?, ?, P_IN>) upstream);
+        } else {
+            return new GathererOp<>(
+                    (ReferencePipeline<?, T>) upstream,
+                    gatherer);
+        }
+    }
+
+    /*
+     * GathererOp.NodeBuilder is a lazy accumulator of elements with O(1)
+     * `append`, and O(8) `join` (concat).
+     *
+     * First `append` inflates a growable Builder, the O(8) for `join` is
+     * because we prefer to delegate to `append` for small concatenations to
+     * avoid excessive indirections (unbalanced Concat-trees) when joining many
+     * NodeBuilders together.
+     */
+    static final class NodeBuilder<X> implements Consumer<X> {
+        private static final int LINEAR_APPEND_MAX = 8; // TODO revisit
+        static final class Builder<X> extends SpinedBuffer<X> implements Node<X> {
+            Builder() {
+            }
+        }
+
+        NodeBuilder() {
+        }
+
+        private Builder<X> rightMost;
+        private Node<X> leftMost;
+
+        private boolean isEmpty() {
+            return rightMost == null && leftMost == null;
+        }
+
+        @Override
+        public void accept(X x) {
+            final var b = rightMost;
+            (b == null ? (rightMost = new NodeBuilder.Builder<>()) : b).accept(x);
+        }
+
+        public NodeBuilder<X> join(NodeBuilder<X> that) {
+            if (isEmpty())
+                return that;
+
+            if (!that.isEmpty()) {
+                final var tb = that.build();
+                if (rightMost != null && tb instanceof NodeBuilder.Builder<X>
+                && tb.count() < LINEAR_APPEND_MAX)
+                    tb.forEach(this); // Avoid conc for small nodes
+                else
+                    leftMost = Nodes.conc(StreamShape.REFERENCE, this.build(), tb);
+            }
+
+            return this;
+        }
+
+        public Node<X> build() {
+            if (isEmpty())
+                return Nodes.emptyNode(StreamShape.REFERENCE);
+
+            final var rm = rightMost;
+
+            if (rm != null) {
+                rightMost = null; // Make sure builder isn't reused
+                final var lm = leftMost;
+                leftMost = (lm == null) ? rm : Nodes.conc(StreamShape.REFERENCE, lm, rm);
+            }
+
+            return leftMost;
+        }
+    }
+
+    static final class GatherSink<T, A, R> implements Sink<T>, Gatherer.Downstream<R> {
+        private final Sink<R> sink;
+        private final Gatherer<T, A, R> gatherer;
+        private final Integrator<A, T, R> integrator; // Optimization: reuse
+        private A state;
+        private boolean proceed = true;
+        private boolean downstreamProceed = true;
+
+        GatherSink(Gatherer<T, A, R> gatherer, Sink<R> sink) {
+            this.gatherer = gatherer;
+            this.sink = sink;
+            this.integrator = gatherer.integrator();
+        }
+
+        // java.util.stream.Sink contract below:
+
+        @Override
+        public void begin(long size) {
+            final var initializer = gatherer.initializer();
+            if (initializer != Gatherer.defaultInitializer()) // Optimization
+                state = initializer.get();
+            sink.begin(-1); // GathererOp does not know the size of the output
+        }
+
+        @Override
+        public void accept(T t) {
+            /* Benchmarks have indicated that doing an unconditional write to
+             * `proceed` is more efficient than branching.
+             * We use `&=` here to prevent flips from `false` -> `true`.
+             *
+             * As of writing this, taking `greedy` or `stateless` into
+             * consideration at this point doesn't yield any performance gains.
+             */
+            proceed &= integrator.integrate(state, t, this);
+        }
+
+        @Override
+        public boolean cancellationRequested() {
+            return cancellationRequested(proceed && downstreamProceed);
+        }
+
+        private boolean cancellationRequested(boolean knownProceed) {
+            // Highly performance sensitive
+            return !(knownProceed && (!sink.cancellationRequested() || (downstreamProceed = false)));
+        }
+
+        @Override
+        public void end() {
+            final var finisher = gatherer.finisher();
+            if (finisher != Gatherer.<A, R>defaultFinisher()) // Optimization
+                finisher.accept(state, this);
+            sink.end();
+            state = null; // GC assistance
+        }
+
+        // Gatherer.Sink contract below:
+
+        @Override
+        public boolean isRejecting() {
+            return !downstreamProceed;
+        }
+
+        @Override
+        public boolean push(R r) {
+            var p = downstreamProceed;
+            if (p)
+                sink.accept(r);
+            return !cancellationRequested(p);
+        }
+    }
+
+    private static int opFlagsFor(Integrator<?, ?, ?> integrator) {
+        return integrator instanceof Integrator.Greedy<?, ?, ?>
+                ? GREEDY_FLAGS : SHORT_CIRCUIT_FLAGS;
+    }
+
+    private static final int DEFAULT_FLAGS =
+            StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT |
+                    StreamOpFlag.NOT_SIZED;
+
+    private static final int SHORT_CIRCUIT_FLAGS =
+            DEFAULT_FLAGS | StreamOpFlag.IS_SHORT_CIRCUIT;
+
+    private static final int GREEDY_FLAGS =
+            DEFAULT_FLAGS;
+
+    final Gatherer<T, A, R> gatherer;
+
+    /*
+     * This constructor is used for initial .gather() invocations
+     */
+    private GathererOp(ReferencePipeline<?, T> upstream, Gatherer<T, A, R> gatherer) {
+        /* TODO this is a prime spot for pre-super calls to make sure that
+         * we only need to call `integrator()` once.
+         */
+        super(upstream, opFlagsFor(gatherer.integrator()));
+        this.gatherer = gatherer;
+    }
+
+    /*
+     * This constructor is used when fusing subsequent .gather() invocations
+     */
+    @SuppressWarnings("unchecked")
+    private GathererOp(Gatherer<T, A, R> gatherer, GathererOp<?, ?, T> upstream) {
+        super((AbstractPipeline<?, T, ?>) upstream.upstream(),
+              upstream,
+              opFlagsFor(gatherer.integrator()));
+        this.gatherer = gatherer;
+    }
+
+    /* This allows internal access to the previous stage,
+     * to be able to fuse `gather` followed by `collect`.
+     */
+    @SuppressWarnings("unchecked")
+    private AbstractPipeline<?, T, ?> upstream() {
+        return (AbstractPipeline<?, T, ?>) super.previousStage;
+    }
+
+    @Override
+    // Android-changed: Made public for CTS tests only.
+    public boolean opIsStateful() {
+        // TODO
+        /* Currently GathererOp is always stateful, but what could be tried is:
+         * return gatherer.initializer() != Gatherer.defaultInitializer()
+         *     || gatherer.combiner() == Gatherer.defaultCombiner()
+         *     || gatherer.finisher() != Gatherer.defaultFinisher();
+         */
+        return true;
+    }
+
+    @Override
+    // Android-changed: Made public for CTS tests only.
+    public Sink<T> opWrapSink(int flags, Sink<R> downstream) {
+        return new GatherSink<>(gatherer, downstream);
+    }
+
+    /*
+     * This is used when evaluating .gather() operations interspersed with
+     * other Stream operations (in parallel)
+     */
+    @Override
+    // Android-changed: Made public for CTS tests only.
+    public <I> Node<R> opEvaluateParallel(PipelineHelper<R> unused1,
+                                   Spliterator<I> spliterator,
+                                   IntFunction<R[]> unused2) {
+        return this.<NodeBuilder<R>, Node<R>>evaluate(
+            upstream().wrapSpliterator(spliterator),
+            true,
+            gatherer,
+            NodeBuilder::new,
+            NodeBuilder::accept,
+            NodeBuilder::join,
+            NodeBuilder::build
+        );
+    }
+
+    @Override
+    // Android-changed: Made public for CTS tests only.
+    public <P_IN> Spliterator<R> opEvaluateParallelLazy(PipelineHelper<R> helper,
+                                                 Spliterator<P_IN> spliterator) {
+        /*
+         * There's a very small subset of possible Gatherers which would be
+         * expressible as Spliterators directly,
+         * - the Gatherer's initializer is Gatherer.defaultInitializer(),
+         * - the Gatherer's combiner is NOT Gatherer.defaultCombiner()
+         * - the Gatherer's finisher is Gatherer.defaultFinisher()
+         */
+        return opEvaluateParallel(null, spliterator, null).spliterator();
+    }
+
+    /* gather-operations immediately followed by (terminal) collect-operations
+     * are fused together to avoid having to first run the gathering to
+     * completion and only after that be able to run the collection on top of
+     * the output.  This is highly beneficial in the parallel case as stateful
+     * operations cannot be pipelined in the ReferencePipeline implementation.
+     * Overriding collect-operations overcomes this limitation.
+     */
+    @Override
+    public <CR, CA> CR collect(Collector<? super R, CA, CR> c) {
+        linkOrConsume(); // Important for structural integrity
+        final var parallel = isParallel();
+        final var u = upstream();
+        return evaluate(
+            u.wrapSpliterator(u.sourceSpliterator(0)),
+            parallel,
+            gatherer,
+            c.supplier(),
+            c.accumulator(),
+            parallel ? c.combiner() : null,
+            c.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)
+                    ? null
+                    : c.finisher()
+        );
+    }
+
+    @Override
+    public <RR> RR collect(Supplier<RR> supplier,
+                           BiConsumer<RR, ? super R> accumulator,
+                           BiConsumer<RR, RR> combiner) {
+        linkOrConsume(); // Important for structural integrity
+        final var parallel = isParallel();
+        final var u = upstream();
+        return evaluate(
+            u.wrapSpliterator(u.sourceSpliterator(0)),
+            parallel,
+            gatherer,
+            supplier,
+            accumulator,
+            parallel ? (l, r) -> {
+                combiner.accept(l, r);
+                return l;
+            } : null,
+            null
+        );
+    }
+
+    /*
+     * evaluate(...) is the primary execution mechanism besides opWrapSink()
+     * and implements both sequential, hybrid parallel-sequential, and
+     * parallel evaluation
+     */
+    private <CA, CR> CR evaluate(final Spliterator<T> spliterator,
+                                 final boolean parallel,
+                                 final Gatherer<T, A, R> gatherer,
+                                 final Supplier<CA> collectorSupplier,
+                                 final BiConsumer<CA, ? super R> collectorAccumulator,
+                                 final BinaryOperator<CA> collectorCombiner,
+                                 final Function<CA, CR> collectorFinisher) {
+
+        // There are two main sections here: sequential and parallel
+
+        final var initializer = gatherer.initializer();
+        final var integrator = gatherer.integrator();
+
+        // Optimization
+        final boolean greedy = integrator instanceof Integrator.Greedy<A, T, R>;
+
+        // Sequential evaluation section starts here.
+
+        // Sequential is the fusion of a Gatherer and a Collector which can
+        // be evaluated sequentially.
+        final class Sequential implements Consumer<T>, Gatherer.Downstream<R> {
+            A state;
+            CA collectorState;
+            boolean proceed;
+
+            Sequential() {
+                if (initializer != Gatherer.defaultInitializer())
+                    state = initializer.get();
+                collectorState = collectorSupplier.get();
+                proceed = true;
+            }
+
+            @ForceInline
+            Sequential evaluateUsing(Spliterator<T> spliterator) {
+                if (greedy)
+                    spliterator.forEachRemaining(this);
+                else
+                    do {
+                    } while (proceed && spliterator.tryAdvance(this));
+
+                return this;
+            }
+
+            /*
+             * No need to override isKnownDone() as the default is `false`
+             * and collectors can never short-circuit.
+             */
+            @Override
+            public boolean push(R r) {
+                collectorAccumulator.accept(collectorState, r);
+                return true;
+            }
+
+            @Override
+            public void accept(T t) {
+                /*
+                 * Benchmarking has shown that, in this case, conditional
+                 * writing of `proceed` is desirable  and if that was not the
+                 *  case, then the following line would've been clearer:
+                 *
+                 * proceed &= integrator.integrate(state, t, this);
+                 */
+
+                var ignore = integrator.integrate(state, t, this)
+                             || (!greedy && (proceed = false));
+            }
+
+            @SuppressWarnings("unchecked")
+            public CR get() {
+                final var finisher = gatherer.finisher();
+                if (finisher != Gatherer.<A, R>defaultFinisher())
+                    finisher.accept(state, this);
+                // IF collectorFinisher == null -> IDENTITY_FINISH
+                return (collectorFinisher == null)
+                           ? (CR) collectorState
+                           : collectorFinisher.apply(collectorState);
+            }
+        }
+
+        /*
+         * It could be considered to also go to sequential mode if the
+         * operation is non-greedy AND the combiner is Gatherer.defaultCombiner()
+         * as those operations will not benefit from upstream parallel
+         * preprocessing which is the main advantage of the Hybrid evaluation
+         * strategy.
+         */
+        if (!parallel)
+            return new Sequential().evaluateUsing(spliterator).get();
+
+        // Parallel section starts here:
+
+        final var combiner = gatherer.combiner();
+
+        /*
+         * The following implementation of hybrid parallel-sequential
+         * Gatherer processing borrows heavily from ForeachOrderedTask,
+         * and adds handling of short-circuiting.
+         */
+        @SuppressWarnings("serial")
+        final class Hybrid extends CountedCompleter<Sequential> {
+            private final long targetSize;
+            private final Hybrid leftPredecessor;
+            private final AtomicBoolean cancelled;
+            private final Sequential localResult;
+
+            private Spliterator<T> spliterator;
+            private Hybrid next;
+
+            private static final VarHandle NEXT = MhUtil.findVarHandle(
+                    MethodHandles.lookup(), "next", Hybrid.class);
+
+            protected Hybrid(Spliterator<T> spliterator) {
+                super(null);
+                this.spliterator = spliterator;
+                this.targetSize =
+                    AbstractTask.suggestTargetSize(spliterator.estimateSize());
+                this.localResult = new Sequential();
+                this.cancelled = greedy ? null : new AtomicBoolean(false);
+                this.leftPredecessor = null;
+            }
+
+            Hybrid(Hybrid parent, Spliterator<T> spliterator, Hybrid leftPredecessor) {
+                super(parent);
+                this.spliterator = spliterator;
+                this.targetSize = parent.targetSize;
+                this.localResult = parent.localResult;
+                this.cancelled = parent.cancelled;
+                this.leftPredecessor = leftPredecessor;
+            }
+
+            @Override
+            public Sequential getRawResult() {
+                return localResult;
+            }
+
+            @Override
+            public void setRawResult(Sequential result) {
+                if (result != null) throw new IllegalStateException();
+            }
+
+            @Override
+            public void compute() {
+                var task = this;
+                Spliterator<T> rightSplit = task.spliterator, leftSplit;
+                long sizeThreshold = task.targetSize;
+                boolean forkRight = false;
+                while ((greedy || !cancelled.get())
+                       && rightSplit.estimateSize() > sizeThreshold
+                       && (leftSplit = rightSplit.trySplit()) != null) {
+
+                    var leftChild = new Hybrid(task, leftSplit, task.leftPredecessor);
+                    var rightChild = new Hybrid(task, rightSplit, leftChild);
+
+                    /* leftChild and rightChild were just created and not
+                     * fork():ed yet so no need for a volatile write
+                     */
+                    leftChild.next = rightChild;
+
+                    // Fork the parent task
+                    // Completion of the left and right children "happens-before"
+                    // completion of the parent
+                    task.addToPendingCount(1);
+                    // Completion of the left child "happens-before" completion of
+                    // the right child
+                    rightChild.addToPendingCount(1);
+
+                    // If task is not on the left spine
+                    if (task.leftPredecessor != null) {
+                        /*
+                         * Completion of left-predecessor, or left subtree,
+                         * "happens-before" completion of left-most leaf node of
+                         * right subtree.
+                         * The left child's pending count needs to be updated before
+                         * it is associated in the completion map, otherwise the
+                         * left child can complete prematurely and violate the
+                         * "happens-before" constraint.
+                         */
+                        leftChild.addToPendingCount(1);
+                        // Update association of left-predecessor to left-most
+                        // leaf node of right subtree
+                        if (NEXT.compareAndSet(task.leftPredecessor, task, leftChild)) {
+                            // If replaced, adjust the pending count of the parent
+                            // to complete when its children complete
+                            task.addToPendingCount(-1);
+                        } else {
+                            // Left-predecessor has already completed, parent's
+                            // pending count is adjusted by left-predecessor;
+                            // left child is ready to complete
+                            leftChild.addToPendingCount(-1);
+                        }
+                    }
+
+                    if (forkRight) {
+                        rightSplit = leftSplit;
+                        task = leftChild;
+                        rightChild.fork();
+                    } else {
+                        task = rightChild;
+                        leftChild.fork();
+                    }
+                    forkRight = !forkRight;
+                }
+
+                /*
+                 * Task's pending count is either 0 or 1.  If 1 then the completion
+                 * map will contain a value that is task, and two calls to
+                 * tryComplete are required for completion, one below and one
+                 * triggered by the completion of task's left-predecessor in
+                 * onCompletion.  Therefore there is no data race within the if
+                 * block.
+                 *
+                 * IMPORTANT: Currently we only perform the processing of this
+                 * upstream data if we know the operation is greedy -- as we cannot
+                 * safely speculate on the cost/benefit ratio of parallelizing
+                 * the pre-processing of upstream data under short-circuiting.
+                 */
+                if (greedy && task.getPendingCount() > 0) {
+                    // Upstream elements are buffered
+                    NodeBuilder<T> nb = new NodeBuilder<>();
+                    rightSplit.forEachRemaining(nb); // Run the upstream
+                    task.spliterator = nb.build().spliterator();
+                }
+                task.tryComplete();
+            }
+
+            @Override
+            public void onCompletion(CountedCompleter<?> caller) {
+                var s = spliterator;
+                spliterator = null; // GC assistance
+
+                /* Performance sensitive since each leaf-task could have a
+                 * spliterator of size 1 which means that all else is overhead
+                 * which needs minimization.
+                 */
+                if (s != null
+                    && (greedy || !cancelled.get())
+                    && !localResult.evaluateUsing(s).proceed
+                    && !greedy)
+                    cancelled.set(true);
+
+                // The completion of this task *and* the dumping of elements
+                // "happens-before" completion of the associated left-most leaf task
+                // of right subtree (if any, which can be this task's right sibling)
+                @SuppressWarnings("unchecked")
+                var leftDescendant = (Hybrid) NEXT.getAndSet(this, null);
+                if (leftDescendant != null) {
+                    leftDescendant.tryComplete();
+                }
+            }
+        }
+
+        /*
+         * The following implementation of parallel Gatherer processing
+         * borrows heavily from AbstractShortCircuitTask
+         */
+        @SuppressWarnings("serial")
+        final class Parallel extends CountedCompleter<Sequential> {
+            private Spliterator<T> spliterator;
+            private Parallel leftChild; // Only non-null if rightChild is
+            private Parallel rightChild; // Only non-null if leftChild is
+            private Sequential localResult;
+            private volatile boolean canceled;
+            private long targetSize; // lazily initialized
+
+            private Parallel(Parallel parent, Spliterator<T> spliterator) {
+                super(parent);
+                this.targetSize = parent.targetSize;
+                this.spliterator = spliterator;
+            }
+
+            Parallel(Spliterator<T> spliterator) {
+                super(null);
+                this.targetSize = 0L;
+                this.spliterator = spliterator;
+            }
+
+            private long getTargetSize(long sizeEstimate) {
+                long s;
+                return ((s = targetSize) != 0
+                        ? s
+                        : (targetSize = AbstractTask.suggestTargetSize(sizeEstimate)));
+            }
+
+            @Override
+            public Sequential getRawResult() {
+                return localResult;
+            }
+
+            @Override
+            public void setRawResult(Sequential result) {
+                if (result != null) throw new IllegalStateException();
+            }
+
+            private void doProcess() {
+                if (!(localResult = new Sequential()).evaluateUsing(spliterator).proceed
+                    && !greedy)
+                    cancelLaterTasks();
+            }
+
+            @Override
+            public void compute() {
+                Spliterator<T> rs = spliterator, ls;
+                long sizeEstimate = rs.estimateSize();
+                final long sizeThreshold = getTargetSize(sizeEstimate);
+                Parallel task = this;
+                boolean forkRight = false;
+                boolean proceed;
+                while ((proceed = (greedy || !task.isRequestedToCancel()))
+                        && sizeEstimate > sizeThreshold
+                        && (ls = rs.trySplit()) != null) {
+                    final var leftChild = task.leftChild = new Parallel(task, ls);
+                    final var rightChild = task.rightChild = new Parallel(task, rs);
+                    task.setPendingCount(1);
+                    if (forkRight) {
+                        rs = ls;
+                        task = leftChild;
+                        rightChild.fork();
+                    } else {
+                        task = rightChild;
+                        leftChild.fork();
+                    }
+                    forkRight = !forkRight;
+                    sizeEstimate = rs.estimateSize();
+                }
+                if (proceed)
+                    task.doProcess();
+                task.tryComplete();
+            }
+
+            Sequential merge(Sequential l, Sequential r) {
+                /*
+                 * Only join the right if the left side didn't short-circuit,
+                 * or when greedy
+                 */
+                if (greedy || (l != null && r != null && l.proceed)) {
+                    l.state = combiner.apply(l.state, r.state);
+                    l.collectorState =
+                        collectorCombiner.apply(l.collectorState, r.collectorState);
+                    l.proceed = r.proceed;
+                    return l;
+                }
+
+                return (l != null) ? l : r;
+            }
+
+            @Override
+            public void onCompletion(CountedCompleter<?> caller) {
+                spliterator = null; // GC assistance
+                if (leftChild != null) {
+                    /* Results can only be null in the case where there's
+                     * short-circuiting or when Gatherers are stateful but
+                     * uses `null` as their state value.
+                     */
+                    localResult = merge(leftChild.localResult, rightChild.localResult);
+                    leftChild = rightChild = null; // GC assistance
+                }
+            }
+
+            @SuppressWarnings("unchecked")
+            private Parallel getParent() {
+                return (Parallel) getCompleter();
+            }
+
+            private boolean isRequestedToCancel() {
+                boolean cancel = canceled;
+                if (!cancel) {
+                    for (Parallel parent = getParent();
+                         !cancel && parent != null;
+                         parent = parent.getParent())
+                        cancel = parent.canceled;
+                }
+                return cancel;
+            }
+
+            private void cancelLaterTasks() {
+                // Go up the tree, cancel right siblings of this node and all parents
+                for (Parallel parent = getParent(), node = this;
+                     parent != null;
+                     node = parent, parent = parent.getParent()) {
+                    // If node is a left child of parent, then has a right sibling
+                    if (parent.leftChild == node)
+                        parent.rightChild.canceled = true;
+                }
+            }
+        }
+
+        if (combiner != Gatherer.defaultCombiner())
+            return new Parallel(spliterator).invoke().get();
+        else
+            return new Hybrid(spliterator).invoke().get();
+    }
+}
\ No newline at end of file
diff --git a/ojluni/src/main/java/java/util/stream/Gatherers.java b/ojluni/src/main/java/java/util/stream/Gatherers.java
new file mode 100644
index 00000000000..acc2ddfe78f
--- /dev/null
+++ b/ojluni/src/main/java/java/util/stream/Gatherers.java
@@ -0,0 +1,726 @@
+/*
+ * Copyright (c) 2023, 2025, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package java.util.stream;
+
+import jdk.internal.access.SharedSecrets;
+import jdk.internal.vm.annotation.ForceInline;
+
+import java.util.ArrayDeque;
+import java.util.List;
+import java.util.Objects;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.Semaphore;
+import java.util.function.BiConsumer;
+import java.util.function.BiFunction;
+import java.util.function.BinaryOperator;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import java.util.stream.Gatherer.Integrator;
+import java.util.stream.Gatherer.Downstream;
+
+/**
+ * Implementations of {@link Gatherer} that provide useful intermediate
+ * operations, such as windowing functions, folding functions,
+ * transforming elements concurrently, etc.
+ *
+ * @since 24
+*/
+public final class Gatherers {
+    private Gatherers() { } // This class is not intended to be instantiated
+
+    // Public built-in Gatherers and factory methods for them
+
+    /**
+     * Returns a Gatherer that gathers elements into windows
+     * -- encounter-ordered groups of elements -- of a fixed size.
+     * If the stream is empty then no window will be produced.
+     * The last window may contain fewer elements than the supplied window size.
+     *
+     * <p>Example:
+     * {@snippet lang = java:
+     * // will contain: [[1, 2, 3], [4, 5, 6], [7, 8]]
+     * List<List<Integer>> windows =
+     *     Stream.of(1,2,3,4,5,6,7,8).gather(Gatherers.windowFixed(3)).toList();
+     * }
+     *
+     * @implSpec Each window produced is an unmodifiable List; calls to any
+     * mutator method will always cause {@code UnsupportedOperationException}
+     * to be thrown. There are no guarantees on the implementation type or
+     * serializability of the produced Lists.
+     *
+     * @apiNote For efficiency reasons, windows may be allocated contiguously
+     *          and eagerly. This means that choosing large window sizes for
+     *          small streams may use excessive memory for the duration of
+     *          evaluation of this operation.
+     *
+     * @param windowSize the size of the windows
+     * @param <TR> the type of elements the returned gatherer consumes
+     *             and the contents of the windows it produces
+     * @return a new gatherer which groups elements into fixed-size windows
+     * @throws IllegalArgumentException when {@code windowSize} is less than 1
+     */
+    public static <TR> Gatherer<TR, ?, List<TR>> windowFixed(int windowSize) {
+        if (windowSize < 1)
+            throw new IllegalArgumentException("'windowSize' must be greater than zero");
+
+        class FixedWindow {
+            Object[] window;
+            int at;
+
+            FixedWindow() {
+                at = 0;
+                window = new Object[windowSize];
+            }
+
+            boolean integrate(TR element, Downstream<? super List<TR>> downstream) {
+                window[at++] = element;
+                if (at < windowSize) {
+                    return true;
+                } else {
+                    final var oldWindow = window;
+                    window = new Object[windowSize];
+                    at = 0;
+                    return downstream.push(
+                        SharedSecrets.getJavaUtilCollectionAccess()
+                                     .listFromTrustedArrayNullsAllowed(oldWindow)
+                    );
+                }
+            }
+
+            void finish(Downstream<? super List<TR>> downstream) {
+                if (at > 0 && !downstream.isRejecting()) {
+                    var lastWindow = new Object[at];
+                    System.arraycopy(window, 0, lastWindow, 0, at);
+                    window = null;
+                    at = 0;
+                    downstream.push(
+                        SharedSecrets.getJavaUtilCollectionAccess()
+                                     .listFromTrustedArrayNullsAllowed(lastWindow)
+                    );
+                }
+            }
+        }
+        return Gatherer.<TR, FixedWindow, List<TR>>ofSequential(
+                // Initializer
+                FixedWindow::new,
+
+                // Integrator
+                Integrator.<FixedWindow, TR, List<TR>>ofGreedy(FixedWindow::integrate),
+
+                // Finisher
+                FixedWindow::finish
+        );
+    }
+
+    /**
+     * Returns a Gatherer that gathers elements into windows --
+     * encounter-ordered groups of elements -- of a given size, where each
+     * subsequent window includes all elements of the previous window except
+     * for the least recent, and adds the next element in the stream.
+     * If the stream is empty then no window will be produced. If the size of
+     * the stream is smaller than the window size then only one window will
+     * be produced, containing all elements in the stream.
+     *
+     * <p>Example:
+     * {@snippet lang = java:
+     * // will contain: [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8]]
+     * List<List<Integer>> windows2 =
+     *     Stream.of(1,2,3,4,5,6,7,8).gather(Gatherers.windowSliding(2)).toList();
+     *
+     * // will contain: [[1, 2, 3, 4, 5, 6], [2, 3, 4, 5, 6, 7], [3, 4, 5, 6, 7, 8]]
+     * List<List<Integer>> windows6 =
+     *     Stream.of(1,2,3,4,5,6,7,8).gather(Gatherers.windowSliding(6)).toList();
+     * }
+     *
+     * @implSpec Each window produced is an unmodifiable List; calls to any
+     * mutator method will always cause {@code UnsupportedOperationException}
+     * to be thrown. There are no guarantees on the implementation type or
+     * serializability of the produced Lists.
+     *
+     * @apiNote For efficiency reasons, windows may be allocated contiguously
+     *          and eagerly. This means that choosing large window sizes for
+     *          small streams may use excessive memory for the duration of
+     *          evaluation of this operation.
+     *
+     * @param windowSize the size of the windows
+     * @param <TR> the type of elements the returned gatherer consumes
+     *             and the contents of the windows it produces
+     * @return a new gatherer which groups elements into sliding windows
+     * @throws IllegalArgumentException when windowSize is less than 1
+     */
+    public static <TR> Gatherer<TR, ?, List<TR>> windowSliding(int windowSize) {
+        if (windowSize < 1)
+            throw new IllegalArgumentException("'windowSize' must be greater than zero");
+
+        class SlidingWindow {
+            Object[] window;
+            int at;
+            boolean firstWindow;
+
+            SlidingWindow() {
+                firstWindow = true;
+                at = 0;
+                window = new Object[windowSize];
+            }
+
+            boolean integrate(TR element, Downstream<? super List<TR>> downstream) {
+                window[at++] = element;
+                if (at < windowSize) {
+                    return true;
+                } else {
+                    final var oldWindow = window;
+                    final var newWindow = new Object[windowSize];
+                    System.arraycopy(oldWindow,1, newWindow, 0, windowSize - 1);
+                    window = newWindow;
+                    at -= 1;
+                    firstWindow = false;
+                    return downstream.push(
+                        SharedSecrets.getJavaUtilCollectionAccess()
+                                     .listFromTrustedArrayNullsAllowed(oldWindow)
+                    );
+                }
+            }
+
+            void finish(Downstream<? super List<TR>> downstream) {
+                if (firstWindow && at > 0 && !downstream.isRejecting()) {
+                    var lastWindow = new Object[at];
+                    System.arraycopy(window, 0, lastWindow, 0, at);
+                    window = null;
+                    at = 0;
+                    downstream.push(
+                        SharedSecrets.getJavaUtilCollectionAccess()
+                                     .listFromTrustedArrayNullsAllowed(lastWindow)
+                    );
+                }
+            }
+        }
+        return Gatherer.<TR, SlidingWindow, List<TR>>ofSequential(
+                // Initializer
+                SlidingWindow::new,
+
+                // Integrator
+                Integrator.<SlidingWindow, TR, List<TR>>ofGreedy(SlidingWindow::integrate),
+
+                // Finisher
+                SlidingWindow::finish
+        );
+    }
+
+    /**
+     * Returns a Gatherer that performs an ordered, <i>reduction-like</i>,
+     * transformation for scenarios where no combiner-function can be
+     * implemented, or for reductions which are intrinsically
+     * order-dependent.
+     *
+     * @implSpec If no exceptions are thrown during processing, then this
+     * operation only ever produces a single element.
+     *
+     * <p>Example:
+     * {@snippet lang = java:
+     * // will contain: Optional["123456789"]
+     * Optional<String> numberString =
+     *     Stream.of(1,2,3,4,5,6,7,8,9)
+     *           .gather(
+     *               Gatherers.fold(() -> "", (string, number) -> string + number)
+     *            )
+     *           .findFirst();
+     * }
+     *
+     * @see java.util.stream.Stream#reduce(Object, BinaryOperator)
+     *
+     * @param initial the identity value for the fold operation
+     * @param folder the folding function
+     * @param <T> the type of elements the returned gatherer consumes
+     * @param <R> the type of elements the returned gatherer produces
+     * @return a new Gatherer
+     * @throws NullPointerException if any of the parameters are {@code null}
+     */
+    public static <T, R> Gatherer<T, ?, R> fold(
+            Supplier<R> initial,
+            BiFunction<? super R, ? super T, ? extends R> folder) {
+        Objects.requireNonNull(initial, "'initial' must not be null");
+        Objects.requireNonNull(folder, "'folder' must not be null");
+
+        class State {
+            R value = initial.get();
+            State() {}
+        }
+
+        return Gatherer.ofSequential(
+                State::new,
+                Integrator.ofGreedy((state, element, downstream) -> {
+                    state.value = folder.apply(state.value, element);
+                    return true;
+                }),
+                (state, downstream) -> downstream.push(state.value)
+        );
+    }
+
+    /**
+     * Returns a Gatherer that performs a Prefix Scan -- an incremental
+     * accumulation -- using the provided functions.  Starting with an
+     * initial value obtained from the {@code Supplier}, each subsequent
+     * value is obtained by applying the {@code BiFunction} to the current
+     * value and the next input element, after which the resulting value is
+     * produced downstream.
+     *
+     * <p>Example:
+     * {@snippet lang = java:
+     * // will contain: ["1", "12", "123", "1234", "12345", "123456", "1234567", "12345678", "123456789"]
+     * List<String> numberStrings =
+     *     Stream.of(1,2,3,4,5,6,7,8,9)
+     *           .gather(
+     *               Gatherers.scan(() -> "", (string, number) -> string + number)
+     *            )
+     *           .toList();
+     * }
+     *
+     * @param initial the supplier of the initial value for the scanner
+     * @param scanner the function to apply for each element
+     * @param <T> the type of element which this gatherer consumes
+     * @param <R> the type of element which this gatherer produces
+     * @return a new Gatherer which performs a prefix scan
+     * @throws NullPointerException if any of the parameters are {@code null}
+     */
+    public static <T, R> Gatherer<T, ?, R> scan(
+            Supplier<R> initial,
+            BiFunction<? super R, ? super T, ? extends R> scanner) {
+        Objects.requireNonNull(initial, "'initial' must not be null");
+        Objects.requireNonNull(scanner, "'scanner' must not be null");
+
+        class State {
+            R current = initial.get();
+            boolean integrate(T element, Downstream<? super R> downstream) {
+                return downstream.push(current = scanner.apply(current, element));
+            }
+        }
+
+        return Gatherer.ofSequential(State::new,
+                Integrator.<State,T, R>ofGreedy(State::integrate));
+    }
+
+    // Android-removed: TODO: Unhide this method when Virtual Thread is implemented.
+    /*
+    /**
+     * An operation which executes a function concurrently
+     * with a configured level of max concurrency, using
+     * <a href="{@docRoot}/java.base/java/lang/Thread.html#virtual-threads">virtual threads</a>.
+     * This operation preserves the ordering of the stream.
+     *
+     * @apiNote In progress tasks will be attempted to be cancelled,
+     * on a best-effort basis, in situations where the downstream no longer
+     * wants to receive any more elements.
+     *
+     * @implSpec If a result of the function is to be pushed downstream but
+     * instead the function completed exceptionally then the corresponding
+     * exception will instead be rethrown by this method as an instance of
+     * {@link RuntimeException}, after which any remaining tasks are canceled.
+     *
+     * @param maxConcurrency the maximum concurrency desired
+     * @param mapper a function to be executed concurrently
+     * @param <T> the type of input
+     * @param <R> the type of output
+     * @return a new Gatherer
+     * @throws IllegalArgumentException if {@code maxConcurrency} is less than 1
+     * @throws NullPointerException if {@code mapper} is {@code null}
+     * /
+    public static <T, R> Gatherer<T,?,R> mapConcurrent(
+            final int maxConcurrency,
+            final Function<? super T, ? extends R> mapper) {
+        if (maxConcurrency < 1)
+            throw new IllegalArgumentException("'maxConcurrency' must be greater than 0");
+
+        Objects.requireNonNull(mapper, "'mapper' must not be null");
+
+        final class MapConcurrentTask extends FutureTask<R> {
+            final Thread thread;
+            private MapConcurrentTask(Callable<R> callable) {
+                super(callable);
+                this.thread = Thread.ofVirtual().unstarted(this);
+            }
+        }
+
+        final class State {
+            private final ArrayDeque<MapConcurrentTask> wip =
+                new ArrayDeque<>(Math.min(maxConcurrency, 16));
+
+            boolean integrate(T element, Downstream<? super R> downstream) {
+                // Prepare the next task and add it to the work-in-progress
+                final var task = new MapConcurrentTask(() -> mapper.apply(element));
+                wip.addLast(task);
+
+                assert wip.peekLast() == task;
+                assert wip.size() <= maxConcurrency;
+
+                // Start the next task
+                task.thread.start();
+
+                // Flush at least 1 element if we're at capacity
+                return flush(wip.size() < maxConcurrency ? 0 : 1, downstream);
+            }
+
+            boolean flush(long atLeastN, Downstream<? super R> downstream) {
+                boolean success = false, interrupted = false;
+                try {
+                    boolean proceed = !downstream.isRejecting();
+                    MapConcurrentTask current;
+                    while (
+                        proceed
+                        && (current = wip.peekFirst()) != null
+                        && (current.isDone() || atLeastN > 0)
+                    ) {
+                        R result;
+
+                        // Ensure that the task is done before proceeding
+                        for (;;) {
+                            try {
+                                result = current.get();
+                                break;
+                            } catch (InterruptedException ie) {
+                                interrupted = true; // ignore for now, and restore later
+                            }
+                        }
+
+                        proceed &= downstream.push(result);
+                        atLeastN -= 1;
+
+                        final var correctRemoval = wip.pollFirst() == current;
+                        assert correctRemoval;
+                    }
+                    return (success = proceed); // Ensure that cleanup occurs if needed
+                } catch (ExecutionException e) {
+                    final var cause = e.getCause();
+                    throw (cause instanceof RuntimeException re)
+                              ? re
+                              : new RuntimeException(cause == null ? e : cause);
+                } finally {
+                    // Clean up work-in-progress
+                    if (!success && !wip.isEmpty()) {
+                        // First signal cancellation for all tasks in progress
+                        for (var task : wip)
+                            task.cancel(true);
+
+                        // Then wait for all in progress task Threads to exit
+                        MapConcurrentTask next;
+                        while ((next = wip.pollFirst()) != null) {
+                            while (next.thread.isAlive()) {
+                                try {
+                                    next.thread.join();
+                                } catch (InterruptedException ie) {
+                                    interrupted = true; // ignore, for now, and restore later
+                                }
+                            }
+                        }
+                    }
+
+                    // integrate(..) could be called from different threads each time
+                    // so we need to restore the interrupt on the calling thread
+                    if (interrupted)
+                        Thread.currentThread().interrupt();
+                }
+            }
+        }
+
+        return Gatherer.ofSequential(
+            State::new,
+            Integrator.<State, T, R>ofGreedy(State::integrate),
+            (state, downstream) -> state.flush(Long.MAX_VALUE, downstream)
+        );
+    }
+    */
+
+    // Implementation details
+
+    /*
+     * This enum is used to provide the default functions for the
+     * factory methods
+     * and for the default methods for when implementing the Gatherer interface.
+     *
+     * This serves the following purposes:
+     * 1. removes the need for using `null` for signalling absence of specified
+     *    value and thereby hiding user bugs
+     * 2. allows to check against these default values to avoid calling methods
+     *    needlessly
+     * 3. allows for more efficient composition and evaluation
+     */
+    @SuppressWarnings("rawtypes")
+    enum Value implements Supplier, BinaryOperator, BiConsumer {
+        DEFAULT;
+
+        final BinaryOperator<Void> statelessCombiner = new BinaryOperator<>() {
+            @Override public Void apply(Void left, Void right) { return null; }
+        };
+
+        // BiConsumer
+        @Override public void accept(Object state, Object downstream) {}
+
+        // BinaryOperator
+        @Override public Object apply(Object left, Object right) {
+            throw new UnsupportedOperationException("This combiner cannot be used!");
+        }
+
+        // Supplier
+        @Override public Object get() { return null; }
+
+        @ForceInline
+        @SuppressWarnings("unchecked")
+        <A> Supplier<A> initializer() { return (Supplier<A>)this; }
+
+        @ForceInline
+        @SuppressWarnings("unchecked")
+        <T> BinaryOperator<T> combiner() { return (BinaryOperator<T>) this; }
+
+        @ForceInline
+        @SuppressWarnings("unchecked")
+        <T, R> BiConsumer<T, Gatherer.Downstream<? super R>> finisher() {
+            return (BiConsumer<T, Downstream<? super R>>) this;
+        }
+    }
+
+    record GathererImpl<T, A, R>(
+            @Override Supplier<A> initializer,
+            @Override Integrator<A, T, R> integrator,
+            @Override BinaryOperator<A> combiner,
+            @Override BiConsumer<A, Downstream<? super R>> finisher) implements Gatherer<T, A, R> {
+
+        static <T, A, R> GathererImpl<T, A, R> of(
+                Supplier<A> initializer,
+                Integrator<A, T, R> integrator,
+                BinaryOperator<A> combiner,
+                BiConsumer<A, Downstream<? super R>> finisher) {
+            return new GathererImpl<>(
+                    Objects.requireNonNull(initializer,"initializer"),
+                    Objects.requireNonNull(integrator, "integrator"),
+                    Objects.requireNonNull(combiner, "combiner"),
+                    Objects.requireNonNull(finisher, "finisher")
+            );
+        }
+    }
+
+    static final class Composite<T, A, R, AA, RR> implements Gatherer<T, Object, RR> {
+        private final Gatherer<T, A, ? extends R> left;
+        private final Gatherer<? super R, AA, ? extends RR> right;
+        // FIXME change `impl` to a computed constant when available
+        private GathererImpl<T, Object, RR> impl;
+
+        static <T, A, R, AA, RR> Composite<T, A, R, AA, RR> of(
+                Gatherer<T, A, ? extends R> left,
+                Gatherer<? super R, AA, ? extends RR> right) {
+            return new Composite<>(left, right);
+        }
+
+        private Composite(Gatherer<T, A, ? extends R> left,
+                          Gatherer<? super R, AA, ? extends RR> right) {
+            this.left = left;
+            this.right = right;
+        }
+
+        @SuppressWarnings("unchecked")
+        private GathererImpl<T, Object, RR> impl() {
+            // ATTENTION: this method currently relies on a "benign" data-race
+            // as it should deterministically produce the same result even if
+            // initialized concurrently on different threads.
+            var i = impl;
+            return i != null
+                     ? i
+                     : (impl = (GathererImpl<T, Object, RR>)impl(left, right));
+        }
+
+        @Override public Supplier<Object> initializer() {
+            return impl().initializer();
+        }
+
+        @Override public Integrator<Object, T, RR> integrator() {
+            return impl().integrator();
+        }
+
+        @Override public BinaryOperator<Object> combiner() {
+            return impl().combiner();
+        }
+
+        @Override public BiConsumer<Object, Downstream<? super RR>> finisher() {
+            return impl().finisher();
+        }
+
+        @Override
+        public <RRR> Gatherer<T, ?, RRR> andThen(
+                Gatherer<? super RR, ?, ? extends RRR> that) {
+            if (that.getClass() == Composite.class) {
+                @SuppressWarnings("unchecked")
+                final var c =
+                    (Composite<? super RR, ?, Object, ?, ? extends RRR>) that;
+                return left.andThen(right.andThen(c.left).andThen(c.right));
+            } else {
+                return left.andThen(right.andThen(that));
+            }
+        }
+
+        static final <T, A, R, AA, RR> GathererImpl<T, ?, RR> impl(
+                Gatherer<T, A, R> left, Gatherer<? super R, AA, RR> right) {
+            final var leftInitializer = left.initializer();
+            final var leftIntegrator = left.integrator();
+            final var leftCombiner = left.combiner();
+            final var leftFinisher = left.finisher();
+
+            final var rightInitializer = right.initializer();
+            final var rightIntegrator = right.integrator();
+            final var rightCombiner = right.combiner();
+            final var rightFinisher = right.finisher();
+
+            final var leftStateless = leftInitializer == Gatherer.defaultInitializer();
+            final var rightStateless = rightInitializer == Gatherer.defaultInitializer();
+
+            final var leftGreedy = leftIntegrator instanceof Integrator.Greedy;
+            final var rightGreedy = rightIntegrator instanceof Integrator.Greedy;
+
+            /*
+             * For pairs of stateless and greedy Gatherers, we can optimize
+             * evaluation as we do not need to track any state nor any
+             * short-circuit signals. This can provide significant
+             * performance improvements.
+             */
+            if (leftStateless && rightStateless && leftGreedy && rightGreedy) {
+                return new GathererImpl<>(
+                    Gatherer.defaultInitializer(),
+                    Gatherer.Integrator.ofGreedy((unused, element, downstream) ->
+                        leftIntegrator.integrate(
+                                null,
+                                element,
+                                r -> rightIntegrator.integrate(null, r, downstream))
+                    ),
+                    (leftCombiner == Gatherer.defaultCombiner()
+                    || rightCombiner == Gatherer.defaultCombiner())
+                            ? Gatherer.defaultCombiner()
+                            : Value.DEFAULT.statelessCombiner
+                    ,
+                    (leftFinisher == Gatherer.<A,R>defaultFinisher()
+                    && rightFinisher == Gatherer.<AA,RR>defaultFinisher())
+                            ? Gatherer.defaultFinisher()
+                            : (unused, downstream) -> {
+                        if (leftFinisher != Gatherer.<A,R>defaultFinisher())
+                            leftFinisher.accept(
+                                    null,
+                                    r -> rightIntegrator.integrate(null, r, downstream));
+                        if (rightFinisher != Gatherer.<AA,RR>defaultFinisher())
+                            rightFinisher.accept(null, downstream);
+                    }
+                );
+            } else {
+                class State {
+                    final A leftState;
+                    final AA rightState;
+                    boolean leftProceed;
+                    boolean rightProceed;
+
+                    private State(A leftState, AA rightState,
+                                  boolean leftProceed, boolean rightProceed) {
+                        this.leftState = leftState;
+                        this.rightState = rightState;
+                        this.leftProceed = leftProceed;
+                        this.rightProceed = rightProceed;
+                    }
+
+                    State() {
+                        this(leftStateless ? null : leftInitializer.get(),
+                             rightStateless ? null : rightInitializer.get(),
+                            true, true);
+                    }
+
+                    State joinLeft(State right) {
+                        return new State(
+                                leftStateless ? null : leftCombiner.apply(this.leftState, right.leftState),
+                                rightStateless ? null : rightCombiner.apply(this.rightState, right.rightState),
+                                this.leftProceed && this.rightProceed,
+                                right.leftProceed && right.rightProceed);
+                    }
+
+                    boolean integrate(T t, Downstream<? super RR> c) {
+                        /*
+                         * rightProceed must be checked after integration of
+                         * left since that can cause right to short-circuit
+                         * We always want to conditionally write leftProceed
+                         * here, which means that we only do so if we are
+                         * known to be not-greedy.
+                         */
+                        return (leftIntegrator.integrate(leftState, t, r -> rightIntegrate(r, c))
+                                  || leftGreedy
+                                  || (leftProceed = false))
+                                && (rightGreedy || rightProceed);
+                    }
+
+                    void finish(Downstream<? super RR> c) {
+                        if (leftFinisher != Gatherer.<A, R>defaultFinisher())
+                            leftFinisher.accept(leftState, r -> rightIntegrate(r, c));
+                        if (rightFinisher != Gatherer.<AA, RR>defaultFinisher())
+                            rightFinisher.accept(rightState, c);
+                    }
+
+                    /*
+                     * Currently we use the following to ferry elements from
+                     * the left Gatherer to the right Gatherer, but we create
+                     * the Gatherer.Downstream as a lambda which means that
+                     * the default implementation of `isKnownDone()` is used.
+                     *
+                     * If it is determined that we want to be able to support
+                     * the full interface of Gatherer.Downstream then we have
+                     *  the following options:
+                     *    1. Have State implement Downstream<? super R>
+                     *       and store the passed in Downstream<? super RR>
+                     *       downstream as an instance field in integrate()
+                     *       and read it in push(R r).
+                     *    2. Allocate a new Gatherer.Downstream<? super R> for
+                     *       each invocation of integrate() which might prove
+                     *       costly.
+                     */
+                    public boolean rightIntegrate(R r, Downstream<? super RR> downstream) {
+                        // The following logic is highly performance sensitive
+                        return (rightGreedy || rightProceed)
+                                && (rightIntegrator.integrate(rightState, r, downstream)
+                                || rightGreedy
+                                || (rightProceed = false));
+                    }
+                }
+
+                return new GathererImpl<T, State, RR>(
+                        State::new,
+                        (leftGreedy && rightGreedy)
+                                ? Integrator.<State, T, RR>ofGreedy(State::integrate)
+                                : Integrator.<State, T, RR>of(State::integrate),
+                        (leftCombiner == Gatherer.defaultCombiner()
+                        || rightCombiner == Gatherer.defaultCombiner())
+                                ? Gatherer.defaultCombiner()
+                                : State::joinLeft,
+                        (leftFinisher == Gatherer.<A, R>defaultFinisher()
+                        && rightFinisher == Gatherer.<AA, RR>defaultFinisher())
+                                ? Gatherer.defaultFinisher()
+                                : State::finish
+                );
+            }
+        }
+    }
+}
diff --git a/ojluni/src/main/java/java/util/stream/IntPipeline.java b/ojluni/src/main/java/java/util/stream/IntPipeline.java
index 8189699ece7..fec87daa16b 100644
--- a/ojluni/src/main/java/java/util/stream/IntPipeline.java
+++ b/ojluni/src/main/java/java/util/stream/IntPipeline.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -179,11 +179,11 @@ public abstract class IntPipeline<E_IN>
     }
 
     private <U> Stream<U> mapToObj(IntFunction<? extends U> mapper, int opFlags) {
-        return new ReferencePipeline.StatelessOp<Integer, U>(this, StreamShape.INT_VALUE, opFlags) {
+        return new ReferencePipeline.StatelessOp<>(this, StreamShape.INT_VALUE, opFlags) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Integer> opWrapSink(int flags, Sink<U> sink) {
-                return new Sink.ChainedInt<U>(sink) {
+                return new Sink.ChainedInt<>(sink) {
                     @Override
                     public void accept(int t) {
                         downstream.accept(mapper.apply(t));
@@ -209,10 +209,11 @@ public abstract class IntPipeline<E_IN>
 
     @Override
     public final LongStream asLongStream() {
-        return new LongPipeline.StatelessOp<Integer>(this, StreamShape.INT_VALUE, 0) {
+        return new LongPipeline.StatelessOp<>(this, StreamShape.INT_VALUE, 0) {
             @Override
+            // Android-changed: Make public, to match the method it's overriding.
             public Sink<Integer> opWrapSink(int flags, Sink<Long> sink) {
-                return new Sink.ChainedInt<Long>(sink) {
+                return new Sink.ChainedInt<>(sink) {
                     @Override
                     public void accept(int t) {
                         downstream.accept((long) t);
@@ -224,11 +225,11 @@ public abstract class IntPipeline<E_IN>
 
     @Override
     public final DoubleStream asDoubleStream() {
-        return new DoublePipeline.StatelessOp<Integer>(this, StreamShape.INT_VALUE, 0) {
+        return new DoublePipeline.StatelessOp<>(this, StreamShape.INT_VALUE, 0) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Integer> opWrapSink(int flags, Sink<Double> sink) {
-                return new Sink.ChainedInt<Double>(sink) {
+                return new Sink.ChainedInt<>(sink) {
                     @Override
                     public void accept(int t) {
                         downstream.accept((double) t);
@@ -246,12 +247,12 @@ public abstract class IntPipeline<E_IN>
     @Override
     public final IntStream map(IntUnaryOperator mapper) {
         Objects.requireNonNull(mapper);
-        return new StatelessOp<Integer>(this, StreamShape.INT_VALUE,
-                                        StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+        return new StatelessOp<>(this, StreamShape.INT_VALUE,
+                StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Integer> opWrapSink(int flags, Sink<Integer> sink) {
-                return new Sink.ChainedInt<Integer>(sink) {
+                return new Sink.ChainedInt<>(sink) {
                     @Override
                     public void accept(int t) {
                         downstream.accept(mapper.applyAsInt(t));
@@ -270,12 +271,12 @@ public abstract class IntPipeline<E_IN>
     @Override
     public final LongStream mapToLong(IntToLongFunction mapper) {
         Objects.requireNonNull(mapper);
-        return new LongPipeline.StatelessOp<Integer>(this, StreamShape.INT_VALUE,
-                                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+        return new LongPipeline.StatelessOp<>(this, StreamShape.INT_VALUE,
+                StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Integer> opWrapSink(int flags, Sink<Long> sink) {
-                return new Sink.ChainedInt<Long>(sink) {
+                return new Sink.ChainedInt<>(sink) {
                     @Override
                     public void accept(int t) {
                         downstream.accept(mapper.applyAsLong(t));
@@ -288,12 +289,12 @@ public abstract class IntPipeline<E_IN>
     @Override
     public final DoubleStream mapToDouble(IntToDoubleFunction mapper) {
         Objects.requireNonNull(mapper);
-        return new DoublePipeline.StatelessOp<Integer>(this, StreamShape.INT_VALUE,
-                                                       StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+        return new DoublePipeline.StatelessOp<>(this, StreamShape.INT_VALUE,
+                StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Integer> opWrapSink(int flags, Sink<Double> sink) {
-                return new Sink.ChainedInt<Double>(sink) {
+                return new Sink.ChainedInt<>(sink) {
                     @Override
                     public void accept(int t) {
                         downstream.accept(mapper.applyAsDouble(t));
@@ -306,48 +307,51 @@ public abstract class IntPipeline<E_IN>
     @Override
     public final IntStream flatMap(IntFunction<? extends IntStream> mapper) {
         Objects.requireNonNull(mapper);
-        return new StatelessOp<Integer>(this, StreamShape.INT_VALUE,
-                                        StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
+        return new StatelessOp<>(this, StreamShape.INT_VALUE,
+                StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Integer> opWrapSink(int flags, Sink<Integer> sink) {
-                return new Sink.ChainedInt<Integer>(sink) {
-                    // true if cancellationRequested() has been called
-                    boolean cancellationRequestedCalled;
-
-                    // cache the consumer to avoid creation on every accepted element
-                    IntConsumer downstreamAsInt = downstream::accept;
-
-                    @Override
-                    public void begin(long size) {
-                        downstream.begin(-1);
-                    }
+                final IntConsumer fastPath =
+                        isShortCircuitingPipeline()
+                                ? null
+                                : (sink instanceof IntConsumer ic)
+                                ? ic
+                                : sink::accept;
+                final class FlatMap implements Sink.OfInt, IntPredicate {
+                    boolean cancel;
+
+                    @Override public void begin(long size) { sink.begin(-1); }
+                    @Override public void end() { sink.end(); }
 
                     @Override
-                    public void accept(int t) {
-                        try (IntStream result = mapper.apply(t)) {
+                    public void accept(int e) {
+                        try (IntStream result = mapper.apply(e)) {
                             if (result != null) {
-                                if (!cancellationRequestedCalled) {
-                                    result.sequential().forEach(downstreamAsInt);
-                                }
-                                else {
-                                    var s = result.sequential().spliterator();
-                                    do { } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsInt));
-                                }
+                                if (fastPath == null)
+                                    result.sequential().allMatch(this);
+                                else
+                                    result.sequential().forEach(fastPath);
                             }
                         }
                     }
 
                     @Override
                     public boolean cancellationRequested() {
-                        // If this method is called then an operation within the stream
-                        // pipeline is short-circuiting (see AbstractPipeline.copyInto).
-                        // Note that we cannot differentiate between an upstream or
-                        // downstream operation
-                        cancellationRequestedCalled = true;
-                        return downstream.cancellationRequested();
+                        return cancel || (cancel |= sink.cancellationRequested());
                     }
-                };
+
+                    @Override
+                    public boolean test(int output) {
+                        if (!cancel) {
+                            sink.accept(output);
+                            return !(cancel |= sink.cancellationRequested());
+                        } else {
+                            return false;
+                        }
+                    }
+                }
+                return new FlatMap();
             }
         };
     }
@@ -368,7 +372,6 @@ public abstract class IntPipeline<E_IN>
                     }
 
                     @Override
-                    @SuppressWarnings("unchecked")
                     public void accept(int t) {
                         mapper.accept(t, (IntConsumer) downstream);
                     }
@@ -381,7 +384,7 @@ public abstract class IntPipeline<E_IN>
     public IntStream unordered() {
         if (!isOrdered())
             return this;
-        return new StatelessOp<Integer>(this, StreamShape.INT_VALUE, StreamOpFlag.NOT_ORDERED) {
+        return new StatelessOp<>(this, StreamShape.INT_VALUE, StreamOpFlag.NOT_ORDERED) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Integer> opWrapSink(int flags, Sink<Integer> sink) {
@@ -393,12 +396,12 @@ public abstract class IntPipeline<E_IN>
     @Override
     public final IntStream filter(IntPredicate predicate) {
         Objects.requireNonNull(predicate);
-        return new StatelessOp<Integer>(this, StreamShape.INT_VALUE,
-                                        StreamOpFlag.NOT_SIZED) {
+        return new StatelessOp<>(this, StreamShape.INT_VALUE,
+                StreamOpFlag.NOT_SIZED) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Integer> opWrapSink(int flags, Sink<Integer> sink) {
-                return new Sink.ChainedInt<Integer>(sink) {
+                return new Sink.ChainedInt<>(sink) {
                     @Override
                     public void begin(long size) {
                         downstream.begin(-1);
@@ -417,12 +420,12 @@ public abstract class IntPipeline<E_IN>
     @Override
     public final IntStream peek(IntConsumer action) {
         Objects.requireNonNull(action);
-        return new StatelessOp<Integer>(this, StreamShape.INT_VALUE,
-                                        0) {
+        return new StatelessOp<>(this, StreamShape.INT_VALUE,
+                0) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Integer> opWrapSink(int flags, Sink<Integer> sink) {
-                return new Sink.ChainedInt<Integer>(sink) {
+                return new Sink.ChainedInt<>(sink) {
                     @Override
                     public void accept(int t) {
                         action.accept(t);
diff --git a/ojluni/src/main/java/java/util/stream/LongPipeline.java b/ojluni/src/main/java/java/util/stream/LongPipeline.java
index abe2b67cddd..5b473d4950e 100644
--- a/ojluni/src/main/java/java/util/stream/LongPipeline.java
+++ b/ojluni/src/main/java/java/util/stream/LongPipeline.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,6 +33,7 @@ import java.util.Spliterator;
 import java.util.Spliterators;
 import java.util.function.BiConsumer;
 import java.util.function.BinaryOperator;
+import java.util.function.IntConsumer;
 import java.util.function.IntFunction;
 import java.util.function.LongBinaryOperator;
 import java.util.function.LongConsumer;
@@ -176,11 +177,11 @@ public abstract class LongPipeline<E_IN>
     }
 
     private <U> Stream<U> mapToObj(LongFunction<? extends U> mapper, int opFlags) {
-        return new ReferencePipeline.StatelessOp<Long, U>(this, StreamShape.LONG_VALUE, opFlags) {
+        return new ReferencePipeline.StatelessOp<>(this, StreamShape.LONG_VALUE, opFlags) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Long> opWrapSink(int flags, Sink<U> sink) {
-                return new Sink.ChainedLong<U>(sink) {
+                return new Sink.ChainedLong<>(sink) {
                     @Override
                     public void accept(long t) {
                         downstream.accept(mapper.apply(t));
@@ -206,11 +207,11 @@ public abstract class LongPipeline<E_IN>
 
     @Override
     public final DoubleStream asDoubleStream() {
-        return new DoublePipeline.StatelessOp<Long>(this, StreamShape.LONG_VALUE, StreamOpFlag.NOT_DISTINCT) {
+        return new DoublePipeline.StatelessOp<>(this, StreamShape.LONG_VALUE, StreamOpFlag.NOT_DISTINCT) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Long> opWrapSink(int flags, Sink<Double> sink) {
-                return new Sink.ChainedLong<Double>(sink) {
+                return new Sink.ChainedLong<>(sink) {
                     @Override
                     public void accept(long t) {
                         downstream.accept((double) t);
@@ -228,12 +229,12 @@ public abstract class LongPipeline<E_IN>
     @Override
     public final LongStream map(LongUnaryOperator mapper) {
         Objects.requireNonNull(mapper);
-        return new StatelessOp<Long>(this, StreamShape.LONG_VALUE,
-                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+        return new StatelessOp<>(this, StreamShape.LONG_VALUE,
+                StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Long> opWrapSink(int flags, Sink<Long> sink) {
-                return new Sink.ChainedLong<Long>(sink) {
+                return new Sink.ChainedLong<>(sink) {
                     @Override
                     public void accept(long t) {
                         downstream.accept(mapper.applyAsLong(t));
@@ -252,12 +253,12 @@ public abstract class LongPipeline<E_IN>
     @Override
     public final IntStream mapToInt(LongToIntFunction mapper) {
         Objects.requireNonNull(mapper);
-        return new IntPipeline.StatelessOp<Long>(this, StreamShape.LONG_VALUE,
-                                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+        return new IntPipeline.StatelessOp<>(this, StreamShape.LONG_VALUE,
+                StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Long> opWrapSink(int flags, Sink<Integer> sink) {
-                return new Sink.ChainedLong<Integer>(sink) {
+                return new Sink.ChainedLong<>(sink) {
                     @Override
                     public void accept(long t) {
                         downstream.accept(mapper.applyAsInt(t));
@@ -270,12 +271,12 @@ public abstract class LongPipeline<E_IN>
     @Override
     public final DoubleStream mapToDouble(LongToDoubleFunction mapper) {
         Objects.requireNonNull(mapper);
-        return new DoublePipeline.StatelessOp<Long>(this, StreamShape.LONG_VALUE,
-                                                    StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+        return new DoublePipeline.StatelessOp<>(this, StreamShape.LONG_VALUE,
+                StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Long> opWrapSink(int flags, Sink<Double> sink) {
-                return new Sink.ChainedLong<Double>(sink) {
+                return new Sink.ChainedLong<>(sink) {
                     @Override
                     public void accept(long t) {
                         downstream.accept(mapper.applyAsDouble(t));
@@ -288,48 +289,51 @@ public abstract class LongPipeline<E_IN>
     @Override
     public final LongStream flatMap(LongFunction<? extends LongStream> mapper) {
         Objects.requireNonNull(mapper);
-        return new StatelessOp<Long>(this, StreamShape.LONG_VALUE,
-                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
+        return new StatelessOp<>(this, StreamShape.LONG_VALUE,
+                StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Long> opWrapSink(int flags, Sink<Long> sink) {
-                return new Sink.ChainedLong<Long>(sink) {
-                    // true if cancellationRequested() has been called
-                    boolean cancellationRequestedCalled;
-
-                    // cache the consumer to avoid creation on every accepted element
-                    LongConsumer downstreamAsLong = downstream::accept;
-
-                    @Override
-                    public void begin(long size) {
-                        downstream.begin(-1);
-                    }
+                final LongConsumer fastPath =
+                        isShortCircuitingPipeline()
+                                ? null
+                                : (sink instanceof LongConsumer lc)
+                                ? lc
+                                : sink::accept;
+                final class FlatMap implements Sink.OfLong, LongPredicate {
+                    boolean cancel;
+
+                    @Override public void begin(long size) { sink.begin(-1); }
+                    @Override public void end() { sink.end(); }
 
                     @Override
-                    public void accept(long t) {
-                        try (LongStream result = mapper.apply(t)) {
+                    public void accept(long e) {
+                        try (LongStream result = mapper.apply(e)) {
                             if (result != null) {
-                                if (!cancellationRequestedCalled) {
-                                    result.sequential().forEach(downstreamAsLong);
-                                }
-                                else {
-                                    var s = result.sequential().spliterator();
-                                    do { } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsLong));
-                                }
+                                if (fastPath == null)
+                                    result.sequential().allMatch(this);
+                                else
+                                    result.sequential().forEach(fastPath);
                             }
                         }
                     }
 
                     @Override
                     public boolean cancellationRequested() {
-                        // If this method is called then an operation within the stream
-                        // pipeline is short-circuiting (see AbstractPipeline.copyInto).
-                        // Note that we cannot differentiate between an upstream or
-                        // downstream operation
-                        cancellationRequestedCalled = true;
-                        return downstream.cancellationRequested();
+                        return cancel || (cancel |= sink.cancellationRequested());
                     }
-                };
+
+                    @Override
+                    public boolean test(long output) {
+                        if (!cancel) {
+                            sink.accept(output);
+                            return !(cancel |= sink.cancellationRequested());
+                        } else {
+                            return false;
+                        }
+                    }
+                }
+                return new FlatMap();
             }
         };
     }
@@ -350,7 +354,6 @@ public abstract class LongPipeline<E_IN>
                     }
 
                     @Override
-                    @SuppressWarnings("unchecked")
                     public void accept(long t) {
                         mapper.accept(t, (LongConsumer) downstream);
                     }
@@ -363,7 +366,7 @@ public abstract class LongPipeline<E_IN>
     public LongStream unordered() {
         if (!isOrdered())
             return this;
-        return new StatelessOp<Long>(this, StreamShape.LONG_VALUE, StreamOpFlag.NOT_ORDERED) {
+        return new StatelessOp<>(this, StreamShape.LONG_VALUE, StreamOpFlag.NOT_ORDERED) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Long> opWrapSink(int flags, Sink<Long> sink) {
@@ -375,12 +378,12 @@ public abstract class LongPipeline<E_IN>
     @Override
     public final LongStream filter(LongPredicate predicate) {
         Objects.requireNonNull(predicate);
-        return new StatelessOp<Long>(this, StreamShape.LONG_VALUE,
-                                     StreamOpFlag.NOT_SIZED) {
+        return new StatelessOp<>(this, StreamShape.LONG_VALUE,
+                StreamOpFlag.NOT_SIZED) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Long> opWrapSink(int flags, Sink<Long> sink) {
-                return new Sink.ChainedLong<Long>(sink) {
+                return new Sink.ChainedLong<>(sink) {
                     @Override
                     public void begin(long size) {
                         downstream.begin(-1);
@@ -399,12 +402,12 @@ public abstract class LongPipeline<E_IN>
     @Override
     public final LongStream peek(LongConsumer action) {
         Objects.requireNonNull(action);
-        return new StatelessOp<Long>(this, StreamShape.LONG_VALUE,
-                                     0) {
+        return new StatelessOp<>(this, StreamShape.LONG_VALUE,
+                0) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Long> opWrapSink(int flags, Sink<Long> sink) {
-                return new Sink.ChainedLong<Long>(sink) {
+                return new Sink.ChainedLong<>(sink) {
                     @Override
                     public void accept(long t) {
                         action.accept(t);
@@ -453,7 +456,7 @@ public abstract class LongPipeline<E_IN>
     public final LongStream distinct() {
         // While functional and quick to implement, this approach is not very efficient.
         // An efficient version requires a long-specific map/set implementation.
-        return boxed().distinct().mapToLong(i -> (long) i);
+        return boxed().distinct().mapToLong(i -> i);
     }
 
     // Terminal ops from LongStream
diff --git a/ojluni/src/main/java/java/util/stream/Node.java b/ojluni/src/main/java/java/util/stream/Node.java
index 006cf36aca7..97daafcdf7a 100644
--- a/ojluni/src/main/java/java/util/stream/Node.java
+++ b/ojluni/src/main/java/java/util/stream/Node.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -247,7 +247,6 @@ public interface Node<T> {
          * @param action a consumer that is to be invoked with each
          *        element in this {@code Node.OfPrimitive}
          */
-        @SuppressWarnings("overloads")
         void forEach(T_CONS action);
 
         @Override
diff --git a/ojluni/src/main/java/java/util/stream/Nodes.java b/ojluni/src/main/java/java/util/stream/Nodes.java
index ed8e9e7775f..258a16b505b 100644
--- a/ojluni/src/main/java/java/util/stream/Nodes.java
+++ b/ojluni/src/main/java/java/util/stream/Nodes.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2022, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,11 +24,12 @@
  */
 package java.util.stream;
 
+import jdk.internal.util.ArraysSupport;
+
 import java.util.ArrayDeque;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Deque;
-import java.util.List;
 import java.util.Objects;
 import java.util.Spliterator;
 import java.util.Spliterators;
@@ -58,7 +59,7 @@ final class Nodes {
     /**
      * The maximum size of an array that can be allocated.
      */
-    static final long MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
+    static final long MAX_ARRAY_SIZE = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;
 
     // IllegalArgumentException messages
     static final String BAD_SIZE = "Stream size exceeds max array size";
@@ -650,7 +651,6 @@ final class Nodes {
         final T[] array;
         int curSize;
 
-        @SuppressWarnings("unchecked")
         ArrayNode(long size, IntFunction<T[]> generator) {
             if (size >= MAX_ARRAY_SIZE)
                 throw new IllegalArgumentException(BAD_SIZE);
@@ -727,7 +727,6 @@ final class Nodes {
         }
 
         @Override
-        @SuppressWarnings("unchecked")
         public T[] asArray(IntFunction<T[]> generator) {
             return c.toArray(generator.apply(c.size()));
         }
diff --git a/ojluni/src/main/java/java/util/stream/ReferencePipeline.java b/ojluni/src/main/java/java/util/stream/ReferencePipeline.java
index 20449433be3..e31920836da 100644
--- a/ojluni/src/main/java/java/util/stream/ReferencePipeline.java
+++ b/ojluni/src/main/java/java/util/stream/ReferencePipeline.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -38,10 +38,13 @@ import java.util.function.BiFunction;
 import java.util.function.BinaryOperator;
 import java.util.function.Consumer;
 import java.util.function.DoubleConsumer;
+import java.util.function.DoublePredicate;
 import java.util.function.Function;
 import java.util.function.IntConsumer;
 import java.util.function.IntFunction;
+import java.util.function.IntPredicate;
 import java.util.function.LongConsumer;
+import java.util.function.LongPredicate;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 import java.util.function.ToDoubleFunction;
@@ -94,12 +97,27 @@ public abstract class ReferencePipeline<P_IN, P_OUT>
      * Constructor for appending an intermediate operation onto an existing
      * pipeline.
      *
-     * @param upstream the upstream element source.
+     * @param upstream the upstream element source
+     * @param opFlags The operation flags for this operation, described in
+     *        {@link StreamOpFlag}
      */
     ReferencePipeline(AbstractPipeline<?, P_IN, ?> upstream, int opFlags) {
         super(upstream, opFlags);
     }
 
+     /**
+      * Constructor for appending an intermediate operation onto an existing
+      * pipeline.
+      *
+      * @param upupstream the upstream of the upstream element source
+      * @param upstream the upstream element source
+      * @param opFlags The operation flags for this operation, described in
+      *        {@link StreamOpFlag}
+      */
+     protected ReferencePipeline(AbstractPipeline<?, P_IN, ?> upupstream, AbstractPipeline<?, P_IN, ?> upstream, int opFlags) {
+         super(upupstream, upstream, opFlags);
+     }
+
     // Shape-specific methods
 
     @Override
@@ -162,7 +180,7 @@ public abstract class ReferencePipeline<P_IN, P_OUT>
     public Stream<P_OUT> unordered() {
         if (!isOrdered())
             return this;
-        return new StatelessOp<P_OUT, P_OUT>(this, StreamShape.REFERENCE, StreamOpFlag.NOT_ORDERED) {
+        return new StatelessOp<>(this, StreamShape.REFERENCE, StreamOpFlag.NOT_ORDERED) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<P_OUT> opWrapSink(int flags, Sink<P_OUT> sink) {
@@ -174,12 +192,12 @@ public abstract class ReferencePipeline<P_IN, P_OUT>
     @Override
     public final Stream<P_OUT> filter(Predicate<? super P_OUT> predicate) {
         Objects.requireNonNull(predicate);
-        return new StatelessOp<P_OUT, P_OUT>(this, StreamShape.REFERENCE,
-                                     StreamOpFlag.NOT_SIZED) {
+        return new StatelessOp<>(this, StreamShape.REFERENCE,
+                StreamOpFlag.NOT_SIZED) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<P_OUT> opWrapSink(int flags, Sink<P_OUT> sink) {
-                return new Sink.ChainedReference<P_OUT, P_OUT>(sink) {
+                return new Sink.ChainedReference<>(sink) {
                     @Override
                     public void begin(long size) {
                         downstream.begin(-1);
@@ -196,14 +214,14 @@ public abstract class ReferencePipeline<P_IN, P_OUT>
     }
 
     @Override
-    @SuppressWarnings("unchecked")
     public final <R> Stream<R> map(Function<? super P_OUT, ? extends R> mapper) {
         Objects.requireNonNull(mapper);
-        return new StatelessOp<P_OUT, R>(this, StreamShape.REFERENCE,
-                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+        return new StatelessOp<>(this, StreamShape.REFERENCE,
+                StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
             @Override
+            // Android-changed: Make public, to match the method it's overriding.
             public Sink<P_OUT> opWrapSink(int flags, Sink<R> sink) {
-                return new Sink.ChainedReference<P_OUT, R>(sink) {
+                return new Sink.ChainedReference<>(sink) {
                     @Override
                     public void accept(P_OUT u) {
                         downstream.accept(mapper.apply(u));
@@ -216,12 +234,12 @@ public abstract class ReferencePipeline<P_IN, P_OUT>
     @Override
     public final IntStream mapToInt(ToIntFunction<? super P_OUT> mapper) {
         Objects.requireNonNull(mapper);
-        return new IntPipeline.StatelessOp<P_OUT>(this, StreamShape.REFERENCE,
-                                              StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+        return new IntPipeline.StatelessOp<>(this, StreamShape.REFERENCE,
+                StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<P_OUT> opWrapSink(int flags, Sink<Integer> sink) {
-                return new Sink.ChainedReference<P_OUT, Integer>(sink) {
+                return new Sink.ChainedReference<>(sink) {
                     @Override
                     public void accept(P_OUT u) {
                         downstream.accept(mapper.applyAsInt(u));
@@ -234,12 +252,12 @@ public abstract class ReferencePipeline<P_IN, P_OUT>
     @Override
     public final LongStream mapToLong(ToLongFunction<? super P_OUT> mapper) {
         Objects.requireNonNull(mapper);
-        return new LongPipeline.StatelessOp<P_OUT>(this, StreamShape.REFERENCE,
-                                      StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+        return new LongPipeline.StatelessOp<>(this, StreamShape.REFERENCE,
+                StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<P_OUT> opWrapSink(int flags, Sink<Long> sink) {
-                return new Sink.ChainedReference<P_OUT, Long>(sink) {
+                return new Sink.ChainedReference<>(sink) {
                     @Override
                     public void accept(P_OUT u) {
                         downstream.accept(mapper.applyAsLong(u));
@@ -252,12 +270,12 @@ public abstract class ReferencePipeline<P_IN, P_OUT>
     @Override
     public final DoubleStream mapToDouble(ToDoubleFunction<? super P_OUT> mapper) {
         Objects.requireNonNull(mapper);
-        return new DoublePipeline.StatelessOp<P_OUT>(this, StreamShape.REFERENCE,
-                                        StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+        return new DoublePipeline.StatelessOp<>(this, StreamShape.REFERENCE,
+                StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<P_OUT> opWrapSink(int flags, Sink<Double> sink) {
-                return new Sink.ChainedReference<P_OUT, Double>(sink) {
+                return new Sink.ChainedReference<>(sink) {
                     @Override
                     public void accept(P_OUT u) {
                         downstream.accept(mapper.applyAsDouble(u));
@@ -270,44 +288,46 @@ public abstract class ReferencePipeline<P_IN, P_OUT>
     @Override
     public final <R> Stream<R> flatMap(Function<? super P_OUT, ? extends Stream<? extends R>> mapper) {
         Objects.requireNonNull(mapper);
-        return new StatelessOp<P_OUT, R>(this, StreamShape.REFERENCE,
-                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
+        return new StatelessOp<>(this, StreamShape.REFERENCE,
+                StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
             @Override
+            // Android-changed: Make public, to match the method it's overriding.
             public Sink<P_OUT> opWrapSink(int flags, Sink<R> sink) {
-                return new Sink.ChainedReference<>(sink) {
-                    // true if cancellationRequested() has been called
-                    boolean cancellationRequestedCalled;
+                boolean shorts = isShortCircuitingPipeline();
+                final class FlatMap implements Sink<P_OUT>, Predicate<R> {
+                    boolean cancel;
 
-                    @Override
-                    public void begin(long size) {
-                        downstream.begin(-1);
-                    }
+                    @Override public void begin(long size) { sink.begin(-1); }
+                    @Override public void end() { sink.end(); }
 
                     @Override
-                    public void accept(P_OUT u) {
-                        try (Stream<? extends R> result = mapper.apply(u)) {
+                    public void accept(P_OUT e) {
+                        try (Stream<? extends R> result = mapper.apply(e)) {
                             if (result != null) {
-                                if (!cancellationRequestedCalled) {
-                                    result.sequential().forEach(downstream);
-                                }
-                                else {
-                                    var s = result.sequential().spliterator();
-                                    do { } while (!downstream.cancellationRequested() && s.tryAdvance(downstream));
-                                }
+                                if (shorts)
+                                    result.sequential().allMatch(this);
+                                else
+                                    result.sequential().forEach(sink);
                             }
                         }
                     }
 
                     @Override
                     public boolean cancellationRequested() {
-                        // If this method is called then an operation within the stream
-                        // pipeline is short-circuiting (see AbstractPipeline.copyInto).
-                        // Note that we cannot differentiate between an upstream or
-                        // downstream operation
-                        cancellationRequestedCalled = true;
-                        return downstream.cancellationRequested();
+                        return cancel || (cancel |= sink.cancellationRequested());
                     }
-                };
+
+                    @Override
+                    public boolean test(R output) {
+                        if (!cancel) {
+                            sink.accept(output);
+                            return !(cancel |= sink.cancellationRequested());
+                        } else {
+                            return false;
+                        }
+                    }
+                }
+                return new FlatMap();
             }
         };
     }
@@ -315,44 +335,51 @@ public abstract class ReferencePipeline<P_IN, P_OUT>
     @Override
     public final IntStream flatMapToInt(Function<? super P_OUT, ? extends IntStream> mapper) {
         Objects.requireNonNull(mapper);
-        return new IntPipeline.StatelessOp<P_OUT>(this, StreamShape.REFERENCE,
-                                              StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
+        return new IntPipeline.StatelessOp<>(this, StreamShape.REFERENCE,
+                StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<P_OUT> opWrapSink(int flags, Sink<Integer> sink) {
-                return new Sink.ChainedReference<P_OUT, Integer>(sink) {
-                    // true if cancellationRequested() has been called
-                    boolean cancellationRequestedCalled;
-
-                    // cache the consumer to avoid creation on every accepted element
-                    IntConsumer downstreamAsInt = downstream::accept;
+                IntConsumer fastPath =
+                    isShortCircuitingPipeline()
+                        ? null
+                        : (sink instanceof IntConsumer ic)
+                            ? ic
+                            : sink::accept;
+                final class FlatMap implements Sink<P_OUT>, IntPredicate {
+                    boolean cancel;
+
+                    @Override public void begin(long size) { sink.begin(-1); }
+                    @Override public void end() { sink.end(); }
 
                     @Override
-                    public void begin(long size) {
-                        downstream.begin(-1);
-                    }
-
-                    @Override
-                    public void accept(P_OUT u) {
-                        try (IntStream result = mapper.apply(u)) {
+                    public void accept(P_OUT e) {
+                        try (IntStream result = mapper.apply(e)) {
                             if (result != null) {
-                                if (!cancellationRequestedCalled) {
-                                    result.sequential().forEach(downstreamAsInt);
-                                }
-                                else {
-                                    var s = result.sequential().spliterator();
-                                    do { } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsInt));
-                                }
+                                if (fastPath == null)
+                                    result.sequential().allMatch(this);
+                                else
+                                    result.sequential().forEach(fastPath);
                             }
                         }
                     }
 
                     @Override
                     public boolean cancellationRequested() {
-                        cancellationRequestedCalled = true;
-                        return downstream.cancellationRequested();
+                        return cancel || (cancel |= sink.cancellationRequested());
                     }
-                };
+
+                    @Override
+                    public boolean test(int output) {
+                        if (!cancel) {
+                            sink.accept(output);
+                            return !(cancel |= sink.cancellationRequested());
+                        } else {
+                            return false;
+                        }
+                    }
+                }
+                return new FlatMap();
             }
         };
     }
@@ -360,44 +387,51 @@ public abstract class ReferencePipeline<P_IN, P_OUT>
     @Override
     public final DoubleStream flatMapToDouble(Function<? super P_OUT, ? extends DoubleStream> mapper) {
         Objects.requireNonNull(mapper);
-        return new DoublePipeline.StatelessOp<P_OUT>(this, StreamShape.REFERENCE,
-                                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
+        return new DoublePipeline.StatelessOp<>(this, StreamShape.REFERENCE,
+                StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<P_OUT> opWrapSink(int flags, Sink<Double> sink) {
-                return new Sink.ChainedReference<P_OUT, Double>(sink) {
-                    // true if cancellationRequested() has been called
-                    boolean cancellationRequestedCalled;
-
-                    // cache the consumer to avoid creation on every accepted element
-                    DoubleConsumer downstreamAsDouble = downstream::accept;
-
-                    @Override
-                    public void begin(long size) {
-                        downstream.begin(-1);
-                    }
+                DoubleConsumer fastPath =
+                    isShortCircuitingPipeline()
+                        ? null
+                        : (sink instanceof DoubleConsumer dc)
+                            ? dc
+                            : sink::accept;
+                final class FlatMap implements Sink<P_OUT>, DoublePredicate {
+                    boolean cancel;
+
+                    @Override public void begin(long size) { sink.begin(-1); }
+                    @Override public void end() { sink.end(); }
 
                     @Override
-                    public void accept(P_OUT u) {
-                        try (DoubleStream result = mapper.apply(u)) {
+                    public void accept(P_OUT e) {
+                        try (DoubleStream result = mapper.apply(e)) {
                             if (result != null) {
-                                if (!cancellationRequestedCalled) {
-                                    result.sequential().forEach(downstreamAsDouble);
-                                }
-                                else {
-                                    var s = result.sequential().spliterator();
-                                    do { } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsDouble));
-                                }
+                                if (fastPath == null)
+                                    result.sequential().allMatch(this);
+                                else
+                                    result.sequential().forEach(fastPath);
                             }
                         }
                     }
 
                     @Override
                     public boolean cancellationRequested() {
-                        cancellationRequestedCalled = true;
-                        return downstream.cancellationRequested();
+                        return cancel || (cancel |= sink.cancellationRequested());
                     }
-                };
+
+                    @Override
+                    public boolean test(double output) {
+                        if (!cancel) {
+                            sink.accept(output);
+                            return !(cancel |= sink.cancellationRequested());
+                        } else {
+                            return false;
+                        }
+                    }
+                }
+                return new FlatMap();
             }
         };
     }
@@ -406,44 +440,51 @@ public abstract class ReferencePipeline<P_IN, P_OUT>
     public final LongStream flatMapToLong(Function<? super P_OUT, ? extends LongStream> mapper) {
         Objects.requireNonNull(mapper);
         // We can do better than this, by polling cancellationRequested when stream is infinite
-        return new LongPipeline.StatelessOp<P_OUT>(this, StreamShape.REFERENCE,
-                                                   StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
+        return new LongPipeline.StatelessOp<>(this, StreamShape.REFERENCE,
+                StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<P_OUT> opWrapSink(int flags, Sink<Long> sink) {
-                return new Sink.ChainedReference<P_OUT, Long>(sink) {
-                    // true if cancellationRequested() has been called
-                    boolean cancellationRequestedCalled;
-
-                    // cache the consumer to avoid creation on every accepted element
-                    LongConsumer downstreamAsLong = downstream::accept;
+                LongConsumer fastPath =
+                    isShortCircuitingPipeline()
+                        ? null
+                        : (sink instanceof LongConsumer lc)
+                            ? lc
+                            : sink::accept;
+                final class FlatMap implements Sink<P_OUT>, LongPredicate {
+                    boolean cancel;
+
+                    @Override public void begin(long size) { sink.begin(-1); }
+                    @Override public void end() { sink.end(); }
 
                     @Override
-                    public void begin(long size) {
-                        downstream.begin(-1);
-                    }
-
-                    @Override
-                    public void accept(P_OUT u) {
-                        try (LongStream result = mapper.apply(u)) {
+                    public void accept(P_OUT e) {
+                        try (LongStream result = mapper.apply(e)) {
                             if (result != null) {
-                                if (!cancellationRequestedCalled) {
-                                    result.sequential().forEach(downstreamAsLong);
-                                }
-                                else {
-                                    var s = result.sequential().spliterator();
-                                    do { } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsLong));
-                                }
+                                if (fastPath == null)
+                                    result.sequential().allMatch(this);
+                                else
+                                    result.sequential().forEach(fastPath);
                             }
                         }
                     }
 
                     @Override
                     public boolean cancellationRequested() {
-                        cancellationRequestedCalled = true;
-                        return downstream.cancellationRequested();
+                        return cancel || (cancel |= sink.cancellationRequested());
                     }
-                };
+
+                    @Override
+                    public boolean test(long output) {
+                        if (!cancel) {
+                            sink.accept(output);
+                            return !(cancel |= sink.cancellationRequested());
+                        } else {
+                            return false;
+                        }
+                    }
+                }
+                return new FlatMap();
             }
         };
     }
@@ -489,7 +530,6 @@ public abstract class ReferencePipeline<P_IN, P_OUT>
                     }
 
                     @Override
-                    @SuppressWarnings("unchecked")
                     public void accept(P_OUT u) {
                         mapper.accept(u, (IntConsumer)downstream);
                     }
@@ -514,7 +554,6 @@ public abstract class ReferencePipeline<P_IN, P_OUT>
                     }
 
                     @Override
-                    @SuppressWarnings("unchecked")
                     public void accept(P_OUT u) {
                         mapper.accept(u, (LongConsumer) downstream);
                     }
@@ -540,7 +579,6 @@ public abstract class ReferencePipeline<P_IN, P_OUT>
                     }
 
                     @Override
-                    @SuppressWarnings("unchecked")
                     public void accept(P_OUT u) {
                         mapper.accept(u, (DoubleConsumer) downstream);
                     }
@@ -552,12 +590,12 @@ public abstract class ReferencePipeline<P_IN, P_OUT>
     @Override
     public final Stream<P_OUT> peek(Consumer<? super P_OUT> action) {
         Objects.requireNonNull(action);
-        return new StatelessOp<P_OUT, P_OUT>(this, StreamShape.REFERENCE,
-                                     0) {
+        return new StatelessOp<>(this, StreamShape.REFERENCE,
+                0) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<P_OUT> opWrapSink(int flags, Sink<P_OUT> sink) {
-                return new Sink.ChainedReference<P_OUT, P_OUT>(sink) {
+                return new Sink.ChainedReference<>(sink) {
                     @Override
                     public void accept(P_OUT u) {
                         action.accept(u);
@@ -690,9 +728,14 @@ public abstract class ReferencePipeline<P_IN, P_OUT>
         return evaluate(ReduceOps.makeRef(identity, accumulator, combiner));
     }
 
+    @Override
+    public final <R> Stream<R> gather(Gatherer<? super P_OUT, ?, R> gatherer) {
+        return GathererOp.of(this, gatherer);
+    }
+
     @Override
     @SuppressWarnings("unchecked")
-    public final <R, A> R collect(Collector<? super P_OUT, A, R> collector) {
+    public <R, A> R collect(Collector<? super P_OUT, A, R> collector) {
         A container;
         if (isParallel()
                 && (collector.characteristics().contains(Collector.Characteristics.CONCURRENT))
@@ -710,7 +753,7 @@ public abstract class ReferencePipeline<P_IN, P_OUT>
     }
 
     @Override
-    public final <R> R collect(Supplier<R> supplier,
+    public <R> R collect(Supplier<R> supplier,
                                BiConsumer<R, ? super P_OUT> accumulator,
                                BiConsumer<R, R> combiner) {
         return evaluate(ReduceOps.makeRef(supplier, accumulator, combiner));
diff --git a/ojluni/src/main/java/java/util/stream/SpinedBuffer.java b/ojluni/src/main/java/java/util/stream/SpinedBuffer.java
index 25a4a06daf9..1d59004ed75 100644
--- a/ojluni/src/main/java/java/util/stream/SpinedBuffer.java
+++ b/ojluni/src/main/java/java/util/stream/SpinedBuffer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2025, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -587,7 +587,6 @@ public class SpinedBuffer<E>
             spineIndex = 0;
         }
 
-        @SuppressWarnings("overloads")
         public void forEach(T_CONS consumer) {
             // completed chunks, if any
             for (int j = 0; j < spineIndex; j++)
diff --git a/ojluni/src/main/java/java/util/stream/Stream.java b/ojluni/src/main/java/java/util/stream/Stream.java
index 9badd4133f1..e954a340d0e 100644
--- a/ojluni/src/main/java/java/util/stream/Stream.java
+++ b/ojluni/src/main/java/java/util/stream/Stream.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2024, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -276,7 +276,7 @@ public interface Stream<T> extends BaseStream<T, Stream<T>> {
      *               function to apply to each element which produces a stream
      *               of new values
      * @return the new stream
-     * @see #mapMulti
+     * @see #mapMulti mapMulti
      */
     <R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);
 
@@ -296,7 +296,7 @@ public interface Stream<T> extends BaseStream<T, Stream<T>> {
      *               function to apply to each element which produces a stream
      *               of new values
      * @return the new stream
-     * @see #flatMap(Function)
+     * @see #flatMap flatMap
      */
     IntStream flatMapToInt(Function<? super T, ? extends IntStream> mapper);
 
@@ -316,7 +316,7 @@ public interface Stream<T> extends BaseStream<T, Stream<T>> {
      *               function to apply to each element which produces a stream
      *               of new values
      * @return the new stream
-     * @see #flatMap(Function)
+     * @see #flatMap flatMap
      */
     LongStream flatMapToLong(Function<? super T, ? extends LongStream> mapper);
 
@@ -336,7 +336,7 @@ public interface Stream<T> extends BaseStream<T, Stream<T>> {
      *               function to apply to each element which produces a stream
      *               of new values
      * @return the new stream
-     * @see #flatMap(Function)
+     * @see #flatMap flatMap
      */
     DoubleStream flatMapToDouble(Function<? super T, ? extends DoubleStream> mapper);
 
@@ -1051,6 +1051,59 @@ public interface Stream<T> extends BaseStream<T, Stream<T>> {
                  BiFunction<U, ? super T, U> accumulator,
                  BinaryOperator<U> combiner);
 
+    /**
+     * Returns a stream consisting of the results of applying the given
+     * {@link Gatherer} to the elements of this stream.
+     *
+     * <p>This is a <a href="package-summary.html#StreamOps">stateful
+     * intermediate operation</a> that is an
+     * <a href="package-summary.html#Extensibility">extension point</a>.
+     *
+     * <p>Gatherers are highly flexible and can describe a vast array of
+     * possibly stateful operations, with support for short-circuiting, and
+     * parallelization.
+     *
+     * <p>When executed in parallel, multiple intermediate results may be
+     * instantiated, populated, and merged so as to maintain isolation of
+     * mutable data structures.  Therefore, even when executed in parallel
+     * with non-thread-safe data structures (such as {@code ArrayList}), no
+     * additional synchronization is needed for a parallel reduction.
+     *
+     * <p>Implementations are allowed, but not required, to detect consecutive
+     * invocations and compose them into a single, fused, operation. This would
+     * make the first expression below behave like the second:
+     *
+     * <pre>{@code
+     *     var stream1 = Stream.of(...).gather(gatherer1).gather(gatherer2);
+     *     var stream2 = Stream.of(...).gather(gatherer1.andThen(gatherer2));
+     * }</pre>
+     *
+     * @implSpec
+     * The default implementation obtains the {@link #spliterator() spliterator}
+     * of this stream, wraps that spliterator so as to support the semantics
+     * of this operation on traversal, and returns a new stream associated with
+     * the wrapped spliterator.  The returned stream preserves the execution
+     * characteristics of this stream (namely parallel or sequential execution
+     * as per {@link #isParallel()}) but the wrapped spliterator may choose to
+     * not support splitting.  When the returned stream is closed, the close
+     * handlers for both the returned and this stream are invoked.
+     * Implementations of this interface should provide their own
+     * implementation of this method.
+     *
+     * @see Gatherers
+     * @param <R> The element type of the new stream
+     * @param gatherer a gatherer
+     * @return the new stream
+     * @since 24
+     *
+     * @hide TODO: Expose this API when Gatherer is ready.
+     */
+    default <R> Stream<R> gather(Gatherer<? super T, ?, R> gatherer) {
+        return StreamSupport.stream(spliterator(), isParallel())
+                            .gather(gatherer)
+                            .onClose(this::close);
+    }
+
     /**
      * Performs a <a href="package-summary.html#MutableReduction">mutable
      * reduction</a> operation on the elements of this stream.  A mutable
@@ -1384,7 +1437,7 @@ public interface Stream<T> extends BaseStream<T, Stream<T>> {
      * @return an empty sequential stream
      */
     public static<T> Stream<T> empty() {
-        return StreamSupport.stream(Spliterators.<T>emptySpliterator(), false);
+        return StreamSupport.stream(Spliterators.emptySpliterator(), false);
     }
 
     /**
diff --git a/ojluni/src/main/java/java/util/stream/StreamSpliterators.java b/ojluni/src/main/java/java/util/stream/StreamSpliterators.java
index d2f558c2821..196cd76c8f8 100644
--- a/ojluni/src/main/java/java/util/stream/StreamSpliterators.java
+++ b/ojluni/src/main/java/java/util/stream/StreamSpliterators.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2024, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -248,6 +248,11 @@ class StreamSpliterators {
                 c |= (spliterator.characteristics() & (Spliterator.SIZED | Spliterator.SUBSIZED));
             }
 
+            // It's not allowed for a Spliterator to report SORTED if not also ORDERED
+            if ((c & Spliterator.SORTED) != 0 && (c & Spliterator.ORDERED) == 0) {
+                c &= ~(Spliterator.SORTED);
+            }
+
             return c;
         }
 
@@ -307,7 +312,7 @@ class StreamSpliterators {
                 Objects.requireNonNull(consumer);
                 init();
 
-                ph.wrapAndCopyInto((Sink<P_OUT>) consumer::accept, spliterator);
+                ph.wrapAndCopyInto(consumer::accept, spliterator);
                 finished = true;
             }
             else {
diff --git a/ojluni/src/main/java/java/util/stream/Tripwire.java b/ojluni/src/main/java/java/util/stream/Tripwire.java
index 962c7d3e1b0..6aae5e67e50 100644
--- a/ojluni/src/main/java/java/util/stream/Tripwire.java
+++ b/ojluni/src/main/java/java/util/stream/Tripwire.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2024, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,9 +24,6 @@
  */
 package java.util.stream;
 
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-
 import sun.util.logging.PlatformLogger;
 
 /**
@@ -49,9 +46,7 @@ final class Tripwire {
     private static final String TRIPWIRE_PROPERTY = "org.openjdk.java.util.stream.tripwire";
 
     /** Should debugging checks be enabled? */
-    @SuppressWarnings("removal")
-    static final boolean ENABLED = AccessController.doPrivileged(
-            (PrivilegedAction<Boolean>) () -> Boolean.getBoolean(TRIPWIRE_PROPERTY));
+    static final boolean ENABLED = Boolean.getBoolean(TRIPWIRE_PROPERTY);
 
     private Tripwire() { }
 
diff --git a/ojluni/src/main/java/java/util/stream/WhileOps.java b/ojluni/src/main/java/java/util/stream/WhileOps.java
index 87fa83e2440..e8a9472aa48 100644
--- a/ojluni/src/main/java/java/util/stream/WhileOps.java
+++ b/ojluni/src/main/java/java/util/stream/WhileOps.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -61,7 +61,7 @@ final class WhileOps {
     static <T> Stream<T> makeTakeWhileRef(AbstractPipeline<?, T, ?> upstream,
                                           Predicate<? super T> predicate) {
         Objects.requireNonNull(predicate);
-        return new ReferencePipeline.StatefulOp<T, T>(upstream, StreamShape.REFERENCE, TAKE_FLAGS) {
+        return new ReferencePipeline.StatefulOp<>(upstream, StreamShape.REFERENCE, TAKE_FLAGS) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public <P_IN> Spliterator<T> opEvaluateParallelLazy(PipelineHelper<T> helper,
@@ -69,8 +69,7 @@ final class WhileOps {
                 if (StreamOpFlag.ORDERED.isKnown(helper.getStreamAndOpFlags())) {
                     return opEvaluateParallel(helper, spliterator, Nodes.castingArray())
                             .spliterator();
-                }
-                else {
+                } else {
                     return new UnorderedWhileSpliterator.OfRef.Taking<>(
                             helper.wrapSpliterator(spliterator), false, predicate);
                 }
@@ -88,7 +87,7 @@ final class WhileOps {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<T> opWrapSink(int flags, Sink<T> sink) {
-                return new Sink.ChainedReference<T, T>(sink) {
+                return new Sink.ChainedReference<>(sink) {
                     boolean take = true;
 
                     @Override
@@ -121,7 +120,7 @@ final class WhileOps {
     static IntStream makeTakeWhileInt(AbstractPipeline<?, Integer, ?> upstream,
                                       IntPredicate predicate) {
         Objects.requireNonNull(predicate);
-        return new IntPipeline.StatefulOp<Integer>(upstream, StreamShape.INT_VALUE, TAKE_FLAGS) {
+        return new IntPipeline.StatefulOp<>(upstream, StreamShape.INT_VALUE, TAKE_FLAGS) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public <P_IN> Spliterator<Integer> opEvaluateParallelLazy(PipelineHelper<Integer> helper,
@@ -129,8 +128,7 @@ final class WhileOps {
                 if (StreamOpFlag.ORDERED.isKnown(helper.getStreamAndOpFlags())) {
                     return opEvaluateParallel(helper, spliterator, Integer[]::new)
                             .spliterator();
-                }
-                else {
+                } else {
                     return new UnorderedWhileSpliterator.OfInt.Taking(
                             (Spliterator.OfInt) helper.wrapSpliterator(spliterator), false, predicate);
                 }
@@ -148,7 +146,7 @@ final class WhileOps {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Integer> opWrapSink(int flags, Sink<Integer> sink) {
-                return new Sink.ChainedInt<Integer>(sink) {
+                return new Sink.ChainedInt<>(sink) {
                     boolean take = true;
 
                     @Override
@@ -181,7 +179,7 @@ final class WhileOps {
     static LongStream makeTakeWhileLong(AbstractPipeline<?, Long, ?> upstream,
                                         LongPredicate predicate) {
         Objects.requireNonNull(predicate);
-        return new LongPipeline.StatefulOp<Long>(upstream, StreamShape.LONG_VALUE, TAKE_FLAGS) {
+        return new LongPipeline.StatefulOp<>(upstream, StreamShape.LONG_VALUE, TAKE_FLAGS) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public <P_IN> Spliterator<Long> opEvaluateParallelLazy(PipelineHelper<Long> helper,
@@ -189,8 +187,7 @@ final class WhileOps {
                 if (StreamOpFlag.ORDERED.isKnown(helper.getStreamAndOpFlags())) {
                     return opEvaluateParallel(helper, spliterator, Long[]::new)
                             .spliterator();
-                }
-                else {
+                } else {
                     return new UnorderedWhileSpliterator.OfLong.Taking(
                             (Spliterator.OfLong) helper.wrapSpliterator(spliterator), false, predicate);
                 }
@@ -208,7 +205,7 @@ final class WhileOps {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Long> opWrapSink(int flags, Sink<Long> sink) {
-                return new Sink.ChainedLong<Long>(sink) {
+                return new Sink.ChainedLong<>(sink) {
                     boolean take = true;
 
                     @Override
@@ -241,7 +238,7 @@ final class WhileOps {
     static DoubleStream makeTakeWhileDouble(AbstractPipeline<?, Double, ?> upstream,
                                             DoublePredicate predicate) {
         Objects.requireNonNull(predicate);
-        return new DoublePipeline.StatefulOp<Double>(upstream, StreamShape.DOUBLE_VALUE, TAKE_FLAGS) {
+        return new DoublePipeline.StatefulOp<>(upstream, StreamShape.DOUBLE_VALUE, TAKE_FLAGS) {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public <P_IN> Spliterator<Double> opEvaluateParallelLazy(PipelineHelper<Double> helper,
@@ -249,8 +246,7 @@ final class WhileOps {
                 if (StreamOpFlag.ORDERED.isKnown(helper.getStreamAndOpFlags())) {
                     return opEvaluateParallel(helper, spliterator, Double[]::new)
                             .spliterator();
-                }
-                else {
+                } else {
                     return new UnorderedWhileSpliterator.OfDouble.Taking(
                             (Spliterator.OfDouble) helper.wrapSpliterator(spliterator), false, predicate);
                 }
@@ -268,7 +264,7 @@ final class WhileOps {
             @Override
             // Android-changed: Make public, to match the method it's overriding.
             public Sink<Double> opWrapSink(int flags, Sink<Double> sink) {
-                return new Sink.ChainedDouble<Double>(sink) {
+                return new Sink.ChainedDouble<>(sink) {
                     boolean take = true;
 
                     @Override
diff --git a/ojluni/src/main/java/java/util/stream/package-info.java b/ojluni/src/main/java/java/util/stream/package-info.java
index 635f44e74c5..59f72cb7eb0 100644
--- a/ojluni/src/main/java/java/util/stream/package-info.java
+++ b/ojluni/src/main/java/java/util/stream/package-info.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -620,6 +620,13 @@
  * but in some cases equivalence may be relaxed to account for differences in
  * order.
  *
+ * <h3><a id="Extensibility">Extensibility</a></h3>
+ *
+ * <p>Implementing {@link java.util.stream.Collector};
+ * using the factory method {@code java.util.stream.Collector.of(...)}; or
+ * using the predefined collectors in {@link java.util.stream.Collectors} allows
+ * for user-defined, reusable, <em>terminal</em> operations.
+ *
  * <h3><a id="ConcurrentReduction">Reduction, concurrency, and ordering</a></h3>
  *
  * With some complex reduction operations, for example a {@code collect()} that
@@ -752,5 +759,4 @@
  */
 package java.util.stream;
 
-import java.util.function.BinaryOperator;
 import java.util.function.UnaryOperator;
diff --git a/ojluni/src/main/java/java/util/zip/ZipFile.java b/ojluni/src/main/java/java/util/zip/ZipFile.java
index 8f60561b1bd..b10098ba17a 100644
--- a/ojluni/src/main/java/java/util/zip/ZipFile.java
+++ b/ojluni/src/main/java/java/util/zip/ZipFile.java
@@ -35,13 +35,15 @@ import java.io.FileNotFoundException;
 import java.io.RandomAccessFile;
 import java.io.UncheckedIOException;
 import java.lang.ref.Cleaner.Cleanable;
-import java.nio.DirectByteBuffer;
 import java.nio.ByteOrder;
+import java.nio.DirectByteBuffer;
 import java.nio.channels.FileChannel;
 import java.nio.channels.FileChannel.MapMode;
 import java.nio.charset.CharacterCodingException;
 import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
+import java.nio.file.FileSystem;
+import java.nio.file.FileSystems;
 import java.nio.file.InvalidPathException;
 import java.nio.file.attribute.BasicFileAttributes;
 import java.nio.file.Files;
@@ -74,6 +76,8 @@ import jdk.internal.misc.VM;
 import jdk.internal.ref.CleanerFactory;
 import jdk.internal.vm.annotation.Stable;
 import sun.misc.Cleaner;
+import sun.nio.fs.DefaultFileSystemProvider;
+import sun.security.action.GetPropertyAction;
 import sun.security.util.SignatureFileVerifier;
 
 import dalvik.system.CloseGuard;
@@ -130,6 +134,15 @@ public class ZipFile implements ZipConstants, Closeable {
     public static final int OPEN_DELETE = 0x4;
 
     // Android-changed: Additional ZipException throw scenario with ZipPathValidator.
+    /**
+     * Flag to specify whether the Extra ZIP64 validation should be
+     * disabled.
+     */
+    private static final boolean DISABLE_ZIP64_EXTRA_VALIDATION =
+            // Android-changed: The validation isn't enabled on Android
+            // getDisableZip64ExtraFieldValidation();
+            true;
+
     /**
      * Opens a zip file for reading.
      *
@@ -1177,10 +1190,30 @@ public class ZipFile implements ZipConstants, Closeable {
         }
     }
 
-    // Android-removed: this code does not run on Windows and JavaUtilZipFileAccess is not imported.
+    // Android-removed: this code does not run on Windows.
+    // private static boolean isWindows;
+    /**
+     * Returns the value of the System property which indicates whether the
+     * Extra ZIP64 validation should be disabled.
+     */
+
+    // Android-removed: The validation isn't enabled on Android.
     /*
-    private static boolean isWindows;
+    static boolean getDisableZip64ExtraFieldValidation() {
+        boolean result;
+        String value = GetPropertyAction.privilegedGetProperty(
+                "jdk.util.zip.disableZip64ExtraFieldValidation");
+        if (value == null) {
+            result = false;
+        } else {
+            result = value.isEmpty() || value.equalsIgnoreCase("true");
+        }
+        return result;
+    }
+    */
 
+    // Android-removed: JavaUtilZipFileAccess is not imported.
+    /*
     static {
         SharedSecrets.setJavaUtilZipFileAccess(
             new JavaUtilZipFileAccess() {
@@ -1303,6 +1336,16 @@ public class ZipFile implements ZipConstants, Closeable {
             if (entryPos + nlen > cen.length - ENDHDR) {
                 zerror("invalid CEN header (bad header size)");
             }
+
+            int elen = CENEXT(cen, pos);
+            if (elen > 0 && !DISABLE_ZIP64_EXTRA_VALIDATION) {
+                long extraStartingOffset = pos + CENHDR + nlen;
+                if ((int)extraStartingOffset != extraStartingOffset) {
+                    zerror("invalid CEN header (bad extra offset)");
+                }
+                checkExtraFields(pos, (int)extraStartingOffset, elen);
+            }
+
             try {
                 ZipCoder zcp = zipCoderForPos(cen, pos);
                 int hash = zcp.checkedHash(cen, entryPos, nlen);
@@ -1319,6 +1362,140 @@ public class ZipFile implements ZipConstants, Closeable {
             return nlen;
         }
 
+        /**
+         * Validate the Zip64 Extra block fields
+         * @param startingOffset Extra Field starting offset within the CEN
+         * @param extraFieldLen Length of this Extra field
+         * @throws ZipException  If an error occurs validating the Zip64 Extra
+         * block
+         */
+        private void checkExtraFields(int cenPos, int startingOffset,
+                                      int extraFieldLen) throws ZipException {
+            // Extra field Length cannot exceed 65,535 bytes per the PKWare
+            // APP.note 4.4.11
+            if (extraFieldLen > 0xFFFF) {
+                zerror("invalid extra field length");
+            }
+            // CEN Offset where this Extra field ends
+            int extraEndOffset = startingOffset + extraFieldLen;
+            // Android-changed: don't keep CEN bytes in heap memory after initialization.
+            //if (extraEndOffset > cen.length) {
+            if (extraEndOffset > cen.limit()) {
+                zerror("Invalid CEN header (extra data field size too long)");
+            }
+            int currentOffset = startingOffset;
+            // Walk through each Extra Header. Each Extra Header Must consist of:
+            //       Header ID - 2 bytes
+            //       Data Size - 2 bytes:
+            while (currentOffset + Integer.BYTES <= extraEndOffset) {
+                int tag = get16(cen, currentOffset);
+                currentOffset += Short.BYTES;
+
+                int tagBlockSize = get16(cen, currentOffset);
+                currentOffset += Short.BYTES;
+                int tagBlockEndingOffset = currentOffset + tagBlockSize;
+
+                //  The ending offset for this tag block should not go past the
+                //  offset for the end of the extra field
+                if (tagBlockEndingOffset > extraEndOffset) {
+                    zerror(String.format(
+                            "Invalid CEN header (invalid extra data field size for " +
+                                    "tag: 0x%04x at %d)",
+                            tag, cenPos));
+                }
+
+                if (tag == ZIP64_EXTID) {
+                    // Get the compressed size;
+                    long csize = CENSIZ(cen, cenPos);
+                    // Get the uncompressed size;
+                    long size = CENLEN(cen, cenPos);
+
+                    checkZip64ExtraFieldValues(currentOffset, tagBlockSize,
+                            csize, size);
+                }
+                currentOffset += tagBlockSize;
+            }
+        }
+
+        /**
+         * Validate the Zip64 Extended Information Extra Field (0x0001) block
+         * size and that the uncompressed size and compressed size field
+         * values are not negative.
+         * Note:  As we do not use the LOC offset or Starting disk number
+         * field value we will not validate them
+         * @param off the starting offset for the Zip64 field value
+         * @param blockSize the size of the Zip64 Extended Extra Field
+         * @param csize CEN header compressed size value
+         * @param size CEN header uncompressed size value
+         * @throws ZipException if an error occurs
+         */
+        private void checkZip64ExtraFieldValues(int off, int blockSize, long csize,
+                                                long size)
+                throws ZipException {
+            // Android-changed: don't keep CEN bytes in heap memory after initialization.
+            // byte[] cen = this.cen;
+            DirectByteBuffer cen = this.cen;
+            // if ZIP64_EXTID blocksize == 0, which may occur with some older
+            // versions of Apache Ant and Commons Compress, validate csize and size
+            // to make sure neither field == ZIP64_MAGICVAL
+            if (blockSize == 0) {
+                if (csize == ZIP64_MAGICVAL || size == ZIP64_MAGICVAL) {
+                    zerror("Invalid CEN header (invalid zip64 extra data field size)");
+                }
+                // Only validate the ZIP64_EXTID data if the block size > 0
+                return;
+            }
+            // Validate the Zip64 Extended Information Extra Field (0x0001)
+            // length.
+            if (!isZip64ExtBlockSizeValid(blockSize)) {
+                zerror("Invalid CEN header (invalid zip64 extra data field size)");
+            }
+            // Check the uncompressed size is not negative
+            // Note we do not need to check blockSize is >= 8 as
+            // we know its length is at least 8 from the call to
+            // isZip64ExtBlockSizeValid()
+            if ((size == ZIP64_MAGICVAL)) {
+                if(get64(cen, off) < 0) {
+                    zerror("Invalid zip64 extra block size value");
+                }
+            }
+            // Check the compressed size is not negative
+            if ((csize == ZIP64_MAGICVAL) && (blockSize >= 16)) {
+                if (get64(cen, off + 8) < 0) {
+                    zerror("Invalid zip64 extra block compressed size value");
+                }
+            }
+        }
+
+        /**
+         * Validate the size and contents of a Zip64 extended information field
+         * The order of the Zip64 fields is fixed, but the fields MUST
+         * only appear if the corresponding LOC or CEN field is set to 0xFFFF:
+         * or 0xFFFFFFFF:
+         * Uncompressed Size - 8 bytes
+         * Compressed Size   - 8 bytes
+         * LOC Header offset - 8 bytes
+         * Disk Start Number - 4 bytes
+         * See PKWare APP.Note Section 4.5.3 for more details
+         *
+         * @param blockSize the Zip64 Extended Information Extra Field size
+         * @return true if the extra block size is valid; false otherwise
+         */
+        private static boolean isZip64ExtBlockSizeValid(int blockSize) {
+            /*
+             * As the fields must appear in order, the block size indicates which
+             * fields to expect:
+             *  8 - uncompressed size
+             * 16 - uncompressed size, compressed size
+             * 24 - uncompressed size, compressed sise, LOC Header offset
+             * 28 - uncompressed size, compressed sise, LOC Header offset,
+             * and Disk start number
+             */
+            return switch(blockSize) {
+                case 8, 16, 24, 28 -> true;
+                default -> false;
+            };
+        }
         private int getEntryHash(int index) { return entries[index]; }
         private int getEntryNext(int index) { return entries[index + 1]; }
         private int getEntryPos(int index)  { return entries[index + 2]; }
@@ -1382,7 +1559,14 @@ public class ZipFile implements ZipConstants, Closeable {
             }
         }
         private static final HashMap<Key, Source> files = new HashMap<>();
-
+        /**
+         * Use the platform's default file system to avoid
+         * issues when the VM is configured to use a custom file system provider.
+         */
+        private static final java.nio.file.FileSystem builtInFS =
+        // Android-changed: Temporary patch until DefaultFileSystemProvider is updated to 17.
+        //         DefaultFileSystemProvider.theFileSystem();
+                FileSystems.getDefault();
 
         // Android-changed: pass izZipFilePathValidatorEnabled argument.
         // static Source get(File file, boolean toDelete, ZipCoder zc) throws IOException {
@@ -1393,12 +1577,12 @@ public class ZipFile implements ZipConstants, Closeable {
                 // BEGIN Android-changed: isZipFilePathValidatorEnabled passed as part of Key.
                 /*
                 key = new Key(file,
-                        Files.readAttributes(file.toPath(), BasicFileAttributes.class),
-                        zc);
+                        Files.readAttributes(builtInFS.getPath(file.getPath()),
+                                BasicFileAttributes.class), zc);
                 */
                 key = new Key(file,
-                        Files.readAttributes(file.toPath(), BasicFileAttributes.class),
-                        zc, isZipPathValidatorEnabled);
+                        Files.readAttributes(builtInFS.getPath(file.getPath()),
+                                BasicFileAttributes.class), zc, isZipPathValidatorEnabled);
                 // END Android-changed: isZipFilePathValidatorEnabled passed as part of Key.
             } catch (InvalidPathException ipe) {
                 throw new IOException(ipe);
@@ -1659,8 +1843,14 @@ public class ZipFile implements ZipConstants, Closeable {
                     zerror("invalid END header (bad central directory offset)");
                 }
                 // read in the CEN and END
+                if (end.cenlen + ENDHDR >= Integer.MAX_VALUE) {
+                    zerror("invalid END header (central directory size too large)");
+                }
                 // BEGIN Android-changed: don't keep CEN bytes in heap memory after initialization.
                 // cen = this.cen = new byte[(int)(end.cenlen + ENDHDR)];
+                // if (readFullyAt(cen, 0, cen.length, cenpos) != end.cenlen + ENDHDR) {
+                //     zerror("read CEN tables failed");
+                // }
                 cenlen = (int) (end.cenlen + ENDHDR);
                 DirectByteBuffer cenBuf = this.cen = (DirectByteBuffer) zfile.getChannel()
                         .map(MapMode.READ_ONLY, cenpos, cenlen);
@@ -1831,13 +2021,18 @@ public class ZipFile implements ZipConstants, Closeable {
                         // slash
                         int entryLen = entry.length();
                         int nameLen = name.length();
-                        if ((entryLen == nameLen && entry.equals(name)) ||
-                                (addSlash &&
-                                nameLen + 1 == entryLen &&
-                                entry.startsWith(name) &&
-                                entry.charAt(entryLen - 1) == '/')) {
+                        if (entryLen == nameLen && entry.equals(name)) {
+                            // Found our match
                             return pos;
                         }
+                        // If addSlash is true we'll now test for name+/ providing
+                        if (addSlash && nameLen + 1 == entryLen
+                                && entry.startsWith(name) &&
+                                entry.charAt(entryLen - 1) == '/') {
+                            // Found the entry "name+/", now find the CEN entry pos
+                            int exactPos = getEntryPos(name, false);
+                            return exactPos == -1 ? pos : exactPos;
+                        }
                     } catch (IllegalArgumentException iae) {
                         // Ignore
                     }
diff --git a/ojluni/src/main/java/jdk/internal/access/SharedSecrets.java b/ojluni/src/main/java/jdk/internal/access/SharedSecrets.java
index 3b1bf48a69f..d4939655c84 100644
--- a/ojluni/src/main/java/jdk/internal/access/SharedSecrets.java
+++ b/ojluni/src/main/java/jdk/internal/access/SharedSecrets.java
@@ -24,9 +24,20 @@
  */
 package jdk.internal.access;
 
-import jdk.internal.misc.Unsafe;
+import javax.crypto.SealedObject;
+import javax.crypto.spec.SecretKeySpec;
+import java.io.Console;
+import java.io.FileDescriptor;
+import java.io.FilePermission;
 import java.io.ObjectInputStream;
 import java.io.FileDescriptor;
+import java.lang.invoke.MethodHandles;
+import java.security.Security;
+import java.security.spec.EncodedKeySpec;
+import java.util.ResourceBundle;
+import java.util.jar.JarFile;
+import jdk.internal.misc.Unsafe;
+
 /** A repository of "shared secrets", which are a mechanism for
  calling implementation-private methods in another package without
  using reflection. A package-private class implements a public
@@ -82,6 +93,7 @@ public class SharedSecrets {
     private static JavaUtilZipFileAccess javaUtilZipFileAccess;
     private static JavaUtilResourceBundleAccess javaUtilResourceBundleAccess;
     private static JavaSecurityAccess javaSecurityAccess;
+    private static JavaSecurityPropertiesAccess javaSecurityPropertiesAccess;
     private static JavaSecuritySignatureAccess javaSecuritySignatureAccess;
     private static JavaSecuritySpecAccess javaSecuritySpecAccess;
     private static JavaxCryptoSealedObjectAccess javaxCryptoSealedObjectAccess;
@@ -271,6 +283,20 @@ public class SharedSecrets {
         }
         return access;
     }
+
+    public static void setJavaSecurityPropertiesAccess(JavaSecurityPropertiesAccess jspa) {
+        javaSecurityPropertiesAccess = jspa;
+    }
+
+    public static JavaSecurityPropertiesAccess getJavaSecurityPropertiesAccess() {
+        var access = javaSecurityPropertiesAccess;
+        if (access == null) {
+            ensureClassInitialized(Security.class);
+            access = javaSecurityPropertiesAccess;
+        }
+        return access;
+    }
+
     public static JavaUtilZipFileAccess getJavaUtilZipFileAccess() {
         var access = javaUtilZipFileAccess;
         if (access == null) {
diff --git a/ojluni/src/main/java/jdk/internal/event/ThreadSleepEvent.java b/ojluni/src/main/java/jdk/internal/event/ThreadSleepEvent.java
new file mode 100644
index 00000000000..ab9b377c0f3
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/event/ThreadSleepEvent.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2020, 2022, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.event;
+
+/**
+ * Event recording thread sleeping.
+ */
+
+public final class ThreadSleepEvent extends Event {
+    private static final ThreadSleepEvent EVENT = new ThreadSleepEvent();
+
+    /**
+     * Returns {@code true} if event is enabled, {@code false} otherwise.
+     */
+    public static boolean isTurnedOn() {
+        return EVENT.isEnabled();
+    }
+
+    public long time;
+}
diff --git a/ojluni/src/main/java/jdk/internal/invoke/MhUtil.java b/ojluni/src/main/java/jdk/internal/invoke/MhUtil.java
new file mode 100644
index 00000000000..4a8cb785470
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/invoke/MhUtil.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2024, 2025, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.invoke;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+import java.lang.invoke.VarHandle;
+
+/**
+ * Static factories for certain VarHandle/MethodHandle variants.
+ * <p>
+ * Some methods take no receiver argument. In these cases, the receiver is the
+ * lookup class.
+ * <p>
+ * The methods will throw an {@link InternalError} if the lookup fails.
+ * <p>
+ * Here is an example of how one of these methods could be used:
+ * {@snippet lang=java
+ * static MethodHandle BAR_HANDLE =
+ *         MhUtil.findVirtual(MethodHandles.lookup(),
+ *                 Foo.class,"bar",MethodType.methodType(int.class));
+ * }
+ */
+public final class MhUtil {
+
+    private MhUtil() {}
+
+    public static VarHandle findVarHandle(MethodHandles.Lookup lookup,
+                                          String name,
+                                          Class<?> type) {
+        return findVarHandle(lookup, lookup.lookupClass(), name, type);
+    }
+
+    public static VarHandle findVarHandle(MethodHandles.Lookup lookup,
+                                          Class<?> recv,
+                                          String name,
+                                          Class<?> type) {
+        try {
+            return lookup.findVarHandle(recv, name, type);
+        } catch (ReflectiveOperationException e) {
+            throw new InternalError(e);
+        }
+    }
+
+    public static MethodHandle findVirtual(MethodHandles.Lookup lookup,
+                                           String name,
+                                           MethodType type) {
+        return findVirtual(lookup, lookup.lookupClass(), name, type);
+    }
+
+    public static MethodHandle findVirtual(MethodHandles.Lookup lookup,
+                                           Class<?> refc,
+                                           String name,
+                                           MethodType type) {
+        try {
+            return lookup.findVirtual(refc, name, type);
+        } catch (ReflectiveOperationException e) {
+            throw new InternalError(e);
+        }
+    }
+
+    public static MethodHandle findStatic(MethodHandles.Lookup lookup,
+                                          String name,
+                                          MethodType type) {
+        return findStatic(lookup, lookup.lookupClass(), name, type);
+    }
+
+    public static MethodHandle findStatic(MethodHandles.Lookup lookup,
+                                          Class<?> refc,
+                                          String name,
+                                          MethodType type) {
+        try {
+            return lookup.findStatic(refc, name, type);
+        } catch (ReflectiveOperationException e) {
+            throw new InternalError(e);
+        }
+    }
+
+}
diff --git a/ojluni/src/main/java/jdk/internal/misc/CarrierThread.java b/ojluni/src/main/java/jdk/internal/misc/CarrierThread.java
new file mode 100644
index 00000000000..e108c234046
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/misc/CarrierThread.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (c) 2021, 2022, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.misc;
+
+import java.security.AccessControlContext;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.security.ProtectionDomain;
+import java.util.concurrent.ForkJoinPool;
+import java.util.concurrent.ForkJoinWorkerThread;
+import jdk.internal.access.SharedSecrets;
+
+/**
+ * A ForkJoinWorkerThread that can be used as a carrier thread.
+ */
+public class CarrierThread extends ForkJoinWorkerThread {
+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final Unsafe U = Unsafe.getUnsafe();
+
+    private static final ThreadGroup CARRIER_THREADGROUP = carrierThreadGroup();
+    @SuppressWarnings("removal")
+    private static final AccessControlContext INNOCUOUS_ACC = innocuousACC();
+
+    private static final long CONTEXTCLASSLOADER;
+    private static final long INHERITABLETHREADLOCALS;
+    private static final long INHERITEDACCESSCONTROLCONTEXT;
+
+    private boolean blocking;    // true if in blocking op
+
+    public CarrierThread(ForkJoinPool pool) {
+        super(CARRIER_THREADGROUP, pool, true);
+        U.putReference(this, CONTEXTCLASSLOADER, ClassLoader.getSystemClassLoader());
+        U.putReference(this, INHERITABLETHREADLOCALS, null);
+        U.putReferenceRelease(this, INHERITEDACCESSCONTROLCONTEXT, INNOCUOUS_ACC);
+    }
+
+    /**
+     * For use by {@link Blocker} to test if the thread is in a blocking operation.
+     */
+    boolean inBlocking() {
+        //assert JLA.currentCarrierThread() == this;
+        return blocking;
+    }
+
+    /**
+     * For use by {@link Blocker} to mark the start of a blocking operation.
+     */
+    void beginBlocking() {
+        //assert JLA.currentCarrierThread() == this && !blocking;
+        blocking = true;
+    }
+
+    /**
+     * For use by {@link Blocker} to mark the end of a blocking operation.
+     */
+    void endBlocking() {
+        //assert JLA.currentCarrierThread() == this && blocking;
+        blocking = false;
+    }
+
+    @Override
+    public void setUncaughtExceptionHandler(UncaughtExceptionHandler ueh) { }
+
+    @Override
+    public void setContextClassLoader(ClassLoader cl) {
+        throw new SecurityException("setContextClassLoader");
+    }
+
+    /**
+     * The thread group for the carrier threads.
+     */
+    @SuppressWarnings("removal")
+    private static final ThreadGroup carrierThreadGroup() {
+        return AccessController.doPrivileged(new PrivilegedAction<ThreadGroup>() {
+            public ThreadGroup run() {
+                ThreadGroup group = JLA.currentCarrierThread().getThreadGroup();
+                for (ThreadGroup p; (p = group.getParent()) != null; )
+                    group = p;
+                var carrierThreadsGroup = new ThreadGroup(group, "CarrierThreads");
+                return carrierThreadsGroup;
+            }
+        });
+    }
+
+    /**
+     * Return an AccessControlContext that doesn't support any permissions.
+     */
+    @SuppressWarnings("removal")
+    private static AccessControlContext innocuousACC() {
+        return new AccessControlContext(new ProtectionDomain[] {
+                new ProtectionDomain(null, null)
+        });
+    }
+
+    static {
+        CONTEXTCLASSLOADER = U.objectFieldOffset(Thread.class,
+                "contextClassLoader");
+        INHERITABLETHREADLOCALS = U.objectFieldOffset(Thread.class,
+                "inheritableThreadLocals");
+        INHERITEDACCESSCONTROLCONTEXT = U.objectFieldOffset(Thread.class,
+                "inheritedAccessControlContext");
+    }
+}
diff --git a/ojluni/src/main/java/jdk/internal/misc/CarrierThreadLocal.java b/ojluni/src/main/java/jdk/internal/misc/CarrierThreadLocal.java
new file mode 100644
index 00000000000..80b81116d36
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/misc/CarrierThreadLocal.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.misc;
+
+import jdk.internal.access.SharedSecrets;
+
+/**
+ * A {@link ThreadLocal} variant which binds its value to current thread's
+ * carrier thread.
+ */
+public class CarrierThreadLocal<T> extends ThreadLocal<T> {
+
+    @Override
+    public T get() {
+        return JLA.getCarrierThreadLocal(this);
+    }
+
+    @Override
+    public void set(T value) {
+        JLA.setCarrierThreadLocal(this, value);
+    }
+
+    @Override
+    public void remove() {
+        JLA.removeCarrierThreadLocal(this);
+    }
+
+    public boolean isPresent() {
+        return JLA.isCarrierThreadLocalPresent(this);
+    }
+
+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+}
diff --git a/ojluni/src/main/java/jdk/internal/misc/InnocuousThread.java b/ojluni/src/main/java/jdk/internal/misc/InnocuousThread.java
index 4c50d6f1746..f8db0bc1c6e 100644
--- a/ojluni/src/main/java/jdk/internal/misc/InnocuousThread.java
+++ b/ojluni/src/main/java/jdk/internal/misc/InnocuousThread.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -35,6 +35,7 @@ import java.util.concurrent.atomic.AtomicInteger;
  * A thread that has no permissions, is not a member of any user-defined
  * ThreadGroup and supports the ability to erase ThreadLocals.
  */
+@SuppressWarnings("removal")
 public final class InnocuousThread extends Thread {
     private static final jdk.internal.misc.Unsafe UNSAFE;
     private static final long THREAD_LOCALS;
@@ -50,7 +51,7 @@ public final class InnocuousThread extends Thread {
     }
 
     /**
-     * Returns a new InnocuousThread with an auto-generated thread name
+     * Returns a new InnocuousThread with an auto-generated thread name,
      * and its context class loader is set to the system class loader.
      */
     public static Thread newThread(Runnable target) {
@@ -62,14 +63,24 @@ public final class InnocuousThread extends Thread {
      * set to the system class loader.
      */
     public static Thread newThread(String name, Runnable target) {
+        return newThread(name, target, -1);
+    }
+    /**
+     * Returns a new InnocuousThread with its context class loader
+     * set to the system class loader. The thread priority will be
+     * set to the given priority.
+     */
+    public static Thread newThread(String name, Runnable target, int priority) {
+        if (System.getSecurityManager() == null) {
+            return createThread(name, target, 0L,
+                    ClassLoader.getSystemClassLoader(), priority);
+        }
         return AccessController.doPrivileged(
                 new PrivilegedAction<Thread>() {
                     @Override
                     public Thread run() {
-                        return new InnocuousThread(INNOCUOUSTHREADGROUP,
-                                                   target,
-                                                   name,
-                                                   ClassLoader.getSystemClassLoader());
+                        return createThread(name, target, 0L,
+                                ClassLoader.getSystemClassLoader(), priority);
                     }
                 });
     }
@@ -86,18 +97,59 @@ public final class InnocuousThread extends Thread {
      * Returns a new InnocuousThread with null context class loader.
      */
     public static Thread newSystemThread(String name, Runnable target) {
+        return newSystemThread(name, target, -1);
+    }
+
+    /**
+     * Returns a new InnocuousThread with null context class loader.
+     * Thread priority is set to the given priority.
+     */
+    public static Thread newSystemThread(String name, Runnable target, int priority) {
+        if (System.getSecurityManager() == null) {
+            return createThread(name, target, 0L, null, priority);
+        }
+        return AccessController.doPrivileged(
+                new PrivilegedAction<Thread>() {
+                    @Override
+                    public Thread run() {
+                        return createThread(name, target, 0L,
+                                null, priority);
+                    }
+                });
+    }
+
+    /**
+     * Returns a new InnocuousThread with null context class loader.
+     * Thread priority is set to the given priority.
+     */
+    public static Thread newSystemThread(String name, Runnable target,
+                                         long stackSize, int priority) {
+        if (System.getSecurityManager() == null) {
+            return createThread(name, target, stackSize, null, priority);
+        }
         return AccessController.doPrivileged(
                 new PrivilegedAction<Thread>() {
                     @Override
                     public Thread run() {
-                        return new InnocuousThread(INNOCUOUSTHREADGROUP,
-                                                   target, name, null);
+                        return createThread(name, target, 0L,
+                                null, priority);
                     }
                 });
     }
 
-    private InnocuousThread(ThreadGroup group, Runnable target, String name, ClassLoader tccl) {
-        super(group, target, name, 0L, false);
+    private static Thread createThread(String name, Runnable target, long stackSize,
+                                       ClassLoader loader, int priority) {
+        Thread t = new InnocuousThread(INNOCUOUSTHREADGROUP,
+                target, name, stackSize, loader);
+        if (priority >= 0) {
+            t.setPriority(priority);
+        }
+        return t;
+    }
+
+    private InnocuousThread(ThreadGroup group, Runnable target, String name,
+                            long stackSize, ClassLoader tccl) {
+        super(group, target, name, stackSize, false);
         UNSAFE.putReferenceRelease(this, INHERITEDACCESSCONTROLCONTEXT, ACC);
         UNSAFE.putReferenceRelease(this, CONTEXTCLASSLOADER, tccl);
     }
@@ -155,10 +207,8 @@ public final class InnocuousThread extends Thread {
             CONTEXTCLASSLOADER = UNSAFE.objectFieldOffset
                 (tk, "contextClassLoader");
 
-            long tg = UNSAFE.objectFieldOffset(tk, "group");
             long gp = UNSAFE.objectFieldOffset(gk, "parent");
-            ThreadGroup group = (ThreadGroup)
-                UNSAFE.getReference(Thread.currentThread(), tg);
+            ThreadGroup group = Thread.currentThread().getThreadGroup();
 
             while (group != null) {
                 ThreadGroup parent = (ThreadGroup)UNSAFE.getReference(group, gp);
@@ -167,13 +217,17 @@ public final class InnocuousThread extends Thread {
                 group = parent;
             }
             final ThreadGroup root = group;
-            INNOCUOUSTHREADGROUP = AccessController.doPrivileged(
-                new PrivilegedAction<ThreadGroup>() {
-                    @Override
-                    public ThreadGroup run() {
-                        return new ThreadGroup(root, "InnocuousThreadGroup");
-                    }
-                });
+            if (System.getSecurityManager() == null) {
+                INNOCUOUSTHREADGROUP = new ThreadGroup(root, "InnocuousThreadGroup");
+            } else {
+                INNOCUOUSTHREADGROUP = AccessController.doPrivileged(
+                    new PrivilegedAction<ThreadGroup>() {
+                        @Override
+                        public ThreadGroup run() {
+                            return new ThreadGroup(root, "InnocuousThreadGroup");
+                        }
+                    });
+            }
         } catch (Exception e) {
             throw new Error(e);
         }
diff --git a/ojluni/src/main/java/jdk/internal/misc/TerminatingThreadLocal.java b/ojluni/src/main/java/jdk/internal/misc/TerminatingThreadLocal.java
index c6d87e2a66d..eeb1a77e226 100644
--- a/ojluni/src/main/java/jdk/internal/misc/TerminatingThreadLocal.java
+++ b/ojluni/src/main/java/jdk/internal/misc/TerminatingThreadLocal.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,11 +29,12 @@ import java.util.Collections;
 import java.util.IdentityHashMap;
 
 /**
- * A thread-local variable that is notified when a thread terminates and
- * it has been initialized in the terminating thread (even if it was
+ * A per-carrier-thread-local variable that is notified when a thread terminates and
+ * it has been initialized in the terminating carrier thread or a virtual thread
+ * that had the terminating carrier thread as its carrier thread (even if it was
  * initialized with a null value).
  */
-public class TerminatingThreadLocal<T> extends ThreadLocal<T> {
+public class TerminatingThreadLocal<T> extends CarrierThreadLocal<T> {
 
     @Override
     public void set(T value) {
@@ -92,11 +93,11 @@ public class TerminatingThreadLocal<T> extends ThreadLocal<T> {
     }
 
     /**
-     * a per-thread registry of TerminatingThreadLocal(s) that have been registered
-     * but later not unregistered in a particular thread.
+     * a per-carrier-thread registry of TerminatingThreadLocal(s) that have been registered
+     * but later not unregistered in a particular carrier-thread.
      */
-    public static final ThreadLocal<Collection<TerminatingThreadLocal<?>>> REGISTRY =
-        new ThreadLocal<>() {
+    public static final CarrierThreadLocal<Collection<TerminatingThreadLocal<?>>> REGISTRY =
+        new CarrierThreadLocal<>() {
             @Override
             protected Collection<TerminatingThreadLocal<?>> initialValue() {
                 return Collections.newSetFromMap(new IdentityHashMap<>(4));
diff --git a/ojluni/src/main/java/jdk/internal/misc/ThreadTracker.java b/ojluni/src/main/java/jdk/internal/misc/ThreadTracker.java
new file mode 100644
index 00000000000..67cf0783223
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/misc/ThreadTracker.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (c) 2021, 2022, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.misc;
+
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * Tracks threads to help detect reentrancy without using ThreadLocal variables.
+ * A thread invokes the {@code begin} or {@code tryBegin} methods at the start
+ * of a block, and the {@code end} method at the end of a block.
+ */
+public class ThreadTracker {
+
+    /**
+     * A reference to a Thread that is suitable for use as a key in a collection.
+     * The hashCode/equals methods do not invoke the Thread hashCode/equals method
+     * as they may run arbitrary code and/or leak references to Thread objects.
+     */
+    private record ThreadRef(Thread thread) {
+        @Override
+        public int hashCode() {
+            return Long.hashCode(thread.threadId());
+        }
+        @Override
+        public boolean equals(Object obj) {
+            return (obj instanceof ThreadRef other)
+                    && this.thread == other.thread;
+        }
+    }
+
+    private final Set<ThreadRef> threads = ConcurrentHashMap.newKeySet();
+
+    /**
+     * Adds the current thread to thread set if not already in the set.
+     * Returns a key to remove the thread or {@code null} if already in the set.
+     */
+    public Object tryBegin() {
+        var threadRef = new ThreadRef(Thread.currentThread());
+        return threads.add(threadRef) ? threadRef : null;
+    }
+
+    /**
+     * Adds the current thread to thread set if not already in the set.
+     * Returns a key to remove the thread.
+     */
+    public Object begin() {
+        var threadRef = new ThreadRef(Thread.currentThread());
+        boolean added = threads.add(threadRef);
+        assert added;
+        return threadRef;
+    }
+
+    /**
+     * Removes the thread identified by the key from the thread set.
+     */
+    public void end(Object key) {
+        var threadRef = (ThreadRef) key;
+        assert threadRef.thread() == Thread.currentThread();
+        boolean removed = threads.remove(threadRef);
+        assert removed;
+    }
+
+    /**
+     * Returns true if the given thread is tracked.
+     */
+    public boolean contains(Thread thread) {
+        var threadRef = new ThreadRef(thread);
+        return threads.contains(threadRef);
+    }
+}
diff --git a/ojluni/src/main/java/jdk/internal/misc/Unsafe.java b/ojluni/src/main/java/jdk/internal/misc/Unsafe.java
index 6dee57142d7..9c28a872c70 100644
--- a/ojluni/src/main/java/jdk/internal/misc/Unsafe.java
+++ b/ojluni/src/main/java/jdk/internal/misc/Unsafe.java
@@ -3850,16 +3850,14 @@ public final class Unsafe {
      * Ensures that stores before the fence will not be reordered with
      * stores after the fence.
      *
-     * @implNote
-     * This method is operationally equivalent to {@link #storeFence()}.
-     *
      * @since 9
      */
+    @IntrinsicCandidate
     public final void storeStoreFence() {
+        // If storeStoreFence intrinsic is not available, fall back to storeFence.
         storeFence();
     }
 
-
     // BEGIN Android-removed: Not used in Android.
     /*
     /**
diff --git a/ojluni/src/main/java/jdk/internal/ref/CleanerFactory.java b/ojluni/src/main/java/jdk/internal/ref/CleanerFactory.java
index c6001a53351..91797be8f96 100644
--- a/ojluni/src/main/java/jdk/internal/ref/CleanerFactory.java
+++ b/ojluni/src/main/java/jdk/internal/ref/CleanerFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,6 +26,7 @@
 package jdk.internal.ref;
 
 import java.lang.ref.Cleaner;
+import java.util.concurrent.ThreadFactory;
 
 /**
  * CleanerFactory provides a Cleaner for use within system modules.
@@ -40,14 +41,8 @@ public final class CleanerFactory {
     private final static Cleaner commonCleaner = Cleaner.create(new ThreadFactory() {
         @Override
         public Thread newThread(Runnable r) {
-            return AccessController.doPrivileged(new PrivilegedAction<>() {
-                @Override
-                public Thread run() {
-                    Thread t = InnocuousThread.newSystemThread("Common-Cleaner", r);
-                    t.setPriority(Thread.MAX_PRIORITY - 2);
-                    return t;
-                }
-            });
+            return InnocuousThread.newSystemThread("Common-Cleaner",
+                    r, Thread.MAX_PRIORITY - 2);
         }
     });
     */
diff --git a/ojluni/src/main/java/jdk/internal/ref/CleanerImpl.java b/ojluni/src/main/java/jdk/internal/ref/CleanerImpl.java
index 88c476fcff8..4586b244a94 100644
--- a/ojluni/src/main/java/jdk/internal/ref/CleanerImpl.java
+++ b/ojluni/src/main/java/jdk/internal/ref/CleanerImpl.java
@@ -353,15 +353,8 @@ public final class CleanerImpl implements Runnable {
         final AtomicInteger cleanerThreadNumber = new AtomicInteger();
 
         public Thread newThread(Runnable r) {
-            return AccessController.doPrivileged(new PrivilegedAction<>() {
-                @Override
-                public Thread run() {
-                    Thread t = InnocuousThread.newThread(r);
-                    t.setPriority(Thread.MAX_PRIORITY - 2);
-                    t.setName("Cleaner-" + cleanerThreadNumber.getAndIncrement());
-                    return t;
-                }
-            });
+            return InnocuousThread.newThread("Cleaner-" + cleanerThreadNumber.getAndIncrement(),
+                r, Thread.MAX_PRIORITY - 2);
         }
     }
 
diff --git a/ojluni/src/main/java/jdk/internal/vm/ContinuationSupport.java b/ojluni/src/main/java/jdk/internal/vm/ContinuationSupport.java
new file mode 100644
index 00000000000..094348b343b
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/vm/ContinuationSupport.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.vm;
+
+/**
+ * Defines a static method to test if the VM has continuations support.
+ */
+public class ContinuationSupport {
+    // Android-changed: Android uses an aconfig flag.
+    //private static final boolean SUPPORTED = isSupported0();
+    private static final boolean SUPPORTED = com.android.art.flags.Flags.virtualThreadImplV1();
+
+    private ContinuationSupport() {
+    }
+
+    /**
+     * Return true if the VM has continuations support.
+     */
+    public static boolean isSupported() {
+        return SUPPORTED;
+    }
+
+    /**
+     * Ensures that VM has continuations support.
+     * @throws UnsupportedOperationException if not supported
+     */
+    public static void ensureSupported() {
+        if (!isSupported()) {
+            throw new UnsupportedOperationException("VM does not support continuations");
+        }
+    }
+
+    // Android-removed: Android uses an aconfig flag.
+    // private static native boolean isSupported0();
+}
diff --git a/ojluni/src/main/java/jdk/internal/vm/SharedThreadContainer.java b/ojluni/src/main/java/jdk/internal/vm/SharedThreadContainer.java
new file mode 100644
index 00000000000..01e0bac2316
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/vm/SharedThreadContainer.java
@@ -0,0 +1,165 @@
+/*
+ * Copyright (c) 2021, 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.vm;
+
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.VarHandle;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.stream.Stream;
+import jdk.internal.access.SharedSecrets;
+
+/**
+ * A "shared" thread container. A shared thread container doesn't have an owner
+ * and is intended for unstructured uses, e.g. thread pools.
+ */
+public class SharedThreadContainer extends ThreadContainer implements AutoCloseable {
+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    private static final VarHandle CLOSED;
+    private static final VarHandle VIRTUAL_THREADS;
+    static {
+        try {
+            MethodHandles.Lookup l = MethodHandles.lookup();
+            CLOSED = l.findVarHandle(SharedThreadContainer.class,
+                    "closed", boolean.class);
+            VIRTUAL_THREADS = l.findVarHandle(SharedThreadContainer.class,
+                    "virtualThreads", Set.class);
+        } catch (Exception e) {
+            throw new ExceptionInInitializerError(e);
+        }
+    }
+
+    // name of container, used by toString
+    private final String name;
+
+    // the virtual threads in the container, created lazily
+    private volatile Set<Thread> virtualThreads;
+
+    // the key for this container in the registry
+    private volatile Object key;
+
+    // set to true when the container is closed
+    private volatile boolean closed;
+
+    /**
+     * Initialize a new SharedThreadContainer.
+     * @param name the container name, can be null
+     */
+    private SharedThreadContainer(String name) {
+        super(/*shared*/ true);
+        this.name = name;
+    }
+
+    /**
+     * Creates a shared thread container with the given parent and name.
+     * @throws IllegalArgumentException if the parent has an owner.
+     */
+    public static SharedThreadContainer create(ThreadContainer parent, String name) {
+        if (parent.owner() != null)
+            throw new IllegalArgumentException("parent has owner");
+        var container = new SharedThreadContainer(name);
+        // register the container to allow discovery by serviceability tools
+        container.key = ThreadContainers.registerContainer(container);
+        return container;
+    }
+
+    /**
+     * Creates a shared thread container with the given name. Its parent will be
+     * the root thread container.
+     */
+    public static SharedThreadContainer create(String name) {
+        return create(ThreadContainers.root(), name);
+    }
+
+    @Override
+    public String name() {
+        return name;
+    }
+
+    @Override
+    public Thread owner() {
+        return null;
+    }
+
+    @Override
+    public void onStart(Thread thread) {
+        // virtual threads needs to be tracked
+        if (thread.isVirtual()) {
+            Set<Thread> vthreads = this.virtualThreads;
+            if (vthreads == null) {
+                vthreads = ConcurrentHashMap.newKeySet();
+                if (!VIRTUAL_THREADS.compareAndSet(this, null, vthreads)) {
+                    // lost the race
+                    vthreads = this.virtualThreads;
+                }
+            }
+            vthreads.add(thread);
+        }
+    }
+
+    @Override
+    public void onExit(Thread thread) {
+        if (thread.isVirtual())
+            virtualThreads.remove(thread);
+    }
+
+    @Override
+    public Stream<Thread> threads() {
+        // live platform threads in this container
+        Stream<Thread> platformThreads = Stream.of(JLA.getAllThreads())
+                .filter(t -> JLA.threadContainer(t) == this);
+        Set<Thread> vthreads = this.virtualThreads;
+        if (vthreads == null) {
+            // live platform threads only, no virtual threads
+            return platformThreads;
+        } else {
+            // all live threads in this container
+            return Stream.concat(platformThreads,
+                                 vthreads.stream().filter(Thread::isAlive));
+        }
+    }
+
+    /**
+     * Starts a thread in this container.
+     * @throws IllegalStateException if the container is closed
+     */
+    public void start(Thread thread) {
+        if (closed)
+            throw new IllegalStateException();
+        JLA.start(thread, this);
+    }
+
+    /**
+     * Closes this container. Further attempts to start a thread in this container
+     * throw IllegalStateException. This method has no impact on threads that are
+     * still running or starting around the time that this method is invoked.
+     */
+    @Override
+    public void close() {
+        if (!closed && CLOSED.compareAndSet(this, false, true)) {
+            ThreadContainers.deregisterContainer(key);
+        }
+    }
+}
diff --git a/ojluni/src/main/java/jdk/internal/vm/StackableScope.java b/ojluni/src/main/java/jdk/internal/vm/StackableScope.java
new file mode 100644
index 00000000000..8f5a840b6bf
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/vm/StackableScope.java
@@ -0,0 +1,260 @@
+/*
+ * Copyright (c) 2021, 2022, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.vm;
+
+import jdk.internal.access.SharedSecrets;
+import jdk.internal.vm.annotation.DontInline;
+import jdk.internal.vm.annotation.ReservedStackAccess;
+
+/**
+ * A stackable scope to support structured constructs. The push method is used to
+ * push a StackableScope to the current thread's scope stack. The tryPop and
+ * popForcefully methods are used to pop the StackableScope from the current thread's
+ * scope stack.
+ */
+public class StackableScope {
+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+
+    private final Thread owner;
+    private volatile StackableScope previous;
+
+    /**
+     * Creates a stackable scope.
+     * @param shared true for a shared scope that cannot be pushed to the stack,
+     * false for scope that is owned by the current thread
+     */
+    StackableScope(boolean shared) {
+        if (shared) {
+            this.owner = null;
+        } else {
+            this.owner = Thread.currentThread();
+        }
+    }
+
+    /**
+     * Creates a stackable scope owned by the current thread.
+     */
+    protected StackableScope() {
+        this(false);
+    }
+
+    /**
+     * Returns the scope owner or null if not owned.
+     */
+    public Thread owner() {
+        return owner;
+    }
+
+    /**
+     * Pushes this scope onto the current thread's scope stack.
+     * @throws WrongThreadException it the current thread is not the owner
+     */
+    public StackableScope push() {
+        if (Thread.currentThread() != owner)
+            throw new WrongThreadException("Not owner");
+        previous = head();
+        setHead(this);
+        return this;
+    }
+
+    /**
+     * Pops this scope from the current thread's scope stack if the scope is
+     * at the top of stack.
+     * @return true if the pop succeeded, false if this scope is not the top of stack
+     * @throws WrongThreadException it the current thread is not the owner
+     */
+    @DontInline @ReservedStackAccess
+    public boolean tryPop() {
+        if (Thread.currentThread() != owner)
+            throw new WrongThreadException("Not owner");
+        if (head() == this) {
+            setHead(previous);
+            previous = null;
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Pops this scope from the current thread's scope stack.
+     *
+     * For well-behaved usages, this scope is at the top of the stack. It is popped
+     * from the stack and the method returns {@code true}.
+     *
+     * If this scope is not at the top of the stack then this method attempts to
+     * close each of the intermediate scopes by invoking their {@link #tryClose()}
+     * method. If tryClose succeeds then the scope is removed from the stack. When
+     * done, this scope is removed from the stack and {@code false} is returned.
+     *
+     * This method does nothing, and returns {@code false}, if this scope is not
+     * on the current thread's scope stack.
+     *
+     * @return true if this scope was at the top of the stack, otherwise false
+     * @throws WrongThreadException it the current thread is not the owner
+     */
+    @DontInline @ReservedStackAccess
+    public boolean popForcefully() {
+        if (Thread.currentThread() != owner)
+            throw new WrongThreadException("Not owner");
+        final StackableScope head = head();
+        if (head == this) {
+            setHead(previous);
+            previous = null;
+            return true;
+        }
+
+        // scope is not the top of stack
+        if (contains(this)) {
+            StackableScope current = head;
+            while (current != this) {
+                StackableScope previous = current.previous();
+                // attempt to forcefully close the scope and remove from stack
+                if (current.tryClose()) {
+                    current.unlink();
+                }
+                current = previous;
+            }
+            unlink();
+        }
+        return false;
+    }
+
+    /**
+     * Pops all scopes from the current thread's scope stack.
+     */
+    public static void popAll() {
+        StackableScope head = head();
+        if (head != null) {
+            StackableScope current = head;
+            while (current != null) {
+                assert Thread.currentThread() == current.owner();
+                current.tryClose();
+                current = current.previous();
+            }
+            setHead(null);
+        }
+    }
+
+    /**
+     * Returns the scope that encloses this scope.
+     */
+    public StackableScope enclosingScope() {
+        StackableScope previous = this.previous;
+        if (previous != null)
+            return previous;
+        if (owner != null)
+            return JLA.threadContainer(owner);
+        return null;
+    }
+
+    /**
+     * Returns the scope of the given type that encloses this scope.
+     */
+    public <T extends StackableScope> T enclosingScope(Class<T> type) {
+        StackableScope current = enclosingScope();
+        while (current != null) {
+            if (type.isInstance(current)) {
+                @SuppressWarnings("unchecked")
+                T tmp = (T) current;
+                return tmp;
+            }
+            current = current.enclosingScope();
+        }
+        return null;
+    }
+
+    /**
+     * Returns the scope that directly encloses this scope, null if none.
+     */
+    StackableScope previous() {
+        return previous;
+    }
+
+    /**
+     * Returns the scope that this scope directly encloses, null if none.
+     */
+    private StackableScope next() {
+        assert contains(this);
+        StackableScope current = head();
+        StackableScope next = null;
+        while (current != this) {
+            next = current;
+            current = current.previous();
+        }
+        return next;
+    }
+
+    /**
+     * Override this method to close this scope and release its resources.
+     * This method should not pop the scope from the stack.
+     * This method is guaranteed to execute on the owner thread.
+     * @return true if this method closed the scope, false if it failed
+     */
+    protected boolean tryClose() {
+        assert Thread.currentThread() == owner;
+        return false;
+    }
+
+    /**
+     * Removes this scope from the current thread's scope stack.
+     */
+    private void unlink() {
+        assert contains(this);
+        StackableScope next = next();
+        if (next == null) {
+            setHead(previous);
+        } else {
+            next.previous = previous;
+        }
+        previous = null;
+    }
+
+    /**
+     * Returns true if the given scope is on the current thread's scope stack.
+     */
+    private static boolean contains(StackableScope scope) {
+        assert scope != null;
+        StackableScope current = head();
+        while (current != null && current != scope) {
+            current = current.previous();
+        }
+        return (current == scope);
+    }
+
+    /**
+     * Returns the head of the current thread's scope stack.
+     */
+    static StackableScope head() {
+        return JLA.headStackableScope(Thread.currentThread());
+    }
+
+    /**
+     * Sets the head (top) of the current thread's scope stack.
+     */
+    private static void setHead(StackableScope scope) {
+        JLA.setHeadStackableScope(scope);
+    }
+}
diff --git a/ojluni/src/main/java/jdk/internal/vm/ThreadContainer.java b/ojluni/src/main/java/jdk/internal/vm/ThreadContainer.java
new file mode 100644
index 00000000000..297dd913ca5
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/vm/ThreadContainer.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2021, 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.vm;
+
+import java.util.Objects;
+import java.util.stream.Stream;
+
+/**
+ * A container of threads.
+ */
+public abstract class ThreadContainer extends StackableScope {
+
+    /**
+     * Creates a ThreadContainer.
+     * @param shared true for a shared container, false for a container
+     * owned by the current thread
+     */
+    protected ThreadContainer(boolean shared) {
+        super(shared);
+    }
+
+    /**
+     * Return the name of this container, may be null.
+     */
+    public String name() {
+        return null;
+    }
+
+    /**
+     * Returns the parent of this container or null if this is the root container.
+     */
+    public ThreadContainer parent() {
+        return ThreadContainers.parent(this);
+    }
+
+    /**
+     * Return the stream of children of this container.
+     */
+    public final Stream<ThreadContainer> children() {
+        return ThreadContainers.children(this);
+    }
+
+    /**
+     * Return a count of the number of threads in this container.
+     */
+    public long threadCount() {
+        return threads().mapToLong(e -> 1L).sum();
+    }
+
+    /**
+     * Returns a stream of the live threads in this container.
+     */
+    public abstract Stream<Thread> threads();
+
+    /**
+     * Invoked by Thread::start before the given Thread is started.
+     */
+    public void onStart(Thread thread) {
+        // do nothing
+    }
+
+    /**
+     * Invoked when a Thread terminates or starting it fails.
+     *
+     * For a platform thread, this method is invoked by the thread itself when it
+     * terminates. For a virtual thread, this method is invoked on its carrier
+     * after the virtual thread has terminated.
+     *
+     * If starting the Thread failed then this method is invoked on the thread
+     * that invoked onStart.
+     */
+    public void onExit(Thread thread) {
+        // do nothing
+    }
+
+    // Android-removed: Remove it until ScopedValue is supported.
+    /*
+    /**
+     * The scoped values captured when the thread container was created.
+     * /
+    public ScopedValueContainer.BindingsSnapshot scopedValueBindings() {
+        return null;
+    }
+    */
+
+    @Override
+    public String toString() {
+        String name = name();
+        if (name != null && name.indexOf('@') >= 0) {
+            return name;
+        } else {
+            String id = Objects.toIdentityString(this);
+            return (name != null) ? name + "/" + id : id;
+        }
+    }
+}
diff --git a/ojluni/src/main/java/jdk/internal/vm/ThreadContainers.java b/ojluni/src/main/java/jdk/internal/vm/ThreadContainers.java
new file mode 100644
index 00000000000..8dcd6281dcc
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/vm/ThreadContainers.java
@@ -0,0 +1,292 @@
+/*
+ * Copyright (c) 2021, 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.vm;
+
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.WeakReference;
+import java.util.Optional;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.LongAdder;
+import java.util.stream.Stream;
+import jdk.internal.access.SharedSecrets;
+import sun.security.action.GetPropertyAction;
+
+/**
+ * This class consists exclusively of static methods to support groupings of threads.
+ */
+public class ThreadContainers {
+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+
+    // true if all threads are tracked
+    private static final boolean TRACK_ALL_THREADS;
+
+    // the root container
+    private static final RootContainer ROOT_CONTAINER;
+
+    // the set of thread containers registered with this class
+    private static final Set<WeakReference<ThreadContainer>> CONTAINER_REGISTRY = ConcurrentHashMap.newKeySet();
+    private static final ReferenceQueue<Object> QUEUE = new ReferenceQueue<>();
+
+    static {
+        String s = GetPropertyAction.privilegedGetProperty("jdk.trackAllThreads");
+        if (s == null || s.isEmpty() || Boolean.parseBoolean(s)) {
+            TRACK_ALL_THREADS = true;
+            ROOT_CONTAINER = new RootContainer.TrackingRootContainer();
+        } else {
+            TRACK_ALL_THREADS = false;
+            ROOT_CONTAINER = new RootContainer.CountingRootContainer();
+        }
+    }
+
+    private ThreadContainers() { }
+
+    /**
+     * Expunge stale entries from the container registry.
+     */
+    private static void expungeStaleEntries() {
+        Object key;
+        while ((key = QUEUE.poll()) != null) {
+            CONTAINER_REGISTRY.remove(key);
+        }
+    }
+
+    /**
+     * Returns true if all threads are tracked.
+     */
+    public static boolean trackAllThreads() {
+        return TRACK_ALL_THREADS;
+    }
+
+    /**
+     * Registers a thread container to be tracked this class, returning a key
+     * that is used to remove it from the registry.
+     */
+    public static Object registerContainer(ThreadContainer container) {
+        expungeStaleEntries();
+        var ref = new WeakReference<>(container, QUEUE);
+        CONTAINER_REGISTRY.add(ref);
+        return ref;
+    }
+
+    /**
+     * Removes a thread container from being tracked by specifying the key
+     * returned when the thread container was registered.
+     */
+    public static void deregisterContainer(Object key) {
+        assert key instanceof WeakReference;
+        CONTAINER_REGISTRY.remove(key);
+    }
+
+    /**
+     * Returns the root thread container.
+     */
+    public static ThreadContainer root() {
+        return ROOT_CONTAINER;
+    }
+
+    /**
+     * Returns the parent of the given thread container.
+     *
+     * If the container has an owner then its parent is the enclosing container when
+     * nested, or the container that the owner is in, when not nested.
+     *
+     * If the container does not have an owner then the root container is returned,
+     * or null if called with the root container.
+     */
+    static ThreadContainer parent(ThreadContainer container) {
+        Thread owner = container.owner();
+        if (owner != null) {
+            ThreadContainer parent = container.enclosingScope(ThreadContainer.class);
+            if (parent != null)
+                return parent;
+            if ((parent = container(owner)) != null)
+                return parent;
+        }
+        ThreadContainer root = root();
+        return (container != root) ? root : null;
+    }
+
+    /**
+     * Returns given thread container's "children".
+     */
+    static Stream<ThreadContainer> children(ThreadContainer container) {
+        // children of registered containers
+        Stream<ThreadContainer> s1 = CONTAINER_REGISTRY.stream()
+                .map(WeakReference::get)
+                .filter(c -> c != null && c.parent() == container);
+
+        // container may enclose another container
+        Stream<ThreadContainer> s2 = Stream.empty();
+        if (container.owner() != null) {
+            ThreadContainer next = next(container);
+            if (next != null)
+                s2 = Stream.of(next);
+        }
+
+        // the top-most container owned by the threads in the container
+        Stream<ThreadContainer> s3 = container.threads()
+                .map(t -> Optional.ofNullable(top(t)))
+                .flatMap(Optional::stream);
+
+        return Stream.concat(s1, Stream.concat(s2, s3));
+    }
+
+    /**
+     * Returns the thread container that the given Thread is in or the root
+     * container if not started in a container.
+     * @throws IllegalStateException if the thread has not been started
+     */
+    public static ThreadContainer container(Thread thread) {
+        // thread container is set when the thread is started
+        if (thread.isAlive() || thread.getState() == Thread.State.TERMINATED) {
+            ThreadContainer container = JLA.threadContainer(thread);
+            return (container != null) ? container : root();
+        } else {
+            throw new IllegalStateException("Thread not started");
+        }
+    }
+
+    /**
+     * Returns the top-most thread container owned by the given thread.
+     */
+    private static ThreadContainer top(Thread thread) {
+        StackableScope current = JLA.headStackableScope(thread);
+        ThreadContainer top = null;
+        while (current != null) {
+            if (current instanceof ThreadContainer tc) {
+                top = tc;
+            }
+            current = current.previous();
+        }
+        return top;
+    }
+
+    /**
+     * Returns the thread container that the given thread container encloses.
+     */
+    private static ThreadContainer next(ThreadContainer container) {
+        StackableScope current = JLA.headStackableScope(container.owner());
+        if (current != null) {
+            ThreadContainer next = null;
+            while (current != null) {
+                if (current == container) {
+                    return next;
+                } else if (current instanceof ThreadContainer tc) {
+                    next = tc;
+                }
+                current = current.previous();
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Root container that "contains" all platform threads not started in a container.
+     * It may include all virtual threads started directly with the Thread API.
+     */
+    private static abstract class RootContainer extends ThreadContainer {
+        protected RootContainer() {
+            super(true);
+        }
+        @Override
+        public ThreadContainer parent() {
+            return null;
+        }
+        @Override
+        public String name() {
+            return "<root>";
+        }
+        @Override
+        public StackableScope previous() {
+            return null;
+        }
+        @Override
+        public String toString() {
+            return name();
+        }
+
+        /**
+         * Returns the platform threads that are not in the container as these
+         * threads are considered to be in the root container.
+         */
+        protected Stream<Thread> platformThreads() {
+            return Stream.of(JLA.getAllThreads())
+                    .filter(t -> JLA.threadContainer(t) == null);
+        }
+
+        /**
+         * Root container that tracks all threads.
+         */
+        private static class TrackingRootContainer extends RootContainer {
+            private static final Set<Thread> VTHREADS = ConcurrentHashMap.newKeySet();
+            @Override
+            public void onStart(Thread thread) {
+                assert thread.isVirtual();
+                VTHREADS.add(thread);
+            }
+            @Override
+            public void onExit(Thread thread) {
+                assert thread.isVirtual();
+                VTHREADS.remove(thread);
+            }
+            @Override
+            public long threadCount() {
+                return platformThreads().count() + VTHREADS.size();
+            }
+            @Override
+            public Stream<Thread> threads() {
+                return Stream.concat(platformThreads(),
+                                     VTHREADS.stream().filter(Thread::isAlive));
+            }
+        }
+
+        /**
+         * Root container that tracks all platform threads and just keeps a
+         * count of the virtual threads.
+         */
+        private static class CountingRootContainer extends RootContainer {
+            private static final LongAdder VTHREAD_COUNT = new LongAdder();
+            @Override
+            public void onStart(Thread thread) {
+                assert thread.isVirtual();
+                VTHREAD_COUNT.add(1L);
+            }
+            @Override
+            public void onExit(Thread thread) {
+                assert thread.isVirtual();
+                VTHREAD_COUNT.add(-1L);
+            }
+            @Override
+            public long threadCount() {
+                return platformThreads().count() + VTHREAD_COUNT.sum();
+            }
+            @Override
+            public Stream<Thread> threads() {
+                return platformThreads();
+            }
+        }
+    }
+}
diff --git a/ojluni/src/main/java/jdk/internal/vm/ThreadDumper.java b/ojluni/src/main/java/jdk/internal/vm/ThreadDumper.java
new file mode 100644
index 00000000000..5318a3f0d19
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/vm/ThreadDumper.java
@@ -0,0 +1,379 @@
+/*
+ * Copyright (c) 2020, 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.vm;
+
+import android.system.Os;
+
+import java.io.BufferedOutputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.PrintStream;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.FileAlreadyExistsException;
+import java.nio.file.Files;
+import java.nio.file.OpenOption;
+import java.nio.file.Path;
+import java.nio.file.StandardOpenOption;
+import java.time.Instant;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ * Thread dump support.
+ *
+ * This class defines methods to dump threads to an output stream or file in plain
+ * text or JSON format.
+ */
+public class ThreadDumper {
+    private ThreadDumper() { }
+
+    // the maximum byte array to return when generating the thread dump to a byte array
+    private static final int MAX_BYTE_ARRAY_SIZE = 16_000;
+
+    /**
+     * Generate a thread dump in plain text format to a byte array or file, UTF-8 encoded.
+     *
+     * This method is invoked by the VM for the Thread.dump_to_file diagnostic command.
+     *
+     * @param file the file path to the file, null or "-" to return a byte array
+     * @param okayToOverwrite true to overwrite an existing file
+     * @return the UTF-8 encoded thread dump or message to return to the user
+     */
+    public static byte[] dumpThreads(String file, boolean okayToOverwrite) {
+        if (file == null || file.equals("-")) {
+            return dumpThreadsToByteArray(false, MAX_BYTE_ARRAY_SIZE);
+        } else {
+            return dumpThreadsToFile(file, okayToOverwrite, false);
+        }
+    }
+
+    /**
+     * Generate a thread dump in JSON format to a byte array or file, UTF-8 encoded.
+     *
+     * This method is invoked by the VM for the Thread.dump_to_file diagnostic command.
+     *
+     * @param file the file path to the file, null or "-" to return a byte array
+     * @param okayToOverwrite true to overwrite an existing file
+     * @return the UTF-8 encoded thread dump or message to return to the user
+     */
+    public static byte[] dumpThreadsToJson(String file, boolean okayToOverwrite) {
+        if (file == null || file.equals("-")) {
+            return dumpThreadsToByteArray(true, MAX_BYTE_ARRAY_SIZE);
+        } else {
+            return dumpThreadsToFile(file, okayToOverwrite, true);
+        }
+    }
+
+    /**
+     * Generate a thread dump in plain text or JSON format to a byte array, UTF-8 encoded.
+     */
+    private static byte[] dumpThreadsToByteArray(boolean json, int maxSize) {
+        try (var out = new BoundedByteArrayOutputStream(maxSize);
+             PrintStream ps = new PrintStream(out, true, StandardCharsets.UTF_8)) {
+            if (json) {
+                dumpThreadsToJson(ps);
+            } else {
+                dumpThreads(ps);
+            }
+            return out.toByteArray();
+        }
+    }
+
+    /**
+     * Generate a thread dump in plain text or JSON format to the given file, UTF-8 encoded.
+     */
+    private static byte[] dumpThreadsToFile(String file, boolean okayToOverwrite, boolean json) {
+        Path path = Path.of(file).toAbsolutePath();
+        OpenOption[] options = (okayToOverwrite)
+                ? new OpenOption[0]
+                : new OpenOption[] { StandardOpenOption.CREATE_NEW };
+        String reply;
+        try (OutputStream out = Files.newOutputStream(path, options);
+             BufferedOutputStream bos = new BufferedOutputStream(out);
+             PrintStream ps = new PrintStream(bos, false, StandardCharsets.UTF_8)) {
+            if (json) {
+                dumpThreadsToJson(ps);
+            } else {
+                dumpThreads(ps);
+            }
+            reply = String.format("Created %s%n", path);
+        } catch (FileAlreadyExistsException e) {
+            reply = String.format("%s exists, use -overwrite to overwrite%n", path);
+        } catch (IOException ioe) {
+            reply = String.format("Failed: %s%n", ioe);
+        }
+        return reply.getBytes(StandardCharsets.UTF_8);
+    }
+
+    /**
+     * Generate a thread dump in plain text format to the given output stream,
+     * UTF-8 encoded.
+     *
+     * This method is invoked by HotSpotDiagnosticMXBean.dumpThreads.
+     */
+    public static void dumpThreads(OutputStream out) {
+        BufferedOutputStream bos = new BufferedOutputStream(out);
+        PrintStream ps = new PrintStream(bos, false, StandardCharsets.UTF_8);
+        try {
+            dumpThreads(ps);
+        } finally {
+            ps.flush();  // flushes underlying stream
+        }
+    }
+
+    /**
+     * Generate a thread dump in plain text format to the given print stream.
+     */
+    private static void dumpThreads(PrintStream ps) {
+        ps.println(processId());
+        ps.println(Instant.now());
+        // Android-changed: Android doesn't have Runtime.version() yet.
+        // ps.println(Runtime.version());
+        ps.println();
+        dumpThreads(ThreadContainers.root(), ps);
+    }
+
+    private static void dumpThreads(ThreadContainer container, PrintStream ps) {
+        container.threads().forEach(t -> dumpThread(t, ps));
+        container.children().forEach(c -> dumpThreads(c, ps));
+    }
+
+    private static void dumpThread(Thread thread, PrintStream ps) {
+        String suffix = thread.isVirtual() ? " virtual" : "";
+        ps.println("#" + thread.threadId() + " \"" + thread.getName() + "\"" + suffix);
+        for (StackTraceElement ste : thread.getStackTrace()) {
+            ps.print("      ");
+            ps.println(ste);
+        }
+        ps.println();
+    }
+
+    /**
+     * Generate a thread dump in JSON format to the given output stream, UTF-8 encoded.
+     *
+     * This method is invoked by HotSpotDiagnosticMXBean.dumpThreads.
+     */
+    public static void dumpThreadsToJson(OutputStream out) {
+        BufferedOutputStream bos = new BufferedOutputStream(out);
+        PrintStream ps = new PrintStream(bos, false, StandardCharsets.UTF_8);
+        try {
+            dumpThreadsToJson(ps);
+        } finally {
+            ps.flush();  // flushes underlying stream
+        }
+    }
+
+    /**
+     * Generate a thread dump to the given print stream in JSON format.
+     */
+    private static void dumpThreadsToJson(PrintStream out) {
+        out.println("{");
+        out.println("  \"threadDump\": {");
+
+        String now = Instant.now().toString();
+        // Android-changed: Android doesn't have Runtime.version() yet.
+        // String runtimeVersion = Runtime.version().toString();
+        out.format("    \"processId\": \"%d\",%n", processId());
+        out.format("    \"time\": \"%s\",%n", escape(now));
+        // Android-changed: Android doesn't have Runtime.version() yet.
+        // out.format("    \"runtimeVersion\": \"%s\",%n", escape(runtimeVersion));
+
+        out.println("    \"threadContainers\": [");
+        List<ThreadContainer> containers = allContainers();
+        Iterator<ThreadContainer> iterator = containers.iterator();
+        while (iterator.hasNext()) {
+            ThreadContainer container = iterator.next();
+            boolean more = iterator.hasNext();
+            dumpThreadsToJson(container, out, more);
+        }
+        out.println("    ]");   // end of threadContainers
+
+        out.println("  }");   // end threadDump
+        out.println("}");  // end object
+    }
+
+    /**
+     * Dump the given thread container to the print stream in JSON format.
+     */
+    private static void dumpThreadsToJson(ThreadContainer container,
+                                          PrintStream out,
+                                          boolean more) {
+        out.println("      {");
+        out.format("        \"container\": \"%s\",%n", escape(container.toString()));
+
+        ThreadContainer parent = container.parent();
+        if (parent == null) {
+            out.format("        \"parent\": null,%n");
+        } else {
+            out.format("        \"parent\": \"%s\",%n", escape(parent.toString()));
+        }
+
+        Thread owner = container.owner();
+        if (owner == null) {
+            out.format("        \"owner\": null,%n");
+        } else {
+            out.format("        \"owner\": \"%d\",%n", owner.threadId());
+        }
+
+        long threadCount = 0;
+        out.println("        \"threads\": [");
+        Iterator<Thread> threads = container.threads().iterator();
+        while (threads.hasNext()) {
+            Thread thread = threads.next();
+            dumpThreadToJson(thread, out, threads.hasNext());
+            threadCount++;
+        }
+        out.println("        ],");   // end of threads
+
+        // thread count
+        if (!ThreadContainers.trackAllThreads()) {
+            threadCount = Long.max(threadCount, container.threadCount());
+        }
+        out.format("        \"threadCount\": \"%d\"%n", threadCount);
+
+        if (more) {
+            out.println("      },");
+        } else {
+            out.println("      }");  // last container, no trailing comma
+        }
+    }
+
+    /**
+     * Dump the given thread and its stack trace to the print stream in JSON format.
+     */
+    private static void dumpThreadToJson(Thread thread, PrintStream out, boolean more) {
+        out.println("         {");
+        out.println("           \"tid\": \"" + thread.threadId() + "\",");
+        out.println("           \"name\": \"" + escape(thread.getName()) + "\",");
+        out.println("           \"stack\": [");
+
+        int i = 0;
+        StackTraceElement[] stackTrace = thread.getStackTrace();
+        while (i < stackTrace.length) {
+            out.print("              \"");
+            out.print(escape(stackTrace[i].toString()));
+            out.print("\"");
+            i++;
+            if (i < stackTrace.length) {
+                out.println(",");
+            } else {
+                out.println();  // last element, no trailing comma
+            }
+        }
+        out.println("           ]");
+        if (more) {
+            out.println("         },");
+        } else {
+            out.println("         }");  // last thread, no trailing comma
+        }
+    }
+
+    /**
+     * Returns a list of all thread containers that are "reachable" from
+     * the root container.
+     */
+    private static List<ThreadContainer> allContainers() {
+        List<ThreadContainer> containers = new ArrayList<>();
+        collect(ThreadContainers.root(), containers);
+        return containers;
+    }
+
+    private static void collect(ThreadContainer container, List<ThreadContainer> containers) {
+        containers.add(container);
+        container.children().forEach(c -> collect(c, containers));
+    }
+
+    /**
+     * Escape any characters that need to be escape in the JSON output.
+     */
+    private static String escape(String value) {
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < value.length(); i++) {
+            char c = value.charAt(i);
+            switch (c) {
+                case '"'  -> sb.append("\\\"");
+                case '\\' -> sb.append("\\\\");
+                case '/'  -> sb.append("\\/");
+                case '\b' -> sb.append("\\b");
+                case '\f' -> sb.append("\\f");
+                case '\n' -> sb.append("\\n");
+                case '\r' -> sb.append("\\r");
+                case '\t' -> sb.append("\\t");
+                default -> {
+                    if (c <= 0x1f) {
+                        // Android-changed: Cast to short to suppress FormatString ErrorProne error.
+                        // sb.append(String.format("\\u%04x", c));
+                        sb.append(String.format("\\u%04x", (short) c));
+                    } else {
+                        sb.append(c);
+                    }
+                }
+            }
+        }
+        return sb.toString();
+    }
+
+    /**
+     * A ByteArrayOutputStream of bounded size. Once the maximum number of bytes is
+     * written the subsequent bytes are discarded.
+     */
+    private static class BoundedByteArrayOutputStream extends ByteArrayOutputStream {
+        final int max;
+        BoundedByteArrayOutputStream(int max) {
+            this.max = max;
+        }
+        @Override
+        public void write(int b) {
+            if (max < count) {
+                super.write(b);
+            }
+        }
+        @Override
+        public void write(byte[] b, int off, int len) {
+            int remaining = max - count;
+            if (remaining > 0) {
+                super.write(b, off, Integer.min(len, remaining));
+            }
+        }
+        @Override
+        public void close() {
+        }
+    }
+
+    /**
+     * Returns the process ID or -1 if not supported.
+     */
+    private static long processId() {
+        try {
+            // Android-changed: Use Os.getpid() until ProcessHandle is imported. b/256576547
+            // return ProcessHandle.current().pid();
+            return Os.getpid();
+        } catch (UnsupportedOperationException e) {
+            return -1L;
+        }
+    }
+}
diff --git a/ojluni/src/main/java/jdk/internal/vm/annotation/ChangesCurrentThread.java b/ojluni/src/main/java/jdk/internal/vm/annotation/ChangesCurrentThread.java
new file mode 100644
index 00000000000..b7cf92f1055
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/vm/annotation/ChangesCurrentThread.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2020, 2022, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.vm.annotation;
+
+import java.lang.annotation.*;
+
+/**
+ * A method or constructor must be annotated as "changes current
+ * thread" if it calls Thread.setCurrentThread. This annotation also
+ * disables inlining for the method to which it is applied unless the
+ * method being inlined into is also annotated ChangesCurrentThread.
+
+ * @implNote
+ * This annotation only takes effect for methods or constructors of classes
+ * loaded by the boot loader.  Annotations on methods or constructors of classes
+ * loaded outside of the boot loader are ignored.
+ */
+@Target({ElementType.METHOD, ElementType.CONSTRUCTOR})
+@Retention(RetentionPolicy.RUNTIME)
+public @interface ChangesCurrentThread {
+}
diff --git a/ojluni/src/main/java/jdk/internal/vm/annotation/JvmtiMountTransition.java b/ojluni/src/main/java/jdk/internal/vm/annotation/JvmtiMountTransition.java
new file mode 100644
index 00000000000..df0545e46b1
--- /dev/null
+++ b/ojluni/src/main/java/jdk/internal/vm/annotation/JvmtiMountTransition.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2021, 2022, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.vm.annotation;
+
+import java.lang.annotation.*;
+
+/**
+ * A method is annotated as "jvmti mount transition" if it starts
+ * or ends virtual thread mount state transition (VTMS transition).
+ *
+ * @implNote
+ * This annotation is only used for VirtualThread methods.
+ */
+@Target({ElementType.METHOD})
+@Retention(RetentionPolicy.RUNTIME)
+public @interface JvmtiMountTransition {
+}
diff --git a/ojluni/src/main/java/sun/misc/Unsafe.java b/ojluni/src/main/java/sun/misc/Unsafe.java
index 6e8d1b358be..987034bdbd0 100644
--- a/ojluni/src/main/java/sun/misc/Unsafe.java
+++ b/ojluni/src/main/java/sun/misc/Unsafe.java
@@ -25,7 +25,10 @@
 
 package sun.misc;
 
+import dalvik.annotation.compat.VersionCodes;
 import dalvik.annotation.optimization.FastNative;
+import dalvik.system.VMRuntime;
+
 import jdk.internal.vm.annotation.IntrinsicCandidate;
 import sun.reflect.Reflection;
 
@@ -45,6 +48,7 @@ public final class Unsafe {
     private static final Unsafe THE_ONE = new Unsafe();
 
     private static final Unsafe theUnsafe = THE_ONE;
+    private static final jdk.internal.misc.Unsafe theInternalUnsafe = jdk.internal.misc.Unsafe.getUnsafe();
     public static final int INVALID_FIELD_OFFSET   = -1;
 
     /**
@@ -70,19 +74,37 @@ public final class Unsafe {
         return THE_ONE;
     }
 
+    // Android-added: allow existing apps to get offset of record fields for compat purposes.
+    private static boolean forbidObtainingRecordFieldOffsets() {
+        return VMRuntime.getSdkVersion() > VersionCodes.BAKLAVA &&
+                VMRuntime.getRuntime().getTargetSdkVersion() > VersionCodes.BAKLAVA;
+    }
+
     /**
      * Gets the raw byte offset from the start of an object's memory to
      * the memory used to store the indicated instance field.
      *
-     * @param field non-{@code null}; the field in question, which must be an
+     * @param f non-{@code null}; the field in question, which must be an
      * instance field
      * @return the offset to the field
      */
-    public long objectFieldOffset(Field field) {
-        if (Modifier.isStatic(field.getModifiers())) {
+    public long objectFieldOffset(Field f) {
+        if (f == null) {
+            throw new NullPointerException();
+        }
+        Class<?> declaringClass = f.getDeclaringClass();
+        if (Modifier.isStatic(f.getModifiers())) {
             throw new IllegalArgumentException("valid for instance fields only");
         }
-        return field.getOffset();
+        if (declaringClass.isHidden()) {
+            throw new UnsupportedOperationException("can't get field offset on a hidden class: " + f);
+        }
+        // Android-changed: compat check added.
+        // if (declaringClass.isRecord()) {
+        if (forbidObtainingRecordFieldOffsets() && declaringClass.isRecord()) {
+            throw new UnsupportedOperationException("can't get field offset on a record class: " + f);
+        }
+        return theInternalUnsafe.objectFieldOffset(f);
     }
 
     /**
diff --git a/ojluni/src/main/java/sun/nio/ByteBuffered.java b/ojluni/src/main/java/sun/nio/ByteBuffered.java
index a09621bbff4..6a016419ee4 100644
--- a/ojluni/src/main/java/sun/nio/ByteBuffered.java
+++ b/ojluni/src/main/java/sun/nio/ByteBuffered.java
@@ -29,11 +29,11 @@ import java.nio.ByteBuffer;
 import java.io.IOException;
 
 /** This is an interface to adapt existing APIs to use {@link java.nio.ByteBuffer
- *  <tt>ByteBuffers</tt>} as the underlying
+ *  ByteBuffers} as the underlying
  *  data format.  Only the initial producer and final consumer have to be changed.<p>
  *
- *  For example, the Zip/Jar code supports {@link java.io.InputStream <tt>InputStreams</tt>}.
- *  To make the Zip code use {@link java.nio.MappedByteBuffer <tt>MappedByteBuffers</tt>} as
+ *  For example, the Zip/Jar code supports {@link java.io.InputStream InputStreams}.
+ *  To make the Zip code use {@link java.nio.MappedByteBuffer MappedByteBuffers} as
  *  the underlying data structure, it can create a class of InputStream that wraps the ByteBuffer,
  *  and implements the ByteBuffered interface. A co-operating class several layers
  *  away can ask the InputStream if it is an instance of ByteBuffered, then
@@ -42,12 +42,12 @@ import java.io.IOException;
 public interface ByteBuffered {
 
      /**
-     * Returns the <tt>ByteBuffer</tt> behind this object, if this particular
-     * instance has one. An implementation of <tt>getByteBuffer()</tt> is allowed
-     * to return <tt>null</tt> for any reason.
+     * Returns the {@code ByteBuffer} behind this object, if this particular
+     * instance has one. An implementation of {@code getByteBuffer()} is allowed
+     * to return {@code null} for any reason.
      *
-     * @return  The <tt>ByteBuffer</tt>, if this particular instance has one,
-     *          or <tt>null</tt> otherwise.
+     * @return  The {@code ByteBuffer}, if this particular instance has one,
+     *          or {@code null} otherwise.
      *
      * @throws  IOException
      *          If the ByteBuffer is no longer valid.
diff --git a/ojluni/src/main/java/sun/nio/ch/FileChannelImpl.java b/ojluni/src/main/java/sun/nio/ch/FileChannelImpl.java
index 8a800fac746..7ad5881a0bf 100644
--- a/ojluni/src/main/java/sun/nio/ch/FileChannelImpl.java
+++ b/ojluni/src/main/java/sun/nio/ch/FileChannelImpl.java
@@ -130,6 +130,12 @@ public class FileChannelImpl
             throw new ClosedChannelException();
     }
 
+    // Android-added: Cherry-pick this unimplemented method from OpenJDK 11.
+    public void setUninterruptible() {
+        // TODO: Implement this method when FileChannelImpl is updated to 11.
+        //uninterruptible = true;
+    }
+
 
     // -- Standard channel operations --
 
diff --git a/ojluni/src/main/java/sun/nio/cs/StreamDecoder.java b/ojluni/src/main/java/sun/nio/cs/StreamDecoder.java
index 3c71a794932..e250208e385 100644
--- a/ojluni/src/main/java/sun/nio/cs/StreamDecoder.java
+++ b/ojluni/src/main/java/sun/nio/cs/StreamDecoder.java
@@ -33,6 +33,7 @@ import java.io.*;
 import java.nio.*;
 import java.nio.channels.*;
 import java.nio.charset.*;
+import java.util.Arrays;
 
 public class StreamDecoder extends Reader
 {
@@ -177,8 +178,14 @@ public class StreamDecoder extends Reader
                 cbuf[off] = (char)c;
                 return n + 1;
             }
-
-            return n + implRead(cbuf, off, off + len);
+            // Android-changed: Cherry-pick the fix for JDK-8287003
+            // Read remaining characters
+            int nr = implRead(cbuf, off, off + len);
+
+            // At this point, n is either 1 if a leftover character was read,
+            // or 0 if no leftover character was read. If n is 1 and nr is -1,
+            // indicating EOF, then we don't return their sum as this loses data.
+            return (nr < 0) ? (n == 1 ? 1 : nr) : (n + nr);
         }
     }
 
@@ -202,6 +209,17 @@ public class StreamDecoder extends Reader
         return isOpen;
     }
 
+    // Android-added: Cherry-pick fillZeroToPosition() for JDK-8320798.
+    public void fillZeroToPosition() throws IOException {
+        Object lock = this.lock;
+        synchronized (lock) {
+            lockedFillZeroToPosition();
+        }
+    }
+
+    private void lockedFillZeroToPosition() {
+        Arrays.fill(bb.array(), bb.arrayOffset(), bb.arrayOffset() + bb.position(), (byte)0);
+    }
 
     // -- Charset-based stream decoder impl --
 
diff --git a/ojluni/src/main/java/sun/nio/fs/AbstractFileTypeDetector.java b/ojluni/src/main/java/sun/nio/fs/AbstractFileTypeDetector.java
index 0e43486e215..7a92479876e 100644
--- a/ojluni/src/main/java/sun/nio/fs/AbstractFileTypeDetector.java
+++ b/ojluni/src/main/java/sun/nio/fs/AbstractFileTypeDetector.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,6 +25,8 @@
 
 package sun.nio.fs;
 
+import java.net.FileNameMap;
+import java.net.URLConnection;
 import java.nio.file.Path;
 import java.nio.file.spi.FileTypeDetector;
 import java.util.Locale;
@@ -41,6 +43,27 @@ public abstract class AbstractFileTypeDetector
         super();
     }
 
+    /**
+     * Returns the extension of a file name, specifically the portion of the
+     * parameter string after the first dot. If the parameter is {@code null},
+     * empty, does not contain a dot, or the dot is the last character, then an
+     * empty string is returned, otherwise the characters after the dot are
+     * returned.
+     *
+     * @param name A file name
+     * @return The characters after the first dot or an empty string.
+     */
+    protected final String getExtension(String name) {
+        String ext = "";
+        if (name != null && !name.isEmpty()) {
+            int dot = name.indexOf('.');
+            if ((dot >= 0) && (dot < name.length() - 1)) {
+                ext = name.substring(dot + 1);
+            }
+        }
+        return ext;
+    }
+
     /**
      * Invokes the appropriate probe method to guess a file's content type,
      * and checks that the content type's syntax is valid.
@@ -50,6 +73,16 @@ public abstract class AbstractFileTypeDetector
         if (file == null)
             throw new NullPointerException("'file' is null");
         String result = implProbeContentType(file);
+
+        // Fall back to content types property.
+        if (result == null) {
+            Path fileName = file.getFileName();
+            if (fileName != null) {
+                FileNameMap fileNameMap = URLConnection.getFileNameMap();
+                result = fileNameMap.getContentTypeFor(fileName.toString());
+            }
+        }
+
         return (result == null) ? null : parse(result);
     }
 
diff --git a/ojluni/src/main/java/sun/nio/fs/AbstractPath.java b/ojluni/src/main/java/sun/nio/fs/AbstractPath.java
deleted file mode 100644
index dd6b3bde9a9..00000000000
--- a/ojluni/src/main/java/sun/nio/fs/AbstractPath.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (c) 2007, 2011, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.nio.fs;
-
-import java.nio.file.*;
-import java.io.File;
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.NoSuchElementException;
-
-/**
- * Base implementation class of {@code Path}.
- */
-
-abstract class AbstractPath implements Path {
-    protected AbstractPath() { }
-
-    @Override
-    public final boolean startsWith(String other) {
-        return startsWith(getFileSystem().getPath(other));
-    }
-
-    @Override
-    public final boolean endsWith(String other) {
-        return endsWith(getFileSystem().getPath(other));
-    }
-
-    @Override
-    public final Path resolve(String other) {
-        return resolve(getFileSystem().getPath(other));
-    }
-
-    @Override
-    public final Path resolveSibling(Path other) {
-        if (other == null)
-            throw new NullPointerException();
-        Path parent = getParent();
-        return (parent == null) ? other : parent.resolve(other);
-    }
-
-    @Override
-    public final Path resolveSibling(String other) {
-        return resolveSibling(getFileSystem().getPath(other));
-    }
-
-    @Override
-    public final Iterator<Path> iterator() {
-        return new Iterator<Path>() {
-            private int i = 0;
-            @Override
-            public boolean hasNext() {
-                return (i < getNameCount());
-            }
-            @Override
-            public Path next() {
-                if (i < getNameCount()) {
-                    Path result = getName(i);
-                    i++;
-                    return result;
-                } else {
-                    throw new NoSuchElementException();
-                }
-            }
-            @Override
-            public void remove() {
-                throw new UnsupportedOperationException();
-            }
-        };
-    }
-
-    @Override
-    public final File toFile() {
-        return new File(toString());
-    }
-
-    @Override
-    public final WatchKey register(WatchService watcher,
-                                   WatchEvent.Kind<?>... events)
-        throws IOException
-    {
-        return register(watcher, events, new WatchEvent.Modifier[0]);
-    }
-}
diff --git a/ojluni/src/main/java/sun/nio/fs/AbstractPoller.java b/ojluni/src/main/java/sun/nio/fs/AbstractPoller.java
index 34d4ea4e3bc..fa2d9a90991 100644
--- a/ojluni/src/main/java/sun/nio/fs/AbstractPoller.java
+++ b/ojluni/src/main/java/sun/nio/fs/AbstractPoller.java
@@ -47,7 +47,7 @@ abstract class AbstractPoller implements Runnable {
     private boolean shutdown;
 
     protected AbstractPoller() {
-        this.requestList = new LinkedList<Request>();
+        this.requestList = new LinkedList<>();
         this.shutdown = false;
     }
 
@@ -56,10 +56,14 @@ abstract class AbstractPoller implements Runnable {
      */
     public void start() {
         final Runnable thisRunnable = this;
-        AccessController.doPrivileged(new PrivilegedAction<Object>() {
+        AccessController.doPrivileged(new PrivilegedAction<>() {
             @Override
             public Object run() {
-                Thread thr = new Thread(thisRunnable);
+                Thread thr = new Thread(null,
+                                        thisRunnable,
+                                        "FileSystemWatchService",
+                                        0,
+                                        false);
                 thr.setDaemon(true);
                 thr.start();
                 return null;
@@ -216,10 +220,10 @@ abstract class AbstractPoller implements Runnable {
                 throw new ClosedWatchServiceException();
             }
             requestList.add(req);
-        }
 
-        // wakeup thread
-        wakeup();
+            // wakeup thread
+            wakeup();
+        }
 
         // wait for result
         Object result = req.awaitResult();
@@ -244,6 +248,7 @@ abstract class AbstractPoller implements Runnable {
                 // if in process of shutdown then reject request
                 if (shutdown) {
                     req.release(new ClosedWatchServiceException());
+                    continue;
                 }
 
                 switch (req.type()) {
diff --git a/ojluni/src/main/java/sun/nio/fs/AbstractWatchKey.java b/ojluni/src/main/java/sun/nio/fs/AbstractWatchKey.java
index 132b6e5d845..710e38fc607 100644
--- a/ojluni/src/main/java/sun/nio/fs/AbstractWatchKey.java
+++ b/ojluni/src/main/java/sun/nio/fs/AbstractWatchKey.java
@@ -70,8 +70,8 @@ abstract class AbstractWatchKey implements WatchKey {
         this.watcher = watcher;
         this.dir = dir;
         this.state = State.READY;
-        this.events = new ArrayList<WatchEvent<?>>();
-        this.lastModifyEvents = new HashMap<Object,WatchEvent<?>>();
+        this.events = new ArrayList<>();
+        this.lastModifyEvents = new HashMap<>();
     }
 
     final AbstractWatchService watcher() {
@@ -146,7 +146,7 @@ abstract class AbstractWatchKey implements WatchKey {
 
             // non-repeated event
             Event<Object> ev =
-                new Event<Object>((WatchEvent.Kind<Object>)kind, context);
+                new Event<>((WatchEvent.Kind<Object>)kind, context);
             if (isModify) {
                 lastModifyEvents.put(context, ev);
             } else if (kind == StandardWatchEventKinds.OVERFLOW) {
@@ -163,7 +163,7 @@ abstract class AbstractWatchKey implements WatchKey {
     public final List<WatchEvent<?>> pollEvents() {
         synchronized (this) {
             List<WatchEvent<?>> result = events;
-            events = new ArrayList<WatchEvent<?>>();
+            events = new ArrayList<>();
             lastModifyEvents.clear();
             return result;
         }
diff --git a/ojluni/src/main/java/sun/nio/fs/Cancellable.java b/ojluni/src/main/java/sun/nio/fs/Cancellable.java
index d386f016cd2..5e3ff43a7b0 100644
--- a/ojluni/src/main/java/sun/nio/fs/Cancellable.java
+++ b/ojluni/src/main/java/sun/nio/fs/Cancellable.java
@@ -117,7 +117,7 @@ abstract class Cancellable implements Runnable {
      * thread by writing into the memory location that it polls cooperatively.
      */
     static void runInterruptibly(Cancellable task) throws ExecutionException {
-        Thread t = new Thread(task);
+        Thread t = new Thread(null, task, "NIO-Task", 0, false);
         t.start();
         boolean cancelledByInterrupt = false;
         while (t.isAlive()) {
diff --git a/ojluni/src/main/java/sun/nio/fs/DefaultFileSystemProvider.java b/ojluni/src/main/java/sun/nio/fs/DefaultFileSystemProvider.java
index 5d2bae6fba2..17afe262fe0 100644
--- a/ojluni/src/main/java/sun/nio/fs/DefaultFileSystemProvider.java
+++ b/ojluni/src/main/java/sun/nio/fs/DefaultFileSystemProvider.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,48 +25,29 @@
 
 package sun.nio.fs;
 
-import java.nio.file.spi.FileSystemProvider;
-import java.security.AccessController;
-import sun.security.action.GetPropertyAction;
+import java.nio.file.FileSystem;
 
 /**
  * Creates this platform's default FileSystemProvider.
  */
 
 public class DefaultFileSystemProvider {
+    private static final LinuxFileSystemProvider INSTANCE
+        = new LinuxFileSystemProvider();
+
     private DefaultFileSystemProvider() { }
 
-    @SuppressWarnings("unchecked")
-    private static FileSystemProvider createProvider(String cn) {
-        Class<FileSystemProvider> c;
-        try {
-            c = (Class<FileSystemProvider>)Class.forName(cn);
-        } catch (ClassNotFoundException x) {
-            throw new AssertionError(x);
-        }
-        try {
-            return c.newInstance();
-        } catch (IllegalAccessException | InstantiationException x) {
-            throw new AssertionError(x);
-        }
+    /**
+     * Returns the platform's default file system provider.
+     */
+    public static LinuxFileSystemProvider instance() {
+        return INSTANCE;
     }
 
     /**
-     * Returns the default FileSystemProvider.
+     * Returns the platform's default file system.
      */
-    public static FileSystemProvider create() {
-        String osname = AccessController
-            .doPrivileged(new GetPropertyAction("os.name"));
-        if (osname.equals("SunOS"))
-            return createProvider("sun.nio.fs.SolarisFileSystemProvider");
-        // Android-changed: Fuchsia: Use LinuxFileSystemProvider.
-        // if (osname.equals("Linux"))
-        if (osname.equals("Linux") || osname.equals("Fuchsia"))
-            return createProvider("sun.nio.fs.LinuxFileSystemProvider");
-        if (osname.contains("OS X"))
-            return createProvider("sun.nio.fs.MacOSXFileSystemProvider");
-        if (osname.equals("AIX"))
-            return createProvider("sun.nio.fs.AixFileSystemProvider");
-        throw new AssertionError("Platform not recognized");
+    public static FileSystem theFileSystem() {
+        return INSTANCE.theFileSystem();
     }
 }
diff --git a/ojluni/src/main/java/sun/nio/fs/ExtendedOptions.java b/ojluni/src/main/java/sun/nio/fs/ExtendedOptions.java
new file mode 100644
index 00000000000..673c3296696
--- /dev/null
+++ b/ojluni/src/main/java/sun/nio/fs/ExtendedOptions.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright (c) 2016, 2017, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package sun.nio.fs;
+
+import java.nio.file.CopyOption;
+import java.nio.file.OpenOption;
+import java.nio.file.WatchEvent;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * Provides support for handling JDK-specific OpenOption, CopyOption and
+ * WatchEvent.Modifier types.
+ */
+
+public final class ExtendedOptions {
+
+    // maps InternalOption to ExternalOption
+    private static final Map<InternalOption<?>, Wrapper<?>> internalToExternal
+        = new ConcurrentHashMap<>();
+
+    /**
+     * Wraps an option or modifier.
+     */
+    private static final class Wrapper<T> {
+        private final Object option;
+        private final T param;
+
+        Wrapper(Object option, T param) {
+            this.option = option;
+            this.param = param;
+        }
+
+        T parameter() {
+            return param;
+        }
+    }
+
+    /**
+     * The internal version of a JDK-specific OpenOption, CopyOption or
+     * WatchEvent.Modifier.
+     */
+    public static final class InternalOption<T> {
+
+        InternalOption() { }
+
+        private void registerInternal(Object option, T param) {
+            Wrapper<T> wrapper = new Wrapper<T>(option, param);
+            internalToExternal.put(this, wrapper);
+        }
+
+        /**
+         * Register this internal option as a OpenOption.
+         */
+        public void register(OpenOption option) {
+            registerInternal(option, null);
+        }
+
+        /**
+         * Register this internal option as a CopyOption.
+         */
+        public void register(CopyOption option) {
+            registerInternal(option, null);
+        }
+
+        /**
+         * Register this internal option as a WatchEvent.Modifier.
+         */
+        public void register(WatchEvent.Modifier option) {
+            registerInternal(option, null);
+        }
+
+        /**
+         * Register this internal option as a WatchEvent.Modifier with the
+         * given parameter.
+         */
+        public void register(WatchEvent.Modifier option, T param) {
+            registerInternal(option, param);
+        }
+
+        /**
+         * Returns true if the given option (or modifier) maps to this internal
+         * option.
+         */
+        public boolean matches(Object option) {
+            Wrapper <?> wrapper = internalToExternal.get(this);
+            if (wrapper == null)
+                return false;
+            else
+                return option == wrapper.option;
+        }
+
+        /**
+         * Returns the parameter object associated with this internal option.
+         */
+        @SuppressWarnings("unchecked")
+        public T parameter() {
+            Wrapper<?> wrapper = internalToExternal.get(this);
+            if (wrapper == null)
+                return null;
+            else
+                return (T) wrapper.parameter();
+        }
+    }
+
+    // Internal equivalents of the options and modifiers defined in
+    // package com.sun.nio.file
+
+    public static final InternalOption<Void> INTERRUPTIBLE = new InternalOption<>();
+
+    public static final InternalOption<Void> NOSHARE_READ = new InternalOption<>();
+    public static final InternalOption<Void> NOSHARE_WRITE = new InternalOption<>();
+    public static final InternalOption<Void> NOSHARE_DELETE = new InternalOption<>();
+
+    public static final InternalOption<Void> FILE_TREE = new InternalOption<>();
+
+    public static final InternalOption<Void> DIRECT = new InternalOption<>();
+
+    public static final InternalOption<Integer> SENSITIVITY_HIGH = new InternalOption<>();
+    public static final InternalOption<Integer> SENSITIVITY_MEDIUM = new InternalOption<>();
+    public static final InternalOption<Integer> SENSITIVITY_LOW = new InternalOption<>();
+}
diff --git a/ojluni/src/main/java/sun/nio/fs/LinuxDosFileAttributeView.java b/ojluni/src/main/java/sun/nio/fs/LinuxDosFileAttributeView.java
index 5673f5632c3..6032773bb61 100644
--- a/ojluni/src/main/java/sun/nio/fs/LinuxDosFileAttributeView.java
+++ b/ojluni/src/main/java/sun/nio/fs/LinuxDosFileAttributeView.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2015, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -117,8 +117,9 @@ class LinuxDosFileAttributeView
     public DosFileAttributes readAttributes() throws IOException {
         file.checkRead();
 
-        int fd = file.openForAttributeAccess(followLinks);
+        int fd = -1;
         try {
+             fd = file.openForAttributeAccess(followLinks);
              final UnixFileAttributes attrs = UnixFileAttributes.get(fd);
              final int dosAttribute = getDosAttribute(fd);
 
@@ -257,8 +258,9 @@ class LinuxDosFileAttributeView
     private void updateDosAttribute(int flag, boolean enable) throws IOException {
         file.checkWrite();
 
-        int fd = file.openForAttributeAccess(followLinks);
+        int fd = -1;
         try {
+            fd = file.openForAttributeAccess(followLinks);
             int oldValue = getDosAttribute(fd);
             int newValue = oldValue;
             if (enable) {
diff --git a/ojluni/src/main/java/sun/nio/fs/LinuxFileStore.java b/ojluni/src/main/java/sun/nio/fs/LinuxFileStore.java
index 360a8d33ba7..1cba03e4197 100644
--- a/ojluni/src/main/java/sun/nio/fs/LinuxFileStore.java
+++ b/ojluni/src/main/java/sun/nio/fs/LinuxFileStore.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,9 +25,14 @@
 
 package sun.nio.fs;
 
-import java.nio.file.attribute.*;
-import java.util.*;
 import java.io.IOException;
+import java.nio.file.attribute.DosFileAttributeView;
+import java.nio.file.attribute.FileAttributeView;
+import java.nio.file.attribute.PosixFileAttributeView;
+import java.nio.file.attribute.UserDefinedFileAttributeView;
+import java.util.Arrays;
+import java.util.List;
+import java.util.regex.Pattern;
 
 /**
  * Linux implementation of FileStore
@@ -66,6 +71,8 @@ class LinuxFileStore
         }
 
         // step 2: find mount point
+        List<UnixMountEntry> procMountsEntries =
+            fs.getMountEntries("/proc/mounts");
         UnixPath parent = path.getParent();
         while (parent != null) {
             UnixFileAttributes attrs = null;
@@ -74,16 +81,23 @@ class LinuxFileStore
             } catch (UnixException x) {
                 x.rethrowAsIOException(parent);
             }
-            if (attrs.dev() != dev())
-                break;
+            if (attrs.dev() != dev()) {
+                // step 3: lookup mounted file systems (use /proc/mounts to
+                // ensure we find the file system even when not in /etc/mtab)
+                byte[] dir = path.asByteArray();
+                for (UnixMountEntry entry : procMountsEntries) {
+                    if (Arrays.equals(dir, entry.dir()))
+                        return entry;
+                }
+            }
             path = parent;
             parent = parent.getParent();
         }
 
-        // step 3: lookup mounted file systems (use /proc/mounts to ensure we
-        // find the file system even when not in /etc/mtab)
+        // step 3: lookup mounted file systems (use /proc/mounts to
+        // ensure we find the file system even when not in /etc/mtab)
         byte[] dir = path.asByteArray();
-        for (UnixMountEntry entry: fs.getMountEntries("/proc/mounts")) {
+        for (UnixMountEntry entry : procMountsEntries) {
             if (Arrays.equals(dir, entry.dir()))
                 return entry;
         }
@@ -94,26 +108,36 @@ class LinuxFileStore
     // returns true if extended attributes enabled on file system where given
     // file resides, returns false if disabled or unable to determine.
     private boolean isExtendedAttributesEnabled(UnixPath path) {
+        int fd = -1;
         try {
-            int fd = path.openForAttributeAccess(false);
-            try {
-                // fgetxattr returns size if called with size==0
-                byte[] name = Util.toBytes("user.java");
-                LinuxNativeDispatcher.fgetxattr(fd, name, 0L, 0);
+            fd = path.openForAttributeAccess(false);
+
+            // fgetxattr returns size if called with size==0
+            byte[] name = Util.toBytes("user.java");
+            LinuxNativeDispatcher.fgetxattr(fd, name, 0L, 0);
+            return true;
+        } catch (UnixException e) {
+            // attribute does not exist
+            if (e.errno() == UnixConstants.ENODATA)
                 return true;
-            } catch (UnixException e) {
-                // attribute does not exist
-                if (e.errno() == UnixConstants.ENODATA)
-                    return true;
-            } finally {
-                UnixNativeDispatcher.close(fd);
-            }
-        } catch (IOException ignore) {
-            // nothing we can do
+        } finally {
+            UnixNativeDispatcher.close(fd);
         }
         return false;
     }
 
+    // get kernel version as a three element array {major, minor, micro}
+    private static int[] getKernelVersion() {
+        Pattern pattern = Pattern.compile("\\D+");
+        String[] matches = pattern.split(System.getProperty("os.version"));
+        int[] majorMinorMicro = new int[3];
+        int length = Math.min(matches.length, majorMinorMicro.length);
+        for (int i = 0; i < length; i++) {
+            majorMinorMicro[i] = Integer.valueOf(matches[i]);
+        }
+        return majorMinorMicro;
+    }
+
     @Override
     public boolean supportsFileAttributeView(Class<? extends FileAttributeView> type) {
         // support DosFileAttributeView and UserDefinedAttributeView if extended
@@ -133,12 +157,28 @@ class LinuxFileStore
             if ((entry().hasOption("user_xattr")))
                 return true;
 
-            // user_xattr option not present but we special-case ext3/4 as we
-            // know that extended attributes are not enabled by default.
-            if (entry().fstype().equals("ext3") || entry().fstype().equals("ext4"))
+            // check for explicit disabling of extended attributes
+            if (entry().hasOption("nouser_xattr")) {
                 return false;
+            }
+
+            // user_xattr option not present but we special-case ext4 as we
+            // know that extended attributes are enabled by default for
+            // kernel version >= 2.6.39
+            if (entry().fstype().equals("ext4")) {
+                if (!xattrChecked) {
+                    // check kernel version
+                    int[] kernelVersion = getKernelVersion();
+                    xattrEnabled = kernelVersion[0] > 2 ||
+                        (kernelVersion[0] == 2 && kernelVersion[1] > 6) ||
+                        (kernelVersion[0] == 2 && kernelVersion[1] == 6 &&
+                            kernelVersion[2] >= 39);
+                    xattrChecked = true;
+                }
+                return xattrEnabled;
+            }
 
-            // not ext3/4 so probe mount point
+            // not ext4 so probe mount point
             if (!xattrChecked) {
                 UnixPath dir = new UnixPath(file().getFileSystem(), entry().dir());
                 xattrEnabled = isExtendedAttributesEnabled(dir);
diff --git a/ojluni/src/main/java/sun/nio/fs/LinuxFileSystem.java b/ojluni/src/main/java/sun/nio/fs/LinuxFileSystem.java
index bdd2f2919f3..6da79d4bea4 100644
--- a/ojluni/src/main/java/sun/nio/fs/LinuxFileSystem.java
+++ b/ojluni/src/main/java/sun/nio/fs/LinuxFileSystem.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -75,14 +75,30 @@ class LinuxFileSystem extends UnixFileSystem {
     /**
      * Returns object to iterate over the mount entries in the given fstab file.
      */
-    Iterable<UnixMountEntry> getMountEntries(String fstab) {
+    List<UnixMountEntry> getMountEntries(String fstab) {
         ArrayList<UnixMountEntry> entries = new ArrayList<>();
         try {
             long fp = setmntent(Util.toBytes(fstab), Util.toBytes("r"));
+            int maxLineSize = 1024;
+            try {
+                for (;;) {
+                    int lineSize = getlinelen(fp);
+                    if (lineSize == -1)
+                        break;
+                    if (lineSize > maxLineSize)
+                        maxLineSize = lineSize;
+                }
+            } catch (UnixException x) {
+                // nothing we need to do
+            } finally {
+                rewind(fp);
+            }
+
             try {
                 for (;;) {
                     UnixMountEntry entry = new UnixMountEntry();
-                    int res = getmntent(fp, entry);
+                    // count in NUL character at the end
+                    int res = getmntent(fp, entry, maxLineSize + 1);
                     if (res < 0)
                         break;
                     entries.add(entry);
@@ -101,9 +117,10 @@ class LinuxFileSystem extends UnixFileSystem {
      * Returns object to iterate over the mount entries in /etc/mtab
      */
     @Override
-    Iterable<UnixMountEntry> getMountEntries() {
+    List<UnixMountEntry> getMountEntries() {
         // Android-changed: As /etc/mtab is not available in Android, therefore, using /proc/mounts
         // instead.
+        // return getMountEntries("/etc/mtab");
         return getMountEntries("/proc/mounts");
     }
 
diff --git a/ojluni/src/main/java/sun/nio/fs/LinuxFileSystemProvider.java b/ojluni/src/main/java/sun/nio/fs/LinuxFileSystemProvider.java
index a3a777add92..5214cd5f6fe 100644
--- a/ojluni/src/main/java/sun/nio/fs/LinuxFileSystemProvider.java
+++ b/ojluni/src/main/java/sun/nio/fs/LinuxFileSystemProvider.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -30,6 +30,8 @@ import java.nio.file.attribute.*;
 import java.nio.file.spi.FileTypeDetector;
 import java.io.IOException;
 
+import jdk.internal.util.StaticProperty;
+
 /**
  * Linux implementation of FileSystemProvider
  */
@@ -121,14 +123,13 @@ public class LinuxFileSystemProvider extends UnixFileSystemProvider {
         // MagicFileTypeDetector have been removed. MimeTypeFileDetector detects file type based
         // on the file extension, which may give false results.
         /*
-        Path userMimeTypes = Paths.get(AccessController.doPrivileged(
-            new GetPropertyAction("user.home")), ".mime.types");
-        Path etcMimeTypes = Paths.get("/etc/mime.types");
 
-        return chain(new GnomeFileTypeDetector(),
-                     new MimeTypesFileTypeDetector(userMimeTypes),
-                     new MimeTypesFileTypeDetector(etcMimeTypes),
-                     new MagicFileTypeDetector());
+        String userHome = StaticProperty.userHome();
+        Path userMimeTypes = Path.of(userHome, ".mime.types");
+        Path etcMimeTypes = Path.of("/etc/mime.types");
+
+        return chain(new MimeTypesFileTypeDetector(userMimeTypes),
+                     new MimeTypesFileTypeDetector(etcMimeTypes));
         */
         return new MimeTypesFileTypeDetector();
     }
diff --git a/ojluni/src/main/java/sun/nio/fs/LinuxNativeDispatcher.java b/ojluni/src/main/java/sun/nio/fs/LinuxNativeDispatcher.java
index a3f27d28db1..cb0eabf090d 100644
--- a/ojluni/src/main/java/sun/nio/fs/LinuxNativeDispatcher.java
+++ b/ojluni/src/main/java/sun/nio/fs/LinuxNativeDispatcher.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -54,7 +54,17 @@ class LinuxNativeDispatcher extends UnixNativeDispatcher {
     /**
      * int getmntent(FILE *fp, struct mnttab *mp, int len);
      */
-    static native int getmntent(long fp, UnixMountEntry entry)
+
+    static int getmntent(long fp, UnixMountEntry entry, int buflen) throws UnixException {
+        NativeBuffer buffer = NativeBuffers.getNativeBuffer(buflen);
+        try {
+            return getmntent0(fp, entry, buffer.address(), buflen);
+        } finally {
+            buffer.release();
+        }
+    }
+
+    static native int getmntent0(long fp, UnixMountEntry entry, long buffer, int bufLen)
         throws UnixException;
 
     /**
@@ -77,7 +87,7 @@ class LinuxNativeDispatcher extends UnixNativeDispatcher {
     }
 
     private static native int fgetxattr0(int filedes, long nameAddress,
-        long valueAdddress, int valueLen) throws UnixException;
+        long valueAddress, int valueLen) throws UnixException;
 
     /**
      *  fsetxattr(int filedes, const char *name, const void *value, size_t size, int flags);
@@ -94,7 +104,7 @@ class LinuxNativeDispatcher extends UnixNativeDispatcher {
     }
 
     private static native void fsetxattr0(int filedes, long nameAddress,
-        long valueAdddress, int valueLen) throws UnixException;
+        long valueAddress, int valueLen) throws UnixException;
 
     /**
      * fremovexattr(int filedes, const char *name);
@@ -123,7 +133,7 @@ class LinuxNativeDispatcher extends UnixNativeDispatcher {
     static {
         // Android-removed: Code to load native libraries, doesn't make sense on Android.
         /*
-        AccessController.doPrivileged(new PrivilegedAction<Void>() {
+        AccessController.doPrivileged(new PrivilegedAction<>() {
             public Void run() {
                 System.loadLibrary("nio");
                 return null;
diff --git a/ojluni/src/main/java/sun/nio/fs/LinuxUserDefinedFileAttributeView.java b/ojluni/src/main/java/sun/nio/fs/LinuxUserDefinedFileAttributeView.java
index 873cf802f77..00a0ff9808a 100644
--- a/ojluni/src/main/java/sun/nio/fs/LinuxUserDefinedFileAttributeView.java
+++ b/ojluni/src/main/java/sun/nio/fs/LinuxUserDefinedFileAttributeView.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2015, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -101,7 +101,12 @@ class LinuxUserDefinedFileAttributeView
         if (System.getSecurityManager() != null)
             checkAccess(file.getPathForPermissionCheck(), true, false);
 
-        int fd = file.openForAttributeAccess(followLinks);
+        int fd = -1;
+        try {
+            fd = file.openForAttributeAccess(followLinks);
+        } catch (UnixException x) {
+            x.rethrowAsIOException(file);
+        }
         NativeBuffer buffer = null;
         try {
             int size = 1024;
@@ -137,7 +142,12 @@ class LinuxUserDefinedFileAttributeView
         if (System.getSecurityManager() != null)
             checkAccess(file.getPathForPermissionCheck(), true, false);
 
-        int fd = file.openForAttributeAccess(followLinks);
+        int fd = -1;
+        try {
+            fd = file.openForAttributeAccess(followLinks);
+        } catch (UnixException x) {
+            x.rethrowAsIOException(file);
+        }
         try {
             // fgetxattr returns size if called with size==0
             return fgetxattr(fd, nameAsBytes(file,name), 0L, 0);
@@ -173,7 +183,12 @@ class LinuxUserDefinedFileAttributeView
             address = nb.address();
         }
 
-        int fd = file.openForAttributeAccess(followLinks);
+        int fd = -1;
+        try {
+            fd = file.openForAttributeAccess(followLinks);
+        } catch (UnixException x) {
+            x.rethrowAsIOException(file);
+        }
         try {
             try {
                 int n = fgetxattr(fd, nameAsBytes(file,name), address, rem);
@@ -252,7 +267,12 @@ class LinuxUserDefinedFileAttributeView
             }
         }
 
-        int fd = file.openForAttributeAccess(followLinks);
+        int fd = -1;
+        try {
+            fd = file.openForAttributeAccess(followLinks);
+        } catch (UnixException x) {
+            x.rethrowAsIOException(file);
+        }
         try {
             try {
                 fsetxattr(fd, nameAsBytes(file,name), address, rem);
@@ -276,7 +296,12 @@ class LinuxUserDefinedFileAttributeView
         if (System.getSecurityManager() != null)
             checkAccess(file.getPathForPermissionCheck(), false, true);
 
-        int fd = file.openForAttributeAccess(followLinks);
+        int fd = -1;
+        try {
+            fd = file.openForAttributeAccess(followLinks);
+        } catch (UnixException x) {
+            x.rethrowAsIOException(file);
+        }
         try {
             fremovexattr(fd, nameAsBytes(file,name));
         } catch (UnixException x) {
diff --git a/ojluni/src/main/java/sun/nio/fs/LinuxWatchService.java b/ojluni/src/main/java/sun/nio/fs/LinuxWatchService.java
index 6c917859dea..f4a86135186 100644
--- a/ojluni/src/main/java/sun/nio/fs/LinuxWatchService.java
+++ b/ojluni/src/main/java/sun/nio/fs/LinuxWatchService.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -31,9 +31,10 @@ import java.security.PrivilegedAction;
 import java.util.*;
 import java.io.IOException;
 
+import jdk.internal.misc.Unsafe;
+
 import dalvik.annotation.optimization.ReachabilitySensitive;
 import dalvik.system.CloseGuard;
-import jdk.internal.misc.Unsafe;
 
 import static sun.nio.fs.UnixNativeDispatcher.*;
 import static sun.nio.fs.UnixConstants.*;
@@ -197,7 +198,7 @@ class LinuxWatchService
             this.watcher = watcher;
             this.ifd = ifd;
             this.socketpair = sp;
-            this.wdToKey = new HashMap<Integer,LinuxWatchKey>();
+            this.wdToKey = new HashMap<>();
             this.address = unsafe.allocateMemory(BUFFER_SIZE);
             // Android-added: CloseGuard support.
             guard.open("close");
@@ -241,9 +242,11 @@ class LinuxWatchService
                 for (WatchEvent.Modifier modifier: modifiers) {
                     if (modifier == null)
                         return new NullPointerException();
-                    if (modifier instanceof com.sun.nio.file.SensitivityWatchEventModifier)
-                        continue; // ignore
-                    return new UnsupportedOperationException("Modifier not supported");
+                    if (!ExtendedOptions.SENSITIVITY_HIGH.matches(modifier) &&
+                            !ExtendedOptions.SENSITIVITY_MEDIUM.matches(modifier) &&
+                            !ExtendedOptions.SENSITIVITY_LOW.matches(modifier)) {
+                        return new UnsupportedOperationException("Modifier not supported");
+                    }
                 }
             }
 
@@ -340,24 +343,11 @@ class LinuxWatchService
                     try {
                         bytesRead = read(ifd, address, BUFFER_SIZE);
                     } catch (UnixException x) {
-                        if (x.errno() != EAGAIN)
+                        if (x.errno() != EAGAIN && x.errno() != EWOULDBLOCK)
                             throw x;
                         bytesRead = 0;
                     }
 
-                    // process any pending requests
-                    if ((nReady > 1) || (nReady == 1 && bytesRead == 0)) {
-                        try {
-                            read(socketpair[0], address, BUFFER_SIZE);
-                            boolean shutdown = processRequests();
-                            if (shutdown)
-                                break;
-                        } catch (UnixException x) {
-                            if (x.errno() != UnixConstants.EAGAIN)
-                                throw x;
-                        }
-                    }
-
                     // iterate over buffer to decode events
                     int offset = 0;
                     while (offset < bytesRead) {
@@ -397,6 +387,19 @@ class LinuxWatchService
 
                         offset += (SIZEOF_INOTIFY_EVENT + len);
                     }
+
+                    // process any pending requests
+                    if ((nReady > 1) || (nReady == 1 && bytesRead == 0)) {
+                        try {
+                            read(socketpair[0], address, BUFFER_SIZE);
+                            boolean shutdown = processRequests();
+                            if (shutdown)
+                                break;
+                        } catch (UnixException x) {
+                            if (x.errno() != EAGAIN && x.errno() != EWOULDBLOCK)
+                                throw x;
+                        }
+                    }
                 }
             } catch (UnixException x) {
                 x.printStackTrace();
@@ -487,7 +490,7 @@ class LinuxWatchService
     // Android-removed: Code to load native libraries, doesn't make sense on Android.
     /*
     static {
-        AccessController.doPrivileged(new PrivilegedAction<Void>() {
+        AccessController.doPrivileged(new PrivilegedAction<>() {
             public Void run() {
                 System.loadLibrary("nio");
                 return null;
diff --git a/ojluni/src/main/java/sun/nio/fs/MimeTypesFileTypeDetector.java b/ojluni/src/main/java/sun/nio/fs/MimeTypesFileTypeDetector.java
index 585b673a000..556948d02d0 100644
--- a/ojluni/src/main/java/sun/nio/fs/MimeTypesFileTypeDetector.java
+++ b/ojluni/src/main/java/sun/nio/fs/MimeTypesFileTypeDetector.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -55,7 +55,7 @@ class MimeTypesFileTypeDetector extends AbstractFileTypeDetector {
     private Map<String,String> mimeTypeMap;
 
     // set to true when file loaded
-    private volatile boolean loaded = false;
+    private volatile boolean loaded;
 
     public MimeTypesFileTypeDetector(Path filePath) {
         mimeTypesFile = filePath;
@@ -93,18 +93,6 @@ class MimeTypesFileTypeDetector extends AbstractFileTypeDetector {
         return mimeType;
     }
 
-    // Get the extension of a file name.
-    private static String getExtension(String name) {
-        String ext = "";
-        if (name != null && !name.isEmpty()) {
-            int dot = name.indexOf('.');
-            if ((dot >= 0) && (dot < name.length() - 1)) {
-                ext = name.substring(dot + 1);
-            }
-        }
-        return ext;
-    }
-
     // BEGIN Android-removed: Delegate to libcore.content.type.MimeMap.
     /*
     /**
@@ -118,7 +106,7 @@ class MimeTypesFileTypeDetector extends AbstractFileTypeDetector {
             synchronized (this) {
                 if (!loaded) {
                     List<String> lines = AccessController.doPrivileged(
-                        new PrivilegedAction<List<String>>() {
+                        new PrivilegedAction<>() {
                             @Override
                             public List<String> run() {
                                 try {
diff --git a/ojluni/src/main/java/sun/nio/fs/NativeBuffer.java b/ojluni/src/main/java/sun/nio/fs/NativeBuffer.java
index d2c4a828426..d565ab4f482 100644
--- a/ojluni/src/main/java/sun/nio/fs/NativeBuffer.java
+++ b/ojluni/src/main/java/sun/nio/fs/NativeBuffer.java
@@ -25,8 +25,9 @@
 
 package sun.nio.fs;
 
+import java.lang.ref.Cleaner.Cleanable;
 import jdk.internal.misc.Unsafe;
-import sun.misc.Cleaner;
+import jdk.internal.ref.CleanerFactory;
 
 /**
  * A light-weight buffer in native memory.
@@ -37,7 +38,7 @@ class NativeBuffer {
 
     private final long address;
     private final int size;
-    private final Cleaner cleaner;
+    private final Cleanable cleanable;
 
     // optional "owner" to avoid copying
     // (only safe for use by thread-local caches)
@@ -56,7 +57,8 @@ class NativeBuffer {
     NativeBuffer(int size) {
         this.address = unsafe.allocateMemory(size);
         this.size = size;
-        this.cleaner = Cleaner.create(this, new Deallocator(address));
+        this.cleanable = CleanerFactory.cleaner()
+                                       .register(this, new Deallocator(address));
     }
 
     // Android-note: releaseNativeBuffer() ensures that its argument is strongly reachable.
@@ -77,8 +79,8 @@ class NativeBuffer {
         return size;
     }
 
-    Cleaner cleaner() {
-        return cleaner;
+    void free() {
+        cleanable.clean();
     }
 
     // not synchronized; only safe for use by thread-local caches
diff --git a/ojluni/src/main/java/sun/nio/fs/NativeBuffers.java b/ojluni/src/main/java/sun/nio/fs/NativeBuffers.java
index d42a5e7e077..1c3450b7cf3 100644
--- a/ojluni/src/main/java/sun/nio/fs/NativeBuffers.java
+++ b/ojluni/src/main/java/sun/nio/fs/NativeBuffers.java
@@ -25,6 +25,7 @@
 
 package sun.nio.fs;
 
+import jdk.internal.misc.TerminatingThreadLocal;
 import jdk.internal.misc.Unsafe;
 
 /**
@@ -37,8 +38,21 @@ class NativeBuffers {
     private static final Unsafe unsafe = Unsafe.getUnsafe();
 
     private static final int TEMP_BUF_POOL_SIZE = 3;
-    private static ThreadLocal<NativeBuffer[]> threadLocal =
-        new ThreadLocal<NativeBuffer[]>();
+    private static ThreadLocal<NativeBuffer[]> threadLocal = new TerminatingThreadLocal<>() {
+        @Override
+        protected void threadTerminated(NativeBuffer[] buffers) {
+            // threadLocal may be initialized but with initialValue of null
+            if (buffers != null) {
+                for (int i = 0; i < TEMP_BUF_POOL_SIZE; i++) {
+                    NativeBuffer buffer = buffers[i];
+                    if (buffer != null) {
+                        buffer.free();
+                        buffers[i] = null;
+                    }
+                }
+            }
+        }
+    };
 
     /**
      * Allocates a native buffer, of at least the given size, from the heap.
@@ -107,14 +121,14 @@ class NativeBuffers {
         for (int i=0; i<TEMP_BUF_POOL_SIZE; i++) {
             NativeBuffer existing = buffers[i];
             if (existing.size() < buffer.size()) {
-                existing.cleaner().clean();
+                existing.free();
                 buffers[i] = buffer;
                 return;
             }
         }
 
         // free it
-        buffer.cleaner().clean();
+        buffer.free();
     }
 
     /**
diff --git a/ojluni/src/main/java/sun/nio/fs/PollingWatchService.java b/ojluni/src/main/java/sun/nio/fs/PollingWatchService.java
index d3d9891223d..13c365894c4 100644
--- a/ojluni/src/main/java/sun/nio/fs/PollingWatchService.java
+++ b/ojluni/src/main/java/sun/nio/fs/PollingWatchService.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,16 +25,32 @@
 
 package sun.nio.fs;
 
-import java.nio.file.*;
-import java.nio.file.attribute.*;
+import java.nio.file.ClosedWatchServiceException;
+import java.nio.file.DirectoryIteratorException;
+import java.nio.file.DirectoryStream;
+import java.nio.file.Files;
+import java.nio.file.LinkOption;
+import java.nio.file.NotDirectoryException;
+import java.nio.file.Path;
+import java.nio.file.StandardWatchEventKinds;
+import java.nio.file.WatchEvent;
+import java.nio.file.WatchKey;
+import java.nio.file.attribute.BasicFileAttributes;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.security.PrivilegedExceptionAction;
 import java.security.PrivilegedActionException;
 import java.io.IOException;
-import java.util.*;
-import java.util.concurrent.*;
-import com.sun.nio.file.SensitivityWatchEventModifier;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
 
 /**
  * Simple WatchService implementation that uses periodic tasks to poll
@@ -46,8 +62,7 @@ class PollingWatchService
     extends AbstractWatchService
 {
     // map of registrations
-    private final Map<Object,PollingWatchKey> map =
-        new HashMap<Object,PollingWatchKey>();
+    private final Map<Object, PollingWatchKey> map = new HashMap<>();
 
     // used to execute the periodic tasks that poll for changes
     private final ScheduledExecutorService scheduledExecutor;
@@ -58,7 +73,7 @@ class PollingWatchService
             .newSingleThreadScheduledExecutor(new ThreadFactory() {
                  @Override
                  public Thread newThread(Runnable r) {
-                     Thread t = new Thread(r);
+                     Thread t = new Thread(null, r, "FileSystemWatcher", 0, false);
                      t.setDaemon(true);
                      return t;
                  }});
@@ -74,8 +89,7 @@ class PollingWatchService
          throws IOException
     {
         // check events - CCE will be thrown if there are invalid elements
-        final Set<WatchEvent.Kind<?>> eventSet =
-            new HashSet<WatchEvent.Kind<?>>(events.length);
+        final Set<WatchEvent.Kind<?>> eventSet = new HashSet<>(events.length);
         for (WatchEvent.Kind<?> event: events) {
             // standard events
             if (event == StandardWatchEventKinds.ENTRY_CREATE ||
@@ -99,17 +113,22 @@ class PollingWatchService
         if (eventSet.isEmpty())
             throw new IllegalArgumentException("No events to register");
 
-        // A modifier may be used to specify the sensitivity level
-        SensitivityWatchEventModifier sensivity = SensitivityWatchEventModifier.MEDIUM;
+        // Extended modifiers may be used to specify the sensitivity level
+        int sensitivity = 10;
         if (modifiers.length > 0) {
             for (WatchEvent.Modifier modifier: modifiers) {
                 if (modifier == null)
                     throw new NullPointerException();
-                if (modifier instanceof SensitivityWatchEventModifier) {
-                    sensivity = (SensitivityWatchEventModifier)modifier;
-                    continue;
+
+                if (ExtendedOptions.SENSITIVITY_HIGH.matches(modifier)) {
+                    sensitivity = ExtendedOptions.SENSITIVITY_HIGH.parameter();
+                } else if (ExtendedOptions.SENSITIVITY_MEDIUM.matches(modifier)) {
+                    sensitivity = ExtendedOptions.SENSITIVITY_MEDIUM.parameter();
+                } else if (ExtendedOptions.SENSITIVITY_LOW.matches(modifier)) {
+                    sensitivity = ExtendedOptions.SENSITIVITY_LOW.parameter();
+                } else {
+                    throw new UnsupportedOperationException("Modifier not supported");
                 }
-                throw new UnsupportedOperationException("Modifier not supported");
             }
         }
 
@@ -120,12 +139,12 @@ class PollingWatchService
         // registration is done in privileged block as it requires the
         // attributes of the entries in the directory.
         try {
-            final SensitivityWatchEventModifier s = sensivity;
+            int value = sensitivity;
             return AccessController.doPrivileged(
                 new PrivilegedExceptionAction<PollingWatchKey>() {
                     @Override
                     public PollingWatchKey run() throws IOException {
-                        return doPrivilegedRegister(path, eventSet, s);
+                        return doPrivilegedRegister(path, eventSet, value);
                     }
                 });
         } catch (PrivilegedActionException pae) {
@@ -140,7 +159,7 @@ class PollingWatchService
     // existing key if already registered
     private PollingWatchKey doPrivilegedRegister(Path path,
                                                  Set<? extends WatchEvent.Kind<?>> events,
-                                                 SensitivityWatchEventModifier sensivity)
+                                                 int sensitivityInSeconds)
         throws IOException
     {
         // check file is a directory and get its file key if possible
@@ -169,7 +188,7 @@ class PollingWatchService
                     watchKey.disable();
                 }
             }
-            watchKey.enable(events, sensivity.sensitivityValueInSeconds());
+            watchKey.enable(events, sensitivityInSeconds);
             return watchKey;
         }
 
@@ -178,7 +197,7 @@ class PollingWatchService
     @Override
     void implClose() throws IOException {
         synchronized (map) {
-            for (Map.Entry<Object,PollingWatchKey> entry: map.entrySet()) {
+            for (Map.Entry<Object, PollingWatchKey> entry: map.entrySet()) {
                 PollingWatchKey watchKey = entry.getValue();
                 watchKey.disable();
                 watchKey.invalidate();
diff --git a/ojluni/src/main/java/sun/nio/fs/UnixConstants.java b/ojluni/src/main/java/sun/nio/fs/UnixConstants.java
index d197ee26093..3a4027e875d 100644
--- a/ojluni/src/main/java/sun/nio/fs/UnixConstants.java
+++ b/ojluni/src/main/java/sun/nio/fs/UnixConstants.java
@@ -1,6 +1,5 @@
 /*
- * Copyright (c) 2008, 2009, Oracle and/or its affiliates. All rights reserved.
- *
+ * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -22,7 +21,6 @@
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
- *
  */
 // AUTOMATICALLY GENERATED FILE - DO NOT EDIT
 package sun.nio.fs;
@@ -56,6 +54,8 @@ class UnixConstants {
 
     static final int O_NOFOLLOW = OsConstants.O_NOFOLLOW;
 
+    static final int O_DIRECT = OsConstants.O_DIRECT;
+
     static final int S_IAMB = get_S_IAMB();
 
     static final int S_IRUSR = OsConstants.S_IRUSR;
@@ -100,6 +100,8 @@ class UnixConstants {
 
     static final int ENOENT = OsConstants.ENOENT;
 
+    static final int ENXIO = OsConstants.ENXIO;
+
     static final int EACCES = OsConstants.EACCES;
 
     static final int EEXIST = OsConstants.EEXIST;
@@ -118,6 +120,10 @@ class UnixConstants {
 
     static final int EAGAIN = OsConstants.EAGAIN;
 
+    // Android-changed: On Linux, EWOULDBLOCK == EAGAIN. Use EAGAIN instead, to reduce confusion.
+    // static final int EWOULDBLOCK = OsConstants.EWOULDBLOCK;
+    static final int EWOULDBLOCK = OsConstants.EAGAIN;
+
     static final int ENOSYS = OsConstants.ENOSYS;
 
     static final int ELOOP = OsConstants.ELOOP;
@@ -142,4 +148,4 @@ class UnixConstants {
 
     static final int AT_SYMLINK_NOFOLLOW = 0x100;
     static final int AT_REMOVEDIR = 0x200;
-}                                                                              
+}
diff --git a/ojluni/src/main/java/sun/nio/fs/UnixCopyFile.java b/ojluni/src/main/java/sun/nio/fs/UnixCopyFile.java
index 67b4695b71a..cdf26604e2f 100644
--- a/ojluni/src/main/java/sun/nio/fs/UnixCopyFile.java
+++ b/ojluni/src/main/java/sun/nio/fs/UnixCopyFile.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,13 +25,18 @@
 
 package sun.nio.fs;
 
-import java.nio.file.*;
 import java.io.IOException;
+import java.nio.file.AtomicMoveNotSupportedException;
+import java.nio.file.CopyOption;
+import java.nio.file.DirectoryNotEmptyException;
+import java.nio.file.FileAlreadyExistsException;
+import java.nio.file.LinkOption;
+import java.nio.file.LinkPermission;
+import java.nio.file.StandardCopyOption;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
-import com.sun.nio.file.ExtendedCopyOption;
 
 import static sun.nio.fs.UnixNativeDispatcher.*;
 import static sun.nio.fs.UnixConstants.*;
@@ -82,7 +87,7 @@ class UnixCopyFile {
                     flags.failIfUnableToCopyBasic = true;
                     continue;
                 }
-                if (option == ExtendedCopyOption.INTERRUPTIBLE) {
+                if (ExtendedOptions.INTERRUPTIBLE.matches(option)) {
                     flags.interruptible = true;
                     continue;
                 }
@@ -368,6 +373,22 @@ class UnixCopyFile {
         }
     }
 
+    // throw a DirectoryNotEmpty exception if appropriate
+    static void ensureEmptyDir(UnixPath dir) throws IOException {
+        try {
+            long ptr = opendir(dir);
+            try (UnixDirectoryStream stream =
+                new UnixDirectoryStream(dir, ptr, e -> true)) {
+                if (stream.iterator().hasNext()) {
+                    throw new DirectoryNotEmptyException(
+                        dir.getPathForExceptionMessage());
+                }
+            }
+        } catch (UnixException e) {
+            e.rethrowAsIOException(dir);
+        }
+    }
+
     // move file from source to target
     static void move(UnixPath source, UnixPath target, CopyOption... options)
         throws IOException
@@ -460,6 +481,7 @@ class UnixCopyFile {
 
         // copy source to target
         if (sourceAttrs.isDirectory()) {
+            ensureEmptyDir(source);
             copyDirectory(source, sourceAttrs, target, flags);
         } else {
             if (sourceAttrs.isSymbolicLink()) {
@@ -608,7 +630,7 @@ class UnixCopyFile {
     // Android-removed: Code to load native libraries, doesn't make sense on Android.
     /*
     static {
-        AccessController.doPrivileged(new PrivilegedAction<Void>() {
+        AccessController.doPrivileged(new PrivilegedAction<>() {
             @Override
             public Void run() {
                 System.loadLibrary("nio");
diff --git a/ojluni/src/main/java/sun/nio/fs/UnixDirectoryStream.java b/ojluni/src/main/java/sun/nio/fs/UnixDirectoryStream.java
index 3a3c715b699..57fcdf76ca6 100644
--- a/ojluni/src/main/java/sun/nio/fs/UnixDirectoryStream.java
+++ b/ojluni/src/main/java/sun/nio/fs/UnixDirectoryStream.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -51,7 +51,7 @@ class UnixDirectoryStream
     // filter (may be null)
     private final DirectoryStream.Filter<? super Path> filter;
 
-    // used to coorindate closing of directory stream
+    // used to coordinate closing of directory stream
     private final ReentrantReadWriteLock streamLock =
         new ReentrantReadWriteLock(true);
 
@@ -128,7 +128,7 @@ class UnixDirectoryStream
         synchronized (this) {
             if (iterator != null)
                 throw new IllegalStateException("Iterator already obtained");
-            iterator = new UnixDirectoryIterator(ds);
+            iterator = new UnixDirectoryIterator();
             return iterator;
         }
     }
@@ -142,17 +142,14 @@ class UnixDirectoryStream
      * Iterator implementation
      */
     private class UnixDirectoryIterator implements Iterator<Path> {
-        private final DirectoryStream<Path> stream;
-
         // true when at EOF
         private boolean atEof;
 
         // next entry to return
         private Path nextEntry;
 
-        UnixDirectoryIterator(DirectoryStream<Path> stream) {
+        UnixDirectoryIterator() {
             atEof = false;
-            this.stream = stream;
         }
 
         // Return true if file name is "." or ".."
diff --git a/ojluni/src/main/java/sun/nio/fs/UnixFileAttributeViews.java b/ojluni/src/main/java/sun/nio/fs/UnixFileAttributeViews.java
index 4d719d3aace..6d43c0f4e95 100644
--- a/ojluni/src/main/java/sun/nio/fs/UnixFileAttributeViews.java
+++ b/ojluni/src/main/java/sun/nio/fs/UnixFileAttributeViews.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2015, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -71,14 +71,30 @@ class UnixFileAttributeViews {
             // permission check
             file.checkWrite();
 
-            int fd = file.openForAttributeAccess(followLinks);
+            boolean haveFd = false;
+            boolean useFutimes = false;
+            int fd = -1;
+            try {
+                fd = file.openForAttributeAccess(followLinks);
+                if (fd != -1) {
+                    haveFd = true;
+                    useFutimes = futimesSupported();
+                }
+            } catch (UnixException x) {
+                if (x.errno() != UnixConstants.ENXIO) {
+                    x.rethrowAsIOException(file);
+                }
+            }
+
             try {
                 // assert followLinks || !UnixFileAttributes.get(fd).isSymbolicLink();
 
                 // if not changing both attributes then need existing attributes
                 if (lastModifiedTime == null || lastAccessTime == null) {
                     try {
-                        UnixFileAttributes attrs = UnixFileAttributes.get(fd);
+                        UnixFileAttributes attrs = haveFd ?
+                            UnixFileAttributes.get(fd) :
+                            UnixFileAttributes.get(file, followLinks);
                         if (lastModifiedTime == null)
                             lastModifiedTime = attrs.lastModifiedTime();
                         if (lastAccessTime == null)
@@ -94,7 +110,7 @@ class UnixFileAttributeViews {
 
                 boolean retry = false;
                 try {
-                    if (futimesSupported()) {
+                    if (useFutimes) {
                         futimes(fd, accessValue, modValue);
                     } else {
                         utimes(file, accessValue, modValue);
@@ -113,7 +129,7 @@ class UnixFileAttributeViews {
                     if (modValue < 0L) modValue = 0L;
                     if (accessValue < 0L) accessValue= 0L;
                     try {
-                        if (futimesSupported()) {
+                        if (useFutimes) {
                             futimes(fd, accessValue, modValue);
                         } else {
                             utimes(file, accessValue, modValue);
@@ -133,7 +149,7 @@ class UnixFileAttributeViews {
         private static final String OWNER_NAME = "owner";
         private static final String GROUP_NAME = "group";
 
-        // the names of the posix attributes (incudes basic)
+        // the names of the posix attributes (includes basic)
         static final Set<String> posixAttributeNames =
             Util.newSet(basicAttributeNames, PERMISSIONS_NAME, OWNER_NAME, GROUP_NAME);
 
diff --git a/ojluni/src/main/java/sun/nio/fs/UnixFileStore.java b/ojluni/src/main/java/sun/nio/fs/UnixFileStore.java
index 8c7031b9aaa..39ba424ede8 100644
--- a/ojluni/src/main/java/sun/nio/fs/UnixFileStore.java
+++ b/ojluni/src/main/java/sun/nio/fs/UnixFileStore.java
@@ -25,6 +25,8 @@
 
 package sun.nio.fs;
 
+import jdk.internal.util.StaticProperty;
+
 import java.nio.file.*;
 import java.nio.file.attribute.*;
 import java.util.*;
diff --git a/ojluni/src/main/java/sun/nio/fs/UnixFileSystem.java b/ojluni/src/main/java/sun/nio/fs/UnixFileSystem.java
index c902acea980..f3a98bdfced 100644
--- a/ojluni/src/main/java/sun/nio/fs/UnixFileSystem.java
+++ b/ojluni/src/main/java/sun/nio/fs/UnixFileSystem.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2015, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -31,7 +31,6 @@ import java.nio.file.spi.*;
 import java.io.IOException;
 import java.util.*;
 import java.util.regex.Pattern;
-import java.security.AccessController;
 import sun.security.action.GetPropertyAction;
 
 /**
@@ -57,10 +56,9 @@ abstract class UnixFileSystem
         // if process-wide chdir is allowed or default directory is not the
         // process working directory then paths must be resolved against the
         // default directory.
-        String propValue = AccessController.doPrivileged(
-            new GetPropertyAction("sun.nio.fs.chdirAllowed", "false"));
-        boolean chdirAllowed = (propValue.length() == 0) ?
-            true : Boolean.valueOf(propValue);
+        String propValue = GetPropertyAction
+                .privilegedGetProperty("sun.nio.fs.chdirAllowed", "false");
+        boolean chdirAllowed = propValue.isEmpty() ? true : Boolean.parseBoolean(propValue);
         if (chdirAllowed) {
             this.needToResolveAgainstDefaultDirectory = true;
         } else {
@@ -152,7 +150,7 @@ abstract class UnixFileSystem
     public final Iterable<Path> getRootDirectories() {
         final List<Path> allowedList =
            Collections.unmodifiableList(Arrays.asList((Path)rootDirectory));
-        return new Iterable<Path>() {
+        return new Iterable<>() {
             public Iterator<Path> iterator() {
                 try {
                     SecurityManager sm = System.getSecurityManager();
@@ -254,7 +252,7 @@ abstract class UnixFileSystem
                 return Collections.emptyList();
             }
         }
-        return new Iterable<FileStore>() {
+        return new Iterable<>() {
             public Iterator<FileStore> iterator() {
                 return new FileStoreIterator();
             }
@@ -270,7 +268,7 @@ abstract class UnixFileSystem
             StringBuilder sb = new StringBuilder();
             sb.append(first);
             for (String segment: more) {
-                if (segment.length() > 0) {
+                if (!segment.isEmpty()) {
                     if (sb.length() > 0)
                         sb.append('/');
                     sb.append(segment);
@@ -290,10 +288,10 @@ abstract class UnixFileSystem
         String input = syntaxAndInput.substring(pos+1);
 
         String expr;
-        if (syntax.equals(GLOB_SYNTAX)) {
+        if (syntax.equalsIgnoreCase(GLOB_SYNTAX)) {
             expr = Globs.toUnixRegexPattern(input);
         } else {
-            if (syntax.equals(REGEX_SYNTAX)) {
+            if (syntax.equalsIgnoreCase(REGEX_SYNTAX)) {
                 expr = input;
             } else {
                 throw new UnsupportedOperationException("Syntax '" + syntax +
@@ -339,7 +337,7 @@ abstract class UnixFileSystem
             };
     }
 
-    // Override if the platform has different path match requrement, such as
+    // Override if the platform has different path match requirement, such as
     // case insensitive or Unicode canonical equal on MacOSX
     Pattern compilePathMatchPattern(String expr) {
         return Pattern.compile(expr);
diff --git a/ojluni/src/main/java/sun/nio/fs/UnixNativeDispatcher.java b/ojluni/src/main/java/sun/nio/fs/UnixNativeDispatcher.java
index 025617c5e0d..f87e88c2dc5 100644
--- a/ojluni/src/main/java/sun/nio/fs/UnixNativeDispatcher.java
+++ b/ojluni/src/main/java/sun/nio/fs/UnixNativeDispatcher.java
@@ -91,9 +91,14 @@ class UnixNativeDispatcher {
         throws UnixException;
 
     /**
-     * close(int filedes)
+     * close(int filedes). If fd is -1 this is a no-op.
      */
-    static native void close(int fd);
+    static void close(int fd) {
+        if (fd != -1) {
+            close0(fd);
+        }
+    }
+    private static native void close0(int fd);
 
     /**
      * FILE* fopen(const char *filename, const char* mode);
@@ -116,6 +121,16 @@ class UnixNativeDispatcher {
      */
     static native void fclose(long stream) throws UnixException;
 
+    /**
+     * void rewind(FILE* stream);
+     */
+    static native void rewind(long stream) throws UnixException;
+
+    /**
+     * ssize_t getline(char **lineptr, size_t *n, FILE *stream);
+     */
+    static native int getlinelen(long stream) throws UnixException;
+
     /**
      * link(const char* existing, const char* new)
      */
@@ -603,7 +618,7 @@ class UnixNativeDispatcher {
     static {
         // Android-removed: Code to load native libraries, doesn't make sense on Android.
         /*
-        AccessController.doPrivileged(new PrivilegedAction<Void>() {
+        AccessController.doPrivileged(new PrivilegedAction<>() {
             public Void run() {
                 System.loadLibrary("nio");
                 return null;
diff --git a/ojluni/src/main/java/sun/nio/fs/UnixPath.java b/ojluni/src/main/java/sun/nio/fs/UnixPath.java
index 90a82f36819..19382e2650b 100644
--- a/ojluni/src/main/java/sun/nio/fs/UnixPath.java
+++ b/ojluni/src/main/java/sun/nio/fs/UnixPath.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2015, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -40,9 +40,7 @@ import static sun.nio.fs.UnixConstants.*;
  * Solaris/Linux implementation of java.nio.file.Path
  */
 
-class UnixPath
-    extends AbstractPath
-{
+class UnixPath implements Path {
     private static ThreadLocal<SoftReference<CharsetEncoder>> encoder =
         new ThreadLocal<SoftReference<CharsetEncoder>>();
 
@@ -123,7 +121,7 @@ class UnixPath
             ce = Util.jnuEncoding().newEncoder()
                 .onMalformedInput(CodingErrorAction.REPORT)
                 .onUnmappableCharacter(CodingErrorAction.REPORT);
-            encoder.set(new SoftReference<CharsetEncoder>(ce));
+            encoder.set(new SoftReference<>(ce));
         }
 
         char[] ca = fs.normalizeNativePath(input.toCharArray());
@@ -245,6 +243,7 @@ class UnixPath
     }
 
     // returns {@code true} if this path is an empty path
+    // Android-changed: Make it package-private until UnixFileSystemProvider is updated to 11.
     boolean isEmpty() {
         return path.length == 0;
     }
@@ -766,11 +765,11 @@ class UnixPath
     // -- file operations --
 
     // package-private
-    int openForAttributeAccess(boolean followLinks) throws IOException {
+    int openForAttributeAccess(boolean followLinks) throws UnixException {
         int flags = O_RDONLY;
         if (!followLinks) {
             if (O_NOFOLLOW == 0)
-                throw new IOException("NOFOLLOW_LINKS is not supported on this platform");
+                throw new UnixException("NOFOLLOW_LINKS is not supported on this platform");
             flags |= O_NOFOLLOW;
         }
         try {
@@ -780,12 +779,7 @@ class UnixPath
             if (getFileSystem().isSolaris() && x.errno() == EINVAL)
                 x.setError(ELOOP);
 
-            if (x.errno() == ELOOP)
-                throw new FileSystemException(getPathForExceptionMessage(), null,
-                    x.getMessage() + " or unable to access attributes of symbolic link");
-
-            x.rethrowAsIOException(this);
-            return -1; // keep compile happy
+            throw x;
         }
     }
 
diff --git a/ojluni/src/main/java/sun/nio/fs/UnixUriUtils.java b/ojluni/src/main/java/sun/nio/fs/UnixUriUtils.java
index 4d6f302acf6..9adbc2747f5 100644
--- a/ojluni/src/main/java/sun/nio/fs/UnixUriUtils.java
+++ b/ojluni/src/main/java/sun/nio/fs/UnixUriUtils.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -49,11 +49,11 @@ class UnixUriUtils {
         String scheme = uri.getScheme();
         if ((scheme == null) || !scheme.equalsIgnoreCase("file"))
             throw new IllegalArgumentException("URI scheme is not \"file\"");
-        if (uri.getAuthority() != null)
+        if (uri.getRawAuthority() != null)
             throw new IllegalArgumentException("URI has an authority component");
-        if (uri.getFragment() != null)
+        if (uri.getRawFragment() != null)
             throw new IllegalArgumentException("URI has a fragment component");
-        if (uri.getQuery() != null)
+        if (uri.getRawQuery() != null)
             throw new IllegalArgumentException("URI has a query component");
 
         // compatibility with java.io.File
@@ -83,9 +83,14 @@ class UnixUriUtils {
                 if (b == 0)
                     throw new IllegalArgumentException("Nul character not allowed");
             } else {
-                assert c < 0x80;
+                if (c == 0 || c >= 0x80)
+                    throw new IllegalArgumentException("Bad escape");
                 b = (byte)c;
             }
+            if (b == '/' && rlen > 0 && result[rlen-1] == '/') {
+                // skip redundant slashes
+                continue;
+            }
             result[rlen++] = b;
         }
         if (rlen != result.length)
@@ -115,11 +120,11 @@ class UnixUriUtils {
         // trailing slash if directory
         if (sb.charAt(sb.length()-1) != '/') {
             try {
-                 if (UnixFileAttributes.get(up, true).isDirectory())
-                     sb.append('/');
-            } catch (UnixException x) {
-                // ignore
-            }
+                up.checkRead();
+                int mode = UnixNativeDispatcher.stat(up);
+                if ((mode & UnixConstants.S_IFMT) == UnixConstants.S_IFDIR)
+                    sb.append('/');
+            } catch (SecurityException ignore) { }
         }
 
         try {
@@ -242,7 +247,7 @@ class UnixUriUtils {
    private static final long L_PATH = L_PCHAR | lowMask(";/");
    private static final long H_PATH = H_PCHAR | highMask(";/");
 
-   private final static char[] hexDigits = {
+   private static final char[] hexDigits = {
         '0', '1', '2', '3', '4', '5', '6', '7',
         '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
     };
diff --git a/ojluni/src/main/java/sun/nio/fs/Util.java b/ojluni/src/main/java/sun/nio/fs/Util.java
index 08a3025a5eb..77bc7627b19 100644
--- a/ojluni/src/main/java/sun/nio/fs/Util.java
+++ b/ojluni/src/main/java/sun/nio/fs/Util.java
@@ -28,8 +28,7 @@ package sun.nio.fs;
 import java.util.*;
 import java.nio.file.*;
 import java.nio.charset.Charset;
-import java.security.*;
-import sun.security.action.*;
+import sun.security.action.GetPropertyAction;
 
 /**
  * Utility methods
@@ -41,7 +40,7 @@ class Util {
     // Android-changed: Hard-code UTF-8 for jnuEncoding rather than requiring a system property.
     // The system property sun.jnu.encoding is not set on Android; we just hard-code "UTF-8" here.
     // private static final Charset jnuEncoding = Charset.forName(
-    //    AccessController.doPrivileged(new GetPropertyAction("sun.jnu.encoding")));
+    //    GetPropertyAction.privilegedGetProperty("sun.jnu.encoding"));
     private static final Charset jnuEncoding = Charset.forName("UTF-8");
 
     /**
diff --git a/ojluni/src/main/java/sun/security/action/GetPropertyAction.java b/ojluni/src/main/java/sun/security/action/GetPropertyAction.java
index edaedc64ae8..f4c07f29a28 100644
--- a/ojluni/src/main/java/sun/security/action/GetPropertyAction.java
+++ b/ojluni/src/main/java/sun/security/action/GetPropertyAction.java
@@ -27,7 +27,9 @@ package sun.security.action;
 
 import java.security.AccessController;
 import java.security.PrivilegedAction;
+import java.util.Locale;
 import java.util.Properties;
+import sun.security.util.Debug;
 
 /**
  * A convenience class for retrieving the string value of a system
@@ -159,4 +161,37 @@ public class GetPropertyAction implements PrivilegedAction<String> {
             );
         }
     }
+
+    /**
+     * Convenience method for fetching System property values that are booleans.
+     *
+     * @param prop the name of the System property
+     * @param def a default value
+     * @param dbg a Debug object, if null no debug messages will be sent
+     *
+     * @return a boolean value corresponding to the value in the System property.
+     *      If the property value is neither "true" or "false", the default value
+     *      will be returned.
+     */
+    public static boolean privilegedGetBooleanProp(String prop, boolean def, Debug dbg) {
+        String rawPropVal = privilegedGetProperty(prop, "");
+        if ("".equals(rawPropVal)) {
+            return def;
+        }
+
+        String lower = rawPropVal.toLowerCase(Locale.ROOT);
+        if ("true".equals(lower)) {
+            return true;
+        } else if ("false".equals(lower)) {
+            return false;
+        } else {
+            if (dbg != null) {
+                dbg.println("Warning: Unexpected value for " + prop +
+                            ": " + rawPropVal +
+                            ". Using default value: " + def);
+            }
+            return def;
+        }
+    }
+
 }
diff --git a/ojluni/src/main/java/sun/security/provider/certpath/CertPathHelper.java b/ojluni/src/main/java/sun/security/provider/certpath/CertPathHelper.java
index af6da8a2686..5dcb6ceda36 100644
--- a/ojluni/src/main/java/sun/security/provider/certpath/CertPathHelper.java
+++ b/ojluni/src/main/java/sun/security/provider/certpath/CertPathHelper.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,15 +26,12 @@
 package sun.security.provider.certpath;
 
 import java.util.Date;
-import java.util.Set;
 
-import java.security.cert.X509CertSelector;
+import java.security.cert.TrustAnchor;
 import java.security.cert.X509CRLSelector;
 
-import sun.security.x509.GeneralNameInterface;
-
 /**
- * Helper class that allows access to Sun specific known-public methods in the
+ * Helper class that allows access to JDK specific known-public methods in the
  * java.security.cert package. It relies on a subclass in the
  * java.security.cert packages that is initialized before any of these methods
  * are called (achieved via static initializers).
@@ -54,17 +51,19 @@ public abstract class CertPathHelper {
         // empty
     }
 
-    protected abstract void implSetPathToNames(X509CertSelector sel,
-            Set<GeneralNameInterface> names);
-
     protected abstract void implSetDateAndTime(X509CRLSelector sel, Date date, long skew);
 
-    static void setPathToNames(X509CertSelector sel,
-            Set<GeneralNameInterface> names) {
-        instance.implSetPathToNames(sel, names);
-    }
+    // Android-removed: Temporarily remove this method until subclasses are updated to 11.
+    // protected abstract boolean implIsJdkCA(TrustAnchor anchor);
 
     public static void setDateAndTime(X509CRLSelector sel, Date date, long skew) {
         instance.implSetDateAndTime(sel, date, skew);
     }
+
+    // Android-removed: Temporarily remove this method until subclasses are updated to 11.
+    /*
+    public static boolean isJdkCA(TrustAnchor anchor) {
+        return (anchor == null) ? false : instance.implIsJdkCA(anchor);
+    }
+    */
 }
diff --git a/ojluni/src/main/java/sun/security/provider/certpath/ForwardBuilder.java b/ojluni/src/main/java/sun/security/provider/certpath/ForwardBuilder.java
index 27bb25fc4d8..1a8e293b2f2 100644
--- a/ojluni/src/main/java/sun/security/provider/certpath/ForwardBuilder.java
+++ b/ojluni/src/main/java/sun/security/provider/certpath/ForwardBuilder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -257,14 +257,6 @@ class ForwardBuilder extends Builder {
              */
             caSelector.setSubject(currentState.issuerDN);
 
-            /*
-             * Match on subjectNamesTraversed (both DNs and AltNames)
-             * (checks that current cert's name constraints permit it
-             * to certify all the DNs and AltNames that have been traversed)
-             */
-            CertPathHelper.setPathToNames
-                (caSelector, currentState.subjectNamesTraversed);
-
             /*
              * check the validity period
              */
@@ -294,9 +286,7 @@ class ForwardBuilder extends Builder {
                         "\n  Issuer: " +
                             trustedCert.getIssuerX500Principal());
                 }
-                if (caCerts.add(trustedCert) && !searchAllCertStores) {
-                    return;
-                }
+                caCerts.add(trustedCert);
             }
         }
 
@@ -346,8 +336,11 @@ class ForwardBuilder extends Builder {
         }
     }
 
+    // Thread-local gate to prevent recursive provider lookups
+    private static ThreadLocal<Object> gate = new ThreadLocal<>();
+
     /**
-     * Download Certificates from the given AIA and add them to the
+     * Download certificates from the given AIA and add them to the
      * specified Collection.
      */
     // cs.getCertificates(caSelector) returns a collection of X509Certificate's
@@ -359,32 +352,47 @@ class ForwardBuilder extends Builder {
         if (Builder.USE_AIA == false) {
             return false;
         }
+
         List<AccessDescription> adList = aiaExt.getAccessDescriptions();
         if (adList == null || adList.isEmpty()) {
             return false;
         }
 
-        boolean add = false;
-        for (AccessDescription ad : adList) {
-            CertStore cs = URICertStore.getInstance(ad);
-            if (cs != null) {
-                try {
-                    if (certs.addAll((Collection<X509Certificate>)
-                        cs.getCertificates(caSelector))) {
-                        add = true;
-                        if (!searchAllCertStores) {
-                            return true;
+        if (gate.get() != null) {
+            // Avoid recursive fetching of certificates
+            if (debug != null) {
+                debug.println("Recursive fetching of certs via the AIA " +
+                    "extension detected");
+            }
+            return false;
+        }
+
+        gate.set(gate);
+        try {
+            boolean add = false;
+            for (AccessDescription ad : adList) {
+                CertStore cs = URICertStore.getInstance(ad);
+                if (cs != null) {
+                    try {
+                        if (certs.addAll((Collection<X509Certificate>)
+                            cs.getCertificates(caSelector))) {
+                            add = true;
+                            if (!searchAllCertStores) {
+                                return true;
+                            }
+                        }
+                    } catch (CertStoreException cse) {
+                        if (debug != null) {
+                            debug.println("exception getting certs from CertStore:");
+                            cse.printStackTrace();
                         }
-                    }
-                } catch (CertStoreException cse) {
-                    if (debug != null) {
-                        debug.println("exception getting certs from CertStore:");
-                        cse.printStackTrace();
                     }
                 }
             }
+            return add;
+        } finally {
+            gate.set(null);
         }
-        return add;
     }
 
     /**
@@ -675,8 +683,7 @@ class ForwardBuilder extends Builder {
      * only be executed in a reverse direction are deferred until the
      * complete path has been built.
      *
-     * Trust anchor certs are not validated, but are used to verify the
-     * signature and revocation status of the previous cert.
+     * Trust anchor certs are not validated.
      *
      * If the last certificate is being verified (the one whose subject
      * matches the target subject, then steps in 6.1.4 of the PKIX
@@ -709,21 +716,6 @@ class ForwardBuilder extends Builder {
         // currState.untrustedChecker.check(cert, Collections.<String>emptySet());
         // END Android-removed: Certificate checking
 
-        /*
-         * check for looping - abort a loop if we encounter the same
-         * certificate twice
-         */
-        if (certPathList != null) {
-            for (X509Certificate cpListCert : certPathList) {
-                if (cert.equals(cpListCert)) {
-                    if (debug != null) {
-                        debug.println("loop detected!!");
-                    }
-                    throw new CertPathValidatorException("loop detected");
-                }
-            }
-        }
-
         /* check if trusted cert */
         boolean isTrustedCert = trustedCerts.contains(cert);
 
@@ -799,27 +791,6 @@ class ForwardBuilder extends Builder {
              */
             KeyChecker.verifyCAKeyUsage(cert);
         }
-
-        /*
-         * the following checks are performed even when the cert
-         * is a trusted cert, since we are only extracting the
-         * subjectDN, and publicKey from the cert
-         * in order to verify a previous cert
-         */
-
-        /*
-         * Check signature only if no key requiring key parameters has been
-         * encountered.
-         */
-        if (!currState.keyParamsNeeded()) {
-            // Android-changed: sigProvider is not required
-            if (buildParams.sigProvider() != null) {
-                (currState.cert).verify(cert.getPublicKey(),
-                                        buildParams.sigProvider());
-            } else {
-                (currState.cert).verify(cert.getPublicKey());
-            }
-        }
     }
 
     /**
diff --git a/ojluni/src/main/java/sun/security/provider/certpath/X509CertPath.java b/ojluni/src/main/java/sun/security/provider/certpath/X509CertPath.java
index f738b5f5fe0..79cde0d72fd 100644
--- a/ojluni/src/main/java/sun/security/provider/certpath/X509CertPath.java
+++ b/ojluni/src/main/java/sun/security/provider/certpath/X509CertPath.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,10 +25,7 @@
 
 package sun.security.provider.certpath;
 
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
+import java.io.*;
 import java.security.cert.CertificateEncodingException;
 import java.security.cert.Certificate;
 import java.security.cert.CertificateException;
@@ -394,4 +391,19 @@ public class X509CertPath extends CertPath {
     public List<X509Certificate> getCertificates() {
         return certs;
     }
+
+    /**
+     * Restores the state of this object from the stream.
+     * <p>
+     * Deserialization of this object is not supported.
+     *
+     * @param  stream the {@code ObjectInputStream} from which data is read
+     * @throws IOException if an I/O error occurs
+     * @throws ClassNotFoundException if a serialized class cannot be loaded
+     */
+    private void readObject(ObjectInputStream stream)
+            throws IOException, ClassNotFoundException {
+        throw new InvalidObjectException(
+                "X509CertPaths are not directly deserializable");
+    }
 }
diff --git a/ojluni/src/main/native/LinuxNativeDispatcher.c b/ojluni/src/main/native/LinuxNativeDispatcher.c
index c8500db5c87..48df9b7c197 100644
--- a/ojluni/src/main/native/LinuxNativeDispatcher.c
+++ b/ojluni/src/main/native/LinuxNativeDispatcher.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -169,12 +169,11 @@ Java_sun_nio_fs_LinuxNativeDispatcher_setmntent0(JNIEnv* env, jclass this, jlong
 }
 
 JNIEXPORT jint JNICALL
-Java_sun_nio_fs_LinuxNativeDispatcher_getmntent(JNIEnv* env, jclass this,
-    jlong value, jobject entry)
+Java_sun_nio_fs_LinuxNativeDispatcher_getmntent0(JNIEnv* env, jclass this,
+    jlong value, jobject entry, jlong buffer, jint bufLen)
 {
     struct mntent ent;
-    char buf[1024];
-    int buflen = sizeof(buf);
+    char * buf = (char*)jlong_to_ptr(buffer);
     struct mntent* m;
     FILE* fp = jlong_to_ptr(value);
     jsize len;
@@ -184,7 +183,7 @@ Java_sun_nio_fs_LinuxNativeDispatcher_getmntent(JNIEnv* env, jclass this,
     char* fstype;
     char* options;
 
-    m = getmntent_r(fp, &ent, (char*)&buf, buflen);
+    m = getmntent_r(fp, &ent, buf, (int)bufLen);
     if (m == NULL)
         return -1;
     name = m->mnt_fsname;
diff --git a/ojluni/src/main/native/UnixNativeDispatcher.c b/ojluni/src/main/native/UnixNativeDispatcher.c
index 6710e13be51..2de1ad428cc 100644
--- a/ojluni/src/main/native/UnixNativeDispatcher.c
+++ b/ojluni/src/main/native/UnixNativeDispatcher.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,19 +29,33 @@
 #include <fcntl.h>
 #include <dirent.h>
 #include <unistd.h>
-#include <pwd.h>
-#include <grp.h>
 #include <errno.h>
 #include <dlfcn.h>
 #include <sys/types.h>
 #include <sys/stat.h>
+#ifdef MACOSX
+#include <sys/param.h>
+#include <sys/mount.h>
+#else
 #include <sys/statvfs.h>
+#endif
 #include <sys/time.h>
 
+/* For POSIX-compliant getpwuid_r, getgrgid_r on Solaris */
+#if defined(__solaris__)
+#define _POSIX_PTHREAD_SEMANTICS
+#endif
+#include <pwd.h>
+#include <grp.h>
+
 #ifdef __solaris__
 #include <strings.h>
 #endif
 
+#ifdef __linux__
+#include <sys/syscall.h>
+#endif
+
 #if defined(__linux__) || defined(_AIX)
 #include <string.h>
 #endif
@@ -52,15 +66,14 @@
 #include <string.h>
 
 #define stat64 stat
+#ifndef MACOSX
 #define statvfs64 statvfs
+#endif
 
 #define open64 open
 #define fstat64 fstat
 #define lstat64 lstat
 #define dirent64 dirent
-// Android-changed: Integrate OpenJDK 12 commit to use readdir, not readdir_r. b/64362645
-// Integrate UnixNativeDispatcher.c changes from http://hg.openjdk.java.net/jdk/jdk/rev/90144bc10fe6
-// #define readdir64_r readdir_r
 #define readdir64 readdir
 #endif
 
@@ -70,6 +83,12 @@
 
 #include "sun_nio_fs_UnixNativeDispatcher.h"
 
+#if defined(_AIX)
+  #define DIR DIR64
+  #define opendir opendir64
+  #define closedir closedir64
+#endif
+
 /**
  * Size of password or group entry when not available via sysconf
  */
@@ -150,14 +169,11 @@ static int fstatat64_wrapper(int dfd, const char *path,
 }
 #endif
 
-#if defined(__linux__) && defined(__x86_64__)
+#if defined(__linux__) && defined(_LP64) && defined(__NR_newfstatat)
 #define FSTATAT64_SYSCALL_AVAILABLE
 static int fstatat64_wrapper(int dfd, const char *path,
                              struct stat64 *statbuf, int flag)
 {
-    #ifndef __NR_newfstatat
-    #define __NR_newfstatat  262
-    #endif
     return syscall(__NR_newfstatat, dfd, path, statbuf, flag);
 }
 #endif
@@ -256,7 +272,11 @@ Java_sun_nio_fs_UnixNativeDispatcher_init(JNIEnv* env, jclass this)
     my_unlinkat_func = (unlinkat_func*) dlsym(RTLD_DEFAULT, "unlinkat");
     my_renameat_func = (renameat_func*) dlsym(RTLD_DEFAULT, "renameat");
     my_futimesat_func = (futimesat_func*) dlsym(RTLD_DEFAULT, "futimesat");
+#if defined(_AIX)
+    my_fdopendir_func = (fdopendir_func*) dlsym(RTLD_DEFAULT, "fdopendir64");
+#else
     my_fdopendir_func = (fdopendir_func*) dlsym(RTLD_DEFAULT, "fdopendir");
+#endif
 
 #if defined(FSTATAT64_SYSCALL_AVAILABLE)
     /* fstatat64 missing from glibc */
@@ -313,21 +333,15 @@ Java_sun_nio_fs_UnixNativeDispatcher_getcwd(JNIEnv* env, jclass this) {
 JNIEXPORT jbyteArray
 Java_sun_nio_fs_UnixNativeDispatcher_strerror(JNIEnv* env, jclass this, jint error)
 {
-    char* msg;
+    char tmpbuf[1024];
     jsize len;
     jbyteArray bytes;
 
-#ifdef _AIX
-    /* strerror() is not thread-safe on AIX so we have to use strerror_r() */
-    char buffer[256];
-    msg = (strerror_r((int)error, buffer, 256) == 0) ? buffer : "Error while calling strerror_r";
-#else
-    msg = strerror((int)error);
-#endif
-    len = strlen(msg);
+    getErrorString((int)errno, tmpbuf, sizeof(tmpbuf));
+    len = strlen(tmpbuf);
     bytes = (*env)->NewByteArray(env, len);
     if (bytes != NULL) {
-        (*env)->SetByteArrayRegion(env, bytes, 0, len, (jbyte*)msg);
+        (*env)->SetByteArrayRegion(env, bytes, 0, len, (jbyte*)tmpbuf);
     }
     return bytes;
 }
@@ -378,6 +392,51 @@ Java_sun_nio_fs_UnixNativeDispatcher_fclose(JNIEnv* env, jclass this, jlong stre
     }
 }
 
+JNIEXPORT void JNICALL
+Java_sun_nio_fs_UnixNativeDispatcher_rewind(JNIEnv* env, jclass this, jlong stream)
+{
+    FILE* fp = jlong_to_ptr(stream);
+    int saved_errno;
+
+    errno = 0;
+    rewind(fp);
+    saved_errno = errno;
+    if (ferror(fp)) {
+        throwUnixException(env, saved_errno);
+    }
+}
+
+/**
+ * This function returns line length without NUL terminator or -1 on EOF.
+ */
+JNIEXPORT jint JNICALL
+Java_sun_nio_fs_UnixNativeDispatcher_getlinelen(JNIEnv* env, jclass this, jlong stream)
+{
+    FILE* fp = jlong_to_ptr(stream);
+    size_t lineSize = 0;
+    char * lineBuffer = NULL;
+    int saved_errno;
+
+    ssize_t res = getline(&lineBuffer, &lineSize, fp);
+    saved_errno = errno;
+
+    /* Should free lineBuffer no matter result, according to man page */
+    if (lineBuffer != NULL)
+        free(lineBuffer);
+
+    if (feof(fp))
+        return -1;
+
+    /* On successfull return res >= 0, otherwise res is -1 */
+    if (res == -1)
+        throwUnixException(env, saved_errno);
+
+    if (res > INT_MAX)
+        throwUnixException(env, EOVERFLOW);
+
+    return (jint)res;
+}
+
 JNIEXPORT jint JNICALL
 Java_sun_nio_fs_UnixNativeDispatcher_open0(JNIEnv* env, jclass this,
     jlong pathAddress, jint oflags, jint mode)
@@ -412,11 +471,7 @@ Java_sun_nio_fs_UnixNativeDispatcher_openat0(JNIEnv* env, jclass this, jint dfd,
 }
 
 JNIEXPORT void JNICALL
-Java_sun_nio_fs_UnixNativeDispatcher_close(JNIEnv* env, jclass this, jint fd) {
-// BEGIN Android-changed: Integrate OpenJDK 12 commit to use readdir, not readdir_r. b/64362645
-//    int err;
-//    /* TDB - need to decide if EIO and other errors should cause exception */
-//    RESTARTABLE(close((int)fd), err);
+Java_sun_nio_fs_UnixNativeDispatcher_close0(JNIEnv* env, jclass this, jint fd) {
     int res;
 
 #if defined(_AIX)
@@ -428,7 +483,6 @@ Java_sun_nio_fs_UnixNativeDispatcher_close(JNIEnv* env, jclass this, jint fd) {
     if (res == -1 && errno != EINTR) {
         throwUnixException(env, errno);
     }
-// END Android-changed: Integrate OpenJDK 12 commit to use readdir, not readdir_r. b/64362645
 }
 
 JNIEXPORT jint JNICALL
@@ -477,10 +531,14 @@ static void prepAttributes(JNIEnv* env, struct stat64* buf, jobject attrs) {
     (*env)->SetLongField(env, attrs, attrs_st_birthtime_sec, (jlong)buf->st_birthtime);
 #endif
 
-#if (_POSIX_C_SOURCE >= 200809L) || defined(__solaris__)
+#ifndef MACOSX
     (*env)->SetLongField(env, attrs, attrs_st_atime_nsec, (jlong)buf->st_atim.tv_nsec);
     (*env)->SetLongField(env, attrs, attrs_st_mtime_nsec, (jlong)buf->st_mtim.tv_nsec);
     (*env)->SetLongField(env, attrs, attrs_st_ctime_nsec, (jlong)buf->st_ctim.tv_nsec);
+#else
+    (*env)->SetLongField(env, attrs, attrs_st_atime_nsec, (jlong)buf->st_atimespec.tv_nsec);
+    (*env)->SetLongField(env, attrs, attrs_st_mtime_nsec, (jlong)buf->st_mtimespec.tv_nsec);
+    (*env)->SetLongField(env, attrs, attrs_st_ctime_nsec, (jlong)buf->st_ctimespec.tv_nsec);
 #endif
 }
 
@@ -963,11 +1021,18 @@ Java_sun_nio_fs_UnixNativeDispatcher_statvfs0(JNIEnv* env, jclass this,
     jlong pathAddress, jobject attrs)
 {
     int err;
+#ifdef MACOSX
+    struct statfs buf;
+#else
     struct statvfs64 buf;
+#endif
     const char* path = (const char*)jlong_to_ptr(pathAddress);
 
-
+#ifdef MACOSX
+    RESTARTABLE(statfs(path, &buf), err);
+#else
     RESTARTABLE(statvfs64(path, &buf), err);
+#endif
     if (err == -1) {
         throwUnixException(env, errno);
     } else {
@@ -983,7 +1048,11 @@ Java_sun_nio_fs_UnixNativeDispatcher_statvfs0(JNIEnv* env, jclass this,
             buf.f_bavail = 0;
         }
 #endif
+#ifdef MACOSX
+        (*env)->SetLongField(env, attrs, attrs_f_frsize, long_to_jlong(buf.f_bsize));
+#else
         (*env)->SetLongField(env, attrs, attrs_f_frsize, long_to_jlong(buf.f_frsize));
+#endif
         (*env)->SetLongField(env, attrs, attrs_f_blocks, long_to_jlong(buf.f_blocks));
         (*env)->SetLongField(env, attrs, attrs_f_bfree,  long_to_jlong(buf.f_bfree));
         (*env)->SetLongField(env, attrs, attrs_f_bavail, long_to_jlong(buf.f_bavail));
@@ -1050,11 +1119,7 @@ Java_sun_nio_fs_UnixNativeDispatcher_getpwuid(JNIEnv* env, jclass this, jint uid
         int res = 0;
 
         errno = 0;
-        #ifdef __solaris__
-            RESTARTABLE_RETURN_PTR(getpwuid_r((uid_t)uid, &pwent, pwbuf, (size_t)buflen), p);
-        #else
-            RESTARTABLE(getpwuid_r((uid_t)uid, &pwent, pwbuf, (size_t)buflen, &p), res);
-        #endif
+        RESTARTABLE(getpwuid_r((uid_t)uid, &pwent, pwbuf, (size_t)buflen, &p), res);
 
         if (res != 0 || p == NULL || p->pw_name == NULL || *(p->pw_name) == '\0') {
             /* not found or error */
@@ -1099,11 +1164,7 @@ Java_sun_nio_fs_UnixNativeDispatcher_getgrgid(JNIEnv* env, jclass this, jint gid
         }
 
         errno = 0;
-        #ifdef __solaris__
-            RESTARTABLE_RETURN_PTR(getgrgid_r((gid_t)gid, &grent, grbuf, (size_t)buflen), g);
-        #else
-            RESTARTABLE(getgrgid_r((gid_t)gid, &grent, grbuf, (size_t)buflen, &g), res);
-        #endif
+        RESTARTABLE(getgrgid_r((gid_t)gid, &grent, grbuf, (size_t)buflen, &g), res);
 
         retry = 0;
         if (res != 0 || g == NULL || g->gr_name == NULL || *(g->gr_name) == '\0') {
@@ -1154,16 +1215,15 @@ Java_sun_nio_fs_UnixNativeDispatcher_getpwnam0(JNIEnv* env, jclass this,
         const char* name = (const char*)jlong_to_ptr(nameAddress);
 
         errno = 0;
-        #ifdef __solaris__
-            RESTARTABLE_RETURN_PTR(getpwnam_r(name, &pwent, pwbuf, (size_t)buflen), p);
-        #else
-            RESTARTABLE(getpwnam_r(name, &pwent, pwbuf, (size_t)buflen, &p), res);
-        #endif
+        RESTARTABLE(getpwnam_r(name, &pwent, pwbuf, (size_t)buflen, &p), res);
 
         if (res != 0 || p == NULL || p->pw_name == NULL || *(p->pw_name) == '\0') {
             /* not found or error */
-            if (errno != 0 && errno != ENOENT && errno != ESRCH)
+            if (errno != 0 && errno != ENOENT && errno != ESRCH &&
+                errno != EBADF && errno != EPERM)
+            {
                 throwUnixException(env, errno);
+            }
         } else {
             uid = p->pw_uid;
         }
@@ -1199,16 +1259,14 @@ Java_sun_nio_fs_UnixNativeDispatcher_getgrnam0(JNIEnv* env, jclass this,
         }
 
         errno = 0;
-        #ifdef __solaris__
-            RESTARTABLE_RETURN_PTR(getgrnam_r(name, &grent, grbuf, (size_t)buflen), g);
-        #else
-            RESTARTABLE(getgrnam_r(name, &grent, grbuf, (size_t)buflen, &g), res);
-        #endif
+        RESTARTABLE(getgrnam_r(name, &grent, grbuf, (size_t)buflen, &g), res);
 
         retry = 0;
         if (res != 0 || g == NULL || g->gr_name == NULL || *(g->gr_name) == '\0') {
             /* not found or error */
-            if (errno != 0 && errno != ENOENT && errno != ESRCH) {
+            if (errno != 0 && errno != ENOENT && errno != ESRCH &&
+                errno != EBADF && errno != EPERM)
+            {
                 if (errno == ERANGE) {
                     /* insufficient buffer size so need larger buffer */
                     buflen += ENT_BUF_SIZE;
@@ -1238,9 +1296,11 @@ static JNINativeMethod gMethods[] = {
   NATIVE_METHOD(Java_sun_nio_fs_UnixNativeDispatcher, dup, "(I)I"),
   NATIVE_METHOD(Java_sun_nio_fs_UnixNativeDispatcher, open0, "(JII)I"),
   NATIVE_METHOD(Java_sun_nio_fs_UnixNativeDispatcher, openat0, "(IJII)I"),
-  NATIVE_METHOD(Java_sun_nio_fs_UnixNativeDispatcher, close, "(I)V"),
+  NATIVE_METHOD(Java_sun_nio_fs_UnixNativeDispatcher, close0, "(I)V"),
   NATIVE_METHOD(Java_sun_nio_fs_UnixNativeDispatcher, fopen0, "(JJ)J"),
   NATIVE_METHOD(Java_sun_nio_fs_UnixNativeDispatcher, fclose, "(J)V"),
+  NATIVE_METHOD(Java_sun_nio_fs_UnixNativeDispatcher, rewind, "(J)V"),
+  NATIVE_METHOD(Java_sun_nio_fs_UnixNativeDispatcher, getlinelen, "(J)I"),
   NATIVE_METHOD(Java_sun_nio_fs_UnixNativeDispatcher, link0, "(JJ)V"),
   NATIVE_METHOD(Java_sun_nio_fs_UnixNativeDispatcher, unlink0, "(J)V"),
   NATIVE_METHOD(Java_sun_nio_fs_UnixNativeDispatcher, unlinkat0, "(IJI)V"),
@@ -1284,5 +1344,5 @@ static JNINativeMethod gMethods[] = {
 };
 
 void register_java_sun_nio_fs_UnixNativeDispatcher(JNIEnv* env) {
-  jniRegisterNativeMethods(env, "sun/nio/fs/UnixNativeDispatcher", gMethods, NELEM(gMethods));
-}
+    jniRegisterNativeMethods(env, "sun/nio/fs/UnixNativeDispatcher", gMethods, NELEM(gMethods));
+}
\ No newline at end of file
diff --git a/ojluni/src/test/Android.bp b/ojluni/src/test/Android.bp
index d5daecdb9d9..77c6d43b0a0 100644
--- a/ojluni/src/test/Android.bp
+++ b/ojluni/src/test/Android.bp
@@ -57,9 +57,9 @@ java_test {
     ],
 
     static_libs: [
+        "core-compat-test-rules",
         "core-test-rules",
         "junit",
-        "core-compat-test-rules",
         "mockwebserver",
         "testng",
     ],
diff --git a/ojluni/src/test/java/io/InputStreamReader/ReadCharBuffer.java b/ojluni/src/test/java/io/InputStreamReader/ReadCharBuffer.java
index c4a584d195f..061ae96f954 100644
--- a/ojluni/src/test/java/io/InputStreamReader/ReadCharBuffer.java
+++ b/ojluni/src/test/java/io/InputStreamReader/ReadCharBuffer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2021, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,13 +23,14 @@
 
 /*
  * @test
- * @bug 4926314
+ * @bug 4926314 8287003
  * @summary Test for InputStreamReader#read(CharBuffer).
  * @run testng ReadCharBuffer
  */
 
 package test.java.io.InputStreamReader;
 
+import org.testng.SkipException;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
@@ -40,9 +41,11 @@ import java.io.InputStreamReader;
 import java.io.Reader;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
+import java.nio.charset.CodingErrorAction;
 import java.util.Arrays;
 
 import static java.nio.charset.StandardCharsets.US_ASCII;
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.testng.Assert.assertEquals;
 
 public class ReadCharBuffer {
@@ -58,6 +61,13 @@ public class ReadCharBuffer {
         };
     }
 
+    private void fillBuffer(CharBuffer buffer) {
+        char[] filler = new char[BUFFER_SIZE];
+        Arrays.fill(filler, 'x');
+        buffer.put(filler);
+        buffer.clear();
+    }
+
     @Test(dataProvider = "buffers")
     public void read(CharBuffer buffer) throws IOException {
         fillBuffer(buffer);
@@ -80,11 +90,37 @@ public class ReadCharBuffer {
         assertEquals(buffer.toString(), "xABCDEFxGHIJKLMNxxxxxxxx");
     }
 
-    private void fillBuffer(CharBuffer buffer) {
-        char[] filler = new char[BUFFER_SIZE];
-        Arrays.fill(filler, 'x');
-        buffer.put(filler);
-        buffer.clear();
+    private static void assumeOpenjdk21V2ApisFlagTrue() {
+        try {
+            if (!com.android.libcore.Flags.openjdk21V2Apis()) {
+                throw new SkipException("Skipping test: "
+                        + com.android.libcore.Flags.FLAG_OPENJDK_21_V2_APIS + " flag is off.");
+            }
+        } catch (NoSuchMethodError e) {
+            System.logE("flag isn't found.", e);
+            // Continue running tests as if the flag value was true, because in this case
+            // it's likely that the APIs have been fully published and the flag has been removed.
+            // Ideally, we should use the exported / test version of java_aconfig_library to read
+            // the flag from the aconfig flag storage via frameworks, but ART test infra can't have
+            // direct dependency on frameworks. We will need to add an abstraction or indirect
+            // dependency to support both CTS infra and ART test infra.
+        }
     }
 
+    @Test
+    public void readLeftover() throws IOException {
+        assumeOpenjdk21V2ApisFlagTrue();
+        byte[] b = new byte[] {'a', 'b', (byte) 0xC2};
+        ByteArrayInputStream bais = new ByteArrayInputStream(b);
+        InputStreamReader r = new InputStreamReader(bais,
+            UTF_8.newDecoder().onMalformedInput(CodingErrorAction.IGNORE));
+        int n = r.read();
+        assertEquals((char)n, 'a');
+        char[] c = new char[3];
+        n = r.read(c, 0, 3);
+        assertEquals(n, 1);
+        assertEquals((char)c[0], 'b');
+        n = r.read();
+        assertEquals(n, -1);
+    }
 }
diff --git a/ojluni/src/test/java/io/Reader/NullReader.java b/ojluni/src/test/java/io/Reader/NullReader.java
index 67083f10f87..8dd8779177d 100644
--- a/ojluni/src/test/java/io/Reader/NullReader.java
+++ b/ojluni/src/test/java/io/Reader/NullReader.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,9 +28,7 @@ import java.io.StringWriter;
 import java.nio.CharBuffer;
 import java.nio.ReadOnlyBufferException;
 
-import org.testng.annotations.AfterGroups;
-import org.testng.annotations.BeforeGroups;
-import org.testng.annotations.Test;
+import org.testng.annotations.*;
 
 import static org.testng.Assert.*;
 
@@ -44,107 +42,103 @@ public class NullReader {
     private static Reader openReader;
     private static Reader closedReader;
 
-    @BeforeGroups(groups = "open")
-    public static void openStream() {
+    @BeforeClass
+    public static void setup() throws IOException {
         openReader = Reader.nullReader();
-    }
-
-    @BeforeGroups(groups = "closed")
-    public static void openAndCloseStream() throws IOException {
         closedReader = Reader.nullReader();
         closedReader.close();
     }
 
-    @AfterGroups(groups = "open")
+    @AfterClass
     public static void closeStream() throws IOException {
         openReader.close();
     }
 
-    @Test(groups = "open")
+    @Test
     public static void testOpen() {
         assertNotNull(openReader, "Reader.nullReader() returned null");
     }
 
-    @Test(groups = "open")
+    @Test
     public static void testRead() throws IOException {
         assertEquals(-1, openReader.read(), "read() != -1");
     }
 
-    @Test(groups = "open")
+    @Test
     public static void testReadBII() throws IOException {
         assertEquals(-1, openReader.read(new char[1], 0, 1),
                 "read(char[],int,int) != -1");
     }
 
-    @Test(groups = "open")
+    @Test
     public static void testReadBIILenZero() throws IOException {
         assertEquals(0, openReader.read(new char[1], 0, 0),
                 "read(char[],int,int) != 0");
     }
 
-    @Test(groups = "open")
+    @Test
     public static void testReadCharBuffer() throws IOException {
         CharBuffer charBuffer = CharBuffer.allocate(1);
         assertEquals(-1, openReader.read(charBuffer),
                 "read(CharBuffer) != -1");
     }
 
-    @Test(groups = "open")
+    @Test
     public static void testReadCharBufferZeroRemaining() throws IOException {
         CharBuffer charBuffer = CharBuffer.allocate(0);
         assertEquals(0, openReader.read(charBuffer),
                 "read(CharBuffer) != 0");
     }
 
-    @Test(groups = "open")
+    @Test
     public static void testReady() throws IOException {
         assertFalse(openReader.ready());
     }
 
-    @Test(groups = "open")
+    @Test
     public static void testSkip() throws IOException {
         assertEquals(0, openReader.skip(1), "skip() != 0");
     }
 
-    @Test(groups = "open")
+    @Test
     public static void testTransferTo() throws IOException {
         assertEquals(0, openReader.transferTo(new StringWriter(7)),
                 "transferTo() != 0");
     }
 
-    @Test(groups = "closed", expectedExceptions = IOException.class)
+    @Test(expectedExceptions = IOException.class)
     public static void testReadClosed() throws IOException {
         closedReader.read();
     }
 
-    @Test(groups = "closed", expectedExceptions = IOException.class)
+    @Test(expectedExceptions = IOException.class)
     public static void testReadBIIClosed() throws IOException {
         closedReader.read(new char[1], 0, 1);
     }
 
-    @Test(groups = "closed", expectedExceptions = IOException.class)
+    @Test(expectedExceptions = IOException.class)
     public static void testReadCharBufferClosed() throws IOException {
         CharBuffer charBuffer = CharBuffer.allocate(0);
         closedReader.read(charBuffer);
     }
 
-    @Test(groups = "closed", expectedExceptions = IOException.class)
+    @Test(expectedExceptions = IOException.class)
     public static void testReadCharBufferZeroRemainingClosed() throws IOException {
         CharBuffer charBuffer = CharBuffer.allocate(0);
         closedReader.read(charBuffer);
     }
 
-    @Test(groups = "closed", expectedExceptions = IOException.class)
+    @Test(expectedExceptions = IOException.class)
     public static void testReadyClosed() throws IOException {
         closedReader.ready();
     }
 
-    @Test(groups = "closed", expectedExceptions = IOException.class)
+    @Test(expectedExceptions = IOException.class)
     public static void testSkipClosed() throws IOException {
         closedReader.skip(1);
     }
 
-    @Test(groups = "closed", expectedExceptions = IOException.class)
+    @Test(expectedExceptions = IOException.class)
     public static void testTransferToClosed() throws IOException {
         closedReader.transferTo(new StringWriter(7));
     }
diff --git a/ojluni/src/test/java/io/Writer/NullWriter.java b/ojluni/src/test/java/io/Writer/NullWriter.java
index f33ecaa3c3b..25f2bda777a 100644
--- a/ojluni/src/test/java/io/Writer/NullWriter.java
+++ b/ojluni/src/test/java/io/Writer/NullWriter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2021, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,14 +23,15 @@
 // Android-added: Test package.
 package test.java.io.Writer;
 
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
 import java.io.IOException;
 import java.io.Writer;
 
-import org.testng.annotations.AfterGroups;
-import org.testng.annotations.BeforeGroups;
-import org.testng.annotations.Test;
-
-import static org.testng.Assert.*;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertSame;
 
 /*
  * @test
@@ -42,127 +43,123 @@ public class NullWriter {
     private static Writer openWriter;
     private static Writer closedWriter;
 
-    @BeforeGroups(groups = "open")
-    public static void openStream() {
+    @BeforeClass
+    public static void setup() throws IOException {
         openWriter = Writer.nullWriter();
-    }
-
-    @BeforeGroups(groups = "closed")
-    public static void openAndCloseStream() throws IOException {
         closedWriter = Writer.nullWriter();
         closedWriter.close();
     }
 
-    @AfterGroups(groups = "open")
+    @AfterClass
     public static void closeStream() throws IOException {
         openWriter.close();
     }
 
-    @Test(groups = "open")
+    @Test
     public static void testOpen() {
         assertNotNull(openWriter, "Writer.nullWriter() returned null");
     }
 
-    @Test(groups = "open")
+    @Test
     public static void testAppendChar() throws IOException {
         assertSame(openWriter, openWriter.append('x'));
     }
 
-    @Test(groups = "open")
+    @Test
     public static void testAppendCharSequence() throws IOException {
         CharSequence cs = "abc";
         assertSame(openWriter, openWriter.append(cs));
     }
 
-    @Test(groups = "open")
+    @Test
     public static void testAppendCharSequenceNull() throws IOException {
         assertSame(openWriter, openWriter.append(null));
     }
 
-    @Test(groups = "open")
+    @Test
     public static void testAppendCharSequenceII() throws IOException {
         CharSequence cs = "abc";
         assertSame(openWriter, openWriter.append(cs, 0, 1));
     }
 
-    @Test(groups = "open")
+    @Test
     public static void testAppendCharSequenceIINull() throws IOException {
         assertSame(openWriter, openWriter.append(null, 2, 1));
     }
 
-    @Test(groups = "open")
+    @Test
     public static void testFlush() throws IOException {
         openWriter.flush();
     }
 
-    @Test(groups = "open")
+    @Test
     public static void testWrite() throws IOException {
         openWriter.write(62832);
     }
 
-    @Test(groups = "open")
+    @Test
     public static void testWriteString() throws IOException {
         openWriter.write("");
     }
 
-    @Test(groups = "open")
+    @Test
     public static void testWriteStringII() throws IOException {
         openWriter.write("", 0, 0);
     }
 
-    @Test(groups = "open")
+    @Test
     public static void testWriteBII() throws IOException, Exception {
         openWriter.write(new char[]{(char) 6}, 0, 1);
     }
 
-    @Test(groups = "closed", expectedExceptions = IOException.class)
+    @Test(expectedExceptions = IOException.class)
     public static void testAppendCharClosed() throws IOException {
         closedWriter.append('x');
     }
 
-    @Test(groups = "closed", expectedExceptions = IOException.class)
+    @Test(expectedExceptions = IOException.class)
     public static void testAppendCharSequenceClosed() throws IOException {
         CharSequence cs = "abc";
         closedWriter.append(cs);
     }
 
-    @Test(groups = "closed", expectedExceptions = IOException.class)
+    @Test(expectedExceptions = IOException.class)
     public static void testAppendCharSequenceNullClosed() throws IOException {
         closedWriter.append(null);
     }
 
-    @Test(groups = "closed", expectedExceptions = IOException.class)
+    @Test(expectedExceptions = IOException.class)
     public static void testAppendCharSequenceIIClosed() throws IOException {
         CharSequence cs = "abc";
         closedWriter.append(cs, 0, 1);
     }
 
-    @Test(groups = "closed", expectedExceptions = IOException.class)
+    @Test(expectedExceptions = IOException.class)
     public static void testAppendCharSequenceIINullClosed() throws IOException {
         closedWriter.append(null, 2, 1);
     }
 
-    @Test(groups = "closed", expectedExceptions = IOException.class)
+    @Test(expectedExceptions = IOException.class)
     public static void testFlushClosed() throws IOException {
         closedWriter.flush();
     }
 
-    @Test(groups = "closed", expectedExceptions = IOException.class)
+    @Test(expectedExceptions = IOException.class)
     public static void testWriteClosed() throws IOException {
         closedWriter.write(62832);
     }
 
-    @Test(groups = "closed", expectedExceptions = IOException.class)
+    @Test(expectedExceptions = IOException.class)
     public static void testWriteStringClosed() throws IOException {
         closedWriter.write("");
     }
 
-    @Test(groups = "closed", expectedExceptions = IOException.class)
+    @Test(expectedExceptions = IOException.class)
     public static void testWriteStringIIClosed() throws IOException {
         closedWriter.write("", 0, 0);
     }
 
-    @Test(groups = "closed", expectedExceptions = IOException.class)
+    @Test(expectedExceptions = IOException.class)
     public static void testWriteBIIClosed() throws IOException {
         closedWriter.write(new char[]{(char) 6}, 0, 1);
     }
diff --git a/ojluni/src/test/java/lang/StackWalker/StackWalkTest.java b/ojluni/src/test/java/lang/StackWalker/StackWalkTest.java
index b2529b6757f..e17ba97bdc8 100644
--- a/ojluni/src/test/java/lang/StackWalker/StackWalkTest.java
+++ b/ojluni/src/test/java/lang/StackWalker/StackWalkTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -63,6 +63,7 @@ public class StackWalkTest {
             "java.lang.reflect.Method",
             "com.sun.javatest.regtest.MainWrapper$MainThread",
             "com.sun.javatest.regtest.agent.MainWrapper$MainThread",
+            "com.sun.javatest.regtest.agent.MainWrapper$MainTask",
             "java.lang.Thread"
     ));
     static final List<Class<?>> streamPipelines = Arrays.asList(
diff --git a/ojluni/src/test/java/lang/invoke/MethodHandlesGeneralTest.java b/ojluni/src/test/java/lang/invoke/MethodHandlesGeneralTest.java
index 7368c6af8d2..c2ba8a8b169 100644
--- a/ojluni/src/test/java/lang/invoke/MethodHandlesGeneralTest.java
+++ b/ojluni/src/test/java/lang/invoke/MethodHandlesGeneralTest.java
@@ -23,7 +23,7 @@
 
 /* @test
  * @summary unit tests for java.lang.invoke.MethodHandles
- * @library /lib/testlibrary /java/lang/invoke/common
+ * @library /test/lib /java/lang/invoke/common
  * @compile MethodHandlesTest.java MethodHandlesGeneralTest.java remote/RemoteExample.java
  * @run junit/othervm/timeout=2500 -XX:+IgnoreUnrecognizedVMOptions
  *                                 -XX:-VerifyDependencies
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleBaseTest.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleBaseTest.java
index 66d2d4d09ab..dd77fefe66b 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleBaseTest.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleBaseTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -43,9 +43,14 @@ import static org.testng.Assert.*;
 
 abstract class VarHandleBaseTest {
     static final int ITERS = Integer.getInteger("iters", 1);
-    // Android-changed: increased weak operation attempts for b/231439685.
-    // static final int WEAK_ATTEMPTS = Integer.getInteger("weakAttempts", 10);
-    static final int WEAK_ATTEMPTS = Integer.getInteger("weakAttempts", 50);
+
+    // More resilience for Weak* tests. These operations may spuriously
+    // fail, and so we do several attempts with delay on failure.
+    // Be mindful of worst-case total time on test, which would be at
+    // roughly (delay*attempts) milliseconds.
+    //
+    static final int WEAK_ATTEMPTS = Integer.getInteger("weakAttempts", 100);
+    static final int WEAK_DELAY_MS = Math.max(1, Integer.getInteger("weakDelay", 1));
 
     interface ThrowingRunnable {
         void run() throws Throwable;
@@ -495,4 +500,14 @@ abstract class VarHandleBaseTest {
             assertEquals(mt.parameterType(mt.parameterCount() - 1), vh.varType());
         }
     }
+
+    static void weakDelay() {
+        try {
+            if (WEAK_DELAY_MS > 0) {
+                Thread.sleep(WEAK_DELAY_MS);
+            }
+        } catch (InterruptedException ie) {
+            // Do nothing.
+        }
+    }
 }
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessBoolean.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessBoolean.java
index c3eafd26b03..7ed457e5fa9 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessBoolean.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessBoolean.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -445,40 +445,72 @@ public class VarHandleTestAccessBoolean extends VarHandleBaseTest {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetPlain(recv, true, false);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain boolean");
+            assertEquals(success, true, "success weakCompareAndSetPlain boolean");
             boolean x = (boolean) vh.get(recv);
-            assertEquals(x, false, "weakCompareAndSetPlain boolean value");
+            assertEquals(x, false, "success weakCompareAndSetPlain boolean value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetPlain(recv, true, false);
+            assertEquals(success, false, "failing weakCompareAndSetPlain boolean");
+            boolean x = (boolean) vh.get(recv);
+            assertEquals(x, false, "failing weakCompareAndSetPlain boolean value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetAcquire(recv, false, true);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire boolean");
+            assertEquals(success, true, "success weakCompareAndSetAcquire boolean");
+            boolean x = (boolean) vh.get(recv);
+            assertEquals(x, true, "success weakCompareAndSetAcquire boolean");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetAcquire(recv, false, false);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire boolean");
             boolean x = (boolean) vh.get(recv);
-            assertEquals(x, true, "weakCompareAndSetAcquire boolean");
+            assertEquals(x, true, "failing weakCompareAndSetAcquire boolean value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetRelease(recv, true, false);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease boolean");
+            assertEquals(success, true, "success weakCompareAndSetRelease boolean");
+            boolean x = (boolean) vh.get(recv);
+            assertEquals(x, false, "success weakCompareAndSetRelease boolean");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetRelease(recv, true, false);
+            assertEquals(success, false, "failing weakCompareAndSetRelease boolean");
             boolean x = (boolean) vh.get(recv);
-            assertEquals(x, false, "weakCompareAndSetRelease boolean");
+            assertEquals(x, false, "failing weakCompareAndSetRelease boolean value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSet(recv, false, true);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet boolean");
+            assertEquals(success, true, "success weakCompareAndSet boolean");
             boolean x = (boolean) vh.get(recv);
-            assertEquals(x, true, "weakCompareAndSet boolean value");
+            assertEquals(x, true, "success weakCompareAndSet boolean value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSet(recv, false, false);
+            assertEquals(success, false, "failing weakCompareAndSet boolean");
+            boolean x = (boolean) vh.get(recv);
+            assertEquals(x, true, "failing weakCompareAndSet boolean value");
         }
 
         // Compare set and get
@@ -705,40 +737,72 @@ public class VarHandleTestAccessBoolean extends VarHandleBaseTest {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetPlain(true, false);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain boolean");
+            assertEquals(success, true, "success weakCompareAndSetPlain boolean");
+            boolean x = (boolean) vh.get();
+            assertEquals(x, false, "success weakCompareAndSetPlain boolean value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetPlain(true, false);
+            assertEquals(success, false, "failing weakCompareAndSetPlain boolean");
             boolean x = (boolean) vh.get();
-            assertEquals(x, false, "weakCompareAndSetPlain boolean value");
+            assertEquals(x, false, "failing weakCompareAndSetPlain boolean value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetAcquire(false, true);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire boolean");
+            assertEquals(success, true, "success weakCompareAndSetAcquire boolean");
+            boolean x = (boolean) vh.get();
+            assertEquals(x, true, "success weakCompareAndSetAcquire boolean");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetAcquire(false, false);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire boolean");
             boolean x = (boolean) vh.get();
-            assertEquals(x, true, "weakCompareAndSetAcquire boolean");
+            assertEquals(x, true, "failing weakCompareAndSetAcquire boolean value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetRelease(true, false);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease boolean");
+            assertEquals(success, true, "success weakCompareAndSetRelease boolean");
             boolean x = (boolean) vh.get();
-            assertEquals(x, false, "weakCompareAndSetRelease boolean");
+            assertEquals(x, false, "success weakCompareAndSetRelease boolean");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetRelease(true, false);
+            assertEquals(success, false, "failing weakCompareAndSetRelease boolean");
+            boolean x = (boolean) vh.get();
+            assertEquals(x, false, "failing weakCompareAndSetRelease boolean value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSet(false, true);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet boolean");
+            assertEquals(success, true, "success weakCompareAndSet boolean");
+            boolean x = (boolean) vh.get();
+            assertEquals(x, true, "success weakCompareAndSet boolean");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSet(false, false);
+            assertEquals(success, false, "failing weakCompareAndSet boolean");
             boolean x = (boolean) vh.get();
-            assertEquals(x, true, "weakCompareAndSet boolean");
+            assertEquals(x, true, "failing weakCompareAndSet boolean value");
         }
 
         // Compare set and get
@@ -968,40 +1032,72 @@ public class VarHandleTestAccessBoolean extends VarHandleBaseTest {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetPlain(array, i, true, false);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetPlain boolean");
+                assertEquals(success, true, "success weakCompareAndSetPlain boolean");
+                boolean x = (boolean) vh.get(array, i);
+                assertEquals(x, false, "success weakCompareAndSetPlain boolean value");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetPlain(array, i, true, false);
+                assertEquals(success, false, "failing weakCompareAndSetPlain boolean");
                 boolean x = (boolean) vh.get(array, i);
-                assertEquals(x, false, "weakCompareAndSetPlain boolean value");
+                assertEquals(x, false, "failing weakCompareAndSetPlain boolean value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetAcquire(array, i, false, true);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetAcquire boolean");
+                assertEquals(success, true, "success weakCompareAndSetAcquire boolean");
                 boolean x = (boolean) vh.get(array, i);
-                assertEquals(x, true, "weakCompareAndSetAcquire boolean");
+                assertEquals(x, true, "success weakCompareAndSetAcquire boolean");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetAcquire(array, i, false, false);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire boolean");
+                boolean x = (boolean) vh.get(array, i);
+                assertEquals(x, true, "failing weakCompareAndSetAcquire boolean value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetRelease(array, i, true, false);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetRelease boolean");
+                assertEquals(success, true, "success weakCompareAndSetRelease boolean");
+                boolean x = (boolean) vh.get(array, i);
+                assertEquals(x, false, "success weakCompareAndSetRelease boolean");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetRelease(array, i, true, false);
+                assertEquals(success, false, "failing weakCompareAndSetRelease boolean");
                 boolean x = (boolean) vh.get(array, i);
-                assertEquals(x, false, "weakCompareAndSetRelease boolean");
+                assertEquals(x, false, "failing weakCompareAndSetRelease boolean value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSet(array, i, false, true);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSet boolean");
+                assertEquals(success, true, "success weakCompareAndSet boolean");
+                boolean x = (boolean) vh.get(array, i);
+                assertEquals(x, true, "success weakCompareAndSet boolean");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSet(array, i, false, false);
+                assertEquals(success, false, "failing weakCompareAndSet boolean");
                 boolean x = (boolean) vh.get(array, i);
-                assertEquals(x, true, "weakCompareAndSet boolean");
+                assertEquals(x, true, "failing weakCompareAndSet boolean value");
             }
 
             // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessByte.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessByte.java
index 0f7e4b5c59d..50e7131599f 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessByte.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessByte.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -423,40 +423,72 @@ public class VarHandleTestAccessByte extends VarHandleBaseTest {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetPlain(recv, (byte)0x01, (byte)0x23);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain byte");
+            assertEquals(success, true, "success weakCompareAndSetPlain byte");
             byte x = (byte) vh.get(recv);
-            assertEquals(x, (byte)0x23, "weakCompareAndSetPlain byte value");
+            assertEquals(x, (byte)0x23, "success weakCompareAndSetPlain byte value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetPlain(recv, (byte)0x01, (byte)0x45);
+            assertEquals(success, false, "failing weakCompareAndSetPlain byte");
+            byte x = (byte) vh.get(recv);
+            assertEquals(x, (byte)0x23, "failing weakCompareAndSetPlain byte value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetAcquire(recv, (byte)0x23, (byte)0x01);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire byte");
+            assertEquals(success, true, "success weakCompareAndSetAcquire byte");
+            byte x = (byte) vh.get(recv);
+            assertEquals(x, (byte)0x01, "success weakCompareAndSetAcquire byte");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetAcquire(recv, (byte)0x23, (byte)0x45);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire byte");
             byte x = (byte) vh.get(recv);
-            assertEquals(x, (byte)0x01, "weakCompareAndSetAcquire byte");
+            assertEquals(x, (byte)0x01, "failing weakCompareAndSetAcquire byte value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetRelease(recv, (byte)0x01, (byte)0x23);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease byte");
+            assertEquals(success, true, "success weakCompareAndSetRelease byte");
+            byte x = (byte) vh.get(recv);
+            assertEquals(x, (byte)0x23, "success weakCompareAndSetRelease byte");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetRelease(recv, (byte)0x01, (byte)0x45);
+            assertEquals(success, false, "failing weakCompareAndSetRelease byte");
             byte x = (byte) vh.get(recv);
-            assertEquals(x, (byte)0x23, "weakCompareAndSetRelease byte");
+            assertEquals(x, (byte)0x23, "failing weakCompareAndSetRelease byte value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSet(recv, (byte)0x23, (byte)0x01);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet byte");
+            assertEquals(success, true, "success weakCompareAndSet byte");
             byte x = (byte) vh.get(recv);
-            assertEquals(x, (byte)0x01, "weakCompareAndSet byte value");
+            assertEquals(x, (byte)0x01, "success weakCompareAndSet byte value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSet(recv, (byte)0x23, (byte)0x45);
+            assertEquals(success, false, "failing weakCompareAndSet byte");
+            byte x = (byte) vh.get(recv);
+            assertEquals(x, (byte)0x01, "failing weakCompareAndSet byte value");
         }
 
         // Compare set and get
@@ -699,40 +731,72 @@ public class VarHandleTestAccessByte extends VarHandleBaseTest {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetPlain((byte)0x01, (byte)0x23);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain byte");
+            assertEquals(success, true, "success weakCompareAndSetPlain byte");
+            byte x = (byte) vh.get();
+            assertEquals(x, (byte)0x23, "success weakCompareAndSetPlain byte value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetPlain((byte)0x01, (byte)0x45);
+            assertEquals(success, false, "failing weakCompareAndSetPlain byte");
             byte x = (byte) vh.get();
-            assertEquals(x, (byte)0x23, "weakCompareAndSetPlain byte value");
+            assertEquals(x, (byte)0x23, "failing weakCompareAndSetPlain byte value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetAcquire((byte)0x23, (byte)0x01);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire byte");
+            assertEquals(success, true, "success weakCompareAndSetAcquire byte");
+            byte x = (byte) vh.get();
+            assertEquals(x, (byte)0x01, "success weakCompareAndSetAcquire byte");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetAcquire((byte)0x23, (byte)0x45);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire byte");
             byte x = (byte) vh.get();
-            assertEquals(x, (byte)0x01, "weakCompareAndSetAcquire byte");
+            assertEquals(x, (byte)0x01, "failing weakCompareAndSetAcquire byte value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetRelease((byte)0x01, (byte)0x23);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease byte");
+            assertEquals(success, true, "success weakCompareAndSetRelease byte");
             byte x = (byte) vh.get();
-            assertEquals(x, (byte)0x23, "weakCompareAndSetRelease byte");
+            assertEquals(x, (byte)0x23, "success weakCompareAndSetRelease byte");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetRelease((byte)0x01, (byte)0x45);
+            assertEquals(success, false, "failing weakCompareAndSetRelease byte");
+            byte x = (byte) vh.get();
+            assertEquals(x, (byte)0x23, "failing weakCompareAndSetRelease byte value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSet((byte)0x23, (byte)0x01);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet byte");
+            assertEquals(success, true, "success weakCompareAndSet byte");
+            byte x = (byte) vh.get();
+            assertEquals(x, (byte)0x01, "success weakCompareAndSet byte");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSet((byte)0x23, (byte)0x45);
+            assertEquals(success, false, "failing weakCompareAndSet byte");
             byte x = (byte) vh.get();
-            assertEquals(x, (byte)0x01, "weakCompareAndSet byte");
+            assertEquals(x, (byte)0x01, "failing weakCompareAndSet byte value");
         }
 
         // Compare set and get
@@ -978,40 +1042,72 @@ public class VarHandleTestAccessByte extends VarHandleBaseTest {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetPlain(array, i, (byte)0x01, (byte)0x23);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetPlain byte");
+                assertEquals(success, true, "success weakCompareAndSetPlain byte");
+                byte x = (byte) vh.get(array, i);
+                assertEquals(x, (byte)0x23, "success weakCompareAndSetPlain byte value");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetPlain(array, i, (byte)0x01, (byte)0x45);
+                assertEquals(success, false, "failing weakCompareAndSetPlain byte");
                 byte x = (byte) vh.get(array, i);
-                assertEquals(x, (byte)0x23, "weakCompareAndSetPlain byte value");
+                assertEquals(x, (byte)0x23, "failing weakCompareAndSetPlain byte value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetAcquire(array, i, (byte)0x23, (byte)0x01);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetAcquire byte");
+                assertEquals(success, true, "success weakCompareAndSetAcquire byte");
                 byte x = (byte) vh.get(array, i);
-                assertEquals(x, (byte)0x01, "weakCompareAndSetAcquire byte");
+                assertEquals(x, (byte)0x01, "success weakCompareAndSetAcquire byte");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetAcquire(array, i, (byte)0x23, (byte)0x45);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire byte");
+                byte x = (byte) vh.get(array, i);
+                assertEquals(x, (byte)0x01, "failing weakCompareAndSetAcquire byte value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetRelease(array, i, (byte)0x01, (byte)0x23);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetRelease byte");
+                assertEquals(success, true, "success weakCompareAndSetRelease byte");
+                byte x = (byte) vh.get(array, i);
+                assertEquals(x, (byte)0x23, "success weakCompareAndSetRelease byte");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetRelease(array, i, (byte)0x01, (byte)0x45);
+                assertEquals(success, false, "failing weakCompareAndSetRelease byte");
                 byte x = (byte) vh.get(array, i);
-                assertEquals(x, (byte)0x23, "weakCompareAndSetRelease byte");
+                assertEquals(x, (byte)0x23, "failing weakCompareAndSetRelease byte value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSet(array, i, (byte)0x23, (byte)0x01);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSet byte");
+                assertEquals(success, true, "success weakCompareAndSet byte");
+                byte x = (byte) vh.get(array, i);
+                assertEquals(x, (byte)0x01, "success weakCompareAndSet byte");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSet(array, i, (byte)0x23, (byte)0x45);
+                assertEquals(success, false, "failing weakCompareAndSet byte");
                 byte x = (byte) vh.get(array, i);
-                assertEquals(x, (byte)0x01, "weakCompareAndSet byte");
+                assertEquals(x, (byte)0x01, "failing weakCompareAndSet byte value");
             }
 
             // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessChar.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessChar.java
index 233d9fe91c3..1d3c8fb274e 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessChar.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessChar.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -423,40 +423,72 @@ public class VarHandleTestAccessChar extends VarHandleBaseTest {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetPlain(recv, '\u0123', '\u4567');
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain char");
+            assertEquals(success, true, "success weakCompareAndSetPlain char");
             char x = (char) vh.get(recv);
-            assertEquals(x, '\u4567', "weakCompareAndSetPlain char value");
+            assertEquals(x, '\u4567', "success weakCompareAndSetPlain char value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetPlain(recv, '\u0123', '\u89AB');
+            assertEquals(success, false, "failing weakCompareAndSetPlain char");
+            char x = (char) vh.get(recv);
+            assertEquals(x, '\u4567', "failing weakCompareAndSetPlain char value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetAcquire(recv, '\u4567', '\u0123');
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire char");
+            assertEquals(success, true, "success weakCompareAndSetAcquire char");
+            char x = (char) vh.get(recv);
+            assertEquals(x, '\u0123', "success weakCompareAndSetAcquire char");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetAcquire(recv, '\u4567', '\u89AB');
+            assertEquals(success, false, "failing weakCompareAndSetAcquire char");
             char x = (char) vh.get(recv);
-            assertEquals(x, '\u0123', "weakCompareAndSetAcquire char");
+            assertEquals(x, '\u0123', "failing weakCompareAndSetAcquire char value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetRelease(recv, '\u0123', '\u4567');
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease char");
+            assertEquals(success, true, "success weakCompareAndSetRelease char");
+            char x = (char) vh.get(recv);
+            assertEquals(x, '\u4567', "success weakCompareAndSetRelease char");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetRelease(recv, '\u0123', '\u89AB');
+            assertEquals(success, false, "failing weakCompareAndSetRelease char");
             char x = (char) vh.get(recv);
-            assertEquals(x, '\u4567', "weakCompareAndSetRelease char");
+            assertEquals(x, '\u4567', "failing weakCompareAndSetRelease char value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSet(recv, '\u4567', '\u0123');
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet char");
+            assertEquals(success, true, "success weakCompareAndSet char");
             char x = (char) vh.get(recv);
-            assertEquals(x, '\u0123', "weakCompareAndSet char value");
+            assertEquals(x, '\u0123', "success weakCompareAndSet char value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSet(recv, '\u4567', '\u89AB');
+            assertEquals(success, false, "failing weakCompareAndSet char");
+            char x = (char) vh.get(recv);
+            assertEquals(x, '\u0123', "failing weakCompareAndSet char value");
         }
 
         // Compare set and get
@@ -699,40 +731,72 @@ public class VarHandleTestAccessChar extends VarHandleBaseTest {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetPlain('\u0123', '\u4567');
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain char");
+            assertEquals(success, true, "success weakCompareAndSetPlain char");
+            char x = (char) vh.get();
+            assertEquals(x, '\u4567', "success weakCompareAndSetPlain char value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetPlain('\u0123', '\u89AB');
+            assertEquals(success, false, "failing weakCompareAndSetPlain char");
             char x = (char) vh.get();
-            assertEquals(x, '\u4567', "weakCompareAndSetPlain char value");
+            assertEquals(x, '\u4567', "failing weakCompareAndSetPlain char value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetAcquire('\u4567', '\u0123');
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire char");
+            assertEquals(success, true, "success weakCompareAndSetAcquire char");
+            char x = (char) vh.get();
+            assertEquals(x, '\u0123', "success weakCompareAndSetAcquire char");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetAcquire('\u4567', '\u89AB');
+            assertEquals(success, false, "failing weakCompareAndSetAcquire char");
             char x = (char) vh.get();
-            assertEquals(x, '\u0123', "weakCompareAndSetAcquire char");
+            assertEquals(x, '\u0123', "failing weakCompareAndSetAcquire char value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetRelease('\u0123', '\u4567');
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease char");
+            assertEquals(success, true, "success weakCompareAndSetRelease char");
             char x = (char) vh.get();
-            assertEquals(x, '\u4567', "weakCompareAndSetRelease char");
+            assertEquals(x, '\u4567', "success weakCompareAndSetRelease char");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetRelease('\u0123', '\u89AB');
+            assertEquals(success, false, "failing weakCompareAndSetRelease char");
+            char x = (char) vh.get();
+            assertEquals(x, '\u4567', "failing weakCompareAndSetRelease char value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSet('\u4567', '\u0123');
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet char");
+            assertEquals(success, true, "success weakCompareAndSet char");
+            char x = (char) vh.get();
+            assertEquals(x, '\u0123', "success weakCompareAndSet char");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSet('\u4567', '\u89AB');
+            assertEquals(success, false, "failing weakCompareAndSet char");
             char x = (char) vh.get();
-            assertEquals(x, '\u0123', "weakCompareAndSet char");
+            assertEquals(x, '\u0123', "failing weakCompareAndSet char value");
         }
 
         // Compare set and get
@@ -978,40 +1042,72 @@ public class VarHandleTestAccessChar extends VarHandleBaseTest {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetPlain(array, i, '\u0123', '\u4567');
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetPlain char");
+                assertEquals(success, true, "success weakCompareAndSetPlain char");
+                char x = (char) vh.get(array, i);
+                assertEquals(x, '\u4567', "success weakCompareAndSetPlain char value");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetPlain(array, i, '\u0123', '\u89AB');
+                assertEquals(success, false, "failing weakCompareAndSetPlain char");
                 char x = (char) vh.get(array, i);
-                assertEquals(x, '\u4567', "weakCompareAndSetPlain char value");
+                assertEquals(x, '\u4567', "failing weakCompareAndSetPlain char value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetAcquire(array, i, '\u4567', '\u0123');
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetAcquire char");
+                assertEquals(success, true, "success weakCompareAndSetAcquire char");
                 char x = (char) vh.get(array, i);
-                assertEquals(x, '\u0123', "weakCompareAndSetAcquire char");
+                assertEquals(x, '\u0123', "success weakCompareAndSetAcquire char");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetAcquire(array, i, '\u4567', '\u89AB');
+                assertEquals(success, false, "failing weakCompareAndSetAcquire char");
+                char x = (char) vh.get(array, i);
+                assertEquals(x, '\u0123', "failing weakCompareAndSetAcquire char value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetRelease(array, i, '\u0123', '\u4567');
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetRelease char");
+                assertEquals(success, true, "success weakCompareAndSetRelease char");
+                char x = (char) vh.get(array, i);
+                assertEquals(x, '\u4567', "success weakCompareAndSetRelease char");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetRelease(array, i, '\u0123', '\u89AB');
+                assertEquals(success, false, "failing weakCompareAndSetRelease char");
                 char x = (char) vh.get(array, i);
-                assertEquals(x, '\u4567', "weakCompareAndSetRelease char");
+                assertEquals(x, '\u4567', "failing weakCompareAndSetRelease char value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSet(array, i, '\u4567', '\u0123');
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSet char");
+                assertEquals(success, true, "success weakCompareAndSet char");
+                char x = (char) vh.get(array, i);
+                assertEquals(x, '\u0123', "success weakCompareAndSet char");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSet(array, i, '\u4567', '\u89AB');
+                assertEquals(success, false, "failing weakCompareAndSet char");
                 char x = (char) vh.get(array, i);
-                assertEquals(x, '\u0123', "weakCompareAndSet char");
+                assertEquals(x, '\u0123', "failing weakCompareAndSet char value");
             }
 
             // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessDouble.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessDouble.java
index 97f35ceadc7..e2cae2b5830 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessDouble.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessDouble.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -493,40 +493,72 @@ public class VarHandleTestAccessDouble extends VarHandleBaseTest {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetPlain(recv, 1.0d, 2.0d);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain double");
+            assertEquals(success, true, "success weakCompareAndSetPlain double");
             double x = (double) vh.get(recv);
-            assertEquals(x, 2.0d, "weakCompareAndSetPlain double value");
+            assertEquals(x, 2.0d, "success weakCompareAndSetPlain double value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetPlain(recv, 1.0d, 3.0d);
+            assertEquals(success, false, "failing weakCompareAndSetPlain double");
+            double x = (double) vh.get(recv);
+            assertEquals(x, 2.0d, "failing weakCompareAndSetPlain double value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetAcquire(recv, 2.0d, 1.0d);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire double");
+            assertEquals(success, true, "success weakCompareAndSetAcquire double");
+            double x = (double) vh.get(recv);
+            assertEquals(x, 1.0d, "success weakCompareAndSetAcquire double");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetAcquire(recv, 2.0d, 3.0d);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire double");
             double x = (double) vh.get(recv);
-            assertEquals(x, 1.0d, "weakCompareAndSetAcquire double");
+            assertEquals(x, 1.0d, "failing weakCompareAndSetAcquire double value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetRelease(recv, 1.0d, 2.0d);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease double");
+            assertEquals(success, true, "success weakCompareAndSetRelease double");
+            double x = (double) vh.get(recv);
+            assertEquals(x, 2.0d, "success weakCompareAndSetRelease double");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetRelease(recv, 1.0d, 3.0d);
+            assertEquals(success, false, "failing weakCompareAndSetRelease double");
             double x = (double) vh.get(recv);
-            assertEquals(x, 2.0d, "weakCompareAndSetRelease double");
+            assertEquals(x, 2.0d, "failing weakCompareAndSetRelease double value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSet(recv, 2.0d, 1.0d);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet double");
+            assertEquals(success, true, "success weakCompareAndSet double");
             double x = (double) vh.get(recv);
-            assertEquals(x, 1.0d, "weakCompareAndSet double value");
+            assertEquals(x, 1.0d, "success weakCompareAndSet double value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSet(recv, 2.0d, 3.0d);
+            assertEquals(success, false, "failing weakCompareAndSet double");
+            double x = (double) vh.get(recv);
+            assertEquals(x, 1.0d, "failing weakCompareAndSet double value");
         }
 
         // Compare set and get
@@ -721,40 +753,72 @@ public class VarHandleTestAccessDouble extends VarHandleBaseTest {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetPlain(1.0d, 2.0d);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain double");
+            assertEquals(success, true, "success weakCompareAndSetPlain double");
+            double x = (double) vh.get();
+            assertEquals(x, 2.0d, "success weakCompareAndSetPlain double value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetPlain(1.0d, 3.0d);
+            assertEquals(success, false, "failing weakCompareAndSetPlain double");
             double x = (double) vh.get();
-            assertEquals(x, 2.0d, "weakCompareAndSetPlain double value");
+            assertEquals(x, 2.0d, "failing weakCompareAndSetPlain double value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetAcquire(2.0d, 1.0d);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire double");
+            assertEquals(success, true, "success weakCompareAndSetAcquire double");
+            double x = (double) vh.get();
+            assertEquals(x, 1.0d, "success weakCompareAndSetAcquire double");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetAcquire(2.0d, 3.0d);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire double");
             double x = (double) vh.get();
-            assertEquals(x, 1.0d, "weakCompareAndSetAcquire double");
+            assertEquals(x, 1.0d, "failing weakCompareAndSetAcquire double value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetRelease(1.0d, 2.0d);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease double");
+            assertEquals(success, true, "success weakCompareAndSetRelease double");
             double x = (double) vh.get();
-            assertEquals(x, 2.0d, "weakCompareAndSetRelease double");
+            assertEquals(x, 2.0d, "success weakCompareAndSetRelease double");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetRelease(1.0d, 3.0d);
+            assertEquals(success, false, "failing weakCompareAndSetRelease double");
+            double x = (double) vh.get();
+            assertEquals(x, 2.0d, "failing weakCompareAndSetRelease double value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSet(2.0d, 1.0d);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet double");
+            assertEquals(success, true, "success weakCompareAndSet double");
+            double x = (double) vh.get();
+            assertEquals(x, 1.0d, "success weakCompareAndSet double");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSet(2.0d, 3.0d);
+            assertEquals(success, false, "failing weakCompareAndSet double");
             double x = (double) vh.get();
-            assertEquals(x, 1.0d, "weakCompareAndSet double");
+            assertEquals(x, 1.0d, "failing weakCompareAndSet double value");
         }
 
         // Compare set and get
@@ -952,40 +1016,72 @@ public class VarHandleTestAccessDouble extends VarHandleBaseTest {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetPlain(array, i, 1.0d, 2.0d);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetPlain double");
+                assertEquals(success, true, "success weakCompareAndSetPlain double");
+                double x = (double) vh.get(array, i);
+                assertEquals(x, 2.0d, "success weakCompareAndSetPlain double value");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetPlain(array, i, 1.0d, 3.0d);
+                assertEquals(success, false, "failing weakCompareAndSetPlain double");
                 double x = (double) vh.get(array, i);
-                assertEquals(x, 2.0d, "weakCompareAndSetPlain double value");
+                assertEquals(x, 2.0d, "failing weakCompareAndSetPlain double value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetAcquire(array, i, 2.0d, 1.0d);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetAcquire double");
+                assertEquals(success, true, "success weakCompareAndSetAcquire double");
                 double x = (double) vh.get(array, i);
-                assertEquals(x, 1.0d, "weakCompareAndSetAcquire double");
+                assertEquals(x, 1.0d, "success weakCompareAndSetAcquire double");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetAcquire(array, i, 2.0d, 3.0d);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire double");
+                double x = (double) vh.get(array, i);
+                assertEquals(x, 1.0d, "failing weakCompareAndSetAcquire double value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetRelease(array, i, 1.0d, 2.0d);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetRelease double");
+                assertEquals(success, true, "success weakCompareAndSetRelease double");
+                double x = (double) vh.get(array, i);
+                assertEquals(x, 2.0d, "success weakCompareAndSetRelease double");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetRelease(array, i, 1.0d, 3.0d);
+                assertEquals(success, false, "failing weakCompareAndSetRelease double");
                 double x = (double) vh.get(array, i);
-                assertEquals(x, 2.0d, "weakCompareAndSetRelease double");
+                assertEquals(x, 2.0d, "failing weakCompareAndSetRelease double value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSet(array, i, 2.0d, 1.0d);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSet double");
+                assertEquals(success, true, "success weakCompareAndSet double");
+                double x = (double) vh.get(array, i);
+                assertEquals(x, 1.0d, "success weakCompareAndSet double");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSet(array, i, 2.0d, 3.0d);
+                assertEquals(success, false, "failing weakCompareAndSet double");
                 double x = (double) vh.get(array, i);
-                assertEquals(x, 1.0d, "weakCompareAndSet double");
+                assertEquals(x, 1.0d, "failing weakCompareAndSet double value");
             }
 
             // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessFloat.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessFloat.java
index b7d7f046de9..4dfc0094ff6 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessFloat.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessFloat.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -493,40 +493,72 @@ public class VarHandleTestAccessFloat extends VarHandleBaseTest {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetPlain(recv, 1.0f, 2.0f);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain float");
+            assertEquals(success, true, "success weakCompareAndSetPlain float");
             float x = (float) vh.get(recv);
-            assertEquals(x, 2.0f, "weakCompareAndSetPlain float value");
+            assertEquals(x, 2.0f, "success weakCompareAndSetPlain float value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetPlain(recv, 1.0f, 3.0f);
+            assertEquals(success, false, "failing weakCompareAndSetPlain float");
+            float x = (float) vh.get(recv);
+            assertEquals(x, 2.0f, "failing weakCompareAndSetPlain float value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetAcquire(recv, 2.0f, 1.0f);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire float");
+            assertEquals(success, true, "success weakCompareAndSetAcquire float");
+            float x = (float) vh.get(recv);
+            assertEquals(x, 1.0f, "success weakCompareAndSetAcquire float");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetAcquire(recv, 2.0f, 3.0f);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire float");
             float x = (float) vh.get(recv);
-            assertEquals(x, 1.0f, "weakCompareAndSetAcquire float");
+            assertEquals(x, 1.0f, "failing weakCompareAndSetAcquire float value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetRelease(recv, 1.0f, 2.0f);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease float");
+            assertEquals(success, true, "success weakCompareAndSetRelease float");
+            float x = (float) vh.get(recv);
+            assertEquals(x, 2.0f, "success weakCompareAndSetRelease float");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetRelease(recv, 1.0f, 3.0f);
+            assertEquals(success, false, "failing weakCompareAndSetRelease float");
             float x = (float) vh.get(recv);
-            assertEquals(x, 2.0f, "weakCompareAndSetRelease float");
+            assertEquals(x, 2.0f, "failing weakCompareAndSetRelease float value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSet(recv, 2.0f, 1.0f);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet float");
+            assertEquals(success, true, "success weakCompareAndSet float");
             float x = (float) vh.get(recv);
-            assertEquals(x, 1.0f, "weakCompareAndSet float value");
+            assertEquals(x, 1.0f, "success weakCompareAndSet float value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSet(recv, 2.0f, 3.0f);
+            assertEquals(success, false, "failing weakCompareAndSet float");
+            float x = (float) vh.get(recv);
+            assertEquals(x, 1.0f, "failing weakCompareAndSet float value");
         }
 
         // Compare set and get
@@ -721,40 +753,72 @@ public class VarHandleTestAccessFloat extends VarHandleBaseTest {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetPlain(1.0f, 2.0f);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain float");
+            assertEquals(success, true, "success weakCompareAndSetPlain float");
+            float x = (float) vh.get();
+            assertEquals(x, 2.0f, "success weakCompareAndSetPlain float value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetPlain(1.0f, 3.0f);
+            assertEquals(success, false, "failing weakCompareAndSetPlain float");
             float x = (float) vh.get();
-            assertEquals(x, 2.0f, "weakCompareAndSetPlain float value");
+            assertEquals(x, 2.0f, "failing weakCompareAndSetPlain float value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetAcquire(2.0f, 1.0f);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire float");
+            assertEquals(success, true, "success weakCompareAndSetAcquire float");
+            float x = (float) vh.get();
+            assertEquals(x, 1.0f, "success weakCompareAndSetAcquire float");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetAcquire(2.0f, 3.0f);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire float");
             float x = (float) vh.get();
-            assertEquals(x, 1.0f, "weakCompareAndSetAcquire float");
+            assertEquals(x, 1.0f, "failing weakCompareAndSetAcquire float value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetRelease(1.0f, 2.0f);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease float");
+            assertEquals(success, true, "success weakCompareAndSetRelease float");
             float x = (float) vh.get();
-            assertEquals(x, 2.0f, "weakCompareAndSetRelease float");
+            assertEquals(x, 2.0f, "success weakCompareAndSetRelease float");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetRelease(1.0f, 3.0f);
+            assertEquals(success, false, "failing weakCompareAndSetRelease float");
+            float x = (float) vh.get();
+            assertEquals(x, 2.0f, "failing weakCompareAndSetRelease float value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSet(2.0f, 1.0f);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet float");
+            assertEquals(success, true, "success weakCompareAndSet float");
+            float x = (float) vh.get();
+            assertEquals(x, 1.0f, "success weakCompareAndSet float");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSet(2.0f, 3.0f);
+            assertEquals(success, false, "failing weakCompareAndSet float");
             float x = (float) vh.get();
-            assertEquals(x, 1.0f, "weakCompareAndSet float");
+            assertEquals(x, 1.0f, "failing weakCompareAndSet float value");
         }
 
         // Compare set and get
@@ -952,40 +1016,72 @@ public class VarHandleTestAccessFloat extends VarHandleBaseTest {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetPlain(array, i, 1.0f, 2.0f);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetPlain float");
+                assertEquals(success, true, "success weakCompareAndSetPlain float");
+                float x = (float) vh.get(array, i);
+                assertEquals(x, 2.0f, "success weakCompareAndSetPlain float value");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetPlain(array, i, 1.0f, 3.0f);
+                assertEquals(success, false, "failing weakCompareAndSetPlain float");
                 float x = (float) vh.get(array, i);
-                assertEquals(x, 2.0f, "weakCompareAndSetPlain float value");
+                assertEquals(x, 2.0f, "failing weakCompareAndSetPlain float value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetAcquire(array, i, 2.0f, 1.0f);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetAcquire float");
+                assertEquals(success, true, "success weakCompareAndSetAcquire float");
                 float x = (float) vh.get(array, i);
-                assertEquals(x, 1.0f, "weakCompareAndSetAcquire float");
+                assertEquals(x, 1.0f, "success weakCompareAndSetAcquire float");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetAcquire(array, i, 2.0f, 3.0f);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire float");
+                float x = (float) vh.get(array, i);
+                assertEquals(x, 1.0f, "failing weakCompareAndSetAcquire float value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetRelease(array, i, 1.0f, 2.0f);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetRelease float");
+                assertEquals(success, true, "success weakCompareAndSetRelease float");
+                float x = (float) vh.get(array, i);
+                assertEquals(x, 2.0f, "success weakCompareAndSetRelease float");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetRelease(array, i, 1.0f, 3.0f);
+                assertEquals(success, false, "failing weakCompareAndSetRelease float");
                 float x = (float) vh.get(array, i);
-                assertEquals(x, 2.0f, "weakCompareAndSetRelease float");
+                assertEquals(x, 2.0f, "failing weakCompareAndSetRelease float value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSet(array, i, 2.0f, 1.0f);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSet float");
+                assertEquals(success, true, "success weakCompareAndSet float");
+                float x = (float) vh.get(array, i);
+                assertEquals(x, 1.0f, "success weakCompareAndSet float");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSet(array, i, 2.0f, 3.0f);
+                assertEquals(success, false, "failing weakCompareAndSet float");
                 float x = (float) vh.get(array, i);
-                assertEquals(x, 1.0f, "weakCompareAndSet float");
+                assertEquals(x, 1.0f, "failing weakCompareAndSet float value");
             }
 
             // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessInt.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessInt.java
index c1a61e8ba50..ee974a222ba 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessInt.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessInt.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -423,40 +423,72 @@ public class VarHandleTestAccessInt extends VarHandleBaseTest {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetPlain(recv, 0x01234567, 0x89ABCDEF);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain int");
+            assertEquals(success, true, "success weakCompareAndSetPlain int");
             int x = (int) vh.get(recv);
-            assertEquals(x, 0x89ABCDEF, "weakCompareAndSetPlain int value");
+            assertEquals(x, 0x89ABCDEF, "success weakCompareAndSetPlain int value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetPlain(recv, 0x01234567, 0xCAFEBABE);
+            assertEquals(success, false, "failing weakCompareAndSetPlain int");
+            int x = (int) vh.get(recv);
+            assertEquals(x, 0x89ABCDEF, "failing weakCompareAndSetPlain int value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetAcquire(recv, 0x89ABCDEF, 0x01234567);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire int");
+            assertEquals(success, true, "success weakCompareAndSetAcquire int");
+            int x = (int) vh.get(recv);
+            assertEquals(x, 0x01234567, "success weakCompareAndSetAcquire int");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetAcquire(recv, 0x89ABCDEF, 0xCAFEBABE);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire int");
             int x = (int) vh.get(recv);
-            assertEquals(x, 0x01234567, "weakCompareAndSetAcquire int");
+            assertEquals(x, 0x01234567, "failing weakCompareAndSetAcquire int value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetRelease(recv, 0x01234567, 0x89ABCDEF);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease int");
+            assertEquals(success, true, "success weakCompareAndSetRelease int");
+            int x = (int) vh.get(recv);
+            assertEquals(x, 0x89ABCDEF, "success weakCompareAndSetRelease int");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetRelease(recv, 0x01234567, 0xCAFEBABE);
+            assertEquals(success, false, "failing weakCompareAndSetRelease int");
             int x = (int) vh.get(recv);
-            assertEquals(x, 0x89ABCDEF, "weakCompareAndSetRelease int");
+            assertEquals(x, 0x89ABCDEF, "failing weakCompareAndSetRelease int value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSet(recv, 0x89ABCDEF, 0x01234567);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet int");
+            assertEquals(success, true, "success weakCompareAndSet int");
             int x = (int) vh.get(recv);
-            assertEquals(x, 0x01234567, "weakCompareAndSet int value");
+            assertEquals(x, 0x01234567, "success weakCompareAndSet int value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSet(recv, 0x89ABCDEF, 0xCAFEBABE);
+            assertEquals(success, false, "failing weakCompareAndSet int");
+            int x = (int) vh.get(recv);
+            assertEquals(x, 0x01234567, "failing weakCompareAndSet int value");
         }
 
         // Compare set and get
@@ -699,40 +731,72 @@ public class VarHandleTestAccessInt extends VarHandleBaseTest {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetPlain(0x01234567, 0x89ABCDEF);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain int");
+            assertEquals(success, true, "success weakCompareAndSetPlain int");
+            int x = (int) vh.get();
+            assertEquals(x, 0x89ABCDEF, "success weakCompareAndSetPlain int value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetPlain(0x01234567, 0xCAFEBABE);
+            assertEquals(success, false, "failing weakCompareAndSetPlain int");
             int x = (int) vh.get();
-            assertEquals(x, 0x89ABCDEF, "weakCompareAndSetPlain int value");
+            assertEquals(x, 0x89ABCDEF, "failing weakCompareAndSetPlain int value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetAcquire(0x89ABCDEF, 0x01234567);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire int");
+            assertEquals(success, true, "success weakCompareAndSetAcquire int");
+            int x = (int) vh.get();
+            assertEquals(x, 0x01234567, "success weakCompareAndSetAcquire int");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetAcquire(0x89ABCDEF, 0xCAFEBABE);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire int");
             int x = (int) vh.get();
-            assertEquals(x, 0x01234567, "weakCompareAndSetAcquire int");
+            assertEquals(x, 0x01234567, "failing weakCompareAndSetAcquire int value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetRelease(0x01234567, 0x89ABCDEF);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease int");
+            assertEquals(success, true, "success weakCompareAndSetRelease int");
             int x = (int) vh.get();
-            assertEquals(x, 0x89ABCDEF, "weakCompareAndSetRelease int");
+            assertEquals(x, 0x89ABCDEF, "success weakCompareAndSetRelease int");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetRelease(0x01234567, 0xCAFEBABE);
+            assertEquals(success, false, "failing weakCompareAndSetRelease int");
+            int x = (int) vh.get();
+            assertEquals(x, 0x89ABCDEF, "failing weakCompareAndSetRelease int value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSet(0x89ABCDEF, 0x01234567);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet int");
+            assertEquals(success, true, "success weakCompareAndSet int");
+            int x = (int) vh.get();
+            assertEquals(x, 0x01234567, "success weakCompareAndSet int");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSet(0x89ABCDEF, 0xCAFEBABE);
+            assertEquals(success, false, "failing weakCompareAndSet int");
             int x = (int) vh.get();
-            assertEquals(x, 0x01234567, "weakCompareAndSet int");
+            assertEquals(x, 0x01234567, "failing weakCompareAndSet int value");
         }
 
         // Compare set and get
@@ -978,40 +1042,72 @@ public class VarHandleTestAccessInt extends VarHandleBaseTest {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetPlain(array, i, 0x01234567, 0x89ABCDEF);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetPlain int");
+                assertEquals(success, true, "success weakCompareAndSetPlain int");
+                int x = (int) vh.get(array, i);
+                assertEquals(x, 0x89ABCDEF, "success weakCompareAndSetPlain int value");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetPlain(array, i, 0x01234567, 0xCAFEBABE);
+                assertEquals(success, false, "failing weakCompareAndSetPlain int");
                 int x = (int) vh.get(array, i);
-                assertEquals(x, 0x89ABCDEF, "weakCompareAndSetPlain int value");
+                assertEquals(x, 0x89ABCDEF, "failing weakCompareAndSetPlain int value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetAcquire(array, i, 0x89ABCDEF, 0x01234567);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetAcquire int");
+                assertEquals(success, true, "success weakCompareAndSetAcquire int");
                 int x = (int) vh.get(array, i);
-                assertEquals(x, 0x01234567, "weakCompareAndSetAcquire int");
+                assertEquals(x, 0x01234567, "success weakCompareAndSetAcquire int");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetAcquire(array, i, 0x89ABCDEF, 0xCAFEBABE);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire int");
+                int x = (int) vh.get(array, i);
+                assertEquals(x, 0x01234567, "failing weakCompareAndSetAcquire int value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetRelease(array, i, 0x01234567, 0x89ABCDEF);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetRelease int");
+                assertEquals(success, true, "success weakCompareAndSetRelease int");
+                int x = (int) vh.get(array, i);
+                assertEquals(x, 0x89ABCDEF, "success weakCompareAndSetRelease int");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetRelease(array, i, 0x01234567, 0xCAFEBABE);
+                assertEquals(success, false, "failing weakCompareAndSetRelease int");
                 int x = (int) vh.get(array, i);
-                assertEquals(x, 0x89ABCDEF, "weakCompareAndSetRelease int");
+                assertEquals(x, 0x89ABCDEF, "failing weakCompareAndSetRelease int value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSet(array, i, 0x89ABCDEF, 0x01234567);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSet int");
+                assertEquals(success, true, "success weakCompareAndSet int");
+                int x = (int) vh.get(array, i);
+                assertEquals(x, 0x01234567, "success weakCompareAndSet int");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSet(array, i, 0x89ABCDEF, 0xCAFEBABE);
+                assertEquals(success, false, "failing weakCompareAndSet int");
                 int x = (int) vh.get(array, i);
-                assertEquals(x, 0x01234567, "weakCompareAndSet int");
+                assertEquals(x, 0x01234567, "failing weakCompareAndSet int value");
             }
 
             // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessLong.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessLong.java
index 8eea846118e..3ec03371c31 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessLong.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessLong.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -423,40 +423,72 @@ public class VarHandleTestAccessLong extends VarHandleBaseTest {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetPlain(recv, 0x0123456789ABCDEFL, 0xCAFEBABECAFEBABEL);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain long");
+            assertEquals(success, true, "success weakCompareAndSetPlain long");
             long x = (long) vh.get(recv);
-            assertEquals(x, 0xCAFEBABECAFEBABEL, "weakCompareAndSetPlain long value");
+            assertEquals(x, 0xCAFEBABECAFEBABEL, "success weakCompareAndSetPlain long value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetPlain(recv, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);
+            assertEquals(success, false, "failing weakCompareAndSetPlain long");
+            long x = (long) vh.get(recv);
+            assertEquals(x, 0xCAFEBABECAFEBABEL, "failing weakCompareAndSetPlain long value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetAcquire(recv, 0xCAFEBABECAFEBABEL, 0x0123456789ABCDEFL);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire long");
+            assertEquals(success, true, "success weakCompareAndSetAcquire long");
+            long x = (long) vh.get(recv);
+            assertEquals(x, 0x0123456789ABCDEFL, "success weakCompareAndSetAcquire long");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetAcquire(recv, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire long");
             long x = (long) vh.get(recv);
-            assertEquals(x, 0x0123456789ABCDEFL, "weakCompareAndSetAcquire long");
+            assertEquals(x, 0x0123456789ABCDEFL, "failing weakCompareAndSetAcquire long value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetRelease(recv, 0x0123456789ABCDEFL, 0xCAFEBABECAFEBABEL);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease long");
+            assertEquals(success, true, "success weakCompareAndSetRelease long");
+            long x = (long) vh.get(recv);
+            assertEquals(x, 0xCAFEBABECAFEBABEL, "success weakCompareAndSetRelease long");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetRelease(recv, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);
+            assertEquals(success, false, "failing weakCompareAndSetRelease long");
             long x = (long) vh.get(recv);
-            assertEquals(x, 0xCAFEBABECAFEBABEL, "weakCompareAndSetRelease long");
+            assertEquals(x, 0xCAFEBABECAFEBABEL, "failing weakCompareAndSetRelease long value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSet(recv, 0xCAFEBABECAFEBABEL, 0x0123456789ABCDEFL);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet long");
+            assertEquals(success, true, "success weakCompareAndSet long");
             long x = (long) vh.get(recv);
-            assertEquals(x, 0x0123456789ABCDEFL, "weakCompareAndSet long value");
+            assertEquals(x, 0x0123456789ABCDEFL, "success weakCompareAndSet long value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSet(recv, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);
+            assertEquals(success, false, "failing weakCompareAndSet long");
+            long x = (long) vh.get(recv);
+            assertEquals(x, 0x0123456789ABCDEFL, "failing weakCompareAndSet long value");
         }
 
         // Compare set and get
@@ -699,40 +731,72 @@ public class VarHandleTestAccessLong extends VarHandleBaseTest {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetPlain(0x0123456789ABCDEFL, 0xCAFEBABECAFEBABEL);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain long");
+            assertEquals(success, true, "success weakCompareAndSetPlain long");
+            long x = (long) vh.get();
+            assertEquals(x, 0xCAFEBABECAFEBABEL, "success weakCompareAndSetPlain long value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetPlain(0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);
+            assertEquals(success, false, "failing weakCompareAndSetPlain long");
             long x = (long) vh.get();
-            assertEquals(x, 0xCAFEBABECAFEBABEL, "weakCompareAndSetPlain long value");
+            assertEquals(x, 0xCAFEBABECAFEBABEL, "failing weakCompareAndSetPlain long value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetAcquire(0xCAFEBABECAFEBABEL, 0x0123456789ABCDEFL);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire long");
+            assertEquals(success, true, "success weakCompareAndSetAcquire long");
+            long x = (long) vh.get();
+            assertEquals(x, 0x0123456789ABCDEFL, "success weakCompareAndSetAcquire long");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetAcquire(0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire long");
             long x = (long) vh.get();
-            assertEquals(x, 0x0123456789ABCDEFL, "weakCompareAndSetAcquire long");
+            assertEquals(x, 0x0123456789ABCDEFL, "failing weakCompareAndSetAcquire long value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetRelease(0x0123456789ABCDEFL, 0xCAFEBABECAFEBABEL);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease long");
+            assertEquals(success, true, "success weakCompareAndSetRelease long");
             long x = (long) vh.get();
-            assertEquals(x, 0xCAFEBABECAFEBABEL, "weakCompareAndSetRelease long");
+            assertEquals(x, 0xCAFEBABECAFEBABEL, "success weakCompareAndSetRelease long");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetRelease(0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);
+            assertEquals(success, false, "failing weakCompareAndSetRelease long");
+            long x = (long) vh.get();
+            assertEquals(x, 0xCAFEBABECAFEBABEL, "failing weakCompareAndSetRelease long value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSet(0xCAFEBABECAFEBABEL, 0x0123456789ABCDEFL);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet long");
+            assertEquals(success, true, "success weakCompareAndSet long");
+            long x = (long) vh.get();
+            assertEquals(x, 0x0123456789ABCDEFL, "success weakCompareAndSet long");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSet(0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);
+            assertEquals(success, false, "failing weakCompareAndSet long");
             long x = (long) vh.get();
-            assertEquals(x, 0x0123456789ABCDEFL, "weakCompareAndSet long");
+            assertEquals(x, 0x0123456789ABCDEFL, "failing weakCompareAndSet long value");
         }
 
         // Compare set and get
@@ -978,40 +1042,72 @@ public class VarHandleTestAccessLong extends VarHandleBaseTest {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetPlain(array, i, 0x0123456789ABCDEFL, 0xCAFEBABECAFEBABEL);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetPlain long");
+                assertEquals(success, true, "success weakCompareAndSetPlain long");
+                long x = (long) vh.get(array, i);
+                assertEquals(x, 0xCAFEBABECAFEBABEL, "success weakCompareAndSetPlain long value");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetPlain(array, i, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);
+                assertEquals(success, false, "failing weakCompareAndSetPlain long");
                 long x = (long) vh.get(array, i);
-                assertEquals(x, 0xCAFEBABECAFEBABEL, "weakCompareAndSetPlain long value");
+                assertEquals(x, 0xCAFEBABECAFEBABEL, "failing weakCompareAndSetPlain long value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetAcquire(array, i, 0xCAFEBABECAFEBABEL, 0x0123456789ABCDEFL);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetAcquire long");
+                assertEquals(success, true, "success weakCompareAndSetAcquire long");
                 long x = (long) vh.get(array, i);
-                assertEquals(x, 0x0123456789ABCDEFL, "weakCompareAndSetAcquire long");
+                assertEquals(x, 0x0123456789ABCDEFL, "success weakCompareAndSetAcquire long");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetAcquire(array, i, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire long");
+                long x = (long) vh.get(array, i);
+                assertEquals(x, 0x0123456789ABCDEFL, "failing weakCompareAndSetAcquire long value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetRelease(array, i, 0x0123456789ABCDEFL, 0xCAFEBABECAFEBABEL);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetRelease long");
+                assertEquals(success, true, "success weakCompareAndSetRelease long");
+                long x = (long) vh.get(array, i);
+                assertEquals(x, 0xCAFEBABECAFEBABEL, "success weakCompareAndSetRelease long");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetRelease(array, i, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);
+                assertEquals(success, false, "failing weakCompareAndSetRelease long");
                 long x = (long) vh.get(array, i);
-                assertEquals(x, 0xCAFEBABECAFEBABEL, "weakCompareAndSetRelease long");
+                assertEquals(x, 0xCAFEBABECAFEBABEL, "failing weakCompareAndSetRelease long value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSet(array, i, 0xCAFEBABECAFEBABEL, 0x0123456789ABCDEFL);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSet long");
+                assertEquals(success, true, "success weakCompareAndSet long");
+                long x = (long) vh.get(array, i);
+                assertEquals(x, 0x0123456789ABCDEFL, "success weakCompareAndSet long");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSet(array, i, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);
+                assertEquals(success, false, "failing weakCompareAndSet long");
                 long x = (long) vh.get(array, i);
-                assertEquals(x, 0x0123456789ABCDEFL, "weakCompareAndSet long");
+                assertEquals(x, 0x0123456789ABCDEFL, "failing weakCompareAndSet long value");
             }
 
             // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessShort.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessShort.java
index 4854aeb120a..824ca527a11 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessShort.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessShort.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -423,40 +423,72 @@ public class VarHandleTestAccessShort extends VarHandleBaseTest {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetPlain(recv, (short)0x0123, (short)0x4567);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain short");
+            assertEquals(success, true, "success weakCompareAndSetPlain short");
             short x = (short) vh.get(recv);
-            assertEquals(x, (short)0x4567, "weakCompareAndSetPlain short value");
+            assertEquals(x, (short)0x4567, "success weakCompareAndSetPlain short value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetPlain(recv, (short)0x0123, (short)0x89AB);
+            assertEquals(success, false, "failing weakCompareAndSetPlain short");
+            short x = (short) vh.get(recv);
+            assertEquals(x, (short)0x4567, "failing weakCompareAndSetPlain short value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetAcquire(recv, (short)0x4567, (short)0x0123);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire short");
+            assertEquals(success, true, "success weakCompareAndSetAcquire short");
+            short x = (short) vh.get(recv);
+            assertEquals(x, (short)0x0123, "success weakCompareAndSetAcquire short");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetAcquire(recv, (short)0x4567, (short)0x89AB);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire short");
             short x = (short) vh.get(recv);
-            assertEquals(x, (short)0x0123, "weakCompareAndSetAcquire short");
+            assertEquals(x, (short)0x0123, "failing weakCompareAndSetAcquire short value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetRelease(recv, (short)0x0123, (short)0x4567);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease short");
+            assertEquals(success, true, "success weakCompareAndSetRelease short");
+            short x = (short) vh.get(recv);
+            assertEquals(x, (short)0x4567, "success weakCompareAndSetRelease short");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetRelease(recv, (short)0x0123, (short)0x89AB);
+            assertEquals(success, false, "failing weakCompareAndSetRelease short");
             short x = (short) vh.get(recv);
-            assertEquals(x, (short)0x4567, "weakCompareAndSetRelease short");
+            assertEquals(x, (short)0x4567, "failing weakCompareAndSetRelease short value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSet(recv, (short)0x4567, (short)0x0123);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet short");
+            assertEquals(success, true, "success weakCompareAndSet short");
             short x = (short) vh.get(recv);
-            assertEquals(x, (short)0x0123, "weakCompareAndSet short value");
+            assertEquals(x, (short)0x0123, "success weakCompareAndSet short value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSet(recv, (short)0x4567, (short)0x89AB);
+            assertEquals(success, false, "failing weakCompareAndSet short");
+            short x = (short) vh.get(recv);
+            assertEquals(x, (short)0x0123, "failing weakCompareAndSet short value");
         }
 
         // Compare set and get
@@ -699,40 +731,72 @@ public class VarHandleTestAccessShort extends VarHandleBaseTest {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetPlain((short)0x0123, (short)0x4567);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain short");
+            assertEquals(success, true, "success weakCompareAndSetPlain short");
+            short x = (short) vh.get();
+            assertEquals(x, (short)0x4567, "success weakCompareAndSetPlain short value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetPlain((short)0x0123, (short)0x89AB);
+            assertEquals(success, false, "failing weakCompareAndSetPlain short");
             short x = (short) vh.get();
-            assertEquals(x, (short)0x4567, "weakCompareAndSetPlain short value");
+            assertEquals(x, (short)0x4567, "failing weakCompareAndSetPlain short value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetAcquire((short)0x4567, (short)0x0123);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire short");
+            assertEquals(success, true, "success weakCompareAndSetAcquire short");
+            short x = (short) vh.get();
+            assertEquals(x, (short)0x0123, "success weakCompareAndSetAcquire short");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetAcquire((short)0x4567, (short)0x89AB);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire short");
             short x = (short) vh.get();
-            assertEquals(x, (short)0x0123, "weakCompareAndSetAcquire short");
+            assertEquals(x, (short)0x0123, "failing weakCompareAndSetAcquire short value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetRelease((short)0x0123, (short)0x4567);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease short");
+            assertEquals(success, true, "success weakCompareAndSetRelease short");
             short x = (short) vh.get();
-            assertEquals(x, (short)0x4567, "weakCompareAndSetRelease short");
+            assertEquals(x, (short)0x4567, "success weakCompareAndSetRelease short");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetRelease((short)0x0123, (short)0x89AB);
+            assertEquals(success, false, "failing weakCompareAndSetRelease short");
+            short x = (short) vh.get();
+            assertEquals(x, (short)0x4567, "failing weakCompareAndSetRelease short value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSet((short)0x4567, (short)0x0123);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet short");
+            assertEquals(success, true, "success weakCompareAndSet short");
+            short x = (short) vh.get();
+            assertEquals(x, (short)0x0123, "success weakCompareAndSet short");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSet((short)0x4567, (short)0x89AB);
+            assertEquals(success, false, "failing weakCompareAndSet short");
             short x = (short) vh.get();
-            assertEquals(x, (short)0x0123, "weakCompareAndSet short");
+            assertEquals(x, (short)0x0123, "failing weakCompareAndSet short value");
         }
 
         // Compare set and get
@@ -978,40 +1042,72 @@ public class VarHandleTestAccessShort extends VarHandleBaseTest {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetPlain(array, i, (short)0x0123, (short)0x4567);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetPlain short");
+                assertEquals(success, true, "success weakCompareAndSetPlain short");
+                short x = (short) vh.get(array, i);
+                assertEquals(x, (short)0x4567, "success weakCompareAndSetPlain short value");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetPlain(array, i, (short)0x0123, (short)0x89AB);
+                assertEquals(success, false, "failing weakCompareAndSetPlain short");
                 short x = (short) vh.get(array, i);
-                assertEquals(x, (short)0x4567, "weakCompareAndSetPlain short value");
+                assertEquals(x, (short)0x4567, "failing weakCompareAndSetPlain short value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetAcquire(array, i, (short)0x4567, (short)0x0123);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetAcquire short");
+                assertEquals(success, true, "success weakCompareAndSetAcquire short");
                 short x = (short) vh.get(array, i);
-                assertEquals(x, (short)0x0123, "weakCompareAndSetAcquire short");
+                assertEquals(x, (short)0x0123, "success weakCompareAndSetAcquire short");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetAcquire(array, i, (short)0x4567, (short)0x89AB);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire short");
+                short x = (short) vh.get(array, i);
+                assertEquals(x, (short)0x0123, "failing weakCompareAndSetAcquire short value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetRelease(array, i, (short)0x0123, (short)0x4567);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetRelease short");
+                assertEquals(success, true, "success weakCompareAndSetRelease short");
+                short x = (short) vh.get(array, i);
+                assertEquals(x, (short)0x4567, "success weakCompareAndSetRelease short");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetRelease(array, i, (short)0x0123, (short)0x89AB);
+                assertEquals(success, false, "failing weakCompareAndSetRelease short");
                 short x = (short) vh.get(array, i);
-                assertEquals(x, (short)0x4567, "weakCompareAndSetRelease short");
+                assertEquals(x, (short)0x4567, "failing weakCompareAndSetRelease short value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSet(array, i, (short)0x4567, (short)0x0123);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSet short");
+                assertEquals(success, true, "success weakCompareAndSet short");
+                short x = (short) vh.get(array, i);
+                assertEquals(x, (short)0x0123, "success weakCompareAndSet short");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSet(array, i, (short)0x4567, (short)0x89AB);
+                assertEquals(success, false, "failing weakCompareAndSet short");
                 short x = (short) vh.get(array, i);
-                assertEquals(x, (short)0x0123, "weakCompareAndSet short");
+                assertEquals(x, (short)0x0123, "failing weakCompareAndSet short value");
             }
 
             // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessString.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessString.java
index 144504b66c8..b6c686c7c89 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessString.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestAccessString.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -522,40 +522,72 @@ public class VarHandleTestAccessString extends VarHandleBaseTest {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetPlain(recv, "foo", "bar");
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain String");
+            assertEquals(success, true, "success weakCompareAndSetPlain String");
             String x = (String) vh.get(recv);
-            assertEquals(x, "bar", "weakCompareAndSetPlain String value");
+            assertEquals(x, "bar", "success weakCompareAndSetPlain String value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetPlain(recv, "foo", "baz");
+            assertEquals(success, false, "failing weakCompareAndSetPlain String");
+            String x = (String) vh.get(recv);
+            assertEquals(x, "bar", "failing weakCompareAndSetPlain String value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetAcquire(recv, "bar", "foo");
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire String");
+            assertEquals(success, true, "success weakCompareAndSetAcquire String");
+            String x = (String) vh.get(recv);
+            assertEquals(x, "foo", "success weakCompareAndSetAcquire String");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetAcquire(recv, "bar", "baz");
+            assertEquals(success, false, "failing weakCompareAndSetAcquire String");
             String x = (String) vh.get(recv);
-            assertEquals(x, "foo", "weakCompareAndSetAcquire String");
+            assertEquals(x, "foo", "failing weakCompareAndSetAcquire String value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetRelease(recv, "foo", "bar");
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease String");
+            assertEquals(success, true, "success weakCompareAndSetRelease String");
+            String x = (String) vh.get(recv);
+            assertEquals(x, "bar", "success weakCompareAndSetRelease String");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetRelease(recv, "foo", "baz");
+            assertEquals(success, false, "failing weakCompareAndSetRelease String");
             String x = (String) vh.get(recv);
-            assertEquals(x, "bar", "weakCompareAndSetRelease String");
+            assertEquals(x, "bar", "failing weakCompareAndSetRelease String value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSet(recv, "bar", "foo");
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet String");
+            assertEquals(success, true, "success weakCompareAndSet String");
             String x = (String) vh.get(recv);
-            assertEquals(x, "foo", "weakCompareAndSet String value");
+            assertEquals(x, "foo", "success weakCompareAndSet String value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSet(recv, "bar", "baz");
+            assertEquals(success, false, "failing weakCompareAndSet String");
+            String x = (String) vh.get(recv);
+            assertEquals(x, "foo", "failing weakCompareAndSet String value");
         }
 
         // Compare set and get
@@ -734,40 +766,72 @@ public class VarHandleTestAccessString extends VarHandleBaseTest {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetPlain("foo", "bar");
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain String");
+            assertEquals(success, true, "success weakCompareAndSetPlain String");
+            String x = (String) vh.get();
+            assertEquals(x, "bar", "success weakCompareAndSetPlain String value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetPlain("foo", "baz");
+            assertEquals(success, false, "failing weakCompareAndSetPlain String");
             String x = (String) vh.get();
-            assertEquals(x, "bar", "weakCompareAndSetPlain String value");
+            assertEquals(x, "bar", "failing weakCompareAndSetPlain String value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetAcquire("bar", "foo");
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire String");
+            assertEquals(success, true, "success weakCompareAndSetAcquire String");
+            String x = (String) vh.get();
+            assertEquals(x, "foo", "success weakCompareAndSetAcquire String");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetAcquire("bar", "baz");
+            assertEquals(success, false, "failing weakCompareAndSetAcquire String");
             String x = (String) vh.get();
-            assertEquals(x, "foo", "weakCompareAndSetAcquire String");
+            assertEquals(x, "foo", "failing weakCompareAndSetAcquire String value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetRelease("foo", "bar");
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease String");
+            assertEquals(success, true, "success weakCompareAndSetRelease String");
             String x = (String) vh.get();
-            assertEquals(x, "bar", "weakCompareAndSetRelease String");
+            assertEquals(x, "bar", "success weakCompareAndSetRelease String");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetRelease("foo", "baz");
+            assertEquals(success, false, "failing weakCompareAndSetRelease String");
+            String x = (String) vh.get();
+            assertEquals(x, "bar", "failing weakCompareAndSetRelease String value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSet("bar", "foo");
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet String");
+            assertEquals(success, true, "success weakCompareAndSet String");
+            String x = (String) vh.get();
+            assertEquals(x, "foo", "success weakCompareAndSet String");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSet("bar", "baz");
+            assertEquals(success, false, "failing weakCompareAndSet String");
             String x = (String) vh.get();
-            assertEquals(x, "foo", "weakCompareAndSet String");
+            assertEquals(x, "foo", "failing weakCompareAndSet String value");
         }
 
         // Compare set and get
@@ -949,40 +1013,72 @@ public class VarHandleTestAccessString extends VarHandleBaseTest {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetPlain(array, i, "foo", "bar");
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetPlain String");
+                assertEquals(success, true, "success weakCompareAndSetPlain String");
+                String x = (String) vh.get(array, i);
+                assertEquals(x, "bar", "success weakCompareAndSetPlain String value");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetPlain(array, i, "foo", "baz");
+                assertEquals(success, false, "failing weakCompareAndSetPlain String");
                 String x = (String) vh.get(array, i);
-                assertEquals(x, "bar", "weakCompareAndSetPlain String value");
+                assertEquals(x, "bar", "failing weakCompareAndSetPlain String value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetAcquire(array, i, "bar", "foo");
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetAcquire String");
+                assertEquals(success, true, "success weakCompareAndSetAcquire String");
                 String x = (String) vh.get(array, i);
-                assertEquals(x, "foo", "weakCompareAndSetAcquire String");
+                assertEquals(x, "foo", "success weakCompareAndSetAcquire String");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetAcquire(array, i, "bar", "baz");
+                assertEquals(success, false, "failing weakCompareAndSetAcquire String");
+                String x = (String) vh.get(array, i);
+                assertEquals(x, "foo", "failing weakCompareAndSetAcquire String value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetRelease(array, i, "foo", "bar");
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetRelease String");
+                assertEquals(success, true, "success weakCompareAndSetRelease String");
+                String x = (String) vh.get(array, i);
+                assertEquals(x, "bar", "success weakCompareAndSetRelease String");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetRelease(array, i, "foo", "baz");
+                assertEquals(success, false, "failing weakCompareAndSetRelease String");
                 String x = (String) vh.get(array, i);
-                assertEquals(x, "bar", "weakCompareAndSetRelease String");
+                assertEquals(x, "bar", "failing weakCompareAndSetRelease String value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSet(array, i, "bar", "foo");
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSet String");
+                assertEquals(success, true, "success weakCompareAndSet String");
+                String x = (String) vh.get(array, i);
+                assertEquals(x, "foo", "success weakCompareAndSet String");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSet(array, i, "bar", "baz");
+                assertEquals(success, false, "failing weakCompareAndSet String");
                 String x = (String) vh.get(array, i);
-                assertEquals(x, "foo", "weakCompareAndSet String");
+                assertEquals(x, "foo", "failing weakCompareAndSet String value");
             }
 
             // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsChar.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsChar.java
index 83d57eda765..f6774d9645d 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsChar.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsChar.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,9 +27,9 @@ package test.java.lang.invoke.VarHandles;
 /*
  * @test
  * @bug 8154556
- * @run testng/othervm -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestByteArrayAsChar
- * @run testng/othervm -Diters=20000                         VarHandleTestByteArrayAsChar
- * @run testng/othervm -Diters=20000 -XX:-TieredCompilation  VarHandleTestByteArrayAsChar
+ * @run testng/othervm/timeout=360 -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestByteArrayAsChar
+ * @run testng/othervm/timeout=360 -Diters=20000                         VarHandleTestByteArrayAsChar
+ * @run testng/othervm/timeout=360 -Diters=20000 -XX:-TieredCompilation  VarHandleTestByteArrayAsChar
  */
 
 import org.testng.annotations.DataProvider;
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsDouble.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsDouble.java
index 55fa4a7b224..d74c7404e45 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsDouble.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsDouble.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,9 +27,9 @@ package test.java.lang.invoke.VarHandles;
 /*
  * @test
  * @bug 8154556
- * @run testng/othervm -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestByteArrayAsDouble
- * @run testng/othervm -Diters=20000                         VarHandleTestByteArrayAsDouble
- * @run testng/othervm -Diters=20000 -XX:-TieredCompilation  VarHandleTestByteArrayAsDouble
+ * @run testng/othervm/timeout=360 -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestByteArrayAsDouble
+ * @run testng/othervm/timeout=360 -Diters=20000                         VarHandleTestByteArrayAsDouble
+ * @run testng/othervm/timeout=360 -Diters=20000 -XX:-TieredCompilation  VarHandleTestByteArrayAsDouble
  */
 
 import org.testng.annotations.DataProvider;
@@ -1053,40 +1053,72 @@ public class VarHandleTestByteArrayAsDouble extends VarHandleBaseByteArrayTest {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_2);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetPlain double");
+                    assertEquals(success, true, "success weakCompareAndSetPlain double");
                     double x = (double) vh.get(array, i);
-                    assertEquals(x, VALUE_2, "weakCompareAndSetPlain double value");
+                    assertEquals(x, VALUE_2, "success weakCompareAndSetPlain double value");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetPlain double");
+                    double x = (double) vh.get(array, i);
+                    assertEquals(x, VALUE_2, "failing weakCompareAndSetPlain double value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_1);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetAcquire double");
+                    assertEquals(success, true, "success weakCompareAndSetAcquire double");
+                    double x = (double) vh.get(array, i);
+                    assertEquals(x, VALUE_1, "success weakCompareAndSetAcquire double");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetAcquire double");
                     double x = (double) vh.get(array, i);
-                    assertEquals(x, VALUE_1, "weakCompareAndSetAcquire double");
+                    assertEquals(x, VALUE_1, "failing weakCompareAndSetAcquire double value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_2);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetRelease double");
+                    assertEquals(success, true, "success weakCompareAndSetRelease double");
                     double x = (double) vh.get(array, i);
-                    assertEquals(x, VALUE_2, "weakCompareAndSetRelease double");
+                    assertEquals(x, VALUE_2, "success weakCompareAndSetRelease double");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetRelease double");
+                    double x = (double) vh.get(array, i);
+                    assertEquals(x, VALUE_2, "failing weakCompareAndSetRelease double value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_1);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSet double");
+                    assertEquals(success, true, "success weakCompareAndSet double");
+                    double x = (double) vh.get(array, i);
+                    assertEquals(x, VALUE_1, "success weakCompareAndSet double");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSet double");
                     double x = (double) vh.get(array, i);
-                    assertEquals(x, VALUE_1, "weakCompareAndSet double");
+                    assertEquals(x, VALUE_1, "failing weakCompareAndSet double value");
                 }
 
                 // Compare set and get
@@ -1226,40 +1258,72 @@ public class VarHandleTestByteArrayAsDouble extends VarHandleBaseByteArrayTest {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_2);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetPlain double");
+                    assertEquals(success, true, "success weakCompareAndSetPlain double");
                     double x = (double) vh.get(array, i);
-                    assertEquals(x, VALUE_2, "weakCompareAndSetPlain double value");
+                    assertEquals(x, VALUE_2, "success weakCompareAndSetPlain double value");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetPlain double");
+                    double x = (double) vh.get(array, i);
+                    assertEquals(x, VALUE_2, "failing weakCompareAndSetPlain double value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_1);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetAcquire double");
+                    assertEquals(success, true, "success weakCompareAndSetAcquire double");
+                    double x = (double) vh.get(array, i);
+                    assertEquals(x, VALUE_1, "success weakCompareAndSetAcquire double");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetAcquire double");
                     double x = (double) vh.get(array, i);
-                    assertEquals(x, VALUE_1, "weakCompareAndSetAcquire double");
+                    assertEquals(x, VALUE_1, "failing weakCompareAndSetAcquire double value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_2);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetRelease double");
+                    assertEquals(success, true, "success weakCompareAndSetRelease double");
                     double x = (double) vh.get(array, i);
-                    assertEquals(x, VALUE_2, "weakCompareAndSetRelease double");
+                    assertEquals(x, VALUE_2, "success weakCompareAndSetRelease double");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetRelease double");
+                    double x = (double) vh.get(array, i);
+                    assertEquals(x, VALUE_2, "failing weakCompareAndSetRelease double value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_1);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSet double");
+                    assertEquals(success, true, "success weakCompareAndSet double");
+                    double x = (double) vh.get(array, i);
+                    assertEquals(x, VALUE_1, "success weakCompareAndSet double");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSet double");
                     double x = (double) vh.get(array, i);
-                    assertEquals(x, VALUE_1, "weakCompareAndSet double");
+                    assertEquals(x, VALUE_1, "failing weakCompareAndSet double value");
                 }
 
                 // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsFloat.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsFloat.java
index bfeb8a8713b..82171d85d08 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsFloat.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsFloat.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,9 +27,9 @@ package test.java.lang.invoke.VarHandles;
 /*
  * @test
  * @bug 8154556
- * @run testng/othervm -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestByteArrayAsFloat
- * @run testng/othervm -Diters=20000                         VarHandleTestByteArrayAsFloat
- * @run testng/othervm -Diters=20000 -XX:-TieredCompilation  VarHandleTestByteArrayAsFloat
+ * @run testng/othervm/timeout=360 -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestByteArrayAsFloat
+ * @run testng/othervm/timeout=360 -Diters=20000                         VarHandleTestByteArrayAsFloat
+ * @run testng/othervm/timeout=360 -Diters=20000 -XX:-TieredCompilation  VarHandleTestByteArrayAsFloat
  */
 
 import org.testng.annotations.DataProvider;
@@ -1053,40 +1053,72 @@ public class VarHandleTestByteArrayAsFloat extends VarHandleBaseByteArrayTest {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_2);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetPlain float");
+                    assertEquals(success, true, "success weakCompareAndSetPlain float");
                     float x = (float) vh.get(array, i);
-                    assertEquals(x, VALUE_2, "weakCompareAndSetPlain float value");
+                    assertEquals(x, VALUE_2, "success weakCompareAndSetPlain float value");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetPlain float");
+                    float x = (float) vh.get(array, i);
+                    assertEquals(x, VALUE_2, "failing weakCompareAndSetPlain float value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_1);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetAcquire float");
+                    assertEquals(success, true, "success weakCompareAndSetAcquire float");
+                    float x = (float) vh.get(array, i);
+                    assertEquals(x, VALUE_1, "success weakCompareAndSetAcquire float");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetAcquire float");
                     float x = (float) vh.get(array, i);
-                    assertEquals(x, VALUE_1, "weakCompareAndSetAcquire float");
+                    assertEquals(x, VALUE_1, "failing weakCompareAndSetAcquire float value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_2);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetRelease float");
+                    assertEquals(success, true, "success weakCompareAndSetRelease float");
                     float x = (float) vh.get(array, i);
-                    assertEquals(x, VALUE_2, "weakCompareAndSetRelease float");
+                    assertEquals(x, VALUE_2, "success weakCompareAndSetRelease float");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetRelease float");
+                    float x = (float) vh.get(array, i);
+                    assertEquals(x, VALUE_2, "failing weakCompareAndSetRelease float value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_1);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSet float");
+                    assertEquals(success, true, "success weakCompareAndSet float");
+                    float x = (float) vh.get(array, i);
+                    assertEquals(x, VALUE_1, "success weakCompareAndSet float");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSet float");
                     float x = (float) vh.get(array, i);
-                    assertEquals(x, VALUE_1, "weakCompareAndSet float");
+                    assertEquals(x, VALUE_1, "failing weakCompareAndSet float value");
                 }
 
                 // Compare set and get
@@ -1226,40 +1258,72 @@ public class VarHandleTestByteArrayAsFloat extends VarHandleBaseByteArrayTest {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_2);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetPlain float");
+                    assertEquals(success, true, "success weakCompareAndSetPlain float");
                     float x = (float) vh.get(array, i);
-                    assertEquals(x, VALUE_2, "weakCompareAndSetPlain float value");
+                    assertEquals(x, VALUE_2, "success weakCompareAndSetPlain float value");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetPlain float");
+                    float x = (float) vh.get(array, i);
+                    assertEquals(x, VALUE_2, "failing weakCompareAndSetPlain float value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_1);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetAcquire float");
+                    assertEquals(success, true, "success weakCompareAndSetAcquire float");
+                    float x = (float) vh.get(array, i);
+                    assertEquals(x, VALUE_1, "success weakCompareAndSetAcquire float");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetAcquire float");
                     float x = (float) vh.get(array, i);
-                    assertEquals(x, VALUE_1, "weakCompareAndSetAcquire float");
+                    assertEquals(x, VALUE_1, "failing weakCompareAndSetAcquire float value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_2);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetRelease float");
+                    assertEquals(success, true, "success weakCompareAndSetRelease float");
                     float x = (float) vh.get(array, i);
-                    assertEquals(x, VALUE_2, "weakCompareAndSetRelease float");
+                    assertEquals(x, VALUE_2, "success weakCompareAndSetRelease float");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetRelease float");
+                    float x = (float) vh.get(array, i);
+                    assertEquals(x, VALUE_2, "failing weakCompareAndSetRelease float value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_1);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSet float");
+                    assertEquals(success, true, "success weakCompareAndSet float");
+                    float x = (float) vh.get(array, i);
+                    assertEquals(x, VALUE_1, "success weakCompareAndSet float");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSet float");
                     float x = (float) vh.get(array, i);
-                    assertEquals(x, VALUE_1, "weakCompareAndSet float");
+                    assertEquals(x, VALUE_1, "failing weakCompareAndSet float value");
                 }
 
                 // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsInt.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsInt.java
index 5e19b1a1bec..9b0cfc8edb9 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsInt.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsInt.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,9 +27,9 @@ package test.java.lang.invoke.VarHandles;
 /*
  * @test
  * @bug 8154556
- * @run testng/othervm -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestByteArrayAsInt
- * @run testng/othervm -Diters=20000                         VarHandleTestByteArrayAsInt
- * @run testng/othervm -Diters=20000 -XX:-TieredCompilation  VarHandleTestByteArrayAsInt
+ * @run testng/othervm/timeout=360 -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestByteArrayAsInt
+ * @run testng/othervm/timeout=360 -Diters=20000                         VarHandleTestByteArrayAsInt
+ * @run testng/othervm/timeout=360 -Diters=20000 -XX:-TieredCompilation  VarHandleTestByteArrayAsInt
  */
 
 import org.testng.annotations.DataProvider;
@@ -1237,40 +1237,72 @@ public class VarHandleTestByteArrayAsInt extends VarHandleBaseByteArrayTest {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_2);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetPlain int");
+                    assertEquals(success, true, "success weakCompareAndSetPlain int");
                     int x = (int) vh.get(array, i);
-                    assertEquals(x, VALUE_2, "weakCompareAndSetPlain int value");
+                    assertEquals(x, VALUE_2, "success weakCompareAndSetPlain int value");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetPlain int");
+                    int x = (int) vh.get(array, i);
+                    assertEquals(x, VALUE_2, "failing weakCompareAndSetPlain int value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_1);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetAcquire int");
+                    assertEquals(success, true, "success weakCompareAndSetAcquire int");
+                    int x = (int) vh.get(array, i);
+                    assertEquals(x, VALUE_1, "success weakCompareAndSetAcquire int");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetAcquire int");
                     int x = (int) vh.get(array, i);
-                    assertEquals(x, VALUE_1, "weakCompareAndSetAcquire int");
+                    assertEquals(x, VALUE_1, "failing weakCompareAndSetAcquire int value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_2);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetRelease int");
+                    assertEquals(success, true, "success weakCompareAndSetRelease int");
                     int x = (int) vh.get(array, i);
-                    assertEquals(x, VALUE_2, "weakCompareAndSetRelease int");
+                    assertEquals(x, VALUE_2, "success weakCompareAndSetRelease int");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetRelease int");
+                    int x = (int) vh.get(array, i);
+                    assertEquals(x, VALUE_2, "failing weakCompareAndSetRelease int value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_1);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSet int");
+                    assertEquals(success, true, "success weakCompareAndSet int");
+                    int x = (int) vh.get(array, i);
+                    assertEquals(x, VALUE_1, "success weakCompareAndSet int");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSet int");
                     int x = (int) vh.get(array, i);
-                    assertEquals(x, VALUE_1, "weakCompareAndSet int");
+                    assertEquals(x, VALUE_1, "failing weakCompareAndSet int value");
                 }
 
                 // Compare set and get
@@ -1520,40 +1552,72 @@ public class VarHandleTestByteArrayAsInt extends VarHandleBaseByteArrayTest {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_2);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetPlain int");
+                    assertEquals(success, true, "success weakCompareAndSetPlain int");
                     int x = (int) vh.get(array, i);
-                    assertEquals(x, VALUE_2, "weakCompareAndSetPlain int value");
+                    assertEquals(x, VALUE_2, "success weakCompareAndSetPlain int value");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetPlain int");
+                    int x = (int) vh.get(array, i);
+                    assertEquals(x, VALUE_2, "failing weakCompareAndSetPlain int value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_1);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetAcquire int");
+                    assertEquals(success, true, "success weakCompareAndSetAcquire int");
+                    int x = (int) vh.get(array, i);
+                    assertEquals(x, VALUE_1, "success weakCompareAndSetAcquire int");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetAcquire int");
                     int x = (int) vh.get(array, i);
-                    assertEquals(x, VALUE_1, "weakCompareAndSetAcquire int");
+                    assertEquals(x, VALUE_1, "failing weakCompareAndSetAcquire int value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_2);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetRelease int");
+                    assertEquals(success, true, "success weakCompareAndSetRelease int");
                     int x = (int) vh.get(array, i);
-                    assertEquals(x, VALUE_2, "weakCompareAndSetRelease int");
+                    assertEquals(x, VALUE_2, "success weakCompareAndSetRelease int");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetRelease int");
+                    int x = (int) vh.get(array, i);
+                    assertEquals(x, VALUE_2, "failing weakCompareAndSetRelease int value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_1);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSet int");
+                    assertEquals(success, true, "success weakCompareAndSet int");
+                    int x = (int) vh.get(array, i);
+                    assertEquals(x, VALUE_1, "success weakCompareAndSet int");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSet int");
                     int x = (int) vh.get(array, i);
-                    assertEquals(x, VALUE_1, "weakCompareAndSet int");
+                    assertEquals(x, VALUE_1, "failing weakCompareAndSet int value");
                 }
 
                 // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsLong.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsLong.java
index 926c3d8a214..c56b48f36af 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsLong.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsLong.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,9 +27,9 @@ package test.java.lang.invoke.VarHandles;
 /*
  * @test
  * @bug 8154556
- * @run testng/othervm -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestByteArrayAsLong
- * @run testng/othervm -Diters=20000                         VarHandleTestByteArrayAsLong
- * @run testng/othervm -Diters=20000 -XX:-TieredCompilation  VarHandleTestByteArrayAsLong
+ * @run testng/othervm/timeout=360 -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestByteArrayAsLong
+ * @run testng/othervm/timeout=360 -Diters=20000                         VarHandleTestByteArrayAsLong
+ * @run testng/othervm/timeout=360 -Diters=20000 -XX:-TieredCompilation  VarHandleTestByteArrayAsLong
  */
 
 import org.testng.annotations.DataProvider;
@@ -1237,40 +1237,72 @@ public class VarHandleTestByteArrayAsLong extends VarHandleBaseByteArrayTest {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_2);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetPlain long");
+                    assertEquals(success, true, "success weakCompareAndSetPlain long");
                     long x = (long) vh.get(array, i);
-                    assertEquals(x, VALUE_2, "weakCompareAndSetPlain long value");
+                    assertEquals(x, VALUE_2, "success weakCompareAndSetPlain long value");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetPlain long");
+                    long x = (long) vh.get(array, i);
+                    assertEquals(x, VALUE_2, "failing weakCompareAndSetPlain long value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_1);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetAcquire long");
+                    assertEquals(success, true, "success weakCompareAndSetAcquire long");
+                    long x = (long) vh.get(array, i);
+                    assertEquals(x, VALUE_1, "success weakCompareAndSetAcquire long");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetAcquire long");
                     long x = (long) vh.get(array, i);
-                    assertEquals(x, VALUE_1, "weakCompareAndSetAcquire long");
+                    assertEquals(x, VALUE_1, "failing weakCompareAndSetAcquire long value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_2);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetRelease long");
+                    assertEquals(success, true, "success weakCompareAndSetRelease long");
                     long x = (long) vh.get(array, i);
-                    assertEquals(x, VALUE_2, "weakCompareAndSetRelease long");
+                    assertEquals(x, VALUE_2, "success weakCompareAndSetRelease long");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetRelease long");
+                    long x = (long) vh.get(array, i);
+                    assertEquals(x, VALUE_2, "failing weakCompareAndSetRelease long value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_1);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSet long");
+                    assertEquals(success, true, "success weakCompareAndSet long");
+                    long x = (long) vh.get(array, i);
+                    assertEquals(x, VALUE_1, "success weakCompareAndSet long");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSet long");
                     long x = (long) vh.get(array, i);
-                    assertEquals(x, VALUE_1, "weakCompareAndSet long");
+                    assertEquals(x, VALUE_1, "failing weakCompareAndSet long value");
                 }
 
                 // Compare set and get
@@ -1520,40 +1552,72 @@ public class VarHandleTestByteArrayAsLong extends VarHandleBaseByteArrayTest {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_2);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetPlain long");
+                    assertEquals(success, true, "success weakCompareAndSetPlain long");
                     long x = (long) vh.get(array, i);
-                    assertEquals(x, VALUE_2, "weakCompareAndSetPlain long value");
+                    assertEquals(x, VALUE_2, "success weakCompareAndSetPlain long value");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetPlain long");
+                    long x = (long) vh.get(array, i);
+                    assertEquals(x, VALUE_2, "failing weakCompareAndSetPlain long value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_1);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetAcquire long");
+                    assertEquals(success, true, "success weakCompareAndSetAcquire long");
+                    long x = (long) vh.get(array, i);
+                    assertEquals(x, VALUE_1, "success weakCompareAndSetAcquire long");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetAcquire long");
                     long x = (long) vh.get(array, i);
-                    assertEquals(x, VALUE_1, "weakCompareAndSetAcquire long");
+                    assertEquals(x, VALUE_1, "failing weakCompareAndSetAcquire long value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_2);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetRelease long");
+                    assertEquals(success, true, "success weakCompareAndSetRelease long");
                     long x = (long) vh.get(array, i);
-                    assertEquals(x, VALUE_2, "weakCompareAndSetRelease long");
+                    assertEquals(x, VALUE_2, "success weakCompareAndSetRelease long");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetRelease long");
+                    long x = (long) vh.get(array, i);
+                    assertEquals(x, VALUE_2, "failing weakCompareAndSetRelease long value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_1);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSet long");
+                    assertEquals(success, true, "success weakCompareAndSet long");
+                    long x = (long) vh.get(array, i);
+                    assertEquals(x, VALUE_1, "success weakCompareAndSet long");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSet long");
                     long x = (long) vh.get(array, i);
-                    assertEquals(x, VALUE_1, "weakCompareAndSet long");
+                    assertEquals(x, VALUE_1, "failing weakCompareAndSet long value");
                 }
 
                 // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsShort.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsShort.java
index d1c740ead85..358200ed54c 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsShort.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestByteArrayAsShort.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,9 +27,9 @@ package test.java.lang.invoke.VarHandles;
 /*
  * @test
  * @bug 8154556
- * @run testng/othervm -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestByteArrayAsShort
- * @run testng/othervm -Diters=20000                         VarHandleTestByteArrayAsShort
- * @run testng/othervm -Diters=20000 -XX:-TieredCompilation  VarHandleTestByteArrayAsShort
+ * @run testng/othervm/timeout=360 -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestByteArrayAsShort
+ * @run testng/othervm/timeout=360 -Diters=20000                         VarHandleTestByteArrayAsShort
+ * @run testng/othervm/timeout=360 -Diters=20000 -XX:-TieredCompilation  VarHandleTestByteArrayAsShort
  */
 
 import org.testng.annotations.DataProvider;
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessBoolean.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessBoolean.java
index 2db5c6487f4..e41239abd98 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessBoolean.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessBoolean.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,6 +33,7 @@ import org.testng.annotations.BeforeClass;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
+import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
@@ -211,43 +212,79 @@ public class VarHandleTestMethodHandleAccessBoolean extends VarHandleBaseTest {
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, true, false);
+                success = (boolean) mh.invokeExact(recv, true, false);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain boolean");
+            assertEquals(success, true, "success weakCompareAndSetPlain boolean");
             boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, false, "weakCompareAndSetPlain boolean value");
+            assertEquals(x, false, "success weakCompareAndSetPlain boolean value");
         }
 
         {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, true, false);
+            assertEquals(success, false, "failing weakCompareAndSetPlain boolean");
+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, false, "failing weakCompareAndSetPlain boolean value");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, false, true);
+                success = (boolean) mh.invokeExact(recv, false, true);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire boolean");
+            assertEquals(success, true, "success weakCompareAndSetAcquire boolean");
+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, true, "success weakCompareAndSetAcquire boolean");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, false, false);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire boolean");
             boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, true, "weakCompareAndSetAcquire boolean");
+            assertEquals(x, true, "failing weakCompareAndSetAcquire boolean value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, true, false);
+                success = (boolean) mh.invokeExact(recv, true, false);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease boolean");
+            assertEquals(success, true, "success weakCompareAndSetRelease boolean");
+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, false, "success weakCompareAndSetRelease boolean");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, true, false);
+            assertEquals(success, false, "failing weakCompareAndSetRelease boolean");
             boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, false, "weakCompareAndSetRelease boolean");
+            assertEquals(x, false, "failing weakCompareAndSetRelease boolean value");
         }
 
         {
             boolean success = false;
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, false, true);
+                success = (boolean) mh.invokeExact(recv, false, true);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet boolean");
+            assertEquals(success, true, "success weakCompareAndSet boolean");
             boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, true, "weakCompareAndSet boolean");
+            assertEquals(x, true, "success weakCompareAndSet boolean");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, false, false);
+            assertEquals(success, false, "failing weakCompareAndSet boolean");
+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, true, "failing weakCompareAndSet boolean value");
         }
 
         // Compare set and get
@@ -445,43 +482,80 @@ public class VarHandleTestMethodHandleAccessBoolean extends VarHandleBaseTest {
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(true, false);
+                success = (boolean) mh.invokeExact(true, false);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain boolean");
+            assertEquals(success, true, "success weakCompareAndSetPlain boolean");
+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, false, "success weakCompareAndSetPlain boolean value");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(true, false);
+            assertEquals(success, false, "failing weakCompareAndSetPlain boolean");
             boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, false, "weakCompareAndSetPlain boolean value");
+            assertEquals(x, false, "failing weakCompareAndSetPlain boolean value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(false, true);
+                success = (boolean) mh.invokeExact(false, true);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire boolean");
+            assertEquals(success, true, "success weakCompareAndSetAcquire boolean");
+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, true, "success weakCompareAndSetAcquire boolean");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
+            boolean success = (boolean) mh.invokeExact(false, false);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire boolean");
             boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, true, "weakCompareAndSetAcquire boolean");
+            assertEquals(x, true, "failing weakCompareAndSetAcquire boolean value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(true, false);
+                success = (boolean) mh.invokeExact(true, false);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease boolean");
+            assertEquals(success, true, "success weakCompareAndSetRelease boolean");
             boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, false, "weakCompareAndSetRelease boolean");
+            assertEquals(x, false, "success weakCompareAndSetRelease boolean");
         }
 
         {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(true, false);
+            assertEquals(success, false, "failing weakCompareAndSetRelease boolean");
+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, false, "failing weakCompareAndSetRelease boolean value");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(false, true);
+                success = (boolean) mh.invokeExact(false, true);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet boolean");
+            assertEquals(success, true, "success weakCompareAndSet boolean");
+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, true, "success weakCompareAndSet boolean");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(false, false);
+            assertEquals(success, false, "failing weakCompareAndSet boolean");
             boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, true, "weakCompareAndSet boolean");
+            assertEquals(x, true, "failing weakCompareAndSetRe boolean value");
         }
 
         // Compare set and get
@@ -704,43 +778,79 @@ public class VarHandleTestMethodHandleAccessBoolean extends VarHandleBaseTest {
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, true, false);
+                    success = (boolean) mh.invokeExact(array, i, true, false);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetPlain boolean");
+                assertEquals(success, true, "success weakCompareAndSetPlain boolean");
+                boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, false, "success weakCompareAndSetPlain boolean value");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, true, false);
+                assertEquals(success, false, "failing weakCompareAndSetPlain boolean");
                 boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, false, "weakCompareAndSetPlain boolean value");
+                assertEquals(x, false, "failing weakCompareAndSetPlain boolean value");
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, false, true);
+                    success = (boolean) mh.invokeExact(array, i, false, true);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetAcquire boolean");
+                assertEquals(success, true, "success weakCompareAndSetAcquire boolean");
                 boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, true, "weakCompareAndSetAcquire boolean");
+                assertEquals(x, true, "success weakCompareAndSetAcquire boolean");
             }
 
             {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, false, false);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire boolean");
+                boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, true, "failing weakCompareAndSetAcquire boolean value");
+            }
+
+            {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(array, i, true, false);
+                    success = (boolean) mh.invokeExact(array, i, true, false);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetRelease boolean");
+                assertEquals(success, true, "success weakCompareAndSetRelease boolean");
+                boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, false, "success weakCompareAndSetRelease boolean");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, true, false);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire boolean");
                 boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, false, "weakCompareAndSetRelease boolean");
+                assertEquals(x, false, "failing weakCompareAndSetAcquire boolean value");
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, false, true);
+                    success = (boolean) mh.invokeExact(array, i, false, true);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSet boolean");
+                assertEquals(success, true, "success weakCompareAndSet boolean");
+                boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, true, "success weakCompareAndSet boolean");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, false, false);
+                assertEquals(success, false, "failing weakCompareAndSet boolean");
                 boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, true, "weakCompareAndSet boolean");
+                assertEquals(x, true, "failing weakCompareAndSet boolean value");
             }
 
             // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessByte.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessByte.java
index 1eac796201f..a4577b29045 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessByte.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessByte.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,6 +33,7 @@ import org.testng.annotations.BeforeClass;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
+import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
@@ -211,43 +212,79 @@ public class VarHandleTestMethodHandleAccessByte extends VarHandleBaseTest {
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, (byte)0x01, (byte)0x23);
+                success = (boolean) mh.invokeExact(recv, (byte)0x01, (byte)0x23);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain byte");
+            assertEquals(success, true, "success weakCompareAndSetPlain byte");
             byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, (byte)0x23, "weakCompareAndSetPlain byte value");
+            assertEquals(x, (byte)0x23, "success weakCompareAndSetPlain byte value");
         }
 
         {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, (byte)0x01, (byte)0x45);
+            assertEquals(success, false, "failing weakCompareAndSetPlain byte");
+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, (byte)0x23, "failing weakCompareAndSetPlain byte value");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, (byte)0x23, (byte)0x01);
+                success = (boolean) mh.invokeExact(recv, (byte)0x23, (byte)0x01);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire byte");
+            assertEquals(success, true, "success weakCompareAndSetAcquire byte");
+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, (byte)0x01, "success weakCompareAndSetAcquire byte");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, (byte)0x23, (byte)0x45);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire byte");
             byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, (byte)0x01, "weakCompareAndSetAcquire byte");
+            assertEquals(x, (byte)0x01, "failing weakCompareAndSetAcquire byte value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, (byte)0x01, (byte)0x23);
+                success = (boolean) mh.invokeExact(recv, (byte)0x01, (byte)0x23);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease byte");
+            assertEquals(success, true, "success weakCompareAndSetRelease byte");
+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, (byte)0x23, "success weakCompareAndSetRelease byte");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, (byte)0x01, (byte)0x45);
+            assertEquals(success, false, "failing weakCompareAndSetRelease byte");
             byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, (byte)0x23, "weakCompareAndSetRelease byte");
+            assertEquals(x, (byte)0x23, "failing weakCompareAndSetRelease byte value");
         }
 
         {
             boolean success = false;
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, (byte)0x23, (byte)0x01);
+                success = (boolean) mh.invokeExact(recv, (byte)0x23, (byte)0x01);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet byte");
+            assertEquals(success, true, "success weakCompareAndSet byte");
             byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, (byte)0x01, "weakCompareAndSet byte");
+            assertEquals(x, (byte)0x01, "success weakCompareAndSet byte");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, (byte)0x23, (byte)0x45);
+            assertEquals(success, false, "failing weakCompareAndSet byte");
+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, (byte)0x01, "failing weakCompareAndSet byte value");
         }
 
         // Compare set and get
@@ -467,43 +504,80 @@ public class VarHandleTestMethodHandleAccessByte extends VarHandleBaseTest {
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact((byte)0x01, (byte)0x23);
+                success = (boolean) mh.invokeExact((byte)0x01, (byte)0x23);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain byte");
+            assertEquals(success, true, "success weakCompareAndSetPlain byte");
+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, (byte)0x23, "success weakCompareAndSetPlain byte value");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact((byte)0x01, (byte)0x45);
+            assertEquals(success, false, "failing weakCompareAndSetPlain byte");
             byte x = (byte) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, (byte)0x23, "weakCompareAndSetPlain byte value");
+            assertEquals(x, (byte)0x23, "failing weakCompareAndSetPlain byte value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact((byte)0x23, (byte)0x01);
+                success = (boolean) mh.invokeExact((byte)0x23, (byte)0x01);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire byte");
+            assertEquals(success, true, "success weakCompareAndSetAcquire byte");
+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, (byte)0x01, "success weakCompareAndSetAcquire byte");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
+            boolean success = (boolean) mh.invokeExact((byte)0x23, (byte)0x45);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire byte");
             byte x = (byte) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, (byte)0x01, "weakCompareAndSetAcquire byte");
+            assertEquals(x, (byte)0x01, "failing weakCompareAndSetAcquire byte value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact((byte)0x01, (byte)0x23);
+                success = (boolean) mh.invokeExact((byte)0x01, (byte)0x23);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease byte");
+            assertEquals(success, true, "success weakCompareAndSetRelease byte");
             byte x = (byte) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, (byte)0x23, "weakCompareAndSetRelease byte");
+            assertEquals(x, (byte)0x23, "success weakCompareAndSetRelease byte");
         }
 
         {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact((byte)0x01, (byte)0x45);
+            assertEquals(success, false, "failing weakCompareAndSetRelease byte");
+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, (byte)0x23, "failing weakCompareAndSetRelease byte value");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact((byte)0x23, (byte)0x01);
+                success = (boolean) mh.invokeExact((byte)0x23, (byte)0x01);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet byte");
+            assertEquals(success, true, "success weakCompareAndSet byte");
+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, (byte)0x01, "success weakCompareAndSet byte");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact((byte)0x23, (byte)0x45);
+            assertEquals(success, false, "failing weakCompareAndSet byte");
             byte x = (byte) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, (byte)0x01, "weakCompareAndSet byte");
+            assertEquals(x, (byte)0x01, "failing weakCompareAndSetRe byte value");
         }
 
         // Compare set and get
@@ -748,43 +822,79 @@ public class VarHandleTestMethodHandleAccessByte extends VarHandleBaseTest {
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, (byte)0x01, (byte)0x23);
+                    success = (boolean) mh.invokeExact(array, i, (byte)0x01, (byte)0x23);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetPlain byte");
+                assertEquals(success, true, "success weakCompareAndSetPlain byte");
+                byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, (byte)0x23, "success weakCompareAndSetPlain byte value");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, (byte)0x01, (byte)0x45);
+                assertEquals(success, false, "failing weakCompareAndSetPlain byte");
                 byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, (byte)0x23, "weakCompareAndSetPlain byte value");
+                assertEquals(x, (byte)0x23, "failing weakCompareAndSetPlain byte value");
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, (byte)0x23, (byte)0x01);
+                    success = (boolean) mh.invokeExact(array, i, (byte)0x23, (byte)0x01);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetAcquire byte");
+                assertEquals(success, true, "success weakCompareAndSetAcquire byte");
                 byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, (byte)0x01, "weakCompareAndSetAcquire byte");
+                assertEquals(x, (byte)0x01, "success weakCompareAndSetAcquire byte");
             }
 
             {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, (byte)0x23, (byte)0x45);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire byte");
+                byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, (byte)0x01, "failing weakCompareAndSetAcquire byte value");
+            }
+
+            {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(array, i, (byte)0x01, (byte)0x23);
+                    success = (boolean) mh.invokeExact(array, i, (byte)0x01, (byte)0x23);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetRelease byte");
+                assertEquals(success, true, "success weakCompareAndSetRelease byte");
+                byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, (byte)0x23, "success weakCompareAndSetRelease byte");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, (byte)0x01, (byte)0x45);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire byte");
                 byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, (byte)0x23, "weakCompareAndSetRelease byte");
+                assertEquals(x, (byte)0x23, "failing weakCompareAndSetAcquire byte value");
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, (byte)0x23, (byte)0x01);
+                    success = (boolean) mh.invokeExact(array, i, (byte)0x23, (byte)0x01);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSet byte");
+                assertEquals(success, true, "success weakCompareAndSet byte");
+                byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, (byte)0x01, "success weakCompareAndSet byte");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, (byte)0x23, (byte)0x45);
+                assertEquals(success, false, "failing weakCompareAndSet byte");
                 byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, (byte)0x01, "weakCompareAndSet byte");
+                assertEquals(x, (byte)0x01, "failing weakCompareAndSet byte value");
             }
 
             // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessChar.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessChar.java
index 1c5796b85af..4d3cce82c2e 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessChar.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessChar.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,6 +33,7 @@ import org.testng.annotations.BeforeClass;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
+import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
@@ -211,43 +212,79 @@ public class VarHandleTestMethodHandleAccessChar extends VarHandleBaseTest {
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, '\u0123', '\u4567');
+                success = (boolean) mh.invokeExact(recv, '\u0123', '\u4567');
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain char");
+            assertEquals(success, true, "success weakCompareAndSetPlain char");
             char x = (char) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, '\u4567', "weakCompareAndSetPlain char value");
+            assertEquals(x, '\u4567', "success weakCompareAndSetPlain char value");
         }
 
         {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, '\u0123', '\u89AB');
+            assertEquals(success, false, "failing weakCompareAndSetPlain char");
+            char x = (char) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, '\u4567', "failing weakCompareAndSetPlain char value");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, '\u4567', '\u0123');
+                success = (boolean) mh.invokeExact(recv, '\u4567', '\u0123');
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire char");
+            assertEquals(success, true, "success weakCompareAndSetAcquire char");
+            char x = (char) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, '\u0123', "success weakCompareAndSetAcquire char");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, '\u4567', '\u89AB');
+            assertEquals(success, false, "failing weakCompareAndSetAcquire char");
             char x = (char) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, '\u0123', "weakCompareAndSetAcquire char");
+            assertEquals(x, '\u0123', "failing weakCompareAndSetAcquire char value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, '\u0123', '\u4567');
+                success = (boolean) mh.invokeExact(recv, '\u0123', '\u4567');
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease char");
+            assertEquals(success, true, "success weakCompareAndSetRelease char");
+            char x = (char) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, '\u4567', "success weakCompareAndSetRelease char");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, '\u0123', '\u89AB');
+            assertEquals(success, false, "failing weakCompareAndSetRelease char");
             char x = (char) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, '\u4567', "weakCompareAndSetRelease char");
+            assertEquals(x, '\u4567', "failing weakCompareAndSetRelease char value");
         }
 
         {
             boolean success = false;
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, '\u4567', '\u0123');
+                success = (boolean) mh.invokeExact(recv, '\u4567', '\u0123');
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet char");
+            assertEquals(success, true, "success weakCompareAndSet char");
             char x = (char) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, '\u0123', "weakCompareAndSet char");
+            assertEquals(x, '\u0123', "success weakCompareAndSet char");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, '\u4567', '\u89AB');
+            assertEquals(success, false, "failing weakCompareAndSet char");
+            char x = (char) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, '\u0123', "failing weakCompareAndSet char value");
         }
 
         // Compare set and get
@@ -467,43 +504,80 @@ public class VarHandleTestMethodHandleAccessChar extends VarHandleBaseTest {
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact('\u0123', '\u4567');
+                success = (boolean) mh.invokeExact('\u0123', '\u4567');
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain char");
+            assertEquals(success, true, "success weakCompareAndSetPlain char");
+            char x = (char) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, '\u4567', "success weakCompareAndSetPlain char value");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact('\u0123', '\u89AB');
+            assertEquals(success, false, "failing weakCompareAndSetPlain char");
             char x = (char) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, '\u4567', "weakCompareAndSetPlain char value");
+            assertEquals(x, '\u4567', "failing weakCompareAndSetPlain char value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact('\u4567', '\u0123');
+                success = (boolean) mh.invokeExact('\u4567', '\u0123');
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire char");
+            assertEquals(success, true, "success weakCompareAndSetAcquire char");
+            char x = (char) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, '\u0123', "success weakCompareAndSetAcquire char");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
+            boolean success = (boolean) mh.invokeExact('\u4567', '\u89AB');
+            assertEquals(success, false, "failing weakCompareAndSetAcquire char");
             char x = (char) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, '\u0123', "weakCompareAndSetAcquire char");
+            assertEquals(x, '\u0123', "failing weakCompareAndSetAcquire char value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact('\u0123', '\u4567');
+                success = (boolean) mh.invokeExact('\u0123', '\u4567');
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease char");
+            assertEquals(success, true, "success weakCompareAndSetRelease char");
             char x = (char) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, '\u4567', "weakCompareAndSetRelease char");
+            assertEquals(x, '\u4567', "success weakCompareAndSetRelease char");
         }
 
         {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact('\u0123', '\u89AB');
+            assertEquals(success, false, "failing weakCompareAndSetRelease char");
+            char x = (char) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, '\u4567', "failing weakCompareAndSetRelease char value");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact('\u4567', '\u0123');
+                success = (boolean) mh.invokeExact('\u4567', '\u0123');
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet char");
+            assertEquals(success, true, "success weakCompareAndSet char");
+            char x = (char) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, '\u0123', "success weakCompareAndSet char");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact('\u4567', '\u89AB');
+            assertEquals(success, false, "failing weakCompareAndSet char");
             char x = (char) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, '\u0123', "weakCompareAndSet char");
+            assertEquals(x, '\u0123', "failing weakCompareAndSetRe char value");
         }
 
         // Compare set and get
@@ -748,43 +822,79 @@ public class VarHandleTestMethodHandleAccessChar extends VarHandleBaseTest {
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, '\u0123', '\u4567');
+                    success = (boolean) mh.invokeExact(array, i, '\u0123', '\u4567');
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetPlain char");
+                assertEquals(success, true, "success weakCompareAndSetPlain char");
+                char x = (char) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, '\u4567', "success weakCompareAndSetPlain char value");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, '\u0123', '\u89AB');
+                assertEquals(success, false, "failing weakCompareAndSetPlain char");
                 char x = (char) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, '\u4567', "weakCompareAndSetPlain char value");
+                assertEquals(x, '\u4567', "failing weakCompareAndSetPlain char value");
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, '\u4567', '\u0123');
+                    success = (boolean) mh.invokeExact(array, i, '\u4567', '\u0123');
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetAcquire char");
+                assertEquals(success, true, "success weakCompareAndSetAcquire char");
                 char x = (char) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, '\u0123', "weakCompareAndSetAcquire char");
+                assertEquals(x, '\u0123', "success weakCompareAndSetAcquire char");
             }
 
             {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, '\u4567', '\u89AB');
+                assertEquals(success, false, "failing weakCompareAndSetAcquire char");
+                char x = (char) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, '\u0123', "failing weakCompareAndSetAcquire char value");
+            }
+
+            {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(array, i, '\u0123', '\u4567');
+                    success = (boolean) mh.invokeExact(array, i, '\u0123', '\u4567');
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetRelease char");
+                assertEquals(success, true, "success weakCompareAndSetRelease char");
+                char x = (char) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, '\u4567', "success weakCompareAndSetRelease char");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, '\u0123', '\u89AB');
+                assertEquals(success, false, "failing weakCompareAndSetAcquire char");
                 char x = (char) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, '\u4567', "weakCompareAndSetRelease char");
+                assertEquals(x, '\u4567', "failing weakCompareAndSetAcquire char value");
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, '\u4567', '\u0123');
+                    success = (boolean) mh.invokeExact(array, i, '\u4567', '\u0123');
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSet char");
+                assertEquals(success, true, "success weakCompareAndSet char");
+                char x = (char) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, '\u0123', "success weakCompareAndSet char");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, '\u4567', '\u89AB');
+                assertEquals(success, false, "failing weakCompareAndSet char");
                 char x = (char) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, '\u0123', "weakCompareAndSet char");
+                assertEquals(x, '\u0123', "failing weakCompareAndSet char value");
             }
 
             // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessDouble.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessDouble.java
index e7864e3b70e..5cbefc29cc0 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessDouble.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessDouble.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,6 +33,7 @@ import org.testng.annotations.BeforeClass;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
+import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
@@ -211,43 +212,79 @@ public class VarHandleTestMethodHandleAccessDouble extends VarHandleBaseTest {
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, 1.0d, 2.0d);
+                success = (boolean) mh.invokeExact(recv, 1.0d, 2.0d);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain double");
+            assertEquals(success, true, "success weakCompareAndSetPlain double");
             double x = (double) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, 2.0d, "weakCompareAndSetPlain double value");
+            assertEquals(x, 2.0d, "success weakCompareAndSetPlain double value");
         }
 
         {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, 1.0d, 3.0d);
+            assertEquals(success, false, "failing weakCompareAndSetPlain double");
+            double x = (double) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, 2.0d, "failing weakCompareAndSetPlain double value");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, 2.0d, 1.0d);
+                success = (boolean) mh.invokeExact(recv, 2.0d, 1.0d);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire double");
+            assertEquals(success, true, "success weakCompareAndSetAcquire double");
+            double x = (double) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, 1.0d, "success weakCompareAndSetAcquire double");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, 2.0d, 3.0d);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire double");
             double x = (double) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, 1.0d, "weakCompareAndSetAcquire double");
+            assertEquals(x, 1.0d, "failing weakCompareAndSetAcquire double value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, 1.0d, 2.0d);
+                success = (boolean) mh.invokeExact(recv, 1.0d, 2.0d);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease double");
+            assertEquals(success, true, "success weakCompareAndSetRelease double");
+            double x = (double) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, 2.0d, "success weakCompareAndSetRelease double");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, 1.0d, 3.0d);
+            assertEquals(success, false, "failing weakCompareAndSetRelease double");
             double x = (double) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, 2.0d, "weakCompareAndSetRelease double");
+            assertEquals(x, 2.0d, "failing weakCompareAndSetRelease double value");
         }
 
         {
             boolean success = false;
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, 2.0d, 1.0d);
+                success = (boolean) mh.invokeExact(recv, 2.0d, 1.0d);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet double");
+            assertEquals(success, true, "success weakCompareAndSet double");
             double x = (double) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, 1.0d, "weakCompareAndSet double");
+            assertEquals(x, 1.0d, "success weakCompareAndSet double");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, 2.0d, 3.0d);
+            assertEquals(success, false, "failing weakCompareAndSet double");
+            double x = (double) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, 1.0d, "failing weakCompareAndSet double value");
         }
 
         // Compare set and get
@@ -389,43 +426,80 @@ public class VarHandleTestMethodHandleAccessDouble extends VarHandleBaseTest {
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(1.0d, 2.0d);
+                success = (boolean) mh.invokeExact(1.0d, 2.0d);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain double");
+            assertEquals(success, true, "success weakCompareAndSetPlain double");
+            double x = (double) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, 2.0d, "success weakCompareAndSetPlain double value");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(1.0d, 3.0d);
+            assertEquals(success, false, "failing weakCompareAndSetPlain double");
             double x = (double) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, 2.0d, "weakCompareAndSetPlain double value");
+            assertEquals(x, 2.0d, "failing weakCompareAndSetPlain double value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(2.0d, 1.0d);
+                success = (boolean) mh.invokeExact(2.0d, 1.0d);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire double");
+            assertEquals(success, true, "success weakCompareAndSetAcquire double");
+            double x = (double) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, 1.0d, "success weakCompareAndSetAcquire double");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
+            boolean success = (boolean) mh.invokeExact(2.0d, 3.0d);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire double");
             double x = (double) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, 1.0d, "weakCompareAndSetAcquire double");
+            assertEquals(x, 1.0d, "failing weakCompareAndSetAcquire double value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(1.0d, 2.0d);
+                success = (boolean) mh.invokeExact(1.0d, 2.0d);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease double");
+            assertEquals(success, true, "success weakCompareAndSetRelease double");
             double x = (double) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, 2.0d, "weakCompareAndSetRelease double");
+            assertEquals(x, 2.0d, "success weakCompareAndSetRelease double");
         }
 
         {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(1.0d, 3.0d);
+            assertEquals(success, false, "failing weakCompareAndSetRelease double");
+            double x = (double) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, 2.0d, "failing weakCompareAndSetRelease double value");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(2.0d, 1.0d);
+                success = (boolean) mh.invokeExact(2.0d, 1.0d);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet double");
+            assertEquals(success, true, "success weakCompareAndSet double");
+            double x = (double) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, 1.0d, "success weakCompareAndSet double");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(2.0d, 3.0d);
+            assertEquals(success, false, "failing weakCompareAndSet double");
             double x = (double) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, 1.0d, "weakCompareAndSet double");
+            assertEquals(x, 1.0d, "failing weakCompareAndSetRe double value");
         }
 
         // Compare set and get
@@ -592,43 +666,79 @@ public class VarHandleTestMethodHandleAccessDouble extends VarHandleBaseTest {
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, 1.0d, 2.0d);
+                    success = (boolean) mh.invokeExact(array, i, 1.0d, 2.0d);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetPlain double");
+                assertEquals(success, true, "success weakCompareAndSetPlain double");
+                double x = (double) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, 2.0d, "success weakCompareAndSetPlain double value");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, 1.0d, 3.0d);
+                assertEquals(success, false, "failing weakCompareAndSetPlain double");
                 double x = (double) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, 2.0d, "weakCompareAndSetPlain double value");
+                assertEquals(x, 2.0d, "failing weakCompareAndSetPlain double value");
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 2.0d, 1.0d);
+                    success = (boolean) mh.invokeExact(array, i, 2.0d, 1.0d);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetAcquire double");
+                assertEquals(success, true, "success weakCompareAndSetAcquire double");
                 double x = (double) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, 1.0d, "weakCompareAndSetAcquire double");
+                assertEquals(x, 1.0d, "success weakCompareAndSetAcquire double");
             }
 
             {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 2.0d, 3.0d);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire double");
+                double x = (double) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, 1.0d, "failing weakCompareAndSetAcquire double value");
+            }
+
+            {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(array, i, 1.0d, 2.0d);
+                    success = (boolean) mh.invokeExact(array, i, 1.0d, 2.0d);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetRelease double");
+                assertEquals(success, true, "success weakCompareAndSetRelease double");
+                double x = (double) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, 2.0d, "success weakCompareAndSetRelease double");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 1.0d, 3.0d);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire double");
                 double x = (double) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, 2.0d, "weakCompareAndSetRelease double");
+                assertEquals(x, 2.0d, "failing weakCompareAndSetAcquire double value");
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, 2.0d, 1.0d);
+                    success = (boolean) mh.invokeExact(array, i, 2.0d, 1.0d);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSet double");
+                assertEquals(success, true, "success weakCompareAndSet double");
+                double x = (double) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, 1.0d, "success weakCompareAndSet double");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, 2.0d, 3.0d);
+                assertEquals(success, false, "failing weakCompareAndSet double");
                 double x = (double) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, 1.0d, "weakCompareAndSet double");
+                assertEquals(x, 1.0d, "failing weakCompareAndSet double value");
             }
 
             // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessFloat.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessFloat.java
index 3f291de9464..df467ada541 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessFloat.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessFloat.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,6 +33,7 @@ import org.testng.annotations.BeforeClass;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
+import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
@@ -211,43 +212,79 @@ public class VarHandleTestMethodHandleAccessFloat extends VarHandleBaseTest {
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, 1.0f, 2.0f);
+                success = (boolean) mh.invokeExact(recv, 1.0f, 2.0f);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain float");
+            assertEquals(success, true, "success weakCompareAndSetPlain float");
             float x = (float) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, 2.0f, "weakCompareAndSetPlain float value");
+            assertEquals(x, 2.0f, "success weakCompareAndSetPlain float value");
         }
 
         {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, 1.0f, 3.0f);
+            assertEquals(success, false, "failing weakCompareAndSetPlain float");
+            float x = (float) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, 2.0f, "failing weakCompareAndSetPlain float value");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, 2.0f, 1.0f);
+                success = (boolean) mh.invokeExact(recv, 2.0f, 1.0f);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire float");
+            assertEquals(success, true, "success weakCompareAndSetAcquire float");
+            float x = (float) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, 1.0f, "success weakCompareAndSetAcquire float");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, 2.0f, 3.0f);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire float");
             float x = (float) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, 1.0f, "weakCompareAndSetAcquire float");
+            assertEquals(x, 1.0f, "failing weakCompareAndSetAcquire float value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, 1.0f, 2.0f);
+                success = (boolean) mh.invokeExact(recv, 1.0f, 2.0f);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease float");
+            assertEquals(success, true, "success weakCompareAndSetRelease float");
+            float x = (float) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, 2.0f, "success weakCompareAndSetRelease float");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, 1.0f, 3.0f);
+            assertEquals(success, false, "failing weakCompareAndSetRelease float");
             float x = (float) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, 2.0f, "weakCompareAndSetRelease float");
+            assertEquals(x, 2.0f, "failing weakCompareAndSetRelease float value");
         }
 
         {
             boolean success = false;
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, 2.0f, 1.0f);
+                success = (boolean) mh.invokeExact(recv, 2.0f, 1.0f);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet float");
+            assertEquals(success, true, "success weakCompareAndSet float");
             float x = (float) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, 1.0f, "weakCompareAndSet float");
+            assertEquals(x, 1.0f, "success weakCompareAndSet float");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, 2.0f, 3.0f);
+            assertEquals(success, false, "failing weakCompareAndSet float");
+            float x = (float) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, 1.0f, "failing weakCompareAndSet float value");
         }
 
         // Compare set and get
@@ -389,43 +426,80 @@ public class VarHandleTestMethodHandleAccessFloat extends VarHandleBaseTest {
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(1.0f, 2.0f);
+                success = (boolean) mh.invokeExact(1.0f, 2.0f);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain float");
+            assertEquals(success, true, "success weakCompareAndSetPlain float");
+            float x = (float) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, 2.0f, "success weakCompareAndSetPlain float value");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(1.0f, 3.0f);
+            assertEquals(success, false, "failing weakCompareAndSetPlain float");
             float x = (float) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, 2.0f, "weakCompareAndSetPlain float value");
+            assertEquals(x, 2.0f, "failing weakCompareAndSetPlain float value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(2.0f, 1.0f);
+                success = (boolean) mh.invokeExact(2.0f, 1.0f);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire float");
+            assertEquals(success, true, "success weakCompareAndSetAcquire float");
+            float x = (float) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, 1.0f, "success weakCompareAndSetAcquire float");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
+            boolean success = (boolean) mh.invokeExact(2.0f, 3.0f);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire float");
             float x = (float) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, 1.0f, "weakCompareAndSetAcquire float");
+            assertEquals(x, 1.0f, "failing weakCompareAndSetAcquire float value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(1.0f, 2.0f);
+                success = (boolean) mh.invokeExact(1.0f, 2.0f);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease float");
+            assertEquals(success, true, "success weakCompareAndSetRelease float");
             float x = (float) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, 2.0f, "weakCompareAndSetRelease float");
+            assertEquals(x, 2.0f, "success weakCompareAndSetRelease float");
         }
 
         {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(1.0f, 3.0f);
+            assertEquals(success, false, "failing weakCompareAndSetRelease float");
+            float x = (float) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, 2.0f, "failing weakCompareAndSetRelease float value");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(2.0f, 1.0f);
+                success = (boolean) mh.invokeExact(2.0f, 1.0f);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet float");
+            assertEquals(success, true, "success weakCompareAndSet float");
+            float x = (float) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, 1.0f, "success weakCompareAndSet float");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(2.0f, 3.0f);
+            assertEquals(success, false, "failing weakCompareAndSet float");
             float x = (float) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, 1.0f, "weakCompareAndSet float");
+            assertEquals(x, 1.0f, "failing weakCompareAndSetRe float value");
         }
 
         // Compare set and get
@@ -592,43 +666,79 @@ public class VarHandleTestMethodHandleAccessFloat extends VarHandleBaseTest {
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, 1.0f, 2.0f);
+                    success = (boolean) mh.invokeExact(array, i, 1.0f, 2.0f);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetPlain float");
+                assertEquals(success, true, "success weakCompareAndSetPlain float");
+                float x = (float) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, 2.0f, "success weakCompareAndSetPlain float value");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, 1.0f, 3.0f);
+                assertEquals(success, false, "failing weakCompareAndSetPlain float");
                 float x = (float) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, 2.0f, "weakCompareAndSetPlain float value");
+                assertEquals(x, 2.0f, "failing weakCompareAndSetPlain float value");
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 2.0f, 1.0f);
+                    success = (boolean) mh.invokeExact(array, i, 2.0f, 1.0f);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetAcquire float");
+                assertEquals(success, true, "success weakCompareAndSetAcquire float");
                 float x = (float) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, 1.0f, "weakCompareAndSetAcquire float");
+                assertEquals(x, 1.0f, "success weakCompareAndSetAcquire float");
             }
 
             {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 2.0f, 3.0f);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire float");
+                float x = (float) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, 1.0f, "failing weakCompareAndSetAcquire float value");
+            }
+
+            {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(array, i, 1.0f, 2.0f);
+                    success = (boolean) mh.invokeExact(array, i, 1.0f, 2.0f);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetRelease float");
+                assertEquals(success, true, "success weakCompareAndSetRelease float");
+                float x = (float) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, 2.0f, "success weakCompareAndSetRelease float");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 1.0f, 3.0f);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire float");
                 float x = (float) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, 2.0f, "weakCompareAndSetRelease float");
+                assertEquals(x, 2.0f, "failing weakCompareAndSetAcquire float value");
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, 2.0f, 1.0f);
+                    success = (boolean) mh.invokeExact(array, i, 2.0f, 1.0f);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSet float");
+                assertEquals(success, true, "success weakCompareAndSet float");
+                float x = (float) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, 1.0f, "success weakCompareAndSet float");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, 2.0f, 3.0f);
+                assertEquals(success, false, "failing weakCompareAndSet float");
                 float x = (float) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, 1.0f, "weakCompareAndSet float");
+                assertEquals(x, 1.0f, "failing weakCompareAndSet float value");
             }
 
             // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessInt.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessInt.java
index d938e3dab02..e3a19907cf0 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessInt.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessInt.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,6 +33,7 @@ import org.testng.annotations.BeforeClass;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
+import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
@@ -211,43 +212,79 @@ public class VarHandleTestMethodHandleAccessInt extends VarHandleBaseTest {
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, 0x01234567, 0x89ABCDEF);
+                success = (boolean) mh.invokeExact(recv, 0x01234567, 0x89ABCDEF);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain int");
+            assertEquals(success, true, "success weakCompareAndSetPlain int");
             int x = (int) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, 0x89ABCDEF, "weakCompareAndSetPlain int value");
+            assertEquals(x, 0x89ABCDEF, "success weakCompareAndSetPlain int value");
         }
 
         {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, 0x01234567, 0xCAFEBABE);
+            assertEquals(success, false, "failing weakCompareAndSetPlain int");
+            int x = (int) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, 0x89ABCDEF, "failing weakCompareAndSetPlain int value");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, 0x89ABCDEF, 0x01234567);
+                success = (boolean) mh.invokeExact(recv, 0x89ABCDEF, 0x01234567);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire int");
+            assertEquals(success, true, "success weakCompareAndSetAcquire int");
+            int x = (int) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, 0x01234567, "success weakCompareAndSetAcquire int");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, 0x89ABCDEF, 0xCAFEBABE);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire int");
             int x = (int) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, 0x01234567, "weakCompareAndSetAcquire int");
+            assertEquals(x, 0x01234567, "failing weakCompareAndSetAcquire int value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, 0x01234567, 0x89ABCDEF);
+                success = (boolean) mh.invokeExact(recv, 0x01234567, 0x89ABCDEF);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease int");
+            assertEquals(success, true, "success weakCompareAndSetRelease int");
+            int x = (int) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, 0x89ABCDEF, "success weakCompareAndSetRelease int");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, 0x01234567, 0xCAFEBABE);
+            assertEquals(success, false, "failing weakCompareAndSetRelease int");
             int x = (int) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, 0x89ABCDEF, "weakCompareAndSetRelease int");
+            assertEquals(x, 0x89ABCDEF, "failing weakCompareAndSetRelease int value");
         }
 
         {
             boolean success = false;
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, 0x89ABCDEF, 0x01234567);
+                success = (boolean) mh.invokeExact(recv, 0x89ABCDEF, 0x01234567);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet int");
+            assertEquals(success, true, "success weakCompareAndSet int");
             int x = (int) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, 0x01234567, "weakCompareAndSet int");
+            assertEquals(x, 0x01234567, "success weakCompareAndSet int");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, 0x89ABCDEF, 0xCAFEBABE);
+            assertEquals(success, false, "failing weakCompareAndSet int");
+            int x = (int) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, 0x01234567, "failing weakCompareAndSet int value");
         }
 
         // Compare set and get
@@ -467,43 +504,80 @@ public class VarHandleTestMethodHandleAccessInt extends VarHandleBaseTest {
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(0x01234567, 0x89ABCDEF);
+                success = (boolean) mh.invokeExact(0x01234567, 0x89ABCDEF);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain int");
+            assertEquals(success, true, "success weakCompareAndSetPlain int");
+            int x = (int) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, 0x89ABCDEF, "success weakCompareAndSetPlain int value");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(0x01234567, 0xCAFEBABE);
+            assertEquals(success, false, "failing weakCompareAndSetPlain int");
             int x = (int) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, 0x89ABCDEF, "weakCompareAndSetPlain int value");
+            assertEquals(x, 0x89ABCDEF, "failing weakCompareAndSetPlain int value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(0x89ABCDEF, 0x01234567);
+                success = (boolean) mh.invokeExact(0x89ABCDEF, 0x01234567);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire int");
+            assertEquals(success, true, "success weakCompareAndSetAcquire int");
+            int x = (int) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, 0x01234567, "success weakCompareAndSetAcquire int");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
+            boolean success = (boolean) mh.invokeExact(0x89ABCDEF, 0xCAFEBABE);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire int");
             int x = (int) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, 0x01234567, "weakCompareAndSetAcquire int");
+            assertEquals(x, 0x01234567, "failing weakCompareAndSetAcquire int value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(0x01234567, 0x89ABCDEF);
+                success = (boolean) mh.invokeExact(0x01234567, 0x89ABCDEF);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease int");
+            assertEquals(success, true, "success weakCompareAndSetRelease int");
             int x = (int) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, 0x89ABCDEF, "weakCompareAndSetRelease int");
+            assertEquals(x, 0x89ABCDEF, "success weakCompareAndSetRelease int");
         }
 
         {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(0x01234567, 0xCAFEBABE);
+            assertEquals(success, false, "failing weakCompareAndSetRelease int");
+            int x = (int) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, 0x89ABCDEF, "failing weakCompareAndSetRelease int value");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(0x89ABCDEF, 0x01234567);
+                success = (boolean) mh.invokeExact(0x89ABCDEF, 0x01234567);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet int");
+            assertEquals(success, true, "success weakCompareAndSet int");
+            int x = (int) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, 0x01234567, "success weakCompareAndSet int");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(0x89ABCDEF, 0xCAFEBABE);
+            assertEquals(success, false, "failing weakCompareAndSet int");
             int x = (int) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, 0x01234567, "weakCompareAndSet int");
+            assertEquals(x, 0x01234567, "failing weakCompareAndSetRe int value");
         }
 
         // Compare set and get
@@ -748,43 +822,79 @@ public class VarHandleTestMethodHandleAccessInt extends VarHandleBaseTest {
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, 0x01234567, 0x89ABCDEF);
+                    success = (boolean) mh.invokeExact(array, i, 0x01234567, 0x89ABCDEF);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetPlain int");
+                assertEquals(success, true, "success weakCompareAndSetPlain int");
+                int x = (int) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, 0x89ABCDEF, "success weakCompareAndSetPlain int value");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, 0x01234567, 0xCAFEBABE);
+                assertEquals(success, false, "failing weakCompareAndSetPlain int");
                 int x = (int) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, 0x89ABCDEF, "weakCompareAndSetPlain int value");
+                assertEquals(x, 0x89ABCDEF, "failing weakCompareAndSetPlain int value");
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 0x89ABCDEF, 0x01234567);
+                    success = (boolean) mh.invokeExact(array, i, 0x89ABCDEF, 0x01234567);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetAcquire int");
+                assertEquals(success, true, "success weakCompareAndSetAcquire int");
                 int x = (int) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, 0x01234567, "weakCompareAndSetAcquire int");
+                assertEquals(x, 0x01234567, "success weakCompareAndSetAcquire int");
             }
 
             {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 0x89ABCDEF, 0xCAFEBABE);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire int");
+                int x = (int) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, 0x01234567, "failing weakCompareAndSetAcquire int value");
+            }
+
+            {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(array, i, 0x01234567, 0x89ABCDEF);
+                    success = (boolean) mh.invokeExact(array, i, 0x01234567, 0x89ABCDEF);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetRelease int");
+                assertEquals(success, true, "success weakCompareAndSetRelease int");
+                int x = (int) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, 0x89ABCDEF, "success weakCompareAndSetRelease int");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 0x01234567, 0xCAFEBABE);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire int");
                 int x = (int) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, 0x89ABCDEF, "weakCompareAndSetRelease int");
+                assertEquals(x, 0x89ABCDEF, "failing weakCompareAndSetAcquire int value");
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, 0x89ABCDEF, 0x01234567);
+                    success = (boolean) mh.invokeExact(array, i, 0x89ABCDEF, 0x01234567);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSet int");
+                assertEquals(success, true, "success weakCompareAndSet int");
+                int x = (int) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, 0x01234567, "success weakCompareAndSet int");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, 0x89ABCDEF, 0xCAFEBABE);
+                assertEquals(success, false, "failing weakCompareAndSet int");
                 int x = (int) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, 0x01234567, "weakCompareAndSet int");
+                assertEquals(x, 0x01234567, "failing weakCompareAndSet int value");
             }
 
             // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessLong.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessLong.java
index 6bb35c0d7d6..b36d37d6af7 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessLong.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessLong.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,6 +33,7 @@ import org.testng.annotations.BeforeClass;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
+import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
@@ -211,43 +212,79 @@ public class VarHandleTestMethodHandleAccessLong extends VarHandleBaseTest {
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, 0x0123456789ABCDEFL, 0xCAFEBABECAFEBABEL);
+                success = (boolean) mh.invokeExact(recv, 0x0123456789ABCDEFL, 0xCAFEBABECAFEBABEL);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain long");
+            assertEquals(success, true, "success weakCompareAndSetPlain long");
             long x = (long) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, 0xCAFEBABECAFEBABEL, "weakCompareAndSetPlain long value");
+            assertEquals(x, 0xCAFEBABECAFEBABEL, "success weakCompareAndSetPlain long value");
         }
 
         {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);
+            assertEquals(success, false, "failing weakCompareAndSetPlain long");
+            long x = (long) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, 0xCAFEBABECAFEBABEL, "failing weakCompareAndSetPlain long value");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, 0xCAFEBABECAFEBABEL, 0x0123456789ABCDEFL);
+                success = (boolean) mh.invokeExact(recv, 0xCAFEBABECAFEBABEL, 0x0123456789ABCDEFL);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire long");
+            assertEquals(success, true, "success weakCompareAndSetAcquire long");
+            long x = (long) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, 0x0123456789ABCDEFL, "success weakCompareAndSetAcquire long");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire long");
             long x = (long) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, 0x0123456789ABCDEFL, "weakCompareAndSetAcquire long");
+            assertEquals(x, 0x0123456789ABCDEFL, "failing weakCompareAndSetAcquire long value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, 0x0123456789ABCDEFL, 0xCAFEBABECAFEBABEL);
+                success = (boolean) mh.invokeExact(recv, 0x0123456789ABCDEFL, 0xCAFEBABECAFEBABEL);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease long");
+            assertEquals(success, true, "success weakCompareAndSetRelease long");
+            long x = (long) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, 0xCAFEBABECAFEBABEL, "success weakCompareAndSetRelease long");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);
+            assertEquals(success, false, "failing weakCompareAndSetRelease long");
             long x = (long) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, 0xCAFEBABECAFEBABEL, "weakCompareAndSetRelease long");
+            assertEquals(x, 0xCAFEBABECAFEBABEL, "failing weakCompareAndSetRelease long value");
         }
 
         {
             boolean success = false;
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, 0xCAFEBABECAFEBABEL, 0x0123456789ABCDEFL);
+                success = (boolean) mh.invokeExact(recv, 0xCAFEBABECAFEBABEL, 0x0123456789ABCDEFL);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet long");
+            assertEquals(success, true, "success weakCompareAndSet long");
             long x = (long) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, 0x0123456789ABCDEFL, "weakCompareAndSet long");
+            assertEquals(x, 0x0123456789ABCDEFL, "success weakCompareAndSet long");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);
+            assertEquals(success, false, "failing weakCompareAndSet long");
+            long x = (long) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, 0x0123456789ABCDEFL, "failing weakCompareAndSet long value");
         }
 
         // Compare set and get
@@ -467,43 +504,80 @@ public class VarHandleTestMethodHandleAccessLong extends VarHandleBaseTest {
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(0x0123456789ABCDEFL, 0xCAFEBABECAFEBABEL);
+                success = (boolean) mh.invokeExact(0x0123456789ABCDEFL, 0xCAFEBABECAFEBABEL);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain long");
+            assertEquals(success, true, "success weakCompareAndSetPlain long");
+            long x = (long) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, 0xCAFEBABECAFEBABEL, "success weakCompareAndSetPlain long value");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);
+            assertEquals(success, false, "failing weakCompareAndSetPlain long");
             long x = (long) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, 0xCAFEBABECAFEBABEL, "weakCompareAndSetPlain long value");
+            assertEquals(x, 0xCAFEBABECAFEBABEL, "failing weakCompareAndSetPlain long value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(0xCAFEBABECAFEBABEL, 0x0123456789ABCDEFL);
+                success = (boolean) mh.invokeExact(0xCAFEBABECAFEBABEL, 0x0123456789ABCDEFL);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire long");
+            assertEquals(success, true, "success weakCompareAndSetAcquire long");
+            long x = (long) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, 0x0123456789ABCDEFL, "success weakCompareAndSetAcquire long");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
+            boolean success = (boolean) mh.invokeExact(0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire long");
             long x = (long) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, 0x0123456789ABCDEFL, "weakCompareAndSetAcquire long");
+            assertEquals(x, 0x0123456789ABCDEFL, "failing weakCompareAndSetAcquire long value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(0x0123456789ABCDEFL, 0xCAFEBABECAFEBABEL);
+                success = (boolean) mh.invokeExact(0x0123456789ABCDEFL, 0xCAFEBABECAFEBABEL);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease long");
+            assertEquals(success, true, "success weakCompareAndSetRelease long");
             long x = (long) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, 0xCAFEBABECAFEBABEL, "weakCompareAndSetRelease long");
+            assertEquals(x, 0xCAFEBABECAFEBABEL, "success weakCompareAndSetRelease long");
         }
 
         {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);
+            assertEquals(success, false, "failing weakCompareAndSetRelease long");
+            long x = (long) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, 0xCAFEBABECAFEBABEL, "failing weakCompareAndSetRelease long value");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(0xCAFEBABECAFEBABEL, 0x0123456789ABCDEFL);
+                success = (boolean) mh.invokeExact(0xCAFEBABECAFEBABEL, 0x0123456789ABCDEFL);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet long");
+            assertEquals(success, true, "success weakCompareAndSet long");
+            long x = (long) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, 0x0123456789ABCDEFL, "success weakCompareAndSet long");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);
+            assertEquals(success, false, "failing weakCompareAndSet long");
             long x = (long) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, 0x0123456789ABCDEFL, "weakCompareAndSet long");
+            assertEquals(x, 0x0123456789ABCDEFL, "failing weakCompareAndSetRe long value");
         }
 
         // Compare set and get
@@ -748,43 +822,79 @@ public class VarHandleTestMethodHandleAccessLong extends VarHandleBaseTest {
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, 0x0123456789ABCDEFL, 0xCAFEBABECAFEBABEL);
+                    success = (boolean) mh.invokeExact(array, i, 0x0123456789ABCDEFL, 0xCAFEBABECAFEBABEL);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetPlain long");
+                assertEquals(success, true, "success weakCompareAndSetPlain long");
+                long x = (long) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, 0xCAFEBABECAFEBABEL, "success weakCompareAndSetPlain long value");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);
+                assertEquals(success, false, "failing weakCompareAndSetPlain long");
                 long x = (long) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, 0xCAFEBABECAFEBABEL, "weakCompareAndSetPlain long value");
+                assertEquals(x, 0xCAFEBABECAFEBABEL, "failing weakCompareAndSetPlain long value");
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 0xCAFEBABECAFEBABEL, 0x0123456789ABCDEFL);
+                    success = (boolean) mh.invokeExact(array, i, 0xCAFEBABECAFEBABEL, 0x0123456789ABCDEFL);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetAcquire long");
+                assertEquals(success, true, "success weakCompareAndSetAcquire long");
                 long x = (long) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, 0x0123456789ABCDEFL, "weakCompareAndSetAcquire long");
+                assertEquals(x, 0x0123456789ABCDEFL, "success weakCompareAndSetAcquire long");
             }
 
             {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire long");
+                long x = (long) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, 0x0123456789ABCDEFL, "failing weakCompareAndSetAcquire long value");
+            }
+
+            {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(array, i, 0x0123456789ABCDEFL, 0xCAFEBABECAFEBABEL);
+                    success = (boolean) mh.invokeExact(array, i, 0x0123456789ABCDEFL, 0xCAFEBABECAFEBABEL);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetRelease long");
+                assertEquals(success, true, "success weakCompareAndSetRelease long");
+                long x = (long) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, 0xCAFEBABECAFEBABEL, "success weakCompareAndSetRelease long");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire long");
                 long x = (long) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, 0xCAFEBABECAFEBABEL, "weakCompareAndSetRelease long");
+                assertEquals(x, 0xCAFEBABECAFEBABEL, "failing weakCompareAndSetAcquire long value");
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, 0xCAFEBABECAFEBABEL, 0x0123456789ABCDEFL);
+                    success = (boolean) mh.invokeExact(array, i, 0xCAFEBABECAFEBABEL, 0x0123456789ABCDEFL);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSet long");
+                assertEquals(success, true, "success weakCompareAndSet long");
+                long x = (long) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, 0x0123456789ABCDEFL, "success weakCompareAndSet long");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);
+                assertEquals(success, false, "failing weakCompareAndSet long");
                 long x = (long) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, 0x0123456789ABCDEFL, "weakCompareAndSet long");
+                assertEquals(x, 0x0123456789ABCDEFL, "failing weakCompareAndSet long value");
             }
 
             // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessShort.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessShort.java
index 45c78bdf6ba..8d02e85a854 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessShort.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessShort.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,6 +33,7 @@ import org.testng.annotations.BeforeClass;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
+import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
@@ -211,43 +212,79 @@ public class VarHandleTestMethodHandleAccessShort extends VarHandleBaseTest {
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, (short)0x0123, (short)0x4567);
+                success = (boolean) mh.invokeExact(recv, (short)0x0123, (short)0x4567);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain short");
+            assertEquals(success, true, "success weakCompareAndSetPlain short");
             short x = (short) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, (short)0x4567, "weakCompareAndSetPlain short value");
+            assertEquals(x, (short)0x4567, "success weakCompareAndSetPlain short value");
         }
 
         {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, (short)0x0123, (short)0x89AB);
+            assertEquals(success, false, "failing weakCompareAndSetPlain short");
+            short x = (short) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, (short)0x4567, "failing weakCompareAndSetPlain short value");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, (short)0x4567, (short)0x0123);
+                success = (boolean) mh.invokeExact(recv, (short)0x4567, (short)0x0123);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire short");
+            assertEquals(success, true, "success weakCompareAndSetAcquire short");
+            short x = (short) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, (short)0x0123, "success weakCompareAndSetAcquire short");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, (short)0x4567, (short)0x89AB);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire short");
             short x = (short) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, (short)0x0123, "weakCompareAndSetAcquire short");
+            assertEquals(x, (short)0x0123, "failing weakCompareAndSetAcquire short value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, (short)0x0123, (short)0x4567);
+                success = (boolean) mh.invokeExact(recv, (short)0x0123, (short)0x4567);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease short");
+            assertEquals(success, true, "success weakCompareAndSetRelease short");
+            short x = (short) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, (short)0x4567, "success weakCompareAndSetRelease short");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, (short)0x0123, (short)0x89AB);
+            assertEquals(success, false, "failing weakCompareAndSetRelease short");
             short x = (short) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, (short)0x4567, "weakCompareAndSetRelease short");
+            assertEquals(x, (short)0x4567, "failing weakCompareAndSetRelease short value");
         }
 
         {
             boolean success = false;
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, (short)0x4567, (short)0x0123);
+                success = (boolean) mh.invokeExact(recv, (short)0x4567, (short)0x0123);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet short");
+            assertEquals(success, true, "success weakCompareAndSet short");
             short x = (short) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, (short)0x0123, "weakCompareAndSet short");
+            assertEquals(x, (short)0x0123, "success weakCompareAndSet short");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, (short)0x4567, (short)0x89AB);
+            assertEquals(success, false, "failing weakCompareAndSet short");
+            short x = (short) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, (short)0x0123, "failing weakCompareAndSet short value");
         }
 
         // Compare set and get
@@ -467,43 +504,80 @@ public class VarHandleTestMethodHandleAccessShort extends VarHandleBaseTest {
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact((short)0x0123, (short)0x4567);
+                success = (boolean) mh.invokeExact((short)0x0123, (short)0x4567);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain short");
+            assertEquals(success, true, "success weakCompareAndSetPlain short");
+            short x = (short) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, (short)0x4567, "success weakCompareAndSetPlain short value");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact((short)0x0123, (short)0x89AB);
+            assertEquals(success, false, "failing weakCompareAndSetPlain short");
             short x = (short) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, (short)0x4567, "weakCompareAndSetPlain short value");
+            assertEquals(x, (short)0x4567, "failing weakCompareAndSetPlain short value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact((short)0x4567, (short)0x0123);
+                success = (boolean) mh.invokeExact((short)0x4567, (short)0x0123);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire short");
+            assertEquals(success, true, "success weakCompareAndSetAcquire short");
+            short x = (short) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, (short)0x0123, "success weakCompareAndSetAcquire short");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
+            boolean success = (boolean) mh.invokeExact((short)0x4567, (short)0x89AB);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire short");
             short x = (short) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, (short)0x0123, "weakCompareAndSetAcquire short");
+            assertEquals(x, (short)0x0123, "failing weakCompareAndSetAcquire short value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact((short)0x0123, (short)0x4567);
+                success = (boolean) mh.invokeExact((short)0x0123, (short)0x4567);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease short");
+            assertEquals(success, true, "success weakCompareAndSetRelease short");
             short x = (short) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, (short)0x4567, "weakCompareAndSetRelease short");
+            assertEquals(x, (short)0x4567, "success weakCompareAndSetRelease short");
         }
 
         {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact((short)0x0123, (short)0x89AB);
+            assertEquals(success, false, "failing weakCompareAndSetRelease short");
+            short x = (short) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, (short)0x4567, "failing weakCompareAndSetRelease short value");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact((short)0x4567, (short)0x0123);
+                success = (boolean) mh.invokeExact((short)0x4567, (short)0x0123);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet short");
+            assertEquals(success, true, "success weakCompareAndSet short");
+            short x = (short) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, (short)0x0123, "success weakCompareAndSet short");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact((short)0x4567, (short)0x89AB);
+            assertEquals(success, false, "failing weakCompareAndSet short");
             short x = (short) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, (short)0x0123, "weakCompareAndSet short");
+            assertEquals(x, (short)0x0123, "failing weakCompareAndSetRe short value");
         }
 
         // Compare set and get
@@ -748,43 +822,79 @@ public class VarHandleTestMethodHandleAccessShort extends VarHandleBaseTest {
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, (short)0x0123, (short)0x4567);
+                    success = (boolean) mh.invokeExact(array, i, (short)0x0123, (short)0x4567);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetPlain short");
+                assertEquals(success, true, "success weakCompareAndSetPlain short");
+                short x = (short) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, (short)0x4567, "success weakCompareAndSetPlain short value");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, (short)0x0123, (short)0x89AB);
+                assertEquals(success, false, "failing weakCompareAndSetPlain short");
                 short x = (short) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, (short)0x4567, "weakCompareAndSetPlain short value");
+                assertEquals(x, (short)0x4567, "failing weakCompareAndSetPlain short value");
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, (short)0x4567, (short)0x0123);
+                    success = (boolean) mh.invokeExact(array, i, (short)0x4567, (short)0x0123);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetAcquire short");
+                assertEquals(success, true, "success weakCompareAndSetAcquire short");
                 short x = (short) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, (short)0x0123, "weakCompareAndSetAcquire short");
+                assertEquals(x, (short)0x0123, "success weakCompareAndSetAcquire short");
             }
 
             {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, (short)0x4567, (short)0x89AB);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire short");
+                short x = (short) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, (short)0x0123, "failing weakCompareAndSetAcquire short value");
+            }
+
+            {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(array, i, (short)0x0123, (short)0x4567);
+                    success = (boolean) mh.invokeExact(array, i, (short)0x0123, (short)0x4567);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetRelease short");
+                assertEquals(success, true, "success weakCompareAndSetRelease short");
+                short x = (short) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, (short)0x4567, "success weakCompareAndSetRelease short");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, (short)0x0123, (short)0x89AB);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire short");
                 short x = (short) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, (short)0x4567, "weakCompareAndSetRelease short");
+                assertEquals(x, (short)0x4567, "failing weakCompareAndSetAcquire short value");
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, (short)0x4567, (short)0x0123);
+                    success = (boolean) mh.invokeExact(array, i, (short)0x4567, (short)0x0123);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSet short");
+                assertEquals(success, true, "success weakCompareAndSet short");
+                short x = (short) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, (short)0x0123, "success weakCompareAndSet short");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, (short)0x4567, (short)0x89AB);
+                assertEquals(success, false, "failing weakCompareAndSet short");
                 short x = (short) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, (short)0x0123, "weakCompareAndSet short");
+                assertEquals(x, (short)0x0123, "failing weakCompareAndSet short value");
             }
 
             // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessString.java b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessString.java
index 36f635786f5..02346d9f093 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessString.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/VarHandleTestMethodHandleAccessString.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,6 +33,7 @@ import org.testng.annotations.BeforeClass;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
+import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
@@ -211,43 +212,79 @@ public class VarHandleTestMethodHandleAccessString extends VarHandleBaseTest {
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, "foo", "bar");
+                success = (boolean) mh.invokeExact(recv, "foo", "bar");
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain String");
+            assertEquals(success, true, "success weakCompareAndSetPlain String");
             String x = (String) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, "bar", "weakCompareAndSetPlain String value");
+            assertEquals(x, "bar", "success weakCompareAndSetPlain String value");
         }
 
         {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, "foo", "baz");
+            assertEquals(success, false, "failing weakCompareAndSetPlain String");
+            String x = (String) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, "bar", "failing weakCompareAndSetPlain String value");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, "bar", "foo");
+                success = (boolean) mh.invokeExact(recv, "bar", "foo");
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire String");
+            assertEquals(success, true, "success weakCompareAndSetAcquire String");
+            String x = (String) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, "foo", "success weakCompareAndSetAcquire String");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, "bar", "baz");
+            assertEquals(success, false, "failing weakCompareAndSetAcquire String");
             String x = (String) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, "foo", "weakCompareAndSetAcquire String");
+            assertEquals(x, "foo", "failing weakCompareAndSetAcquire String value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, "foo", "bar");
+                success = (boolean) mh.invokeExact(recv, "foo", "bar");
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease String");
+            assertEquals(success, true, "success weakCompareAndSetRelease String");
+            String x = (String) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, "bar", "success weakCompareAndSetRelease String");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, "foo", "baz");
+            assertEquals(success, false, "failing weakCompareAndSetRelease String");
             String x = (String) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, "bar", "weakCompareAndSetRelease String");
+            assertEquals(x, "bar", "failing weakCompareAndSetRelease String value");
         }
 
         {
             boolean success = false;
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, "bar", "foo");
+                success = (boolean) mh.invokeExact(recv, "bar", "foo");
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet String");
+            assertEquals(success, true, "success weakCompareAndSet String");
             String x = (String) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, "foo", "weakCompareAndSet String");
+            assertEquals(x, "foo", "success weakCompareAndSet String");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, "bar", "baz");
+            assertEquals(success, false, "failing weakCompareAndSet String");
+            String x = (String) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, "foo", "failing weakCompareAndSet String value");
         }
 
         // Compare set and get
@@ -367,43 +404,80 @@ public class VarHandleTestMethodHandleAccessString extends VarHandleBaseTest {
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact("foo", "bar");
+                success = (boolean) mh.invokeExact("foo", "bar");
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain String");
+            assertEquals(success, true, "success weakCompareAndSetPlain String");
+            String x = (String) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, "bar", "success weakCompareAndSetPlain String value");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact("foo", "baz");
+            assertEquals(success, false, "failing weakCompareAndSetPlain String");
             String x = (String) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, "bar", "weakCompareAndSetPlain String value");
+            assertEquals(x, "bar", "failing weakCompareAndSetPlain String value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact("bar", "foo");
+                success = (boolean) mh.invokeExact("bar", "foo");
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire String");
+            assertEquals(success, true, "success weakCompareAndSetAcquire String");
+            String x = (String) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, "foo", "success weakCompareAndSetAcquire String");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
+            boolean success = (boolean) mh.invokeExact("bar", "baz");
+            assertEquals(success, false, "failing weakCompareAndSetAcquire String");
             String x = (String) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, "foo", "weakCompareAndSetAcquire String");
+            assertEquals(x, "foo", "failing weakCompareAndSetAcquire String value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact("foo", "bar");
+                success = (boolean) mh.invokeExact("foo", "bar");
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease String");
+            assertEquals(success, true, "success weakCompareAndSetRelease String");
             String x = (String) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, "bar", "weakCompareAndSetRelease String");
+            assertEquals(x, "bar", "success weakCompareAndSetRelease String");
         }
 
         {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact("foo", "baz");
+            assertEquals(success, false, "failing weakCompareAndSetRelease String");
+            String x = (String) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, "bar", "failing weakCompareAndSetRelease String value");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact("bar", "foo");
+                success = (boolean) mh.invokeExact("bar", "foo");
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet String");
+            assertEquals(success, true, "success weakCompareAndSet String");
+            String x = (String) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, "foo", "success weakCompareAndSet String");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact("bar", "baz");
+            assertEquals(success, false, "failing weakCompareAndSet String");
             String x = (String) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, "foo", "weakCompareAndSet String");
+            assertEquals(x, "foo", "failing weakCompareAndSetRe String value");
         }
 
         // Compare set and get
@@ -548,43 +622,79 @@ public class VarHandleTestMethodHandleAccessString extends VarHandleBaseTest {
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, "foo", "bar");
+                    success = (boolean) mh.invokeExact(array, i, "foo", "bar");
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetPlain String");
+                assertEquals(success, true, "success weakCompareAndSetPlain String");
+                String x = (String) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, "bar", "success weakCompareAndSetPlain String value");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, "foo", "baz");
+                assertEquals(success, false, "failing weakCompareAndSetPlain String");
                 String x = (String) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, "bar", "weakCompareAndSetPlain String value");
+                assertEquals(x, "bar", "failing weakCompareAndSetPlain String value");
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, "bar", "foo");
+                    success = (boolean) mh.invokeExact(array, i, "bar", "foo");
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetAcquire String");
+                assertEquals(success, true, "success weakCompareAndSetAcquire String");
                 String x = (String) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, "foo", "weakCompareAndSetAcquire String");
+                assertEquals(x, "foo", "success weakCompareAndSetAcquire String");
             }
 
             {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, "bar", "baz");
+                assertEquals(success, false, "failing weakCompareAndSetAcquire String");
+                String x = (String) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, "foo", "failing weakCompareAndSetAcquire String value");
+            }
+
+            {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(array, i, "foo", "bar");
+                    success = (boolean) mh.invokeExact(array, i, "foo", "bar");
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetRelease String");
+                assertEquals(success, true, "success weakCompareAndSetRelease String");
+                String x = (String) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, "bar", "success weakCompareAndSetRelease String");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, "foo", "baz");
+                assertEquals(success, false, "failing weakCompareAndSetAcquire String");
                 String x = (String) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, "bar", "weakCompareAndSetRelease String");
+                assertEquals(x, "bar", "failing weakCompareAndSetAcquire String value");
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, "bar", "foo");
+                    success = (boolean) mh.invokeExact(array, i, "bar", "foo");
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSet String");
+                assertEquals(success, true, "success weakCompareAndSet String");
+                String x = (String) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, "foo", "success weakCompareAndSet String");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, "bar", "baz");
+                assertEquals(success, false, "failing weakCompareAndSet String");
                 String x = (String) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, "foo", "weakCompareAndSet String");
+                assertEquals(x, "foo", "failing weakCompareAndSet String value");
             }
 
             // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/X-VarHandleTestAccess.java.template b/ojluni/src/test/java/lang/invoke/VarHandles/X-VarHandleTestAccess.java.template
index 6c38f7c5ac3..b82908ca2be 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/X-VarHandleTestAccess.java.template
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/X-VarHandleTestAccess.java.template
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -661,40 +661,72 @@ public class VarHandleTestAccess$Type$ extends VarHandleBaseTest {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetPlain(recv, $value1$, $value2$);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain $type$");
+            assertEquals(success, true, "success weakCompareAndSetPlain $type$");
             $type$ x = ($type$) vh.get(recv);
-            assertEquals(x, $value2$, "weakCompareAndSetPlain $type$ value");
+            assertEquals(x, $value2$, "success weakCompareAndSetPlain $type$ value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetPlain(recv, $value1$, $value3$);
+            assertEquals(success, false, "failing weakCompareAndSetPlain $type$");
+            $type$ x = ($type$) vh.get(recv);
+            assertEquals(x, $value2$, "failing weakCompareAndSetPlain $type$ value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetAcquire(recv, $value2$, $value1$);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire $type$");
+            assertEquals(success, true, "success weakCompareAndSetAcquire $type$");
+            $type$ x = ($type$) vh.get(recv);
+            assertEquals(x, $value1$, "success weakCompareAndSetAcquire $type$");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetAcquire(recv, $value2$, $value3$);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire $type$");
             $type$ x = ($type$) vh.get(recv);
-            assertEquals(x, $value1$, "weakCompareAndSetAcquire $type$");
+            assertEquals(x, $value1$, "failing weakCompareAndSetAcquire $type$ value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetRelease(recv, $value1$, $value2$);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease $type$");
+            assertEquals(success, true, "success weakCompareAndSetRelease $type$");
+            $type$ x = ($type$) vh.get(recv);
+            assertEquals(x, $value2$, "success weakCompareAndSetRelease $type$");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetRelease(recv, $value1$, $value3$);
+            assertEquals(success, false, "failing weakCompareAndSetRelease $type$");
             $type$ x = ($type$) vh.get(recv);
-            assertEquals(x, $value2$, "weakCompareAndSetRelease $type$");
+            assertEquals(x, $value2$, "failing weakCompareAndSetRelease $type$ value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSet(recv, $value2$, $value1$);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet $type$");
+            assertEquals(success, true, "success weakCompareAndSet $type$");
             $type$ x = ($type$) vh.get(recv);
-            assertEquals(x, $value1$, "weakCompareAndSet $type$ value");
+            assertEquals(x, $value1$, "success weakCompareAndSet $type$ value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSet(recv, $value2$, $value3$);
+            assertEquals(success, false, "failing weakCompareAndSet $type$");
+            $type$ x = ($type$) vh.get(recv);
+            assertEquals(x, $value1$, "failing weakCompareAndSet $type$ value");
         }
 
         // Compare set and get
@@ -1038,40 +1070,72 @@ public class VarHandleTestAccess$Type$ extends VarHandleBaseTest {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetPlain($value1$, $value2$);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain $type$");
+            assertEquals(success, true, "success weakCompareAndSetPlain $type$");
+            $type$ x = ($type$) vh.get();
+            assertEquals(x, $value2$, "success weakCompareAndSetPlain $type$ value");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetPlain($value1$, $value3$);
+            assertEquals(success, false, "failing weakCompareAndSetPlain $type$");
             $type$ x = ($type$) vh.get();
-            assertEquals(x, $value2$, "weakCompareAndSetPlain $type$ value");
+            assertEquals(x, $value2$, "failing weakCompareAndSetPlain $type$ value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetAcquire($value2$, $value1$);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire $type$");
+            assertEquals(success, true, "success weakCompareAndSetAcquire $type$");
+            $type$ x = ($type$) vh.get();
+            assertEquals(x, $value1$, "success weakCompareAndSetAcquire $type$");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetAcquire($value2$, $value3$);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire $type$");
             $type$ x = ($type$) vh.get();
-            assertEquals(x, $value1$, "weakCompareAndSetAcquire $type$");
+            assertEquals(x, $value1$, "failing weakCompareAndSetAcquire $type$ value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSetRelease($value1$, $value2$);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease $type$");
+            assertEquals(success, true, "success weakCompareAndSetRelease $type$");
             $type$ x = ($type$) vh.get();
-            assertEquals(x, $value2$, "weakCompareAndSetRelease $type$");
+            assertEquals(x, $value2$, "success weakCompareAndSetRelease $type$");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSetRelease($value1$, $value3$);
+            assertEquals(success, false, "failing weakCompareAndSetRelease $type$");
+            $type$ x = ($type$) vh.get();
+            assertEquals(x, $value2$, "failing weakCompareAndSetRelease $type$ value");
         }
 
         {
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                 success = vh.weakCompareAndSet($value2$, $value1$);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet $type$");
+            assertEquals(success, true, "success weakCompareAndSet $type$");
+            $type$ x = ($type$) vh.get();
+            assertEquals(x, $value1$, "success weakCompareAndSet $type$");
+        }
+
+        {
+            boolean success = vh.weakCompareAndSet($value2$, $value3$);
+            assertEquals(success, false, "failing weakCompareAndSet $type$");
             $type$ x = ($type$) vh.get();
-            assertEquals(x, $value1$, "weakCompareAndSet $type$");
+            assertEquals(x, $value1$, "failing weakCompareAndSet $type$ value");
         }
 
         // Compare set and get
@@ -1418,40 +1482,72 @@ public class VarHandleTestAccess$Type$ extends VarHandleBaseTest {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetPlain(array, i, $value1$, $value2$);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetPlain $type$");
+                assertEquals(success, true, "success weakCompareAndSetPlain $type$");
+                $type$ x = ($type$) vh.get(array, i);
+                assertEquals(x, $value2$, "success weakCompareAndSetPlain $type$ value");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetPlain(array, i, $value1$, $value3$);
+                assertEquals(success, false, "failing weakCompareAndSetPlain $type$");
                 $type$ x = ($type$) vh.get(array, i);
-                assertEquals(x, $value2$, "weakCompareAndSetPlain $type$ value");
+                assertEquals(x, $value2$, "failing weakCompareAndSetPlain $type$ value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetAcquire(array, i, $value2$, $value1$);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetAcquire $type$");
+                assertEquals(success, true, "success weakCompareAndSetAcquire $type$");
                 $type$ x = ($type$) vh.get(array, i);
-                assertEquals(x, $value1$, "weakCompareAndSetAcquire $type$");
+                assertEquals(x, $value1$, "success weakCompareAndSetAcquire $type$");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetAcquire(array, i, $value2$, $value3$);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire $type$");
+                $type$ x = ($type$) vh.get(array, i);
+                assertEquals(x, $value1$, "failing weakCompareAndSetAcquire $type$ value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSetRelease(array, i, $value1$, $value2$);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetRelease $type$");
+                assertEquals(success, true, "success weakCompareAndSetRelease $type$");
+                $type$ x = ($type$) vh.get(array, i);
+                assertEquals(x, $value2$, "success weakCompareAndSetRelease $type$");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSetRelease(array, i, $value1$, $value3$);
+                assertEquals(success, false, "failing weakCompareAndSetRelease $type$");
                 $type$ x = ($type$) vh.get(array, i);
-                assertEquals(x, $value2$, "weakCompareAndSetRelease $type$");
+                assertEquals(x, $value2$, "failing weakCompareAndSetRelease $type$ value");
             }
 
             {
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                     success = vh.weakCompareAndSet(array, i, $value2$, $value1$);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSet $type$");
+                assertEquals(success, true, "success weakCompareAndSet $type$");
+                $type$ x = ($type$) vh.get(array, i);
+                assertEquals(x, $value1$, "success weakCompareAndSet $type$");
+            }
+
+            {
+                boolean success = vh.weakCompareAndSet(array, i, $value2$, $value3$);
+                assertEquals(success, false, "failing weakCompareAndSet $type$");
                 $type$ x = ($type$) vh.get(array, i);
-                assertEquals(x, $value1$, "weakCompareAndSet $type$");
+                assertEquals(x, $value1$, "failing weakCompareAndSet $type$ value");
             }
 
             // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/X-VarHandleTestByteArrayView.java.template b/ojluni/src/test/java/lang/invoke/VarHandles/X-VarHandleTestByteArrayView.java.template
index 0587d48a689..c56f31d1178 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/X-VarHandleTestByteArrayView.java.template
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/X-VarHandleTestByteArrayView.java.template
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,9 +27,9 @@ package test.java.lang.invoke.VarHandles;
 /*
  * @test
  * @bug 8154556
- * @run testng/othervm -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestByteArrayAs$Type$
- * @run testng/othervm -Diters=20000                         VarHandleTestByteArrayAs$Type$
- * @run testng/othervm -Diters=20000 -XX:-TieredCompilation  VarHandleTestByteArrayAs$Type$
+ * @run testng/othervm/timeout=360 -Diters=20000 -XX:TieredStopAtLevel=1 VarHandleTestByteArrayAs$Type$
+ * @run testng/othervm/timeout=360 -Diters=20000                         VarHandleTestByteArrayAs$Type$
+ * @run testng/othervm/timeout=360 -Diters=20000 -XX:-TieredCompilation  VarHandleTestByteArrayAs$Type$
  */
 
 import org.testng.annotations.DataProvider;
@@ -1594,40 +1594,72 @@ public class VarHandleTestByteArrayAs$Type$ extends VarHandleBaseByteArrayTest {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_2);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetPlain $type$");
+                    assertEquals(success, true, "success weakCompareAndSetPlain $type$");
                     $type$ x = ($type$) vh.get(array, i);
-                    assertEquals(x, VALUE_2, "weakCompareAndSetPlain $type$ value");
+                    assertEquals(x, VALUE_2, "success weakCompareAndSetPlain $type$ value");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetPlain $type$");
+                    $type$ x = ($type$) vh.get(array, i);
+                    assertEquals(x, VALUE_2, "failing weakCompareAndSetPlain $type$ value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_1);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetAcquire $type$");
+                    assertEquals(success, true, "success weakCompareAndSetAcquire $type$");
+                    $type$ x = ($type$) vh.get(array, i);
+                    assertEquals(x, VALUE_1, "success weakCompareAndSetAcquire $type$");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetAcquire $type$");
                     $type$ x = ($type$) vh.get(array, i);
-                    assertEquals(x, VALUE_1, "weakCompareAndSetAcquire $type$");
+                    assertEquals(x, VALUE_1, "failing weakCompareAndSetAcquire $type$ value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_2);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetRelease $type$");
+                    assertEquals(success, true, "success weakCompareAndSetRelease $type$");
                     $type$ x = ($type$) vh.get(array, i);
-                    assertEquals(x, VALUE_2, "weakCompareAndSetRelease $type$");
+                    assertEquals(x, VALUE_2, "success weakCompareAndSetRelease $type$");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetRelease $type$");
+                    $type$ x = ($type$) vh.get(array, i);
+                    assertEquals(x, VALUE_2, "failing weakCompareAndSetRelease $type$ value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_1);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSet $type$");
+                    assertEquals(success, true, "success weakCompareAndSet $type$");
+                    $type$ x = ($type$) vh.get(array, i);
+                    assertEquals(x, VALUE_1, "success weakCompareAndSet $type$");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSet $type$");
                     $type$ x = ($type$) vh.get(array, i);
-                    assertEquals(x, VALUE_1, "weakCompareAndSet $type$");
+                    assertEquals(x, VALUE_1, "failing weakCompareAndSet $type$ value");
                 }
 
                 // Compare set and get
@@ -1883,40 +1915,72 @@ public class VarHandleTestByteArrayAs$Type$ extends VarHandleBaseByteArrayTest {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_2);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetPlain $type$");
+                    assertEquals(success, true, "success weakCompareAndSetPlain $type$");
                     $type$ x = ($type$) vh.get(array, i);
-                    assertEquals(x, VALUE_2, "weakCompareAndSetPlain $type$ value");
+                    assertEquals(x, VALUE_2, "success weakCompareAndSetPlain $type$ value");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetPlain(array, i, VALUE_1, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetPlain $type$");
+                    $type$ x = ($type$) vh.get(array, i);
+                    assertEquals(x, VALUE_2, "failing weakCompareAndSetPlain $type$ value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_1);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetAcquire $type$");
+                    assertEquals(success, true, "success weakCompareAndSetAcquire $type$");
+                    $type$ x = ($type$) vh.get(array, i);
+                    assertEquals(x, VALUE_1, "success weakCompareAndSetAcquire $type$");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetAcquire(array, i, VALUE_2, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetAcquire $type$");
                     $type$ x = ($type$) vh.get(array, i);
-                    assertEquals(x, VALUE_1, "weakCompareAndSetAcquire $type$");
+                    assertEquals(x, VALUE_1, "failing weakCompareAndSetAcquire $type$ value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_2);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSetRelease $type$");
+                    assertEquals(success, true, "success weakCompareAndSetRelease $type$");
                     $type$ x = ($type$) vh.get(array, i);
-                    assertEquals(x, VALUE_2, "weakCompareAndSetRelease $type$");
+                    assertEquals(x, VALUE_2, "success weakCompareAndSetRelease $type$");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSetRelease(array, i, VALUE_1, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSetRelease $type$");
+                    $type$ x = ($type$) vh.get(array, i);
+                    assertEquals(x, VALUE_2, "failing weakCompareAndSetRelease $type$ value");
                 }
 
                 {
                     boolean success = false;
                     for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
                         success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_1);
+                        if (!success) weakDelay();
                     }
-                    assertEquals(success, true, "weakCompareAndSet $type$");
+                    assertEquals(success, true, "success weakCompareAndSet $type$");
+                    $type$ x = ($type$) vh.get(array, i);
+                    assertEquals(x, VALUE_1, "success weakCompareAndSet $type$");
+                }
+
+                {
+                    boolean success = vh.weakCompareAndSet(array, i, VALUE_2, VALUE_3);
+                    assertEquals(success, false, "failing weakCompareAndSet $type$");
                     $type$ x = ($type$) vh.get(array, i);
-                    assertEquals(x, VALUE_1, "weakCompareAndSet $type$");
+                    assertEquals(x, VALUE_1, "failing weakCompareAndSet $type$ value");
                 }
 
                 // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/X-VarHandleTestMethodHandleAccess.java.template b/ojluni/src/test/java/lang/invoke/VarHandles/X-VarHandleTestMethodHandleAccess.java.template
index fee66baf226..a593db2401c 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/X-VarHandleTestMethodHandleAccess.java.template
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/X-VarHandleTestMethodHandleAccess.java.template
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,6 +33,7 @@ import org.testng.annotations.BeforeClass;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
+import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
@@ -212,43 +213,79 @@ public class VarHandleTestMethodHandleAccess$Type$ extends VarHandleBaseTest {
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, $value1$, $value2$);
+                success = (boolean) mh.invokeExact(recv, $value1$, $value2$);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain $type$");
+            assertEquals(success, true, "success weakCompareAndSetPlain $type$");
             $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, $value2$, "weakCompareAndSetPlain $type$ value");
+            assertEquals(x, $value2$, "success weakCompareAndSetPlain $type$ value");
         }
 
         {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, $value1$, $value3$);
+            assertEquals(success, false, "failing weakCompareAndSetPlain $type$");
+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, $value2$, "failing weakCompareAndSetPlain $type$ value");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, $value2$, $value1$);
+                success = (boolean) mh.invokeExact(recv, $value2$, $value1$);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire $type$");
+            assertEquals(success, true, "success weakCompareAndSetAcquire $type$");
+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, $value1$, "success weakCompareAndSetAcquire $type$");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, $value2$, $value3$);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire $type$");
             $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, $value1$, "weakCompareAndSetAcquire $type$");
+            assertEquals(x, $value1$, "failing weakCompareAndSetAcquire $type$ value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, $value1$, $value2$);
+                success = (boolean) mh.invokeExact(recv, $value1$, $value2$);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease $type$");
+            assertEquals(success, true, "success weakCompareAndSetRelease $type$");
+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, $value2$, "success weakCompareAndSetRelease $type$");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, $value1$, $value3$);
+            assertEquals(success, false, "failing weakCompareAndSetRelease $type$");
             $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, $value2$, "weakCompareAndSetRelease $type$");
+            assertEquals(x, $value2$, "failing weakCompareAndSetRelease $type$ value");
         }
 
         {
             boolean success = false;
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, $value2$, $value1$);
+                success = (boolean) mh.invokeExact(recv, $value2$, $value1$);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet $type$");
+            assertEquals(success, true, "success weakCompareAndSet $type$");
             $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(recv);
-            assertEquals(x, $value1$, "weakCompareAndSet $type$");
+            assertEquals(x, $value1$, "success weakCompareAndSet $type$");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, $value2$, $value3$);
+            assertEquals(success, false, "failing weakCompareAndSet $type$");
+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(recv);
+            assertEquals(x, $value1$, "failing weakCompareAndSet $type$ value");
         }
 
         // Compare set and get
@@ -507,43 +544,80 @@ public class VarHandleTestMethodHandleAccess$Type$ extends VarHandleBaseTest {
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact($value1$, $value2$);
+                success = (boolean) mh.invokeExact($value1$, $value2$);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetPlain $type$");
+            assertEquals(success, true, "success weakCompareAndSetPlain $type$");
+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, $value2$, "success weakCompareAndSetPlain $type$ value");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact($value1$, $value3$);
+            assertEquals(success, false, "failing weakCompareAndSetPlain $type$");
             $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, $value2$, "weakCompareAndSetPlain $type$ value");
+            assertEquals(x, $value2$, "failing weakCompareAndSetPlain $type$ value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact($value2$, $value1$);
+                success = (boolean) mh.invokeExact($value2$, $value1$);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetAcquire $type$");
+            assertEquals(success, true, "success weakCompareAndSetAcquire $type$");
+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, $value1$, "success weakCompareAndSetAcquire $type$");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
+            boolean success = (boolean) mh.invokeExact($value2$, $value3$);
+            assertEquals(success, false, "failing weakCompareAndSetAcquire $type$");
             $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, $value1$, "weakCompareAndSetAcquire $type$");
+            assertEquals(x, $value1$, "failing weakCompareAndSetAcquire $type$ value");
         }
 
         {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact($value1$, $value2$);
+                success = (boolean) mh.invokeExact($value1$, $value2$);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSetRelease $type$");
+            assertEquals(success, true, "success weakCompareAndSetRelease $type$");
             $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, $value2$, "weakCompareAndSetRelease $type$");
+            assertEquals(x, $value2$, "success weakCompareAndSetRelease $type$");
         }
 
         {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact($value1$, $value3$);
+            assertEquals(success, false, "failing weakCompareAndSetRelease $type$");
+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, $value2$, "failing weakCompareAndSetRelease $type$ value");
+        }
+
+        {
+            MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
             boolean success = false;
             for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact($value2$, $value1$);
+                success = (boolean) mh.invokeExact($value2$, $value1$);
+                if (!success) weakDelay();
             }
-            assertEquals(success, true, "weakCompareAndSet $type$");
+            assertEquals(success, true, "success weakCompareAndSet $type$");
+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact();
+            assertEquals(x, $value1$, "success weakCompareAndSet $type$");
+        }
+
+        {
+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact($value2$, $value3$);
+            assertEquals(success, false, "failing weakCompareAndSet $type$");
             $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact();
-            assertEquals(x, $value1$, "weakCompareAndSet $type$");
+            assertEquals(x, $value1$, "failing weakCompareAndSetRe $type$ value");
         }
 
         // Compare set and get
@@ -827,43 +901,79 @@ public class VarHandleTestMethodHandleAccess$Type$ extends VarHandleBaseTest {
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, $value1$, $value2$);
+                    success = (boolean) mh.invokeExact(array, i, $value1$, $value2$);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetPlain $type$");
+                assertEquals(success, true, "success weakCompareAndSetPlain $type$");
+                $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, $value2$, "success weakCompareAndSetPlain $type$ value");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, $value1$, $value3$);
+                assertEquals(success, false, "failing weakCompareAndSetPlain $type$");
                 $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, $value2$, "weakCompareAndSetPlain $type$ value");
+                assertEquals(x, $value2$, "failing weakCompareAndSetPlain $type$ value");
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, $value2$, $value1$);
+                    success = (boolean) mh.invokeExact(array, i, $value2$, $value1$);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetAcquire $type$");
+                assertEquals(success, true, "success weakCompareAndSetAcquire $type$");
                 $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, $value1$, "weakCompareAndSetAcquire $type$");
+                assertEquals(x, $value1$, "success weakCompareAndSetAcquire $type$");
             }
 
             {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, $value2$, $value3$);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire $type$");
+                $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, $value1$, "failing weakCompareAndSetAcquire $type$ value");
+            }
+
+            {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(array, i, $value1$, $value2$);
+                    success = (boolean) mh.invokeExact(array, i, $value1$, $value2$);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSetRelease $type$");
+                assertEquals(success, true, "success weakCompareAndSetRelease $type$");
+                $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, $value2$, "success weakCompareAndSetRelease $type$");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, $value1$, $value3$);
+                assertEquals(success, false, "failing weakCompareAndSetAcquire $type$");
                 $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, $value2$, "weakCompareAndSetRelease $type$");
+                assertEquals(x, $value2$, "failing weakCompareAndSetAcquire $type$ value");
             }
 
             {
+                MethodHandle mh = hs.get(TestAccessMode.WEAK_COMPARE_AND_SET);
                 boolean success = false;
                 for (int c = 0; c < WEAK_ATTEMPTS && !success; c++) {
-                    success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, $value2$, $value1$);
+                    success = (boolean) mh.invokeExact(array, i, $value2$, $value1$);
+                    if (!success) weakDelay();
                 }
-                assertEquals(success, true, "weakCompareAndSet $type$");
+                assertEquals(success, true, "success weakCompareAndSet $type$");
+                $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(array, i);
+                assertEquals(x, $value1$, "success weakCompareAndSet $type$");
+            }
+
+            {
+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, $value2$, $value3$);
+                assertEquals(success, false, "failing weakCompareAndSet $type$");
                 $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(array, i);
-                assertEquals(x, $value1$, "weakCompareAndSet $type$");
+                assertEquals(x, $value1$, "failing weakCompareAndSet $type$ value");
             }
 
             // Compare set and get
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/accessibility/TestFieldLookupAccessibility.java b/ojluni/src/test/java/lang/invoke/VarHandles/accessibility/TestFieldLookupAccessibility.java
index 29759a9e4b7..78ef695624b 100644
--- a/ojluni/src/test/java/lang/invoke/VarHandles/accessibility/TestFieldLookupAccessibility.java
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/accessibility/TestFieldLookupAccessibility.java
@@ -52,6 +52,21 @@ import java.util.stream.Stream;
 
 public class TestFieldLookupAccessibility {
 
+    // BEGIN Android-added: in certain cases static final can be modified in ART
+    private static final boolean STATIC_FINALS_ARE_UNMODIFIABLE;
+
+    static {
+        boolean isUnmodifiable;
+        try {
+            isUnmodifiable = TestFieldLookupAccessibility.class.getDeclaredField("STATIC_FINALS_ARE_UNMODIFIABLE").isMonotonic();
+        } catch (Exception e) {
+            // This means code runs in hotspot.
+            isUnmodifiable = true;
+        }
+        STATIC_FINALS_ARE_UNMODIFIABLE = isUnmodifiable;
+    }
+    // END Android-added: in certain cases static final can be modified in ART
+
     // The set of possible field lookup mechanisms
     enum FieldLookup {
         MH_GETTER() {
@@ -99,6 +114,12 @@ public class TestFieldLookupAccessibility {
             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
                 return l.unreflectGetter(cloneAndSetAccessible(f));
             }
+
+            // Setting the accessibility bit of a Field grants access under
+            // all conditions for MethodHandle getters.
+            Set<String> inaccessibleFields(Set<String> inaccessibleFields) {
+                return new HashSet<>();
+            }
         },
         MH_UNREFLECT_SETTER() {
             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
@@ -106,13 +127,29 @@ public class TestFieldLookupAccessibility {
             }
 
             boolean isAccessible(Field f) {
-                return f.isAccessible() || !Modifier.isFinal(f.getModifiers());
+                return f.isAccessible() && !Modifier.isStatic(f.getModifiers()) || !Modifier.isFinal(f.getModifiers());
             }
         },
         MH_UNREFLECT_SETTER_ACCESSIBLE() {
             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
                 return l.unreflectSetter(cloneAndSetAccessible(f));
             }
+
+            boolean isAccessible(Field f) {
+                // Android-changed: check whether static final fields are modifiable.
+                return !(STATIC_FINALS_ARE_UNMODIFIABLE && Modifier.isStatic(f.getModifiers()) && Modifier.isFinal(f.getModifiers()));
+            }
+
+            // Setting the accessibility bit of a Field grants access to non-static
+            // final fields for MethodHandle setters.
+            Set<String> inaccessibleFields(Set<String>inaccessibleFields) {
+                Set<String> result = new HashSet<>();
+                inaccessibleFields.stream()
+                        // Android-changed: check whether static final fields are modifiable.
+                        .filter(f -> (STATIC_FINALS_ARE_UNMODIFIABLE && f.contains("static") && f.contains("final")))
+                        .forEach(result::add);
+                return result;
+            }
         },
         VH() {
             Object lookup(MethodHandles.Lookup l, Field f) throws Exception {
@@ -145,6 +182,10 @@ public class TestFieldLookupAccessibility {
             return true;
         }
 
+        Set<String> inaccessibleFields(Set<String> inaccessibleFields) {
+            return new HashSet<>(inaccessibleFields);
+        }
+
         static Field cloneAndSetAccessible(Field f) throws Exception {
             // Clone to avoid mutating source field
             f = f.getDeclaringClass().getDeclaredField(f.getName());
@@ -183,7 +224,7 @@ public class TestFieldLookupAccessibility {
     @Test(dataProvider = "lookupProvider")
     public void test(FieldLookup fl, Class<?> src, MethodHandles.Lookup l, Set<String> inaccessibleFields) {
         // Add to the expected failures all inaccessible fields due to accessibility modifiers
-        Set<String> expected = new HashSet<>(inaccessibleFields);
+        Set<String> expected = fl.inaccessibleFields(inaccessibleFields);
         Map<Field, Throwable> actual = new HashMap<>();
 
         for (Field f : fields(src)) {
@@ -205,12 +246,7 @@ public class TestFieldLookupAccessibility {
                 collect(Collectors.toSet());
         if (!actualFieldNames.equals(expected)) {
             if (actualFieldNames.isEmpty()) {
-                // Setting the accessibility bit of a Field grants access under
-                // all conditions for MethodHander getters and setters
-                if (fl != FieldLookup.MH_UNREFLECT_GETTER_ACCESSIBLE &&
-                    fl != FieldLookup.MH_UNREFLECT_SETTER_ACCESSIBLE) {
-                    Assert.assertEquals(actualFieldNames, expected, "No accessibility failures:");
-                }
+                Assert.assertEquals(actualFieldNames, expected, "No accessibility failures:");
             }
             else {
                 Assert.assertEquals(actualFieldNames, expected, "Accessibility failures differ:");
diff --git a/ojluni/src/test/java/lang/invoke/VarHandles/generate-vh-tests.sh b/ojluni/src/test/java/lang/invoke/VarHandles/generate-vh-tests.sh
old mode 100644
new mode 100755
index d3b41978080..d6b51d2d502
--- a/ojluni/src/test/java/lang/invoke/VarHandles/generate-vh-tests.sh
+++ b/ojluni/src/test/java/lang/invoke/VarHandles/generate-vh-tests.sh
@@ -84,9 +84,15 @@ do
   args="$args -Dvalue1=$value1 -Dvalue2=$value2 -Dvalue3=$value3 -Dwrong_primitive_type=$wrong_primitive_type"
 
   echo $args
-  java $SPP -nel $args < X-VarHandleTestAccess.java.template > VarHandleTestAccess${Type}.java
-  java $SPP -nel $args < X-VarHandleTestMethodHandleAccess.java.template > VarHandleTestMethodHandleAccess${Type}.java
-  java $SPP -nel $args < X-VarHandleTestMethodType.java.template > VarHandleTestMethodType${Type}.java
+  out=VarHandleTestAccess${Type}.java
+  rm -f $out
+  java $SPP -nel $args -iX-VarHandleTestAccess.java.template -o$out
+  out=VarHandleTestMethodHandleAccess${Type}.java
+  rm -f $out
+  java $SPP -nel $args -iX-VarHandleTestMethodHandleAccess.java.template -o$out
+  out=VarHandleTestMethodType${Type}.java
+  rm -f $out
+  java $SPP -nel $args -iX-VarHandleTestMethodType.java.template -o$out
 done
 
 for type in short char int long float double
@@ -163,7 +169,9 @@ do
   args="$args -Dvalue1=$value1 -Dvalue2=$value2 -Dvalue3=$value3"
 
   echo $args
-  java $SPP -nel $args < X-VarHandleTestByteArrayView.java.template > VarHandleTestByteArrayAs${Type}.java
+  out=VarHandleTestByteArrayAs${Type}.java
+  rm -f $out
+  java $SPP -nel $args -iX-VarHandleTestByteArrayView.java.template -o$out
 done
 
 rm -fr build
diff --git a/ojluni/src/test/java/math/BigDecimal/SerializationTests.java b/ojluni/src/test/java/math/BigDecimal/SerializationTests.java
index d6b6499cd34..33b0e3ac689 100644
--- a/ojluni/src/test/java/math/BigDecimal/SerializationTests.java
+++ b/ojluni/src/test/java/math/BigDecimal/SerializationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,13 +24,13 @@ package test.java.math.BigDecimal;
 
 /*
  * @test
- * @bug 6177836
+ * @bug 6177836 8282252
  * @summary Verify BigDecimal objects with collapsed values are serialized properly.
- * @author Joseph D. Darcy
  */
 
 import java.math.*;
 import java.io.*;
+import java.util.List;
 
 import org.testng.Assert;
 import org.testng.annotations.Test;
@@ -38,43 +38,128 @@ import org.testng.annotations.Test;
 // Android-changed: Replace error counting with asserts.
 public class SerializationTests {
 
-    static void checkSerialForm(BigDecimal bd) throws Exception {
+    // Android-removed: Use TestNg.
+    /*
+    public static void main(String... args) throws Exception {
+        checkBigDecimalSerialRoundTrip();
+        checkBigDecimalSubSerialRoundTrip();
+    }
+    */
+
+    private static void checkSerialForm(BigDecimal bd) throws Exception  {
+        checkSerialForm0(bd);
+        checkSerialForm0(bd.negate());
+    }
+
+    private static void checkSerialForm0(BigDecimal bd) throws Exception  {
         ByteArrayOutputStream bos = new ByteArrayOutputStream();
-        ObjectOutputStream oos = new ObjectOutputStream(bos);
-        oos.writeObject(bd);
-        oos.flush();
-        oos.close();
+        try(ObjectOutputStream oos = new ObjectOutputStream(bos)) {
+            oos.writeObject(bd);
+            oos.flush();
+        }
+
         ObjectInputStream ois = new
             ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));
         BigDecimal tmp = (BigDecimal)ois.readObject();
 
-        if (!bd.equals(tmp) || bd.hashCode() != tmp.hashCode()) {
+
+        if (!bd.equals(tmp) ||
+            bd.hashCode() != tmp.hashCode() ||
+            bd.getClass() != tmp.getClass() ||
+            // Directly test equality of components
+            bd.scale() != tmp.scale() ||
+            !bd.unscaledValue().equals(tmp.unscaledValue())) {
+            //System.err.print("  original : " + bd);
+            //System.err.println(" (hash: 0x" + Integer.toHexString(bd.hashCode()) + ")");
+            //System.err.print("serialized : " + tmp);
+            //System.err.println(" (hash: 0x" + Integer.toHexString(tmp.hashCode()) + ")");
+            //throw new RuntimeException("Bad serial roundtrip");
             Assert.fail("  original : " + bd +
-                " (hash: 0x" + Integer.toHexString(bd.hashCode()) + ")" +
-                " serialized : " + tmp +
-                " (hash: 0x" + Integer.toHexString(tmp.hashCode()) + ")");
+                    " (hash: 0x" + Integer.toHexString(bd.hashCode()) + ")" +
+                    " serialized : " + tmp +
+                    " (hash: 0x" + Integer.toHexString(tmp.hashCode()) + ")");
+        }
+
+        // If the class of the deserialized number is BigDecimal,
+        // verify the implementation constraint on the unscaled value
+        // having BigInteger class
+        if (tmp.getClass() == BigDecimal.class) {
+            if (tmp.unscaledValue().getClass() != BigInteger.class) {
+                throw new RuntimeException("Not using genuine BigInteger as an unscaled value");
+            }
+        }
+    }
+
+    private static class BigIntegerSub extends BigInteger {
+        public BigIntegerSub(BigInteger bi) {
+            super(bi.toByteArray());
+        }
+
+        @Override
+        public String toString() {
+            return java.util.Arrays.toString(toByteArray());
         }
     }
 
     @Test
-    public void testSerialization() throws Exception {
-        BigDecimal values[] = {
-            BigDecimal.ZERO,
-            BigDecimal.ONE,
-            BigDecimal.TEN,
-            new BigDecimal(0),
-            new BigDecimal(1),
-            new BigDecimal(10),
-            new BigDecimal(Integer.MAX_VALUE),
-            new BigDecimal(Long.MAX_VALUE-1),
-            new BigDecimal(BigInteger.valueOf(1), 1),
-            new BigDecimal(BigInteger.valueOf(100), 50),
-        };
+    public static void checkBigDecimalSerialRoundTrip() throws Exception {
+        var values =
+            List.of(BigDecimal.ZERO,
+                    BigDecimal.ONE,
+                    BigDecimal.TEN,
+                    new BigDecimal(0),
+                    new BigDecimal(1),
+                    new BigDecimal(10),
+                    new BigDecimal(Integer.MAX_VALUE),
+                    new BigDecimal(Long.MAX_VALUE-1),
+                    new BigDecimal(BigInteger.valueOf(1), 1),
+                    new BigDecimal(BigInteger.valueOf(100), 50),
+                    new BigDecimal(new BigInteger("9223372036854775808"), // Long.MAX_VALUE + 1
+                                   Integer.MAX_VALUE),
+                    new BigDecimal(new BigInteger("9223372036854775808"), // Long.MAX_VALUE + 1
+                                   Integer.MIN_VALUE),
+                    new BigDecimal(new BigIntegerSub(BigInteger.ONE), 2));
 
         for(BigDecimal value : values) {
             checkSerialForm(value);
-            checkSerialForm(value.negate());
         }
+    }
+
+    private static class BigDecimalSub extends BigDecimal {
+        public BigDecimalSub(BigDecimal bd) {
+            super(bd.unscaledValue(), bd.scale());
+        }
+
+        @Override
+        public String toString() {
+            return unscaledValue() + "x10^" + (-scale());
+        }
+    }
+
+    // Subclass defining a serialVersionUID
+    private static class BigDecimalSubSVUID extends BigDecimal {
+        private static long serialVesionUID = 0x0123_4567_89ab_cdefL;
 
+        public BigDecimalSubSVUID(BigDecimal bd) {
+            super(bd.unscaledValue(), bd.scale());
+        }
+    }
+
+    @Test
+    public static void checkBigDecimalSubSerialRoundTrip() throws Exception {
+        var values =
+            List.of(BigDecimal.ZERO,
+                    BigDecimal.ONE,
+                    BigDecimal.TEN,
+                    new BigDecimal(BigInteger.TEN, 1234),
+                    new BigDecimal(new BigInteger("9223372036854775808"), // Long.MAX_VALUE + 1
+                                   Integer.MAX_VALUE),
+                    new BigDecimal(new BigInteger("9223372036854775808"), // Long.MAX_VALUE + 1
+                                   Integer.MIN_VALUE));
+
+        for(var value : values) {
+            checkSerialForm(new BigDecimalSub(value));
+            checkSerialForm(new BigDecimalSubSVUID(value));
+        }
     }
 }
diff --git a/ojluni/src/test/java/math/BigInteger/BigIntegerTest.java b/ojluni/src/test/java/math/BigInteger/BigIntegerTest.java
index f74a19aef42..9c97b4f4da2 100644
--- a/ojluni/src/test/java/math/BigInteger/BigIntegerTest.java
+++ b/ojluni/src/test/java/math/BigInteger/BigIntegerTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -981,6 +981,7 @@ public class BigIntegerTest {
         }
     }
 
+
     private static final int ORDER_1 = ORDER_MEDIUM;
     private static final int ORDER_2 = ORDER_SMALL;
     private static final int ORDER_3 = ORDER_KARATSUBA;
@@ -1126,6 +1127,100 @@ public class BigIntegerTest {
         multiplyLarge();
     }
 
+    // Android-removed: Split main into smaller test cases.
+    /*
+    /**
+     * Main to interpret arguments and run several tests.
+     *
+     * Up to three arguments may be given to specify the SIZE of BigIntegers
+     * used for call parameters 1, 2, and 3. The SIZE is interpreted as
+     * the maximum number of decimal digits that the parameters will have.
+     *
+     * /
+    public static void main(String[] args) throws Exception {
+        // subset zero indicates to run all subsets
+        int subset = Integer.valueOf(System.getProperty("subset",
+            String.valueOf(1 + random.nextInt(3))));
+        if (subset < 0 || subset > 3) {
+            throw new RuntimeException("Unknown subset " + subset);
+        }
+        if (subset == 0)
+            System.out.println("Testing all subsets");
+        else
+            System.out.println("Testing subset " + subset);
+
+        // Some variables for sizing test numbers in bits
+        int order1 = ORDER_MEDIUM;
+        int order2 = ORDER_SMALL;
+        int order3 = ORDER_KARATSUBA;
+        int order4 = ORDER_TOOM_COOK;
+
+        if (args.length >0)
+            order1 = (int)((Integer.parseInt(args[0]))* 3.333);
+        if (args.length >1)
+            order2 = (int)((Integer.parseInt(args[1]))* 3.333);
+        if (args.length >2)
+            order3 = (int)((Integer.parseInt(args[2]))* 3.333);
+        if (args.length >3)
+            order4 = (int)((Integer.parseInt(args[3]))* 3.333);
+
+        if (subset == 0 || subset == 1) {
+            constructor();
+
+            prime();
+            nextProbablePrime();
+
+            arithmetic(order1);   // small numbers
+            arithmetic(order3);   // Karatsuba range
+            arithmetic(order4);   // Toom-Cook / Burnikel-Ziegler range
+
+            divideAndRemainder(order1);   // small numbers
+            divideAndRemainder(order3);   // Karatsuba range
+            divideAndRemainder(order4);   // Toom-Cook / Burnikel-Ziegler range
+
+            pow(order1);
+            pow(order3);
+            pow(order4);
+
+            square(ORDER_MEDIUM);
+            square(ORDER_KARATSUBA_SQUARE);
+            square(ORDER_TOOM_COOK_SQUARE);
+
+            squareRoot();
+            squareRootAndRemainder();
+
+            bitCount();
+            bitLength();
+            bitOps(order1);
+            bitwise(order1);
+
+            shift(order1);
+
+            byteArrayConv(order1);
+
+            modInv(order1);   // small numbers
+            modInv(order3);   // Karatsuba range
+        }
+        if (subset == 0 || subset == 2) {
+            modInv(order4);   // Toom-Cook / Burnikel-Ziegler range
+
+            modExp(order1, order2);
+            modExp2(order1);
+        }
+        if (subset == 0 || subset == 3) {
+            stringConv();
+            serialize();
+
+            multiplyLarge();
+            squareLarge();
+            divideLarge();
+        }
+
+        if (failure)
+            throw new RuntimeException("Failure in BigIntegerTest.");
+    }
+    */
+
     @Test
     public void testSquareLarge() {
         squareLarge();
diff --git a/ojluni/src/test/java/math/BigInteger/LargeValueExceptions.java b/ojluni/src/test/java/math/BigInteger/LargeValueExceptions.java
index efa988c970e..ef978828e00 100644
--- a/ojluni/src/test/java/math/BigInteger/LargeValueExceptions.java
+++ b/ojluni/src/test/java/math/BigInteger/LargeValueExceptions.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -32,6 +32,8 @@ package test.java.math.BigInteger;
 
 import java.math.BigInteger;
 import static java.math.BigInteger.ONE;
+import org.testng.ITestResult;
+import org.testng.annotations.AfterMethod;
 import org.testng.annotations.Test;
 
 //
@@ -64,6 +66,13 @@ public class LargeValueExceptions {
     // Half BigInteger.MAX_MAG_LENGTH
     private static final int MAX_INTS_HALF = MAX_INTS / 2;
 
+    // Print the run time of each sub-test in milliseconds
+    @AfterMethod
+    public void getRunTime(ITestResult tr) {
+        long time = tr.getEndMillis() - tr.getStartMillis();
+        System.out.printf("Run time: %d ms%n", time);
+    }
+
     // --- squaring ---
 
     // Largest no overflow determined by examining data lengths alone.
diff --git a/ojluni/src/test/java/nio/Buffer/BulkPutBuffer.java b/ojluni/src/test/java/nio/Buffer/BulkPutBuffer.java
index 3bf6fe8ed09..2af97b8567d 100644
--- a/ojluni/src/test/java/nio/Buffer/BulkPutBuffer.java
+++ b/ojluni/src/test/java/nio/Buffer/BulkPutBuffer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -55,8 +55,8 @@ import org.testng.annotations.Test;
  * @test
  * @bug 8219014 8245121
  * @summary Ensure that a bulk put of a buffer into another is correct.
- * @compile --enable-preview -source ${jdk.version} BulkPutBuffer.java
- * @run testng/othervm --enable-preview BulkPutBuffer
+ * @compile BulkPutBuffer.java
+ * @run testng/othervm BulkPutBuffer
  */
 public class BulkPutBuffer {
     static final long SEED = System.nanoTime();
diff --git a/ojluni/src/test/java/nio/channels/SelectionKey/AtomicUpdates.java b/ojluni/src/test/java/nio/channels/SelectionKey/AtomicUpdates.java
index c25f585c7c6..277a0002ad0 100644
--- a/ojluni/src/test/java/nio/channels/SelectionKey/AtomicUpdates.java
+++ b/ojluni/src/test/java/nio/channels/SelectionKey/AtomicUpdates.java
@@ -4,9 +4,7 @@
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
+ * published by the Free Software Foundation.
  *
  * This code is distributed in the hope that it will be useful, but WITHOUT
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
diff --git a/ojluni/src/test/java/nio/file/Files/ReadWriteString.java b/ojluni/src/test/java/nio/file/Files/ReadWriteString.java
new file mode 100644
index 00000000000..3b0ec21e7fe
--- /dev/null
+++ b/ojluni/src/test/java/nio/file/Files/ReadWriteString.java
@@ -0,0 +1,367 @@
+/*
+ * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package test.java.nio.file.Files;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.nio.charset.CharacterCodingException;
+import java.nio.charset.Charset;
+import java.nio.charset.MalformedInputException;
+import java.nio.charset.UnmappableCharacterException;
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static java.nio.charset.StandardCharsets.ISO_8859_1;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import java.nio.file.Files;
+import java.nio.file.OpenOption;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import static java.nio.file.StandardOpenOption.APPEND;
+import static java.nio.file.StandardOpenOption.CREATE;
+import java.util.Arrays;
+import java.util.Random;
+import java.util.concurrent.Callable;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+
+import org.testng.SkipException;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.DataProvider;
+import org.testng.annotations.Test;
+
+/* @test
+ * @bug 8201276 8205058 8209576
+ * @build ReadWriteString PassThroughFileSystem
+ * @run testng ReadWriteString
+ * @summary Unit test for methods for Files readString and write methods.
+ * @key randomness
+ */
+@Test(groups = "readwrite")
+public class ReadWriteString {
+
+    // data for text files
+    final String TEXT_UNICODE = "\u201CHello\u201D";
+    final String TEXT_ASCII = "ABCDEFGHIJKLMNOPQRSTUVWXYZ\n abcdefghijklmnopqrstuvwxyz\n 1234567890\n";
+    private static final String JA_STRING = "\u65e5\u672c\u8a9e\u6587\u5b57\u5217";
+
+    // malformed input: a high surrogate without the low surrogate
+    static char[] illChars = {
+        '\u00fa', '\ud800'
+    };
+
+    static byte[] data = getData();
+
+    static byte[] getData() {
+        try {
+            String str1 = "A string that contains ";
+            String str2 = " , an invalid character for UTF-8.";
+
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            baos.write(str1.getBytes());
+            baos.write(0xFA);
+            baos.write(str2.getBytes());
+            return baos.toByteArray();
+        } catch (IOException ex) {
+            // in case it happens, fail the test
+            throw new RuntimeException(ex);
+        }
+    }
+
+    // file used by testReadWrite, testReadString and testWriteString
+    private Path[] testFiles = new Path[3];
+
+    // Android-changed: Ignore the test when the API flag is off.
+    @BeforeMethod
+    public void beforeMethod() {
+        try {
+            if (!com.android.libcore.Flags.openjdk21V2Apis()) {
+                throw new SkipException("Skipping test: "
+                        + com.android.libcore.Flags.FLAG_OPENJDK_21_V2_APIS + " flag is off.");
+            }
+        } catch (NoSuchMethodError e) {
+            System.logE("flag isn't found.", e);
+            // Continue running tests as if the flag value was true, because in this case
+            // it's likely that the APIs have been fully published and the flag has been removed.
+            // Ideally, we should use the exported / test version of java_aconfig_library to read
+            // the flag from the aconfig flag storage via frameworks, but ART test infra can't have
+            // direct dependency on frameworks. We will need to add an abstraction or indirect
+            // dependency to support both CTS infra and ART test infra.
+        }
+    }
+
+    /*
+     * DataProvider for malformed write test. Provides the following fields:
+     * file path, malformed input string, charset
+     */
+    @DataProvider(name = "malformedWrite")
+    public Object[][] getMalformedWrite() throws IOException {
+        Path path = Files.createTempFile("malformedWrite", null);
+        return new Object[][]{
+            {path, "\ud800", null},  //the default Charset is UTF_8
+            {path, "\u00A0\u00A1", US_ASCII},
+            {path, "\ud800", UTF_8},
+            {path, JA_STRING, ISO_8859_1},
+        };
+    }
+
+    /*
+     * DataProvider for illegal input test
+     * Writes the data in ISO8859 and reads with UTF_8, expects MalformedInputException
+     */
+    @DataProvider(name = "illegalInput")
+    public Object[][] getIllegalInput() throws IOException {
+        Path path = Files.createTempFile("illegalInput", null);
+        return new Object[][]{
+            {path, data, ISO_8859_1, null},
+            {path, data, ISO_8859_1, UTF_8}
+        };
+    }
+
+    /*
+     * DataProvider for writeString test
+     * Writes the data using both the existing and new method and compares the results.
+     */
+    @DataProvider(name = "testWriteString")
+    public Object[][] getWriteString() throws IOException {
+
+        return new Object[][]{
+            {testFiles[1], testFiles[2], TEXT_ASCII, US_ASCII, null},
+            {testFiles[1], testFiles[2], TEXT_ASCII, US_ASCII, US_ASCII},
+            {testFiles[1], testFiles[2], TEXT_UNICODE, UTF_8, null},
+            {testFiles[1], testFiles[2], TEXT_UNICODE, UTF_8, UTF_8}
+        };
+    }
+
+    /*
+     * DataProvider for readString test
+     * Reads the file using both the existing and new method and compares the results.
+     */
+    @DataProvider(name = "testReadString")
+    public Object[][] getReadString() throws IOException {
+        Path path = Files.createTempFile("readString_file1", null);
+        return new Object[][]{
+            {testFiles[1], TEXT_ASCII, US_ASCII, US_ASCII},
+            {testFiles[1], TEXT_ASCII, US_ASCII, UTF_8},
+            {testFiles[1], TEXT_UNICODE, UTF_8, null},
+            {testFiles[1], TEXT_UNICODE, UTF_8, UTF_8}
+        };
+    }
+
+    @BeforeClass
+    void setup() throws IOException {
+        testFiles[0] = Files.createTempFile("readWriteString", null);
+        testFiles[1] = Files.createTempFile("writeString_file1", null);
+        testFiles[2] = Files.createTempFile("writeString_file2", null);
+    }
+
+    @AfterClass
+    void cleanup() throws IOException {
+        for (Path path : testFiles) {
+            Files.deleteIfExists(path);
+        }
+    }
+
+    /**
+     * Verifies that NPE is thrown when one of the parameters is null.
+     */
+    @Test
+    public void testNulls() {
+        Path path = Paths.get("foo");
+        String s = "abc";
+
+        checkNullPointerException(() -> Files.readString((Path) null));
+        checkNullPointerException(() -> Files.readString((Path) null, UTF_8));
+        checkNullPointerException(() -> Files.readString(path, (Charset) null));
+
+        checkNullPointerException(() -> Files.writeString((Path) null, s, CREATE));
+        checkNullPointerException(() -> Files.writeString(path, (CharSequence) null, CREATE));
+        checkNullPointerException(() -> Files.writeString(path, s, (OpenOption[]) null));
+
+        checkNullPointerException(() -> Files.writeString((Path) null, s, UTF_8, CREATE));
+        checkNullPointerException(() -> Files.writeString(path, (CharSequence) null, UTF_8, CREATE));
+        checkNullPointerException(() -> Files.writeString(path, s, (Charset) null, CREATE));
+        checkNullPointerException(() -> Files.writeString(path, s, UTF_8, (OpenOption[]) null));
+    }
+
+    /**
+     * Verifies the readString and write String methods. Writes to files Strings
+     * of various sizes, with/without specifying the Charset, and then compares
+     * the result of reading the files.
+     */
+    @Test
+    public void testReadWrite() throws IOException {
+        int size = 0;
+        while (size < 16 * 1024) {
+            testReadWrite(size, null, false);
+            testReadWrite(size, null, true);
+            testReadWrite(size, UTF_8, false);
+            testReadWrite(size, UTF_8, true);
+            size += 1024;
+        }
+    }
+
+    /**
+     * Verifies fix for @bug 8209576 that the writeString method converts the
+     * bytes properly.
+     * This method compares the results written by the existing write method and
+     * the writeString method added since 11.
+     */
+    @Test(dataProvider = "testWriteString")
+    public void testWriteString(Path path, Path path2, String text, Charset cs, Charset cs2) throws IOException {
+        Files.write(path, text.getBytes(cs));
+
+        // writeString @since 11
+        if (cs2 == null) {
+            Files.writeString(path2, text);
+        } else {
+            Files.writeString(path2, text, cs2);
+        }
+        byte[] bytes = Files.readAllBytes(path);
+        byte[] bytes2 = Files.readAllBytes(path2);
+        assertTrue((Arrays.compare(bytes, bytes2) == 0), "The bytes should be the same");
+    }
+
+    /**
+     * Verifies that the readString method added since 11 behaves the same as
+     * constructing a string from the existing readAllBytes method.
+     */
+    @Test(dataProvider = "testReadString")
+    public void testReadString(Path path, String text, Charset cs, Charset cs2) throws IOException {
+        Files.write(path, text.getBytes(cs));
+        String str = new String(Files.readAllBytes(path), cs);
+
+        // readString @since 11
+        String str2 = (cs2 == null) ? Files.readString(path) :
+                                      Files.readString(path, cs2);
+        assertTrue((str.equals(str2)), "The strings should be the same");
+    }
+
+    /**
+     * Verifies that IOException is thrown (as specified) when giving a malformed
+     * string input.
+     *
+     * @param path the path to write
+     * @param s the string
+     * @param cs the Charset
+     * @throws IOException if the input is malformed
+     */
+    // Android-changed: ICU encoder throws MalformedInputException for a single \ud800 surrogate,
+    // because the input isn't a legal UTF-16 sequence.
+    //@Test(dataProvider = "malformedWrite", expectedExceptions = UnmappableCharacterException.class)
+    @Test(dataProvider = "malformedWrite", expectedExceptions = CharacterCodingException.class)
+    public void testMalformedWrite(Path path, String s, Charset cs) throws IOException {
+        path.toFile().deleteOnExit();
+        if (cs == null) {
+            Files.writeString(path, s, CREATE);
+        } else {
+            Files.writeString(path, s, cs, CREATE);
+        }
+    }
+
+    /**
+     * Verifies that IOException is thrown when reading a file using the wrong
+     * Charset.
+     *
+     * @param path the path to write and read
+     * @param data the data used for the test
+     * @param csWrite the Charset to use for writing the test file
+     * @param csRead the Charset to use for reading the file
+     * @throws IOException when the Charset used for reading the file is incorrect
+     */
+    @Test(dataProvider = "illegalInput", expectedExceptions = MalformedInputException.class)
+    public void testMalformedRead(Path path, byte[] data, Charset csWrite, Charset csRead) throws IOException {
+        path.toFile().deleteOnExit();
+        String temp = new String(data, csWrite);
+        Files.writeString(path, temp, csWrite, CREATE);
+        String s;
+        if (csRead == null) {
+            s = Files.readString(path);
+        } else {
+            s = Files.readString(path, csRead);
+        }
+    }
+
+    private void checkNullPointerException(Callable<?> c) {
+        try {
+            c.call();
+            fail("NullPointerException expected");
+        } catch (NullPointerException ignore) {
+        } catch (Exception e) {
+            fail(e + " not expected");
+        }
+    }
+
+    private void testReadWrite(int size, Charset cs, boolean append) throws IOException {
+        String expected;
+        String str = generateString(size);
+        Path result;
+        if (cs == null) {
+            result = Files.writeString(testFiles[0], str);
+        } else {
+            result = Files.writeString(testFiles[0], str, cs);
+        }
+
+        //System.out.println(result.toUri().toASCIIString());
+        assertTrue(result == testFiles[0]);
+        if (append) {
+            if (cs == null) {
+                Files.writeString(testFiles[0], str, APPEND);
+            } else {
+                Files.writeString(testFiles[0], str, cs, APPEND);
+            }
+            assertTrue(Files.size(testFiles[0]) == size * 2);
+        }
+
+
+        if (append) {
+            expected = str + str;
+        } else {
+            expected = str;
+        }
+
+        String read;
+        if (cs == null) {
+            read = Files.readString(result);
+        } else {
+            read = Files.readString(result, cs);
+        }
+
+        assertTrue(read.equals(expected), "String read not the same as written");
+    }
+
+    static final char[] CHARS = "abcdefghijklmnopqrstuvwxyz \r\n".toCharArray();
+    StringBuilder sb = new StringBuilder(1024 << 4);
+    Random random = new Random();
+
+    private String generateString(int size) {
+        sb.setLength(0);
+        for (int i = 0; i < size; i++) {
+            char c = CHARS[random.nextInt(CHARS.length)];
+            sb.append(c);
+        }
+
+        return sb.toString();
+    }
+}
diff --git a/ojluni/src/test/java/time/test/java/time/chrono/TestJapaneseChronoImpl.java b/ojluni/src/test/java/time/test/java/time/chrono/TestJapaneseChronoImpl.java
index 359d9c01bd0..41031743573 100644
--- a/ojluni/src/test/java/time/test/java/time/chrono/TestJapaneseChronoImpl.java
+++ b/ojluni/src/test/java/time/test/java/time/chrono/TestJapaneseChronoImpl.java
@@ -58,6 +58,7 @@ package test.java.time.chrono;
 
 import static org.testng.Assert.assertEquals;
 
+import android.platform.test.annotations.FlakyTest;
 import android.platform.test.annotations.LargeTest;
 
 import java.time.LocalDate;
@@ -127,6 +128,9 @@ public class TestJapaneseChronoImpl {
     // Verify  Japanese Calendar matches java.util.Calendar for number of days
     // in years 1 and 2.
     //-----------------------------------------------------------------------
+    @FlakyTest(bugId = 407732066, detail = "jd.get(ChronoField.DAY_OF_YEAR) return 2 when the test "
+            + "is flaky. However, this test isn't valid on Android, because "
+            + "Android's Calendar.getInstance doesn't support Japanese calendar.")
     @Test
     public void test_dayOfYearVsCalendar() {
         Locale locale = Locale.forLanguageTag("ja-JP-u-ca-japanese");
diff --git a/ojluni/src/test/java/time/test/java/time/format/TestZoneTextPrinterParser.java b/ojluni/src/test/java/time/test/java/time/format/TestZoneTextPrinterParser.java
index 9d0afb6cc5e..52872c9df5e 100644
--- a/ojluni/src/test/java/time/test/java/time/format/TestZoneTextPrinterParser.java
+++ b/ojluni/src/test/java/time/test/java/time/format/TestZoneTextPrinterParser.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2022, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -51,7 +51,7 @@ import org.testng.annotations.Test;
 
 /*
  * @test
- * @bug 8081022 8151876 8166875 8189784 8206980
+ * @bug 8081022 8151876 8166875 8189784 8206980 8278434
  * @key randomness
  */
 
@@ -61,6 +61,11 @@ import org.testng.annotations.Test;
 @Test
 public class TestZoneTextPrinterParser extends AbstractTestPrinterParser {
 
+    private static final Locale[] SAMPLE_LOCALES = {
+        Locale.US, Locale.UK, Locale.FRANCE, Locale.GERMANY, Locale.ITALY, Locale.forLanguageTag("es"),
+        Locale.forLanguageTag("pt-BR"), Locale.forLanguageTag("ru"),
+        Locale.CHINA, Locale.TAIWAN, Locale.JAPAN, Locale.KOREA, Locale.ROOT};
+
     protected static DateTimeFormatter getFormatter(Locale locale, TextStyle style) {
         return new DateTimeFormatterBuilder().appendZoneText(style)
                                              .toFormatter(locale)
@@ -71,8 +76,8 @@ public class TestZoneTextPrinterParser extends AbstractTestPrinterParser {
     public void test_printText() {
         Random r = RandomFactory.getRandom();
         // Android-changed: only run one iteration.
+        // int N = 8;
         int N = 1;
-        Locale[] locales = Locale.getAvailableLocales();
         Set<String> zids = ZoneRulesProvider.getAvailableZoneIds();
         ZonedDateTime zdt = ZonedDateTime.now();
 
@@ -90,8 +95,7 @@ public class TestZoneTextPrinterParser extends AbstractTestPrinterParser {
                 zdt = zdt.withZoneSameLocal(ZoneId.of(zid));
                 TimeZone tz = TimeZone.getTimeZone(zid);
                 boolean isDST = tz.inDaylightTime(new Date(zdt.toInstant().toEpochMilli()));
-                for (Locale locale : locales) {
-                    boolean isDST = tz.inDaylightTime(new Date(zdt.toInstant().toEpochMilli()));
+                for (Locale locale : SAMPLE_LOCALES) {
                     String longDisplayName = tz.getDisplayName(isDST, TimeZone.LONG, locale);
                     String shortDisplayName = tz.getDisplayName(isDST, TimeZone.SHORT, locale);
                     if ((longDisplayName.startsWith("GMT+") && shortDisplayName.startsWith("GMT+"))
@@ -101,7 +105,7 @@ public class TestZoneTextPrinterParser extends AbstractTestPrinterParser {
                         continue;
                     }
              */
-            for (Locale locale : locales) {
+            for (Locale locale : SAMPLE_LOCALES) {
                 // Android-changed: "ji" isn't correctly aliased to "yi", see http//b/8634320.
                 if (locale.getLanguage().equals("ji")) {
                     continue;
@@ -166,9 +170,8 @@ public class TestZoneTextPrinterParser extends AbstractTestPrinterParser {
     // Android-changed: disable test as it doesn't assert anything and produces a lot of output.
     @Test(enabled = false)
     public void test_ParseText() {
-        Locale[] locales = new Locale[] { Locale.ENGLISH, Locale.JAPANESE, Locale.FRENCH };
         Set<String> zids = ZoneRulesProvider.getAvailableZoneIds();
-        for (Locale locale : locales) {
+        for (Locale locale : SAMPLE_LOCALES) {
             parseText(zids, locale, TextStyle.FULL, false);
             parseText(zids, locale, TextStyle.FULL, true);
             parseText(zids, locale, TextStyle.SHORT, false);
diff --git a/ojluni/src/test/java/util/Random/RandomTestBsi1999.java b/ojluni/src/test/java/util/Random/RandomTestBsi1999.java
index 71232fca27d..b9c2603a2cb 100644
--- a/ojluni/src/test/java/util/Random/RandomTestBsi1999.java
+++ b/ojluni/src/test/java/util/Random/RandomTestBsi1999.java
@@ -45,9 +45,9 @@ import static java.util.stream.Collectors.toSet;
 
 /**
  * @test
- * @summary test bit sequences produced by clases that implement interface RandomGenerator
+ * @summary test bit sequences produced by classes that implement interface RandomGenerator
  * @bug 8248862
- * @run main RandomTestBsi1999
+ * @run main/othervm/timeout=400 RandomTestBsi1999
  * @key randomness
  */
 
diff --git a/ojluni/src/test/java/util/Scanner/ScanTest.java b/ojluni/src/test/java/util/Scanner/ScanTest.java
index b9900936440..2cc5b346906 100644
--- a/ojluni/src/test/java/util/Scanner/ScanTest.java
+++ b/ojluni/src/test/java/util/Scanner/ScanTest.java
@@ -1666,10 +1666,20 @@ public class ScanTest {
     }
 
     static Scanner scannerFor(String input, int sourceType) {
-        if (sourceType == 1)
-            return new Scanner(input);
-        else
-            return new Scanner(new StutteringInputStream(input));
+        // Android-changed: Use Locale.US to ensure consistent parsing of decimal numbers.
+        // if (sourceType == 1)
+        //     return new Scanner(input);
+        // else
+        //     return new Scanner(new StutteringInputStream(input));
+        if (sourceType == 1) {
+            Scanner scanner = new Scanner(input);
+            scanner.useLocale(Locale.US);
+            return scanner;
+        } else {
+            Scanner scanner = new Scanner(new StutteringInputStream(input));
+            scanner.useLocale(Locale.US);
+            return scanner;
+        }
     }
 
     static class ThrowingReadable implements Readable {
diff --git a/ojluni/src/test/java/util/Timer/Args.java b/ojluni/src/test/java/util/Timer/Args.java
index f2d13e165ae..07c7b5ee631 100644
--- a/ojluni/src/test/java/util/Timer/Args.java
+++ b/ojluni/src/test/java/util/Timer/Args.java
@@ -31,6 +31,10 @@ package test.java.util.Timer;
 
 import java.util.*;
 import java.util.concurrent.*;
+
+import libcore.test.annotation.NonCts;
+import libcore.test.reasons.NonCtsReasons;
+
 import static java.util.concurrent.TimeUnit.*;
 
 public class Args {
@@ -183,6 +187,8 @@ elapsed));
     void equal(Object x, Object y) {
         if (x == null ? y == null : x.equals(y)) pass();
         else fail(x + " not equal to " + y);}
+    // Android-added: Timer's behaviour depends on ART Module version (see aosp/3316792).
+    @NonCts(bug = 415048615, reason = NonCtsReasons.NON_BREAKING_BEHAVIOR_FIX)
     public static void main(String[] args) throws Throwable {
         new Args().instanceMain(args);}
     void instanceMain(String[] args) throws Throwable {
diff --git a/ojluni/src/test/java/util/UUID/UUIDTest.java b/ojluni/src/test/java/util/UUID/UUIDTest.java
index b44db95c11b..260b3c32e30 100644
--- a/ojluni/src/test/java/util/UUID/UUIDTest.java
+++ b/ojluni/src/test/java/util/UUID/UUIDTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -22,24 +22,32 @@
  */
 
 /* @test
- * @bug 4173528 5068772 8148936 8196334
+ * @bug 4173528 5068772 8148936 8196334 8308803
  * @summary Unit tests for java.util.UUID
  * @key randomness
- * @run main/othervm -XX:+CompactStrings UUIDTest
- * @run main/othervm -XX:-CompactStrings UUIDTest
+ * @library /test/lib
+ * @build jdk.test.lib.RandomFactory
+ * @run main/othervm -Xmx1g -XX:+CompactStrings UUIDTest
+ * @run main/othervm -Xmx1g -XX:-CompactStrings UUIDTest
  */
 
 package test.java.util.UUID;
 
 import java.util.*;
+import java.util.stream.IntStream;
+import jdk.test.lib.RandomFactory;
 
 public class UUIDTest {
 
-    static Random generator = new Random();
+    // Single UUID instance is ~32 bytes, 1M instances take ~256M in the set
+    private static final int COUNT = 1_000_000;
+
+    static final Random generator = RandomFactory.getRandom();
 
     public static void main(String[] args) throws Exception {
-        containsTest();
+        negativeTest();
         randomUUIDTest();
+        randomUUIDTest_Multi();
         nameUUIDFromBytesTest();
         stringTest();
         versionTest();
@@ -51,56 +59,103 @@ public class UUIDTest {
         compareTo();
     }
 
-    // Verify that list.contains detects UUID collisons
-    private static void containsTest() throws Exception {
-        List list = new LinkedList();
-        list.add(new UUID(4,4));
-        if (!list.contains(new UUID(4,4)))
-            throw new Exception("contains test did not work as expected");
+    private static void negativeTest() throws Exception {
+        Set<UUID> set = new HashSet<>();
+        set.add(new UUID(4, 4));
+        if (set.add(new UUID(4, 4))) {
+            throw new Exception("Contains test does not work as expected");
+        }
     }
 
     private static void randomUUIDTest() throws Exception {
-        List list = new LinkedList();
-        for (int i=0; i<100; i++) {
-            UUID u1 = UUID.randomUUID();
-            if (4 != u1.version()) {
-                throw new Exception("bad version");
+        List<UUID> collisions = new ArrayList<>();
+
+        Set<UUID> set = new HashSet<>();
+        for (int i = 0; i < COUNT; i++) {
+            UUID u = UUID.randomUUID();
+            if (u.version() != 4) {
+                throw new Exception("Bad version: " + u);
+            }
+            if (u.variant() != 2) {
+                throw new Exception("Bad variant: " + u);
+            }
+            if (!set.add(u)) {
+                collisions.add(u);
+            }
+        }
+
+        if (!collisions.isEmpty()) {
+           // This is extremely unlikely to happen. If you see this failure,
+           // this highly likely points to the implementation bug, rather than
+           // the odd chance.
+           throw new Exception("UUID collisions detected: " + collisions);
+        }
+    }
+
+    private static void randomUUIDTest_Multi() throws Exception {
+        List<UUID> uuids = IntStream.range(0, COUNT).parallel()
+                                    .mapToObj(i -> UUID.randomUUID())
+                                    .toList();
+
+        List<UUID> collisions = new ArrayList<>();
+
+        Set<UUID> set = new HashSet<>();
+        for (UUID u : uuids) {
+            if (u.version() != 4) {
+                throw new Exception("Bad version: " + u);
+            }
+            if (u.variant() != 2) {
+                throw new Exception("Bad variant: " + u);
             }
-            if (2 != u1.variant()) {
-                throw new Exception("bad variant");
+            if (!set.add(u)) {
+                collisions.add(u);
             }
-            if (list.contains(u1))
-                throw new Exception("random UUID collision very unlikely");
-            list.add(u1);
+        }
+
+        if (!collisions.isEmpty()) {
+           // This is extremely unlikely to happen. If you see this failure,
+           // this highly likely points to the implementation bug, rather than
+           // the odd chance.
+           throw new Exception("UUID collisions detected: " + collisions);
         }
     }
 
+
     private static void nameUUIDFromBytesTest() throws Exception {
-        Random byteSource = new Random();
+        List<UUID> collisions = new ArrayList<>();
+
         byte[] someBytes = new byte[12];
-        List list = new LinkedList();
-        for (int i=0; i<100; i++) {
-            byteSource.nextBytes(someBytes);
-            UUID u1 = UUID.nameUUIDFromBytes(someBytes);
-            if (3 != u1.version()) {
-                throw new Exception("bad version");
+        Set<UUID> set = new HashSet<>();
+        for (int i = 0; i < COUNT; i++) {
+            generator.nextBytes(someBytes);
+            UUID u = UUID.nameUUIDFromBytes(someBytes);
+            if (u.version() != 3) {
+                throw new Exception("Bad version: " + u);
+            }
+            if (u.variant() != 2) {
+                throw new Exception("Bad variant: " + u);
             }
-            if (2 != u1.variant()) {
-                throw new Exception("bad variant");
+            if (!set.add(u)) {
+                collisions.add(u);
             }
-            if (list.contains(u1))
-                throw new Exception("byte UUID collision very unlikely");
-            list.add(u1);
+        }
+
+        if (!collisions.isEmpty()) {
+           // This is extremely unlikely to happen. If you see this failure,
+           // this highly likely points to the implementation bug, rather than
+           // the odd chance.
+           throw new Exception("UUID collisions detected: " + collisions);
         }
     }
 
     private static void stringTest() throws Exception {
-        for (int i=0; i<100; i++) {
+        for (int i = 0; i < COUNT; i++) {
             UUID u1 = UUID.randomUUID();
             UUID u2 = UUID.fromString(u1.toString().toLowerCase());
             UUID u3 = UUID.fromString(u1.toString().toUpperCase());
-            if (!u1.equals(u2) || !u1.equals(u3))
-                throw new Exception("UUID -> string -> UUID failed");
+            if (!u1.equals(u2) || !u1.equals(u3)) {
+                throw new Exception("UUID -> string -> UUID failed: " + u1 + " -> " + u2 + " -> " + u3);
+            }
         }
 
         testFromStringError("-0");
@@ -125,62 +180,90 @@ public class UUIDTest {
 
     private static void versionTest() throws Exception {
         UUID test = UUID.randomUUID();
-        if (test.version() != 4)
-            throw new Exception("randomUUID not type 4");
-        Random byteSource = new Random();
+        if (test.version() != 4) {
+            throw new Exception("randomUUID not type 4: " + test);
+        }
+
         byte[] someBytes = new byte[12];
-        byteSource.nextBytes(someBytes);
+        generator.nextBytes(someBytes);
         test = UUID.nameUUIDFromBytes(someBytes);
-        if (test.version() != 3)
-            throw new Exception("nameUUIDFromBytes not type 3");
+        if (test.version() != 3) {
+            throw new Exception("nameUUIDFromBytes not type 3: " + test);
+        }
+
         test = UUID.fromString("9835451d-e2e0-1e41-8a5a-be785f17dcda");
-        if (test.version() != 1)
+        if (test.version() != 1) {
             throw new Exception("wrong version fromString 1");
+        }
+
         test = UUID.fromString("9835451d-e2e0-2e41-8a5a-be785f17dcda");
-        if (test.version() != 2)
+        if (test.version() != 2) {
             throw new Exception("wrong version fromString 2");
+        }
+
         test = UUID.fromString("9835451d-e2e0-3e41-8a5a-be785f17dcda");
-        if (test.version() != 3)
+        if (test.version() != 3) {
             throw new Exception("wrong version fromString 3");
+        }
+
         test = UUID.fromString("9835451d-e2e0-4e41-8a5a-be785f17dcda");
-        if (test.version() != 4)
+        if (test.version() != 4) {
             throw new Exception("wrong version fromString 4");
+        }
+
         test = new UUID(0x0000000000001000L, 55L);
-        if (test.version() != 1)
+        if (test.version() != 1) {
             throw new Exception("wrong version from bit set to 1");
+        }
+
         test = new UUID(0x0000000000002000L, 55L);
-        if (test.version() != 2)
+        if (test.version() != 2) {
             throw new Exception("wrong version from bit set to 2");
+        }
+
         test = new UUID(0x0000000000003000L, 55L);
-        if (test.version() != 3)
+        if (test.version() != 3) {
             throw new Exception("wrong version from bit set to 3");
+        }
+
         test = new UUID(0x0000000000004000L, 55L);
-        if (test.version() != 4)
+        if (test.version() != 4) {
             throw new Exception("wrong version from bit set to 4");
+        }
     }
 
     private static void variantTest() throws Exception {
         UUID test = UUID.randomUUID();
-        if (test.variant() != 2)
+        if (test.variant() != 2) {
             throw new Exception("randomUUID not variant 2");
-        Random byteSource = new Random();
+        }
+
         byte[] someBytes = new byte[12];
-        byteSource.nextBytes(someBytes);
+        generator.nextBytes(someBytes);
         test = UUID.nameUUIDFromBytes(someBytes);
-        if (test.variant() != 2)
+        if (test.variant() != 2) {
             throw new Exception("nameUUIDFromBytes not variant 2");
+        }
+
         test = new UUID(55L, 0x0000000000001000L);
-        if (test.variant() != 0)
+        if (test.variant() != 0) {
             throw new Exception("wrong variant from bit set to 0");
+        }
+
         test = new UUID(55L, 0x8000000000001000L);
-        if (test.variant() != 2)
+        if (test.variant() != 2) {
             throw new Exception("wrong variant from bit set to 2");
-       test = new UUID(55L, 0xc000000000001000L);
-        if (test.variant() != 6)
+        }
+
+        test = new UUID(55L, 0xc000000000001000L);
+        if (test.variant() != 6) {
             throw new Exception("wrong variant from bit set to 6");
-       test = new UUID(55L, 0xe000000000001000L);
-        if (test.variant() != 7)
+        }
+
+        test = new UUID(55L, 0xe000000000001000L);
+        if (test.variant() != 7) {
             throw new Exception("wrong variant from bit set to 7");
+        }
     }
 
     private static void timestampTest() throws Exception {
@@ -191,15 +274,21 @@ public class UUIDTest {
         } catch (UnsupportedOperationException uoe) {
             // Correct result
         }
+
         test = UUID.fromString("00000001-0000-1000-8a5a-be785f17dcda");
-        if (test.timestamp() != 1)
+        if (test.timestamp() != 1) {
             throw new Exception("Incorrect timestamp");
+        }
+
         test = UUID.fromString("00000400-0000-1000-8a5a-be785f17dcda");
-        if (test.timestamp() != 1024)
+        if (test.timestamp() != 1024) {
             throw new Exception("Incorrect timestamp");
+        }
+
         test = UUID.fromString("FFFFFFFF-FFFF-1FFF-8a5a-be785f17dcda");
-        if (test.timestamp() != Long.MAX_VALUE>>3)
+        if (test.timestamp() != (Long.MAX_VALUE >> 3)) {
             throw new Exception("Incorrect timestamp");
+        }
     }
 
     private static void clockSequenceTest() throws Exception {
@@ -210,18 +299,26 @@ public class UUIDTest {
         } catch (UnsupportedOperationException uoe) {
             // Correct result
         }
+
         test = UUID.fromString("00000001-0000-1000-8001-be785f17dcda");
-        if (test.clockSequence() != 1)
+        if (test.clockSequence() != 1) {
             throw new Exception("Incorrect sequence");
+        }
+
         test = UUID.fromString("00000001-0000-1000-8002-be785f17dcda");
-        if (test.clockSequence() != 2)
+        if (test.clockSequence() != 2) {
             throw new Exception("Incorrect sequence");
+        }
+
         test = UUID.fromString("00000001-0000-1000-8010-be785f17dcda");
-        if (test.clockSequence() != 16)
+        if (test.clockSequence() != 16) {
             throw new Exception("Incorrect sequence");
+        }
+
         test = UUID.fromString("00000001-0000-1000-bFFF-be785f17dcda");
-        if (test.clockSequence() != ((2L<<13)-1)) // 2^14 - 1
+        if (test.clockSequence() != ((1L << 14) - 1)) {
             throw new Exception("Incorrect sequence");
+        }
     }
 
     private static void nodeTest() throws Exception {
@@ -232,32 +329,40 @@ public class UUIDTest {
         } catch (UnsupportedOperationException uoe) {
             // Correct result
         }
+
         test = UUID.fromString("00000001-0000-1000-8001-000000000001");
-        if (test.node() != 1)
+        if (test.node() != 1) {
             throw new Exception("Incorrect node");
+        }
+
         test = UUID.fromString("00000001-0000-1000-8002-FFFFFFFFFFFF");
-        if (test.node() != ((2L<<47)-1)) // 2^48 - 1
+        if (test.node() != ((1L << 48) - 1)) {
             throw new Exception("Incorrect node");
+        }
     }
 
     private static void hashCodeEqualsTest() throws Exception {
         // If two UUIDs are equal they must have the same hashCode
-        for (int i=0; i<100; i++) {
+        for (int i = 0; i < COUNT; i++) {
             UUID u1 = UUID.randomUUID();
             UUID u2 = UUID.fromString(u1.toString());
-            if (u1.hashCode() != u2.hashCode())
-                throw new Exception("Equal UUIDs with different hashcodes");
+            if (u1.hashCode() != u2.hashCode()) {
+                throw new Exception("Equal UUIDs with different hash codes: " + u1 + "(" + u1.hashCode() + ") " +
+                                    "and " + u2 + "(" + u2.hashCode() + ")");
+            }
         }
+
         // Test equality of UUIDs with tampered bits
-        for (int i=0; i<1000; i++) {
+        for (int i = 0; i < COUNT; i++) {
             long l = generator.nextLong();
             long l2 = generator.nextLong();
             int position = generator.nextInt(64);
             UUID u1 = new UUID(l, l2);
             l = l ^ (1L << position);
             UUID u2 = new UUID(l, l2);
-            if (u1.equals(u2))
-                throw new Exception("UUIDs with different bits equal");
+            if (u1.equals(u2)) {
+                throw new Exception("UUIDs with different bits equal: " + u1 + " and " + u2);
+            }
         }
     }
 
@@ -271,18 +376,20 @@ public class UUIDTest {
         if ((id.compareTo(id2) >= 0) ||
             (id2.compareTo(id3) >= 0) ||
             (id3.compareTo(id4) >= 0) ||
-            (id4.compareTo(id5) >= 0))
+            (id4.compareTo(id5) >= 0)) {
             throw new RuntimeException("compareTo failure");
+        }
 
         if ((id5.compareTo(id4) <= 0) ||
             (id4.compareTo(id3) <= 0) ||
             (id3.compareTo(id2) <= 0) ||
-            (id2.compareTo(id) <= 0))
+            (id2.compareTo(id) <= 0)) {
             throw new RuntimeException("compareTo failure");
+        }
 
-        if (id.compareTo(id) != 0)
+        if (id.compareTo(id) != 0) {
             throw new RuntimeException("compareTo failure");
-
+        }
     }
 
 }
diff --git a/ojluni/src/test/java/util/zip/TestExtraTime.java b/ojluni/src/test/java/util/zip/TestExtraTime.java
index 587d9ea9bc0..e78616b193e 100644
--- a/ojluni/src/test/java/util/zip/TestExtraTime.java
+++ b/ojluni/src/test/java/util/zip/TestExtraTime.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,6 +29,8 @@
  */
 package test.java.util.zip;
 import java.io.*;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
@@ -59,7 +61,15 @@ public class TestExtraTime {
         }
         */
         TimeZone tz = TimeZone.getTimeZone("Asia/Shanghai");
-        for (byte[] extra : new byte[][] { null, new byte[] {1, 2, 3}}) {
+        // A structurally valid extra data example
+        byte[] sampleExtra = new byte[Short.BYTES*3];
+        ByteBuffer.wrap(sampleExtra).order(ByteOrder.LITTLE_ENDIAN)
+                .putShort((short) 123)         // ID:   123
+                .putShort((short) Short.BYTES) // Size: 2
+                .putShort((short) 42);         // Data: Two bytes
+
+        for (byte[] extra : new byte[][] { null, sampleExtra}) {
+
             // ms-dos 1980 epoch problem
             test0(FileTime.from(10, TimeUnit.MILLISECONDS), null, null, null, extra);
             // negative epoch time
diff --git a/openjdk_java_files.bp b/openjdk_java_files.bp
index b8057dee4a8..908ef2a07a8 100644
--- a/openjdk_java_files.bp
+++ b/openjdk_java_files.bp
@@ -483,6 +483,7 @@ filegroup {
         "ojluni/src/main/java/java/nio/file/DirectoryNotEmptyException.java",
         "ojluni/src/main/java/java/nio/file/DirectoryStream.java",
         "ojluni/src/main/java/java/nio/file/FileAlreadyExistsException.java",
+        "ojluni/src/main/java/java/nio/file/FileChannelLinesSpliterator.java",
         "ojluni/src/main/java/java/nio/file/FileStore.java",
         "ojluni/src/main/java/java/nio/file/FileSystem.java",
         "ojluni/src/main/java/java/nio/file/FileSystemAlreadyExistsException.java",
@@ -1511,6 +1512,8 @@ filegroup {
         "ojluni/src/main/java/java/lang/JavaLangAccess.java",
         "ojluni/src/main/java/java/lang/StringLatin1.java",
         "ojluni/src/main/java/java/lang/StringUTF16.java",
+        "ojluni/src/main/java/java/lang/VirtualThread.java",
+        "ojluni/src/main/java/java/lang/WrongThreadException.java",
         // Hide the java.lang.constant APIs until master switches away from Android UDC. b/270028670
         "ojluni/src/main/java/java/lang/invoke/ConstantBootstraps.java",
         "ojluni/src/main/java/java/lang/constant/AsTypeMethodHandleDesc.java",
@@ -1539,6 +1542,11 @@ filegroup {
         "ojluni/src/main/java/java/util/ReverseOrderListView.java",
         "ojluni/src/main/java/java/util/ReverseOrderSortedMapView.java",
         "ojluni/src/main/java/java/util/ReverseOrderSortedSetView.java",
+        "ojluni/src/main/java/java/util/concurrent/StructureViolationException.java",
+        "ojluni/src/main/java/java/util/stream/Gatherer.java",
+        "ojluni/src/main/java/java/util/stream/GathererOp.java",
+        "ojluni/src/main/java/java/util/stream/Gatherers.java",
+        "ojluni/src/main/java/java/util/stream/WhileOps.java",
         "ojluni/src/main/java/jdk/net/ExtendedSocketOptions.java",
         "ojluni/src/main/java/jdk/net/NetworkPermission.java",
         "ojluni/src/main/java/jdk/net/SocketFlow.java",
@@ -1550,12 +1558,17 @@ filegroup {
         "ojluni/src/main/java/jdk/internal/access/JavaUtilCollectionAccess.java",
         "ojluni/src/main/java/jdk/internal/access/SharedSecrets.java",
         "ojluni/src/main/java/jdk/internal/event/Event.java",
+        "ojluni/src/main/java/jdk/internal/event/ThreadSleepEvent.java",
         "ojluni/src/main/java/jdk/internal/event/VirtualThreadEndEvent.java",
         "ojluni/src/main/java/jdk/internal/event/VirtualThreadPinnedEvent.java",
         "ojluni/src/main/java/jdk/internal/event/VirtualThreadStartEvent.java",
         "ojluni/src/main/java/jdk/internal/event/VirtualThreadSubmitFailedEvent.java",
+        "ojluni/src/main/java/jdk/internal/invoke/MhUtil.java",
+        "ojluni/src/main/java/jdk/internal/misc/CarrierThread.java",
+        "ojluni/src/main/java/jdk/internal/misc/CarrierThreadLocal.java",
         "ojluni/src/main/java/jdk/internal/misc/InnocuousThread.java",
         "ojluni/src/main/java/jdk/internal/misc/TerminatingThreadLocal.java",
+        "ojluni/src/main/java/jdk/internal/misc/ThreadTracker.java",
         "ojluni/src/main/java/jdk/internal/misc/Unsafe.java",
         "ojluni/src/main/java/jdk/internal/misc/UnsafeConstants.java",
         "ojluni/src/main/java/jdk/internal/misc/VM.java",
@@ -1566,16 +1579,24 @@ filegroup {
         "ojluni/src/main/java/jdk/internal/ref/PhantomCleanable.java",
         "ojluni/src/main/java/jdk/internal/reflect/CallerSensitive.java",
         "ojluni/src/main/java/jdk/internal/reflect/Reflection.java",
+        "ojluni/src/main/java/jdk/internal/vm/annotation/ChangesCurrentThread.java",
         "ojluni/src/main/java/jdk/internal/vm/annotation/Contended.java",
         "ojluni/src/main/java/jdk/internal/vm/annotation/DontInline.java",
         "ojluni/src/main/java/jdk/internal/vm/annotation/ForceInline.java",
         "ojluni/src/main/java/jdk/internal/vm/annotation/Hidden.java",
         "ojluni/src/main/java/jdk/internal/vm/annotation/IntrinsicCandidate.java",
+        "ojluni/src/main/java/jdk/internal/vm/annotation/JvmtiMountTransition.java",
         "ojluni/src/main/java/jdk/internal/vm/annotation/ReservedStackAccess.java",
         "ojluni/src/main/java/jdk/internal/vm/annotation/Stable.java",
         "ojluni/src/main/java/jdk/internal/vm/Continuation.java",
         "ojluni/src/main/java/jdk/internal/vm/ContinuationScope.java",
+        "ojluni/src/main/java/jdk/internal/vm/ContinuationSupport.java",
+        "ojluni/src/main/java/jdk/internal/vm/SharedThreadContainer.java",
+        "ojluni/src/main/java/jdk/internal/vm/StackableScope.java",
         "ojluni/src/main/java/jdk/internal/vm/StackChunk.java",
+        "ojluni/src/main/java/jdk/internal/vm/ThreadContainer.java",
+        "ojluni/src/main/java/jdk/internal/vm/ThreadContainers.java",
+        "ojluni/src/main/java/jdk/internal/vm/ThreadDumper.java",
         "ojluni/src/main/java/jdk/internal/util/ArraysSupport.java",
         "ojluni/src/main/java/jdk/internal/util/NullableKeyValueHolder.java",
         "ojluni/src/main/java/jdk/internal/util/Preconditions.java",
@@ -1736,7 +1757,6 @@ filegroup {
         "ojluni/src/main/java/sun/nio/fs/AbstractBasicFileAttributeView.java",
         "ojluni/src/main/java/sun/nio/fs/AbstractFileSystemProvider.java",
         "ojluni/src/main/java/sun/nio/fs/AbstractFileTypeDetector.java",
-        "ojluni/src/main/java/sun/nio/fs/AbstractPath.java",
         "ojluni/src/main/java/sun/nio/fs/AbstractPoller.java",
         "ojluni/src/main/java/sun/nio/fs/AbstractUserDefinedFileAttributeView.java",
         "ojluni/src/main/java/sun/nio/fs/AbstractWatchKey.java",
@@ -1746,6 +1766,7 @@ filegroup {
         "ojluni/src/main/java/sun/nio/fs/DefaultFileSystemProvider.java",
         "ojluni/src/main/java/sun/nio/fs/DefaultFileTypeDetector.java",
         "ojluni/src/main/java/sun/nio/fs/DynamicFileAttributeView.java",
+        "ojluni/src/main/java/sun/nio/fs/ExtendedOptions.java",
         "ojluni/src/main/java/sun/nio/fs/FileOwnerAttributeViewImpl.java",
         "ojluni/src/main/java/sun/nio/fs/Globs.java",
         "ojluni/src/main/java/sun/nio/fs/LinuxDosFileAttributeView.java",
diff --git a/support/src/test/java/tests/resources/x509/certs_with_comment.pem b/support/src/test/java/tests/resources/x509/certs_with_comment.pem
new file mode 100644
index 00000000000..a1a7be0ea32
--- /dev/null
+++ b/support/src/test/java/tests/resources/x509/certs_with_comment.pem
@@ -0,0 +1,111 @@
+Comments can be here too
+-----BEGIN CERTIFICATE-----
+MIIEvDCCBCWgAwIBAgIJAL/CeNuylKxCMA0GCSqGSIb3DQEBBQUAMGAxCzAJBgNV
+BAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRIwEAYDVQQHEwlTYW4gTWF0ZW8x
+FzAVBgNVBAoTDkdlbml1cy5jb20gSW5jMQ8wDQYDVQQLEwZOZXRPcHMwHhcNMTMw
+MzA2MDA0MjA2WhcNMjMwMzA0MDA0MjA2WjBgMQswCQYDVQQGEwJVUzETMBEGA1UE
+CBMKQ2FsaWZvcm5pYTESMBAGA1UEBxMJU2FuIE1hdGVvMRcwFQYDVQQKEw5HZW5p
+dXMuY29tIEluYzEPMA0GA1UECxMGTmV0T3BzMIGfMA0GCSqGSIb3DQEBAQUAA4GN
+ADCBiQKBgQCxtuZhs1g1NvAYRkbdyDwNh+KLxc/GWDC+reFz9bO8NDmINjLVoe3P
+u5S1ONXEgpkvSj6v8a9S7FgSShautZd6G1fm6XFB2Nn+eUjN56o86xNHMiEOG+QC
+TRRupAkZaa3W1WEh+zqq2x0X9JlYY/xpDmP3voGC6rOcfnOoyl/fPQIDAQABo4IC
+fDCCAngwCQYDVR0TBAIwADALBgNVHQ8EBAMCBeAwHQYDVR0OBBYEFL8PXLxMk0+9
+UpkmyqlonexUHoq4MIGSBgNVHSMEgYowgYeAFL8PXLxMk0+9UpkmyqlonexUHoq4
+oWSkYjBgMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTESMBAGA1UE
+BxMJU2FuIE1hdGVvMRcwFQYDVQQKEw5HZW5pdXMuY29tIEluYzEPMA0GA1UECxMG
+TmV0T3BzggkAv8J427KUrEIwHgYJYIZIAYb4QgENBBEWD1guNTA5IFVuaXQgVGVz
+dDCBwwYDVR0RBIG7MIG4oA4GAyoDBKAHDAV0ZXN0MYEQeDUwOUBleGFtcGxlLmNv
+bYIQeDUwOS5leGFtcGxlLmNvbaRQME4xCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1B
+d2Vzb21lIER1ZGVzMRcwFQYDVQQLFA7DnGJlciBGcsOuZW5kczEOMAwGA1UEAxQF
+4oiGxpKGJWh0dHA6Ly93d3cuZXhhbXBsZS5jb20vP3E9YXdlc29tZW5lc3OHBMCo
+AAGIAyoDBDCBwwYDVR0SBIG7MIG4oA4GAyoDBKAHDAV0ZXN0MYEQeDUwOUBleGFt
+cGxlLmNvbYIQeDUwOS5leGFtcGxlLmNvbaRQME4xCzAJBgNVBAYTAlVTMRYwFAYD
+VQQKEw1Bd2Vzb21lIER1ZGVzMRcwFQYDVQQLFA7DnGJlciBGcsOuZW5kczEOMAwG
+A1UEAxQF4oiGxpKGJWh0dHA6Ly93d3cuZXhhbXBsZS5jb20vP3E9YXdlc29tZW5l
+c3OHBMCoAAGIAyoDBDANBgkqhkiG9w0BAQUFAAOBgQAaN9rhafhvcIyhXyUVNfPQ
+/TodmSV/2Kr+IgfCjanjUusQxATHnJeMb5HHgd608hmqQODnHUjEk/KMatrxUcxP
+p9HcQTNlBBWTz0Oj60KgAb+xYEi/cBn3Cxubyxo+hgjpLhc1st/vgMQnyXHWa3vj
+FuRD1b7munGaUBNsFi0Bnw==
+-----END CERTIFICATE-----
+niyvbovdklsbdf - njhfbsoe - jfksbe
+-----BEGIN CERTIFICATE-----
+MIIDFzCCAtWgAwIBAgIJAOgj1gF4KHp/MAkGByqGSM44BAMwYDELMAkGA1UEBhMC
+VVMxEzARBgNVBAgTCkNhbGlmb3JuaWExEjAQBgNVBAcTCVNhbiBNYXRlbzEXMBUG
+A1UEChMOR2VuaXVzLmNvbSBJbmMxDzANBgNVBAsTBk5ldE9wczAeFw0xMzAzMDYw
+MDQyMDhaFw0xMzA0MDUwMDQyMDhaMGAxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpD
+YWxpZm9ybmlhMRIwEAYDVQQHEwlTYW4gTWF0ZW8xFzAVBgNVBAoTDkdlbml1cy5j
+b20gSW5jMQ8wDQYDVQQLEwZOZXRPcHMwggG2MIIBKwYHKoZIzjgEATCCAR4CgYEA
+lIUdJlZvKfSUmbe/ZV4WhU09IIzhqRL5jFnw3JiMTCXnxoJhb9K2yXExB5C+jD77
+VvMzYYwyrqLb19LL/LzD+Q2C5rqYL4fWuSgA/LXOv+qJgPnguBWbneyO6v0dlpI/
+mHlTW7R/u5iufF3mvyez+k0nUedV0/NsUSAFTQtGNS0CFQC9y5Dmn2vFE856B/Z7
+cM/x2Bz4twKBgAnY4bcHgl046jAmJ014gUvYTzqdD1ipj7JCfvrSDcvbc9f62Mlq
+DW8l+9LanBTVfTDdjC92g8EUvAF/LS8TAQWpHvSIkL8Tay3eB5mps+NlaShRLpGr
+f74mwqgvFgwuez/ZT3++mX8oXbTnddrdC9PJ3QPGzWjdPSaDauE/wWV0A4GEAAKB
+gBgH7DjvrvKllrDVFg0tZaX5QV7gvZx+xkoYzlnx+WpwmR7Ll+GTZU9EVr9hdQRi
+5iSBqcZAU2qu/a2UtqWlypFfTQFcsUbHZYWuGljW7ZhicNXnEYWksfgxXQ2/DSIM
+wP6r5ajawfkyBRsKaeXC1nzGFBgXczYLJvh+eb61Cw2coxowGDAJBgNVHRMEAjAA
+MAsGA1UdDwQEAwIANzAJBgcqhkjOOAQDAzEAMC4CFQC3cy1MKZcYB0nyAa2uD8F8
+BD+U+gIVAIyXLNTBLfUS1+ctK79IYVHrHFMy
+-----END CERTIFICATE-----
+jhvbhdcaocbvijs
+vhbkjdfrbiujksdjn
+-----BEGIN CERTIFICATE-----
+MIIEvDCCBCWgAwIBAgIJAL/CeNuylKxCMA0GCSqGSIb3DQEBBQUAMGAxCzAJBgNV
+BAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRIwEAYDVQQHEwlTYW4gTWF0ZW8x
+FzAVBgNVBAoTDkdlbml1cy5jb20gSW5jMQ8wDQYDVQQLEwZOZXRPcHMwHhcNMTMw
+MzA2MDA0MjA2WhcNMjMwMzA0MDA0MjA2WjBgMQswCQYDVQQGEwJVUzETMBEGA1UE
+CBMKQ2FsaWZvcm5pYTESMBAGA1UEBxMJU2FuIE1hdGVvMRcwFQYDVQQKEw5HZW5p
+dXMuY29tIEluYzEPMA0GA1UECxMGTmV0T3BzMIGfMA0GCSqGSIb3DQEBAQUAA4GN
+ADCBiQKBgQCxtuZhs1g1NvAYRkbdyDwNh+KLxc/GWDC+reFz9bO8NDmINjLVoe3P
+u5S1ONXEgpkvSj6v8a9S7FgSShautZd6G1fm6XFB2Nn+eUjN56o86xNHMiEOG+QC
+TRRupAkZaa3W1WEh+zqq2x0X9JlYY/xpDmP3voGC6rOcfnOoyl/fPQIDAQABo4IC
+fDCCAngwCQYDVR0TBAIwADALBgNVHQ8EBAMCBeAwHQYDVR0OBBYEFL8PXLxMk0+9
+UpkmyqlonexUHoq4MIGSBgNVHSMEgYowgYeAFL8PXLxMk0+9UpkmyqlonexUHoq4
+oWSkYjBgMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTESMBAGA1UE
+BxMJU2FuIE1hdGVvMRcwFQYDVQQKEw5HZW5pdXMuY29tIEluYzEPMA0GA1UECxMG
+TmV0T3BzggkAv8J427KUrEIwHgYJYIZIAYb4QgENBBEWD1guNTA5IFVuaXQgVGVz
+dDCBwwYDVR0RBIG7MIG4oA4GAyoDBKAHDAV0ZXN0MYEQeDUwOUBleGFtcGxlLmNv
+bYIQeDUwOS5leGFtcGxlLmNvbaRQME4xCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1B
+d2Vzb21lIER1ZGVzMRcwFQYDVQQLFA7DnGJlciBGcsOuZW5kczEOMAwGA1UEAxQF
+4oiGxpKGJWh0dHA6Ly93d3cuZXhhbXBsZS5jb20vP3E9YXdlc29tZW5lc3OHBMCo
+AAGIAyoDBDCBwwYDVR0SBIG7MIG4oA4GAyoDBKAHDAV0ZXN0MYEQeDUwOUBleGFt
+cGxlLmNvbYIQeDUwOS5leGFtcGxlLmNvbaRQME4xCzAJBgNVBAYTAlVTMRYwFAYD
+VQQKEw1Bd2Vzb21lIER1ZGVzMRcwFQYDVQQLFA7DnGJlciBGcsOuZW5kczEOMAwG
+A1UEAxQF4oiGxpKGJWh0dHA6Ly93d3cuZXhhbXBsZS5jb20vP3E9YXdlc29tZW5l
+c3OHBMCoAAGIAyoDBDANBgkqhkiG9w0BAQUFAAOBgQAaN9rhafhvcIyhXyUVNfPQ
+/TodmSV/2Kr+IgfCjanjUusQxATHnJeMb5HHgd608hmqQODnHUjEk/KMatrxUcxP
+p9HcQTNlBBWTz0Oj60KgAb+xYEi/cBn3Cxubyxo+hgjpLhc1st/vgMQnyXHWa3vj
+FuRD1b7munGaUBNsFi0Bnw==
+-----END CERTIFICATE-----
+grgeaf
+One comment
+csijkbvnslvbs
+-----BEGIN CERTIFICATE-----
+MIIEvDCCBCWgAwIBAgIJAL/CeNuylKxCMA0GCSqGSIb3DQEBBQUAMGAxCzAJBgNV
+BAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRIwEAYDVQQHEwlTYW4gTWF0ZW8x
+FzAVBgNVBAoTDkdlbml1cy5jb20gSW5jMQ8wDQYDVQQLEwZOZXRPcHMwHhcNMTMw
+MzA2MDA0MjA2WhcNMjMwMzA0MDA0MjA2WjBgMQswCQYDVQQGEwJVUzETMBEGA1UE
+CBMKQ2FsaWZvcm5pYTESMBAGA1UEBxMJU2FuIE1hdGVvMRcwFQYDVQQKEw5HZW5p
+dXMuY29tIEluYzEPMA0GA1UECxMGTmV0T3BzMIGfMA0GCSqGSIb3DQEBAQUAA4GN
+ADCBiQKBgQCxtuZhs1g1NvAYRkbdyDwNh+KLxc/GWDC+reFz9bO8NDmINjLVoe3P
+u5S1ONXEgpkvSj6v8a9S7FgSShautZd6G1fm6XFB2Nn+eUjN56o86xNHMiEOG+QC
+TRRupAkZaa3W1WEh+zqq2x0X9JlYY/xpDmP3voGC6rOcfnOoyl/fPQIDAQABo4IC
+fDCCAngwCQYDVR0TBAIwADALBgNVHQ8EBAMCBeAwHQYDVR0OBBYEFL8PXLxMk0+9
+UpkmyqlonexUHoq4MIGSBgNVHSMEgYowgYeAFL8PXLxMk0+9UpkmyqlonexUHoq4
+oWSkYjBgMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTESMBAGA1UE
+BxMJU2FuIE1hdGVvMRcwFQYDVQQKEw5HZW5pdXMuY29tIEluYzEPMA0GA1UECxMG
+TmV0T3BzggkAv8J427KUrEIwHgYJYIZIAYb4QgENBBEWD1guNTA5IFVuaXQgVGVz
+dDCBwwYDVR0RBIG7MIG4oA4GAyoDBKAHDAV0ZXN0MYEQeDUwOUBleGFtcGxlLmNv
+bYIQeDUwOS5leGFtcGxlLmNvbaRQME4xCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1B
+d2Vzb21lIER1ZGVzMRcwFQYDVQQLFA7DnGJlciBGcsOuZW5kczEOMAwGA1UEAxQF
+4oiGxpKGJWh0dHA6Ly93d3cuZXhhbXBsZS5jb20vP3E9YXdlc29tZW5lc3OHBMCo
+AAGIAyoDBDCBwwYDVR0SBIG7MIG4oA4GAyoDBKAHDAV0ZXN0MYEQeDUwOUBleGFt
+cGxlLmNvbYIQeDUwOS5leGFtcGxlLmNvbaRQME4xCzAJBgNVBAYTAlVTMRYwFAYD
+VQQKEw1Bd2Vzb21lIER1ZGVzMRcwFQYDVQQLFA7DnGJlciBGcsOuZW5kczEOMAwG
+A1UEAxQF4oiGxpKGJWh0dHA6Ly93d3cuZXhhbXBsZS5jb20vP3E9YXdlc29tZW5l
+c3OHBMCoAAGIAyoDBDANBgkqhkiG9w0BAQUFAAOBgQAaN9rhafhvcIyhXyUVNfPQ
+/TodmSV/2Kr+IgfCjanjUusQxATHnJeMb5HHgd608hmqQODnHUjEk/KMatrxUcxP
+p9HcQTNlBBWTz0Oj60KgAb+xYEi/cBn3Cxubyxo+hgjpLhc1st/vgMQnyXHWa3vj
+FuRD1b7munGaUBNsFi0Bnw==
+-----END CERTIFICATE-----
+sckjdbvsj
\ No newline at end of file
diff --git a/tools/expected_upstream/README.md b/tools/expected_upstream/README.md
index 712e8d6e555..40fa6f42a1b 100644
--- a/tools/expected_upstream/README.md
+++ b/tools/expected_upstream/README.md
@@ -9,7 +9,7 @@ the right documentation.
 -----------B----------D----------   main
 ```
 
-The general idea is to get a change from OpenJDK into libcore in AOSP by
+The general idea is to get a change from OpenJDK into libcore by
 `git merge` from an OpenJDK branch. However, each file in `ojluni/` can come
 from a different OpenJDK version. `expected_upstream` is a staging branch
 storing the OpenJDK version of each file. Thus, we can use `git merge` when
@@ -22,7 +22,7 @@ automatically merge the file if no merge conflict.
 * python3
 * python3-git
   * Install it via `apt install python3-git`
-* A remote `aosp` is setup in your local git repository
+* A remote `goog` is setup in your local git repository
 
 ## 1. Setup
 ```shell
@@ -85,15 +85,15 @@ the change with the following commands
 
 ```shell
 # Upload the original upstream files to the expected_upstream branch
-$ git push aosp HEAD^2:refs/for/expected_upstream
+$ git push goog HEAD^2:refs/for/expected_upstream
 # Upload the merge commit to the main branch
 $ repo upload --cbr .
 ```
 
 # Directory Layout
-in the `aosp/expected_upstream` branch.
+in the `goog/expected_upstream` branch.
 1. `ojluni/`
-    * It has the same layout as the ojluni/ files in `aosp/main`
+    * It has the same layout as the ojluni/ files in `goog/main`
 2. `EXPECTED_UPSTREAM` file
     * The table has 3 columns, i.e.
         1. Destination path in `ojluni/`
@@ -105,17 +105,17 @@ in the `aosp/expected_upstream` branch.
 
 # Understanding your change
 
-## Changes that should be made via the `aosp/expected_upstream` branch
+## Changes that should be made via the `goog/expected_upstream` branch
 1. Add or upgrade a file from the upstream OpenJDK
     * You are reading the right document! This documentation tells you how to
       import the file from the upstream. Later, you can merge the file and
-      `expected_upstream` into `aosp/main` branch.
+      `expected_upstream` into `goog/main` branch.
 2. Remove an `ojluni/` file that originally came from the OpenJDK
-    * Please remove the file on both `aosp/main` and `aosp/expected_upstream`
+    * Please remove the file on both `goog/main` and `goog/expected_upstream`
       branches. Don't forget to remove the entry in the `EXPECTED_UPSTREAM` too.
-3. Revert the merge commit on `aosp/main` from `expected_upstream`
-    * If you don't plan to re-land your change on `aosp/main`, you should
-      probably revert the change `aosp/expected_upstream` as well.
+3. Revert the merge commit on `goog/main` from `expected_upstream`
+    * If you don't plan to re-land your change on `goog/main`, you should
+      probably revert the change `goog/expected_upstream` as well.
     * If you plan to re-land your change, your re-landing commit won't be
       a merge commit, because `git` doesn't allow you to merge the same commit
       twice into the same branch. You have 2 options
@@ -123,27 +123,27 @@ in the `aosp/expected_upstream` branch.
           when you reland your change
         2. Just accept that the re-landing commit won't be a merge commit.
 
-## Changes that shouldn't happen in the `aosp/expected_upstream` branch
+## Changes that shouldn't happen in the `goog/expected_upstream` branch
 In general, if you want to change an `ojluni/` file by a text editor / IDE
-manually, you should make the change on `aosp/main`.
+manually, you should make the change on `goog/main`.
 
 1. Changes to non-OpenJDK files
     * Those files are usually under the `luni/` folder, you can make the change
-      directly on `aosp/main`
+      directly on `goog/main`
 2. Adding / updating a patch to an existing `ojluni/` file
-    * You can make the change directly on `aosp/main`. Please follow this
+    * You can make the change directly on `goog/main`. Please follow this
       [patch style guideline](https://goto.google.com/libcore-openjdk8-verify).
 3. Cherry-picking a commit from upstream
     * You should first try to update an `ojluni/` file to a particular upstream
       version. If you can't but still want to cherry-pick a upstream fix, you
-      should do so on the `aosp/main` branch.
+      should do so on the `goog/main` branch.
 4. Changes to non-OpenJDK files in `ojluni/`
     * Files, e.g. Android.bp, don't come from the upstream. You can make the
-      change directly on `aosp/main`.
+      change directly on `goog/main`.
 
 
 
-# [Only relevant if using `ojluni_refresh_files`] Submit your change in [AOSP gerrit](http://r.android.com/)
+# [Only relevant if using `ojluni_refresh_files`] Submit your change in gerrit
 ```text
 ----11.0.13-ga----------------   openjdk/jdk11u
          \
@@ -202,7 +202,7 @@ Typically, you will need 5 CLs
 * `repo upload` may not succeed because gerrit returns error.
     1. Just try to run `repo upload` again!
         * The initial upload takes a long time because it tries to sync with the
-          remote AOSP gerrit server. The second upload is much faster because
+          remote gerrit server. The second upload is much faster because
           the `git` objects have been uploaded.
     2. `repo upload` returns TimeOutException, but the CL has been uploaded.
        Just find your CL in http://r.android.com/. See http://b/202848945
@@ -224,4 +224,4 @@ Typically, you will need 5 CLs
 
 # Report bugs
 * Report bugs if the git repository is corrupted!
-    * Sometimes, you can recover the repository by running `git reset aosp/expected_upstream`
+    * Sometimes, you can recover the repository by running `git reset goog/expected_upstream`
diff --git a/tools/expected_upstream/common_util.py b/tools/expected_upstream/common_util.py
index 987136689e2..88160659e10 100644
--- a/tools/expected_upstream/common_util.py
+++ b/tools/expected_upstream/common_util.py
@@ -37,6 +37,16 @@ except ModuleNotFoundError:
 THIS_DIR = Path(__file__).resolve().parent
 LIBCORE_DIR = THIS_DIR.parent.parent.resolve()
 
+AUTOCOMPLETE_TAGS = [
+    'jdk21u/jdk-21.0.6-ga',
+    'jdk17u/jdk-17.0.14-ga',
+    'jdk11u/jdk-11.0.26-ga',
+    'jdk9/jdk-9+181',
+    'jdk8u/jdk8u121-b13',
+    'jdk8u/jdk8u60-b31',
+    'jdk7u/jdk7u40-b60',
+]
+
 UPSTREAM_CLASS_PATHS = [
     'jdk/src/share/classes/',
     'src/java.base/share/classes/',
diff --git a/tools/expected_upstream/install_tools.sh b/tools/expected_upstream/install_tools.sh
index 24f57cf79f2..d3f02b7a7b3 100755
--- a/tools/expected_upstream/install_tools.sh
+++ b/tools/expected_upstream/install_tools.sh
@@ -3,16 +3,16 @@
 THIS_DIR=$(realpath $(dirname ${BASH_SOURCE[0]:-$0}))
 
 pushd ${THIS_DIR}
-git fetch aosp main
-git fetch aosp expected_upstream
+git fetch goog main
+git fetch goog expected_upstream
 # -t option to fetch tags used in the EXPECTED_UPSTREAM file
-git fetch -t aosp upstream-openjdk7u
-git fetch -t aosp upstream-openjdk8u
-git fetch -t aosp upstream-openjdk9
-git fetch -t aosp upstream-openjdk11u
-git fetch -t aosp upstream-openjdk17u
-git fetch -t aosp upstream-openjdk21u
-git fetch -t aosp upstream-openjdk
+git fetch -t goog upstream-openjdk7u
+git fetch -t goog upstream-openjdk8u
+git fetch -t goog upstream-openjdk9
+git fetch -t goog upstream-openjdk11u
+git fetch -t goog upstream-openjdk17u
+git fetch -t goog upstream-openjdk21u
+git fetch -t goog upstream-openjdk
 popd
 
 alias ojluni_refresh_files=${THIS_DIR}/ojluni_refresh_files.py
diff --git a/tools/expected_upstream/ojluni_merge_package.sh b/tools/expected_upstream/ojluni_merge_package.sh
index 1f8477d22fa..53c038df7e9 100755
--- a/tools/expected_upstream/ojluni_merge_package.sh
+++ b/tools/expected_upstream/ojluni_merge_package.sh
@@ -1,14 +1,10 @@
 #!/bin/bash
 
 SELF=$(basename "${0}")
-DEFAULT_TAG="jdk21u/jdk-21.0.2-ga"
-SUPPORTED_TAGS="jdk7u/jdk7u40-b60"
-SUPPORTED_TAGS="${SUPPORTED_TAGS} jdk8u/jdk8u121-b13"
-SUPPORTED_TAGS="${SUPPORTED_TAGS} jdk8u/jdk8u60-b31"
-SUPPORTED_TAGS="${SUPPORTED_TAGS} jdk9/jdk-9+181"
-SUPPORTED_TAGS="${SUPPORTED_TAGS} jdk11u/jdk-11.0.22-ga"
-SUPPORTED_TAGS="${SUPPORTED_TAGS} jdk17u/jdk-17.0.10-ga"
-SUPPORTED_TAGS="${SUPPORTED_TAGS} jdk21u/jdk-21.0.2-ga"
+DIR=$(dirname "${0}")
+
+SUPPORTED_TAGS=$("${DIR}/ojluni_print_autocomplete_jdk_versions.py")
+DEFAULT_TAG=$(echo "${SUPPORTED_TAGS}" | cut -d ' ' -f1)
 
 
 USAGE=$(cat << EndOfUsage
@@ -204,7 +200,7 @@ function ojluni-merge-package
   done
 
   local version_id=$(echo "${version}" | grep -oE "^[^/]+")
-  local branch="aosp/upstream-open${version_id}"
+  local branch="goog/upstream-open${version_id}"
   local new_classes=$(git diff --name-only --diff-filter=D "${branch}" -- \
     "src/java.base/share/classes/${package_path}" \
     "ojluni/src/main/java/${package_path}")
diff --git a/tools/expected_upstream/ojluni_merge_to_main.py b/tools/expected_upstream/ojluni_merge_to_main.py
index 9f39787ebb2..b9b9d2519a3 100755
--- a/tools/expected_upstream/ojluni_merge_to_main.py
+++ b/tools/expected_upstream/ojluni_merge_to_main.py
@@ -97,7 +97,7 @@ MSG_FIRST_COMMIT = ("Import {summary}\n"
                     "{change_id_str}")
 
 MSG_SECOND_COMMIT = ("Merge {summary} into the "
-                     "aosp/main branch\n"
+                     "goog/main branch\n"
                      "\n"
                      "List of files:\n"
                      "  {files}\n"
@@ -332,8 +332,8 @@ def get_diff_entries(repo: Repo, base_expected_commit: Commit) -> Tuple[
     a list of entries
   """
   current_tracking_branch = repo.active_branch.tracking_branch()
-  if current_tracking_branch.name != "aosp/main":
-    print("This script should only run on aosp/main branch. "
+  if current_tracking_branch.name != "goog/main":
+    print("This script should only run on goog/main branch. "
           f"Currently, this is on branch {repo.active_branch} "
           f"tracking {current_tracking_branch}", file=sys.stderr)
     return INVALID_DIFF
@@ -457,7 +457,7 @@ def main_run(
       bug_id = extract_bug_id(last_expected_commit)
   else:
     if expected_upstream_base is None:
-      expected_upstream_base = "aosp/expected_upstream"
+      expected_upstream_base = "goog/expected_upstream"
     try:
       base_expected_branch_commit = repo.commit(expected_upstream_base)
     finally:
@@ -486,7 +486,7 @@ def main_run(
   master_head = repo.active_branch
   branch_name = create_random_branch_name()
   new_branch = repo.create_head(branch_name, base_expected_branch_commit.hexsha)
-  new_branch.set_tracking_branch(repo.remotes.aosp.refs.expected_upstream)
+  new_branch.set_tracking_branch(repo.remotes.goog.refs.expected_upstream)
   new_branch = create_commit_at_expected_upstream(
       repo, new_branch, diff_entries, removed_paths, bug_id,
       last_expected_change_id, discard_working_tree)
diff --git a/tools/expected_upstream/ojluni_modify_expectation.py b/tools/expected_upstream/ojluni_modify_expectation.py
index 0c93c633bb2..839fba29435 100755
--- a/tools/expected_upstream/ojluni_modify_expectation.py
+++ b/tools/expected_upstream/ojluni_modify_expectation.py
@@ -28,6 +28,7 @@ from typing import (
 from common_util import (
     ExpectedUpstreamEntry,
     ExpectedUpstreamFile,
+    AUTOCOMPLETE_TAGS,
     LIBCORE_DIR,
     OpenjdkFinder,
     OjluniFinder,
@@ -40,16 +41,6 @@ from gitdb.exc import BadName
 
 LIBCORE_REPO = Repo(LIBCORE_DIR.as_posix())
 
-AUTOCOMPLETE_TAGS = [
-    'jdk7u/jdk7u40-b60',
-    'jdk8u/jdk8u121-b13',
-    'jdk8u/jdk8u60-b31',
-    'jdk9/jdk-9+181',
-    'jdk11u/jdk-11.0.22-ga',
-    'jdk17u/jdk-17.0.10-ga',
-    'jdk21u/jdk-21.0.4-ga',
-]
-
 
 def error_and_exit(msg: str) -> None:
   print(f'Error: {msg}', file=sys.stderr)
@@ -271,4 +262,8 @@ def main(argv: Sequence[str]) -> None:
 
 
 if __name__ == '__main__':
-  main(sys.argv[1:])
+  try:
+    main(sys.argv[1:])
+  finally:
+    # Avoid ImportError when __del__ runs during python3 shutdown. b/409528854
+    LIBCORE_REPO.close()
diff --git a/tools/expected_upstream/ojluni_print_autocomplete_jdk_versions.py b/tools/expected_upstream/ojluni_print_autocomplete_jdk_versions.py
new file mode 100755
index 00000000000..d9a916ae3de
--- /dev/null
+++ b/tools/expected_upstream/ojluni_print_autocomplete_jdk_versions.py
@@ -0,0 +1,29 @@
+#!/usr/bin/python3 -B
+
+# Copyright 2025 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+"""ojluni_print_autocomplete_jdk_versions prints the autocomplete jdk versions into stdout."""
+
+# pylint: disable=g-importing-member
+import sys
+from typing import Sequence
+
+from common_util import AUTOCOMPLETE_TAGS
+
+
+def main(_: Sequence[str]) -> None:
+  print(' '.join(AUTOCOMPLETE_TAGS))
+
+if __name__ == '__main__':
+  main(sys.argv[1:])
diff --git a/tools/expected_upstream/ojluni_refresh_files.py b/tools/expected_upstream/ojluni_refresh_files.py
index fed28ad490f..02ac7ccd097 100755
--- a/tools/expected_upstream/ojluni_refresh_files.py
+++ b/tools/expected_upstream/ojluni_refresh_files.py
@@ -108,7 +108,7 @@ def merge_files_and_create_commit(entry_set: List[ExpectedUpstreamEntry],
                                   repo: Repo, checkout_only: bool) -> None:
   r"""Create the commits importing the given files into the current branch.
 
-  `--------<ref>---------------   aosp/upstream_openjdkXXX
+  `--------<ref>---------------   goog/upstream_openjdkXXX
              \
         <first_commit>
               \
@@ -209,8 +209,8 @@ def merge_files_and_create_commit(entry_set: List[ExpectedUpstreamEntry],
 def create_commits(repo: Repo, checkout_only: bool) -> None:
   """Create the commits importing files according to the EXPECTED_UPSTREAM."""
   current_tracking_branch = repo.active_branch.tracking_branch()
-  if current_tracking_branch.name != "aosp/expected_upstream":
-    print("This script should only run on aosp/expected_upstream branch. "
+  if current_tracking_branch.name != "goog/expected_upstream":
+    print("This script should only run on goog/expected_upstream branch. "
           f"Currently, this is on branch {repo.active_branch} "
           f"tracking {current_tracking_branch}")
     return
diff --git a/tools/expected_upstream/ojluni_upgrade_identicals.py b/tools/expected_upstream/ojluni_upgrade_identicals.py
index 1e49bb99929..99ee508258b 100755
--- a/tools/expected_upstream/ojluni_upgrade_identicals.py
+++ b/tools/expected_upstream/ojluni_upgrade_identicals.py
@@ -103,4 +103,8 @@ def main(argv: Sequence[str]) -> None:
 
 
 if __name__ == '__main__':
-  main(sys.argv[1:])
+  try:
+    main(sys.argv[1:])
+  finally:
+    # Avoid ImportError when __del__ runs during python3 shutdown. b/409528854
+    LIBCORE_REPO.close()
```

