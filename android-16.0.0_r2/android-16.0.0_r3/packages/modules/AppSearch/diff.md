```diff
diff --git a/Android.bp b/Android.bp
index 30b74dc7..92759d20 100644
--- a/Android.bp
+++ b/Android.bp
@@ -45,9 +45,16 @@ apex {
     key: "com.android.appsearch.key",
     certificate: ":com.android.appsearch.certificate",
     defaults: ["t-launched-apex-module"],
-    jni_libs: ["libicing"],
+    jni_libs: [
+        "libappsearchservice",
+        "libicing_anywhere",
+    ],
     prebuilts: ["current_sdkinfo"],
     apps: ["com.android.appsearch.apk"],
+    licenses: [
+        "packages_modules_appsearch_license",
+        "opensourcerequest",
+    ],
 }
 
 apex_key {
diff --git a/apk/Android.bp b/apk/Android.bp
index 1693d00f..9cbcaea0 100644
--- a/apk/Android.bp
+++ b/apk/Android.bp
@@ -21,23 +21,7 @@ android_app_certificate {
     certificate: "com.android.appsearch.apk",
 }
 
-soong_config_module_type {
-    name: "appsearch_java_defaults",
-    module_type: "java_defaults",
-    config_namespace: "appsearch",
-    bool_variables: [
-        "enable_isolated_storage",
-    ],
-    properties: [
-        "jni_libs",
-    ],
-}
-
-soong_config_bool_variable {
-    name: "enable_isolated_storage",
-}
-
-appsearch_java_defaults {
+java_defaults {
     name: "appsearch-apk-defaults",
     sdk_version: "module_current",
     min_sdk_version: "Tiramisu",
@@ -55,10 +39,18 @@ appsearch_java_defaults {
     jni_uses_platform_apis: true,
     use_embedded_native_libs: true,
     apex_available: ["com.android.appsearch"],
-    soong_config_variables: {
-        enable_isolated_storage: {
-            jni_libs: ["libisolated_storage_service"],
-        },
+
+    // - this library is mounted via the APEX
+    // jni_libs: ["libicing_anywhere"],
+    optimize: {
+        // TODO: more aggressive proguarding?
+        // proguard_compatibility: false,
+        // proguard_flags_files: ["proguard.flags"],
+
+        enabled: true,
+        optimize: true,
+        shrink_resources: true,
+        shrink: true,
     },
 }
 
diff --git a/apk/AndroidManifest.xml b/apk/AndroidManifest.xml
index 96738405..58251b72 100644
--- a/apk/AndroidManifest.xml
+++ b/apk/AndroidManifest.xml
@@ -24,12 +24,16 @@
     <uses-permission android:name="android.permission.MANAGE_VIRTUAL_MACHINE" />
     <uses-permission android:name="android.permission.USE_RELAXED_MICRODROID_ROLLBACK_PROTECTION" />
     <uses-feature android:name="android.software.virtualization_framework" android:required="true" />
-    <application android:allowBackup="false">
+    <application android:allowBackup="false"  android:directBootAware="true">
         <!-- Only non-decreasing ROLLBACK_INDEX value is allowed. In case of security fixes, we'll
         increase the ROLLBACK_INDEX value to prevent rolling pVM back to old versions with lower
         ROLLBACK_INDEX value. -->
         <property android:name="android.system.virtualmachine.ROLLBACK_INDEX" android:value="1" />
-        <service android:name="com.android.server.appsearch.isolated_storage_service.IsolatedStorageService" android:exported="true">
+        <property android:name="android.system.virtualmachine.ENCRYPTED_STORE_MODE" android:value="1" />
+        <service
+            android:name="com.android.server.appsearch.isolated_storage_service.IsolatedStorageService"
+            android:exported="true"
+            android:permission="android.permission.BIND_APP_SEARCH_ISOLATED_STORAGE_SERVICE">
             <intent-filter>
                 <action android:name="com.android.appsearch.ISOLATED_STORAGE_SERVICE" />
             </intent-filter>
diff --git a/apk/aidl/com/android/server/appsearch/isolated_storage_service/IIsolatedStorageService.aidl b/apk/aidl/com/android/server/appsearch/isolated_storage_service/IIsolatedStorageService.aidl
index b2207834..7cf03a7f 100644
--- a/apk/aidl/com/android/server/appsearch/isolated_storage_service/IIsolatedStorageService.aidl
+++ b/apk/aidl/com/android/server/appsearch/isolated_storage_service/IIsolatedStorageService.aidl
@@ -26,15 +26,29 @@ import com.android.server.appsearch.isolated_storage_service.ServiceConfig;
  * storage is encrypted.
  */
 interface IIsolatedStorageService {
-    const int PORT = 5678;
-
     /**
-     * Sets up the service.
+     * Starts the pVM.
+     *
+     * @param config The service configuration.
+     * @param timeoutSeconds The timeout in seconds when waiting for the pVm payload to be ready.
+     * @param forceRestart Whether to force the pVM to restart if it's already running.
+     * @return true if the pVm payload is ready, false otherwise. If false, please retry.
      */
-    void setup(in ServiceConfig config);
+    // TODO(b/416035857): remove forceRestart once VM status is fixed.
+    boolean startVm(in ServiceConfig config, in long timeoutSeconds, in boolean forceRestart);
 
     /**
      * Gets the connection to the pVM.
      */
     ParcelFileDescriptor getVmConnection();
+
+    /**
+     * Gets the status of the pVM.
+     */
+    int getVmStatus();
+
+    /**
+     * Cleans up old pVMs in the CE directory.
+     */
+    oneway void cleanUpOldVms();
 }
diff --git a/apk/src/com/android/server/appsearch/isolated_storage_service/IsolatedStorageService.java b/apk/src/com/android/server/appsearch/isolated_storage_service/IsolatedStorageService.java
index 26ae6b74..c39afb3a 100644
--- a/apk/src/com/android/server/appsearch/isolated_storage_service/IsolatedStorageService.java
+++ b/apk/src/com/android/server/appsearch/isolated_storage_service/IsolatedStorageService.java
@@ -24,11 +24,14 @@ import static com.android.server.appsearch.stats.VMPayloadStats.CALLBACK_TYPE_ST
 import android.app.Service;
 import android.content.Context;
 import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.os.Binder;
 import android.os.IBinder;
+import android.os.Parcel;
 import android.os.ParcelFileDescriptor;
+import android.os.Process;
 import android.os.RemoteException;
 import android.os.SystemProperties;
-import android.os.storage.StorageManager;
 import android.system.virtualmachine.VirtualMachine;
 import android.system.virtualmachine.VirtualMachineCallback;
 import android.system.virtualmachine.VirtualMachineConfig;
@@ -43,14 +46,13 @@ import androidx.annotation.Nullable;
 import com.android.server.appsearch.stats.IsolateStorageServiceLogger;
 import com.android.server.appsearch.stats.VMPayloadStats;
 
-import java.io.IOException;
 import java.util.Objects;
-import java.util.UUID;
+import java.util.concurrent.CancellationException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.TimeoutException;
 
 /**
  * Service that provides isolated storage.
@@ -59,11 +61,10 @@ import java.util.concurrent.atomic.AtomicReference;
  * IIsolatedStorageService} interface.
  */
 public class IsolatedStorageService extends Service {
-
     private static final String TAG = "IsolatedStorageService";
 
     private static final String VM_NAME = "isolated_storage_service_vm";
-    private static final String PAYLOAD_BINARY_NAME = "libisolated_storage_service.so";
+    private static final String PAYLOAD_BINARY_NAME = "libicing_anywhere.so";
 
     private static final String SYSTEM_PROPERTY_ENABLE_DEBUG_BUILD = "ro.debuggable";
     private static final boolean IS_DEBUG_BUILD =
@@ -73,37 +74,41 @@ public class IsolatedStorageService extends Service {
      * as needed and choosing a reasonably large storage size avoids costly storage resizing
      * in the VM.
      */
-    public static final long DEFAULT_ENCRYPTED_STORAGE_BYTES = 64_000_000_000L; // 64GB
-    private long mAvailableStorageBytes = DEFAULT_ENCRYPTED_STORAGE_BYTES;
+    private static final long DEFAULT_ENCRYPTED_STORAGE_BYTES = 2_000_000_000L; // 2GB
+
+    /**
+     * The threshold to delete vm after encountering consecutive {@link
+     * VirtualMachineCallback#ERROR_PAYLOAD_CHANGED} VM errors when trying to start the vm.
+     */
+    private static final int CONSECUTIVE_VM_PAYLOAD_CHANGED_ERROR_THRESHOLD = 4;
 
     private final ExecutorService mExecutorService = Executors.newFixedThreadPool(1);
     private final IsolatedStorageServiceStub mIsolatedStorageServiceStub =
             new IsolatedStorageServiceStub();
 
-    private VirtualMachine mVm;
+    private final Object mLock = new Object();
 
-    /* Gets the size of the IsolatedStorageService encrypted storage. Set the size to the
-     * maximum number of bytes the app can allocate based on available device space.
+    /**
+     * Number of consecutive {@link VirtualMachineCallback#ERROR_PAYLOAD_CHANGED} VM errors when
+     * starting the VM.
      */
-    private long getEncryptedStorageBytes() {
-        // mAvailableStorageBytes is initialized with the default storage value. Only query the
-        // storageManager if we have not done so before or a previous query failed.
-        if (mAvailableStorageBytes != DEFAULT_ENCRYPTED_STORAGE_BYTES) {
-            return mAvailableStorageBytes;
-        }
+    @GuardedBy("mLock")
+    private int mNumConsecutivePayloadChangedErrors = 0;
 
-        // Query the storageManager to determine the amount of space the app can allocate on device.
-        Context context = this.getApplicationContext();
-        StorageManager storageManager = context.getSystemService(StorageManager.class);
-        try {
-            UUID appInternalDir = storageManager.getUuidForPath(context.getFilesDir());
-            mAvailableStorageBytes = storageManager.getAllocatableBytes(appInternalDir);
-            Log.i(TAG, "Setting encrypted storage size to " + mAvailableStorageBytes + " bytes.");
-        } catch (IOException e) {
-            Log.i(TAG, "Setting encrypted storage size to " + mAvailableStorageBytes + " bytes.");
-        }
-        return mAvailableStorageBytes;
-    }
+    /**
+     * Future object for payload ready state checking and waiting. IsolatedStorageService uses this
+     * object to determine if the payload is ready or not (see {@link #isPayloadReadyLocked}). If
+     * any unexpected error happens and requires to restart the vm, then we should set this member
+     * to null.
+     */
+    @GuardedBy("mLock")
+    private CompletableFuture<Void> mPayloadReadyFuture;
+
+    @GuardedBy("mLock")
+    private VirtualMachine mVm;
+
+    @GuardedBy("mLock")
+    private com.android.isolated_storage_service.IIsolatedStorageService mVmIsolatedStorageService;
 
     @Override
     public void onCreate() {
@@ -116,23 +121,61 @@ public class IsolatedStorageService extends Service {
         return START_STICKY;
     }
 
-    private CompletableFuture<Void> startVm(ServiceConfig config) {
-        CompletableFuture<Void> future = new CompletableFuture<>();
-        mVm = maybeCreateVm(config);
+    @Override
+    public void onTrimMemory(int level) {
+        synchronized (mLock) {
+            onTrimMemoryLocked();
+        }
+    }
+
+    @GuardedBy("mLock")
+    private void onTrimMemoryLocked() {
+        if (mVmIsolatedStorageService != null) {
+            try {
+                mVmIsolatedStorageService.trimMemory();
+            } catch (RemoteException e) {
+                Log.e(TAG, "Unable to trim memory", e);
+            }
+        }
+    }
+
+    /** Restarts the vm instance, regardless of whether {@code forceRestart} is true or not. */
+    @GuardedBy("mLock")
+    private void restartVmLocked(ServiceConfig serviceConfig, boolean forceRestart)
+            throws VirtualMachineException, NullPointerException {
         if (mVm == null) {
-            Log.e(TAG, "Unable to create/get VirtualMachine");
-            future.cancel(/* mayInterruptIfRunning= */ true);
-            return future;
+            mVm = maybeCreateVm(serviceConfig);
+            if (mVm == null) {
+                throw new NullPointerException("VM instance is null");
+            }
+            if (mVm.getStatus() == VirtualMachine.STATUS_RUNNING) {
+                // If other services are allowed to create the vm instance (i.e. other classes
+                // called vmm.getOrCreate() with the same vm name and started the instance), then
+                // a running vm instance will be assigned to mVm. For now:
+                // - It is unlikely to have this situation.
+                // - But let's log this situation anyway and restart the vm, so we can make sure the
+                //   payload is ready before starting to use it.
+                //
+                // TODO: implement a better way to wait for payload ready for a running VM to avoid
+                //   unnecessary restart.
+                Log.w(
+                        TAG,
+                        "Got a running vm instance from VirtualMachineManager. The vm instance may"
+                                + " have been created and started by another service. Restart it"
+                                + " here anyway");
+            }
         }
-        IsolateStorageServiceLogger logger = new IsolateStorageServiceLogger(config);
-        VmCallback vmCallback = new VmCallback(future, logger);
+
+        Log.i(TAG, "close and restart the vm, force restart flag = " + forceRestart);
+        // Close the vm.
+        // Note: close() will be no-op if the status is not VirtualMachine.STATUS_RUNNING.
+        mVm.close();
+
+        mPayloadReadyFuture = new CompletableFuture<>();
+        IsolateStorageServiceLogger logger = new IsolateStorageServiceLogger(serviceConfig);
+        VmCallback vmCallback = new VmCallback(mPayloadReadyFuture, logger);
         mVm.setCallback(mExecutorService, vmCallback);
-        try {
-            mVm.run();
-        } catch (VirtualMachineException e) {
-            Log.e(TAG, "Failed to run " + VM_NAME, e);
-        }
-        return future;
+        mVm.run();
     }
 
     /**
@@ -141,52 +184,37 @@ public class IsolatedStorageService extends Service {
      * <p>If the VM already exists, return it. If the VM doesn't exist or is deleted, create a new
      * VM and return it. Return {@code null} if failed to get or create the VM.
      */
-    private @Nullable VirtualMachine maybeCreateVm(ServiceConfig config) {
-        VirtualMachineManager vmm = getSystemService(VirtualMachineManager.class);
+    private @Nullable VirtualMachine maybeCreateVm(ServiceConfig serviceConfig) {
+        Context context = createDeviceProtectedStorageContext();
+        VirtualMachineManager vmm = context.getSystemService(VirtualMachineManager.class);
         if (vmm == null) {
             Log.e(TAG, "Unable to get VirtualMachineManager");
             return null;
         }
-        VirtualMachine vm = null;
-        try {
-            vm = vmm.get(VM_NAME);
-        } catch (VirtualMachineException e) {
-            Log.e(TAG, "VirtualMachineManager#get failed", e);
-        }
-        if (vm != null && vm.getStatus() != VirtualMachine.STATUS_DELETED) {
-            return vm;
-        }
-        if (vm == null) {
-            Log.i(TAG, "Virtual machine " + VM_NAME + " does not exist. Creating one");
-        } else {
-            Log.i(TAG, "Virtual machine " + VM_NAME + " is deleted. Creating one");
-        }
-        return createVm(vmm, config);
-    }
 
-    private @Nullable VirtualMachine createVm(
-            VirtualMachineManager vmm, ServiceConfig serviceConfig) {
-        final int vmDebugLevel =
-                IS_DEBUG_BUILD
-                        ? VirtualMachineConfig.DEBUG_LEVEL_FULL
-                        : VirtualMachineConfig.DEBUG_LEVEL_NONE;
         try {
+            final int vmDebugLevel =
+                    IS_DEBUG_BUILD
+                            ? VirtualMachineConfig.DEBUG_LEVEL_FULL
+                            : VirtualMachineConfig.DEBUG_LEVEL_NONE;
+            // TODO(b/406258175): enable delayed encrypted store setup to allow icing data to be
+            //  protected by CE
             VirtualMachineConfig config =
-                    new VirtualMachineConfig.Builder(this)
+                    new VirtualMachineConfig.Builder(context)
                             .setPayloadBinaryName(PAYLOAD_BINARY_NAME)
                             .setProtectedVm(true)
                             .setDebugLevel(vmDebugLevel)
                             // Set the maximum size of the VM encrypted storage. Storage is
                             // allocated on an as needed basis.
-                            .setEncryptedStorageBytes(getEncryptedStorageBytes())
+                            .setEncryptedStorageBytes(DEFAULT_ENCRYPTED_STORAGE_BYTES)
                             .setMemoryBytes(serviceConfig.pVmMemoryBytes)
                             .setCpuTopology(VirtualMachineConfig.CPU_TOPOLOGY_ONE_CPU)
                             .setShouldUseHugepages(true)
                             .build();
             try {
-                return vmm.create(VM_NAME, config);
+                return vmm.getOrCreate(VM_NAME, config);
             } catch (VirtualMachineException e) {
-                Log.e(TAG, "Failed to create virtual machine " + VM_NAME, e);
+                Log.e(TAG, "Failed to get or create virtual machine " + VM_NAME, e);
                 return null;
             }
         } catch (IllegalArgumentException
@@ -197,6 +225,60 @@ public class IsolatedStorageService extends Service {
         }
     }
 
+    @GuardedBy("mLock")
+    private void deleteCurrentVmLocked(@Nullable String vmErrorMessage) {
+        Log.i(TAG, "Deleting current VM...");
+        Context context = createDeviceProtectedStorageContext();
+        VirtualMachineManager vmm = context.getSystemService(VirtualMachineManager.class);
+        if (vmm == null) {
+            Log.e(TAG, "Unable to get VirtualMachineManager");
+            return;
+        }
+        if (deleteVm(vmm, VM_NAME)) {
+            if (vmErrorMessage != null) {
+                Log.wtf(TAG, vmErrorMessage);
+            } else {
+                Log.i(TAG, "Successfully deleted the VM.");
+            }
+            mVm = null;
+            mNumConsecutivePayloadChangedErrors = 0;
+        } else {
+            Log.e(TAG, "Failed to delete current VM");
+        }
+    }
+
+    private void deleteOldVms() {
+        VirtualMachineManager vmm = getSystemService(VirtualMachineManager.class);
+        if (vmm == null) {
+            Log.e(TAG, "Unable to get VirtualMachineManager");
+            return;
+        }
+        deleteVm(vmm, "isolated_storage_service_vm");
+        deleteVm(vmm, "isolated_storage_service2_vm");
+    }
+
+    private boolean deleteVm(VirtualMachineManager vmm, String name) {
+        try {
+            vmm.delete(name);
+        } catch (VirtualMachineException e) {
+            Log.e(TAG, "Failed to delete VM " + name, e);
+            return false;
+        }
+        return true;
+    }
+
+    @GuardedBy("mLock")
+    private boolean isVmRunningLocked() {
+        return mVm != null && mVm.getStatus() == VirtualMachine.STATUS_RUNNING;
+    }
+
+    @GuardedBy("mLock")
+    private boolean isPayloadReadyLocked() {
+        return mPayloadReadyFuture != null
+                && !mPayloadReadyFuture.isCancelled()
+                && mPayloadReadyFuture.isDone();
+    }
+
     /** Callbacks for pVM status changes. */
     private class VmCallback implements VirtualMachineCallback {
 
@@ -217,10 +299,42 @@ public class IsolatedStorageService extends Service {
 
         @Override
         public void onPayloadReady(VirtualMachine vm) {
-            Log.i(TAG, "Payload ready");
-            mFuture.complete(null);
+            synchronized (mLock) {
+                mNumConsecutivePayloadChangedErrors = 0;
+
+                if (mFuture != mPayloadReadyFuture) {
+                    Log.w(
+                            TAG,
+                            "Another restart has been kicked off before payload ready. Abandon"
+                                    + " this callback");
+                    return;
+                }
+
+                Log.i(TAG, "Payload ready");
+                try {
+                    mVmIsolatedStorageService =
+                            com.android.isolated_storage_service.IIsolatedStorageService.Stub
+                                    .asInterface(
+                                            vm.connectToVsockServer(
+                                                    com.android.isolated_storage_service
+                                                            .IIsolatedStorageService.PORT));
+                } catch (VirtualMachineException e) {
+                    Log.e(TAG, "Failed to connect to " + VM_NAME, e);
+
+                    // Set the payload ready future object in IsolatedStorageService to null, so
+                    // the service can avoid serving any request with an invalid
+                    // mVmIsolatedStorageService.
+                    mPayloadReadyFuture = null;
+                    VMPayloadStats stats = new VMPayloadStats.Builder(CALLBACK_TYPE_ERROR).build();
+                    mLogger.logStats(stats);
+                    return;
+                }
+            }
+
             VMPayloadStats stats = new VMPayloadStats.Builder(CALLBACK_TYPE_READY).build();
             mLogger.logStats(stats);
+
+            mFuture.complete(null);
         }
 
         @Override
@@ -233,10 +347,37 @@ public class IsolatedStorageService extends Service {
 
         @Override
         public void onError(VirtualMachine vm, int errorCode, String errorMessage) {
-            Log.e(TAG, "Error " + VM_NAME + " code : " + errorCode + " msg : " + errorMessage);
+
+            synchronized (mLock) {
+                String vmErrorMessage = "Error " + VM_NAME + " code : " + errorCode + " msg : "
+                        + errorMessage;
+                Log.e(TAG, vmErrorMessage);
+                if (errorCode == VirtualMachineCallback.ERROR_PAYLOAD_CHANGED) {
+                    mNumConsecutivePayloadChangedErrors++;
+                    if (mNumConsecutivePayloadChangedErrors
+                            >= CONSECUTIVE_VM_PAYLOAD_CHANGED_ERROR_THRESHOLD) {
+                        vmErrorMessage = vmErrorMessage + ". Previous payload changed error count: "
+                                + mNumConsecutivePayloadChangedErrors;
+                        deleteCurrentVmLocked(vmErrorMessage);
+                    } else {
+                        Log.i(
+                                TAG,
+                                "Encountered "
+                                        + mNumConsecutivePayloadChangedErrors
+                                        + " payload changed errors. Not deleting current VM.");
+                    }
+                } else {
+                    mNumConsecutivePayloadChangedErrors = 0;
+                }
+            }
+
             VMPayloadStats stats =
                     new VMPayloadStats.Builder(CALLBACK_TYPE_ERROR).setErrorCode(errorCode).build();
             mLogger.logStats(stats);
+
+            // The future itself is trivial - it's just a signaling mechanism for the waiting thread
+            // (i.e. get()) to unblock before timeout.
+            mFuture.cancel(/* mayInterruptIfRunning= */ true);
         }
 
         @Override
@@ -247,48 +388,95 @@ public class IsolatedStorageService extends Service {
                             .setStopReason(stopReason)
                             .build();
             mLogger.logStats(stats);
+
+            // The future itself is trivial - it's just a signaling mechanism for the waiting thread
+            // (i.e. get()) to unblock before timeout.
+            mFuture.cancel(/* mayInterruptIfRunning= */ true);
         }
     }
 
     @Override
     public IBinder onBind(Intent intent) {
-        // TODO: b/384768541 - ensure only AppSearch can bind to this service.
         return mIsolatedStorageServiceStub.asBinder();
     }
 
     /** Implementation of the {@link IIsolatedStorageService}. */
     private class IsolatedStorageServiceStub extends IIsolatedStorageService.Stub {
-        private static final int PAYLOAD_READY_WAIT_TIMEOUT_SECONDS = 15;
 
-        @GuardedBy("mConfigLocked")
-        private final AtomicReference<ServiceConfig> mConfigLocked = new AtomicReference<>();
+        // We check here instead of onBind as IBinder can be passed around.
+        @Override
+        public boolean onTransact(int code, Parcel data, Parcel reply, int flags)
+                throws RemoteException {
+            checkCallerPermission();
+            return super.onTransact(code, data, reply, flags);
+        }
+
+        // We only allow packages with BIND_APPSEARCH_ISOLATED_STORAGE_SERVICE permission to do the
+        // binder call to this service.
+        // Furthermore, we only want system_server to bind to this service.
+        private void checkCallerPermission() {
+            int checkPermission =
+                    checkCallingPermission(
+                            "android.permission.BIND_APP_SEARCH_ISOLATED_STORAGE_SERVICE");
+            if (checkPermission != PackageManager.PERMISSION_GRANTED) {
+                throw new SecurityException("Permission check failed with code " + checkPermission);
+            }
+
+            // check to only allow system_server access.
+            if (Binder.getCallingUid() != Process.SYSTEM_UID) {
+                throw new SecurityException(
+                        "Only system server is allowed to bind to this service.");
+            }
+        }
 
         @Override
-        public void setup(ServiceConfig config) throws RemoteException {
-            Objects.requireNonNull(config);
-            synchronized (mConfigLocked) {
-                if (mConfigLocked.get() != null) {
-                    Log.w(TAG, "Service already set up");
-                    return;
+        public boolean startVm(ServiceConfig config, long timeoutSeconds, boolean forceRestart)
+                throws RemoteException {
+            CompletableFuture<Void> localPayloadReadyFuture = null;
+            synchronized (mLock) {
+                if (isVmRunningLocked() && isPayloadReadyLocked() && !forceRestart) {
+                    return true;
                 }
-                mConfigLocked.set(config);
+
                 try {
-                    startVm(config).get(PAYLOAD_READY_WAIT_TIMEOUT_SECONDS, TimeUnit.SECONDS);
+                    restartVmLocked(config, forceRestart);
                 } catch (Exception e) {
-                    Log.e(TAG, "Unable to wait for payload ready", e);
+                    Log.e(TAG, "Unable to start VM", e);
+
+                    // Reset payload ready future object.
+                    mPayloadReadyFuture = null;
                     throw new RemoteException(e.getMessage());
                 }
+                localPayloadReadyFuture = mPayloadReadyFuture;
+            }
+
+            if (localPayloadReadyFuture == null) {
+                String msg =
+                        new String(
+                                "Got a null payload ready future object to wait. This should not"
+                                        + " happen");
+                Log.e(TAG, msg);
+                throw new RemoteException(msg);
+            }
+
+            try {
+                localPayloadReadyFuture.get(timeoutSeconds, TimeUnit.SECONDS);
+            } catch (InterruptedException | TimeoutException | CancellationException e) {
+                Log.w(TAG, "Unable to wait for payload ready", e);
+                return false;
+            } catch (Exception e) {
+                Log.e(TAG, "Unable to start VM", e);
+                throw new RemoteException(e.getMessage());
             }
+            return true;
         }
 
         @Override
         public ParcelFileDescriptor getVmConnection() throws RemoteException {
-            synchronized (mConfigLocked) {
-                if (mConfigLocked.get() == null) {
-                    throw new RemoteException("Service not set up yet");
-                }
-                if (mVm == null) {
-                    throw new RemoteException("pVM payload is not ready/available");
+            synchronized (mLock) {
+                if (!isVmRunningLocked() || !isPayloadReadyLocked()) {
+                    throw new RemoteException(
+                            "pVM is not running or payload is not ready/available");
                 }
                 try {
                     return mVm.connectVsock(
@@ -299,5 +487,20 @@ public class IsolatedStorageService extends Service {
                 }
             }
         }
+
+        @Override
+        public int getVmStatus() throws RemoteException {
+            synchronized (mLock) {
+                if (mVm == null) {
+                    throw new RemoteException("pVM is not available");
+                }
+                return mVm.getStatus();
+            }
+        }
+
+        @Override
+        public void cleanUpOldVms() {
+            deleteOldVms();
+        }
     }
 }
diff --git a/flags/Android.bp b/flags/Android.bp
index 630258de..abfbd182 100644
--- a/flags/Android.bp
+++ b/flags/Android.bp
@@ -20,6 +20,7 @@ java_aconfig_library {
         "//cts/tests/appsearch:__subpackages__",
         "//frameworks/base",
         "//packages/modules/AppSearch/testing:__subpackages__",
+        "//packages/modules/Permission/tests/cts/permissionpolicy",
     ],
     mode: "exported",
     defaults: ["framework-minus-apex-aconfig-java-defaults"],
diff --git a/flags/appsearch.aconfig b/flags/appsearch.aconfig
index 457ab81e..7eb9595a 100644
--- a/flags/appsearch.aconfig
+++ b/flags/appsearch.aconfig
@@ -114,15 +114,6 @@ flag {
     is_fixed_read_only: true
 }
 
-flag {
-    name: "enable_app_functions"
-    namespace: "appsearch"
-    description: "Guards everything related to AppFunction."
-    bug: "327134039"
-    is_fixed_read_only: true
-    is_exported: true
-}
-
 flag {
     name: "enable_generic_document_over_ipc"
     namespace: "appsearch"
@@ -487,3 +478,216 @@ flag {
         purpose: PURPOSE_BUGFIX
     }
 }
+
+flag {
+    name: "enable_query_visibility_documents"
+    namespace: "appsearch"
+    description: "Improve load visibility store performance."
+    bug: "404622915"
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+flag {
+    name: "enable_batch_get"
+    namespace: "appsearch"
+    description: "Uses the new batch get API from Icing."
+    bug: "401245769"
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+flag {
+    name: "enable_strict_page_byte_size_limit"
+    namespace: "appsearch"
+    description: "Enables strict byte size enforcement on a result page."
+    bug: "392648537"
+}
+
+flag {
+    name: "enable_compression_threshold"
+    namespace: "appsearch"
+    description: "Enables compression threshold."
+    bug: "406066880"
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+flag {
+    name: "enable_compression_mem_level_one"
+    namespace: "appsearch"
+    description: "Enables using a compression mem-level of 1."
+    bug: "405420968"
+}
+
+flag {
+    name: "enable_smaller_decompression_buffer_size"
+    namespace: "appsearch"
+    description: "Enables gzip decompression buffer size memory optimization."
+    bug: "405420968"
+}
+
+flag {
+    name: "enable_new_optimize_strategy_for_active_result_states"
+    namespace: "appsearch"
+    description: "Enables new optimize strategy for active result states."
+    bug: "409070736"
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+flag {
+    name: "enable_storage_info_cache"
+    namespace: "appsearch"
+    description: "Enables the StorageInfo cache in AppSearchImpl."
+    bug: "395156359"
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+flag {
+    name: "enable_indexer_run_on_app_function_component_change"
+    namespace: "appsearch"
+    description: "Enables running apps indexer when app function component within an app changes."
+    bug: "409611864"
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+flag {
+    name: "enable_indexer_run_on_ota_update"
+    namespace: "appsearch"
+    description: "Enables running apps indexer when there's an OTA update and system apps are updated."
+    bug: "411384350"
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+flag {
+    name: "enable_result_aborted"
+    namespace: "appsearch"
+    description: "Enables the AppSearchResult#RESULT_ABORTED."
+    bug: "409070736"
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+flag {
+    name: "enable_throw_exception_for_native_not_found_page_token"
+    namespace: "appsearch"
+    description: "Enables throwing AppSearchException with codeRESULT_ABORTED if the search result page token is not found in native."
+    bug: "409070736"
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+flag {
+    name: "enable_batch_put_visibility_documents"
+    namespace: "appsearch"
+    description: "Enables using batch put for set visibility documents to Icing."
+    bug: "404622915"
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+flag {
+    name: "enable_user_instance_futures"
+    namespace: "appsearch"
+    description: "Enables using futures to create user instances."
+    bug: "415031127"
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+flag {
+    name: "enable_database_scoped_schema_operations"
+    namespace: "appsearch"
+    description: "Enable database-scoped set and get schema operations for AppSearch internal impl."
+    bug: "337913932"
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+flag {
+    name: "app_open_event_indexer_stats_logging_enabled"
+    namespace: "appsearch"
+    description: "Enables the app open event indexer stats logging to PWW"
+    bug: "357835538"
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+flag {
+    name: "enable_initialization_retries_before_reset"
+    namespace: "appsearch"
+    description: "Enable retrying the critical section of initialization before resetting as a last resort."
+    bug: "415387509"
+}
+
+flag {
+    name: "enable_result_unavailable"
+    namespace: "appsearch"
+    description: "Enables the AppSearchResult#RESULT_UNAVAILABLE."
+    bug: "404210068"
+}
+
+flag {
+    name: "enable_enterprise_visible_to_config"
+    namespace: "appsearch"
+    description: "Enable checking VisibleToConfig for schema visibility when querying with enterprise global search session."
+    bug: "417289133"
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
+
+flag {
+    name: "enable_delayed_persist_to_disk"
+    namespace: "appsearch"
+    description: "Enables AppSearch write API calls to schedule persistToDisk calls after a specified delay, rather than executing them immediately."
+    bug: "417463182"
+}
+
+flag {
+    name: "enable_five_min_persist_to_disk_delay"
+    namespace: "appsearch"
+    description: "Sets scheduled persist to disk delay time to five minutes."
+    bug: "417463182"
+}
+
+flag {
+    name: "enable_eigen_embedding_scoring"
+    namespace: "appsearch"
+    description: "Enables the Eigen library for embedding scoring."
+    bug: "420960001"
+}
+
+flag {
+    name: "enable_wiping_out_system_server_data_after_migration"
+    namespace: "appsearch"
+    description: "Enable wiping out old icing directory after data has been migrated to the VM."
+    bug: "422162268"
+}
+
+flag {
+    name: "enable_close_appsearch_on_creation_failure"
+    namespace: "appsearch"
+    description: "Enable closing the instance of AppSearchImpl if we manage to create it, but we fail to fully create the user instance."
+    bug: "418422820"
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+}
diff --git a/framework/Android.bp b/framework/Android.bp
index fdbab839..6c96abba 100644
--- a/framework/Android.bp
+++ b/framework/Android.bp
@@ -70,6 +70,7 @@ java_sdk_library {
         enabled: true,
         optimize: true,
         shrink: true,
+        shrink_resources: true,
         // Enable R8 compat mode. R8 full mode implicitly adds -allowaccessmodification,
         // which may cause non-public fields and methods to become public.
         proguard_compatibility: true,
diff --git a/framework/api/current.txt b/framework/api/current.txt
index feb8a11f..87a99d92 100644
--- a/framework/api/current.txt
+++ b/framework/api/current.txt
@@ -50,6 +50,7 @@ package android.app.appsearch {
     method public boolean isSuccess();
     method @NonNull public static <ValueType> android.app.appsearch.AppSearchResult<ValueType> newFailedResult(int, @Nullable String);
     method @NonNull public static <ValueType> android.app.appsearch.AppSearchResult<ValueType> newSuccessfulResult(@Nullable ValueType);
+    field @FlaggedApi("com.android.appsearch.flags.enable_result_aborted") public static final int RESULT_ABORTED = 13; // 0xd
     field @FlaggedApi("com.android.appsearch.flags.enable_result_already_exists") public static final int RESULT_ALREADY_EXISTS = 12; // 0xc
     field @FlaggedApi("com.android.appsearch.flags.enable_result_denied_and_result_rate_limited") public static final int RESULT_DENIED = 9; // 0x9
     field public static final int RESULT_INTERNAL_ERROR = 2; // 0x2
@@ -61,6 +62,7 @@ package android.app.appsearch {
     field public static final int RESULT_OUT_OF_SPACE = 5; // 0x5
     field @FlaggedApi("com.android.appsearch.flags.enable_result_denied_and_result_rate_limited") public static final int RESULT_RATE_LIMITED = 10; // 0xa
     field public static final int RESULT_SECURITY_ERROR = 8; // 0x8
+    field @FlaggedApi("com.android.appsearch.flags.enable_result_unavailable") public static final int RESULT_UNAVAILABLE = 14; // 0xe
     field public static final int RESULT_UNKNOWN_ERROR = 1; // 0x1
   }
 
@@ -602,14 +604,17 @@ package android.app.appsearch {
     method @NonNull public android.app.appsearch.SearchResult.MatchInfo.Builder setSubmatchRange(@NonNull android.app.appsearch.SearchResult.MatchRange);
   }
 
-  public static final class SearchResult.MatchRange {
+  public static final class SearchResult.MatchRange implements android.os.Parcelable {
     ctor public SearchResult.MatchRange(int, int);
+    method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public final int describeContents();
     method public int getEnd();
     method public int getStart();
+    method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") @NonNull public static final android.os.Parcelable.Creator<android.app.appsearch.SearchResult.MatchRange> CREATOR;
   }
 
   @FlaggedApi("com.android.appsearch.flags.enable_embedding_match_info") public static final class SearchResult.TextMatchInfo implements android.os.Parcelable {
-    ctor public SearchResult.TextMatchInfo(int, int, int, int, int, int);
+    ctor public SearchResult.TextMatchInfo(@NonNull android.app.appsearch.SearchResult.MatchRange, @NonNull android.app.appsearch.SearchResult.MatchRange, @NonNull android.app.appsearch.SearchResult.MatchRange);
     method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public final int describeContents();
     method @FlaggedApi("com.android.appsearch.flags.enable_embedding_match_info") @NonNull public CharSequence getExactMatch();
     method @FlaggedApi("com.android.appsearch.flags.enable_embedding_match_info") @NonNull public android.app.appsearch.SearchResult.MatchRange getExactMatchRange();
diff --git a/framework/java/android/app/appsearch/SearchResults.java b/framework/java/android/app/appsearch/SearchResults.java
index 893a4187..e6236d7f 100644
--- a/framework/java/android/app/appsearch/SearchResults.java
+++ b/framework/java/android/app/appsearch/SearchResults.java
@@ -145,23 +145,31 @@ public class SearchResults implements Closeable {
                             wrapCallback(executor, callback));
                 }
             } else {
-                // TODO(b/276349029): Log different join types when they get added.
-                @AppSearchSchema.StringPropertyConfig.JoinableValueType
-                int joinType = JOINABLE_VALUE_TYPE_NONE;
-                JoinSpec joinSpec = mSearchSpec.getJoinSpec();
-                if (joinSpec != null && !joinSpec.getChildPropertyExpression().isEmpty()) {
-                    joinType = JOINABLE_VALUE_TYPE_QUALIFIED_ID;
+                if (mNextPageToken == SearchResultPage.EMPTY_PAGE_TOKEN) {
+                    // Construct an empty page and invoke the callback if the next page token is
+                    // empty token. This will save a binder call.
+                    AppSearchResult<SearchResultPage> searchResultPageResult =
+                            AppSearchResult.newSuccessfulResult(new SearchResultPage());
+                    invokeCallback(searchResultPageResult, callback);
+                } else {
+                    // TODO(b/276349029): Log different join types when they get added.
+                    @AppSearchSchema.StringPropertyConfig.JoinableValueType
+                    int joinType = JOINABLE_VALUE_TYPE_NONE;
+                    JoinSpec joinSpec = mSearchSpec.getJoinSpec();
+                    if (joinSpec != null && !joinSpec.getChildPropertyExpression().isEmpty()) {
+                        joinType = JOINABLE_VALUE_TYPE_QUALIFIED_ID;
+                    }
+                    mService.getNextPage(
+                            new GetNextPageAidlRequest(
+                                    mAttributionSource,
+                                    mDatabaseName,
+                                    mNextPageToken,
+                                    joinType,
+                                    mUserHandle,
+                                    binderCallStartTimeMillis,
+                                    mIsForEnterprise),
+                            wrapCallback(executor, callback));
                 }
-                mService.getNextPage(
-                        new GetNextPageAidlRequest(
-                                mAttributionSource,
-                                mDatabaseName,
-                                mNextPageToken,
-                                joinType,
-                                mUserHandle,
-                                binderCallStartTimeMillis,
-                                mIsForEnterprise),
-                        wrapCallback(executor, callback));
             }
         } catch (RemoteException e) {
             ExceptionUtil.handleRemoteException(e);
@@ -171,17 +179,23 @@ public class SearchResults implements Closeable {
     @Override
     public void close() {
         if (!mIsClosed) {
-            try {
-                mService.invalidateNextPageToken(
-                        new InvalidateNextPageTokenAidlRequest(
-                                mAttributionSource,
-                                mNextPageToken,
-                                mUserHandle,
-                                /* binderCallStartTimeMillis= */ SystemClock.elapsedRealtime(),
-                                mIsForEnterprise));
+            if (mNextPageToken == SearchResultPage.EMPTY_PAGE_TOKEN) {
+                // Save a binder call for invalidateNextPageToken if the next page token is empty
+                // token.
                 mIsClosed = true;
-            } catch (RemoteException e) {
-                Log.e(TAG, "Unable to close the SearchResults", e);
+            } else {
+                try {
+                    mService.invalidateNextPageToken(
+                            new InvalidateNextPageTokenAidlRequest(
+                                    mAttributionSource,
+                                    mNextPageToken,
+                                    mUserHandle,
+                                    /* binderCallStartTimeMillis= */ SystemClock.elapsedRealtime(),
+                                    mIsForEnterprise));
+                    mIsClosed = true;
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Unable to close the SearchResults", e);
+                }
             }
         }
     }
diff --git a/framework/java/external/android/app/appsearch/AppSearchResult.java b/framework/java/external/android/app/appsearch/AppSearchResult.java
index cf43e774..d3e9427b 100644
--- a/framework/java/external/android/app/appsearch/AppSearchResult.java
+++ b/framework/java/external/android/app/appsearch/AppSearchResult.java
@@ -30,6 +30,8 @@ import java.io.IOException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Objects;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
 
 /**
  * Information about the success or failure of an AppSearch call.
@@ -59,7 +61,9 @@ public final class AppSearchResult<ValueType> {
                 RESULT_SECURITY_ERROR,
                 RESULT_DENIED,
                 RESULT_RATE_LIMITED,
-                RESULT_ALREADY_EXISTS
+                RESULT_ALREADY_EXISTS,
+                RESULT_ABORTED,
+                RESULT_UNAVAILABLE
             })
     @Retention(RetentionPolicy.SOURCE)
     public @interface ResultCode {}
@@ -121,6 +125,27 @@ public final class AppSearchResult<ValueType> {
     @FlaggedApi(Flags.FLAG_ENABLE_RESULT_ALREADY_EXISTS)
     public static final int RESULT_ALREADY_EXISTS = 12;
 
+    /**
+     * The operation is aborted because an internal state change invalidated the results of the
+     * request. New requests should be able to process correctly and callers may, therefore, wish to
+     * retry.
+     *
+     * <p>Note: if retrying, the caller should restart the request at the topmost API level. For
+     * example, if {@link SearchResults#getNextPage} throws an exception with code {@link
+     * #RESULT_ABORTED}, then the caller should restart the search via {@link
+     * AppSearchSession#search} API with a new {@link SearchResults} object, instead of calling
+     * {@link SearchResults#getNextPage} again with the original {@link SearchResults} object.
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_RESULT_ABORTED)
+    public static final int RESULT_ABORTED = 13;
+
+    /**
+     * An error occurred due to AppSearch not having the necessary resources to execute the API
+     * call.
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_RESULT_UNAVAILABLE)
+    public static final int RESULT_UNAVAILABLE = 14;
+
     @ResultCode private final int mResultCode;
     private final @Nullable ValueType mResultValue;
     private final @Nullable String mErrorMessage;
@@ -256,7 +281,11 @@ public final class AppSearchResult<ValueType> {
 
         String exceptionClass = t.getClass().getSimpleName();
         @AppSearchResult.ResultCode int resultCode;
-        if (t instanceof IllegalStateException || t instanceof NullPointerException) {
+        if (t instanceof CancellationException || t instanceof InterruptedException) {
+            resultCode = AppSearchResult.RESULT_ABORTED;
+        } else if (t instanceof IllegalStateException
+                || t instanceof NullPointerException
+                || t instanceof ExecutionException) {
             resultCode = AppSearchResult.RESULT_INTERNAL_ERROR;
         } else if (t instanceof IllegalArgumentException) {
             resultCode = AppSearchResult.RESULT_INVALID_ARGUMENT;
diff --git a/framework/java/external/android/app/appsearch/AppSearchSchema.java b/framework/java/external/android/app/appsearch/AppSearchSchema.java
index cd3794d1..a51cd51d 100644
--- a/framework/java/external/android/app/appsearch/AppSearchSchema.java
+++ b/framework/java/external/android/app/appsearch/AppSearchSchema.java
@@ -1076,7 +1076,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
                     Preconditions.checkState(
                             mCardinality != CARDINALITY_REPEATED,
                             "Cannot set JOINABLE_VALUE_TYPE_QUALIFIED_ID with"
-                                    + " CARDINALITY_REPEATED.");
+                                + " CARDINALITY_REPEATED.");
                 }
                 if (mDeletePropagationType != DELETE_PROPAGATION_TYPE_NONE) {
                     Preconditions.checkState(
diff --git a/framework/java/external/android/app/appsearch/SearchResult.java b/framework/java/external/android/app/appsearch/SearchResult.java
index 3d0d3b3d..06937028 100644
--- a/framework/java/external/android/app/appsearch/SearchResult.java
+++ b/framework/java/external/android/app/appsearch/SearchResult.java
@@ -539,9 +539,9 @@ public final class SearchResult extends AbstractSafeParcelable {
             if (tempTextMatch == null && mEmbeddingMatch == null) {
                 tempTextMatch =
                         new TextMatchInfo(
-                                exactMatchRangeStart, exactMatchRangeEnd,
-                                submatchRangeStart, submatchRangeEnd,
-                                snippetRangeStart, snippetRangeEnd);
+                                new MatchRange(exactMatchRangeStart, exactMatchRangeEnd),
+                                new MatchRange(submatchRangeStart, submatchRangeEnd),
+                                new MatchRange(snippetRangeStart, snippetRangeEnd));
                 tempTextMatch.setPropertyPath(mPropertyPath);
             }
 
@@ -777,11 +777,7 @@ public final class SearchResult extends AbstractSafeParcelable {
             public @NonNull MatchInfo build() {
                 TextMatchInfo textMatch = null;
                 if (mEmbeddingMatch == null) {
-                    textMatch =
-                            new TextMatchInfo(
-                                    mExactMatchRange.getStart(), mExactMatchRange.getEnd(),
-                                    mSubmatchRange.getStart(), mSubmatchRange.getEnd(),
-                                    mSnippetRange.getStart(), mSnippetRange.getEnd());
+                    textMatch = new TextMatchInfo(mExactMatchRange, mSubmatchRange, mSnippetRange);
                     textMatch.setPropertyPath(mPropertyPath);
                 }
                 return new MatchInfo(
@@ -879,23 +875,14 @@ public final class SearchResult extends AbstractSafeParcelable {
         public static final @NonNull Parcelable.Creator<TextMatchInfo> CREATOR =
                 new TextMatchInfoCreator();
 
-        @Field(id = 1)
-        final int mExactMatchRangeStart;
-
-        @Field(id = 2)
-        final int mExactMatchRangeEnd;
+        @Field(id = 1, getter = "getExactMatchRange")
+        private final MatchRange mExactMatchRange;
 
-        @Field(id = 3)
-        final int mSubmatchRangeStart;
+        @Field(id = 2, getter = "getSubmatchRange")
+        private final MatchRange mSubmatchRange;
 
-        @Field(id = 4)
-        final int mSubmatchRangeEnd;
-
-        @Field(id = 5)
-        final int mSnippetRangeStart;
-
-        @Field(id = 6)
-        final int mSnippetRangeEnd;
+        @Field(id = 3, getter = "getSnippetRange")
+        private final MatchRange mSnippetRange;
 
         /**
          * The path of the matching snippet property.
@@ -916,42 +903,21 @@ public final class SearchResult extends AbstractSafeParcelable {
         /** Full text of the matched property. Populated on first use. */
         private @Nullable String mFullText;
 
-        /** Range of property that exactly matched the query. Populated on first use. */
-        private @Nullable MatchRange mExactMatchRangeCached;
-
-        /**
-         * Range of property that corresponds to the subsequence of the exact match that directly
-         * matches a query term. Populated on first use.
-         */
-        private @Nullable MatchRange mSubmatchRangeCached;
-
-        /** Range of some reasonable amount of context around the query. Populated on first use. */
-        private @Nullable MatchRange mWindowRangeCached;
-
         /**
          * Creates a new immutable TextMatchInfo.
          *
-         * @param exactMatchRangeStart the start of the exact {@link MatchRange} for the entry.
-         * @param exactMatchRangeEnd the end of the exact {@link MatchRange} for the entry.
-         * @param submatchRangeStart the start of the sub-match {@link MatchRange} for the entry.
-         * @param submatchRangeEnd the end of the sub-match {@link MatchRange} for the entry.
-         * @param snippetRangeStart the start of the snippet {@link MatchRange} for the entry.
-         * @param snippetRangeEnd the end of the snippet {@link MatchRange} for the entry.
+         * @param exactMatchRange the exact {@link MatchRange} for the entry.
+         * @param submatchRange the sub-match {@link MatchRange} for the entry.
+         * @param snippetRange the snippet {@link MatchRange} for the entry.
          */
         @Constructor
         public TextMatchInfo(
-                @Param(id = 1) int exactMatchRangeStart,
-                @Param(id = 2) int exactMatchRangeEnd,
-                @Param(id = 3) int submatchRangeStart,
-                @Param(id = 4) int submatchRangeEnd,
-                @Param(id = 5) int snippetRangeStart,
-                @Param(id = 6) int snippetRangeEnd) {
-            mExactMatchRangeStart = exactMatchRangeStart;
-            mExactMatchRangeEnd = exactMatchRangeEnd;
-            mSubmatchRangeStart = submatchRangeStart;
-            mSubmatchRangeEnd = submatchRangeEnd;
-            mSnippetRangeStart = snippetRangeStart;
-            mSnippetRangeEnd = snippetRangeEnd;
+                @Param(id = 1) @NonNull MatchRange exactMatchRange,
+                @Param(id = 2) @NonNull MatchRange submatchRange,
+                @Param(id = 3) @NonNull MatchRange snippetRange) {
+            mExactMatchRange = exactMatchRange;
+            mSubmatchRange = submatchRange;
+            mSnippetRange = snippetRange;
         }
 
         /**
@@ -986,10 +952,7 @@ public final class SearchResult extends AbstractSafeParcelable {
          */
         @FlaggedApi(Flags.FLAG_ENABLE_EMBEDDING_MATCH_INFO)
         public @NonNull MatchRange getExactMatchRange() {
-            if (mExactMatchRangeCached == null) {
-                mExactMatchRangeCached = new MatchRange(mExactMatchRangeStart, mExactMatchRangeEnd);
-            }
-            return mExactMatchRangeCached;
+            return mExactMatchRange;
         }
 
         /**
@@ -1017,10 +980,7 @@ public final class SearchResult extends AbstractSafeParcelable {
         @FlaggedApi(Flags.FLAG_ENABLE_EMBEDDING_MATCH_INFO)
         public @NonNull MatchRange getSubmatchRange() {
             checkSubmatchSupported();
-            if (mSubmatchRangeCached == null) {
-                mSubmatchRangeCached = new MatchRange(mSubmatchRangeStart, mSubmatchRangeEnd);
-            }
-            return mSubmatchRangeCached;
+            return mSubmatchRange;
         }
 
         /**
@@ -1050,10 +1010,7 @@ public final class SearchResult extends AbstractSafeParcelable {
          */
         @FlaggedApi(Flags.FLAG_ENABLE_EMBEDDING_MATCH_INFO)
         public @NonNull MatchRange getSnippetRange() {
-            if (mWindowRangeCached == null) {
-                mWindowRangeCached = new MatchRange(mSnippetRangeStart, mSnippetRangeEnd);
-            }
-            return mWindowRangeCached;
+            return mSnippetRange;
         }
 
         /**
@@ -1079,7 +1036,7 @@ public final class SearchResult extends AbstractSafeParcelable {
         }
 
         private void checkSubmatchSupported() {
-            if (mSubmatchRangeStart == -1) {
+            if (mSubmatchRange.getStart() == -1) {
                 throw new UnsupportedOperationException(
                         "Submatch is not supported with this backend/Android API level "
                                 + "combination");
@@ -1217,10 +1174,20 @@ public final class SearchResult extends AbstractSafeParcelable {
      *
      * <p>Example: MatchRange(0, 100) represents hundred ints from 0 to 99."
      */
-    public static final class MatchRange {
-        private final int mEnd;
+    @SafeParcelable.Class(creator = "MatchRangeCreator")
+    @SuppressWarnings("HiddenSuperclass")
+    public static final class MatchRange extends AbstractSafeParcelable {
+
+        @FlaggedApi(Flags.FLAG_ENABLE_SAFE_PARCELABLE_2)
+        public static final @NonNull Parcelable.Creator<MatchRange> CREATOR =
+                new MatchRangeCreator();
+
+        @Field(id = 1, getter = "getStart")
         private final int mStart;
 
+        @Field(id = 2, getter = "getEnd")
+        private final int mEnd;
+
         /**
          * Creates a new immutable range.
          *
@@ -1230,7 +1197,8 @@ public final class SearchResult extends AbstractSafeParcelable {
          * @param start The start point (inclusive)
          * @param end The end point (exclusive)
          */
-        public MatchRange(int start, int end) {
+        @Constructor
+        public MatchRange(@Param(id = 1) int start, @Param(id = 2) int end) {
             if (start > end) {
                 throw new IllegalArgumentException(
                         "Start point must be less than or equal to " + "end point");
@@ -1271,5 +1239,11 @@ public final class SearchResult extends AbstractSafeParcelable {
         public int hashCode() {
             return Objects.hash(mStart, mEnd);
         }
+
+        @FlaggedApi(Flags.FLAG_ENABLE_SAFE_PARCELABLE_2)
+        @Override
+        public void writeToParcel(@NonNull Parcel dest, int flags) {
+            MatchRangeCreator.writeToParcel(this, dest, flags);
+        }
     }
 }
diff --git a/framework/java/external/android/app/appsearch/SearchResultPage.java b/framework/java/external/android/app/appsearch/SearchResultPage.java
index 8aacd867..7d0e56c5 100644
--- a/framework/java/external/android/app/appsearch/SearchResultPage.java
+++ b/framework/java/external/android/app/appsearch/SearchResultPage.java
@@ -37,6 +37,9 @@ public class SearchResultPage extends AbstractSafeParcelable {
     public static final Parcelable.@NonNull Creator<SearchResultPage> CREATOR =
             new SearchResultPageCreator();
 
+    /** A value 0 means that there are no more pages in the search results. */
+    public static final long EMPTY_PAGE_TOKEN = 0;
+
     @Field(id = 1, getter = "getNextPageToken")
     private final long mNextPageToken;
 
@@ -53,7 +56,7 @@ public class SearchResultPage extends AbstractSafeParcelable {
 
     /** Default constructor for {@link SearchResultPage}. */
     public SearchResultPage() {
-        mNextPageToken = 0;
+        mNextPageToken = EMPTY_PAGE_TOKEN;
         mResults = Collections.emptyList();
     }
 
diff --git a/service/Android.bp b/service/Android.bp
index 9f72bedf..3199fa18 100644
--- a/service/Android.bp
+++ b/service/Android.bp
@@ -52,12 +52,13 @@ java_defaults {
     static_libs: [
         "com.android.appsearch.isolated_storage_service.aidl-java",
         "com.android.isolated_storage_service.aidl-java",
+
+        // Entries below this line are outside of the appsearch package tree and must be kept in
+        // sync with jarjar.txt
         "icing-java-proto-lite",
         "libicing-java",
         "statslog-appsearch-lib",
 
-        // Entries below this line are outside of the appsearch package tree and must be kept in
-        // sync with jarjar.txt
         "appsearch_flags_java_lib",
         "modules-utils-preconditions",
     ],
@@ -70,6 +71,10 @@ java_defaults {
         "jspecify",
     ],
     optimize: {
+        enabled: true,
+        optimize: true,
+        shrink: true,
+        shrink_resources: true,
         proguard_flags_files: ["proguard.flags"],
     },
     defaults: [
@@ -90,6 +95,20 @@ java_defaults {
     apex_available: ["com.android.appsearch"],
 }
 
+cc_library {
+    name: "libappsearchservice",
+    header_libs: ["jni_headers"],
+    static_libs: ["libcutils"],
+    shared_libs: ["liblog"],
+    cflags: [
+        "-fvisibility=hidden",
+    ],
+    srcs: ["com_android_server_appsearch_isolated_storage_service_VmStateSignaler.cpp"],
+    stl: "none",
+    min_sdk_version: "33",
+    apex_available: ["com.android.appsearch"],
+}
+
 // A special library created strictly for use by the tests as they need the implementation library
 // but that is not available when building from prebuilts. Using a library with a different name to
 // what is used by the prebuilts ensures that this will never depend on the prebuilt.
diff --git a/service/com_android_server_appsearch_isolated_storage_service_VmStateSignaler.cpp b/service/com_android_server_appsearch_isolated_storage_service_VmStateSignaler.cpp
new file mode 100644
index 00000000..ef686d93
--- /dev/null
+++ b/service/com_android_server_appsearch_isolated_storage_service_VmStateSignaler.cpp
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <cutils/properties.h>
+#include <jni.h>
+#include <log/log.h>
+
+__attribute__ ((visibility ("default")))
+extern "C" void
+Java_com_android_server_appsearch_isolated_1storage_1service_VmStateSignaler_notifyIdle__Z(
+        JNIEnv *env, jclass clazz, jboolean value) {
+    (void) env;
+    (void) clazz;
+
+    if (0 != property_set("appsearch_vm.idle", value ? "1" : "0")) {
+        ALOGE("AppSearch could not set idle property!");
+    }
+}
+
diff --git a/service/java/com/android/server/appsearch/AppSearchComponentFactory.java b/service/java/com/android/server/appsearch/AppSearchComponentFactory.java
index bd53a53d..b4bf8368 100644
--- a/service/java/com/android/server/appsearch/AppSearchComponentFactory.java
+++ b/service/java/com/android/server/appsearch/AppSearchComponentFactory.java
@@ -31,14 +31,16 @@ public final class AppSearchComponentFactory {
     private static volatile ServiceAppSearchConfig sConfigInstance;
 
     /** Gets an instance of ServiceAppSearchConfig for the given executor. */
-    public static ServiceAppSearchConfig getConfigInstance(@NonNull Executor executor) {
+    public static ServiceAppSearchConfig getConfigInstance(
+            @NonNull Executor executor, @NonNull Context context) {
         ServiceAppSearchConfig localRef = sConfigInstance;
         if (localRef == null) {
             synchronized (AppSearchComponentFactory.class) {
                 localRef = sConfigInstance;
                 if (localRef == null) {
                     sConfigInstance =
-                            localRef = FrameworkServiceAppSearchConfig.getInstance(executor);
+                            localRef =
+                                    FrameworkServiceAppSearchConfig.getInstance(executor, context);
                 }
             }
         }
diff --git a/service/java/com/android/server/appsearch/AppSearchManagerService.java b/service/java/com/android/server/appsearch/AppSearchManagerService.java
index e5142808..332e158d 100644
--- a/service/java/com/android/server/appsearch/AppSearchManagerService.java
+++ b/service/java/com/android/server/appsearch/AppSearchManagerService.java
@@ -23,14 +23,15 @@ import static android.app.appsearch.AppSearchResult.RESULT_SECURITY_ERROR;
 import static android.app.appsearch.AppSearchResult.throwableToFailedResult;
 import static android.os.Process.INVALID_UID;
 
-import static com.android.server.appsearch.external.localstorage.stats.SearchStats.VISIBILITY_SCOPE_GLOBAL;
-import static com.android.server.appsearch.external.localstorage.stats.SearchStats.VISIBILITY_SCOPE_LOCAL;
+import static com.android.server.appsearch.external.localstorage.stats.QueryStats.VISIBILITY_SCOPE_GLOBAL;
+import static com.android.server.appsearch.external.localstorage.stats.QueryStats.VISIBILITY_SCOPE_LOCAL;
 import static com.android.server.appsearch.util.ServiceImplHelper.invokeCallbackOnError;
 import static com.android.server.appsearch.util.ServiceImplHelper.invokeCallbackOnResult;
 
 import android.annotation.BinderThread;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.annotation.SuppressLint;
 import android.annotation.UserIdInt;
 import android.annotation.WorkerThread;
 import android.app.appsearch.AppSearchBatchResult;
@@ -42,18 +43,21 @@ import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.CommitBlobResponse;
 import android.app.appsearch.GenericDocument;
+import android.app.appsearch.GetByDocumentIdRequest;
 import android.app.appsearch.GetSchemaResponse;
 import android.app.appsearch.InternalSetSchemaResponse;
 import android.app.appsearch.InternalVisibilityConfig;
 import android.app.appsearch.OpenBlobForReadResponse;
 import android.app.appsearch.OpenBlobForWriteResponse;
 import android.app.appsearch.RemoveBlobResponse;
+import android.app.appsearch.SearchResult;
 import android.app.appsearch.SearchResultPage;
 import android.app.appsearch.SearchSpec;
 import android.app.appsearch.SearchSuggestionResult;
 import android.app.appsearch.SetSchemaResponse;
 import android.app.appsearch.SetSchemaResponse.MigrationFailure;
 import android.app.appsearch.StorageInfo;
+import android.app.appsearch.aidl.AppSearchAttributionSource;
 import android.app.appsearch.aidl.AppSearchBatchResultParcel;
 import android.app.appsearch.aidl.AppSearchResultParcel;
 import android.app.appsearch.aidl.AppSearchResultParcelV2;
@@ -104,24 +108,29 @@ import android.net.Uri;
 import android.os.Binder;
 import android.os.Build;
 import android.os.ParcelFileDescriptor;
+import android.os.Process;
 import android.os.RemoteException;
 import android.os.SystemClock;
 import android.os.UserHandle;
+import android.util.ArrayMap;
 import android.util.ArraySet;
 import android.util.Log;
 
 import com.android.appsearch.flags.Flags;
+import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.LocalManagerRegistry;
 import com.android.server.SystemService;
 import com.android.server.appsearch.external.localstorage.stats.CallStats;
 import com.android.server.appsearch.external.localstorage.stats.OptimizeStats;
-import com.android.server.appsearch.external.localstorage.stats.SearchStats;
+import com.android.server.appsearch.external.localstorage.stats.QueryStats;
 import com.android.server.appsearch.external.localstorage.stats.SetSchemaStats;
 import com.android.server.appsearch.external.localstorage.usagereporting.SearchSessionStatsExtractor;
 import com.android.server.appsearch.external.localstorage.visibilitystore.CallerAccess;
 import com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityStore;
+import com.android.server.appsearch.isolated_storage_service.IsolatedStorageServiceManager;
 import com.android.server.appsearch.observer.AppSearchObserverProxy;
+import com.android.server.appsearch.stats.PlatformLogger;
 import com.android.server.appsearch.stats.StatsCollector;
 import com.android.server.appsearch.transformer.EnterpriseSearchResultPageTransformer;
 import com.android.server.appsearch.transformer.EnterpriseSearchSpecTransformer;
@@ -136,6 +145,7 @@ import com.android.server.usage.StorageStatsManagerLocal.StorageStatsAugmenter;
 import com.google.android.icing.proto.DebugInfoProto;
 import com.google.android.icing.proto.DebugInfoVerbosity;
 import com.google.android.icing.proto.PersistType;
+import com.google.android.icing.proto.StorageInfoProto;
 
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
@@ -151,7 +161,12 @@ import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.ReentrantLock;
 
 /**
  * The main service implementation which contains AppSearch's platform functionality.
@@ -184,6 +199,7 @@ public class AppSearchManagerService extends SystemService {
     private PackageManager mPackageManager;
     private RoleManager mRoleManager;
     private ServiceImplHelper mServiceImplHelper;
+    private IsolatedStorageServiceManager mIsolatedStorageServiceManager;
     private AppSearchUserInstanceManager mAppSearchUserInstanceManager;
 
     // Keep a reference for the lifecycle instance, so we can access other services like
@@ -191,14 +207,29 @@ public class AppSearchManagerService extends SystemService {
     private final AppSearchModule.Lifecycle mLifecycle;
     private final SearchSessionStatsExtractor mSearchSessionStatsExtractor;
 
+    // Tracks the scheduled persistToDisk task, ensuring only one persistToDisk task is scheduled
+    // at a time.
+    //TODO(b/405169836) Consider moving the ScheduledFutures to a better place, e.g.,
+    // AppSearchUserInstance.
+    @GuardedBy("mPerUserPersistToDiskFutureLocked")
+    private final Map<UserHandle, ScheduledFuture<?>> mPerUserPersistToDiskFutureLocked =
+            new ArrayMap<>();
+
     public AppSearchManagerService(Context context, AppSearchModule.Lifecycle lifecycle) {
         super(context);
         mContext = Objects.requireNonNull(context);
         mLifecycle = Objects.requireNonNull(lifecycle);
         mAppSearchEnvironment = AppSearchEnvironmentFactory.getEnvironmentInstance();
-        mAppSearchConfig = AppSearchComponentFactory.getConfigInstance(SHARED_EXECUTOR);
+        mAppSearchConfig = AppSearchComponentFactory.getConfigInstance(SHARED_EXECUTOR, mContext);
         mExecutorManager = new ExecutorManager(mAppSearchConfig);
         mSearchSessionStatsExtractor = new SearchSessionStatsExtractor();
+        if (IsolatedStorageServiceManager.useIsolatedStorage(mContext, mAppSearchConfig)) {
+            Log.i(TAG, "Isolated storage is enabled.");
+            mIsolatedStorageServiceManager =
+                    new IsolatedStorageServiceManager(mContext, mAppSearchConfig, SHARED_EXECUTOR);
+        } else {
+            Log.i(TAG, "Isolated storage is not enabled.");
+        }
     }
 
     @Override
@@ -212,6 +243,24 @@ public class AppSearchManagerService extends SystemService {
         LocalManagerRegistry.getManager(StorageStatsManagerLocal.class)
                 .registerStorageStatsAugmenter(new AppSearchStorageStatsAugmenter(), TAG);
         LocalManagerRegistry.addManager(LocalService.class, new LocalService());
+        initializeIsolatedStorageIfNeeded();
+    }
+
+    private void initializeIsolatedStorageIfNeeded() {
+        if (mIsolatedStorageServiceManager == null) {
+            Log.i(TAG, "Isolated storage is not enabled, no need to initialize it");
+            return;
+        }
+        mExecutorManager.executeLambdaForUserNoCallbackAsync(
+                UserHandle.SYSTEM,
+                () -> {
+                    Log.i(TAG, "Initializing isolated storage service");
+                    try {
+                        mIsolatedStorageServiceManager.initialize();
+                    } catch (AppSearchException e) {
+                        Log.e(TAG, "Unable to prepare IsolatedStorageServiceManager", e);
+                    }
+                });
     }
 
     @Override
@@ -254,11 +303,7 @@ public class AppSearchManagerService extends SystemService {
                             "Extra " + Intent.EXTRA_USER + " is missing in the intent: " + intent);
                     return;
                 }
-                // We can handle user removal the same way as user stopping: shut down the executor
-                // and close icing. The data of AppSearch is saved in the "credential encrypted"
-                // system directory of each user. That directory will be auto-deleted when a user is
-                // removed, so we don't need it handle it specially.
-                onUserStopping(userHandle);
+                onUserRemoved(userHandle);
             } else {
                 Log.e(TAG, "Received unknown intent: " + intent);
             }
@@ -326,7 +371,11 @@ public class AppSearchManagerService extends SystemService {
                                     mAppSearchEnvironment.createContextAsUser(mContext, userHandle);
                             AppSearchUserInstance instance =
                                     mAppSearchUserInstanceManager.getOrCreateUserInstance(
-                                            userContext, userHandle, mAppSearchConfig);
+                                            userContext,
+                                            userHandle,
+                                            mAppSearchConfig,
+                                            mExecutorManager,
+                                            mIsolatedStorageServiceManager);
                             instance.getAppSearchImpl().clearPackageData(packageName);
                             dispatchChangeNotifications(instance);
                             instance.getLogger().removeCacheForPackage(packageName);
@@ -344,6 +393,13 @@ public class AppSearchManagerService extends SystemService {
         UserHandle userHandle = user.getUserHandle();
         mServiceImplHelper.setUserIsLocked(userHandle, false);
 
+        if (mIsolatedStorageServiceManager != null) {
+            SHARED_EXECUTOR.execute(
+                    () ->
+                            mIsolatedStorageServiceManager.onUserUnlocking(
+                                    mAppSearchConfig, userHandle));
+        }
+
         // Only schedule task if AppSearch exists for this user.
         if (mAppSearchEnvironment.getAppSearchDir(mContext, userHandle).exists()) {
             mExecutorManager.executeLambdaForUserNoCallbackAsync(
@@ -358,7 +414,9 @@ public class AppSearchManagerService extends SystemService {
                                     mAppSearchUserInstanceManager.getOrCreateUserInstance(
                                             userContext,
                                             userHandle,
-                                            mAppSearchConfig);
+                                            mAppSearchConfig,
+                                            mExecutorManager,
+                                            mIsolatedStorageServiceManager);
                             List<PackageInfo> installedPackageInfos = userContext
                                     .getPackageManager()
                                     .getInstalledPackages(/* flags= */ 0);
@@ -390,18 +448,52 @@ public class AppSearchManagerService extends SystemService {
     @Override
     public void onUserStopping(@NonNull TargetUser user) {
         Objects.requireNonNull(user);
-        onUserStopping(user.getUserHandle());
+        onUserStopping(user.getUserHandle(), /* requiresShutdown= */ false);
     }
 
-    private void onUserStopping(@NonNull UserHandle userHandle) {
+    private void onUserStopping(@NonNull UserHandle userHandle, boolean requiresShutdown) {
         Objects.requireNonNull(userHandle);
         if (LogUtil.INFO) {
             Log.i(TAG, "Shutting down AppSearch for user " + userHandle);
         }
         try {
             mServiceImplHelper.setUserIsLocked(userHandle, true);
-            mExecutorManager.shutDownAndRemoveUserExecutor(userHandle);
-            mAppSearchUserInstanceManager.closeAndRemoveUserInstance(userHandle);
+
+            ScheduledFuture<?> persistToDiskFuture;
+            synchronized (mPerUserPersistToDiskFutureLocked) {
+                persistToDiskFuture = mPerUserPersistToDiskFutureLocked.remove(userHandle);
+            }
+            if (persistToDiskFuture != null) {
+                // Cancel the persistToDisk task if it is scheduled but has not yet started.
+                persistToDiskFuture.cancel(/* mayInterruptIfRunning= */ false);
+            }
+
+            if (mIsolatedStorageServiceManager == null
+                    || !IsolatedStorageServiceManager.isUserAllowed(userHandle)
+                    || requiresShutdown) {
+                if (LogUtil.INFO) {
+                    Log.i(TAG,
+                            "Shutting down executor and closing AppSearch for user " + userHandle);
+                }
+                mExecutorManager.shutDownAndRemoveUserExecutor(userHandle);
+                mAppSearchUserInstanceManager.closeAndRemoveUserInstance(userHandle);
+            } else {
+                if (LogUtil.INFO) {
+                    Log.i(TAG, "Scheduling close for AppSearch for user " + userHandle);
+                }
+                mExecutorManager.executeLambdaForUserNoCallbackAsync(userHandle, () -> {
+                    if (LogUtil.INFO) {
+                        Log.i(TAG, "Closing AppSearch for user " + userHandle);
+                    }
+                    // The user instance is removed in a locked critical section and then its
+                    // AppSearchImpl is closed outside of that section. This is safe currently
+                    // in a single-threaded environment but possibly dangerous in a
+                    // multi-threaded environment in the case that an initialize() task manages
+                    // to create a new AppSearchImpl at the same time
+                    mAppSearchUserInstanceManager.closeAndRemoveUserInstance(userHandle);
+                });
+            }
+
             AppSearchMaintenanceService.cancelFullyPersistJobIfScheduled(
                     mContext, userHandle.getIdentifier());
             if (LogUtil.INFO) {
@@ -413,12 +505,44 @@ public class AppSearchManagerService extends SystemService {
         }
     }
 
+    // When a user is removed, two INTENTS are received: one for userStopped and one for
+    // userRemoved. When onUserStopped is called, the AppSearch instance is destroyed and
+    // marked as "closed". However, during destruction we do not know if onUserStopped was
+    // called because a user paused their profile or the profile is being removed. Thus we
+    // cannot remove user data in onUserStopped. Create a specific onUserRemoved function
+    // to ensure the user data is properly destroyed when a user profile is removed.
+    private void onUserRemoved(@NonNull UserHandle userHandle) {
+        Objects.requireNonNull(userHandle);
+        if (LogUtil.INFO) {
+            Log.i(TAG, "Removing AppSearch user and associated data for user " + userHandle);
+        }
+        // We can handle user removal the same way as user stopping: shut down the executor
+        // and close icing. The data of AppSearch is saved in the "credential encrypted"
+        // system directory of each user. That directory will be auto-deleted when a user is
+        // removed, so we don't need it handle it specially.
+        //
+        // When isolated storage is enabled, we must explicitly delete the data in the AppSearch
+        // user instance.
+        onUserStopping(userHandle, /* requiresShutdown= */ true);
+        Context userContext = mAppSearchEnvironment.createContextAsUser(mContext, userHandle);
+        try {
+            mAppSearchUserInstanceManager.removeUserData(
+                    userHandle, userContext, mAppSearchConfig, mIsolatedStorageServiceManager);
+        } catch (RuntimeException e) {
+            Log.e(TAG, "Unable to remove user data: " + userHandle, e);
+        }
+    }
+
     class LocalService {
         /** Persist all pending mutation operation to disk for the given user. */
-        public void doFullyPersistForUser(@UserIdInt int userId) throws AppSearchException {
+        public void doFullyPersistForUser(@UserIdInt int userId)
+                throws AppSearchException,
+                        CancellationException,
+                        ExecutionException,
+                        InterruptedException {
             UserHandle targetUser = UserHandle.getUserHandleForUid(userId);
             AppSearchUserInstance instance =
-                mAppSearchUserInstanceManager.getUserInstance(targetUser);
+                    mAppSearchUserInstanceManager.getUserInstance(targetUser);
             instance.getAppSearchImpl().persistToDisk(PersistType.Code.FULL);
         }
     }
@@ -430,6 +554,8 @@ public class AppSearchManagerService extends SystemService {
                 @NonNull IAppSearchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
+
             checkUnsupportedEmbeddingUse(request.getSchemas());
 
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
@@ -504,7 +630,10 @@ public class AppSearchManagerService extends SystemService {
                             .setOptimizeLatencyMillis(
                                     (int) (checkForOptimizeLatencyEndTimeMillis
                                             - checkForOptimizeLatencyStartTimeMillis));
-                } catch (AppSearchException | RuntimeException e) {
+                } catch (AppSearchException
+                         | RuntimeException
+                         | InterruptedException
+                         | ExecutionException e) {
                     ++operationFailureCount;
                     AppSearchResult<Void> failedResult = throwableToFailedResult(e);
                     statusCode = failedResult.getResultCode();
@@ -522,6 +651,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setDatabase(request.getDatabaseName())
                                 .setStatusCode(statusCode)
                                 .setTotalLatencyMillis(totalLatencyMillis)
+                                .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                                 .setCallType(CallStats.CALL_TYPE_SET_SCHEMA)
                                 // TODO(b/173532925) check the existing binder call latency chart
                                 // is good enough for us:
@@ -537,6 +667,23 @@ public class AppSearchManagerService extends SystemService {
                                 .setTotalLatencyMillis(totalLatencyMillis)
                                 .setLaunchVMEnabled(instance.isVMEnabled())
                                 .build());
+
+                        SetSchemaStats setSchemaStats =
+                                setSchemaStatsBuilder
+                                    .setStatusCode(statusCode)
+                                    .setSchemaMigrationCallType(request
+                                        .getSchemaMigrationCallType())
+                                    .setTotalLatencyMillis(totalLatencyMillis)
+                                    .setLaunchVMEnabled(instance.isVMEnabled())
+                                    .build();
+                        if (setSchemaStats.getNewTypeCount() > 0
+                                || setSchemaStats.getDeletedTypeCount() > 0
+                                || setSchemaStats.getCompatibleTypeChangeCount() > 0
+                                || setSchemaStats.getIndexIncompatibleTypeChangeCount() > 0
+                                || setSchemaStats.getBackwardsIncompatibleTypeChangeCount() > 0) {
+                            // Drop the cache only if there has been a change in this setSchema call
+                            dropStorageInfoCacheForUser(targetUser);
+                        }
                     }
                 }
             });
@@ -554,6 +701,7 @@ public class AppSearchManagerService extends SystemService {
                 @NonNull IAppSearchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
 
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
             UserHandle targetUser = mServiceImplHelper.verifyIncomingCallWithCallback(
@@ -605,7 +753,10 @@ public class AppSearchManagerService extends SystemService {
                     invokeCallbackOnResult(callback, AppSearchResultParcel
                             .fromGetSchemaResponse(response)
                     );
-                } catch (AppSearchException | RuntimeException e) {
+                } catch (AppSearchException
+                         | RuntimeException
+                         | InterruptedException
+                         | ExecutionException e) {
                     ++operationFailureCount;
                     AppSearchResult<Void> failedResult = throwableToFailedResult(e);
                     statusCode = failedResult.getResultCode();
@@ -623,6 +774,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setDatabase(request.getDatabaseName())
                                 .setStatusCode(statusCode)
                                 .setTotalLatencyMillis(totalLatencyMillis)
+                                .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                                 .setCallType(callType)
                                 // TODO(b/173532925) check the existing binder call latency chart
                                 // is good enough for us:
@@ -648,6 +800,7 @@ public class AppSearchManagerService extends SystemService {
                 @NonNull IAppSearchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
 
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
             UserHandle targetUser = mServiceImplHelper.verifyIncomingCallWithCallback(
@@ -677,7 +830,10 @@ public class AppSearchManagerService extends SystemService {
                     invokeCallbackOnResult(callback, AppSearchResultParcel
                             .fromStringList(namespaces)
                     );
-                } catch (AppSearchException | RuntimeException e) {
+                } catch (AppSearchException
+                         | RuntimeException
+                         | InterruptedException
+                         | ExecutionException e) {
                     ++operationFailureCount;
                     AppSearchResult<Void> failedResult = throwableToFailedResult(e);
                     statusCode = failedResult.getResultCode();
@@ -695,6 +851,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setDatabase(request.getDatabaseName())
                                 .setStatusCode(statusCode)
                                 .setTotalLatencyMillis(totalLatencyMillis)
+                                .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                                 .setCallType(CallStats.CALL_TYPE_GET_NAMESPACES)
                                 // TODO(b/173532925) check the existing binder call latency chart
                                 // is good enough for us:
@@ -721,6 +878,7 @@ public class AppSearchManagerService extends SystemService {
                 @NonNull IAppSearchBatchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
 
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
             UserHandle targetUser = mServiceImplHelper.verifyIncomingCallWithCallback(
@@ -809,8 +967,15 @@ public class AppSearchManagerService extends SystemService {
                             }
                         }
 
-                        // Now that the batch has been written. Persist the newly written data.
-                        instance.getAppSearchImpl().persistToDisk(PersistType.Code.LITE);
+                        // Now that the batch has been written, persist the newly written data.
+                        if (Flags.enableDelayedPersistToDisk()) {
+                            schedulePersistToDisk(targetUser, instance,
+                                    mAppSearchConfig.getLightweightPersistType(),
+                                    mAppSearchConfig.getCachedPersistDelayMillis());
+                        } else {
+                            instance.getAppSearchImpl().persistToDisk(
+                                    mAppSearchConfig.getLightweightPersistType());
+                        }
                     } else {
                         if (!documentParcels.isEmpty() || !takenActionDocumentParcels.isEmpty()) {
                             // List to hold the current batch.
@@ -852,7 +1017,8 @@ public class AppSearchManagerService extends SystemService {
                                 takenActionGenericDocuments.add(document);
                                 currentBatch.add(document);
                             }
-                            // flush the last batch with PersistType.Code.LITE.
+                            // flush the last batch with
+                            // mAppSearchConfig.getLightweightPersistType().
                             instance.getAppSearchImpl().batchPutDocuments(
                                     callingPackageName,
                                     request.getDatabaseName(),
@@ -860,7 +1026,10 @@ public class AppSearchManagerService extends SystemService {
                                     resultBuilder,
                                     /* sendChangeNotifications=*/ true,
                                     instance.getLogger(),
-                                    PersistType.Code.LITE);
+                                    PersistType.Code.UNKNOWN);
+                            schedulePersistToDisk(targetUser, instance,
+                                    mAppSearchConfig.getLightweightPersistType(),
+                                    mAppSearchConfig.getCachedPersistDelayMillis());
                         }
                     }
 
@@ -897,7 +1066,10 @@ public class AppSearchManagerService extends SystemService {
                             instance,
                             /* mutateBatchSize= */
                             request.getDocumentsParcel().getTotalDocumentCount());
-                } catch (AppSearchException | RuntimeException e) {
+                } catch (AppSearchException
+                         | RuntimeException
+                         | InterruptedException
+                         | ExecutionException e) {
                     ++operationFailureCount;
                     AppSearchResult<Void> failedResult = throwableToFailedResult(e);
                     statusCode = failedResult.getResultCode();
@@ -905,6 +1077,7 @@ public class AppSearchManagerService extends SystemService {
                 } finally {
                     // TODO(b/261959320) add outstanding latency fields in AppSearch stats
                     if (instance != null) {
+                        dropStorageInfoCacheForUser(targetUser);
                         int estimatedBinderLatencyMillis =
                                 2 * (int) (totalLatencyStartTimeMillis
                                         - request.getBinderCallStartTimeMillis());
@@ -915,6 +1088,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setDatabase(request.getDatabaseName())
                                 .setStatusCode(statusCode)
                                 .setTotalLatencyMillis(totalLatencyMillis)
+                                .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                                 .setCallType(CallStats.CALL_TYPE_PUT_DOCUMENTS)
                                 // TODO(b/173532925) check the existing binder call latency chart
                                 // is good enough for us:
@@ -954,6 +1128,7 @@ public class AppSearchManagerService extends SystemService {
                 @NonNull IAppSearchBatchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
 
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
             UserHandle targetUser = mServiceImplHelper.verifyIncomingCallWithCallback(
@@ -1010,65 +1185,137 @@ public class AppSearchManagerService extends SystemService {
                 int operationSuccessCount = 0;
                 int operationFailureCount = 0;
                 try {
+                    instance = mAppSearchUserInstanceManager.getUserInstance(userToQuery);
                     AppSearchBatchResult.Builder<String, GenericDocumentParcel> resultBuilder =
                             new AppSearchBatchResult.Builder<>();
-                    instance = mAppSearchUserInstanceManager.getUserInstance(userToQuery);
-                    for (String id : request.getGetByDocumentIdRequest().getIds()) {
-                        try {
-                            GenericDocument document;
-                            if (global) {
-                                boolean callerHasSystemAccess = instance.getVisibilityChecker()
-                                        .doesCallerHaveSystemAccess(
-                                                request.getCallerAttributionSource()
-                                                        .getPackageName());
-                                Map<String, List<String>> typePropertyPaths =
-                                        request.getGetByDocumentIdRequest().getProjections();
-                                if (request.isForEnterprise()) {
-                                    EnterpriseSearchSpecTransformer.transformPropertiesMap(
-                                            typePropertyPaths);
+
+                    if (!Flags.enableBatchGet()) {
+                        for (String id : request.getGetByDocumentIdRequest().getIds()) {
+                            try {
+                                GenericDocument document;
+                                if (global) {
+                                    boolean callerHasSystemAccess = instance.getVisibilityChecker()
+                                            .doesCallerHaveSystemAccess(
+                                                    request.getCallerAttributionSource()
+                                                            .getPackageName());
+                                    Map<String, List<String>> typePropertyPaths =
+                                            request.getGetByDocumentIdRequest().getProjections();
+                                    if (request.isForEnterprise()) {
+                                        EnterpriseSearchSpecTransformer.transformPropertiesMap(
+                                                typePropertyPaths);
+                                    }
+                                    document = instance.getAppSearchImpl().globalGetDocument(
+                                            request.getTargetPackageName(),
+                                            request.getDatabaseName(),
+                                            request.getGetByDocumentIdRequest().getNamespace(),
+                                            id,
+                                            typePropertyPaths,
+                                            new FrameworkCallerAccess(
+                                                    request.getCallerAttributionSource(),
+                                                    callerHasSystemAccess,
+                                                    request.isForEnterprise()));
+                                    if (request.isForEnterprise()) {
+                                        document =
+                                                EnterpriseSearchResultPageTransformer
+                                                        .transformDocument(
+                                                                request.getTargetPackageName(),
+                                                                request.getDatabaseName(),
+                                                                document);
+                                    }
+                                } else {
+                                    document = instance.getAppSearchImpl().getDocument(
+                                            request.getTargetPackageName(),
+                                            request.getDatabaseName(),
+                                            request.getGetByDocumentIdRequest().getNamespace(),
+                                            id,
+                                            request.getGetByDocumentIdRequest().getProjections());
                                 }
-                                document = instance.getAppSearchImpl().globalGetDocument(
-                                        request.getTargetPackageName(),
-                                        request.getDatabaseName(),
-                                        request.getGetByDocumentIdRequest().getNamespace(),
-                                        id,
-                                        typePropertyPaths,
-                                        new FrameworkCallerAccess(
-                                                request.getCallerAttributionSource(),
-                                                callerHasSystemAccess,
-                                                request.isForEnterprise()));
-                                if (request.isForEnterprise()) {
-                                    document =
-                                            EnterpriseSearchResultPageTransformer.transformDocument(
-                                                    request.getTargetPackageName(),
-                                                    request.getDatabaseName(),
-                                                    document);
+                                ++operationSuccessCount;
+                                resultBuilder.setSuccess(id, document.getDocumentParcel());
+                            } catch (AppSearchException | RuntimeException e) {
+                                // Since we can only include one status code in the atom,
+                                // for failures, we would just save the one for the last failure
+                                // Also, we don't rethrow here, so we can keep trying for
+                                // the following ones.
+                                AppSearchResult<GenericDocumentParcel> result =
+                                        throwableToFailedResult(e);
+                                resultBuilder.setResult(id, result);
+                                statusCode = result.getResultCode();
+                                ++operationFailureCount;
+                            }
+                        }
+                    } else if (!request.getGetByDocumentIdRequest().getIds().isEmpty()) {
+                        AppSearchBatchResult<String, GenericDocument> getDocumentsResult;
+                        if (global) {
+                            boolean callerHasSystemAccess = instance.getVisibilityChecker()
+                                    .doesCallerHaveSystemAccess(
+                                            request.getCallerAttributionSource()
+                                                    .getPackageName());
+                            GetByDocumentIdRequest getByDocumentIdRequest =
+                                    request.getGetByDocumentIdRequest();
+                            if (request.isForEnterprise()) {
+                                // Rebuild a GetByDocumentIdRequest with
+                                // a modified typePropertyPaths
+                                GetByDocumentIdRequest.Builder builder =
+                                        new GetByDocumentIdRequest.Builder(
+                                                getByDocumentIdRequest.getNamespace());
+                                builder.addIds(getByDocumentIdRequest.getIds());
+                                Map<String, List<String>> typePropertyPaths =
+                                        getByDocumentIdRequest.getProjections();
+                                EnterpriseSearchSpecTransformer.transformPropertiesMap(
+                                        typePropertyPaths);
+                                for (Map.Entry<String, List<String>> entry :
+                                        typePropertyPaths.entrySet()) {
+                                    builder.addProjection(entry.getKey(), entry.getValue());
                                 }
-                            } else {
-                                document = instance.getAppSearchImpl().getDocument(
+                                getByDocumentIdRequest = builder.build();
+                            }
+                            getDocumentsResult = instance.getAppSearchImpl().batchGetDocuments(
+                                    request.getTargetPackageName(),
+                                    request.getDatabaseName(),
+                                    getByDocumentIdRequest,
+                                    new FrameworkCallerAccess(
+                                            request.getCallerAttributionSource(),
+                                            callerHasSystemAccess,
+                                            request.isForEnterprise()));
+                        } else {
+                            getDocumentsResult = instance.getAppSearchImpl().batchGetDocuments(
+                                    request.getTargetPackageName(),
+                                    request.getDatabaseName(),
+                                    request.getGetByDocumentIdRequest(),
+                                    /*callerAccess=*/ null);
+                        }
+
+                        // Build the result to be returned.
+                        for (Map.Entry<String, GenericDocument> entry :
+                                getDocumentsResult.getSuccesses().entrySet()) {
+                            GenericDocument document = entry.getValue();
+                            if (request.isForEnterprise()) {
+                                document = EnterpriseSearchResultPageTransformer.transformDocument(
                                         request.getTargetPackageName(),
                                         request.getDatabaseName(),
-                                        request.getGetByDocumentIdRequest().getNamespace(),
-                                        id,
-                                        request.getGetByDocumentIdRequest().getProjections());
+                                        document);
                             }
                             ++operationSuccessCount;
-                            resultBuilder.setSuccess(id, document.getDocumentParcel());
-                        } catch (AppSearchException | RuntimeException e) {
-                            // Since we can only include one status code in the atom,
-                            // for failures, we would just save the one for the last failure
-                            // Also, we don't rethrow here, so we can keep trying for
-                            // the following ones.
-                            AppSearchResult<GenericDocumentParcel> result =
-                                    throwableToFailedResult(e);
-                            resultBuilder.setResult(id, result);
-                            statusCode = result.getResultCode();
+                            resultBuilder.setSuccess(entry.getKey(), document.getDocumentParcel());
+                        }
+
+                        for (Map.Entry<String, AppSearchResult<GenericDocument>> entry :
+                                getDocumentsResult.getFailures().entrySet()) {
+                            AppSearchResult<GenericDocument> failure = entry.getValue();
                             ++operationFailureCount;
+                            statusCode = failure.getResultCode();
+                            // We can't use the result from Icing directly as the type is
+                            // AppSearchResult<GenericDocument>,
+                            // not AppSearchResult<GenericDocumentParcel>
+                            resultBuilder.setResult(entry.getKey(),
+                                    AppSearchResult.newFailedResult(failure));
                         }
                     }
+
                     invokeCallbackOnResult(callback, AppSearchBatchResultParcel
                             .fromStringToGenericDocumentParcel(resultBuilder.build()));
-                } catch (RuntimeException e) {
+                } catch (RuntimeException | InterruptedException | ExecutionException e) {
                     ++operationFailureCount;
                     AppSearchResult<Void> failedResult = throwableToFailedResult(e);
                     statusCode = failedResult.getResultCode();
@@ -1086,6 +1333,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setDatabase(request.getDatabaseName())
                                 .setStatusCode(statusCode)
                                 .setTotalLatencyMillis(totalLatencyMillis)
+                                .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                                 .setCallType(callType)
                                 // TODO(b/173532925) check the existing binder call latency chart
                                 // is good enough for us:
@@ -1113,6 +1361,7 @@ public class AppSearchManagerService extends SystemService {
                 OpenBlobForWriteAidlRequest request, @NonNull IAppSearchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
             UserHandle targetUser =
                     mServiceImplHelper.verifyIncomingCallWithCallback(
@@ -1162,7 +1411,7 @@ public class AppSearchManagerService extends SystemService {
                             new OpenBlobForWriteResponse(resultBuilder.build());
                     invokeCallbackOnResult(callback,
                             AppSearchResultParcelV2.fromOpenBlobForWriteResponse(response));
-                } catch (RuntimeException e) {
+                } catch (RuntimeException | InterruptedException | ExecutionException e) {
                     ++operationFailureCount;
                     AppSearchResult<Void> failedResult = throwableToFailedResult(e);
                     statusCode = failedResult.getResultCode();
@@ -1170,6 +1419,7 @@ public class AppSearchManagerService extends SystemService {
                             AppSearchResultParcelV2.fromFailedResult(failedResult));
                 } finally {
                     if (instance != null) {
+                        dropStorageInfoCacheForUser(targetUser);
                         int estimatedBinderLatencyMillis =
                                 2 * (int) (totalLatencyStartTimeMillis -
                                         request.getBinderCallStartTimeMillis());
@@ -1181,6 +1431,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setDatabase(request.getCallingDatabaseName())
                                 .setCallType(CallStats.CALL_TYPE_OPEN_WRITE_BLOB)
                                 .setStatusCode(statusCode)
+                                .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                                 .setTotalLatencyMillis(totalLatencyMillis)
                                 // TODO(b/173532925) check the existing binder call latency chart
                                 // is good enough for us:
@@ -1212,6 +1463,8 @@ public class AppSearchManagerService extends SystemService {
                 RemoveBlobAidlRequest request, @NonNull IAppSearchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
+
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
             UserHandle targetUser =
                     mServiceImplHelper.verifyIncomingCallWithCallback(
@@ -1260,7 +1513,7 @@ public class AppSearchManagerService extends SystemService {
                     RemoveBlobResponse response = new RemoveBlobResponse(resultBuilder.build());
                     invokeCallbackOnResult(callback,
                             AppSearchResultParcelV2.fromRemoveBlobResponseParcel(response));
-                } catch (RuntimeException e) {
+                } catch (RuntimeException | InterruptedException | ExecutionException e) {
                     ++operationFailureCount;
                     AppSearchResult<Void> failedResult = throwableToFailedResult(e);
                     statusCode = failedResult.getResultCode();
@@ -1268,6 +1521,7 @@ public class AppSearchManagerService extends SystemService {
                             AppSearchResultParcelV2.fromFailedResult(failedResult));
                 } finally {
                     if (instance != null) {
+                        dropStorageInfoCacheForUser(targetUser);
                         int estimatedBinderLatencyMillis =
                                 2 * (int) (totalLatencyStartTimeMillis -
                                         request.getBinderCallStartTimeMillis());
@@ -1279,6 +1533,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setDatabase(request.getCallingDatabaseName())
                                 .setCallType(CallStats.CALL_TYPE_REMOVE_BLOB)
                                 .setStatusCode(statusCode)
+                                .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                                 .setTotalLatencyMillis(totalLatencyMillis)
                                 // TODO(b/173532925) check the existing binder call latency chart
                                 // is good enough for us:
@@ -1310,6 +1565,8 @@ public class AppSearchManagerService extends SystemService {
                 CommitBlobAidlRequest request, @NonNull IAppSearchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
+
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
             UserHandle targetUser =
                     mServiceImplHelper.verifyIncomingCallWithCallback(
@@ -1359,7 +1616,7 @@ public class AppSearchManagerService extends SystemService {
                             new CommitBlobResponse(resultBuilder.build());
                     invokeCallbackOnResult(callback,
                             AppSearchResultParcelV2.fromCommitBlobResponseParcel(response));
-                } catch (RuntimeException e) {
+                } catch (RuntimeException | InterruptedException | ExecutionException e) {
                     ++operationFailureCount;
                     AppSearchResult<Void> failedResult = throwableToFailedResult(e);
                     statusCode = failedResult.getResultCode();
@@ -1367,6 +1624,7 @@ public class AppSearchManagerService extends SystemService {
                             AppSearchResultParcelV2.fromFailedResult(failedResult));
                 } finally {
                     if (instance != null) {
+                        dropStorageInfoCacheForUser(targetUser);
                         int estimatedBinderLatencyMillis =
                                 2 * (int) (totalLatencyStartTimeMillis -
                                         request.getBinderCallStartTimeMillis());
@@ -1378,6 +1636,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setDatabase(request.getCallingDatabaseName())
                                 .setCallType(CallStats.CALL_TYPE_COMMIT_BLOB)
                                 .setStatusCode(statusCode)
+                                .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                                 .setTotalLatencyMillis(totalLatencyMillis)
                                 // TODO(b/173532925) check the existing binder call latency chart
                                 // is good enough for us:
@@ -1410,6 +1669,8 @@ public class AppSearchManagerService extends SystemService {
                 OpenBlobForReadAidlRequest request, @NonNull IAppSearchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
+
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
             UserHandle targetUser =
                     mServiceImplHelper.verifyIncomingCallWithCallback(
@@ -1470,7 +1731,7 @@ public class AppSearchManagerService extends SystemService {
                             new OpenBlobForReadResponse(resultBuilder.build());
                     invokeCallbackOnResult(callback,
                             AppSearchResultParcelV2.fromOpenBlobForReadResponse(response));
-                } catch (RuntimeException e) {
+                } catch (RuntimeException | InterruptedException | ExecutionException e) {
                     ++operationFailureCount;
                     AppSearchResult<Void> failedResult = throwableToFailedResult(e);
                     statusCode = failedResult.getResultCode();
@@ -1489,6 +1750,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setDatabase(request.getCallingDatabaseName())
                                 .setStatusCode(statusCode)
                                 .setCallType(callType)
+                                .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                                 .setTotalLatencyMillis(totalLatencyMillis)
                                 // TODO(b/173532925) check the existing binder call latency chart
                                 // is good enough for us:
@@ -1520,6 +1782,8 @@ public class AppSearchManagerService extends SystemService {
                 SetBlobVisibilityAidlRequest request, @NonNull IAppSearchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
+
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
             UserHandle targetUser =
                     mServiceImplHelper.verifyIncomingCallWithCallback(
@@ -1553,7 +1817,8 @@ public class AppSearchManagerService extends SystemService {
                             visibilityConfigs);
                     ++operationSuccessCount;
                     invokeCallbackOnResult(callback, AppSearchResultParcelV2.fromVoid());
-                } catch (AppSearchException | RuntimeException e) {
+                } catch (AppSearchException | RuntimeException | InterruptedException
+                         | ExecutionException e) {
                     ++operationFailureCount;
                     AppSearchResult<Void> failedResult = throwableToFailedResult(e);
                     statusCode = failedResult.getResultCode();
@@ -1572,6 +1837,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setDatabase(request.getCallingDatabaseName())
                                 .setCallType(CallStats.CALL_TYPE_SET_BLOB_VISIBILITY)
                                 .setStatusCode(statusCode)
+                                .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                                 .setTotalLatencyMillis(totalLatencyMillis)
                                 // TODO(b/173532925) check the existing binder call latency chart
                                 // is good enough for us:
@@ -1604,6 +1870,8 @@ public class AppSearchManagerService extends SystemService {
                 @NonNull IAppSearchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
+
             checkUnsupportedEmbeddingUse(request.getSearchSpec());
 
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
@@ -1637,7 +1905,8 @@ public class AppSearchManagerService extends SystemService {
                     invokeCallbackOnResult(
                             callback,
                             AppSearchResultParcel.fromSearchResultPage(searchResultPage));
-                } catch (AppSearchException | RuntimeException e) {
+                } catch (AppSearchException | RuntimeException | InterruptedException
+                         | ExecutionException e) {
                     ++operationFailureCount;
                     AppSearchResult<Void> failedResult = throwableToFailedResult(e);
                     statusCode = failedResult.getResultCode();
@@ -1654,6 +1923,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setDatabase(request.getDatabaseName())
                                 .setStatusCode(statusCode)
                                 .setTotalLatencyMillis(totalLatencyMillis)
+                                .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                                 .setCallType(CallStats.CALL_TYPE_SEARCH)
                                 // TODO(b/173532925) check the existing binder call latency chart
                                 // is good enough for us:
@@ -1680,6 +1950,8 @@ public class AppSearchManagerService extends SystemService {
                 @NonNull IAppSearchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
+
             checkUnsupportedEmbeddingUse(request.getSearchSpec());
 
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
@@ -1732,7 +2004,8 @@ public class AppSearchManagerService extends SystemService {
                     invokeCallbackOnResult(
                             callback,
                             AppSearchResultParcel.fromSearchResultPage(searchResultPage));
-                } catch (AppSearchException | RuntimeException e) {
+                } catch (AppSearchException | RuntimeException | InterruptedException
+                         | ExecutionException e) {
                     ++operationFailureCount;
                     AppSearchResult<Void> failedResult = throwableToFailedResult(e);
                     statusCode = failedResult.getResultCode();
@@ -1748,6 +2021,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setPackageName(callingPackageName)
                                 .setStatusCode(statusCode)
                                 .setTotalLatencyMillis(totalLatencyMillis)
+                                .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                                 .setCallType(CallStats.CALL_TYPE_GLOBAL_SEARCH)
                                 // TODO(b/173532925) check the existing binder call latency chart
                                 // is good enough for us:
@@ -1774,6 +2048,7 @@ public class AppSearchManagerService extends SystemService {
                 @NonNull IAppSearchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
 
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
             UserHandle targetUser = mServiceImplHelper.verifyIncomingCallWithCallback(
@@ -1806,13 +2081,13 @@ public class AppSearchManagerService extends SystemService {
                 AppSearchUserInstance instance = null;
                 int operationSuccessCount = 0;
                 int operationFailureCount = 0;
-                SearchStats.Builder statsBuilder;
+                QueryStats.Builder statsBuilder;
                 if (global) {
-                    statsBuilder = new SearchStats.Builder(VISIBILITY_SCOPE_GLOBAL,
+                    statsBuilder = new QueryStats.Builder(VISIBILITY_SCOPE_GLOBAL,
                             callingPackageName)
                             .setJoinType(request.getJoinType());
                 } else {
-                    statsBuilder = new SearchStats.Builder(VISIBILITY_SCOPE_LOCAL,
+                    statsBuilder = new QueryStats.Builder(VISIBILITY_SCOPE_LOCAL,
                             callingPackageName)
                             .setDatabase(request.getDatabaseName())
                             .setJoinType(request.getJoinType());
@@ -1831,7 +2106,8 @@ public class AppSearchManagerService extends SystemService {
                     invokeCallbackOnResult(
                             callback,
                             AppSearchResultParcel.fromSearchResultPage(searchResultPage));
-                } catch (AppSearchException | RuntimeException e) {
+                } catch (AppSearchException | RuntimeException | InterruptedException
+                         | ExecutionException e) {
                     ++operationFailureCount;
                     AppSearchResult<Void> failedResult = throwableToFailedResult(e);
                     statusCode = failedResult.getResultCode();
@@ -1848,6 +2124,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setDatabase(request.getDatabaseName())
                                 .setStatusCode(statusCode)
                                 .setTotalLatencyMillis(totalLatencyMillis)
+                                .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                                 .setCallType(callType)
                                 // TODO(b/173532925) check the existing binder call latency chart
                                 // is good enough for us:
@@ -1871,6 +2148,7 @@ public class AppSearchManagerService extends SystemService {
         @Override
         public void invalidateNextPageToken(@NonNull InvalidateNextPageTokenAidlRequest request) {
             Objects.requireNonNull(request);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
 
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
             try {
@@ -1902,7 +2180,8 @@ public class AppSearchManagerService extends SystemService {
                         instance.getAppSearchImpl().invalidateNextPageToken(
                                 callingPackageName, request.getNextPageToken());
                         operationSuccessCount++;
-                    } catch (AppSearchException | RuntimeException e) {
+                    } catch (AppSearchException | RuntimeException | InterruptedException
+                             | ExecutionException e) {
                         ++operationFailureCount;
                         statusCode = throwableToFailedResult(e).getResultCode();
                         Log.e(TAG, "Unable to invalidate the query page token", e);
@@ -1919,6 +2198,7 @@ public class AppSearchManagerService extends SystemService {
                                     .setPackageName(callingPackageName)
                                     .setStatusCode(statusCode)
                                     .setTotalLatencyMillis(totalLatencyMillis)
+                                    .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                                     .setCallType(CallStats.CALL_TYPE_INVALIDATE_NEXT_PAGE_TOKEN)
                                     // TODO(b/173532925) check the existing binder call latency
                                     //  chart
@@ -1951,6 +2231,8 @@ public class AppSearchManagerService extends SystemService {
                 @NonNull IAppSearchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
+
             checkUnsupportedEmbeddingUse(request.getSearchSpec());
 
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
@@ -1999,7 +2281,8 @@ public class AppSearchManagerService extends SystemService {
                         }
                     }
                     invokeCallbackOnResult(callback, AppSearchResultParcel.fromVoid());
-                } catch (AppSearchException | IOException | RuntimeException e) {
+                } catch (AppSearchException | IOException | RuntimeException
+                         | InterruptedException | ExecutionException e) {
                     ++operationFailureCount;
                     AppSearchResult<Void> failedResult = throwableToFailedResult(e);
                     statusCode = failedResult.getResultCode();
@@ -2016,6 +2299,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setDatabase(request.getDatabaseName())
                                 .setStatusCode(statusCode)
                                 .setTotalLatencyMillis(totalLatencyMillis)
+                                .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                                 .setCallType(CallStats.CALL_TYPE_WRITE_SEARCH_RESULTS_TO_FILE)
                                 // TODO(b/173532925) check the existing binder call latency chart
                                 // is good enough for us:
@@ -2042,6 +2326,7 @@ public class AppSearchManagerService extends SystemService {
                 @NonNull IAppSearchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
 
             long callStatsTotalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
             UserHandle targetUser = mServiceImplHelper.verifyIncomingCallWithCallback(
@@ -2106,14 +2391,23 @@ public class AppSearchManagerService extends SystemService {
                             }
                         }
                     }
-                    instance.getAppSearchImpl().persistToDisk(PersistType.Code.FULL);
+                    // Now that the batch has been written, persist the newly written data.
+                    if (Flags.enableDelayedPersistToDisk()) {
+                        schedulePersistToDisk(targetUser, instance,
+                                mAppSearchConfig.getLightweightPersistType(),
+                                mAppSearchConfig.getCachedPersistDelayMillis());
+                    } else {
+                        instance.getAppSearchImpl().persistToDisk(
+                                mAppSearchConfig.getLightweightPersistType());
+                    }
 
                     schemaMigrationStatsBuilder
                             .setTotalSuccessMigratedDocumentCount(operationSuccessCount)
                             .setMigrationFailureCount(migrationFailures.size());
                     invokeCallbackOnResult(callback, AppSearchResultParcel
                             .fromMigrationFailuresList(migrationFailures));
-                } catch (AppSearchException | IOException | RuntimeException e) {
+                } catch (AppSearchException | IOException | RuntimeException
+                         | InterruptedException | ExecutionException e) {
                     ++operationFailureCount;
                     AppSearchResult<Void> failedResult = throwableToFailedResult(e);
                     statusCode = failedResult.getResultCode();
@@ -2121,6 +2415,7 @@ public class AppSearchManagerService extends SystemService {
                             failedResult));
                 } finally {
                     if (instance != null) {
+                        dropStorageInfoCacheForUser(targetUser);
                         long latencyEndTimeMillis =
                                 SystemClock.elapsedRealtime();
                         int estimatedBinderLatencyMillis =
@@ -2142,6 +2437,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setDatabase(request.getDatabaseName())
                                 .setStatusCode(statusCode)
                                 .setTotalLatencyMillis(callStatsTotalLatencyMillis)
+                                .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                                 .setCallType(CallStats.CALL_TYPE_PUT_DOCUMENTS_FROM_FILE)
                                 // TODO(b/173532925) check the existing binder call latency chart
                                 // is good enough for us:
@@ -2177,6 +2473,7 @@ public class AppSearchManagerService extends SystemService {
                 @NonNull IAppSearchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
 
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
             UserHandle targetUser = mServiceImplHelper.verifyIncomingCallWithCallback(
@@ -2211,7 +2508,8 @@ public class AppSearchManagerService extends SystemService {
                     invokeCallbackOnResult(
                             callback, AppSearchResultParcel
                                     .fromSearchSuggestionResultList(searchSuggestionResults));
-                } catch (AppSearchException | RuntimeException e) {
+                } catch (AppSearchException | RuntimeException | InterruptedException
+                         | ExecutionException e) {
                     ++operationFailureCount;
                     AppSearchResult<Void> failedResult = throwableToFailedResult(e);
                     statusCode = failedResult.getResultCode();
@@ -2229,6 +2527,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setDatabase(request.getDatabaseName())
                                 .setStatusCode(statusCode)
                                 .setTotalLatencyMillis(totalLatencyMillis)
+                                .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                                 .setCallType(CallStats.CALL_TYPE_SEARCH_SUGGESTION)
                                 // TODO(b/173532925) check the existing binder call latency chart
                                 // is good enough for us:
@@ -2255,6 +2554,7 @@ public class AppSearchManagerService extends SystemService {
                 @NonNull IAppSearchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
 
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
             UserHandle targetUser = mServiceImplHelper.verifyIncomingCallWithCallback(
@@ -2308,7 +2608,8 @@ public class AppSearchManagerService extends SystemService {
                             request.isSystemUsage());
                     ++operationSuccessCount;
                     invokeCallbackOnResult(callback, AppSearchResultParcel.fromVoid());
-                } catch (AppSearchException | RuntimeException e) {
+                } catch (AppSearchException | RuntimeException | InterruptedException
+                         | ExecutionException e) {
                     ++operationFailureCount;
                     AppSearchResult<Void> failedResult = throwableToFailedResult(e);
                     statusCode = failedResult.getResultCode();
@@ -2316,6 +2617,7 @@ public class AppSearchManagerService extends SystemService {
                             failedResult));
                 } finally {
                     if (instance != null) {
+                        dropStorageInfoCacheForUser(targetUser);
                         int estimatedBinderLatencyMillis =
                                 2 * (int) (totalLatencyStartTimeMillis -
                                         request.getBinderCallStartTimeMillis());
@@ -2326,6 +2628,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setDatabase(request.getDatabaseName())
                                 .setStatusCode(statusCode)
                                 .setTotalLatencyMillis(totalLatencyMillis)
+                                .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                                 .setCallType(callType)
                                 // TODO(b/173532925) check the existing binder call latency chart
                                 // is good enough for us:
@@ -2352,6 +2655,7 @@ public class AppSearchManagerService extends SystemService {
                 @NonNull IAppSearchBatchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
 
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
             UserHandle targetUser = mServiceImplHelper.verifyIncomingCallWithCallback(
@@ -2398,8 +2702,15 @@ public class AppSearchManagerService extends SystemService {
                             ++operationFailureCount;
                         }
                     }
-                    // Now that the batch has been written. Persist the newly written data.
-                    instance.getAppSearchImpl().persistToDisk(PersistType.Code.LITE);
+                    // Now that the batch has been written, persist the newly written data.
+                    if (Flags.enableDelayedPersistToDisk()) {
+                        schedulePersistToDisk(targetUser, instance,
+                                mAppSearchConfig.getLightweightPersistType(),
+                                mAppSearchConfig.getCachedPersistDelayMillis());
+                    } else {
+                        instance.getAppSearchImpl().persistToDisk(
+                                mAppSearchConfig.getLightweightPersistType());
+                    }
                     invokeCallbackOnResult(callback, AppSearchBatchResultParcel.fromStringToVoid(
                             resultBuilder.build()));
 
@@ -2409,7 +2720,8 @@ public class AppSearchManagerService extends SystemService {
 
                     checkForOptimize(targetUser, instance,
                             request.getRemoveByDocumentIdRequest().getIds().size());
-                } catch (AppSearchException | RuntimeException e) {
+                } catch (AppSearchException | RuntimeException | InterruptedException
+                         | ExecutionException e) {
                     ++operationFailureCount;
                     AppSearchResult<Void> failedResult = throwableToFailedResult(e);
                     statusCode = failedResult.getResultCode();
@@ -2417,6 +2729,7 @@ public class AppSearchManagerService extends SystemService {
                 } finally {
                     // TODO(b/261959320) add outstanding latency fields in AppSearch stats
                     if (instance != null) {
+                        dropStorageInfoCacheForUser(targetUser);
                         int estimatedBinderLatencyMillis =
                                 2 * (int) (totalLatencyStartTimeMillis
                                         - request.getBinderCallStartTimeMillis());
@@ -2427,6 +2740,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setDatabase(request.getDatabaseName())
                                 .setStatusCode(statusCode)
                                 .setTotalLatencyMillis(totalLatencyMillis)
+                                .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                                 .setCallType(CallStats.CALL_TYPE_REMOVE_DOCUMENTS_BY_ID)
                                 // TODO(b/173532925) check the existing binder call latency chart
                                 // is good enough for us:
@@ -2454,6 +2768,8 @@ public class AppSearchManagerService extends SystemService {
                 @NonNull IAppSearchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
+
             checkUnsupportedEmbeddingUse(request.getSearchSpec());
 
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
@@ -2484,8 +2800,15 @@ public class AppSearchManagerService extends SystemService {
                             request.getQueryExpression(),
                             request.getSearchSpec(),
                             /* removeStatsBuilder= */ null);
-                    // Now that the batch has been written. Persist the newly written data.
-                    instance.getAppSearchImpl().persistToDisk(PersistType.Code.LITE);
+                    // Now that the batch has been written, persist the newly written data.
+                    if (Flags.enableDelayedPersistToDisk()) {
+                        schedulePersistToDisk(targetUser, instance,
+                                mAppSearchConfig.getLightweightPersistType(),
+                                mAppSearchConfig.getCachedPersistDelayMillis());
+                    } else {
+                        instance.getAppSearchImpl().persistToDisk(
+                                mAppSearchConfig.getLightweightPersistType());
+                    }
                     ++operationSuccessCount;
                     invokeCallbackOnResult(callback, AppSearchResultParcel.fromVoid());
 
@@ -2494,7 +2817,8 @@ public class AppSearchManagerService extends SystemService {
                     dispatchChangeNotifications(instance);
 
                     checkForOptimize(targetUser, instance);
-                } catch (AppSearchException | RuntimeException e) {
+                } catch (AppSearchException | RuntimeException | InterruptedException
+                         | ExecutionException e) {
                     ++operationFailureCount;
                     AppSearchResult<Void> failedResult = throwableToFailedResult(e);
                     statusCode = failedResult.getResultCode();
@@ -2503,6 +2827,7 @@ public class AppSearchManagerService extends SystemService {
                 } finally {
                     // TODO(b/261959320) add outstanding latency fields in AppSearch stats
                     if (instance != null) {
+                        dropStorageInfoCacheForUser(targetUser);
                         int estimatedBinderLatencyMillis =
                                 2 * (int) (totalLatencyStartTimeMillis
                                         - request.getBinderCallStartTimeMillis());
@@ -2513,6 +2838,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setDatabase(request.getDatabaseName())
                                 .setStatusCode(statusCode)
                                 .setTotalLatencyMillis(totalLatencyMillis)
+                                .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                                 .setCallType(CallStats.CALL_TYPE_REMOVE_DOCUMENTS_BY_SEARCH)
                                 // TODO(b/173532925) check the existing binder call latency chart
                                 // is good enough for us:
@@ -2539,6 +2865,7 @@ public class AppSearchManagerService extends SystemService {
                 @NonNull IAppSearchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
 
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
             UserHandle targetUser = mServiceImplHelper.verifyIncomingCallWithCallback(
@@ -2566,7 +2893,8 @@ public class AppSearchManagerService extends SystemService {
                     ++operationSuccessCount;
                     invokeCallbackOnResult(
                             callback, AppSearchResultParcel.fromStorageInfo(storageInfo));
-                } catch (AppSearchException | RuntimeException e) {
+                } catch (AppSearchException | RuntimeException | InterruptedException
+                         | ExecutionException e) {
                     ++operationFailureCount;
                     AppSearchResult<Void> failedResult = throwableToFailedResult(e);
                     statusCode = failedResult.getResultCode();
@@ -2584,6 +2912,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setDatabase(request.getDatabaseName())
                                 .setStatusCode(statusCode)
                                 .setTotalLatencyMillis(totalLatencyMillis)
+                                .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                                 .setCallType(CallStats.CALL_TYPE_GET_STORAGE_INFO)
                                 // TODO(b/173532925) check the existing binder call latency chart
                                 // is good enough for us:
@@ -2607,6 +2936,7 @@ public class AppSearchManagerService extends SystemService {
         @Override
         public void persistToDisk(@NonNull PersistToDiskAidlRequest request) {
             Objects.requireNonNull(request);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
 
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
             try {
@@ -2629,7 +2959,8 @@ public class AppSearchManagerService extends SystemService {
                         instance = mAppSearchUserInstanceManager.getUserInstance(targetUser);
                         instance.getAppSearchImpl().persistToDisk(PersistType.Code.FULL);
                         ++operationSuccessCount;
-                    } catch (AppSearchException | RuntimeException e) {
+                    } catch (AppSearchException | RuntimeException | InterruptedException
+                             | ExecutionException e) {
                         ++operationFailureCount;
                         statusCode = throwableToFailedResult(e).getResultCode();
                         // We will print two error messages if we rethrow, but I would rather keep
@@ -2649,6 +2980,7 @@ public class AppSearchManagerService extends SystemService {
                                     .setPackageName(callingPackageName)
                                     .setStatusCode(statusCode)
                                     .setTotalLatencyMillis(totalLatencyMillis)
+                                    .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                                     .setCallType(CallStats.CALL_TYPE_FLUSH)
                                     // TODO(b/173532925) check the existing binder call latency
                                     // chart is good enough for us:
@@ -2680,6 +3012,7 @@ public class AppSearchManagerService extends SystemService {
                 @NonNull IAppSearchObserverProxy observerProxyStub) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(observerProxyStub);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
 
             @AppSearchResult.ResultCode int statusCode = AppSearchResult.RESULT_OK;
             AppSearchUserInstance instance = null;
@@ -2731,7 +3064,10 @@ public class AppSearchManagerService extends SystemService {
                 } finally {
                     Binder.restoreCallingIdentity(callingIdentity);
                 }
-            } catch (RemoteException | RuntimeException e) {
+            } catch (RemoteException
+                     | RuntimeException
+                     | InterruptedException
+                     | ExecutionException e) {
                 ++operationFailureCount;
                 AppSearchResult<Void> failedResult = throwableToFailedResult(e);
                 statusCode = failedResult.getResultCode();
@@ -2747,6 +3083,7 @@ public class AppSearchManagerService extends SystemService {
                             .setPackageName(callingPackageName)
                             .setStatusCode(statusCode)
                             .setTotalLatencyMillis(totalLatencyMillis)
+                            .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                             .setCallType(CallStats.CALL_TYPE_REGISTER_OBSERVER_CALLBACK)
                             // TODO(b/173532925) check the existing binder call latency chart
                             // is good enough for us:
@@ -2766,6 +3103,7 @@ public class AppSearchManagerService extends SystemService {
                 @NonNull IAppSearchObserverProxy observerProxyStub) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(observerProxyStub);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
 
             @AppSearchResult.ResultCode int statusCode = AppSearchResult.RESULT_OK;
             AppSearchUserInstance instance = null;
@@ -2796,7 +3134,7 @@ public class AppSearchManagerService extends SystemService {
                 } finally {
                     Binder.restoreCallingIdentity(callingIdentity);
                 }
-            } catch (RuntimeException e) {
+            } catch (RuntimeException | InterruptedException | ExecutionException e) {
                 ++operationFailureCount;
                 AppSearchResult<Void> failedResult = throwableToFailedResult(e);
                 statusCode = failedResult.getResultCode();
@@ -2814,6 +3152,7 @@ public class AppSearchManagerService extends SystemService {
                             .setPackageName(callingPackageName)
                             .setStatusCode(statusCode)
                             .setTotalLatencyMillis(totalLatencyMillis)
+                            .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                             .setCallType(CallStats.CALL_TYPE_UNREGISTER_OBSERVER_CALLBACK)
                             // TODO(b/173532925) check the existing binder call latency chart
                             // is good enough for us:
@@ -2833,6 +3172,7 @@ public class AppSearchManagerService extends SystemService {
                 @NonNull IAppSearchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            final long callReceivedTimestampMillis = System.currentTimeMillis();
 
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
             UserHandle targetUser = mServiceImplHelper.verifyIncomingCallWithCallback(
@@ -2861,7 +3201,9 @@ public class AppSearchManagerService extends SystemService {
                     instance = mAppSearchUserInstanceManager.getOrCreateUserInstance(
                             targetUserContext,
                             targetUser,
-                            mAppSearchConfig);
+                            mAppSearchConfig,
+                            mExecutorManager,
+                            mIsolatedStorageServiceManager);
                     ++operationSuccessCount;
                     invokeCallbackOnResult(callback, AppSearchResultParcel.fromVoid());
                 } catch (AppSearchException | RuntimeException e) {
@@ -2881,6 +3223,7 @@ public class AppSearchManagerService extends SystemService {
                                 .setPackageName(callingPackageName)
                                 .setStatusCode(statusCode)
                                 .setTotalLatencyMillis(totalLatencyMillis)
+                                .setCallReceivedTimestampMillis(callReceivedTimestampMillis)
                                 .setCallType(CallStats.CALL_TYPE_INITIALIZE)
                                 // TODO(b/173532925) check the existing binder call latency chart
                                 // is good enough for us:
@@ -3000,6 +3343,7 @@ public class AppSearchManagerService extends SystemService {
             if (args != null) {
                 for (int i = 0; i < args.length; i++) {
                     String arg = args[i];
+
                     if (Objects.equals(arg, "-h")) {
                         pw.println(
                                 "Dumps the internal state of AppSearch platform storage and "
@@ -3010,6 +3354,36 @@ public class AppSearchManagerService extends SystemService {
                         // "-a" is included when adb dumps all services e.g. in adb bugreport so we
                         // want to run in verbose mode when this happens
                         verbose = true;
+                    } else if (arg.startsWith("--query")) {
+                        if (Binder.getCallingUid() != Process.ROOT_UID) {
+                            pw.println("Query requires root.");
+                            return;
+                        }
+                        if (!"eng".equals(Build.TYPE) && !"userdebug".equals(Build.TYPE)) {
+                            pw.println("Query requires eng or userdebug build.");
+                            return;
+                        }
+
+                        String query = arg.substring("--query".length(), arg.length());
+                        if (query.startsWith("=")) {
+                            query = query.substring(1, query.length());
+                        }
+                        if (query.startsWith("\"") && query.endsWith("\"") && query.length() > 1) {
+                            query = query.substring(1, query.length() - 1);
+                        }
+
+                        for (int j = i + 1; j < args.length; j++) {
+                            if (query.length() > 0) query += " ";
+                            query += args[j];
+                        }
+
+                        pw.println("Dump with query: \"" + query + "\"");
+                        runCommandLineQuery(pw, query);
+                        return;
+                    } else {
+                        pw.println(String.format("AppSearch unrecognized arg: \"%s\".", arg));
+                        // TODO: we do not return here, though it's probably okay, it
+                        // may require more testing.
                     }
                 }
             }
@@ -3020,7 +3394,87 @@ public class AppSearchManagerService extends SystemService {
         }
     }
 
+    @BinderThread
+    @SuppressLint("WrongThread")
+    private void runCommandLineQuery(@NonNull PrintWriter pw, @NonNull String query) {
+        Objects.requireNonNull(pw);
+        UserHandle currentUser = UserHandle.getUserHandleForUid(Binder.getCallingUid());
+        try {
+            AppSearchUserInstance instance =
+                    mAppSearchUserInstanceManager.getUserInstance(currentUser);
+            SearchSpec querySearchSpec =
+                    new SearchSpec.Builder()
+                            .setTermMatch(SearchSpec.TERM_MATCH_PREFIX)
+                            .setResultCountPerPage(25)
+                            .build();
+            List<QueryStats> statsList = new ArrayList<>();
+            PlatformLogger logger =
+                    new PlatformLogger(mContext, mAppSearchConfig) {
+                        @Override
+                        public void logStats(@NonNull QueryStats stats) {
+                            statsList.add(stats);
+                        }
+                    };
+            SearchResultPage searchResultPage =
+                    instance.getAppSearchImpl()
+                            .globalQuery(
+                                    query,
+                                    querySearchSpec,
+                                    new FrameworkCallerAccess(
+                                            new AppSearchAttributionSource(
+                                                    mContext.getPackageName(),
+                                                    Process.myUid(),
+                                                    Process.myPid()),
+                                            /* callerHasSystemAccess= */ true,
+                                            /* sForEnterprise= */ false),
+                                    logger);
+            while (!searchResultPage.getResults().isEmpty()) {
+                printResultPage(pw, searchResultPage);
+                QueryStats.Builder statsBuilder =
+                        new QueryStats.Builder(VISIBILITY_SCOPE_GLOBAL, mContext.getPackageName());
+                searchResultPage =
+                        instance.getAppSearchImpl()
+                                .getNextPage(
+                                        mContext.getPackageName(),
+                                        searchResultPage.getNextPageToken(),
+                                        statsBuilder);
+                statsList.add(statsBuilder.build());
+            }
+            printStats(pw, statsList);
+        } catch (Exception e) {
+            pw.println("Encountered exception: " + e);
+
+            // smoreland@ says - can't find this in logcat output when hit ???
+            Log.e(TAG, "Encountered exception ", e);
+        }
+    }
+
+    private void printResultPage(PrintWriter pw, SearchResultPage page) {
+        pw.println("Printing result page: ");
+        for (SearchResult result : page.getResults()) {
+            pw.println(
+                    String.format(
+                            "Result={pkg=%s, db=%s, ns=%s, id=%s}",
+                            result.getPackageName(),
+                            result.getDatabaseName(),
+                            result.getGenericDocument().getNamespace(),
+                            result.getGenericDocument().getId()));
+        }
+    }
+
+    private void printStats(PrintWriter pw, List<QueryStats> stats) {
+        pw.println("Printing search stats: ");
+        for (QueryStats s : stats) {
+            pw.println(s);
+        }
+    }
+
     private class AppSearchStorageStatsAugmenter implements StorageStatsAugmenter {
+        private static final int STORAGE_STATS_RETRIEVAL_TIMEOUT_MS = 100;
+        // This lock exists to block incessant calls from StorageStatsManager so that they don't
+        // acquire AppSearch's internal lock and starve other requests.
+        private final ReentrantLock mStorageStatsCacheRefreshLock = new ReentrantLock();
+
         @Override
         public void augmentStatsForPackageForUser(
                 @NonNull PackageStats stats,
@@ -3032,26 +3486,30 @@ public class AppSearchManagerService extends SystemService {
             Objects.requireNonNull(userHandle);
 
             try {
-                mServiceImplHelper.verifyUserUnlocked(userHandle);
+                if (mServiceImplHelper.isUserLocked(userHandle)) {
+                    // No need to get stats for locked user.
+                    return;
+                }
                 AppSearchUserInstance instance =
                         mAppSearchUserInstanceManager.getUserInstanceOrNull(userHandle);
-                if (instance == null) {
-                    // augment storage info from file
-                    Context userContext = mAppSearchEnvironment
-                            .createContextAsUser(mContext, userHandle);
+                if (instance == null || Flags.enableStorageInfoCache()) {
+                    Context userContext =
+                            mAppSearchEnvironment.createContextAsUser(mContext, userHandle);
                     UserStorageInfo userStorageInfo =
-                            mAppSearchUserInstanceManager.getOrCreateUserStorageInfoInstance(
+                            mAppSearchUserInstanceManager
+                                .getOrCreateUserStorageInfoInstance(
                                     userContext, userHandle);
-                    stats.dataSize +=
-                            userStorageInfo.getSizeBytesForPackage(packageName);
+
+                    refreshCachedStorageInfoIfNecessary(instance, userStorageInfo);
+                    stats.dataSize += userStorageInfo.getSizeBytesForPackage(packageName);
                 } else {
                     stats.dataSize +=
                             instance.getAppSearchImpl()
-                                    .getStorageInfoForPackages(
-                                            new ArraySet<>(Collections.singleton(packageName)))
-                                    .getSizeBytes();
+                                .getStorageInfoForPackages(
+                                    new ArraySet<>(Collections.singleton(packageName)))
+                                .getSizeBytes();
                 }
-            } catch (AppSearchException | RuntimeException e) {
+            } catch (AppSearchException | InterruptedException | RuntimeException e) {
                 Log.e(
                         TAG,
                         "Unable to augment storage stats for "
@@ -3070,32 +3528,37 @@ public class AppSearchManagerService extends SystemService {
 
             UserHandle userHandle = UserHandle.getUserHandleForUid(uid);
             try {
-                mServiceImplHelper.verifyUserUnlocked(userHandle);
+                if (mServiceImplHelper.isUserLocked(userHandle)) {
+                    // No need to get stats for locked user.
+                    return;
+                }
                 String[] packagesForUid = mPackageManager.getPackagesForUid(uid);
                 if (packagesForUid == null) {
                     return;
                 }
                 AppSearchUserInstance instance =
                         mAppSearchUserInstanceManager.getUserInstanceOrNull(userHandle);
-                if (instance == null) {
-                    // augment storage info from file
-                    Context userContext = mAppSearchEnvironment
-                            .createContextAsUser(mContext, userHandle);
+                if (instance == null || Flags.enableStorageInfoCache()) {
+                    Context userContext =
+                            mAppSearchEnvironment.createContextAsUser(mContext, userHandle);
                     UserStorageInfo userStorageInfo =
-                            mAppSearchUserInstanceManager.getOrCreateUserStorageInfoInstance(
+                            mAppSearchUserInstanceManager
+                                .getOrCreateUserStorageInfoInstance(
                                     userContext, userHandle);
+
+                    refreshCachedStorageInfoIfNecessary(instance, userStorageInfo);
                     for (int i = 0; i < packagesForUid.length; i++) {
                         stats.dataSize += userStorageInfo.getSizeBytesForPackage(
-                                packagesForUid[i]);
+                            packagesForUid[i]);
                     }
                 } else {
                     Set<String> packageNames = new ArraySet<>(packagesForUid);
                     stats.dataSize +=
                             instance.getAppSearchImpl()
-                                    .getStorageInfoForPackages(packageNames)
-                                    .getSizeBytes();
+                                .getStorageInfoForPackages(packageNames)
+                                .getSizeBytes();
                 }
-            } catch (AppSearchException | RuntimeException e) {
+            } catch (AppSearchException | InterruptedException | RuntimeException e) {
                 Log.e(TAG, "Unable to augment storage stats for uid " + uid, e);
                 ExceptionUtil.handleException(e);
             }
@@ -3111,20 +3574,26 @@ public class AppSearchManagerService extends SystemService {
             Objects.requireNonNull(userHandle);
 
             try {
-                mServiceImplHelper.verifyUserUnlocked(userHandle);
+                if (mServiceImplHelper.isUserLocked(userHandle)) {
+                    // No need to get stats for locked user.
+                    return;
+                }
                 AppSearchUserInstance instance =
                         mAppSearchUserInstanceManager.getUserInstanceOrNull(userHandle);
-                if (instance == null) {
-                    // augment storage info from file
-                    Context userContext = mAppSearchEnvironment
-                            .createContextAsUser(mContext, userHandle);
+                if (instance == null || Flags.enableStorageInfoCache()) {
+                    Context userContext =
+                            mAppSearchEnvironment.createContextAsUser(mContext, userHandle);
                     UserStorageInfo userStorageInfo =
-                            mAppSearchUserInstanceManager.getOrCreateUserStorageInfoInstance(
+                            mAppSearchUserInstanceManager
+                                .getOrCreateUserStorageInfoInstance(
                                     userContext, userHandle);
+
+                    refreshCachedStorageInfoIfNecessary(instance, userStorageInfo);
                     stats.dataSize += userStorageInfo.getTotalSizeBytes();
                 } else {
-                    List<PackageInfo> packagesForUser = mPackageManager.getInstalledPackagesAsUser(
-                            /* flags= */ 0, userHandle.getIdentifier());
+                    List<PackageInfo> packagesForUser =
+                            mPackageManager.getInstalledPackagesAsUser(
+                                    /* flags= */ 0, userHandle.getIdentifier());
                     if (packagesForUser != null) {
                         Set<String> packageNames = new ArraySet<>();
                         for (int i = 0; i < packagesForUser.size(); i++) {
@@ -3137,11 +3606,46 @@ public class AppSearchManagerService extends SystemService {
                                         .getSizeBytes();
                     }
                 }
-            } catch (AppSearchException | RuntimeException e) {
+            } catch (AppSearchException | InterruptedException | RuntimeException e) {
                 Log.e(TAG, "Unable to augment storage stats for " + userHandle, e);
                 ExceptionUtil.handleException(e);
             }
         }
+
+        private void refreshCachedStorageInfoIfNecessary(
+                AppSearchUserInstance instance, UserStorageInfo userStorageInfo)
+                throws AppSearchException, InterruptedException {
+            if (instance == null) {
+                return;
+            }
+            // If the instance is not null, then it's possible that the cache
+            // has been invalidated after creation.
+            if (!userStorageInfo.isCacheEmpty()) {
+                return;
+            }
+            boolean lockAcquired = false;
+            try {
+                lockAcquired =
+                        mStorageStatsCacheRefreshLock.tryLock(
+                                STORAGE_STATS_RETRIEVAL_TIMEOUT_MS, TimeUnit.MILLISECONDS);
+                if (lockAcquired) {
+                    // If we were blocked while acquiring the lock, then it's likely that the
+                    // blocking thread has updated the cache. Therefore, we should check again to
+                    // ensure that we really do need to retrieve storage info from AppSearch.
+                    if (userStorageInfo.isCacheEmpty()) {
+                        StorageInfoProto storageInfo =
+                                instance.getAppSearchImpl().getRawStorageInfoProto();
+                        userStorageInfo.updateStorageInfoCache(storageInfo);
+                    }
+                } else {
+                    Log.w(TAG, "StorageStatsAugmenter timed out waiting on cache refresh.");
+                }
+            } finally {
+                if (lockAcquired) {
+                    mStorageStatsCacheRefreshLock.unlock();
+                }
+            }
+        }
     }
 
     /**
@@ -3181,7 +3685,10 @@ public class AppSearchManagerService extends SystemService {
                                 (int) (SystemClock.elapsedRealtime() - totalLatencyStartMillis))
                                 .build();
                         if (oStats.getOriginalDocumentCount() > 0) {
-                            // see if optimize has been run by checking originalDocumentCount
+                            if (oStats.getDeletedDocumentCount()
+                                    + oStats.getExpiredDocumentCount() > 0) {
+                                dropStorageInfoCacheForUser(targetUser);
+                            }
                             instance.getLogger().logStats(oStats);
                         }
                     }
@@ -3211,12 +3718,47 @@ public class AppSearchManagerService extends SystemService {
                                 .build();
                         if (oStats.getOriginalDocumentCount() > 0) {
                             // see if optimize has been run by checking originalDocumentCount
+                            if (oStats.getDeletedDocumentCount()
+                                    + oStats.getExpiredDocumentCount() > 0) {
+                                dropStorageInfoCacheForUser(targetUser);
+                            }
                             instance.getLogger().logStats(oStats);
                         }
                     }
                 });
     }
 
+    @WorkerThread
+    private void schedulePersistToDisk(
+            @NonNull UserHandle targetUser,
+            @NonNull AppSearchUserInstance instance,
+            @NonNull PersistType.Code persistType,
+            long delayMs) {
+        if (mServiceImplHelper.isUserLocked(targetUser)) {
+            // We shouldn't schedule any task to locked user.
+            return;
+        }
+        synchronized (mPerUserPersistToDiskFutureLocked) {
+            ScheduledFuture<?> persistToDiskFuture =
+                    mPerUserPersistToDiskFutureLocked.get(targetUser);
+            if (persistToDiskFuture == null || persistToDiskFuture.isDone()) {
+                persistToDiskFuture = mExecutorManager.scheduleLambdaForUserNoCallbackAsync(
+                        targetUser, () -> {
+                            if (mServiceImplHelper.isUserLocked(targetUser)) {
+                                // Skip the persistToDisk call if the user is locked.
+                                return;
+                            }
+                            try {
+                                instance.getAppSearchImpl().persistToDisk(persistType);
+                            } catch (Exception e) {
+                                Log.w(TAG, "Unable to persist the data to disk", e);
+                            }
+                        }, delayMs, TimeUnit.MILLISECONDS);
+                mPerUserPersistToDiskFutureLocked.put(targetUser, persistToDiskFuture);
+            }
+        }
+    }
+
     /**
      * An API call is considered global if the calling package and target package names do not
      * match.
@@ -3245,16 +3787,21 @@ public class AppSearchManagerService extends SystemService {
                 2 * (int) (totalLatencyStartTimeMillis - binderCallStartTimeMillis);
         int totalLatencyMillis =
                 (int) (SystemClock.elapsedRealtime() - totalLatencyStartTimeMillis);
-        mAppSearchUserInstanceManager.getUserInstance(targetUser).getLogger().logStats(
-                new CallStats.Builder()
-                        .setPackageName(callingPackageName)
-                        .setDatabase(callingDatabaseName)
-                        .setStatusCode(statusCode)
-                        .setTotalLatencyMillis(totalLatencyMillis)
-                        .setCallType(apiType)
-                        .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
-                        .setNumOperationsFailed(numOperations)
-                        .build());
+        try {
+            mAppSearchUserInstanceManager.getUserInstance(targetUser).getLogger().logStats(
+                    new CallStats.Builder()
+                            .setPackageName(callingPackageName)
+                            .setDatabase(callingDatabaseName)
+                            .setStatusCode(statusCode)
+                            .setTotalLatencyMillis(totalLatencyMillis)
+                            .setCallType(apiType)
+                            .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
+                            .setNumOperationsFailed(numOperations)
+                            .build());
+        } catch (ExecutionException | InterruptedException | CancellationException e) {
+            Log.e(TAG, "Failed to get logger for user: " + targetUser
+                    + " due to " + e.getMessage());
+        }
     }
 
     private void checkUnsupportedEmbeddingUse(@NonNull List<AppSearchSchema> schemas) {
@@ -3365,4 +3912,25 @@ public class AppSearchManagerService extends SystemService {
         }
         return false;
     }
+
+    /**
+     * Drops the cached storage information for a specific user.
+     * This method retrieves the {@link UserStorageInfo} instance associated with the specified user
+     * and clears the cached storage data to ensure that subsequent calls reflect any changes or
+     * updates in storage usage.
+     */
+    private void dropStorageInfoCacheForUser(@NonNull UserHandle targetUser) {
+        if (!Flags.enableStorageInfoCache()) {
+            return;
+        }
+
+        Context targetContext =
+                mAppSearchEnvironment.createContextAsUser(mContext, targetUser);
+        UserStorageInfo userStorageInfo =
+                mAppSearchUserInstanceManager
+                    .getOrUserStorageInfoInstanceOrNull(targetContext, targetUser);
+        if (userStorageInfo != null) {
+            userStorageInfo.dropStorageInfoCache();
+        }
+    }
 }
diff --git a/service/java/com/android/server/appsearch/AppSearchUserInstanceManager.java b/service/java/com/android/server/appsearch/AppSearchUserInstanceManager.java
index cd4ef3e3..f9df81d3 100644
--- a/service/java/com/android/server/appsearch/AppSearchUserInstanceManager.java
+++ b/service/java/com/android/server/appsearch/AppSearchUserInstanceManager.java
@@ -17,10 +17,13 @@
 package com.android.server.appsearch;
 
 import static android.app.appsearch.AppSearchResult.RESULT_INTERNAL_ERROR;
+import static android.app.appsearch.AppSearchResult.RESULT_OK;
+import static android.app.appsearch.AppSearchResult.throwableToFailedResult;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.app.appsearch.AppSearchEnvironmentFactory;
+import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.exceptions.AppSearchException;
 import android.app.appsearch.util.LogUtil;
 import android.content.Context;
@@ -31,19 +34,31 @@ import android.util.Log;
 
 import com.android.appsearch.flags.Flags;
 import com.android.internal.annotations.GuardedBy;
+import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.appsearch.external.localstorage.AppSearchImpl;
 import com.android.server.appsearch.external.localstorage.stats.InitializeStats;
 import com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityChecker;
+import com.android.server.appsearch.isolated_storage_service.DataMigrationUtil;
 import com.android.server.appsearch.isolated_storage_service.IsolatedStorageServiceManager;
+import com.android.server.appsearch.util.ExecutorManager;
 
 import com.google.android.icing.IcingSearchEngineInterface;
+import com.google.android.icing.proto.InitializeResultProto;
+import com.google.android.icing.proto.ResetResultProto;
+import com.google.android.icing.proto.StatusProto;
 
 import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
-import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.ReentrantLock;
 
 /**
  * Manages the lifecycle of AppSearch classes that should only be initialized once per device-user
@@ -56,17 +71,30 @@ public final class AppSearchUserInstanceManager {
 
     private static volatile AppSearchUserInstanceManager sAppSearchUserInstanceManager;
 
-    @GuardedBy("mInstancesLocked")
+    private final ExecutorService mAppSearchUserInstanceExecutorService =
+            Flags.enableUserInstanceFutures()
+                    ? ExecutorManager.createDefaultExecutorService()
+                    : null;
+
+    private final ReentrantLock mInstanceMapLock = new ReentrantLock();
+
+    private final ReentrantLock mFutureInstanceMapLock = new ReentrantLock();
+
+    @GuardedBy("mInstanceMapLock")
     private final Map<UserHandle, AppSearchUserInstance> mInstancesLocked = new ArrayMap<>();
 
+    @GuardedBy("mFutureInstanceMapLock")
+    private final Map<UserHandle, Future<AppSearchUserInstance>> mFutureInstancesLocked =
+            new ArrayMap<>();
+
     @GuardedBy("mStorageInfoLocked")
     private final Map<UserHandle, UserStorageInfo> mStorageInfoLocked = new ArrayMap<>();
 
-    @GuardedBy("mIsolatedStorageServiceManagerLocked")
-    private final AtomicReference<IsolatedStorageServiceManager>
-            mIsolatedStorageServiceManagerLocked = new AtomicReference<>();
+    @GuardedBy("mPerUserMigrationFutureLocked")
+    private final Map<UserHandle, ScheduledFuture<?>> mPerUserMigrationFutureLocked =
+            new ArrayMap();
 
-    private AppSearchUserInstanceManager() {}
+    public AppSearchUserInstanceManager() {}
 
     /**
      * Gets an instance of AppSearchUserInstanceManager to be used.
@@ -95,25 +123,34 @@ public final class AppSearchUserInstanceManager {
      * @param userContext Context of the user calling AppSearch
      * @param userHandle The multi-user handle of the device user calling AppSearch
      * @param config Flag manager for AppSearch
+     * @param isolatedStorageServiceManager Manager for isolated storage
      * @return An initialized {@link AppSearchUserInstance} for this user
      */
     @NonNull
     public AppSearchUserInstance getOrCreateUserInstance(
             @NonNull Context userContext,
             @NonNull UserHandle userHandle,
-            @NonNull ServiceAppSearchConfig config)
+            @NonNull ServiceAppSearchConfig config,
+            @NonNull ExecutorManager executorManager,
+            @Nullable IsolatedStorageServiceManager isolatedStorageServiceManager)
             throws AppSearchException {
         Objects.requireNonNull(userContext);
         Objects.requireNonNull(userHandle);
         Objects.requireNonNull(config);
-
-        synchronized (mInstancesLocked) {
-            AppSearchUserInstance instance = mInstancesLocked.get(userHandle);
-            if (instance == null) {
-                instance = createUserInstance(userContext, userHandle, config);
-                mInstancesLocked.put(userHandle, instance);
-            }
-            return instance;
+        if (Flags.enableUserInstanceFutures()) {
+            return getOrCreateUserInstanceFuture(
+                    userContext,
+                    userHandle,
+                    config,
+                    executorManager,
+                    isolatedStorageServiceManager);
+        } else {
+            return internalGetOrCreateUserInstance(
+                    userContext,
+                    userHandle,
+                    config,
+                    executorManager,
+                    isolatedStorageServiceManager);
         }
     }
 
@@ -122,21 +159,44 @@ public final class AppSearchUserInstanceManager {
      *
      * <p>All mutations applied to the underlying {@link AppSearchImpl} will be persisted to disk.
      *
-     * @param userHandle The multi-user user handle of the user that need to be removed.
+     * @param userHandle The multi-user user handle of the user that needs to be removed.
      */
     public void closeAndRemoveUserInstance(@NonNull UserHandle userHandle) {
         Objects.requireNonNull(userHandle);
-        synchronized (mInstancesLocked) {
-            AppSearchUserInstance instance = mInstancesLocked.remove(userHandle);
-            if (instance != null) {
-                instance.getAppSearchImpl().close();
-            }
+        if (Flags.enableUserInstanceFutures()) {
+            closeAndRemoveUserInstanceFuture(userHandle);
+        } else {
+            internalCloseAndRemoveUserInstance(userHandle);
         }
+
         synchronized (mStorageInfoLocked) {
             mStorageInfoLocked.remove(userHandle);
         }
     }
 
+    /**
+     * Removes the user data for the given {@link AppSearchUserInstance} user. This is handled
+     * automatically by the system unless isolated storage is used.
+     *
+     * @param userHandle The multi-user user handle of the user that needs to be removed.
+     * @param userContext Context for the user instance being removed.
+     * @param isolatedStorageServiceManager Manager for isolated storage.
+     */
+    public void removeUserData(
+            @NonNull UserHandle userHandle,
+            @NonNull Context userContext,
+            @NonNull ServiceAppSearchConfig config,
+            @Nullable IsolatedStorageServiceManager isolatedStorageServiceManager) {
+        Objects.requireNonNull(userHandle);
+        Objects.requireNonNull(userContext);
+        Objects.requireNonNull(config);
+
+        // Remove the icing user instance in IsolatedStorageService
+        if (isolatedStorageServiceManager != null) {
+            isolatedStorageServiceManager.removeUserInstance(userHandle);
+        }
+    }
+
     /**
      * Gets an {@link AppSearchUserInstance} for the given user.
      *
@@ -147,20 +207,19 @@ public final class AppSearchUserInstanceManager {
      * @return An initialized {@link AppSearchUserInstance} for this user
      * @throws IllegalStateException if {@link AppSearchUserInstance} haven't created for the given
      *     user.
+     * @throws CancellationException if {@link AppSearchUserInstance} creation was cancelled.
+     * @throws InterruptedException if the thread creating {@link AppSearchUserInstance} was
+     *     interrupted
+     * @throws ExecutionException if {@link AppSearchUserInstance} creation encountered an exception
      */
     @NonNull
-    public AppSearchUserInstance getUserInstance(@NonNull UserHandle userHandle) {
+    public AppSearchUserInstance getUserInstance(@NonNull UserHandle userHandle)
+            throws CancellationException, InterruptedException, ExecutionException {
         Objects.requireNonNull(userHandle);
-        synchronized (mInstancesLocked) {
-            AppSearchUserInstance instance = mInstancesLocked.get(userHandle);
-            if (instance == null) {
-                // Impossible scenario, user cannot call an uninitialized SearchSession,
-                // getInstance should always find the instance for the given user and never try to
-                // create an instance for this user again.
-                throw new IllegalStateException(
-                        "AppSearchUserInstance has never been created for: " + userHandle);
-            }
-            return instance;
+        if (Flags.enableUserInstanceFutures()) {
+            return getUserInstanceFuture(userHandle);
+        } else {
+            return internalGetUserInstance(userHandle);
         }
     }
 
@@ -168,14 +227,22 @@ public final class AppSearchUserInstanceManager {
      * Returns the initialized {@link AppSearchUserInstance} for the given user, or {@code null} if
      * no such instance exists.
      *
+     * This method will NOT block on creation of {@link AppSearchUserInstance} and will instead
+     * return null;
+     *
      * @param userHandle The multi-user handle of the device user calling AppSearch
      */
     @Nullable
     public AppSearchUserInstance getUserInstanceOrNull(@NonNull UserHandle userHandle) {
         Objects.requireNonNull(userHandle);
-        synchronized (mInstancesLocked) {
-            return mInstancesLocked.get(userHandle);
+        AppSearchUserInstance instance;
+        if (Flags.enableUserInstanceFutures()) {
+            instance = getUserInstanceFutureOrNull(userHandle);
+
+        } else {
+            instance = internalGetUserInstanceOrNull(userHandle);
         }
+        return instance;
     }
 
     /**
@@ -203,6 +270,23 @@ public final class AppSearchUserInstanceManager {
         }
     }
 
+    /**
+     * Gets an {@link UserStorageInfo} for the given user.
+     *
+     * @param userContext Context for the user.
+     * @param userHandle The multi-user handle of the device user
+     * @return An initialized {@link UserStorageInfo} for this user, or {@code null} if not found.
+     */
+    @Nullable
+    public UserStorageInfo getOrUserStorageInfoInstanceOrNull(
+            @NonNull Context userContext, @NonNull UserHandle userHandle) {
+        Objects.requireNonNull(userContext);
+        Objects.requireNonNull(userHandle);
+        synchronized (mStorageInfoLocked) {
+            return mStorageInfoLocked.get(userHandle);
+        }
+    }
+
     /**
      * Returns the list of all {@link UserHandle}s.
      *
@@ -210,8 +294,10 @@ public final class AppSearchUserInstanceManager {
      */
     @NonNull
     public List<UserHandle> getAllUserHandles() {
-        synchronized (mInstancesLocked) {
-            return new ArrayList<>(mInstancesLocked.keySet());
+        if (Flags.enableUserInstanceFutures()) {
+            return getAllFutureUserHandles();
+        } else {
+            return internalGetAllUserHandles();
         }
     }
 
@@ -219,7 +305,9 @@ public final class AppSearchUserInstanceManager {
     private AppSearchUserInstance createUserInstance(
             @NonNull Context userContext,
             @NonNull UserHandle userHandle,
-            @NonNull ServiceAppSearchConfig config)
+            @NonNull ServiceAppSearchConfig config,
+            @NonNull ExecutorManager executorManager,
+            @Nullable IsolatedStorageServiceManager isolatedStorageServiceManager)
             throws AppSearchException {
         long totalLatencyStartMillis = SystemClock.elapsedRealtime();
         InitializeStats.Builder initStatsBuilder = new InitializeStats.Builder();
@@ -232,12 +320,32 @@ public final class AppSearchUserInstanceManager {
                 AppSearchEnvironmentFactory.getEnvironmentInstance()
                         .getAppSearchDir(userContext, userHandle);
         File icingDir = new File(appSearchDir, "icing");
-        if (LogUtil.INFO) {
-            if (IsolatedStorageServiceManager.useIsolatedStorage(userContext)) {
-                Log.i(TAG, "Creating new AppSearch instance in isolated storage.");
-            } else {
-                Log.i(TAG, "Creating new AppSearch instance at: " + icingDir);
+        IcingSearchEngineInterface icingInstance = null;
+        if (isolatedStorageServiceManager != null
+                && IsolatedStorageServiceManager.isUserAllowed(userHandle)) {
+            if (LogUtil.INFO) {
+                Log.i(
+                        TAG,
+                        "Creating new AppSearch instance for "
+                                + userHandle
+                                + " in isolated storage.");
             }
+            icingInstance =
+                    maybeGetIsolatedIcingSearchEngine(
+                            userContext,
+                            userHandle,
+                            config,
+                            executorManager,
+                            isolatedStorageServiceManager);
+        } else {
+            if (LogUtil.INFO) {
+                Log.i(
+                        TAG,
+                        "Creating new AppSearch instance for " + userHandle + " at: " + icingDir);
+            }
+            // Data is stored in host. We need to delete the migration status file
+            // so next migration can run.
+            DataMigrationUtil.deleteMigrationStatus(userHandle, appSearchDir);
         }
         VisibilityChecker visibilityCheckerImpl =
                 AppSearchComponentFactory.createVisibilityCheckerInstance(userContext);
@@ -246,32 +354,281 @@ public final class AppSearchUserInstanceManager {
             frameworkRevocableFileDescriptorStore =
                     new FrameworkRevocableFileDescriptorStore(userContext, config);
         }
-        AppSearchImpl appSearchImpl =
-                AppSearchImpl.create(
-                        icingDir,
-                        config,
-                        initStatsBuilder,
-                        visibilityCheckerImpl,
-                        frameworkRevocableFileDescriptorStore,
-                        maybeGetIsolatedIcingSearchEngine(userContext, userHandle, config),
-                        new ServiceOptimizeStrategy(config));
-
-        // Update storage info file
-        UserStorageInfo userStorageInfo =
-                getOrCreateUserStorageInfoInstance(userContext, userHandle);
-        userStorageInfo.updateStorageInfoFile(appSearchImpl);
-
-        initStatsBuilder.setTotalLatencyMillis(
-                (int) (SystemClock.elapsedRealtime() - totalLatencyStartMillis));
-        logger.logStats(initStatsBuilder.build());
-
-        return new AppSearchUserInstance(logger, appSearchImpl, visibilityCheckerImpl);
+        @AppSearchResult.ResultCode int statusCode = RESULT_OK;
+        AppSearchImpl appSearchImpl = null;
+        try {
+            appSearchImpl =
+                    AppSearchImpl.create(
+                            icingDir,
+                            config,
+                            initStatsBuilder,
+                            visibilityCheckerImpl,
+                            frameworkRevocableFileDescriptorStore,
+                            icingInstance,
+                            new ServiceOptimizeStrategy(config));
+
+            // Update storage info file
+            UserStorageInfo userStorageInfo =
+                    getOrCreateUserStorageInfoInstance(userContext, userHandle);
+            userStorageInfo.updateStorageInfoFile(appSearchImpl);
+
+            return new AppSearchUserInstance(logger, appSearchImpl, visibilityCheckerImpl);
+        } catch (AppSearchException e) {
+            AppSearchResult<Void> failedResult = throwableToFailedResult(e);
+            statusCode = failedResult.getResultCode();
+            if (Flags.enableCloseAppsearchOnCreationFailure() && appSearchImpl != null) {
+                // If we've created the instance, but encountered some issue.
+                // Close this instance so that we clean up it's resources.
+                Log.e(TAG, "Failed to create AppSearch instance: ", e);
+                appSearchImpl.close();
+            }
+            throw e;
+        } catch (Exception e) {
+            if (Flags.enableCloseAppsearchOnCreationFailure() && appSearchImpl != null) {
+                // If we've created the instance, but encountered some issue.
+                // Close this instance so that we clean up it's resources.
+                Log.e(TAG, "Failed to create AppSearch instance: ", e);
+                appSearchImpl.close();
+            }
+            throw e;
+        } finally {
+            initStatsBuilder
+                    .setTotalLatencyMillis(
+                            (int) (SystemClock.elapsedRealtime() - totalLatencyStartMillis))
+                    .setStatusCode(statusCode);
+            logger.logStats(initStatsBuilder.build());
+        }
+    }
+
+    private Future<AppSearchUserInstance> createUserInstanceFuture(
+            @NonNull Context userContext,
+            @NonNull UserHandle userHandle,
+            @NonNull ServiceAppSearchConfig config,
+            @NonNull ExecutorManager executorManager,
+            @Nullable IsolatedStorageServiceManager isolatedStorageServiceManager) {
+        return mAppSearchUserInstanceExecutorService.submit(
+                () ->
+                        createUserInstance(
+                                userContext,
+                                userHandle,
+                                config,
+                                executorManager,
+                                isolatedStorageServiceManager));
+    }
+
+    private AppSearchUserInstance getOrCreateUserInstanceFuture(
+            @NonNull Context userContext,
+            @NonNull UserHandle userHandle,
+            @NonNull ServiceAppSearchConfig config,
+            @NonNull ExecutorManager executorManager,
+            @Nullable IsolatedStorageServiceManager isolatedStorageServiceManager)
+            throws AppSearchException {
+        Future<AppSearchUserInstance> instanceFuture;
+        mFutureInstanceMapLock.lock();
+        try {
+            instanceFuture = mFutureInstancesLocked.get(userHandle);
+            if (instanceFuture == null) {
+                instanceFuture =
+                        createUserInstanceFuture(
+                                userContext,
+                                userHandle,
+                                config,
+                                executorManager,
+                                isolatedStorageServiceManager);
+                mFutureInstancesLocked.put(userHandle, instanceFuture);
+            }
+        } finally {
+            mFutureInstanceMapLock.unlock();
+        }
+        try {
+            return instanceFuture.get();
+        } catch (ExecutionException | InterruptedException e) {
+            throw new AppSearchException(
+                    AppSearchResult.RESULT_ABORTED,
+                    "User Instance creation for: " + userHandle + " failed to complete.");
+        }
+    }
+
+    private AppSearchUserInstance internalGetOrCreateUserInstance(
+            @NonNull Context userContext,
+            @NonNull UserHandle userHandle,
+            @NonNull ServiceAppSearchConfig config,
+            @NonNull ExecutorManager executorManager,
+            @Nullable IsolatedStorageServiceManager isolatedStorageServiceManager)
+            throws AppSearchException {
+        Objects.requireNonNull(userContext);
+        Objects.requireNonNull(userHandle);
+        Objects.requireNonNull(config);
+
+        mInstanceMapLock.lock();
+        try {
+            AppSearchUserInstance instance = mInstancesLocked.get(userHandle);
+            if (instance == null) {
+                instance =
+                        createUserInstance(
+                                userContext,
+                                userHandle,
+                                config,
+                                executorManager,
+                                isolatedStorageServiceManager);
+                mInstancesLocked.put(userHandle, instance);
+            }
+            return instance;
+        } finally {
+            mInstanceMapLock.unlock();
+        }
+    }
+
+    private void closeAndRemoveUserInstanceFuture(UserHandle userHandle) {
+        Future<AppSearchUserInstance> instanceFuture;
+        mFutureInstanceMapLock.lock();
+        try {
+            instanceFuture = mFutureInstancesLocked.remove(userHandle);
+        } finally {
+            mFutureInstanceMapLock.unlock();
+        }
+        if (instanceFuture != null) {
+            if (instanceFuture.isDone()) {
+                try {
+                    instanceFuture.get().getAppSearchImpl().close();
+                } catch (InterruptedException | ExecutionException | CancellationException e) {
+                    Log.w(
+                            TAG,
+                            "No AppSearchImpl to close for "
+                                    + userHandle
+                                    + ". User instance failed to be created.",
+                            e);
+                }
+            }
+        }
+    }
+
+    private void internalCloseAndRemoveUserInstance(UserHandle userHandle) {
+        AppSearchUserInstance instance;
+        mInstanceMapLock.lock();
+        try {
+            instance = mInstancesLocked.remove(userHandle);
+        } finally {
+            mInstanceMapLock.unlock();
+        }
+        if (instance != null) {
+            instance.getAppSearchImpl().close();
+        }
+    }
+
+    private AppSearchUserInstance getUserInstanceFuture(UserHandle userHandle)
+            throws ExecutionException, InterruptedException, CancellationException {
+        Future<AppSearchUserInstance> instanceFuture;
+        mFutureInstanceMapLock.lock();
+        try {
+            instanceFuture = mFutureInstancesLocked.get(userHandle);
+            if (instanceFuture == null) {
+                throw new IllegalStateException(
+                        "AppSearchUserInstanceFuture has never been created for: " + userHandle);
+            }
+        } finally {
+            mFutureInstanceMapLock.unlock();
+        }
+        try {
+            return instanceFuture.get();
+        } catch (ExecutionException e) {
+            throw new ExecutionException(
+                    "An exception occurred during AppSearchUserInstance creation for userHandle: "
+                            + userHandle,
+                    e.getCause());
+        } catch (InterruptedException e) {
+            throw new InterruptedException(
+                    "An interrupt occurred during AppSearchUserInstance creation for userHandle: "
+                            + userHandle
+                            + " with cause: "
+                            + e.getMessage());
+        } catch (CancellationException e) {
+            throw new CancellationException(
+                    "AppSearchUserInstance creation for: "
+                            + userHandle
+                            + " was cancelled with cause: "
+                            + e.getMessage());
+        }
+    }
+
+    private AppSearchUserInstance internalGetUserInstance(UserHandle userHandle) {
+        mInstanceMapLock.lock();
+        try {
+            AppSearchUserInstance instance = mInstancesLocked.get(userHandle);
+            if (instance == null) {
+                // Impossible scenario, user cannot call an uninitialized SearchSession,
+                // getInstance should always find the instance for the given user and never try to
+                // create an instance for this user again.
+                throw new IllegalStateException(
+                        "AppSearchUserInstance is not created for "
+                                + userHandle
+                                + ". Instance may still be starting, have crashed, have never been "
+                                + "created, or may have been removed.");
+            }
+            return instance;
+        } finally {
+            mInstanceMapLock.unlock();
+        }
+    }
+
+    private AppSearchUserInstance getUserInstanceFutureOrNull(UserHandle userHandle) {
+        Future<AppSearchUserInstance> instanceFuture = null;
+        if (mFutureInstanceMapLock.tryLock()) {
+            try {
+                instanceFuture = mFutureInstancesLocked.get(userHandle);
+            } finally {
+                mFutureInstanceMapLock.unlock();
+            }
+        }
+        if (instanceFuture != null && instanceFuture.isDone()) {
+            try {
+                return instanceFuture.get();
+            } catch (ExecutionException | InterruptedException | CancellationException e) {
+                Log.w(
+                        TAG,
+                        "User instance creation encountered an issue or was cancelled."
+                                + " Returning null.");
+            }
+        }
+        return null;
+    }
+
+    private AppSearchUserInstance internalGetUserInstanceOrNull(UserHandle userHandle) {
+        // mInstanceMapLock being held is unlikely unless we're creating a UserInstance. If we're
+        // in the midst of UserInstance creation, we should avoid blocking and simply return null.
+        if (mInstanceMapLock.tryLock()) {
+            try {
+                return mInstancesLocked.get(userHandle);
+            } finally {
+                mInstanceMapLock.unlock();
+            }
+        }
+        return null;
+    }
+
+    private List<UserHandle> getAllFutureUserHandles() {
+        mFutureInstanceMapLock.lock();
+        try {
+            return new ArrayList<>(mFutureInstancesLocked.keySet());
+        } finally {
+            mFutureInstanceMapLock.unlock();
+        }
+    }
+
+    private List<UserHandle> internalGetAllUserHandles() {
+        mInstanceMapLock.lock();
+        try {
+            return new ArrayList<>(mInstancesLocked.keySet());
+        } finally {
+            mInstanceMapLock.unlock();
+        }
     }
 
     /**
      * Gets the isolated icing engine for the user if isolated storage is enabled.
      *
-     * @return IcingSearchEngineInterface or null if isolated storage is not enabled.
+     * @return IcingSearchEngineInterface or null if isolated storage is not enabled or
+     *     can't be used right away due to, e.g. pending data migration.
      * @throws AppSearchException if isolated storage is enabled, but the isolated storage service
      *     is unavailable or fails.
      */
@@ -279,35 +636,129 @@ public final class AppSearchUserInstanceManager {
     private IcingSearchEngineInterface maybeGetIsolatedIcingSearchEngine(
             @NonNull Context userContext,
             @NonNull UserHandle userHandle,
-            @NonNull ServiceAppSearchConfig config)
+            @NonNull ServiceAppSearchConfig config,
+            @NonNull ExecutorManager executorManager,
+            @NonNull IsolatedStorageServiceManager isolatedStorageServiceManager)
             throws AppSearchException {
         Objects.requireNonNull(userContext);
         Objects.requireNonNull(userHandle);
         Objects.requireNonNull(config);
+        Objects.requireNonNull(executorManager);
+        Objects.requireNonNull(isolatedStorageServiceManager);
 
-        if (!IsolatedStorageServiceManager.useIsolatedStorage(userContext)) {
-            Log.i(TAG, "Isolated storage is not enabled.");
-            return null;
-        }
-
-        IcingSearchEngineInterface icingInstance;
-        synchronized (mIsolatedStorageServiceManagerLocked) {
-            if (mIsolatedStorageServiceManagerLocked.get() == null) {
-                mIsolatedStorageServiceManagerLocked.set(
-                        new IsolatedStorageServiceManager(userContext, config));
-                mIsolatedStorageServiceManagerLocked.get().startIsolatedStorageService();
-            }
-            icingInstance =
-                    mIsolatedStorageServiceManagerLocked.get().getIcingInstance(userHandle, config);
-        }
+        IcingSearchEngineInterface isolatedIcingInterface =
+                isolatedStorageServiceManager.getIcingInstance(userHandle, config);
 
         // Enforce successful isolated storage creation when configured for use
-        if (icingInstance == null) {
+        if (isolatedIcingInterface == null) {
             Log.e(TAG, "Failed to get isolated storage instance!");
             throw new AppSearchException(
                     RESULT_INTERNAL_ERROR, "Failed to get isolated storage instance!");
         }
 
-        return icingInstance;
+        if (!config.enableIsolatedStorageMigration()
+                || !DataMigrationUtil.needDataMigration(userContext, userHandle)) {
+            return isolatedIcingInterface;
+        }
+
+        // Schedule migration
+        synchronized (mPerUserMigrationFutureLocked) {
+            ScheduledFuture<?> migrationFuture = mPerUserMigrationFutureLocked.get(userHandle);
+            if (migrationFuture == null) {
+                // TODO(b/407815165): Allow configuring resetDestination, forceOverride & delay
+                // TODO(b/407815165): we should schedule a background job to do migration,
+                //  and we should block any incoming write APIs while migration runs.
+                migrationFuture =
+                        executorManager.scheduleLambdaForUserNoCallbackAsync(
+                                userHandle,
+                                () -> {
+                                    AppSearchUserInstance instance =
+                                            getUserInstanceOrNull(userHandle);
+                                    if (instance != null) {
+                                        InitializeResultProto initResult =
+                                                isolatedIcingInterface.initialize();
+                                        if (initResult.getStatus().getCode()
+                                                != StatusProto.Code.OK) {
+                                            Log.e(
+                                                    TAG,
+                                                    "Failed to initialize Isolated Storage Icing!"
+                                                            + " Status code: "
+                                                            + initResult
+                                                                    .getStatus()
+                                                                    .getCode()
+                                                                    .getNumber());
+                                        }
+                                        StatusProto status =
+                                                DataMigrationUtil.copyData(
+                                                        // Get the non-isolated icing instance
+                                                        instance.getAppSearchImpl(),
+                                                        isolatedIcingInterface,
+                                                        /* resetDestination= */ false,
+                                                        /* forceOverride= */ true);
+                                        if (LogUtil.INFO) {
+                                            Log.i(TAG, "Data migration status: " + status);
+                                        }
+
+                                        if (status.getCode() != StatusProto.Code.OK) {
+                                            Log.e(
+                                                    TAG,
+                                                    "Data migration failed with status code: "
+                                                            + status.getCode().getNumber());
+                                            return;
+                                        }
+
+                                        // Switch to the isolated instance
+                                        IcingSearchEngineInterface priorIcingSearchEngine =
+                                                instance.getAppSearchImpl()
+                                                        .swapIcingSearchEngineLocked(
+                                                                isolatedIcingInterface);
+
+                                        DataMigrationUtil.createMigrationStatus(
+                                                AppSearchEnvironmentFactory
+                                                        .getEnvironmentInstance()
+                                                        .getAppSearchDir(userContext, userHandle));
+
+                                        // Destroy the current instance.
+                                        if (Flags.enableWipingOutSystemServerDataAfterMigration()) {
+                                            // TODO(b/407815165): We can't delete blob related
+                                            //  files as well as migration status file.
+                                            ResetResultProto resetResult =
+                                                    priorIcingSearchEngine.clearAndDestroy();
+                                            priorIcingSearchEngine.close();
+                                            if (LogUtil.INFO) {
+                                                Log.i(TAG,
+                                                        "Clear and destroy result: "
+                                                                + resetResult);
+                                            }
+                                        }
+                                    }
+                                },
+                                1,
+                                TimeUnit.MINUTES);
+                mPerUserMigrationFutureLocked.put(userHandle, migrationFuture);
+                Log.i(TAG, "Data migration for " + userHandle + " scheduled.");
+            }
+        }
+        // If we need a migration, return null so that AppSearch will create the non-isolated
+        // version of Icing in AppSearchImpl.create.
+        return null;
+    }
+
+    @VisibleForTesting
+    void lockInstanceMap() {
+        if (Flags.enableUserInstanceFutures()) {
+            mFutureInstanceMapLock.lock();
+        } else {
+            mInstanceMapLock.lock();
+        }
+    }
+
+    @VisibleForTesting
+    void unlockInstanceMap() {
+        if (Flags.enableUserInstanceFutures()) {
+            mFutureInstanceMapLock.unlock();
+        } else {
+            mInstanceMapLock.unlock();
+        }
     }
 }
diff --git a/service/java/com/android/server/appsearch/FrameworkServiceAppSearchConfig.java b/service/java/com/android/server/appsearch/FrameworkServiceAppSearchConfig.java
index 95128cdb..63b8f13e 100644
--- a/service/java/com/android/server/appsearch/FrameworkServiceAppSearchConfig.java
+++ b/service/java/com/android/server/appsearch/FrameworkServiceAppSearchConfig.java
@@ -17,8 +17,8 @@
 package com.android.server.appsearch;
 
 import static com.android.server.appsearch.isolated_storage_service.IsolatedStorageServiceManager.DEFAULT_MAX_PAGE_BYTES_LIMIT_FOR_ISOLATED_STORAGE;
-import static com.android.server.appsearch.isolated_storage_service.IsolatedStorageServiceManager.isolatedStorageFlagsSet;
 
+import android.content.Context;
 import android.os.Build;
 import android.os.Bundle;
 import android.provider.DeviceConfig;
@@ -26,6 +26,8 @@ import android.provider.DeviceConfig.OnPropertiesChangedListener;
 
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.server.appsearch.appsindexer.AppOpenEventIndexerConfig;
+import com.android.server.appsearch.appsindexer.FrameworkAppOpenEventIndexerConfig;
 import com.android.server.appsearch.external.localstorage.IcingOptionsConfig;
 import com.android.server.appsearch.isolated_storage_service.IsolatedStorageServiceManager;
 
@@ -120,10 +122,18 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
     public static final String KEY_APP_FUNCTION_CALL_TIMEOUT_MILLIS =
             "app_function_call_timeout_millis";
     public static final String KEY_FULLY_PERSIST_JOB_INTERVAL = "fully_persist_job_interval";
+    public static final String KEY_PERSIST_DELAY = "persist_delay";
     public static final String KEY_MAX_OPEN_BLOB_COUNT = "max_open_blob_count";
     public static final String KEY_ORPHAN_BLOB_TIME_TO_LIVE_MS = "orphan_blob_time_to_live_ms";
-    public static final String ISOLATED_STORAGE_MEMORY_BYTES = "isolated_storage_memory_bytes";
+    public static final String KEY_ISOLATED_STORAGE_MEMORY_BYTES = "isolated_storage_memory_bytes";
     public static final String KEY_LIGHTWEIGHT_PERSIST_TYPE = "lightweight_persist_type";
+    public static final String KEY_ISOLATED_STORAGE_ENABLED = "isolated_storage_enabled";
+    public static final String KEY_ISOLATED_STORAGE_MIGRATION_ENABLED =
+            "isolated_storage_migration_enabled";
+    public static final String KEY_ISOLATED_STORAGE_DELETE_CE_VMS =
+            "isolated_storage_delete_ce_vms";
+    public static final String KEY_COMPRESSION_THRESHOLD_BYTES = "compression_threshold_bytes";
+    public static final String KEY_COMPRESSION_MEM_LEVEL = "compression_mem_level";
 
     /**
      * This config does not need to be cached in FrameworkServiceAppSearchConfig as it is only
@@ -142,6 +152,7 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
         KEY_SAMPLING_INTERVAL_FOR_GLOBAL_SEARCH_STATS,
         KEY_SAMPLING_INTERVAL_FOR_OPTIMIZE_STATS,
         KEY_LIMIT_CONFIG_MAX_DOCUMENT_SIZE_BYTES,
+        KEY_LIMIT_CONFIG_MAX_BYTE_LIMIT_BATCH_PUT,
         KEY_LIMIT_CONFIG_PER_PACKAGE_DOCUMENT_COUNT_LIMIT,
         KEY_LIMIT_CONFIG_DOCUMENT_COUNT_LIMIT_START_THRESHOLD,
         KEY_LIMIT_CONFIG_MAX_SUGGESTION_COUNT,
@@ -172,9 +183,16 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
         KEY_BUILD_PROPERTY_EXISTENCE_METADATA_HITS,
         KEY_APP_FUNCTION_CALL_TIMEOUT_MILLIS,
         KEY_FULLY_PERSIST_JOB_INTERVAL,
+        KEY_PERSIST_DELAY,
         KEY_MAX_OPEN_BLOB_COUNT,
         KEY_ORPHAN_BLOB_TIME_TO_LIVE_MS,
-        KEY_LIGHTWEIGHT_PERSIST_TYPE
+        KEY_LIGHTWEIGHT_PERSIST_TYPE,
+        KEY_ISOLATED_STORAGE_MEMORY_BYTES,
+        KEY_LIGHTWEIGHT_PERSIST_TYPE,
+        KEY_ISOLATED_STORAGE_ENABLED,
+        KEY_COMPRESSION_THRESHOLD_BYTES,
+        KEY_USE_FIXED_EXECUTOR_SERVICE,
+        KEY_COMPRESSION_MEM_LEVEL
     };
 
     // Lock needed for all the operations in this class.
@@ -210,7 +228,14 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
                 updateCachedValues(properties);
             };
 
-    private FrameworkServiceAppSearchConfig() {}
+    private final Context mContext;
+
+    private FrameworkServiceAppSearchConfig(@NonNull Context context) {
+        mContext = context;
+    }
+
+    private final AppOpenEventIndexerConfig mAppOpenEventIndexerConfig =
+            new FrameworkAppOpenEventIndexerConfig();
 
     /**
      * Creates an instance of {@link FrameworkServiceAppSearchConfig}.
@@ -220,9 +245,11 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
      */
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
     @NonNull
-    public static FrameworkServiceAppSearchConfig create(@NonNull Executor executor) {
+    public static FrameworkServiceAppSearchConfig create(
+            @NonNull Executor executor, @NonNull Context context) {
         Objects.requireNonNull(executor);
-        FrameworkServiceAppSearchConfig configManager = new FrameworkServiceAppSearchConfig();
+        FrameworkServiceAppSearchConfig configManager =
+                new FrameworkServiceAppSearchConfig(context);
         configManager.initialize(executor);
         return configManager;
     }
@@ -234,12 +261,13 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
      * existing instance will be returned.
      */
     @NonNull
-    public static FrameworkServiceAppSearchConfig getInstance(@NonNull Executor executor) {
+    public static FrameworkServiceAppSearchConfig getInstance(
+            @NonNull Executor executor, @NonNull Context context) {
         Objects.requireNonNull(executor);
         if (sConfig == null) {
             synchronized (FrameworkServiceAppSearchConfig.class) {
                 if (sConfig == null) {
-                    sConfig = create(executor);
+                    sConfig = create(executor, context);
                 }
             }
         }
@@ -383,8 +411,8 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
         synchronized (mLock) {
             throwIfClosedLocked();
             return mBundleLocked.getInt(
-                    KEY_LIMIT_CONFIG_MAX_DOCUMENT_SIZE_BYTES,
-                    DEFAULT_LIMIT_CONFIG_MAX_DOCUMENT_SIZE_BYTES);
+                    KEY_LIMIT_CONFIG_MAX_BYTE_LIMIT_BATCH_PUT,
+                    DEFAULT_MAX_BYTE_LIMIT_FOR_BATCH_PUT);
         }
     }
 
@@ -570,12 +598,21 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
             throwIfClosedLocked();
             // TODO: b/389105038 - remove the temporary workaround for binder transaction
             //  limit.
-            int defaultMaxPageBytesLimit = IcingOptionsConfig.DEFAULT_MAX_PAGE_BYTES_LIMIT;
-            if (isolatedStorageFlagsSet()) {
-                // It's very likely we are using pVM backed isolated storage now.
-                defaultMaxPageBytesLimit = DEFAULT_MAX_PAGE_BYTES_LIMIT_FOR_ISOLATED_STORAGE;
-            }
-            return mBundleLocked.getInt(KEY_ICING_MAX_PAGE_BYTES_LIMIT, defaultMaxPageBytesLimit);
+            return mBundleLocked.getInt(
+                    KEY_ICING_MAX_PAGE_BYTES_LIMIT,
+                    IcingOptionsConfig.DEFAULT_MAX_PAGE_BYTES_LIMIT);
+        }
+    }
+
+    @Override
+    public int getMaxPageBytesLimitForVm() {
+        synchronized (mLock) {
+            throwIfClosedLocked();
+            // TODO: b/389105038 - remove the temporary workaround for binder transaction
+            //  limit.
+            return mBundleLocked.getInt(
+                    KEY_ICING_MAX_PAGE_BYTES_LIMIT,
+                    DEFAULT_MAX_PAGE_BYTES_LIMIT_FOR_ISOLATED_STORAGE);
         }
     }
 
@@ -613,6 +650,14 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
         }
     }
 
+    @Override
+    public long getCachedPersistDelayMillis() {
+        synchronized (mLock) {
+            throwIfClosedLocked();
+            return mBundleLocked.getLong(KEY_PERSIST_DELAY, defaultPersistDelayMillis());
+        }
+    }
+
     @Override
     public int getIntegerIndexBucketSplitThreshold() {
         synchronized (mLock) {
@@ -674,12 +719,34 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
 
     @Override
     public long getIsolatedStorageMemoryBytes() {
-        synchronized (mLock) {
-            throwIfClosedLocked();
-            return mBundleLocked.getLong(
-                    ISOLATED_STORAGE_MEMORY_BYTES,
-                    IsolatedStorageServiceManager.DEFAULT_MEMORY_BYTES);
-        }
+        return DeviceConfig.getLong(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_ISOLATED_STORAGE_MEMORY_BYTES,
+                IsolatedStorageServiceManager.DEFAULT_MEMORY_BYTES);
+    }
+
+    @Override
+    public boolean getIsolatedStorageEnabled() {
+        return DeviceConfig.getBoolean(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_ISOLATED_STORAGE_ENABLED,
+                IsolatedStorageServiceManager.DEFAULT_ISOLATED_STORAGE_ENABLED);
+    }
+
+    @Override
+    public boolean enableIsolatedStorageMigration() {
+        return DeviceConfig.getBoolean(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_ISOLATED_STORAGE_MIGRATION_ENABLED,
+                IsolatedStorageServiceManager.DEFAULT_ISOLATED_STORAGE_MIGRATION_ENABLED);
+    }
+
+    @Override
+    public boolean getIsolatedStorageDeleteCeVms() {
+        return DeviceConfig.getBoolean(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_ISOLATED_STORAGE_DELETE_CE_VMS,
+                IsolatedStorageServiceManager.DEFAULT_ISOLATED_STORAGE_DELETE_CE_VMS);
     }
 
     @Override
@@ -702,12 +769,30 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
         synchronized (mLock) {
             throwIfClosedLocked();
             int val =
-                mBundleLocked.getInt(
-                    KEY_LIGHTWEIGHT_PERSIST_TYPE, defaultLightweightPersistType().getNumber());
+                    mBundleLocked.getInt(
+                            KEY_LIGHTWEIGHT_PERSIST_TYPE,
+                            defaultLightweightPersistType().getNumber());
             return PersistType.Code.forNumber(val);
         }
     }
 
+    @Override
+    public int getCompressionThresholdBytes() {
+        synchronized (mLock) {
+            throwIfClosedLocked();
+            return mBundleLocked.getInt(
+                    KEY_COMPRESSION_THRESHOLD_BYTES, DEFAULT_COMPRESSION_THRESHOLD_BYTES);
+        }
+    }
+
+    @Override
+    public int getCompressionMemLevel() {
+        synchronized (mLock) {
+            throwIfClosedLocked();
+            return mBundleLocked.getInt(KEY_COMPRESSION_MEM_LEVEL, defaultCompressionMemLevel());
+        }
+    }
+
     @GuardedBy("mLock")
     private void throwIfClosedLocked() {
         if (mIsClosedLocked) {
@@ -715,6 +800,14 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
         }
     }
 
+    @Override
+    public int getAppOpenEventIndexerLoggingSamplingRate() {
+        synchronized (mLock) {
+            throwIfClosedLocked();
+            return mAppOpenEventIndexerConfig.getLoggingSamplingRate();
+        }
+    }
+
     private void updateCachedValues(DeviceConfig.@NonNull Properties properties) {
         for (String key : properties.getKeyset()) {
             updateCachedValue(key, properties);
@@ -757,13 +850,18 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
                 }
                 break;
             case KEY_LIMIT_CONFIG_MAX_DOCUMENT_SIZE_BYTES:
-            case KEY_LIMIT_CONFIG_MAX_BYTE_LIMIT_BATCH_PUT:
                 synchronized (mLock) {
                     mBundleLocked.putInt(
                             key,
                             properties.getInt(key, DEFAULT_LIMIT_CONFIG_MAX_DOCUMENT_SIZE_BYTES));
                 }
                 break;
+            case KEY_LIMIT_CONFIG_MAX_BYTE_LIMIT_BATCH_PUT:
+                synchronized (mLock) {
+                    mBundleLocked.putInt(
+                            key, properties.getInt(key, DEFAULT_MAX_BYTE_LIMIT_FOR_BATCH_PUT));
+                }
+                break;
             case KEY_LIMIT_CONFIG_PER_PACKAGE_DOCUMENT_COUNT_LIMIT:
                 synchronized (mLock) {
                     mBundleLocked.putInt(
@@ -978,6 +1076,12 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
                             key, properties.getLong(key, DEFAULT_FULLY_PERSIST_JOB_INTERVAL));
                 }
                 break;
+            case KEY_PERSIST_DELAY:
+                synchronized (mLock) {
+                    mBundleLocked.putLong(
+                            key, properties.getLong(key, defaultPersistDelayMillis()));
+                }
+                break;
             case KEY_ORPHAN_BLOB_TIME_TO_LIVE_MS:
                 synchronized (mLock) {
                     mBundleLocked.putLong(
@@ -989,27 +1093,30 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
                     mBundleLocked.putInt(key, properties.getInt(key, DEFAULT_MAX_OPEN_BLOB_COUNT));
                 }
                 break;
-            case ISOLATED_STORAGE_MEMORY_BYTES:
-                synchronized (mLock) {
-                    mBundleLocked.putLong(
-                            key,
-                            properties.getLong(
-                                    key, IsolatedStorageServiceManager.DEFAULT_MEMORY_BYTES));
-                }
-                break;
             case KEY_LIGHTWEIGHT_PERSIST_TYPE:
                 synchronized (mLock) {
                     int val = properties.getInt(key, defaultLightweightPersistType().getNumber());
                     PersistType.Code code = PersistType.Code.forNumber(val);
                     // Confirm that the provided value is actually valid. Otherwise, ignore.
                     if (code != null && code != PersistType.Code.UNKNOWN) {
-                      mBundleLocked.putInt(key, val);
+                        mBundleLocked.putInt(key, val);
                     }
                 }
                 break;
+            case KEY_COMPRESSION_THRESHOLD_BYTES:
+                synchronized (mLock) {
+                    mBundleLocked.putInt(
+                            key, properties.getInt(key, DEFAULT_COMPRESSION_THRESHOLD_BYTES));
+                }
+                break;
+            case KEY_COMPRESSION_MEM_LEVEL:
+                synchronized (mLock) {
+                    mBundleLocked.putInt(key, properties.getInt(key, defaultCompressionMemLevel()));
+                }
+                break;
             case KEY_BUILD_PROPERTY_EXISTENCE_METADATA_HITS:
-                // TODO(b/309826655) Set this value properly in main branch
-                // fall throw to default since we never turn this feature on in udc-mainline-prod
+            // TODO(b/309826655) Set this value properly in main branch
+            // fall throw to default since we never turn this feature on in udc-mainline-prod
             default:
                 break;
         }
diff --git a/service/java/com/android/server/appsearch/InternalAppSearchLogger.java b/service/java/com/android/server/appsearch/InternalAppSearchLogger.java
index 1cbeecb7..516fb066 100644
--- a/service/java/com/android/server/appsearch/InternalAppSearchLogger.java
+++ b/service/java/com/android/server/appsearch/InternalAppSearchLogger.java
@@ -18,6 +18,7 @@ package com.android.server.appsearch;
 
 import android.annotation.NonNull;
 
+import com.android.server.appsearch.appsindexer.AppOpenEventStats;
 import com.android.server.appsearch.external.localstorage.AppSearchLogger;
 import com.android.server.appsearch.util.ApiCallRecord;
 
@@ -35,4 +36,6 @@ public interface InternalAppSearchLogger extends AppSearchLogger {
 
     /** Returns a copy of the recorded {@link ApiCallRecord}. */
     List<ApiCallRecord> getLastCalledApis();
+
+    void logStats(@NonNull AppOpenEventStats appOpenEventStats);
 }
diff --git a/service/java/com/android/server/appsearch/ServiceAppSearchConfig.java b/service/java/com/android/server/appsearch/ServiceAppSearchConfig.java
index ea54ea11..e3bdcf71 100644
--- a/service/java/com/android/server/appsearch/ServiceAppSearchConfig.java
+++ b/service/java/com/android/server/appsearch/ServiceAppSearchConfig.java
@@ -17,6 +17,7 @@
 package com.android.server.appsearch;
 
 import static android.text.format.DateUtils.DAY_IN_MILLIS;
+import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
 
 import com.android.appsearch.flags.Flags;
 import com.android.server.appsearch.external.localstorage.AppSearchConfig;
@@ -96,12 +97,21 @@ public interface ServiceAppSearchConfig extends AppSearchConfig, AutoCloseable {
     /** The default interval in millisecond to trigger fully persist job. */
     long DEFAULT_FULLY_PERSIST_JOB_INTERVAL = DAY_IN_MILLIS;
 
+    /** The default delay in millisecond to schedule persistToDisk after putDocuments. */
+    long DEFAULT_PERSIST_DELAY = MINUTE_IN_MILLIS;
+
+    /** The time for a 5-min delay in millisecond to schedule persistToDisk after putDocuments. */
+    long DEFAULT_FIVE_MINUTE_PERSIST_DELAY = TimeUnit.MINUTES.toMillis(5);
+
     /**
      * The default number of active fds an app is allowed to open for read and write blob from
      * AppSearch.
      */
     int DEFAULT_MAX_OPEN_BLOB_COUNT = 250;
 
+    /** The default number of max byte size limit for a single batch put request. */
+    int DEFAULT_MAX_BYTE_LIMIT_FOR_BATCH_PUT = 64 * 1024; // 64 KiB
+
     /** Returns cached value for minTimeIntervalBetweenSamplesMillis. */
     long getCachedMinTimeIntervalBetweenSamplesMillis();
 
@@ -199,6 +209,11 @@ public interface ServiceAppSearchConfig extends AppSearchConfig, AutoCloseable {
     /** Returns the cached {@link AppSearchRateLimitConfig}. */
     AppSearchRateLimitConfig getCachedRateLimitConfig();
 
+    /** Returns the sampling rate for App Open Event Indexer stats logging. */
+    default int getAppOpenEventIndexerLoggingSamplingRate() {
+        return DEFAULT_SAMPLING_INTERVAL;
+    }
+
     /**
      * Returns the maximum allowed duration for an app function call in milliseconds.
      *
@@ -211,25 +226,42 @@ public interface ServiceAppSearchConfig extends AppSearchConfig, AutoCloseable {
      */
     long getCachedFullyPersistJobIntervalMillis();
 
+    /** Returns the delay in millisecond to schedule persistToDisk after putDocuments. */
+    long getCachedPersistDelayMillis();
+
     /** Returns the memory size in bytes for isolated storage. */
     default long getIsolatedStorageMemoryBytes() {
         return IsolatedStorageServiceManager.DEFAULT_MEMORY_BYTES;
     }
 
+    /** Returns whether or not AppSearch should use Isolated Storage */
+    default boolean getIsolatedStorageEnabled() {
+        return IsolatedStorageServiceManager.DEFAULT_ISOLATED_STORAGE_ENABLED;
+    }
+
+    /** Returns whether or not AppSearch should migrate data to isolated storage. */
+    default boolean enableIsolatedStorageMigration() {
+        return IsolatedStorageServiceManager.DEFAULT_ISOLATED_STORAGE_MIGRATION_ENABLED;
+    }
+
+    /** Returns whether or not we need to clean up old CE VMs */
+    default boolean getIsolatedStorageDeleteCeVms() {
+        return IsolatedStorageServiceManager.DEFAULT_ISOLATED_STORAGE_DELETE_CE_VMS;
+    }
+
     /**
      * Default min time interval between consecutive optimize calls in millis if there is no value
      * set for {@link #getCachedMinTimeOptimizeThresholdMs()} in the flag system.
      */
     default int defaultMinTimeOptimizeThresholdMillis() {
-        // TODO (b/385020106): figure out how to make the default 0 timeSinceLastOptimize work
-        //  with a higher threshold and return 4 hours when
-        //  Flags.enable_four_hour_min_optimize_threshold is true
-        return DEFAULT_MIN_TIME_OPTIMIZE_THRESHOLD_MILLIS;
+        return Flags.enableFourHourMinTimeOptimizeThreshold()
+                ? DEFAULT_FOUR_HOUR_MIN_TIME_OPTIMIZE_THRESHOLD_MILLIS
+                : DEFAULT_MIN_TIME_OPTIMIZE_THRESHOLD_MILLIS;
     }
 
     /**
-     * Default {@code PersistType.Code} that should be used to persist common mutations such as
-     * PUTs or DELETEs.
+     * Default {@code PersistType.Code} that should be used to persist common mutations such as PUTs
+     * or DELETEs.
      */
     default PersistType.@NonNull Code defaultLightweightPersistType() {
         return Flags.enableRecoveryProofPersistence()
@@ -237,6 +269,18 @@ public interface ServiceAppSearchConfig extends AppSearchConfig, AutoCloseable {
                 : PersistType.Code.LITE;
     }
 
+    /** Default mem level used for document compression. */
+    default int defaultCompressionMemLevel() {
+        return Flags.enableCompressionMemLevelOne() ? 1 : DEFAULT_COMPRESSION_MEM_LEVEL;
+    }
+
+    /** Default persist to disk delay time. */
+    default long defaultPersistDelayMillis() {
+        return Flags.enableFiveMinPersistToDiskDelay()
+                ? DEFAULT_FIVE_MINUTE_PERSIST_DELAY
+                : DEFAULT_PERSIST_DELAY;
+    }
+
     /**
      * Closes this {@link AppSearchConfig}.
      *
diff --git a/service/java/com/android/server/appsearch/ServiceOptimizeStrategy.java b/service/java/com/android/server/appsearch/ServiceOptimizeStrategy.java
index c3f5a763..db60a5e8 100644
--- a/service/java/com/android/server/appsearch/ServiceOptimizeStrategy.java
+++ b/service/java/com/android/server/appsearch/ServiceOptimizeStrategy.java
@@ -19,6 +19,7 @@ import android.annotation.NonNull;
 import android.app.appsearch.util.LogUtil;
 import android.util.Log;
 
+import com.android.appsearch.flags.Flags;
 import com.android.server.appsearch.external.localstorage.AppSearchImpl;
 import com.android.server.appsearch.external.localstorage.OptimizeStrategy;
 
@@ -43,6 +44,46 @@ public class ServiceOptimizeStrategy implements OptimizeStrategy {
 
     @Override
     public boolean shouldOptimize(@NonNull GetOptimizeInfoResultProto optimizeInfo) {
+        boolean hasWaitedForMinimumInterval =
+                optimizeInfo.getNoPreviousOptimizeInfo()
+                        || optimizeInfo.getTimeSinceLastOptimizeMs()
+                                >= mAppSearchConfig.getCachedMinTimeOptimizeThresholdMs();
+
+        if (Flags.enableNewOptimizeStrategyForActiveResultStates()) {
+            boolean forceOptimize =
+                    optimizeInfo.getTimeSinceLastOptimizeMs()
+                            >= Math.max(
+                                    mAppSearchConfig.getCachedTimeOptimizeThresholdMs(),
+                                    mAppSearchConfig.getCachedMinTimeOptimizeThresholdMs());
+            boolean optionalOptimize =
+                    optimizeInfo.getNumActiveResultStates() == 0
+                            && (optimizeInfo.getOptimizableDocs()
+                                            >= mAppSearchConfig.getCachedDocCountOptimizeThreshold()
+                                    || optimizeInfo.getEstimatedOptimizableBytes()
+                                            >= mAppSearchConfig.getCachedBytesOptimizeThreshold());
+            if (forceOptimize) {
+                return true;
+            }
+
+            if (optionalOptimize && !hasWaitedForMinimumInterval) {
+                // TODO(b/271890504): Produce a log message for statsd when we skip a potential
+                //  compaction because the time since the last compaction has not reached
+                //  the minimum threshold.
+                if (LogUtil.INFO) {
+                    Log.i(
+                            TAG,
+                            "Skipping optimization because time since last optimize ["
+                                    + optimizeInfo.getTimeSinceLastOptimizeMs()
+                                    + " ms] is lesser than the threshold for minimum time between"
+                                    + " optimizations ["
+                                    + mAppSearchConfig.getCachedMinTimeOptimizeThresholdMs()
+                                    + " ms]");
+                }
+                return false;
+            }
+            return optionalOptimize;
+        }
+
         boolean wantsOptimize =
                 optimizeInfo.getOptimizableDocs()
                                 >= mAppSearchConfig.getCachedDocCountOptimizeThreshold()
@@ -50,9 +91,7 @@ public class ServiceOptimizeStrategy implements OptimizeStrategy {
                                 >= mAppSearchConfig.getCachedBytesOptimizeThreshold()
                         || optimizeInfo.getTimeSinceLastOptimizeMs()
                                 >= mAppSearchConfig.getCachedTimeOptimizeThresholdMs();
-        if (wantsOptimize
-                && optimizeInfo.getTimeSinceLastOptimizeMs()
-                        < mAppSearchConfig.getCachedMinTimeOptimizeThresholdMs()) {
+        if (wantsOptimize && !hasWaitedForMinimumInterval) {
             // TODO(b/271890504): Produce a log message for statsd when we skip a potential
             //  compaction because the time since the last compaction has not reached
             //  the minimum threshold.
diff --git a/service/java/com/android/server/appsearch/UserStorageInfo.java b/service/java/com/android/server/appsearch/UserStorageInfo.java
index 89f63eb7..1600775b 100644
--- a/service/java/com/android/server/appsearch/UserStorageInfo.java
+++ b/service/java/com/android/server/appsearch/UserStorageInfo.java
@@ -27,6 +27,7 @@ import android.app.appsearch.util.ExceptionUtil;
 import android.util.ArrayMap;
 import android.util.Log;
 
+import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.appsearch.external.localstorage.AppSearchImpl;
 
@@ -51,11 +52,15 @@ public final class UserStorageInfo {
     public static final String STORAGE_INFO_FILE = "appsearch_storage";
     private static final String TAG = "AppSearchUserStorage";
     private final ReadWriteLock mReadWriteLock = new ReentrantReadWriteLock();
+
+    @GuardedBy("mReadWriteLock")
     private final File mStorageInfoFile;
 
     // Saves storage usage byte size for each package under the user, keyed by package name.
+    @GuardedBy("mReadWriteLock")
     private Map<String, Long> mPackageStorageSizeMap;
     // Saves storage usage byte size for all packages under the user.
+    @GuardedBy("mReadWriteLock")
     private long mTotalStorageSizeBytes;
 
     public UserStorageInfo(@NonNull File fileParentPath) {
@@ -70,16 +75,71 @@ public final class UserStorageInfo {
     public void updateStorageInfoFile(@NonNull AppSearchImpl appSearchImpl) {
         Objects.requireNonNull(appSearchImpl);
         mReadWriteLock.writeLock().lock();
-        try (FileOutputStream out = new FileOutputStream(mStorageInfoFile)) {
-            appSearchImpl.getRawStorageInfoProto().writeTo(out);
-        } catch (IOException | AppSearchException | RuntimeException e) {
-            Log.w(TAG, "Failed to dump storage info into file", e);
+        try {
+            StorageInfoProto storageInfo = appSearchImpl.getRawStorageInfoProto();
+            updateStorageInfoCacheLocked(storageInfo);
+            updateFileLocked(storageInfo);
+        } catch (AppSearchException e) {
+            Log.w(TAG, "Failed to get native storage info", e);
             ExceptionUtil.handleException(e);
         } finally {
             mReadWriteLock.writeLock().unlock();
         }
     }
 
+    /**
+     * Updates storage info file with the latest storage info.
+     */
+    public void updateStorageInfoCache(@NonNull StorageInfoProto storageInfo) {
+        Objects.requireNonNull(storageInfo);
+        mReadWriteLock.writeLock().lock();
+        try {
+            updateStorageInfoCacheLocked(storageInfo);
+        } finally {
+            mReadWriteLock.writeLock().unlock();
+        }
+    }
+
+    @GuardedBy("mReadWriteLock")
+    private void updateStorageInfoCacheLocked(@NonNull StorageInfoProto storageInfo) {
+        mTotalStorageSizeBytes = storageInfo.getTotalStorageSize();
+        mPackageStorageSizeMap = calculatePackageStorageInfoMap(storageInfo);
+    }
+
+    /**
+     * Clears the in-memory storage info cache.
+     * Resets the total storage size and clears the package storage size map.
+     */
+    public void dropStorageInfoCache() {
+        mReadWriteLock.writeLock().lock();
+        try {
+            dropStorageInfoCacheLocked();
+        } finally {
+            mReadWriteLock.writeLock().unlock();
+        }
+    }
+
+    @GuardedBy("mReadWriteLock")
+    private void dropStorageInfoCacheLocked() {
+        mTotalStorageSizeBytes = 0;
+        mPackageStorageSizeMap = Collections.emptyMap();
+    }
+
+    /**
+     * Checks if the storage info cache is empty.
+     *
+     * @return {@code true} if the cache is empty, otherwise {@code false}.
+     */
+    public boolean isCacheEmpty() {
+        mReadWriteLock.readLock().lock();
+        try {
+            return mTotalStorageSizeBytes == 0
+                    && mPackageStorageSizeMap.isEmpty();
+        } finally {
+            mReadWriteLock.readLock().unlock();
+        }
+    }
+
     /**
      * Gets storage usage byte size for a package with a given package name.
      *
@@ -87,7 +147,12 @@ public final class UserStorageInfo {
      */
     public long getSizeBytesForPackage(@NonNull String packageName) {
         Objects.requireNonNull(packageName);
-        return mPackageStorageSizeMap.getOrDefault(packageName, 0L);
+        mReadWriteLock.readLock().lock();
+        try {
+            return mPackageStorageSizeMap.getOrDefault(packageName, 0L);
+        } finally {
+            mReadWriteLock.readLock().unlock();
+        }
     }
 
     /**
@@ -96,28 +161,42 @@ public final class UserStorageInfo {
      * <p>Please note the storage info cached in file may be stale.
      */
     public long getTotalSizeBytes() {
-        return mTotalStorageSizeBytes;
+        mReadWriteLock.readLock().lock();
+        try {
+            return mTotalStorageSizeBytes;
+        } finally {
+            mReadWriteLock.readLock().unlock();
+        }
     }
 
     @RequiresNonNull("mStorageInfoFile")
     @VisibleForTesting
     void readStorageInfoFromFile(@UnderInitialization UserStorageInfo this) {
-        if (mStorageInfoFile.exists()) {
-            mReadWriteLock.readLock().lock();
-            try (InputStream in = new FileInputStream(mStorageInfoFile)) {
-                StorageInfoProto storageInfo = StorageInfoProto.parseFrom(in);
-                mTotalStorageSizeBytes = storageInfo.getTotalStorageSize();
-                mPackageStorageSizeMap = calculatePackageStorageInfoMap(storageInfo);
-                return;
-            } catch (IOException | RuntimeException e) {
-                Log.w(TAG, "Failed to read storage info from file", e);
-                ExceptionUtil.handleException(e);
-            } finally {
-                mReadWriteLock.readLock().unlock();
-            }
+        if (!mStorageInfoFile.exists()) {
+            dropStorageInfoCache();
+            return;
+        }
+
+        mReadWriteLock.writeLock().lock();
+        try (InputStream in = new FileInputStream(mStorageInfoFile)) {
+            StorageInfoProto storageInfo = StorageInfoProto.parseFrom(in);
+            updateStorageInfoCacheLocked(storageInfo);
+        } catch (IOException | RuntimeException e) {
+            Log.w(TAG, "Failed to read storage info from file", e);
+            dropStorageInfoCacheLocked();
+            ExceptionUtil.handleException(e);
+        } finally {
+            mReadWriteLock.writeLock().unlock();
+        }
+    }
+
+    private void updateFileLocked(@NonNull StorageInfoProto storageInfo) {
+        try (FileOutputStream out = new FileOutputStream(mStorageInfoFile)) {
+            storageInfo.writeTo(out);
+        } catch (IOException | RuntimeException e) {
+            Log.w(TAG, "Failed to dump storage info into file", e);
+            ExceptionUtil.handleException(e);
         }
-        mTotalStorageSizeBytes = 0;
-        mPackageStorageSizeMap = Collections.emptyMap();
     }
 
     /** Calculates storage usage byte size for packages from a {@link StorageInfoProto}. */
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppFunctionDiffCalculator.java b/service/java/com/android/server/appsearch/appsindexer/AppFunctionDiffCalculator.java
new file mode 100644
index 00000000..efe25171
--- /dev/null
+++ b/service/java/com/android/server/appsearch/appsindexer/AppFunctionDiffCalculator.java
@@ -0,0 +1,243 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.appsindexer;
+
+import android.annotation.NonNull;
+import android.app.appsearch.GenericDocument;
+import android.util.ArrayMap;
+import android.util.ArraySet;
+
+import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionDocument;
+
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
+public final class AppFunctionDiffCalculator {
+
+    /**
+     * Represents the difference between the currently stored and newly provided app functions.
+     *
+     * <p>This class is used to determine changes in app functions, including which functions have
+     * been added, updated, or removed, and whether the schema needs to be updated.
+     */
+    public static final class AppFunctionDiff {
+        /**
+         * Indicates whether {@code setSchema} should be called based on the diff.
+         *
+         * <p>This will be {@code true} if either of the following conditions is met:
+         *
+         * <ul>
+         *   <li>A new package with app functions has been added.
+         *   <li>A previously indexed package no longer contains app functions.
+         * </ul>
+         */
+        public final boolean modifySchema;
+
+        /** A map of newly added app function documents, keyed by function ID. */
+        public final Map<String, AppFunctionDocument> addedAppFunctions;
+
+        /**
+         * A map of updated app function documents, where the contents differ from their previously
+         * stored versions. Keyed by function ID.
+         */
+        public final Map<String, AppFunctionDocument> updatedAppFunctions;
+
+        /**
+         * A set of function IDs that should be removed using a {@code removeByDocumentId} call to
+         * AppSearch.
+         */
+        public final Set<String> functionIdsToRemove;
+
+        /**
+         * A set of all function document IDs that will be deleted either via a {@code setSchema}
+         * call or a {@code removeByDocumentId} call. Used for logging purposes only.
+         */
+        public final Set<String> allDeletedFunctionIds;
+
+        private AppFunctionDiff(
+                boolean modifySchema,
+                @NonNull Map<String, AppFunctionDocument> addedAppFunctions,
+                @NonNull Map<String, AppFunctionDocument> updatedAppFunctions,
+                @NonNull Set<String> functionIdsToRemove,
+                @NonNull Set<String> allDeletedFunctionIds) {
+            this.modifySchema = modifySchema;
+            this.addedAppFunctions = Objects.requireNonNull(addedAppFunctions);
+            this.updatedAppFunctions = Objects.requireNonNull(updatedAppFunctions);
+            this.functionIdsToRemove = Objects.requireNonNull(functionIdsToRemove);
+            this.allDeletedFunctionIds = Objects.requireNonNull(allDeletedFunctionIds);
+        }
+    }
+
+    /**
+     * Calculates the difference between the currently stored and the newly provided app functions.
+     *
+     * @param storedAppFunctions a map of package names to their stored app functions, keyed by
+     *     function ID
+     * @param currentAppFunctions a map of package names to their current app functions, keyed by
+     *     function ID
+     */
+    public static AppFunctionDiff calculate(
+            @NonNull Map<String, Map<String, AppFunctionDocument>> storedAppFunctions,
+            @NonNull Map<String, Map<String, ? extends AppFunctionDocument>> currentAppFunctions) {
+        // If a new package was added or removed.
+        boolean modifySchema = !storedAppFunctions.keySet().equals(currentAppFunctions.keySet());
+        Map<String, AppFunctionDocument> addedAppFunctions = new ArrayMap<>();
+        Map<String, AppFunctionDocument> updatedAppFunctions = new ArrayMap<>();
+        Set<String> functionIdsToRemove = new ArraySet<>();
+        Set<String> allDeletedFunctionIds = new ArraySet<>();
+
+        for (Map.Entry<String, Map<String, ? extends AppFunctionDocument>> packageEntry :
+                currentAppFunctions.entrySet()) {
+            String packageName = packageEntry.getKey();
+            Map<String, ? extends AppFunctionDocument> currentAppFunctionsPerApp =
+                    packageEntry.getValue();
+
+            // This might be null, in the case of functions newly added to a package
+            Map<String, AppFunctionDocument> appSearchAppFunctionsPerApp =
+                    storedAppFunctions.get(packageName);
+
+            if (appSearchAppFunctionsPerApp == null && !currentAppFunctionsPerApp.isEmpty()) {
+                // Functions added to an app that didn't have
+                modifySchema = true;
+                addedAppFunctions.putAll(currentAppFunctionsPerApp);
+            } else if (appSearchAppFunctionsPerApp != null) {
+                if (currentAppFunctionsPerApp.isEmpty()) {
+                    // All functions removed from an app that had them
+                    modifySchema = true;
+                    allDeletedFunctionIds.addAll(appSearchAppFunctionsPerApp.keySet());
+                } else {
+                    // App updated that had packages, we should check
+                    comparePackageFunctionDocuments(
+                            currentAppFunctionsPerApp,
+                            appSearchAppFunctionsPerApp,
+                            addedAppFunctions,
+                            updatedAppFunctions,
+                            functionIdsToRemove,
+                            allDeletedFunctionIds);
+                }
+            }
+        }
+
+        return new AppFunctionDiff(
+                modifySchema,
+                addedAppFunctions,
+                updatedAppFunctions,
+                functionIdsToRemove,
+                allDeletedFunctionIds);
+    }
+
+    /**
+     * Compares the app function documents in PackageManager vs those in AppSearch, and updates
+     * corresponding collections accordingly.
+     *
+     * @param currentAppFunctionDocumentsPerApp the mapping of function ids to documents
+     *     corresponding to what is in the apps metadata.
+     * @param appSearchAppFunctionDocumentsPerApp the mapping of function ids to documents
+     *     corresponding to what is in AppSearch
+     * @param addedAppFunctionsPerApp the mapping of newly added {@link AppFunctionDocument}(s) to
+     *     their ids for the app.
+     * @param updatedAppFunctionsPerApp the mapping of modified {@link AppFunctionDocument}(s) to
+     *     their ids for the app.
+     * @param functionIdsToRemove the set of ids that will be sent to a remove call in AppSearch
+     * @param allDeletedFunctionIds the set of ids of all functions that will be removed from
+     *     AppSearch, either by a delete call or by a setSchema call. For logging purposes.
+     */
+    private static void comparePackageFunctionDocuments(
+            @NonNull Map<String, ? extends AppFunctionDocument> currentAppFunctionDocumentsPerApp,
+            @NonNull Map<String, AppFunctionDocument> appSearchAppFunctionDocumentsPerApp,
+            @NonNull Map<String, AppFunctionDocument> addedAppFunctionsPerApp,
+            @NonNull Map<String, AppFunctionDocument> updatedAppFunctionsPerApp,
+            @NonNull Set<String> functionIdsToRemove,
+            @NonNull Set<String> allDeletedFunctionIds) {
+        Objects.requireNonNull(currentAppFunctionDocumentsPerApp);
+        Objects.requireNonNull(appSearchAppFunctionDocumentsPerApp);
+        Objects.requireNonNull(addedAppFunctionsPerApp);
+        Objects.requireNonNull(updatedAppFunctionsPerApp);
+        Objects.requireNonNull(functionIdsToRemove);
+        Objects.requireNonNull(allDeletedFunctionIds);
+
+        for (Map.Entry<String, ? extends AppFunctionDocument> currentFunctionEntry :
+                currentAppFunctionDocumentsPerApp.entrySet()) {
+            String functionId = currentFunctionEntry.getKey();
+            AppFunctionDocument currentFunctionDocument = currentFunctionEntry.getValue();
+            AppFunctionDocument appSearchFunctionDocument =
+                    appSearchAppFunctionDocumentsPerApp.get(functionId);
+            // appSearchFunctionDocument == null means it's a new document.
+            if (appSearchFunctionDocument == null) {
+                addedAppFunctionsPerApp.put(functionId, currentFunctionDocument);
+
+            } else if (!areFunctionDocumentsEqual(
+                    appSearchFunctionDocument, currentFunctionDocument)) {
+                updatedAppFunctionsPerApp.put(functionId, currentFunctionDocument);
+            }
+        }
+
+        for (Map.Entry<String, AppFunctionDocument> appSearchFunctionEntry :
+                appSearchAppFunctionDocumentsPerApp.entrySet()) {
+            String functionId = appSearchFunctionEntry.getKey();
+            if (!currentAppFunctionDocumentsPerApp.containsKey(functionId)) {
+                functionIdsToRemove.add(functionId);
+                allDeletedFunctionIds.add(functionId);
+            }
+        }
+    }
+
+    /**
+     * Checks if two AppFunction documents are equal. It isn't enough to call equals. We also need
+     * to ignore creation timestamp and parent types. These are set in AppSearch, but aren't set for
+     * the "about to be indexed" docs
+     *
+     * @return true if the documents are equal, false otherwise.
+     */
+    private static boolean areFunctionDocumentsEqual(
+            @NonNull GenericDocument document1, @NonNull GenericDocument document2) {
+        Objects.requireNonNull(document1);
+        Objects.requireNonNull(document2);
+
+        document1 = clearTimestampsAndParentTypesInDocument(document1);
+        document2 = clearTimestampsAndParentTypesInDocument(document2);
+
+        return document1.equals(document2);
+    }
+
+    private static GenericDocument clearTimestampsAndParentTypesInDocument(
+            @NonNull GenericDocument document) {
+        GenericDocument.Builder<?> builder =
+                new GenericDocument.Builder<>(document)
+                        .setCreationTimestampMillis(0)
+                        // GenericDocument#PARENT_TYPES_SYNTHETIC_PROPERTY is hidden
+                        .clearProperty("$$__AppSearch__parentTypes");
+
+        for (String propertyName : document.getPropertyNames()) {
+            Object property = document.getProperty(propertyName);
+            if (property instanceof GenericDocument[] nestedDocuments) {
+                GenericDocument[] clearedNestedDocuments =
+                        new GenericDocument[nestedDocuments.length];
+
+                for (int i = 0; i < nestedDocuments.length; i++) {
+                    clearedNestedDocuments[i] =
+                            clearTimestampsAndParentTypesInDocument(nestedDocuments[i]);
+                }
+
+                builder.setPropertyDocument(propertyName, clearedNestedDocuments);
+            }
+        }
+
+        return builder.build();
+    }
+}
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppFunctionDocumentParser.java b/service/java/com/android/server/appsearch/appsindexer/AppFunctionDocumentParser.java
index a684c253..b868eacc 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppFunctionDocumentParser.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppFunctionDocumentParser.java
@@ -22,7 +22,8 @@ import android.content.pm.PackageManager;
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionDocument;
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
 
-import java.util.List;
+import org.xmlpull.v1.XmlPullParser;
+
 import java.util.Map;
 
 /**
@@ -35,23 +36,6 @@ import java.util.Map;
  * named dynamically to be unique to the app package name.
  */
 public interface AppFunctionDocumentParser {
-    // TODO(b/367410454): Remove this method once enable_apps_indexer_incremental_put flag is
-    //  rolled out
-    /**
-     * Parses static metadata about App Functions from the given XML asset file.
-     *
-     * @param packageManager The PackageManager used to access app resources.
-     * @param packageName The package name of the app whose assets contain the XML file.
-     * @param assetFilePath The path to the XML file within the app's assets.
-     * @return A list of {@link AppFunctionStaticMetadata} objects representing the parsed App
-     *     Functions. An empty list is returned if there's an error during parsing.
-     */
-    @NonNull
-    List<AppFunctionStaticMetadata> parse(
-            @NonNull PackageManager packageManager,
-            @NonNull String packageName,
-            @NonNull String assetFilePath);
-
     /**
      * Parses static metadata about App Functions from the given XML asset file.
      *
@@ -69,8 +53,8 @@ public interface AppFunctionDocumentParser {
             @NonNull String assetFilePath);
 
     /**
-     * Parses metadata about App Functions from the given XML asset file, using type information
-     * from the given schemas.
+     * Parses metadata about App Functions from the given XML parser, using type information from
+     * the given schemas.
      *
      * <p>Note: The following requirements must be met for successful parsing:
      *
@@ -81,8 +65,9 @@ public interface AppFunctionDocumentParser {
      * </ul>
      *
      * @param packageManager the PackageManager used to access app resources.
-     * @param packageName the package name of the app whose assets contain the XML file.
-     * @param assetFilePath the path to the XML file within the app's assets.
+     * @param packageName the package name of the app for which app functions are being indexed.
+     * @param xmlParser an {@link XmlPullParser} instance that can be used to read the app function
+     *     documents serialized as XML in the app's APK.
      * @param schemas the mapping of schema types to their corresponding {@link AppSearchSchema}
      *     objects.
      * @return a mapping of document IDs to their corresponding {@link AppFunctionDocument} objects.
@@ -93,6 +78,6 @@ public interface AppFunctionDocumentParser {
     Map<String, AppFunctionDocument> parseIntoMapForGivenSchemas(
             @NonNull PackageManager packageManager,
             @NonNull String packageName,
-            @NonNull String assetFilePath,
+            @NonNull XmlPullParser xmlParser,
             @NonNull Map<String, AppSearchSchema> schemas);
 }
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppFunctionDocumentParserImpl.java b/service/java/com/android/server/appsearch/appsindexer/AppFunctionDocumentParserImpl.java
index 4ae77d8c..4b8aa70a 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppFunctionDocumentParserImpl.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppFunctionDocumentParserImpl.java
@@ -66,33 +66,6 @@ public class AppFunctionDocumentParserImpl implements AppFunctionDocumentParser
         mMaxAppFunctions = config.getMaxAppFunctionsPerPackage();
     }
 
-    // TODO(b/367410454): Remove this method once enable_apps_indexer_incremental_put flag is
-    //  rolled out
-    @NonNull
-    @Override
-    public List<AppFunctionStaticMetadata> parse(
-            @NonNull PackageManager packageManager,
-            @NonNull String packageName,
-            @NonNull String assetFilePath) {
-        Objects.requireNonNull(packageManager);
-        Objects.requireNonNull(packageName);
-        Objects.requireNonNull(assetFilePath);
-        try {
-            return parseAppFunctions(
-                    initializeParser(packageManager, packageName, assetFilePath), packageName);
-        } catch (Exception ex) {
-            // The code parses an XML file from another app's assets, using a broad try-catch to
-            // handle potential errors since the XML structure might be unpredictable.
-            Log.e(
-                    TAG,
-                    String.format(
-                            "Failed to parse XML from package '%s', asset file '%s'",
-                            packageName, assetFilePath),
-                    ex);
-        }
-        return Collections.emptyList();
-    }
-
     @NonNull
     @Override
     public Map<String, AppFunctionStaticMetadata> parseIntoMap(
@@ -139,37 +112,6 @@ public class AppFunctionDocumentParserImpl implements AppFunctionDocumentParser
         return parser;
     }
 
-    // TODO(b/367410454): Remove this method once enable_apps_indexer_incremental_put flag is
-    //  rolled out
-    /**
-     * Parses a sequence of `appfunction` elements from the XML into a list of {@link
-     * AppFunctionStaticMetadata}.
-     *
-     * @param parser the XmlPullParser positioned at the start of the xml file
-     */
-    @NonNull
-    private List<AppFunctionStaticMetadata> parseAppFunctions(
-            @NonNull XmlPullParser parser, @NonNull String packageName)
-            throws XmlPullParserException, IOException {
-        List<AppFunctionStaticMetadata> appFunctions = new ArrayList<>();
-
-        int eventType = parser.getEventType();
-
-        while (eventType != XmlPullParser.END_DOCUMENT) {
-            String tagName = parser.getName();
-            if (eventType == XmlPullParser.START_TAG && XML_TAG_APPFUNCTION.equals(tagName)) {
-                AppFunctionStaticMetadata appFunction = parseAppFunction(parser, packageName);
-                appFunctions.add(appFunction);
-                if (appFunctions.size() >= mMaxAppFunctions) {
-                    Log.d(TAG, "Exceeding the max number of app functions: " + packageName);
-                    return appFunctions;
-                }
-            }
-            eventType = parser.next();
-        }
-        return appFunctions;
-    }
-
     /**
      * Parses a sequence of `appfunction` elements from the XML into a map of function ids to their
      * corresponding {@link AppFunctionStaticMetadata}.
@@ -283,27 +225,19 @@ public class AppFunctionDocumentParserImpl implements AppFunctionDocumentParser
     public Map<String, AppFunctionDocument> parseIntoMapForGivenSchemas(
             @NonNull PackageManager packageManager,
             @NonNull String packageName,
-            @NonNull String assetFilePath,
+            @NonNull XmlPullParser xmlPullParser,
             @NonNull Map<String, AppSearchSchema> schemas) {
         Objects.requireNonNull(packageManager);
         Objects.requireNonNull(packageName);
-        Objects.requireNonNull(assetFilePath);
+        Objects.requireNonNull(xmlPullParser);
         Objects.requireNonNull(schemas);
 
         try {
-            return parseAppFunctionsIntoMapForGivenSchemas(
-                    initializeParser(packageManager, packageName, assetFilePath),
-                    packageName,
-                    schemas);
+            return parseAppFunctionsIntoMapForGivenSchemas(xmlPullParser, packageName, schemas);
         } catch (Exception ex) {
             // The code parses an XML file from another app's assets, using a broad try-catch to
             // handle potential errors since the XML structure might be unpredictable.
-            Log.e(
-                    TAG,
-                    String.format(
-                            "Failed to parse XML from package '%s', asset file '%s'",
-                            packageName, assetFilePath),
-                    ex);
+            Log.e(TAG, String.format("Failed to parse XML from package '%s'", packageName), ex);
         }
         return Collections.emptyMap();
     }
@@ -434,6 +368,15 @@ public class AppFunctionDocumentParserImpl implements AppFunctionDocumentParser
                             docBuilder.setId(packageName + "/" + id);
                             wasDocIdSet = true;
                         }
+                    } else {
+                        // Unrecognized start tag, throw an exception.
+                        throw new IllegalStateException(
+                                "Found a start tag not defined by schema "
+                                        + schemaType
+                                        + ": "
+                                        + parser.getName()
+                                        + ". Check the corresponding schema file specified by "
+                                        + "android.app.appfunctions.schema.");
                     }
                     break;
 
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerConfig.java b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerConfig.java
index 3d8ce763..1e56e4b8 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerConfig.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerConfig.java
@@ -41,6 +41,12 @@ public interface AppOpenEventIndexerConfig {
      */
     long DEFAULT_APP_OPEN_EVENT_MIN_TIME_BETWEEN_SYNCS_MILLIS = TimeUnit.HOURS.toMillis(1);
 
+    /** Returns the default sampling rate for App Open Event Indexer stats logging. */
+    boolean DEFAULT_APP_OPEN_EVENT_INDEXER_STATS_LOGGING_ENABLED = true;
+
+    /** Returns the default sampling rate for App Open Event Indexer stats logging. */
+    int DEFAULT_APP_OPEN_EVENT_INDEXER_STATS_LOGGING_SAMPLING_RATE = 10;
+
     /** Returns whether App Open Event Indexer is enabled. */
     boolean isAppOpenEventIndexerEnabled();
 
@@ -52,4 +58,10 @@ public interface AppOpenEventIndexerConfig {
      * milliseconds.
      */
     long getMinTimeBetweenSyncsMillis();
+
+    /** Returns whether App Open Event Indexer stats logging is enabled. */
+    boolean isLoggingEnabled();
+
+    /** Returns the sampling rate for App Open Event Indexer stats logging. */
+    int getLoggingSamplingRate();
 }
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerImpl.java b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerImpl.java
index 6be14e91..43722e1f 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerImpl.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerImpl.java
@@ -21,6 +21,7 @@ import android.annotation.WorkerThread;
 import android.app.appsearch.exceptions.AppSearchException;
 import android.app.usage.UsageStatsManager;
 import android.content.Context;
+import android.os.SystemClock;
 
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppOpenEvent;
 
@@ -53,22 +54,39 @@ public final class AppOpenEventIndexerImpl implements Closeable {
      *     ran
      */
     @WorkerThread
-    public void doUpdate(@NonNull AppOpenEventIndexerSettings settings) throws AppSearchException {
+    public void doUpdate(
+            @NonNull AppOpenEventIndexerSettings settings,
+            @NonNull AppOpenEventStats.Builder appOpenEventStatsBuilder)
+            throws AppSearchException {
         Objects.requireNonNull(settings);
+        Objects.requireNonNull(appOpenEventStatsBuilder);
 
         UsageStatsManager usageStatsManager = mContext.getSystemService(UsageStatsManager.class);
 
         long currentTimeMillis = System.currentTimeMillis();
         long lastAppOpenIndexerUpdateTimeMillis = settings.getLastUpdateTimestampMillis();
+        appOpenEventStatsBuilder.setLastAppUpdateTimestampMillis(
+                lastAppOpenIndexerUpdateTimeMillis);
+
+        long startTimeMillis = SystemClock.elapsedRealtime();
         List<AppOpenEvent> appOpenEvents =
                 AppsUtil.getAppOpenEvents(
                         usageStatsManager, lastAppOpenIndexerUpdateTimeMillis, currentTimeMillis);
+        appOpenEventStatsBuilder.setUsageStatsManagerReadLatencyMillis(
+                SystemClock.elapsedRealtime() - startTimeMillis);
+        appOpenEventStatsBuilder.setNumberOfAppOpenEventsAdded(appOpenEvents.size());
 
         try {
             // This should be a no-op if the schema is already set and unchanged.
+            startTimeMillis = SystemClock.elapsedRealtime();
             mAppSearchHelper.setSchemaForAppOpenEvents();
+            appOpenEventStatsBuilder.setAppSearchSetSchemaLatencyMillis(
+                    SystemClock.elapsedRealtime() - startTimeMillis);
 
-            mAppSearchHelper.indexAppOpenEvents(appOpenEvents);
+            startTimeMillis = SystemClock.elapsedRealtime();
+            mAppSearchHelper.indexAppOpenEvents(appOpenEvents, appOpenEventStatsBuilder);
+            appOpenEventStatsBuilder.setAppSearchPutLatencyMillis(
+                    SystemClock.elapsedRealtime() - startTimeMillis);
             settings.setLastUpdateTimestampMillis(currentTimeMillis);
         } catch (AppSearchException e) {
             // Reset the last update time stamp and app update timestamp so we can try again later.
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerUserInstance.java b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerUserInstance.java
index c4620126..c4fc8f1d 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerUserInstance.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerUserInstance.java
@@ -27,6 +27,8 @@ import android.util.Slog;
 
 import com.android.appsearch.flags.Flags;
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.server.appsearch.AppSearchComponentFactory;
+import com.android.server.appsearch.InternalAppSearchLogger;
 import com.android.server.appsearch.indexer.IndexerMaintenanceService;
 
 import java.io.File;
@@ -63,6 +65,8 @@ public final class AppOpenEventIndexerUserInstance {
 
     private final AppOpenEventIndexerConfig mAppOpenEventIndexerConfig;
 
+    private final InternalAppSearchLogger mLogger;
+
     /**
      * Single threaded executor to make sure there is only one active sync per {@link
      * BaseIndexerUserInstance}. Background tasks should be scheduled using {@link
@@ -144,6 +148,11 @@ public final class AppOpenEventIndexerUserInstance {
         mDataDir = Objects.requireNonNull(dataDir);
         mSingleThreadedExecutor = Objects.requireNonNull(singleThreadedExecutor);
         mContext = Objects.requireNonNull(context);
+        mLogger =
+                AppSearchComponentFactory.createLoggerInstance(
+                        mContext,
+                        AppSearchComponentFactory.getConfigInstance(mSingleThreadedExecutor, mContext));
+
         mAppOpenEventIndexerImpl = Objects.requireNonNull(appOpenEventIndexerImpl);
         mAppOpenEventIndexerSettings = Objects.requireNonNull(appOpenEventIndexerSettings);
         mAppOpenEventIndexerConfig = Objects.requireNonNull(appOpenEventIndexerConfig);
@@ -173,24 +182,30 @@ public final class AppOpenEventIndexerUserInstance {
 
     /** Schedule an update on single threaded executor. */
     public void updateAsync() {
-        executeOnSingleThreadedExecutor(
-                () -> {
-                    doUpdate();
-                    schedulePeriodicUpdate();
-                });
+        updateAsync(() -> {});
     }
 
     /**
-     * Schedule an update on a single-threaded executor.
+     * Schedule an update on a single-threaded executor. Mainly to be used for testing, where the
+     * callback is used to wait for the update to complete.
      *
      * @param callback A callback to be invoked after the update is complete.
      */
     void updateAsync(@NonNull Runnable callback) {
+        AppOpenEventStats.Builder appOpenEventStatsBuilder = new AppOpenEventStats.Builder();
+        appOpenEventStatsBuilder.setUpdateStartTimestampMillis(System.currentTimeMillis());
+        long startTimeMillis = System.currentTimeMillis();
         executeOnSingleThreadedExecutor(
                 () -> {
                     try {
-                        doUpdate();
+                        doUpdate(appOpenEventStatsBuilder);
                         schedulePeriodicUpdate();
+                        appOpenEventStatsBuilder.setTotalLatencyMillis(
+                                System.currentTimeMillis() - startTimeMillis);
+                        if (Flags.appOpenEventIndexerStatsLoggingEnabled()
+                                && mAppOpenEventIndexerConfig.isLoggingEnabled()) {
+                            mLogger.logStats(appOpenEventStatsBuilder.build());
+                        }
                     } finally {
                         callback.run();
                     }
@@ -258,8 +273,9 @@ public final class AppOpenEventIndexerUserInstance {
      * {@code MIN_TIME_BETWEEN_UPDATES_MILLIS} it will be a no-op.
      */
     @VisibleForTesting
-    void doUpdate() {
+    void doUpdate(@NonNull AppOpenEventStats.Builder appOpenEventStatsBuilder) {
         try {
+            Objects.requireNonNull(appOpenEventStatsBuilder);
             if (Flags.enableAppOpenEventsIndexerCheckPriorAttempt()) {
                 long now = System.currentTimeMillis();
                 long lastRun = mAppOpenEventIndexerSettings.getLastAttemptedUpdateTimestampMillis();
@@ -285,7 +301,8 @@ public final class AppOpenEventIndexerUserInstance {
                 Log.w(TAG, "Skipping update because last update was too recent");
                 return;
             }
-            mAppOpenEventIndexerImpl.doUpdate(mAppOpenEventIndexerSettings);
+            mAppOpenEventIndexerImpl.doUpdate(
+                    mAppOpenEventIndexerSettings, appOpenEventStatsBuilder);
             mAppOpenEventIndexerSettings.persist();
         } catch (IOException e) {
             Log.w(TAG, "Failed to save settings to disk", e);
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppOpenEventStats.java b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventStats.java
new file mode 100644
index 00000000..e4956d81
--- /dev/null
+++ b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventStats.java
@@ -0,0 +1,139 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.appsindexer;
+
+import android.util.ArraySet;
+
+import java.util.Collections;
+import java.util.Set;
+
+public final class AppOpenEventStats {
+
+    private final Set<Integer> mUpdateStatusCodes;
+    private final int mNumberOfAppOpenEventsAdded;
+    private final long mTotalLatencyMillis;
+    private final long mUsageStatsManagerReadLatencyMillis;
+    private final long mAppSearchSetSchemaLatencyMillis;
+    private final long mAppSearchPutLatencyMillis;
+    private final long mUpdateStartTimestampMillis;
+    private final long mLastAppUpdateTimestampMillis;
+
+    private AppOpenEventStats(Builder builder) {
+        mUpdateStatusCodes =
+                Collections.unmodifiableSet(new ArraySet<>(builder.mUpdateStatusCodes));
+        mNumberOfAppOpenEventsAdded = builder.mNumberOfAppOpenEventsAdded;
+        mTotalLatencyMillis = builder.mTotalLatencyMillis;
+        mUsageStatsManagerReadLatencyMillis = builder.mUsageStatsManagerReadLatencyMillis;
+        mAppSearchSetSchemaLatencyMillis = builder.mAppSearchSetSchemaLatencyMillis;
+        mAppSearchPutLatencyMillis = builder.mAppSearchPutLatencyMillis;
+        mUpdateStartTimestampMillis = builder.mUpdateStartTimestampMillis;
+        mLastAppUpdateTimestampMillis = builder.mLastAppUpdateTimestampMillis;
+    }
+
+    public Set<Integer> getUpdateStatusCodes() {
+        return mUpdateStatusCodes;
+    }
+
+    public int getNumberOfAppOpenEventsAdded() {
+        return mNumberOfAppOpenEventsAdded;
+    }
+
+    public long getTotalLatencyMillis() {
+        return mTotalLatencyMillis;
+    }
+
+    public long getUsageStatsManagerReadLatencyMillis() {
+        return mUsageStatsManagerReadLatencyMillis;
+    }
+
+    public long getAppSearchSetSchemaLatencyMillis() {
+        return mAppSearchSetSchemaLatencyMillis;
+    }
+
+    public long getAppSearchPutLatencyMillis() {
+        return mAppSearchPutLatencyMillis;
+    }
+
+    public long getUpdateStartTimestampMillis() {
+        return mUpdateStartTimestampMillis;
+    }
+
+    public long getLastAppUpdateTimestampMillis() {
+        return mLastAppUpdateTimestampMillis;
+    }
+
+    public static class Builder {
+        private Set<Integer> mUpdateStatusCodes = new ArraySet<>();
+        private int mNumberOfAppOpenEventsAdded = 0;
+        private long mTotalLatencyMillis = 0;
+        private long mUsageStatsManagerReadLatencyMillis = 0;
+        private long mAppSearchSetSchemaLatencyMillis = 0;
+        private long mAppSearchPutLatencyMillis = 0;
+        private long mUpdateStartTimestampMillis = 0;
+        private long mLastAppUpdateTimestampMillis = 0;
+
+        public Builder addUpdateStatusCode(int statusCode) {
+            mUpdateStatusCodes.add(statusCode);
+            return this;
+        }
+
+        public Builder setUpdateStatusCodes(Set<Integer> statusCodes) {
+            mUpdateStatusCodes = new ArraySet<>(statusCodes);
+            return this;
+        }
+
+        public Builder setNumberOfAppOpenEventsAdded(int numberOfAppOpenEventsAdded) {
+            mNumberOfAppOpenEventsAdded = numberOfAppOpenEventsAdded;
+            return this;
+        }
+
+        public Builder setTotalLatencyMillis(long totalLatencyMillis) {
+            mTotalLatencyMillis = totalLatencyMillis;
+            return this;
+        }
+
+        public Builder setUsageStatsManagerReadLatencyMillis(
+                long usageStatsManagerReadLatencyMillis) {
+            mUsageStatsManagerReadLatencyMillis = usageStatsManagerReadLatencyMillis;
+            return this;
+        }
+
+        public Builder setAppSearchSetSchemaLatencyMillis(long appSearchSetSchemaLatencyMillis) {
+            mAppSearchSetSchemaLatencyMillis = appSearchSetSchemaLatencyMillis;
+            return this;
+        }
+
+        public Builder setAppSearchPutLatencyMillis(long appSearchPutLatencyMillis) {
+            mAppSearchPutLatencyMillis = appSearchPutLatencyMillis;
+            return this;
+        }
+
+        public Builder setUpdateStartTimestampMillis(long updateStartTimestampMillis) {
+            mUpdateStartTimestampMillis = updateStartTimestampMillis;
+            return this;
+        }
+
+        public Builder setLastAppUpdateTimestampMillis(long lastAppUpdateTimestampMillis) {
+            mLastAppUpdateTimestampMillis = lastAppUpdateTimestampMillis;
+            return this;
+        }
+
+        public AppOpenEventStats build() {
+            return new AppOpenEventStats(this);
+        }
+    }
+}
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppSearchHelper.java b/service/java/com/android/server/appsearch/appsindexer/AppSearchHelper.java
index 31267621..87e7f7eb 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppSearchHelper.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppSearchHelper.java
@@ -50,7 +50,6 @@ import com.android.server.appsearch.appsindexer.appsearchtypes.MobileApplication
 
 import java.io.Closeable;
 import java.io.IOException;
-import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
@@ -376,96 +375,6 @@ public class AppSearchHelper implements Closeable {
         mSyncAppSearchAppOpenEventDbSession.setSchema(schemaBuilder.build());
     }
 
-    // TODO(b/367410454): Remove this method once enable_apps_indexer_incremental_put flag is
-    //  rolled out
-    /**
-     * Indexes a collection of apps into AppSearch. This requires that the corresponding
-     * MobileApplication and AppFunctionStaticMetadata schemas are already set by a previous call to
-     * {@link#setSchemasForPackages}. The call doesn't necessarily have to happen in the current
-     * sync.
-     *
-     * @param apps a list of MobileApplication documents to be inserted.
-     * @param currentAppFunctions a list of AppFunctionStaticMetadata documents to be inserted. Each
-     *     AppFunctionStaticMetadata should point to its corresponding MobileApplication.
-     * @param indexedAppFunctions a list of indexed AppFunctionStaticMetadata documents
-     * @param appsUpdateStats stats object to update, necessary as we determine number of deleted
-     *     functions in this method.
-     * @throws AppSearchException if indexing results in a {@link
-     *     AppSearchResult#RESULT_OUT_OF_SPACE} result code. It will also throw this if the put call
-     *     results in a system error as in {@link BatchResultCallback#onSystemError}. This may
-     *     happen if the AppSearch service unexpectedly fails to initialize and can't be recovered,
-     *     for instance.
-     * @return an {@link AppSearchBatchResult} containing the results of the put operation. The keys
-     *     of the returned {@link AppSearchBatchResult} are the IDs of the input documents. The
-     *     values are {@code null} if they were successfully indexed, or a failed {@link
-     *     AppSearchResult} otherwise.
-     * @see AppSearchSession#put
-     */
-    @WorkerThread
-    public AppSearchBatchResult<String, Void> indexApps(
-            @NonNull List<MobileApplication> apps,
-            @NonNull List<AppFunctionStaticMetadata> currentAppFunctions,
-            @NonNull List<GenericDocument> indexedAppFunctions,
-            @NonNull AppsUpdateStats appsUpdateStats)
-            throws AppSearchException {
-        Objects.requireNonNull(apps);
-        Objects.requireNonNull(currentAppFunctions);
-        Objects.requireNonNull(appsUpdateStats);
-
-        // For packages that we are re-indexing, we need to collect a list of stale of function IDs.
-        Set<String> packagesToReindex = new ArraySet<>();
-        Set<String> currentAppFunctionIds = new ArraySet<>();
-        for (int i = 0; i < currentAppFunctions.size(); i++) {
-            AppFunctionStaticMetadata appFunction = currentAppFunctions.get(i);
-            packagesToReindex.add(appFunction.getPackageName());
-            currentAppFunctionIds.add(appFunction.getId());
-        }
-        // Determine which indexed app functions are no longer in the apps. We should only remove
-        // functions in packages that we are re-indexing.
-        Set<String> appFunctionIdsToRemove = new ArraySet<>();
-        for (int i = 0; i < indexedAppFunctions.size(); i++) {
-            GenericDocument appFunction = indexedAppFunctions.get(i);
-            String id = appFunction.getId();
-            String packageName =
-                    appFunction.getPropertyString(AppFunctionDocument.PROPERTY_PACKAGE_NAME);
-            if (packagesToReindex.contains(packageName) && !currentAppFunctionIds.contains(id)) {
-                appFunctionIdsToRemove.add(id);
-            }
-        }
-
-        // Then, insert all the documents. At this point, the document schema names have
-        // already been set to the per-package name. We can just add them to the request.
-        // TODO(b/357551503): put only the documents that have been added or updated.
-        PutDocumentsRequest request =
-                new PutDocumentsRequest.Builder()
-                        .addGenericDocuments(apps)
-                        .addGenericDocuments(currentAppFunctions)
-                        .build();
-
-        AppSearchBatchResult<String, Void> result = mSyncAppSearchAppsDbSession.put(request);
-        if (!result.isSuccess()) {
-            Map<String, AppSearchResult<Void>> failures = result.getFailures();
-            for (AppSearchResult<Void> failure : failures.values()) {
-                // If it's out of space, stop indexing
-                if (failure.getResultCode() == AppSearchResult.RESULT_OUT_OF_SPACE) {
-                    throw new AppSearchException(
-                            failure.getResultCode(), failure.getErrorMessage());
-                } else {
-                    Log.e(TAG, "Ran into error while indexing apps: " + failure);
-                }
-            }
-        }
-
-        appsUpdateStats.mApproximateNumberOfFunctionsRemoved = appFunctionIdsToRemove.size();
-        // Then, delete all the stale documents.
-        mSyncAppSearchAppsDbSession.remove(
-                new RemoveByDocumentIdRequest.Builder(
-                                AppFunctionStaticMetadata.APP_FUNCTION_NAMESPACE)
-                        .addIds(appFunctionIdsToRemove)
-                        .build());
-        return result;
-    }
-
     /**
      * Indexes a collection of app open events into AppSearch. This requires that the AppOpenEvent
      * schema is already set by a previous call to {@link setSchemaForAppOpenEvents}.
@@ -476,7 +385,9 @@ public class AppSearchHelper implements Closeable {
      */
     @WorkerThread
     public AppSearchBatchResult<String, Void> indexAppOpenEvents(
-            @NonNull List<AppOpenEvent> appOpenEvents) throws AppSearchException {
+            @NonNull List<AppOpenEvent> appOpenEvents,
+            @NonNull AppOpenEventStats.Builder appOpenEventStatsBuilder)
+            throws AppSearchException {
         Objects.requireNonNull(appOpenEvents);
 
         PutDocumentsRequest request =
@@ -487,6 +398,7 @@ public class AppSearchHelper implements Closeable {
         if (!result.isSuccess()) {
             Map<String, AppSearchResult<Void>> failures = result.getFailures();
             for (AppSearchResult<Void> failure : failures.values()) {
+                appOpenEventStatsBuilder.addUpdateStatusCode(failure.getResultCode());
                 // If it's out of space, stop indexing
                 if (failure.getResultCode() == AppSearchResult.RESULT_OUT_OF_SPACE) {
                     throw new AppSearchException(
@@ -495,6 +407,8 @@ public class AppSearchHelper implements Closeable {
                     Log.e(TAG, "Ran into error while indexing apps: " + failure);
                 }
             }
+        } else {
+            appOpenEventStatsBuilder.addUpdateStatusCode(AppSearchResult.RESULT_OK);
         }
         return result;
     }
@@ -592,10 +506,12 @@ public class AppSearchHelper implements Closeable {
                         .setJoinSpec(appFunctionJoinSpec)
                         .build();
 
-        SyncSearchResults results =
-                mSyncAppSearchAppsDbSession.search("", mobileApplicationSearchSpec);
-
-        return collectAppFunctionDocumentsFromAllPages(results, new ArraySet<>(appPackageIds));
+        try (SyncSearchResults results =
+                mSyncAppSearchAppsDbSession.search("", mobileApplicationSearchSpec)) {
+            return collectAppFunctionDocumentsFromAllPages(results, new ArraySet<>(appPackageIds));
+        } catch (IOException e) {
+            throw new AppSearchException(RESULT_IO_ERROR, "Failed to close search results", e);
+        }
     }
 
     /**
@@ -644,27 +560,33 @@ public class AppSearchHelper implements Closeable {
     }
 
     /**
-     * Searches AppSearch and returns a Map with the package ids and their last updated times. This
-     * helps us determine which app documents need to be re-indexed.
+     * Searches AppSearch and returns a Map with the package ids to their last updated times and
+     * whether app function service was enabled. This helps us determine which app documents need to
+     * be re-indexed.
      *
-     * @return a mapping of document id Strings to updated timestamps.
+     * @return a mapping of document id Strings to MobileApplication document with updatedTimestamp
+     *     and isAppFunctionServiceEnabled properties.
      */
     @NonNull
     @WorkerThread
-    public Map<String, Long> getAppsFromAppSearch() throws AppSearchException {
+    public Map<String, MobileApplication>
+            getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch()
+                    throws AppSearchException {
         SearchSpec allAppsSpec =
                 new SearchSpec.Builder()
                         .addFilterNamespaces(MobileApplication.APPS_NAMESPACE)
                         .addProjection(
                                 SearchSpec.SCHEMA_TYPE_WILDCARD,
-                                Collections.singletonList(
-                                        MobileApplication.APP_PROPERTY_UPDATED_TIMESTAMP))
+                                List.of(
+                                        MobileApplication.APP_PROPERTY_UPDATED_TIMESTAMP,
+                                        MobileApplication
+                                                .APP_PROPERTY_IS_APP_FUNCTION_SERVICE_ENABLED))
                         .addFilterPackageNames(mContext.getPackageName())
                         .setResultCountPerPage(GET_APP_IDS_PAGE_SIZE)
                         .build();
         try (SyncSearchResults results =
                 mSyncGlobalSearchSession.search(/* query= */ "", allAppsSpec)) {
-            return collectUpdatedTimestampFromAllPages(results);
+            return collectUpdatedTimestampAndAppFunctionServiceEnabledFromAllPages(results);
         } catch (IOException e) {
             throw new AppSearchException(RESULT_IO_ERROR, "Failed to close search results", e);
         }
@@ -717,16 +639,19 @@ public class AppSearchHelper implements Closeable {
     }
 
     /**
-     * Iterates through result pages to get the last updated times
+     * Iterates through result pages to get the last updated times and AppFunctionService's enabled
+     * state in the app.
      *
-     * @return a mapping of document id Strings updated timestamps.
+     * @return a mapping of package name to MobileApplication documents with updatedTimestamps and
+     *     isAppFunctionServiceEnabled properties.
      */
     @NonNull
     @WorkerThread
-    private Map<String, Long> collectUpdatedTimestampFromAllPages(
-            @NonNull SyncSearchResults results) {
+    private Map<String, MobileApplication>
+            collectUpdatedTimestampAndAppFunctionServiceEnabledFromAllPages(
+                    @NonNull SyncSearchResults results) {
         Objects.requireNonNull(results);
-        Map<String, Long> appUpdatedMap = new ArrayMap<>();
+        Map<String, MobileApplication> appUpdatedMap = new ArrayMap<>();
 
         try {
             List<SearchResult> resultList = results.getNextPage();
@@ -736,9 +661,7 @@ public class AppSearchHelper implements Closeable {
                     SearchResult result = resultList.get(i);
                     appUpdatedMap.put(
                             result.getGenericDocument().getId(),
-                            result.getGenericDocument()
-                                    .getPropertyLong(
-                                            MobileApplication.APP_PROPERTY_UPDATED_TIMESTAMP));
+                            new MobileApplication(result.getGenericDocument()));
                 }
 
                 resultList = results.getNextPage();
@@ -752,81 +675,6 @@ public class AppSearchHelper implements Closeable {
         return appUpdatedMap;
     }
 
-    // TODO(b/357551503): Refactor/combine these two methods with the above to simplify code.
-
-    // TODO(b/367410454): Remove this method once enable_apps_indexer_incremental_put flag is
-    //  rolled out
-    /**
-     * Searches AppSearch and returns a list of app function GenericDocuments.
-     *
-     * @return a list of app function GenericDocuments, containing just the id and package name.
-     */
-    @NonNull
-    @WorkerThread
-    public List<GenericDocument> getAppFunctionsFromAppSearch() throws AppSearchException {
-        List<GenericDocument> appFunctions = new ArrayList<>();
-        SearchSpec allAppsSpec =
-                new SearchSpec.Builder()
-                        .addFilterNamespaces(AppFunctionStaticMetadata.APP_FUNCTION_NAMESPACE)
-                        .addProjection(
-                                SearchSpec.SCHEMA_TYPE_WILDCARD,
-                                Collections.singletonList(
-                                        AppFunctionDocument.PROPERTY_PACKAGE_NAME))
-                        .addFilterPackageNames(mContext.getPackageName())
-                        .setResultCountPerPage(GET_APP_IDS_PAGE_SIZE)
-                        .build();
-        try (SyncSearchResults results =
-                mSyncGlobalSearchSession.search(/* query= */ "", allAppsSpec)) {
-            // TODO(b/357551503): Use pagination instead of building a list of all docs.
-            List<SearchResult> resultList = results.getNextPage();
-            while (!resultList.isEmpty()) {
-                for (int i = 0; i < resultList.size(); i++) {
-                    appFunctions.add(resultList.get(i).getGenericDocument());
-                }
-                resultList = results.getNextPage();
-            }
-        } catch (IOException e) {
-            throw new AppSearchException(RESULT_IO_ERROR, "Failed to close search results", e);
-        } catch (AppSearchException e) {
-            Log.e(TAG, "Error while searching for all app documents", e);
-        }
-        return appFunctions;
-    }
-
-    // TODO(b/367410454): Remove this method once enable_apps_indexer_incremental_put flag is
-    //  rolled out
-    /**
-     * Iterates through result pages and returns a set of package name corresponding to the packages
-     * that have app functions currently indexed into AppSearch.
-     */
-    @NonNull
-    @WorkerThread
-    private Set<String> collectAppFunctionPackagesFromAllPages(@NonNull SyncSearchResults results) {
-        Objects.requireNonNull(results);
-        Set<String> packages = new ArraySet<>();
-
-        try {
-            List<SearchResult> resultList = results.getNextPage();
-
-            while (!resultList.isEmpty()) {
-                for (int i = 0; i < resultList.size(); i++) {
-                    SearchResult result = resultList.get(i);
-                    packages.add(
-                            result.getGenericDocument()
-                                    .getPropertyString(AppFunctionDocument.PROPERTY_PACKAGE_NAME));
-                }
-
-                resultList = results.getNextPage();
-            }
-        } catch (AppSearchException e) {
-            Log.e(TAG, "Error while searching for all app documents", e);
-        }
-        // Return what we have so far. Even if this doesn't fetch all documents, that is fine as we
-        // can continue with indexing. The documents that aren't fetched will be detected as new
-        // apps and re-indexed.
-        return packages;
-    }
-
     /** Closes the AppSearch sessions. */
     @Override
     public void close() {
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerImpl.java b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerImpl.java
index 597a1770..195eaf09 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerImpl.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerImpl.java
@@ -17,16 +17,17 @@
 package com.android.server.appsearch.appsindexer;
 
 import android.annotation.NonNull;
+import android.annotation.Nullable;
 import android.annotation.WorkerThread;
 import android.app.appsearch.AppSearchBatchResult;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.AppSearchSchema;
-import android.app.appsearch.GenericDocument;
 import android.app.appsearch.PackageIdentifier;
 import android.app.appsearch.exceptions.AppSearchException;
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
 import android.os.SystemClock;
 import android.util.ArrayMap;
 import android.util.ArraySet;
@@ -36,7 +37,6 @@ import android.util.Pair;
 import com.android.appsearch.flags.Flags;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionDocument;
-import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
 import com.android.server.appsearch.appsindexer.appsearchtypes.MobileApplication;
 
 import java.io.Closeable;
@@ -88,14 +88,15 @@ public final class AppsIndexerImpl implements Closeable {
             @NonNull AppsUpdateStats appsUpdateStats,
             boolean isFullUpdateRequired)
             throws AppSearchException {
-        // TODO(b/357551503): Add metrics for app function indexing
+        // TODO(b/357551503): Split this method up into helper methods
         Objects.requireNonNull(settings);
         Objects.requireNonNull(appsUpdateStats);
         long currentTimeMillis = System.currentTimeMillis();
 
         // Search AppSearch for MobileApplication objects to get a "current" list of indexed apps.
         long beforeGetTimestamp = SystemClock.elapsedRealtime();
-        Map<String, Long> appUpdatedTimestamps = mAppSearchHelper.getAppsFromAppSearch();
+        Map<String, MobileApplication> previouslyIndexedAppDetails =
+                mAppSearchHelper.getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch();
 
         appsUpdateStats.mAppSearchGetLatencyMillis =
                 SystemClock.elapsedRealtime() - beforeGetTimestamp;
@@ -107,10 +108,6 @@ public final class AppsIndexerImpl implements Closeable {
         appsUpdateStats.mPackageManagerLatencyMillis =
                 SystemClock.elapsedRealtime() - beforePackageManagerTimestamp;
 
-        List<AppFunctionDocument> functionDocumentsToAddOrUpdate = new ArrayList<>();
-        // To remove, we only need the id
-        Set<String> functionIdsToRemove = new ArraySet<>();
-
         long mostRecentAppUpdatedTimestampMillis = settings.getLastAppUpdateTimestampMillis();
 
         // This boolean will be turned on if an app was added, an app was removed, all app
@@ -135,6 +132,8 @@ public final class AppsIndexerImpl implements Closeable {
         // First loop, determine the status of apps
         for (Map.Entry<PackageInfo, ResolveInfos> packageEntry : packagesToIndex.entrySet()) {
             PackageInfo packageInfo = packageEntry.getKey();
+            ResolveInfo appFunctionServiceResolveInfo =
+                    packageEntry.getValue().getAppFunctionServiceInfo();
             packagesToIndexIdSet.add(packageInfo.packageName);
 
             // Update the most recent timestamp as we iterate
@@ -142,14 +141,28 @@ public final class AppsIndexerImpl implements Closeable {
                 mostRecentAppUpdatedTimestampMillis = packageInfo.lastUpdateTime;
             }
 
-            Long storedAppUpdateTime = appUpdatedTimestamps.get(packageInfo.packageName);
+            long storedAppUpdateTime = -1;
+
+            boolean storedIsAppFunctionServiceEnabled = false;
+
+            MobileApplication appDetails = previouslyIndexedAppDetails.get(packageInfo.packageName);
+            if (appDetails != null) {
+                storedAppUpdateTime = appDetails.getUpdatedTimestamp();
+                storedIsAppFunctionServiceEnabled = appDetails.isAppFunctionServiceEnabled();
+            }
 
-            if (storedAppUpdateTime == null) {
+            if (storedAppUpdateTime == -1) {
                 // New app.
                 addedOrRemovedFlag = true;
                 appsUpdateStats.mNumberOfAppsAdded++;
                 packagesToBeAddedOrUpdated.put(packageInfo, packageEntry.getValue());
-            } else if (packageInfo.lastUpdateTime != storedAppUpdateTime || isFullUpdateRequired) {
+            } else if (isPackageUpdatedOrChanged(
+                            packageManager,
+                            packageInfo,
+                            storedAppUpdateTime,
+                            appFunctionServiceResolveInfo,
+                            storedIsAppFunctionServiceEnabled)
+                    || isFullUpdateRequired) {
                 // Package last update timestamp discrepancy between AppSearch and PackageManager
                 // or app indexer code was updated. Add this to the list of updated
                 // apps so we can check what functions are indexed in AppSearch
@@ -163,7 +176,7 @@ public final class AppsIndexerImpl implements Closeable {
         }
 
         // Now check for removed apps
-        for (String appPackageId : appUpdatedTimestamps.keySet()) {
+        for (String appPackageId : previouslyIndexedAppDetails.keySet()) {
             if (!packagesToIndexIdSet.contains(appPackageId)) {
                 // App was removed, remove all it's functions. This is simple because removing the
                 // schema will remove all the functions. Do not add the app to the list of schemas
@@ -198,36 +211,13 @@ public final class AppsIndexerImpl implements Closeable {
         Map<String, Map<String, AppFunctionDocument>> appFunctionsFromAppSearch =
                 mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(updatedPackageIds);
 
-        for (Map.Entry<String, Map<String, ? extends AppFunctionDocument>> packageEntry :
-                currentAppFunctionsForAddedUpdatedPackages.entrySet()) {
-            String packageName = packageEntry.getKey();
-            Map<String, ? extends AppFunctionDocument> currentAppFunctionsPerApp =
-                    packageEntry.getValue();
-
-            // This might be null, in the case of functions newly added to a package
-            Map<String, AppFunctionDocument> appSearchAppFunctionsPerApp =
-                    appFunctionsFromAppSearch.get(packageName);
-
-            if (appSearchAppFunctionsPerApp == null && !currentAppFunctionsPerApp.isEmpty()) {
-                // Functions added to an app that didn't have them
-                functionDocumentsToAddOrUpdate.addAll(currentAppFunctionsPerApp.values());
-                addedOrRemovedFlag = true;
-            }
-
-            if (appSearchAppFunctionsPerApp != null) {
-                if (currentAppFunctionsPerApp.isEmpty()) {
-                    // All functions removed from an app that had them
-                    addedOrRemovedFlag = true;
-                } else {
-                    // App updated that had packages, we should check
-                    comparePackageFunctionDocuments(
-                            currentAppFunctionsPerApp,
-                            appSearchAppFunctionsPerApp,
-                            functionDocumentsToAddOrUpdate,
-                            functionIdsToRemove);
-                }
-            }
-        }
+        AppFunctionDiffCalculator.AppFunctionDiff appFunctionDiff =
+                AppFunctionDiffCalculator.calculate(
+                        appFunctionsFromAppSearch, currentAppFunctionsForAddedUpdatedPackages);
+        addedOrRemovedFlag |= appFunctionDiff.modifySchema;
+        List<AppFunctionDocument> functionDocumentsToAddOrUpdate =
+                new ArrayList<>(appFunctionDiff.addedAppFunctions.values());
+        functionDocumentsToAddOrUpdate.addAll(appFunctionDiff.updatedAppFunctions.values());
 
         try {
             // TODO(b/382254638): Skip set schema calls if no packages have an updated schema.
@@ -291,9 +281,10 @@ public final class AppsIndexerImpl implements Closeable {
                         SystemClock.elapsedRealtime() - beforePutTimestamp;
             }
 
-            if (!functionIdsToRemove.isEmpty()) {
+            if (!appFunctionDiff.functionIdsToRemove.isEmpty()) {
                 AppSearchBatchResult<String, Void> result =
-                        mAppSearchHelper.removeAppFunctionsById(functionIdsToRemove);
+                        mAppSearchHelper.removeAppFunctionsById(
+                                appFunctionDiff.functionIdsToRemove);
                 if (result.isSuccess()) {
                     appsUpdateStats.mUpdateStatusCodes.add(AppSearchResult.RESULT_OK);
                 }
@@ -302,16 +293,118 @@ public final class AppsIndexerImpl implements Closeable {
             settings.setLastAppUpdateTimestampMillis(mostRecentAppUpdatedTimestampMillis);
             settings.setLastUpdateTimestampMillis(currentTimeMillis);
 
+            appsUpdateStats.mNumberOfFunctionsAdded = appFunctionDiff.addedAppFunctions.size();
+            appsUpdateStats.mNumberOfFunctionsUpdated = appFunctionDiff.updatedAppFunctions.size();
+            appsUpdateStats.mApproximateNumberOfFunctionsRemoved =
+                    appFunctionDiff.allDeletedFunctionIds.size();
             appsUpdateStats.mLastAppUpdateTimestampMillis = mostRecentAppUpdatedTimestampMillis;
         } catch (AppSearchException e) {
             // Reset the last update time stamp and app update timestamp so we can try again later.
             settings.reset();
             appsUpdateStats.mUpdateStatusCodes.clear();
             appsUpdateStats.mUpdateStatusCodes.add(e.getResultCode());
+            settings.appendLog(String.format("Error updating apps indexer: %s", e));
             throw e;
+        } finally {
+            Set<String> removedApps = new ArraySet<>(previouslyIndexedAppDetails.keySet());
+            removedApps.removeAll(packagesToIndexIdSet);
+
+            List<String> addedAppPackageNames = new ArrayList<>();
+            List<String> updatedAppPackageNames = new ArrayList<>();
+            for (Map.Entry<PackageInfo, ResolveInfos> entry :
+                    packagesToBeAddedOrUpdated.entrySet()) {
+                if (!previouslyIndexedAppDetails.containsKey(entry.getKey().packageName)) {
+                    addedAppPackageNames.add(entry.getKey().packageName);
+                } else if (entry.getKey().lastUpdateTime
+                        != previouslyIndexedAppDetails
+                                .get(entry.getKey().packageName)
+                                .getUpdatedTimestamp()) {
+                    updatedAppPackageNames.add(entry.getKey().packageName);
+                }
+            }
+
+            final int functionLogLimit = 50;
+            settings.appendLog(
+                    String.format(
+                            "Apps Indexer Update [%d]: Cause - Incremental %s,\n"
+                                    + "APPS\n"
+                                    + "\tAdded - [%s],\n"
+                                    + "\tUpdated - [%s],\n"
+                                    + "\tDeleted - [%s]\n"
+                                    + "FUNCTIONS\n"
+                                    + "\tAdded - [%s],\n"
+                                    + "\tUpdated - [%s],\n"
+                                    + "\tDeleted - [%s]",
+                            currentTimeMillis,
+                            isFullUpdateRequired ? " (Full)" : "",
+                            addedAppPackageNames,
+                            updatedAppPackageNames,
+                            removedApps,
+                            new ArrayList<>(appFunctionDiff.addedAppFunctions.keySet())
+                                    .subList(
+                                            0,
+                                            Math.min(
+                                                    functionLogLimit,
+                                                    appFunctionDiff
+                                                            .addedAppFunctions
+                                                            .keySet()
+                                                            .size())),
+                            new ArrayList<>(appFunctionDiff.updatedAppFunctions.keySet())
+                                    .subList(
+                                            0,
+                                            Math.min(
+                                                    functionLogLimit,
+                                                    appFunctionDiff
+                                                            .updatedAppFunctions
+                                                            .keySet()
+                                                            .size())),
+                            new ArrayList<>(appFunctionDiff.allDeletedFunctionIds)
+                                    .subList(
+                                            0,
+                                            Math.min(
+                                                    functionLogLimit,
+                                                    appFunctionDiff.allDeletedFunctionIds
+                                                            .size()))));
         }
     }
 
+    /**
+     * Returns true if the package update time is not equal to stored app update time or if
+     * AppFunctionService enabled state is not the same as the stored one.
+     *
+     * @param packageManager PackageManager instance.
+     * @param packageInfo Current information of the package with last update time.
+     * @param storedAppUpdateTime The update time stored for the package in appsearch.
+     * @param appFunctionServiceResolveInfo Current resolve info for the AppFunctionService in the
+     *     package.
+     * @param storedIsAppFunctionServiceEnabled Stored enabled state for the AppFunctionService in
+     *     apppsearch.
+     */
+    private static boolean isPackageUpdatedOrChanged(
+            PackageManager packageManager,
+            @NonNull PackageInfo packageInfo,
+            long storedAppUpdateTime,
+            @Nullable ResolveInfo appFunctionServiceResolveInfo,
+            boolean storedIsAppFunctionServiceEnabled) {
+        if (packageInfo.lastUpdateTime != storedAppUpdateTime) {
+            return true;
+        }
+
+        if (!Flags.enableIndexerRunOnAppFunctionComponentChange()) {
+            return false;
+        }
+
+        if (appFunctionServiceResolveInfo == null) {
+            // appFunctionServiceResolveInfo being null means the service is disabled/does not
+            // exist, hence the package status is determined by the stored state.
+            return storedIsAppFunctionServiceEnabled;
+        }
+
+        boolean isAppFunctionServiceEnabled =
+                AppsUtil.isAppFunctionServiceEnabled(packageManager, appFunctionServiceResolveInfo);
+        return isAppFunctionServiceEnabled != storedIsAppFunctionServiceEnabled;
+    }
+
     /**
      * Return a pair of lists of {@link PackageIdentifier}s, the first list representing all
      * packages, and the second list representing packages with app functions.
@@ -359,290 +452,6 @@ public final class AppsIndexerImpl implements Closeable {
         return new Pair<>(packageIdentifiers, packageIdentifiersWithAppFunctions);
     }
 
-    /**
-     * Compares the app function documents in PackageManager vs those in AppSearch, and updates
-     * functionDocumentsToAddOrUpdate and functionDocumentIdsToRemove accordingly.
-     *
-     * @param currentAppFunctionDocumentsPerApp the mapping of function ids to documents
-     *     corresponding to what is in the apps metadata.
-     * @param appSearchAppFunctionDocumentsPerApp the mapping of function ids to documents
-     *     corresponding to what is in AppSearch
-     * @param functionDocumentsToAddOrUpdate the List of {@link AppFunctionDocument} that will be
-     *     sent to a put call to AppSearch
-     * @param functionDocumentIdsToRemove the set of ids that will be sent to a remove call in
-     *     AppSearch
-     */
-    private void comparePackageFunctionDocuments(
-            @NonNull Map<String, ? extends AppFunctionDocument> currentAppFunctionDocumentsPerApp,
-            @NonNull Map<String, AppFunctionDocument> appSearchAppFunctionDocumentsPerApp,
-            @NonNull List<AppFunctionDocument> functionDocumentsToAddOrUpdate,
-            @NonNull Set<String> functionDocumentIdsToRemove) {
-        Objects.requireNonNull(currentAppFunctionDocumentsPerApp);
-        Objects.requireNonNull(appSearchAppFunctionDocumentsPerApp);
-        Objects.requireNonNull(functionDocumentsToAddOrUpdate);
-        Objects.requireNonNull(functionDocumentIdsToRemove);
-
-        for (Map.Entry<String, ? extends AppFunctionDocument> currentFunctionEntry :
-                currentAppFunctionDocumentsPerApp.entrySet()) {
-            String functionId = currentFunctionEntry.getKey();
-            AppFunctionDocument currentFunctionDocument = currentFunctionEntry.getValue();
-            AppFunctionDocument appSearchFunctionDocument =
-                    appSearchAppFunctionDocumentsPerApp.get(functionId);
-            // appSearchFunctionDocument == null means it's a new document, document inequality
-            // means
-            // updated document. Both mean we need to call put with this document.
-            if (appSearchFunctionDocument == null
-                    || !areFunctionDocumentsEqual(
-                            appSearchFunctionDocument, currentFunctionDocument)) {
-                functionDocumentsToAddOrUpdate.add(currentFunctionDocument);
-            }
-        }
-
-        for (Map.Entry<String, AppFunctionDocument> appSearchFunctionEntry :
-                appSearchAppFunctionDocumentsPerApp.entrySet()) {
-            if (!currentAppFunctionDocumentsPerApp.containsKey(appSearchFunctionEntry.getKey())) {
-                functionDocumentIdsToRemove.add(appSearchFunctionEntry.getValue().getId());
-            }
-        }
-    }
-
-    /**
-     * Checks if two AppFunction documents are equal. It isn't enough to call equals. We also need
-     * to ignore creation timestamp and parent types. These are set in AppSearch, but aren't set for
-     * the "about to be indexed" docs
-     *
-     * @return true if the documents are equal, false otherwise.
-     */
-    private boolean areFunctionDocumentsEqual(
-            @NonNull GenericDocument document1, @NonNull GenericDocument document2) {
-        Objects.requireNonNull(document1);
-        Objects.requireNonNull(document2);
-
-        document1 = clearTimestampsAndParentTypesInDocument(document1);
-        document2 = clearTimestampsAndParentTypesInDocument(document2);
-
-        return document1.equals(document2);
-    }
-
-    private GenericDocument clearTimestampsAndParentTypesInDocument(
-            @NonNull GenericDocument document) {
-        GenericDocument.Builder<?> builder =
-                new GenericDocument.Builder<>(document)
-                        .setCreationTimestampMillis(0)
-                        // GenericDocument#PARENT_TYPES_SYNTHETIC_PROPERTY is hidden
-                        .clearProperty("$$__AppSearch__parentTypes");
-
-        for (String propertyName : document.getPropertyNames()) {
-            Object property = document.getProperty(propertyName);
-            if (property instanceof GenericDocument[] nestedDocuments) {
-                GenericDocument[] clearedNestedDocuments =
-                        new GenericDocument[nestedDocuments.length];
-
-                for (int i = 0; i < nestedDocuments.length; i++) {
-                    clearedNestedDocuments[i] =
-                            clearTimestampsAndParentTypesInDocument(nestedDocuments[i]);
-                }
-
-                builder.setPropertyDocument(propertyName, clearedNestedDocuments);
-            }
-        }
-
-        return builder.build();
-    }
-
-    /**
-     * Checks PackageManager and AppSearch to sync the Apps Index in AppSearch.
-     *
-     * <p>It deletes removed apps, inserts newly-added ones, and updates existing ones in the App
-     * corpus in AppSearch.
-     *
-     * @param settings contains update timestamps that help the indexer determine which apps were
-     *     updated.
-     * @param appsUpdateStats contains stats about the apps indexer update. This method will
-     *     populate the fields of this {@link AppsUpdateStats} structure.
-     */
-    @VisibleForTesting
-    @WorkerThread
-    public void doUpdate(
-            @NonNull AppsIndexerSettings settings, @NonNull AppsUpdateStats appsUpdateStats)
-            throws AppSearchException {
-        Objects.requireNonNull(settings);
-        Objects.requireNonNull(appsUpdateStats);
-        long currentTimeMillis = System.currentTimeMillis();
-
-        // Search AppSearch for MobileApplication objects to get a "current" list of indexed apps.
-        long beforeGetTimestamp = SystemClock.elapsedRealtime();
-        Map<String, Long> appUpdatedTimestamps = mAppSearchHelper.getAppsFromAppSearch();
-        appsUpdateStats.mAppSearchGetLatencyMillis =
-                SystemClock.elapsedRealtime() - beforeGetTimestamp;
-
-        long beforePackageManagerTimestamp = SystemClock.elapsedRealtime();
-        PackageManager packageManager = mContext.getPackageManager();
-        Map<PackageInfo, ResolveInfos> packagesToIndex =
-                AppsUtil.getPackagesToIndex(packageManager);
-        appsUpdateStats.mPackageManagerLatencyMillis =
-                SystemClock.elapsedRealtime() - beforePackageManagerTimestamp;
-        Set<PackageInfo> packageInfos = packagesToIndex.keySet();
-
-        Map<PackageInfo, ResolveInfos> packagesToBeAddedOrUpdated = new ArrayMap<>();
-        long mostRecentAppUpdatedTimestampMillis = settings.getLastAppUpdateTimestampMillis();
-
-        // Prepare a set of current app IDs for efficient lookup
-        Set<String> currentAppIds = new ArraySet<>();
-        for (PackageInfo packageInfo : packageInfos) {
-            currentAppIds.add(packageInfo.packageName);
-
-            // Update the most recent timestamp as we iterate
-            if (packageInfo.lastUpdateTime > mostRecentAppUpdatedTimestampMillis) {
-                mostRecentAppUpdatedTimestampMillis = packageInfo.lastUpdateTime;
-            }
-
-            Long storedUpdateTime = appUpdatedTimestamps.get(packageInfo.packageName);
-
-            boolean added = storedUpdateTime == null;
-            boolean updated =
-                    storedUpdateTime != null && packageInfo.lastUpdateTime != storedUpdateTime;
-
-            if (added) {
-                appsUpdateStats.mNumberOfAppsAdded++;
-            }
-            if (updated) {
-                appsUpdateStats.mNumberOfAppsUpdated++;
-            }
-            if (added || updated) {
-                packagesToBeAddedOrUpdated.put(packageInfo, packagesToIndex.get(packageInfo));
-            } else {
-                appsUpdateStats.mNumberOfAppsUnchanged++;
-            }
-        }
-
-        List<GenericDocument> appSearchAppFunctions =
-                mAppSearchHelper.getAppFunctionsFromAppSearch();
-
-        try {
-            if (!currentAppIds.equals(appUpdatedTimestamps.keySet())
-                    || requiresInsertSchemaForAppFunction(packagesToIndex, appSearchAppFunctions)) {
-                // The current list of apps/app functions in AppSearch does not match what is in
-                // PackageManager. This means this is the first sync, an app/app function was
-                // removed, or an app/app function was added. In all cases, we need to call
-                // setSchema to keep AppSearch in sync with PackageManager.
-
-                // currentAppIds comes from PackageManager, appUpdatedTimestamps comes from
-                // AppSearch. Deleted apps are those in appUpdateTimestamps and NOT in currentAppIds
-                appsUpdateStats.mNumberOfAppsRemoved = 0;
-                for (String appSearchApp : appUpdatedTimestamps.keySet()) {
-                    if (!currentAppIds.contains(appSearchApp)) {
-                        appsUpdateStats.mNumberOfAppsRemoved++;
-                    }
-                }
-
-                List<PackageIdentifier> packageIdentifiers = new ArrayList<>();
-                List<PackageIdentifier> packageIdentifiersWithAppFunctions = new ArrayList<>();
-                for (Map.Entry<PackageInfo, ResolveInfos> entry : packagesToIndex.entrySet()) {
-                    // We get certificates here as getting the certificates during the previous for
-                    // loop would be wasteful if we end up not needing to call set schema
-                    PackageInfo packageInfo = entry.getKey();
-                    byte[] certificate = AppsUtil.getCertificate(packageInfo);
-                    if (certificate == null) {
-                        Log.e(TAG, "Certificate not found for package: " + packageInfo.packageName);
-                        continue;
-                    }
-                    PackageIdentifier packageIdentifier =
-                            new PackageIdentifier(packageInfo.packageName, certificate);
-                    packageIdentifiers.add(packageIdentifier);
-                    if (entry.getValue().getAppFunctionServiceInfo() != null) {
-                        packageIdentifiersWithAppFunctions.add(packageIdentifier);
-                    }
-                }
-                // The certificate is necessary along with the package name as it is used in
-                // visibility settings.
-                long beforeSetSchemaTimestamp = SystemClock.elapsedRealtime();
-                mAppSearchHelper.setSchemasForPackages(
-                        packageIdentifiers, packageIdentifiersWithAppFunctions);
-                appsUpdateStats.mAppSearchSetSchemaLatencyMillis =
-                        SystemClock.elapsedRealtime() - beforeSetSchemaTimestamp;
-            }
-
-            if (!packagesToBeAddedOrUpdated.isEmpty()) {
-                long beforePutTimestamp = SystemClock.elapsedRealtime();
-                List<MobileApplication> mobileApplications =
-                        AppsUtil.buildAppsFromPackageInfos(
-                                packageManager, packagesToBeAddedOrUpdated);
-                List<AppFunctionStaticMetadata> appFunctions =
-                        AppsUtil.buildAppFunctionStaticMetadata(
-                                packageManager,
-                                packagesToBeAddedOrUpdated,
-                                /* indexerPackageName= */ mContext.getPackageName(),
-                                mAppsIndexerConfig);
-
-                AppSearchBatchResult<String, Void> result =
-                        mAppSearchHelper.indexApps(
-                                mobileApplications,
-                                appFunctions,
-                                appSearchAppFunctions,
-                                appsUpdateStats);
-                // Here we log all of these functions as "updated". However, some of these may be
-                // added or unchanged.
-                // TODO(b/357551503): Log function counts more accurately
-                appsUpdateStats.mNumberOfFunctionsUpdated = appFunctions.size();
-                if (result.isSuccess()) {
-                    appsUpdateStats.mUpdateStatusCodes.add(AppSearchResult.RESULT_OK);
-                } else {
-                    Collection<AppSearchResult<Void>> values = result.getAll().values();
-
-                    for (AppSearchResult<Void> putResult : values) {
-                        appsUpdateStats.mUpdateStatusCodes.add(putResult.getResultCode());
-                    }
-                }
-                appsUpdateStats.mAppSearchPutLatencyMillis =
-                        SystemClock.elapsedRealtime() - beforePutTimestamp;
-            }
-
-            settings.setLastAppUpdateTimestampMillis(mostRecentAppUpdatedTimestampMillis);
-            settings.setLastUpdateTimestampMillis(currentTimeMillis);
-
-            appsUpdateStats.mLastAppUpdateTimestampMillis = mostRecentAppUpdatedTimestampMillis;
-        } catch (AppSearchException e) {
-            // Reset the last update time stamp and app update timestamp so we can try again later.
-            settings.reset();
-            appsUpdateStats.mUpdateStatusCodes.clear();
-            appsUpdateStats.mUpdateStatusCodes.add(e.getResultCode());
-            throw e;
-        }
-    }
-
-    /** Returns whether the indexer should insert schema for app functions. */
-    private boolean requiresInsertSchemaForAppFunction(
-            @NonNull Map<PackageInfo, ResolveInfos> targetedPackages,
-            List<GenericDocument> appSearchAppFunctions)
-            throws AppSearchException {
-        // Should re-insert the schema as long as the indexed packages does not match the current
-        // set of packages.
-        Set<String> indexedAppFunctionPackages = new ArraySet<>();
-        for (int i = 0; i < appSearchAppFunctions.size(); i++) {
-            indexedAppFunctionPackages.add(
-                    appSearchAppFunctions
-                            .get(i)
-                            .getPropertyString(AppFunctionDocument.PROPERTY_PACKAGE_NAME));
-        }
-        Set<String> currentAppFunctionPackages = getCurrentAppFunctionPackages(targetedPackages);
-        return !indexedAppFunctionPackages.equals(currentAppFunctionPackages);
-    }
-
-    /** Returns a set of currently installed packages that have app functions. */
-    private Set<String> getCurrentAppFunctionPackages(
-            @NonNull Map<PackageInfo, ResolveInfos> targetedPackages) {
-        Set<String> currentAppFunctionPackages = new ArraySet<>();
-        for (Map.Entry<PackageInfo, ResolveInfos> entry : targetedPackages.entrySet()) {
-            PackageInfo packageInfo = entry.getKey();
-            ResolveInfos resolveInfos = entry.getValue();
-            if (resolveInfos.getAppFunctionServiceInfo() != null) {
-                currentAppFunctionPackages.add(packageInfo.packageName);
-            }
-        }
-        return currentAppFunctionPackages;
-    }
-
     /** Shuts down the {@link AppsIndexerImpl} and its {@link AppSearchHelper}. */
     @Override
     public void close() {
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerManagerService.java b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerManagerService.java
index 9377dc99..f5859c16 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerManagerService.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerManagerService.java
@@ -29,12 +29,15 @@ import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
 import android.os.CancellationSignal;
 import android.os.UserHandle;
 import android.util.ArrayMap;
 import android.util.Log;
 import android.util.Slog;
 
+import com.android.appsearch.flags.Flags;
 import com.android.internal.annotations.GuardedBy;
 import com.android.server.LocalManagerRegistry;
 import com.android.server.SystemService;
@@ -42,6 +45,7 @@ import com.android.server.appsearch.indexer.IndexerLocalService;
 
 import java.io.File;
 import java.io.PrintWriter;
+import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 
@@ -141,13 +145,14 @@ public final class AppsIndexerManagerService extends SystemService {
         try {
             Objects.requireNonNull(userHandle);
             Objects.requireNonNull(pw);
+            AppsIndexerUserInstance instance;
             synchronized (mAppsIndexersLocked) {
-                AppsIndexerUserInstance instance = mAppsIndexersLocked.get(userHandle);
-                if (instance != null) {
-                    instance.dump(pw);
-                } else {
-                    pw.println("AppsIndexerUserInstance is not created for " + userHandle);
-                }
+                instance = mAppsIndexersLocked.get(userHandle);
+            }
+            if (instance != null) {
+                instance.dump(pw);
+            } else {
+                pw.println("AppsIndexerUserInstance is not created for " + userHandle);
             }
         } catch (RuntimeException e) {
             Slog.wtf(TAG, "AppsIndexerManagerService.dumpAppsIndexerForUser() failed ", e);
@@ -186,10 +191,10 @@ public final class AppsIndexerManagerService extends SystemService {
     private class AppsProviderChangedReceiver extends BroadcastReceiver {
 
         /**
-         * Checks if the entire package was changed, or if the intent just represents a component
-         * change.
+         * Return true if the entire package was changed, or if the AppFunction Component was
+         * changed, false otherwise.
          */
-        private boolean isEntirePackageChanged(@NonNull Intent intent) {
+        private boolean shouldRunIndexerOnPackageChange(@NonNull Intent intent) {
             Objects.requireNonNull(intent);
             String[] changedComponents =
                     intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST);
@@ -209,6 +214,29 @@ public final class AppsIndexerManagerService extends SystemService {
                 if (changedComponent.equals(changedPackage)) {
                     return true;
                 }
+
+                // If the state of AppFunctionService component is changed within the package,
+                // indexer should be rerun. AppFunctionService component is identified by checking
+                // if it matches the app function intent filter.
+                if (Flags.enableIndexerRunOnAppFunctionComponentChange()) {
+                    Intent appFunctionServiceIntent =
+                            new Intent("android.app.appfunctions.AppFunctionService")
+                                    .setPackage(changedPackage);
+                    // Include disabled components in the query because if this broadcast is
+                    // disabling AppFunctionService, the component may already be disabled and would
+                    // otherwise be skipped
+                    List<ResolveInfo> services =
+                            mContext.getPackageManager()
+                                    .queryIntentServices(
+                                            appFunctionServiceIntent,
+                                            /* flags= */ PackageManager.MATCH_DISABLED_COMPONENTS);
+
+                    for (int j = 0; j < services.size(); j++) {
+                        if (changedComponent.equals(services.get(j).serviceInfo.name)) {
+                            return true;
+                        }
+                    }
+                }
             }
             return false;
         }
@@ -222,7 +250,7 @@ public final class AppsIndexerManagerService extends SystemService {
 
                 switch (intent.getAction()) {
                     case Intent.ACTION_PACKAGE_CHANGED:
-                        if (!isEntirePackageChanged(intent)) {
+                        if (!shouldRunIndexerOnPackageChange(intent)) {
                             // If it was just a component change, do not run the indexer
                             return;
                         }
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerSettings.java b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerSettings.java
index a361c6a2..5d10feed 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerSettings.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerSettings.java
@@ -19,10 +19,18 @@ package com.android.server.appsearch.appsindexer;
 import static com.android.server.appsearch.appsindexer.AppIndexerVersions.APP_INDEXER_VERSION_UNKNOWN;
 
 import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.os.Build;
 
 import com.android.server.appsearch.indexer.IndexerSettings;
 
 import java.io.File;
+import java.io.IOException;
+import java.util.ArrayDeque;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Deque;
+import java.util.List;
 
 /**
  * Apps indexer settings backed by a PersistableBundle.
@@ -40,8 +48,24 @@ public class AppsIndexerSettings extends IndexerSettings {
 
     static final String PREVIOUS_APP_INDEXER_VERSION_CODE = "previous_app_indexer_version_code";
 
+    private static final String LAST_PARTITIONS_FINGERPRINT_SORTED_BY_PARTITION_NAME =
+            "last_partitions_fingerprint_sorted_by_partition_name";
+
+    private static final String LOG_LINES_KEY = "log_lines";
+    private static final int MAX_LOG_LINES = 15;
+    private static final int MAX_LOG_LENGTH = 10_000;
+
+    private final Deque<String> mLogLines;
+
     public AppsIndexerSettings(@NonNull File baseDir) {
         super(baseDir);
+        mLogLines = new ArrayDeque<>(MAX_LOG_LINES);
+        String[] storedLogLines = mBundle.getStringArray(LOG_LINES_KEY);
+        if (storedLogLines != null) {
+            for (String line : storedLogLines) {
+                mLogLines.offerLast(line);
+            }
+        }
     }
 
     @Override
@@ -71,11 +95,62 @@ public class AppsIndexerSettings extends IndexerSettings {
         mBundle.putInt(PREVIOUS_APP_INDEXER_VERSION_CODE, versionCode);
     }
 
+    /**
+     * Returns the stored fingerprint strings for partitions sorted by {@link
+     * Build.Partition#getName()} returned by {@link Build#getFingerprintedPartitions()} from the
+     * last indexer run.
+     */
+    @Nullable
+    public String[] getLastPartitionFingerprintsSortedByPartitionName() {
+        return mBundle.getStringArray(LAST_PARTITIONS_FINGERPRINT_SORTED_BY_PARTITION_NAME);
+    }
+
+    /**
+     * Stores the fingerprints of all partitions as a string array sorted by {@link
+     * Build.Partition#getName()}.
+     */
+    public void setLastPartitionFingerprintsSortedByPartitionName(
+            @NonNull List<Build.Partition> fingerprintedPartitions) {
+        String[] fingerprints = new String[fingerprintedPartitions.size()];
+        for (int i = 0; i < fingerprintedPartitions.size(); ++i) {
+            fingerprints[i] = fingerprintedPartitions.get(i).getFingerprint();
+        }
+        mBundle.putStringArray(LAST_PARTITIONS_FINGERPRINT_SORTED_BY_PARTITION_NAME, fingerprints);
+    }
+
+    /** Appends a log message to the settings log. */
+    public void appendLog(@NonNull String log) {
+        if (log.length() > MAX_LOG_LENGTH) {
+            log = log.substring(0, MAX_LOG_LENGTH);
+        }
+        // There are no locks protecting access to this field since it is only accessed through a
+        // single-threaded executor. Even if there is a race condition, it is acceptable as this is
+        // for debugging purposes.
+        mLogLines.offerLast(log);
+        if (mLogLines.size() > MAX_LOG_LINES) {
+            mLogLines.pollFirst();
+        }
+    }
+
+    /** Returns the current log messages. */
+    @NonNull
+    public Collection<String> getLogLines() {
+        return Collections.unmodifiableCollection(mLogLines);
+    }
+
     /** Resets all settings to default values except {@link #getPreviousIndexerVersionCode()}. */
     @Override
     public void reset() {
         super.reset();
         setLastAppUpdateTimestampMillis(0);
         setPreviousIndexerVersionCode(APP_INDEXER_VERSION_UNKNOWN);
+        mLogLines.clear();
+        mBundle.remove(LOG_LINES_KEY);
+    }
+
+    @Override
+    public void persist() throws IOException {
+        mBundle.putStringArray(LOG_LINES_KEY, mLogLines.toArray(new String[0]));
+        super.persist();
     }
 }
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerUserInstance.java b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerUserInstance.java
index 4416b1ec..6f6d87ac 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerUserInstance.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerUserInstance.java
@@ -24,12 +24,14 @@ import android.annotation.WorkerThread;
 import android.app.appsearch.AppSearchEnvironmentFactory;
 import android.app.appsearch.exceptions.AppSearchException;
 import android.content.Context;
+import android.os.Build;
 import android.os.SystemClock;
 import android.util.Log;
 import android.util.Slog;
 
 import com.android.appsearch.flags.Flags;
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.server.appsearch.appsindexer.appsearchtypes.MobileApplication;
 import com.android.server.appsearch.indexer.IndexerMaintenanceService;
 import com.android.server.appsearch.stats.AppSearchStatsLog;
 
@@ -37,6 +39,16 @@ import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.PrintWriter;
+import java.time.Instant;
+import java.time.LocalDateTime;
+import java.time.ZoneId;
+import java.time.format.DateTimeFormatter;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
 import java.util.Objects;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Semaphore;
@@ -159,13 +171,63 @@ public final class AppsIndexerUserInstance {
 
     /** Dumps the internal state of this {@link AppsIndexerUserInstance}. */
     public void dump(@NonNull PrintWriter pw) {
-        // Those timestamps are not protected by any lock since in AppsIndexerUserInstance
-        // we only have one thread to handle all the updates. It is possible we might run into
-        // race condition if there is an update running while those numbers are being printed.
+        executeOnSingleThreadedExecutor(() -> dumpInternal(pw));
+    }
+
+    /**
+     * Dumps the internal state of this {@link AppsIndexerUserInstance}. This will be ran on the
+     * single threaed executor.
+     */
+    private void dumpInternal(@NonNull PrintWriter pw) {
+        // Those timestamps are not protected by any lock since in
+        // AppsIndexerUserInstance
+        // we only have one thread to handle all the updates. It is possible we might
+        // run into
+        // race condition if there is an update running while those numbers are being
+        // printed.
         // This is acceptable though for debug purpose, so still no lock here.
-        pw.println("last_update_timestamp_millis: " + mSettings.getLastUpdateTimestampMillis());
         pw.println(
-                "last_app_update_timestamp_millis: " + mSettings.getLastAppUpdateTimestampMillis());
+                "last_update_timestamp_millis: "
+                        + formatTimestamp(mSettings.getLastUpdateTimestampMillis()));
+        pw.println(
+                "last_app_update_timestamp_millis: "
+                        + formatTimestamp(mSettings.getLastAppUpdateTimestampMillis()));
+        pw.println(
+                "last_partitions_fingerprint_sorted_by_partition_name"
+                        + Arrays.toString(
+                                mSettings.getLastPartitionFingerprintsSortedByPartitionName()));
+        try (AppSearchHelper appSearchHelper = new AppSearchHelper(mContext)) {
+            Map<String, MobileApplication> appsMap =
+                    appSearchHelper
+                            .getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch();
+            pw.println("Indexed Apps:");
+            for (Map.Entry<String, MobileApplication> appLastUpdatedEntry : appsMap.entrySet()) {
+                pw.println(
+                        "    packageName: "
+                                + appLastUpdatedEntry.getKey()
+                                + " lastUpdatedTimestamp: "
+                                + formatTimestamp(
+                                        appLastUpdatedEntry.getValue().getUpdatedTimestamp()));
+            }
+        } catch (AppSearchException e) {
+            pw.println("Error in dumping indexed applications");
+        }
+        pw.println("Apps Indexer Logs:");
+        Collection<String> logs = mSettings.getLogLines();
+        if (logs.isEmpty()) {
+            pw.println("  No logs available.");
+        } else {
+            for (String log : logs) {
+                pw.println("  " + log);
+            }
+        }
+    }
+
+    private static String formatTimestamp(long timestampInMillis) {
+        LocalDateTime dateTime =
+                LocalDateTime.ofInstant(
+                        Instant.ofEpochMilli(timestampInMillis), ZoneId.systemDefault());
+        return dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
     }
 
     /**
@@ -226,6 +288,15 @@ public final class AppsIndexerUserInstance {
             boolean isAppIndexerUpdated =
                     Flags.enableAllPackageIndexingOnIndexerUpdate()
                             && checkAndUpdateIndexerVersion();
+
+            List<Build.Partition> currentFingerprintedPartitions =
+                    Build.getFingerprintedPartitions();
+            List<Build.Partition> sortedFingerprintedPartitions =
+                    new ArrayList<>(currentFingerprintedPartitions);
+            sortedFingerprintedPartitions.sort(Comparator.comparing(Build.Partition::getName));
+
+            boolean isOtaUpdate = checkForOtaUpdate(sortedFingerprintedPartitions);
+
             if (firstRun) {
                 if (Flags.enableAppsIndexerCheckPriorAttempt()) {
                     // Special "firstRun" case.
@@ -246,21 +317,24 @@ public final class AppsIndexerUserInstance {
                     mSettings.persist();
                 }
 
-                // Check if there was a previous successful run and AppSearch wasn't updated since.
-                if (mSettings.getLastUpdateTimestampMillis() != 0 && !isAppIndexerUpdated) {
+                // Check if there was a previous successful run and AppSearch or system image wasn't
+                // updated since.
+                if (mSettings.getLastUpdateTimestampMillis() != 0
+                        && !isAppIndexerUpdated
+                        && !isOtaUpdate) {
                     return;
                 }
             }
-            if (Flags.enableAppsIndexerIncrementalPut()) {
-                mAppsIndexerImpl.doUpdateIncrementalPut(
-                        mSettings,
-                        appsUpdateStats,
-                        /* isFullUpdateRequired= */ isAppIndexerUpdated);
-            } else {
-                // TODO(b/367410454): Remove this method and related code paths once
-                //  enable_apps_indexer_incremental_put flag is rolled out.
-                mAppsIndexerImpl.doUpdate(mSettings, appsUpdateStats);
+
+            mAppsIndexerImpl.doUpdateIncrementalPut(
+                    mSettings,
+                    appsUpdateStats,
+                    /* isFullUpdateRequired= */ isAppIndexerUpdated || isOtaUpdate);
+            if (isOtaUpdate) {
+                mSettings.setLastPartitionFingerprintsSortedByPartitionName(
+                        sortedFingerprintedPartitions);
             }
+
             mSettings.persist();
         } catch (IOException e) {
             Log.w(TAG, "Failed to save settings to disk", e);
@@ -274,6 +348,37 @@ public final class AppsIndexerUserInstance {
         }
     }
 
+    /**
+     * Checks if an OTA update has occurred by comparing the current partition fingerprints against
+     * the last known fingerprints stored in settings.
+     *
+     * @param fingerprintedPartitions the current list of fingerprinted partitions, sorted by {@link
+     *     Build.Partition#getName()}
+     * @return true if an OTA update is detected (i.e., at least one fingerprint has changed), false
+     *     otherwise
+     */
+    private boolean checkForOtaUpdate(List<Build.Partition> fingerprintedPartitions) {
+        String[] oldFingerprintedPartitions =
+                mSettings.getLastPartitionFingerprintsSortedByPartitionName();
+
+        if (oldFingerprintedPartitions == null
+                || fingerprintedPartitions.size() != oldFingerprintedPartitions.length) {
+            // Either first time check or the number of partitions has changed => OTA likely
+            // occurred
+            return true;
+        }
+
+        for (int i = 0; i < fingerprintedPartitions.size(); ++i) {
+            if (!Objects.equals(
+                    fingerprintedPartitions.get(i).getFingerprint(),
+                    oldFingerprintedPartitions[i])) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
     /**
      * Checks if the current App Indexer versionCode differs from the previously stored versionCode
      * in {@link AppsIndexerSettings} and updates the stored versionCode if necessary.
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppsUtil.java b/service/java/com/android/server/appsearch/appsindexer/AppsUtil.java
index bfc42b3b..a2584c5a 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppsUtil.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppsUtil.java
@@ -32,18 +32,25 @@ import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
 import android.content.pm.Signature;
+import android.content.res.AssetManager;
 import android.content.res.Resources;
 import android.net.Uri;
 import android.text.TextUtils;
 import android.util.ArrayMap;
 import android.util.Log;
 
-import com.android.internal.annotations.VisibleForTesting;
+import com.android.appsearch.flags.Flags;
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionDocument;
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppOpenEvent;
 import com.android.server.appsearch.appsindexer.appsearchtypes.MobileApplication;
 
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+import org.xmlpull.v1.XmlPullParserFactory;
+
+import java.io.IOException;
+import java.io.InputStreamReader;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.util.ArrayList;
@@ -161,7 +168,7 @@ public final class AppsUtil {
         Intent appFunctionServiceIntent = new Intent("android.app.appfunctions.AppFunctionService");
         Map<String, ResolveInfo> packageNameToAppFunctionServiceInfo = new ArrayMap<>();
         List<ResolveInfo> services =
-                packageManager.queryIntentServices(appFunctionServiceIntent, 0);
+                packageManager.queryIntentServices(appFunctionServiceIntent, /* flags= */ 0);
         for (int i = 0; i < services.size(); i++) {
             ResolveInfo resolveInfo = services.get(i);
             packageNameToAppFunctionServiceInfo.put(
@@ -209,10 +216,8 @@ public final class AppsUtil {
 
         List<MobileApplication> mobileApplications = new ArrayList<>();
         for (Map.Entry<PackageInfo, ResolveInfos> entry : packageInfos.entrySet()) {
-            ResolveInfo resolveInfo = entry.getValue().getLaunchActivityResolveInfo();
-
             MobileApplication mobileApplication =
-                    createMobileApplication(packageManager, entry.getKey(), resolveInfo);
+                    createMobileApplication(packageManager, entry.getKey(), entry.getValue());
             if (mobileApplication != null) {
                 mobileApplications.add(mobileApplication);
             }
@@ -220,73 +225,6 @@ public final class AppsUtil {
         return mobileApplications;
     }
 
-    // TODO(b/367410454): Remove this method once enable_apps_indexer_incremental_put flag is
-    //  rolled out
-    /**
-     * Uses {@link PackageManager} and a Map of {@link PackageInfo}s to {@link ResolveInfos}s to
-     * build AppSearch {@link AppFunctionStaticMetadata} documents. Info from both are required to
-     * build app documents.
-     *
-     * @param packageInfos a mapping of {@link PackageInfo}s and their corresponding {@link
-     *     ResolveInfo} for the packages launch activity.
-     * @param indexerPackageName the name of the package performing the indexing. This should be the
-     *     same as the package running the apps indexer so that qualified ids are correctly created.
-     * @param config the app indexer config used to enforce various limits during parsing.
-     */
-    public static List<AppFunctionStaticMetadata> buildAppFunctionStaticMetadata(
-            @NonNull PackageManager packageManager,
-            @NonNull Map<PackageInfo, ResolveInfos> packageInfos,
-            @NonNull String indexerPackageName,
-            AppsIndexerConfig config) {
-        AppFunctionDocumentParser parser =
-                new AppFunctionDocumentParserImpl(indexerPackageName, config);
-        return buildAppFunctionStaticMetadata(packageManager, packageInfos, parser);
-    }
-
-    // TODO(b/367410454): Remove this method once enable_apps_indexer_incremental_put flag is
-    //  rolled out
-    /**
-     * Similar to the above {@link #buildAppFunctionStaticMetadata}, but allows the caller to
-     * provide a custom parser. This is for testing purposes.
-     */
-    @VisibleForTesting
-    static List<AppFunctionStaticMetadata> buildAppFunctionStaticMetadata(
-            @NonNull PackageManager packageManager,
-            @NonNull Map<PackageInfo, ResolveInfos> packageInfos,
-            @NonNull AppFunctionDocumentParser parser) {
-        Objects.requireNonNull(packageManager);
-        Objects.requireNonNull(packageInfos);
-        Objects.requireNonNull(parser);
-
-        List<AppFunctionStaticMetadata> appFunctions = new ArrayList<>();
-        for (Map.Entry<PackageInfo, ResolveInfos> entry : packageInfos.entrySet()) {
-            PackageInfo packageInfo = entry.getKey();
-            ResolveInfo resolveInfo = entry.getValue().getAppFunctionServiceInfo();
-            if (resolveInfo == null) {
-                continue;
-            }
-
-            String assetFilePath;
-            try {
-                PackageManager.Property property =
-                        packageManager.getProperty(
-                                "android.app.appfunctions",
-                                new ComponentName(
-                                        resolveInfo.serviceInfo.packageName,
-                                        resolveInfo.serviceInfo.name));
-                assetFilePath = property.getString();
-            } catch (PackageManager.NameNotFoundException e) {
-                Log.w(TAG, "buildAppFunctionMetadataFromPackageInfo: Failed to get property", e);
-                continue;
-            }
-            if (assetFilePath != null) {
-                appFunctions.addAll(
-                        parser.parse(packageManager, packageInfo.packageName, assetFilePath));
-            }
-        }
-        return appFunctions;
-    }
-
     /**
      * Uses {@link PackageManager} and a Map of {@link PackageInfo}s to {@link ResolveInfos}s to
      * build AppSearch {@link GenericDocument} objects. Info from both are required to build app
@@ -331,12 +269,12 @@ public final class AppsUtil {
      *
      * @see #buildAppFunctionDocumentsIntoMap(PackageManager, Map, String, AppsIndexerConfig, Map)
      */
-    @VisibleForTesting
-    static Map<String, Map<String, ? extends AppFunctionDocument>> buildAppFunctionDocumentsIntoMap(
-            @NonNull PackageManager packageManager,
-            @NonNull Map<PackageInfo, ResolveInfos> packageInfos,
-            @NonNull AppFunctionDocumentParser parser,
-            @Nullable Map<String, Map<String, AppSearchSchema>> schemasPerPackage) {
+    private static Map<String, Map<String, ? extends AppFunctionDocument>>
+            buildAppFunctionDocumentsIntoMap(
+                    @NonNull PackageManager packageManager,
+                    @NonNull Map<PackageInfo, ResolveInfos> packageInfos,
+                    @NonNull AppFunctionDocumentParser parser,
+                    @Nullable Map<String, Map<String, AppSearchSchema>> schemasPerPackage) {
         Objects.requireNonNull(packageManager);
         Objects.requireNonNull(packageInfos);
         Objects.requireNonNull(parser);
@@ -344,57 +282,74 @@ public final class AppsUtil {
         for (Map.Entry<PackageInfo, ResolveInfos> entry : packageInfos.entrySet()) {
             PackageInfo packageInfo = entry.getKey();
             ResolveInfo resolveInfo = entry.getValue().getAppFunctionServiceInfo();
-            if (resolveInfo == null) {
-                continue;
-            }
-
-            String assetFilePath;
+            if (resolveInfo == null) continue;
             boolean isDynamicSchemaDefined =
                     schemasPerPackage != null
                             && !schemasPerPackage
                                     .getOrDefault(packageInfo.packageName, Collections.emptyMap())
                                     .isEmpty();
-
-            // Currently SDK will generate two files for hardcoded and dynamic schemas respectively
-            // so that devices running older AppSearch versions that are incompatible with new
-            // format can continue to parse app function documents while newer versions can use v2
-            // file for constructing app function documents with dynamic schema and more properties.
-            // TODO(b/386676297) - Merge these two when enough devices have changes to support
-            // dynamic schema.
-            String appFunctionXmlPropertyName =
+            // Choose appropriate property name based on schema type
+            String xmlPropertyName =
                     isDynamicSchemaDefined
                             ? "android.app.appfunctions.v2"
                             : "android.app.appfunctions";
+            PackageManager.Property xmlProperty;
             try {
-                PackageManager.Property property =
+                xmlProperty =
                         packageManager.getProperty(
-                                appFunctionXmlPropertyName,
+                                xmlPropertyName,
                                 new ComponentName(
                                         resolveInfo.serviceInfo.packageName,
                                         resolveInfo.serviceInfo.name));
-                assetFilePath = property.getString();
             } catch (PackageManager.NameNotFoundException e) {
-                Log.w(TAG, "buildAppFunctionMetadataFromPackageInfo: Failed to get property", e);
+                Log.w(TAG, "Failed to get property for: " + packageInfo.packageName, e);
                 continue;
             }
 
-            if (assetFilePath != null) {
-                if (isDynamicSchemaDefined) {
-                    appFunctions.put(
-                            packageInfo.packageName,
-                            parser.parseIntoMapForGivenSchemas(
-                                    packageManager,
-                                    packageInfo.packageName,
-                                    assetFilePath,
-                                    schemasPerPackage.get(packageInfo.packageName)));
+            if (!isDynamicSchemaDefined && xmlProperty.isString()) {
+                Map<String, ? extends AppFunctionDocument> parsedMap =
+                        parser.parseIntoMap(
+                                packageManager,
+                                packageInfo.packageName,
+                                Objects.requireNonNull(xmlProperty.getString()));
+                appFunctions.put(packageInfo.packageName, parsedMap);
+                continue;
+            }
+
+            // Parse with dynamic schema
+            try {
+                Resources resources =
+                        packageManager.getResourcesForApplication(packageInfo.packageName);
+                XmlPullParser xmlPullParser;
+
+                if (xmlProperty.isResourceId()) {
+                    xmlPullParser = resources.getXml(xmlProperty.getResourceId());
+                } else if (xmlProperty.isString()) {
+                    AssetManager assetManager = resources.getAssets();
+                    xmlPullParser = XmlPullParserFactory.newInstance().newPullParser();
+                    xmlPullParser.setInput(
+                            new InputStreamReader(
+                                    assetManager.open(
+                                            Objects.requireNonNull(xmlProperty.getString()))));
                 } else {
-                    appFunctions.put(
-                            packageInfo.packageName,
-                            parser.parseIntoMap(
-                                    packageManager, packageInfo.packageName, assetFilePath));
+                    continue;
                 }
+
+                Map<String, ? extends AppFunctionDocument> parsedMap =
+                        parser.parseIntoMapForGivenSchemas(
+                                packageManager,
+                                packageInfo.packageName,
+                                xmlPullParser,
+                                schemasPerPackage.get(packageInfo.packageName));
+                appFunctions.put(packageInfo.packageName, parsedMap);
+
+            } catch (PackageManager.NameNotFoundException
+                    | XmlPullParserException
+                    | IOException e) {
+                Log.w(TAG, "Failed to parse dynamic XML for: " + packageInfo.packageName, e);
             }
         }
+
         return appFunctions;
     }
 
@@ -465,9 +420,10 @@ public final class AppsUtil {
     private static MobileApplication createMobileApplication(
             @NonNull PackageManager packageManager,
             @NonNull PackageInfo packageInfo,
-            @Nullable ResolveInfo resolveInfo) {
+            @NonNull ResolveInfos resolveInfos) {
         Objects.requireNonNull(packageManager);
         Objects.requireNonNull(packageInfo);
+        Objects.requireNonNull(resolveInfos);
 
         byte[] certificate = getCertificate(packageInfo);
         if (certificate == null) {
@@ -480,15 +436,25 @@ public final class AppsUtil {
                         .setCreationTimestampMillis(packageInfo.firstInstallTime)
                         .setUpdatedTimestampMs(packageInfo.lastUpdateTime);
 
-        if (resolveInfo == null) {
+        ResolveInfo appFunctionServiceResolveInfo = resolveInfos.getAppFunctionServiceInfo();
+        if (Flags.enableIndexerRunOnAppFunctionComponentChange()
+                && appFunctionServiceResolveInfo != null) {
+            builder.setIsAppFunctionServiceEnabled(
+                    isAppFunctionServiceEnabled(packageManager, appFunctionServiceResolveInfo));
+        }
+
+        ResolveInfo launchActivityResolveInfo = resolveInfos.getLaunchActivityResolveInfo();
+        if (launchActivityResolveInfo == null) {
             return builder.build();
         }
-        String applicationDisplayName = resolveInfo.loadLabel(packageManager).toString();
+        String applicationDisplayName =
+                launchActivityResolveInfo.loadLabel(packageManager).toString();
         if (TextUtils.isEmpty(applicationDisplayName)) {
             applicationDisplayName = packageInfo.applicationInfo.className;
         }
         builder.setDisplayName(applicationDisplayName);
-        String iconUri = getActivityIconUriString(packageManager, resolveInfo.activityInfo);
+        String iconUri =
+                getActivityIconUriString(packageManager, launchActivityResolveInfo.activityInfo);
         if (iconUri != null) {
             builder.setIconUri(iconUri);
         }
@@ -498,12 +464,33 @@ public final class AppsUtil {
             // This can be different from applicationDisplayName, and should be indexed
             builder.setAlternateNames(applicationLabel);
         }
-        if (resolveInfo.activityInfo.name != null) {
-            builder.setClassName(resolveInfo.activityInfo.name);
+        if (launchActivityResolveInfo.activityInfo.name != null) {
+            builder.setClassName(launchActivityResolveInfo.activityInfo.name);
         }
         return builder.build();
     }
 
+    /**
+     * Returns the current enabled state of AppFunctionService component specified by
+     * appFunctionServiceResolveInfo.
+     */
+    public static boolean isAppFunctionServiceEnabled(
+            @NonNull PackageManager packageManager,
+            @NonNull ResolveInfo appFunctionServiceResolveInfo) {
+        int currentAppFunctionServiceState =
+                packageManager.getComponentEnabledSetting(
+                        new ComponentName(
+                                appFunctionServiceResolveInfo.serviceInfo.packageName,
+                                appFunctionServiceResolveInfo.serviceInfo.name));
+
+        boolean isAppFunctionServiceEnabled =
+                currentAppFunctionServiceState == PackageManager.COMPONENT_ENABLED_STATE_DEFAULT
+                        ? appFunctionServiceResolveInfo.serviceInfo.isEnabled()
+                        : currentAppFunctionServiceState
+                                == PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
+        return isAppFunctionServiceEnabled;
+    }
+
     /**
      * Creates dynamic app function schemas defined by the app per package.
      *
diff --git a/service/java/com/android/server/appsearch/appsindexer/FrameworkAppOpenEventIndexerConfig.java b/service/java/com/android/server/appsearch/appsindexer/FrameworkAppOpenEventIndexerConfig.java
index ddf5dc04..fa6d24e2 100644
--- a/service/java/com/android/server/appsearch/appsindexer/FrameworkAppOpenEventIndexerConfig.java
+++ b/service/java/com/android/server/appsearch/appsindexer/FrameworkAppOpenEventIndexerConfig.java
@@ -33,6 +33,10 @@ public class FrameworkAppOpenEventIndexerConfig implements AppOpenEventIndexerCo
             "app_open_event_update_interval_millis";
     static final String KEY_APP_OPEN_EVENT_MIN_TIME_BETWEEN_SYNCS_MILLIS =
             "min_time_between_syncs_millis";
+    static final String KEY_APP_OPEN_EVENT_INDEXER_STATS_LOGGING_ENABLED =
+            "app_open_event_indexer_stats_logging_enabled";
+    static final String KEY_APP_OPEN_EVENT_INDEXER_STATS_LOGGING_SAMPLING_RATE =
+            "app_open_event_indexer_stats_logging_sampling_rate";
 
     @Override
     public boolean isAppOpenEventIndexerEnabled() {
@@ -57,4 +61,20 @@ public class FrameworkAppOpenEventIndexerConfig implements AppOpenEventIndexerCo
                 KEY_APP_OPEN_EVENT_MIN_TIME_BETWEEN_SYNCS_MILLIS,
                 DEFAULT_APP_OPEN_EVENT_MIN_TIME_BETWEEN_SYNCS_MILLIS);
     }
+
+    @Override
+    public boolean isLoggingEnabled() {
+        return DeviceConfig.getBoolean(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_APP_OPEN_EVENT_INDEXER_STATS_LOGGING_ENABLED,
+                DEFAULT_APP_OPEN_EVENT_INDEXER_STATS_LOGGING_ENABLED);
+    }
+
+    @Override
+    public int getLoggingSamplingRate() {
+        return DeviceConfig.getInt(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_APP_OPEN_EVENT_INDEXER_STATS_LOGGING_SAMPLING_RATE,
+                DEFAULT_APP_OPEN_EVENT_INDEXER_STATS_LOGGING_SAMPLING_RATE);
+    }
 }
diff --git a/service/java/com/android/server/appsearch/appsindexer/appsearchtypes/MobileApplication.java b/service/java/com/android/server/appsearch/appsindexer/appsearchtypes/MobileApplication.java
index 3e1d3128..1319e36f 100644
--- a/service/java/com/android/server/appsearch/appsindexer/appsearchtypes/MobileApplication.java
+++ b/service/java/com/android/server/appsearch/appsindexer/appsearchtypes/MobileApplication.java
@@ -47,6 +47,9 @@ public class MobileApplication extends GenericDocument {
     public static final String APP_PROPERTY_UPDATED_TIMESTAMP = "updatedTimestamp";
     public static final String APP_PROPERTY_CLASS_NAME = "className";
 
+    public static final String APP_PROPERTY_IS_APP_FUNCTION_SERVICE_ENABLED =
+            "isAppFunctionServiceEnabled";
+
     /** Returns a per-app schema name. */
     @VisibleForTesting
     public static String getSchemaNameForPackage(@NonNull String pkg) {
@@ -118,11 +121,15 @@ public class MobileApplication extends GenericDocument {
                         new AppSearchSchema.StringPropertyConfig.Builder(APP_PROPERTY_CLASS_NAME)
                                 .setCardinality(AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL)
                                 .build())
+                .addProperty(
+                        new AppSearchSchema.BooleanPropertyConfig.Builder(
+                                        APP_PROPERTY_IS_APP_FUNCTION_SERVICE_ENABLED)
+                                .setCardinality(AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL)
+                                .build())
                 .build();
     }
 
     /** Constructs a {@link MobileApplication}. */
-    @VisibleForTesting
     public MobileApplication(@NonNull GenericDocument document) {
         super(document);
     }
@@ -201,6 +208,16 @@ public class MobileApplication extends GenericDocument {
         return getPropertyString(APP_PROPERTY_CLASS_NAME);
     }
 
+    /**
+     * Returns whether AppFunctionService was effectively enabled when the app was last indexed.
+     *
+     * <p>For a service to be enabled it needs to be defined in the Manifest and not marked {@code
+     * android:enabled="false"}
+     */
+    public boolean isAppFunctionServiceEnabled() {
+        return getPropertyBoolean(APP_PROPERTY_IS_APP_FUNCTION_SERVICE_ENABLED);
+    }
+
     public static final class Builder extends GenericDocument.Builder<Builder> {
         public Builder(@NonNull String packageName, @NonNull byte[] sha256Certificate) {
             // Changing the schema type dynamically so that we can use separate schemas
@@ -247,10 +264,22 @@ public class MobileApplication extends GenericDocument {
             return this;
         }
 
+        /**
+         * Sets whether the AppFunctionService is effectively enabled in the app.
+         *
+         * <p>For a service to be enabled it needs to be defined in the Manifest and not marked
+         * {@code android:enabled="false"}
+         */
+        @NonNull
+        public Builder setIsAppFunctionServiceEnabled(boolean isAppFunctionServiceEnabled) {
+            setPropertyBoolean(
+                    APP_PROPERTY_IS_APP_FUNCTION_SERVICE_ENABLED, isAppFunctionServiceEnabled);
+            return this;
+        }
+
         @NonNull
         public MobileApplication build() {
             return new MobileApplication(super.build());
         }
     }
 }
-
diff --git a/service/java/com/android/server/appsearch/external/localstorage/AppSearchImpl.java b/service/java/com/android/server/appsearch/external/localstorage/AppSearchImpl.java
index 06822082..a05fa1ed 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/AppSearchImpl.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/AppSearchImpl.java
@@ -26,7 +26,9 @@ import static com.android.server.appsearch.external.localstorage.util.PrefixUtil
 import static com.android.server.appsearch.external.localstorage.util.PrefixUtil.getDatabaseName;
 import static com.android.server.appsearch.external.localstorage.util.PrefixUtil.getPackageName;
 import static com.android.server.appsearch.external.localstorage.util.PrefixUtil.getPrefix;
+import static com.android.server.appsearch.external.localstorage.util.PrefixUtil.removePrefix;
 import static com.android.server.appsearch.external.localstorage.util.PrefixUtil.removePrefixesFromDocument;
+import static com.android.server.appsearch.external.localstorage.util.PrefixUtil.removePrefixesFromSchemaType;
 
 import android.annotation.WorkerThread;
 import android.app.appsearch.AppSearchBatchResult;
@@ -41,6 +43,7 @@ import android.app.appsearch.InternalVisibilityConfig;
 import android.app.appsearch.JoinSpec;
 import android.app.appsearch.PackageIdentifier;
 import android.app.appsearch.SchemaVisibilityConfig;
+import android.app.appsearch.SearchResult;
 import android.app.appsearch.SearchResultPage;
 import android.app.appsearch.SearchSpec;
 import android.app.appsearch.SearchSuggestionResult;
@@ -48,6 +51,7 @@ import android.app.appsearch.SearchSuggestionSpec;
 import android.app.appsearch.SetSchemaResponse;
 import android.app.appsearch.StorageInfo;
 import android.app.appsearch.exceptions.AppSearchException;
+import android.app.appsearch.observer.DocumentChangeInfo;
 import android.app.appsearch.observer.ObserverCallback;
 import android.app.appsearch.observer.ObserverSpec;
 import android.app.appsearch.util.LogUtil;
@@ -56,6 +60,7 @@ import android.os.SystemClock;
 import android.util.ArrayMap;
 import android.util.ArraySet;
 import android.util.Log;
+import android.util.Pair;
 
 import com.android.appsearch.flags.Flags;
 import com.android.internal.annotations.GuardedBy;
@@ -72,10 +77,9 @@ import com.android.server.appsearch.external.localstorage.converter.TypeProperty
 import com.android.server.appsearch.external.localstorage.stats.InitializeStats;
 import com.android.server.appsearch.external.localstorage.stats.OptimizeStats;
 import com.android.server.appsearch.external.localstorage.stats.PutDocumentStats;
+import com.android.server.appsearch.external.localstorage.stats.QueryStats;
 import com.android.server.appsearch.external.localstorage.stats.RemoveStats;
-import com.android.server.appsearch.external.localstorage.stats.SearchStats;
 import com.android.server.appsearch.external.localstorage.stats.SetSchemaStats;
-import com.android.server.appsearch.external.localstorage.util.PrefixUtil;
 import com.android.server.appsearch.external.localstorage.visibilitystore.CallerAccess;
 import com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityChecker;
 import com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityStore;
@@ -83,6 +87,7 @@ import com.android.server.appsearch.external.localstorage.visibilitystore.Visibi
 
 import com.google.android.icing.IcingSearchEngine;
 import com.google.android.icing.IcingSearchEngineInterface;
+import com.google.android.icing.proto.BatchGetResultProto;
 import com.google.android.icing.proto.BatchPutResultProto;
 import com.google.android.icing.proto.BlobProto;
 import com.google.android.icing.proto.DebugInfoProto;
@@ -93,6 +98,7 @@ import com.google.android.icing.proto.DeleteResultProto;
 import com.google.android.icing.proto.DocumentProto;
 import com.google.android.icing.proto.DocumentStorageInfoProto;
 import com.google.android.icing.proto.GetAllNamespacesResultProto;
+import com.google.android.icing.proto.GetNextPageRequestProto;
 import com.google.android.icing.proto.GetOptimizeInfoResultProto;
 import com.google.android.icing.proto.GetResultProto;
 import com.google.android.icing.proto.GetResultSpecProto;
@@ -117,6 +123,7 @@ import com.google.android.icing.proto.SchemaTypeConfigProto;
 import com.google.android.icing.proto.ScoringSpecProto;
 import com.google.android.icing.proto.SearchResultProto;
 import com.google.android.icing.proto.SearchSpecProto;
+import com.google.android.icing.proto.SetSchemaRequestProto;
 import com.google.android.icing.proto.SetSchemaResultProto;
 import com.google.android.icing.proto.StatusProto;
 import com.google.android.icing.proto.StorageInfoProto;
@@ -138,7 +145,6 @@ import java.security.NoSuchAlgorithmException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
@@ -186,11 +192,10 @@ import java.util.concurrent.locks.ReentrantReadWriteLock;
 public final class AppSearchImpl implements Closeable {
     private static final String TAG = "AppSearchImpl";
 
-    /** A value 0 means that there're no more pages in the search results. */
-    private static final long EMPTY_PAGE_TOKEN = 0;
-
     @VisibleForTesting static final int CHECK_OPTIMIZE_INTERVAL = 100;
 
+    @VisibleForTesting static final int PRUNE_PACKAGE_USING_FULL_SET_SCHEMA_THRESHOLD = 20;
+
     /** A GetResultSpec that uses projection to skip all properties. */
     private static final GetResultSpecProto GET_RESULT_SPEC_NO_PROPERTIES =
             GetResultSpecProto.newBuilder()
@@ -207,10 +212,12 @@ public final class AppSearchImpl implements Closeable {
 
     @GuardedBy("mReadWriteLock")
     @VisibleForTesting
-    final IcingSearchEngineInterface mIcingSearchEngineLocked;
+    IcingSearchEngineInterface mIcingSearchEngineLocked;
 
     private final boolean mIsVMEnabled;
 
+    private boolean mIsIcingSchemaDatabaseEnabled = false;
+
     @GuardedBy("mReadWriteLock")
     private final SchemaCache mSchemaCacheLocked = new SchemaCache();
 
@@ -329,23 +336,32 @@ public final class AppSearchImpl implements Closeable {
         mVisibilityCheckerLocked = visibilityChecker;
         mRevocableFileDescriptorStore = revocableFileDescriptorStore;
 
+        // By default, we don't perform any retries.
+        int maxInitRetries = 0;
         mReadWriteLock.writeLock().lock();
         try {
             // We synchronize here because we don't want to call IcingSearchEngine.initialize() more
             // than once. It's unnecessary and can be a costly operation.
             if (icingSearchEngine == null) {
+                mIsVMEnabled = false;
+                if (Flags.enableInitializationRetriesBeforeReset()) {
+                    maxInitRetries = 2;
+                }
                 IcingSearchEngineOptions options =
-                        mConfig.toIcingSearchEngineOptions(icingDir.getAbsolutePath());
+                        mConfig.toIcingSearchEngineOptions(
+                                icingDir.getAbsolutePath(), mIsVMEnabled);
                 LogUtil.piiTrace(TAG, "Constructing IcingSearchEngine, request", options);
                 mIcingSearchEngineLocked = new IcingSearchEngine(options);
+                mIsIcingSchemaDatabaseEnabled = options.getEnableSchemaDatabase();
                 LogUtil.piiTrace(
                         TAG,
                         "Constructing IcingSearchEngine, response",
                         Objects.hashCode(mIcingSearchEngineLocked));
-                mIsVMEnabled = false;
             } else {
                 mIcingSearchEngineLocked = icingSearchEngine;
                 mIsVMEnabled = true;
+                mIsIcingSchemaDatabaseEnabled = true;
+                maxInitRetries = 2;
             }
 
             // The core initialization procedure. If any part of this fails, we bail into
@@ -353,6 +369,17 @@ public final class AppSearchImpl implements Closeable {
             try {
                 LogUtil.piiTrace(TAG, "icingSearchEngine.initialize, request");
                 InitializeResultProto initializeResultProto = mIcingSearchEngineLocked.initialize();
+                while (maxInitRetries > 0 && !isSuccess(initializeResultProto.getStatus())) {
+                    Log.e(
+                            TAG,
+                            String.format(
+                                    "INIT: Initialize failed with status (%d:%s). %d retries left!",
+                                    initializeResultProto.getStatus().getCode().getNumber(),
+                                    initializeResultProto.getStatus().getMessage(),
+                                    maxInitRetries));
+                    --maxInitRetries;
+                    initializeResultProto = mIcingSearchEngineLocked.initialize();
+                }
                 LogUtil.piiTrace(
                         TAG,
                         "icingSearchEngine.initialize, response",
@@ -368,6 +395,19 @@ public final class AppSearchImpl implements Closeable {
                             .setLaunchVMEnabled(mIsVMEnabled);
                     AppSearchLoggerHelper.copyNativeStats(
                             initializeResultProto.getInitializeStats(), initStatsBuilder);
+                    if (isVMEnabled()) {
+                        // TODO(b/415387509): Add an actual atom field to capture this value.
+                        // Hack to propagate the failure cause early
+                        // Store value in IcuDataStatus because that field doesn't matter in
+                        // platform. Add 100 to separate from the range of possible values that
+                        // would otherwise be set in this field.
+                        initStatsBuilder.setNativeInitializeIcuDataStatusCode(
+                                100
+                                        + initializeResultProto
+                                                .getInitializeStats()
+                                                .getFailureStage()
+                                                .getNumber());
+                    }
                 }
                 checkSuccess(initializeResultProto.getStatus());
 
@@ -382,18 +422,57 @@ public final class AppSearchImpl implements Closeable {
 
                 // Read all protos we need to construct AppSearchImpl's cache maps
                 long prepareSchemaAndNamespacesLatencyStartMillis = SystemClock.elapsedRealtime();
-                SchemaProto schemaProto = getSchemaProtoLocked();
-
-                LogUtil.piiTrace(TAG, "init:getAllNamespaces, request");
-                GetAllNamespacesResultProto getAllNamespacesResultProto =
-                        mIcingSearchEngineLocked.getAllNamespaces();
+                LogUtil.piiTrace(TAG, "getSchema, request");
+                GetSchemaResultProto schemaResultProto = mIcingSearchEngineLocked.getSchema();
+                // GetSchema may return NOT_FOUND if we've initialized an empty instance.
+                while (maxInitRetries > 0
+                        && !isCodeOneOf(
+                                schemaResultProto.getStatus(),
+                                StatusProto.Code.OK,
+                                StatusProto.Code.NOT_FOUND)) {
+                    Log.e(
+                            TAG,
+                            String.format(
+                                    "INIT: GetSchema failed with status (%d:%s). %d retries left!",
+                                    schemaResultProto.getStatus().getCode().getNumber(),
+                                    schemaResultProto.getStatus().getMessage(),
+                                    maxInitRetries));
+                    --maxInitRetries;
+                    schemaResultProto = mIcingSearchEngineLocked.getSchema();
+                }
                 LogUtil.piiTrace(
                         TAG,
-                        "init:getAllNamespaces, response",
-                        getAllNamespacesResultProto.getNamespacesCount(),
-                        getAllNamespacesResultProto);
-
-                StorageInfoProto storageInfoProto = getRawStorageInfoProto();
+                        "getSchema, response",
+                        schemaResultProto.getStatus(),
+                        schemaResultProto);
+                checkCodeOneOf(
+                        schemaResultProto.getStatus(),
+                        StatusProto.Code.OK,
+                        StatusProto.Code.NOT_FOUND);
+                SchemaProto schemaProto = schemaResultProto.getSchema();
+
+                LogUtil.piiTrace(TAG, "getStorageInfo, request");
+                StorageInfoResultProto storageInfoResult =
+                        mIcingSearchEngineLocked.getStorageInfo();
+                while (maxInitRetries > 0 && !isSuccess(storageInfoResult.getStatus())) {
+                    Log.e(
+                            TAG,
+                            String.format(
+                                    "INIT: GetStorageInfo failed with status (%d:%s). %d retries"
+                                            + " left!",
+                                    storageInfoResult.getStatus().getCode().getNumber(),
+                                    storageInfoResult.getStatus().getMessage(),
+                                    maxInitRetries));
+                    --maxInitRetries;
+                    storageInfoResult = mIcingSearchEngineLocked.getStorageInfo();
+                }
+                LogUtil.piiTrace(
+                        TAG,
+                        "getStorageInfo, response",
+                        storageInfoResult.getStatus(),
+                        storageInfoResult);
+                checkSuccess(storageInfoResult.getStatus());
+                StorageInfoProto storageInfoProto = storageInfoResult.getStorageInfo();
 
                 // Log the time it took to read the data that goes into the cache maps
                 if (initStatsBuilder != null) {
@@ -401,15 +480,12 @@ public final class AppSearchImpl implements Closeable {
                     // set the latency for preparation.
                     // If there is no error, the value will be overridden by the actual one later.
                     initStatsBuilder
-                            .setStatusCode(
-                                    statusProtoToResultCode(
-                                            getAllNamespacesResultProto.getStatus()))
+                            .setStatusCode(AppSearchResult.RESULT_OK)
                             .setPrepareSchemaAndNamespacesLatencyMillis(
                                     (int)
                                             (SystemClock.elapsedRealtime()
                                                     - prepareSchemaAndNamespacesLatencyStartMillis));
                 }
-                checkSuccess(getAllNamespacesResultProto.getStatus());
 
                 // Populate schema map
                 List<SchemaTypeConfigProto> schemaProtoTypesList = schemaProto.getTypesList();
@@ -423,10 +499,10 @@ public final class AppSearchImpl implements Closeable {
                 mSchemaCacheLocked.rebuildCache();
 
                 // Populate namespace map
-                List<String> prefixedNamespaceList =
-                        getAllNamespacesResultProto.getNamespacesList();
-                for (int i = 0; i < prefixedNamespaceList.size(); i++) {
-                    String prefixedNamespace = prefixedNamespaceList.get(i);
+                List<NamespaceStorageInfoProto> namespaceInfos =
+                        storageInfoProto.getDocumentStorageInfo().getNamespaceStorageInfoList();
+                for (int i = 0; i < namespaceInfos.size(); i++) {
+                    String prefixedNamespace = namespaceInfos.get(i).getNamespace();
                     mNamespaceCacheLocked.addToDocumentNamespaceMap(
                             getPrefix(prefixedNamespace), prefixedNamespace);
                 }
@@ -464,7 +540,7 @@ public final class AppSearchImpl implements Closeable {
 
             } catch (AppSearchException e) {
                 // Some error. Reset and see if it fixes it.
-                Log.e(TAG, "Error initializing, resetting IcingSearchEngine.", e);
+                Log.e(TAG, "Error initializing, attempting to reset IcingSearchEngine.", e);
                 if (initStatsBuilder != null) {
                     initStatsBuilder.setStatusCode(e.getResultCode());
                 }
@@ -538,6 +614,27 @@ public final class AppSearchImpl implements Closeable {
         return mIsVMEnabled;
     }
 
+    /** Returns whether this AppSearchImpl instance should use database-scoped set and get schema */
+    @VisibleForTesting
+    boolean useDatabaseScopedSchemaOperations() {
+        return mIsIcingSchemaDatabaseEnabled;
+    }
+
+    /** Atomic method to set a new icing search engine and return the previous engine. */
+    @GuardedBy("mReadWriteLock")
+    public @NonNull IcingSearchEngineInterface swapIcingSearchEngineLocked(
+            @NonNull IcingSearchEngineInterface icingSearchEngineLocked) {
+        Objects.requireNonNull(icingSearchEngineLocked);
+        mReadWriteLock.writeLock().lock();
+        try {
+            IcingSearchEngineInterface previousIcingSearchEngine = mIcingSearchEngineLocked;
+            mIcingSearchEngineLocked = icingSearchEngineLocked;
+            return previousIcingSearchEngine;
+        } finally {
+            mReadWriteLock.writeLock().unlock();
+        }
+    }
+
     /**
      * Updates the AppSearch schema for this app.
      *
@@ -585,23 +682,35 @@ public final class AppSearchImpl implements Closeable {
                         .setLaunchVMEnabled(mIsVMEnabled);
             }
             if (mObserverManager.isPackageObserved(packageName)) {
-                return doSetSchemaWithChangeNotificationLocked(
-                        packageName,
-                        databaseName,
-                        schemas,
-                        visibilityConfigs,
-                        forceOverride,
-                        version,
-                        setSchemaStatsBuilder);
+                if (useDatabaseScopedSchemaOperations()) {
+                    return doSetSchemaWithChangeNotificationNoGetSchemaLocked(
+                            packageName,
+                            databaseName,
+                            schemas,
+                            visibilityConfigs,
+                            forceOverride,
+                            version,
+                            setSchemaStatsBuilder);
+                } else {
+                    return doSetSchemaWithChangeNotificationLocked(
+                            packageName,
+                            databaseName,
+                            schemas,
+                            visibilityConfigs,
+                            forceOverride,
+                            version,
+                            setSchemaStatsBuilder);
+                }
             } else {
                 return doSetSchemaNoChangeNotificationLocked(
-                        packageName,
-                        databaseName,
-                        schemas,
-                        visibilityConfigs,
-                        forceOverride,
-                        version,
-                        setSchemaStatsBuilder);
+                                packageName,
+                                databaseName,
+                                schemas,
+                                visibilityConfigs,
+                                forceOverride,
+                                version,
+                                setSchemaStatsBuilder)
+                        .first;
             }
         } finally {
             mReadWriteLock.writeLock().unlock();
@@ -609,7 +718,8 @@ public final class AppSearchImpl implements Closeable {
     }
 
     /**
-     * Updates the AppSearch schema for this app, dispatching change notifications.
+     * Updates the AppSearch schema for this app, dispatching change notifications. This method
+     * calls the getSchema API in the process.
      *
      * @see #setSchema
      * @see #doSetSchemaNoChangeNotificationLocked
@@ -670,13 +780,14 @@ public final class AppSearchImpl implements Closeable {
         // Apply the new schema
         InternalSetSchemaResponse internalSetSchemaResponse =
                 doSetSchemaNoChangeNotificationLocked(
-                        packageName,
-                        databaseName,
-                        schemas,
-                        visibilityConfigs,
-                        forceOverride,
-                        version,
-                        setSchemaStatsBuilder);
+                                packageName,
+                                databaseName,
+                                schemas,
+                                visibilityConfigs,
+                                forceOverride,
+                                version,
+                                setSchemaStatsBuilder)
+                        .first;
 
         // This check is needed wherever setSchema is called to detect soft errors which do not
         // throw an exception but also prevent the schema from actually being applied.
@@ -791,15 +902,14 @@ public final class AppSearchImpl implements Closeable {
     }
 
     /**
-     * Updates the AppSearch schema for this app, without dispatching change notifications.
-     *
-     * <p>This method can be used only when no one is observing {@code packageName}.
+     * Updates the AppSearch schema for this app and dispatches change notifications, without
+     * calling the getSchema API.
      *
      * @see #setSchema
-     * @see #doSetSchemaWithChangeNotificationLocked
+     * @see #doSetSchemaNoChangeNotificationLocked
      */
     @GuardedBy("mReadWriteLock")
-    private @NonNull InternalSetSchemaResponse doSetSchemaNoChangeNotificationLocked(
+    private @NonNull InternalSetSchemaResponse doSetSchemaWithChangeNotificationNoGetSchemaLocked(
             @NonNull String packageName,
             @NonNull String databaseName,
             @NonNull List<AppSearchSchema> schemas,
@@ -808,9 +918,242 @@ public final class AppSearchImpl implements Closeable {
             int version,
             SetSchemaStats.@Nullable Builder setSchemaStatsBuilder)
             throws AppSearchException {
-        long setRewriteSchemaLatencyStartTimeMillis = SystemClock.elapsedRealtime();
-        SchemaProto.Builder existingSchemaBuilder = getSchemaProtoLocked().toBuilder();
+        // Get the old schema map and cache the listening packages for the database
+        long getOldSchemaObserverStartTimeMillis = SystemClock.elapsedRealtime();
+        Set<String> oldPrefixedTypesForPrefix =
+                mSchemaCacheLocked
+                        .getSchemaMapForPrefix(createPrefix(packageName, databaseName))
+                        .keySet();
+        Map<String, Set<String>> oldSchemaNameToVisibleListeningPackage =
+                new ArrayMap<>(oldPrefixedTypesForPrefix.size());
+        for (String prefixedTypeName : oldPrefixedTypesForPrefix) {
+            String unprefixedTypeName = removePrefix(prefixedTypeName);
+            oldSchemaNameToVisibleListeningPackage.put(
+                    unprefixedTypeName,
+                    mObserverManager.getObserversForSchemaType(
+                            packageName,
+                            databaseName,
+                            unprefixedTypeName,
+                            mDocumentVisibilityStoreLocked,
+                            mVisibilityCheckerLocked));
+        }
+        int getOldSchemaObserverLatencyMillis =
+                (int) (SystemClock.elapsedRealtime() - getOldSchemaObserverStartTimeMillis);
+
+        // Apply the new schema
+        Pair<InternalSetSchemaResponse, SetSchemaResultProto> setSchemaResponsePair =
+                doSetSchemaNoChangeNotificationLocked(
+                        packageName,
+                        databaseName,
+                        schemas,
+                        visibilityConfigs,
+                        forceOverride,
+                        version,
+                        setSchemaStatsBuilder);
+
+        // This check is needed wherever setSchema is called to detect soft errors which do not
+        // throw an exception but also prevent the schema from actually being applied.
+        if (!setSchemaResponsePair.first.isSuccess()) {
+            return setSchemaResponsePair.first;
+        }
+
+        long getNewSchemaObserverStartTimeMillis = SystemClock.elapsedRealtime();
+        // Maps unprefixed schema name to the set of listening packages that have visibility into
+        // that type under the new schema.
+        Map<String, Set<String>> requestSchemaNameToVisibleListeningPackage =
+                new ArrayMap<>(schemas.size());
+        Set<String> requestUnprefixedSchemaNames = new ArraySet<>();
+        for (AppSearchSchema requestSchemaType : schemas) {
+            String requestSchemaName = requestSchemaType.getSchemaType();
+            requestUnprefixedSchemaNames.add(requestSchemaName);
+            requestSchemaNameToVisibleListeningPackage.put(
+                    requestSchemaName,
+                    mObserverManager.getObserversForSchemaType(
+                            packageName,
+                            databaseName,
+                            requestSchemaName,
+                            mDocumentVisibilityStoreLocked,
+                            mVisibilityCheckerLocked));
+        }
+        long getNewSchemaObserverEndTimeMillis = SystemClock.elapsedRealtime();
+        if (setSchemaStatsBuilder != null) {
+            setSchemaStatsBuilder.setGetObserverLatencyMillis(
+                    getOldSchemaObserverLatencyMillis
+                            + (int)
+                                    (getNewSchemaObserverEndTimeMillis
+                                            - getNewSchemaObserverStartTimeMillis));
+        }
+
+        long preparingChangeNotificationStartTimeMillis = SystemClock.elapsedRealtime();
+        SetSchemaResultProto setSchemaResultProto = setSchemaResponsePair.second;
+        // Send notifications for all old listeners of deleted types
+        sendDeletedTypeNotificationsLocked(
+                packageName,
+                databaseName,
+                setSchemaResultProto.getDeletedSchemaTypesList(),
+                oldSchemaNameToVisibleListeningPackage);
+
+        // Send notifications for types in the request schema.
+        sendRequestSchemaTypesNotificationsLocked(
+                packageName,
+                databaseName,
+                setSchemaResultProto,
+                requestUnprefixedSchemaNames,
+                oldSchemaNameToVisibleListeningPackage,
+                requestSchemaNameToVisibleListeningPackage);
+
+        if (setSchemaStatsBuilder != null) {
+            setSchemaStatsBuilder.setPreparingChangeNotificationLatencyMillis(
+                    (int)
+                            (SystemClock.elapsedRealtime()
+                                    - preparingChangeNotificationStartTimeMillis));
+        }
+
+        return setSchemaResponsePair.first;
+    }
+
+    /**
+     * Schedule observer notifications for schema types that have been deleted.
+     *
+     * @param targetPackageName The package of the deleted types.
+     * @param databaseName The database of the deleted types.
+     * @param prefixedDeletedTypes A list of prefixed deleted schema type names.
+     * @param unprefixedSchemaNameToObserversMap A map from unprefixed schema type names to the set
+     *     of observer package names that should be notified.
+     */
+    private void sendDeletedTypeNotificationsLocked(
+            String targetPackageName,
+            String databaseName,
+            List<String> prefixedDeletedTypes,
+            Map<String, Set<String>> unprefixedSchemaNameToObserversMap)
+            throws AppSearchException {
+        for (int i = 0; i < prefixedDeletedTypes.size(); ++i) {
+            String deletedType = removePrefix(prefixedDeletedTypes.get(i));
+            Set<String> visibleListeners = unprefixedSchemaNameToObserversMap.get(deletedType);
+            if (visibleListeners != null) {
+                for (String listeningPackageName : visibleListeners) {
+                    mObserverManager.onSchemaChange(
+                            listeningPackageName, targetPackageName, databaseName, deletedType);
+                }
+            }
+        }
+    }
 
+    /**
+     * Schedule observer notifications for schema types in the request schema. Notifications are
+     * scheduled for a type if: 1. The type is either a new type, or its definition has changed from
+     * before. 2. There is a change in the type's visibility from its old visibility for the
+     * observer.
+     *
+     * @param targetPackageName The package of the deleted types.
+     * @param databaseName The database of the deleted types.
+     * @param setSchemaResultProto Result proto from the set schema request
+     * @param unprefixedRequestSchemaNames Set of unprefixed schema type names for the set schema
+     *     request
+     * @param unprefixedPriorSchemaNameToObserversMap A map from the prior unprefixed schema type
+     *     names to the set of observer package names that should be notified.
+     * @param unprefixedRequestSchemaNameToObserversMap A map from the request's unprefixed schema
+     *     type names to the set of observer package names that should be notified.
+     */
+    private void sendRequestSchemaTypesNotificationsLocked(
+            String targetPackageName,
+            String databaseName,
+            SetSchemaResultProto setSchemaResultProto,
+            Set<String> unprefixedRequestSchemaNames,
+            Map<String, Set<String>> unprefixedPriorSchemaNameToObserversMap,
+            Map<String, Set<String>> unprefixedRequestSchemaNameToObserversMap)
+            throws AppSearchException {
+        // Get new or changed types from the setSchemaResultProto
+        Set<String> unprefixedNewAndChangedTypes = new ArraySet<>();
+        addUnprefixedTypeNames(
+                setSchemaResultProto.getNewSchemaTypesList(), unprefixedNewAndChangedTypes);
+        addUnprefixedTypeNames(
+                setSchemaResultProto.getIncompatibleSchemaTypesList(),
+                unprefixedNewAndChangedTypes);
+        addUnprefixedTypeNames(
+                setSchemaResultProto.getFullyCompatibleChangedSchemaTypesList(),
+                unprefixedNewAndChangedTypes);
+        addUnprefixedTypeNames(
+                setSchemaResultProto.getIndexIncompatibleChangedSchemaTypesList(),
+                unprefixedNewAndChangedTypes);
+        addUnprefixedTypeNames(
+                setSchemaResultProto.getJoinIncompatibleChangedSchemaTypesList(),
+                unprefixedNewAndChangedTypes);
+
+        // Iterate through each type in the request schema and send notifications
+        for (String schemaName : unprefixedRequestSchemaNames) {
+            Set<String> priorVisibleListeners =
+                    unprefixedPriorSchemaNameToObserversMap.get(schemaName);
+            Set<String> requestVisibleListeners =
+                    unprefixedRequestSchemaNameToObserversMap.get(schemaName);
+
+            // Iterate through each observer in the prior and current listeners and consider its
+            // view of the type to send notifications
+            if (priorVisibleListeners != null) {
+                for (String priorListeningPackage : priorVisibleListeners) {
+                    if (requestVisibleListeners != null
+                            && requestVisibleListeners.contains(priorListeningPackage)
+                            && !unprefixedNewAndChangedTypes.contains(schemaName)) {
+                        // Neither the listener's view nor the type itself has changed -- no need to
+                        // notify
+                        continue;
+                    }
+                    mObserverManager.onSchemaChange(
+                            priorListeningPackage, targetPackageName, databaseName, schemaName);
+                }
+            }
+
+            if (requestVisibleListeners != null) {
+                for (String currentListeningPackage : requestVisibleListeners) {
+                    // At this point we only need to notify if the listener is not a visible
+                    // listener prior to the request.
+                    // For other scenarios, we've already checked and notified above while
+                    // notifying prior listeners.
+                    if (priorVisibleListeners == null
+                            || !priorVisibleListeners.contains(currentListeningPackage)) {
+                        mObserverManager.onSchemaChange(
+                                currentListeningPackage,
+                                targetPackageName,
+                                databaseName,
+                                schemaName);
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Extracts unprefixed type names from a list of prefixed type names and adds them to the given
+     * set.
+     */
+    private void addUnprefixedTypeNames(List<String> prefixedTypes, Set<String> unprefixedTypeSet)
+            throws AppSearchException {
+        for (int i = 0; i < prefixedTypes.size(); ++i) {
+            unprefixedTypeSet.add(removePrefix(prefixedTypes.get(i)));
+        }
+    }
+
+    /**
+     * Updates the AppSearch schema for this app, without dispatching change notifications.
+     *
+     * <p>This method can be used only when no one is observing {@code packageName}.
+     *
+     * @see #setSchema
+     * @see #doSetSchemaWithChangeNotificationLocked
+     */
+    @GuardedBy("mReadWriteLock")
+    private @NonNull Pair<InternalSetSchemaResponse, SetSchemaResultProto>
+            doSetSchemaNoChangeNotificationLocked(
+                    @NonNull String packageName,
+                    @NonNull String databaseName,
+                    @NonNull List<AppSearchSchema> schemas,
+                    @NonNull List<InternalVisibilityConfig> visibilityConfigs,
+                    boolean forceOverride,
+                    int version,
+                    SetSchemaStats.@Nullable Builder setSchemaStatsBuilder)
+                    throws AppSearchException {
+        long rewriteSchemaStartTimeMillis = SystemClock.elapsedRealtime();
+        String prefix = createPrefix(packageName, databaseName);
         SchemaProto.Builder newSchemaBuilder = SchemaProto.newBuilder();
         for (int i = 0; i < schemas.size(); i++) {
             AppSearchSchema schema = schemas.get(i);
@@ -819,28 +1162,59 @@ public final class AppSearchImpl implements Closeable {
             newSchemaBuilder.addTypes(schemaTypeProto);
         }
 
-        String prefix = createPrefix(packageName, databaseName);
-        // Combine the existing schema (which may have types from other prefixes) with this
-        // prefix's new schema. Modifies the existingSchemaBuilder.
-        RewrittenSchemaResults rewrittenSchemaResults =
-                rewriteSchema(prefix, existingSchemaBuilder, newSchemaBuilder.build());
+        Set<String> deletedPrefixedTypes;
+        Map<String, SchemaTypeConfigProto> rewrittenPrefixedTypes;
+        SetSchemaResultProto setSchemaResultProto;
 
-        long rewriteSchemaEndTimeMillis = SystemClock.elapsedRealtime();
-        if (setSchemaStatsBuilder != null) {
-            setSchemaStatsBuilder.setRewriteSchemaLatencyMillis(
-                    (int) (rewriteSchemaEndTimeMillis - setRewriteSchemaLatencyStartTimeMillis));
-        }
-
-        // Apply schema
+        long rewriteSchemaEndTimeMillis;
         long nativeLatencyStartTimeMillis = SystemClock.elapsedRealtime();
-        SchemaProto finalSchema = existingSchemaBuilder.build();
-        LogUtil.piiTrace(TAG, "setSchema, request", finalSchema.getTypesCount(), finalSchema);
-        SetSchemaResultProto setSchemaResultProto =
-                mIcingSearchEngineLocked.setSchema(finalSchema, forceOverride);
+        // Rewrite and apply schema
+        if (useDatabaseScopedSchemaOperations()) {
+            rewrittenPrefixedTypes =
+                    getRewrittenPrefixedTypes(
+                            prefix, newSchemaBuilder.build(), /* populateDatabase= */ true);
+            rewriteSchemaEndTimeMillis = SystemClock.elapsedRealtime();
+
+            SchemaProto finalSchema =
+                    SchemaProto.newBuilder().addAllTypes(rewrittenPrefixedTypes.values()).build();
+            SetSchemaRequestProto setSchemaRequestProto =
+                    SetSchemaRequestProto.newBuilder()
+                            .setSchema(finalSchema)
+                            .setDatabase(prefix)
+                            .setIgnoreErrorsAndDeleteDocuments(forceOverride)
+                            .build();
+            LogUtil.piiTrace(
+                    TAG, "setSchema, request", finalSchema.getTypesCount(), setSchemaRequestProto);
+            setSchemaResultProto =
+                    mIcingSearchEngineLocked.setSchemaWithRequestProto(setSchemaRequestProto);
+            deletedPrefixedTypes = new ArraySet<>(setSchemaResultProto.getDeletedSchemaTypesList());
+        } else {
+            SchemaProto.Builder existingSchemaBuilder = getSchemaProtoLocked().toBuilder();
+            // Combine the existing schema (which may have types from other prefixes) with this
+            // prefix's new schema. Modifies the existingSchemaBuilder.
+            RewrittenSchemaResults rewrittenSchemaResults =
+                    rewriteSchema(
+                            prefix,
+                            existingSchemaBuilder,
+                            newSchemaBuilder.build(),
+                            /* populateDatabase= */ false);
+            rewriteSchemaEndTimeMillis = SystemClock.elapsedRealtime();
+
+            deletedPrefixedTypes = rewrittenSchemaResults.mDeletedPrefixedTypes;
+            rewrittenPrefixedTypes = rewrittenSchemaResults.mRewrittenPrefixedTypes;
+
+            SchemaProto finalSchema = existingSchemaBuilder.build();
+            LogUtil.piiTrace(TAG, "setSchema, request", finalSchema.getTypesCount(), finalSchema);
+            setSchemaResultProto = mIcingSearchEngineLocked.setSchema(finalSchema, forceOverride);
+        }
         LogUtil.piiTrace(
                 TAG, "setSchema, response", setSchemaResultProto.getStatus(), setSchemaResultProto);
         long nativeLatencyEndTimeMillis = SystemClock.elapsedRealtime();
+
+        // Populate logging stats
         if (setSchemaStatsBuilder != null) {
+            setSchemaStatsBuilder.setRewriteSchemaLatencyMillis(
+                    (int) (rewriteSchemaEndTimeMillis - rewriteSchemaStartTimeMillis));
             setSchemaStatsBuilder
                     .setTotalNativeLatencyMillis(
                             (int) (nativeLatencyEndTimeMillis - nativeLatencyStartTimeMillis))
@@ -869,7 +1243,9 @@ public final class AppSearchImpl implements Closeable {
                                 + setSchemaResponse.getDeletedTypes()
                                 + "\n  Incompatible types: "
                                 + setSchemaResponse.getIncompatibleTypes();
-                return newFailedSetSchemaResponse(setSchemaResponse, errorMessage);
+                return new Pair<>(
+                        newFailedSetSchemaResponse(setSchemaResponse, errorMessage),
+                        setSchemaResultProto);
             } else {
                 throw e;
             }
@@ -877,12 +1253,11 @@ public final class AppSearchImpl implements Closeable {
 
         long saveVisibilitySettingStartTimeMillis = SystemClock.elapsedRealtime();
         // Update derived data structures.
-        for (SchemaTypeConfigProto schemaTypeConfigProto :
-                rewrittenSchemaResults.mRewrittenPrefixedTypes.values()) {
+        for (SchemaTypeConfigProto schemaTypeConfigProto : rewrittenPrefixedTypes.values()) {
             mSchemaCacheLocked.addToSchemaMap(prefix, schemaTypeConfigProto);
         }
 
-        for (String schemaType : rewrittenSchemaResults.mDeletedPrefixedTypes) {
+        for (String schemaType : deletedPrefixedTypes) {
             mSchemaCacheLocked.removeFromSchemaMap(prefix, schemaType);
         }
 
@@ -895,14 +1270,14 @@ public final class AppSearchImpl implements Closeable {
             // Find out which Visibility document is deleted or changed to all-default settings.
             // We need to remove them from Visibility Store.
             Set<String> deprecatedVisibilityDocuments =
-                    new ArraySet<>(rewrittenSchemaResults.mRewrittenPrefixedTypes.keySet());
+                    new ArraySet<>(rewrittenPrefixedTypes.keySet());
             List<InternalVisibilityConfig> prefixedVisibilityConfigs =
                     rewriteVisibilityConfigs(
                             prefix, visibilityConfigs, deprecatedVisibilityDocuments);
             // Now deprecatedVisibilityDocuments contains those existing schemas that has
             // all-default visibility settings, add deleted schemas. That's all we need to
             // remove.
-            deprecatedVisibilityDocuments.addAll(rewrittenSchemaResults.mDeletedPrefixedTypes);
+            deprecatedVisibilityDocuments.addAll(deletedPrefixedTypes);
             mDocumentVisibilityStoreLocked.removeVisibility(deprecatedVisibilityDocuments);
             mDocumentVisibilityStoreLocked.setVisibility(prefixedVisibilityConfigs);
         }
@@ -924,7 +1299,7 @@ public final class AppSearchImpl implements Closeable {
             setSchemaStatsBuilder.setConvertToResponseLatencyMillis(
                     (int) (convertToResponseEndTimeMillis - convertToResponseStartTimeMillis));
         }
-        return setSchemaResponse;
+        return new Pair<>(setSchemaResponse, setSchemaResultProto);
     }
 
     /**
@@ -946,16 +1321,28 @@ public final class AppSearchImpl implements Closeable {
         try {
             throwIfClosedLocked();
 
-            SchemaProto fullSchema = getSchemaProtoLocked();
+            // Get the schema from IcingLib.
+            // If database-scoped schema operations is enabled, the schema that is retrieved would
+            // only contain schema types corresponding to the package-database prefix. Otherwise,
+            // the full schema containing all types (across all packages and databases) will be
+            // retrieved.
+            SchemaProto icingSchema;
             String prefix = createPrefix(packageName, databaseName);
+            if (useDatabaseScopedSchemaOperations()) {
+                icingSchema = getSchemaProtoForPrefixLocked(prefix);
+            } else {
+                icingSchema = getSchemaProtoLocked();
+            }
             GetSchemaResponse.Builder responseBuilder = new GetSchemaResponse.Builder();
-            for (int i = 0; i < fullSchema.getTypesCount(); i++) {
+            for (int i = 0; i < icingSchema.getTypesCount(); i++) {
                 // Check that this type belongs to the requested app and that the caller has
                 // access to it.
-                SchemaTypeConfigProto typeConfig = fullSchema.getTypes(i);
+                SchemaTypeConfigProto typeConfig = icingSchema.getTypes(i);
                 String prefixedSchemaType = typeConfig.getSchemaType();
                 String typePrefix = getPrefix(prefixedSchemaType);
                 if (!prefix.equals(typePrefix)) {
+                    // TODO: Remove this unnecessary check once
+                    //  enableDatabaseScopedSchemaOperations is rolled out.
                     // This schema type doesn't belong to the database we're querying for.
                     continue;
                 }
@@ -971,7 +1358,7 @@ public final class AppSearchImpl implements Closeable {
 
                 // Rewrite SchemaProto.types.schema_type
                 SchemaTypeConfigProto.Builder typeConfigBuilder = typeConfig.toBuilder();
-                PrefixUtil.removePrefixesFromSchemaType(typeConfigBuilder);
+                removePrefixesFromSchemaType(typeConfigBuilder);
                 AppSearchSchema schema =
                         SchemaToProtoConverter.toAppSearchSchema(typeConfigBuilder);
 
@@ -1081,8 +1468,8 @@ public final class AppSearchImpl implements Closeable {
      * @param databaseName The databaseName this document resides in.
      * @param documents A list of documents to index.
      * @param batchResultBuilder The builder for returning the batch result.
-     * @param sendChangeNotifications Whether to dispatch {@link
-     *     android.app.appsearch.observer.DocumentChangeInfo} messages to observers for this change.
+     * @param sendChangeNotifications Whether to dispatch {@link DocumentChangeInfo} messages to
+     *     observers for this change.
      * @param persistType The persist type used to call PersistToDisk inside Icing at the end of the
      *     Put request. If UNKNOWN, PersistToDisk will not be called. See also {@link
      *     #persistToDisk(PersistType.Code)}.
@@ -1112,10 +1499,7 @@ public final class AppSearchImpl implements Closeable {
             List<PutDocumentRequest.Builder> requestBuilderList = new ArrayList<>();
             // This is to make sure the batching size is at least getMaxDocumentSizeBytes.
             // Otherwise one valid size doc may not fit into a batch.
-            int maxBufferedBytes =
-                    Integer.max(
-                            mConfig.getMaxByteLimitForBatchPut(),
-                            mConfig.getMaxDocumentSizeBytes());
+            int maxBufferedBytes = mConfig.getMaxByteLimitForBatchPut();
             int currentTotalBytes = 0;
             PutDocumentRequest.Builder currentBatchBuilder =
                     PutDocumentRequest.newBuilder().setPersistType(PersistType.Code.UNKNOWN);
@@ -1150,10 +1534,15 @@ public final class AppSearchImpl implements Closeable {
                     int serializedSizeBytes = finalDocument.getSerializedSize();
                     enforceLimitConfigLocked(packageName, docId, serializedSizeBytes);
 
-                    // to see if we want to finish the current batch and build a PutRequestProto.
-                    // based on how we calculate maxBufferedBytes, serializedSizeBytes is guaranteed
-                    // to be smaller or same as maxBufferedBytes.
-                    if (serializedSizeBytes > maxBufferedBytes - currentTotalBytes) {
+                    // to see if we want to finish the current batch due to the byte limitation and
+                    // build a PutRequestProto.
+                    // - It is possible for serializedSizeBytes to exceed maxBufferedBytes if the
+                    //   currentBatch is empty, then we must add the document to it instead of
+                    //   finishing the batch.
+                    // - If the currentBatch is non-empty, then we should finish that batch and
+                    //   create a new one with this document.
+                    if (currentBatchBuilder.getDocumentsCount() > 0
+                            && serializedSizeBytes > maxBufferedBytes - currentTotalBytes) {
                         // Time to finish the current batch.
                         requestBuilderList.add(currentBatchBuilder);
 
@@ -1274,8 +1663,8 @@ public final class AppSearchImpl implements Closeable {
                             mObserverManager.onDocumentChange(
                                     packageName,
                                     databaseName,
-                                    PrefixUtil.removePrefix(documentProto.getNamespace()),
-                                    PrefixUtil.removePrefix(documentProto.getSchema()),
+                                    removePrefix(documentProto.getNamespace()),
+                                    removePrefix(documentProto.getSchema()),
                                     documentProto.getUri(),
                                     mDocumentVisibilityStoreLocked,
                                     mVisibilityCheckerLocked);
@@ -1283,6 +1672,8 @@ public final class AppSearchImpl implements Closeable {
                     } catch (Throwable t) {
                         if (batchResultBuilder != null) {
                             batchResultBuilder.setResult(docId, throwableToFailedResult(t));
+                        } else {
+                            throw t;
                         }
                     }
                 }
@@ -1318,8 +1709,8 @@ public final class AppSearchImpl implements Closeable {
      * @param packageName The package name that owns this document.
      * @param databaseName The databaseName this document resides in.
      * @param document The document to index.
-     * @param sendChangeNotifications Whether to dispatch {@link
-     *     android.app.appsearch.observer.DocumentChangeInfo} messages to observers for this change.
+     * @param sendChangeNotifications Whether to dispatch {@link DocumentChangeInfo} messages to
+     *     observers for this change.
      * @throws AppSearchException on IcingSearchEngine error.
      * @deprecated use {@link #batchPutDocuments(String, String, List, AppSearchBatchResult.Builder,
      *     boolean, AppSearchLogger)}
@@ -1762,7 +2153,7 @@ public final class AppSearchImpl implements Closeable {
         try {
             throwIfClosedLocked();
             if (mBlobVisibilityStoreLocked != null) {
-                String prefix = PrefixUtil.createPrefix(packageName, databaseName);
+                String prefix = createPrefix(packageName, databaseName);
                 Set<String> removedVisibilityConfigs =
                         mNamespaceCacheLocked.getPrefixedBlobNamespaces(prefix);
                 if (removedVisibilityConfigs == null) {
@@ -1958,6 +2349,134 @@ public final class AppSearchImpl implements Closeable {
         }
     }
 
+    /**
+     * Retrieves a list document from the AppSearch index by namespace and document ID.
+     *
+     * <p>This method belongs to query group.
+     *
+     * @param packageName The package that owns this document.
+     * @param databaseName The databaseName this document resides in.
+     * @param request The request configuration for BatchGet.
+     * @param callerAccess The information about caller. Visibility will be checked if it is not
+     *     NULL. This indicates it is a global get call.
+     * @return The Document contents in a {@link AppSearchBatchResult}.
+     */
+    public @NonNull AppSearchBatchResult<String, GenericDocument> batchGetDocuments(
+            @NonNull String packageName,
+            @NonNull String databaseName,
+            @NonNull GetByDocumentIdRequest request,
+            @Nullable CallerAccess callerAccess) {
+        AppSearchBatchResult.Builder<String, GenericDocument> resultBuilder =
+                new AppSearchBatchResult.Builder<>();
+
+        // If the id list is empty, we can just return directly.
+        if (request.getIds().isEmpty()) {
+            return resultBuilder.build();
+        }
+
+        mReadWriteLock.readLock().lock();
+        try {
+            throwIfClosedLocked();
+
+            BatchGetResultProto batchGetResultProto =
+                    batchGetDocumentProtoByIdLocked(packageName, databaseName, request);
+
+            for (int i = 0; i < batchGetResultProto.getGetResultProtosCount(); ++i) {
+                GetResultProto getResultProto = batchGetResultProto.getGetResultProtos(i);
+                String id = getResultProto.getUri();
+                try {
+                    checkSuccess(getResultProto.getStatus());
+
+                    // Check if the schema is visible to the caller. This is only done if
+                    // callerAccess is not null.
+                    // TODO(b/404643381) We can cache the results and use those if we have seen
+                    //  the same schema before.
+                    if (callerAccess != null
+                            && !VisibilityUtil.isSchemaSearchableByCaller(
+                                    callerAccess,
+                                    packageName,
+                                    getResultProto.getDocument().getSchema(),
+                                    mDocumentVisibilityStoreLocked,
+                                    mVisibilityCheckerLocked)) {
+                        throw new AppSearchException(AppSearchResult.RESULT_NOT_FOUND);
+                    }
+
+                    DocumentProto.Builder documentBuilder =
+                            getResultProto.getDocument().toBuilder();
+                    removePrefixesFromDocument(documentBuilder);
+                    String prefix = createPrefix(packageName, databaseName);
+                    // The schema type map cannot be null at this point. It could only be null if no
+                    // schema had ever been set for that prefix. Given we have retrieved a document
+                    // from the index, we know a schema had to have been set.
+                    GenericDocument doc =
+                            GenericDocumentToProtoConverter.toGenericDocument(
+                                    documentBuilder.build(), prefix, mSchemaCacheLocked, mConfig);
+
+                    resultBuilder.setSuccess(id, doc);
+                } catch (Throwable t) {
+                    // Global get
+                    if (callerAccess != null) {
+                        // Not passing cause in AppSearchException as that violates privacy
+                        // guarantees as user could differentiate between document not existing
+                        // and not having access.
+                        resultBuilder.setResult(
+                                id,
+                                new AppSearchException(
+                                                AppSearchResult.RESULT_NOT_FOUND,
+                                                "Document ("
+                                                        + request.getNamespace()
+                                                        + ", "
+                                                        + id
+                                                        + ") not found.")
+                                        .toAppSearchResult());
+                    } else {
+                        resultBuilder.setResult(id, throwableToFailedResult(t));
+                    }
+                }
+            }
+
+            return resultBuilder.build();
+        } finally {
+            mReadWriteLock.readLock().unlock();
+        }
+    }
+
+    private GetResultSpecProto createGetResultSpecProto(
+            @NonNull String packageName,
+            @NonNull String databaseName,
+            @NonNull String namespace,
+            @NonNull Map<String, List<String>> typePropertyPaths,
+            @Nullable Set<String> ids) {
+        String prefix = createPrefix(packageName, databaseName);
+        List<TypePropertyMask.Builder> nonPrefixedPropertyMaskBuilders =
+                TypePropertyPathToProtoConverter.toTypePropertyMaskBuilderList(typePropertyPaths);
+        List<TypePropertyMask> prefixedPropertyMasks =
+                new ArrayList<>(nonPrefixedPropertyMaskBuilders.size());
+        for (int i = 0; i < nonPrefixedPropertyMaskBuilders.size(); ++i) {
+            String nonPrefixedType = nonPrefixedPropertyMaskBuilders.get(i).getSchemaType();
+            String prefixedType = nonPrefixedType;
+            if (!nonPrefixedType.equals(GetByDocumentIdRequest.PROJECTION_SCHEMA_TYPE_WILDCARD)) {
+                // Append prefix if it is not a wildcard.
+                prefixedType = prefix + nonPrefixedType;
+            }
+            prefixedPropertyMasks.add(
+                    nonPrefixedPropertyMaskBuilders.get(i).setSchemaType(prefixedType).build());
+        }
+
+        GetResultSpecProto.Builder resultSpecProtoBuilder =
+                GetResultSpecProto.newBuilder()
+                        .setNamespaceRequested(namespace)
+                        .addAllTypePropertyMasks(prefixedPropertyMasks);
+
+        // For old getDocumentProtoByIdLocked, we don't need to set the ids in the request.
+        // So we don't pass the ids in from there.
+        if (ids != null && !ids.isEmpty()) {
+            resultSpecProtoBuilder.addAllIds(ids);
+        }
+
+        return resultSpecProtoBuilder.build();
+    }
+
     /**
      * Returns a DocumentProto from Icing.
      *
@@ -1980,26 +2499,15 @@ public final class AppSearchImpl implements Closeable {
             @NonNull String id,
             @NonNull Map<String, List<String>> typePropertyPaths)
             throws AppSearchException {
-        String prefix = createPrefix(packageName, databaseName);
-        List<TypePropertyMask.Builder> nonPrefixedPropertyMaskBuilders =
-                TypePropertyPathToProtoConverter.toTypePropertyMaskBuilderList(typePropertyPaths);
-        List<TypePropertyMask> prefixedPropertyMasks =
-                new ArrayList<>(nonPrefixedPropertyMaskBuilders.size());
-        for (int i = 0; i < nonPrefixedPropertyMaskBuilders.size(); ++i) {
-            String nonPrefixedType = nonPrefixedPropertyMaskBuilders.get(i).getSchemaType();
-            String prefixedType =
-                    nonPrefixedType.equals(GetByDocumentIdRequest.PROJECTION_SCHEMA_TYPE_WILDCARD)
-                            ? nonPrefixedType
-                            : prefix + nonPrefixedType;
-            prefixedPropertyMasks.add(
-                    nonPrefixedPropertyMaskBuilders.get(i).setSchemaType(prefixedType).build());
-        }
+        String finalNamespace = createPrefix(packageName, databaseName) + namespace;
         GetResultSpecProto getResultSpec =
-                GetResultSpecProto.newBuilder()
-                        .addAllTypePropertyMasks(prefixedPropertyMasks)
-                        .build();
+                createGetResultSpecProto(
+                        packageName,
+                        databaseName,
+                        finalNamespace,
+                        typePropertyPaths,
+                        /* ids= */ null);
 
-        String finalNamespace = createPrefix(packageName, databaseName) + namespace;
         if (LogUtil.isPiiTraceEnabled()) {
             LogUtil.piiTrace(
                     TAG, "getDocument, request", finalNamespace + ", " + id + "," + getResultSpec);
@@ -2012,6 +2520,32 @@ public final class AppSearchImpl implements Closeable {
         return getResultProto.getDocument();
     }
 
+    /*
+     * Returns a BatchGetResultProto from Icing. It contains GetResultProto for each id.
+     */
+    @GuardedBy("mReadWriteLock")
+    @SuppressWarnings("LiteProtoToString")
+    private @NonNull BatchGetResultProto batchGetDocumentProtoByIdLocked(
+            @NonNull String packageName,
+            @NonNull String databaseName,
+            @NonNull GetByDocumentIdRequest request) {
+        String finalNamespace = createPrefix(packageName, databaseName) + request.getNamespace();
+        GetResultSpecProto getResultSpec =
+                createGetResultSpecProto(
+                        packageName,
+                        databaseName,
+                        finalNamespace,
+                        request.getProjections(),
+                        request.getIds());
+
+        LogUtil.piiTrace(TAG, "getDocument, request", getResultSpec);
+        BatchGetResultProto batchGetResultProto = mIcingSearchEngineLocked.batchGet(getResultSpec);
+        LogUtil.piiTrace(
+                TAG, "getDocument, response", batchGetResultProto.getStatus(), batchGetResultProto);
+
+        return batchGetResultProto;
+    }
+
     /**
      * Executes a query against the AppSearch index and returns results.
      *
@@ -2034,10 +2568,10 @@ public final class AppSearchImpl implements Closeable {
             @Nullable AppSearchLogger logger)
             throws AppSearchException {
         long totalLatencyStartMillis = SystemClock.elapsedRealtime();
-        SearchStats.Builder sStatsBuilder = null;
+        QueryStats.Builder sStatsBuilder = null;
         if (logger != null) {
             sStatsBuilder =
-                    new SearchStats.Builder(SearchStats.VISIBILITY_SCOPE_LOCAL, packageName)
+                    new QueryStats.Builder(QueryStats.VISIBILITY_SCOPE_LOCAL, packageName)
                             .setDatabase(databaseName)
                             .setSearchSourceLogTag(searchSpec.getSearchSourceLogTag())
                             .setLaunchVMEnabled(mIsVMEnabled);
@@ -2059,7 +2593,7 @@ public final class AppSearchImpl implements Closeable {
                 // Client wanted to query over some packages that weren't its own. This isn't
                 // allowed through local query so we can return early with no results.
                 if (sStatsBuilder != null && logger != null) {
-                    sStatsBuilder.setStatusCode(AppSearchResult.RESULT_SECURITY_ERROR);
+                    sStatsBuilder.setStatusCode(RESULT_SECURITY_ERROR);
                 }
                 return new SearchResultPage();
             }
@@ -2114,11 +2648,11 @@ public final class AppSearchImpl implements Closeable {
             @Nullable AppSearchLogger logger)
             throws AppSearchException {
         long totalLatencyStartMillis = SystemClock.elapsedRealtime();
-        SearchStats.Builder sStatsBuilder = null;
+        QueryStats.Builder sStatsBuilder = null;
         if (logger != null) {
             sStatsBuilder =
-                    new SearchStats.Builder(
-                                    SearchStats.VISIBILITY_SCOPE_GLOBAL,
+                    new QueryStats.Builder(
+                                    QueryStats.VISIBILITY_SCOPE_GLOBAL,
                                     callerAccess.getCallingPackageName())
                             .setSearchSourceLogTag(searchSpec.getSearchSourceLogTag())
                             .setLaunchVMEnabled(mIsVMEnabled);
@@ -2209,15 +2743,16 @@ public final class AppSearchImpl implements Closeable {
     @GuardedBy("mReadWriteLock")
     private SearchResultPage doQueryLocked(
             @NonNull SearchSpecToProtoConverter searchSpecToProtoConverter,
-            SearchStats.@Nullable Builder sStatsBuilder)
+            QueryStats.@Nullable Builder sStatsBuilder)
             throws AppSearchException {
         // Rewrite the given SearchSpec into SearchSpecProto, ResultSpecProto and ScoringSpecProto.
         // All processes are counted in rewriteSearchSpecLatencyMillis
         long rewriteSearchSpecLatencyStartMillis = SystemClock.elapsedRealtime();
-        SearchSpecProto finalSearchSpec = searchSpecToProtoConverter.toSearchSpecProto();
+        SearchSpecProto finalSearchSpec =
+                searchSpecToProtoConverter.toSearchSpecProto(mIsVMEnabled);
         ResultSpecProto finalResultSpec =
                 searchSpecToProtoConverter.toResultSpecProto(
-                        mNamespaceCacheLocked, mSchemaCacheLocked);
+                        mNamespaceCacheLocked, mSchemaCacheLocked, mIsVMEnabled);
         ScoringSpecProto scoringSpec = searchSpecToProtoConverter.toScoringSpecProto();
         if (sStatsBuilder != null) {
             sStatsBuilder.setRewriteSearchSpecLatencyMillis(
@@ -2247,7 +2782,7 @@ public final class AppSearchImpl implements Closeable {
             @NonNull SearchSpecProto searchSpec,
             @NonNull ResultSpecProto resultSpec,
             @NonNull ScoringSpecProto scoringSpec,
-            SearchStats.@Nullable Builder sStatsBuilder)
+            QueryStats.@Nullable Builder sStatsBuilder)
             throws AppSearchException {
         if (LogUtil.isPiiTraceEnabled()) {
             LogUtil.piiTrace(
@@ -2260,18 +2795,89 @@ public final class AppSearchImpl implements Closeable {
                 mIcingSearchEngineLocked.search(searchSpec, scoringSpec, resultSpec);
         LogUtil.piiTrace(
                 TAG, "search, response", searchResultProto.getResultsCount(), searchResultProto);
+
+        long nextPageToken = searchResultProto.getNextPageToken();
+        int additionalPagesRetrievalLatency = 0;
+        int numAdditionalPages = 0;
+        int totalAdditionalResults = 0;
+        if (nextPageToken != SearchResultPage.EMPTY_PAGE_TOKEN
+                && searchResultProto.getResultsCount() > 0
+                && searchResultProto.getResultsCount() < resultSpec.getNumPerPage()) {
+            long additionalPageRetrievalLatencyStartMillis = SystemClock.elapsedRealtime();
+            // Did not get a full page of results in the initial search. Do getNextPage until we
+            // get a full result page or we run out of results.
+            SearchResultProto.Builder finalSearchResultProtoBuilder =
+                    SearchResultProto.newBuilder(searchResultProto);
+
+            int remainingResultCount =
+                    resultSpec.getNumPerPage() - searchResultProto.getResultsCount();
+            while (nextPageToken != SearchResultPage.EMPTY_PAGE_TOKEN && remainingResultCount > 0) {
+                GetNextPageRequestProto getNextPageRequest =
+                        GetNextPageRequestProto.newBuilder()
+                                .setNextPageToken(nextPageToken)
+                                .setMaxResultsToRetrieveFromPage(remainingResultCount)
+                                .build();
+                LogUtil.piiTrace(TAG, "getNextPage, request", getNextPageRequest);
+                SearchResultProto nextResultPageProto =
+                        mIcingSearchEngineLocked.getNextPage(getNextPageRequest);
+                LogUtil.piiTrace(
+                        TAG,
+                        "getNextPage, response",
+                        nextResultPageProto.getResultsCount(),
+                        nextResultPageProto);
+                checkSuccess(nextResultPageProto.getStatus());
+
+                ++numAdditionalPages;
+                nextPageToken = nextResultPageProto.getNextPageToken();
+                mergeSearchResultProtos(nextResultPageProto, finalSearchResultProtoBuilder);
+                if (nextResultPageProto.getResultsCount() == 0) {
+                    Log.e(
+                            TAG,
+                            "Got additional page with 0 results during search. This should"
+                                    + " never happen normally. GetNextPage status code: "
+                                    + nextResultPageProto.getStatus().getCode());
+                    break;
+                }
+                totalAdditionalResults += nextResultPageProto.getResultsCount();
+                remainingResultCount -= nextResultPageProto.getResultsCount();
+            }
+            searchResultProto = finalSearchResultProtoBuilder.build();
+            additionalPagesRetrievalLatency =
+                    (int)
+                            (SystemClock.elapsedRealtime()
+                                    - additionalPageRetrievalLatencyStartMillis);
+        }
+
         if (sStatsBuilder != null) {
             sStatsBuilder.setStatusCode(statusProtoToResultCode(searchResultProto.getStatus()));
             if (searchSpec.hasJoinSpec()) {
                 sStatsBuilder.setJoinType(
                         AppSearchSchema.StringPropertyConfig.JOINABLE_VALUE_TYPE_QUALIFIED_ID);
             }
+            // TODO(b/421230879): Restructure QueryStats to record full stats for GetNextPage calls.
+            sStatsBuilder.setAdditionalPageCount(numAdditionalPages);
+            sStatsBuilder.setAdditionalPagesReturnedResultCount(totalAdditionalResults);
+            sStatsBuilder.setAdditionalPageRetrievalLatencyMillis(additionalPagesRetrievalLatency);
             AppSearchLoggerHelper.copyNativeStats(searchResultProto.getQueryStats(), sStatsBuilder);
         }
         checkSuccess(searchResultProto.getStatus());
         return searchResultProto;
     }
 
+    /**
+     * Merges the results from {@code searchResultProto} into the {@code
+     * finalSearchResultProtoBuilder}.
+     */
+    private void mergeSearchResultProtos(
+            @NonNull SearchResultProto searchResultProto,
+            SearchResultProto.@NonNull Builder finalSearchResultProtoBuilder) {
+        finalSearchResultProtoBuilder
+                .setStatus(searchResultProto.getStatus())
+                .addAllResults(searchResultProto.getResultsList())
+                .setNextPageToken(searchResultProto.getNextPageToken())
+                .setPageTokenNotFound(searchResultProto.getPageTokenNotFound());
+    }
+
     /**
      * Generates suggestions based on the given search prefix.
      *
@@ -2282,8 +2888,8 @@ public final class AppSearchImpl implements Closeable {
      * @param suggestionQueryExpression The non-empty query expression used to be completed.
      * @param searchSuggestionSpec Spec for setting filters.
      * @return a List of {@link SearchSuggestionResult}. The returned {@link SearchSuggestionResult}
-     *     are order by the number of {@link android.app.appsearch.SearchResult} you could get by
-     *     using that suggestion in {@link #query}.
+     *     are order by the number of {@link SearchResult} you could get by using that suggestion in
+     *     {@link #query}.
      * @throws AppSearchException if the suggestionQueryExpression is empty.
      */
     public @NonNull List<SearchSuggestionResult> searchSuggestion(
@@ -2385,7 +2991,7 @@ public final class AppSearchImpl implements Closeable {
     public @NonNull SearchResultPage getNextPage(
             @NonNull String packageName,
             long nextPageToken,
-            SearchStats.@Nullable Builder sStatsBuilder)
+            QueryStats.@Nullable Builder sStatsBuilder)
             throws AppSearchException {
         long totalLatencyStartMillis = SystemClock.elapsedRealtime();
 
@@ -2404,15 +3010,29 @@ public final class AppSearchImpl implements Closeable {
 
             LogUtil.piiTrace(TAG, "getNextPage, request", nextPageToken);
             checkNextPageToken(packageName, nextPageToken);
-            SearchResultProto searchResultProto =
-                    mIcingSearchEngineLocked.getNextPage(nextPageToken);
+            SearchResultProto searchResultProto;
+            if (nextPageToken != SearchResultPage.EMPTY_PAGE_TOKEN) {
+                searchResultProto = mIcingSearchEngineLocked.getNextPage(nextPageToken);
+            } else {
+                // If it is an empty page token, then avoid sending it to Icing to save a JNI call.
+                searchResultProto =
+                        SearchResultProto.newBuilder()
+                                .setStatus(
+                                        StatusProto.newBuilder()
+                                                .setCode(StatusProto.Code.OK)
+                                                .build())
+                                .setNextPageToken(SearchResultPage.EMPTY_PAGE_TOKEN)
+                                .build();
+            }
 
             if (sStatsBuilder != null) {
                 sStatsBuilder.setStatusCode(statusProtoToResultCode(searchResultProto.getStatus()));
                 // Join query stats are handled by SearchResultsImpl, which has access to the
                 // original SearchSpec.
-                AppSearchLoggerHelper.copyNativeStats(
-                        searchResultProto.getQueryStats(), sStatsBuilder);
+                if (nextPageToken != SearchResultPage.EMPTY_PAGE_TOKEN) {
+                    AppSearchLoggerHelper.copyNativeStats(
+                            searchResultProto.getQueryStats(), sStatsBuilder);
+                }
             }
 
             LogUtil.piiTrace(
@@ -2421,8 +3041,8 @@ public final class AppSearchImpl implements Closeable {
                     searchResultProto.getResultsCount(),
                     searchResultProto);
             checkSuccess(searchResultProto.getStatus());
-            if (nextPageToken != EMPTY_PAGE_TOKEN
-                    && searchResultProto.getNextPageToken() == EMPTY_PAGE_TOKEN) {
+            if (nextPageToken != SearchResultPage.EMPTY_PAGE_TOKEN
+                    && searchResultProto.getNextPageToken() == SearchResultPage.EMPTY_PAGE_TOKEN) {
                 // At this point, we're guaranteed that this nextPageToken exists for this package,
                 // otherwise checkNextPageToken would've thrown an exception.
                 // Since the new token is 0, this is the last page. We should remove the old token
@@ -2433,6 +3053,18 @@ public final class AppSearchImpl implements Closeable {
                     nextPageTokensForPackage.remove(nextPageToken);
                 }
             }
+
+            // In normal use case, the page token is guaranteed to be valid, so if page token not
+            // found flag is true, then it is mostly caused by pagination cache eviction. Therefore,
+            // throw an exception indicating that the search and pagination is aborted.
+            if (Flags.enableResultAborted()
+                    && Flags.enableThrowExceptionForNativeNotFoundPageToken()
+                    && searchResultProto.getPageTokenNotFound()) {
+                throw new AppSearchException(
+                        AppSearchResult.RESULT_ABORTED,
+                        "Page token not found. It is usually caused by pagination cache eviction.");
+            }
+
             long rewriteSearchResultLatencyStartMillis = SystemClock.elapsedRealtime();
             // Rewrite search result before we return.
             SearchResultPage searchResultPage =
@@ -2466,7 +3098,7 @@ public final class AppSearchImpl implements Closeable {
      */
     public void invalidateNextPageToken(@NonNull String packageName, long nextPageToken)
             throws AppSearchException {
-        if (nextPageToken == EMPTY_PAGE_TOKEN) {
+        if (nextPageToken == SearchResultPage.EMPTY_PAGE_TOKEN) {
             // (b/208305352) Directly return here since we are no longer caching EMPTY_PAGE_TOKEN
             // in the cached token set. So no need to remove it anymore.
             return;
@@ -2573,7 +3205,7 @@ public final class AppSearchImpl implements Closeable {
                                 prefixedNamespace, documentId, GET_RESULT_SPEC_NO_PROPERTIES);
                 LogUtil.piiTrace(TAG, "removeById, getResponse", getResult.getStatus(), getResult);
                 checkSuccess(getResult.getStatus());
-                schemaType = PrefixUtil.removePrefix(getResult.getDocument().getSchema());
+                schemaType = removePrefix(getResult.getDocument().getSchema());
             }
 
             if (LogUtil.isPiiTraceEnabled()) {
@@ -2678,7 +3310,8 @@ public final class AppSearchImpl implements Closeable {
                 return;
             }
 
-            SearchSpecProto finalSearchSpec = searchSpecToProtoConverter.toSearchSpecProto();
+            SearchSpecProto finalSearchSpec =
+                    searchSpecToProtoConverter.toSearchSpecProto(mIsVMEnabled);
 
             Set<String> prefixedObservedSchemas = null;
             if (mObserverManager.isPackageObserved(packageName)) {
@@ -2686,7 +3319,7 @@ public final class AppSearchImpl implements Closeable {
                 List<String> prefixedTargetSchemaTypes = finalSearchSpec.getSchemaTypeFiltersList();
                 for (int i = 0; i < prefixedTargetSchemaTypes.size(); i++) {
                     String prefixedType = prefixedTargetSchemaTypes.get(i);
-                    String shortTypeName = PrefixUtil.removePrefix(prefixedType);
+                    String shortTypeName = removePrefix(prefixedType);
                     if (mObserverManager.isSchemaTypeObserved(packageName, shortTypeName)) {
                         prefixedObservedSchemas.add(prefixedType);
                     }
@@ -2769,9 +3402,9 @@ public final class AppSearchImpl implements Closeable {
             if (!prefixedObservedSchemas.contains(group.getSchema())) {
                 continue;
             }
-            String databaseName = PrefixUtil.getDatabaseName(group.getNamespace());
-            String namespace = PrefixUtil.removePrefix(group.getNamespace());
-            String schemaType = PrefixUtil.removePrefix(group.getSchema());
+            String databaseName = getDatabaseName(group.getNamespace());
+            String namespace = removePrefix(group.getNamespace());
+            String schemaType = removePrefix(group.getSchema());
             for (int j = 0; j < group.getUrisCount(); ++j) {
                 String uri = group.getUris(j);
                 mObserverManager.onDocumentChange(
@@ -2892,6 +3525,27 @@ public final class AppSearchImpl implements Closeable {
         }
     }
 
+    /** Get {@link GetSchemaResponse} for a given visibility database. */
+    @NonNull
+    public GetSchemaResponse getVisibilitySchema(@NonNull String prefix) throws AppSearchException {
+        mReadWriteLock.readLock().lock();
+        try {
+            GetSchemaResponse.Builder responseBuilder = new GetSchemaResponse.Builder();
+            Map<String, SchemaTypeConfigProto> visibilitySchemaProto =
+                    mSchemaCacheLocked.getSchemaMapForPrefix(prefix);
+            for (SchemaTypeConfigProto typeConfig : visibilitySchemaProto.values()) {
+                SchemaTypeConfigProto.Builder typeConfigBuilder = typeConfig.toBuilder();
+                removePrefixesFromSchemaType(typeConfigBuilder);
+                responseBuilder.setVersion(typeConfig.getVersion());
+                responseBuilder.addSchema(
+                        SchemaToProtoConverter.toAppSearchSchema(typeConfigBuilder));
+            }
+            return responseBuilder.build();
+        } finally {
+            mReadWriteLock.readLock().unlock();
+        }
+    }
+
     /**
      * Extracts and returns {@link StorageInfo} from {@link StorageInfoProto} based on prefixed
      * namespaces.
@@ -3132,38 +3786,55 @@ public final class AppSearchImpl implements Closeable {
                 return;
             }
 
-            // Prune schema proto
-            SchemaProto existingSchema = getSchemaProtoLocked();
-            SchemaProto.Builder newSchemaBuilder = SchemaProto.newBuilder();
-            for (int i = 0; i < existingSchema.getTypesCount(); i++) {
-                String packageName = getPackageName(existingSchema.getTypes(i).getSchemaType());
-                if (installedPackages.contains(packageName)) {
-                    newSchemaBuilder.addTypes(existingSchema.getTypes(i));
+            // Prune schema proto and delete documents
+            boolean successfullyDeletedData = false;
+            if (useDatabaseScopedSchemaOperations()) {
+                Set<String> databasesToDelete = new ArraySet<>();
+                Set<String> allSchemaPrefixes = mSchemaCacheLocked.getAllPrefixes();
+                for (String prefix : allSchemaPrefixes) {
+                    String packageName = getPackageName(prefix);
+                    if (!installedPackages.contains(packageName)) {
+                        databasesToDelete.add(prefix);
+                    }
                 }
-            }
 
-            SchemaProto finalSchema = newSchemaBuilder.build();
+                if (databasesToDelete.size() < PRUNE_PACKAGE_USING_FULL_SET_SCHEMA_THRESHOLD) {
+                    // Use database-scoped set schema request to prune the schemas and documents
+                    // a single database at a time.
+                    for (String database : databasesToDelete) {
+                        // Apply an empty schema and set force override to true to remove all
+                        // schemas and documents that don't belong to any of the installed packages.
+                        SetSchemaRequestProto emptySetSchemaRequestProto =
+                                SetSchemaRequestProto.newBuilder()
+                                        .setSchema(SchemaProto.newBuilder().build())
+                                        .setDatabase(database)
+                                        .setIgnoreErrorsAndDeleteDocuments(true)
+                                        .build();
+                        LogUtil.piiTrace(
+                                TAG,
+                                "clearPackageData.setSchema for database, request",
+                                emptySetSchemaRequestProto);
+                        SetSchemaResultProto setSchemaResultProto =
+                                mIcingSearchEngineLocked.setSchemaWithRequestProto(
+                                        emptySetSchemaRequestProto);
+                        LogUtil.piiTrace(
+                                TAG,
+                                "clearPackageData.setSchema, response",
+                                setSchemaResultProto.getStatus(),
+                                setSchemaResultProto);
 
-            // Apply schema, set force override to true to remove all schemas and documents that
-            // doesn't belong to any of these installed packages.
-            LogUtil.piiTrace(
-                    TAG,
-                    "clearPackageData.setSchema, request",
-                    finalSchema.getTypesCount(),
-                    finalSchema);
-            SetSchemaResultProto setSchemaResultProto =
-                    mIcingSearchEngineLocked.setSchema(
-                            finalSchema, /* ignoreErrorsAndDeleteDocuments= */ true);
-            LogUtil.piiTrace(
-                    TAG,
-                    "clearPackageData.setSchema, response",
-                    setSchemaResultProto.getStatus(),
-                    setSchemaResultProto);
+                        // Determine whether it succeeded.
+                        checkSuccess(setSchemaResultProto.getStatus());
+                    }
+                    successfullyDeletedData = true;
+                }
+            }
 
-            // Determine whether it succeeded.
-            checkSuccess(setSchemaResultProto.getStatus());
+            if (!successfullyDeletedData) {
+                prunePackageDataUsingFullSetSchemaLocked(installedPackages);
+            }
 
-            // Prune cached maps
+            // Prune cached maps once schema and documents have been successfully deleted
             for (Map.Entry<String, Set<String>> entry : packageToDatabases.entrySet()) {
                 String packageName = entry.getKey();
                 Set<String> databaseNames = entry.getValue();
@@ -3188,6 +3859,47 @@ public final class AppSearchImpl implements Closeable {
         }
     }
 
+    /**
+     * Remove all {@link AppSearchSchema}s and {@link GenericDocument}s that doesn't belong to any
+     * of the given installed packages by resetting the full schema for the remaining installed
+     * packages.
+     *
+     * @param installedPackages The name of all installed package.
+     * @throws AppSearchException if we cannot remove the data.
+     */
+    private void prunePackageDataUsingFullSetSchemaLocked(@NonNull Set<String> installedPackages)
+            throws AppSearchException {
+        SchemaProto existingSchema = getSchemaProtoLocked();
+        SchemaProto.Builder newSchemaBuilder = SchemaProto.newBuilder();
+        for (int i = 0; i < existingSchema.getTypesCount(); i++) {
+            String packageName = getPackageName(existingSchema.getTypes(i).getSchemaType());
+            if (installedPackages.contains(packageName)) {
+                newSchemaBuilder.addTypes(existingSchema.getTypes(i));
+            }
+        }
+
+        SchemaProto finalSchema = newSchemaBuilder.build();
+
+        // Apply schema, set force override to true to remove all schemas and documents that
+        // doesn't belong to any of these installed packages.
+        LogUtil.piiTrace(
+                TAG,
+                "clearPackageData.setSchema, request",
+                finalSchema.getTypesCount(),
+                finalSchema);
+        SetSchemaResultProto setSchemaResultProto =
+                mIcingSearchEngineLocked.setSchema(
+                        finalSchema, /* ignoreErrorsAndDeleteDocuments= */ true);
+        LogUtil.piiTrace(
+                TAG,
+                "clearPackageData.setSchema, response",
+                setSchemaResultProto.getStatus(),
+                setSchemaResultProto);
+
+        // Determine whether it succeeded.
+        checkSuccess(setSchemaResultProto.getStatus());
+    }
+
     /**
      * Clears documents and schema across all packages and databaseNames.
      *
@@ -3224,6 +3936,10 @@ public final class AppSearchImpl implements Closeable {
             initStatsBuilder
                     .setHasReset(true)
                     .setResetStatusCode(statusProtoToResultCode(resetResultProto.getStatus()));
+            Log.i(
+                    TAG,
+                    "IcingSearchEngine Reset returned with status: "
+                            + resetResultProto.getStatus());
         }
 
         checkSuccess(resetResultProto.getStatus());
@@ -3233,6 +3949,8 @@ public final class AppSearchImpl implements Closeable {
     @VisibleForTesting
     static class RewrittenSchemaResults {
         // Any prefixed types that used to exist in the schema, but are deleted in the new one.
+        // This set will be empty if rewrittenSchema is called with database-scoped schema
+        // operations enabled.
         final Set<String> mDeletedPrefixedTypes = new ArraySet<>();
 
         // Map of prefixed schema types to SchemaTypeConfigProtos that were part of the new schema.
@@ -3240,13 +3958,16 @@ public final class AppSearchImpl implements Closeable {
     }
 
     /**
-     * Rewrites all types mentioned in the given {@code newSchema} to prepend {@code prefix}.
-     * Rewritten types will be added to the {@code existingSchema}.
+     * Rewrites all types mentioned in the given {@code newSchema}.
+     *
+     * <p>Rewritten types will be added to the {@code existingSchema}.
      *
      * @param prefix The full prefix to prepend to the schema.
-     * @param existingSchema A schema that may contain existing types from across all prefixes. Will
-     *     be mutated to contain the properly rewritten schema types from {@code newSchema}.
+     * @param existingSchema A schema that may contain existing types from across all prefixes (only
+     *     if database-scoped schema operations is disabled). Will be mutated to contain the
+     *     properly rewritten schema types from {@code newSchema}.
      * @param newSchema Schema with types to add to the {@code existingSchema}.
+     * @param populateDatabase Whether to populate the database field in the rewritten schema.
      * @return a RewrittenSchemaResults that contains all prefixed schema type names in the given
      *     prefix as well as a set of schema types that were deleted.
      */
@@ -3254,17 +3975,65 @@ public final class AppSearchImpl implements Closeable {
     static RewrittenSchemaResults rewriteSchema(
             @NonNull String prefix,
             SchemaProto.@NonNull Builder existingSchema,
-            @NonNull SchemaProto newSchema)
+            @NonNull SchemaProto newSchema,
+            boolean populateDatabase)
+            throws AppSearchException {
+        Map<String, SchemaTypeConfigProto> newTypesToProto =
+                getRewrittenPrefixedTypes(prefix, newSchema, populateDatabase);
+
+        // newTypesToProto is modified below, so we need a copy first
+        RewrittenSchemaResults rewrittenSchemaResults = new RewrittenSchemaResults();
+        rewrittenSchemaResults.mRewrittenPrefixedTypes.putAll(newTypesToProto);
+
+        // Combine the existing schema (which may have types from other prefixes if
+        // database-scoped schema operations is disabled) with this prefix's new schema. Modifies
+        // the existingSchemaBuilder.
+        // Check if we need to replace any old schema types with the new ones.
+        for (int i = 0; i < existingSchema.getTypesCount(); i++) {
+            String schemaType = existingSchema.getTypes(i).getSchemaType();
+            SchemaTypeConfigProto newProto = newTypesToProto.remove(schemaType);
+            if (newProto != null) {
+                // Replacement
+                existingSchema.setTypes(i, newProto);
+            } else if (prefix.equals(getPrefix(schemaType))) {
+                // All types existing before but not in newSchema should be removed.
+                existingSchema.removeTypes(i);
+                --i;
+                rewrittenSchemaResults.mDeletedPrefixedTypes.add(schemaType);
+            }
+        }
+        // We've been removing existing types from newTypesToProto, so everything that remains is
+        // new.
+        existingSchema.addAllTypes(newTypesToProto.values());
+
+        return rewrittenSchemaResults;
+    }
+
+    /**
+     * Rewrites all types in the given {@code schema}. The rewrite prepends {@code prefix} to the
+     * schema types, and also populates the schema's database field accordingly.
+     *
+     * @param prefix The full prefix to prepend to the schema.
+     * @param newSchema Schema with types to rewrite.
+     * @param populateDatabase Whether to populate the database field in the rewritten schema
+     * @return a map containing the rewritten schema type names and their corresponding rewritten
+     *     protos.
+     */
+    static Map<String, SchemaTypeConfigProto> getRewrittenPrefixedTypes(
+            @NonNull String prefix, @NonNull SchemaProto newSchema, boolean populateDatabase)
             throws AppSearchException {
-        HashMap<String, SchemaTypeConfigProto> newTypesToProto = new HashMap<>();
+        Map<String, SchemaTypeConfigProto> newTypesToProto = new ArrayMap<>();
         // Rewrite the schema type to include the typePrefix.
         for (int typeIdx = 0; typeIdx < newSchema.getTypesCount(); typeIdx++) {
             SchemaTypeConfigProto.Builder typeConfigBuilder =
                     newSchema.getTypes(typeIdx).toBuilder();
 
-            // Rewrite SchemaProto.types.schema_type
+            // Rewrite SchemaProto.types.schema_type and populate SchemaProto.types.database
             String newSchemaType = prefix + typeConfigBuilder.getSchemaType();
             typeConfigBuilder.setSchemaType(newSchemaType);
+            if (populateDatabase) {
+                typeConfigBuilder.setDatabase(prefix);
+            }
 
             // Rewrite SchemaProto.types.properties.schema_type
             for (int propertyIdx = 0;
@@ -3289,32 +4058,7 @@ public final class AppSearchImpl implements Closeable {
 
             newTypesToProto.put(newSchemaType, typeConfigBuilder.build());
         }
-
-        // newTypesToProto is modified below, so we need a copy first
-        RewrittenSchemaResults rewrittenSchemaResults = new RewrittenSchemaResults();
-        rewrittenSchemaResults.mRewrittenPrefixedTypes.putAll(newTypesToProto);
-
-        // Combine the existing schema (which may have types from other prefixes) with this
-        // prefix's new schema. Modifies the existingSchemaBuilder.
-        // Check if we need to replace any old schema types with the new ones.
-        for (int i = 0; i < existingSchema.getTypesCount(); i++) {
-            String schemaType = existingSchema.getTypes(i).getSchemaType();
-            SchemaTypeConfigProto newProto = newTypesToProto.remove(schemaType);
-            if (newProto != null) {
-                // Replacement
-                existingSchema.setTypes(i, newProto);
-            } else if (prefix.equals(getPrefix(schemaType))) {
-                // All types existing before but not in newSchema should be removed.
-                existingSchema.removeTypes(i);
-                --i;
-                rewrittenSchemaResults.mDeletedPrefixedTypes.add(schemaType);
-            }
-        }
-        // We've been removing existing types from newTypesToProto, so everything that remains is
-        // new.
-        existingSchema.addAllTypes(newTypesToProto.values());
-
-        return rewrittenSchemaResults;
+        return newTypesToProto;
     }
 
     /**
@@ -3355,6 +4099,10 @@ public final class AppSearchImpl implements Closeable {
         return prefixedVisibilityConfigs;
     }
 
+    /**
+     * Retrieves the full SchemaProto stored in IcingLib. The returned SchemaProto contains types
+     * across all prefixes.
+     */
     @VisibleForTesting
     @GuardedBy("mReadWriteLock")
     SchemaProto getSchemaProtoLocked() throws AppSearchException {
@@ -3367,8 +4115,29 @@ public final class AppSearchImpl implements Closeable {
         return schemaProto.getSchema();
     }
 
+    /**
+     * Retrieves the SchemaProto from IcingLib for the specified prefix. The returned SchemaProto
+     * will only contain types for the matching the schema database prefix.
+     *
+     * <p>Requires {@link #useDatabaseScopedSchemaOperations()} to be true. {@link
+     * #getSchemaProtoLocked()} should be used instead when {@link
+     * #useDatabaseScopedSchemaOperations()} is false or when the entire schema is needed.
+     *
+     * @param prefix The full prefix for which to retrieve the schema.
+     */
+    @VisibleForTesting
+    @GuardedBy("mReadWriteLock")
+    SchemaProto getSchemaProtoForPrefixLocked(@NonNull String prefix) throws AppSearchException {
+        LogUtil.piiTrace(TAG, "getSchemaForDatabase, request", prefix);
+        GetSchemaResultProto schemaProto = mIcingSearchEngineLocked.getSchemaForDatabase(prefix);
+        LogUtil.piiTrace(
+                TAG, "getSchemaForDatabase, response", schemaProto.getStatus(), schemaProto);
+        checkCodeOneOf(schemaProto.getStatus(), StatusProto.Code.OK, StatusProto.Code.NOT_FOUND);
+        return schemaProto.getSchema();
+    }
+
     private void addNextPageToken(String packageName, long nextPageToken) {
-        if (nextPageToken == EMPTY_PAGE_TOKEN) {
+        if (nextPageToken == SearchResultPage.EMPTY_PAGE_TOKEN) {
             // There is no more pages. No need to add it.
             return;
         }
@@ -3384,7 +4153,7 @@ public final class AppSearchImpl implements Closeable {
 
     private void checkNextPageToken(String packageName, long nextPageToken)
             throws AppSearchException {
-        if (nextPageToken == EMPTY_PAGE_TOKEN) {
+        if (nextPageToken == SearchResultPage.EMPTY_PAGE_TOKEN) {
             // Swallow the check for empty page token, token = 0 means there is no more page and it
             // won't return anything from Icing.
             return;
@@ -3486,23 +4255,32 @@ public final class AppSearchImpl implements Closeable {
      */
     private static void checkCodeOneOf(StatusProto statusProto, StatusProto.Code... codes)
             throws AppSearchException {
+        if (!isCodeOneOf(statusProto, codes)) {
+            throw new AppSearchException(
+                    ResultCodeToProtoConverter.toResultCode(statusProto.getCode()),
+                    statusProto.getMessage());
+        }
+    }
+
+    /** Returns true if the status is OK or WARNING_DATA_LOSS, false otherwise. */
+    private static boolean isSuccess(StatusProto statusProto) {
+        return isCodeOneOf(statusProto, StatusProto.Code.OK);
+    }
+
+    /** Returns true if the status is one of codes or WARNING_DATA_LOSS, false otherwise. */
+    private static boolean isCodeOneOf(StatusProto statusProto, StatusProto.Code... codes) {
         for (int i = 0; i < codes.length; i++) {
             if (codes[i] == statusProto.getCode()) {
-                // Everything's good
-                return;
+                return true;
             }
         }
-
         if (statusProto.getCode() == StatusProto.Code.WARNING_DATA_LOSS) {
             // TODO: May want to propagate WARNING_DATA_LOSS up to AppSearchSession so they can
             //  choose to log the error or potentially pass it on to clients.
             Log.w(TAG, "Encountered WARNING_DATA_LOSS: " + statusProto.getMessage());
-            return;
+            return true;
         }
-
-        throw new AppSearchException(
-                ResultCodeToProtoConverter.toResultCode(statusProto.getCode()),
-                statusProto.getMessage());
+        return false;
     }
 
     /**
@@ -3706,4 +4484,35 @@ public final class AppSearchImpl implements Closeable {
                             + blobHandle.getDatabaseName());
         }
     }
+
+    /** Calls getSchema in a thread safe manner. */
+    public SchemaProto rawGetSchema() {
+        mReadWriteLock.readLock().lock();
+        try {
+            return mIcingSearchEngineLocked.getSchema().getSchema();
+        } finally {
+            mReadWriteLock.readLock().unlock();
+        }
+    }
+
+    /** Calls search in a thread safe manner. */
+    public SearchResultProto rawSearch(
+            SearchSpecProto spec, ScoringSpecProto scoringSpec, ResultSpecProto resultSpec) {
+        mReadWriteLock.readLock().lock();
+        try {
+            return mIcingSearchEngineLocked.search(spec, scoringSpec, resultSpec);
+        } finally {
+            mReadWriteLock.readLock().unlock();
+        }
+    }
+
+    /** Calls getSchema in a thread safe manner. */
+    public SearchResultProto rawGetNextPage(long nextPageToken) {
+        mReadWriteLock.readLock().lock();
+        try {
+            return mIcingSearchEngineLocked.getNextPage(nextPageToken);
+        } finally {
+            mReadWriteLock.readLock().unlock();
+        }
+    }
 }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/AppSearchLogger.java b/service/java/com/android/server/appsearch/external/localstorage/AppSearchLogger.java
index f876ae15..f4d75040 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/AppSearchLogger.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/AppSearchLogger.java
@@ -22,9 +22,9 @@ import com.android.server.appsearch.external.localstorage.stats.CallStats;
 import com.android.server.appsearch.external.localstorage.stats.InitializeStats;
 import com.android.server.appsearch.external.localstorage.stats.OptimizeStats;
 import com.android.server.appsearch.external.localstorage.stats.PutDocumentStats;
+import com.android.server.appsearch.external.localstorage.stats.QueryStats;
 import com.android.server.appsearch.external.localstorage.stats.RemoveStats;
 import com.android.server.appsearch.external.localstorage.stats.SearchSessionStats;
-import com.android.server.appsearch.external.localstorage.stats.SearchStats;
 import com.android.server.appsearch.external.localstorage.stats.SetSchemaStats;
 
 import org.jspecify.annotations.NonNull;
@@ -57,8 +57,8 @@ public interface AppSearchLogger {
         // no-op
     }
 
-    /** Logs {@link SearchStats} */
-    default void logStats(@NonNull SearchStats stats) {
+    /** Logs {@link QueryStats} */
+    default void logStats(@NonNull QueryStats stats) {
         // no-op
     }
 
diff --git a/service/java/com/android/server/appsearch/external/localstorage/AppSearchLoggerHelper.java b/service/java/com/android/server/appsearch/external/localstorage/AppSearchLoggerHelper.java
index 422f616d..498dd6a2 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/AppSearchLoggerHelper.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/AppSearchLoggerHelper.java
@@ -19,6 +19,7 @@ package com.android.server.appsearch.external.localstorage;
 import com.android.server.appsearch.external.localstorage.stats.InitializeStats;
 import com.android.server.appsearch.external.localstorage.stats.OptimizeStats;
 import com.android.server.appsearch.external.localstorage.stats.PutDocumentStats;
+import com.android.server.appsearch.external.localstorage.stats.QueryStats;
 import com.android.server.appsearch.external.localstorage.stats.RemoveStats;
 import com.android.server.appsearch.external.localstorage.stats.SearchStats;
 import com.android.server.appsearch.external.localstorage.stats.SetSchemaStats;
@@ -68,7 +69,9 @@ public final class AppSearchLoggerHelper {
                 .setNativeIntegerIndexLatencyMillis(fromNativeStats.getIntegerIndexLatencyMs())
                 .setNativeQualifiedIdJoinIndexLatencyMillis(
                         fromNativeStats.getQualifiedIdJoinIndexLatencyMs())
-                .setNativeLiteIndexSortLatencyMillis(fromNativeStats.getLiteIndexSortLatencyMs());
+                .setNativeLiteIndexSortLatencyMillis(fromNativeStats.getLiteIndexSortLatencyMs())
+                .setMetadataTermIndexLatencyMillis(fromNativeStats.getMetadataTermIndexLatencyMs())
+                .setEmbeddingIndexLatencyMillis(fromNativeStats.getEmbeddingIndexLatencyMs());
     }
 
     /**
@@ -84,20 +87,33 @@ public final class AppSearchLoggerHelper {
         Objects.requireNonNull(toStatsBuilder);
         toStatsBuilder
                 .setNativeLatencyMillis(fromNativeStats.getLatencyMs())
-                .setDocumentStoreRecoveryCause(
+                .setNativeDocumentStoreRecoveryCause(
                         fromNativeStats.getDocumentStoreRecoveryCause().getNumber())
-                .setIndexRestorationCause(fromNativeStats.getIndexRestorationCause().getNumber())
-                .setSchemaStoreRecoveryCause(
+                .setNativeIndexRestorationCause(
+                        fromNativeStats.getIndexRestorationCause().getNumber())
+                .setNativeSchemaStoreRecoveryCause(
                         fromNativeStats.getSchemaStoreRecoveryCause().getNumber())
-                .setDocumentStoreRecoveryLatencyMillis(
+                .setNativeDocumentStoreRecoveryLatencyMillis(
                         fromNativeStats.getDocumentStoreRecoveryLatencyMs())
-                .setIndexRestorationLatencyMillis(fromNativeStats.getIndexRestorationLatencyMs())
-                .setSchemaStoreRecoveryLatencyMillis(
+                .setNativeIndexRestorationLatencyMillis(
+                        fromNativeStats.getIndexRestorationLatencyMs())
+                .setNativeSchemaStoreRecoveryLatencyMillis(
                         fromNativeStats.getSchemaStoreRecoveryLatencyMs())
-                .setDocumentStoreDataStatus(
+                .setNativeDocumentStoreDataStatus(
                         fromNativeStats.getDocumentStoreDataStatus().getNumber())
-                .setDocumentCount(fromNativeStats.getNumDocuments())
-                .setSchemaTypeCount(fromNativeStats.getNumSchemaTypes());
+                .setNativeDocumentCount(fromNativeStats.getNumDocuments())
+                .setNativeSchemaTypeCount(fromNativeStats.getNumSchemaTypes())
+                .setNativeNumPreviousInitFailures(fromNativeStats.getNumPreviousInitFailures())
+                .setNativeIntegerIndexRestorationCause(
+                        fromNativeStats.getIntegerIndexRestorationCause().getNumber())
+                .setNativeQualifiedIdJoinIndexRestorationCause(
+                        fromNativeStats.getQualifiedIdJoinIndexRestorationCause().getNumber())
+                .setNativeEmbeddingIndexRestorationCause(
+                        fromNativeStats.getEmbeddingIndexRestorationCause().getNumber())
+                .setNativeInitializeIcuDataStatusCode(
+                        fromNativeStats.getInitializeIcuDataStatus().getCode().getNumber())
+                .setNativeNumFailedReindexedDocuments(
+                        fromNativeStats.getNumFailedReindexedDocuments());
     }
 
     /**
@@ -107,33 +123,63 @@ public final class AppSearchLoggerHelper {
      * @param toStatsBuilder Stats copied to.
      */
     static void copyNativeStats(
-            @NonNull QueryStatsProto fromNativeStats, SearchStats.@NonNull Builder toStatsBuilder) {
+            @NonNull QueryStatsProto fromNativeStats, QueryStats.@NonNull Builder toStatsBuilder) {
         Objects.requireNonNull(fromNativeStats);
         Objects.requireNonNull(toStatsBuilder);
         toStatsBuilder
-                .setNativeLatencyMillis(fromNativeStats.getLatencyMs())
-                .setTermCount(fromNativeStats.getNumTerms())
-                .setQueryLength(fromNativeStats.getQueryLength())
-                .setFilteredNamespaceCount(fromNativeStats.getNumNamespacesFiltered())
-                .setFilteredSchemaTypeCount(fromNativeStats.getNumSchemaTypesFiltered())
+                .setIsFirstPage(fromNativeStats.getIsFirstPage())
                 .setRequestedPageSize(fromNativeStats.getRequestedPageSize())
                 .setCurrentPageReturnedResultCount(
                         fromNativeStats.getNumResultsReturnedCurrentPage())
-                .setIsFirstPage(fromNativeStats.getIsFirstPage())
-                .setParseQueryLatencyMillis(fromNativeStats.getParseQueryLatencyMs())
-                .setRankingStrategy(fromNativeStats.getRankingStrategy().getNumber())
-                .setScoredDocumentCount(fromNativeStats.getNumDocumentsScored())
-                .setScoringLatencyMillis(fromNativeStats.getScoringLatencyMs())
+                .setNativeLatencyMillis(fromNativeStats.getLatencyMs())
                 .setRankingLatencyMillis(fromNativeStats.getRankingLatencyMs())
-                .setResultWithSnippetsCount(fromNativeStats.getNumResultsWithSnippets())
                 .setDocumentRetrievingLatencyMillis(fromNativeStats.getDocumentRetrievalLatencyMs())
+                .setResultWithSnippetsCount(fromNativeStats.getNumResultsWithSnippets())
                 .setNativeLockAcquisitionLatencyMillis(
                         fromNativeStats.getLockAcquisitionLatencyMs())
                 .setJavaToNativeJniLatencyMillis(fromNativeStats.getJavaToNativeJniLatencyMs())
                 .setNativeToJavaJniLatencyMillis(fromNativeStats.getNativeToJavaJniLatencyMs())
+                .setNativeJoinLatencyMillis(fromNativeStats.getJoinLatencyMs())
                 .setNativeNumJoinedResultsCurrentPage(
                         fromNativeStats.getNumJoinedResultsReturnedCurrentPage())
-                .setNativeJoinLatencyMillis(fromNativeStats.getJoinLatencyMs());
+                .setParentSearchStats(copyNativeStats(fromNativeStats.getParentSearchStats()))
+                .setChildSearchStats(copyNativeStats(fromNativeStats.getChildSearchStats()))
+                .setLiteIndexHitBufferByteSize(fromNativeStats.getLiteIndexHitBufferByteSize())
+                .setLiteIndexHitBufferUnsortedByteSize(
+                        fromNativeStats.getLiteIndexHitBufferUnsortedByteSize())
+                .setPageTokenType(fromNativeStats.getPageTokenType().getNumber())
+                .setNumResultStatsEvicted(fromNativeStats.getNumResultStatesEvicted());
+    }
+
+    /**
+     * Copies native Search stats to {@link SearchStats}.
+     *
+     * @param fromNativeStats Stats copied from.
+     */
+    static @NonNull SearchStats copyNativeStats(
+            QueryStatsProto.@NonNull SearchStats fromNativeStats) {
+        Objects.requireNonNull(fromNativeStats);
+        return new SearchStats.Builder()
+                .setNativeQueryLength(fromNativeStats.getQueryLength())
+                .setNativeTermCount(fromNativeStats.getNumTerms())
+                .setNativeFilteredNamespaceCount(fromNativeStats.getNumNamespacesFiltered())
+                .setNativeFilteredSchemaTypeCount(fromNativeStats.getNumSchemaTypesFiltered())
+                .setNativeRankingStrategy(fromNativeStats.getRankingStrategy().getNumber())
+                .setNativeScoredDocumentCount(fromNativeStats.getNumDocumentsScored())
+                .setNativeParseQueryLatencyMillis(fromNativeStats.getParseQueryLatencyMs())
+                .setNativeScoringLatencyMillis(fromNativeStats.getScoringLatencyMs())
+                .setNativeIsNumericQuery(fromNativeStats.getIsNumericQuery())
+                .setNativeNumFetchedHitsLiteIndex(fromNativeStats.getNumFetchedHitsLiteIndex())
+                .setNativeNumFetchedHitsMainIndex(fromNativeStats.getNumFetchedHitsMainIndex())
+                .setNativeNumFetchedHitsIntegerIndex(
+                        fromNativeStats.getNumFetchedHitsIntegerIndex())
+                .setNativeQueryProcessorLexerExtractTokenLatencyMillis(
+                        fromNativeStats.getQueryProcessorLexerExtractTokenLatencyMs())
+                .setNativeQueryProcessorParserConsumeQueryLatencyMillis(
+                        fromNativeStats.getQueryProcessorParserConsumeQueryLatencyMs())
+                .setNativeQueryProcessorQueryVisitorLatencyMillis(
+                        fromNativeStats.getQueryProcessorQueryVisitorLatencyMs())
+                .build();
     }
 
     /**
@@ -168,7 +214,13 @@ public final class AppSearchLoggerHelper {
         toStatsBuilder
                 .setNativeLatencyMillis(fromNativeStats.getLatencyMs())
                 .setDeleteType(RemoveStats.QUERY)
-                .setDeletedDocumentCount(fromNativeStats.getNumDocumentsDeleted());
+                .setDeletedDocumentCount(fromNativeStats.getNumDocumentsDeleted())
+                .setQueryLength(fromNativeStats.getQueryLength())
+                .setNumTerms(fromNativeStats.getNumTerms())
+                .setNumNamespacesFiltered(fromNativeStats.getNumNamespacesFiltered())
+                .setNumSchemaTypesFiltered(fromNativeStats.getNumSchemaTypesFiltered())
+                .setParseQueryLatencyMillis(fromNativeStats.getParseQueryLatencyMs())
+                .setDocumentRemovalLatencyMillis(fromNativeStats.getDocumentRemovalLatencyMs());
     }
 
     /**
@@ -192,7 +244,10 @@ public final class AppSearchLoggerHelper {
                 .setExpiredDocumentCount(fromNativeStats.getNumExpiredDocuments())
                 .setStorageSizeBeforeBytes(fromNativeStats.getStorageSizeBefore())
                 .setStorageSizeAfterBytes(fromNativeStats.getStorageSizeAfter())
-                .setTimeSinceLastOptimizeMillis(fromNativeStats.getTimeSinceLastOptimizeMs());
+                .setTimeSinceLastOptimizeMillis(fromNativeStats.getTimeSinceLastOptimizeMs())
+                .setIndexRestorationMode(fromNativeStats.getIndexRestorationMode().getNumber())
+                .setNumOriginalNamespaces(fromNativeStats.getNumOriginalNamespaces())
+                .setNumDeletedNamespaces(fromNativeStats.getNumDeletedNamespaces());
     }
 
     /*
diff --git a/service/java/com/android/server/appsearch/external/localstorage/IcingOptionsConfig.java b/service/java/com/android/server/appsearch/external/localstorage/IcingOptionsConfig.java
index 7d212fa0..5a9bd43d 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/IcingOptionsConfig.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/IcingOptionsConfig.java
@@ -45,6 +45,12 @@ public interface IcingOptionsConfig {
      */
     int DEFAULT_COMPRESSION_LEVEL = 3;
 
+    /**
+     * The default compression mem level in IcingSearchEngineOptions proto matches the
+     * previously-hardcoded document compression level in Icing (which is 8).
+     */
+    int DEFAULT_COMPRESSION_MEM_LEVEL = 8;
+
     boolean DEFAULT_USE_PREMAPPING_WITH_FILE_BACKED_VECTOR = false;
 
     boolean DEFAULT_USE_PERSISTENT_HASH_MAP = false;
@@ -80,6 +86,8 @@ public interface IcingOptionsConfig {
 
     String DEFAULT_ICU_DATA_FILE_ABSOLUTE_PATH = "";
 
+    int DEFAULT_COMPRESSION_THRESHOLD_BYTES = 600;
+
     /**
      * The maximum allowable token length. All tokens in excess of this size will be truncated to
      * max_token_length before being indexed.
@@ -130,6 +138,14 @@ public interface IcingOptionsConfig {
      */
     int getCompressionLevel();
 
+    /**
+     * The mem level for gzip compression for documents in the Icing document store.
+     *
+     * <p>1 uses minimum memory but is slow and reduces compression ratio; 9 uses maximum memory for
+     * optimal speed and compression ratio. Icing historically used a memLevel of 8.
+     */
+    int getCompressionMemLevel();
+
     /**
      * Whether to allow circular references between schema types for the schema definition.
      *
@@ -178,6 +194,17 @@ public interface IcingOptionsConfig {
      */
     int getMaxPageBytesLimit();
 
+    /**
+     * Flag for {@link com.google.android.icing.proto.ResultSpecProto}.
+     *
+     * <p>The maximum byte size to allow in a single page, when icing is running in a pVM. This
+     * limit is only loosely binding. AppSearch will add results to the page until either
+     * 1) AppSearch has retrieved {@link SearchSpec#getResultCountPerPage()} results or 2) total
+     * size of the page exceeds this value. Therefore, AppSearch will always retrieve at least a
+     * single result, even if that result exceeds this limit.
+     */
+    int getMaxPageBytesLimitForVm();
+
     /**
      * Flag for {@link com.google.android.icing.proto.IcingSearchEngineOptions}.
      *
@@ -246,12 +273,20 @@ public interface IcingOptionsConfig {
      */
     @NonNull String getIcuDataFileAbsolutePath();
 
+    /**
+     * The threshold in bytes for compressing documents. If a document is larger than or equal to
+     * this threshold, it will be compressed based on getCompressionLevel(). 0 means always
+     * compress.
+     */
+    int getCompressionThresholdBytes();
+
     /**
      * Converts to an {@link IcingSearchEngineOptions} instance.
      *
      * @param baseDir base directory of the icing instance.
      */
-    default @NonNull IcingSearchEngineOptions toIcingSearchEngineOptions(@NonNull String baseDir) {
+    default @NonNull IcingSearchEngineOptions toIcingSearchEngineOptions(
+            @NonNull String baseDir, boolean isVMEnabled) {
         return IcingSearchEngineOptions.newBuilder()
                 .setBaseDir(baseDir)
                 .setMaxTokenLength(getMaxTokenLength())
@@ -284,6 +319,24 @@ public interface IcingOptionsConfig {
                 .setEnableMarkerFileForOptimize(Flags.enableMarkerFileForOptimize())
                 .setReleaseBackupSchemaFileIfOverlayPresent(
                         Flags.enableReleaseBackupSchemaFileIfOverlayPresent())
+                // This is a necessary bug fix for the VMEnabled case. VMEnabled is guarded by its
+                // own trunk-stable flag, therefore this can be included there. Otherwise, we should
+                // use this trank-stable flag.
+                .setEnableStrictPageByteSizeLimit(
+                        Flags.enableStrictPageByteSizeLimit() || isVMEnabled)
+                .setCompressionThresholdBytes(
+                        (Flags.enableCompressionThreshold() || isVMEnabled)
+                                ? Math.max(0, getCompressionThresholdBytes())
+                                : 0)
+                .setCompressionMemLevel(
+                        (Flags.enableCompressionMemLevelOne() || isVMEnabled)
+                                ? 1
+                                : getCompressionMemLevel())
+                .setEnableSchemaDatabase(
+                        Flags.enableDatabaseScopedSchemaOperations() || isVMEnabled)
+                .setEnableSmallerDecompressionBufferSize(
+                        Flags.enableSmallerDecompressionBufferSize() || isVMEnabled)
+                .setEnableEigenEmbeddingScoring(Flags.enableEigenEmbeddingScoring() || isVMEnabled)
                 .build();
     }
 }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/converter/ResultCodeToProtoConverter.java b/service/java/com/android/server/appsearch/external/localstorage/converter/ResultCodeToProtoConverter.java
index 91d2e5e5..293f07fd 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/converter/ResultCodeToProtoConverter.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/converter/ResultCodeToProtoConverter.java
@@ -52,6 +52,8 @@ public final class ResultCodeToProtoConverter {
                 return AppSearchResult.RESULT_INVALID_ARGUMENT;
             case ALREADY_EXISTS:
                 return AppSearchResult.RESULT_ALREADY_EXISTS;
+            case UNAVAILABLE:
+                return AppSearchResult.RESULT_UNAVAILABLE;
             default:
                 // Some unknown/unsupported error
                 Log.e(
diff --git a/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverter.java b/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverter.java
index 99cb9c8c..d31de119 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverter.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverter.java
@@ -277,8 +277,12 @@ public final class SearchSpecToProtoConverter {
         }
     }
 
-    /** Extracts {@link SearchSpecProto} information from a {@link SearchSpec}. */
-    public @NonNull SearchSpecProto toSearchSpecProto() {
+    /**
+     * Extracts {@link SearchSpecProto} information from a {@link SearchSpec}.
+     *
+     * @param isVMEnabled Whether or not icing is running in a pVM.
+     */
+    public @NonNull SearchSpecProto toSearchSpecProto(boolean isVMEnabled) {
         // set query to SearchSpecProto and override schema and namespace filter by
         // targetPrefixedFilters which contains all existing and also accessible to the caller
         // filters.
@@ -355,9 +359,9 @@ public final class SearchSpecToProtoConverter {
                     JoinSpecProto.NestedSpecProto.newBuilder()
                             .setResultSpec(
                                     mNestedConverter.toResultSpecProto(
-                                            mNamespaceCache, mSchemaCache))
+                                            mNamespaceCache, mSchemaCache, isVMEnabled))
                             .setScoringSpec(mNestedConverter.toScoringSpecProto())
-                            .setSearchSpec(mNestedConverter.toSearchSpecProto())
+                            .setSearchSpec(mNestedConverter.toSearchSpecProto(isVMEnabled))
                             .build();
 
             // This cannot be null, otherwise mNestedConverter would be null as well.
@@ -424,9 +428,11 @@ public final class SearchSpecToProtoConverter {
      *
      * @param namespaceCache The NamespaceCache instance held in AppSearch.
      * @param schemaCache The SchemaCache instance held in AppSearch.
+     * @param isVMEnabled Whether or not icing is running in a pVM.
      */
     public @NonNull ResultSpecProto toResultSpecProto(
-            @NonNull NamespaceCache namespaceCache, @NonNull SchemaCache schemaCache) {
+            @NonNull NamespaceCache namespaceCache, @NonNull SchemaCache schemaCache,
+            boolean isVMEnabled) {
         ResultSpecProto.Builder resultSpecBuilder =
                 ResultSpecProto.newBuilder()
                         .setNumPerPage(mSearchSpec.getResultCountPerPage())
@@ -437,9 +443,14 @@ public final class SearchSpecToProtoConverter {
                                                 mSearchSpec.getSnippetCountPerProperty())
                                         .setMaxWindowUtf32Length(mSearchSpec.getMaxSnippetSize())
                                         .setGetEmbeddingMatchInfo(
-                                                mSearchSpec.shouldRetrieveEmbeddingMatchInfos()))
-                        .setNumTotalBytesPerPageThreshold(
-                                mIcingOptionsConfig.getMaxPageBytesLimit());
+                                                mSearchSpec.shouldRetrieveEmbeddingMatchInfos()));
+        if (isVMEnabled) {
+            resultSpecBuilder.setNumTotalBytesPerPageThreshold(
+                    mIcingOptionsConfig.getMaxPageBytesLimitForVm());
+        } else {
+            resultSpecBuilder.setNumTotalBytesPerPageThreshold(
+                    mIcingOptionsConfig.getMaxPageBytesLimit());
+        }
         JoinSpec joinSpec = mSearchSpec.getJoinSpec();
         if (joinSpec != null) {
             resultSpecBuilder.setMaxJoinedChildrenPerParentToReturn(
diff --git a/service/java/com/android/server/appsearch/external/localstorage/stats/CallStats.java b/service/java/com/android/server/appsearch/external/localstorage/stats/CallStats.java
index ec5a844f..eb2d4927 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/stats/CallStats.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/stats/CallStats.java
@@ -128,6 +128,9 @@ public class CallStats extends BaseStats {
     public static final int CALL_TYPE_GLOBAL_OPEN_READ_BLOB = 35;
     public static final int CALL_TYPE_REMOVE_BLOB = 36;
     public static final int CALL_TYPE_SET_BLOB_VISIBILITY = 37;
+    // Most call types are for AppSearchManager APIs. This call type is for internal calls, such
+    // as from indexers.
+    public static final int INTERNAL_CALL_TYPE_APP_OPEN_EVENT_INDEXER = 38;
 
     // These strings are for the subset of call types that correspond to an AppSearchManager API
     private static final String CALL_TYPE_STRING_INITIALIZE = "initialize";
@@ -182,6 +185,7 @@ public class CallStats extends BaseStats {
     private final int mEstimatedBinderLatencyMillis;
     private final int mNumOperationsSucceeded;
     private final int mNumOperationsFailed;
+    private final long mCallReceivedTimestampMillis;
 
     CallStats(@NonNull Builder builder) {
         super(builder);
@@ -193,6 +197,7 @@ public class CallStats extends BaseStats {
         mEstimatedBinderLatencyMillis = builder.mEstimatedBinderLatencyMillis;
         mNumOperationsSucceeded = builder.mNumOperationsSucceeded;
         mNumOperationsFailed = builder.mNumOperationsFailed;
+        mCallReceivedTimestampMillis = builder.mCallReceivedTimestampMillis;
     }
 
     /** Returns calling package name. */
@@ -257,6 +262,11 @@ public class CallStats extends BaseStats {
         return mNumOperationsFailed;
     }
 
+    /** Returns the wall-clock timestamp in milliseconds when the API call was received. */
+    public long getCallReceivedTimestampMillis() {
+        return mCallReceivedTimestampMillis;
+    }
+
     /** Builder for {@link CallStats}. */
     public static class Builder extends BaseStats.Builder<CallStats.Builder> {
         @Nullable String mPackageName;
@@ -267,6 +277,7 @@ public class CallStats extends BaseStats {
         int mEstimatedBinderLatencyMillis;
         int mNumOperationsSucceeded;
         int mNumOperationsFailed;
+        long mCallReceivedTimestampMillis;
 
         /** Sets the PackageName used by the session. */
         @CanIgnoreReturnValue
@@ -344,6 +355,13 @@ public class CallStats extends BaseStats {
             return this;
         }
 
+        /** Sets the wall-clock timestamp in milliseconds when the API call was received. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setCallReceivedTimestampMillis(long callReceivedTimestampMillis) {
+            mCallReceivedTimestampMillis = callReceivedTimestampMillis;
+            return this;
+        }
+
         /** Creates {@link CallStats} object from {@link Builder} instance. */
         @Override
         public @NonNull CallStats build() {
diff --git a/service/java/com/android/server/appsearch/external/localstorage/stats/InitializeStats.java b/service/java/com/android/server/appsearch/external/localstorage/stats/InitializeStats.java
index 5811f54d..218281f1 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/stats/InitializeStats.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/stats/InitializeStats.java
@@ -42,8 +42,14 @@ public final class InitializeStats extends BaseStats {
                 RECOVERY_CAUSE_NONE,
                 RECOVERY_CAUSE_DATA_LOSS,
                 RECOVERY_CAUSE_INCONSISTENT_WITH_GROUND_TRUTH,
-                RECOVERY_CAUSE_TOTAL_CHECKSUM_MISMATCH,
+                RECOVERY_CAUSE_SCHEMA_CHANGES_OUT_OF_SYNC,
                 RECOVERY_CAUSE_IO_ERROR,
+                RECOVERY_CAUSE_LEGACY_DOCUMENT_LOG_FORMAT,
+                RECOVERY_CAUSE_VERSION_CHANGED,
+                RECOVERY_CAUSE_DEPENDENCIES_CHANGED,
+                RECOVERY_CAUSE_FEATURE_FLAG_CHANGED,
+                RECOVERY_CAUSE_UNKNOWN_OUT_OF_SYNC,
+                RECOVERY_CAUSE_OPTIMIZE_OUT_OF_SYNC
             })
     @Retention(RetentionPolicy.SOURCE)
     public @interface RecoveryCause {}
@@ -54,10 +60,31 @@ public final class InitializeStats extends BaseStats {
     public static final int RECOVERY_CAUSE_DATA_LOSS = 1;
     // Data in index is inconsistent with ground truth.
     public static final int RECOVERY_CAUSE_INCONSISTENT_WITH_GROUND_TRUTH = 2;
-    // Total checksum of all the components does not match.
-    public static final int RECOVERY_CAUSE_TOTAL_CHECKSUM_MISMATCH = 3;
+    // Changes were made to the schema, but the marker file remains in the
+    // filesystem indicating that changes possibly were not fully applied to the
+    // document store and the index - requiring a recovery.
+    public static final int RECOVERY_CAUSE_SCHEMA_CHANGES_OUT_OF_SYNC = 3;
     // Random I/O errors.
     public static final int RECOVERY_CAUSE_IO_ERROR = 4;
+    // The document log is using legacy format.
+    public static final int RECOVERY_CAUSE_LEGACY_DOCUMENT_LOG_FORMAT = 5;
+    // The current code version is different from existing data version.
+    public static final int RECOVERY_CAUSE_VERSION_CHANGED = 6;
+    // Any dependencies have changed.
+    public static final int RECOVERY_CAUSE_DEPENDENCIES_CHANGED = 7;
+    // Change detected in Icing's feature flags since last initialization that
+    // requires recovery.
+    public static final int RECOVERY_CAUSE_FEATURE_FLAG_CHANGED = 8;
+    // Changes were made by an incomplete complex operation, which caused marker
+    // file to remain in the filesystem - requiring a recovery.
+    //
+    // Note: Icing is unable to interpret the information from the marker file
+    // due to some reasons, so the OUT_OF_SYNC reason is UNKNOWN.
+    public static final int RECOVERY_CAUSE_UNKNOWN_OUT_OF_SYNC = 9;
+    // Changes were made by optimize, but the marker file remains in the
+    // filesystem indicating that optimize possibly was not fully applied to the
+    // document store and the index - requiring a recovery.
+    public static final int RECOVERY_CAUSE_OPTIMIZE_OUT_OF_SYNC = 10;
 
     /** Status regarding how much data is lost during the initialization. */
     @IntDef(
@@ -119,7 +146,26 @@ public final class InitializeStats extends BaseStats {
     /** Returns number of schema types currently in the schema store. */
     private final int mNativeNumSchemaTypes;
 
-    /** Whether we had to reset the index, losing all data, during initialization. */
+    /**
+     * Number of consecutive initialization failures that immediately preceded this initialization.
+     */
+    int mNativeNumPreviousInitFailures;
+
+    /** Restoration cause of integer index. */
+    @RecoveryCause int mNativeIntegerIndexRestorationCause;
+
+    /** Restoration cause of qualified id join index. */
+    @RecoveryCause int mNativeQualifiedIdJoinIndexRestorationCause;
+
+    /** Restoration cause of embedding index. */
+    @RecoveryCause int mNativeEmbeddingIndexRestorationCause;
+
+    /** ICU data initialization status code */
+    @AppSearchResult.ResultCode int mNativeInitializeIcuDataStatusCode;
+
+    /** Number of documents that failed to be reindexed during index restoration. */
+    int mNativeNumFailedReindexedDocuments;
+
     private final boolean mHasReset;
 
     /** If we had to reset, contains the status code of the reset operation. */
@@ -161,61 +207,42 @@ public final class InitializeStats extends BaseStats {
         return mNativeLatencyMillis;
     }
 
-    /**
-     * Returns recovery cause for document store.
-     *
-     * <p>Possible recovery causes for document store:
-     * <li>{@link InitializeStats#RECOVERY_CAUSE_DATA_LOSS}
-     * <li>{@link InitializeStats#RECOVERY_CAUSE_TOTAL_CHECKSUM_MISMATCH}
-     * <li>{@link InitializeStats#RECOVERY_CAUSE_IO_ERROR}
-     */
+    /** Returns recovery cause for document store. */
     @RecoveryCause
-    public int getDocumentStoreRecoveryCause() {
+    public int getNativeDocumentStoreRecoveryCause() {
         return mNativeDocumentStoreRecoveryCause;
     }
 
-    /**
-     * Returns restoration cause for index store.
-     *
-     * <p>Possible causes:
-     * <li>{@link InitializeStats#RECOVERY_CAUSE_INCONSISTENT_WITH_GROUND_TRUTH}
-     * <li>{@link InitializeStats#RECOVERY_CAUSE_TOTAL_CHECKSUM_MISMATCH}
-     * <li>{@link InitializeStats#RECOVERY_CAUSE_IO_ERROR}
-     */
+    /** Returns restoration cause for index store. */
     @RecoveryCause
-    public int getIndexRestorationCause() {
+    public int getNativeIndexRestorationCause() {
         return mNativeIndexRestorationCause;
     }
 
-    /**
-     * Returns recovery cause for schema store.
-     *
-     * <p>Possible causes:
-     * <li>IO_ERROR
-     */
+    /** Returns recovery cause for schema store. */
     @RecoveryCause
-    public int getSchemaStoreRecoveryCause() {
+    public int getNativeSchemaStoreRecoveryCause() {
         return mNativeSchemaStoreRecoveryCause;
     }
 
     /** Returns time used to recover the document store. */
-    public int getDocumentStoreRecoveryLatencyMillis() {
+    public int getNativeDocumentStoreRecoveryLatencyMillis() {
         return mNativeDocumentStoreRecoveryLatencyMillis;
     }
 
     /** Returns time used to restore the index. */
-    public int getIndexRestorationLatencyMillis() {
+    public int getNativeIndexRestorationLatencyMillis() {
         return mNativeIndexRestorationLatencyMillis;
     }
 
     /** Returns time used to recover the schema store. */
-    public int getSchemaStoreRecoveryLatencyMillis() {
+    public int getNativeSchemaStoreRecoveryLatencyMillis() {
         return mNativeSchemaStoreRecoveryLatencyMillis;
     }
 
     /** Returns status about how much data is lost during the initialization. */
     @DocumentStoreDataStatus
-    public int getDocumentStoreDataStatus() {
+    public int getNativeDocumentStoreDataStatus() {
         return mNativeDocumentStoreDataStatus;
     }
 
@@ -223,15 +250,56 @@ public final class InitializeStats extends BaseStats {
      * Returns number of documents currently in document store. Those may include alive, deleted,
      * and expired documents.
      */
-    public int getDocumentCount() {
+    public int getNativeDocumentCount() {
         return mNativeNumDocuments;
     }
 
     /** Returns number of schema types currently in the schema store. */
-    public int getSchemaTypeCount() {
+    public int getNativeSchemaTypeCount() {
         return mNativeNumSchemaTypes;
     }
 
+    /**
+     * Returns number of consecutive initialization failures that immediately preceded this
+     * initialization.
+     */
+    public int getNativeNumPreviousInitFailures() {
+        return mNativeNumPreviousInitFailures;
+    }
+
+    /** Returns restoration cause for Integer index. */
+    @RecoveryCause
+    public int getNativeIntegerIndexRestorationCause() {
+        return mNativeIntegerIndexRestorationCause;
+    }
+
+    /** Returns restoration cause for qualified id join index. */
+    @RecoveryCause
+    public int getNativeQualifiedIdJoinIndexRestorationCause() {
+        return mNativeQualifiedIdJoinIndexRestorationCause;
+    }
+
+    /** Returns restoration cause for embedding index. */
+    @RecoveryCause
+    public int getNativeEmbeddingIndexRestorationCause() {
+        return mNativeEmbeddingIndexRestorationCause;
+    }
+
+    /**
+     * Returns the status of ICU data initialization.
+     *
+     * <p>If no value has been set, the default value is {@link AppSearchResult#RESULT_OK}.
+     */
+    @AppSearchResult.ResultCode
+    public int getNativeInitializeIcuDataStatusCode() {
+        return mNativeInitializeIcuDataStatusCode;
+    }
+
+    /** Returns number of documents that failed to be reindexed during index restoration. */
+    public int getNativeNumFailedReindexedDocuments() {
+        return mNativeNumFailedReindexedDocuments;
+    }
+
     /** Returns whether we had to reset the index, losing all data, as part of initialization. */
     public boolean hasReset() {
         return mHasReset;
@@ -265,6 +333,13 @@ public final class InitializeStats extends BaseStats {
         mNativeDocumentStoreDataStatus = builder.mNativeDocumentStoreDataStatus;
         mNativeNumDocuments = builder.mNativeNumDocuments;
         mNativeNumSchemaTypes = builder.mNativeNumSchemaTypes;
+        mNativeNumPreviousInitFailures = builder.mNativeNumPreviousInitFailures;
+        mNativeIntegerIndexRestorationCause = builder.mNativeIntegerIndexRestorationCause;
+        mNativeQualifiedIdJoinIndexRestorationCause =
+                builder.mNativeQualifiedIdJoinIndexRestorationCause;
+        mNativeEmbeddingIndexRestorationCause = builder.mNativeEmbeddingIndexRestorationCause;
+        mNativeInitializeIcuDataStatusCode = builder.mNativeInitializeIcuDataStatusCode;
+        mNativeNumFailedReindexedDocuments = builder.mNativeNumFailedReindexedDocuments;
         mHasReset = builder.mHasReset;
         mResetStatusCode = builder.mResetStatusCode;
     }
@@ -287,6 +362,12 @@ public final class InitializeStats extends BaseStats {
         @DocumentStoreDataStatus int mNativeDocumentStoreDataStatus;
         int mNativeNumDocuments;
         int mNativeNumSchemaTypes;
+        int mNativeNumPreviousInitFailures;
+        @RecoveryCause int mNativeIntegerIndexRestorationCause;
+        @RecoveryCause int mNativeQualifiedIdJoinIndexRestorationCause;
+        @RecoveryCause int mNativeEmbeddingIndexRestorationCause;
+        int mNativeInitializeIcuDataStatusCode;
+        int mNativeNumFailedReindexedDocuments;
         boolean mHasReset;
         @AppSearchResult.ResultCode int mResetStatusCode;
 
@@ -339,69 +420,51 @@ public final class InitializeStats extends BaseStats {
             return this;
         }
 
-        /**
-         * Sets recovery cause for document store.
-         *
-         * <p>Possible recovery causes for document store:
-         * <li>{@link InitializeStats#RECOVERY_CAUSE_DATA_LOSS}
-         * <li>{@link InitializeStats#RECOVERY_CAUSE_TOTAL_CHECKSUM_MISMATCH}
-         * <li>{@link InitializeStats#RECOVERY_CAUSE_IO_ERROR}
-         */
+        /** Sets recovery cause for document store. */
         @CanIgnoreReturnValue
-        public @NonNull Builder setDocumentStoreRecoveryCause(
-                @RecoveryCause int documentStoreRecoveryCause) {
-            mNativeDocumentStoreRecoveryCause = documentStoreRecoveryCause;
+        public @NonNull Builder setNativeDocumentStoreRecoveryCause(
+                @RecoveryCause int nativeDocumentStoreRecoveryCause) {
+            mNativeDocumentStoreRecoveryCause = nativeDocumentStoreRecoveryCause;
             return this;
         }
 
-        /**
-         * Sets restoration cause for index store.
-         *
-         * <p>Possible causes:
-         * <li>{@link InitializeStats#DOCUMENT_STORE_DATA_STATUS_COMPLETE_LOSS}
-         * <li>{@link InitializeStats#RECOVERY_CAUSE_TOTAL_CHECKSUM_MISMATCH}
-         * <li>{@link InitializeStats#RECOVERY_CAUSE_IO_ERROR}
-         */
+        /** Sets restoration cause for index store. */
         @CanIgnoreReturnValue
-        public @NonNull Builder setIndexRestorationCause(@RecoveryCause int indexRestorationCause) {
-            mNativeIndexRestorationCause = indexRestorationCause;
+        public @NonNull Builder setNativeIndexRestorationCause(
+                @RecoveryCause int nativeIndexRestorationCause) {
+            mNativeIndexRestorationCause = nativeIndexRestorationCause;
             return this;
         }
 
-        /**
-         * Returns recovery cause for schema store.
-         *
-         * <p>Possible causes:
-         * <li>{@link InitializeStats#RECOVERY_CAUSE_IO_ERROR}
-         */
+        /** Sets recovery cause for schema store. */
         @CanIgnoreReturnValue
-        public @NonNull Builder setSchemaStoreRecoveryCause(
-                @RecoveryCause int schemaStoreRecoveryCause) {
-            mNativeSchemaStoreRecoveryCause = schemaStoreRecoveryCause;
+        public @NonNull Builder setNativeSchemaStoreRecoveryCause(
+                @RecoveryCause int nativeSchemaStoreRecoveryCause) {
+            mNativeSchemaStoreRecoveryCause = nativeSchemaStoreRecoveryCause;
             return this;
         }
 
         /** Sets time used to recover the document store. */
         @CanIgnoreReturnValue
-        public @NonNull Builder setDocumentStoreRecoveryLatencyMillis(
-                int documentStoreRecoveryLatencyMillis) {
-            mNativeDocumentStoreRecoveryLatencyMillis = documentStoreRecoveryLatencyMillis;
+        public @NonNull Builder setNativeDocumentStoreRecoveryLatencyMillis(
+                int nativeDocumentStoreRecoveryLatencyMillis) {
+            mNativeDocumentStoreRecoveryLatencyMillis = nativeDocumentStoreRecoveryLatencyMillis;
             return this;
         }
 
         /** Sets time used to restore the index. */
         @CanIgnoreReturnValue
-        public @NonNull Builder setIndexRestorationLatencyMillis(
-                int indexRestorationLatencyMillis) {
-            mNativeIndexRestorationLatencyMillis = indexRestorationLatencyMillis;
+        public @NonNull Builder setNativeIndexRestorationLatencyMillis(
+                int nativeIndexRestorationLatencyMillis) {
+            mNativeIndexRestorationLatencyMillis = nativeIndexRestorationLatencyMillis;
             return this;
         }
 
         /** Sets time used to recover the schema store. */
         @CanIgnoreReturnValue
-        public @NonNull Builder setSchemaStoreRecoveryLatencyMillis(
-                int schemaStoreRecoveryLatencyMillis) {
-            mNativeSchemaStoreRecoveryLatencyMillis = schemaStoreRecoveryLatencyMillis;
+        public @NonNull Builder setNativeSchemaStoreRecoveryLatencyMillis(
+                int nativeSchemaStoreRecoveryLatencyMillis) {
+            mNativeSchemaStoreRecoveryLatencyMillis = nativeSchemaStoreRecoveryLatencyMillis;
             return this;
         }
 
@@ -410,9 +473,9 @@ public final class InitializeStats extends BaseStats {
          * external/icing/proto/icing/proto/logging.proto
          */
         @CanIgnoreReturnValue
-        public @NonNull Builder setDocumentStoreDataStatus(
-                @DocumentStoreDataStatus int documentStoreDataStatus) {
-            mNativeDocumentStoreDataStatus = documentStoreDataStatus;
+        public @NonNull Builder setNativeDocumentStoreDataStatus(
+                @DocumentStoreDataStatus int nativeDocumentStoreDataStatus) {
+            mNativeDocumentStoreDataStatus = nativeDocumentStoreDataStatus;
             return this;
         }
 
@@ -421,15 +484,67 @@ public final class InitializeStats extends BaseStats {
          * and expired documents.
          */
         @CanIgnoreReturnValue
-        public @NonNull Builder setDocumentCount(int numDocuments) {
-            mNativeNumDocuments = numDocuments;
+        public @NonNull Builder setNativeDocumentCount(int nativeNumDocuments) {
+            mNativeNumDocuments = nativeNumDocuments;
             return this;
         }
 
         /** Sets number of schema types currently in the schema store. */
         @CanIgnoreReturnValue
-        public @NonNull Builder setSchemaTypeCount(int numSchemaTypes) {
-            mNativeNumSchemaTypes = numSchemaTypes;
+        public @NonNull Builder setNativeSchemaTypeCount(int nativeNumSchemaTypes) {
+            mNativeNumSchemaTypes = nativeNumSchemaTypes;
+            return this;
+        }
+
+        /**
+         * Sets number of consecutive initialization failures that immediately preceded this
+         * initialization.
+         */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setNativeNumPreviousInitFailures(
+                int nativeNumPreviousInitFailures) {
+            mNativeNumPreviousInitFailures = nativeNumPreviousInitFailures;
+            return this;
+        }
+
+        /** Sets restoration cause for integer store. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setNativeIntegerIndexRestorationCause(
+                @RecoveryCause int nativeIntegerIndexRestorationCause) {
+            mNativeIntegerIndexRestorationCause = nativeIntegerIndexRestorationCause;
+            return this;
+        }
+
+        /** Sets restoration cause for qualified id join index. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setNativeQualifiedIdJoinIndexRestorationCause(
+                @RecoveryCause int nativeQualifiedIdJoinIndexRestorationCause) {
+            mNativeQualifiedIdJoinIndexRestorationCause =
+                    nativeQualifiedIdJoinIndexRestorationCause;
+            return this;
+        }
+
+        /** Sets restoration cause for embedding index. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setNativeEmbeddingIndexRestorationCause(
+                @RecoveryCause int nativeEmbeddingIndexRestorationCause) {
+            mNativeEmbeddingIndexRestorationCause = nativeEmbeddingIndexRestorationCause;
+            return this;
+        }
+
+        /** Sets the status of the initialize Icu data. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setNativeInitializeIcuDataStatusCode(
+                @AppSearchResult.ResultCode int nativeInitializeIcuDataStatusCode) {
+            mNativeInitializeIcuDataStatusCode = nativeInitializeIcuDataStatusCode;
+            return this;
+        }
+
+        /** Sets number of documents that failed to be reindexed during index restoration. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setNativeNumFailedReindexedDocuments(
+                int nativeNumFailedReindexedDocuments) {
+            mNativeNumFailedReindexedDocuments = nativeNumFailedReindexedDocuments;
             return this;
         }
 
diff --git a/service/java/com/android/server/appsearch/external/localstorage/stats/OptimizeStats.java b/service/java/com/android/server/appsearch/external/localstorage/stats/OptimizeStats.java
index 629591d1..976bc0d7 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/stats/OptimizeStats.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/stats/OptimizeStats.java
@@ -16,18 +16,44 @@
 
 package com.android.server.appsearch.external.localstorage.stats;
 
+import android.annotation.IntDef;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
 import android.app.appsearch.stats.BaseStats;
 
 import org.jspecify.annotations.NonNull;
 
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
 /**
  * Class holds detailed stats for Optimize.
  *
  * @hide
  */
 public final class OptimizeStats extends BaseStats {
+
+    /**
+     * The cause of IcingSearchEngine recovering from a previous bad state during initialization.
+     */
+    @IntDef(
+            value = {
+                // It needs to be sync with RecoveryCause in
+                // external/icing/proto/icing/proto/logging.proto#InitializeStatsProto
+                INDEX_TRANSLATION,
+                FULL_INDEX_REBUILD,
+            })
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface IndexRestorationMode {}
+
+    // The index has been translated in place to match the optimized document
+    // store.
+    public static final int INDEX_TRANSLATION = 0;
+    // The index has been rebuilt from scratch during optimization. This could
+    // happen when we received a DATA_LOSS error from OptimizeDocumentStore,
+    // Index::Optimize failed, or rebuilding could be faster.
+    public static final int FULL_INDEX_REBUILD = 1;
+
     /**
      * The status code returned by {@link AppSearchResult#getResultCode()} for the call or internal
      * state.
@@ -61,6 +87,15 @@ public final class OptimizeStats extends BaseStats {
     // The amount of time in millis since the last optimization ran calculated using wall clock time
     private final long mNativeTimeSinceLastOptimizeMillis;
 
+    // The mode of index restoration if there is any.
+    @IndexRestorationMode private final int mIndexRestorationMode;
+
+    // Number of namespaces before the optimization.
+    private final int mNumOriginalNamespaces;
+
+    // Number of namespaces deleted.
+    private final int mNumDeletedNamespaces;
+
     OptimizeStats(@NonNull Builder builder) {
         super(builder);
         mStatusCode = builder.mStatusCode;
@@ -75,6 +110,9 @@ public final class OptimizeStats extends BaseStats {
         mNativeStorageSizeBeforeBytes = builder.mNativeStorageSizeBeforeBytes;
         mNativeStorageSizeAfterBytes = builder.mNativeStorageSizeAfterBytes;
         mNativeTimeSinceLastOptimizeMillis = builder.mNativeTimeSinceLastOptimizeMillis;
+        mIndexRestorationMode = builder.mIndexRestorationMode;
+        mNumOriginalNamespaces = builder.mNumOriginalNamespaces;
+        mNumDeletedNamespaces = builder.mNumDeletedNamespaces;
     }
 
     /** Returns status code for this optimization. */
@@ -136,6 +174,22 @@ public final class OptimizeStats extends BaseStats {
         return mNativeTimeSinceLastOptimizeMillis;
     }
 
+    /** Returns the index restoration mode. */
+    @IndexRestorationMode
+    public int getIndexRestorationMode() {
+        return mIndexRestorationMode;
+    }
+
+    /** Returns number of namespaces before the optimization. */
+    public int getNumOriginalNamespaces() {
+        return mNumOriginalNamespaces;
+    }
+
+    /** Returns number of namespaces deleted. */
+    public int getNumDeletedNamespaces() {
+        return mNumDeletedNamespaces;
+    }
+
     /** Builder for {@link RemoveStats}. */
     public static class Builder extends BaseStats.Builder<OptimizeStats.Builder> {
         /**
@@ -154,6 +208,9 @@ public final class OptimizeStats extends BaseStats {
         long mNativeStorageSizeBeforeBytes;
         long mNativeStorageSizeAfterBytes;
         long mNativeTimeSinceLastOptimizeMillis;
+        @IndexRestorationMode int mIndexRestorationMode;
+        int mNumOriginalNamespaces;
+        int mNumDeletedNamespaces;
 
         /** Sets the status code. */
         @CanIgnoreReturnValue
@@ -236,6 +293,28 @@ public final class OptimizeStats extends BaseStats {
             return this;
         }
 
+        /** Sets the index restoration mode. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setIndexRestorationMode(
+                @IndexRestorationMode int indexRestorationMode) {
+            mIndexRestorationMode = indexRestorationMode;
+            return this;
+        }
+
+        /** Sets the number of namespaces before the optimization. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setNumOriginalNamespaces(int numOriginalNamespaces) {
+            mNumOriginalNamespaces = numOriginalNamespaces;
+            return this;
+        }
+
+        /** Sets the number of namespaces deleted. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setNumDeletedNamespaces(int numDeletedNamespaces) {
+            mNumDeletedNamespaces = numDeletedNamespaces;
+            return this;
+        }
+
         /** Creates a {@link OptimizeStats}. */
         @Override
         public @NonNull OptimizeStats build() {
diff --git a/service/java/com/android/server/appsearch/external/localstorage/stats/PutDocumentStats.java b/service/java/com/android/server/appsearch/external/localstorage/stats/PutDocumentStats.java
index a5a191e6..bbf75f66 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/stats/PutDocumentStats.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/stats/PutDocumentStats.java
@@ -81,6 +81,15 @@ public final class PutDocumentStats extends BaseStats {
     /** Time used to sort and merge the lite index's hit buffer. */
     private final int mNativeLiteIndexSortLatencyMillis;
 
+    /**
+     * Time used to index all metadata terms in the document, which can only be added by
+     * PropertyExistenceIndexingHandler currently.
+     */
+    private final int mMetadataTermIndexLatencyMillis;
+
+    /** Time used to index all embeddings in the document. */
+    private final int mEmbeddingIndexLatencyMillis;
+
     PutDocumentStats(@NonNull Builder builder) {
         super(builder);
         mPackageName = builder.mPackageName;
@@ -99,6 +108,8 @@ public final class PutDocumentStats extends BaseStats {
         mNativeIntegerIndexLatencyMillis = builder.mNativeIntegerIndexLatencyMillis;
         mNativeQualifiedIdJoinIndexLatencyMillis = builder.mNativeQualifiedIdJoinIndexLatencyMillis;
         mNativeLiteIndexSortLatencyMillis = builder.mNativeLiteIndexSortLatencyMillis;
+        mMetadataTermIndexLatencyMillis = builder.mMetadataTermIndexLatencyMillis;
+        mEmbeddingIndexLatencyMillis = builder.mEmbeddingIndexLatencyMillis;
     }
 
     /** Returns calling package name. */
@@ -182,6 +193,19 @@ public final class PutDocumentStats extends BaseStats {
         return mNativeLiteIndexSortLatencyMillis;
     }
 
+    /**
+     * Returns time used to index all metadata terms in the document, which can only be added by
+     * PropertyExistenceIndexingHandler currently, in milliseconds.
+     */
+    public int getMetadataTermIndexLatencyMillis() {
+        return mMetadataTermIndexLatencyMillis;
+    }
+
+    /** Returns time used to index all embeddings in the document, in milliseconds. */
+    public int getEmbeddingIndexLatencyMillis() {
+        return mEmbeddingIndexLatencyMillis;
+    }
+
     /** Builder for {@link PutDocumentStats}. */
     public static class Builder extends BaseStats.Builder<PutDocumentStats.Builder> {
         final @NonNull String mPackageName;
@@ -200,6 +224,8 @@ public final class PutDocumentStats extends BaseStats {
         int mNativeIntegerIndexLatencyMillis;
         int mNativeQualifiedIdJoinIndexLatencyMillis;
         int mNativeLiteIndexSortLatencyMillis;
+        int mMetadataTermIndexLatencyMillis;
+        int mEmbeddingIndexLatencyMillis;
 
         /** Builder for {@link PutDocumentStats} */
         public Builder(@NonNull String packageName, @NonNull String database) {
@@ -315,6 +341,21 @@ public final class PutDocumentStats extends BaseStats {
             return this;
         }
 
+        /** Sets the native metadata term index latency, in millis. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setMetadataTermIndexLatencyMillis(
+                int metadataTermIndexLatencyMillis) {
+            mMetadataTermIndexLatencyMillis = metadataTermIndexLatencyMillis;
+            return this;
+        }
+
+        /** Sets the native embedding index latency, in millis. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setEmbeddingIndexLatencyMillis(int embeddingIndexLatencyMillis) {
+            mEmbeddingIndexLatencyMillis = embeddingIndexLatencyMillis;
+            return this;
+        }
+
         /**
          * Creates a new {@link PutDocumentStats} object from the contents of this {@link Builder}
          * instance.
diff --git a/service/java/com/android/server/appsearch/external/localstorage/stats/QueryStats.java b/service/java/com/android/server/appsearch/external/localstorage/stats/QueryStats.java
new file mode 100644
index 00000000..1efb569b
--- /dev/null
+++ b/service/java/com/android/server/appsearch/external/localstorage/stats/QueryStats.java
@@ -0,0 +1,757 @@
+/*
+ * Copyright 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.server.appsearch.external.localstorage.stats;
+
+import android.annotation.IntDef;
+import android.app.appsearch.AppSearchResult;
+import android.app.appsearch.AppSearchSchema.StringPropertyConfig.JoinableValueType;
+import android.app.appsearch.SearchSpec;
+import android.app.appsearch.annotation.CanIgnoreReturnValue;
+import android.app.appsearch.stats.BaseStats;
+
+import com.android.internal.util.Preconditions;
+
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.Objects;
+
+/**
+ * Class holds detailed stats for {@link android.app.appsearch.AppSearchSession#search(String,
+ * SearchSpec)}
+ *
+ * @hide
+ */
+public final class QueryStats extends BaseStats {
+    /** Types of Visibility scopes available for search. */
+    @IntDef(
+            value = {
+                // Searches apps' own documents.
+                VISIBILITY_SCOPE_LOCAL,
+                // Searches the global documents. Including platform surfaceable and 3p-access.
+                VISIBILITY_SCOPE_GLOBAL,
+                VISIBILITY_SCOPE_UNKNOWN,
+                // TODO(b/173532925) Add THIRD_PARTY_ACCESS once we can distinguish platform
+                //  surfaceable from 3p access(right both of them are categorized as
+                //  VISIBILITY_SCOPE_GLOBAL)
+            })
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface VisibilityScope {}
+
+    /** Types of page result for search. */
+    @IntDef(
+            value = {
+                PAGE_TOKEN_TYPE_NONE,
+                PAGE_TOKEN_TYPE_VALID,
+                PAGE_TOKEN_TYPE_NOT_FOUND,
+                PAGE_TOKEN_TYPE_EMPTY,
+            })
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface PageTokenType {}
+
+    // Default. Usually used when it is the first page.
+    public static final int PAGE_TOKEN_TYPE_NONE = 0;
+    public static final int PAGE_TOKEN_TYPE_VALID = 1;
+    // The current page token is not found in ResultStateManager. This is
+    // usually caused by cache eviction.
+    public static final int PAGE_TOKEN_TYPE_NOT_FOUND = 2;
+    // The current page token is empty (kInvalidNextPageToken).
+    public static final int PAGE_TOKEN_TYPE_EMPTY = 3;
+
+    // Searches apps' own documents.
+    public static final int VISIBILITY_SCOPE_LOCAL = 1;
+    // Searches the global documents. Including platform surfaceable and 3p-access.
+    public static final int VISIBILITY_SCOPE_GLOBAL = 2;
+    public static final int VISIBILITY_SCOPE_UNKNOWN = 3;
+
+    // TODO(b/173532925): Add a field searchType to indicate where the search is used(normal
+    //  query vs in removeByQuery vs during migration)
+
+    private final @NonNull String mPackageName;
+    private final @Nullable String mDatabase;
+
+    /**
+     * The status code returned by {@link AppSearchResult#getResultCode()} for the call or internal
+     * state.
+     */
+    @AppSearchResult.ResultCode private final int mStatusCode;
+
+    private final int mTotalLatencyMillis;
+
+    /** Time used to rewrite the search spec. */
+    private final int mRewriteSearchSpecLatencyMillis;
+
+    /** Time used to rewrite the search results. */
+    private final int mRewriteSearchResultLatencyMillis;
+
+    /** Time passed while waiting to acquire the lock during Java function calls. */
+    private final int mJavaLockAcquisitionLatencyMillis;
+
+    /**
+     * Time spent on ACL checking. This is the time spent filtering namespaces based on package
+     * permissions and Android permission access.
+     */
+    private final int mAclCheckLatencyMillis;
+
+    /** Defines the scope the query is searching over. */
+    @VisibilityScope private final int mVisibilityScope;
+
+    private final @Nullable String mSearchSourceLogTag;
+
+    /**
+     * Whether the function call is querying the first page. If it's not, Icing will fetch the
+     * results from cache so that some steps may be skipped.
+     */
+    private final boolean mNativeIsFirstPage;
+
+    /**
+     * The number of additional pages retrieved after the first page if it did not retrieve enough
+     * results.
+     */
+    private final int mAdditionalPageCount;
+
+    /** The requested number of results in one page. */
+    private final int mNativeRequestedPageSize;
+
+    /** The actual number of results returned in the current page. */
+    private final int mNativeNumResultsReturnedCurrentPage;
+
+    /**
+     * The number of results returned in all additional pages that are retrieved if the first page
+     * did not retrieve enough results.
+     */
+    private final int mNumResultsReturnedAdditionalPages;
+
+    /** Overall time used for the native function call. */
+    private final int mNativeLatencyMillis;
+
+    /**
+     * Overall time used for retrieving additional pages if the first page did not retrieve enough
+     * results.
+     */
+    private final int mAdditionalPageRetrievalLatencyMillis;
+
+    /** Time used to rank the scored results. */
+    private final int mNativeRankingLatencyMillis;
+
+    /**
+     * Time used to fetch the document protos. Note that it includes the time to snippet if {@link
+     * QueryStats#mNativeNumResultsWithSnippets} is greater than 0.
+     */
+    private final int mNativeDocumentRetrievingLatencyMillis;
+
+    /** How many snippets are calculated. */
+    private final int mNativeNumResultsWithSnippets;
+
+    /** Time passed while waiting to acquire the lock during native function calls. */
+    private final int mNativeLockAcquisitionLatencyMillis;
+
+    /** Time used to send data across the JNI boundary from java to native side. */
+    private final int mJavaToNativeJniLatencyMillis;
+
+    /** Time used to send data across the JNI boundary from native to java side. */
+    private final int mNativeToJavaJniLatencyMillis;
+
+    /** Time taken to join documents together. */
+    private final int mNativeJoinLatencyMillis;
+
+    /** The total number of joined documents in the current page. */
+    private final int mNativeNumJoinedResultsCurrentPage;
+
+    /** The type of join performed. Zero if no join is performed */
+    @JoinableValueType private final int mJoinType;
+
+    private final SearchStats mParentSearchStats;
+    private final SearchStats mChildSearchStats;
+    private final long mLiteIndexHitBufferByteSize;
+    private final long mLiteIndexHitBufferUnsortedByteSize;
+    // The type of the input page token.
+    @PageTokenType int mPageTokenType;
+    // Number of result states being force-evicted from ResultStateManager due to
+    // budget limit. This doesn't include expired or invalidated states.
+    int mNumResultStatesEvicted;
+
+    QueryStats(@NonNull Builder builder) {
+        super(builder);
+        mPackageName = builder.mPackageName;
+        mDatabase = builder.mDatabase;
+        mStatusCode = builder.mStatusCode;
+        mTotalLatencyMillis = builder.mTotalLatencyMillis;
+        mRewriteSearchSpecLatencyMillis = builder.mRewriteSearchSpecLatencyMillis;
+        mRewriteSearchResultLatencyMillis = builder.mRewriteSearchResultLatencyMillis;
+        mJavaLockAcquisitionLatencyMillis = builder.mJavaLockAcquisitionLatencyMillis;
+        mAclCheckLatencyMillis = builder.mAclCheckLatencyMillis;
+        mVisibilityScope = builder.mVisibilityScope;
+        mSearchSourceLogTag = builder.mSearchSourceLogTag;
+        mNativeIsFirstPage = builder.mNativeIsFirstPage;
+        mAdditionalPageCount = builder.mAdditionalPageCount;
+        mNativeRequestedPageSize = builder.mNativeRequestedPageSize;
+        mNativeNumResultsReturnedCurrentPage = builder.mNativeNumResultsReturnedCurrentPage;
+        mNumResultsReturnedAdditionalPages = builder.mNumResultsReturnedAdditionalPages;
+        mNativeLatencyMillis = builder.mNativeLatencyMillis;
+        mAdditionalPageRetrievalLatencyMillis = builder.mAdditionalPageRetrievalLatencyMillis;
+        mNativeRankingLatencyMillis = builder.mNativeRankingLatencyMillis;
+        mNativeDocumentRetrievingLatencyMillis = builder.mNativeDocumentRetrievingLatencyMillis;
+        mNativeNumResultsWithSnippets = builder.mNativeNumResultsWithSnippets;
+        mNativeLockAcquisitionLatencyMillis = builder.mNativeLockAcquisitionLatencyMillis;
+        mJavaToNativeJniLatencyMillis = builder.mJavaToNativeJniLatencyMillis;
+        mNativeToJavaJniLatencyMillis = builder.mNativeToJavaJniLatencyMillis;
+        mNativeJoinLatencyMillis = builder.mNativeJoinLatencyMillis;
+        mNativeNumJoinedResultsCurrentPage = builder.mNativeNumJoinedResultsCurrentPage;
+        mJoinType = builder.mJoinType;
+        mParentSearchStats = builder.mParentSearchStats;
+        mChildSearchStats = builder.mChildSearchStats;
+        mLiteIndexHitBufferByteSize = builder.mLiteIndexHitBufferByteSize;
+        mLiteIndexHitBufferUnsortedByteSize = builder.mLiteIndexHitBufferUnsortedByteSize;
+        mPageTokenType = builder.mPageTokenType;
+        mNumResultStatesEvicted = builder.mNumResultStatesEvicted;
+    }
+
+    /** Returns the package name of the session. */
+    public @NonNull String getPackageName() {
+        return mPackageName;
+    }
+
+    /**
+     * Returns the database name of the session.
+     *
+     * @return database name used by the session. {@code null} if and only if it is a global
+     *     search(visibilityScope is {@link QueryStats#VISIBILITY_SCOPE_GLOBAL}).
+     */
+    public @Nullable String getDatabase() {
+        return mDatabase;
+    }
+
+    /** Returns status of the search. */
+    @AppSearchResult.ResultCode
+    public int getStatusCode() {
+        return mStatusCode;
+    }
+
+    /** Returns the total latency of the search. */
+    public int getTotalLatencyMillis() {
+        return mTotalLatencyMillis;
+    }
+
+    /** Returns how much time spent on rewriting the {@link SearchSpec}. */
+    public int getRewriteSearchSpecLatencyMillis() {
+        return mRewriteSearchSpecLatencyMillis;
+    }
+
+    /** Returns how much time spent on rewriting the {@link android.app.appsearch.SearchResult}. */
+    public int getRewriteSearchResultLatencyMillis() {
+        return mRewriteSearchResultLatencyMillis;
+    }
+
+    /** Returns time passed while waiting to acquire the lock during Java function calls */
+    public int getJavaLockAcquisitionLatencyMillis() {
+        return mJavaLockAcquisitionLatencyMillis;
+    }
+
+    /**
+     * Returns time spent on ACL checking, which is the time spent filtering namespaces based on
+     * package permissions and Android permission access.
+     */
+    public int getAclCheckLatencyMillis() {
+        return mAclCheckLatencyMillis;
+    }
+
+    /** Returns the visibility scope of the search. */
+    @VisibilityScope
+    public int getVisibilityScope() {
+        return mVisibilityScope;
+    }
+
+    /** Returns a tag to indicate the source of this search, or {code null} if never set. */
+    public @Nullable String getSearchSourceLogTag() {
+        return mSearchSourceLogTag;
+    }
+
+    // TODO(b/185184738) Make it an integer to show how many pages having been returned.
+    /** Returns whether the function call is querying the first page. */
+    public boolean isFirstPage() {
+        return mNativeIsFirstPage;
+    }
+
+    /**
+     * Returns the number of additional pages retrieved after the first page if it did not return
+     * enough results.
+     */
+    public int getAdditionalPageCount() {
+        return mAdditionalPageCount;
+    }
+
+    /** Returns the requested number of results in one page. */
+    public int getRequestedPageSize() {
+        return mNativeRequestedPageSize;
+    }
+
+    /** Returns the actual number of results returned in the current page. */
+    public int getCurrentPageReturnedResultCount() {
+        return mNativeNumResultsReturnedCurrentPage;
+    }
+
+    /**
+     * Returns the number of results returned in all additional pages that are retrieved if the
+     * first page did not retrieve enough results.
+     */
+    public int getAdditionalPagesReturnedResultCount() {
+        return mNumResultsReturnedAdditionalPages;
+    }
+
+    /** Returns how much time spent on the native calls. */
+    public int getNativeLatencyMillis() {
+        return mNativeLatencyMillis;
+    }
+
+    /**
+     * Returns how much time is spent retrieving additional pages if the first page did not return
+     * enough results.
+     */
+    public int getAdditionalPageRetrievalLatencyMillis() {
+        return mAdditionalPageRetrievalLatencyMillis;
+    }
+
+    /** Returns time used to rank the scored results. */
+    public int getRankingLatencyMillis() {
+        return mNativeRankingLatencyMillis;
+    }
+
+    /**
+     * Returns time used to fetch the document protos. Note that it includes the time to snippet if
+     * {@link QueryStats#mNativeNumResultsWithSnippets} is not zero.
+     */
+    public int getDocumentRetrievingLatencyMillis() {
+        return mNativeDocumentRetrievingLatencyMillis;
+    }
+
+    /** Returns the number of the results in the page returned were snippeted. */
+    public int getResultWithSnippetsCount() {
+        return mNativeNumResultsWithSnippets;
+    }
+
+    /** Returns time passed while waiting to acquire the lock during native function calls. */
+    public int getNativeLockAcquisitionLatencyMillis() {
+        return mNativeLockAcquisitionLatencyMillis;
+    }
+
+    /** Returns time used to send data across the JNI boundary from java to native side. */
+    public int getJavaToNativeJniLatencyMillis() {
+        return mJavaToNativeJniLatencyMillis;
+    }
+
+    /** Returns time used to send data across the JNI boundary from native to java side. */
+    public int getNativeToJavaJniLatencyMillis() {
+        return mNativeToJavaJniLatencyMillis;
+    }
+
+    /** Returns the time taken to join documents together. */
+    public int getJoinLatencyMillis() {
+        return mNativeJoinLatencyMillis;
+    }
+
+    /** Returns the total number of joined documents in the current page. */
+    public int getNumJoinedResultsCurrentPage() {
+        return mNativeNumJoinedResultsCurrentPage;
+    }
+
+    /** Returns the type of join performed. Blank if no join is performed */
+    public @JoinableValueType int getJoinType() {
+        return mJoinType;
+    }
+
+    /**
+     * Returns a search stats for parent. Only valid for first page, or {code null} if never set.
+     */
+    public @Nullable SearchStats getParentSearchStats() {
+        return mParentSearchStats;
+    }
+
+    /** Returns a search stats for child. Only valid for first page, or {code null} if never set. */
+    public @Nullable SearchStats getChildSearchStats() {
+        return mChildSearchStats;
+    }
+
+    /** Returns the byte size of the lite index hit buffer. */
+    public long getLiteIndexHitBufferByteSize() {
+        return mLiteIndexHitBufferByteSize;
+    }
+
+    /** Returns the byte size of the unsorted tail of the lite index hit buffer. */
+    public long getLiteIndexHitBufferUnsortedByteSize() {
+        return mLiteIndexHitBufferUnsortedByteSize;
+    }
+
+    /** Returns the type of the input page token. */
+    @PageTokenType
+    public int getPageTokenType() {
+        return mPageTokenType;
+    }
+
+    /** Returns the type of the input page token. */
+    public int getNumResultStatesEvicted() {
+        return mNumResultStatesEvicted;
+    }
+
+    @NonNull
+    @Override
+    public String toString() {
+        return String.format(
+                "QueryStats {\n"
+                        + "package=%s, database=%s, status=%d, total_latency=%d, "
+                        + "rewrite_search_spec_latency=%d,\n"
+                        + "rewrite_search_result_latency=%d, java_lock_acquisition_latency=%d, "
+                        + "acl_check_latency=%d, visibility_score=%d,\n"
+                        + "search_source_log_tag=%s, is_first_page=%b, requested_page_size=%d, "
+                        + "num_results_returned_current_page=%d,\n"
+                        + "native_latency=%d, ranking_latency=%d, document_retrieving_latency=%d, "
+                        + "num_results_with_snippets=%d,\n"
+                        + "native_lock_acquisition_latency=%d, java_to_native_jni_latency=%d, "
+                        + "native_to_java_jni_latency=%d,\n"
+                        + "join_latency_ms=%d, num_joined_results_current_page=%d, join_type=%d, "
+                        + "lite_index_hit_buffer_byte_size=%d,\n"
+                        + "lite_index_hit_buffer_unsorted_byte_size=%d\n"
+                        + "page_token_type=%d, num_result_states_evicted=%d\n"
+                        + "parent_search_stats=%s,\n child_search_stats=%s}",
+                mPackageName,
+                mDatabase,
+                mStatusCode,
+                mTotalLatencyMillis,
+                mRewriteSearchSpecLatencyMillis,
+                mRewriteSearchResultLatencyMillis,
+                mJavaLockAcquisitionLatencyMillis,
+                mAclCheckLatencyMillis,
+                mVisibilityScope,
+                mSearchSourceLogTag,
+                mNativeIsFirstPage,
+                mNativeRequestedPageSize,
+                mNativeNumResultsReturnedCurrentPage,
+                mNativeLatencyMillis,
+                mNativeRankingLatencyMillis,
+                mNativeDocumentRetrievingLatencyMillis,
+                mNativeNumResultsWithSnippets,
+                mNativeLockAcquisitionLatencyMillis,
+                mJavaToNativeJniLatencyMillis,
+                mNativeToJavaJniLatencyMillis,
+                mNativeJoinLatencyMillis,
+                mNativeNumJoinedResultsCurrentPage,
+                mJoinType,
+                mLiteIndexHitBufferByteSize,
+                mLiteIndexHitBufferUnsortedByteSize,
+                mPageTokenType,
+                mNumResultStatesEvicted,
+                mParentSearchStats.toString(),
+                mChildSearchStats.toString());
+    }
+
+    /** Builder for {@link QueryStats} */
+    public static class Builder extends BaseStats.Builder<QueryStats.Builder> {
+        final @NonNull String mPackageName;
+        @Nullable String mDatabase;
+        @AppSearchResult.ResultCode int mStatusCode;
+        int mTotalLatencyMillis;
+        int mRewriteSearchSpecLatencyMillis;
+        int mRewriteSearchResultLatencyMillis;
+        int mJavaLockAcquisitionLatencyMillis;
+        int mAclCheckLatencyMillis;
+        int mVisibilityScope;
+        @Nullable String mSearchSourceLogTag;
+        boolean mNativeIsFirstPage;
+        int mAdditionalPageCount;
+        int mNativeRequestedPageSize;
+        int mNativeNumResultsReturnedCurrentPage;
+        int mNumResultsReturnedAdditionalPages;
+        int mNativeLatencyMillis;
+        int mAdditionalPageRetrievalLatencyMillis;
+        int mNativeRankingLatencyMillis;
+        int mNativeDocumentRetrievingLatencyMillis;
+        int mNativeNumResultsWithSnippets;
+        int mNativeLockAcquisitionLatencyMillis;
+        int mJavaToNativeJniLatencyMillis;
+        int mNativeToJavaJniLatencyMillis;
+        int mNativeJoinLatencyMillis;
+        int mNativeNumJoinedResultsCurrentPage;
+        @JoinableValueType int mJoinType;
+        SearchStats mParentSearchStats;
+        SearchStats mChildSearchStats;
+        long mLiteIndexHitBufferByteSize;
+        long mLiteIndexHitBufferUnsortedByteSize;
+        @PageTokenType int mPageTokenType;
+        int mNumResultStatesEvicted;
+
+        /**
+         * Constructor of {@link QueryStats}.
+         *
+         * @param visibilityScope scope for the corresponding search.
+         * @param packageName name of the calling package.
+         */
+        public Builder(@VisibilityScope int visibilityScope, @NonNull String packageName) {
+            mVisibilityScope = visibilityScope;
+            mPackageName = Objects.requireNonNull(packageName);
+        }
+
+        /** Sets the database used by the session. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setDatabase(@Nullable String database) {
+            mDatabase = database;
+            return this;
+        }
+
+        /** Sets the status of the search. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setStatusCode(@AppSearchResult.ResultCode int statusCode) {
+            mStatusCode = statusCode;
+            return this;
+        }
+
+        /** Sets total latency for the search. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setTotalLatencyMillis(int totalLatencyMillis) {
+            mTotalLatencyMillis = totalLatencyMillis;
+            return this;
+        }
+
+        /** Sets time used to rewrite the search spec. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setRewriteSearchSpecLatencyMillis(
+                int rewriteSearchSpecLatencyMillis) {
+            mRewriteSearchSpecLatencyMillis = rewriteSearchSpecLatencyMillis;
+            return this;
+        }
+
+        /** Sets time used to rewrite the search results. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setRewriteSearchResultLatencyMillis(
+                int rewriteSearchResultLatencyMillis) {
+            mRewriteSearchResultLatencyMillis = rewriteSearchResultLatencyMillis;
+            return this;
+        }
+
+        /** Sets time passed while waiting to acquire the lock during Java function calls. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setJavaLockAcquisitionLatencyMillis(
+                int javaLockAcquisitionLatencyMillis) {
+            mJavaLockAcquisitionLatencyMillis = javaLockAcquisitionLatencyMillis;
+            return this;
+        }
+
+        /**
+         * Sets time spent on ACL checking, which is the time spent filtering namespaces based on
+         * package permissions and Android permission access.
+         */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setAclCheckLatencyMillis(int aclCheckLatencyMillis) {
+            mAclCheckLatencyMillis = aclCheckLatencyMillis;
+            return this;
+        }
+
+        /** Sets a tag to indicate the source of this search. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setSearchSourceLogTag(@Nullable String searchSourceLogTag) {
+            mSearchSourceLogTag = searchSourceLogTag;
+            return this;
+        }
+
+        /**
+         * Sets whether the function call is querying the first page. If it's not, Icing will fetch
+         * the results from cache so that some steps may be skipped.
+         */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setIsFirstPage(boolean nativeIsFirstPage) {
+            mNativeIsFirstPage = nativeIsFirstPage;
+            return this;
+        }
+
+        /** Sets the actual number of results returned in the current page. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setAdditionalPagesReturnedResultCount(
+                int additionalPagesReturnedResultCount) {
+            mNumResultsReturnedAdditionalPages = additionalPagesReturnedResultCount;
+            return this;
+        }
+
+        /** Sets the requested number of results in one page. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setRequestedPageSize(int requestedPageSize) {
+            mNativeRequestedPageSize = requestedPageSize;
+            return this;
+        }
+
+        /** Sets the actual number of results returned in the current page. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setCurrentPageReturnedResultCount(
+                int currentPageReturnedResultCount) {
+            mNativeNumResultsReturnedCurrentPage = currentPageReturnedResultCount;
+            return this;
+        }
+
+        /**
+         * Sets the number of additional pages retrieved after the first one if it did not return
+         * enough results.
+         */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setAdditionalPageCount(int additionalPageCount) {
+            mAdditionalPageCount = additionalPageCount;
+            return this;
+        }
+
+        /** Sets overall time used for the native function calls. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setNativeLatencyMillis(int nativeLatencyMillis) {
+            mNativeLatencyMillis = nativeLatencyMillis;
+            return this;
+        }
+
+        /**
+         * Sets overall time used for retrieving additional pages if the first page did not return
+         * enough results.
+         */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setAdditionalPageRetrievalLatencyMillis(
+                int additionalPageRetrievalLatencyMillis) {
+            mAdditionalPageRetrievalLatencyMillis = additionalPageRetrievalLatencyMillis;
+            return this;
+        }
+
+        /** Sets time used to rank the scored results. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setRankingLatencyMillis(int rankingLatencyMillis) {
+            mNativeRankingLatencyMillis = rankingLatencyMillis;
+            return this;
+        }
+
+        /** Sets time used to fetch the document protos. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setDocumentRetrievingLatencyMillis(
+                int documentRetrievingLatencyMillis) {
+            mNativeDocumentRetrievingLatencyMillis = documentRetrievingLatencyMillis;
+            return this;
+        }
+
+        /** Sets how many snippets are calculated. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setResultWithSnippetsCount(int resultWithSnippetsCount) {
+            mNativeNumResultsWithSnippets = resultWithSnippetsCount;
+            return this;
+        }
+
+        /** Sets time passed while waiting to acquire the lock during native function calls. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setNativeLockAcquisitionLatencyMillis(
+                int nativeLockAcquisitionLatencyMillis) {
+            mNativeLockAcquisitionLatencyMillis = nativeLockAcquisitionLatencyMillis;
+            return this;
+        }
+
+        /** Sets time used to send data across the JNI boundary from java to native side. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setJavaToNativeJniLatencyMillis(int javaToNativeJniLatencyMillis) {
+            mJavaToNativeJniLatencyMillis = javaToNativeJniLatencyMillis;
+            return this;
+        }
+
+        /** Sets time used to send data across the JNI boundary from native to java side. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setNativeToJavaJniLatencyMillis(int nativeToJavaJniLatencyMillis) {
+            mNativeToJavaJniLatencyMillis = nativeToJavaJniLatencyMillis;
+            return this;
+        }
+
+        /** Sets time it takes to join documents together in icing. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setNativeJoinLatencyMillis(int nativeJoinLatencyMillis) {
+            mNativeJoinLatencyMillis = nativeJoinLatencyMillis;
+            return this;
+        }
+
+        /** Set the total number of joined documents in a page. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setNativeNumJoinedResultsCurrentPage(
+                int nativeNumJoinedResultsCurrentPage) {
+            mNativeNumJoinedResultsCurrentPage = nativeNumJoinedResultsCurrentPage;
+            return this;
+        }
+
+        /** Sets whether or not this is a join query */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setJoinType(@JoinableValueType int joinType) {
+            mJoinType = joinType;
+            return this;
+        }
+
+        /** Sets search stats for parent. Only valid for first page. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setParentSearchStats(@Nullable SearchStats parentSearchStats) {
+            mParentSearchStats = parentSearchStats;
+            return this;
+        }
+
+        /** Sets search stats for child. Only valid for first page. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setChildSearchStats(@Nullable SearchStats childSearchStats) {
+            mChildSearchStats = childSearchStats;
+            return this;
+        }
+
+        /** Sets byte size of the lite index hit buffer. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setLiteIndexHitBufferByteSize(long liteIndexHitBufferByteSize) {
+            mLiteIndexHitBufferByteSize = liteIndexHitBufferByteSize;
+            return this;
+        }
+
+        /** Sets byte size of the unsorted tail of the lite index hit buffer. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setLiteIndexHitBufferUnsortedByteSize(
+                long liteIndexHitBufferUnsortedByteSize) {
+            mLiteIndexHitBufferUnsortedByteSize = liteIndexHitBufferUnsortedByteSize;
+            return this;
+        }
+
+        /** Sets the type of the input page token. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setPageTokenType(@PageTokenType int pageTokenType) {
+            mPageTokenType = pageTokenType;
+            return this;
+        }
+
+        /**
+         * Sets the Number of result states being force-evicted from ResultStateManager due to
+         * budget limit. This doesn't include expired or invalidated states.
+         */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setNumResultStatsEvicted(int numResultStatesEvicted) {
+            mNumResultStatesEvicted = numResultStatesEvicted;
+            return this;
+        }
+
+        /**
+         * Constructs a new {@link QueryStats} from the contents of this {@link QueryStats.Builder}.
+         */
+        @Override
+        public @NonNull QueryStats build() {
+            if (mDatabase == null) {
+                Preconditions.checkState(
+                        mVisibilityScope != QueryStats.VISIBILITY_SCOPE_LOCAL,
+                        "database can not be null if visibilityScope is local.");
+            }
+
+            return new QueryStats(/* builder= */ this);
+        }
+    }
+}
diff --git a/service/java/com/android/server/appsearch/external/localstorage/stats/RemoveStats.java b/service/java/com/android/server/appsearch/external/localstorage/stats/RemoveStats.java
index 6d791dc6..52620f4c 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/stats/RemoveStats.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/stats/RemoveStats.java
@@ -79,6 +79,12 @@ public final class RemoveStats extends BaseStats {
     private final int mNativeLatencyMillis;
     @DeleteType private final int mNativeDeleteType;
     private final int mNativeNumDocumentsDeleted;
+    private final int mQueryLength;
+    private final int mNumTerms;
+    private final int mNumNamespacesFiltered;
+    private final int mNumSchemaTypesFiltered;
+    private final int mParseQueryLatencyMillis;
+    private final int mDocumentRemovalLatencyMillis;
 
     RemoveStats(@NonNull Builder builder) {
         super(builder);
@@ -89,6 +95,12 @@ public final class RemoveStats extends BaseStats {
         mNativeLatencyMillis = builder.mNativeLatencyMillis;
         mNativeDeleteType = builder.mNativeDeleteType;
         mNativeNumDocumentsDeleted = builder.mNativeNumDocumentsDeleted;
+        mQueryLength = builder.mQueryLength;
+        mNumTerms = builder.mNumTerms;
+        mNumNamespacesFiltered = builder.mNumNamespacesFiltered;
+        mNumSchemaTypesFiltered = builder.mNumSchemaTypesFiltered;
+        mParseQueryLatencyMillis = builder.mParseQueryLatencyMillis;
+        mDocumentRemovalLatencyMillis = builder.mDocumentRemovalLatencyMillis;
     }
 
     /** Returns calling package name. */
@@ -128,6 +140,39 @@ public final class RemoveStats extends BaseStats {
         return mNativeNumDocumentsDeleted;
     }
 
+    /** The UTF-8 length of the query string. */
+    public int getQueryLength() {
+        return mQueryLength;
+    }
+
+    /** Number of terms in the query string. */
+    public int getNumTerms() {
+        return mNumTerms;
+    }
+
+    /** Number of namespaces filtered. */
+    public int getNumNamespacesFiltered() {
+        return mNumNamespacesFiltered;
+    }
+
+    /** Number of schema types filtered.. */
+    public int getNumSchemaTypesFiltered() {
+        return mNumSchemaTypesFiltered;
+    }
+
+    /**
+     * Returns the time used to parse the query, including 2 parts: tokenizing and transforming
+     * tokens into an iterator tree.
+     */
+    public int getParseQueryLatencyMillis() {
+        return mParseQueryLatencyMillis;
+    }
+
+    /** Returns the time used to delete each document */
+    public int getDocumentRemovalLatencyMillis() {
+        return mDocumentRemovalLatencyMillis;
+    }
+
     /** Builder for {@link RemoveStats}. */
     public static class Builder extends BaseStats.Builder<RemoveStats.Builder> {
         final @NonNull String mPackageName;
@@ -137,6 +182,12 @@ public final class RemoveStats extends BaseStats {
         int mNativeLatencyMillis;
         @DeleteType int mNativeDeleteType;
         int mNativeNumDocumentsDeleted;
+        int mQueryLength;
+        int mNumTerms;
+        int mNumNamespacesFiltered;
+        int mNumSchemaTypesFiltered;
+        int mParseQueryLatencyMillis;
+        int mDocumentRemovalLatencyMillis;
 
         /** Constructor for the {@link Builder}. */
         public Builder(@NonNull String packageName, @NonNull String database) {
@@ -179,6 +230,51 @@ public final class RemoveStats extends BaseStats {
             return this;
         }
 
+        /** Sets the UTF-8 length of the query string. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setQueryLength(int queryLength) {
+            mQueryLength = queryLength;
+            return this;
+        }
+
+        /** Sets number of terms in the query string. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setNumTerms(int numTerms) {
+            mNumTerms = numTerms;
+            return this;
+        }
+
+        /** Sets number of namespaces filtered. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setNumNamespacesFiltered(int numNamespacesFiltered) {
+            mNumNamespacesFiltered = numNamespacesFiltered;
+            return this;
+        }
+
+        /** Sets number of schema types filtered. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setNumSchemaTypesFiltered(int numSchemaTypesFiltered) {
+            mNumSchemaTypesFiltered = numSchemaTypesFiltered;
+            return this;
+        }
+
+        /**
+         * Sets time used to parse the query, including 2 parts: tokenizing and transforming tokens
+         * into an iterator tree.
+         */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setParseQueryLatencyMillis(int parseQueryLatencyMillis) {
+            mParseQueryLatencyMillis = parseQueryLatencyMillis;
+            return this;
+        }
+
+        /** Sets Time used to delete each document. */
+        @CanIgnoreReturnValue
+        public @NonNull Builder setDocumentRemovalLatencyMillis(int documentRemovalLatencyMillis) {
+            mDocumentRemovalLatencyMillis = documentRemovalLatencyMillis;
+            return this;
+        }
+
         /** Creates a {@link RemoveStats}. */
         @Override
         public @NonNull RemoveStats build() {
diff --git a/service/java/com/android/server/appsearch/external/localstorage/stats/SearchStats.java b/service/java/com/android/server/appsearch/external/localstorage/stats/SearchStats.java
index bc8b3be6..f9f96e78 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/stats/SearchStats.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/stats/SearchStats.java
@@ -15,108 +15,38 @@
  */
 package com.android.server.appsearch.external.localstorage.stats;
 
-import android.annotation.IntDef;
-import android.app.appsearch.AppSearchResult;
-import android.app.appsearch.AppSearchSchema.StringPropertyConfig.JoinableValueType;
 import android.app.appsearch.SearchSpec;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
-import android.app.appsearch.stats.BaseStats;
-
-import com.android.internal.util.Preconditions;
 
 import org.jspecify.annotations.NonNull;
-import org.jspecify.annotations.Nullable;
-
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.util.Objects;
 
 /**
  * Class holds detailed stats for {@link android.app.appsearch.AppSearchSession#search(String,
- * SearchSpec)}
+ * SearchSpec)}.
+ *
+ * <p>Only valid for first page.
  *
  * @hide
  */
-public final class SearchStats extends BaseStats {
-    /** Types of Visibility scopes available for search. */
-    @IntDef(
-            value = {
-                // Searches apps' own documents.
-                VISIBILITY_SCOPE_LOCAL,
-                // Searches the global documents. Including platform surfaceable and 3p-access.
-                VISIBILITY_SCOPE_GLOBAL,
-                VISIBILITY_SCOPE_UNKNOWN,
-                // TODO(b/173532925) Add THIRD_PARTY_ACCESS once we can distinguish platform
-                //  surfaceable from 3p access(right both of them are categorized as
-                //  VISIBILITY_SCOPE_GLOBAL)
-            })
-    @Retention(RetentionPolicy.SOURCE)
-    public @interface VisibilityScope {}
-
-    // Searches apps' own documents.
-    public static final int VISIBILITY_SCOPE_LOCAL = 1;
-    // Searches the global documents. Including platform surfaceable and 3p-access.
-    public static final int VISIBILITY_SCOPE_GLOBAL = 2;
-    public static final int VISIBILITY_SCOPE_UNKNOWN = 3;
-
-    // TODO(b/173532925): Add a field searchType to indicate where the search is used(normal
-    //  query vs in removeByQuery vs during migration)
-
-    private final @NonNull String mPackageName;
-    private final @Nullable String mDatabase;
-
-    /**
-     * The status code returned by {@link AppSearchResult#getResultCode()} for the call or internal
-     * state.
-     */
-    @AppSearchResult.ResultCode private final int mStatusCode;
+public final class SearchStats {
 
-    private final int mTotalLatencyMillis;
-
-    /** Time used to rewrite the search spec. */
-    private final int mRewriteSearchSpecLatencyMillis;
-
-    /** Time used to rewrite the search results. */
-    private final int mRewriteSearchResultLatencyMillis;
-
-    /** Time passed while waiting to acquire the lock during Java function calls. */
-    private final int mJavaLockAcquisitionLatencyMillis;
-
-    /**
-     * Time spent on ACL checking. This is the time spent filtering namespaces based on package
-     * permissions and Android permission access.
-     */
-    private final int mAclCheckLatencyMillis;
-
-    /** Defines the scope the query is searching over. */
-    @VisibilityScope private final int mVisibilityScope;
-
-    /** Overall time used for the native function call. */
-    private final int mNativeLatencyMillis;
+    /** Length of the query string. */
+    private final int mNativeQueryLength;
 
     /** Number of terms in the query string. */
     private final int mNativeNumTerms;
 
-    /** Length of the query string. */
-    private final int mNativeQueryLength;
-
     /** Number of namespaces filtered. */
     private final int mNativeNumNamespacesFiltered;
 
     /** Number of schema types filtered. */
     private final int mNativeNumSchemaTypesFiltered;
 
-    /** The requested number of results in one page. */
-    private final int mNativeRequestedPageSize;
-
-    /** The actual number of results returned in the current page. */
-    private final int mNativeNumResultsReturnedCurrentPage;
+    /** Strategy of scoring and ranking. */
+    @SearchSpec.RankingStrategy private final int mNativeRankingStrategy;
 
-    /**
-     * Whether the function call is querying the first page. If it's not, Icing will fetch the
-     * results from cache so that some steps may be skipped.
-     */
-    private final boolean mNativeIsFirstPage;
+    /** Number of documents scored. */
+    private final int mNativeNumDocumentsScored;
 
     /**
      * Time used to parse the query, including 2 parts: tokenizing and transforming tokens into an
@@ -124,412 +54,220 @@ public final class SearchStats extends BaseStats {
      */
     private final int mNativeParseQueryLatencyMillis;
 
-    /** Strategy of scoring and ranking. */
-    @SearchSpec.RankingStrategy private final int mNativeRankingStrategy;
-
-    /** Number of documents scored. */
-    private final int mNativeNumDocumentsScored;
-
     /** Time used to score the raw results. */
     private final int mNativeScoringLatencyMillis;
 
-    /** Time used to rank the scored results. */
-    private final int mNativeRankingLatencyMillis;
+    /** Whether it contains numeric query or not. */
+    private final boolean mNativeIsNumericQuery;
 
-    /**
-     * Time used to fetch the document protos. Note that it includes the time to snippet if {@link
-     * SearchStats#mNativeNumResultsWithSnippets} is greater than 0.
-     */
-    private final int mNativeDocumentRetrievingLatencyMillis;
-
-    /** How many snippets are calculated. */
-    private final int mNativeNumResultsWithSnippets;
-
-    /** Time passed while waiting to acquire the lock during native function calls. */
-    private final int mNativeLockAcquisitionLatencyMillis;
-
-    /** Time used to send data across the JNI boundary from java to native side. */
-    private final int mJavaToNativeJniLatencyMillis;
+    /** Number of hits fetched by lite index before applying any filters. */
+    private final int mNativeNumFetchedHitsLiteIndex;
 
-    /** Time used to send data across the JNI boundary from native to java side. */
-    private final int mNativeToJavaJniLatencyMillis;
+    /** Number of hits fetched by main index before applying any filters. */
+    private final int mNativeNumFetchedHitsMainIndex;
 
-    /** The type of join performed. Zero if no join is performed */
-    @JoinableValueType private final int mJoinType;
+    /** Number of hits fetched by integer index before applying any filters. */
+    private final int mNativeNumFetchedHitsIntegerIndex;
 
-    /** The total number of joined documents in the current page. */
-    private final int mNativeNumJoinedResultsCurrentPage;
+    /** Time used in Lexer to extract lexer tokens from the query. */
+    private final int mNativeQueryProcessorLexerExtractTokenLatencyMillis;
 
-    /** Time taken to join documents together. */
-    private final int mNativeJoinLatencyMillis;
+    /** Time used in Parser to consume lexer tokens extracted from the query. */
+    private final int mNativeQueryProcessorParserConsumeQueryLatencyMillis;
 
-    private final @Nullable String mSearchSourceLogTag;
+    /** Time used in QueryVisitor to visit and build (nested) DocHitInfoIterator. */
+    private final int mNativeQueryProcessorQueryVisitorLatencyMillis;
 
     SearchStats(@NonNull Builder builder) {
-        super(builder);
-        mPackageName = builder.mPackageName;
-        mDatabase = builder.mDatabase;
-        mStatusCode = builder.mStatusCode;
-        mTotalLatencyMillis = builder.mTotalLatencyMillis;
-        mRewriteSearchSpecLatencyMillis = builder.mRewriteSearchSpecLatencyMillis;
-        mRewriteSearchResultLatencyMillis = builder.mRewriteSearchResultLatencyMillis;
-        mJavaLockAcquisitionLatencyMillis = builder.mJavaLockAcquisitionLatencyMillis;
-        mAclCheckLatencyMillis = builder.mAclCheckLatencyMillis;
-        mVisibilityScope = builder.mVisibilityScope;
-        mNativeLatencyMillis = builder.mNativeLatencyMillis;
-        mNativeNumTerms = builder.mNativeNumTerms;
         mNativeQueryLength = builder.mNativeQueryLength;
+        mNativeNumTerms = builder.mNativeNumTerms;
         mNativeNumNamespacesFiltered = builder.mNativeNumNamespacesFiltered;
         mNativeNumSchemaTypesFiltered = builder.mNativeNumSchemaTypesFiltered;
-        mNativeRequestedPageSize = builder.mNativeRequestedPageSize;
-        mNativeNumResultsReturnedCurrentPage = builder.mNativeNumResultsReturnedCurrentPage;
-        mNativeIsFirstPage = builder.mNativeIsFirstPage;
-        mNativeParseQueryLatencyMillis = builder.mNativeParseQueryLatencyMillis;
         mNativeRankingStrategy = builder.mNativeRankingStrategy;
         mNativeNumDocumentsScored = builder.mNativeNumDocumentsScored;
+        mNativeParseQueryLatencyMillis = builder.mNativeParseQueryLatencyMillis;
         mNativeScoringLatencyMillis = builder.mNativeScoringLatencyMillis;
-        mNativeRankingLatencyMillis = builder.mNativeRankingLatencyMillis;
-        mNativeNumResultsWithSnippets = builder.mNativeNumResultsWithSnippets;
-        mNativeDocumentRetrievingLatencyMillis = builder.mNativeDocumentRetrievingLatencyMillis;
-        mNativeLockAcquisitionLatencyMillis = builder.mNativeLockAcquisitionLatencyMillis;
-        mJavaToNativeJniLatencyMillis = builder.mJavaToNativeJniLatencyMillis;
-        mNativeToJavaJniLatencyMillis = builder.mNativeToJavaJniLatencyMillis;
-        mJoinType = builder.mJoinType;
-        mNativeNumJoinedResultsCurrentPage = builder.mNativeNumJoinedResultsCurrentPage;
-        mNativeJoinLatencyMillis = builder.mNativeJoinLatencyMillis;
-        mSearchSourceLogTag = builder.mSearchSourceLogTag;
+        mNativeIsNumericQuery = builder.mNativeIsNumericQuery;
+        mNativeNumFetchedHitsLiteIndex = builder.mNativeNumFetchedHitsLiteIndex;
+        mNativeNumFetchedHitsMainIndex = builder.mNativeNumFetchedHitsMainIndex;
+        mNativeNumFetchedHitsIntegerIndex = builder.mNativeNumFetchedHitsIntegerIndex;
+        mNativeQueryProcessorLexerExtractTokenLatencyMillis =
+                builder.mNativeQueryProcessorLexerExtractTokenLatencyMillis;
+        mNativeQueryProcessorParserConsumeQueryLatencyMillis =
+                builder.mNativeQueryProcessorParserConsumeQueryLatencyMillis;
+        mNativeQueryProcessorQueryVisitorLatencyMillis =
+                builder.mNativeQueryProcessorQueryVisitorLatencyMillis;
     }
 
-    /** Returns the package name of the session. */
-    public @NonNull String getPackageName() {
-        return mPackageName;
-    }
-
-    /**
-     * Returns the database name of the session.
-     *
-     * @return database name used by the session. {@code null} if and only if it is a global
-     *     search(visibilityScope is {@link SearchStats#VISIBILITY_SCOPE_GLOBAL}).
-     */
-    public @Nullable String getDatabase() {
-        return mDatabase;
-    }
-
-    /** Returns status of the search. */
-    @AppSearchResult.ResultCode
-    public int getStatusCode() {
-        return mStatusCode;
-    }
-
-    /** Returns the total latency of the search. */
-    public int getTotalLatencyMillis() {
-        return mTotalLatencyMillis;
-    }
-
-    /** Returns how much time spent on rewriting the {@link SearchSpec}. */
-    public int getRewriteSearchSpecLatencyMillis() {
-        return mRewriteSearchSpecLatencyMillis;
-    }
-
-    /** Returns how much time spent on rewriting the {@link android.app.appsearch.SearchResult}. */
-    public int getRewriteSearchResultLatencyMillis() {
-        return mRewriteSearchResultLatencyMillis;
-    }
-
-    /** Returns time passed while waiting to acquire the lock during Java function calls */
-    public int getJavaLockAcquisitionLatencyMillis() {
-        return mJavaLockAcquisitionLatencyMillis;
-    }
-
-    /**
-     * Returns time spent on ACL checking, which is the time spent filtering namespaces based on
-     * package permissions and Android permission access.
-     */
-    public int getAclCheckLatencyMillis() {
-        return mAclCheckLatencyMillis;
-    }
-
-    /** Returns the visibility scope of the search. */
-    @VisibilityScope
-    public int getVisibilityScope() {
-        return mVisibilityScope;
-    }
-
-    /** Returns how much time spent on the native calls. */
-    public int getNativeLatencyMillis() {
-        return mNativeLatencyMillis;
+    /** Returns the length of the search string. */
+    public int getNativeQueryLength() {
+        return mNativeQueryLength;
     }
 
     /** Returns number of terms in the search string. */
-    public int getTermCount() {
+    public int getNativeTermCount() {
         return mNativeNumTerms;
     }
 
-    /** Returns the length of the search string. */
-    public int getQueryLength() {
-        return mNativeQueryLength;
-    }
-
     /** Returns number of namespaces filtered. */
-    public int getFilteredNamespaceCount() {
+    public int getNativeFilteredNamespaceCount() {
         return mNativeNumNamespacesFiltered;
     }
 
     /** Returns number of schema types filtered. */
-    public int getFilteredSchemaTypeCount() {
+    public int getNativeFilteredSchemaTypeCount() {
         return mNativeNumSchemaTypesFiltered;
     }
 
-    /** Returns the requested number of results in one page. */
-    public int getRequestedPageSize() {
-        return mNativeRequestedPageSize;
-    }
-
-    /** Returns the actual number of results returned in the current page. */
-    public int getCurrentPageReturnedResultCount() {
-        return mNativeNumResultsReturnedCurrentPage;
+    /** Returns strategy of scoring and ranking. */
+    @SearchSpec.RankingStrategy
+    public int getNativeRankingStrategy() {
+        return mNativeRankingStrategy;
     }
 
-    // TODO(b/185184738) Make it an integer to show how many pages having been returned.
-    /** Returns whether the function call is querying the first page. */
-    public boolean isFirstPage() {
-        return mNativeIsFirstPage;
+    /** Returns number of documents scored. */
+    public int getNativeScoredDocumentCount() {
+        return mNativeNumDocumentsScored;
     }
 
     /**
      * Returns time used to parse the query, including 2 parts: tokenizing and transforming tokens
      * into an iterator tree.
      */
-    public int getParseQueryLatencyMillis() {
+    public int getNativeParseQueryLatencyMillis() {
         return mNativeParseQueryLatencyMillis;
     }
 
-    /** Returns strategy of scoring and ranking. */
-    @SearchSpec.RankingStrategy
-    public int getRankingStrategy() {
-        return mNativeRankingStrategy;
-    }
-
-    /** Returns number of documents scored. */
-    public int getScoredDocumentCount() {
-        return mNativeNumDocumentsScored;
-    }
-
     /** Returns time used to score the raw results. */
-    public int getScoringLatencyMillis() {
+    public int getNativeScoringLatencyMillis() {
         return mNativeScoringLatencyMillis;
     }
 
-    /** Returns time used to rank the scored results. */
-    public int getRankingLatencyMillis() {
-        return mNativeRankingLatencyMillis;
-    }
-
-    /**
-     * Returns time used to fetch the document protos. Note that it includes the time to snippet if
-     * {@link SearchStats#mNativeNumResultsWithSnippets} is not zero.
-     */
-    public int getDocumentRetrievingLatencyMillis() {
-        return mNativeDocumentRetrievingLatencyMillis;
+    /** Returns whether it contains numeric query or not. */
+    public boolean isNativeNumericQuery() {
+        return mNativeIsNumericQuery;
     }
 
-    /** Returns the number of the results in the page returned were snippeted. */
-    public int getResultWithSnippetsCount() {
-        return mNativeNumResultsWithSnippets;
+    /** Returns number of hits fetched by lite index before applying any filters. */
+    public int getNativeNumFetchedHitsLiteIndex() {
+        return mNativeNumFetchedHitsLiteIndex;
     }
 
-    /** Returns time passed while waiting to acquire the lock during native function calls. */
-    public int getNativeLockAcquisitionLatencyMillis() {
-        return mNativeLockAcquisitionLatencyMillis;
+    /** Returns number of hits fetched by main index before applying any filters. */
+    public int getNativeNumFetchedHitsMainIndex() {
+        return mNativeNumFetchedHitsMainIndex;
     }
 
-    /** Returns time used to send data across the JNI boundary from java to native side. */
-    public int getJavaToNativeJniLatencyMillis() {
-        return mJavaToNativeJniLatencyMillis;
+    /** Returns number of hits fetched by integer index before applying any filters. */
+    public int getNativeNumFetchedHitsIntegerIndex() {
+        return mNativeNumFetchedHitsIntegerIndex;
     }
 
-    /** Returns time used to send data across the JNI boundary from native to java side. */
-    public int getNativeToJavaJniLatencyMillis() {
-        return mNativeToJavaJniLatencyMillis;
+    /** Returns time used in Lexer to extract lexer tokens from the query. */
+    public int getNativeQueryProcessorLexerExtractTokenLatencyMillis() {
+        return mNativeQueryProcessorLexerExtractTokenLatencyMillis;
     }
 
-    /** Returns the type of join performed. Blank if no join is performed */
-    public @JoinableValueType int getJoinType() {
-        return mJoinType;
+    /** Returns time used in Parser to consume lexer tokens extracted from the query. */
+    public int getNativeQueryProcessorParserConsumeQueryLatencyMillis() {
+        return mNativeQueryProcessorParserConsumeQueryLatencyMillis;
     }
 
-    /** Returns the total number of joined documents in the current page. */
-    public int getNumJoinedResultsCurrentPage() {
-        return mNativeNumJoinedResultsCurrentPage;
+    /** Returns time used in QueryVisitor to visit and build (nested) DocHitInfoIterator. */
+    public int getNativeQueryProcessorQueryVisitorLatencyMillis() {
+        return mNativeQueryProcessorQueryVisitorLatencyMillis;
     }
 
-    /** Returns the time taken to join documents together. */
-    public int getJoinLatencyMillis() {
-        return mNativeJoinLatencyMillis;
-    }
-
-    /** Returns a tag to indicate the source of this search, or {code null} if never set. */
-    public @Nullable String getSearchSourceLogTag() {
-        return mSearchSourceLogTag;
+    @NonNull
+    @Override
+    public String toString() {
+        return String.format(
+                "SearchStats {\n"
+                        + "query_length=%d, num_terms=%d, num_namespaces_filtered=%d, "
+                        + "num_schema_types_filtered=%d,\n"
+                        + "ranking_strategy=%d, num_docs_scored=%d, parse_query_latency=%d, "
+                        + "scoring_latency=%d, is_numeric_query=%b,\n"
+                        + "num_fetched_hits_lite_index=%d, num_fetched_hits_main_index=%d, "
+                        + "num_fetched_hits_integer_index=%d,\n"
+                        + "query_processor_lexer_extract_token_latency=%d, "
+                        + "query_processor_parser_consume_query_latency=%d,\n"
+                        + "query_processor_query_visitor_latency=%d}",
+                mNativeQueryLength,
+                mNativeNumTerms,
+                mNativeNumNamespacesFiltered,
+                mNativeNumSchemaTypesFiltered,
+                mNativeRankingStrategy,
+                mNativeNumDocumentsScored,
+                mNativeParseQueryLatencyMillis,
+                mNativeScoringLatencyMillis,
+                mNativeIsNumericQuery,
+                mNativeNumFetchedHitsLiteIndex,
+                mNativeNumFetchedHitsMainIndex,
+                mNativeNumFetchedHitsIntegerIndex,
+                mNativeQueryProcessorLexerExtractTokenLatencyMillis,
+                mNativeQueryProcessorParserConsumeQueryLatencyMillis,
+                mNativeQueryProcessorQueryVisitorLatencyMillis);
     }
 
     /** Builder for {@link SearchStats} */
-    public static class Builder extends BaseStats.Builder<SearchStats.Builder> {
-        final @NonNull String mPackageName;
-        @Nullable String mDatabase;
-        @AppSearchResult.ResultCode int mStatusCode;
-        int mTotalLatencyMillis;
-        int mRewriteSearchSpecLatencyMillis;
-        int mRewriteSearchResultLatencyMillis;
-        int mJavaLockAcquisitionLatencyMillis;
-        int mAclCheckLatencyMillis;
-        int mVisibilityScope;
-        int mNativeLatencyMillis;
-        int mNativeNumTerms;
+    public static class Builder {
         int mNativeQueryLength;
+        int mNativeNumTerms;
         int mNativeNumNamespacesFiltered;
         int mNativeNumSchemaTypesFiltered;
-        int mNativeRequestedPageSize;
-        int mNativeNumResultsReturnedCurrentPage;
-        boolean mNativeIsFirstPage;
-        int mNativeParseQueryLatencyMillis;
-        int mNativeRankingStrategy;
+        @SearchSpec.RankingStrategy int mNativeRankingStrategy;
         int mNativeNumDocumentsScored;
+        int mNativeParseQueryLatencyMillis;
         int mNativeScoringLatencyMillis;
-        int mNativeRankingLatencyMillis;
-        int mNativeNumResultsWithSnippets;
-        int mNativeDocumentRetrievingLatencyMillis;
-        int mNativeLockAcquisitionLatencyMillis;
-        int mJavaToNativeJniLatencyMillis;
-        int mNativeToJavaJniLatencyMillis;
-        @JoinableValueType int mJoinType;
-        int mNativeNumJoinedResultsCurrentPage;
-        int mNativeJoinLatencyMillis;
-        @Nullable String mSearchSourceLogTag;
-
-        /**
-         * Constructor
-         *
-         * @param visibilityScope scope for the corresponding search.
-         * @param packageName name of the calling package.
-         */
-        public Builder(@VisibilityScope int visibilityScope, @NonNull String packageName) {
-            mVisibilityScope = visibilityScope;
-            mPackageName = Objects.requireNonNull(packageName);
-        }
-
-        /** Sets the database used by the session. */
-        @CanIgnoreReturnValue
-        public @NonNull Builder setDatabase(@Nullable String database) {
-            mDatabase = database;
-            return this;
-        }
-
-        /** Sets the status of the search. */
-        @CanIgnoreReturnValue
-        public @NonNull Builder setStatusCode(@AppSearchResult.ResultCode int statusCode) {
-            mStatusCode = statusCode;
-            return this;
-        }
-
-        /** Sets total latency for the search. */
-        @CanIgnoreReturnValue
-        public @NonNull Builder setTotalLatencyMillis(int totalLatencyMillis) {
-            mTotalLatencyMillis = totalLatencyMillis;
-            return this;
-        }
-
-        /** Sets time used to rewrite the search spec. */
-        @CanIgnoreReturnValue
-        public @NonNull Builder setRewriteSearchSpecLatencyMillis(
-                int rewriteSearchSpecLatencyMillis) {
-            mRewriteSearchSpecLatencyMillis = rewriteSearchSpecLatencyMillis;
-            return this;
-        }
+        boolean mNativeIsNumericQuery;
+        int mNativeNumFetchedHitsLiteIndex;
+        int mNativeNumFetchedHitsMainIndex;
+        int mNativeNumFetchedHitsIntegerIndex;
+        int mNativeQueryProcessorLexerExtractTokenLatencyMillis;
+        int mNativeQueryProcessorParserConsumeQueryLatencyMillis;
+        int mNativeQueryProcessorQueryVisitorLatencyMillis;
 
-        /** Sets time used to rewrite the search results. */
-        @CanIgnoreReturnValue
-        public @NonNull Builder setRewriteSearchResultLatencyMillis(
-                int rewriteSearchResultLatencyMillis) {
-            mRewriteSearchResultLatencyMillis = rewriteSearchResultLatencyMillis;
-            return this;
-        }
-
-        /** Sets time passed while waiting to acquire the lock during Java function calls. */
-        @CanIgnoreReturnValue
-        public @NonNull Builder setJavaLockAcquisitionLatencyMillis(
-                int javaLockAcquisitionLatencyMillis) {
-            mJavaLockAcquisitionLatencyMillis = javaLockAcquisitionLatencyMillis;
-            return this;
-        }
-
-        /**
-         * Sets time spent on ACL checking, which is the time spent filtering namespaces based on
-         * package permissions and Android permission access.
-         */
-        @CanIgnoreReturnValue
-        public @NonNull Builder setAclCheckLatencyMillis(int aclCheckLatencyMillis) {
-            mAclCheckLatencyMillis = aclCheckLatencyMillis;
-            return this;
-        }
-
-        /** Sets overall time used for the native function calls. */
+        /** Sets length of the search string. */
         @CanIgnoreReturnValue
-        public @NonNull Builder setNativeLatencyMillis(int nativeLatencyMillis) {
-            mNativeLatencyMillis = nativeLatencyMillis;
+        public @NonNull Builder setNativeQueryLength(int nativeQueryLength) {
+            mNativeQueryLength = nativeQueryLength;
             return this;
         }
 
         /** Sets number of terms in the search string. */
         @CanIgnoreReturnValue
-        public @NonNull Builder setTermCount(int termCount) {
-            mNativeNumTerms = termCount;
-            return this;
-        }
-
-        /** Sets length of the search string. */
-        @CanIgnoreReturnValue
-        public @NonNull Builder setQueryLength(int queryLength) {
-            mNativeQueryLength = queryLength;
+        public @NonNull Builder setNativeTermCount(int nativeTermCount) {
+            mNativeNumTerms = nativeTermCount;
             return this;
         }
 
         /** Sets number of namespaces filtered. */
         @CanIgnoreReturnValue
-        public @NonNull Builder setFilteredNamespaceCount(int filteredNamespaceCount) {
-            mNativeNumNamespacesFiltered = filteredNamespaceCount;
+        public @NonNull Builder setNativeFilteredNamespaceCount(int nativeFilteredNamespaceCount) {
+            mNativeNumNamespacesFiltered = nativeFilteredNamespaceCount;
             return this;
         }
 
         /** Sets number of schema types filtered. */
         @CanIgnoreReturnValue
-        public @NonNull Builder setFilteredSchemaTypeCount(int filteredSchemaTypeCount) {
-            mNativeNumSchemaTypesFiltered = filteredSchemaTypeCount;
+        public @NonNull Builder setNativeFilteredSchemaTypeCount(
+                int nativeFilteredSchemaTypeCount) {
+            mNativeNumSchemaTypesFiltered = nativeFilteredSchemaTypeCount;
             return this;
         }
 
-        /** Sets the requested number of results in one page. */
-        @CanIgnoreReturnValue
-        public @NonNull Builder setRequestedPageSize(int requestedPageSize) {
-            mNativeRequestedPageSize = requestedPageSize;
-            return this;
-        }
-
-        /** Sets the actual number of results returned in the current page. */
+        /** Sets strategy of scoring and ranking. */
         @CanIgnoreReturnValue
-        public @NonNull Builder setCurrentPageReturnedResultCount(
-                int currentPageReturnedResultCount) {
-            mNativeNumResultsReturnedCurrentPage = currentPageReturnedResultCount;
+        public @NonNull Builder setNativeRankingStrategy(
+                @SearchSpec.RankingStrategy int nativeRankingStrategy) {
+            mNativeRankingStrategy = nativeRankingStrategy;
             return this;
         }
 
-        /**
-         * Sets whether the function call is querying the first page. If it's not, Icing will fetch
-         * the results from cache so that some steps may be skipped.
-         */
+        /** Sets number of documents scored. */
         @CanIgnoreReturnValue
-        public @NonNull Builder setIsFirstPage(boolean nativeIsFirstPage) {
-            mNativeIsFirstPage = nativeIsFirstPage;
+        public @NonNull Builder setNativeScoredDocumentCount(int nativeScoredDocumentCount) {
+            mNativeNumDocumentsScored = nativeScoredDocumentCount;
             return this;
         }
 
@@ -538,103 +276,74 @@ public final class SearchStats extends BaseStats {
          * into an iterator tree.
          */
         @CanIgnoreReturnValue
-        public @NonNull Builder setParseQueryLatencyMillis(int parseQueryLatencyMillis) {
-            mNativeParseQueryLatencyMillis = parseQueryLatencyMillis;
-            return this;
-        }
-
-        /** Sets strategy of scoring and ranking. */
-        @CanIgnoreReturnValue
-        public @NonNull Builder setRankingStrategy(
-                @SearchSpec.RankingStrategy int rankingStrategy) {
-            mNativeRankingStrategy = rankingStrategy;
-            return this;
-        }
-
-        /** Sets number of documents scored. */
-        @CanIgnoreReturnValue
-        public @NonNull Builder setScoredDocumentCount(int scoredDocumentCount) {
-            mNativeNumDocumentsScored = scoredDocumentCount;
+        public @NonNull Builder setNativeParseQueryLatencyMillis(
+                int nativeParseQueryLatencyMillis) {
+            mNativeParseQueryLatencyMillis = nativeParseQueryLatencyMillis;
             return this;
         }
 
         /** Sets time used to score the raw results. */
         @CanIgnoreReturnValue
-        public @NonNull Builder setScoringLatencyMillis(int scoringLatencyMillis) {
-            mNativeScoringLatencyMillis = scoringLatencyMillis;
-            return this;
-        }
-
-        /** Sets time used to rank the scored results. */
-        @CanIgnoreReturnValue
-        public @NonNull Builder setRankingLatencyMillis(int rankingLatencyMillis) {
-            mNativeRankingLatencyMillis = rankingLatencyMillis;
-            return this;
-        }
-
-        /** Sets time used to fetch the document protos. */
-        @CanIgnoreReturnValue
-        public @NonNull Builder setDocumentRetrievingLatencyMillis(
-                int documentRetrievingLatencyMillis) {
-            mNativeDocumentRetrievingLatencyMillis = documentRetrievingLatencyMillis;
+        public @NonNull Builder setNativeScoringLatencyMillis(int nativeScoringLatencyMillis) {
+            mNativeScoringLatencyMillis = nativeScoringLatencyMillis;
             return this;
         }
 
-        /** Sets how many snippets are calculated. */
+        /** Sets whether it contains numeric query or not. */
         @CanIgnoreReturnValue
-        public @NonNull Builder setResultWithSnippetsCount(int resultWithSnippetsCount) {
-            mNativeNumResultsWithSnippets = resultWithSnippetsCount;
+        public @NonNull Builder setNativeIsNumericQuery(boolean nativeIsNumericQuery) {
+            mNativeIsNumericQuery = nativeIsNumericQuery;
             return this;
         }
 
-        /** Sets time passed while waiting to acquire the lock during native function calls. */
+        /** Sets number of hits fetched by lite index before applying any filters. */
         @CanIgnoreReturnValue
-        public @NonNull Builder setNativeLockAcquisitionLatencyMillis(
-                int nativeLockAcquisitionLatencyMillis) {
-            mNativeLockAcquisitionLatencyMillis = nativeLockAcquisitionLatencyMillis;
+        public @NonNull Builder setNativeNumFetchedHitsLiteIndex(
+                int nativeNumFetchedHitsLiteIndex) {
+            mNativeNumFetchedHitsLiteIndex = nativeNumFetchedHitsLiteIndex;
             return this;
         }
 
-        /** Sets time used to send data across the JNI boundary from java to native side. */
+        /** Sets number of hits fetched by main index before applying any filters. */
         @CanIgnoreReturnValue
-        public @NonNull Builder setJavaToNativeJniLatencyMillis(int javaToNativeJniLatencyMillis) {
-            mJavaToNativeJniLatencyMillis = javaToNativeJniLatencyMillis;
+        public @NonNull Builder setNativeNumFetchedHitsMainIndex(
+                int nativeNumFetchedHitsMainIndex) {
+            mNativeNumFetchedHitsMainIndex = nativeNumFetchedHitsMainIndex;
             return this;
         }
 
-        /** Sets time used to send data across the JNI boundary from native to java side. */
+        /** Sets number of hits fetched by integer index before applying any filters. */
         @CanIgnoreReturnValue
-        public @NonNull Builder setNativeToJavaJniLatencyMillis(int nativeToJavaJniLatencyMillis) {
-            mNativeToJavaJniLatencyMillis = nativeToJavaJniLatencyMillis;
+        public @NonNull Builder setNativeNumFetchedHitsIntegerIndex(
+                int nativeNumFetchedHitsIntegerIndex) {
+            mNativeNumFetchedHitsIntegerIndex = nativeNumFetchedHitsIntegerIndex;
             return this;
         }
 
-        /** Sets whether or not this is a join query */
+        /** Sets time used in Lexer to extract lexer tokens from the query. */
         @CanIgnoreReturnValue
-        public @NonNull Builder setJoinType(@JoinableValueType int joinType) {
-            mJoinType = joinType;
+        public @NonNull Builder setNativeQueryProcessorLexerExtractTokenLatencyMillis(
+                int nativeQueryProcessorLexerExtractTokenLatencyMillis) {
+            mNativeQueryProcessorLexerExtractTokenLatencyMillis =
+                    nativeQueryProcessorLexerExtractTokenLatencyMillis;
             return this;
         }
 
-        /** Set the total number of joined documents in a page. */
+        /** Sets time used in Parser to consume lexer tokens extracted from the query. */
         @CanIgnoreReturnValue
-        public @NonNull Builder setNativeNumJoinedResultsCurrentPage(
-                int nativeNumJoinedResultsCurrentPage) {
-            mNativeNumJoinedResultsCurrentPage = nativeNumJoinedResultsCurrentPage;
+        public @NonNull Builder setNativeQueryProcessorParserConsumeQueryLatencyMillis(
+                int nativeQueryProcessorParserConsumeQueryLatencyMillis) {
+            mNativeQueryProcessorParserConsumeQueryLatencyMillis =
+                    nativeQueryProcessorParserConsumeQueryLatencyMillis;
             return this;
         }
 
-        /** Sets time it takes to join documents together in icing. */
+        /** Sets time used in QueryVisitor to visit and build (nested) DocHitInfoIterator. */
         @CanIgnoreReturnValue
-        public @NonNull Builder setNativeJoinLatencyMillis(int nativeJoinLatencyMillis) {
-            mNativeJoinLatencyMillis = nativeJoinLatencyMillis;
-            return this;
-        }
-
-        /** Sets a tag to indicate the source of this search. */
-        @CanIgnoreReturnValue
-        public @NonNull Builder setSearchSourceLogTag(@Nullable String searchSourceLogTag) {
-            mSearchSourceLogTag = searchSourceLogTag;
+        public @NonNull Builder setNativeQueryProcessorQueryVisitorLatencyMillis(
+                int nativeQueryProcessorQueryVisitorLatencyMillis) {
+            mNativeQueryProcessorQueryVisitorLatencyMillis =
+                    nativeQueryProcessorQueryVisitorLatencyMillis;
             return this;
         }
 
@@ -642,14 +351,7 @@ public final class SearchStats extends BaseStats {
          * Constructs a new {@link SearchStats} from the contents of this {@link
          * SearchStats.Builder}.
          */
-        @Override
         public @NonNull SearchStats build() {
-            if (mDatabase == null) {
-                Preconditions.checkState(
-                        mVisibilityScope != SearchStats.VISIBILITY_SCOPE_LOCAL,
-                        "database can not be null if visibilityScope is local.");
-            }
-
             return new SearchStats(/* builder= */ this);
         }
     }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStore.java b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStore.java
index fc2f2023..fad7dfc3 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStore.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStore.java
@@ -17,12 +17,18 @@ package com.android.server.appsearch.external.localstorage.visibilitystore;
 
 import static android.app.appsearch.AppSearchResult.RESULT_NOT_FOUND;
 
+import static com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE;
+import static com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE;
+
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.GenericDocument;
 import android.app.appsearch.GetSchemaResponse;
 import android.app.appsearch.InternalSetSchemaResponse;
 import android.app.appsearch.InternalVisibilityConfig;
+import android.app.appsearch.SearchResult;
+import android.app.appsearch.SearchResultPage;
+import android.app.appsearch.SearchSpec;
 import android.app.appsearch.VisibilityPermissionConfig;
 import android.app.appsearch.checker.initialization.qual.UnderInitialization;
 import android.app.appsearch.checker.initialization.qual.UnknownInitialization;
@@ -32,12 +38,16 @@ import android.app.appsearch.util.LogUtil;
 import android.util.ArrayMap;
 import android.util.Log;
 
+import com.android.appsearch.flags.Flags;
 import com.android.server.appsearch.external.localstorage.AppSearchImpl;
 import com.android.server.appsearch.external.localstorage.util.PrefixUtil;
 
+import com.google.android.icing.proto.PersistType;
+
 import org.jspecify.annotations.NonNull;
 import org.jspecify.annotations.Nullable;
 
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
@@ -74,6 +84,7 @@ public class VisibilityStore {
 
     public static final String BLOB_VISIBILITY_DATABASE_NAME = "VSBlob#Db";
     public static final String BLOB_ANDROID_V_OVERLAY_DATABASE_NAME = "VSBlob#AndroidVDb";
+    public static final int QUERY_RESULT_COUNT_PER_PAGE = 100;
 
     /**
      * Map of PrefixedSchemaType to InternalVisibilityConfig stores visibility information for each
@@ -136,12 +147,7 @@ public class VisibilityStore {
         mAppSearchImpl = Objects.requireNonNull(appSearchImpl);
         mDatabaseName = Objects.requireNonNull(databaseName);
         mAndroidVOverlayDatabaseName = Objects.requireNonNull(androidVOverlayDatabaseName);
-
-        GetSchemaResponse getSchemaResponse =
-                mAppSearchImpl.getSchema(
-                        VISIBILITY_PACKAGE_NAME,
-                        mDatabaseName,
-                        new CallerAccess(/* callingPackageName= */ VISIBILITY_PACKAGE_NAME));
+        GetSchemaResponse getSchemaResponse = getVisibilitySchemaResponse(mDatabaseName);
         List<VisibilityDocumentV1> visibilityDocumentsV1s = null;
         switch (getSchemaResponse.getVersion()) {
             case VisibilityToDocumentConverter.SCHEMA_VERSION_DOC_PER_PACKAGE:
@@ -153,7 +159,7 @@ public class VisibilityStore {
                 visibilityDocumentsV1s =
                         VisibilityStoreMigrationHelperFromV0.toVisibilityDocumentV1(
                                 visibilityDocumentsV0s);
-                // fall through
+            // fall through
             case VisibilityToDocumentConverter.SCHEMA_VERSION_DOC_PER_SCHEMA:
                 if (visibilityDocumentsV1s == null) {
                     // We need to read VisibilityDocument in Version 1 from AppSearch instead of
@@ -194,6 +200,8 @@ public class VisibilityStore {
             throws AppSearchException {
         Objects.requireNonNull(prefixedVisibilityConfigs);
         // Save new setting.
+        List<GenericDocument> visibilityDocuments = new ArrayList<>();
+        List<GenericDocument> overlayDocuments = new ArrayList<>();
         for (int i = 0; i < prefixedVisibilityConfigs.size(); i++) {
             // put VisibilityConfig to AppSearchImpl and mVisibilityConfigMap. If there is a
             // VisibilityConfig with same prefixed schema exists, it will be replaced by new
@@ -201,43 +209,46 @@ public class VisibilityStore {
             InternalVisibilityConfig prefixedVisibilityConfig = prefixedVisibilityConfigs.get(i);
             InternalVisibilityConfig oldVisibilityConfig =
                     mVisibilityConfigMap.get(prefixedVisibilityConfig.getSchemaType());
-            // TODO(b/394875109) switch to use batchPut
-            mAppSearchImpl.putDocument(
-                    VISIBILITY_PACKAGE_NAME,
-                    mDatabaseName,
-                    VisibilityToDocumentConverter.createVisibilityDocument(
-                            prefixedVisibilityConfig),
-                    /* sendChangeNotifications= */ false,
-                    /* logger= */ null);
-
-            // Put the android V visibility overlay document to AppSearchImpl.
-            GenericDocument androidVOverlay =
-                    VisibilityToDocumentConverter.createAndroidVOverlay(prefixedVisibilityConfig);
-            if (androidVOverlay != null) {
-                // TODO(b/394875109) switch to use batchPut
+            if (Flags.enableBatchPutVisibilityDocuments()) {
+                if (prefixedVisibilityConfig.equals(oldVisibilityConfig)) {
+                    // This schema has no visibility changes.
+                    continue;
+                }
+                visibilityDocuments.add(
+                        VisibilityToDocumentConverter.createVisibilityDocument(
+                                prefixedVisibilityConfig));
+                GenericDocument androidVOverlay =
+                        VisibilityToDocumentConverter.createAndroidVOverlay(
+                                prefixedVisibilityConfig);
+                if (androidVOverlay != null) {
+                    overlayDocuments.add(androidVOverlay);
+                } else {
+                    maybeRemoveOverlayDocument(
+                            prefixedVisibilityConfig.getSchemaType(), oldVisibilityConfig);
+                }
+            } else {
                 mAppSearchImpl.putDocument(
                         VISIBILITY_PACKAGE_NAME,
-                        mAndroidVOverlayDatabaseName,
-                        androidVOverlay,
+                        mDatabaseName,
+                        VisibilityToDocumentConverter.createVisibilityDocument(
+                                prefixedVisibilityConfig),
                         /* sendChangeNotifications= */ false,
                         /* logger= */ null);
-            } else if (isConfigContainsAndroidVOverlay(oldVisibilityConfig)) {
-                // We need to make sure to remove the VisibilityOverlay on disk as the current
-                // VisibilityConfig does not have a VisibilityOverlay.
-                // For performance improvement, we should only make the remove call if the old
-                // VisibilityConfig contains the overlay settings.
-                try {
-                    mAppSearchImpl.remove(
+
+                // Put the android V visibility overlay document to AppSearchImpl.
+                GenericDocument androidVOverlay =
+                        VisibilityToDocumentConverter.createAndroidVOverlay(
+                                prefixedVisibilityConfig);
+                if (androidVOverlay != null) {
+                    mAppSearchImpl.putDocument(
                             VISIBILITY_PACKAGE_NAME,
                             mAndroidVOverlayDatabaseName,
-                            VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
-                            prefixedVisibilityConfig.getSchemaType(),
-                            /* removeStatsBuilder= */ null);
-                } catch (AppSearchException e) {
-                    // If it already doesn't exist, that is fine
-                    if (e.getResultCode() != RESULT_NOT_FOUND) {
-                        throw e;
-                    }
+                            androidVOverlay,
+                            /* sendChangeNotifications= */ false,
+                            /* logger= */ null);
+                } else {
+                    maybeRemoveOverlayDocument(
+                            prefixedVisibilityConfig.getSchemaType(), oldVisibilityConfig);
                 }
             }
 
@@ -245,8 +256,29 @@ public class VisibilityStore {
             mVisibilityConfigMap.put(
                     prefixedVisibilityConfig.getSchemaType(), prefixedVisibilityConfig);
         }
-        // Now that the visibility document has been written. Persist the newly written data.
-        mAppSearchImpl.persistToDisk(mAppSearchImpl.getConfig().getLightweightPersistType());
+
+        if (Flags.enableBatchPutVisibilityDocuments() && !visibilityDocuments.isEmpty()) {
+            if (!overlayDocuments.isEmpty()) {
+                mAppSearchImpl.batchPutDocuments(
+                        VISIBILITY_PACKAGE_NAME,
+                        mAndroidVOverlayDatabaseName,
+                        overlayDocuments,
+                        /* batchResultBuilder= */ null,
+                        /* sendChangeNotifications= */ false,
+                        /* logger= */ null,
+                        PersistType.Code.UNKNOWN);
+            }
+            // Now that the both main and overlay visibility document has been written. Persist the
+            // newly written data.
+            mAppSearchImpl.batchPutDocuments(
+                    VISIBILITY_PACKAGE_NAME,
+                    mDatabaseName,
+                    visibilityDocuments,
+                    /* batchResultBuilder= */ null,
+                    /* sendChangeNotifications= */ false,
+                    /* logger= */ null,
+                    PersistType.Code.LITE);
+        }
     }
 
     /**
@@ -263,7 +295,7 @@ public class VisibilityStore {
                     mAppSearchImpl.remove(
                             VISIBILITY_PACKAGE_NAME,
                             mDatabaseName,
-                            VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
+                            VISIBILITY_DOCUMENT_NAMESPACE,
                             prefixedSchemaType,
                             /* removeStatsBuilder= */ null);
                 } catch (AppSearchException e) {
@@ -284,7 +316,7 @@ public class VisibilityStore {
                     mAppSearchImpl.remove(
                             VISIBILITY_PACKAGE_NAME,
                             mAndroidVOverlayDatabaseName,
-                            VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
+                            ANDROID_V_OVERLAY_NAMESPACE,
                             prefixedSchemaType,
                             /* removeStatsBuilder= */ null);
                 } catch (AppSearchException e) {
@@ -324,56 +356,114 @@ public class VisibilityStore {
             @NonNull List<String> allVisibilityDocumentIds)
             throws AppSearchException {
         // Populate visibility settings set
-        for (int i = 0; i < allVisibilityDocumentIds.size(); i++) {
-            String visibilityDocumentId = allVisibilityDocumentIds.get(i);
-            String packageName = PrefixUtil.getPackageName(visibilityDocumentId);
-            if (packageName.equals(VISIBILITY_PACKAGE_NAME)) {
-                continue; // Our own package. Skip.
+        if (Flags.enableQueryVisibilityDocuments()) {
+            // query all overlay document first and convert to id->doc map.
+            List<GenericDocument> androidVOverlayDocuments =
+                    queryVisibilityDocument(
+                            mAndroidVOverlayDatabaseName, ANDROID_V_OVERLAY_NAMESPACE);
+            Map<String, GenericDocument> androidVOverlapMap =
+                    new ArrayMap<>(androidVOverlayDocuments.size());
+            for (int i = 0; i < androidVOverlayDocuments.size(); i++) {
+                GenericDocument androidVOverlayDocument = androidVOverlayDocuments.get(i);
+                androidVOverlapMap.put(androidVOverlayDocument.getId(), androidVOverlayDocument);
             }
 
-            GenericDocument visibilityDocument;
-            GenericDocument visibilityAndroidVOverlay = null;
-            try {
-                // Note: We use the other clients' prefixed schema type as ids
-                visibilityDocument =
-                        mAppSearchImpl.getDocument(
-                                VISIBILITY_PACKAGE_NAME,
-                                mDatabaseName,
-                                VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
-                                /* id= */ visibilityDocumentId,
-                                /* typePropertyPaths= */ Collections.emptyMap());
-            } catch (AppSearchException e) {
-                if (e.getResultCode() == RESULT_NOT_FOUND) {
-                    // The schema has all default setting and we won't have a VisibilityDocument for
-                    // it.
-                    continue;
-                }
-                // Otherwise, this is some other error we should pass up.
-                throw e;
+            // It's ok to have null overlay document, and we should never have overlay document that
+            // doesn't have main visibility document.
+            List<GenericDocument> visibilityDocuments =
+                    queryVisibilityDocument(mDatabaseName, VISIBILITY_DOCUMENT_NAMESPACE);
+            for (int i = 0; i < visibilityDocuments.size(); i++) {
+                GenericDocument visibilityDocument = visibilityDocuments.get(i);
+                GenericDocument visibilityAndroidVOverlay =
+                        androidVOverlapMap.get(visibilityDocument.getId());
+                mVisibilityConfigMap.put(
+                        visibilityDocument.getId(),
+                        VisibilityToDocumentConverter.createInternalVisibilityConfig(
+                                visibilityDocument, visibilityAndroidVOverlay));
             }
+        } else {
+            for (int i = 0; i < allVisibilityDocumentIds.size(); i++) {
+                String visibilityDocumentId = allVisibilityDocumentIds.get(i);
+                String packageName = PrefixUtil.getPackageName(visibilityDocumentId);
+                if (packageName.equals(VISIBILITY_PACKAGE_NAME)) {
+                    continue; // Our own package. Skip.
+                }
 
-            try {
-                visibilityAndroidVOverlay =
-                        mAppSearchImpl.getDocument(
-                                VISIBILITY_PACKAGE_NAME,
-                                mAndroidVOverlayDatabaseName,
-                                VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
-                                /* id= */ visibilityDocumentId,
-                                /* typePropertyPaths= */ Collections.emptyMap());
-            } catch (AppSearchException e) {
-                if (e.getResultCode() != RESULT_NOT_FOUND) {
-                    // This is some other error we should pass up.
+                GenericDocument visibilityDocument;
+                GenericDocument visibilityAndroidVOverlay = null;
+                try {
+                    // Note: We use the other clients' prefixed schema type as ids
+                    visibilityDocument =
+                            mAppSearchImpl.getDocument(
+                                    VISIBILITY_PACKAGE_NAME,
+                                    mDatabaseName,
+                                    VISIBILITY_DOCUMENT_NAMESPACE,
+                                    /* id= */ visibilityDocumentId,
+                                    /* typePropertyPaths= */ Collections.emptyMap());
+                } catch (AppSearchException e) {
+                    if (e.getResultCode() == RESULT_NOT_FOUND) {
+                        // The schema has all default setting and we won't have a VisibilityDocument
+                        // for it.
+                        continue;
+                    }
+                    // Otherwise, this is some other error we should pass up.
                     throw e;
                 }
-                // Otherwise we continue inserting into visibility document map as the overlay
-                // map can be null
+
+                try {
+                    visibilityAndroidVOverlay =
+                            mAppSearchImpl.getDocument(
+                                    VISIBILITY_PACKAGE_NAME,
+                                    mAndroidVOverlayDatabaseName,
+                                    ANDROID_V_OVERLAY_NAMESPACE,
+                                    /* id= */ visibilityDocumentId,
+                                    /* typePropertyPaths= */ Collections.emptyMap());
+                } catch (AppSearchException e) {
+                    if (e.getResultCode() != RESULT_NOT_FOUND) {
+                        // This is some other error we should pass up.
+                        throw e;
+                    }
+                    // Otherwise we continue inserting into visibility document map as the overlay
+                    // map can be null
+                }
+
+                mVisibilityConfigMap.put(
+                        visibilityDocumentId,
+                        VisibilityToDocumentConverter.createInternalVisibilityConfig(
+                                visibilityDocument, visibilityAndroidVOverlay));
             }
+        }
+    }
 
-            mVisibilityConfigMap.put(
-                    visibilityDocumentId,
-                    VisibilityToDocumentConverter.createInternalVisibilityConfig(
-                            visibilityDocument, visibilityAndroidVOverlay));
+    @NonNull
+    private List<GenericDocument> queryVisibilityDocument(
+            @NonNull String databaseName, @NonNull String namespace) throws AppSearchException {
+        SearchSpec searchSpec =
+                new SearchSpec.Builder()
+                        .addFilterNamespaces(namespace)
+                        .setResultCountPerPage(QUERY_RESULT_COUNT_PER_PAGE)
+                        .build();
+        SearchResultPage searchResultPage =
+                mAppSearchImpl.query(
+                        VISIBILITY_PACKAGE_NAME,
+                        databaseName,
+                        /* queryExpression= */ "",
+                        searchSpec,
+                        /* logger= */ null);
+        List<GenericDocument> visibilityDocuments = new ArrayList<>();
+        List<SearchResult> searchResults = searchResultPage.getResults();
+        while (!searchResults.isEmpty()) {
+            for (int i = 0; i < searchResults.size(); i++) {
+                visibilityDocuments.add(searchResults.get(i).getGenericDocument());
+            }
+            searchResultPage =
+                    mAppSearchImpl.getNextPage(
+                            VISIBILITY_PACKAGE_NAME,
+                            searchResultPage.getNextPageToken(),
+                            /* statsBuilder= */ null);
+            searchResults = searchResultPage.getResults();
         }
+        return visibilityDocuments;
     }
 
     /** Set the latest version of {@link InternalVisibilityConfig} and its schema to AppSearch. */
@@ -421,16 +511,32 @@ public class VisibilityStore {
                     AppSearchResult.RESULT_INTERNAL_ERROR,
                     internalSetAndroidVOverlaySchemaResponse.getErrorMessage());
         }
+        List<GenericDocument> migratedVisibilityDocuments =
+                new ArrayList<>(migratedDocuments.size());
         for (int i = 0; i < migratedDocuments.size(); i++) {
             InternalVisibilityConfig migratedConfig = migratedDocuments.get(i);
             mVisibilityConfigMap.put(migratedConfig.getSchemaType(), migratedConfig);
-            // TODO(b/394875109) switch to use batchPut
-            mAppSearchImpl.putDocument(
+            if (Flags.enableBatchPutVisibilityDocuments()) {
+                migratedVisibilityDocuments.add(
+                        VisibilityToDocumentConverter.createVisibilityDocument(migratedConfig));
+            } else {
+                mAppSearchImpl.putDocument(
+                        VISIBILITY_PACKAGE_NAME,
+                        mDatabaseName,
+                        VisibilityToDocumentConverter.createVisibilityDocument(migratedConfig),
+                        /* sendChangeNotifications= */ false,
+                        /* logger= */ null);
+            }
+        }
+        if (Flags.enableBatchPutVisibilityDocuments() && !migratedVisibilityDocuments.isEmpty()) {
+            mAppSearchImpl.batchPutDocuments(
                     VISIBILITY_PACKAGE_NAME,
                     mDatabaseName,
-                    VisibilityToDocumentConverter.createVisibilityDocument(migratedConfig),
+                    migratedVisibilityDocuments,
+                    /* batchResultBuilder= */ null,
                     /* sendChangeNotifications= */ false,
-                    /* logger= */ null);
+                    /* logger= */ null,
+                    PersistType.Code.UNKNOWN);
         }
     }
 
@@ -442,10 +548,7 @@ public class VisibilityStore {
     private void migrateVisibilityOverlayDatabase(@UnderInitialization VisibilityStore this)
             throws AppSearchException {
         GetSchemaResponse getSchemaResponse =
-                mAppSearchImpl.getSchema(
-                        VISIBILITY_PACKAGE_NAME,
-                        mAndroidVOverlayDatabaseName,
-                        new CallerAccess(/* callingPackageName= */ VISIBILITY_PACKAGE_NAME));
+                getVisibilitySchemaResponse(mAndroidVOverlayDatabaseName);
         switch (getSchemaResponse.getVersion()) {
             case VisibilityToDocumentConverter.OVERLAY_SCHEMA_VERSION_PUBLIC_ACL_VISIBLE_TO_CONFIG:
                 // Force override to next version. This version hasn't released to any public
@@ -585,6 +688,47 @@ public class VisibilityStore {
         }
     }
 
+    /** Remove the overlay document if the old visibility config exists and contains overlay. */
+    private void maybeRemoveOverlayDocument(
+            @NonNull String prefixedSchemaType,
+            @Nullable InternalVisibilityConfig oldVisibilityConfig)
+            throws AppSearchException {
+        if (isConfigContainsAndroidVOverlay(oldVisibilityConfig)) {
+            try {
+                mAppSearchImpl.remove(
+                        VISIBILITY_PACKAGE_NAME,
+                        mAndroidVOverlayDatabaseName,
+                        ANDROID_V_OVERLAY_NAMESPACE,
+                        prefixedSchemaType,
+                        /* removeStatsBuilder= */ null);
+            } catch (AppSearchException e) {
+                // If it already doesn't exist, that is fine
+                if (e.getResultCode() != RESULT_NOT_FOUND) {
+                    throw e;
+                }
+            }
+        }
+    }
+
+    /** Get the {@link GetSchemaResponse} for the given visibility database. */
+    @NonNull
+    private GetSchemaResponse getVisibilitySchemaResponse(@NonNull String databaseName)
+            throws AppSearchException {
+        GetSchemaResponse getSchemaResponse;
+        if (Flags.enableBatchPutVisibilityDocuments()) {
+            getSchemaResponse =
+                    mAppSearchImpl.getVisibilitySchema(
+                            PrefixUtil.createPrefix(VISIBILITY_PACKAGE_NAME, databaseName));
+        } else {
+            getSchemaResponse =
+                    mAppSearchImpl.getSchema(
+                            VISIBILITY_PACKAGE_NAME,
+                            databaseName,
+                            new CallerAccess(/* callingPackageName= */ VISIBILITY_PACKAGE_NAME));
+        }
+        return getSchemaResponse;
+    }
+
     /**
      * Whether the given {@link InternalVisibilityConfig} contains Android V overlay settings.
      *
diff --git a/service/java/com/android/server/appsearch/isolated_storage_service/DataMigrationUtil.java b/service/java/com/android/server/appsearch/isolated_storage_service/DataMigrationUtil.java
new file mode 100644
index 00000000..5d9b77a3
--- /dev/null
+++ b/service/java/com/android/server/appsearch/isolated_storage_service/DataMigrationUtil.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.server.appsearch.isolated_storage_service;
+
+import android.annotation.NonNull;
+import android.app.appsearch.AppSearchEnvironmentFactory;
+import android.content.Context;
+import android.os.UserHandle;
+import android.util.Log;
+
+import com.android.server.appsearch.external.localstorage.AppSearchImpl;
+
+import com.google.android.icing.IcingSearchEngineInterface;
+import com.google.android.icing.proto.BatchPutResultProto;
+import com.google.android.icing.proto.PutDocumentRequest;
+import com.google.android.icing.proto.ResetResultProto;
+import com.google.android.icing.proto.ResultSpecProto;
+import com.google.android.icing.proto.ScoringSpecProto;
+import com.google.android.icing.proto.SearchResultProto;
+import com.google.android.icing.proto.SearchSpecProto;
+import com.google.android.icing.proto.SetSchemaResultProto;
+import com.google.android.icing.proto.StatusProto;
+import com.google.android.icing.proto.TermMatchType;
+
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * Utils to migrate data from AppSearch to IsolatedStorage.
+ *
+ * @hide
+ */
+public class DataMigrationUtil {
+    private DataMigrationUtil() {}
+
+    private static final String TAG = "IcingDataMigration";
+
+    private static final String DATA_MIGRATION_STATUS_FILE = "data_migration_status";
+
+    /** Checks if data migration is needed from AppSearch to Isolated Storage. */
+    // TODO(b/407815165) Right now just check if the icing/version on host exists
+    //  We can persist a file to save the migration status, so dir deletion could happen later.
+    public static boolean needDataMigration(
+            @NonNull Context userContext, @NonNull UserHandle userHandle) {
+        File appSearchDir =
+                AppSearchEnvironmentFactory.getEnvironmentInstance()
+                        .getAppSearchDir(userContext, userHandle);
+        File icingVersion = new File(appSearchDir, "icing/version");
+        File dataMigrationStatus = new File(
+                appSearchDir, DATA_MIGRATION_STATUS_FILE);
+
+        // icing version exists means icing has been initialized and used.
+        // And if there is no migration_status file created, it means migration has not been
+        // scheduled yet, so we need to schedule a migration.
+        return icingVersion.exists() && !dataMigrationStatus.exists();
+    }
+
+    /** deletes the migration status file if it exists. */
+    public static void deleteMigrationStatus(
+            @NonNull UserHandle userHandle,
+            @NonNull File appSearchDir) {
+        try {
+            File icingMigrationStatus = new File(
+                    appSearchDir,  DATA_MIGRATION_STATUS_FILE);
+            if (icingMigrationStatus.exists())  {
+                Log.i(TAG,
+                        "data migration was run before for " + userHandle);
+                icingMigrationStatus.delete();
+            }
+        } catch (Exception e) {
+            Log.e(TAG,
+                    "Exception thrown while checking migration status "
+                            + "file for " + userHandle,
+                    e);
+        }
+    }
+
+    /** creates the migration status file. */
+    public static void createMigrationStatus(@NonNull File appSearchDir) {
+        try {
+            // TODO(b/407815165) right now we just create this file
+            //  to mark migration done successfully.
+            //  In the future we might want to create the file
+            //  earlier and put different statuses for
+            //  different stages during migration.
+            File icingMigrationStatus = new File(
+                    appSearchDir, DATA_MIGRATION_STATUS_FILE);
+            icingMigrationStatus.createNewFile();
+        } catch (IOException e) {
+            Log.e(TAG,
+                    "Fail to create marker file to mark "
+                            + "data migration done.", e);
+        }
+    }
+
+    /**
+     * Copies all the data from the source to the destination.
+     *
+     * <p>{@code source} won't be modified by this method.
+     *
+     * <p>This method calls AppSearchImpl's thread-safe APIs for source.
+     */
+    public static StatusProto copyData(
+            @NonNull AppSearchImpl source,
+            @NonNull IcingSearchEngineInterface destination,
+            boolean resetDestination,
+            boolean forceOverride) {
+        // TODO(b/407815165): Either remove this limit or make it configurable in future.
+        int maxBytesPerPage =
+                IsolatedStorageServiceManager.DEFAULT_MAX_PAGE_BYTES_LIMIT_FOR_ISOLATED_STORAGE;
+
+        if (resetDestination) {
+            // Clear all current data from icing instance and reinitialize it.
+            ResetResultProto resetResult = destination.reset();
+            if (resetResult.getStatus().getCode() != StatusProto.Code.OK) {
+                return resetResult.getStatus();
+            }
+
+            Log.i(TAG, "Destination reset during data migration successful");
+        }
+
+        // Step-1 Set schema in destination by getting schema from source.
+        SetSchemaResultProto setSchemaResult =
+                destination.setSchema(source.rawGetSchema(), forceOverride);
+        if (setSchemaResult.getStatus().getCode() != StatusProto.Code.OK) {
+            return setSchemaResult.getStatus();
+        }
+
+        Log.i(TAG, "Set Schema during data migration successful");
+
+        // Step-2 Query all documents from source using an empty query.
+        //
+        // TODO(b/407815165) Add exception handling for any exceptions while querying.
+        //
+        // TODO(b/407815165) Add logic to queue any incoming changes during copy.
+        SearchSpecProto searchSpec =
+                SearchSpecProto.newBuilder()
+                        .setQuery("") // an empty query will return all docs.
+                        .setTermMatchType(TermMatchType.Code.PREFIX)
+                        .build();
+        SearchResultProto searchResult =
+                source.rawSearch(
+                        searchSpec,
+                        ScoringSpecProto.newBuilder().build(),
+                        ResultSpecProto.newBuilder()
+                                .setNumTotalBytesPerPageThreshold(maxBytesPerPage)
+                                // median doc size is 700b.
+                                // half of the maxBytesPerPage is 250_000.
+                                // so 250_000 / 700 = 350 results per page.
+                                .setNumPerPage(350)
+                                .build());
+        if (searchResult.getStatus().getCode() != StatusProto.Code.OK) {
+            return searchResult.getStatus();
+        }
+
+        Log.i(TAG, "Querying documents from source for data migration successful");
+
+        // Step-3 Put all documents in searchResult in destination using a batchPut call.
+        //
+        // TODO(b/407815165) Add exception handling for any exceptions during put.
+        long nextPageToken = searchResult.getNextPageToken();
+        long totalDocuments = 0L;
+        while (searchResult != null && searchResult.getResultsCount() > 0) {
+            PutDocumentRequest.Builder requestBuilder = PutDocumentRequest.newBuilder();
+            for (int i = 0; i < searchResult.getResultsCount(); ++i) {
+                requestBuilder.addDocuments(searchResult.getResults(i).getDocument());
+            }
+            BatchPutResultProto batchPutResult = destination.batchPut(requestBuilder.build());
+            // TODO(b/407815165) Either return error if some put fails (if we cannot tolerate data
+            //  loss) or save IDs for documents that failed to index in order to retry / log.
+            if (batchPutResult.getStatus().getCode() != StatusProto.Code.OK) {
+                Log.w(
+                        TAG,
+                        "Error calling batchPut during data migration "
+                                + batchPutResult.getStatus().getMessage());
+            }
+            totalDocuments += searchResult.getResultsCount();
+            searchResult = source.rawGetNextPage(nextPageToken);
+        }
+        Log.i(TAG, "Successfully migrated " + totalDocuments + " documents");
+
+        return StatusProto.newBuilder().setCode(StatusProto.Code.OK).build();
+    }
+}
diff --git a/service/java/com/android/server/appsearch/isolated_storage_service/IcingSearchEngine.java b/service/java/com/android/server/appsearch/isolated_storage_service/IcingSearchEngine.java
index f9dc93c3..7afc2a62 100644
--- a/service/java/com/android/server/appsearch/isolated_storage_service/IcingSearchEngine.java
+++ b/service/java/com/android/server/appsearch/isolated_storage_service/IcingSearchEngine.java
@@ -17,10 +17,12 @@ package com.android.server.appsearch.isolated_storage_service;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.os.DeadObjectException;
 import android.os.RemoteException;
 import android.util.Log;
 
 import com.android.isolated_storage_service.IIcingSearchEngine;
+import com.android.server.appsearch.util.MemInfoReader;
 
 import com.google.android.icing.IcingSearchEngineInterface;
 import com.google.android.icing.proto.BatchGetResultProto;
@@ -34,6 +36,7 @@ import com.google.android.icing.proto.DeleteBySchemaTypeResultProto;
 import com.google.android.icing.proto.DeleteResultProto;
 import com.google.android.icing.proto.DocumentProto;
 import com.google.android.icing.proto.GetAllNamespacesResultProto;
+import com.google.android.icing.proto.GetNextPageRequestProto;
 import com.google.android.icing.proto.GetOptimizeInfoResultProto;
 import com.google.android.icing.proto.GetResultProto;
 import com.google.android.icing.proto.GetResultSpecProto;
@@ -65,6 +68,7 @@ import com.google.protobuf.InvalidProtocolBufferException;
 import com.google.protobuf.MessageLite;
 import com.google.protobuf.Parser;
 
+import java.util.List;
 import java.util.Objects;
 import java.util.function.Function;
 
@@ -72,24 +76,58 @@ import java.util.function.Function;
 public final class IcingSearchEngine implements IcingSearchEngineInterface {
     private static final String TAG = "IcingSearchEngine";
 
-    private final IIcingSearchEngine mEngine;
     private final IcingSearchEngineOptions mOptions;
+    private final VmStateSignaler mVmStateSignaler;
+    private volatile IIcingSearchEngine mEngine;
+    // The isolated storage service implemented by the VM to access icing.
+    private volatile com.android.isolated_storage_service.IIsolatedStorageService
+            mVmIsolatedStorageService;
+    private volatile boolean mIsReconnecting = false;
 
     /** Enforces singleton class pattern. */
     public IcingSearchEngine(
-            @NonNull IIcingSearchEngine engine, @NonNull IcingSearchEngineOptions options) {
+            @NonNull IIcingSearchEngine engine,
+            @NonNull IcingSearchEngineOptions options,
+            @NonNull VmStateSignaler vmStateSignaler,
+            @NonNull
+                    com.android.isolated_storage_service.IIsolatedStorageService
+                            vmIsolatedStorageService) {
         Log.d(TAG, "constructing");
         mEngine = Objects.requireNonNull(engine);
+        mVmIsolatedStorageService = Objects.requireNonNull(vmIsolatedStorageService);
         mOptions = Objects.requireNonNull(options);
+        mVmStateSignaler = Objects.requireNonNull(vmStateSignaler);
+    }
+
+    /**
+     * Sets the VM instances, including engine and isolated storage service.
+     *
+     * <p>Use this to replace dead VM instances.
+     */
+    public void setVmInstances(
+            @NonNull IIcingSearchEngine engine,
+            @NonNull
+                    com.android.isolated_storage_service.IIsolatedStorageService
+                            vmIsolatedStorageService) {
+        mEngine = Objects.requireNonNull(engine);
+        mVmIsolatedStorageService = Objects.requireNonNull(vmIsolatedStorageService);
+    }
+
+    /** Sets whether the vm engine is reconnecting. */
+    public void setIsReconnecting(boolean isReconnecting) {
+        mIsReconnecting = isReconnecting;
     }
 
     @Override
     public void close() {
         Log.d(TAG, "closing");
         try {
+            mVmStateSignaler.signalActivityStarts();
             mEngine.close();
         } catch (RemoteException e) {
             Log.e(TAG, "failed to call close", e);
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
     }
 
@@ -98,9 +136,12 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     public InitializeResultProto initialize() {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData = mEngine.initialize(mOptions.toByteArray());
         } catch (RemoteException e) {
             return InitializeResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -112,30 +153,33 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     @NonNull
     @Override
     public SetSchemaResultProto setSchema(@NonNull SchemaProto schema) {
-        byte[] resultData;
-        try {
-            resultData =
-                    mEngine.setSchema(
-                            schema.toByteArray(), /* ignoreErrorsAndDeleteDocuments= */ false);
-        } catch (RemoteException e) {
-            return SetSchemaResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
-        }
-
-        return getResponseProtoFromRawData(
-                resultData,
-                SetSchemaResultProto.getDefaultInstance(),
-                status -> SetSchemaResultProto.newBuilder().setStatus(status).build());
+        return setSchema(schema, /* ignoreErrorsAndDeleteDocuments= */ false);
     }
 
     @NonNull
     @Override
     public SetSchemaResultProto setSchema(
             @NonNull SchemaProto schema, boolean ignoreErrorsAndDeleteDocuments) {
+        byte[] input = schema.toByteArray();
+
         byte[] resultData;
         try {
-            resultData = mEngine.setSchema(schema.toByteArray(), ignoreErrorsAndDeleteDocuments);
+            mVmStateSignaler.signalActivityStarts();
+            resultData = mEngine.setSchema(input, ignoreErrorsAndDeleteDocuments);
+        } catch (OutOfMemoryError e) {
+            Log.w(
+                    TAG,
+                    "Got out of memory in set schema. Request length: "
+                            + input.length
+                            + ", number of schema types in request: "
+                            + schema.getTypesCount());
+            logFreeMemoryInfo(e);
+
+            return SetSchemaResultProto.newBuilder().setStatus(oomExceptionStatus(e)).build();
         } catch (RemoteException e) {
             return SetSchemaResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -149,10 +193,34 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
      *
      * @param setSchemaRequest the request proto for setting the schema.
      */
+    @NonNull
+    @Override
     public SetSchemaResultProto setSchemaWithRequestProto(SetSchemaRequestProto setSchemaRequest) {
-        // TODO(b/337913932): have vm version support this api.
-        throw new UnsupportedOperationException(
-                "setSchemaWithRequestProto is temporarily unsupported.");
+        byte[] inputRequest = setSchemaRequest.toByteArray();
+
+        byte[] resultData;
+        try {
+            mVmStateSignaler.signalActivityStarts();
+            resultData = mEngine.setSchemaWithRequestProto(inputRequest);
+        } catch (OutOfMemoryError e) {
+            // TODO: if we are still seeing issue, print VM MemAvailable as well
+            Log.w(
+                    TAG,
+                    "Got out of memory in set schema. Request length: "
+                            + inputRequest.length
+                            + ", number of schema types in request: "
+                            + setSchemaRequest.getSchema().getTypesCount());
+            return SetSchemaResultProto.newBuilder().setStatus(oomExceptionStatus(e)).build();
+        } catch (RemoteException e) {
+            return SetSchemaResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                SetSchemaResultProto.getDefaultInstance(),
+                status -> SetSchemaResultProto.newBuilder().setStatus(status).build());
     }
 
     @NonNull
@@ -160,9 +228,12 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     public GetSchemaResultProto getSchema() {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData = mEngine.getSchema();
         } catch (RemoteException e) {
             return GetSchemaResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -176,9 +247,12 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     public GetSchemaResultProto getSchemaForDatabase(@NonNull String database) {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData = mEngine.getSchemaForDatabase(database);
         } catch (RemoteException e) {
             return GetSchemaResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -192,11 +266,14 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     public GetSchemaTypeResultProto getSchemaType(@NonNull String schemaType) {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData = mEngine.getSchemaType(schemaType);
         } catch (RemoteException e) {
             return GetSchemaTypeResultProto.newBuilder()
                     .setStatus(remoteExceptionStatus(e))
                     .build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -208,11 +285,21 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     @NonNull
     @Override
     public PutResultProto put(@NonNull DocumentProto document) {
+        byte[] input = document.toByteArray();
+
         byte[] resultData;
         try {
-            resultData = mEngine.put(document.toByteArray());
+            mVmStateSignaler.signalActivityStarts();
+            resultData = mEngine.put(input);
+        } catch (OutOfMemoryError e) {
+            Log.w(TAG, "Got out of memory in put. Request length: " + input.length);
+            logFreeMemoryInfo(e);
+
+            return PutResultProto.newBuilder().setStatus(oomExceptionStatus(e)).build();
         } catch (RemoteException e) {
             return PutResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -224,14 +311,29 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     @NonNull
     @Override
     public BatchPutResultProto batchPut(@NonNull PutDocumentRequest putDocumentRequest) {
+        byte[] input = putDocumentRequest.toByteArray();
+
         byte[] resultData;
         try {
-            resultData = mEngine.batchPut(putDocumentRequest.toByteArray());
+            mVmStateSignaler.signalActivityStarts();
+            resultData = mEngine.batchPut(input);
+        } catch (OutOfMemoryError e) {
+            Log.w(
+                    TAG,
+                    "Got out of memory in batch put. Request length: "
+                            + input.length
+                            + ", number of documents in request: "
+                            + putDocumentRequest.getDocumentsCount());
+            logFreeMemoryInfo(e);
+
+            return BatchPutResultProto.newBuilder().setStatus(oomExceptionStatus(e)).build();
         } catch (RemoteException e) {
             return BatchPutResultProto.newBuilder()
                     // TODO(b/401245113) set status when the change is available.
-                    // .setStatus(remoteExceptionStatus(e))
+                    .setStatus(remoteExceptionStatus(e))
                     .build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -240,7 +342,7 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
                 status ->
                         BatchPutResultProto.newBuilder()
                                 // TODO(b/401245113) set status when the change is available.
-                                // .setStatus(status)
+                                .setStatus(status)
                                 .build());
     }
 
@@ -252,9 +354,12 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
             @NonNull GetResultSpecProto getResultSpec) {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData = mEngine.get(namespace, uri, getResultSpec.toByteArray());
         } catch (RemoteException e) {
             return GetResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -266,8 +371,106 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     @NonNull
     @Override
     public BatchGetResultProto batchGet(@NonNull GetResultSpecProto getResultSpec) {
-        // TODO(b/396144272): Implement this
-        throw new UnsupportedOperationException("Not implemented yet.");
+        BatchGetResultProto responseForTheFirstCall = null;
+        // Used to rewrite the response from the 1st call if limit is reached.
+        BatchGetResultProto.Builder responseBuilderIfLimitReached = null;
+
+        try {
+            mVmStateSignaler.signalActivityStarts();
+            // TODO(b/401245769) this could be set directly in the caller so we don't need to do
+            //  this extra toBuilder here.
+            // The transaction limit for the VM is 600KB. We just use the same limit for query here.
+            GetResultSpecProto.Builder requestBuilder = getResultSpec.toBuilder()
+                    .setNumTotalDocumentBytesToReturn(
+                            IsolatedStorageServiceManager
+                                    .DEFAULT_MAX_PAGE_BYTES_LIMIT_FOR_ISOLATED_STORAGE);
+            int numIdsRequested = getResultSpec.getIdsList().size();
+            // tracks the previous curIndex value
+            int prevIndex = 0;
+            // tracks the doc position in the response being rewritten. It is being used to rewrite
+            // the result
+            // if we reach the limit.
+            int curIndex = 0;
+
+            // TODO(b/401245769) We can refactor this do-while with some helper functions to make
+            //  the logic easier to follow.
+
+            // We do one batchGet first, and if we see from some id we reach the limit, we will
+            // call batchGet again and rewrite the response to retrieve all the docs.
+            do {
+                getResultSpec = requestBuilder.build();
+                // requestBuilder is reused for all the batchGet so we need to clear ids here.
+                requestBuilder.clearIds();
+
+                byte[] resultData = mEngine.batchGet(getResultSpec.toByteArray());
+                BatchGetResultProto response = getResponseProtoFromRawData(
+                        resultData,
+                        BatchGetResultProto.getDefaultInstance(),
+                        status ->
+                                BatchGetResultProto.newBuilder()
+                                        .setStatus(status)
+                                        .build());
+                List<GetResultProto> getResultProtoList = response.getGetResultProtosList();
+
+                if (responseForTheFirstCall == null) {
+                    responseForTheFirstCall = response;
+                }
+
+                // This flag is set when we see the first ABORTED to indicate for the current
+                // batchGet, we can't get all the documents out due to reaching the limit
+                // Right now in Icing, if we hit the limit, we will fail the remaining ids.
+                // So we don't need to check the status code for the rest of the results if
+                // this flag is true.
+                boolean limitReached = false;
+                prevIndex = curIndex; // saves the previous position.
+                // TODO(b/401245769) We can set a different status code to indicate we reach
+                //  the limit and should retry to avoid entering this loop unnecessarily.
+                for (int i = 0; i < getResultProtoList.size(); ++i) {
+                    GetResultProto getResultProto = getResultProtoList.get(i);
+                    if (!limitReached
+                            && getResultProto.getStatus().getCode() != StatusProto.Code.ABORTED) {
+                        if (responseBuilderIfLimitReached != null) {
+                            // This is not the 1st call so we need to rewrite the result for
+                            // curIndex.
+                            responseBuilderIfLimitReached.setGetResultProtos(curIndex,
+                                    getResultProto);
+                        }
+                        // Advance the index in the final result as we won't retry for
+                        // the current id.
+                        ++curIndex;
+                    } else {
+                        //
+                        // We hit the limit and need to retry.
+                        //
+                        if (responseBuilderIfLimitReached == null) {
+                            // This is the first call. Create response builder from the 1st call.
+                            responseBuilderIfLimitReached = responseForTheFirstCall.toBuilder();
+                        }
+                        limitReached = true;
+                        requestBuilder.addIds(getResultProto.getUri());
+                    }
+                }
+
+                // We exit if
+                // 1) we have gotten all the docs we need out(curIndex == requestIdsSize).
+                // OR
+                // 2) curIndex is not changed(prevIndex == curIndex).
+                // It means somehow we get stuck. It could be the asked doc size is always bigger
+                // than the limit set. In this case, we should just exit.
+            } while(curIndex < numIdsRequested && prevIndex < curIndex);
+        } catch (RemoteException e) {
+            return BatchGetResultProto.newBuilder()
+                    .setStatus(remoteExceptionStatus(e))
+                    .build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
+        }
+
+        if (responseBuilderIfLimitReached == null) {
+            // We didn't reach the limit.
+            return responseForTheFirstCall;
+        }
+        return responseBuilderIfLimitReached.build();
     }
 
     @NonNull
@@ -275,9 +478,12 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     public ReportUsageResultProto reportUsage(@NonNull UsageReport usageReport) {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData = mEngine.reportUsage(usageReport.toByteArray());
         } catch (RemoteException e) {
             return ReportUsageResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -291,11 +497,14 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     public GetAllNamespacesResultProto getAllNamespaces() {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData = mEngine.getAllNamespaces();
         } catch (RemoteException e) {
             return GetAllNamespacesResultProto.newBuilder()
                     .setStatus(remoteExceptionStatus(e))
                     .build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -312,6 +521,7 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
             @NonNull ResultSpecProto resultSpec) {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData =
                     mEngine.search(
                             searchSpec.toByteArray(),
@@ -319,6 +529,8 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
                             resultSpec.toByteArray());
         } catch (RemoteException e) {
             return SearchResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -332,9 +544,33 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     public SearchResultProto getNextPage(long nextPageToken) {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData = mEngine.getNextPage(nextPageToken);
         } catch (RemoteException e) {
             return SearchResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                SearchResultProto.getDefaultInstance(),
+                status -> SearchResultProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public SearchResultProto getNextPage(@NonNull GetNextPageRequestProto getNextPageRequest) {
+        byte[] inputRequest = getNextPageRequest.toByteArray();
+
+        byte[] resultData;
+        try {
+            mVmStateSignaler.signalActivityStarts();
+            resultData = mEngine.getNextPageWithRequestProto(inputRequest);
+        } catch (RemoteException e) {
+            return SearchResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -346,9 +582,12 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     @Override
     public void invalidateNextPageToken(long nextPageToken) {
         try {
+            mVmStateSignaler.signalActivityStarts();
             mEngine.invalidateNextPageToken(nextPageToken);
         } catch (RemoteException e) {
             Log.e(TAG, "failed to call invalidateNextPageToken", e);
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
     }
 
@@ -357,9 +596,12 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     public BlobProto openWriteBlob(@NonNull PropertyProto.BlobHandleProto blobHandle) {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData = mEngine.openWriteBlob(blobHandle.toByteArray());
         } catch (RemoteException e) {
             return BlobProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -373,9 +615,12 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     public BlobProto removeBlob(@NonNull PropertyProto.BlobHandleProto blobHandle) {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData = mEngine.removeBlob(blobHandle.toByteArray());
         } catch (RemoteException e) {
             return BlobProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -389,9 +634,12 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     public BlobProto openReadBlob(@NonNull PropertyProto.BlobHandleProto blobHandle) {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData = mEngine.openReadBlob(blobHandle.toByteArray());
         } catch (RemoteException e) {
             return BlobProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -405,9 +653,12 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     public BlobProto commitBlob(@NonNull PropertyProto.BlobHandleProto blobHandle) {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData = mEngine.commitBlob(blobHandle.toByteArray());
         } catch (RemoteException e) {
             return BlobProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -421,9 +672,12 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     public DeleteResultProto delete(@NonNull String namespace, @NonNull String uri) {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData = mEngine.deleteDoc(namespace, uri);
         } catch (RemoteException e) {
             return DeleteResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -437,9 +691,12 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     public SuggestionResponse searchSuggestions(@NonNull SuggestionSpecProto suggestionSpec) {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData = mEngine.searchSuggestions(suggestionSpec.toByteArray());
         } catch (RemoteException e) {
             return SuggestionResponse.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -453,11 +710,14 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     public DeleteByNamespaceResultProto deleteByNamespace(@NonNull String namespace) {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData = mEngine.deleteByNamespace(namespace);
         } catch (RemoteException e) {
             return DeleteByNamespaceResultProto.newBuilder()
                     .setStatus(remoteExceptionStatus(e))
                     .build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -471,11 +731,14 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     public DeleteBySchemaTypeResultProto deleteBySchemaType(@NonNull String schemaType) {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData = mEngine.deleteBySchemaType(schemaType);
         } catch (RemoteException e) {
             return DeleteBySchemaTypeResultProto.newBuilder()
                     .setStatus(remoteExceptionStatus(e))
                     .build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -489,6 +752,7 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     public DeleteByQueryResultProto deleteByQuery(@NonNull SearchSpecProto searchSpec) {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData =
                     mEngine.deleteByQuery(
                             searchSpec.toByteArray(), /* returnDeletedDocumentInfo= */ false);
@@ -496,6 +760,8 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
             return DeleteByQueryResultProto.newBuilder()
                     .setStatus(remoteExceptionStatus(e))
                     .build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -510,11 +776,14 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
             @NonNull SearchSpecProto searchSpec, boolean returnDeletedDocumentInfo) {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData = mEngine.deleteByQuery(searchSpec.toByteArray(), returnDeletedDocumentInfo);
         } catch (RemoteException e) {
             return DeleteByQueryResultProto.newBuilder()
                     .setStatus(remoteExceptionStatus(e))
                     .build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -528,11 +797,14 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     public PersistToDiskResultProto persistToDisk(@NonNull PersistType.Code persistTypeCode) {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData = mEngine.persistToDisk(persistTypeCode.getNumber());
         } catch (RemoteException e) {
             return PersistToDiskResultProto.newBuilder()
                     .setStatus(remoteExceptionStatus(e))
                     .build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -546,9 +818,12 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     public OptimizeResultProto optimize() {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData = mEngine.optimize();
         } catch (RemoteException e) {
             return OptimizeResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -562,11 +837,14 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     public GetOptimizeInfoResultProto getOptimizeInfo() {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData = mEngine.getOptimizeInfo();
         } catch (RemoteException e) {
             return GetOptimizeInfoResultProto.newBuilder()
                     .setStatus(remoteExceptionStatus(e))
                     .build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -580,9 +858,12 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     public StorageInfoResultProto getStorageInfo() {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData = mEngine.getStorageInfo();
         } catch (RemoteException e) {
             return StorageInfoResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -596,9 +877,12 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     public DebugInfoResultProto getDebugInfo(@NonNull DebugInfoVerbosity.Code verbosity) {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData = mEngine.getDebugInfo(verbosity.getNumber());
         } catch (RemoteException e) {
             return DebugInfoResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -612,9 +896,31 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
     public ResetResultProto reset() {
         byte[] resultData;
         try {
+            mVmStateSignaler.signalActivityStarts();
             resultData = mEngine.reset();
         } catch (RemoteException e) {
             return ResetResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
+        }
+
+        return getResponseProtoFromRawData(
+                resultData,
+                ResetResultProto.getDefaultInstance(),
+                status -> ResetResultProto.newBuilder().setStatus(status).build());
+    }
+
+    @NonNull
+    @Override
+    public ResetResultProto clearAndDestroy() {
+        byte[] resultData;
+        try {
+            mVmStateSignaler.signalActivityStarts();
+            resultData = mEngine.clearAndDestroy();
+        } catch (RemoteException e) {
+            return ResetResultProto.newBuilder().setStatus(remoteExceptionStatus(e)).build();
+        } finally {
+            mVmStateSignaler.signalActivityEnds();
         }
 
         return getResponseProtoFromRawData(
@@ -647,19 +953,79 @@ public final class IcingSearchEngine implements IcingSearchEngineInterface {
         return parser.parseFrom(data);
     }
 
-    private static @NonNull StatusProto remoteExceptionStatus(@NonNull Exception e) {
-        Log.e(TAG, "Failed to call isolated storage service via binder", e);
+    private @NonNull StatusProto remoteExceptionStatus(@NonNull RemoteException e) {
+        String message;
+        if (mIsReconnecting && e instanceof DeadObjectException) {
+            Log.w(TAG, "Reconnecting to isolated storage service", e);
+            message = "reconnecting to isolated storage service, please wait and retry";
+        } else {
+            Log.w(TAG, "Failed to call isolated storage service via binder", e);
+            message = "failed to call isolated storage service via binder: " + e.getMessage();
+        }
         return StatusProto.newBuilder()
-                .setCode(StatusProto.Code.INTERNAL)
-                .setMessage("failed to call isolated storage service via binder: " + e.getMessage())
+                .setCode(StatusProto.Code.UNAVAILABLE)
+                .setMessage(message)
+                .build();
+    }
+
+    private static @NonNull StatusProto oomExceptionStatus(@NonNull OutOfMemoryError e) {
+        Log.w(TAG, "Encountered OOM in midst of binder transaction", e);
+        // TODO(b/404210068): Add a different error code to distinguish these failures.
+        return StatusProto.newBuilder()
+                .setCode(StatusProto.Code.UNKNOWN)
+                .setMessage("Ran out of memory when allocating request: " + e.getMessage())
                 .build();
     }
 
     private static @NonNull StatusProto protoParseFailureStatus(@NonNull Exception e) {
-        Log.e(TAG, "Failed to parse proto data", e);
+        Log.w(TAG, "Failed to parse proto data", e);
         return StatusProto.newBuilder()
                 .setCode(StatusProto.Code.INTERNAL)
                 .setMessage("failed to parse proto data: " + e.getMessage())
                 .build();
     }
+
+    /**
+     * Helper function to get and print the amount of free RAM in KB. {@code -1} will be printed if
+     * failing to get the number.
+     */
+    private void logFreeMemoryInfo(@Nullable OutOfMemoryError oomError) {
+        long deviceFreeMemoryKb = -1;
+        try {
+            MemInfoReader memInfo = new MemInfoReader();
+            deviceFreeMemoryKb = memInfo.getFreeSizeKb();
+        } catch (Error e) {
+            Log.w(TAG, "Unable to get device free memory size from /proc/meminfo due to error", e);
+        } catch (Exception e) {
+            Log.w(TAG, "Unable to get device free memory size from /proc/meminfo", e);
+        }
+
+        long jvmFreeMemoryKb = -1;
+        try {
+            jvmFreeMemoryKb = Runtime.getRuntime().freeMemory() / 1024;
+        } catch (Error e) {
+            Log.w(TAG, "Unable to get jvm free memory size due to error", e);
+        }
+
+        long vmIsolatedStorageFreeMemoryKb = -1;
+        try {
+            vmIsolatedStorageFreeMemoryKb = mVmIsolatedStorageService.getAvailableMemory();
+        } catch (RemoteException e) {
+            Log.wtf(TAG, "Unable to get vm isolated storage free memory size", e);
+        } catch (OutOfMemoryError e) {
+            Log.wtf(TAG, "Unable to get vm isolated storage free memory size due to OOM error", e);
+        } catch (Error e) {
+            Log.wtf(TAG, "Unable to get vm isolated storage free memory size due to error", e);
+        }
+
+        Log.wtf(
+                TAG,
+                "Android device free memory (from /proc/meminfo): "
+                        + deviceFreeMemoryKb
+                        + " KB, Android JVM free memory (from Runtime): "
+                        + jvmFreeMemoryKb
+                        + " KB, VM isolated storage free memory: "
+                        + vmIsolatedStorageFreeMemoryKb
+                        + " KB.", oomError);
+    }
 }
diff --git a/service/java/com/android/server/appsearch/isolated_storage_service/IsolatedStorageServiceManager.java b/service/java/com/android/server/appsearch/isolated_storage_service/IsolatedStorageServiceManager.java
index 5ff1ac71..274047e8 100644
--- a/service/java/com/android/server/appsearch/isolated_storage_service/IsolatedStorageServiceManager.java
+++ b/service/java/com/android/server/appsearch/isolated_storage_service/IsolatedStorageServiceManager.java
@@ -15,10 +15,15 @@
  */
 package com.android.server.appsearch.isolated_storage_service;
 
+import static android.app.appsearch.AppSearchResult.RESULT_INTERNAL_ERROR;
+import static android.app.appsearch.AppSearchResult.RESULT_UNAVAILABLE;
+
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.WorkerThread;
+import android.app.appsearch.exceptions.AppSearchException;
 import android.app.appsearch.util.ExceptionUtil;
+import android.app.appsearch.util.LogUtil;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
@@ -26,7 +31,10 @@ import android.content.ServiceConnection;
 import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
 import android.os.Build;
+import android.os.Handler;
 import android.os.IBinder;
+import android.os.Looper;
+import android.os.ParcelFileDescriptor;
 import android.os.RemoteException;
 import android.os.SystemProperties;
 import android.os.UserHandle;
@@ -40,11 +48,15 @@ import com.android.internal.annotations.GuardedBy;
 import com.android.server.appsearch.ServiceAppSearchConfig;
 
 import com.google.android.icing.IcingSearchEngineInterface;
+import com.google.android.icing.proto.InitializeResultProto;
+import com.google.android.icing.proto.ResetResultProto;
+import com.google.android.icing.proto.StatusProto;
 
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
 
 /** Manages the isolated storage service and provides related services. */
@@ -52,44 +64,100 @@ public final class IsolatedStorageServiceManager {
     private static final String TAG = "IsolatedStorageServiceM";
 
     // TODO: b/389105038 - remove the temporary workaround for binder transaction limit.
-    // Binder RPC max transaction allocation is 600 KiB. We use 512 KiB here since the current
-    // max doc size is 512 KiB, and also leave some room for non-page fields in the response protos.
-    public static final int DEFAULT_MAX_PAGE_BYTES_LIMIT_FOR_ISOLATED_STORAGE = 512 * 1024;
+    // Binder RPC max transaction allocation is 600 KiB.
+    // - We use 64 KiB here. This will leave some room for non-page fields in the response protos
+    // - The current max doc size is 512 KiB, but the result page retrieval logic will add at least
+    //   one document into the page even if it exceeds this limit, so we're still able to get a
+    //   single giant document in a single page.
+    public static final int DEFAULT_MAX_PAGE_BYTES_LIMIT_FOR_ISOLATED_STORAGE = 64 * 1024;
 
     public static final String SYSTEM_PROPERTY_ENABLE_ISOLATED_STORAGE =
             "ro.appsearch.feature.enable_isolated_storage";
-    public static final long DEFAULT_MEMORY_BYTES = 1_000_000_000;
+    public static final long DEFAULT_MEMORY_BYTES = 512_000_000;
+    public static final boolean DEFAULT_ISOLATED_STORAGE_ENABLED = true;
+    public static final boolean DEFAULT_ISOLATED_STORAGE_MIGRATION_ENABLED = false;
+    public static final boolean DEFAULT_ISOLATED_STORAGE_DELETE_CE_VMS = false;
     private static final String ISOLATED_STORAGE_SERVICE =
             "com.android.appsearch.ISOLATED_STORAGE_SERVICE";
     private static final String ISOLATED_STORAGE_SERVICE_CLASS_NAME =
             "com.android.server.appsearch.isolated_storage_service.IsolatedStorageService";
-    private static final int FUTURE_WAIT_TIMEOUT_SECONDS = 5;
+    private static final int BINDING_WAIT_TIMEOUT_SECONDS = 10;
+    private static final int PAYLOAD_WAIT_TIMEOUT_SECONDS = 61;
+    private static final int MAX_VM_START_RETRIES = 3;
+    private static final int MAX_REINITIALIZATION_RETRIES = 9;
+    private static final int MAX_ICING_INITIALIZATION_RETRIES = 3;
+    private static final long VM_STATUS_CHECK_INTERVAL_MS = 60 * 1000; // 1 minute
+
+    private static final UserHandle ISOLATED_STORAGE_USER = UserHandle.SYSTEM;
 
     private final Context mContext;
     private final ServiceAppSearchConfig mAppSearchConfig;
+    private final Executor mExecutor;
+    private final VmStateSignaler mVmStateSignaler;
+    private final IsolatedStorageServiceDeathRecipient mIsolatedStorageServiceDeathRecipient =
+            new IsolatedStorageServiceDeathRecipient();
+    private final VmIsolatedStorageServiceDeathRecipient mVmIsolatedStorageServiceDeathRecipient =
+            new VmIsolatedStorageServiceDeathRecipient();
+    private final Handler mHandler;
+    private final Runnable mVmStatusChecker;
+    private final Object mLock = new Object();
+
+    private final VmDataUnlocker mVmUnlocker = new VmDataUnlocker();
 
     // The isolated storage service implemented by the apk to manage VM and pass VM connections.
-    private IIsolatedStorageService mIsolatedStorageService;
+    private volatile IIsolatedStorageService mIsolatedStorageService;
+
     // The isolated storage service implemented by the VM to access icing.
+    @GuardedBy("mLock")
     private com.android.isolated_storage_service.IIsolatedStorageService mVmIsolatedStorageService;
 
-    @GuardedBy("mIcingInstancesLocked")
-    private final Map<UserHandle, IcingSearchEngineInterface> mIcingInstancesLocked =
-            new ArrayMap<>();
+    @GuardedBy("mLock")
+    private final Map<UserHandle, IcingSearchEngine> mIcingInstancesLocked = new ArrayMap<>();
 
     public IsolatedStorageServiceManager(
-            @NonNull Context context, @NonNull ServiceAppSearchConfig appSearchConfig) {
+            @NonNull Context context,
+            @NonNull ServiceAppSearchConfig appSearchConfig,
+            @NonNull Executor executor) {
         mContext = Objects.requireNonNull(context);
         mAppSearchConfig = Objects.requireNonNull(appSearchConfig);
+        mExecutor = Objects.requireNonNull(executor);
+        mVmStateSignaler = new VmStateSignaler();
+        mHandler = new Handler(Looper.getMainLooper());
+        mVmStatusChecker =
+                new Runnable() {
+                    @Override
+                    public void run() {
+                        synchronized (mLock) {
+                            try {
+                                if (mIsolatedStorageService == null) {
+                                    Log.i(TAG, "Isolated storage service not connected");
+                                } else {
+                                    int status = mIsolatedStorageService.getVmStatus();
+                                    Log.i(TAG, "Isolated storage service VM status: " + status);
+                                }
+
+                            } catch (Exception | OutOfMemoryError e) {
+                                Log.e(TAG, "Unable to get VM status", e);
+                            } finally {
+                                mHandler.postDelayed(this, VM_STATUS_CHECK_INTERVAL_MS);
+                            }
+                        }
+                    }
+                };
     }
 
     /** Gets whether isolated storage should be used. */
-    public static boolean useIsolatedStorage(Context context) {
-        return isolatedStorageFlagsSet() && deviceSupportsVmsAndNewApis(context);
+    public static boolean useIsolatedStorage(
+            @NonNull Context context, @NonNull ServiceAppSearchConfig appSearchConfig) {
+        Objects.requireNonNull(context);
+        Objects.requireNonNull(appSearchConfig);
+        return appSearchConfig.getIsolatedStorageEnabled()
+                && isolatedStorageFlagsSet()
+                && deviceSupportsVmsAndNewApis(context);
     }
 
     /** Gets whether isolated storage flags are all set. */
-    public static boolean isolatedStorageFlagsSet() {
+    private static boolean isolatedStorageFlagsSet() {
         return Flags.enableIsolatedStorage()
                 && SystemProperties.getBoolean(
                         SYSTEM_PROPERTY_ENABLE_ISOLATED_STORAGE, /* def= */ false);
@@ -110,16 +178,109 @@ public final class IsolatedStorageServiceManager {
                 && ((vmm.getCapabilities() & VirtualMachineManager.CAPABILITY_PROTECTED_VM) != 0);
     }
 
-    /** Starts the isolated storage service if not already. */
+    /**
+     * Initializes the isolated storage service if not already.
+     *
+     * <p>This will bind to the isolated storage service, start the VM, and connects to the VM if
+     * not already.
+     */
+    public void initialize() throws AppSearchException {
+        initialize(false, MAX_VM_START_RETRIES);
+    }
+
+    /**
+     * Initializes the isolated storage service if not already.
+     *
+     * <p>This will bind to the isolated storage service, start the VM, and connects to the VM if
+     * not already.
+     *
+     * @param forceVmRestart Whether to force restarting the VM.
+     * @param numRetries Number of retries when starting the VM.
+     */
+    private void initialize(boolean forceVmRestart, int numRetries) throws AppSearchException {
+        synchronized (mLock) {
+            if (mIsolatedStorageService == null) {
+                bindIsolatedStorageServiceLocked();
+            }
+            if (mVmIsolatedStorageService == null) {
+                connectToVmIsolatedStorageServiceLocked(forceVmRestart, numRetries);
+            }
+            if (LogUtil.INFO && !mHandler.hasCallbacks(mVmStatusChecker)) {
+                Log.d(TAG, "Scheduling VM status check");
+                mHandler.post(mVmStatusChecker);
+            }
+        }
+    }
+
+    /** Called when the user unlocks the device. */
+    public void onUserUnlocking(
+            @NonNull ServiceAppSearchConfig appSearchConfig, @NonNull UserHandle userHandle) {
+        Objects.requireNonNull(appSearchConfig);
+        Objects.requireNonNull(userHandle);
+
+        if (!isUserAllowed(userHandle)) {
+            // Currently the Isolated Storage Service only stores data for the primary
+            // user. Ignore calls for other users. In the future, when the Isolated Storage
+            // service supports multiple users, we may handle this call appropriately.
+            Log.i(TAG, "ignoring onUserUnlocking call for disallowed user " + userHandle);
+            return;
+        }
+
+        Log.i(TAG, "onUserUnlocking");
+        mVmStateSignaler.scheduleEnablement();
+        mVmUnlocker.onUserUnlocking();
+
+        synchronized (mLock) {
+            if (mIsolatedStorageService != null
+                    && appSearchConfig.getIsolatedStorageDeleteCeVms()) {
+                try {
+                    mIsolatedStorageService.cleanUpOldVms();
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Unable to clean up old VMs", e);
+                }
+            }
+        }
+    }
+
+    /** Removes the icing instance for the corresponding userHandle */
+    public void removeUserInstance(UserHandle userHandle) {
+        synchronized (mLock) {
+            IcingSearchEngineInterface instance = mIcingInstancesLocked.remove(userHandle);
+            if (instance != null) {
+                // Delete the corresponding user data in isolated storage
+                ResetResultProto result = instance.clearAndDestroy();
+                if (result.getStatus().getCode() != StatusProto.Code.OK) {
+                    Log.i(
+                            TAG,
+                            "Error while deleting isolated storage data for user: " + userHandle);
+                }
+                try {
+                    // Remove the Icing connection from the VM Isolated Storage Service
+                    mVmIsolatedStorageService.removeIcingConnection(userHandle.getIdentifier());
+                } catch (RemoteException e) {
+                    Log.e(
+                            TAG,
+                            "Unable to remove Isolated Icing connection for user: " + userHandle,
+                            e);
+                }
+            }
+        }
+    }
+
+    /** Binds to the isolated storage service if not already. */
     @WorkerThread
-    public void startIsolatedStorageService() {
+    @GuardedBy("mLock")
+    private void bindIsolatedStorageServiceLocked() throws AppSearchException {
         if (mIsolatedStorageService != null) {
+            Log.i(TAG, "Isolated storage service already bound");
             return;
         }
+        Log.i(TAG, "Binding to " + ISOLATED_STORAGE_SERVICE);
 
         String packageName = maybeGetPackageName(mContext);
         if (packageName == null) {
-            return;
+            throw new AppSearchException(
+                    RESULT_INTERNAL_ERROR, "Unable to get isolated storage service package name");
         }
 
         Intent intent = new Intent();
@@ -129,36 +290,62 @@ public final class IsolatedStorageServiceManager {
                 intent,
                 new IsolatedStorageServiceConnection(future),
                 Context.BIND_AUTO_CREATE | Context.BIND_IMPORTANT,
-                UserHandle.SYSTEM);
+                ISOLATED_STORAGE_USER);
         try {
-            future.get(FUTURE_WAIT_TIMEOUT_SECONDS, TimeUnit.SECONDS);
+            future.get(BINDING_WAIT_TIMEOUT_SECONDS, TimeUnit.SECONDS);
         } catch (Exception e) {
             Log.e(TAG, "Unable to bind to " + ISOLATED_STORAGE_SERVICE, e);
-            ExceptionUtil.handleException(e);
-            return;
+            throw new AppSearchException(
+                    RESULT_UNAVAILABLE, "Unable to bind to " + ISOLATED_STORAGE_SERVICE, e);
         }
         if (mIsolatedStorageService == null) {
+            Log.e(TAG, "Unable to bind to " + ISOLATED_STORAGE_SERVICE);
+            throw new AppSearchException(
+                    RESULT_UNAVAILABLE, "Unable to bind to " + ISOLATED_STORAGE_SERVICE);
+        }
+    }
+
+    /** Connects to the VM isolated storage service if not already. */
+    @WorkerThread
+    @GuardedBy("mLock")
+    private void connectToVmIsolatedStorageServiceLocked(boolean forceVmRestart, int numRetries)
+            throws AppSearchException {
+        if (mVmIsolatedStorageService != null) {
+            Log.i(TAG, "VM already connected");
             return;
         }
-        waitForVmPayloadReady();
+        Log.i(TAG, "Connecting to vm");
+        waitForVmPayloadReadyLocked(forceVmRestart, numRetries);
         try {
             IBinder iBinder =
                     VirtualMachine.binderFromPreconnectedClient(
                             () -> {
                                 try {
-                                    return mIsolatedStorageService.getVmConnection();
-                                } catch (RemoteException e) {
+                                    ParcelFileDescriptor pfd = getVmConnectionLocked();
+                                    return pfd;
+                                } catch (Exception e) {
                                     Log.e(TAG, "Unable to get vm connection", e);
                                     throw new RuntimeException(e);
                                 }
                             });
+            if (iBinder == null) {
+                throw new NullPointerException("Null binder when connecting to VM");
+            }
             mVmIsolatedStorageService =
                     com.android.isolated_storage_service.IIsolatedStorageService.Stub.asInterface(
                             iBinder);
+            iBinder.linkToDeath(mVmIsolatedStorageServiceDeathRecipient, /* flags= */ 0);
+            mVmUnlocker.onVmAvailable();
         } catch (Exception e) {
+            mVmIsolatedStorageService = null;
             Log.e(TAG, "Unable to connect to vm", e);
-            ExceptionUtil.handleException(e);
+            throw new AppSearchException(RESULT_UNAVAILABLE, "Unable to connect to vm", e);
+        }
+        if (mVmIsolatedStorageService == null) {
+            Log.e(TAG, "Failed to connect to vm");
+            throw new AppSearchException(RESULT_UNAVAILABLE, "Unable to connect to vm");
         }
+        Log.i(TAG, "Successfully connected to vm");
     }
 
     /**
@@ -187,13 +374,58 @@ public final class IsolatedStorageServiceManager {
         return resolveInfos.get(0).serviceInfo.packageName;
     }
 
-    private void waitForVmPayloadReady() {
+    @GuardedBy("mLock")
+    private void waitForVmPayloadReadyLocked(boolean forceVmRestart, int numRetries)
+            throws AppSearchException {
+        boolean vmStarted = false;
+        ServiceConfig serviceConfig = createServiceConfig();
         try {
-            mIsolatedStorageService.setup(createServiceConfig());
-        } catch (RemoteException e) {
+            for (int i = 0; i < numRetries; i++) {
+                // TODO(b/421272017): log latency, improve timeout and retry worst total time.
+                // - For recovering from dead vm, usually it takes more time to restart the vm in a
+                //   single attempt, so we increased PAYLOAD_WAIT_TIMEOUT_SECONDS.
+                // - But for rebooting, the total time is much stricter, so we should tune them.
+                if (mIsolatedStorageService.startVm(
+                        serviceConfig, PAYLOAD_WAIT_TIMEOUT_SECONDS, forceVmRestart)) {
+                    vmStarted = true;
+                    break;
+                }
+                Log.w(TAG, "Unable to wait for payload ready, retrying");
+                forceVmRestart = false;
+            }
+        } catch (Exception e) {
             Log.e(TAG, "Unable to wait for pVM to be ready", e);
-            ExceptionUtil.handleRemoteException(e);
+            throw new AppSearchException(RESULT_UNAVAILABLE, "Failed to start VM and load payload");
+        }
+        if (!vmStarted) {
+            throw new AppSearchException(
+                    RESULT_UNAVAILABLE, "Unable to wait for payload ready after retries");
+        }
+    }
+
+    @NonNull
+    @GuardedBy("mLock")
+    private ParcelFileDescriptor getVmConnectionLocked()
+            throws RemoteException, NullPointerException, IllegalStateException {
+        ParcelFileDescriptor pfd = mIsolatedStorageService.getVmConnection();
+        if (pfd == null) {
+            throw new NullPointerException("Null PFD VM connection");
+        } else if (pfd.getFd() < 0) {
+            throw new IllegalStateException("PFD VM connection is an invalid FD: " + pfd.getFd());
         }
+        return pfd;
+    }
+
+    /**
+     * Return true iff data from this user can be stored in isolatedStorage.
+     *
+     * <p>To ensure that data is encrypted with the appropriate credential encryption (CE) keys, we
+     * restrict Isolated Storage usage to only users running with the same ID as the Isolated
+     * Storage Service user. Other users should store their data in conventionally protected
+     * storage, which has equivalent security properties.
+     */
+    public static boolean isUserAllowed(@NonNull UserHandle id) {
+        return ISOLATED_STORAGE_USER.equals(id);
     }
 
     private ServiceConfig createServiceConfig() {
@@ -208,16 +440,16 @@ public final class IsolatedStorageServiceManager {
     /** Gets isolated storage backed icing instance for user. */
     @WorkerThread
     public @Nullable IcingSearchEngineInterface getIcingInstance(
-            @NonNull UserHandle userHandle, @NonNull ServiceAppSearchConfig config) {
+            @NonNull UserHandle userHandle, @NonNull ServiceAppSearchConfig config)
+            throws AppSearchException {
         Objects.requireNonNull(userHandle);
         Objects.requireNonNull(config);
 
-        if (mIsolatedStorageService == null) {
-            return null;
-        }
+        IcingSearchEngine instance;
+        synchronized (mLock) {
+            // initialize the isolated storage service if not already
+            initialize();
 
-        IcingSearchEngineInterface instance;
-        synchronized (mIcingInstancesLocked) {
             instance = mIcingInstancesLocked.get(userHandle);
             if (instance == null) {
                 Log.i(TAG, "getting isolated icing instance for user " + userHandle);
@@ -226,7 +458,10 @@ public final class IsolatedStorageServiceManager {
                             new IcingSearchEngine(
                                     mVmIsolatedStorageService.getOrCreateIcingConnection(
                                             userHandle.getIdentifier()),
-                                    config.toIcingSearchEngineOptions(/* baseDir= */ "appsearch"));
+                                    config.toIcingSearchEngineOptions(
+                                            /* baseDir= */ "appsearch", /* isVMEnabled= */ true),
+                                    mVmStateSignaler,
+                                    mVmIsolatedStorageService);
                 } catch (RemoteException e) {
                     Log.e(TAG, "Unable to get icing instance for " + userHandle, e);
                     ExceptionUtil.handleRemoteException(e);
@@ -241,7 +476,7 @@ public final class IsolatedStorageServiceManager {
     }
 
     /** A connection to the isolated storage service. */
-    private class IsolatedStorageServiceConnection implements ServiceConnection {
+    private final class IsolatedStorageServiceConnection implements ServiceConnection {
         private final CompletableFuture<Void> mFuture;
 
         IsolatedStorageServiceConnection(@NonNull CompletableFuture<Void> future) {
@@ -251,6 +486,15 @@ public final class IsolatedStorageServiceManager {
         @Override
         public void onServiceConnected(ComponentName className, IBinder service) {
             mIsolatedStorageService = IIsolatedStorageService.Stub.asInterface(service);
+            IBinder binder = mIsolatedStorageService.asBinder();
+            try {
+                binder.linkToDeath(mIsolatedStorageServiceDeathRecipient, /* flags= */ 0);
+            } catch (RemoteException e) {
+                Log.e(
+                        TAG,
+                        "failed to register a recipient of died IsolatedStorageService binder",
+                        e);
+            }
             Log.i(TAG, "IsolatedStorageService connected");
             mFuture.complete(null);
         }
@@ -258,22 +502,169 @@ public final class IsolatedStorageServiceManager {
         @Override
         public void onServiceDisconnected(ComponentName className) {
             Log.i(TAG, "IsolatedStorageService disconnected");
-            mIsolatedStorageService = null;
+            synchronized (mLock) {
+                mIsolatedStorageService = null;
+            }
             mFuture.cancel(/* mayInterruptIfRunning= */ true);
         }
 
         @Override
         public void onBindingDied(ComponentName className) {
+            // TODO(b/416509934): properly handle this when it's correctly triggered
             Log.i(TAG, "IsolatedStorageService binding died");
-            mIsolatedStorageService = null;
+            synchronized (mLock) {
+                mIsolatedStorageService = null;
+            }
             mFuture.cancel(/* mayInterruptIfRunning= */ true);
         }
 
         @Override
         public void onNullBinding(ComponentName className) {
             Log.i(TAG, "IsolatedStorageService null binding");
-            mIsolatedStorageService = null;
             mFuture.cancel(/* mayInterruptIfRunning= */ true);
         }
     }
+
+    private final class IsolatedStorageServiceDeathRecipient implements IBinder.DeathRecipient {
+        @Override
+        public void binderDied() {
+            Log.w(TAG, "binderDied: IsolatedStorageService");
+            synchronized (mLock) {
+                mIsolatedStorageService = null;
+            }
+            mExecutor.execute(() -> replaceVmIcingInstances());
+        }
+    }
+
+    private final class VmIsolatedStorageServiceDeathRecipient implements IBinder.DeathRecipient {
+        @Override
+        public void binderDied() {
+            Log.w(TAG, "binderDied: VmIsolatedStorageService");
+            synchronized (mLock) {
+                mVmIsolatedStorageService = null;
+                mVmUnlocker.onVmUnavailable();
+            }
+            mExecutor.execute(() -> replaceVmIcingInstances());
+        }
+    }
+
+    private void replaceVmIcingInstances() {
+        synchronized (mLock) {
+            try {
+                notifyVmReconnectingLocked(true);
+                try {
+                    // TODO(b/421272017): add logs that will cover how many retries we're attempting
+                    // and whether they actually recover eventually.
+                    initialize(true, MAX_REINITIALIZATION_RETRIES);
+                } catch (AppSearchException e) {
+                    Log.e(
+                            TAG,
+                            "failed to re-initialize after "
+                                    + MAX_REINITIALIZATION_RETRIES
+                                    + " retries");
+                    return;
+                }
+                for (UserHandle userHandle : mIcingInstancesLocked.keySet()) {
+                    IcingSearchEngine instance = mIcingInstancesLocked.get(userHandle);
+                    try {
+                        instance.setVmInstances(
+                                mVmIsolatedStorageService.getOrCreateIcingConnection(
+                                        userHandle.getIdentifier()),
+                                mVmIsolatedStorageService);
+                        initializeIcingWithRetryLocked(instance);
+                    } catch (RemoteException e) {
+                        Log.e(TAG, "failed to get vm icing instance for user " + userHandle, e);
+                    }
+                }
+            } finally {
+                notifyVmReconnectingLocked(false);
+            }
+        }
+    }
+
+    @GuardedBy("mLock")
+    private void notifyVmReconnectingLocked(boolean isReconnecting) {
+        for (IcingSearchEngine instance : mIcingInstancesLocked.values()) {
+            instance.setIsReconnecting(isReconnecting);
+        }
+    }
+
+    @GuardedBy("mLock")
+    private static void initializeIcingWithRetryLocked(IcingSearchEngine instance) {
+        boolean succeeded = false;
+        for (int i = 0; i < MAX_ICING_INITIALIZATION_RETRIES; i++) {
+            InitializeResultProto initializeResultProto = instance.initialize();
+            if (initializeResultProto.getStatus().getCode() == StatusProto.Code.OK) {
+                Log.i(TAG, "icing instance initialized");
+                succeeded = true;
+                break;
+            } else {
+                Log.e(
+                        TAG,
+                        "failed to initialize icing instance: "
+                                + initializeResultProto.getStatus());
+            }
+        }
+        if (!succeeded) {
+            Log.e(
+                    TAG,
+                    "failed to initialize icing after "
+                            + MAX_ICING_INITIALIZATION_RETRIES
+                            + " retries");
+            // TODO(b/416509382): consider resetting the icing instance
+        }
+    }
+
+    private final class VmDataUnlocker {
+        @GuardedBy("mLock")
+        private boolean mIsUserUnlocked = false;
+
+        @GuardedBy("mLock")
+        private boolean mIsVmAvailable = false;
+
+        private void onVmAvailable() {
+            synchronized (mLock) {
+                mIsVmAvailable = true;
+                tryVmDataUnlock();
+            }
+        }
+
+        private void onVmUnavailable() {
+            synchronized (mLock) {
+                mIsVmAvailable = false;
+            }
+        }
+
+        private void onUserUnlocking() {
+            synchronized (mLock) {
+                mIsUserUnlocked = true;
+                try {
+                    tryVmDataUnlock();
+                } catch (Exception e) {
+                    Log.e(TAG, "tryVmDataUnlock failed", e);
+                }
+            }
+        }
+
+        @GuardedBy("mLock")
+        private void tryVmDataUnlock() {
+            if (!mIsVmAvailable || !mIsUserUnlocked) {
+                Log.i(
+                        TAG,
+                        "not ready to unlock isVmAvailable="
+                                + mIsVmAvailable
+                                + " isUserUnlocked="
+                                + mIsUserUnlocked);
+                return;
+            }
+
+            Log.i(TAG, "signaling VM to unlock");
+            try {
+                mVmIsolatedStorageService.onUserUnlocking();
+            } catch (RemoteException e) {
+                Log.e(TAG, "onUserUnlocking VM notify failure", e);
+                ExceptionUtil.handleRemoteException(e);
+            }
+        }
+    }
 }
diff --git a/service/java/com/android/server/appsearch/isolated_storage_service/VmStateSignaler.java b/service/java/com/android/server/appsearch/isolated_storage_service/VmStateSignaler.java
new file mode 100644
index 00000000..d05923e4
--- /dev/null
+++ b/service/java/com/android/server/appsearch/isolated_storage_service/VmStateSignaler.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.server.appsearch.isolated_storage_service;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.util.Log;
+
+import com.android.internal.annotations.GuardedBy;
+
+/**
+ * Signals VM state changes.
+ *
+ * <p>The signaler tries to set the VM to idle if there is no activity for a certain amount of time.
+ * The signaler needs to be enabled explicitly.
+ */
+final class VmStateSignaler {
+    private static final String TAG = "VmStateSignaler";
+    private static final long INACTIVITY_TIMEOUT_MS = 20 * 1000; // 20 seconds
+    private static final long ENABLEMENT_DELAY_MS = 60 * 1000; // 60 seconds
+    private final Handler mHandler;
+    private final Runnable mVmStateIdleSetter;
+    private final Object mLock = new Object();
+
+    @GuardedBy("mLock")
+    private int mNumActivities = 0;
+
+    private volatile boolean mEnabled = false;
+    private volatile Boolean mIsIdle = null;
+
+    public VmStateSignaler() {
+        System.loadLibrary("appsearchservice");
+        mHandler = new Handler(Looper.getMainLooper());
+        mVmStateIdleSetter =
+                () -> {
+                    if (mIsIdle == null || !mIsIdle) {
+                        mIsIdle = true;
+                        notifyIdle(true);
+                    }
+                };
+    }
+
+    /** Schedules the signaler to be enabled. */
+    public void scheduleEnablement() {
+        if (mEnabled) {
+            Log.i(TAG, "already enabled");
+            return;
+        }
+        mHandler.postDelayed(() -> mEnabled = true, ENABLEMENT_DELAY_MS);
+    }
+
+    /** Signals that a VM activity starts. */
+    public void signalActivityStarts() {
+        synchronized (mLock) {
+            mNumActivities++;
+        }
+        if (!mEnabled) {
+            return;
+        }
+        mHandler.removeCallbacks(mVmStateIdleSetter);
+
+        if (mIsIdle == null || mIsIdle) {
+            mIsIdle = false;
+            notifyIdle(false);
+        }
+    }
+
+    /**
+     * Signals that the a VM activity ends.
+     *
+     * <p>Resets the inactivity timeout.
+     */
+    public void signalActivityEnds() {
+        synchronized (mLock) {
+            mNumActivities--;
+            if (mEnabled && mNumActivities == 0) {
+                mHandler.postDelayed(mVmStateIdleSetter, INACTIVITY_TIMEOUT_MS);
+            }
+        }
+    }
+
+    /** Signals that the VM is idle. */
+    private static native void notifyIdle(boolean idle);
+}
diff --git a/service/java/com/android/server/appsearch/stats/PlatformLogger.java b/service/java/com/android/server/appsearch/stats/PlatformLogger.java
index 91ca1809..e610451c 100644
--- a/service/java/com/android/server/appsearch/stats/PlatformLogger.java
+++ b/service/java/com/android/server/appsearch/stats/PlatformLogger.java
@@ -32,11 +32,13 @@ import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.appsearch.InternalAppSearchLogger;
 import com.android.server.appsearch.ServiceAppSearchConfig;
+import com.android.server.appsearch.appsindexer.AppOpenEventStats;
 import com.android.server.appsearch.external.localstorage.stats.CallStats;
 import com.android.server.appsearch.external.localstorage.stats.ClickStats;
 import com.android.server.appsearch.external.localstorage.stats.InitializeStats;
 import com.android.server.appsearch.external.localstorage.stats.OptimizeStats;
 import com.android.server.appsearch.external.localstorage.stats.PutDocumentStats;
+import com.android.server.appsearch.external.localstorage.stats.QueryStats;
 import com.android.server.appsearch.external.localstorage.stats.RemoveStats;
 import com.android.server.appsearch.external.localstorage.stats.SearchIntentStats;
 import com.android.server.appsearch.external.localstorage.stats.SearchSessionStats;
@@ -61,7 +63,7 @@ import java.util.Objects;
  *
  * @hide
  */
-public final class PlatformLogger implements InternalAppSearchLogger {
+public class PlatformLogger implements InternalAppSearchLogger {
     private static final String TAG = "AppSearchPlatformLogger";
 
     // Context of the user we're logging for.
@@ -95,9 +97,16 @@ public final class PlatformLogger implements InternalAppSearchLogger {
     @GuardedBy("mLock")
     private final Map<String, Integer> mPackageUidCacheLocked = new ArrayMap<>();
 
-    /** Elapsed time for last stats logged from boot in millis */
+    /** Elapsed time for last stats logged (to statsd) from boot in millis */
     @GuardedBy("mLock")
-    private long mLastPushTimeMillisLocked = 0;
+    private long mLastPushTimeMillisLocked = 0L;
+
+    /**
+     * Timestamp of the last `logStats(@NonNull CallStats stats)` call, used for calculating
+     * 'timeSincePreviousRequestMillis'. Updated even if the log is sampled.
+     */
+    @GuardedBy("mLock")
+    private long mLastCallStatsTimestampMillisLocked = 0L;
 
     /**
      * Record the last n API calls used by dumpsys to print debugging information about the sequence
@@ -133,15 +142,24 @@ public final class PlatformLogger implements InternalAppSearchLogger {
     @Override
     public void logStats(@NonNull CallStats stats) {
         Objects.requireNonNull(stats);
+        long currentCallReceivedTimestamp = stats.getCallReceivedTimestampMillis();
+        long calculatedTimeSincePreviousRequestMillis = -1L;
+
         synchronized (mLock) {
+            if (mLastCallStatsTimestampMillisLocked > 0) {
+                calculatedTimeSincePreviousRequestMillis =
+                        Math.max(currentCallReceivedTimestamp - mLastCallStatsTimestampMillisLocked, -1L);
+            }
+
             if (mConfig.getCachedApiCallStatsLimit() > 0) {
                 addStatsToQueueLocked(new ApiCallRecord(stats));
             } else {
                 mLastNCalls.clear();
             }
             if (shouldLogForTypeLocked(stats.getCallType())) {
-                logStatsImplLocked(stats);
+                logStatsImplLocked(stats, calculatedTimeSincePreviousRequestMillis);
             }
+            mLastCallStatsTimestampMillisLocked = currentCallReceivedTimestamp;
         }
     }
 
@@ -167,7 +185,17 @@ public final class PlatformLogger implements InternalAppSearchLogger {
     }
 
     @Override
-    public void logStats(@NonNull SearchStats stats) {
+    public void logStats(@NonNull AppOpenEventStats appOpenEventStats) {
+        Objects.requireNonNull(appOpenEventStats);
+        synchronized (mLock) {
+            if (shouldLogForTypeLocked(CallStats.INTERNAL_CALL_TYPE_APP_OPEN_EVENT_INDEXER)) {
+                logStatsImplLocked(appOpenEventStats);
+            }
+        }
+    }
+
+    @Override
+    public void logStats(@NonNull QueryStats stats) {
         Objects.requireNonNull(stats);
         synchronized (mLock) {
             if (shouldLogForTypeLocked(CallStats.CALL_TYPE_SEARCH)) {
@@ -178,7 +206,12 @@ public final class PlatformLogger implements InternalAppSearchLogger {
 
     @Override
     public void logStats(@NonNull RemoveStats stats) {
-        // TODO(b/173532925): Log stats
+        Objects.requireNonNull(stats);
+        synchronized (mLock) {
+            if (shouldLogForTypeLocked(CallStats.CALL_TYPE_REMOVE_DOCUMENTS_BY_ID)) {
+                logStatsImplLocked(stats);
+            }
+        }
     }
 
     @Override
@@ -264,7 +297,8 @@ public final class PlatformLogger implements InternalAppSearchLogger {
     }
 
     @GuardedBy("mLock")
-    private void logStatsImplLocked(@NonNull CallStats stats) {
+    private void logStatsImplLocked(
+            @NonNull CallStats stats, long timeSincePreviousRequestMillis) {
         mLastPushTimeMillisLocked = SystemClock.elapsedRealtime();
         ExtraStats extraStats = createExtraStatsLocked(stats.getPackageName(), stats.getCallType());
         String database = stats.getDatabase();
@@ -294,7 +328,8 @@ public final class PlatformLogger implements InternalAppSearchLogger {
                     stats.getNumOperationsSucceeded(),
                     stats.getNumOperationsFailed(),
                     numReportedCalls,
-                    stats.getEnabledFeatures());
+                    stats.getEnabledFeatures(),
+                    timeSincePreviousRequestMillis);
         } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
             // TODO(b/184204720) report hashing error to statsd
             //  We need to set a special value(e.g. 0xFFFFFFFF) for the hashing of the database,
@@ -358,6 +393,47 @@ public final class PlatformLogger implements InternalAppSearchLogger {
         }
     }
 
+    @GuardedBy("mLock")
+    private void logStatsImplLocked(@NonNull RemoveStats stats) {
+        mLastPushTimeMillisLocked = SystemClock.elapsedRealtime();
+        ExtraStats extraStats =
+                createExtraStatsLocked(
+                        stats.getPackageName(), CallStats.CALL_TYPE_REMOVE_DOCUMENTS_BY_ID);
+        String database = stats.getDatabase();
+        try {
+            int hashCodeForDatabase = StatsUtil.calculateHashCodeMd5(database);
+            // ignore close exception
+            AppSearchStatsLog.write(
+                    AppSearchStatsLog.APP_SEARCH_REMOVE_STATS_REPORTED,
+                    extraStats.mSamplingInterval,
+                    extraStats.mSkippedSampleCount,
+                    extraStats.mPackageUid,
+                    hashCodeForDatabase,
+                    stats.getStatusCode(),
+                    stats.getTotalLatencyMillis(),
+                    stats.getNativeLatencyMillis(),
+                    stats.getDeleteType(),
+                    stats.getDeletedDocumentCount(),
+                    stats.getEnabledFeatures(),
+                    stats.getQueryLength(),
+                    stats.getNumTerms(),
+                    stats.getNumNamespacesFiltered(),
+                    stats.getNumSchemaTypesFiltered(),
+                    stats.getParseQueryLatencyMillis(),
+                    stats.getDocumentRemovalLatencyMillis());
+        } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
+            // TODO(b/184204720) report hashing error to statsd
+            //  We need to set a special value(e.g. 0xFFFFFFFF) for the hashing of the database,
+            //  so in the dashboard we know there is some error for hashing.
+            //
+            // Something is wrong while calculating the hash code for database
+            // this shouldn't happen since we always use "MD5" and "UTF-8"
+            if (database != null) {
+                Log.e(TAG, "Error calculating hash code for database " + database, e);
+            }
+        }
+    }
+
     @GuardedBy("mLock")
     private void logStatsImplLocked(@NonNull SchemaMigrationStats stats) {
         mLastPushTimeMillisLocked = SystemClock.elapsedRealtime();
@@ -383,7 +459,8 @@ public final class PlatformLogger implements InternalAppSearchLogger {
                     stats.getSaveDocumentLatencyMillis(),
                     stats.getTotalNeedMigratedDocumentCount(),
                     stats.getTotalSuccessMigratedDocumentCount(),
-                    stats.getMigrationFailureCount());
+                    stats.getMigrationFailureCount(),
+                    stats.getEnabledFeatures());
         } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
             // TODO(b/184204720) report hashing error to statsd
             //  We need to set a special value(e.g. 0xFFFFFFFF) for the hashing of the database,
@@ -422,7 +499,9 @@ public final class PlatformLogger implements InternalAppSearchLogger {
                     stats.getNativeDocumentSizeBytes(),
                     stats.getNativeNumTokensIndexed(),
                     /* nativeExceededMaxNumTokens= */ false /* Deprecated and removed */,
-                    stats.getEnabledFeatures());
+                    stats.getEnabledFeatures(),
+                    stats.getMetadataTermIndexLatencyMillis(),
+                    stats.getEmbeddingIndexLatencyMillis());
         } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
             // TODO(b/184204720) report hashing error to statsd
             //  We need to set a special value(e.g. 0xFFFFFFFF) for the hashing of the database,
@@ -437,51 +516,91 @@ public final class PlatformLogger implements InternalAppSearchLogger {
     }
 
     @GuardedBy("mLock")
-    private void logStatsImplLocked(@NonNull SearchStats stats) {
+    private void logStatsImplLocked(@NonNull QueryStats queryStats) {
         mLastPushTimeMillisLocked = SystemClock.elapsedRealtime();
         ExtraStats extraStats =
-                createExtraStatsLocked(stats.getPackageName(), CallStats.CALL_TYPE_SEARCH);
-        String database = stats.getDatabase();
+                createExtraStatsLocked(queryStats.getPackageName(), CallStats.CALL_TYPE_SEARCH);
+        String database = queryStats.getDatabase();
         try {
             int hashCodeForDatabase = StatsUtil.calculateHashCodeMd5(database);
             int hashCodeForSearchSourceLogTag =
-                    StatsUtil.calculateHashCodeMd5(stats.getSearchSourceLogTag());
+                    StatsUtil.calculateHashCodeMd5(queryStats.getSearchSourceLogTag());
+            SearchStats parentStats = queryStats.getParentSearchStats();
+            SearchStats childStats = queryStats.getChildSearchStats();
             AppSearchStatsLog.write(
                     AppSearchStatsLog.APP_SEARCH_QUERY_STATS_REPORTED,
                     extraStats.mSamplingInterval,
                     extraStats.mSkippedSampleCount,
                     extraStats.mPackageUid,
                     hashCodeForDatabase,
-                    stats.getStatusCode(),
-                    stats.getTotalLatencyMillis(),
-                    stats.getRewriteSearchSpecLatencyMillis(),
-                    stats.getRewriteSearchResultLatencyMillis(),
-                    stats.getVisibilityScope(),
-                    stats.getNativeLatencyMillis(),
-                    stats.getTermCount(),
-                    stats.getQueryLength(),
-                    stats.getFilteredNamespaceCount(),
-                    stats.getFilteredSchemaTypeCount(),
-                    stats.getRequestedPageSize(),
-                    stats.getCurrentPageReturnedResultCount(),
-                    stats.isFirstPage(),
-                    stats.getParseQueryLatencyMillis(),
-                    stats.getRankingStrategy(),
-                    stats.getScoredDocumentCount(),
-                    stats.getScoringLatencyMillis(),
-                    stats.getRankingLatencyMillis(),
-                    stats.getDocumentRetrievingLatencyMillis(),
-                    stats.getResultWithSnippetsCount(),
-                    stats.getJavaLockAcquisitionLatencyMillis(),
-                    stats.getAclCheckLatencyMillis(),
-                    stats.getNativeLockAcquisitionLatencyMillis(),
-                    stats.getJavaToNativeJniLatencyMillis(),
-                    stats.getNativeToJavaJniLatencyMillis(),
-                    stats.getJoinType(),
-                    stats.getNumJoinedResultsCurrentPage(),
-                    stats.getJoinLatencyMillis(),
+                    queryStats.getStatusCode(),
+                    queryStats.getTotalLatencyMillis(),
+                    queryStats.getRewriteSearchSpecLatencyMillis(),
+                    queryStats.getRewriteSearchResultLatencyMillis(),
+                    queryStats.getVisibilityScope(),
+                    queryStats.getNativeLatencyMillis(),
+                    parentStats == null ? 0 : parentStats.getNativeTermCount(),
+                    parentStats == null ? 0 : parentStats.getNativeQueryLength(),
+                    parentStats == null ? 0 : parentStats.getNativeFilteredNamespaceCount(),
+                    parentStats == null ? 0 : parentStats.getNativeFilteredSchemaTypeCount(),
+                    queryStats.getRequestedPageSize(),
+                    queryStats.getCurrentPageReturnedResultCount(),
+                    queryStats.isFirstPage(),
+                    parentStats == null ? 0 : parentStats.getNativeParseQueryLatencyMillis(),
+                    parentStats == null ? 0 : parentStats.getNativeRankingStrategy(),
+                    parentStats == null ? 0 : parentStats.getNativeScoredDocumentCount(),
+                    parentStats == null ? 0 : parentStats.getNativeScoringLatencyMillis(),
+                    queryStats.getRankingLatencyMillis(),
+                    queryStats.getDocumentRetrievingLatencyMillis(),
+                    queryStats.getResultWithSnippetsCount(),
+                    queryStats.getJavaLockAcquisitionLatencyMillis(),
+                    queryStats.getAclCheckLatencyMillis(),
+                    queryStats.getNativeLockAcquisitionLatencyMillis(),
+                    queryStats.getJavaToNativeJniLatencyMillis(),
+                    queryStats.getNativeToJavaJniLatencyMillis(),
+                    queryStats.getJoinType(),
+                    queryStats.getNumJoinedResultsCurrentPage(),
+                    queryStats.getJoinLatencyMillis(),
                     hashCodeForSearchSourceLogTag,
-                    stats.getEnabledFeatures());
+                    queryStats.getEnabledFeatures(),
+                    parentStats == null ? false : parentStats.isNativeNumericQuery(),
+                    parentStats == null ? 0 : parentStats.getNativeNumFetchedHitsLiteIndex(),
+                    parentStats == null ? 0 : parentStats.getNativeNumFetchedHitsMainIndex(),
+                    parentStats == null ? 0 : parentStats.getNativeNumFetchedHitsIntegerIndex(),
+                    parentStats == null
+                            ? 0
+                            : parentStats.getNativeQueryProcessorLexerExtractTokenLatencyMillis(),
+                    parentStats == null
+                            ? 0
+                            : parentStats.getNativeQueryProcessorParserConsumeQueryLatencyMillis(),
+                    parentStats == null
+                            ? 0
+                            : parentStats.getNativeQueryProcessorQueryVisitorLatencyMillis(),
+                    childStats == null ? 0 : childStats.getNativeQueryLength(),
+                    childStats == null ? 0 : childStats.getNativeTermCount(),
+                    childStats == null ? 0 : childStats.getNativeFilteredNamespaceCount(),
+                    childStats == null ? 0 : childStats.getNativeFilteredSchemaTypeCount(),
+                    childStats == null ? 0 : childStats.getNativeRankingStrategy(),
+                    childStats == null ? 0 : childStats.getNativeScoredDocumentCount(),
+                    childStats == null ? 0 : childStats.getNativeParseQueryLatencyMillis(),
+                    childStats == null ? 0 : childStats.getNativeScoringLatencyMillis(),
+                    childStats == null ? false : childStats.isNativeNumericQuery(),
+                    childStats == null ? 0 : childStats.getNativeNumFetchedHitsLiteIndex(),
+                    childStats == null ? 0 : childStats.getNativeNumFetchedHitsMainIndex(),
+                    childStats == null ? 0 : childStats.getNativeNumFetchedHitsIntegerIndex(),
+                    childStats == null
+                            ? 0
+                            : childStats.getNativeQueryProcessorLexerExtractTokenLatencyMillis(),
+                    childStats == null
+                            ? 0
+                            : childStats.getNativeQueryProcessorParserConsumeQueryLatencyMillis(),
+                    childStats == null
+                            ? 0
+                            : childStats.getNativeQueryProcessorQueryVisitorLatencyMillis(),
+                    queryStats.getLiteIndexHitBufferByteSize(),
+                    queryStats.getLiteIndexHitBufferUnsortedByteSize(),
+                    queryStats.getPageTokenType(),
+                    queryStats.getNumResultStatesEvicted());
         } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
             // TODO(b/184204720) report hashing error to statsd
             //  We need to set a special value(e.g. 0xFFFFFFFF) for the hashing of the database,
@@ -511,18 +630,24 @@ public final class PlatformLogger implements InternalAppSearchLogger {
                 stats.getPrepareSchemaAndNamespacesLatencyMillis(),
                 stats.getPrepareVisibilityStoreLatencyMillis(),
                 stats.getNativeLatencyMillis(),
-                stats.getDocumentStoreRecoveryCause(),
-                stats.getIndexRestorationCause(),
-                stats.getSchemaStoreRecoveryCause(),
-                stats.getDocumentStoreRecoveryLatencyMillis(),
-                stats.getIndexRestorationLatencyMillis(),
-                stats.getSchemaStoreRecoveryLatencyMillis(),
-                stats.getDocumentStoreDataStatus(),
-                stats.getDocumentCount(),
-                stats.getSchemaTypeCount(),
+                stats.getNativeDocumentStoreRecoveryCause(),
+                stats.getNativeIndexRestorationCause(),
+                stats.getNativeSchemaStoreRecoveryCause(),
+                stats.getNativeDocumentStoreRecoveryLatencyMillis(),
+                stats.getNativeIndexRestorationLatencyMillis(),
+                stats.getNativeSchemaStoreRecoveryLatencyMillis(),
+                stats.getNativeDocumentStoreDataStatus(),
+                stats.getNativeDocumentCount(),
+                stats.getNativeSchemaTypeCount(),
                 stats.hasReset(),
                 stats.getResetStatusCode(),
-                stats.getEnabledFeatures());
+                stats.getEnabledFeatures(),
+                stats.getNativeNumPreviousInitFailures(),
+                stats.getNativeIntegerIndexRestorationCause(),
+                stats.getNativeQualifiedIdJoinIndexRestorationCause(),
+                stats.getNativeEmbeddingIndexRestorationCause(),
+                stats.getNativeInitializeIcuDataStatusCode(),
+                stats.getNativeNumFailedReindexedDocuments());
     }
 
     @GuardedBy("mLock")
@@ -545,7 +670,32 @@ public final class PlatformLogger implements InternalAppSearchLogger {
                 stats.getStorageSizeBeforeBytes(),
                 stats.getStorageSizeAfterBytes(),
                 stats.getTimeSinceLastOptimizeMillis(),
-                stats.getEnabledFeatures());
+                stats.getEnabledFeatures(),
+                stats.getIndexRestorationMode(),
+                stats.getNumOriginalNamespaces(),
+                stats.getNumDeletedNamespaces());
+    }
+
+    @GuardedBy("mLock")
+    private void logStatsImplLocked(@NonNull AppOpenEventStats appOpenEventStats) {
+        mLastPushTimeMillisLocked = SystemClock.elapsedRealtime();
+        int[] updateStatusArr = new int[appOpenEventStats.getUpdateStatusCodes().size()];
+        int updateIdx = 0;
+        for (int updateStatus : appOpenEventStats.getUpdateStatusCodes()) {
+            updateStatusArr[updateIdx] = updateStatus;
+            ++updateIdx;
+        }
+
+        AppSearchStatsLog.write(
+                AppSearchStatsLog.APP_SEARCH_APP_OPEN_EVENT_INDEXER_STATS_REPORTED,
+                updateStatusArr,
+                appOpenEventStats.getNumberOfAppOpenEventsAdded(),
+                appOpenEventStats.getTotalLatencyMillis(),
+                appOpenEventStats.getUsageStatsManagerReadLatencyMillis(),
+                appOpenEventStats.getAppSearchSetSchemaLatencyMillis(),
+                appOpenEventStats.getAppSearchPutLatencyMillis(),
+                appOpenEventStats.getUpdateStartTimestampMillis(),
+                appOpenEventStats.getLastAppUpdateTimestampMillis());
     }
 
     @GuardedBy("mLock")
@@ -774,6 +924,8 @@ public final class PlatformLogger implements InternalAppSearchLogger {
                 return mConfig.getCachedSamplingIntervalForGlobalSearchStats();
             case CallStats.CALL_TYPE_OPTIMIZE:
                 return mConfig.getCachedSamplingIntervalForOptimizeStats();
+            case CallStats.INTERNAL_CALL_TYPE_APP_OPEN_EVENT_INDEXER:
+                return mConfig.getAppOpenEventIndexerLoggingSamplingRate();
             case CallStats.CALL_TYPE_UNKNOWN:
             case CallStats.CALL_TYPE_SET_SCHEMA:
             case CallStats.CALL_TYPE_GET_DOCUMENT:
@@ -798,7 +950,7 @@ public final class PlatformLogger implements InternalAppSearchLogger {
             case CallStats.CALL_TYPE_OPEN_WRITE_BLOB:
             case CallStats.CALL_TYPE_COMMIT_BLOB:
             case CallStats.CALL_TYPE_OPEN_READ_BLOB:
-                // TODO(b/173532925) Some of them above will have dedicated sampling ratio config
+            // TODO(b/173532925) Some of them above will have dedicated sampling ratio config
             default:
                 return mConfig.getCachedSamplingIntervalDefault();
         }
diff --git a/service/java/com/android/server/appsearch/stats/StatsCollector.java b/service/java/com/android/server/appsearch/stats/StatsCollector.java
index 911f6c58..4b695fd3 100644
--- a/service/java/com/android/server/appsearch/stats/StatsCollector.java
+++ b/service/java/com/android/server/appsearch/stats/StatsCollector.java
@@ -39,6 +39,7 @@ import com.google.android.icing.proto.StorageInfoProto;
 
 import java.util.List;
 import java.util.Objects;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 
 /**
@@ -125,7 +126,10 @@ public final class StatsCollector implements StatsManager.StatsPullAtomCallback
                 data.add(
                         buildStatsEvent(
                                 userHandle.getIdentifier(), storageInfoProto, enabledFeatures));
-            } catch (AppSearchException | RuntimeException e) {
+            } catch (AppSearchException
+                    | RuntimeException
+                    | InterruptedException
+                    | ExecutionException e) {
                 Log.e(TAG, "Failed to pull the storage info for user " + userHandle.toString(), e);
                 ExceptionUtil.handleException(e);
             }
diff --git a/service/java/com/android/server/appsearch/util/AdbDumpUtil.java b/service/java/com/android/server/appsearch/util/AdbDumpUtil.java
index efe96c6f..32a66f13 100644
--- a/service/java/com/android/server/appsearch/util/AdbDumpUtil.java
+++ b/service/java/com/android/server/appsearch/util/AdbDumpUtil.java
@@ -107,12 +107,18 @@ public final class AdbDumpUtil {
         for (int i = 0; i < schemaBuilder.getTypesCount(); ++i) {
             SchemaTypeConfigProto.Builder typeBuilder = schemaBuilder.getTypes(i).toBuilder();
             typeBuilder.setSchemaType(generateFingerprintMd5(typeBuilder.getSchemaType()));
+            if (!typeBuilder.getDatabase().isEmpty()) {
+                typeBuilder.setDatabase(generateFingerprintMd5(typeBuilder.getDatabase()));
+            }
             for (int j = 0; j < typeBuilder.getPropertiesCount(); ++j) {
                 PropertyConfigProto property = typeBuilder.getProperties(j);
                 if (property.getDataType() == PropertyConfigProto.DataType.Code.DOCUMENT) {
                     PropertyConfigProto.Builder propertyBuilder = property.toBuilder();
                     propertyBuilder.setSchemaType(
                             generateFingerprintMd5(propertyBuilder.getSchemaType()));
+                    if (!typeBuilder.getDatabase().isEmpty()) {
+                        typeBuilder.setDatabase(generateFingerprintMd5(typeBuilder.getDatabase()));
+                    }
                     typeBuilder.setProperties(j, propertyBuilder);
                 }
             }
diff --git a/service/java/com/android/server/appsearch/util/ExecutorManager.java b/service/java/com/android/server/appsearch/util/ExecutorManager.java
index 1fd971a1..9499339a 100644
--- a/service/java/com/android/server/appsearch/util/ExecutorManager.java
+++ b/service/java/com/android/server/appsearch/util/ExecutorManager.java
@@ -30,6 +30,7 @@ import android.app.appsearch.aidl.AppSearchResultParcel;
 import android.app.appsearch.aidl.IAppSearchBatchResultCallback;
 import android.app.appsearch.aidl.IAppSearchResultCallback;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
+import android.os.SystemClock;
 import android.os.UserHandle;
 import android.util.ArrayMap;
 
@@ -39,11 +40,16 @@ import com.android.server.appsearch.FrameworkServiceAppSearchConfig;
 import com.android.server.appsearch.ServiceAppSearchConfig;
 import com.android.server.appsearch.external.localstorage.stats.CallStats;
 
+import java.time.Duration;
+import java.time.Instant;
 import java.util.Map;
 import java.util.Objects;
 import java.util.concurrent.Executor;
 import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
 
 /**
@@ -77,6 +83,15 @@ public class ExecutorManager {
                         /* priority= */ 0); // priority is unused.
     }
 
+    /**
+     * Creates a new single-threaded {@link ScheduledExecutorService} for scheduling and running
+     * background tasks in AppSearch.
+     */
+    @NonNull
+    public static ScheduledExecutorService createDefaultScheduledExecutorService() {
+        return Executors.newSingleThreadScheduledExecutor();
+    }
+
     private final ServiceAppSearchConfig mAppSearchConfig;
 
     /**
@@ -86,6 +101,14 @@ public class ExecutorManager {
     @GuardedBy("mPerUserExecutorsLocked")
     private final Map<UserHandle, ExecutorService> mPerUserExecutorsLocked = new ArrayMap<>();
 
+    /**
+     * A map of per-user scheduled executors for scheduled work. These can be started or shut down
+     * via this class's public API.
+     */
+    @GuardedBy("mPerUserScheduledExecutorsLocked")
+    private final Map<UserHandle, ScheduledExecutorService> mPerUserScheduledExecutorsLocked =
+            new ArrayMap<>();
+
     public ExecutorManager(@NonNull ServiceAppSearchConfig appSearchConfig) {
         mAppSearchConfig = Objects.requireNonNull(appSearchConfig);
     }
@@ -112,6 +135,21 @@ public class ExecutorManager {
         }
     }
 
+    /** Gets the scheduled executor service for the given user, creating it if it does not exist. */
+    @NonNull
+    public ScheduledExecutorService getOrCreateUserScheduledExecutor(
+            @NonNull UserHandle userHandle) {
+        Objects.requireNonNull(userHandle);
+        synchronized (mPerUserScheduledExecutorsLocked) {
+            ScheduledExecutorService executor = mPerUserScheduledExecutorsLocked.get(userHandle);
+            if (executor == null) {
+                executor = createDefaultScheduledExecutorService();
+                mPerUserScheduledExecutorsLocked.put(userHandle, executor);
+            }
+            return executor;
+        }
+    }
+
     /**
      * Gracefully shuts down the executor for the given user if there is one, waiting up to 30
      * seconds for jobs to finish.
@@ -125,12 +163,32 @@ public class ExecutorManager {
         }
         if (executor != null) {
             executor.shutdown();
-            // Wait a little bit to finish outstanding requests. It's important not to call
-            // shutdownNow because nothing would pass a final result to the caller, leading to
-            // hangs. If we are interrupted or the timeout elapses, just move on to closing the
-            // user instance, meaning pending tasks may crash when AppSearchImpl closes under
-            // them.
-            executor.awaitTermination(30, TimeUnit.SECONDS);
+        }
+
+        ScheduledExecutorService scheduleExecutor;
+        synchronized (mPerUserScheduledExecutorsLocked) {
+            scheduleExecutor = mPerUserScheduledExecutorsLocked.remove(userHandle);
+        }
+        if (scheduleExecutor != null) {
+            scheduleExecutor.shutdown();
+        }
+
+        // Wait a little bit to finish outstanding requests. It's important not to call
+        // shutdownNow because nothing would pass a final result to the caller, leading to
+        // hangs. If we are interrupted or the timeout elapses, just move on to closing the
+        // user instance, meaning pending tasks may crash when AppSearchImpl closes under
+        // them.
+        long awaitStartTimeMs = SystemClock.elapsedRealtime();
+        long awaitDurationMs = 30 * 1000;
+        if (executor != null) {
+            executor.awaitTermination(awaitDurationMs, TimeUnit.MILLISECONDS);
+        }
+        long awaitTimeElapsedMs = SystemClock.elapsedRealtime() - awaitStartTimeMs;
+        if (scheduleExecutor != null) {
+            awaitDurationMs -= awaitTimeElapsedMs;
+            if (awaitDurationMs > 0) {
+                scheduleExecutor.awaitTermination(awaitDurationMs, TimeUnit.MILLISECONDS);
+            }
         }
     }
 
@@ -281,6 +339,29 @@ public class ExecutorManager {
         }
     }
 
+    /**
+     * Schedules a task to be executed on the ScheduledExecutorService for the given user.
+     *
+     * @param targetUser The user for whom the task should be scheduled.
+     * @param lambda     The task to be executed.
+     * @param delay      The time from now to delay execution.
+     * @param unit       The time unit of the delay parameter.
+     * @return the ScheduledFuture for the task.
+     */
+    public ScheduledFuture<?> scheduleLambdaForUserNoCallbackAsync(
+            @NonNull UserHandle targetUser,
+            @NonNull Runnable lambda,
+            long delay,
+            @NonNull TimeUnit unit) {
+        Objects.requireNonNull(targetUser);
+        Objects.requireNonNull(lambda);
+        Objects.requireNonNull(unit);
+
+        synchronized (mPerUserScheduledExecutorsLocked) {
+            return getOrCreateUserScheduledExecutor(targetUser).schedule(lambda, delay, unit);
+        }
+    }
+
     @GuardedBy("mPerUserExecutorsLocked")
     @NonNull
     private Executor getOrCreateUserExecutorLocked(@NonNull UserHandle userHandle) {
diff --git a/service/java/com/android/server/appsearch/util/MemInfoReader.java b/service/java/com/android/server/appsearch/util/MemInfoReader.java
new file mode 100644
index 00000000..412037df
--- /dev/null
+++ b/service/java/com/android/server/appsearch/util/MemInfoReader.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.util;
+
+import java.io.BufferedReader;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
+import java.io.IOException;
+
+/**
+ * Utility class to read memory info from /proc/meminfo.
+ *
+ * @hide
+ */
+public final class MemInfoReader {
+    private static final String MEM_INFO_FILE_PATH = "/proc/meminfo";
+
+    public MemInfoReader() {}
+
+    /** Gets the amount of free RAM in KB. Returns {@code -1} if failing to get the number. */
+    public long getFreeSizeKb() throws FileNotFoundException, IOException, NumberFormatException {
+        BufferedReader memInfo = new BufferedReader(new FileReader(MEM_INFO_FILE_PATH));
+        String line;
+        while ((line = memInfo.readLine()) != null) {
+            int colon = line.indexOf(':');
+            if (colon == -1) {
+                continue;
+            }
+            String keyword = line.substring(0, colon);
+            if (!keyword.equals("MemAvailable")) {
+                continue;
+            }
+
+            int startPos = -1;
+            int len = 0;
+            for (int i = colon + 1; i < line.length(); ++i) {
+                if (Character.isDigit(line.charAt(i))) {
+                    len += 1;
+                    if (startPos == -1) {
+                        startPos = i;
+                    }
+                } else if (startPos != -1) {
+                    break;
+                }
+            }
+            // Now we found the digit at range [startPos, startPos + len).
+            return Long.parseLong(line.substring(startPos, startPos + len));
+        }
+        throw new IOException("Cannot find MemAvailable in /proc/meminfo");
+    }
+}
diff --git a/service/java/com/android/server/appsearch/visibilitystore/VisibilityCheckerImpl.java b/service/java/com/android/server/appsearch/visibilitystore/VisibilityCheckerImpl.java
index 51783f28..cde26efb 100644
--- a/service/java/com/android/server/appsearch/visibilitystore/VisibilityCheckerImpl.java
+++ b/service/java/com/android/server/appsearch/visibilitystore/VisibilityCheckerImpl.java
@@ -39,6 +39,7 @@ import android.content.pm.PackageManager;
 import android.os.UserHandle;
 import android.permission.PermissionManager;
 
+import com.android.appsearch.flags.Flags;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.appsearch.external.localstorage.visibilitystore.CallerAccess;
 import com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityChecker;
@@ -89,14 +90,30 @@ public class VisibilityCheckerImpl implements VisibilityChecker {
         InternalVisibilityConfig internalVisibilityConfig =
                 visibilityStore.getVisibility(prefixedSchema);
 
-        // If caller requires enterprise access, the given schema is only visible if caller has all
-        // required permissions.
+        // If caller requires enterprise access, the given schema is only visible if there exists a
+        // required permissions set containing ENTERPRISE_ACCESS that the caller passes; the passing
+        // set may be part of a SchemaVisibilityConfig
         if (frameworkCallerAccess.isForEnterprise()) {
-            return internalVisibilityConfig != null
-                    && isSchemaVisibleToPermission(
-                            internalVisibilityConfig.getVisibilityConfig(),
-                            frameworkCallerAccess.getCallingAttributionSource(),
-                            /* checkEnterpriseAccess= */ true);
+            if (internalVisibilityConfig == null) {
+                return false;
+            }
+            if (isSchemaVisibleToPermission(
+                    internalVisibilityConfig.getVisibilityConfig(),
+                    frameworkCallerAccess.getCallingAttributionSource(),
+                    /* checkEnterpriseAccess= */ true)) {
+                return true;
+            }
+            if (Flags.enableEnterpriseVisibleToConfig()) {
+                Set<SchemaVisibilityConfig> visibleToConfigs =
+                        internalVisibilityConfig.getVisibleToConfigs();
+                for (SchemaVisibilityConfig visibleToConfig : visibleToConfigs) {
+                    if (checkMatchAllVisibilityConfig(frameworkCallerAccess,
+                            visibleToConfig, /* checkEnterpriseAccess= */ true)) {
+                        return true;
+                    }
+                }
+            }
+            return false;
         }
 
         if (internalVisibilityConfig == null) {
@@ -124,7 +141,8 @@ public class VisibilityCheckerImpl implements VisibilityChecker {
         Set<SchemaVisibilityConfig> visibleToConfigs =
                 internalVisibilityConfig.getVisibleToConfigs();
         for (SchemaVisibilityConfig visibleToConfig : visibleToConfigs) {
-            if (checkMatchAllVisibilityConfig(frameworkCallerAccess, visibleToConfig)) {
+            if (checkMatchAllVisibilityConfig(frameworkCallerAccess,
+                    visibleToConfig, /* checkEnterpriseAccess= */ false)) {
                 return true;
             }
         }
@@ -156,11 +174,13 @@ public class VisibilityCheckerImpl implements VisibilityChecker {
     /** Check whether the caller math ALL of the visibility requirements. */
     private boolean checkMatchAllVisibilityConfig(
             @NonNull FrameworkCallerAccess frameworkCallerAccess,
-            @NonNull SchemaVisibilityConfig visibilityConfig) {
+            @NonNull SchemaVisibilityConfig visibilityConfig,
+            boolean checkEnterpriseAccess) {
 
         // We will skip following checks if user never specific them. But the caller should has
         // passed at least one check to get the access.
         boolean hasPassedCheck = false;
+        boolean hasPassedRequiredPermissionsCheck = false;
 
         // Check whether the caller is in the allow list and has access to the given schema.
         if (!visibilityConfig.getAllowedPackages().isEmpty()) {
@@ -173,15 +193,15 @@ public class VisibilityCheckerImpl implements VisibilityChecker {
         }
 
         // Check whether caller has all required permissions for the given schema.
-        // We could directly return the boolean results since it is the last checking.
         if (!visibilityConfig.getRequiredPermissions().isEmpty()) {
             if (!isSchemaVisibleToPermission(
                     visibilityConfig,
                     frameworkCallerAccess.getCallingAttributionSource(),
-                    /* checkEnterpriseAccess= */ false)) {
+                    checkEnterpriseAccess)) {
                 return false; // Return early for the 'ALL' case.
             }
             hasPassedCheck = true;
+            hasPassedRequiredPermissionsCheck = true;
         }
 
         // Check whether the calling package has visibility to the package providing the schema.
@@ -192,7 +212,8 @@ public class VisibilityCheckerImpl implements VisibilityChecker {
             hasPassedCheck = true;
         }
 
-        return hasPassedCheck;
+        // If enterprise call, must also pass a required permissions check
+        return hasPassedCheck && (!checkEnterpriseAccess || hasPassedRequiredPermissionsCheck);
     }
 
     private boolean isSchemaPubliclyVisibleFromPackage(
diff --git a/synced_jetpack_sha.txt b/synced_jetpack_sha.txt
index b7c22601..367976b7 100644
--- a/synced_jetpack_sha.txt
+++ b/synced_jetpack_sha.txt
@@ -1 +1 @@
-b2a9756a09b234e2a59d9dd603a612c7ab35c562
+b060b2517e76100ed330df2e95a3c245f1b21f94
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionDiffCalculatorTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionDiffCalculatorTest.java
new file mode 100644
index 00000000..0b9b66c1
--- /dev/null
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionDiffCalculatorTest.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.appsindexer;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionDocument;
+import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.junit.MockitoJUnitRunner;
+
+import java.util.Map;
+
+@RunWith(MockitoJUnitRunner.class)
+public class AppFunctionDiffCalculatorTest {
+
+    public static final String TEST_PACKAGE_NAME = "com.example";
+
+    private static AppFunctionDocument createFunctionDoc(String id, String packageName) {
+        return new AppFunctionDocument.Builder(
+                        packageName,
+                        id,
+                        /* indexerPackageName= */ "android",
+                        AppFunctionStaticMetadata.SCHEMA_TYPE)
+                .build();
+    }
+
+    @Test
+    public void testCalculate_noChanges_returnsEmptyDiff() {
+        Map<String, Map<String, AppFunctionDocument>> stored =
+                Map.of(
+                        TEST_PACKAGE_NAME,
+                        Map.of("func1", createFunctionDoc("func1", TEST_PACKAGE_NAME)));
+        Map<String, Map<String, ? extends AppFunctionDocument>> current =
+                Map.of(
+                        TEST_PACKAGE_NAME,
+                        Map.of("func1", createFunctionDoc("func1", TEST_PACKAGE_NAME)));
+
+        AppFunctionDiffCalculator.AppFunctionDiff diff =
+                AppFunctionDiffCalculator.calculate(stored, current);
+
+        assertThat(diff.modifySchema).isFalse();
+        assertThat(diff.addedAppFunctions).isEmpty();
+        assertThat(diff.updatedAppFunctions).isEmpty();
+        assertThat(diff.functionIdsToRemove).isEmpty();
+        assertThat(diff.allDeletedFunctionIds).isEmpty();
+    }
+
+    @Test
+    public void calculate_allFunctionsRemoved_detectsAllDeletedFunctionsAndSchemaModification() {
+        Map<String, Map<String, AppFunctionDocument>> stored =
+                Map.of(
+                        TEST_PACKAGE_NAME,
+                        Map.of("func1", createFunctionDoc("func1", TEST_PACKAGE_NAME)));
+
+        AppFunctionDiffCalculator.AppFunctionDiff diff =
+                AppFunctionDiffCalculator.calculate(stored, Map.of(TEST_PACKAGE_NAME, Map.of()));
+
+        assertThat(diff.modifySchema).isTrue();
+        assertThat(diff.allDeletedFunctionIds).containsExactly("func1");
+    }
+
+    @Test
+    public void calculate_functionAddedToExistingPackage_detectsNewFunction() {
+        AppFunctionDocument existing = createFunctionDoc("func1", TEST_PACKAGE_NAME);
+        AppFunctionDocument added = createFunctionDoc("func2", TEST_PACKAGE_NAME);
+        Map<String, Map<String, AppFunctionDocument>> stored =
+                Map.of(TEST_PACKAGE_NAME, Map.of("func1", existing));
+        Map<String, Map<String, ? extends AppFunctionDocument>> current =
+                Map.of(
+                        TEST_PACKAGE_NAME,
+                        Map.of(
+                                "func1", existing,
+                                "func2", added));
+
+        AppFunctionDiffCalculator.AppFunctionDiff diff =
+                AppFunctionDiffCalculator.calculate(stored, current);
+
+        assertThat(diff.modifySchema).isFalse();
+        assertThat(diff.addedAppFunctions.keySet()).contains("func2");
+    }
+
+    @Test
+    public void calculate_functionRemoved_detectsRemoval() {
+        AppFunctionDocument doc1 = createFunctionDoc("func1", TEST_PACKAGE_NAME);
+        AppFunctionDocument docToRemove = createFunctionDoc("funcToRemove", TEST_PACKAGE_NAME);
+        Map<String, Map<String, AppFunctionDocument>> stored =
+                Map.of("com.example", Map.of("func1", doc1, "funcToRemove", docToRemove));
+        Map<String, Map<String, ? extends AppFunctionDocument>> current =
+                Map.of("com.example", Map.of("func1", doc1));
+
+        AppFunctionDiffCalculator.AppFunctionDiff diff =
+                AppFunctionDiffCalculator.calculate(stored, current);
+
+        assertThat(diff.functionIdsToRemove).containsExactly("funcToRemove");
+        assertThat(diff.allDeletedFunctionIds).containsExactly("funcToRemove");
+    }
+
+    @Test
+    public void calculate_functionUpdated_detectsChangedContent() {
+        AppFunctionDocument oldDoc =
+                new AppFunctionStaticMetadata.Builder(TEST_PACKAGE_NAME, "func1", "android")
+                        .setEnabledByDefault(false)
+                        .build();
+        AppFunctionDocument newDoc =
+                new AppFunctionStaticMetadata.Builder(TEST_PACKAGE_NAME, "func1", "android")
+                        .setEnabledByDefault(true)
+                        .build();
+        Map<String, Map<String, AppFunctionDocument>> stored =
+                Map.of("com.example", Map.of("func1", oldDoc));
+        Map<String, Map<String, ? extends AppFunctionDocument>> current =
+                Map.of("com.example", Map.of("func1", newDoc));
+
+        AppFunctionDiffCalculator.AppFunctionDiff diff =
+                AppFunctionDiffCalculator.calculate(stored, current);
+
+        assertThat(diff.updatedAppFunctions.keySet()).contains("func1");
+        assertThat(
+                        diff.updatedAppFunctions
+                                .get("func1")
+                                .getPropertyBoolean(
+                                        AppFunctionStaticMetadata.PROPERTY_ENABLED_BY_DEFAULT))
+                .isTrue();
+    }
+}
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionDocumentParserImplTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionDocumentParserImplTest.java
index 75739180..dc32e1cc 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionDocumentParserImplTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionDocumentParserImplTest.java
@@ -25,20 +25,24 @@ import android.content.pm.PackageManager;
 import android.content.res.AssetManager;
 import android.content.res.Resources;
 
+import androidx.annotation.NonNull;
+
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionDocument;
-import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.junit.MockitoJUnitRunner;
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+import org.xmlpull.v1.XmlPullParserFactory;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.InputStreamReader;
 import java.util.Arrays;
-import java.util.List;
 import java.util.Map;
 
 @RunWith(MockitoJUnitRunner.class)
@@ -101,184 +105,24 @@ public class AppFunctionDocumentParserImplTest {
         when(mAssetManager.open(TEST_XML_ASSET_FILE_PATH)).thenReturn(inputStream);
     }
 
-    @Test
-    public void parse_singleAppFunctionWithAllProperties() throws Exception {
-        setXmlInput(
-                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
-                        + "<version>1</version>\n"
-                        + "<appfunctions>\n"
-                        + "  <appfunction>\n"
-                        + "    <function_id>com.example.utils#print</function_id>\n"
-                        + "    <schema_name>insert_note</schema_name>\n"
-                        + "    <schema_version>1</schema_version>\n"
-                        + "    <schema_category>utils</schema_category>\n"
-                        + "    <enabled_by_default>false</enabled_by_default>\n"
-                        + "    <restrict_callers_with_execute_app_functions>true\n"
-                        + "</restrict_callers_with_execute_app_functions>\n"
-                        + "    <display_name_string_res>10</display_name_string_res>\n"
-                        + "  </appfunction>\n"
-                        + "</appfunctions>");
-
-        List<AppFunctionStaticMetadata> appFunctions =
-                mParser.parse(mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH);
-
-        assertThat(appFunctions).hasSize(1);
-
-        AppFunctionStaticMetadata appFunction1 = appFunctions.get(0);
-        assertThat(appFunction1.getFunctionId()).isEqualTo("com.example.utils#print");
-        assertThat(appFunction1.getPackageName()).isEqualTo(TEST_PACKAGE_NAME);
-        assertThat(appFunction1.getSchemaName()).isEqualTo("insert_note");
-        assertThat(appFunction1.getSchemaVersion()).isEqualTo(1);
-        assertThat(appFunction1.getSchemaCategory()).isEqualTo("utils");
-        assertThat(appFunction1.getEnabledByDefault()).isEqualTo(false);
-        assertThat(appFunction1.getRestrictCallersWithExecuteAppFunctions()).isEqualTo(true);
-        assertThat(appFunction1.getDisplayNameStringRes()).isEqualTo(10);
-    }
-
-    @Test
-    public void parse_singleAppFunctionWithDefaults() throws Exception {
-        setXmlInput(
-                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
-                        + "<version>1</version>\n"
-                        + "<appfunctions>\n"
-                        + "  <appfunction>\n"
-                        + "    <function_id>com.example.utils#print</function_id>\n"
-                        + "  </appfunction>\n"
-                        + "</appfunctions>");
-
-        List<AppFunctionStaticMetadata> appFunctions =
-                mParser.parse(mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH);
-
-        assertThat(appFunctions).hasSize(1);
-
-        AppFunctionStaticMetadata appFunction1 = appFunctions.get(0);
-        assertThat(appFunction1.getFunctionId()).isEqualTo("com.example.utils#print");
-        assertThat(appFunction1.getPackageName()).isEqualTo(TEST_PACKAGE_NAME);
-        assertThat(appFunction1.getSchemaName()).isNull();
-        assertThat(appFunction1.getSchemaVersion()).isEqualTo(0);
-        assertThat(appFunction1.getSchemaCategory()).isNull();
-        assertThat(appFunction1.getEnabledByDefault()).isEqualTo(true);
-        assertThat(appFunction1.getRestrictCallersWithExecuteAppFunctions()).isEqualTo(false);
-        assertThat(appFunction1.getDisplayNameStringRes()).isEqualTo(0);
-    }
-
-    @Test
-    public void parse_ignoresUnknownProperties() throws Exception {
-        setXmlInput(
-                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
-                        + "<version>1</version>\n"
-                        + "<appfunctions>\n"
-                        + "  <appfunction>\n"
-                        + "    <function_id>com.example.utils#print</function_id>\n"
-                        + "    <parameters><name>test</name></parameters>\n"
-                        + "    <unknown_property>test</unknown_property>\n"
-                        + "  </appfunction>\n"
-                        + "</appfunctions>");
-
-        List<AppFunctionStaticMetadata> appFunctions =
-                mParser.parse(mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH);
-
-        assertThat(appFunctions).hasSize(1);
-        // Only contain known properties from XML or properties populated by default.
-        assertThat(appFunctions.get(0).getPropertyNames())
-                .containsExactly(
-                        "functionId",
-                        "packageName",
-                        "enabledByDefault",
-                        "mobileApplicationQualifiedId");
-    }
-
-    @Test
-    public void parse_missingFunctionId() throws Exception {
-        setXmlInput(
-                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
-                        + "<version>1</version>\n"
-                        + "<appfunctions>\n"
-                        + "  <appfunction>\n"
-                        + "    <schema_name>insert_note</schema_name>\n"
-                        + "    <schema_version>1</schema_version>\n"
-                        + "    <schema_category>utils</schema_category>\n"
-                        + "  </appfunction>\n"
-                        + "</appfunctions>");
-
-        List<AppFunctionStaticMetadata> appFunctions =
-                mParser.parse(mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH);
-
-        assertThat(appFunctions).isEmpty();
-    }
-
-    @Test
-    public void parse_malformedXml() throws Exception {
-        // Missing </functionId>
-        setXmlInput(
-                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
-                        + "<version>1</version>\n"
-                        + "<appfunctions>\n"
-                        + "  <appfunction>\n"
-                        + "    <function_id>com.example.utils#print"
-                        + "    <schema_name>insert_note</schema_name>\n"
-                        + "    <schema_version>1</schema_version>\n"
-                        + "    <schema_category>utils</schema_category>\n"
-                        + "  </appfunction>\n"
-                        + "</appfunctions>");
-
-        List<AppFunctionStaticMetadata> appFunctions =
-                mParser.parse(mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH);
-
-        assertThat(appFunctions).isEmpty();
-    }
-
-    @Test
-    public void parse_exceedMaxNumAppFunctions() throws Exception {
-        mParser =
-                new AppFunctionDocumentParserImpl(
-                        TEST_INDEXER_PACKAGE_NAME,
-                        new TestAppsIndexerConfig() {
-                            @Override
-                            public int getMaxAppFunctionsPerPackage() {
-                                return 2;
-                            }
-                        });
-        setXmlInput(
-                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
-                        + "<version>1</version>\n"
-                        + "<appfunctions>\n"
-                        + "  <appfunction>\n"
-                        + "    <function_id>com.example#send_message1</function_id>\n"
-                        + "  </appfunction>\n"
-                        + "  <appfunction>\n"
-                        + "    <function_id>com.example#send_message2</function_id>\n"
-                        + "  </appfunction>\n"
-                        + "  <appfunction>\n"
-                        + "    <function_id>com.example#send_message3</function_id>\n"
-                        + "  </appfunction>\n"
-                        + "</appfunctions>");
-
-        List<AppFunctionStaticMetadata> appFunctions =
-                mParser.parse(mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH);
-
-        assertThat(appFunctions).hasSize(2);
-        assertThat(appFunctions.get(0).getFunctionId()).isEqualTo("com.example#send_message1");
-        assertThat(appFunctions.get(1).getFunctionId()).isEqualTo("com.example#send_message2");
-    }
-
     @Test
     public void parseIntoMapForGivenSchemas_singleAppFunctionWithPrimitiveProperties()
             throws Exception {
-        setXmlInput(
-                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
-                        + "<appfunctions>\n"
-                        + "  <AppFunctionStaticMetadata>\n"
-                        + "    <id>com.example.utils#print</id>\n"
-                        + "    <functionId>com.example.utils#print</functionId>\n"
-                        + "    <enabledByDefault>true</enabledByDefault>\n"
-                        + "    <schemaVersion>10</schemaVersion>\n"
-                        + "  </AppFunctionStaticMetadata>\n"
-                        + "</appfunctions>");
+        XmlPullParser xmlPullParser =
+                getXmlPullParser(
+                        "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                                + "<appfunctions>\n"
+                                + "  <AppFunctionStaticMetadata>\n"
+                                + "    <id>com.example.utils#print</id>\n"
+                                + "    <functionId>com.example.utils#print</functionId>\n"
+                                + "    <enabledByDefault>true</enabledByDefault>\n"
+                                + "    <schemaVersion>10</schemaVersion>\n"
+                                + "  </AppFunctionStaticMetadata>\n"
+                                + "</appfunctions>");
 
         Map<String, AppFunctionDocument> appFunctions =
                 mParser.parseIntoMapForGivenSchemas(
-                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
+                        mPackageManager, TEST_PACKAGE_NAME, xmlPullParser, TEST_SCHEMAS);
 
         assertThat(appFunctions).hasSize(1);
         assertThat(appFunctions).containsKey("com.example.app/com.example.utils#print");
@@ -297,28 +141,36 @@ public class AppFunctionDocumentParserImplTest {
                 .isEqualTo("com.android.test.indexer$apps-db/apps#com.example.app");
     }
 
+    @NonNull
+    private static XmlPullParser getXmlPullParser(String xml) throws XmlPullParserException {
+        XmlPullParser xmlPullParser = XmlPullParserFactory.newInstance().newPullParser();
+        xmlPullParser.setInput(new InputStreamReader(new ByteArrayInputStream(xml.getBytes())));
+        return xmlPullParser;
+    }
+
     @Test
     public void parseIntoMapForGivenSchemas_multipleAppFunctions() throws Exception {
-        setXmlInput(
-                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
-                        + "<appfunctions>\n"
-                        + "  <AppFunctionStaticMetadata>\n"
-                        + "    <id>com.example.utils#print</id>\n"
-                        + "    <functionId>com.example.utils#print1</functionId>\n"
-                        + "    <enabledByDefault>true</enabledByDefault>\n"
-                        + "    <schemaVersion>10</schemaVersion>\n"
-                        + "  </AppFunctionStaticMetadata>\n"
-                        + "  <AppFunctionStaticMetadata>\n"
-                        + "    <id>com.example.utils#print2</id>\n"
-                        + "    <functionId>com.example.utils#print2</functionId>\n"
-                        + "    <enabledByDefault>true</enabledByDefault>\n"
-                        + "    <schemaVersion>10</schemaVersion>\n"
-                        + "  </AppFunctionStaticMetadata>\n"
-                        + "</appfunctions>");
+        XmlPullParser xmlPullParser =
+                getXmlPullParser(
+                        "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                                + "<appfunctions>\n"
+                                + "  <AppFunctionStaticMetadata>\n"
+                                + "    <id>com.example.utils#print</id>\n"
+                                + "    <functionId>com.example.utils#print1</functionId>\n"
+                                + "    <enabledByDefault>true</enabledByDefault>\n"
+                                + "    <schemaVersion>10</schemaVersion>\n"
+                                + "  </AppFunctionStaticMetadata>\n"
+                                + "  <AppFunctionStaticMetadata>\n"
+                                + "    <id>com.example.utils#print2</id>\n"
+                                + "    <functionId>com.example.utils#print2</functionId>\n"
+                                + "    <enabledByDefault>true</enabledByDefault>\n"
+                                + "    <schemaVersion>10</schemaVersion>\n"
+                                + "  </AppFunctionStaticMetadata>\n"
+                                + "</appfunctions>");
 
         Map<String, AppFunctionDocument> appFunctions =
                 mParser.parseIntoMapForGivenSchemas(
-                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
+                        mPackageManager, TEST_PACKAGE_NAME, xmlPullParser, TEST_SCHEMAS);
 
         assertThat(appFunctions).hasSize(2);
         assertThat(appFunctions).containsKey("com.example.app/com.example.utils#print");
@@ -327,23 +179,24 @@ public class AppFunctionDocumentParserImplTest {
 
     @Test
     public void parseIntoMapForGivenSchemas_malformedXml_returnsEmptyMap() throws Exception {
-        setXmlInput(
-                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
-                        + "<appfunctions>\n"
-                        + "  <AppFunctionStaticMetadata>\n"
-                        + "    <functionId>com.example.utils#print</functionId>\n"
-                        + "    <enabledByDefault>true</enabledByDefault>\n"
-                        + "    <schemaVersion>10</schemaVersion>\n"
-                        + "  </AppFunctionStaticMetadata>\n"
-                        + "  <AppFunctionStaticMetadata>\n"
-                        + "    <functionId>com.example.utils#print2</functionId>\n"
-                        + "    <enabledByDefault>true</enabledByDefault>\n"
-                        + "    <schemaVersion>10</schemaVersion>\n"
-                        + "</appfunctions>");
+        XmlPullParser xmlPullParser =
+                getXmlPullParser(
+                        "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                                + "<appfunctions>\n"
+                                + "  <AppFunctionStaticMetadata>\n"
+                                + "    <functionId>com.example.utils#print</functionId>\n"
+                                + "    <enabledByDefault>true</enabledByDefault>\n"
+                                + "    <schemaVersion>10</schemaVersion>\n"
+                                + "  </AppFunctionStaticMetadata>\n"
+                                + "  <AppFunctionStaticMetadata>\n"
+                                + "    <functionId>com.example.utils#print2</functionId>\n"
+                                + "    <enabledByDefault>true</enabledByDefault>\n"
+                                + "    <schemaVersion>10</schemaVersion>\n"
+                                + "</appfunctions>");
 
         Map<String, AppFunctionDocument> appFunctions =
                 mParser.parseIntoMapForGivenSchemas(
-                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
+                        mPackageManager, TEST_PACKAGE_NAME, xmlPullParser, TEST_SCHEMAS);
 
         assertThat(appFunctions).isEmpty();
     }
@@ -360,32 +213,33 @@ public class AppFunctionDocumentParserImplTest {
                                 return 2;
                             }
                         });
-        setXmlInput(
-                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
-                        + "<appfunctions>\n"
-                        + "  <AppFunctionStaticMetadata>\n"
-                        + "    <id>com.example.utils#print1</id>\n"
-                        + "    <functionId>com.example.utils#print1</functionId>\n"
-                        + "    <enabledByDefault>true</enabledByDefault>\n"
-                        + "    <schemaVersion>10</schemaVersion>\n"
-                        + "  </AppFunctionStaticMetadata>\n"
-                        + "  <AppFunctionStaticMetadata>\n"
-                        + "    <id>com.example.utils#print2</id>\n"
-                        + "    <functionId>com.example.utils#print2</functionId>\n"
-                        + "    <enabledByDefault>true</enabledByDefault>\n"
-                        + "    <schemaVersion>10</schemaVersion>\n"
-                        + "  </AppFunctionStaticMetadata>\n"
-                        + "  <AppFunctionStaticMetadata>\n"
-                        + "    <id>com.example.utils#print3</id>\n"
-                        + "    <functionId>com.example.utils#print3</functionId>\n"
-                        + "    <enabledByDefault>true</enabledByDefault>\n"
-                        + "    <schemaVersion>10</schemaVersion>\n"
-                        + "  </AppFunctionStaticMetadata>\n"
-                        + "</appfunctions>");
+        XmlPullParser xmlPullParser =
+                getXmlPullParser(
+                        "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                                + "<appfunctions>\n"
+                                + "  <AppFunctionStaticMetadata>\n"
+                                + "    <id>com.example.utils#print1</id>\n"
+                                + "    <functionId>com.example.utils#print1</functionId>\n"
+                                + "    <enabledByDefault>true</enabledByDefault>\n"
+                                + "    <schemaVersion>10</schemaVersion>\n"
+                                + "  </AppFunctionStaticMetadata>\n"
+                                + "  <AppFunctionStaticMetadata>\n"
+                                + "    <id>com.example.utils#print2</id>\n"
+                                + "    <functionId>com.example.utils#print2</functionId>\n"
+                                + "    <enabledByDefault>true</enabledByDefault>\n"
+                                + "    <schemaVersion>10</schemaVersion>\n"
+                                + "  </AppFunctionStaticMetadata>\n"
+                                + "  <AppFunctionStaticMetadata>\n"
+                                + "    <id>com.example.utils#print3</id>\n"
+                                + "    <functionId>com.example.utils#print3</functionId>\n"
+                                + "    <enabledByDefault>true</enabledByDefault>\n"
+                                + "    <schemaVersion>10</schemaVersion>\n"
+                                + "  </AppFunctionStaticMetadata>\n"
+                                + "</appfunctions>");
 
         Map<String, AppFunctionDocument> appFunctions =
                 mParser.parseIntoMapForGivenSchemas(
-                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
+                        mPackageManager, TEST_PACKAGE_NAME, xmlPullParser, TEST_SCHEMAS);
 
         assertThat(appFunctions).hasSize(2);
         assertThat(appFunctions).containsKey("com.example.app/com.example.utils#print1");
@@ -395,23 +249,24 @@ public class AppFunctionDocumentParserImplTest {
     @Test
     public void parseIntoMapForGivenSchemas_singleAppFunctionWithDocumentProperties()
             throws Exception {
-        setXmlInput(
-                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
-                        + "<appfunctions>\n"
-                        + "  <AppFunctionStaticMetadata>\n"
-                        + "    <id>com.example.utils#print</id>\n"
-                        + "    <functionId>com.example.utils#print</functionId>\n"
-                        + "    <appFunctionParameterMetadata>\n"
-                        + "      <id>com.example.utils#print/appFunctionParameterMetadata-0"
-                        + "</id>\n"
-                        + "      <parameterName>test</parameterName>\n"
-                        + "    </appFunctionParameterMetadata>\n"
-                        + "  </AppFunctionStaticMetadata>\n"
-                        + "</appfunctions>");
+        XmlPullParser xmlPullParser =
+                getXmlPullParser(
+                        "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                                + "<appfunctions>\n"
+                                + "  <AppFunctionStaticMetadata>\n"
+                                + "    <id>com.example.utils#print</id>\n"
+                                + "    <functionId>com.example.utils#print</functionId>\n"
+                                + "    <appFunctionParameterMetadata>\n"
+                                + "      <id>com.example.utils#print/appFunctionParameterMetadata-0"
+                                + "</id>\n"
+                                + "      <parameterName>test</parameterName>\n"
+                                + "    </appFunctionParameterMetadata>\n"
+                                + "  </AppFunctionStaticMetadata>\n"
+                                + "</appfunctions>");
 
         Map<String, AppFunctionDocument> appFunctions =
                 mParser.parseIntoMapForGivenSchemas(
-                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
+                        mPackageManager, TEST_PACKAGE_NAME, xmlPullParser, TEST_SCHEMAS);
 
         assertThat(appFunctions).hasSize(1);
         assertThat(appFunctions).containsKey("com.example.app/com.example.utils#print");
@@ -431,28 +286,29 @@ public class AppFunctionDocumentParserImplTest {
     @Test
     public void parseIntoMapForGivenSchemas_singleAppFunctionWithSelfReferencingSchema()
             throws Exception {
-        setXmlInput(
-                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
-                        + "<appfunctions>\n"
-                        + "  <AppFunctionStaticMetadata>\n"
-                        + "    <id>com.example.utils#print</id>\n"
-                        + "    <functionId>com.example.utils#print</functionId>\n"
-                        + "    <appFunctionParameterMetadata>\n"
-                        + "      <id>com.example.utils#print/appFunctionParameterMetadata-0"
-                        + "</id>\n"
-                        + "      <parameterName>test</parameterName>\n"
-                        + "    <selfReference>\n"
-                        + "      <id>com.example.utils#print/appFunctionParameterMetadata-1"
-                        + "</id>\n"
-                        + "      <parameterName>selfReferencingParam</parameterName>\n"
-                        + "    </selfReference>\n"
-                        + "    </appFunctionParameterMetadata>\n"
-                        + "  </AppFunctionStaticMetadata>\n"
-                        + "</appfunctions>");
+        XmlPullParser xmlPullParser =
+                getXmlPullParser(
+                        "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                                + "<appfunctions>\n"
+                                + "  <AppFunctionStaticMetadata>\n"
+                                + "    <id>com.example.utils#print</id>\n"
+                                + "    <functionId>com.example.utils#print</functionId>\n"
+                                + "    <appFunctionParameterMetadata>\n"
+                                + "      <id>com.example.utils#print/appFunctionParameterMetadata-0"
+                                + "</id>\n"
+                                + "      <parameterName>test</parameterName>\n"
+                                + "    <selfReference>\n"
+                                + "      <id>com.example.utils#print/appFunctionParameterMetadata-1"
+                                + "</id>\n"
+                                + "      <parameterName>selfReferencingParam</parameterName>\n"
+                                + "    </selfReference>\n"
+                                + "    </appFunctionParameterMetadata>\n"
+                                + "  </AppFunctionStaticMetadata>\n"
+                                + "</appfunctions>");
 
         Map<String, AppFunctionDocument> appFunctions =
                 mParser.parseIntoMapForGivenSchemas(
-                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
+                        mPackageManager, TEST_PACKAGE_NAME, xmlPullParser, TEST_SCHEMAS);
 
         assertThat(appFunctions).hasSize(1);
         assertThat(appFunctions).containsKey("com.example.app/com.example.utils#print");
@@ -475,22 +331,23 @@ public class AppFunctionDocumentParserImplTest {
 
     @Test
     public void parseIntoMapForGivenSchemas_multipleTypesOfRootDocuments() throws Exception {
-        setXmlInput(
-                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
-                        + "<appfunctions>\n"
-                        + "  <AppFunctionStaticMetadata>\n"
-                        + "    <id>com.example.utils#print</id>\n"
-                        + "    <functionId>com.example.utils#print</functionId>\n"
-                        + "  </AppFunctionStaticMetadata>\n"
-                        + "  <AppFunctionParameterMetadata>\n"
-                        + "    <id>com.example.utils#printParameterMetadata</id>\n"
-                        + "    <parameterName>message</parameterName>\n"
-                        + "  </AppFunctionParameterMetadata>\n"
-                        + "</appfunctions>");
+        XmlPullParser xmlPullParser =
+                getXmlPullParser(
+                        "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                                + "<appfunctions>\n"
+                                + "  <AppFunctionStaticMetadata>\n"
+                                + "    <id>com.example.utils#print</id>\n"
+                                + "    <functionId>com.example.utils#print</functionId>\n"
+                                + "  </AppFunctionStaticMetadata>\n"
+                                + "  <AppFunctionParameterMetadata>\n"
+                                + "    <id>com.example.utils#printParameterMetadata</id>\n"
+                                + "    <parameterName>message</parameterName>\n"
+                                + "  </AppFunctionParameterMetadata>\n"
+                                + "</appfunctions>");
 
         Map<String, AppFunctionDocument> appFunctions =
                 mParser.parseIntoMapForGivenSchemas(
-                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
+                        mPackageManager, TEST_PACKAGE_NAME, xmlPullParser, TEST_SCHEMAS);
 
         assertThat(appFunctions).hasSize(2);
         assertThat(appFunctions).containsKey("com.example.app/com.example.utils#print");
@@ -510,21 +367,22 @@ public class AppFunctionDocumentParserImplTest {
     public void
             parseIntoMapForGivenSchemas_singleFunctionWithDocumentProperties_missingIdInNestedDoc()
                     throws Exception {
-        setXmlInput(
-                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
-                        + "<appfunctions>\n"
-                        + "  <AppFunctionStaticMetadata>\n"
-                        + "    <id>com.example.utils#print</id>\n"
-                        + "    <functionId>com.example.utils#print</functionId>\n"
-                        + "    <appFunctionParameterMetadata>\n"
-                        + "      <parameterName>test</parameterName>\n"
-                        + "    </appFunctionParameterMetadata>\n"
-                        + "  </AppFunctionStaticMetadata>\n"
-                        + "</appfunctions>");
+        XmlPullParser xmlPullParser =
+                getXmlPullParser(
+                        "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                                + "<appfunctions>\n"
+                                + "  <AppFunctionStaticMetadata>\n"
+                                + "    <id>com.example.utils#print</id>\n"
+                                + "    <functionId>com.example.utils#print</functionId>\n"
+                                + "    <appFunctionParameterMetadata>\n"
+                                + "      <parameterName>test</parameterName>\n"
+                                + "    </appFunctionParameterMetadata>\n"
+                                + "  </AppFunctionStaticMetadata>\n"
+                                + "</appfunctions>");
 
         Map<String, AppFunctionDocument> appFunctions =
                 mParser.parseIntoMapForGivenSchemas(
-                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
+                        mPackageManager, TEST_PACKAGE_NAME, xmlPullParser, TEST_SCHEMAS);
 
         assertThat(appFunctions).isEmpty();
     }
@@ -532,29 +390,30 @@ public class AppFunctionDocumentParserImplTest {
     @Test
     public void parseIntoMapForGivenSchemas_singleAppFunctionWithRepeatedProperties()
             throws Exception {
-        setXmlInput(
-                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
-                        + "<appfunctions>\n"
-                        + "  <AppFunctionStaticMetadata>\n"
-                        + "    <id>com.example.utils#print</id>\n"
-                        + "    <functionId>com.example.utils#print</functionId>\n"
-                        + "    <appFunctionParameterMetadata>\n"
-                        + "      <id>com.example.utils#print/appFunctionParameterMetadata-0"
-                        + "</id>\n"
-                        + "      <parameterName>test1</parameterName>\n"
-                        + "      <parameterName>test2</parameterName>\n"
-                        + "    </appFunctionParameterMetadata>\n"
-                        + "    <appFunctionParameterMetadata>\n"
-                        + "      <id>com.example.utils#print/appFunctionParameterMetadata-1"
-                        + "</id>\n"
-                        + "      <parameterName>test3</parameterName>\n"
-                        + "    </appFunctionParameterMetadata>\n"
-                        + "  </AppFunctionStaticMetadata>\n"
-                        + "</appfunctions>");
+        XmlPullParser xmlPullParser =
+                getXmlPullParser(
+                        "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                                + "<appfunctions>\n"
+                                + "  <AppFunctionStaticMetadata>\n"
+                                + "    <id>com.example.utils#print</id>\n"
+                                + "    <functionId>com.example.utils#print</functionId>\n"
+                                + "    <appFunctionParameterMetadata>\n"
+                                + "      <id>com.example.utils#print/appFunctionParameterMetadata-0"
+                                + "</id>\n"
+                                + "      <parameterName>test1</parameterName>\n"
+                                + "      <parameterName>test2</parameterName>\n"
+                                + "    </appFunctionParameterMetadata>\n"
+                                + "    <appFunctionParameterMetadata>\n"
+                                + "      <id>com.example.utils#print/appFunctionParameterMetadata-1"
+                                + "</id>\n"
+                                + "      <parameterName>test3</parameterName>\n"
+                                + "    </appFunctionParameterMetadata>\n"
+                                + "  </AppFunctionStaticMetadata>\n"
+                                + "</appfunctions>");
 
         Map<String, AppFunctionDocument> appFunctions =
                 mParser.parseIntoMapForGivenSchemas(
-                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
+                        mPackageManager, TEST_PACKAGE_NAME, xmlPullParser, TEST_SCHEMAS);
 
         assertThat(appFunctions).hasSize(1);
         assertThat(appFunctions).containsKey("com.example.app/com.example.utils#print");
@@ -577,20 +436,21 @@ public class AppFunctionDocumentParserImplTest {
     @Test
     public void parseIntoMapForGivenSchemas_validXmlWithUnderscores_worksWithDynamicSchemas()
             throws Exception {
-        setXmlInput(
-                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
-                        + "<appfunctions>\n"
-                        + "  <appfunction>\n"
-                        + "    <id>com.example.utils#print</id>\n"
-                        + "    <function__id>com.example.utils#print</function__id>\n"
-                        + "    <enabled_by_default>true</enabled_by_default>\n"
-                        + "    <scHema_veRsion>10</scHema_veRsion>\n"
-                        + "  </appfunction>\n"
-                        + "</appfunctions>");
+        XmlPullParser xmlPullParser =
+                getXmlPullParser(
+                        "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                                + "<appfunctions>\n"
+                                + "  <appfunction>\n"
+                                + "    <id>com.example.utils#print</id>\n"
+                                + "    <function__id>com.example.utils#print</function__id>\n"
+                                + "    <enabled_by_default>true</enabled_by_default>\n"
+                                + "    <scHema_veRsion>10</scHema_veRsion>\n"
+                                + "  </appfunction>\n"
+                                + "</appfunctions>");
 
         Map<String, AppFunctionDocument> appFunctions =
                 mParser.parseIntoMapForGivenSchemas(
-                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
+                        mPackageManager, TEST_PACKAGE_NAME, xmlPullParser, TEST_SCHEMAS);
 
         assertThat(appFunctions).hasSize(1);
         assertThat(appFunctions).containsKey("com.example.app/com.example.utils#print");
@@ -607,34 +467,55 @@ public class AppFunctionDocumentParserImplTest {
     }
 
     @Test
-    public void parseIntoMapForGivenSchemas_xmlTagWithStartingOrOnlyUnderscores_propertiesIgnored()
+    public void parseIntoMapForGivenSchemas_xmlTagWithStartingOrOnlyUnderscores_noFunctionParsed()
             throws Exception {
-        setXmlInput(
-                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
-                        + "<appfunctions>\n"
-                        + "  <AppFunctionStaticMetadata>\n"
-                        + "    <id>com.example.utils#print</id>\n"
-                        + "    <functionId>com.example.utils#print</functionId>\n"
-                        + "    <___>test</___>\n"
-                        + "    <_schema_version_>test</_schema_version_>\n"
-                        + "  </AppFunctionStaticMetadata>\n"
-                        + "</appfunctions>");
+        XmlPullParser xmlPullParser =
+                getXmlPullParser(
+                        "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                                + "<appfunctions>\n"
+                                + "  <AppFunctionStaticMetadata>\n"
+                                + "    <id>com.example.utils#print</id>\n"
+                                + "    <functionId>com.example.utils#invalid</functionId>\n"
+                                + "    <___>test</___>\n"
+                                + "    <_schema_version_>test</_schema_version_>\n"
+                                + "  </AppFunctionStaticMetadata>\n"
+                                + "  <AppFunctionStaticMetadata>\n"
+                                + "    <id>com.example.utils#print</id>\n"
+                                + "    <functionId>com.example.utils#print</functionId>\n"
+                                + "  </AppFunctionStaticMetadata>\n"
+                                + "</appfunctions>");
 
         Map<String, AppFunctionDocument> appFunctions =
                 mParser.parseIntoMapForGivenSchemas(
-                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
+                        mPackageManager, TEST_PACKAGE_NAME, xmlPullParser, TEST_SCHEMAS);
 
-        assertThat(appFunctions).hasSize(1);
-        assertThat(appFunctions).containsKey("com.example.app/com.example.utils#print");
-        GenericDocument actualAppFunction =
-                appFunctions.get("com.example.app/com.example.utils#print");
-        assertThat(actualAppFunction.getNamespace()).isEqualTo("app_functions");
-        assertThat(actualAppFunction.getId()).isEqualTo("com.example.app/com.example.utils#print");
-        assertThat(actualAppFunction.getSchemaType())
-                .isEqualTo("AppFunctionStaticMetadata-com.example.app");
-        assertThat(actualAppFunction.getPropertyString("functionId"))
-                .isEqualTo("com.example.utils#print");
-        assertThat(actualAppFunction.getPropertyNames())
-                .containsExactly("functionId", "packageName", "mobileApplicationQualifiedId");
+        assertThat(appFunctions).isEmpty();
+    }
+
+    @Test
+    public void parseIntoMapForGivenSchemas_unknownProperties_noFunctionParsed() throws Exception {
+        XmlPullParser xmlPullParser =
+                getXmlPullParser(
+                        "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                                + "<appfunctions>\n"
+                                + "  <AppFunctionStaticMetadata>\n"
+                                + "    <id>com.example.utils#print</id>\n"
+                                + "    <functionId>com.example.utils#invalid</functionId>\n"
+                                + "    <unknownProperty>"
+                                + "        <id>nestedId</id>\n"
+                                + "        <functionId>nestedFunctionId</functionId>\n"
+                                + "    </unknownProperty>\n"
+                                + "  </AppFunctionStaticMetadata>\n"
+                                + "  <AppFunctionStaticMetadata>\n"
+                                + "    <id>com.example.utils#print</id>\n"
+                                + "    <functionId>com.example.utils#print</functionId>\n"
+                                + "  </AppFunctionStaticMetadata>\n"
+                                + "</appfunctions>");
+
+        Map<String, AppFunctionDocument> appFunctions =
+                mParser.parseIntoMapForGivenSchemas(
+                        mPackageManager, TEST_PACKAGE_NAME, xmlPullParser, TEST_SCHEMAS);
+
+        assertThat(appFunctions).isEmpty();
     }
 }
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerImplTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerImplTest.java
index 3f98ed79..9146f87d 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerImplTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerImplTest.java
@@ -25,6 +25,7 @@ import static org.junit.Assert.assertThrows;
 import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.Mockito.when;
 
+import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.exceptions.AppSearchException;
 import android.app.usage.UsageEvents;
 import android.app.usage.UsageStatsManager;
@@ -59,6 +60,7 @@ public class AppOpenEventIndexerImplTest {
     @After
     public void tearDown() throws Exception {
         mAppSearchHelper.close();
+        temporaryFolder.delete();
     }
 
     @Test
@@ -85,7 +87,9 @@ public class AppOpenEventIndexerImplTest {
                 };
 
         AppOpenEventIndexerImpl appOpenEventIndexerImpl = new AppOpenEventIndexerImpl(context);
-        assertThrows(Exception.class, () -> appOpenEventIndexerImpl.doUpdate(settings));
+        assertThrows(
+                Exception.class,
+                () -> appOpenEventIndexerImpl.doUpdate(settings, new AppOpenEventStats.Builder()));
         // Indexing did not succeed, so we should not be able to get any app open events
         assertThrows(
                 AppSearchException.class,
@@ -129,15 +133,68 @@ public class AppOpenEventIndexerImplTest {
                 };
 
         AppOpenEventIndexerImpl appOpenEventIndexerImpl = new AppOpenEventIndexerImpl(context);
-        appOpenEventIndexerImpl.doUpdate(settings);
+        AppOpenEventStats.Builder appOpenEventStatsBuilder = new AppOpenEventStats.Builder();
+        appOpenEventIndexerImpl.doUpdate(settings, appOpenEventStatsBuilder);
+        AppOpenEventStats appOpenEventStats = appOpenEventStatsBuilder.build();
 
         assertThat(
                         mAppSearchHelper
                                 .getSubsequentAppOpenEventAfterThreshold(currentTimeMillis)
                                 .getId())
                 .isEqualTo("com.example.package" + (currentTimeMillis + 1L));
+        assertThat(appOpenEventStats.getNumberOfAppOpenEventsAdded()).isEqualTo(1);
+        assertThat(appOpenEventStats.getUpdateStatusCodes())
+                .containsExactly(AppSearchResult.RESULT_OK);
 
         // Settings updated on successful indexing
         assertThat(settings.getLastUpdateTimestampMillis()).isGreaterThan(currentTimeMillis);
     }
+
+    @Test
+    public void testAppOpenEventIndexerImpl_updateApps_statsAreCorrect() throws Exception {
+        long currentTimeMillis = System.currentTimeMillis();
+        AppOpenEventIndexerSettings settings =
+                new AppOpenEventIndexerSettings(temporaryFolder.newFolder("tmp"));
+        settings.setLastUpdateTimestampMillis(currentTimeMillis);
+
+        UsageStatsManager usm = Mockito.mock(UsageStatsManager.class);
+
+        UsageEvents.Event[] oldEvents =
+                new UsageEvents.Event[] {
+                    createIndividualUsageEvent(
+                            UsageEvents.Event.MOVE_TO_FOREGROUND,
+                            currentTimeMillis,
+                            "com.example.package"),
+                    createIndividualUsageEvent(
+                            UsageEvents.Event.MOVE_TO_FOREGROUND,
+                            currentTimeMillis + 1L,
+                            "com.example.package"),
+                };
+        UsageEvents mockUsageEvents = TestUtils.createUsageEvents(oldEvents);
+
+        when(usm.queryEvents(anyLong(), anyLong())).thenReturn(mockUsageEvents);
+
+        Context context =
+                new ContextWrapper(mContext) {
+                    @Override
+                    public Object getSystemService(String name) {
+                        if (name.equals(Context.USAGE_STATS_SERVICE)) {
+                            return usm;
+                        }
+                        return super.getSystemService(name);
+                    }
+                };
+
+        AppOpenEventIndexerImpl appOpenEventIndexerImpl = new AppOpenEventIndexerImpl(context);
+        AppOpenEventStats.Builder appOpenEventStatsBuilder = new AppOpenEventStats.Builder();
+        appOpenEventIndexerImpl.doUpdate(settings, appOpenEventStatsBuilder);
+
+        AppOpenEventStats appOpenEventStats = appOpenEventStatsBuilder.build();
+
+        assertThat(appOpenEventStats.getNumberOfAppOpenEventsAdded()).isEqualTo(2);
+        assertThat(appOpenEventStats.getUpdateStatusCodes()).hasSize(1);
+        assertThat(appOpenEventStats.getUpdateStatusCodes()).contains(AppSearchResult.RESULT_OK);
+        assertThat(appOpenEventStats.getUsageStatsManagerReadLatencyMillis()).isGreaterThan(0L);
+        assertThat(settings.getLastUpdateTimestampMillis()).isAtLeast(currentTimeMillis);
+    }
 }
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerRealDocumentsTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerRealDocumentsTest.java
index 57d20620..271a5d92 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerRealDocumentsTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerRealDocumentsTest.java
@@ -17,6 +17,7 @@ package com.android.server.appsearch.appsindexer;
 
 import static android.Manifest.permission.OBSERVE_APP_USAGE;
 import static android.Manifest.permission.PACKAGE_USAGE_STATS;
+import static android.Manifest.permission.READ_DEVICE_CONFIG;
 import static android.Manifest.permission.RECEIVE_BOOT_COMPLETED;
 
 import static com.android.server.appsearch.appsindexer.TestUtils.createFakeAppOpenEventsIndexerSession;
@@ -80,7 +81,6 @@ public class AppOpenEventIndexerRealDocumentsTest {
     protected Context mContext;
     protected UserInfo mUserInfo;
     protected UserHandle mUserHandle;
-    protected Context mUserContext;
     protected UiAutomation mUiAutomation;
 
     @Rule public TemporaryFolder mTemporaryFolder = new TemporaryFolder();
@@ -92,14 +92,11 @@ public class AppOpenEventIndexerRealDocumentsTest {
                 new UserInfo(
                         mContext.getUser().getIdentifier(), /* name= */ "default", /* flags= */ 0);
         mUserHandle = new SystemService.TargetUser(mUserInfo).getUserHandle();
-        mUserContext =
-                AppSearchEnvironmentFactory.getEnvironmentInstance()
-                        .createContextAsUser(mContext, mUserHandle);
         removeFakeAppOpenEventDocuments(mContext, Executors.newSingleThreadExecutor());
 
         mUiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
         mUiAutomation.adoptShellPermissionIdentity(
-                PACKAGE_USAGE_STATS, OBSERVE_APP_USAGE, RECEIVE_BOOT_COMPLETED);
+                PACKAGE_USAGE_STATS, OBSERVE_APP_USAGE, RECEIVE_BOOT_COMPLETED, READ_DEVICE_CONFIG);
 
         File mAppSearchDir = mTemporaryFolder.newFolder();
         AppSearchEnvironmentFactory.setEnvironmentInstanceForTest(
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerUserInstanceTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerUserInstanceTest.java
index 8c643a91..494526c6 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerUserInstanceTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerUserInstanceTest.java
@@ -229,7 +229,6 @@ public class AppOpenEventIndexerUserInstanceTest {
 
     @Test
     public void testStart_onShutdown_cancelsUpdateJob() throws Exception {
-        long currentTimeMillis = System.currentTimeMillis();
         JobScheduler mockJobScheduler = mock(JobScheduler.class);
         mContext.setJobScheduler(mockJobScheduler);
 
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppSearchHelperTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppSearchHelperTest.java
index 65c9ef91..b7880140 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppSearchHelperTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppSearchHelperTest.java
@@ -58,15 +58,18 @@ import android.app.appsearch.SearchSpec;
 import android.app.appsearch.SetSchemaRequest;
 import android.app.appsearch.exceptions.AppSearchException;
 import android.content.Context;
+import android.util.ArraySet;
 
 import androidx.test.core.app.ApplicationProvider;
 
+import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionDocument;
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppOpenEvent;
 import com.android.server.appsearch.appsindexer.appsearchtypes.MobileApplication;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
 
 import org.junit.After;
 import org.junit.Before;
@@ -76,6 +79,7 @@ import org.mockito.Mockito;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
@@ -105,10 +109,7 @@ public class AppSearchHelperTest {
     public void testAppSearchHelper_permissionSetCorrectlyForMobileApplication() throws Exception {
         mAppSearchHelper.setSchemasForPackages(createMockPackageIdentifiers(1), new ArrayList<>());
         mAppSearchHelper.indexApps(
-                createMobileApplications(1),
-                /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of(),
-                /* appsUpdateStats= */ new AppsUpdateStats());
+                createMobileApplications(1), /* appFunctions= */ ImmutableList.of());
 
         AppSearchSessionShim session =
                 createFakeAppIndexerSession(mContext, mSingleThreadedExecutor);
@@ -133,11 +134,7 @@ public class AppSearchHelperTest {
             throws Exception {
         mAppSearchHelper.setSchemasForPackages(createMockPackageIdentifiers(1), new ArrayList<>());
         mAppSearchHelper.indexApps(
-                createMobileApplications(1),
-                /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of(),
-                /* appsUpdateStats= */
-                /* appsUpdateStats= */ new AppsUpdateStats());
+                createMobileApplications(1), /* appFunctions= */ ImmutableList.of());
 
         AppSearchSessionShim session =
                 createFakeAppIndexerSession(mContext, mSingleThreadedExecutor);
@@ -155,11 +152,9 @@ public class AppSearchHelperTest {
         mAppSearchHelper.setSchemasForPackages(
                 createMockPackageIdentifiers(600), new ArrayList<>());
         mAppSearchHelper.indexApps(
-                createMobileApplications(600),
-                /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of(),
-                /* appsUpdateStats= */ new AppsUpdateStats());
-        Map<String, Long> appsearchIds = mAppSearchHelper.getAppsFromAppSearch();
+                createMobileApplications(600), /* appFunctions= */ ImmutableList.of());
+        Map<String, MobileApplication> appsearchIds =
+                mAppSearchHelper.getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch();
         assertThat(appsearchIds.size()).isEqualTo(600);
         List<SearchResult> real = searchAppSearchForApps(600 + 1);
         assertThat(real).hasSize(600);
@@ -184,9 +179,7 @@ public class AppSearchHelperTest {
                 ImmutableList.of(createMockPackageIdentifier(variant)), new ArrayList<>());
         appSearchHelper.indexApps(
                 ImmutableList.of(createFakeMobileApplication(variant)),
-                /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of(),
-                /* appsUpdateStats= */ new AppsUpdateStats());
+                /* appFunctions= */ ImmutableList.of());
 
         assertThat(appSearchHelper).isNotNull();
         List<SearchResult> results = searchAppSearchForApps(1 + 1);
@@ -211,7 +204,8 @@ public class AppSearchHelperTest {
         AppSearchHelper appSearchHelper = new AppSearchHelper(mContext);
         appSearchHelper.setSchemaForAppOpenEvents();
         AppOpenEvent fakeAppOpenEvent = createFakeAppOpenEvent(currentTimeMillis);
-        appSearchHelper.indexAppOpenEvents(ImmutableList.of(fakeAppOpenEvent));
+        appSearchHelper.indexAppOpenEvents(
+                ImmutableList.of(fakeAppOpenEvent), new AppOpenEventStats.Builder());
 
         assertThat(appSearchHelper).isNotNull();
         AppOpenEvent appOpenEvent =
@@ -236,10 +230,7 @@ public class AppSearchHelperTest {
 
         mAppSearchHelper.setSchemasForPackages(createMockPackageIdentifiers(50), new ArrayList<>());
         mAppSearchHelper.indexApps(
-                createMobileApplications(50),
-                /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of(),
-                /* appsUpdateStats= */ new AppsUpdateStats());
+                createMobileApplications(50), /* appFunctions= */ ImmutableList.of());
 
         List<SearchResult> real = searchAppSearchForApps(50 + 1);
         assertThat(real).hasSize(50);
@@ -283,7 +274,8 @@ public class AppSearchHelperTest {
         appSearchHelper.setSchemaForAppOpenEvents();
         AppOpenEvent fakeAppOpenEvent = createFakeAppOpenEvent(currentTimeMillis);
         appSearchHelper.indexAppOpenEvents(
-                ImmutableList.of(createFakeAppOpenEvent(currentTimeMillis)));
+                ImmutableList.of(createFakeAppOpenEvent(currentTimeMillis)),
+                new AppOpenEventStats.Builder());
 
         assertThat(appSearchHelper).isNotNull();
         AppOpenEvent appOpenEvent =
@@ -335,9 +327,7 @@ public class AppSearchHelperTest {
                 () ->
                         mocked.indexApps(
                                 ImmutableList.of(createFakeMobileApplication(0)),
-                                /* appFunctions= */ ImmutableList.of(),
-                                /* existingAppFunctions= */ ImmutableList.of(),
-                                /* appsUpdateStats= */ new AppsUpdateStats()));
+                                /* appFunctions= */ ImmutableList.of()));
     }
 
     @Test
@@ -345,10 +335,7 @@ public class AppSearchHelperTest {
         mAppSearchHelper.setSchemasForPackages(
                 createMockPackageIdentifiers(100), new ArrayList<>());
         mAppSearchHelper.indexApps(
-                createMobileApplications(100),
-                /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of(),
-                /* appsUpdateStats= */ new AppsUpdateStats());
+                createMobileApplications(100), /* appFunctions= */ ImmutableList.of());
 
         mAppSearchHelper.setSchemasForPackages(createMockPackageIdentifiers(50), new ArrayList<>());
 
@@ -358,9 +345,11 @@ public class AppSearchHelperTest {
             deletedIds.add(FAKE_PACKAGE_PREFIX + i);
         }
 
-        Map<String, Long> indexedIds = mAppSearchHelper.getAppsFromAppSearch();
+        Map<String, MobileApplication> indexedIds =
+                mAppSearchHelper.getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch();
         assertThat(indexedIds.size()).isEqualTo(50);
-        Map<String, Long> appsearchIds = mAppSearchHelper.getAppsFromAppSearch();
+        Map<String, MobileApplication> appsearchIds =
+                mAppSearchHelper.getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch();
         assertThat(appsearchIds.keySet()).containsNoneIn(deletedIds);
     }
 
@@ -371,25 +360,21 @@ public class AppSearchHelperTest {
 
         mAppSearchHelper.setSchemasForPackages(createMockPackageIdentifiers(2), new ArrayList<>());
         mAppSearchHelper.indexApps(
-                ImmutableList.of(app0, app1),
-                /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of(),
-                /* appsUpdateStats= */ new AppsUpdateStats());
-        Map<String, Long> timestampMapping = mAppSearchHelper.getAppsFromAppSearch();
-        assertThat(timestampMapping)
-                .containsExactly("com.fake.package0", 0L, "com.fake.package1", 1L);
+                ImmutableList.of(app0, app1), /* appFunctions= */ ImmutableList.of());
+        Map<String, MobileApplication> timestampMapping =
+                mAppSearchHelper.getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch();
+        assertThat(timestampMapping.keySet())
+                .containsExactly("com.fake.package0", "com.fake.package1");
 
         // Try to add the same apps
         mAppSearchHelper.indexApps(
-                ImmutableList.of(app0, app1),
-                /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of(),
-                /* appsUpdateStats= */ new AppsUpdateStats());
+                ImmutableList.of(app0, app1), /* appFunctions= */ ImmutableList.of());
 
         // Should still be two
-        timestampMapping = mAppSearchHelper.getAppsFromAppSearch();
-        assertThat(timestampMapping)
-                .containsExactly("com.fake.package0", 0L, "com.fake.package1", 1L);
+        timestampMapping =
+                mAppSearchHelper.getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch();
+        assertThat(timestampMapping.keySet())
+                .containsExactly("com.fake.package0", "com.fake.package1");
     }
 
     @Test
@@ -399,13 +384,11 @@ public class AppSearchHelperTest {
 
         mAppSearchHelper.setSchemasForPackages(createMockPackageIdentifiers(2), new ArrayList<>());
         mAppSearchHelper.indexApps(
-                ImmutableList.of(app0, app1),
-                /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of(),
-                /* appsUpdateStats= */ new AppsUpdateStats());
-        Map<String, Long> timestampMapping = mAppSearchHelper.getAppsFromAppSearch();
-        assertThat(timestampMapping)
-                .containsExactly("com.fake.package0", 0L, "com.fake.package1", 1L);
+                ImmutableList.of(app0, app1), /* appFunctions= */ ImmutableList.of());
+        Map<String, MobileApplication> timestampMapping =
+                mAppSearchHelper.getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch();
+        assertThat(timestampMapping.keySet())
+                .containsExactly("com.fake.package0", "com.fake.package1");
 
         // Check what happens if we keep the same id
         app1 =
@@ -418,14 +401,12 @@ public class AppSearchHelperTest {
                         .build();
 
         // Should update the app, not add a new one
-        mAppSearchHelper.indexApps(
-                ImmutableList.of(app1),
-                /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of(),
-                /* appsUpdateStats= */ new AppsUpdateStats());
-        timestampMapping = mAppSearchHelper.getAppsFromAppSearch();
-        assertThat(timestampMapping)
-                .containsExactly("com.fake.package0", 0L, "com.fake.package1", 300L);
+        mAppSearchHelper.indexApps(ImmutableList.of(app1), /* appFunctions= */ ImmutableList.of());
+        timestampMapping =
+                mAppSearchHelper.getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch();
+        assertThat(timestampMapping.keySet())
+                .containsExactly("com.fake.package0", "com.fake.package1");
+        assertThat(timestampMapping.get("com.fake.package1").getUpdatedTimestamp()).isEqualTo(300L);
     }
 
     @Test
@@ -435,26 +416,23 @@ public class AppSearchHelperTest {
 
         mAppSearchHelper.setSchemasForPackages(createMockPackageIdentifiers(2), new ArrayList<>());
         mAppSearchHelper.indexApps(
-                ImmutableList.of(app0, app1),
-                /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of(),
-                /* appsUpdateStats= */ new AppsUpdateStats());
-        assertThat(mAppSearchHelper.getAppsFromAppSearch()).hasSize(2);
+                ImmutableList.of(app0, app1), /* appFunctions= */ ImmutableList.of());
+        assertThat(
+                        mAppSearchHelper
+                                .getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch())
+                .hasSize(2);
 
         MobileApplication app2 = createFakeMobileApplication(2);
 
         mAppSearchHelper.setSchemasForPackages(createMockPackageIdentifiers(3), new ArrayList<>());
         mAppSearchHelper.indexApps(
-                ImmutableList.of(app0, app1, app2),
-                /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of(),
-                /* appsUpdateStats= */ new AppsUpdateStats());
+                ImmutableList.of(app0, app1, app2), /* appFunctions= */ ImmutableList.of());
 
         // Should be three
-        Map<String, Long> timestampMapping = mAppSearchHelper.getAppsFromAppSearch();
-        assertThat(timestampMapping)
-                .containsExactly(
-                        "com.fake.package0", 0L, "com.fake.package1", 1L, "com.fake.package2", 2L);
+        Map<String, MobileApplication> timestampMapping =
+                mAppSearchHelper.getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch();
+        assertThat(timestampMapping.keySet())
+                .containsExactly("com.fake.package0", "com.fake.package1", "com.fake.package2");
     }
 
     @Test
@@ -463,28 +441,39 @@ public class AppSearchHelperTest {
         MobileApplication app0 = createFakeMobileApplication(0);
         MobileApplication app1 = createFakeMobileApplication(1);
 
+        Set<String> packages = ImmutableSet.of("com.fake.package0", "com.fake.package1");
+
         // initially, no apps has app functions.
         mAppSearchHelper.setSchemasForPackages(
                 createMockPackageIdentifiers(2), createMockPackageIdentifiers(0));
         mAppSearchHelper.indexApps(
-                ImmutableList.of(app0, app1),
-                /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of(),
-                /* appsUpdateStats= */ new AppsUpdateStats());
-        assertThat(mAppSearchHelper.getAppFunctionsFromAppSearch()).isEmpty();
+                ImmutableList.of(app0, app1), /* appFunctions= */ ImmutableList.of());
+        List<String> indexedFunctionIds = new ArrayList<>();
+        Map<String, Map<String, AppFunctionDocument>> indexedFunctions =
+                mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(new ArraySet<>(packages));
+        for (Map<String, AppFunctionDocument> functions : indexedFunctions.values()) {
+            for (AppFunctionDocument function : functions.values()) {
+                indexedFunctionIds.add(function.getId());
+            }
+        }
+        assertThat(indexedFunctionIds).isEmpty();
 
         // Now app0 has an app function.
         mAppSearchHelper.setSchemasForPackages(
                 createMockPackageIdentifiers(2), createMockPackageIdentifiers(1));
         AppFunctionStaticMetadata app0Function0 = createFakeAppFunction(0, 0, mContext);
         mAppSearchHelper.indexApps(
-                ImmutableList.of(app0, app1),
-                /* appFunctions= */ ImmutableList.of(app0Function0),
-                /* existingAppFunctions= */ ImmutableList.of(app0Function0),
-                /* appsUpdateStats= */ new AppsUpdateStats());
-
-        assertThat(mAppSearchHelper.getAppFunctionsFromAppSearch().get(0).getId())
-                .isEqualTo("com.fake.package0/function_id0");
+                ImmutableList.of(app0, app1), /* appFunctions= */ ImmutableList.of(app0Function0));
+
+        indexedFunctionIds = new ArrayList<>();
+        indexedFunctions =
+                mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(new ArraySet<>(packages));
+        for (Map<String, AppFunctionDocument> functions : indexedFunctions.values()) {
+            for (AppFunctionDocument function : functions.values()) {
+                indexedFunctionIds.add(function.getId());
+            }
+        }
+        assertThat(indexedFunctionIds).containsExactly("com.fake.package0/function_id0");
     }
 
     @Test
@@ -497,10 +486,7 @@ public class AppSearchHelperTest {
                 createMockPackageIdentifiers(1), createMockPackageIdentifiers(1));
         AppFunctionStaticMetadata app0Function0 = createFakeAppFunction(0, 0, mContext);
         mAppSearchHelper.indexApps(
-                ImmutableList.of(app0),
-                /* appFunctions= */ ImmutableList.of(app0Function0),
-                /* existingAppFunctions= */ ImmutableList.of(),
-                /* appsUpdateStats= */ new AppsUpdateStats());
+                ImmutableList.of(app0), /* appFunctions= */ ImmutableList.of(app0Function0));
 
         AppSearchSessionShim session =
                 createFakeAppIndexerSession(mContext, mSingleThreadedExecutor);
@@ -521,45 +507,58 @@ public class AppSearchHelperTest {
         AppFunctionStaticMetadata app0Function0 = createFakeAppFunction(0, 0, mContext);
         AppFunctionStaticMetadata app0Function1 = createFakeAppFunction(0, 1, mContext);
 
+        Set<String> packages = ImmutableSet.of("com.fake.package0", "com.fake.package1");
+
         mAppSearchHelper.setSchemasForPackages(
                 createMockPackageIdentifiers(2), createMockPackageIdentifiers(1));
         mAppSearchHelper.indexApps(
                 ImmutableList.of(app0, app1),
-                /* appFunctions= */ ImmutableList.of(app0Function0, app0Function1),
-                /* existingAppFunctions= */ ImmutableList.of(),
-                /* appsUpdateStats= */ new AppsUpdateStats());
-        List<GenericDocument> appFunctionsInAppSearch =
-                mAppSearchHelper.getAppFunctionsFromAppSearch();
-        assertThat(appFunctionsInAppSearch).hasSize(2);
-        List<String> ids = new ArrayList<>();
-        ids.add(appFunctionsInAppSearch.get(0).getId());
-        ids.add(appFunctionsInAppSearch.get(1).getId());
-        assertThat(ids)
+                /* appFunctions= */ ImmutableList.of(app0Function0, app0Function1));
+        List<String> indexedFunctionIds = new ArrayList<>();
+        Map<String, Map<String, AppFunctionDocument>> indexedFunctions =
+                mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(packages);
+        for (Map<String, AppFunctionDocument> functions : indexedFunctions.values()) {
+            for (AppFunctionDocument function : functions.values()) {
+                indexedFunctionIds.add(function.getId());
+            }
+        }
+        assertThat(indexedFunctionIds)
                 .containsExactly(
                         "com.fake.package0/function_id0", "com.fake.package0/function_id1");
 
         // Now we remove one app function from app0
         mAppSearchHelper.setSchemasForPackages(
                 createMockPackageIdentifiers(2), createMockPackageIdentifiers(1));
+        mAppSearchHelper.removeAppFunctionsById(ImmutableList.of("com.fake.package0/function_id1"));
         mAppSearchHelper.indexApps(
-                ImmutableList.of(app0, app1),
-                /* appFunctions= */ ImmutableList.of(app0Function0),
-                /* existingAppFunctions= */ ImmutableList.of(app0Function0, app0Function1),
-                /* appsUpdateStats= */ new AppsUpdateStats());
+                ImmutableList.of(app0, app1), /* appFunctions= */ ImmutableList.of(app0Function0));
+
         // app0 still have one app function. so app0 is being indexed.
-        assertThat(mAppSearchHelper.getAppFunctionsFromAppSearch().get(0).getId())
-                .isEqualTo("com.fake.package0/function_id0");
+        indexedFunctionIds = new ArrayList<>();
+        indexedFunctions = mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(packages);
+        for (Map<String, AppFunctionDocument> functions : indexedFunctions.values()) {
+            for (AppFunctionDocument function : functions.values()) {
+                indexedFunctionIds.add(function.getId());
+            }
+        }
+        assertThat(indexedFunctionIds).containsExactly("com.fake.package0/function_id0");
 
         // We remove the last app function from app0.
         mAppSearchHelper.setSchemasForPackages(
                 createMockPackageIdentifiers(2), createMockPackageIdentifiers(0));
+        mAppSearchHelper.removeAppFunctionsById(ImmutableList.of("com.fake.package0/function_id0"));
         mAppSearchHelper.indexApps(
-                ImmutableList.of(app0, app1),
-                /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of(app0Function0),
-                /* appsUpdateStats= */ new AppsUpdateStats());
+                ImmutableList.of(app0, app1), /* appFunctions= */ ImmutableList.of());
         // App0 is no longer indexed for app functions cause it no longer has any of them.
-        assertThat(mAppSearchHelper.getAppFunctionsFromAppSearch()).isEmpty();
+        indexedFunctionIds = new ArrayList<>();
+        indexedFunctions =
+                mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(new ArraySet<>(packages));
+        for (Map<String, AppFunctionDocument> functions : indexedFunctions.values()) {
+            for (AppFunctionDocument function : functions.values()) {
+                indexedFunctionIds.add(function.getId());
+            }
+        }
+        assertThat(indexedFunctionIds).isEmpty();
     }
 
     @Test
@@ -567,11 +566,13 @@ public class AppSearchHelperTest {
         long currentTimeMillis = System.currentTimeMillis();
         AppOpenEvent event1 = createFakeAppOpenEvent(currentTimeMillis + 100L);
         mAppSearchHelper.setSchemaForAppOpenEvents();
-        mAppSearchHelper.indexAppOpenEvents(ImmutableList.of(event1));
+        mAppSearchHelper.indexAppOpenEvents(
+                ImmutableList.of(event1), new AppOpenEventStats.Builder());
 
         AppOpenEvent event2 = createFakeAppOpenEvent(currentTimeMillis + 200L);
         mAppSearchHelper.setSchemaForAppOpenEvents();
-        mAppSearchHelper.indexAppOpenEvents(ImmutableList.of(event2));
+        mAppSearchHelper.indexAppOpenEvents(
+                ImmutableList.of(event2), new AppOpenEventStats.Builder());
 
         assertThat(
                         mAppSearchHelper
@@ -592,7 +593,8 @@ public class AppSearchHelperTest {
         AppOpenEvent event1 = createFakeAppOpenEvent(currentTimeMillis + 100L);
         mAppSearchHelper.setSchemasForPackages(createMockPackageIdentifiers(1), new ArrayList<>());
 
-        mAppSearchHelper.indexAppOpenEvents(ImmutableList.of(event1));
+        mAppSearchHelper.indexAppOpenEvents(
+                ImmutableList.of(event1), new AppOpenEventStats.Builder());
         assertThat(
                         mAppSearchHelper
                                 .getSubsequentAppOpenEventAfterThreshold(currentTimeMillis)
@@ -611,7 +613,8 @@ public class AppSearchHelperTest {
                 AppSearchException.class,
                 () -> mAppSearchHelper.getSubsequentAppOpenEventAfterThreshold(currentTimeMillis));
 
-        mAppSearchHelper.indexAppOpenEvents(ImmutableList.of(event1, event2));
+        mAppSearchHelper.indexAppOpenEvents(
+                ImmutableList.of(event1, event2), new AppOpenEventStats.Builder());
         assertThat(
                         mAppSearchHelper
                                 .getSubsequentAppOpenEventAfterThreshold(currentTimeMillis)
@@ -633,18 +636,15 @@ public class AppSearchHelperTest {
     public void testAppOpenEventJoinsToMobileApplication() throws Exception {
         mAppSearchHelper.setSchemasForPackages(createMockPackageIdentifiers(1), new ArrayList<>());
         List<MobileApplication> apps = createMobileApplications(1);
-        mAppSearchHelper.indexApps(
-                apps,
-                /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of(),
-                /* appsUpdateStats= */ new AppsUpdateStats());
+        mAppSearchHelper.indexApps(apps, /* appFunctions= */ ImmutableList.of());
 
         long currentTimeMillis = System.currentTimeMillis();
         AppOpenEvent event1 =
                 AppOpenEvent.create(
                         apps.get(0).getPackageName(), currentTimeMillis, mContext.getPackageName());
         mAppSearchHelper.setSchemaForAppOpenEvents();
-        mAppSearchHelper.indexAppOpenEvents(ImmutableList.of(event1));
+        mAppSearchHelper.indexAppOpenEvents(
+                ImmutableList.of(event1), new AppOpenEventStats.Builder());
 
         SearchSpec nestedSearchSpec =
                 new SearchSpec.Builder()
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerImplTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerImplTest.java
index 2f03c76a..27793fc7 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerImplTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerImplTest.java
@@ -48,6 +48,7 @@ import android.content.pm.ResolveInfo;
 import android.content.res.AssetManager;
 import android.content.res.Resources;
 import android.platform.test.annotations.RequiresFlagsEnabled;
+import android.util.ArraySet;
 
 import androidx.test.core.app.ApplicationProvider;
 
@@ -110,11 +111,9 @@ public class AppsIndexerImplTest {
 
         mAppSearchHelper.setSchemasForPackages(createMockPackageIdentifiers(2), new ArrayList<>());
         mAppSearchHelper.indexApps(
-                ImmutableList.of(app1, app2),
-                /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of(),
-                new AppsUpdateStats());
-        Map<String, Long> appTimestampMap = mAppSearchHelper.getAppsFromAppSearch();
+                ImmutableList.of(app1, app2), /* appFunctions= */ ImmutableList.of());
+        Map<String, MobileApplication> appTimestampMap =
+                mAppSearchHelper.getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch();
 
         List<String> packageIds = new ArrayList<>(appTimestampMap.keySet());
         assertThat(packageIds).containsExactly("com.fake.package0", "com.fake.package1");
@@ -128,12 +127,16 @@ public class AppsIndexerImplTest {
                 /* appFunctionServices= */ ImmutableList.of());
         Context context = createContextWithPackageManager(pm);
         try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context, mAppsIndexerConfig)) {
-            appsIndexerImpl.doUpdate(
+            appsIndexerImpl.doUpdateIncrementalPut(
                     new AppsIndexerSettings(temporaryFolder.newFolder("temp")),
-                    new AppsUpdateStats());
+                    new AppsUpdateStats(),
+                    /* isFullUpdateRequired= */ false);
 
-            assertThat(mAppSearchHelper.getAppsFromAppSearch().keySet())
-                    .containsExactly("com.fake.package0");
+            Set<String> ids =
+                    mAppSearchHelper
+                            .getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch()
+                            .keySet();
+            assertThat(ids).containsExactly("com.fake.package0");
         }
     }
 
@@ -143,12 +146,17 @@ public class AppsIndexerImplTest {
         when(pm.getInstalledPackages(any())).thenThrow(new RuntimeException("fake"));
         Context context = createContextWithPackageManager(pm);
         try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context, mAppsIndexerConfig)) {
-            appsIndexerImpl.doUpdate(
+            appsIndexerImpl.doUpdateIncrementalPut(
                     new AppsIndexerSettings(temporaryFolder.newFolder("tmp")),
-                    new AppsUpdateStats());
+                    new AppsUpdateStats(),
+                    /* isFullUpdateRequired= */ false);
 
             // Shouldn't throw, but no apps indexed
-            assertThat(mAppSearchHelper.getAppsFromAppSearch()).isEmpty();
+            Set<String> ids =
+                    mAppSearchHelper
+                            .getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch()
+                            .keySet();
+            assertThat(ids).isEmpty();
         }
     }
 
@@ -166,8 +174,10 @@ public class AppsIndexerImplTest {
         // Perform the first update
         try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
             AppsUpdateStats stats1 = new AppsUpdateStats();
-            appsIndexerImpl.doUpdate(
-                    new AppsIndexerSettings(temporaryFolder.newFolder("temp1")), stats1);
+            appsIndexerImpl.doUpdateIncrementalPut(
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp1")),
+                    stats1,
+                    /* isFullUpdateRequired= */ false);
 
             // Check the stats object after the first update
             assertThat(stats1.mNumberOfAppsAdded).isEqualTo(3); // Three new apps added
@@ -176,7 +186,11 @@ public class AppsIndexerImplTest {
             assertThat(stats1.mNumberOfAppsUpdated).isEqualTo(0); // No apps updated
 
             // Verify the state of the indexed apps after the first update
-            assertThat(mAppSearchHelper.getAppsFromAppSearch().keySet())
+            Set<String> ids =
+                    mAppSearchHelper
+                            .getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch()
+                            .keySet();
+            assertThat(ids)
                     .containsExactly("com.fake.package0", "com.fake.package1", "com.fake.package2");
         }
 
@@ -198,8 +212,10 @@ public class AppsIndexerImplTest {
         // Perform the second update
         try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context2, mAppsIndexerConfig)) {
             AppsUpdateStats stats2 = new AppsUpdateStats();
-            appsIndexerImpl.doUpdate(
-                    new AppsIndexerSettings(temporaryFolder.newFolder("temp2")), stats2);
+            appsIndexerImpl.doUpdateIncrementalPut(
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp2")),
+                    stats2,
+                    /* isFullUpdateRequired= */ false);
 
             // Check the stats object after the second update
             assertThat(stats2.mNumberOfAppsAdded).isEqualTo(1); // One new app added
@@ -208,7 +224,11 @@ public class AppsIndexerImplTest {
             assertThat(stats2.mNumberOfAppsUpdated).isEqualTo(1); // One app updated
 
             // Verify the state of the indexed apps after the second update
-            assertThat(mAppSearchHelper.getAppsFromAppSearch().keySet())
+            Set<String> ids =
+                    mAppSearchHelper
+                            .getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch()
+                            .keySet();
+            assertThat(ids)
                     .containsExactly("com.fake.package1", "com.fake.package2", "com.fake.package3");
         }
     }
@@ -228,9 +248,10 @@ public class AppsIndexerImplTest {
         }
 
         when(pm1.getProperty(any(String.class), any(ComponentName.class)))
-                .thenReturn(new PackageManager.Property("", "", "", ""));
+                .thenThrow(PackageManager.NameNotFoundException.class);
+        when(pm1.getProperty(eq("android.app.appfunctions"), any(ComponentName.class)))
+                .thenReturn(new PackageManager.Property("", "app_functions.xml", "", ""));
         AssetManager assetManager = Mockito.mock(AssetManager.class);
-
         // Three functions initially. One will be deleted, another updated, the third left alone,
         // then a fourth added.
         String xml =
@@ -247,20 +268,19 @@ public class AppsIndexerImplTest {
                         + "    <function_id>com.example.utils#pay</function_id>\n"
                         + "  </appfunction>\n"
                         + "</appfunctions>";
-
-        when(assetManager.open(any(String.class)))
+        when(assetManager.open(eq("app_functions.xml")))
                 .thenReturn(
                         new ByteArrayInputStream(xml.getBytes()),
                         new ByteArrayInputStream(xml.getBytes()),
                         new ByteArrayInputStream(xml.getBytes()),
                         new ByteArrayInputStream(xml.getBytes()),
                         new ByteArrayInputStream(xml.getBytes()));
-
-        Resources resources = Mockito.mock(Resources.class);
-        when(resources.getAssets()).thenReturn(assetManager);
-        when(pm1.getResourcesForApplication(any(String.class))).thenReturn(resources);
+        setUpResourcesForApp(assetManager, pm1, fakePackages.get(0).packageName);
+        setUpResourcesForApp(assetManager, pm1, fakePackages.get(1).packageName);
+        setUpResourcesForApp(assetManager, pm1, fakePackages.get(2).packageName);
+        setUpResourcesForApp(assetManager, pm1, fakePackages.get(3).packageName);
+        setUpResourcesForApp(assetManager, pm1, fakePackages.get(4).packageName);
         setupMockPackageManager(pm1, fakePackages, fakeActivities, fakeAppFunctionServices);
-
         Context context1 = createContextWithPackageManager(pm1);
 
         List<String> packages = new ArrayList<>();
@@ -280,8 +300,10 @@ public class AppsIndexerImplTest {
         // Perform the first update
         try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
             AppsUpdateStats stats1 = new AppsUpdateStats();
-            appsIndexerImpl.doUpdate(
-                    new AppsIndexerSettings(temporaryFolder.newFolder("temp1")), stats1);
+            appsIndexerImpl.doUpdateIncrementalPut(
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp1")),
+                    stats1,
+                    /* isFullUpdateRequired= */ true);
 
             // Check the stats object after the first update
             assertThat(stats1.mNumberOfAppsAdded).isEqualTo(5);
@@ -289,17 +311,17 @@ public class AppsIndexerImplTest {
             assertThat(stats1.mNumberOfAppsUnchanged).isEqualTo(0); // No apps unchanged
             assertThat(stats1.mNumberOfAppsUpdated).isEqualTo(0); // No apps updated
 
-            // Currently we are logging added and updated and unchanged all as updated
-            assertThat(stats1.mNumberOfFunctionsUpdated).isEqualTo(15); // One app updated
-            assertThat(stats1.mNumberOfFunctionsAdded).isEqualTo(0);
+            assertThat(stats1.mNumberOfFunctionsUpdated).isEqualTo(0);
+            assertThat(stats1.mNumberOfFunctionsAdded).isEqualTo(15);
             assertThat(stats1.mApproximateNumberOfFunctionsRemoved).isEqualTo(0);
-            assertThat(stats1.mApproximateNumberOfFunctionsUnchanged).isEqualTo(0);
 
-            List<GenericDocument> indexedFunctions =
-                    mAppSearchHelper.getAppFunctionsFromAppSearch();
             List<String> indexedFunctionIds = new ArrayList<>();
-            for (int i = 0; i < indexedFunctions.size(); i++) {
-                indexedFunctionIds.add(indexedFunctions.get(i).getId());
+            Map<String, Map<String, AppFunctionDocument>> indexedFunctions =
+                    mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(new ArraySet<>(packages));
+            for (Map<String, AppFunctionDocument> functions : indexedFunctions.values()) {
+                for (AppFunctionDocument function : functions.values()) {
+                    indexedFunctionIds.add(function.getId());
+                }
             }
             // Verify the state of the indexed apps after the first update
             assertThat(indexedFunctionIds).containsExactlyElementsIn(expectedFunctionIds);
@@ -348,8 +370,10 @@ public class AppsIndexerImplTest {
 
         try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
             AppsUpdateStats stats1 = new AppsUpdateStats();
-            appsIndexerImpl.doUpdate(
-                    new AppsIndexerSettings(temporaryFolder.newFolder("temp2")), stats1);
+            appsIndexerImpl.doUpdateIncrementalPut(
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp2")),
+                    stats1,
+                    /* isFullUpdateRequired= */ false);
 
             // Check the stats object after the first update
             assertThat(stats1.mNumberOfAppsAdded).isEqualTo(0);
@@ -357,17 +381,17 @@ public class AppsIndexerImplTest {
             assertThat(stats1.mNumberOfAppsUnchanged).isEqualTo(0);
             assertThat(stats1.mNumberOfAppsUpdated).isEqualTo(5);
 
-            // Currently we are logging added and updated and unchanged all as updated
-            assertThat(stats1.mNumberOfFunctionsUpdated).isEqualTo(15);
+            assertThat(stats1.mNumberOfFunctionsUpdated).isEqualTo(5);
             assertThat(stats1.mApproximateNumberOfFunctionsRemoved).isEqualTo(5);
-            assertThat(stats1.mNumberOfFunctionsAdded).isEqualTo(0);
-            assertThat(stats1.mApproximateNumberOfFunctionsUnchanged).isEqualTo(0);
+            assertThat(stats1.mNumberOfFunctionsAdded).isEqualTo(5);
 
-            List<GenericDocument> indexedFunctions =
-                    mAppSearchHelper.getAppFunctionsFromAppSearch();
             List<String> indexedFunctionIds = new ArrayList<>();
-            for (int i = 0; i < indexedFunctions.size(); i++) {
-                indexedFunctionIds.add(indexedFunctions.get(i).getId());
+            Map<String, Map<String, AppFunctionDocument>> indexedFunctions =
+                    mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(new ArraySet<>(packages));
+            for (Map<String, AppFunctionDocument> functions : indexedFunctions.values()) {
+                for (AppFunctionDocument function : functions.values()) {
+                    indexedFunctionIds.add(function.getId());
+                }
             }
             // Verify the state of the indexed apps after the first update
             assertThat(indexedFunctionIds).containsExactlyElementsIn(expectedFunctionIds);
@@ -388,8 +412,10 @@ public class AppsIndexerImplTest {
         // Perform the first update
         try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
             AppsUpdateStats stats = new AppsUpdateStats();
-            appsIndexerImpl.doUpdate(
-                    new AppsIndexerSettings(temporaryFolder.newFolder("temp1")), stats);
+            appsIndexerImpl.doUpdateIncrementalPut(
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp1")),
+                    stats,
+                    /* isFullUpdateRequired= */ true);
 
             // Check the stats object after the first update
             assertThat(stats.mNumberOfAppsAdded).isEqualTo(3); // Three new apps added
@@ -473,6 +499,10 @@ public class AppsIndexerImplTest {
             assertThat(stats1.mNumberOfAppsUnchanged).isEqualTo(0);
             assertThat(stats1.mNumberOfAppsUpdated).isEqualTo(0);
 
+            assertThat(stats1.mNumberOfFunctionsUpdated).isEqualTo(0);
+            assertThat(stats1.mApproximateNumberOfFunctionsRemoved).isEqualTo(0);
+            assertThat(stats1.mNumberOfFunctionsAdded).isEqualTo(1);
+
             // Verify the state of the indexed apps after the first update
             assertThat(mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(packages).keySet())
                     .containsExactlyElementsIn(packages);
@@ -520,6 +550,10 @@ public class AppsIndexerImplTest {
             assertThat(stats1.mNumberOfAppsUnchanged).isEqualTo(0);
             assertThat(stats1.mNumberOfAppsUpdated).isEqualTo(1);
 
+            assertThat(stats1.mNumberOfFunctionsUpdated).isEqualTo(0);
+            assertThat(stats1.mApproximateNumberOfFunctionsRemoved).isEqualTo(0);
+            assertThat(stats1.mNumberOfFunctionsAdded).isEqualTo(1);
+
             assertThat(mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(packages).keySet())
                     .containsExactlyElementsIn(packages);
         }
@@ -572,6 +606,10 @@ public class AppsIndexerImplTest {
                     new AppsIndexerSettings(temporaryFolder.newFolder("temp1")),
                     stats1,
                     /* isFullUpdateRequired= */ false);
+
+            assertThat(stats1.mNumberOfFunctionsUpdated).isEqualTo(0);
+            assertThat(stats1.mApproximateNumberOfFunctionsRemoved).isEqualTo(0);
+            assertThat(stats1.mNumberOfFunctionsAdded).isEqualTo(1);
         }
 
         // Simulate an update
@@ -590,6 +628,9 @@ public class AppsIndexerImplTest {
                     new AppsIndexerSettings(temporaryFolder.newFolder("temp2")),
                     stats1,
                     /* isFullUpdateRequired= */ false);
+            assertThat(stats1.mNumberOfFunctionsUpdated).isEqualTo(0);
+            assertThat(stats1.mApproximateNumberOfFunctionsRemoved).isEqualTo(1);
+            assertThat(stats1.mNumberOfFunctionsAdded).isEqualTo(0);
         }
 
         assertThat(mAppSearchHelper.getAppFunctionDocumentsFromAppSearch(packages).keySet())
@@ -1164,7 +1205,11 @@ public class AppsIndexerImplTest {
             assertThat(stats1.mNumberOfAppsUpdated).isEqualTo(0); // No apps updated
 
             // Verify the state of the indexed apps after the first update
-            assertThat(mAppSearchHelper.getAppsFromAppSearch().keySet())
+            Set<String> ids =
+                    mAppSearchHelper
+                            .getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch()
+                            .keySet();
+            assertThat(ids)
                     .containsExactly("com.fake.package0", "com.fake.package1", "com.fake.package2");
         }
 
@@ -1193,7 +1238,11 @@ public class AppsIndexerImplTest {
             assertThat(stats2.mNumberOfAppsUpdated).isEqualTo(2); // Two apps updated
 
             // Verify the state of the indexed apps after the second update
-            assertThat(mAppSearchHelper.getAppsFromAppSearch().keySet())
+            Set<String> ids =
+                    mAppSearchHelper
+                            .getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch()
+                            .keySet();
+            assertThat(ids)
                     .containsExactly("com.fake.package0", "com.fake.package1", "com.fake.package2");
         }
     }
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerManagerServiceTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerManagerServiceTest.java
index e9cd6422..2176b13e 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerManagerServiceTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerManagerServiceTest.java
@@ -87,7 +87,6 @@ public class AppsIndexerManagerServiceTest extends AppsIndexerTestBase {
     private BroadcastReceiver mCapturedReceiver;
     // Saving to class so we can unregister the callback
     private final PackageManager mPackageManager = Mockito.mock(PackageManager.class);
-    private GlobalSearchSessionShim mShim;
 
     @Before
     @Override
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerUserInstanceTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerUserInstanceTest.java
index 39b743c6..8f733c9e 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerUserInstanceTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerUserInstanceTest.java
@@ -45,6 +45,7 @@ import android.app.job.JobScheduler;
 import android.content.Context;
 import android.content.ContextWrapper;
 import android.content.pm.PackageManager;
+import android.os.Build;
 import android.os.PersistableBundle;
 import android.os.UserHandle;
 import android.platform.test.annotations.RequiresFlagsDisabled;
@@ -53,6 +54,7 @@ import android.platform.test.annotations.RequiresFlagsEnabled;
 import androidx.test.core.app.ApplicationProvider;
 
 import com.android.appsearch.flags.Flags;
+import com.android.server.appsearch.appsindexer.appsearchtypes.MobileApplication;
 import com.android.server.appsearch.indexer.IndexerSettings;
 
 import com.google.common.collect.ImmutableList;
@@ -66,6 +68,8 @@ import org.junit.rules.TemporaryFolder;
 import org.mockito.ArgumentCaptor;
 
 import java.io.File;
+import java.time.Duration;
+import java.util.Arrays;
 import java.util.Map;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executors;
@@ -76,6 +80,9 @@ import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
 public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
+
+    private static final Duration UPDATE_ASYNC_TIMEOUT = Duration.ofSeconds(2);
+
     private TestContext mTestContext;
     private final PackageManager mMockPackageManager = mock(PackageManager.class);
 
@@ -152,20 +159,17 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
                 /* appFunctionServices= */ ImmutableList.of());
 
         // Wait for file setup, as file setup uses the same ExecutorService.
-        semaphore.acquire();
+        assertThat(semaphore.tryAcquire(UPDATE_ASYNC_TIMEOUT.toSeconds(), TimeUnit.SECONDS))
+                .isTrue();
 
-        long beforeFirstRun = mSingleThreadedExecutor.getCompletedTaskCount();
-
-        mInstance.updateAsync(true);
-        semaphore.acquire();
-
-        while (mSingleThreadedExecutor.getCompletedTaskCount() != beforeFirstRun + 1) {
-            Thread.sleep(100);
-        }
+        mInstance.updateAsync(/* firstRun= */ true);
+        // Wait for the task to finish
+        assertThat(semaphore.tryAcquire(UPDATE_ASYNC_TIMEOUT.toSeconds(), TimeUnit.SECONDS))
+                .isTrue();
 
-        assertThat(mSingleThreadedExecutor.getCompletedTaskCount()).isEqualTo(beforeFirstRun + 1);
         try (AppSearchHelper searchHelper = new AppSearchHelper(mTestContext)) {
-            Map<String, Long> appsTimestampMap = searchHelper.getAppsFromAppSearch();
+            Map<String, MobileApplication> appsTimestampMap =
+                    searchHelper.getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch();
             assertThat(appsTimestampMap).hasSize(1);
             assertThat(appsTimestampMap.keySet()).containsExactly("com.fake.package0");
         }
@@ -178,6 +182,8 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
         AppsIndexerSettings settings = new AppsIndexerSettings(mAppsDir);
         mAppsDir.mkdirs();
         settings.setLastUpdateTimestampMillis(1000);
+        settings.setLastPartitionFingerprintsSortedByPartitionName(
+                Build.getFingerprintedPartitions());
         settings.persist();
 
         // This semaphore allows us to pause test execution until we're sure the tasks in
@@ -208,26 +214,21 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
                 /* appFunctionServices= */ ImmutableList.of());
 
         // Wait for file setup, as file setup uses the same ExecutorService.
-        semaphore.acquire();
+        assertThat(semaphore.tryAcquire(UPDATE_ASYNC_TIMEOUT.toSeconds(), TimeUnit.SECONDS))
+                .isTrue();
 
-        long beforeFirstRun = mSingleThreadedExecutor.getCompletedTaskCount();
+        mInstance.updateAsync(/* firstRun= */ true);
 
-        mInstance.updateAsync(true);
         // Wait for the task to finish
-        semaphore.acquire();
-
-        while (mSingleThreadedExecutor.getCompletedTaskCount() != beforeFirstRun + 1) {
-            Thread.sleep(100);
-        }
-        // One more task should've ran, checked settings, and exited
-        assertThat(mSingleThreadedExecutor.getActiveCount()).isEqualTo(0);
-        assertThat(mSingleThreadedExecutor.getTaskCount()).isEqualTo(beforeFirstRun + 1);
-        assertThat(mSingleThreadedExecutor.getCompletedTaskCount()).isEqualTo(beforeFirstRun + 1);
+        assertThat(semaphore.tryAcquire(UPDATE_ASYNC_TIMEOUT.toSeconds(), TimeUnit.SECONDS))
+                .isTrue();
 
         // Even though a task ran and we got 1 app ready, we requested a "firstRun" but the
         // timestamp was not 0, so nothing should've been indexed
         try (AppSearchHelper searchHelper = new AppSearchHelper(mTestContext)) {
-            assertThat(searchHelper.getAppsFromAppSearch()).isEmpty();
+            Map<String, MobileApplication> apps =
+                    searchHelper.getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch();
+            assertThat(apps).isEmpty();
         }
     }
 
@@ -262,12 +263,14 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
                 /* appFunctionServices= */ ImmutableList.of());
 
         // Wait for file setup, as file setup uses the same ExecutorService.
-        semaphore.acquire();
+        assertThat(semaphore.tryAcquire(UPDATE_ASYNC_TIMEOUT.toSeconds(), TimeUnit.SECONDS))
+                .isTrue();
 
-        mInstance.updateAsync(true);
+        mInstance.updateAsync(/* firstRun= */ true);
 
         // Wait for the task to finish
-        semaphore.acquire();
+        assertThat(semaphore.tryAcquire(UPDATE_ASYNC_TIMEOUT.toSeconds(), TimeUnit.SECONDS))
+                .isTrue();
 
         AppsIndexerSettings settings = new AppsIndexerSettings(mAppsDir);
         settings.load();
@@ -310,12 +313,13 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
                 /* appFunctionServices= */ ImmutableList.of());
 
         // Wait for file setup, as file setup uses the same ExecutorService.
-        semaphore.acquire();
-
-        mInstance.updateAsync(true);
+        assertThat(semaphore.tryAcquire(UPDATE_ASYNC_TIMEOUT.toSeconds(), TimeUnit.SECONDS))
+                .isTrue();
 
+        mInstance.updateAsync(/* firstRun= */ true);
         // Wait for the task to finish
-        semaphore.acquire();
+        assertThat(semaphore.tryAcquire(UPDATE_ASYNC_TIMEOUT.toSeconds(), TimeUnit.SECONDS))
+                .isTrue();
 
         settings = new AppsIndexerSettings(mAppsDir);
         settings.load();
@@ -355,12 +359,14 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
                 /* appFunctionServices= */ ImmutableList.of());
 
         // Wait for file setup, as file setup uses the same ExecutorService.
-        semaphore.acquire();
+        assertThat(semaphore.tryAcquire(UPDATE_ASYNC_TIMEOUT.toSeconds(), TimeUnit.SECONDS))
+                .isTrue();
 
-        mInstance.updateAsync(true);
+        mInstance.updateAsync(/* firstRun= */ true);
 
         // Wait for the task to finish
-        semaphore.acquire();
+        assertThat(semaphore.tryAcquire(UPDATE_ASYNC_TIMEOUT.toSeconds(), TimeUnit.SECONDS))
+                .isTrue();
 
         AppsIndexerSettings settings = new AppsIndexerSettings(mAppsDir);
         settings.load();
@@ -399,12 +405,13 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
                 /* appFunctionServices= */ ImmutableList.of());
 
         // Wait for file setup, as file setup uses the same ExecutorService.
-        semaphore.acquire();
-
-        mInstance.updateAsync(true);
+        assertThat(semaphore.tryAcquire(UPDATE_ASYNC_TIMEOUT.toSeconds(), TimeUnit.SECONDS))
+                .isTrue();
 
+        mInstance.updateAsync(/* firstRun= */ true);
         // Wait for the task to finish
-        semaphore.acquire();
+        assertThat(semaphore.tryAcquire(UPDATE_ASYNC_TIMEOUT.toSeconds(), TimeUnit.SECONDS))
+                .isTrue();
 
         AppsIndexerSettings settings = new AppsIndexerSettings(mAppsDir);
         settings.load();
@@ -436,6 +443,123 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
                                 + new TestAppsIndexerConfig().getMinTimeBetweenFirstSyncsMillis());
     }
 
+    @Test
+    public void testFirstRun_withOtaUpdate_updateAlreadyRan_indexesApp() throws Exception {
+        // Pretend we already ran with no fingerprints set.
+        AppsIndexerSettings settings = new AppsIndexerSettings(mAppsDir);
+        mAppsDir.mkdirs();
+        settings.setLastUpdateTimestampMillis(1000);
+        settings.setPreviousIndexerVersionCode(CURR_APP_INDEXER_VERSION);
+        settings.persist();
+
+        // This semaphore allows us to pause test execution until we're sure the tasks in
+        // AppsIndexerUserInstance are finished.
+        final Semaphore semaphore = new Semaphore(0);
+        mSingleThreadedExecutor =
+                new ThreadPoolExecutor(
+                        /* corePoolSize= */ 1,
+                        /* maximumPoolSize= */ 1,
+                        /* KeepAliveTime= */ 0L,
+                        TimeUnit.MILLISECONDS,
+                        new LinkedBlockingQueue<>()) {
+                    @Override
+                    protected void afterExecute(Runnable r, Throwable t) {
+                        super.afterExecute(r, t);
+                        semaphore.release();
+                    }
+                };
+        mInstance =
+                AppsIndexerUserInstance.createInstance(
+                        mTestContext, mAppsDir, mAppsIndexerConfig, mSingleThreadedExecutor);
+
+        // Pretend there's one package on device
+        setupMockPackageManager(
+                mMockPackageManager,
+                createFakePackageInfos(1),
+                createFakeResolveInfos(1),
+                /* appFunctionServices= */ ImmutableList.of());
+
+        // Wait for settings file initialization as it uses the same executor service.
+        assertThat(semaphore.tryAcquire(UPDATE_ASYNC_TIMEOUT.toSeconds(), TimeUnit.SECONDS))
+                .isTrue();
+
+        mInstance.updateAsync(/* firstRun= */ true);
+        // Wait for the task to finish
+        assertThat(semaphore.tryAcquire(UPDATE_ASYNC_TIMEOUT.toSeconds(), TimeUnit.SECONDS))
+                .isTrue();
+
+        try (AppSearchHelper searchHelper = new AppSearchHelper(mTestContext)) {
+            Map<String, MobileApplication> appsTimestampMap =
+                    searchHelper.getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch();
+            assertThat(appsTimestampMap.keySet()).containsExactly("com.fake.package0");
+        }
+        // Last joined partition fingerprint is updated in settings.
+        AppsIndexerSettings currSettings = new AppsIndexerSettings(mAppsDir);
+        currSettings.load();
+        assertThat(Arrays.asList(currSettings.getLastPartitionFingerprintsSortedByPartitionName()))
+                .containsExactlyElementsIn(
+                        Build.getFingerprintedPartitions().stream()
+                                .map(partition -> partition.getFingerprint())
+                                .toArray());
+    }
+
+    @Test
+    public void testFirstRun_noOtaUpdate_updateAlreadyRan_doesNotIndex() throws Exception {
+        // Pretend we already ran with the current partition fingerprints.
+        AppsIndexerSettings settings = new AppsIndexerSettings(mAppsDir);
+        mAppsDir.mkdirs();
+        settings.setLastUpdateTimestampMillis(1000);
+        settings.setLastPartitionFingerprintsSortedByPartitionName(
+                Build.getFingerprintedPartitions());
+        settings.setPreviousIndexerVersionCode(CURR_APP_INDEXER_VERSION);
+        settings.persist();
+
+        // This semaphore allows us to pause test execution until we're sure the tasks in
+        // AppsIndexerUserInstance are finished.
+        final Semaphore semaphore = new Semaphore(0);
+        mSingleThreadedExecutor =
+                new ThreadPoolExecutor(
+                        /* corePoolSize= */ 1,
+                        /* maximumPoolSize= */ 1,
+                        /* KeepAliveTime= */ 0L,
+                        TimeUnit.MILLISECONDS,
+                        new LinkedBlockingQueue<>()) {
+                    @Override
+                    protected void afterExecute(Runnable r, Throwable t) {
+                        super.afterExecute(r, t);
+                        semaphore.release();
+                    }
+                };
+        mInstance =
+                AppsIndexerUserInstance.createInstance(
+                        mTestContext, mAppsDir, mAppsIndexerConfig, mSingleThreadedExecutor);
+
+        // Pretend there's one package on device
+        setupMockPackageManager(
+                mMockPackageManager,
+                createFakePackageInfos(1),
+                createFakeResolveInfos(1),
+                /* appFunctionServices= */ ImmutableList.of());
+
+        // Wait for settings file initialization as it uses the same executor service.
+        assertThat(semaphore.tryAcquire(UPDATE_ASYNC_TIMEOUT.toSeconds(), TimeUnit.SECONDS))
+                .isTrue();
+
+        mInstance.updateAsync(/* firstRun= */ true);
+
+        // Wait for the task to finish
+        assertThat(semaphore.tryAcquire(UPDATE_ASYNC_TIMEOUT.toSeconds(), TimeUnit.SECONDS))
+                .isTrue();
+
+        // Even though a task ran and we got 1 app ready, we requested a "firstRun" but the
+        // fingerprint string didn't change, so nothing should've been indexed
+        try (AppSearchHelper searchHelper = new AppSearchHelper(mTestContext)) {
+            Map<String, MobileApplication> apps =
+                    searchHelper.getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch();
+            assertThat(apps).isEmpty();
+        }
+    }
+
     @Test
     @RequiresFlagsEnabled(Flags.FLAG_ENABLE_ALL_PACKAGE_INDEXING_ON_INDEXER_UPDATE)
     public void testFirstRun_withIndexerUpdate_updateAlreadyRan_indexesApp() throws Exception {
@@ -474,24 +598,18 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
                 /* appFunctionServices= */ ImmutableList.of());
 
         // Wait for file setup, as file setup uses the same ExecutorService.
-        semaphore.acquire();
-
-        long beforeFirstRun = mSingleThreadedExecutor.getCompletedTaskCount();
+        assertThat(semaphore.tryAcquire(UPDATE_ASYNC_TIMEOUT.toSeconds(), TimeUnit.SECONDS))
+                .isTrue();
 
         mInstance.updateAsync(/* firstRun= */ true);
-        // Wait for the task to finish
-        semaphore.acquire();
 
-        while (mSingleThreadedExecutor.getCompletedTaskCount() != beforeFirstRun + 1) {
-            Thread.sleep(100);
-        }
+        // Wait for the task to finish
+        assertThat(semaphore.tryAcquire(UPDATE_ASYNC_TIMEOUT.toSeconds(), TimeUnit.SECONDS))
+                .isTrue();
 
-        // One more task should've ran and indexed the functions.
-        assertThat(mSingleThreadedExecutor.getActiveCount()).isEqualTo(0);
-        assertThat(mSingleThreadedExecutor.getTaskCount()).isEqualTo(beforeFirstRun + 1);
-        assertThat(mSingleThreadedExecutor.getCompletedTaskCount()).isEqualTo(beforeFirstRun + 1);
         try (AppSearchHelper searchHelper = new AppSearchHelper(mTestContext)) {
-            Map<String, Long> appsTimestampMap = searchHelper.getAppsFromAppSearch();
+            Map<String, MobileApplication> appsTimestampMap =
+                    searchHelper.getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch();
             assertThat(appsTimestampMap).hasSize(1);
             assertThat(appsTimestampMap.keySet()).containsExactly("com.fake.package0");
         }
@@ -509,6 +627,8 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
         AppsIndexerSettings settings = new AppsIndexerSettings(mAppsDir);
         mAppsDir.mkdirs();
         settings.setLastUpdateTimestampMillis(1000);
+        settings.setLastPartitionFingerprintsSortedByPartitionName(
+                Build.getFingerprintedPartitions());
         settings.setPreviousIndexerVersionCode(CURR_APP_INDEXER_VERSION);
         settings.persist();
 
@@ -540,26 +660,21 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
                 /* appFunctionServices= */ ImmutableList.of());
 
         // Wait for file setup, as file setup uses the same ExecutorService.
-        semaphore.acquire();
-
-        long beforeFirstRun = mSingleThreadedExecutor.getCompletedTaskCount();
+        assertThat(semaphore.tryAcquire(UPDATE_ASYNC_TIMEOUT.toSeconds(), TimeUnit.SECONDS))
+                .isTrue();
 
         mInstance.updateAsync(/* firstRun= */ true);
-        // Wait for the task to finish
-        semaphore.acquire();
 
-        while (mSingleThreadedExecutor.getCompletedTaskCount() != beforeFirstRun + 1) {
-            Thread.sleep(100);
-        }
-        // One more task should've ran, checked settings, and exited
-        assertThat(mSingleThreadedExecutor.getActiveCount()).isEqualTo(0);
-        assertThat(mSingleThreadedExecutor.getTaskCount()).isEqualTo(beforeFirstRun + 1);
-        assertThat(mSingleThreadedExecutor.getCompletedTaskCount()).isEqualTo(beforeFirstRun + 1);
+        // Wait for the task to finish
+        assertThat(semaphore.tryAcquire(UPDATE_ASYNC_TIMEOUT.toSeconds(), TimeUnit.SECONDS))
+                .isTrue();
 
         // Even though a task ran and we got 1 app ready, we requested a "firstRun" but the
         // timestamp was not 0, so nothing should've been indexed
         try (AppSearchHelper searchHelper = new AppSearchHelper(mTestContext)) {
-            assertThat(searchHelper.getAppsFromAppSearch()).isEmpty();
+            Map<String, MobileApplication> apps =
+                    searchHelper.getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch();
+            assertThat(apps).isEmpty();
         }
     }
 
@@ -755,7 +870,8 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
         latch.await(10, TimeUnit.SECONDS);
 
         AppSearchHelper searchHelper = new AppSearchHelper(mTestContext);
-        Map<String, Long> appIds = searchHelper.getAppsFromAppSearch();
+        Map<String, MobileApplication> appIds =
+                searchHelper.getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch();
         assertThat(appIds.size()).isEqualTo(docCount);
     }
 
@@ -794,7 +910,8 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
         mInstance.doUpdate(/* firstRun= */ false, new AppsUpdateStats());
 
         AppSearchHelper searchHelper = new AppSearchHelper(mTestContext);
-        Map<String, Long> appIds = searchHelper.getAppsFromAppSearch();
+        Map<String, MobileApplication> appIds =
+                searchHelper.getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch();
         assertThat(appIds.size()).isEqualTo(10);
 
         setupMockPackageManager(
@@ -806,7 +923,7 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
         mInstance.doUpdate(/* firstRun= */ false, new AppsUpdateStats());
 
         searchHelper = new AppSearchHelper(mTestContext);
-        appIds = searchHelper.getAppsFromAppSearch();
+        appIds = searchHelper.getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch();
         assertThat(appIds.size()).isEqualTo(6);
         assertThat(appIds.keySet())
                 .containsNoneOf(
@@ -1086,7 +1203,8 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
         afterSemaphore.acquire();
 
         AppSearchHelper searchHelper = new AppSearchHelper(mTestContext);
-        Map<String, Long> appIds = searchHelper.getAppsFromAppSearch();
+        Map<String, MobileApplication> appIds =
+                searchHelper.getAppsLastUpdatedTimeAndAppFunctionServiceEnabledFromAppSearch();
         assertThat(appIds.size()).isEqualTo(250);
 
         PersistableBundle settingsBundle = AppsIndexerSettings.readBundle(mSettingsFile);
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsUtilTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsUtilTest.java
index 5abc87e6..022ed0c6 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsUtilTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsUtilTest.java
@@ -25,25 +25,19 @@ import static com.android.server.appsearch.appsindexer.TestUtils.setupMockPackag
 
 import static com.google.common.truth.Truth.assertThat;
 
-import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyLong;
-import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.when;
 
 import android.app.usage.UsageEvents;
 import android.app.usage.UsageStatsManager;
-import android.content.ComponentName;
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
-import android.content.res.AssetManager;
-import android.content.res.Resources;
 import android.util.ArrayMap;
 
 import androidx.test.core.app.ApplicationProvider;
 
-import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppOpenEvent;
 import com.android.server.appsearch.appsindexer.appsearchtypes.MobileApplication;
 
@@ -52,7 +46,6 @@ import com.google.common.collect.ImmutableList;
 import org.junit.Test;
 import org.mockito.Mockito;
 
-import java.io.ByteArrayInputStream;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.List;
@@ -185,53 +178,4 @@ public class AppsUtilTest {
                                     .packageName);
         }
     }
-
-    @Test
-    public void testBuildAppFunctionStaticMetadata() throws Exception {
-        PackageManager pm = Mockito.mock(PackageManager.class);
-        List<PackageInfo> fakePackages = new ArrayList<>();
-        List<ResolveInfo> fakeActivities = new ArrayList<>();
-        List<ResolveInfo> fakeAppFunctionServices = new ArrayList<>();
-
-        for (int i = 0; i < 10; i++) {
-            fakePackages.add(createFakePackageInfo(i));
-            fakeActivities.add(createFakeLaunchResolveInfo(i));
-            fakeAppFunctionServices.add(createFakeAppFunctionResolveInfo(i));
-        }
-
-        // Set up mocking
-        when(pm.getProperty(any(String.class), any(ComponentName.class)))
-                .thenReturn(new PackageManager.Property("", "", "", ""));
-        AssetManager assetManager = Mockito.mock(AssetManager.class);
-
-        when(assetManager.open(any())).thenReturn(new ByteArrayInputStream("".getBytes()));
-
-        Resources resources = Mockito.mock(Resources.class);
-        when(resources.getAssets()).thenReturn(assetManager);
-        when(pm.getResourcesForApplication(any(String.class))).thenReturn(resources);
-
-        setupMockPackageManager(pm, fakePackages, fakeActivities, fakeAppFunctionServices);
-
-        AppFunctionDocumentParser parser = Mockito.mock(AppFunctionDocumentParser.class);
-        for (PackageInfo packageInfo : fakePackages) {
-            when(parser.parse(any(), eq(packageInfo.packageName), any()))
-                    .thenReturn(
-                            ImmutableList.of(
-                                    new AppFunctionStaticMetadata.Builder(
-                                                    packageInfo.packageName,
-                                                    /* functionId= */ "com.example.utils#print",
-                                                    /* indexerPackageName= */ "android")
-                                            .build()));
-        }
-
-        Map<PackageInfo, ResolveInfos> packageActivityMapping = AppsUtil.getPackagesToIndex(pm);
-
-        List<AppFunctionStaticMetadata> resultAppFunctions =
-                AppsUtil.buildAppFunctionStaticMetadata(pm, packageActivityMapping, parser);
-
-        assertThat(resultAppFunctions).hasSize(10);
-        for (AppFunctionStaticMetadata appFunction : resultAppFunctions) {
-            assertThat(appFunction.getFunctionId()).isEqualTo("com.example.utils#print");
-        }
-    }
 }
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestAppOpenEventIndexerConfig.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestAppOpenEventIndexerConfig.java
index ac7359f5..c42fe334 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestAppOpenEventIndexerConfig.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestAppOpenEventIndexerConfig.java
@@ -31,4 +31,14 @@ public class TestAppOpenEventIndexerConfig implements AppOpenEventIndexerConfig
     public long getMinTimeBetweenSyncsMillis() {
         return 100L;
     }
+
+    @Override
+    public boolean isLoggingEnabled() {
+        return true;
+    }
+
+    @Override
+    public int getLoggingSamplingRate() {
+        return 10;
+    }
 }
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestUtils.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestUtils.java
index 90196ab6..faf0e85c 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestUtils.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestUtils.java
@@ -285,6 +285,7 @@ class TestUtils {
         String pkgName = FAKE_PACKAGE_PREFIX + variant;
         ResolveInfo mockResolveInfo = new ResolveInfo();
         mockResolveInfo.serviceInfo = new ServiceInfo();
+        mockResolveInfo.serviceInfo.applicationInfo = new ApplicationInfo();
         mockResolveInfo.serviceInfo.packageName = pkgName;
         mockResolveInfo.serviceInfo.name = pkgName + ".FakeActivity";
 
diff --git a/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsIndexerMaintenanceTest.java b/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsIndexerMaintenanceTest.java
index d5006971..73bf9c7c 100644
--- a/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsIndexerMaintenanceTest.java
+++ b/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsIndexerMaintenanceTest.java
@@ -37,8 +37,8 @@ import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
 
 import android.annotation.UserIdInt;
-import android.app.appsearch.testutil.TestContactsIndexerConfig;
 import android.app.UiAutomation;
+import android.app.appsearch.testutil.TestContactsIndexerConfig;
 import android.app.job.JobInfo;
 import android.app.job.JobParameters;
 import android.app.job.JobScheduler;
@@ -467,16 +467,14 @@ public class ContactsIndexerMaintenanceTest {
                     .isEqualTo(-1);
 
             verify(mockLocalService, timeout(10000L)).doUpdateForUser(any(), any());
+
             // Scheduler should be called after the update is done and we re-schedule the job
-            verify(spyScheduler, timeout(10000L)).schedule(any(JobInfo.class));
+            ArgumentCaptor<JobInfo> jobInfoCaptor = ArgumentCaptor.forClass(JobInfo.class);
+            verify(spyScheduler, timeout(10000L)).schedule(jobInfoCaptor.capture());
 
             // It should be rescheduled with the proper extra value.
-            assertThat(
-                            jobScheduler
-                                    .getPendingJob(MIN_CONTACTS_INDEXER_JOB_ID + DEFAULT_USER_ID)
-                                    .getExtras()
-                                    .getInt("indexer_type", -1))
-                    .isEqualTo(CONTACTS_INDEXER);
+            assertThat(jobInfoCaptor.getValue().getExtras().getInt("indexer_type", -1)).isEqualTo(
+                    CONTACTS_INDEXER);
         } finally {
             uiAutomation.dropShellPermissionIdentity();
         }
diff --git a/testing/coretests/src/android/app/appsearch/external/app/AppSearchSchemaInternalTest.java b/testing/coretests/src/android/app/appsearch/external/app/AppSearchSchemaInternalTest.java
index 2a83cf8f..6733afbe 100644
--- a/testing/coretests/src/android/app/appsearch/external/app/AppSearchSchemaInternalTest.java
+++ b/testing/coretests/src/android/app/appsearch/external/app/AppSearchSchemaInternalTest.java
@@ -108,7 +108,7 @@ public class AppSearchSchemaInternalTest {
                 .hasMessageThat()
                 .contains(
                         "Cannot set delete propagation without setting"
-                                + " JOINABLE_VALUE_TYPE_QUALIFIED_ID.");
+                            + " JOINABLE_VALUE_TYPE_QUALIFIED_ID.");
     }
 
     @Test
diff --git a/testing/coretests/src/android/app/appsearch/external/flags/FlagsTest.java b/testing/coretests/src/android/app/appsearch/external/flags/FlagsTest.java
index 36efc3a8..c749933a 100644
--- a/testing/coretests/src/android/app/appsearch/external/flags/FlagsTest.java
+++ b/testing/coretests/src/android/app/appsearch/external/flags/FlagsTest.java
@@ -240,4 +240,67 @@ public class FlagsTest {
         assertThat(Flags.FLAG_ENABLE_EMBEDDING_MATCH_INFO)
                 .isEqualTo("com.android.appsearch.flags.enable_embedding_match_info");
     }
+
+    @Test
+    public void testFlagValue_enableQueryVisibilityDocuments() {
+        assertThat(Flags.FLAG_ENABLE_QUERY_VISIBILITY_DOCUMENTS)
+                .isEqualTo("com.android.appsearch.flags.enable_query_visibility_documents");
+    }
+
+    @Test
+    public void testFlagValue_enableStrictPageByteSizeLimit() {
+        assertThat(Flags.FLAG_ENABLE_STRICT_PAGE_BYTE_SIZE_LIMIT)
+                .isEqualTo("com.android.appsearch.flags.enable_strict_page_byte_size_limit");
+    }
+
+    @Test
+    public void testFlagValue_enableCompressionThreshold() {
+        assertThat(Flags.FLAG_ENABLE_COMPRESSION_THRESHOLD)
+                .isEqualTo("com.android.appsearch.flags.enable_compression_threshold");
+    }
+
+    @Test
+    public void testFlagValue_enableCompressionMemLevelOne() {
+        assertThat(Flags.FLAG_ENABLE_COMPRESSION_MEM_LEVEL_ONE)
+                .isEqualTo("com.android.appsearch.flags.enable_compression_mem_level_one");
+    }
+
+    @Test
+    public void testFlagValue_enableResultAborted() {
+        assertThat(Flags.FLAG_ENABLE_RESULT_ABORTED)
+                .isEqualTo("com.android.appsearch.flags.enable_result_aborted");
+    }
+
+    @Test
+    public void testFlagValue_enableThrowExceptionForNativeNotFoundPageToken() {
+        assertThat(Flags.FLAG_ENABLE_THROW_EXCEPTION_FOR_NATIVE_NOT_FOUND_PAGE_TOKEN)
+                .isEqualTo(
+                        "com.android.appsearch.flags"
+                                + ".enable_throw_exception_for_native_not_found_page_token");
+    }
+
+    @Test
+    public void testFlagValue_enableDatabaseScopedSchemaOperations() {
+        assertThat(Flags.FLAG_ENABLE_DATABASE_SCOPED_SCHEMA_OPERATIONS)
+                .isEqualTo("com.android.appsearch.flags.enable_database_scoped_schema_operations");
+    }
+
+    @Test
+    public void testFlagValue_enableSmallerDecompressionBufferSize() {
+        assertThat(Flags.FLAG_ENABLE_SMALLER_DECOMPRESSION_BUFFER_SIZE)
+                .isEqualTo("com.android.appsearch.flags.enable_smaller_decompression_buffer_size");
+    }
+
+    @Test
+    public void testFlagValue_enableEigenEmbeddingScoring() {
+        assertThat(Flags.FLAG_ENABLE_EIGEN_EMBEDDING_SCORING)
+                .isEqualTo("com.android.appsearch.flags.enable_eigen_embedding_scoring");
+    }
+
+    @Test
+    public void testFlagValue_enableInitializationRetriesBeforeReset() {
+        assertThat(Flags.FLAG_ENABLE_INITIALIZATION_RETRIES_BEFORE_RESET)
+                .isEqualTo(
+                        "com.android.appsearch.flags.enable_initialization_retries_before_reset");
+    }
 }
diff --git a/testing/mem.pbtx b/testing/mem.pbtx
new file mode 100644
index 00000000..5b16d707
--- /dev/null
+++ b/testing/mem.pbtx
@@ -0,0 +1,102 @@
+buffers: {
+    size_kb: 262144
+    fill_policy: RING_BUFFER
+}
+data_sources: {
+  config {
+    name: "linux.system_info"
+    target_buffer: 0
+  }
+}
+data_sources: {
+    config {
+        name: "linux.process_stats"
+        process_stats_config {
+            scan_all_processes_on_start: true
+            proc_stats_poll_ms: 250
+        }
+    }
+}
+data_sources: {
+    config {
+        name: "android.surfaceflinger.frametimeline"
+    }
+}
+data_sources: {
+    config {
+        name: "linux.sys_stats"
+        sys_stats_config {
+            meminfo_period_ms: 200
+            vmstat_period_ms: 200
+            stat_period_ms: 1000
+            stat_counters: STAT_CPU_TIMES
+            stat_counters: STAT_FORK_COUNT
+        }
+    }
+}
+data_sources: {
+    config {
+        name: "linux.ftrace"
+        ftrace_config {
+            symbolize_ksyms:true
+            ftrace_events: "sched/sched_wakeup"
+            ftrace_events: "sched/sched_wakeup_new"
+            ftrace_events: "sched/sched_waking"
+            ftrace_events: "sched/sched_switch"
+            ftrace_events: "power/suspend_resume"
+            ftrace_events: "power/cpu_frequency"
+            ftrace_events: "power/cpu_idle"
+            ftrace_events: "task/task_newtask"
+            ftrace_events: "task/task_rename"
+            ftrace_events: "lowmemorykiller/lowmemory_kill"
+            ftrace_events: "oom/oom_score_adj_update"
+            ftrace_events: "workqueue/*"
+            ftrace_events: "ftrace/print"
+            ftrace_events: "fastrpc/*"
+            ftrace_events: "kmem/rss_stat"
+            ftrace_events: "ion/ion_stat"
+            ftrace_events: "dmabuf_heap/dma_heap_stat"
+            ftrace_events: "kmem/ion_heap_grow"
+            ftrace_events: "kmem/ion_heap_shrink"
+            ftrace_events: "trusty/trusty_share_memory"
+            ftrace_events: "trusty/trusty_share_memory_done"
+            ftrace_events: "trusty/trusty_reclaim_memory"
+            ftrace_events: "trusty/trusty_reclaim_memory_done"
+            ftrace_events: "trusty/trusty_smc"
+            ftrace_events: "trusty/trusty_smc_done"
+            atrace_categories: "view"
+            atrace_categories: "webview"
+            atrace_categories: "wm"
+            atrace_categories: "am"
+            atrace_categories: "video"
+            atrace_categories: "camera"
+            atrace_categories: "sched"
+            atrace_categories: "hal"
+            atrace_categories: "ss"
+            atrace_categories: "aidl"
+            atrace_categories: "binder_driver"
+            atrace_categories: "input"
+            atrace_categories: "gfx"
+            atrace_categories: "disk"
+            atrace_categories: "bionic"
+            atrace_categories: "power"
+            atrace_categories: "memreclaim"
+            atrace_categories: "memory"
+            atrace_categories: "sync"
+            atrace_categories: "thermal"
+            atrace_apps: "lmkd"
+            atrace_apps: "*"
+            compact_sched: {
+              enabled: true
+            }
+        }
+    }
+}
+
+write_into_file: true
+file_write_period_ms: 604800000
+flush_period_ms: 30000
+incremental_state_config {
+    clear_period_ms: 5000
+}
+
diff --git a/testing/mockingservicestests/Android.bp b/testing/mockingservicestests/Android.bp
index 767f7bbe..81f8bdc9 100644
--- a/testing/mockingservicestests/Android.bp
+++ b/testing/mockingservicestests/Android.bp
@@ -38,7 +38,10 @@ android_test {
         "framework-appsearch.impl",
     ],
     // jni libs are not normally accessible from apps so they must be explicitly included.
-    jni_libs: ["libicing"],
+    jni_libs: [
+        "libappsearchservice",
+        "libicing_anywhere",
+    ],
     test_suites: [
         "general-tests",
         "mts-appsearch",
diff --git a/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchManagerServiceTest.java b/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchManagerServiceTest.java
index 59a74fe3..2c646f75 100644
--- a/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchManagerServiceTest.java
+++ b/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchManagerServiceTest.java
@@ -24,6 +24,7 @@ import static android.system.OsConstants.O_WRONLY;
 
 import static com.android.internal.util.ConcurrentUtils.DIRECT_EXECUTOR;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_DENYLIST;
+import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_ISOLATED_STORAGE_ENABLED;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_RATE_LIMIT_API_COSTS;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_RATE_LIMIT_ENABLED;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_RATE_LIMIT_TASK_QUEUE_PER_PACKAGE_CAPACITY_PERCENTAGE;
@@ -130,19 +131,20 @@ import com.android.modules.utils.testing.StaticMockFixture;
 import com.android.modules.utils.testing.TestableDeviceConfig;
 import com.android.server.LocalManagerRegistry;
 import com.android.server.appsearch.external.localstorage.stats.CallStats;
+import com.android.server.appsearch.external.localstorage.stats.QueryStats;
 import com.android.server.appsearch.external.localstorage.stats.SearchIntentStats;
 import com.android.server.appsearch.external.localstorage.stats.SearchSessionStats;
-import com.android.server.appsearch.external.localstorage.stats.SearchStats;
 import com.android.server.appsearch.external.localstorage.stats.SetSchemaStats;
 import com.android.server.appsearch.external.localstorage.usagereporting.ClickActionGenericDocument;
 import com.android.server.appsearch.external.localstorage.usagereporting.SearchActionGenericDocument;
 import com.android.server.appsearch.isolated_storage_service.IsolatedStorageServiceManager;
+import com.android.server.appsearch.util.ExecutorManager;
 import com.android.server.usage.StorageStatsManagerLocal;
 
-import com.google.common.util.concurrent.SettableFuture;
-
 import libcore.io.IoBridge;
 
+import com.google.common.util.concurrent.SettableFuture;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -188,6 +190,7 @@ public class AppSearchManagerServiceTest {
     private IAppSearchManager.Stub mAppSearchManagerServiceStub;
     private AppSearchUserInstance mUserInstance;
     private InternalAppSearchLogger mLogger;
+    private ExecutorManager mExecutorManager;
 
     private int mCallingPid;
 
@@ -215,15 +218,18 @@ public class AppSearchManagerServiceTest {
         // TestableDeviceConfig, the propertyChangedListeners are removed. Therefore we have to set
         // a fresh config with listeners in setUp in order to set new properties.
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
         AppSearchComponentFactory.setConfigInstanceForTest(appSearchConfig);
 
         // Create the user instance and add a spy to its logger to verify logging
         // Note, SimpleTestLogger does not suffice for our tests since CallStats logging in
         // AppSearchManagerService occurs in a separate thread. With a spy, we can verify with a
         // timeout to catch asynchronous calls.
-        mUserInstance = AppSearchUserInstanceManager.getInstance().getOrCreateUserInstance(mContext,
-                mUserHandle, appSearchConfig);
+        mExecutorManager = new ExecutorManager(appSearchConfig);
+        mUserInstance =
+                AppSearchUserInstanceManager.getInstance()
+                        .getOrCreateUserInstance(
+                                mContext, mUserHandle, appSearchConfig, mExecutorManager, null);
         mLogger = spy(mUserInstance.getLogger());
         mUserInstance.setLoggerForTest(mLogger);
 
@@ -269,6 +275,7 @@ public class AppSearchManagerServiceTest {
 
     @Test
     public void testSetSchemaStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         TestResultCallback callback = new TestResultCallback();
         mAppSearchManagerServiceStub.setSchema(
                 new SetSchemaAidlRequest(
@@ -280,7 +287,7 @@ public class AppSearchManagerServiceTest {
                 SchemaMigrationStats.FIRST_CALL_GET_INCOMPATIBLE),
                 callback);
         assertThat(callback.get().getResultCode()).isEqualTo(AppSearchResult.RESULT_OK);
-        verifyCallStats(mContext.getPackageName(), DATABASE_NAME, CallStats.CALL_TYPE_SET_SCHEMA);
+        verifyCallStats(mContext.getPackageName(), DATABASE_NAME, CallStats.CALL_TYPE_SET_SCHEMA, callReceivedTimestampMillis);
         // SetSchemaStats is also logged in SetSchema
         ArgumentCaptor<SetSchemaStats> setSchemaStatsCaptor = ArgumentCaptor.forClass(
                 SetSchemaStats.class);
@@ -295,6 +302,7 @@ public class AppSearchManagerServiceTest {
 
     @Test
     public void testLocalGetSchemaStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         TestResultCallback callback = new TestResultCallback();
         mAppSearchManagerServiceStub.getSchema(
                 new GetSchemaAidlRequest(
@@ -304,11 +312,12 @@ public class AppSearchManagerServiceTest {
                         BINDER_CALL_START_TIME, /* isForEnterprise= */ false),
                 callback);
         assertThat(callback.get().getResultCode()).isEqualTo(AppSearchResult.RESULT_OK);
-        verifyCallStats(mContext.getPackageName(), DATABASE_NAME, CallStats.CALL_TYPE_GET_SCHEMA);
+        verifyCallStats(mContext.getPackageName(), DATABASE_NAME, CallStats.CALL_TYPE_GET_SCHEMA, callReceivedTimestampMillis);
     }
 
     @Test
     public void testGlobalGetSchemaStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         String otherPackageName = mContext.getPackageName() + "foo";
         TestResultCallback callback = new TestResultCallback();
         mAppSearchManagerServiceStub.getSchema(
@@ -319,12 +328,13 @@ public class AppSearchManagerServiceTest {
                         /* isForEnterprise= */ false),
                 callback);
         assertThat(callback.get().getResultCode()).isEqualTo(AppSearchResult.RESULT_OK);
-        verifyCallStats(mContext.getPackageName(), DATABASE_NAME,
-                CallStats.CALL_TYPE_GLOBAL_GET_SCHEMA);
+        verifyCallStats(
+                mContext.getPackageName(), DATABASE_NAME, CallStats.CALL_TYPE_GLOBAL_GET_SCHEMA, callReceivedTimestampMillis);
     }
 
     @Test
     public void testGetNamespacesStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         TestResultCallback callback = new TestResultCallback();
         mAppSearchManagerServiceStub.getNamespaces(
                 new GetNamespacesAidlRequest(
@@ -333,12 +343,13 @@ public class AppSearchManagerServiceTest {
                         mUserHandle, BINDER_CALL_START_TIME),
                 callback);
         assertThat(callback.get().getResultCode()).isEqualTo(AppSearchResult.RESULT_OK);
-        verifyCallStats(mContext.getPackageName(), DATABASE_NAME,
-                CallStats.CALL_TYPE_GET_NAMESPACES);
+        verifyCallStats(
+                mContext.getPackageName(), DATABASE_NAME, CallStats.CALL_TYPE_GET_NAMESPACES, callReceivedTimestampMillis);
     }
 
     @Test
     public void testPutDocumentsStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         TestBatchResultErrorCallback callback = new TestBatchResultErrorCallback();
         mAppSearchManagerServiceStub.putDocuments(
                 new PutDocumentsAidlRequest(
@@ -347,13 +358,14 @@ public class AppSearchManagerServiceTest {
                         new DocumentsParcel(Collections.emptyList(), Collections.emptyList()),
                         mUserHandle, BINDER_CALL_START_TIME), callback);
         assertThat(callback.get()).isNull(); // null means there wasn't an error
-        verifyCallStats(mContext.getPackageName(), DATABASE_NAME,
-                CallStats.CALL_TYPE_PUT_DOCUMENTS);
+        verifyCallStats(
+                mContext.getPackageName(), DATABASE_NAME, CallStats.CALL_TYPE_PUT_DOCUMENTS, callReceivedTimestampMillis);
         // putDocuments only logs PutDocumentStats indirectly so we don't verify it
     }
 
     @Test
     public void testPutDocumentsStatsLogging_takenActions() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         // Set SearchAction and ClickAction schemas.
         List<AppSearchSchema> schemas =
                 Arrays.asList(
@@ -465,7 +477,7 @@ public class AppSearchManagerServiceTest {
                 callback);
         assertThat(callback.get()).isNull(); // null means there wasn't an error
         verifyCallStats(
-                mContext.getPackageName(), DATABASE_NAME, CallStats.CALL_TYPE_PUT_DOCUMENTS);
+                mContext.getPackageName(), DATABASE_NAME, CallStats.CALL_TYPE_PUT_DOCUMENTS, callReceivedTimestampMillis);
 
         // Verify search sessions.
         ArgumentCaptor<List<SearchSessionStats>> searchSessionsStatsCaptor =
@@ -506,6 +518,7 @@ public class AppSearchManagerServiceTest {
 
     @Test
     public void testLocalGetDocumentsStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         TestBatchResultErrorCallback callback = new TestBatchResultErrorCallback();
         mAppSearchManagerServiceStub.getDocuments(
                 new GetDocumentsAidlRequest(
@@ -518,12 +531,13 @@ public class AppSearchManagerServiceTest {
                 mUserHandle, BINDER_CALL_START_TIME, /* isForEnterprise= */ false),
                 callback);
         assertThat(callback.get()).isNull(); // null means there wasn't an error
-        verifyCallStats(mContext.getPackageName(), DATABASE_NAME,
-                CallStats.CALL_TYPE_GET_DOCUMENTS);
+        verifyCallStats(
+                mContext.getPackageName(), DATABASE_NAME, CallStats.CALL_TYPE_GET_DOCUMENTS, callReceivedTimestampMillis);
     }
 
     @Test
     public void testGlobalGetDocumentsStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         String otherPackageName = mContext.getPackageName() + "foo";
         TestBatchResultErrorCallback callback = new TestBatchResultErrorCallback();
         mAppSearchManagerServiceStub.getDocuments(
@@ -537,12 +551,16 @@ public class AppSearchManagerServiceTest {
                        mUserHandle, BINDER_CALL_START_TIME, /* isForEnterprise= */ false),
                 callback);
         assertThat(callback.get()).isNull(); // null means there wasn't an error
-        verifyCallStats(mContext.getPackageName(), DATABASE_NAME,
-                CallStats.CALL_TYPE_GLOBAL_GET_DOCUMENT_BY_ID);
+        verifyCallStats(
+                mContext.getPackageName(),
+                DATABASE_NAME,
+                CallStats.CALL_TYPE_GLOBAL_GET_DOCUMENT_BY_ID,
+                callReceivedTimestampMillis);
     }
 
     @Test
     public void testSearchStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         TestResultCallback callback = new TestResultCallback();
         mAppSearchManagerServiceStub.search(
                 new SearchAidlRequest(AppSearchAttributionSource.createAttributionSource(mContext,
@@ -550,24 +568,26 @@ public class AppSearchManagerServiceTest {
                         DATABASE_NAME, /* searchExpression= */ "", EMPTY_SEARCH_SPEC, mUserHandle,
                         BINDER_CALL_START_TIME), callback);
         assertThat(callback.get().getResultCode()).isEqualTo(AppSearchResult.RESULT_OK);
-        verifyCallStats(mContext.getPackageName(), DATABASE_NAME, CallStats.CALL_TYPE_SEARCH);
+        verifyCallStats(mContext.getPackageName(), DATABASE_NAME, CallStats.CALL_TYPE_SEARCH, callReceivedTimestampMillis);
         // search only logs SearchStats indirectly so we don't verify it
     }
 
     @Test
     public void testGlobalSearchStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         TestResultCallback callback = new TestResultCallback();
         mAppSearchManagerServiceStub.globalSearch(new GlobalSearchAidlRequest(
                 AppSearchAttributionSource.createAttributionSource(mContext, mCallingPid),
                 /* searchExpression= */ "", EMPTY_SEARCH_SPEC, mUserHandle, BINDER_CALL_START_TIME,
                 /* isForEnterprise= */ false), callback);
         assertThat(callback.get().getResultCode()).isEqualTo(AppSearchResult.RESULT_OK);
-        verifyCallStats(mContext.getPackageName(), CallStats.CALL_TYPE_GLOBAL_SEARCH);
+        verifyCallStats(mContext.getPackageName(), CallStats.CALL_TYPE_GLOBAL_SEARCH, callReceivedTimestampMillis);
         // globalSearch only logs SearchStats indirectly so we don't verify it
     }
 
     @Test
     public void testLocalGetNextPageStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         TestResultCallback callback = new TestResultCallback();
         mAppSearchManagerServiceStub.getNextPage(new GetNextPageAidlRequest(
                 AppSearchAttributionSource.createAttributionSource(mContext, mCallingPid),
@@ -575,21 +595,22 @@ public class AppSearchManagerServiceTest {
                 AppSearchSchema.StringPropertyConfig.JOINABLE_VALUE_TYPE_QUALIFIED_ID, mUserHandle,
                 BINDER_CALL_START_TIME, /* isForEnterprise= */ false), callback);
         assertThat(callback.get().getResultCode()).isEqualTo(AppSearchResult.RESULT_OK);
-        verifyCallStats(mContext.getPackageName(), DATABASE_NAME,
-                CallStats.CALL_TYPE_GET_NEXT_PAGE);
-        // getNextPage also logs SearchStats
-        ArgumentCaptor<SearchStats> searchStatsCaptor = ArgumentCaptor.forClass(SearchStats.class);
-        verify(mLogger, timeout(1000).times(1)).logStats(searchStatsCaptor.capture());
-        SearchStats searchStats = searchStatsCaptor.getValue();
-        assertThat(searchStats.getVisibilityScope()).isEqualTo(SearchStats.VISIBILITY_SCOPE_LOCAL);
-        assertThat(searchStats.getPackageName()).isEqualTo(mContext.getPackageName());
-        assertThat(searchStats.getDatabase()).isEqualTo(DATABASE_NAME);
-        assertThat(searchStats.getJoinType()).isEqualTo(
-                AppSearchSchema.StringPropertyConfig.JOINABLE_VALUE_TYPE_QUALIFIED_ID);
+        verifyCallStats(
+                mContext.getPackageName(), DATABASE_NAME, CallStats.CALL_TYPE_GET_NEXT_PAGE, callReceivedTimestampMillis);
+        // getNextPage also logs QueryStats
+        ArgumentCaptor<QueryStats> queryStatsCaptor = ArgumentCaptor.forClass(QueryStats.class);
+        verify(mLogger, timeout(1000).times(1)).logStats(queryStatsCaptor.capture());
+        QueryStats queryStats = queryStatsCaptor.getValue();
+        assertThat(queryStats.getVisibilityScope()).isEqualTo(QueryStats.VISIBILITY_SCOPE_LOCAL);
+        assertThat(queryStats.getPackageName()).isEqualTo(mContext.getPackageName());
+        assertThat(queryStats.getDatabase()).isEqualTo(DATABASE_NAME);
+        assertThat(queryStats.getJoinType())
+                .isEqualTo(AppSearchSchema.StringPropertyConfig.JOINABLE_VALUE_TYPE_QUALIFIED_ID);
     }
 
     @Test
     public void testGlobalGetNextPageStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         TestResultCallback callback = new TestResultCallback();
         mAppSearchManagerServiceStub.getNextPage(new GetNextPageAidlRequest(
                 AppSearchAttributionSource.createAttributionSource(mContext, mCallingPid),
@@ -597,29 +618,31 @@ public class AppSearchManagerServiceTest {
                 AppSearchSchema.StringPropertyConfig.JOINABLE_VALUE_TYPE_QUALIFIED_ID, mUserHandle,
                 BINDER_CALL_START_TIME, /* isForEnterprise= */ false), callback);
         assertThat(callback.get().getResultCode()).isEqualTo(AppSearchResult.RESULT_OK);
-        verifyCallStats(mContext.getPackageName(), CallStats.CALL_TYPE_GLOBAL_GET_NEXT_PAGE);
-        // getNextPage also logs SearchStats
-        ArgumentCaptor<SearchStats> searchStatsCaptor = ArgumentCaptor.forClass(SearchStats.class);
-        verify(mLogger, timeout(1000).times(1)).logStats(searchStatsCaptor.capture());
-        SearchStats searchStats = searchStatsCaptor.getValue();
-        assertThat(searchStats.getVisibilityScope()).isEqualTo(SearchStats.VISIBILITY_SCOPE_GLOBAL);
-        assertThat(searchStats.getPackageName()).isEqualTo(mContext.getPackageName());
-        assertThat(searchStats.getDatabase()).isNull();
-        assertThat(searchStats.getJoinType()).isEqualTo(
-                AppSearchSchema.StringPropertyConfig.JOINABLE_VALUE_TYPE_QUALIFIED_ID);
+        verifyCallStats(mContext.getPackageName(), CallStats.CALL_TYPE_GLOBAL_GET_NEXT_PAGE, callReceivedTimestampMillis);
+        // getNextPage also logs QueryStats
+        ArgumentCaptor<QueryStats> queryStatsCaptor = ArgumentCaptor.forClass(QueryStats.class);
+        verify(mLogger, timeout(1000).times(1)).logStats(queryStatsCaptor.capture());
+        QueryStats queryStats = queryStatsCaptor.getValue();
+        assertThat(queryStats.getVisibilityScope()).isEqualTo(QueryStats.VISIBILITY_SCOPE_GLOBAL);
+        assertThat(queryStats.getPackageName()).isEqualTo(mContext.getPackageName());
+        assertThat(queryStats.getDatabase()).isNull();
+        assertThat(queryStats.getJoinType())
+                .isEqualTo(AppSearchSchema.StringPropertyConfig.JOINABLE_VALUE_TYPE_QUALIFIED_ID);
     }
 
     @Test
     public void testInvalidateNextPageTokenStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         mAppSearchManagerServiceStub.invalidateNextPageToken(new InvalidateNextPageTokenAidlRequest(
                 AppSearchAttributionSource.createAttributionSource(mContext, mCallingPid),
                 /* nextPageToken= */ 0, mUserHandle, BINDER_CALL_START_TIME,
                 /* isForEnterprise= */ false));
-        verifyCallStats(mContext.getPackageName(), CallStats.CALL_TYPE_INVALIDATE_NEXT_PAGE_TOKEN);
+        verifyCallStats(mContext.getPackageName(), CallStats.CALL_TYPE_INVALIDATE_NEXT_PAGE_TOKEN, callReceivedTimestampMillis);
     }
 
     @Test
     public void testWriteSearchResultsToFileStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         File tempFile = mTemporaryFolder.newFile();
         FileDescriptor fd = IoBridge.open(tempFile.getPath(), O_WRONLY);
         TestResultCallback callback = new TestResultCallback();
@@ -630,12 +653,16 @@ public class AppSearchManagerServiceTest {
                         new ParcelFileDescriptor(fd), /* searchExpression= */ "", EMPTY_SEARCH_SPEC,
                         mUserHandle, BINDER_CALL_START_TIME), callback);
         assertThat(callback.get().getResultCode()).isEqualTo(AppSearchResult.RESULT_OK);
-        verifyCallStats(mContext.getPackageName(), DATABASE_NAME,
-                CallStats.CALL_TYPE_WRITE_SEARCH_RESULTS_TO_FILE);
+        verifyCallStats(
+                mContext.getPackageName(),
+                DATABASE_NAME,
+                CallStats.CALL_TYPE_WRITE_SEARCH_RESULTS_TO_FILE,
+                callReceivedTimestampMillis);
     }
 
     @Test
     public void testPutDocumentsFromFileStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         File tempFile = mTemporaryFolder.newFile();
         FileDescriptor fd = IoBridge.open(tempFile.getPath(), O_RDONLY);
         TestResultCallback callback = new TestResultCallback();
@@ -646,8 +673,10 @@ public class AppSearchManagerServiceTest {
                 new SchemaMigrationStats.Builder(mContext.getPackageName(), DATABASE_NAME).build(),
                 /* totalLatencyStartTimeMillis= */ 0, BINDER_CALL_START_TIME), callback);
         assertThat(callback.get().getResultCode()).isEqualTo(AppSearchResult.RESULT_OK);
-        verifyCallStats(mContext.getPackageName(), DATABASE_NAME,
-                CallStats.CALL_TYPE_PUT_DOCUMENTS_FROM_FILE);
+        verifyCallStats(
+                mContext.getPackageName(),
+                DATABASE_NAME,
+                CallStats.CALL_TYPE_PUT_DOCUMENTS_FROM_FILE, callReceivedTimestampMillis);
         // putDocumentsFromFile also logs SchemaMigrationStats
         ArgumentCaptor<SchemaMigrationStats> migrationStatsCaptor = ArgumentCaptor.forClass(
                 SchemaMigrationStats.class);
@@ -660,6 +689,7 @@ public class AppSearchManagerServiceTest {
 
     @Test
     public void testSearchSuggestionStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         SearchSuggestionSpec searchSuggestionSpec =
             new SearchSuggestionSpec.Builder(/*maximumResultCount=*/1).build();
         TestResultCallback callback = new TestResultCallback();
@@ -671,12 +701,13 @@ public class AppSearchManagerServiceTest {
                         mUserHandle, BINDER_CALL_START_TIME),
                 callback);
         assertThat(callback.get().getResultCode()).isEqualTo(AppSearchResult.RESULT_OK);
-        verifyCallStats(mContext.getPackageName(), DATABASE_NAME,
-                CallStats.CALL_TYPE_SEARCH_SUGGESTION);
+        verifyCallStats(
+                mContext.getPackageName(), DATABASE_NAME, CallStats.CALL_TYPE_SEARCH_SUGGESTION, callReceivedTimestampMillis);
     }
 
     @Test
     public void testLocalReportUsageStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         setUpTestSchema(mContext.getPackageName(), DATABASE_NAME);
         setUpTestDocument(mContext.getPackageName(), DATABASE_NAME, NAMESPACE, ID);
         TestResultCallback callback = new TestResultCallback();
@@ -691,12 +722,13 @@ public class AppSearchManagerServiceTest {
                         /* systemUsage= */ false, mUserHandle, BINDER_CALL_START_TIME),
                 callback);
         assertThat(callback.get().getResultCode()).isEqualTo(AppSearchResult.RESULT_OK);
-        verifyCallStats(mContext.getPackageName(), DATABASE_NAME, CallStats.CALL_TYPE_REPORT_USAGE);
+        verifyCallStats(mContext.getPackageName(), DATABASE_NAME, CallStats.CALL_TYPE_REPORT_USAGE, callReceivedTimestampMillis);
         removeTestSchema(mContext.getPackageName(), DATABASE_NAME);
     }
 
     @Test
     public void testGlobalReportUsageStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         // Grant system access for global report usage
         mUiAutomation.adoptShellPermissionIdentity(Manifest.permission.READ_GLOBAL_APP_SEARCH_DATA);
         try {
@@ -715,8 +747,10 @@ public class AppSearchManagerServiceTest {
                             /* systemUsage= */ true, mUserHandle, BINDER_CALL_START_TIME),
                     callback);
             assertThat(callback.get().getResultCode()).isEqualTo(AppSearchResult.RESULT_OK);
-            verifyCallStats(mContext.getPackageName(), DATABASE_NAME,
-                    CallStats.CALL_TYPE_REPORT_SYSTEM_USAGE);
+            verifyCallStats(
+                    mContext.getPackageName(),
+                    DATABASE_NAME,
+                    CallStats.CALL_TYPE_REPORT_SYSTEM_USAGE, callReceivedTimestampMillis);
             removeTestSchema(otherPackageName, DATABASE_NAME);
         } finally {
             mUiAutomation.dropShellPermissionIdentity();
@@ -725,6 +759,7 @@ public class AppSearchManagerServiceTest {
 
     @Test
     public void testRemoveByDocumentIdStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         TestBatchResultErrorCallback callback = new TestBatchResultErrorCallback();
         mAppSearchManagerServiceStub.removeByDocumentId(
                 new RemoveByDocumentIdAidlRequest(
@@ -738,12 +773,15 @@ public class AppSearchManagerServiceTest {
                         BINDER_CALL_START_TIME),
                 callback);
         assertThat(callback.get()).isNull(); // null means there wasn't an error
-        verifyCallStats(mContext.getPackageName(), DATABASE_NAME,
-                CallStats.CALL_TYPE_REMOVE_DOCUMENTS_BY_ID);
+        verifyCallStats(
+                mContext.getPackageName(),
+                DATABASE_NAME,
+                CallStats.CALL_TYPE_REMOVE_DOCUMENTS_BY_ID, callReceivedTimestampMillis);
     }
 
     @Test
     public void testRemoveByQueryStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         TestResultCallback callback = new TestResultCallback();
         mAppSearchManagerServiceStub.removeByQuery(
                 new RemoveByQueryAidlRequest(
@@ -753,12 +791,15 @@ public class AppSearchManagerServiceTest {
                         BINDER_CALL_START_TIME),
                 callback);
         assertThat(callback.get().getResultCode()).isEqualTo(AppSearchResult.RESULT_OK);
-        verifyCallStats(mContext.getPackageName(), DATABASE_NAME,
-                CallStats.CALL_TYPE_REMOVE_DOCUMENTS_BY_SEARCH);
+        verifyCallStats(
+                mContext.getPackageName(),
+                DATABASE_NAME,
+                CallStats.CALL_TYPE_REMOVE_DOCUMENTS_BY_SEARCH, callReceivedTimestampMillis);
     }
 
     @Test
     public void testGetStorageInfoStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         TestResultCallback callback = new TestResultCallback();
         mAppSearchManagerServiceStub.getStorageInfo(
                 new GetStorageInfoAidlRequest(
@@ -767,22 +808,24 @@ public class AppSearchManagerServiceTest {
                         mUserHandle, BINDER_CALL_START_TIME),
                 callback);
         assertThat(callback.get().getResultCode()).isEqualTo(AppSearchResult.RESULT_OK);
-        verifyCallStats(mContext.getPackageName(), DATABASE_NAME,
-                CallStats.CALL_TYPE_GET_STORAGE_INFO);
+        verifyCallStats(
+                mContext.getPackageName(), DATABASE_NAME, CallStats.CALL_TYPE_GET_STORAGE_INFO, callReceivedTimestampMillis);
     }
 
     @Test
     public void testPersistToDiskStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         mAppSearchManagerServiceStub.persistToDisk(
                 new PersistToDiskAidlRequest(
                         AppSearchAttributionSource.createAttributionSource(mContext,
                                 mCallingPid), mUserHandle,
                         BINDER_CALL_START_TIME));
-        verifyCallStats(mContext.getPackageName(), CallStats.CALL_TYPE_FLUSH);
+        verifyCallStats(mContext.getPackageName(), CallStats.CALL_TYPE_FLUSH, callReceivedTimestampMillis);
     }
 
     @Test
     public void testRegisterObserverCallbackStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         AppSearchResultParcel<Void> resultParcel =
                 mAppSearchManagerServiceStub.registerObserverCallback(
                         new RegisterObserverCallbackAidlRequest(
@@ -804,11 +847,12 @@ public class AppSearchManagerServiceTest {
                             }
                         });
         assertThat(resultParcel.getResult().getResultCode()).isEqualTo(AppSearchResult.RESULT_OK);
-        verifyCallStats(mContext.getPackageName(), CallStats.CALL_TYPE_REGISTER_OBSERVER_CALLBACK);
+        verifyCallStats(mContext.getPackageName(), CallStats.CALL_TYPE_REGISTER_OBSERVER_CALLBACK, callReceivedTimestampMillis);
     }
 
     @Test
     public void testUnregisterObserverCallbackStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         AppSearchResultParcel<Void> resultParcel =
                 mAppSearchManagerServiceStub.unregisterObserverCallback(
                         new UnregisterObserverCallbackAidlRequest(
@@ -829,12 +873,13 @@ public class AppSearchManagerServiceTest {
                             }
                         });
         assertThat(resultParcel.getResult().getResultCode()).isEqualTo(AppSearchResult.RESULT_OK);
-        verifyCallStats(mContext.getPackageName(),
-                CallStats.CALL_TYPE_UNREGISTER_OBSERVER_CALLBACK);
+        verifyCallStats(
+                mContext.getPackageName(), CallStats.CALL_TYPE_UNREGISTER_OBSERVER_CALLBACK, callReceivedTimestampMillis);
     }
 
     @Test
     public void testInitializeStatsLogging() throws Exception {
+        final long callReceivedTimestampMillis = System.currentTimeMillis();
         TestResultCallback callback = new TestResultCallback();
         mAppSearchManagerServiceStub.initialize(
                 new InitializeAidlRequest(
@@ -843,11 +888,11 @@ public class AppSearchManagerServiceTest {
                         BINDER_CALL_START_TIME),
                 callback);
         assertThat(callback.get().getResultCode()).isEqualTo(AppSearchResult.RESULT_OK);
-        verifyCallStats(mContext.getPackageName(), CallStats.CALL_TYPE_INITIALIZE);
+        verifyCallStats(mContext.getPackageName(), CallStats.CALL_TYPE_INITIALIZE, callReceivedTimestampMillis);
         // initialize only logs InitializeStats indirectly so we don't verify it
     }
 
-    private void verifyCallStats(String packageName, String databaseName, int callType) {
+    private void verifyCallStats(String packageName, String databaseName, int callType, long expectedCallReceivedTimestampMillis) {
         ArgumentCaptor<CallStats> captor = ArgumentCaptor.forClass(CallStats.class);
         verify(mLogger, timeout(1000).times(1)).logStats(captor.capture());
         CallStats callStats = captor.getValue();
@@ -856,10 +901,12 @@ public class AppSearchManagerServiceTest {
         assertThat(callStats.getCallType()).isEqualTo(callType);
         assertThat(callStats.getStatusCode()).isEqualTo(AppSearchResult.RESULT_OK);
         assertThat(callStats.getEstimatedBinderLatencyMillis()).isGreaterThan(0);
+        assertThat(callStats.getCallReceivedTimestampMillis()).isAtLeast(expectedCallReceivedTimestampMillis);
+        assertThat(callStats.getCallReceivedTimestampMillis()).isAtMost(expectedCallReceivedTimestampMillis + 1000);
     }
 
-    private void verifyCallStats(String packageName, int callType) {
-        verifyCallStats(packageName, /* databaseName= */ null, callType);
+    private void verifyCallStats(String packageName, int callType, long expectedCallReceivedTimestampMillis) {
+        verifyCallStats(packageName, /* databaseName= */ null, callType, expectedCallReceivedTimestampMillis);
     }
 
     @Test
@@ -1458,21 +1505,34 @@ public class AppSearchManagerServiceTest {
 
     @Test
     public void testIsolatedStorageNotAvailable() throws Exception {
-        assumeTrue(IsolatedStorageServiceManager.isolatedStorageFlagsSet());
-        // Ensure that AppSearch fails if the isolated storage service fails
-        final boolean useIsolatedStorage = true;
         Context context = ApplicationProvider.getApplicationContext();
-        // Create a new user, one was already created during setUp()
-        UserHandle testUserHandle = new UserHandle(1);
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
+        DeviceConfig.setProperty(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_ISOLATED_STORAGE_ENABLED,
+                Boolean.toString(true),
+                false);
+        assumeTrue(IsolatedStorageServiceManager.useIsolatedStorage(context, appSearchConfig));
+        // The original user0 was created to not use isolated storage, and that result was
+        // cached. Clear the cache so that our new settings take effect.
+        AppSearchUserInstanceManager.getInstance().closeAndRemoveUserInstance(mUserHandle);
+        IsolatedStorageServiceManager isolatedStorageServiceManager =
+                new IsolatedStorageServiceManager(context, appSearchConfig, DIRECT_EXECUTOR);
+        // Ensure that AppSearch fails if the isolated storage service fails
         TestContext testContext =
-                new TestContext(context, mRoleManager, mDevicePolicyManager, useIsolatedStorage);
+                new TestContext(context, mRoleManager, mDevicePolicyManager,
+                        /*useIsolatedStorage=*/true);
         assertThrows(
                 AppSearchException.class,
                 () -> {
                     AppSearchUserInstanceManager.getInstance()
-                            .getOrCreateUserInstance(testContext, testUserHandle, appSearchConfig);
+                            .getOrCreateUserInstance(
+                                    testContext,
+                                    mUserHandle,
+                                    appSearchConfig,
+                                    mExecutorManager,
+                                    isolatedStorageServiceManager);
                 });
     }
 
diff --git a/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchModuleTest.java b/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchModuleTest.java
index 61fa4bc6..0a778146 100644
--- a/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchModuleTest.java
+++ b/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchModuleTest.java
@@ -125,7 +125,8 @@ public class AppSearchModuleTest {
                     @NonNull
                     @Override
                     AppOpenEventIndexerManagerService createAppOpenEventIndexerManagerService(
-                            @NonNull Context mContext, @NonNull AppOpenEventIndexerConfig config) {
+                            @NonNull Context mContext,
+                            @NonNull AppOpenEventIndexerConfig config) {
                         return mAppOpenEventIndexerService;
                     }
                 };
diff --git a/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchUserInstanceManagerTest.java b/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchUserInstanceManagerTest.java
new file mode 100644
index 00000000..e370631b
--- /dev/null
+++ b/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchUserInstanceManagerTest.java
@@ -0,0 +1,218 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.server.appsearch;
+
+import static com.android.internal.util.ConcurrentUtils.DIRECT_EXECUTOR;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertThrows;
+
+import android.annotation.NonNull;
+import android.app.appsearch.AppSearchEnvironmentFactory;
+import android.app.appsearch.FrameworkAppSearchEnvironment;
+import android.app.appsearch.exceptions.AppSearchException;
+import android.app.appsearch.testutil.AppSearchTestUtils;
+import android.content.Context;
+import android.os.UserHandle;
+
+import androidx.test.core.app.ApplicationProvider;
+
+import com.android.server.appsearch.util.ExecutorManager;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.RuleChain;
+import org.junit.rules.TemporaryFolder;
+
+import java.io.File;
+import java.util.List;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+
+public class AppSearchUserInstanceManagerTest {
+    @Rule public final RuleChain mRuleChain = AppSearchTestUtils.createCommonTestRules();
+
+    @Rule public TemporaryFolder mTemporaryFolder = new TemporaryFolder();
+
+    private Context mContext;
+    private UserHandle mUserHandle;
+
+    private ServiceAppSearchConfig mServiceConfig;
+    private ExecutorManager mExecutorManager;
+
+    @Before
+    public void setUp() throws Exception {
+        mContext = ApplicationProvider.getApplicationContext();
+        mUserHandle = mContext.getUser();
+
+        // Set a test environment that provides a temporary folder for AppSearch
+        File mAppSearchDir = mTemporaryFolder.newFolder();
+        AppSearchEnvironmentFactory.setEnvironmentInstanceForTest(
+                new FrameworkAppSearchEnvironment() {
+                    @Override
+                    public File getAppSearchDir(
+                            @NonNull Context unused, @NonNull UserHandle userHandle) {
+                        return mAppSearchDir;
+                    }
+                });
+
+        mServiceConfig = FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, mContext);
+        AppSearchComponentFactory.setConfigInstanceForTest(mServiceConfig);
+
+        mExecutorManager = new ExecutorManager(mServiceConfig);
+    }
+
+    @Test
+    public void getInstance_returnsInstance() {
+        assertThat(AppSearchUserInstanceManager.getInstance()).isNotNull();
+    }
+
+    @Test
+    public void getInstance_sameThread_getInstanceTwice_returnsSameInstance() {
+        AppSearchUserInstanceManager originalInstance = AppSearchUserInstanceManager.getInstance();
+        AppSearchUserInstanceManager newInstance = AppSearchUserInstanceManager.getInstance();
+        assertThat(originalInstance).isSameInstanceAs(newInstance);
+    }
+
+    @Test
+    public void getInstance_multipleThreads_getInstanceTwice_returnsSameInstance()
+            throws ExecutionException, InterruptedException {
+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {
+            Future<AppSearchUserInstanceManager> originalInstanceFuture =
+                    executor.submit(AppSearchUserInstanceManager::getInstance);
+            Future<AppSearchUserInstanceManager> newInstanceFuture =
+                    executor.submit(AppSearchUserInstanceManager::getInstance);
+
+            AppSearchUserInstanceManager originalInstance = originalInstanceFuture.get();
+            AppSearchUserInstanceManager newInstance = newInstanceFuture.get();
+            assertThat(originalInstance).isEqualTo(newInstance);
+        }
+    }
+
+    @Test
+    public void getOrCreateUserInstance_returnsInstance() throws AppSearchException {
+        AppSearchUserInstance userInstance =
+                AppSearchUserInstanceManager.getInstance()
+                        .getOrCreateUserInstance(
+                                mContext, mUserHandle, mServiceConfig, mExecutorManager, null);
+
+        assertThat(userInstance).isNotNull();
+        assertThat(userInstance.isVMEnabled()).isFalse();
+    }
+
+    @Test
+    public void getOrCreateUserInstance_sameThread_callTwice_returnsSameInstance()
+            throws AppSearchException {
+        AppSearchUserInstance originalInstance =
+                AppSearchUserInstanceManager.getInstance()
+                        .getOrCreateUserInstance(
+                                mContext, mUserHandle, mServiceConfig, mExecutorManager, null);
+
+        AppSearchUserInstance newInstance =
+                AppSearchUserInstanceManager.getInstance()
+                        .getOrCreateUserInstance(
+                                mContext, mUserHandle, mServiceConfig, mExecutorManager, null);
+        assertThat(originalInstance).isSameInstanceAs(newInstance);
+    }
+
+    @Test
+    public void getOrCreateUserInstance_multipleThreads_callTwice_returnsSameInstance()
+            throws InterruptedException, ExecutionException {
+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {
+            AppSearchUserInstanceManager manager = AppSearchUserInstanceManager.getInstance();
+            Future<AppSearchUserInstance> originalInstanceFuture =
+                    executor.submit(
+                            () ->
+                                    manager.getOrCreateUserInstance(
+                                            mContext,
+                                            mUserHandle,
+                                            mServiceConfig,
+                                            mExecutorManager,
+                                            null));
+
+            Future<AppSearchUserInstance> newInstanceFuture =
+                    executor.submit(
+                            () ->
+                                    manager.getOrCreateUserInstance(
+                                            mContext,
+                                            mUserHandle,
+                                            mServiceConfig,
+                                            mExecutorManager,
+                                            null));
+            AppSearchUserInstance originalInstance = originalInstanceFuture.get();
+            AppSearchUserInstance newInstance = newInstanceFuture.get();
+            assertThat(originalInstance).isSameInstanceAs(newInstance);
+        }
+    }
+
+    @Test
+    public void getAllUserHandles_returnsCorrectUserHandles() throws AppSearchException {
+        AppSearchUserInstanceManager manager = AppSearchUserInstanceManager.getInstance();
+        List<UserHandle> userHandles =
+                List.of(new UserHandle(0), new UserHandle(1), new UserHandle(2));
+        for (UserHandle userHandle : userHandles) {
+            manager.getOrCreateUserInstance(
+                    mContext, userHandle, mServiceConfig, mExecutorManager, null);
+        }
+        assertThat(manager.getAllUserHandles()).containsExactlyElementsIn(userHandles);
+    }
+
+    @Test
+    public void closeAndRemoveUserInstance_removesInstance() throws AppSearchException {
+        AppSearchUserInstanceManager manager = AppSearchUserInstanceManager.getInstance();
+        manager.getOrCreateUserInstance(
+                mContext, mUserHandle, mServiceConfig, mExecutorManager, null);
+
+        manager.closeAndRemoveUserInstance(mUserHandle);
+        assertThat(manager.getAllUserHandles()).doesNotContain(mUserHandle);
+    }
+
+    @Test
+    public void getUserInstance_instanceNotFound_throwsException() {
+        AppSearchUserInstanceManager manager = AppSearchUserInstanceManager.getInstance();
+
+        assertThrows(
+                IllegalStateException.class, () -> manager.getUserInstance(new UserHandle(-1)));
+    }
+
+    @Test
+    public void getUserInstanceOrNull_instanceNotFound_returnsNull() {
+        AppSearchUserInstanceManager manager = AppSearchUserInstanceManager.getInstance();
+
+        AppSearchUserInstance instance = manager.getUserInstanceOrNull(new UserHandle(-1));
+        assertThat(instance).isNull();
+    }
+
+    @Test
+    public void getUserInstanceOrNull_tryLocks_returnsNullForBlocked()
+            throws AppSearchException, ExecutionException, InterruptedException {
+        AppSearchUserInstanceManager manager = AppSearchUserInstanceManager.getInstance();
+        manager.getOrCreateUserInstance(
+                mContext, mUserHandle, mServiceConfig, mExecutorManager, null);
+
+        try (ExecutorService executor = Executors.newFixedThreadPool(1)) {
+            manager.lockInstanceMap();
+            AppSearchUserInstance newInstance =
+                    executor.submit(() -> manager.getUserInstanceOrNull(mUserHandle)).get();
+            manager.unlockInstanceMap();
+            assertThat(newInstance).isNull();
+        }
+    }
+}
diff --git a/testing/mockingservicestests/src/com/android/server/appsearch/MockingServiceOptimizeStrategyTest.java b/testing/mockingservicestests/src/com/android/server/appsearch/MockingServiceOptimizeStrategyTest.java
index 4eabe136..28b39477 100644
--- a/testing/mockingservicestests/src/com/android/server/appsearch/MockingServiceOptimizeStrategyTest.java
+++ b/testing/mockingservicestests/src/com/android/server/appsearch/MockingServiceOptimizeStrategyTest.java
@@ -19,8 +19,11 @@ import static com.android.internal.util.ConcurrentUtils.DIRECT_EXECUTOR;
 
 import static com.google.common.truth.Truth.assertThat;
 
+import android.content.Context;
 import android.provider.DeviceConfig;
 
+import androidx.test.core.app.ApplicationProvider;
+
 import com.android.modules.utils.testing.TestableDeviceConfig;
 import com.android.server.appsearch.icing.proto.GetOptimizeInfoResultProto;
 import com.android.server.appsearch.icing.proto.StatusProto;
@@ -38,6 +41,7 @@ public class MockingServiceOptimizeStrategyTest {
 
     @Test
     public void testShouldNotOptimize_overOtherThresholds_underMinTimeThreshold() {
+        Context context = ApplicationProvider.getApplicationContext();
         // Create ServiceAppSearchConfig with min_time_optimize_threshold <
         // time_optimize_threshold
         DeviceConfig.setProperty(
@@ -61,7 +65,7 @@ public class MockingServiceOptimizeStrategyTest {
                 Integer.toString(0),
                 false);
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
         ServiceOptimizeStrategy mServiceOptimizeStrategy =
                 new ServiceOptimizeStrategy(appSearchConfig);
         // Create optimizeInfo with all values above respective thresholds.
diff --git a/testing/mockingservicestests/src/com/android/server/appsearch/ServiceAppSearchConfigTest.java b/testing/mockingservicestests/src/com/android/server/appsearch/ServiceAppSearchConfigTest.java
index 656d0b0f..c47bb98c 100644
--- a/testing/mockingservicestests/src/com/android/server/appsearch/ServiceAppSearchConfigTest.java
+++ b/testing/mockingservicestests/src/com/android/server/appsearch/ServiceAppSearchConfigTest.java
@@ -19,6 +19,8 @@ package com.android.server.appsearch;
 import static com.android.internal.util.ConcurrentUtils.DIRECT_EXECUTOR;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_API_CALL_STATS_LIMIT;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_BYTES_OPTIMIZE_THRESHOLD;
+import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_COMPRESSION_MEM_LEVEL;
+import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_COMPRESSION_THRESHOLD_BYTES;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_DENYLIST;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_DOC_COUNT_OPTIMIZE_THRESHOLD;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_FULLY_PERSIST_JOB_INTERVAL;
@@ -43,6 +45,7 @@ import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_M
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_MIN_TIME_INTERVAL_BETWEEN_SAMPLES_MILLIS;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_MIN_TIME_OPTIMIZE_THRESHOLD_MILLIS;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_ORPHAN_BLOB_TIME_TO_LIVE_MS;
+import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_PERSIST_DELAY;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_RATE_LIMIT_API_COSTS;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_RATE_LIMIT_ENABLED;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_RATE_LIMIT_TASK_QUEUE_PER_PACKAGE_CAPACITY_PERCENTAGE;
@@ -58,7 +61,10 @@ import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_T
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_USE_NEW_QUALIFIED_ID_JOIN_INDEX;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_API_CALL_STATS_LIMIT;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_BYTES_OPTIMIZE_THRESHOLD;
+import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_COMPRESSION_THRESHOLD_BYTES;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_DOC_COUNT_OPTIMIZE_THRESHOLD;
+import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_FIVE_MINUTE_PERSIST_DELAY;
+import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_FOUR_HOUR_MIN_TIME_OPTIMIZE_THRESHOLD_MILLIS;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_FULLY_PERSIST_JOB_INTERVAL;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_ICING_CONFIG_USE_READ_ONLY_SEARCH;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_INTEGER_INDEX_BUCKET_SPLIT_THRESHOLD;
@@ -71,11 +77,13 @@ import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_LITE_I
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_MAX_OPEN_BLOB_COUNT;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_MIN_TIME_INTERVAL_BETWEEN_SAMPLES_MILLIS;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_MIN_TIME_OPTIMIZE_THRESHOLD_MILLIS;
+import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_PERSIST_DELAY;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_RATE_LIMIT_ENABLED;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_RATE_LIMIT_TASK_QUEUE_PER_PACKAGE_CAPACITY_PERCENTAGE;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_RATE_LIMIT_TASK_QUEUE_TOTAL_CAPACITY;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_SAMPLING_INTERVAL;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_TIME_OPTIMIZE_THRESHOLD_MILLIS;
+import static com.android.server.appsearch.external.localstorage.IcingOptionsConfig.DEFAULT_COMPRESSION_MEM_LEVEL;
 import static com.android.server.appsearch.external.localstorage.IcingOptionsConfig.DEFAULT_ICU_DATA_FILE_ABSOLUTE_PATH;
 import static com.android.server.appsearch.external.localstorage.IcingOptionsConfig.DEFAULT_ORPHAN_BLOB_TIME_TO_LIVE_MS;
 import static com.android.server.appsearch.external.localstorage.IcingOptionsConfig.DEFAULT_USE_NEW_QUALIFIED_ID_JOIN_INDEX;
@@ -83,10 +91,13 @@ import static com.android.server.appsearch.external.localstorage.IcingOptionsCon
 import static com.google.common.truth.Truth.assertThat;
 
 import android.app.appsearch.testutil.AppSearchTestUtils;
+import android.content.Context;
 import android.platform.test.annotations.RequiresFlagsDisabled;
 import android.platform.test.annotations.RequiresFlagsEnabled;
 import android.provider.DeviceConfig;
 
+import androidx.test.core.app.ApplicationProvider;
+
 import com.android.appsearch.flags.Flags;
 import com.android.modules.utils.testing.TestableDeviceConfig;
 import com.android.server.appsearch.external.localstorage.AppSearchConfig;
@@ -100,28 +111,60 @@ import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.RuleChain;
 
+import java.util.concurrent.TimeUnit;
+
 public class ServiceAppSearchConfigTest {
     @Rule
     public final RuleChain mRuleChain =
         AppSearchTestUtils.createCommonTestRules()
             .around(new TestableDeviceConfig.TestableDeviceConfigRule());
+    private final Context context = ApplicationProvider.getApplicationContext();
 
     @Test
     public void testDefaultValues_cachedMinTimeOptimizeThreshold() {
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
+
+        if (Flags.enableFourHourMinTimeOptimizeThreshold()) {
+            assertThat(appSearchConfig.getCachedMinTimeOptimizeThresholdMs())
+                    .isEqualTo(DEFAULT_FOUR_HOUR_MIN_TIME_OPTIMIZE_THRESHOLD_MILLIS);
+        } else {
+            assertThat(appSearchConfig.getCachedMinTimeOptimizeThresholdMs())
+                    .isEqualTo(DEFAULT_MIN_TIME_OPTIMIZE_THRESHOLD_MILLIS);
+        }
+    }
 
-        // TODO (b/385020106): figure out how to make the default 0 timeSinceLastOptimize work
-        //  with a higher threshold and return 4 hours when
-        //  Flags.enable_four_hour_min_optimize_threshold is true
-        assertThat(appSearchConfig.getCachedMinTimeOptimizeThresholdMs())
-                .isEqualTo(DEFAULT_MIN_TIME_OPTIMIZE_THRESHOLD_MILLIS);
+    @Test
+    public void testDefaultValues_cachedPersistDelayMillis() {
+        ServiceAppSearchConfig appSearchConfig =
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
+
+        if (Flags.enableFiveMinPersistToDiskDelay()) {
+            assertThat(appSearchConfig.getCachedPersistDelayMillis())
+                    .isEqualTo(DEFAULT_FIVE_MINUTE_PERSIST_DELAY);
+        } else {
+            assertThat(appSearchConfig.getCachedPersistDelayMillis())
+                    .isEqualTo(DEFAULT_PERSIST_DELAY);
+        }
+    }
+
+    @Test
+    public void testDefaultValues_compressionMemLevel() {
+        ServiceAppSearchConfig appSearchConfig =
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
+
+        if (Flags.enableCompressionMemLevelOne()) {
+            assertThat(appSearchConfig.getCompressionMemLevel()).isEqualTo(1);
+        } else {
+            assertThat(appSearchConfig.getCompressionMemLevel())
+                    .isEqualTo(DEFAULT_COMPRESSION_MEM_LEVEL);
+        }
     }
 
     @Test
     public void testDefaultValues_allCachedValue() {
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
 
         assertThat(appSearchConfig.getCachedMinTimeIntervalBetweenSamplesMillis()).isEqualTo(
                 DEFAULT_MIN_TIME_INTERVAL_BETWEEN_SAMPLES_MILLIS);
@@ -209,6 +252,8 @@ public class ServiceAppSearchConfigTest {
                 .isEqualTo(DEFAULT_ORPHAN_BLOB_TIME_TO_LIVE_MS);
         assertThat(appSearchConfig.getIcuDataFileAbsolutePath())
                 .isEqualTo(DEFAULT_ICU_DATA_FILE_ABSOLUTE_PATH);
+        assertThat(appSearchConfig.getCompressionThresholdBytes())
+                .isEqualTo(DEFAULT_COMPRESSION_THRESHOLD_BYTES);
     }
 
     @Test
@@ -220,7 +265,7 @@ public class ServiceAppSearchConfigTest {
                 false);
 
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
 
         assertThat(appSearchConfig.getCachedMinTimeIntervalBetweenSamplesMillis()).isEqualTo(
                 minTimeIntervalBetweenSamplesMillis);
@@ -234,7 +279,7 @@ public class ServiceAppSearchConfigTest {
                 Long.toString(minTimeIntervalBetweenSamplesMillis),
                 false);
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
 
         minTimeIntervalBetweenSamplesMillis = -2;
         DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
@@ -286,7 +331,7 @@ public class ServiceAppSearchConfigTest {
                 false);
 
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
 
         assertThat(appSearchConfig.getCachedSamplingIntervalDefault()).isEqualTo(
                 samplingIntervalDefault);
@@ -342,7 +387,7 @@ public class ServiceAppSearchConfigTest {
                 Integer.toString(samplingIntervalOptimizeStats),
                 false);
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
 
         // Overrides
         samplingIntervalDefault = -4;
@@ -411,7 +456,7 @@ public class ServiceAppSearchConfigTest {
                 false);
 
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
 
         assertThat(appSearchConfig.getCachedSamplingIntervalForPutDocumentStats()).isEqualTo(
                 samplingIntervalPutDocumentStats);
@@ -435,7 +480,7 @@ public class ServiceAppSearchConfigTest {
                 false);
 
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
 
         assertThat(appSearchConfig.getCachedSamplingIntervalForPutDocumentStats()).isEqualTo(
                 samplingIntervalPutDocumentStats);
@@ -458,7 +503,7 @@ public class ServiceAppSearchConfigTest {
                 false);
 
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
 
         // Sampling values changed.
         samplingIntervalPutDocumentStats = -3;
@@ -493,7 +538,7 @@ public class ServiceAppSearchConfigTest {
                 false);
 
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
 
         // Default sampling interval changed.
         samplingIntervalDefault = -3;
@@ -524,7 +569,7 @@ public class ServiceAppSearchConfigTest {
                 /* makeDefault= */ false);
 
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
         assertThat(appSearchConfig.getMaxDocumentSizeBytes()).isEqualTo(2001);
         assertThat(appSearchConfig.getPerPackageDocumentCountLimit()).isEqualTo(2002);
         assertThat(appSearchConfig.getDocumentCountLimitStartThreshold()).isEqualTo(2003);
@@ -558,7 +603,7 @@ public class ServiceAppSearchConfigTest {
                 /*makeDefault=*/ false);
 
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
         assertThat(appSearchConfig.getMaxSuggestionCount()).isEqualTo(2003);
 
         // Override
@@ -590,7 +635,7 @@ public class ServiceAppSearchConfigTest {
                 false);
 
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
 
         assertThat(appSearchConfig.getCachedBytesOptimizeThreshold()).isEqualTo(147147);
         assertThat(appSearchConfig.getCachedTimeOptimizeThresholdMs()).isEqualTo(258258);
@@ -618,7 +663,7 @@ public class ServiceAppSearchConfigTest {
                 false);
 
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
 
         // Override
         DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
@@ -651,7 +696,7 @@ public class ServiceAppSearchConfigTest {
                 KEY_API_CALL_STATS_LIMIT, Long.toString(dumpsysStatsLimit), false);
 
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
 
         assertThat(appSearchConfig.getCachedApiCallStatsLimit()).isEqualTo(dumpsysStatsLimit);
     }
@@ -662,7 +707,7 @@ public class ServiceAppSearchConfigTest {
         DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
                 KEY_API_CALL_STATS_LIMIT, Long.toString(dumpsysStatsLimit), false);
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
 
         long newDumpsysStatsLimit = 20;
         DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
@@ -677,7 +722,7 @@ public class ServiceAppSearchConfigTest {
                 KEY_DENYLIST, "pkg=foo&db=bar&apis=localSetSchema,localGetSchema", false);
 
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
         assertThat(appSearchConfig.getCachedDenylist().checkDeniedPackageDatabase("foo", "bar",
                 CallStats.CALL_TYPE_SET_SCHEMA)).isTrue();
         assertThat(appSearchConfig.getCachedDenylist().checkDeniedPackageDatabase("foo", "bar",
@@ -689,7 +734,7 @@ public class ServiceAppSearchConfigTest {
     @Test
     public void testCustomizedValueOverride_denylist() {
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
 
         // By default, denylist should be empty
         for (Integer apiType : CallStats.getAllApiCallTypes()) {
@@ -743,9 +788,11 @@ public class ServiceAppSearchConfigTest {
                 KEY_ICING_LITE_INDEX_SORT_AT_INDEXING, Boolean.toString(true), false);
         DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
                 KEY_ICING_LITE_INDEX_SORT_SIZE, Integer.toString(1003), false);
+        DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_COMPRESSION_THRESHOLD_BYTES, Integer.toString(1004), false);
 
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
         assertThat(appSearchConfig.getMaxTokenLength()).isEqualTo(15);
         assertThat(appSearchConfig.getIndexMergeSize()).isEqualTo(1000);
         assertThat(appSearchConfig.getDocumentStoreNamespaceIdFingerprint()).isEqualTo(true);
@@ -758,6 +805,7 @@ public class ServiceAppSearchConfigTest {
         assertThat(appSearchConfig.getIntegerIndexBucketSplitThreshold()).isEqualTo(1002);
         assertThat(appSearchConfig.getLiteIndexSortAtIndexing()).isEqualTo(true);
         assertThat(appSearchConfig.getLiteIndexSortSize()).isEqualTo(1003);
+        assertThat(appSearchConfig.getCompressionThresholdBytes()).isEqualTo(1004);
     }
 
     @Test
@@ -786,9 +834,13 @@ public class ServiceAppSearchConfigTest {
                 KEY_ICING_LITE_INDEX_SORT_AT_INDEXING, Boolean.toString(true), false);
         DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
                 KEY_ICING_LITE_INDEX_SORT_SIZE, Integer.toString(1003), false);
+        DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_COMPRESSION_THRESHOLD_BYTES, Integer.toString(1004), false);
+        DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_COMPRESSION_MEM_LEVEL, Integer.toString(3), false);
 
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
 
         // Override
         DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
@@ -815,6 +867,10 @@ public class ServiceAppSearchConfigTest {
                 KEY_ICING_LITE_INDEX_SORT_AT_INDEXING, Boolean.toString(false), false);
         DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
                 KEY_ICING_LITE_INDEX_SORT_SIZE, Integer.toString(1004), false);
+        DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_COMPRESSION_THRESHOLD_BYTES, Integer.toString(1005), false);
+        DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_COMPRESSION_MEM_LEVEL, Integer.toString(4), false);
 
         assertThat(appSearchConfig.getMaxTokenLength()).isEqualTo(25);
         assertThat(appSearchConfig.getIndexMergeSize()).isEqualTo(2000);
@@ -828,12 +884,14 @@ public class ServiceAppSearchConfigTest {
         assertThat(appSearchConfig.getIntegerIndexBucketSplitThreshold()).isEqualTo(1003);
         assertThat(appSearchConfig.getLiteIndexSortAtIndexing()).isEqualTo(false);
         assertThat(appSearchConfig.getLiteIndexSortSize()).isEqualTo(1004);
+        assertThat(appSearchConfig.getCompressionThresholdBytes()).isEqualTo(1005);
+        assertThat(appSearchConfig.getCompressionMemLevel()).isEqualTo(4);
     }
 
     @Test
     public void testCustomizedValueOverride_rateLimitConfig() {
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
         assertThat(appSearchConfig.getCachedRateLimitEnabled()).isEqualTo(
                 DEFAULT_RATE_LIMIT_ENABLED);
         AppSearchRateLimitConfig rateLimitConfig = appSearchConfig.getCachedRateLimitConfig();
@@ -894,7 +952,7 @@ public class ServiceAppSearchConfigTest {
                 false);
 
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
 
         assertThat(appSearchConfig.getUseNewQualifiedIdJoinIndex()).isEqualTo(true);
     }
@@ -908,7 +966,7 @@ public class ServiceAppSearchConfigTest {
                 false);
 
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
 
         // Override
         DeviceConfig.setProperty(
@@ -928,7 +986,7 @@ public class ServiceAppSearchConfigTest {
                 /*makeDefault=*/ false);
 
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
         assertThat(appSearchConfig.getCachedFullyPersistJobIntervalMillis()).isEqualTo(2003);
 
         // Override
@@ -940,6 +998,28 @@ public class ServiceAppSearchConfigTest {
         assertThat(appSearchConfig.getCachedFullyPersistJobIntervalMillis()).isEqualTo(1777);
     }
 
+    @Test
+    public void testCustomizedValueOverride_persistDelay() {
+        DeviceConfig.setProperty(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_PERSIST_DELAY,
+                Integer.toString(2003),
+                /* makeDefault= */ false);
+
+        ServiceAppSearchConfig appSearchConfig =
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
+        assertThat(appSearchConfig.getCachedPersistDelayMillis()).isEqualTo(2003);
+
+        // Override
+        DeviceConfig.setProperty(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_PERSIST_DELAY,
+                Integer.toString(1777),
+                /* makeDefault= */ false);
+
+        assertThat(appSearchConfig.getCachedPersistDelayMillis()).isEqualTo(1777);
+    }
+
     @Test
     public void testCustomizedValueOverride_blobStore() {
         DeviceConfig.setProperty(
@@ -954,7 +1034,7 @@ public class ServiceAppSearchConfigTest {
                 /* makeDefault= */ false);
 
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
         assertThat(appSearchConfig.getMaxOpenBlobCount()).isEqualTo(2003);
         assertThat(appSearchConfig.getOrphanBlobTimeToLiveMs()).isEqualTo(2004);
 
@@ -978,7 +1058,7 @@ public class ServiceAppSearchConfigTest {
     @RequiresFlagsDisabled(Flags.FLAG_ENABLE_RECOVERY_PROOF_PERSISTENCE)
     public void testGetLightweightPersistType_defaultValue_returnsLite() {
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
         assertThat(appSearchConfig.getLightweightPersistType())
                 .isEqualTo(PersistType.Code.LITE);
     }
@@ -987,7 +1067,7 @@ public class ServiceAppSearchConfigTest {
     @RequiresFlagsEnabled(Flags.FLAG_ENABLE_RECOVERY_PROOF_PERSISTENCE)
     public void testGetLightweightPersistType_defaultValue_returnsRecoveryProof() {
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
         assertThat(appSearchConfig.getLightweightPersistType())
                 .isEqualTo(PersistType.Code.RECOVERY_PROOF);
     }
@@ -1001,7 +1081,7 @@ public class ServiceAppSearchConfigTest {
                 /* makeDefault= */ false);
 
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
         assertThat(appSearchConfig.getLightweightPersistType())
                 .isEqualTo(PersistType.Code.FULL);
     }
@@ -1016,7 +1096,7 @@ public class ServiceAppSearchConfigTest {
                 /* makeDefault= */ false);
 
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
         assertThat(appSearchConfig.getLightweightPersistType())
                 .isEqualTo(PersistType.Code.FULL);
 
@@ -1034,7 +1114,7 @@ public class ServiceAppSearchConfigTest {
     @Test
     public void testNotUsable_afterClose() {
         ServiceAppSearchConfig appSearchConfig =
-                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
 
         appSearchConfig.close();
 
@@ -1139,6 +1219,9 @@ public class ServiceAppSearchConfigTest {
         Assert.assertThrows("Trying to use a closed AppSearchConfig instance.",
                 IllegalStateException.class,
                 () -> appSearchConfig.getCachedFullyPersistJobIntervalMillis());
+        Assert.assertThrows("Trying to use a closed AppSearchConfig instance.",
+                IllegalStateException.class,
+                () -> appSearchConfig.getCachedPersistDelayMillis());
         Assert.assertThrows(
                 "Trying to use a closed AppSearchConfig instance.",
                 IllegalStateException.class,
@@ -1147,5 +1230,13 @@ public class ServiceAppSearchConfigTest {
                 "Trying to use a closed AppSearchConfig instance.",
                 IllegalStateException.class,
                 () -> appSearchConfig.getOrphanBlobTimeToLiveMs());
+        Assert.assertThrows(
+                "Trying to use a closed AppSearchConfig instance.",
+                IllegalStateException.class,
+                () -> appSearchConfig.getCompressionThresholdBytes());
+        Assert.assertThrows(
+                "Trying to use a closed AppSearchConfig instance.",
+                IllegalStateException.class,
+                () -> appSearchConfig.getCompressionMemLevel());
     }
 }
diff --git a/testing/mockingservicestests/src/com/android/server/appsearch/stats/MockingPlatformLoggerTest.java b/testing/mockingservicestests/src/com/android/server/appsearch/stats/MockingPlatformLoggerTest.java
index 85fca267..4b5650fb 100644
--- a/testing/mockingservicestests/src/com/android/server/appsearch/stats/MockingPlatformLoggerTest.java
+++ b/testing/mockingservicestests/src/com/android/server/appsearch/stats/MockingPlatformLoggerTest.java
@@ -20,6 +20,7 @@ import static com.android.internal.util.ConcurrentUtils.DIRECT_EXECUTOR;
 
 import static com.google.common.truth.Truth.assertThat;
 
+import android.content.Context;
 import android.os.SystemClock;
 import android.provider.DeviceConfig;
 
@@ -58,7 +59,8 @@ public class MockingPlatformLoggerTest {
 
     @Before
     public void setUp() throws Exception {
-        mAppSearchConfig = FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+        Context context = ApplicationProvider.getApplicationContext();
+        mAppSearchConfig = FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR, context);
     }
 
     @Test
diff --git a/testing/servicestests/Android.bp b/testing/servicestests/Android.bp
index 02518112..b01b97bd 100644
--- a/testing/servicestests/Android.bp
+++ b/testing/servicestests/Android.bp
@@ -40,7 +40,7 @@ android_test {
         "android.test.runner.stubs.system",
     ],
     // jni libs are not normally accessible from apps so they must be explicitly included.
-    jni_libs: ["libicing"],
+    jni_libs: ["libicing_anywhere"],
     jarjar_rules: "jarjar-rules.txt",
     test_suites: [
         "general-tests",
diff --git a/testing/servicestests/src/android/app/appsearch/testutil/external/testutil/SimpleTestLoggerTest.java b/testing/servicestests/src/android/app/appsearch/testutil/external/testutil/SimpleTestLoggerTest.java
index daad527c..dc90f088 100644
--- a/testing/servicestests/src/android/app/appsearch/testutil/external/testutil/SimpleTestLoggerTest.java
+++ b/testing/servicestests/src/android/app/appsearch/testutil/external/testutil/SimpleTestLoggerTest.java
@@ -24,8 +24,8 @@ import com.android.server.appsearch.external.localstorage.stats.CallStats;
 import com.android.server.appsearch.external.localstorage.stats.InitializeStats;
 import com.android.server.appsearch.external.localstorage.stats.OptimizeStats;
 import com.android.server.appsearch.external.localstorage.stats.PutDocumentStats;
+import com.android.server.appsearch.external.localstorage.stats.QueryStats;
 import com.android.server.appsearch.external.localstorage.stats.RemoveStats;
-import com.android.server.appsearch.external.localstorage.stats.SearchStats;
 import com.android.server.appsearch.external.localstorage.stats.SetSchemaStats;
 
 import org.junit.Test;
@@ -38,7 +38,7 @@ public class SimpleTestLoggerTest {
         assertThat(logger.mCallStats).isNull();
         assertThat(logger.mPutDocumentStats).isNull();
         assertThat(logger.mInitializeStats).isNull();
-        assertThat(logger.mSearchStats).isNull();
+        assertThat(logger.mQueryStats).isNull();
         assertThat(logger.mRemoveStats).isNull();
         assertThat(logger.mOptimizeStats).isNull();
         assertThat(logger.mSetSchemaStats).isEmpty();
@@ -53,7 +53,7 @@ public class SimpleTestLoggerTest {
         logger.logStats(new PutDocumentStats.Builder("package", "db").build());
         logger.logStats(new InitializeStats.Builder().build());
         logger.logStats(
-                new SearchStats.Builder(SearchStats.VISIBILITY_SCOPE_UNKNOWN, "package").build());
+                new QueryStats.Builder(QueryStats.VISIBILITY_SCOPE_UNKNOWN, "package").build());
         logger.logStats(new RemoveStats.Builder("package", "db").build());
         logger.logStats(new OptimizeStats.Builder().build());
         logger.logStats(new SetSchemaStats.Builder("package", "db").build());
@@ -62,7 +62,7 @@ public class SimpleTestLoggerTest {
         assertThat(logger.mCallStats).isNotNull();
         assertThat(logger.mPutDocumentStats).isNotNull();
         assertThat(logger.mInitializeStats).isNotNull();
-        assertThat(logger.mSearchStats).isNotNull();
+        assertThat(logger.mQueryStats).isNotNull();
         assertThat(logger.mRemoveStats).isNotNull();
         assertThat(logger.mOptimizeStats).isNotNull();
         assertThat(logger.mSetSchemaStats).isNotNull();
diff --git a/testing/servicestests/src/com/android/server/appsearch/ServiceOptimizeStrategyTest.java b/testing/servicestests/src/com/android/server/appsearch/ServiceOptimizeStrategyTest.java
index d48b54fb..8effd007 100644
--- a/testing/servicestests/src/com/android/server/appsearch/ServiceOptimizeStrategyTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/ServiceOptimizeStrategyTest.java
@@ -25,7 +25,6 @@ import com.android.appsearch.flags.Flags;
 import com.android.server.appsearch.icing.proto.GetOptimizeInfoResultProto;
 import com.android.server.appsearch.icing.proto.StatusProto;
 
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.RuleChain;
@@ -94,6 +93,23 @@ public class ServiceOptimizeStrategyTest {
         assertThat(mServiceOptimizeStrategy.shouldOptimize(optimizeInfo)).isTrue();
     }
 
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_NEW_OPTIMIZE_STRATEGY_FOR_ACTIVE_RESULT_STATES)
+    public void testShouldOptimize_timeThresholdWithActiveResultStates() {
+        GetOptimizeInfoResultProto optimizeInfo =
+                GetOptimizeInfoResultProto.newBuilder()
+                        .setTimeSinceLastOptimizeMs(
+                                mAppSearchConfig.getCachedTimeOptimizeThresholdMs())
+                        .setEstimatedOptimizableBytes(
+                                mAppSearchConfig.getCachedBytesOptimizeThreshold() - 1)
+                        .setOptimizableDocs(
+                                mAppSearchConfig.getCachedDocCountOptimizeThreshold() - 1)
+                        .setNumActiveResultStates(1)
+                        .setStatus(StatusProto.newBuilder().setCode(StatusProto.Code.OK).build())
+                        .build();
+        assertThat(mServiceOptimizeStrategy.shouldOptimize(optimizeInfo)).isTrue();
+    }
+
     @Test
     public void testShouldOptimize_docCountThreshold() {
         GetOptimizeInfoResultProto optimizeInfo =
@@ -122,10 +138,6 @@ public class ServiceOptimizeStrategyTest {
         assertThat(mServiceOptimizeStrategy.shouldOptimize(optimizeInfo)).isFalse();
     }
 
-    // TODO (b/385020106): figure out how to make the default 0 timeSinceLastOptimize work
-    //  with a higher threshold and return 4 hours when
-    //  Flags.enable_four_hour_min_optimize_threshold is true and reenable
-    @Ignore
     @Test
     @RequiresFlagsEnabled(Flags.FLAG_ENABLE_FOUR_HOUR_MIN_TIME_OPTIMIZE_THRESHOLD)
     public void testShouldNotOptimize_underFourHourMinTimeThreshold() {
@@ -136,6 +148,71 @@ public class ServiceOptimizeStrategyTest {
                                 mAppSearchConfig.getCachedBytesOptimizeThreshold())
                         .setOptimizableDocs(mAppSearchConfig.getCachedDocCountOptimizeThreshold())
                         .setStatus(StatusProto.newBuilder().setCode(StatusProto.Code.OK).build())
+                        .setNoPreviousOptimizeInfo(false)
+                        .build();
+        assertThat(mServiceOptimizeStrategy.shouldOptimize(optimizeInfo)).isFalse();
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_FOUR_HOUR_MIN_TIME_OPTIMIZE_THRESHOLD)
+    public void testShouldOptimize_firstOptimize() {
+        GetOptimizeInfoResultProto optimizeInfo =
+                GetOptimizeInfoResultProto.newBuilder()
+                        .setTimeSinceLastOptimizeMs(0)
+                        .setEstimatedOptimizableBytes(
+                                mAppSearchConfig.getCachedBytesOptimizeThreshold())
+                        .setOptimizableDocs(mAppSearchConfig.getCachedDocCountOptimizeThreshold())
+                        .setStatus(StatusProto.newBuilder().setCode(StatusProto.Code.OK).build())
+                        .setNoPreviousOptimizeInfo(true)
+                        .build();
+        assertThat(mServiceOptimizeStrategy.shouldOptimize(optimizeInfo)).isTrue();
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_NEW_OPTIMIZE_STRATEGY_FOR_ACTIVE_RESULT_STATES)
+    public void testShouldOptimize_noActiveResultStates() {
+        GetOptimizeInfoResultProto optimizeInfo =
+                GetOptimizeInfoResultProto.newBuilder()
+                        .setTimeSinceLastOptimizeMs(
+                                mAppSearchConfig.getCachedMinTimeOptimizeThresholdMs())
+                        .setEstimatedOptimizableBytes(
+                                mAppSearchConfig.getCachedBytesOptimizeThreshold())
+                        .setOptimizableDocs(mAppSearchConfig.getCachedDocCountOptimizeThreshold())
+                        .setNumActiveResultStates(0)
+                        .setStatus(StatusProto.newBuilder().setCode(StatusProto.Code.OK).build())
+                        .build();
+        assertThat(mServiceOptimizeStrategy.shouldOptimize(optimizeInfo)).isTrue();
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_NEW_OPTIMIZE_STRATEGY_FOR_ACTIVE_RESULT_STATES)
+    public void testShouldOptimize_noActiveResultStates_firstTimeOptimize() {
+        GetOptimizeInfoResultProto optimizeInfo =
+                GetOptimizeInfoResultProto.newBuilder()
+                        .setTimeSinceLastOptimizeMs(
+                                mAppSearchConfig.getCachedMinTimeOptimizeThresholdMs() - 1)
+                        .setEstimatedOptimizableBytes(
+                                mAppSearchConfig.getCachedBytesOptimizeThreshold())
+                        .setOptimizableDocs(mAppSearchConfig.getCachedDocCountOptimizeThreshold())
+                        .setNumActiveResultStates(0)
+                        .setStatus(StatusProto.newBuilder().setCode(StatusProto.Code.OK).build())
+                        .setNoPreviousOptimizeInfo(true)
+                        .build();
+        assertThat(mServiceOptimizeStrategy.shouldOptimize(optimizeInfo)).isTrue();
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_NEW_OPTIMIZE_STRATEGY_FOR_ACTIVE_RESULT_STATES)
+    public void testShouldNotOptimize_hasActiveResultStates() {
+        GetOptimizeInfoResultProto optimizeInfo =
+                GetOptimizeInfoResultProto.newBuilder()
+                        .setTimeSinceLastOptimizeMs(
+                                mAppSearchConfig.getCachedMinTimeOptimizeThresholdMs())
+                        .setEstimatedOptimizableBytes(
+                                mAppSearchConfig.getCachedBytesOptimizeThreshold())
+                        .setOptimizableDocs(mAppSearchConfig.getCachedDocCountOptimizeThreshold())
+                        .setNumActiveResultStates(1)
+                        .setStatus(StatusProto.newBuilder().setCode(StatusProto.Code.OK).build())
                         .build();
         assertThat(mServiceOptimizeStrategy.shouldOptimize(optimizeInfo)).isFalse();
     }
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchImplTest.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchImplTest.java
index 2c89d3e5..2242427e 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchImplTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchImplTest.java
@@ -16,6 +16,7 @@
 
 package com.android.server.appsearch.external.localstorage;
 
+import static android.app.appsearch.AppSearchResult.RESULT_ABORTED;
 import static android.app.appsearch.AppSearchResult.RESULT_INVALID_ARGUMENT;
 import static android.app.appsearch.AppSearchResult.RESULT_NOT_FOUND;
 import static android.app.appsearch.AppSearchResult.RESULT_OUT_OF_SPACE;
@@ -25,6 +26,7 @@ import static android.app.appsearch.testutil.AppSearchTestUtils.generateRandomBy
 
 import static com.android.server.appsearch.external.localstorage.util.PrefixUtil.addPrefixToDocument;
 import static com.android.server.appsearch.external.localstorage.util.PrefixUtil.createPrefix;
+import static com.android.server.appsearch.external.localstorage.util.PrefixUtil.getPrefix;
 import static com.android.server.appsearch.external.localstorage.util.PrefixUtil.removePrefixesFromDocument;
 import static com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityStore.BLOB_ANDROID_V_OVERLAY_DATABASE_NAME;
 import static com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityStore.BLOB_VISIBILITY_DATABASE_NAME;
@@ -35,6 +37,8 @@ import static com.android.server.appsearch.external.localstorage.visibilitystore
 import static com.google.common.truth.Truth.assertThat;
 
 import static org.junit.Assert.assertThrows;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.when;
 
 import android.app.appsearch.AppSearchBatchResult;
 import android.app.appsearch.AppSearchBlobHandle;
@@ -42,6 +46,7 @@ import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.Features;
 import android.app.appsearch.GenericDocument;
+import android.app.appsearch.GetByDocumentIdRequest;
 import android.app.appsearch.GetSchemaResponse;
 import android.app.appsearch.InternalSetSchemaResponse;
 import android.app.appsearch.InternalVisibilityConfig;
@@ -59,6 +64,7 @@ import android.app.appsearch.exceptions.AppSearchException;
 import android.app.appsearch.observer.DocumentChangeInfo;
 import android.app.appsearch.observer.ObserverSpec;
 import android.app.appsearch.observer.SchemaChangeInfo;
+import android.app.appsearch.testutil.AppSearchEmail;
 import android.app.appsearch.testutil.AppSearchTestUtils;
 import android.app.appsearch.testutil.TestObserverCallback;
 import android.content.Context;
@@ -78,8 +84,8 @@ import com.android.server.appsearch.appsearch.proto.VisibilityConfigProto;
 import com.android.server.appsearch.external.localstorage.stats.InitializeStats;
 import com.android.server.appsearch.external.localstorage.stats.OptimizeStats;
 import com.android.server.appsearch.external.localstorage.stats.PutDocumentStats;
+import com.android.server.appsearch.external.localstorage.stats.QueryStats;
 import com.android.server.appsearch.external.localstorage.stats.RemoveStats;
-import com.android.server.appsearch.external.localstorage.stats.SearchStats;
 import com.android.server.appsearch.external.localstorage.stats.SetSchemaStats;
 import com.android.server.appsearch.external.localstorage.util.PrefixUtil;
 import com.android.server.appsearch.external.localstorage.visibilitystore.CallerAccess;
@@ -92,14 +98,20 @@ import com.android.server.appsearch.icing.proto.DocumentProto;
 import com.android.server.appsearch.icing.proto.GetOptimizeInfoResultProto;
 import com.android.server.appsearch.icing.proto.GetSchemaResultProto;
 import com.android.server.appsearch.icing.proto.IcingSearchEngineOptions;
+import com.android.server.appsearch.icing.proto.InitializeResultProto;
+import com.android.server.appsearch.icing.proto.PersistToDiskResultProto;
 import com.android.server.appsearch.icing.proto.PersistType;
 import com.android.server.appsearch.icing.proto.PropertyConfigProto;
 import com.android.server.appsearch.icing.proto.PropertyProto;
 import com.android.server.appsearch.icing.proto.PutResultProto;
+import com.android.server.appsearch.icing.proto.ResetResultProto;
 import com.android.server.appsearch.icing.proto.SchemaProto;
 import com.android.server.appsearch.icing.proto.SchemaTypeConfigProto;
+import com.android.server.appsearch.icing.proto.SetSchemaRequestProto;
+import com.android.server.appsearch.icing.proto.SetSchemaResultProto;
 import com.android.server.appsearch.icing.proto.StatusProto;
 import com.android.server.appsearch.icing.proto.StorageInfoProto;
+import com.android.server.appsearch.icing.proto.StorageInfoResultProto;
 import com.android.server.appsearch.icing.proto.StringIndexingConfig;
 import com.android.server.appsearch.icing.proto.TermMatchType;
 import com.android.server.appsearch.protobuf.ByteString;
@@ -119,6 +131,8 @@ import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.RuleChain;
 import org.junit.rules.TemporaryFolder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 
 import java.io.File;
 import java.io.FileOutputStream;
@@ -139,6 +153,11 @@ public class AppSearchImplTest {
      */
     private static final OptimizeStrategy ALWAYS_OPTIMIZE = optimizeInfo -> true;
 
+    private static final StatusProto OK =
+            StatusProto.newBuilder().setCode(StatusProto.Code.OK).build();
+    private static final StatusProto ERROR =
+            StatusProto.newBuilder().setCode(StatusProto.Code.INTERNAL).build();
+
     @Rule public final RuleChain mRuleChain = AppSearchTestUtils.createCommonTestRules();
 
     @Rule public TemporaryFolder mTemporaryFolder = new TemporaryFolder();
@@ -154,8 +173,11 @@ public class AppSearchImplTest {
             new AppSearchConfigImpl(
                     new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig());
 
+    @Mock private IcingSearchEngine mMockIcingSearchEngine;
+
     @Before
     public void setUp() throws Exception {
+        MockitoAnnotations.initMocks(this);
         mAppSearchDir = mTemporaryFolder.newFolder();
         mAppSearchImpl =
                 AppSearchImpl.create(
@@ -177,8 +199,12 @@ public class AppSearchImplTest {
      * Ensure that we can rewrite an incoming schema type by adding the database as a prefix. While
      * also keeping any other existing schema types that may already be part of Icing's persisted
      * schema.
+     *
+     * <p>This test is disabled when database-scoped schema operations are enabled, since
+     * rewriteSchema will not be called with existing types from multiple prefixes in that case.
      */
     @Test
+    @RequiresFlagsDisabled(Flags.FLAG_ENABLE_DATABASE_SCOPED_SCHEMA_OPERATIONS)
     public void testRewriteSchema_addType() throws Exception {
         SchemaProto.Builder existingSchemaBuilder =
                 SchemaProto.newBuilder()
@@ -232,7 +258,10 @@ public class AppSearchImplTest {
 
         AppSearchImpl.RewrittenSchemaResults rewrittenSchemaResults =
                 AppSearchImpl.rewriteSchema(
-                        createPrefix("package", "newDatabase"), existingSchemaBuilder, newSchema);
+                        createPrefix("package", "newDatabase"),
+                        existingSchemaBuilder,
+                        newSchema,
+                        mAppSearchImpl.useDatabaseScopedSchemaOperations());
 
         // We rewrote all the new types that were added. And nothing was removed.
         assertThat(rewrittenSchemaResults.mRewrittenPrefixedTypes.keySet())
@@ -335,15 +364,20 @@ public class AppSearchImplTest {
                 AppSearchImpl.rewriteSchema(
                         createPrefix("package", "existingDatabase"),
                         existingSchemaBuilder,
-                        newSchema);
+                        newSchema,
+                        mAppSearchImpl.useDatabaseScopedSchemaOperations());
 
         // Nothing was removed, but the method did rewrite the type name.
         assertThat(rewrittenSchemaResults.mRewrittenPrefixedTypes.keySet())
                 .containsExactly("package$existingDatabase/Foo");
         assertThat(rewrittenSchemaResults.mDeletedPrefixedTypes).isEmpty();
 
-        // Same schema since nothing was added.
+        // Same schema since nothing was added, but the database field should be populated if
+        // useDatabaseScopedSchemaOperations() is true
         SchemaProto expectedSchema = existingSchemaBuilder.build();
+        if (mAppSearchImpl.useDatabaseScopedSchemaOperations()) {
+            expectedSchema = getSchemaProtoWithDatabase(expectedSchema);
+        }
         assertThat(existingSchemaBuilder.getTypesList())
                 .containsExactlyElementsIn(expectedSchema.getTypesList());
     }
@@ -370,7 +404,8 @@ public class AppSearchImplTest {
                 AppSearchImpl.rewriteSchema(
                         createPrefix("package", "existingDatabase"),
                         existingSchemaBuilder,
-                        newSchema);
+                        newSchema,
+                        mAppSearchImpl.useDatabaseScopedSchemaOperations());
 
         // Bar type was rewritten, but Foo ended up being deleted since it wasn't included in the
         // new schema.
@@ -385,9 +420,11 @@ public class AppSearchImplTest {
                 SchemaProto.newBuilder()
                         .addTypes(
                                 SchemaTypeConfigProto.newBuilder()
-                                        .setSchemaType("package$existingDatabase/Bar")
-                                        .build())
+                                        .setSchemaType("package$existingDatabase/Bar"))
                         .build();
+        if (mAppSearchImpl.useDatabaseScopedSchemaOperations()) {
+            expectedSchema = getSchemaProtoWithDatabase(expectedSchema);
+        }
 
         assertThat(existingSchemaBuilder.getTypesList())
                 .containsExactlyElementsIn(expectedSchema.getTypesList());
@@ -643,13 +680,13 @@ public class AppSearchImplTest {
         assertThat(initStats).isNotNull();
         assertThat(initStats.getStatusCode()).isEqualTo(AppSearchResult.RESULT_INTERNAL_ERROR);
         assertThat(initStats.hasDeSync()).isFalse();
-        assertThat(initStats.getDocumentStoreRecoveryCause())
+        assertThat(initStats.getNativeDocumentStoreRecoveryCause())
                 .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
-        assertThat(initStats.getIndexRestorationCause())
+        assertThat(initStats.getNativeIndexRestorationCause())
                 .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
-        assertThat(initStats.getSchemaStoreRecoveryCause())
+        assertThat(initStats.getNativeSchemaStoreRecoveryCause())
                 .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
-        assertThat(initStats.getDocumentStoreDataStatus())
+        assertThat(initStats.getNativeDocumentStoreDataStatus())
                 .isEqualTo(InitializeStats.DOCUMENT_STORE_DATA_STATUS_NO_DATA_LOSS);
         assertThat(initStats.hasReset()).isTrue();
         assertThat(initStats.getResetStatusCode()).isEqualTo(AppSearchResult.RESULT_OK);
@@ -702,6 +739,404 @@ public class AppSearchImplTest {
         assertThat(results.getResults().get(0).getGenericDocument()).isEqualTo(validDoc);
     }
 
+    @Test
+    public void testResetNativeInitFails_retryWithoutReset() throws Exception {
+        // Setup Icing mock to fail the first init call, but then succeed
+        setUpSuccessfulMocksForCreation();
+        InitializeResultProto failedInit =
+                InitializeResultProto.newBuilder().setStatus(ERROR).build();
+        InitializeResultProto okInit = InitializeResultProto.newBuilder().setStatus(OK).build();
+        when(mMockIcingSearchEngine.initialize()).thenReturn(failedInit, okInit);
+
+        InitializeStats.Builder initStatsBuilder = new InitializeStats.Builder();
+        // Initializing with a custom icing instance will cause AppSearch to assume
+        // isVMEnabled. This will enable both database-scoped operations and init retries.
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        initStatsBuilder,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        mMockIcingSearchEngine,
+                        ALWAYS_OPTIMIZE);
+
+        // Check recovery state
+        InitializeStats initStats = initStatsBuilder.build();
+        assertThat(initStats).isNotNull();
+        assertThat(initStats.getStatusCode()).isEqualTo(AppSearchResult.RESULT_OK);
+        assertThat(initStats.hasReset()).isFalse();
+    }
+
+    @Test
+    public void testResetNativeGetSchemaFails_retryWithoutReset() throws Exception {
+        // Setup Icing mock to fail the first getSchema call, but then succeed
+        setUpSuccessfulMocksForCreation();
+        GetSchemaResultProto failedGetSchema =
+                GetSchemaResultProto.newBuilder().setStatus(ERROR).build();
+        GetSchemaResultProto successGetSchema =
+                GetSchemaResultProto.newBuilder().setStatus(OK).build();
+        when(mMockIcingSearchEngine.getSchema()).thenReturn(failedGetSchema, successGetSchema);
+
+        InitializeStats.Builder initStatsBuilder = new InitializeStats.Builder();
+        // Initializing with a custom icing instance will cause AppSearch to assume
+        // isVMEnabled. This will enable both database-scoped operations and init retries.
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        initStatsBuilder,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        mMockIcingSearchEngine,
+                        ALWAYS_OPTIMIZE);
+
+        // Check recovery state
+        InitializeStats initStats = initStatsBuilder.build();
+        assertThat(initStats).isNotNull();
+        assertThat(initStats.getStatusCode()).isEqualTo(AppSearchResult.RESULT_OK);
+        assertThat(initStats.hasReset()).isFalse();
+    }
+
+    @Test
+    public void testResetNativeGetStorageInfoFails_retryWithoutReset() throws Exception {
+        // Setup Icing mock to fail the first getStorageInfo call, but then succeed
+        setUpSuccessfulMocksForCreation();
+        StorageInfoResultProto failedGetStorageInfo =
+                StorageInfoResultProto.newBuilder().setStatus(ERROR).build();
+        StorageInfoResultProto successGetStorageInfo =
+                StorageInfoResultProto.newBuilder().setStatus(OK).build();
+        when(mMockIcingSearchEngine.getStorageInfo())
+                .thenReturn(failedGetStorageInfo, successGetStorageInfo);
+
+        InitializeStats.Builder initStatsBuilder = new InitializeStats.Builder();
+        // Initializing with a custom icing instance will cause AppSearch to assume
+        // isVMEnabled. This will enable both database-scoped operations and init retries.
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        initStatsBuilder,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        mMockIcingSearchEngine,
+                        ALWAYS_OPTIMIZE);
+
+        // Check recovery state
+        InitializeStats initStats = initStatsBuilder.build();
+        assertThat(initStats).isNotNull();
+        assertThat(initStats.getStatusCode()).isEqualTo(AppSearchResult.RESULT_OK);
+        assertThat(initStats.hasReset()).isFalse();
+    }
+
+    @Test
+    public void testResetNativeInitExhaustsRetries_resets() throws Exception {
+        // Setup Icing mock to fail the first three init calls, but then succeed (if ever called
+        // after)
+        setUpSuccessfulMocksForCreation();
+        InitializeResultProto failedInit =
+                InitializeResultProto.newBuilder().setStatus(ERROR).build();
+        InitializeResultProto okInit = InitializeResultProto.newBuilder().setStatus(OK).build();
+        when(mMockIcingSearchEngine.initialize())
+                .thenReturn(failedInit, failedInit, failedInit, okInit);
+
+        InitializeStats.Builder initStatsBuilder = new InitializeStats.Builder();
+        // Initializing with a custom icing instance will cause AppSearch to assume
+        // isVMEnabled. This will enable both database-scoped operations and init retries.
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        initStatsBuilder,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        mMockIcingSearchEngine,
+                        ALWAYS_OPTIMIZE);
+
+        // Check recovery state
+        InitializeStats initStats = initStatsBuilder.build();
+        assertThat(initStats).isNotNull();
+        assertThat(initStats.getStatusCode()).isEqualTo(AppSearchResult.RESULT_INTERNAL_ERROR);
+        assertThat(initStats.hasReset()).isTrue();
+    }
+
+    @Test
+    public void testResetNativeGetSchemaExhaustsRetries_resets() throws Exception {
+        // Setup Icing mock to fail the three getSchema call, but then succeed (if ever called).
+        setUpSuccessfulMocksForCreation();
+        GetSchemaResultProto failedGetSchema =
+                GetSchemaResultProto.newBuilder().setStatus(ERROR).build();
+        GetSchemaResultProto successGetSchema =
+                GetSchemaResultProto.newBuilder().setStatus(OK).build();
+        when(mMockIcingSearchEngine.getSchema())
+                .thenReturn(failedGetSchema, failedGetSchema, failedGetSchema, successGetSchema);
+
+        InitializeStats.Builder initStatsBuilder = new InitializeStats.Builder();
+        // Initializing with a custom icing instance will cause AppSearch to assume
+        // isVMEnabled. This will enable both database-scoped operations and init retries.
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        initStatsBuilder,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        mMockIcingSearchEngine,
+                        ALWAYS_OPTIMIZE);
+
+        // Check recovery state
+        InitializeStats initStats = initStatsBuilder.build();
+        assertThat(initStats).isNotNull();
+        assertThat(initStats.getStatusCode()).isEqualTo(AppSearchResult.RESULT_INTERNAL_ERROR);
+        assertThat(initStats.hasReset()).isTrue();
+    }
+
+    @Test
+    public void testResetNativeGetStorageInfoExhaustsRetries_resets() throws Exception {
+        // Setup Icing mock to fail the first three getStorageInfo calls, but then succeed (if ever
+        // called again)
+        setUpSuccessfulMocksForCreation();
+
+        StorageInfoResultProto failedGetStorageInfo =
+                StorageInfoResultProto.newBuilder().setStatus(ERROR).build();
+        StorageInfoResultProto successGetStorageInfo =
+                StorageInfoResultProto.newBuilder().setStatus(OK).build();
+        when(mMockIcingSearchEngine.getStorageInfo())
+                .thenReturn(
+                        failedGetStorageInfo,
+                        failedGetStorageInfo,
+                        failedGetStorageInfo,
+                        successGetStorageInfo);
+
+        InitializeStats.Builder initStatsBuilder = new InitializeStats.Builder();
+        // Initializing with a custom icing instance will cause AppSearch to assume
+        // isVMEnabled. This will enable both database-scoped operations and init retries.
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        initStatsBuilder,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        mMockIcingSearchEngine,
+                        ALWAYS_OPTIMIZE);
+
+        // Check recovery state
+        InitializeStats initStats = initStatsBuilder.build();
+        assertThat(initStats).isNotNull();
+        assertThat(initStats.getStatusCode()).isEqualTo(AppSearchResult.RESULT_INTERNAL_ERROR);
+        assertThat(initStats.hasReset()).isTrue();
+    }
+
+    @Test
+    public void testResetNativeCallsExhaustsRetries_resets() throws Exception {
+        // Setup Icing mock to fail the first call for all native apis. This will exceed the max
+        // retry limit and trigger a reset.
+        setUpSuccessfulMocksForCreation();
+        InitializeResultProto failedInit =
+                InitializeResultProto.newBuilder().setStatus(ERROR).build();
+        InitializeResultProto okInit = InitializeResultProto.newBuilder().setStatus(OK).build();
+        when(mMockIcingSearchEngine.initialize()).thenReturn(failedInit, okInit);
+
+        GetSchemaResultProto failedGetSchema =
+                GetSchemaResultProto.newBuilder().setStatus(ERROR).build();
+        GetSchemaResultProto successGetSchema =
+                GetSchemaResultProto.newBuilder().setStatus(OK).build();
+        when(mMockIcingSearchEngine.getSchema()).thenReturn(failedGetSchema, successGetSchema);
+
+        StorageInfoResultProto failedGetStorageInfo =
+                StorageInfoResultProto.newBuilder().setStatus(ERROR).build();
+        StorageInfoResultProto successGetStorageInfo =
+                StorageInfoResultProto.newBuilder().setStatus(OK).build();
+        when(mMockIcingSearchEngine.getStorageInfo())
+                .thenReturn(failedGetStorageInfo, successGetStorageInfo);
+
+        InitializeStats.Builder initStatsBuilder = new InitializeStats.Builder();
+        // Initializing with a custom icing instance will cause AppSearch to assume
+        // isVMEnabled. This will enable both database-scoped operations and init retries.
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        initStatsBuilder,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        mMockIcingSearchEngine,
+                        ALWAYS_OPTIMIZE);
+
+        // Check recovery state
+        InitializeStats initStats = initStatsBuilder.build();
+        assertThat(initStats).isNotNull();
+        assertThat(initStats.getStatusCode()).isEqualTo(AppSearchResult.RESULT_INTERNAL_ERROR);
+        assertThat(initStats.hasReset()).isTrue();
+    }
+
+    @Test
+    public void testResetWithSchemaDatabaseMigration() throws Exception {
+        IcingSearchEngineOptions.Builder optionsBuilder =
+                IcingSearchEngineOptions.newBuilder(
+                        mUnlimitedConfig.toIcingSearchEngineOptions(
+                                mAppSearchDir.getAbsolutePath(), /* isVMEnabled= */ false));
+        // Initialize Icing without schema database enabled.
+        IcingSearchEngine icingSearchEngine =
+                new IcingSearchEngine(optionsBuilder.setEnableSchemaDatabase(false).build());
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        mUnlimitedConfig,
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        // Initializing with a custom icing instance will cause AppSearch to assume
+                        // isVMEnabled. Therefore we cannot call AppSearch::setSchema below since
+                        // it'll still use database-scoped operations.
+                        icingSearchEngine,
+                        ALWAYS_OPTIMIZE);
+
+        SchemaProto existingSchema = mAppSearchImpl.getSchemaProtoLocked();
+        // Insert some schemas in 2 databases. We need to use the full SchemaProto and call Icing's
+        // set schema API directly as AppSearch will use database-scoped schema operation since
+        // we initialized with a custom icing instance (which AppSearch understands as having VM
+        // enabled). This will fail as the Icing instance has not enabled schema database.
+        SchemaProto expectedProto =
+                SchemaProto.newBuilder()
+                        .addTypes(
+                                SchemaTypeConfigProto.newBuilder()
+                                        .setSchemaType("package$database1/Type1")
+                                        .setDescription("")
+                                        .setVersion(0))
+                        .addTypes(
+                                SchemaTypeConfigProto.newBuilder()
+                                        .setSchemaType("package$database1/Type2")
+                                        .setDescription("")
+                                        .setVersion(0))
+                        .addTypes(
+                                SchemaTypeConfigProto.newBuilder()
+                                        .setSchemaType("package$database2/Type3")
+                                        .setDescription("")
+                                        .setVersion(0))
+                        .build();
+        SchemaProto fullSchema =
+                SchemaProto.newBuilder(existingSchema)
+                        .addAllTypes(expectedProto.getTypesList())
+                        .build();
+        SetSchemaRequestProto requestProto =
+                SetSchemaRequestProto.newBuilder()
+                        .setSchema(fullSchema)
+                        .setIgnoreErrorsAndDeleteDocuments(false)
+                        .build();
+        assertThat(icingSearchEngine.setSchemaWithRequestProto(requestProto).getStatus().getCode())
+                .isEqualTo(StatusProto.Code.OK);
+
+        // We need to get the full schema here since Icing doesn't have schema database enabled,
+        // which also disables the getSchemaForPrefix API. The schema should be exactly the same
+        // as what we've just set, without the database fields being populated.
+        assertThat(mAppSearchImpl.getSchemaProtoLocked().getTypesList())
+                .containsExactlyElementsIn(fullSchema.getTypesList());
+
+        // Reinitialize Icing and AppSearch, this time with schema database enabled.
+        InitializeStats.Builder initStatsBuilder = new InitializeStats.Builder();
+        icingSearchEngine =
+                new IcingSearchEngine(optionsBuilder.setEnableSchemaDatabase(true).build());
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        mUnlimitedConfig,
+                        initStatsBuilder,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        icingSearchEngine,
+                        ALWAYS_OPTIMIZE);
+
+        // Initialization should NOT trigger a recovery
+        InitializeStats initStats = initStatsBuilder.build();
+        assertThat(initStats.getNativeDocumentStoreRecoveryCause())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
+        assertThat(initStats.getNativeIndexRestorationCause())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
+
+        // GetSchema for db1 and db2. The old schema should have the database field populated
+        // after the migration
+        SchemaProto expectedDb1Proto =
+                SchemaProto.newBuilder()
+                        .addTypes(
+                                SchemaTypeConfigProto.newBuilder()
+                                        .setSchemaType("package$database1/Type1")
+                                        .setDatabase("package$database1/")
+                                        .setDescription("")
+                                        .setVersion(0))
+                        .addTypes(
+                                SchemaTypeConfigProto.newBuilder()
+                                        .setSchemaType("package$database1/Type2")
+                                        .setDatabase("package$database1/")
+                                        .setDescription("")
+                                        .setVersion(0))
+                        .build();
+        SchemaProto expectedDb2Proto =
+                SchemaProto.newBuilder()
+                        .addTypes(
+                                SchemaTypeConfigProto.newBuilder()
+                                        .setSchemaType("package$database2/Type3")
+                                        .setDatabase("package$database2/")
+                                        .setDescription("")
+                                        .setVersion(0))
+                        .build();
+        assertThat(
+                        mAppSearchImpl
+                                .getSchemaProtoForPrefixLocked("package$database1/")
+                                .getTypesList())
+                .containsExactlyElementsIn(expectedDb1Proto.getTypesList());
+        assertThat(
+                        mAppSearchImpl
+                                .getSchemaProtoForPrefixLocked("package$database2/")
+                                .getTypesList())
+                .containsExactlyElementsIn(expectedDb2Proto.getTypesList());
+
+        // SetSchema for database 1 again. We can use the AppSearch API this time since we've
+        // enabled database-scoped schema operation for Icing too. Check that the old db1 schema
+        // gets overridden and db2 is not affected
+        List<AppSearchSchema> schemas =
+                Collections.singletonList(new AppSearchSchema.Builder("Type4").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package",
+                        "database1",
+                        schemas,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ true,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+
+        // expectedDb1Proto has changed. The proto should contain the database field.
+        expectedDb1Proto =
+                SchemaProto.newBuilder()
+                        .addTypes(
+                                SchemaTypeConfigProto.newBuilder()
+                                        .setSchemaType("package$database1/Type4")
+                                        .setDatabase("package$database1/")
+                                        .setDescription("")
+                                        .setVersion(0))
+                        .build();
+        assertThat(
+                        mAppSearchImpl
+                                .getSchemaProtoForPrefixLocked("package$database1/")
+                                .getTypesList())
+                .containsExactlyElementsIn(expectedDb1Proto.getTypesList());
+        assertThat(
+                        mAppSearchImpl
+                                .getSchemaProtoForPrefixLocked("package$database2/")
+                                .getTypesList())
+                .containsExactlyElementsIn(expectedDb2Proto.getTypesList());
+    }
+
     @Test
     public void testQueryEmptyDatabase() throws Exception {
         SearchSpec searchSpec =
@@ -712,6 +1147,79 @@ public class AppSearchImplTest {
         assertThat(searchResultPage.getResults()).isEmpty();
     }
 
+    @Test
+    public void testQueryWithPageSizeLimit() throws Exception {
+        IcingSearchEngineOptions icingOptions =
+                IcingSearchEngineOptions.newBuilder(
+                                mUnlimitedConfig.toIcingSearchEngineOptions(
+                                        mAppSearchDir.getAbsolutePath(), /* isVMEnabled= */ false))
+                        .setEnableStrictPageByteSizeLimit(true)
+                        .build();
+        IcingSearchEngine icingSearchEngine = new IcingSearchEngine(icingOptions);
+        AppSearchConfig appSearchConfig =
+                new AppSearchConfigImpl(
+                        new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()) {
+                    @Override
+                    // Set a very small page byte size limit -- this means that each search result
+                    // page
+                    // would normally be able to fit one result only.
+                    public int getMaxPageBytesLimit() {
+                        return 1;
+                    }
+                };
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        appSearchConfig,
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        icingSearchEngine,
+                        ALWAYS_OPTIMIZE);
+
+        // Insert schema
+        List<AppSearchSchema> schema = ImmutableList.of(AppSearchEmail.SCHEMA);
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package1",
+                        "database1",
+                        schema,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+
+        // Insert 5 documents
+        for (int i = 0; i < 5; i++) {
+            AppSearchEmail email =
+                    new AppSearchEmail.Builder("namespace", "id" + i)
+                            .setFrom("from@example.com")
+                            .setTo("to1@example.com", "to2@example.com")
+                            .setSubject("testPut example")
+                            .setBody("This is the body of the testPut email")
+                            .build();
+            mAppSearchImpl.putDocument(
+                    "package1",
+                    "database1",
+                    email,
+                    /* sendChangeNotifications= */ false,
+                    /* logger= */ null);
+        }
+
+        // Search for the documents, all 5 documents should be returned despite the page size limit
+        SearchSpec searchSpec =
+                new SearchSpec.Builder()
+                        .setTermMatch(TermMatchType.Code.PREFIX_VALUE)
+                        .setResultCountPerPage(5)
+                        .build();
+        SearchResultPage searchResultPage =
+                mAppSearchImpl.query("package1", "database1", "", searchSpec, /* logger= */ null);
+        assertThat(searchResultPage.getResults()).hasSize(5);
+        assertThat(searchResultPage.getNextPageToken())
+                .isEqualTo(SearchResultPage.EMPTY_PAGE_TOKEN);
+    }
+
     @Test
     public void testBatchPut_emptyList_noDocInserted() throws Exception {
         // Insert package1 schema
@@ -2047,11 +2555,193 @@ public class AppSearchImplTest {
                         .setResultCountPerPage(1)
                         .build();
         SearchResultPage searchResultPage =
-                mAppSearchImpl.globalQuery(
-                        /* queryExpression= */ "",
-                        searchSpec,
-                        new CallerAccess(/* callingPackageName= */ "package1"),
-                        /* logger= */ null);
+                mAppSearchImpl.globalQuery(
+                        /* queryExpression= */ "",
+                        searchSpec,
+                        new CallerAccess(/* callingPackageName= */ "package1"),
+                        /* logger= */ null);
+
+        // Document2 will come first because it was inserted last and default return order is
+        // most recent.
+        assertThat(searchResultPage.getResults()).hasSize(1);
+        assertThat(searchResultPage.getResults().get(0).getGenericDocument()).isEqualTo(document2);
+
+        long nextPageToken = searchResultPage.getNextPageToken();
+
+        // Try getting next page with the wrong package, package2
+        AppSearchException e =
+                assertThrows(
+                        AppSearchException.class,
+                        () ->
+                                mAppSearchImpl.getNextPage(
+                                        "package2", nextPageToken, /* statsBuilder= */ null));
+        assertThat(e)
+                .hasMessageThat()
+                .contains("Package \"package2\" cannot use nextPageToken: " + nextPageToken);
+        assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_SECURITY_ERROR);
+
+        // Can continue getting next page for package1
+        searchResultPage =
+                mAppSearchImpl.getNextPage("package1", nextPageToken, /* statsBuilder= */ null);
+        assertThat(searchResultPage.getResults()).hasSize(1);
+        assertThat(searchResultPage.getResults().get(0).getGenericDocument()).isEqualTo(document1);
+    }
+
+    @Test
+    public void testInvalidateNextPageToken_query() throws Exception {
+        // Insert package1 schema
+        List<AppSearchSchema> schema1 =
+                ImmutableList.of(new AppSearchSchema.Builder("schema1").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package1",
+                        "database1",
+                        schema1,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+
+        // Insert two package1 documents
+        GenericDocument document1 =
+                new GenericDocument.Builder<>("namespace", "id1", "schema1").build();
+        GenericDocument document2 =
+                new GenericDocument.Builder<>("namespace", "id2", "schema1").build();
+        mAppSearchImpl.putDocument(
+                "package1",
+                "database1",
+                document1,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+        mAppSearchImpl.putDocument(
+                "package1",
+                "database1",
+                document2,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+
+        // Query for only 1 result per page
+        SearchSpec searchSpec =
+                new SearchSpec.Builder()
+                        .setTermMatch(TermMatchType.Code.PREFIX_VALUE)
+                        .setResultCountPerPage(1)
+                        .build();
+        SearchResultPage searchResultPage =
+                mAppSearchImpl.query("package1", "database1", "", searchSpec, /* logger= */ null);
+
+        // Document2 will come first because it was inserted last and default return order is
+        // most recent.
+        assertThat(searchResultPage.getResults()).hasSize(1);
+        assertThat(searchResultPage.getResults().get(0).getGenericDocument()).isEqualTo(document2);
+
+        long nextPageToken = searchResultPage.getNextPageToken();
+
+        // Invalidate the token
+        mAppSearchImpl.invalidateNextPageToken("package1", nextPageToken);
+
+        // Can't get next page because we invalidated the token.
+        AppSearchException e =
+                assertThrows(
+                        AppSearchException.class,
+                        () ->
+                                mAppSearchImpl.getNextPage(
+                                        "package1", nextPageToken, /* statsBuilder= */ null));
+        assertThat(e)
+                .hasMessageThat()
+                .contains("Package \"package1\" cannot use nextPageToken: " + nextPageToken);
+        assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_SECURITY_ERROR);
+    }
+
+    @Test
+    public void testInvalidateNextPageToken_zeroNextPageToken() throws Exception {
+        // Insert package1 schema
+        List<AppSearchSchema> schema1 =
+                ImmutableList.of(new AppSearchSchema.Builder("schema1").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package1",
+                        "database1",
+                        schema1,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+
+        // Insert one package1 documents
+        GenericDocument document1 =
+                new GenericDocument.Builder<>("namespace", "id1", "schema1").build();
+        mAppSearchImpl.putDocument(
+                "package1",
+                "database1",
+                document1,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+
+        // Query for 2 results per page, so all the results can fit in one page.
+        SearchSpec searchSpec =
+                new SearchSpec.Builder()
+                        .setTermMatch(TermMatchType.Code.PREFIX_VALUE)
+                        .setResultCountPerPage(
+                                2) // make sure all the results can be returned in one page.
+                        .build();
+        SearchResultPage searchResultPage =
+                mAppSearchImpl.query("package1", "database1", "", searchSpec, /* logger= */ null);
+
+        // We only have one document indexed
+        assertThat(searchResultPage.getResults()).hasSize(1);
+
+        // nextPageToken should be 0 since there is no more results
+        long nextPageToken = searchResultPage.getNextPageToken();
+        assertThat(nextPageToken).isEqualTo(0);
+
+        // Invalidate the token, no exception should be thrown
+        mAppSearchImpl.invalidateNextPageToken("package1", nextPageToken);
+    }
+
+    @Test
+    public void testInvalidateNextPageTokenWithDifferentPackage_query() throws Exception {
+        // Insert package1 schema
+        List<AppSearchSchema> schema1 =
+                ImmutableList.of(new AppSearchSchema.Builder("schema1").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package1",
+                        "database1",
+                        schema1,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+
+        // Insert two package1 documents
+        GenericDocument document1 =
+                new GenericDocument.Builder<>("namespace", "id1", "schema1").build();
+        GenericDocument document2 =
+                new GenericDocument.Builder<>("namespace", "id2", "schema1").build();
+        mAppSearchImpl.putDocument(
+                "package1",
+                "database1",
+                document1,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+        mAppSearchImpl.putDocument(
+                "package1",
+                "database1",
+                document2,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+
+        // Query for only 1 result per page
+        SearchSpec searchSpec =
+                new SearchSpec.Builder()
+                        .setTermMatch(TermMatchType.Code.PREFIX_VALUE)
+                        .setResultCountPerPage(1)
+                        .build();
+        SearchResultPage searchResultPage =
+                mAppSearchImpl.query("package1", "database1", "", searchSpec, /* logger= */ null);
 
         // Document2 will come first because it was inserted last and default return order is
         // most recent.
@@ -2064,9 +2754,7 @@ public class AppSearchImplTest {
         AppSearchException e =
                 assertThrows(
                         AppSearchException.class,
-                        () ->
-                                mAppSearchImpl.getNextPage(
-                                        "package2", nextPageToken, /* statsBuilder= */ null));
+                        () -> mAppSearchImpl.invalidateNextPageToken("package2", nextPageToken));
         assertThat(e)
                 .hasMessageThat()
                 .contains("Package \"package2\" cannot use nextPageToken: " + nextPageToken);
@@ -2080,7 +2768,7 @@ public class AppSearchImplTest {
     }
 
     @Test
-    public void testInvalidateNextPageToken_query() throws Exception {
+    public void testInvalidateNextPageToken_globalQuery() throws Exception {
         // Insert package1 schema
         List<AppSearchSchema> schema1 =
                 ImmutableList.of(new AppSearchSchema.Builder("schema1").build());
@@ -2120,7 +2808,11 @@ public class AppSearchImplTest {
                         .setResultCountPerPage(1)
                         .build();
         SearchResultPage searchResultPage =
-                mAppSearchImpl.query("package1", "database1", "", searchSpec, /* logger= */ null);
+                mAppSearchImpl.globalQuery(
+                        /* queryExpression= */ "",
+                        searchSpec,
+                        new CallerAccess(/* callingPackageName= */ "package1"),
+                        /* logger= */ null);
 
         // Document2 will come first because it was inserted last and default return order is
         // most recent.
@@ -2146,54 +2838,7 @@ public class AppSearchImplTest {
     }
 
     @Test
-    public void testInvalidateNextPageToken_zeroNextPageToken() throws Exception {
-        // Insert package1 schema
-        List<AppSearchSchema> schema1 =
-                ImmutableList.of(new AppSearchSchema.Builder("schema1").build());
-        InternalSetSchemaResponse internalSetSchemaResponse =
-                mAppSearchImpl.setSchema(
-                        "package1",
-                        "database1",
-                        schema1,
-                        /* visibilityConfigs= */ Collections.emptyList(),
-                        /* forceOverride= */ false,
-                        /* version= */ 0,
-                        /* setSchemaStatsBuilder= */ null);
-        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
-
-        // Insert one package1 documents
-        GenericDocument document1 =
-                new GenericDocument.Builder<>("namespace", "id1", "schema1").build();
-        mAppSearchImpl.putDocument(
-                "package1",
-                "database1",
-                document1,
-                /* sendChangeNotifications= */ false,
-                /* logger= */ null);
-
-        // Query for 2 results per page, so all the results can fit in one page.
-        SearchSpec searchSpec =
-                new SearchSpec.Builder()
-                        .setTermMatch(TermMatchType.Code.PREFIX_VALUE)
-                        .setResultCountPerPage(
-                                2) // make sure all the results can be returned in one page.
-                        .build();
-        SearchResultPage searchResultPage =
-                mAppSearchImpl.query("package1", "database1", "", searchSpec, /* logger= */ null);
-
-        // We only have one document indexed
-        assertThat(searchResultPage.getResults()).hasSize(1);
-
-        // nextPageToken should be 0 since there is no more results
-        long nextPageToken = searchResultPage.getNextPageToken();
-        assertThat(nextPageToken).isEqualTo(0);
-
-        // Invalidate the token, no exception should be thrown
-        mAppSearchImpl.invalidateNextPageToken("package1", nextPageToken);
-    }
-
-    @Test
-    public void testInvalidateNextPageTokenWithDifferentPackage_query() throws Exception {
+    public void testInvalidateNextPageTokenWithDifferentPackage_globalQuery() throws Exception {
         // Insert package1 schema
         List<AppSearchSchema> schema1 =
                 ImmutableList.of(new AppSearchSchema.Builder("schema1").build());
@@ -2233,7 +2878,11 @@ public class AppSearchImplTest {
                         .setResultCountPerPage(1)
                         .build();
         SearchResultPage searchResultPage =
-                mAppSearchImpl.query("package1", "database1", "", searchSpec, /* logger= */ null);
+                mAppSearchImpl.globalQuery(
+                        /* queryExpression= */ "",
+                        searchSpec,
+                        new CallerAccess(/* callingPackageName= */ "package1"),
+                        /* logger= */ null);
 
         // Document2 will come first because it was inserted last and default return order is
         // most recent.
@@ -2260,7 +2909,11 @@ public class AppSearchImplTest {
     }
 
     @Test
-    public void testInvalidateNextPageToken_globalQuery() throws Exception {
+    @RequiresFlagsEnabled({
+        Flags.FLAG_ENABLE_RESULT_ABORTED,
+        Flags.FLAG_ENABLE_THROW_EXCEPTION_FOR_NATIVE_NOT_FOUND_PAGE_TOKEN
+    })
+    public void testEvictedNextPageToken_flagEnabledShouldThrow() throws Exception {
         // Insert package1 schema
         List<AppSearchSchema> schema1 =
                 ImmutableList.of(new AppSearchSchema.Builder("schema1").build());
@@ -2312,25 +2965,29 @@ public class AppSearchImplTest {
         assertThat(searchResultPage.getResults().get(0).getGenericDocument()).isEqualTo(document2);
 
         long nextPageToken = searchResultPage.getNextPageToken();
+        assertThat(nextPageToken).isNotEqualTo(0);
 
-        // Invalidate the token
-        mAppSearchImpl.invalidateNextPageToken("package1", nextPageToken);
+        // Call Optimize.
+        mAppSearchImpl.optimize(/* builder= */ null);
 
-        // Can't get next page because we invalidated the token.
+        // All page tokens are evicted after optimize, so AppSearchException with code
+        // RESULT_ABORTED will be thrown.
         AppSearchException e =
                 assertThrows(
                         AppSearchException.class,
                         () ->
                                 mAppSearchImpl.getNextPage(
                                         "package1", nextPageToken, /* statsBuilder= */ null));
+        assertThat(e.getResultCode()).isEqualTo(RESULT_ABORTED);
         assertThat(e)
                 .hasMessageThat()
-                .contains("Package \"package1\" cannot use nextPageToken: " + nextPageToken);
-        assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_SECURITY_ERROR);
+                .contains(
+                        "Page token not found. It is usually caused by pagination cache eviction.");
     }
 
     @Test
-    public void testInvalidateNextPageTokenWithDifferentPackage_globalQuery() throws Exception {
+    @RequiresFlagsDisabled(Flags.FLAG_ENABLE_THROW_EXCEPTION_FOR_NATIVE_NOT_FOUND_PAGE_TOKEN)
+    public void testEvictedNextPageToken_flagDisabledShouldReturnEmptyResult() throws Exception {
         // Insert package1 schema
         List<AppSearchSchema> schema1 =
                 ImmutableList.of(new AppSearchSchema.Builder("schema1").build());
@@ -2382,22 +3039,17 @@ public class AppSearchImplTest {
         assertThat(searchResultPage.getResults().get(0).getGenericDocument()).isEqualTo(document2);
 
         long nextPageToken = searchResultPage.getNextPageToken();
+        assertThat(nextPageToken).isNotEqualTo(0);
 
-        // Try getting next page with the wrong package, package2
-        AppSearchException e =
-                assertThrows(
-                        AppSearchException.class,
-                        () -> mAppSearchImpl.invalidateNextPageToken("package2", nextPageToken));
-        assertThat(e)
-                .hasMessageThat()
-                .contains("Package \"package2\" cannot use nextPageToken: " + nextPageToken);
-        assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_SECURITY_ERROR);
+        // Call Optimize.
+        mAppSearchImpl.optimize(/* builder= */ null);
 
-        // Can continue getting next page for package1
-        searchResultPage =
+        // All page tokens are evicted after optimize. getNextPage should return an empty page if
+        // the flag is disabled.
+        SearchResultPage searchResultPage2 =
                 mAppSearchImpl.getNextPage("package1", nextPageToken, /* statsBuilder= */ null);
-        assertThat(searchResultPage.getResults()).hasSize(1);
-        assertThat(searchResultPage.getResults().get(0).getGenericDocument()).isEqualTo(document1);
+        assertThat(searchResultPage2.getResults()).isEmpty();
+        assertThat(searchResultPage2.getNextPageToken()).isEqualTo(0);
     }
 
     @Test
@@ -2451,6 +3103,9 @@ public class AppSearchImplTest {
                                         .setDescription("")
                                         .setVersion(0))
                         .build();
+        if (mAppSearchImpl.useDatabaseScopedSchemaOperations()) {
+            expectedProto = getSchemaProtoWithDatabase(expectedProto);
+        }
 
         List<SchemaTypeConfigProto> expectedTypes = new ArrayList<>();
         expectedTypes.addAll(existingSchemas);
@@ -2545,6 +3200,9 @@ public class AppSearchImplTest {
                                         .setDescription("")
                                         .setVersion(0))
                         .build();
+        if (mAppSearchImpl.useDatabaseScopedSchemaOperations()) {
+            expectedProto = getSchemaProtoWithDatabase(expectedProto);
+        }
 
         // Check both schema Email and Document saved correctly.
         List<SchemaTypeConfigProto> expectedTypes = new ArrayList<>();
@@ -2591,6 +3249,9 @@ public class AppSearchImplTest {
                                         .setDescription("")
                                         .setVersion(0))
                         .build();
+        if (mAppSearchImpl.useDatabaseScopedSchemaOperations()) {
+            expectedProto = getSchemaProtoWithDatabase(expectedProto);
+        }
 
         expectedTypes = new ArrayList<>();
         expectedTypes.addAll(existingSchemas);
@@ -2656,6 +3317,9 @@ public class AppSearchImplTest {
                                         .setDescription("")
                                         .setVersion(0))
                         .build();
+        if (mAppSearchImpl.useDatabaseScopedSchemaOperations()) {
+            expectedProto = getSchemaProtoWithDatabase(expectedProto);
+        }
 
         // Check Email and Document is saved in database 1 and 2 correctly.
         List<SchemaTypeConfigProto> expectedTypes = new ArrayList<>();
@@ -2697,6 +3361,9 @@ public class AppSearchImplTest {
                                         .setDescription("")
                                         .setVersion(0))
                         .build();
+        if (mAppSearchImpl.useDatabaseScopedSchemaOperations()) {
+            expectedProto = getSchemaProtoWithDatabase(expectedProto);
+        }
 
         // Check nothing changed in database2.
         expectedTypes = new ArrayList<>();
@@ -3829,6 +4496,10 @@ public class AppSearchImplTest {
                                         .setDescription("")
                                         .setVersion(0))
                         .build();
+        if (mAppSearchImpl.useDatabaseScopedSchemaOperations()) {
+            expectedProto = getSchemaProtoWithDatabase(expectedProto);
+        }
+
         List<SchemaTypeConfigProto> expectedTypes = new ArrayList<>();
         expectedTypes.addAll(existingSchemas);
         expectedTypes.addAll(expectedProto.getTypesList());
@@ -3875,6 +4546,102 @@ public class AppSearchImplTest {
                 .isNull();
     }
 
+    @Test
+    public void testPrunePackageData_overDatabaseScopedThreshold() throws AppSearchException {
+        List<SchemaTypeConfigProto> existingSchemas =
+                mAppSearchImpl.getSchemaProtoLocked().getTypesList();
+        Map<String, Set<String>> existingDatabases = mAppSearchImpl.getPackageToDatabases();
+
+        Set<String> existingPackages = new ArraySet<>(existingSchemas.size());
+        for (int i = 0; i < existingSchemas.size(); i++) {
+            existingPackages.add(PrefixUtil.getPackageName(existingSchemas.get(i).getSchemaType()));
+        }
+
+        // Create VisibilityConfig
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder("schema")
+                        .setNotDisplayedBySystem(true)
+                        .addVisibleToPackage(new PackageIdentifier("pkgBar", new byte[32]))
+                        .build();
+
+        // Insert schema for package A and B.
+        List<AppSearchSchema> schema =
+                ImmutableList.of(new AppSearchSchema.Builder("schema").build());
+        SchemaProto.Builder expectedProtoBuilder = SchemaProto.newBuilder();
+        for (int i = 0; i < AppSearchImpl.PRUNE_PACKAGE_USING_FULL_SET_SCHEMA_THRESHOLD; i++) {
+            String packageName = "package" + i;
+            String databaseName = "database";
+            InternalSetSchemaResponse internalSetSchemaResponse =
+                    mAppSearchImpl.setSchema(
+                            packageName,
+                            databaseName,
+                            schema,
+                            /* visibilityConfigs= */ ImmutableList.of(visibilityConfig),
+                            /* forceOverride= */ false,
+                            /* version= */ 0,
+                            /* setSchemaStatsBuilder= */ null);
+            assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+
+            String schemaType = PrefixUtil.createPrefix(packageName, databaseName) + "schema";
+            expectedProtoBuilder.addTypes(
+                    SchemaTypeConfigProto.newBuilder()
+                            .setSchemaType(schemaType)
+                            .setDescription("")
+                            .setVersion(0));
+        }
+
+        // Verify these two packages are stored in AppSearch.
+        SchemaProto expectedProto = expectedProtoBuilder.build();
+        if (mAppSearchImpl.useDatabaseScopedSchemaOperations()) {
+            expectedProto = getSchemaProtoWithDatabase(expectedProto);
+        }
+
+        List<SchemaTypeConfigProto> expectedTypes = new ArrayList<>();
+        expectedTypes.addAll(existingSchemas);
+        expectedTypes.addAll(expectedProto.getTypesList());
+        assertThat(mAppSearchImpl.getSchemaProtoLocked().getTypesList())
+                .containsExactlyElementsIn(expectedTypes);
+
+        // Verify some visibility documents
+        InternalVisibilityConfig expectedVisibilityConfig1 =
+                new InternalVisibilityConfig.Builder("package1$database/schema")
+                        .setNotDisplayedBySystem(true)
+                        .addVisibleToPackage(new PackageIdentifier("pkgBar", new byte[32]))
+                        .build();
+        InternalVisibilityConfig expectedVisibilityConfig2 =
+                new InternalVisibilityConfig.Builder("package2$database/schema")
+                        .setNotDisplayedBySystem(true)
+                        .addVisibleToPackage(new PackageIdentifier("pkgBar", new byte[32]))
+                        .build();
+        assertThat(
+                        mAppSearchImpl.mDocumentVisibilityStoreLocked.getVisibility(
+                                "package1$database/schema"))
+                .isEqualTo(expectedVisibilityConfig1);
+        assertThat(
+                        mAppSearchImpl.mDocumentVisibilityStoreLocked.getVisibility(
+                                "package2$database/schema"))
+                .isEqualTo(expectedVisibilityConfig2);
+
+        // Prune packages
+        mAppSearchImpl.prunePackageData(existingPackages);
+
+        // Verify the schema is same as beginning.
+        assertThat(mAppSearchImpl.getSchemaProtoLocked().getTypesList())
+                .containsExactlyElementsIn(existingSchemas);
+        assertThat(mAppSearchImpl.getPackageToDatabases())
+                .containsExactlyEntriesIn(existingDatabases);
+
+        // Verify the VisibilitySetting is removed.
+        assertThat(
+                        mAppSearchImpl.mDocumentVisibilityStoreLocked.getVisibility(
+                                "package1$database/schema"))
+                .isNull();
+        assertThat(
+                        mAppSearchImpl.mDocumentVisibilityStoreLocked.getVisibility(
+                                "package2$database/schema"))
+                .isNull();
+    }
+
     @Test
     public void testGetPackageToDatabases() throws Exception {
         Map<String, Set<String>> existingMapping = mAppSearchImpl.getPackageToDatabases();
@@ -4722,9 +5489,9 @@ public class AppSearchImplTest {
 
         // Initialization should trigger a recovery
         InitializeStats initStats = initStatsBuilder.build();
-        assertThat(initStats.getDocumentStoreRecoveryCause())
+        assertThat(initStats.getNativeDocumentStoreRecoveryCause())
                 .isEqualTo(InitializeStats.RECOVERY_CAUSE_IO_ERROR);
-        assertThat(initStats.getIndexRestorationCause())
+        assertThat(initStats.getNativeIndexRestorationCause())
                 .isEqualTo(InitializeStats.RECOVERY_CAUSE_IO_ERROR);
 
         // That document should be visible even from another instance.
@@ -4810,9 +5577,9 @@ public class AppSearchImplTest {
 
         // Initialization should trigger a recovery
         InitializeStats initStats = initStatsBuilder.build();
-        assertThat(initStats.getDocumentStoreRecoveryCause())
+        assertThat(initStats.getNativeDocumentStoreRecoveryCause())
                 .isEqualTo(InitializeStats.RECOVERY_CAUSE_IO_ERROR);
-        assertThat(initStats.getIndexRestorationCause())
+        assertThat(initStats.getNativeIndexRestorationCause())
                 .isEqualTo(InitializeStats.RECOVERY_CAUSE_IO_ERROR);
 
         // Only the second document should be retrievable from another instance.
@@ -4915,9 +5682,9 @@ public class AppSearchImplTest {
 
         // Initialization should trigger a recovery
         InitializeStats initStats = initStatsBuilder.build();
-        assertThat(initStats.getDocumentStoreRecoveryCause())
+        assertThat(initStats.getNativeDocumentStoreRecoveryCause())
                 .isEqualTo(InitializeStats.RECOVERY_CAUSE_IO_ERROR);
-        assertThat(initStats.getIndexRestorationCause())
+        assertThat(initStats.getNativeIndexRestorationCause())
                 .isEqualTo(InitializeStats.RECOVERY_CAUSE_IO_ERROR);
 
         // Only the second document should be retrievable from another instance.
@@ -4983,9 +5750,9 @@ public class AppSearchImplTest {
 
         // Initialization should NOT trigger a recovery
         InitializeStats initStats = initStatsBuilder.build();
-        assertThat(initStats.getDocumentStoreRecoveryCause())
+        assertThat(initStats.getNativeDocumentStoreRecoveryCause())
                 .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
-        assertThat(initStats.getIndexRestorationCause())
+        assertThat(initStats.getNativeIndexRestorationCause())
                 .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
 
         // That document should be visible even from another instance.
@@ -5071,9 +5838,9 @@ public class AppSearchImplTest {
 
         // Initialization should NOT trigger a recovery.
         InitializeStats initStats = initStatsBuilder.build();
-        assertThat(initStats.getDocumentStoreRecoveryCause())
+        assertThat(initStats.getNativeDocumentStoreRecoveryCause())
                 .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
-        assertThat(initStats.getIndexRestorationCause())
+        assertThat(initStats.getNativeIndexRestorationCause())
                 .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
 
         // Only the second document should be retrievable from another instance.
@@ -5176,9 +5943,9 @@ public class AppSearchImplTest {
 
         // Initialization should NOT trigger a recovery.
         InitializeStats initStats = initStatsBuilder.build();
-        assertThat(initStats.getDocumentStoreRecoveryCause())
+        assertThat(initStats.getNativeDocumentStoreRecoveryCause())
                 .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
-        assertThat(initStats.getIndexRestorationCause())
+        assertThat(initStats.getNativeIndexRestorationCause())
                 .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
 
         // Only the second document should be retrievable from another instance.
@@ -5402,7 +6169,8 @@ public class AppSearchImplTest {
     public void testStatsIsLaunchVM() throws Exception {
         InitializeStats.Builder initStatsBuilder = new InitializeStats.Builder();
         IcingSearchEngineOptions options =
-                mUnlimitedConfig.toIcingSearchEngineOptions(mAppSearchDir.getAbsolutePath());
+                mUnlimitedConfig.toIcingSearchEngineOptions(
+                        mAppSearchDir.getAbsolutePath(), /* isVMEnabled= */ true);
         IcingSearchEngine icingSearchEngine = new IcingSearchEngine(options);
         // the bit mask for only enable launch VM feature.
         int onlyLaunchVMFeature = 1;
@@ -5447,7 +6215,7 @@ public class AppSearchImplTest {
                     }
 
                     @Override
-                    public void logStats(@NonNull SearchStats stats) {
+                    public void logStats(@NonNull QueryStats stats) {
                         assertThat(stats.getEnabledFeatures()).isEqualTo(onlyLaunchVMFeature);
                     }
                 };
@@ -5539,7 +6307,7 @@ public class AppSearchImplTest {
                     }
 
                     @Override
-                    public void logStats(@NonNull SearchStats stats) {
+                    public void logStats(@NonNull QueryStats stats) {
                         assertThat(stats.getEnabledFeatures()).isEqualTo(noLaunchFeature);
                     }
                 };
@@ -10094,7 +10862,7 @@ public class AppSearchImplTest {
         IcingSearchEngineInterface modifiedIcingInstance =
                 new IcingSearchEngine(
                         mUnlimitedConfig.toIcingSearchEngineOptions(
-                                mAppSearchDir.getAbsolutePath())) {
+                                mAppSearchDir.getAbsolutePath(), /* isVMEnabled= */ true)) {
                     @Override
                     public GetSchemaResultProto getSchema() {
                         GetSchemaResultProto.Builder resultBuilder = super.getSchema().toBuilder();
@@ -10131,15 +10899,38 @@ public class AppSearchImplTest {
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
 
         // Create expected schemaType proto.
-        SchemaProto expectedProto =
-                SchemaProto.newBuilder()
-                        .addTypes(
-                                SchemaTypeConfigProto.newBuilder()
-                                        .setSchemaType("package$database1/Email")
-                                        .setDescription("")
-                                        .setVersion(0))
-                        .addTypes(additionalConfigProto)
-                        .build();
+        SchemaProto expectedProto;
+        if (mAppSearchImpl.useDatabaseScopedSchemaOperations()) {
+            expectedProto =
+                    SchemaProto.newBuilder()
+                            .addTypes(
+                                    SchemaTypeConfigProto.newBuilder()
+                                            .setSchemaType("package$database1/Email")
+                                            .setDatabase("package$database1/")
+                                            .setDescription("")
+                                            .setVersion(0))
+                            .build();
+        } else {
+            expectedProto =
+                    SchemaProto.newBuilder()
+                            .addTypes(
+                                    SchemaTypeConfigProto.newBuilder()
+                                            .setSchemaType("package$database1/Email")
+                                            .setDescription("")
+                                            .setVersion(0))
+                            // This type shows up twice in the expectedProto when it actually should
+                            // only
+                            // be there once. This is because we call getSchema in the setSchema
+                            // operation, and then build on top of the retrieved schema. When the
+                            // new
+                            // database-scoped schema operation we'll only retrieve the types from
+                            // the
+                            // requested database, and so this shouldn't be built into the existing
+                            // schema
+                            // again.
+                            .addTypes(additionalConfigProto)
+                            .build();
+        }
 
         List<SchemaTypeConfigProto> expectedTypes = new ArrayList<>();
         expectedTypes.addAll(existingSchemas);
@@ -10147,4 +10938,163 @@ public class AppSearchImplTest {
         assertThat(mAppSearchImpl.getSchemaProtoLocked().getTypesList())
                 .containsExactlyElementsIn(expectedTypes);
     }
+
+    @Test
+    public void testBatchGetDocumentsWithEmptyIdList() throws Exception {
+        AppSearchBatchResult<String, GenericDocument> batchGetResult =
+                mAppSearchImpl.batchGetDocuments(
+                        "packageName",
+                        "dbName",
+                        new GetByDocumentIdRequest.Builder("namespace").build(),
+                        /* callerAccess= */ null);
+
+        assertThat(batchGetResult.getAll()).isEmpty();
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_COMPRESSION_THRESHOLD)
+    public void testCompressionThreshold() throws Exception {
+        mAppSearchImpl.close();
+        // Initialize AppSearch with a small compression threshold, which should force
+        // compression for large documents.
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(),
+                                new LocalStorageIcingOptionsConfig() {
+                                    @Override
+                                    public int getCompressionThresholdBytes() {
+                                        return 10;
+                                    }
+                                }),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
+                        ALWAYS_OPTIMIZE);
+
+        // Set schema
+        List<AppSearchSchema> schemas =
+                Collections.singletonList(
+                        new AppSearchSchema.Builder("Type")
+                                .addProperty(
+                                        new AppSearchSchema.StringPropertyConfig.Builder(
+                                                        "largeString")
+                                                .setCardinality(
+                                                        AppSearchSchema.PropertyConfig
+                                                                .CARDINALITY_OPTIONAL)
+                                                .setIndexingType(
+                                                        AppSearchSchema.StringPropertyConfig
+                                                                .INDEXING_TYPE_NONE)
+                                                .setTokenizerType(
+                                                        AppSearchSchema.StringPropertyConfig
+                                                                .TOKENIZER_TYPE_NONE)
+                                                .build())
+                                .build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package",
+                        "database",
+                        schemas,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+
+        // Add a large document
+        GenericDocument largeDoc =
+                new GenericDocument.Builder<>("namespace", "id1", "Type")
+                        .setPropertyString(
+                                "largeString",
+                                // A string of 10000 'A' characters.
+                                new String(new char[10000]).replace('\0', 'A'))
+                        .build();
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                largeDoc,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+        mAppSearchImpl.optimize(/* builder= */ null);
+        mAppSearchImpl.persistToDisk(PersistType.Code.LITE);
+
+        // Record storage size (the document should be compressed)
+        StorageInfoProto storageInfo = mAppSearchImpl.getRawStorageInfoProto();
+        long compressedSize = storageInfo.getDocumentStorageInfo().getDocumentLogSize();
+        assertThat(compressedSize).isGreaterThan(0);
+
+        // Close and re-open AppSearchImpl with a larger threshold, which should disable
+        // compression for the document.
+        mAppSearchImpl.close();
+        AppSearchConfig configLargeThreshold =
+                new AppSearchConfigImpl(
+                        new UnlimitedLimitConfig(),
+                        new LocalStorageIcingOptionsConfig() {
+                            @Override
+                            public int getCompressionThresholdBytes() {
+                                return 100000;
+                            }
+                        });
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        configLargeThreshold,
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        /* icingSearchEngine= */ null,
+                        ALWAYS_OPTIMIZE);
+
+        // Run optimize, and test that the document is decompressed based on the new threshold.
+        mAppSearchImpl.optimize(/* builder= */ null);
+
+        // Record storage size again (should be uncompressed)
+        storageInfo = mAppSearchImpl.getRawStorageInfoProto();
+        long uncompressedSize = storageInfo.getDocumentStorageInfo().getDocumentLogSize();
+        assertThat(uncompressedSize).isGreaterThan(0);
+
+        // Check that previous size (compressed) is smaller than the latter (uncompressed)
+        assertThat(compressedSize).isLessThan(uncompressedSize);
+    }
+
+    private SchemaProto getSchemaProtoWithDatabase(SchemaProto schema) throws AppSearchException {
+        SchemaProto.Builder schemaBuilder = SchemaProto.newBuilder();
+        for (int i = 0; i < schema.getTypesList().size(); i++) {
+            SchemaTypeConfigProto type = schema.getTypes(i);
+            SchemaTypeConfigProto.Builder typeBuilder =
+                    SchemaTypeConfigProto.newBuilder(type)
+                            .setDatabase(getPrefix(type.getSchemaType()));
+            schemaBuilder.addTypes(typeBuilder);
+        }
+        return schemaBuilder.build();
+    }
+
+    // Mocks all methods that are called during AppSearchImpl#create to return successful statuses.
+    private void setUpSuccessfulMocksForCreation() {
+        // Setup Icing mock to fail the first init call, but then succeed
+        InitializeResultProto okInit = InitializeResultProto.newBuilder().setStatus(OK).build();
+        when(mMockIcingSearchEngine.initialize()).thenReturn(okInit);
+
+        GetSchemaResultProto successGetSchema =
+                GetSchemaResultProto.newBuilder().setStatus(OK).build();
+        when(mMockIcingSearchEngine.getSchema()).thenReturn(successGetSchema);
+        when(mMockIcingSearchEngine.getSchemaForDatabase(any())).thenReturn(successGetSchema);
+
+        StorageInfoResultProto successGetStorageInfo =
+                StorageInfoResultProto.newBuilder().setStatus(OK).build();
+        when(mMockIcingSearchEngine.getStorageInfo()).thenReturn(successGetStorageInfo);
+
+        ResetResultProto successReset = ResetResultProto.newBuilder().setStatus(OK).build();
+        when(mMockIcingSearchEngine.reset()).thenReturn(successReset);
+
+        SetSchemaResultProto successSetSchema =
+                SetSchemaResultProto.newBuilder().setStatus(OK).build();
+        when(mMockIcingSearchEngine.setSchemaWithRequestProto(any())).thenReturn(successSetSchema);
+
+        PersistToDiskResultProto successPersist =
+                PersistToDiskResultProto.newBuilder().setStatus(OK).build();
+        when(mMockIcingSearchEngine.persistToDisk(any())).thenReturn(successPersist);
+    }
 }
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchLoggerTest.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchLoggerTest.java
index 7d741ada..20e0136d 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchLoggerTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchLoggerTest.java
@@ -20,6 +20,8 @@ import static com.google.common.truth.Truth.assertThat;
 
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.AppSearchSchema;
+import android.app.appsearch.AppSearchSchema.PropertyConfig;
+import android.app.appsearch.AppSearchSchema.StringPropertyConfig;
 import android.app.appsearch.GenericDocument;
 import android.app.appsearch.InternalSetSchemaResponse;
 import android.app.appsearch.JoinSpec;
@@ -35,6 +37,7 @@ import com.android.appsearch.flags.Flags;
 import com.android.server.appsearch.external.localstorage.stats.InitializeStats;
 import com.android.server.appsearch.external.localstorage.stats.OptimizeStats;
 import com.android.server.appsearch.external.localstorage.stats.PutDocumentStats;
+import com.android.server.appsearch.external.localstorage.stats.QueryStats;
 import com.android.server.appsearch.external.localstorage.stats.RemoveStats;
 import com.android.server.appsearch.external.localstorage.stats.SearchStats;
 import com.android.server.appsearch.external.localstorage.stats.SetSchemaStats;
@@ -118,6 +121,15 @@ public class AppSearchLoggerTest {
                 InitializeStatsProto.DocumentStoreDataStatus.NO_DATA_LOSS_VALUE;
         int nativeNumDocuments = 11;
         int nativeNumSchemaTypes = 12;
+        int nativeNumPreviousInitFailures = 13;
+        int nativeIntegerIndexRestorationCause =
+                InitializeStatsProto.RecoveryCause.UNKNOWN_OUT_OF_SYNC_VALUE;
+        int nativeQualifiedIdJoinIndexRestorationCause =
+                InitializeStatsProto.RecoveryCause.FEATURE_FLAG_CHANGED_VALUE;
+        int nativeEmbeddingIndexRestorationCause =
+                InitializeStatsProto.RecoveryCause.DEPENDENCIES_CHANGED_VALUE;
+        StatusProto.Code initializeIcuDataStatusCode = StatusProto.Code.OK;
+        int nativeNumFailedReindexedDocuments = 18;
         InitializeStatsProto.Builder nativeInitBuilder =
                 InitializeStatsProto.newBuilder()
                         .setLatencyMs(nativeLatencyMillis)
@@ -137,26 +149,53 @@ public class AppSearchLoggerTest {
                                 InitializeStatsProto.DocumentStoreDataStatus.forNumber(
                                         nativeDocumentStoreDataStatus))
                         .setNumDocuments(nativeNumDocuments)
-                        .setNumSchemaTypes(nativeNumSchemaTypes);
+                        .setNumSchemaTypes(nativeNumSchemaTypes)
+                        .setNumPreviousInitFailures(nativeNumPreviousInitFailures)
+                        .setIntegerIndexRestorationCause(
+                                InitializeStatsProto.RecoveryCause.forNumber(
+                                        nativeIntegerIndexRestorationCause))
+                        .setQualifiedIdJoinIndexRestorationCause(
+                                InitializeStatsProto.RecoveryCause.forNumber(
+                                        nativeQualifiedIdJoinIndexRestorationCause))
+                        .setEmbeddingIndexRestorationCause(
+                                InitializeStatsProto.RecoveryCause.forNumber(
+                                        nativeEmbeddingIndexRestorationCause))
+                        .setInitializeIcuDataStatus(
+                                StatusProto.newBuilder().setCode(initializeIcuDataStatusCode))
+                        .setNumFailedReindexedDocuments(nativeNumFailedReindexedDocuments);
         InitializeStats.Builder initBuilder = new InitializeStats.Builder();
 
         AppSearchLoggerHelper.copyNativeStats(nativeInitBuilder.build(), initBuilder);
 
         InitializeStats iStats = initBuilder.build();
         assertThat(iStats.getNativeLatencyMillis()).isEqualTo(nativeLatencyMillis);
-        assertThat(iStats.getDocumentStoreRecoveryCause())
+        assertThat(iStats.getNativeDocumentStoreRecoveryCause())
                 .isEqualTo(nativeDocumentStoreRecoveryCause);
-        assertThat(iStats.getIndexRestorationCause()).isEqualTo(nativeIndexRestorationCause);
-        assertThat(iStats.getSchemaStoreRecoveryCause()).isEqualTo(nativeSchemaStoreRecoveryCause);
-        assertThat(iStats.getDocumentStoreRecoveryLatencyMillis())
+        assertThat(iStats.getNativeIndexRestorationCause()).isEqualTo(nativeIndexRestorationCause);
+        assertThat(iStats.getNativeSchemaStoreRecoveryCause())
+                .isEqualTo(nativeSchemaStoreRecoveryCause);
+        assertThat(iStats.getNativeDocumentStoreRecoveryLatencyMillis())
                 .isEqualTo(nativeDocumentStoreRecoveryLatencyMillis);
-        assertThat(iStats.getIndexRestorationLatencyMillis())
+        assertThat(iStats.getNativeIndexRestorationLatencyMillis())
                 .isEqualTo(nativeIndexRestorationLatencyMillis);
-        assertThat(iStats.getSchemaStoreRecoveryLatencyMillis())
+        assertThat(iStats.getNativeSchemaStoreRecoveryLatencyMillis())
                 .isEqualTo(nativeSchemaStoreRecoveryLatencyMillis);
-        assertThat(iStats.getDocumentStoreDataStatus()).isEqualTo(nativeDocumentStoreDataStatus);
-        assertThat(iStats.getDocumentCount()).isEqualTo(nativeNumDocuments);
-        assertThat(iStats.getSchemaTypeCount()).isEqualTo(nativeNumSchemaTypes);
+        assertThat(iStats.getNativeDocumentStoreDataStatus())
+                .isEqualTo(nativeDocumentStoreDataStatus);
+        assertThat(iStats.getNativeDocumentCount()).isEqualTo(nativeNumDocuments);
+        assertThat(iStats.getNativeSchemaTypeCount()).isEqualTo(nativeNumSchemaTypes);
+        assertThat(iStats.getNativeNumPreviousInitFailures())
+                .isEqualTo(nativeNumPreviousInitFailures);
+        assertThat(iStats.getNativeIntegerIndexRestorationCause())
+                .isEqualTo(nativeIntegerIndexRestorationCause);
+        assertThat(iStats.getNativeQualifiedIdJoinIndexRestorationCause())
+                .isEqualTo(nativeQualifiedIdJoinIndexRestorationCause);
+        assertThat(iStats.getNativeEmbeddingIndexRestorationCause())
+                .isEqualTo(nativeEmbeddingIndexRestorationCause);
+        assertThat(iStats.getNativeInitializeIcuDataStatusCode())
+                .isEqualTo(initializeIcuDataStatusCode.getNumber());
+        assertThat(iStats.getNativeNumFailedReindexedDocuments())
+                .isEqualTo(nativeNumFailedReindexedDocuments);
     }
 
     @Test
@@ -172,6 +211,8 @@ public class AppSearchLoggerTest {
         final int nativeIntegerIndexLatencyMillis = 10;
         final int nativeQualifiedIdJoinIndexLatencyMillis = 11;
         final int nativeLiteIndexSortLatencyMillis = 12;
+        final int mMetadataTermIndexLatencyMillis = 13;
+        final int mEmbeddingIndexLatencyMillis = 14;
         PutDocumentStatsProto nativePutDocumentStats =
                 PutDocumentStatsProto.newBuilder()
                         .setLatencyMs(nativeLatencyMillis)
@@ -187,6 +228,8 @@ public class AppSearchLoggerTest {
                         .setIntegerIndexLatencyMs(nativeIntegerIndexLatencyMillis)
                         .setQualifiedIdJoinIndexLatencyMs(nativeQualifiedIdJoinIndexLatencyMillis)
                         .setLiteIndexSortLatencyMs(nativeLiteIndexSortLatencyMillis)
+                        .setMetadataTermIndexLatencyMs(mMetadataTermIndexLatencyMillis)
+                        .setEmbeddingIndexLatencyMs(mEmbeddingIndexLatencyMillis)
                         .build();
         PutDocumentStats.Builder pBuilder = new PutDocumentStats.Builder(PACKAGE_NAME, DATABASE);
 
@@ -209,81 +252,178 @@ public class AppSearchLoggerTest {
                 .isEqualTo(nativeQualifiedIdJoinIndexLatencyMillis);
         assertThat(pStats.getNativeLiteIndexSortLatencyMillis())
                 .isEqualTo(nativeLiteIndexSortLatencyMillis);
+        assertThat(pStats.getMetadataTermIndexLatencyMillis())
+                .isEqualTo(mMetadataTermIndexLatencyMillis);
+        assertThat(pStats.getEmbeddingIndexLatencyMillis()).isEqualTo(mEmbeddingIndexLatencyMillis);
     }
 
     @Test
     public void testAppSearchLoggerHelper_testCopyNativeStats_search() {
-        int nativeLatencyMillis = 4;
-        int nativeNumTerms = 5;
-        int nativeQueryLength = 6;
-        int nativeNumNamespacesFiltered = 7;
-        int nativeNumSchemaTypesFiltered = 8;
-        int nativeRequestedPageSize = 9;
-        int nativeNumResultsReturnedCurrentPage = 10;
-        boolean nativeIsFirstPage = true;
-        int nativeParseQueryLatencyMillis = 11;
+        int nativeNumTerms = 1;
+        int nativeQueryLength = 2;
+        int nativeNumNamespacesFiltered = 3;
+        int nativeNumSchemaTypesFiltered = 4;
         int nativeRankingStrategy = ScoringSpecProto.RankingStrategy.Code.CREATION_TIMESTAMP_VALUE;
-        int nativeNumDocumentsScored = 13;
-        int nativeScoringLatencyMillis = 14;
-        int nativeRankingLatencyMillis = 15;
-        int nativeNumResultsWithSnippets = 16;
-        int nativeDocumentRetrievingLatencyMillis = 17;
-        int nativeLockAcquisitionLatencyMillis = 18;
-        int javaToNativeJniLatencyMillis = 19;
-        int nativeToJavaJniLatencyMillis = 20;
-        QueryStatsProto nativeQueryStats =
-                QueryStatsProto.newBuilder()
-                        .setLatencyMs(nativeLatencyMillis)
-                        .setNumTerms(nativeNumTerms)
+        int nativeNumDocumentsScored = 5;
+        int nativeParseQueryLatencyMillis = 6;
+        int nativeScoringLatencyMillis = 7;
+        boolean isNumericQuery = true;
+        int numFetchedHitsLiteIndex = 8;
+        int numFetchedHitsMainIndex = 9;
+        int numFetchedHitsIntegerIndex = 10;
+        int queryProcessorLexerExtractTokenLatencyMillis = 11;
+        int queryProcessorParserConsumeQueryLatencyMillis = 12;
+        int queryProcessorQueryVisitorLatencyMillis = 13;
+
+        QueryStatsProto.SearchStats searchStats =
+                QueryStatsProto.SearchStats.newBuilder()
                         .setQueryLength(nativeQueryLength)
+                        .setNumTerms(nativeNumTerms)
                         .setNumNamespacesFiltered(nativeNumNamespacesFiltered)
                         .setNumSchemaTypesFiltered(nativeNumSchemaTypesFiltered)
-                        .setRequestedPageSize(nativeRequestedPageSize)
-                        .setNumResultsReturnedCurrentPage(nativeNumResultsReturnedCurrentPage)
-                        .setIsFirstPage(nativeIsFirstPage)
-                        .setParseQueryLatencyMs(nativeParseQueryLatencyMillis)
                         .setRankingStrategy(
                                 ScoringSpecProto.RankingStrategy.Code.forNumber(
                                         nativeRankingStrategy))
+                        .setParseQueryLatencyMs(nativeParseQueryLatencyMillis)
                         .setNumDocumentsScored(nativeNumDocumentsScored)
                         .setScoringLatencyMs(nativeScoringLatencyMillis)
+                        .setIsNumericQuery(isNumericQuery)
+                        .setNumFetchedHitsLiteIndex(numFetchedHitsLiteIndex)
+                        .setNumFetchedHitsMainIndex(numFetchedHitsMainIndex)
+                        .setNumFetchedHitsIntegerIndex(numFetchedHitsIntegerIndex)
+                        .setQueryProcessorLexerExtractTokenLatencyMs(
+                                queryProcessorLexerExtractTokenLatencyMillis)
+                        .setQueryProcessorParserConsumeQueryLatencyMs(
+                                queryProcessorParserConsumeQueryLatencyMillis)
+                        .setQueryProcessorQueryVisitorLatencyMs(
+                                queryProcessorQueryVisitorLatencyMillis)
+                        .build();
+
+        boolean nativeIsFirstPage = true;
+        int nativeRequestedPageSize = 101;
+        int nativeNumResultsReturnedCurrentPage = 102;
+        int nativeLatencyMillis = 102;
+        int nativeRankingLatencyMillis = 103;
+        int nativeDocumentRetrievingLatencyMillis = 104;
+        int nativeNumResultsWithSnippets = 105;
+        int nativeLockAcquisitionLatencyMillis = 106;
+        int javaToNativeJniLatencyMillis = 107;
+        int nativeToJavaJniLatencyMillis = 108;
+        int nativeJoinLatencyMillis = 109;
+        int nativeNumJoinedResultsCurrentPage = 110;
+        long liteIndexHitBufferByteSize = 111;
+        long liteIndexHitBufferUnsortedByteSize = 112;
+        int pageTokenType = QueryStatsProto.PageTokenType.Code.EMPTY_VALUE;
+        int numResultStatesEvicted = 113;
+
+        QueryStatsProto nativeQueryStats =
+                QueryStatsProto.newBuilder()
+                        .setIsFirstPage(nativeIsFirstPage)
+                        .setRequestedPageSize(nativeRequestedPageSize)
+                        .setNumResultsReturnedCurrentPage(nativeNumResultsReturnedCurrentPage)
+                        .setLatencyMs(nativeLatencyMillis)
                         .setRankingLatencyMs(nativeRankingLatencyMillis)
-                        .setNumResultsWithSnippets(nativeNumResultsWithSnippets)
                         .setDocumentRetrievalLatencyMs(nativeDocumentRetrievingLatencyMillis)
+                        .setNumResultsWithSnippets(nativeNumResultsWithSnippets)
                         .setLockAcquisitionLatencyMs(nativeLockAcquisitionLatencyMillis)
                         .setJavaToNativeJniLatencyMs(javaToNativeJniLatencyMillis)
                         .setNativeToJavaJniLatencyMs(nativeToJavaJniLatencyMillis)
+                        .setJoinLatencyMs(nativeJoinLatencyMillis)
+                        .setNumJoinedResultsReturnedCurrentPage(nativeNumJoinedResultsCurrentPage)
+                        .setParentSearchStats(searchStats)
+                        .setChildSearchStats(searchStats)
+                        .setLiteIndexHitBufferByteSize(liteIndexHitBufferByteSize)
+                        .setLiteIndexHitBufferUnsortedByteSize(liteIndexHitBufferUnsortedByteSize)
+                        .setPageTokenType(
+                                QueryStatsProto.PageTokenType.Code.forNumber(pageTokenType))
+                        .setNumResultStatesEvicted(numResultStatesEvicted)
                         .build();
-        SearchStats.Builder qBuilder =
-                new SearchStats.Builder(SearchStats.VISIBILITY_SCOPE_LOCAL, PACKAGE_NAME)
+        QueryStats.Builder qBuilder =
+                new QueryStats.Builder(QueryStats.VISIBILITY_SCOPE_LOCAL, PACKAGE_NAME)
                         .setDatabase(DATABASE);
 
         AppSearchLoggerHelper.copyNativeStats(nativeQueryStats, qBuilder);
 
-        SearchStats sStats = qBuilder.build();
-        assertThat(sStats.getNativeLatencyMillis()).isEqualTo(nativeLatencyMillis);
-        assertThat(sStats.getTermCount()).isEqualTo(nativeNumTerms);
-        assertThat(sStats.getQueryLength()).isEqualTo(nativeQueryLength);
-        assertThat(sStats.getFilteredNamespaceCount()).isEqualTo(nativeNumNamespacesFiltered);
-        assertThat(sStats.getFilteredSchemaTypeCount()).isEqualTo(nativeNumSchemaTypesFiltered);
+        QueryStats sStats = qBuilder.build();
+        assertThat(sStats.isFirstPage()).isTrue();
         assertThat(sStats.getRequestedPageSize()).isEqualTo(nativeRequestedPageSize);
         assertThat(sStats.getCurrentPageReturnedResultCount())
                 .isEqualTo(nativeNumResultsReturnedCurrentPage);
-        assertThat(sStats.isFirstPage()).isTrue();
-        assertThat(sStats.getParseQueryLatencyMillis()).isEqualTo(nativeParseQueryLatencyMillis);
-        assertThat(sStats.getRankingStrategy()).isEqualTo(nativeRankingStrategy);
-        assertThat(sStats.getScoredDocumentCount()).isEqualTo(nativeNumDocumentsScored);
-        assertThat(sStats.getScoringLatencyMillis()).isEqualTo(nativeScoringLatencyMillis);
+        assertThat(sStats.getNativeLatencyMillis()).isEqualTo(nativeLatencyMillis);
         assertThat(sStats.getRankingLatencyMillis()).isEqualTo(nativeRankingLatencyMillis);
-        assertThat(sStats.getResultWithSnippetsCount()).isEqualTo(nativeNumResultsWithSnippets);
         assertThat(sStats.getDocumentRetrievingLatencyMillis())
                 .isEqualTo(nativeDocumentRetrievingLatencyMillis);
+        assertThat(sStats.getResultWithSnippetsCount()).isEqualTo(nativeNumResultsWithSnippets);
         assertThat(sStats.getNativeLockAcquisitionLatencyMillis())
                 .isEqualTo(nativeLockAcquisitionLatencyMillis);
         assertThat(sStats.getJavaToNativeJniLatencyMillis())
                 .isEqualTo(javaToNativeJniLatencyMillis);
-        assertThat(sStats.getNativeToJavaJniLatencyMillis())
-                .isEqualTo(nativeToJavaJniLatencyMillis);
+        assertThat(sStats.getJoinLatencyMillis()).isEqualTo(nativeJoinLatencyMillis);
+        assertThat(sStats.getNumJoinedResultsCurrentPage())
+                .isEqualTo(nativeNumJoinedResultsCurrentPage);
+        assertThat(sStats.getLiteIndexHitBufferByteSize()).isEqualTo(liteIndexHitBufferByteSize);
+        assertThat(sStats.getLiteIndexHitBufferUnsortedByteSize())
+                .isEqualTo(liteIndexHitBufferUnsortedByteSize);
+        assertThat(sStats.getPageTokenType()).isEqualTo(pageTokenType);
+        assertThat(sStats.getNumResultStatesEvicted()).isEqualTo(numResultStatesEvicted);
+
+        SearchStats parentSearchStats = sStats.getParentSearchStats();
+
+        assertThat(parentSearchStats.getNativeQueryLength()).isEqualTo(nativeQueryLength);
+        assertThat(parentSearchStats.getNativeTermCount()).isEqualTo(nativeNumTerms);
+        assertThat(parentSearchStats.getNativeFilteredNamespaceCount())
+                .isEqualTo(nativeNumNamespacesFiltered);
+        assertThat(parentSearchStats.getNativeFilteredSchemaTypeCount())
+                .isEqualTo(nativeNumSchemaTypesFiltered);
+        assertThat(parentSearchStats.getNativeRankingStrategy()).isEqualTo(nativeRankingStrategy);
+        assertThat(parentSearchStats.getNativeScoredDocumentCount())
+                .isEqualTo(nativeNumDocumentsScored);
+        assertThat(parentSearchStats.getNativeParseQueryLatencyMillis())
+                .isEqualTo(nativeParseQueryLatencyMillis);
+        assertThat(parentSearchStats.getNativeScoringLatencyMillis())
+                .isEqualTo(nativeScoringLatencyMillis);
+        assertThat(parentSearchStats.isNativeNumericQuery()).isEqualTo(isNumericQuery);
+        assertThat(parentSearchStats.getNativeNumFetchedHitsLiteIndex())
+                .isEqualTo(numFetchedHitsLiteIndex);
+        assertThat(parentSearchStats.getNativeNumFetchedHitsMainIndex())
+                .isEqualTo(numFetchedHitsMainIndex);
+        assertThat(parentSearchStats.getNativeNumFetchedHitsIntegerIndex())
+                .isEqualTo(numFetchedHitsIntegerIndex);
+        assertThat(parentSearchStats.getNativeQueryProcessorLexerExtractTokenLatencyMillis())
+                .isEqualTo(queryProcessorLexerExtractTokenLatencyMillis);
+        assertThat(parentSearchStats.getNativeQueryProcessorParserConsumeQueryLatencyMillis())
+                .isEqualTo(queryProcessorParserConsumeQueryLatencyMillis);
+        assertThat(parentSearchStats.getNativeQueryProcessorQueryVisitorLatencyMillis())
+                .isEqualTo(queryProcessorQueryVisitorLatencyMillis);
+
+        SearchStats childSearchStats = sStats.getParentSearchStats();
+
+        assertThat(childSearchStats.getNativeQueryLength()).isEqualTo(nativeQueryLength);
+        assertThat(childSearchStats.getNativeTermCount()).isEqualTo(nativeNumTerms);
+        assertThat(childSearchStats.getNativeFilteredNamespaceCount())
+                .isEqualTo(nativeNumNamespacesFiltered);
+        assertThat(childSearchStats.getNativeFilteredSchemaTypeCount())
+                .isEqualTo(nativeNumSchemaTypesFiltered);
+        assertThat(childSearchStats.getNativeRankingStrategy()).isEqualTo(nativeRankingStrategy);
+        assertThat(childSearchStats.getNativeScoredDocumentCount())
+                .isEqualTo(nativeNumDocumentsScored);
+        assertThat(childSearchStats.getNativeParseQueryLatencyMillis())
+                .isEqualTo(nativeParseQueryLatencyMillis);
+        assertThat(childSearchStats.getNativeScoringLatencyMillis())
+                .isEqualTo(nativeScoringLatencyMillis);
+        assertThat(childSearchStats.isNativeNumericQuery()).isEqualTo(isNumericQuery);
+        assertThat(childSearchStats.getNativeNumFetchedHitsLiteIndex())
+                .isEqualTo(numFetchedHitsLiteIndex);
+        assertThat(childSearchStats.getNativeNumFetchedHitsMainIndex())
+                .isEqualTo(numFetchedHitsMainIndex);
+        assertThat(childSearchStats.getNativeNumFetchedHitsIntegerIndex())
+                .isEqualTo(numFetchedHitsIntegerIndex);
+        assertThat(childSearchStats.getNativeQueryProcessorLexerExtractTokenLatencyMillis())
+                .isEqualTo(queryProcessorLexerExtractTokenLatencyMillis);
+        assertThat(childSearchStats.getNativeQueryProcessorParserConsumeQueryLatencyMillis())
+                .isEqualTo(queryProcessorParserConsumeQueryLatencyMillis);
+        assertThat(childSearchStats.getNativeQueryProcessorQueryVisitorLatencyMillis())
+                .isEqualTo(queryProcessorQueryVisitorLatencyMillis);
     }
 
     @Test
@@ -291,13 +431,26 @@ public class AppSearchLoggerTest {
         final int nativeLatencyMillis = 1;
         final int nativeDeleteType = 2;
         final int nativeNumDocumentDeleted = 3;
+        final int queryLength = 4;
+        final int numTerms = 5;
+        final int numNamespacesFiltered = 6;
+        final int numSchemaTypesFiltered = 7;
+        final int parseQueryLatencyMillis = 8;
+        final int documentRemovalLatencyMillis = 9;
         DeleteStatsProto nativeDeleteStatsProto =
                 DeleteStatsProto.newBuilder()
                         .setLatencyMs(nativeLatencyMillis)
                         .setDeleteType(DeleteStatsProto.DeleteType.Code.forNumber(nativeDeleteType))
                         .setNumDocumentsDeleted(nativeNumDocumentDeleted)
                         .build();
-        RemoveStats.Builder rBuilder = new RemoveStats.Builder("packageName", "database");
+        RemoveStats.Builder rBuilder =
+                new RemoveStats.Builder("packageName", "database")
+                        .setQueryLength(queryLength)
+                        .setNumTerms(numTerms)
+                        .setNumNamespacesFiltered(numNamespacesFiltered)
+                        .setNumSchemaTypesFiltered(numSchemaTypesFiltered)
+                        .setParseQueryLatencyMillis(parseQueryLatencyMillis)
+                        .setDocumentRemovalLatencyMillis(documentRemovalLatencyMillis);
 
         AppSearchLoggerHelper.copyNativeStats(nativeDeleteStatsProto, rBuilder);
 
@@ -305,6 +458,13 @@ public class AppSearchLoggerTest {
         assertThat(rStats.getNativeLatencyMillis()).isEqualTo(nativeLatencyMillis);
         assertThat(rStats.getDeleteType()).isEqualTo(nativeDeleteType);
         assertThat(rStats.getDeletedDocumentCount()).isEqualTo(nativeNumDocumentDeleted);
+        assertThat(rStats.getQueryLength()).isEqualTo(queryLength);
+        assertThat(rStats.getNumTerms()).isEqualTo(numTerms);
+        assertThat(rStats.getNumNamespacesFiltered()).isEqualTo(numNamespacesFiltered);
+        assertThat(rStats.getNumSchemaTypesFiltered()).isEqualTo(numSchemaTypesFiltered);
+        assertThat(rStats.getParseQueryLatencyMillis()).isEqualTo(parseQueryLatencyMillis);
+        assertThat(rStats.getDocumentRemovalLatencyMillis())
+                .isEqualTo(documentRemovalLatencyMillis);
     }
 
     @Test
@@ -318,6 +478,9 @@ public class AppSearchLoggerTest {
         long nativeStorageSizeBeforeBytes = Integer.MAX_VALUE + 1;
         long nativeStorageSizeAfterBytes = Integer.MAX_VALUE + 2;
         long nativeTimeSinceLastOptimizeMillis = Integer.MAX_VALUE + 3;
+        int indexRestorationMode = OptimizeStats.FULL_INDEX_REBUILD;
+        int numOriginalNamespaces = 7;
+        int numDeletedNamespaces = 8;
         OptimizeStatsProto optimizeStatsProto =
                 OptimizeStatsProto.newBuilder()
                         .setLatencyMs(nativeLatencyMillis)
@@ -329,6 +492,11 @@ public class AppSearchLoggerTest {
                         .setStorageSizeBefore(nativeStorageSizeBeforeBytes)
                         .setStorageSizeAfter(nativeStorageSizeAfterBytes)
                         .setTimeSinceLastOptimizeMs(nativeTimeSinceLastOptimizeMillis)
+                        .setIndexRestorationMode(
+                                OptimizeStatsProto.IndexRestorationMode.forNumber(
+                                        indexRestorationMode))
+                        .setNumOriginalNamespaces(numOriginalNamespaces)
+                        .setNumDeletedNamespaces(numDeletedNamespaces)
                         .build();
         OptimizeStats.Builder oBuilder = new OptimizeStats.Builder();
 
@@ -347,6 +515,9 @@ public class AppSearchLoggerTest {
         assertThat(oStats.getStorageSizeAfterBytes()).isEqualTo(nativeStorageSizeAfterBytes);
         assertThat(oStats.getTimeSinceLastOptimizeMillis())
                 .isEqualTo(nativeTimeSinceLastOptimizeMillis);
+        assertThat(oStats.getIndexRestorationMode()).isEqualTo(indexRestorationMode);
+        assertThat(oStats.getNumOriginalNamespaces()).isEqualTo(numOriginalNamespaces);
+        assertThat(oStats.getNumDeletedNamespaces()).isEqualTo(numDeletedNamespaces);
     }
 
     @Test
@@ -404,12 +575,24 @@ public class AppSearchLoggerTest {
         // Total latency captured in LocalStorage
         assertThat(iStats.getTotalLatencyMillis()).isEqualTo(0);
         assertThat(iStats.hasDeSync()).isFalse();
-        assertThat(iStats.getDocumentStoreDataStatus())
-                .isEqualTo(InitializeStatsProto.DocumentStoreDataStatus.NO_DATA_LOSS_VALUE);
-        assertThat(iStats.getDocumentCount()).isEqualTo(0);
-        assertThat(iStats.getSchemaTypeCount()).isEqualTo(0);
+        assertThat(iStats.getNativeDocumentStoreDataStatus())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
+        assertThat(iStats.getNativeIndexRestorationCause())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
+        assertThat(iStats.getNativeDocumentCount()).isEqualTo(0);
+        assertThat(iStats.getNativeSchemaTypeCount()).isEqualTo(0);
         assertThat(iStats.hasReset()).isEqualTo(false);
         assertThat(iStats.getResetStatusCode()).isEqualTo(AppSearchResult.RESULT_OK);
+        assertThat(iStats.getNativeNumPreviousInitFailures()).isEqualTo(0);
+        assertThat(iStats.getNativeIntegerIndexRestorationCause())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
+        assertThat(iStats.getNativeQualifiedIdJoinIndexRestorationCause())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
+        assertThat(iStats.getNativeEmbeddingIndexRestorationCause())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
+        assertThat(iStats.getNativeInitializeIcuDataStatusCode())
+                .isEqualTo(AppSearchResult.RESULT_INVALID_ARGUMENT);
+        assertThat(iStats.getNativeNumFailedReindexedDocuments()).isEqualTo(0);
     }
 
     @Test
@@ -471,13 +654,25 @@ public class AppSearchLoggerTest {
         // Total latency captured in LocalStorage
         assertThat(iStats.getTotalLatencyMillis()).isEqualTo(0);
         assertThat(iStats.hasDeSync()).isFalse();
-        assertThat(iStats.getDocumentStoreDataStatus())
-                .isEqualTo(InitializeStatsProto.DocumentStoreDataStatus.NO_DATA_LOSS_VALUE);
-        assertThat(iStats.getDocumentCount()).isEqualTo(2);
+        assertThat(iStats.getNativeDocumentStoreDataStatus())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
+        assertThat(iStats.getNativeIndexRestorationCause())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
+        assertThat(iStats.getNativeDocumentCount()).isEqualTo(2);
         // Type1 + Type2 +2 for VisibilitySchema, +1 for VisibilityOverlay
-        assertThat(iStats.getSchemaTypeCount()).isEqualTo(5);
+        assertThat(iStats.getNativeSchemaTypeCount()).isEqualTo(5);
         assertThat(iStats.hasReset()).isEqualTo(false);
         assertThat(iStats.getResetStatusCode()).isEqualTo(AppSearchResult.RESULT_OK);
+        assertThat(iStats.getNativeNumPreviousInitFailures()).isEqualTo(0);
+        assertThat(iStats.getNativeIntegerIndexRestorationCause())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
+        assertThat(iStats.getNativeQualifiedIdJoinIndexRestorationCause())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
+        assertThat(iStats.getNativeEmbeddingIndexRestorationCause())
+                .isEqualTo(InitializeStats.RECOVERY_CAUSE_NONE);
+        assertThat(iStats.getNativeInitializeIcuDataStatusCode())
+                .isEqualTo(AppSearchResult.RESULT_INVALID_ARGUMENT);
+        assertThat(iStats.getNativeNumFailedReindexedDocuments()).isEqualTo(0);
         appSearchImpl.close();
     }
 
@@ -542,12 +737,12 @@ public class AppSearchLoggerTest {
         // Total latency captured in LocalStorage
         assertThat(iStats.getTotalLatencyMillis()).isEqualTo(0);
         assertThat(iStats.hasDeSync()).isFalse();
-        assertThat(iStats.getDocumentStoreDataStatus())
+        assertThat(iStats.getNativeDocumentStoreDataStatus())
                 .isEqualTo(InitializeStatsProto.DocumentStoreDataStatus.NO_DATA_LOSS_VALUE);
-        assertThat(iStats.getDocumentCount()).isEqualTo(2);
+        assertThat(iStats.getNativeDocumentCount()).isEqualTo(2);
         // Type1 + Type2 + 2(document and blob visibility db)
         // * (2 for VisibilitySchema +1 for VisibilityOverlay)
-        assertThat(iStats.getSchemaTypeCount()).isEqualTo(8);
+        assertThat(iStats.getNativeSchemaTypeCount()).isEqualTo(8);
         assertThat(iStats.hasReset()).isEqualTo(false);
         assertThat(iStats.getResetStatusCode()).isEqualTo(AppSearchResult.RESULT_OK);
         appSearchImpl.close();
@@ -809,7 +1004,7 @@ public class AppSearchLoggerTest {
         assertThat(searchResultPage.getResults().get(0).getGenericDocument()).isEqualTo(document2);
         assertThat(searchResultPage.getResults().get(1).getGenericDocument()).isEqualTo(document1);
 
-        SearchStats sStats = mLogger.mSearchStats;
+        QueryStats sStats = mLogger.mQueryStats;
 
         assertThat(sStats).isNotNull();
         // If the process goes really fast, the total latency could be 0. Since the default of total
@@ -817,17 +1012,27 @@ public class AppSearchLoggerTest {
         assertThat(sStats.getPackageName()).isEqualTo(testPackageName);
         assertThat(sStats.getDatabase()).isEqualTo(testDatabase);
         assertThat(sStats.getStatusCode()).isEqualTo(AppSearchResult.RESULT_OK);
-        assertThat(sStats.getVisibilityScope()).isEqualTo(SearchStats.VISIBILITY_SCOPE_LOCAL);
-        assertThat(sStats.getTermCount()).isEqualTo(2);
-        assertThat(sStats.getQueryLength()).isEqualTo(queryStr.length());
-        assertThat(sStats.getFilteredNamespaceCount()).isEqualTo(1);
-        assertThat(sStats.getFilteredSchemaTypeCount()).isEqualTo(1);
+        assertThat(sStats.getVisibilityScope()).isEqualTo(QueryStats.VISIBILITY_SCOPE_LOCAL);
         assertThat(sStats.getCurrentPageReturnedResultCount()).isEqualTo(2);
         assertThat(sStats.isFirstPage()).isTrue();
-        assertThat(sStats.getRankingStrategy())
-                .isEqualTo(SearchSpec.RANKING_STRATEGY_CREATION_TIMESTAMP);
-        assertThat(sStats.getScoredDocumentCount()).isEqualTo(2);
         assertThat(sStats.getResultWithSnippetsCount()).isEqualTo(0);
+        assertThat(sStats.getLiteIndexHitBufferByteSize()).isGreaterThan(0);
+        assertThat(sStats.getLiteIndexHitBufferUnsortedByteSize()).isGreaterThan(0);
+        assertThat(sStats.getPageTokenType()).isEqualTo(QueryStats.PAGE_TOKEN_TYPE_NONE);
+        assertThat(sStats.getNumResultStatesEvicted()).isEqualTo(0);
+
+        SearchStats parentSearchStats = sStats.getParentSearchStats();
+        assertThat(parentSearchStats.getNativeTermCount()).isEqualTo(2);
+        assertThat(parentSearchStats.getNativeQueryLength()).isEqualTo(queryStr.length());
+        assertThat(parentSearchStats.getNativeFilteredNamespaceCount()).isEqualTo(1);
+        assertThat(parentSearchStats.getNativeFilteredSchemaTypeCount()).isEqualTo(1);
+        assertThat(parentSearchStats.getNativeRankingStrategy())
+                .isEqualTo(SearchSpec.RANKING_STRATEGY_CREATION_TIMESTAMP);
+        assertThat(parentSearchStats.getNativeScoredDocumentCount()).isEqualTo(2);
+        assertThat(parentSearchStats.isNativeNumericQuery()).isFalse();
+        assertThat(parentSearchStats.getNativeNumFetchedHitsLiteIndex()).isGreaterThan(0);
+        assertThat(parentSearchStats.getNativeNumFetchedHitsMainIndex()).isEqualTo(0);
+        assertThat(parentSearchStats.getNativeNumFetchedHitsIntegerIndex()).isEqualTo(0);
     }
 
     @Test
@@ -863,7 +1068,7 @@ public class AppSearchLoggerTest {
                 searchSpec,
                 /* logger= */ mLogger);
 
-        SearchStats sStats = mLogger.mSearchStats;
+        QueryStats sStats = mLogger.mQueryStats;
         assertThat(sStats).isNotNull();
         assertThat(sStats.getPackageName()).isEqualTo(testPackageName);
         assertThat(sStats.getDatabase()).isEqualTo(testPackageName);
@@ -1012,23 +1217,16 @@ public class AppSearchLoggerTest {
         assertThat(searchResultPage.getResults().get(0).getGenericDocument()).isEqualTo(entity1);
         assertThat(searchResultPage.getResults().get(1).getGenericDocument()).isEqualTo(entity2);
 
-        SearchStats sStats = mLogger.mSearchStats;
+        QueryStats sStats = mLogger.mQueryStats;
 
         assertThat(sStats).isNotNull();
 
         assertThat(sStats.getPackageName()).isEqualTo(testPackageName);
         assertThat(sStats.getDatabase()).isEqualTo(testDatabase);
         assertThat(sStats.getStatusCode()).isEqualTo(AppSearchResult.RESULT_OK);
-        assertThat(sStats.getVisibilityScope()).isEqualTo(SearchStats.VISIBILITY_SCOPE_LOCAL);
-        assertThat(sStats.getTermCount()).isEqualTo(1);
-        assertThat(sStats.getQueryLength()).isEqualTo(queryStr.length());
-        assertThat(sStats.getFilteredNamespaceCount()).isEqualTo(1);
-        assertThat(sStats.getFilteredSchemaTypeCount()).isEqualTo(2);
+        assertThat(sStats.getVisibilityScope()).isEqualTo(QueryStats.VISIBILITY_SCOPE_LOCAL);
         assertThat(sStats.getCurrentPageReturnedResultCount()).isEqualTo(2);
         assertThat(sStats.isFirstPage()).isTrue();
-        assertThat(sStats.getRankingStrategy())
-                .isEqualTo(ScoringSpecProto.RankingStrategy.Code.JOIN_AGGREGATE_SCORE_VALUE);
-        assertThat(sStats.getScoredDocumentCount()).isEqualTo(2);
         assertThat(sStats.getResultWithSnippetsCount()).isEqualTo(0);
         // Join-specific stats. If the process goes really fast, the total latency could be 0.
         // Since the default of total latency is also 0, we just remove the assertion on
@@ -1036,6 +1234,30 @@ public class AppSearchLoggerTest {
         assertThat(sStats.getJoinType())
                 .isEqualTo(AppSearchSchema.StringPropertyConfig.JOINABLE_VALUE_TYPE_QUALIFIED_ID);
         assertThat(sStats.getNumJoinedResultsCurrentPage()).isEqualTo(4);
+        assertThat(sStats.getPageTokenType()).isEqualTo(QueryStats.PAGE_TOKEN_TYPE_NONE);
+        assertThat(sStats.getNumResultStatesEvicted()).isEqualTo(0);
+
+        SearchStats parentSearchStats = sStats.getParentSearchStats();
+        assertThat(parentSearchStats.getNativeTermCount()).isEqualTo(1);
+        assertThat(parentSearchStats.getNativeQueryLength()).isEqualTo(queryStr.length());
+        assertThat(parentSearchStats.getNativeFilteredNamespaceCount()).isEqualTo(1);
+        assertThat(parentSearchStats.getNativeFilteredSchemaTypeCount()).isEqualTo(2);
+        assertThat(parentSearchStats.getNativeRankingStrategy())
+                .isEqualTo(ScoringSpecProto.RankingStrategy.Code.JOIN_AGGREGATE_SCORE_VALUE);
+        assertThat(parentSearchStats.getNativeScoredDocumentCount()).isEqualTo(2);
+
+        SearchStats ChildSearchStats = sStats.getChildSearchStats();
+        assertThat(ChildSearchStats.getNativeTermCount()).isEqualTo(0);
+        assertThat(ChildSearchStats.getNativeQueryLength()).isEqualTo(0);
+        assertThat(ChildSearchStats.getNativeFilteredNamespaceCount()).isEqualTo(1);
+        assertThat(ChildSearchStats.getNativeFilteredSchemaTypeCount()).isEqualTo(2);
+        assertThat(ChildSearchStats.getNativeRankingStrategy())
+                .isEqualTo(SearchSpec.RANKING_STRATEGY_DOCUMENT_SCORE);
+        assertThat(ChildSearchStats.getNativeScoredDocumentCount()).isEqualTo(6);
+        assertThat(ChildSearchStats.isNativeNumericQuery()).isFalse();
+        assertThat(ChildSearchStats.getNativeNumFetchedHitsLiteIndex()).isEqualTo(0);
+        assertThat(ChildSearchStats.getNativeNumFetchedHitsMainIndex()).isEqualTo(0);
+        assertThat(ChildSearchStats.getNativeNumFetchedHitsIntegerIndex()).isEqualTo(0);
     }
 
     @Test
@@ -1140,7 +1362,17 @@ public class AppSearchLoggerTest {
         final String testDatabase = "testDatabase";
         final String testNamespace = "testNameSpace";
         List<AppSearchSchema> schemas =
-                Collections.singletonList(new AppSearchSchema.Builder("type").build());
+                Collections.singletonList(
+                        new AppSearchSchema.Builder("type")
+                                .addProperty(
+                                        new AppSearchSchema.StringPropertyConfig.Builder("body")
+                                                .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
+                                                .setTokenizerType(
+                                                        StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
+                                                .setIndexingType(
+                                                        StringPropertyConfig.INDEXING_TYPE_PREFIXES)
+                                                .build())
+                                .build());
         InternalSetSchemaResponse internalSetSchemaResponse =
                 mAppSearchImpl.setSchema(
                         testPackageName,
@@ -1152,9 +1384,13 @@ public class AppSearchLoggerTest {
                         /* setSchemaStatsBuilder= */ null);
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
         GenericDocument document1 =
-                new GenericDocument.Builder<>(testNamespace, "id1", "type").build();
+                new GenericDocument.Builder<>(testNamespace, "id1", "type")
+                        .setPropertyString("body", "body1")
+                        .build();
         GenericDocument document2 =
-                new GenericDocument.Builder<>(testNamespace, "id2", "type").build();
+                new GenericDocument.Builder<>(testNamespace, "id2", "type")
+                        .setPropertyString("body", "body2")
+                        .build();
         mAppSearchImpl.putDocument(
                 testPackageName,
                 testDatabase,
@@ -1175,7 +1411,7 @@ public class AppSearchLoggerTest {
         mAppSearchImpl.removeByQuery(
                 testPackageName,
                 testDatabase,
-                /* queryExpression= */ "",
+                /* queryExpression= */ "body",
                 searchSpec,
                 rStatsBuilder);
         RemoveStats rStats = rStatsBuilder.build();
@@ -1187,6 +1423,10 @@ public class AppSearchLoggerTest {
         assertThat(rStats.getDeleteType())
                 .isEqualTo(DeleteStatsProto.DeleteType.Code.DEPRECATED_QUERY_VALUE);
         assertThat(rStats.getDeletedDocumentCount()).isEqualTo(2);
+        assertThat(rStats.getQueryLength()).isEqualTo(4);
+        assertThat(rStats.getNumTerms()).isEqualTo(1);
+        assertThat(rStats.getNumSchemaTypesFiltered()).isEqualTo(1);
+        assertThat(rStats.getNumNamespacesFiltered()).isEqualTo(1);
     }
 
     @Test
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverterTest.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverterTest.java
index 0bb7a22e..96fbaaf3 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverterTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverterTest.java
@@ -148,7 +148,7 @@ public class SearchSpecToProtoConverterTest {
                                                         prefix2 + "typeB", configProto))),
                         mLocalStorageIcingOptionsConfig);
         // Convert SearchSpec to proto.
-        SearchSpecProto searchSpecProto = converter.toSearchSpecProto();
+        SearchSpecProto searchSpecProto = converter.toSearchSpecProto(/*isVMEnabled=*/false);
 
         assertThat(searchSpecProto.getQuery()).isEqualTo("query");
         assertThat(searchSpecProto.getSchemaTypeFiltersList())
@@ -215,7 +215,7 @@ public class SearchSpecToProtoConverterTest {
                         mLocalStorageIcingOptionsConfig);
 
         // Convert SearchSpec to proto.
-        SearchSpecProto searchSpecProto = converter.toSearchSpecProto();
+        SearchSpecProto searchSpecProto = converter.toSearchSpecProto(/*isVMEnabled=*/false);
 
         assertThat(searchSpecProto.getQuery()).isEqualTo("query");
         assertThat(searchSpecProto.getSchemaTypeFiltersList())
@@ -305,7 +305,7 @@ public class SearchSpecToProtoConverterTest {
                                 prefix2 + "typeB")));
 
         // Convert SearchSpec to proto.
-        SearchSpecProto searchSpecProto = converter.toSearchSpecProto();
+        SearchSpecProto searchSpecProto = converter.toSearchSpecProto(/*isVMEnabled=*/false);
 
         assertThat(searchSpecProto.getQuery()).isEqualTo("query");
         assertThat(searchSpecProto.getSchemaTypeFiltersList())
@@ -463,7 +463,10 @@ public class SearchSpecToProtoConverterTest {
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
         ResultSpecProto resultSpecProto =
-                convert.toResultSpecProto(new NamespaceCache(ImmutableMap.of()), new SchemaCache());
+                convert.toResultSpecProto(
+                        new NamespaceCache(ImmutableMap.of()),
+                        new SchemaCache(),
+                        /*isVMEnabled=*/false);
 
         assertThat(resultSpecProto.getNumPerPage()).isEqualTo(123);
         assertThat(resultSpecProto.getSnippetSpec().getNumToSnippet()).isEqualTo(234);
@@ -492,7 +495,10 @@ public class SearchSpecToProtoConverterTest {
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
         ResultSpecProto resultSpecProto =
-                convert.toResultSpecProto(new NamespaceCache(ImmutableMap.of()), new SchemaCache());
+                convert.toResultSpecProto(
+                        new NamespaceCache(ImmutableMap.of()),
+                        new SchemaCache(),
+                        /*isVMEnabled=*/false);
 
         assertThat(resultSpecProto.getNumPerPage()).isEqualTo(123);
         assertThat(resultSpecProto.getSnippetSpec().getNumToSnippet()).isEqualTo(234);
@@ -538,7 +544,9 @@ public class SearchSpecToProtoConverterTest {
 
         ResultSpecProto resultSpecProto =
                 converter.toResultSpecProto(
-                        new NamespaceCache(ImmutableMap.of()), new SchemaCache());
+                        new NamespaceCache(ImmutableMap.of()),
+                        new SchemaCache(),
+                        /*isVMEnabled=*/false);
 
         assertThat(resultSpecProto.getNumPerPage()).isEqualTo(123);
         assertThat(resultSpecProto.getSnippetSpec().getNumToSnippet()).isEqualTo(234);
@@ -592,13 +600,17 @@ public class SearchSpecToProtoConverterTest {
                         mLocalStorageIcingOptionsConfig);
 
         ResultSpecProto resultSpecProto =
-                converter.toResultSpecProto(namespaceCache, new SchemaCache(schemaMap));
+                converter.toResultSpecProto(
+                        namespaceCache,
+                        new SchemaCache(schemaMap),
+                        /*isVMEnabled=*/false);
 
         assertThat(resultSpecProto.getResultGroupingsCount()).isEqualTo(1);
         assertThat(resultSpecProto.getResultGroupings(0).getEntryGroupings(0).getNamespace())
                 .isEqualTo("contacts$database/namespaceA");
         ResultSpecProto nestedResultSpecProto =
-                converter.toSearchSpecProto().getJoinSpec().getNestedSpec().getResultSpec();
+                converter.toSearchSpecProto(/*isVMEnabled=*/false)
+                        .getJoinSpec().getNestedSpec().getResultSpec();
         assertThat(nestedResultSpecProto.getResultGroupingsCount()).isEqualTo(1);
         assertThat(nestedResultSpecProto.getResultGroupings(0).getEntryGroupings(0).getNamespace())
                 .isEqualTo("aiai$database/namespaceA");
@@ -649,7 +661,10 @@ public class SearchSpecToProtoConverterTest {
                         mLocalStorageIcingOptionsConfig);
 
         ResultSpecProto resultSpecProto =
-                converter.toResultSpecProto(namespaceCache, new SchemaCache(schemaMap));
+                converter.toResultSpecProto(
+                        namespaceCache,
+                        new SchemaCache(schemaMap),
+                        /*isVMEnabled=*/false);
 
         assertThat(resultSpecProto.getTypePropertyMasksCount()).isEqualTo(1);
         assertThat(resultSpecProto.getTypePropertyMasks(0).getSchemaType())
@@ -657,7 +672,8 @@ public class SearchSpecToProtoConverterTest {
         assertThat(resultSpecProto.getTypePropertyMasks(0).getPaths(0)).isEqualTo("name");
 
         ResultSpecProto nestedResultSpecProto =
-                converter.toSearchSpecProto().getJoinSpec().getNestedSpec().getResultSpec();
+                converter.toSearchSpecProto(/*isVMEnabled=*/false)
+                        .getJoinSpec().getNestedSpec().getResultSpec();
         assertThat(nestedResultSpecProto.getTypePropertyMasksCount()).isEqualTo(1);
         assertThat(nestedResultSpecProto.getTypePropertyMasks(0).getSchemaType())
                 .isEqualTo("aiai$database/ContactAction");
@@ -687,7 +703,10 @@ public class SearchSpecToProtoConverterTest {
 
         ResultSpecProto resultSpecProto =
                 converter.toResultSpecProto(
-                        new NamespaceCache(ImmutableMap.of()), new SchemaCache());
+                        new NamespaceCache(
+                                ImmutableMap.of()),
+                        new SchemaCache(),
+                        /*isVMEnabled=*/false);
 
         assertThat(resultSpecProto.getTypePropertyMasksCount()).isEqualTo(1);
         assertThat(resultSpecProto.getTypePropertyMasks(0).getSchemaType())
@@ -716,7 +735,9 @@ public class SearchSpecToProtoConverterTest {
 
         ResultSpecProto resultSpecProto =
                 converter.toResultSpecProto(
-                        new NamespaceCache(ImmutableMap.of()), new SchemaCache());
+                        new NamespaceCache(ImmutableMap.of()),
+                        new SchemaCache(),
+                        /*isVMEnabled=*/false);
 
         assertThat(resultSpecProto.getTypePropertyMasksCount()).isEqualTo(1);
         assertThat(resultSpecProto.getTypePropertyMasks(0).getSchemaType())
@@ -765,7 +786,10 @@ public class SearchSpecToProtoConverterTest {
                         mLocalStorageIcingOptionsConfig);
 
         ResultSpecProto resultSpecProto =
-                converter.toResultSpecProto(namespaceCache, new SchemaCache(schemaMap));
+                converter.toResultSpecProto(
+                        namespaceCache,
+                        new SchemaCache(schemaMap),
+                        /*isVMEnabled=*/false);
 
         // The "name" property specified in Artist's projection should remain in the result,
         // since even though Artist doesn't exist in the original schema filters directly, we have
@@ -778,6 +802,169 @@ public class SearchSpecToProtoConverterTest {
         assertThat(resultSpecProto.getTypePropertyMasks(0).getPaths(0)).isEqualTo("name");
     }
 
+    @Test
+    public void testToResultSpecProto_isVMEnabledFalse_normalNumTotalBytesPerPageThresholdSet()
+            throws Exception {
+        IcingOptionsConfig customConfig = new LocalStorageIcingOptionsConfig() {
+            @Override
+            public int getMaxPageBytesLimit() {
+                return 12345;
+            }
+
+            @Override
+            public int getMaxPageBytesLimitForVm() {
+                return 98765;
+            }
+        };
+        NamespaceCache namespaceCache = new NamespaceCache(ImmutableMap.of());
+        SchemaCache schemaCache = new SchemaCache();
+        SearchSpecToProtoConverter converter =
+                new SearchSpecToProtoConverter(
+                        /* queryExpression= */ "",
+                        new SearchSpec.Builder().build(),
+                        /* prefixes= */ ImmutableSet.of(),
+                        namespaceCache,
+                        schemaCache,
+                        customConfig);
+        ResultSpecProto resultSpecProto =
+                converter.toResultSpecProto(namespaceCache, schemaCache, /*isVMEnabled=*/false);
+        assertThat(resultSpecProto.getNumTotalBytesPerPageThreshold()).isEqualTo(12345);
+    }
+
+    @Test
+    public void testToResultSpecProto_isVMEnabledTrue_vmNumTotalBytesPerPageThresholdSet()
+            throws Exception {
+        IcingOptionsConfig customConfig = new LocalStorageIcingOptionsConfig() {
+            @Override
+            public int getMaxPageBytesLimit() {
+                return 12345;
+            }
+
+            @Override
+            public int getMaxPageBytesLimitForVm() {
+                return 98765;
+            }
+        };
+        NamespaceCache namespaceCache = new NamespaceCache(ImmutableMap.of());
+        SchemaCache schemaCache = new SchemaCache();
+        SearchSpecToProtoConverter converter =
+                new SearchSpecToProtoConverter(
+                        /* queryExpression= */ "",
+                        new SearchSpec.Builder().build(),
+                        /* prefixes= */ ImmutableSet.of(),
+                        namespaceCache,
+                        schemaCache,
+                        customConfig);
+        ResultSpecProto resultSpecProto =
+                converter.toResultSpecProto(namespaceCache, schemaCache, /*isVMEnabled=*/true);
+        assertThat(resultSpecProto.getNumTotalBytesPerPageThreshold()).isEqualTo(98765);
+    }
+
+
+    @Test
+    public void testToSearchSpecProto_isVMEnabledFalse_normalNumTotalBytesPerPageThresholdSet()
+            throws Exception {
+        IcingOptionsConfig customConfig = new LocalStorageIcingOptionsConfig() {
+            @Override
+            public int getMaxPageBytesLimit() {
+                return 12345;
+            }
+
+            @Override
+            public int getMaxPageBytesLimitForVm() {
+                return 98765;
+            }
+        };
+
+        // Create a JoinSpec object and set it in the converter
+        JoinSpec joinSpec =
+                new JoinSpec.Builder("childPropertyExpression")
+                        .setNestedSearch("", new SearchSpec.Builder().build())
+                        .build();
+
+        SearchSpec searchSpec =
+                new SearchSpec.Builder()
+                        .setJoinSpec(joinSpec)
+                        .build();
+
+        String personPrefix = PrefixUtil.createPrefix("contacts", "database");
+        NamespaceCache namespaceCache =
+                new NamespaceCache(
+                        ImmutableMap.of(
+                                personPrefix, ImmutableSet.of(personPrefix + "namespaceA")));
+
+        SchemaTypeConfigProto configProto = SchemaTypeConfigProto.getDefaultInstance();
+        Map<String, Map<String, SchemaTypeConfigProto>> schemaMap =
+                ImmutableMap.of(
+                        personPrefix, ImmutableMap.of(personPrefix + "Person", configProto));
+        SchemaCache schemaCache = new SchemaCache(schemaMap);
+        SearchSpecToProtoConverter converter =
+                new SearchSpecToProtoConverter(
+                        /* queryExpression= */ "",
+                        searchSpec,
+                        /* prefixes= */ ImmutableSet.of(personPrefix),
+                        namespaceCache,
+                        schemaCache,
+                        customConfig);
+
+        ResultSpecProto nestedResultSpecProto =
+                converter.toSearchSpecProto(/*isVMEnabled=*/false)
+                        .getJoinSpec().getNestedSpec().getResultSpec();
+        assertThat(nestedResultSpecProto.getNumTotalBytesPerPageThreshold()).isEqualTo(12345);
+    }
+
+    @Test
+    public void testToSearchSpecProto_isVMEnabledTrue_vmNumTotalBytesPerPageThresholdSet()
+            throws Exception {
+        IcingOptionsConfig customConfig = new LocalStorageIcingOptionsConfig() {
+            @Override
+            public int getMaxPageBytesLimit() {
+                return 12345;
+            }
+
+            @Override
+            public int getMaxPageBytesLimitForVm() {
+                return 98765;
+            }
+        };
+
+        // Create a JoinSpec object and set it in the converter
+        JoinSpec joinSpec =
+                new JoinSpec.Builder("childPropertyExpression")
+                        .setNestedSearch("", new SearchSpec.Builder().build())
+                        .build();
+
+        SearchSpec searchSpec =
+                new SearchSpec.Builder()
+                        .setJoinSpec(joinSpec)
+                        .build();
+
+        String personPrefix = PrefixUtil.createPrefix("contacts", "database");
+        NamespaceCache namespaceCache =
+                new NamespaceCache(
+                        ImmutableMap.of(
+                                personPrefix, ImmutableSet.of(personPrefix + "namespaceA")));
+
+        SchemaTypeConfigProto configProto = SchemaTypeConfigProto.getDefaultInstance();
+        Map<String, Map<String, SchemaTypeConfigProto>> schemaMap =
+                ImmutableMap.of(
+                        personPrefix, ImmutableMap.of(personPrefix + "Person", configProto));
+        SchemaCache schemaCache = new SchemaCache(schemaMap);
+        SearchSpecToProtoConverter converter =
+                new SearchSpecToProtoConverter(
+                        /* queryExpression= */ "",
+                        searchSpec,
+                        /* prefixes= */ ImmutableSet.of(personPrefix),
+                        namespaceCache,
+                        schemaCache,
+                        customConfig);
+
+        ResultSpecProto nestedResultSpecProto =
+                converter.toSearchSpecProto(/*isVMEnabled=*/true)
+                        .getJoinSpec().getNestedSpec().getResultSpec();
+        assertThat(nestedResultSpecProto.getNumTotalBytesPerPageThreshold()).isEqualTo(98765);
+    }
+
     @Test
     public void testToSearchSpecProto_propertyFilter_withJoinSpec_packageFilter() throws Exception {
         String personPrefix = PrefixUtil.createPrefix("contacts", "database");
@@ -822,7 +1009,7 @@ public class SearchSpecToProtoConverterTest {
                         new SchemaCache(schemaMap),
                         mLocalStorageIcingOptionsConfig);
 
-        SearchSpecProto searchSpecProto = converter.toSearchSpecProto();
+        SearchSpecProto searchSpecProto = converter.toSearchSpecProto(/*isVMEnabled=*/false);
 
         assertThat(searchSpecProto.getTypePropertyFiltersCount()).isEqualTo(1);
         assertThat(searchSpecProto.getTypePropertyFilters(0).getSchemaType())
@@ -857,7 +1044,7 @@ public class SearchSpecToProtoConverterTest {
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
 
-        SearchSpecProto searchSpecProto = converter.toSearchSpecProto();
+        SearchSpecProto searchSpecProto = converter.toSearchSpecProto(/*isVMEnabled=*/false);
 
         assertThat(searchSpecProto.getTypePropertyFiltersCount()).isEqualTo(1);
         assertThat(searchSpecProto.getTypePropertyFilters(0).getSchemaType())
@@ -905,7 +1092,7 @@ public class SearchSpecToProtoConverterTest {
                         new SchemaCache(schemaMap),
                         mLocalStorageIcingOptionsConfig);
 
-        SearchSpecProto searchSpecProto = converter.toSearchSpecProto();
+        SearchSpecProto searchSpecProto = converter.toSearchSpecProto(/*isVMEnabled=*/false);
 
         // The "name" property specified in Artist's property filters should remain in the result,
         // since even though Artist doesn't exist in the original schema filters directly, we have
@@ -974,7 +1161,8 @@ public class SearchSpecToProtoConverterTest {
                 .isEqualTo("name");
 
         ScoringSpecProto nestedScoringSpecProto =
-                converter.toSearchSpecProto().getJoinSpec().getNestedSpec().getScoringSpec();
+                converter.toSearchSpecProto(/*isVMEnabled=*/false)
+                        .getJoinSpec().getNestedSpec().getScoringSpec();
         assertThat(nestedScoringSpecProto.getTypePropertyWeightsCount()).isEqualTo(1);
         assertThat(nestedScoringSpecProto.getTypePropertyWeights(0).getSchemaType())
                 .isEqualTo("aiai$database/ContactAction");
@@ -1016,7 +1204,8 @@ public class SearchSpecToProtoConverterTest {
                                                 ImmutableSet.of(
                                                         prefix2 + "namespaceA",
                                                         prefix2 + "namespaceB"))),
-                        new SchemaCache());
+                        new SchemaCache(),
+                        /*isVMEnabled=*/false);
 
         assertThat(resultSpecProto.getResultGroupingsCount()).isEqualTo(2);
         // First grouping should have same package name.
@@ -1064,7 +1253,10 @@ public class SearchSpecToProtoConverterTest {
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
         ResultSpecProto resultSpecProto =
-                converter.toResultSpecProto(namespaceCache, new SchemaCache());
+                converter.toResultSpecProto(
+                        namespaceCache,
+                        new SchemaCache(),
+                        /*isVMEnabled=*/false);
 
         assertThat(resultSpecProto.getResultGroupingsCount()).isEqualTo(2);
         // First grouping should have same namespace.
@@ -1112,7 +1304,9 @@ public class SearchSpecToProtoConverterTest {
                         mLocalStorageIcingOptionsConfig);
         ResultSpecProto resultSpecProto =
                 converter.toResultSpecProto(
-                        new NamespaceCache(ImmutableMap.of()), new SchemaCache(schemaMap));
+                        new NamespaceCache(ImmutableMap.of()),
+                        new SchemaCache(schemaMap),
+                        /*isVMEnabled=*/false);
 
         assertThat(resultSpecProto.getResultGroupingsCount()).isEqualTo(2);
         // First grouping should have the same schema type.
@@ -1158,7 +1352,10 @@ public class SearchSpecToProtoConverterTest {
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
         ResultSpecProto resultSpecProto =
-                converter.toResultSpecProto(namespaceCache, new SchemaCache());
+                converter.toResultSpecProto(
+                        namespaceCache,
+                        new SchemaCache(),
+                        /*isVMEnabled=*/false);
 
         // All namespace should be separated.
         assertThat(resultSpecProto.getResultGroupingsCount()).isEqualTo(4);
@@ -1200,7 +1397,9 @@ public class SearchSpecToProtoConverterTest {
                         mLocalStorageIcingOptionsConfig);
         ResultSpecProto resultSpecProto =
                 converter.toResultSpecProto(
-                        new NamespaceCache(ImmutableMap.of()), new SchemaCache(schemaMap));
+                        new NamespaceCache(ImmutableMap.of()),
+                        new SchemaCache(schemaMap),
+                        /*isVMEnabled=*/false);
 
         // All schema should be separated.
         assertThat(resultSpecProto.getResultGroupingsCount()).isEqualTo(4);
@@ -1252,7 +1451,10 @@ public class SearchSpecToProtoConverterTest {
                         new SchemaCache(schemaMap),
                         mLocalStorageIcingOptionsConfig);
         ResultSpecProto resultSpecProto =
-                converter.toResultSpecProto(namespaceCache, new SchemaCache(schemaMap));
+                converter.toResultSpecProto(
+                        namespaceCache,
+                        new SchemaCache(schemaMap),
+                        /*isVMEnabled=*/false);
 
         assertThat(resultSpecProto.getResultGroupingsCount()).isEqualTo(4);
         ResultSpecProto.ResultGrouping grouping1 = resultSpecProto.getResultGroupings(0);
@@ -1346,7 +1548,10 @@ public class SearchSpecToProtoConverterTest {
                         new SchemaCache(schemaMap),
                         mLocalStorageIcingOptionsConfig);
         ResultSpecProto resultSpecProto =
-                converter.toResultSpecProto(namespaceCache, new SchemaCache(schemaMap));
+                converter.toResultSpecProto(
+                        namespaceCache,
+                        new SchemaCache(schemaMap),
+                        /*isVMEnabled=*/false);
 
         assertThat(resultSpecProto.getResultGroupingsCount()).isEqualTo(8);
         ResultSpecProto.ResultGrouping grouping1 = resultSpecProto.getResultGroupings(0);
@@ -1441,7 +1646,7 @@ public class SearchSpecToProtoConverterTest {
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
 
-        SearchSpecProto searchSpecProto = converter.toSearchSpecProto();
+        SearchSpecProto searchSpecProto = converter.toSearchSpecProto(/*isVMEnabled=*/false);
 
         assertThat(searchSpecProto.getNamespaceFiltersList())
                 .containsExactly(
@@ -1474,7 +1679,7 @@ public class SearchSpecToProtoConverterTest {
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
 
-        SearchSpecProto searchSpecProto = converter.toSearchSpecProto();
+        SearchSpecProto searchSpecProto = converter.toSearchSpecProto(/*isVMEnabled=*/false);
         // Only search prefix1 will return namespace 1 and 2.
         assertThat(searchSpecProto.getNamespaceFiltersList())
                 .containsExactly("package$database1/namespace1", "package$database1/namespace2");
@@ -1500,7 +1705,7 @@ public class SearchSpecToProtoConverterTest {
                                                 "package$database1/namespace2"))),
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
-        SearchSpecProto searchSpecProto = converter.toSearchSpecProto();
+        SearchSpecProto searchSpecProto = converter.toSearchSpecProto(/*isVMEnabled=*/false);
         // If the searching namespace filter is not empty, the target namespace filter will be the
         // intersection of the searching namespace filters that users want to search over and
         // those candidates which are stored in AppSearch.
@@ -1527,7 +1732,7 @@ public class SearchSpecToProtoConverterTest {
                                                 "package$database1/namespace2"))),
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
-        SearchSpecProto searchSpecProto = converter.toSearchSpecProto();
+        SearchSpecProto searchSpecProto = converter.toSearchSpecProto(/*isVMEnabled=*/false);
         // If the searching namespace filter is not empty, the target namespace filter will be the
         // intersection of the searching namespace filters that users want to search over and
         // those candidates which are stored in AppSearch.
@@ -1564,7 +1769,7 @@ public class SearchSpecToProtoConverterTest {
                                                         "package$database2/typeD",
                                                                 schemaTypeConfigProto))),
                         mLocalStorageIcingOptionsConfig);
-        SearchSpecProto searchSpecProto = converter.toSearchSpecProto();
+        SearchSpecProto searchSpecProto = converter.toSearchSpecProto(/*isVMEnabled=*/false);
         // Empty searching filter will get all types for target filter
         assertThat(searchSpecProto.getSchemaTypeFiltersList())
                 .containsExactly(
@@ -1603,7 +1808,7 @@ public class SearchSpecToProtoConverterTest {
                                                         "package$database2/typeD",
                                                                 schemaTypeConfigProto))),
                         mLocalStorageIcingOptionsConfig);
-        SearchSpecProto searchSpecProto = converter.toSearchSpecProto();
+        SearchSpecProto searchSpecProto = converter.toSearchSpecProto(/*isVMEnabled=*/false);
         // Only search prefix1 will return typeA and B.
         assertThat(searchSpecProto.getSchemaTypeFiltersList())
                 .containsExactly("package$database1/typeA", "package$database1/typeB");
@@ -1632,7 +1837,7 @@ public class SearchSpecToProtoConverterTest {
                                                 "package$database1/typeA", schemaTypeConfigProto,
                                                 "package$database1/typeB", schemaTypeConfigProto))),
                         mLocalStorageIcingOptionsConfig);
-        SearchSpecProto searchSpecProto = converter.toSearchSpecProto();
+        SearchSpecProto searchSpecProto = converter.toSearchSpecProto(/*isVMEnabled=*/false);
         // If the searching schema filter is not empty, the target schema filter will be the
         // intersection of the schema filters that users want to search over and those candidates
         // which are stored in AppSearch.
@@ -1672,7 +1877,7 @@ public class SearchSpecToProtoConverterTest {
                                         prefix, ImmutableSet.of("package$database/namespace"))),
                         new SchemaCache(schemaMap),
                         mLocalStorageIcingOptionsConfig);
-        SearchSpecProto searchSpecProto = converter.toSearchSpecProto();
+        SearchSpecProto searchSpecProto = converter.toSearchSpecProto(/*isVMEnabled=*/false);
         // The schema filter of "Person" specified in searchSpec will be expanded to "Artist" via
         // polymorphism.
         assertThat(searchSpecProto.getSchemaTypeFiltersList())
@@ -1723,7 +1928,7 @@ public class SearchSpecToProtoConverterTest {
                                         prefix, ImmutableSet.of("package$database/namespace"))),
                         new SchemaCache(schemaMap),
                         mLocalStorageIcingOptionsConfig);
-        SearchSpecProto searchSpecProto = converter.toSearchSpecProto();
+        SearchSpecProto searchSpecProto = converter.toSearchSpecProto(/*isVMEnabled=*/false);
         assertThat(searchSpecProto.getSchemaTypeFiltersList())
                 .containsExactly(
                         "package$database/A",
@@ -1755,7 +1960,7 @@ public class SearchSpecToProtoConverterTest {
                                                 "package$database1/typeA", schemaTypeConfigProto,
                                                 "package$database1/typeB", schemaTypeConfigProto))),
                         mLocalStorageIcingOptionsConfig);
-        SearchSpecProto searchSpecProto = converter.toSearchSpecProto();
+        SearchSpecProto searchSpecProto = converter.toSearchSpecProto(/*isVMEnabled=*/false);
         // If there is no intersection of the schema filters that user want to search over and
         // those filters which are stored in AppSearch, return empty.
         assertThat(searchSpecProto.getSchemaTypeFiltersList()).isEmpty();
@@ -1799,7 +2004,7 @@ public class SearchSpecToProtoConverterTest {
                         /* visiblePrefixedSchemas= */ ImmutableSet.of(
                                 prefix + "schema1", prefix + "schema3")));
 
-        SearchSpecProto searchSpecProto = converter.toSearchSpecProto();
+        SearchSpecProto searchSpecProto = converter.toSearchSpecProto(/*isVMEnabled=*/false);
         // schema 2 is filtered out since it is not searchable for user.
         assertThat(searchSpecProto.getSchemaTypeFiltersList())
                 .containsExactly(prefix + "schema1", prefix + "schema3");
@@ -1870,7 +2075,8 @@ public class SearchSpecToProtoConverterTest {
                 /* visibilityChecker= */ null);
         assertThat(nonEmptyConverter.hasNothingToSearch()).isTrue();
         // As the JoinSpec has nothing to search, it should not be part of the SearchSpec
-        assertThat(nonEmptyConverter.toSearchSpecProto().hasJoinSpec()).isFalse();
+        assertThat(
+                nonEmptyConverter.toSearchSpecProto(/*isVMEnabled=*/false).hasJoinSpec()).isFalse();
     }
 
     @Test
@@ -1913,7 +2119,7 @@ public class SearchSpecToProtoConverterTest {
                 AppSearchTestUtils.createMockVisibilityChecker(
                         /* visiblePrefixedSchemas= */ ImmutableSet.of(prefix + "schema3")));
 
-        SearchSpecProto searchSpecProto = converter.toSearchSpecProto();
+        SearchSpecProto searchSpecProto = converter.toSearchSpecProto(/*isVMEnabled=*/false);
         assertThat(searchSpecProto.getSchemaTypeFiltersList()).containsExactly(prefix + "schema3");
 
         // Schema 1 and 2 are filtered out of the nested spec. As the JoinSpec has nothing to
@@ -2051,7 +2257,7 @@ public class SearchSpecToProtoConverterTest {
                         namespaceCache,
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
-        SearchSpecProto proto = converter.toSearchSpecProto();
+        SearchSpecProto proto = converter.toSearchSpecProto(/*isVMEnabled=*/false);
         assertThat(proto.getDocumentUriFiltersList())
                 .containsExactly(
                         NamespaceDocumentUriGroup.newBuilder()
@@ -2110,7 +2316,7 @@ public class SearchSpecToProtoConverterTest {
                         namespaceCache,
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
-        SearchSpecProto proto = converter.toSearchSpecProto();
+        SearchSpecProto proto = converter.toSearchSpecProto(/*isVMEnabled=*/false);
         assertThat(proto.getDocumentUriFiltersList())
                 .containsExactly(
                         NamespaceDocumentUriGroup.newBuilder()
@@ -2151,7 +2357,7 @@ public class SearchSpecToProtoConverterTest {
                         namespaceCache,
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
-        SearchSpecProto proto = converter.toSearchSpecProto();
+        SearchSpecProto proto = converter.toSearchSpecProto(/*isVMEnabled=*/false);
         assertThat(proto.getDocumentUriFiltersList())
                 .containsExactly(
                         NamespaceDocumentUriGroup.newBuilder()
@@ -2199,7 +2405,7 @@ public class SearchSpecToProtoConverterTest {
                         namespaceCache,
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
-        SearchSpecProto proto = converter.toSearchSpecProto();
+        SearchSpecProto proto = converter.toSearchSpecProto(/*isVMEnabled=*/false);
         assertThat(proto.getDocumentUriFiltersList())
                 .containsExactly(
                         NamespaceDocumentUriGroup.newBuilder()
@@ -2235,7 +2441,7 @@ public class SearchSpecToProtoConverterTest {
                         namespaceCache,
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
-        SearchSpecProto proto = converter.toSearchSpecProto();
+        SearchSpecProto proto = converter.toSearchSpecProto(/*isVMEnabled=*/false);
         assertThat(proto.getDocumentUriFiltersList()).isEmpty();
     }
 }
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/stats/AppSearchStatsTest.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/stats/AppSearchStatsTest.java
index 97963ec7..a0f15006 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/stats/AppSearchStatsTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/stats/AppSearchStatsTest.java
@@ -108,6 +108,8 @@ public class AppSearchStatsTest {
         final int nativeQualifiedIdJoinIndexLatencyMillis = 11;
         final int nativeLiteIndexSortLatencyMillis = 12;
         final int enabledFeatures = 1;
+        int metadataTermIndexLatencyMillis = 13;
+        int embeddingIndexLatencyMillis = 14;
         final PutDocumentStats.Builder pStatsBuilder =
                 new PutDocumentStats.Builder(TEST_PACKAGE_NAME, TEST_DATA_BASE)
                         .setStatusCode(TEST_STATUS_CODE)
@@ -125,7 +127,9 @@ public class AppSearchStatsTest {
                         .setNativeQualifiedIdJoinIndexLatencyMillis(
                                 nativeQualifiedIdJoinIndexLatencyMillis)
                         .setNativeLiteIndexSortLatencyMillis(nativeLiteIndexSortLatencyMillis)
-                        .setLaunchVMEnabled(true);
+                        .setLaunchVMEnabled(true)
+                        .setMetadataTermIndexLatencyMillis(metadataTermIndexLatencyMillis)
+                        .setEmbeddingIndexLatencyMillis(embeddingIndexLatencyMillis);
 
         final PutDocumentStats pStats = pStatsBuilder.build();
 
@@ -154,23 +158,33 @@ public class AppSearchStatsTest {
         assertThat(pStats.getNativeLiteIndexSortLatencyMillis())
                 .isEqualTo(nativeLiteIndexSortLatencyMillis);
         assertThat(pStats.getEnabledFeatures()).isEqualTo(enabledFeatures);
+        assertThat(pStats.getMetadataTermIndexLatencyMillis())
+                .isEqualTo(metadataTermIndexLatencyMillis);
+        assertThat(pStats.getEmbeddingIndexLatencyMillis()).isEqualTo(embeddingIndexLatencyMillis);
     }
 
     @Test
     public void testAppSearchStats_InitializeStats() {
+        int enabledFeatures = 1;
         int prepareSchemaAndNamespacesLatencyMillis = 1;
         int prepareVisibilityFileLatencyMillis = 2;
         int nativeLatencyMillis = 3;
-        int nativeDocumentStoreRecoveryCause = 4;
-        int nativeIndexRestorationCause = 5;
-        int nativeSchemaStoreRecoveryCause = 6;
-        int nativeDocumentStoreRecoveryLatencyMillis = 7;
-        int nativeIndexRestorationLatencyMillis = 8;
-        int nativeSchemaStoreRecoveryLatencyMillis = 9;
-        int nativeDocumentStoreDataStatus = 10;
-        int nativeNumDocuments = 11;
-        int nativeNumSchemaTypes = 12;
-        int enabledFeatures = 1;
+        int nativeDocumentStoreRecoveryCause = InitializeStats.RECOVERY_CAUSE_DEPENDENCIES_CHANGED;
+        int nativeIndexRestorationCause = InitializeStats.RECOVERY_CAUSE_FEATURE_FLAG_CHANGED;
+        int nativeSchemaStoreRecoveryCause = InitializeStats.RECOVERY_CAUSE_IO_ERROR;
+        int nativeDocumentStoreRecoveryLatencyMillis = 4;
+        int nativeIndexRestorationLatencyMillis = 5;
+        int nativeSchemaStoreRecoveryLatencyMillis = 6;
+        int nativeDocumentStoreDataStatus = 7;
+        int nativeNumDocuments = 8;
+        int nativeNumSchemaTypes = 9;
+        int numPreviousInitFailures = 10;
+        int integerIndexRestorationCause = InitializeStats.RECOVERY_CAUSE_DATA_LOSS;
+        int qualifiedIdJoinIndexRestorationCause =
+                InitializeStats.RECOVERY_CAUSE_INCONSISTENT_WITH_GROUND_TRUTH;
+        int embeddingIndexRestorationCause = InitializeStats.RECOVERY_CAUSE_DATA_LOSS;
+        int initializeIcuDataStatusCode = 11;
+        int numFailedReindexedDocuments = 12;
 
         final InitializeStats.Builder iStatsBuilder =
                 new InitializeStats.Builder()
@@ -181,19 +195,27 @@ public class AppSearchStatsTest {
                                 prepareSchemaAndNamespacesLatencyMillis)
                         .setPrepareVisibilityStoreLatencyMillis(prepareVisibilityFileLatencyMillis)
                         .setNativeLatencyMillis(nativeLatencyMillis)
-                        .setDocumentStoreRecoveryCause(nativeDocumentStoreRecoveryCause)
-                        .setIndexRestorationCause(nativeIndexRestorationCause)
-                        .setSchemaStoreRecoveryCause(nativeSchemaStoreRecoveryCause)
-                        .setDocumentStoreRecoveryLatencyMillis(
+                        .setNativeDocumentStoreRecoveryCause(nativeDocumentStoreRecoveryCause)
+                        .setNativeIndexRestorationCause(nativeIndexRestorationCause)
+                        .setNativeSchemaStoreRecoveryCause(nativeSchemaStoreRecoveryCause)
+                        .setNativeDocumentStoreRecoveryLatencyMillis(
                                 nativeDocumentStoreRecoveryLatencyMillis)
-                        .setIndexRestorationLatencyMillis(nativeIndexRestorationLatencyMillis)
-                        .setSchemaStoreRecoveryLatencyMillis(nativeSchemaStoreRecoveryLatencyMillis)
-                        .setDocumentStoreDataStatus(nativeDocumentStoreDataStatus)
-                        .setDocumentCount(nativeNumDocuments)
-                        .setSchemaTypeCount(nativeNumSchemaTypes)
+                        .setNativeIndexRestorationLatencyMillis(nativeIndexRestorationLatencyMillis)
+                        .setNativeSchemaStoreRecoveryLatencyMillis(
+                                nativeSchemaStoreRecoveryLatencyMillis)
+                        .setNativeDocumentStoreDataStatus(nativeDocumentStoreDataStatus)
+                        .setNativeDocumentCount(nativeNumDocuments)
+                        .setNativeSchemaTypeCount(nativeNumSchemaTypes)
                         .setHasReset(true)
                         .setResetStatusCode(AppSearchResult.RESULT_INVALID_SCHEMA)
-                        .setLaunchVMEnabled(true);
+                        .setLaunchVMEnabled(true)
+                        .setNativeNumPreviousInitFailures(numPreviousInitFailures)
+                        .setNativeIntegerIndexRestorationCause(integerIndexRestorationCause)
+                        .setNativeQualifiedIdJoinIndexRestorationCause(
+                                qualifiedIdJoinIndexRestorationCause)
+                        .setNativeEmbeddingIndexRestorationCause(embeddingIndexRestorationCause)
+                        .setNativeInitializeIcuDataStatusCode(initializeIcuDataStatusCode)
+                        .setNativeNumFailedReindexedDocuments(numFailedReindexedDocuments);
         final InitializeStats iStats = iStatsBuilder.build();
 
         assertThat(iStats.getStatusCode()).isEqualTo(TEST_STATUS_CODE);
@@ -204,82 +226,214 @@ public class AppSearchStatsTest {
         assertThat(iStats.getPrepareVisibilityStoreLatencyMillis())
                 .isEqualTo(prepareVisibilityFileLatencyMillis);
         assertThat(iStats.getNativeLatencyMillis()).isEqualTo(nativeLatencyMillis);
-        assertThat(iStats.getDocumentStoreRecoveryCause())
+        assertThat(iStats.getNativeDocumentStoreRecoveryCause())
                 .isEqualTo(nativeDocumentStoreRecoveryCause);
-        assertThat(iStats.getIndexRestorationCause()).isEqualTo(nativeIndexRestorationCause);
-        assertThat(iStats.getSchemaStoreRecoveryCause()).isEqualTo(nativeSchemaStoreRecoveryCause);
-        assertThat(iStats.getDocumentStoreRecoveryLatencyMillis())
+        assertThat(iStats.getNativeIndexRestorationCause()).isEqualTo(nativeIndexRestorationCause);
+        assertThat(iStats.getNativeSchemaStoreRecoveryCause())
+                .isEqualTo(nativeSchemaStoreRecoveryCause);
+        assertThat(iStats.getNativeDocumentStoreRecoveryLatencyMillis())
                 .isEqualTo(nativeDocumentStoreRecoveryLatencyMillis);
-        assertThat(iStats.getIndexRestorationLatencyMillis())
+        assertThat(iStats.getNativeIndexRestorationLatencyMillis())
                 .isEqualTo(nativeIndexRestorationLatencyMillis);
-        assertThat(iStats.getSchemaStoreRecoveryLatencyMillis())
+        assertThat(iStats.getNativeSchemaStoreRecoveryLatencyMillis())
                 .isEqualTo(nativeSchemaStoreRecoveryLatencyMillis);
-        assertThat(iStats.getDocumentStoreDataStatus()).isEqualTo(nativeDocumentStoreDataStatus);
-        assertThat(iStats.getDocumentCount()).isEqualTo(nativeNumDocuments);
-        assertThat(iStats.getSchemaTypeCount()).isEqualTo(nativeNumSchemaTypes);
+        assertThat(iStats.getNativeDocumentStoreDataStatus())
+                .isEqualTo(nativeDocumentStoreDataStatus);
+        assertThat(iStats.getNativeDocumentCount()).isEqualTo(nativeNumDocuments);
+        assertThat(iStats.getNativeSchemaTypeCount()).isEqualTo(nativeNumSchemaTypes);
         assertThat(iStats.hasReset()).isTrue();
         assertThat(iStats.getResetStatusCode()).isEqualTo(AppSearchResult.RESULT_INVALID_SCHEMA);
         assertThat(iStats.getEnabledFeatures()).isEqualTo(enabledFeatures);
+        assertThat(iStats.getNativeNumPreviousInitFailures()).isEqualTo(numPreviousInitFailures);
+        assertThat(iStats.getNativeIntegerIndexRestorationCause())
+                .isEqualTo(integerIndexRestorationCause);
+        assertThat(iStats.getNativeQualifiedIdJoinIndexRestorationCause())
+                .isEqualTo(qualifiedIdJoinIndexRestorationCause);
+        assertThat(iStats.getNativeEmbeddingIndexRestorationCause())
+                .isEqualTo(embeddingIndexRestorationCause);
+        assertThat(iStats.getNativeInitializeIcuDataStatusCode())
+                .isEqualTo(initializeIcuDataStatusCode);
+        assertThat(iStats.getNativeNumFailedReindexedDocuments())
+                .isEqualTo(numFailedReindexedDocuments);
     }
 
     @Test
     public void testAppSearchStats_SearchStats() {
-        int rewriteSearchSpecLatencyMillis = 1;
-        int rewriteSearchResultLatencyMillis = 2;
-        int javaLockAcquisitionLatencyMillis = 3;
-        int aclCheckLatencyMillis = 4;
-        int visibilityScope = SearchStats.VISIBILITY_SCOPE_LOCAL;
-        int nativeLatencyMillis = 6;
-        int nativeNumTerms = 7;
-        int nativeQueryLength = 8;
-        int nativeNumNamespacesFiltered = 9;
-        int nativeNumSchemaTypesFiltered = 10;
-        int nativeRequestedPageSize = 11;
-        int nativeNumResultsReturnedCurrentPage = 12;
-        boolean nativeIsFirstPage = true;
-        int nativeParseQueryLatencyMillis = 13;
-        int nativeRankingStrategy = 14;
-        int nativeNumDocumentsScored = 15;
-        int nativeScoringLatencyMillis = 16;
-        int nativeRankingLatencyMillis = 17;
-        int nativeNumResultsSnippeted = 18;
-        int nativeDocumentRetrievingLatencyMillis = 19;
-        int nativeLockAcquisitionLatencyMillis = 20;
-        int javaToNativeJniLatencyMillis = 21;
-        int nativeToJavaJniLatencyMillis = 22;
-        String searchSourceLogTag = "tag";
-        int enabledFeatures = 1;
+        int nativeQueryLength = 1;
+        int nativeNumTerms = 2;
+        int nativeNumNamespacesFiltered = 3;
+        int nativeNumSchemaTypesFiltered = 4;
+        int nativeRankingStrategy = 5;
+        int nativeNumDocumentsScored = 6;
+        int nativeParseQueryLatencyMillis = 7;
+        int nativeScoringLatencyMillis = 8;
+        boolean isNumericQuery = true;
+        int numFetchedHitsLiteIndex = 9;
+        int numFetchedHitsMainIndex = 10;
+        int numFetchedHitsIntegerIndex = 11;
+        int queryProcessorLexerExtractTokenLatencyMillis = 12;
+        int queryProcessorParserConsumeQueryLatencyMillis = 13;
+        int queryProcessorQueryVisitorLatencyMillis = 14;
+
         final SearchStats.Builder sStatsBuilder =
-                new SearchStats.Builder(visibilityScope, TEST_PACKAGE_NAME)
+                new SearchStats.Builder()
+                        .setNativeQueryLength(nativeQueryLength)
+                        .setNativeTermCount(nativeNumTerms)
+                        .setNativeFilteredNamespaceCount(nativeNumNamespacesFiltered)
+                        .setNativeFilteredSchemaTypeCount(nativeNumSchemaTypesFiltered)
+                        .setNativeParseQueryLatencyMillis(nativeParseQueryLatencyMillis)
+                        .setNativeRankingStrategy(nativeRankingStrategy)
+                        .setNativeQueryProcessorParserConsumeQueryLatencyMillis(
+                                nativeParseQueryLatencyMillis)
+                        .setNativeScoredDocumentCount(nativeNumDocumentsScored)
+                        .setNativeScoringLatencyMillis(nativeScoringLatencyMillis)
+                        .setNativeIsNumericQuery(isNumericQuery)
+                        .setNativeNumFetchedHitsLiteIndex(numFetchedHitsLiteIndex)
+                        .setNativeNumFetchedHitsMainIndex(numFetchedHitsMainIndex)
+                        .setNativeNumFetchedHitsIntegerIndex(numFetchedHitsIntegerIndex)
+                        .setNativeQueryProcessorLexerExtractTokenLatencyMillis(
+                                queryProcessorLexerExtractTokenLatencyMillis)
+                        .setNativeQueryProcessorParserConsumeQueryLatencyMillis(
+                                queryProcessorParserConsumeQueryLatencyMillis)
+                        .setNativeQueryProcessorQueryVisitorLatencyMillis(
+                                queryProcessorQueryVisitorLatencyMillis);
+        final SearchStats sStats = sStatsBuilder.build();
+
+        assertThat(sStats.getNativeQueryLength()).isEqualTo(nativeQueryLength);
+        assertThat(sStats.getNativeTermCount()).isEqualTo(nativeNumTerms);
+        assertThat(sStats.getNativeFilteredNamespaceCount()).isEqualTo(nativeNumNamespacesFiltered);
+        assertThat(sStats.getNativeFilteredSchemaTypeCount())
+                .isEqualTo(nativeNumSchemaTypesFiltered);
+        assertThat(sStats.getNativeRankingStrategy()).isEqualTo(nativeRankingStrategy);
+        assertThat(sStats.getNativeParseQueryLatencyMillis())
+                .isEqualTo(nativeParseQueryLatencyMillis);
+        assertThat(sStats.getNativeScoredDocumentCount()).isEqualTo(nativeNumDocumentsScored);
+        assertThat(sStats.getNativeScoringLatencyMillis()).isEqualTo(nativeScoringLatencyMillis);
+        assertThat(sStats.isNativeNumericQuery()).isEqualTo(isNumericQuery);
+        assertThat(sStats.getNativeNumFetchedHitsLiteIndex()).isEqualTo(numFetchedHitsLiteIndex);
+        assertThat(sStats.getNativeNumFetchedHitsMainIndex()).isEqualTo(numFetchedHitsMainIndex);
+        assertThat(sStats.getNativeNumFetchedHitsIntegerIndex())
+                .isEqualTo(numFetchedHitsIntegerIndex);
+        assertThat(sStats.getNativeQueryProcessorLexerExtractTokenLatencyMillis())
+                .isEqualTo(queryProcessorLexerExtractTokenLatencyMillis);
+        assertThat(sStats.getNativeQueryProcessorParserConsumeQueryLatencyMillis())
+                .isEqualTo(queryProcessorParserConsumeQueryLatencyMillis);
+        assertThat(sStats.getNativeQueryProcessorQueryVisitorLatencyMillis())
+                .isEqualTo(queryProcessorQueryVisitorLatencyMillis);
+        String expectedString =
+                "SearchStats {\n"
+                        + "query_length=1, num_terms=2, num_namespaces_filtered=3, "
+                        + "num_schema_types_filtered=4,\n"
+                        + "ranking_strategy=5, num_docs_scored=6, parse_query_latency=7, "
+                        + "scoring_latency=8, is_numeric_query=true,\n"
+                        + "num_fetched_hits_lite_index=9, num_fetched_hits_main_index=10, "
+                        + "num_fetched_hits_integer_index=11,\n"
+                        + "query_processor_lexer_extract_token_latency=12, "
+                        + "query_processor_parser_consume_query_latency=13,\n"
+                        + "query_processor_query_visitor_latency=14}";
+        assertThat(sStats.toString()).isEqualTo(expectedString);
+    }
+
+    @Test
+    public void testAppSearchStats_QueryStats() {
+        int nativeQueryLength = 101;
+        int nativeNumTerms = 102;
+        int nativeNumNamespacesFiltered = 103;
+        int nativeNumSchemaTypesFiltered = 104;
+        int nativeRankingStrategy = 105;
+        int nativeNumDocumentsScored = 106;
+        int nativeParseQueryLatencyMillis = 107;
+        int nativeScoringLatencyMillis = 108;
+        boolean isNumericQuery = true;
+        int numFetchedHitsLiteIndex = 109;
+        int numFetchedHitsMainIndex = 110;
+        int numFetchedHitsIntegerIndex = 111;
+        int queryProcessorLexerExtractTokenLatencyMillis = 112;
+        int queryProcessorParserConsumeQueryLatencyMillis = 113;
+        int queryProcessorQueryVisitorLatencyMillis = 114;
+
+        SearchStats searchStats =
+                new SearchStats.Builder()
+                        .setNativeQueryLength(nativeQueryLength)
+                        .setNativeTermCount(nativeNumTerms)
+                        .setNativeFilteredNamespaceCount(nativeNumNamespacesFiltered)
+                        .setNativeFilteredSchemaTypeCount(nativeNumSchemaTypesFiltered)
+                        .setNativeParseQueryLatencyMillis(nativeParseQueryLatencyMillis)
+                        .setNativeRankingStrategy(nativeRankingStrategy)
+                        .setNativeQueryProcessorParserConsumeQueryLatencyMillis(
+                                nativeParseQueryLatencyMillis)
+                        .setNativeScoredDocumentCount(nativeNumDocumentsScored)
+                        .setNativeScoringLatencyMillis(nativeScoringLatencyMillis)
+                        .setNativeIsNumericQuery(isNumericQuery)
+                        .setNativeNumFetchedHitsLiteIndex(numFetchedHitsLiteIndex)
+                        .setNativeNumFetchedHitsMainIndex(numFetchedHitsMainIndex)
+                        .setNativeNumFetchedHitsIntegerIndex(numFetchedHitsIntegerIndex)
+                        .setNativeQueryProcessorLexerExtractTokenLatencyMillis(
+                                queryProcessorLexerExtractTokenLatencyMillis)
+                        .setNativeQueryProcessorParserConsumeQueryLatencyMillis(
+                                queryProcessorParserConsumeQueryLatencyMillis)
+                        .setNativeQueryProcessorQueryVisitorLatencyMillis(
+                                queryProcessorQueryVisitorLatencyMillis)
+                        .build();
+
+        int enabledFeatures = 1;
+        int rewriteSearchSpecLatencyMillis = 202;
+        int rewriteSearchResultLatencyMillis = 203;
+        int javaLockAcquisitionLatencyMillis = 204;
+        int aclCheckLatencyMillis = 205;
+        int visibilityScope = QueryStats.VISIBILITY_SCOPE_LOCAL;
+        String searchSourceLogTag = "tag";
+        boolean nativeIsFirstPage = true;
+        int nativeRequestedPageSize = 206;
+        int nativeNumResultsReturnedCurrentPage = 207;
+        int nativeLatencyMillis = 208;
+        int nativeRankingLatencyMillis = 209;
+        int nativeDocumentRetrievingLatencyMillis = 210;
+        int nativeNumResultsSnippeted = 211;
+        int nativeLockAcquisitionLatencyMillis = 212;
+        int javaToNativeJniLatencyMillis = 213;
+        int nativeToJavaJniLatencyMillis = 214;
+        long liteIndexHitBufferByteSize = 215;
+        long liteIndexHitBufferUnsortedByteSize = 216;
+        int pageTypeToken = QueryStats.PAGE_TOKEN_TYPE_EMPTY;
+        int numResultStatesEvicted = 217;
+        int additionalPageCount = 218;
+        int numResultsReturnedAdditionalPages = 219;
+        int additionalPagesRetrievalLatency = 220;
+
+        final QueryStats.Builder sStatsBuilder =
+                new QueryStats.Builder(visibilityScope, TEST_PACKAGE_NAME)
                         .setDatabase(TEST_DATA_BASE)
                         .setStatusCode(TEST_STATUS_CODE)
+                        .setLaunchVMEnabled(true)
                         .setTotalLatencyMillis(TEST_TOTAL_LATENCY_MILLIS)
                         .setRewriteSearchSpecLatencyMillis(rewriteSearchSpecLatencyMillis)
                         .setRewriteSearchResultLatencyMillis(rewriteSearchResultLatencyMillis)
                         .setJavaLockAcquisitionLatencyMillis(javaLockAcquisitionLatencyMillis)
                         .setAclCheckLatencyMillis(aclCheckLatencyMillis)
-                        .setNativeLatencyMillis(nativeLatencyMillis)
-                        .setTermCount(nativeNumTerms)
-                        .setQueryLength(nativeQueryLength)
-                        .setFilteredNamespaceCount(nativeNumNamespacesFiltered)
-                        .setFilteredSchemaTypeCount(nativeNumSchemaTypesFiltered)
+                        .setSearchSourceLogTag(searchSourceLogTag)
+                        .setIsFirstPage(nativeIsFirstPage)
                         .setRequestedPageSize(nativeRequestedPageSize)
                         .setCurrentPageReturnedResultCount(nativeNumResultsReturnedCurrentPage)
-                        .setIsFirstPage(nativeIsFirstPage)
-                        .setParseQueryLatencyMillis(nativeParseQueryLatencyMillis)
-                        .setRankingStrategy(nativeRankingStrategy)
-                        .setScoredDocumentCount(nativeNumDocumentsScored)
-                        .setScoringLatencyMillis(nativeScoringLatencyMillis)
+                        .setNativeLatencyMillis(nativeLatencyMillis)
                         .setRankingLatencyMillis(nativeRankingLatencyMillis)
-                        .setResultWithSnippetsCount(nativeNumResultsSnippeted)
                         .setDocumentRetrievingLatencyMillis(nativeDocumentRetrievingLatencyMillis)
+                        .setResultWithSnippetsCount(nativeNumResultsSnippeted)
                         .setNativeLockAcquisitionLatencyMillis(nativeLockAcquisitionLatencyMillis)
                         .setJavaToNativeJniLatencyMillis(javaToNativeJniLatencyMillis)
                         .setNativeToJavaJniLatencyMillis(nativeToJavaJniLatencyMillis)
-                        .setSearchSourceLogTag(searchSourceLogTag)
-                        .setLaunchVMEnabled(true);
-        final SearchStats sStats = sStatsBuilder.build();
+                        .setChildSearchStats(searchStats)
+                        .setParentSearchStats(searchStats)
+                        .setLiteIndexHitBufferByteSize(liteIndexHitBufferByteSize)
+                        .setLiteIndexHitBufferUnsortedByteSize(liteIndexHitBufferUnsortedByteSize)
+                        .setPageTokenType(pageTypeToken)
+                        .setNumResultStatsEvicted(numResultStatesEvicted)
+                        .setAdditionalPageCount(additionalPageCount)
+                        .setAdditionalPagesReturnedResultCount(numResultsReturnedAdditionalPages)
+                        .setAdditionalPageRetrievalLatencyMillis(additionalPagesRetrievalLatency);
+        final QueryStats sStats = sStatsBuilder.build();
 
+        assertThat(sStats.getEnabledFeatures()).isEqualTo(enabledFeatures);
         assertThat(sStats.getPackageName()).isEqualTo(TEST_PACKAGE_NAME);
         assertThat(sStats.getDatabase()).isEqualTo(TEST_DATA_BASE);
         assertThat(sStats.getStatusCode()).isEqualTo(TEST_STATUS_CODE);
@@ -292,19 +446,12 @@ public class AppSearchStatsTest {
                 .isEqualTo(javaLockAcquisitionLatencyMillis);
         assertThat(sStats.getAclCheckLatencyMillis()).isEqualTo(aclCheckLatencyMillis);
         assertThat(sStats.getVisibilityScope()).isEqualTo(visibilityScope);
-        assertThat(sStats.getNativeLatencyMillis()).isEqualTo(nativeLatencyMillis);
-        assertThat(sStats.getTermCount()).isEqualTo(nativeNumTerms);
-        assertThat(sStats.getQueryLength()).isEqualTo(nativeQueryLength);
-        assertThat(sStats.getFilteredNamespaceCount()).isEqualTo(nativeNumNamespacesFiltered);
-        assertThat(sStats.getFilteredSchemaTypeCount()).isEqualTo(nativeNumSchemaTypesFiltered);
+        assertThat(sStats.getSearchSourceLogTag()).isEqualTo(searchSourceLogTag);
+        assertThat(sStats.isFirstPage()).isTrue();
         assertThat(sStats.getRequestedPageSize()).isEqualTo(nativeRequestedPageSize);
         assertThat(sStats.getCurrentPageReturnedResultCount())
                 .isEqualTo(nativeNumResultsReturnedCurrentPage);
-        assertThat(sStats.isFirstPage()).isTrue();
-        assertThat(sStats.getParseQueryLatencyMillis()).isEqualTo(nativeParseQueryLatencyMillis);
-        assertThat(sStats.getRankingStrategy()).isEqualTo(nativeRankingStrategy);
-        assertThat(sStats.getScoredDocumentCount()).isEqualTo(nativeNumDocumentsScored);
-        assertThat(sStats.getScoringLatencyMillis()).isEqualTo(nativeScoringLatencyMillis);
+        assertThat(sStats.getNativeLatencyMillis()).isEqualTo(nativeLatencyMillis);
         assertThat(sStats.getRankingLatencyMillis()).isEqualTo(nativeRankingLatencyMillis);
         assertThat(sStats.getResultWithSnippetsCount()).isEqualTo(nativeNumResultsSnippeted);
         assertThat(sStats.getDocumentRetrievingLatencyMillis())
@@ -315,8 +462,55 @@ public class AppSearchStatsTest {
                 .isEqualTo(javaToNativeJniLatencyMillis);
         assertThat(sStats.getNativeToJavaJniLatencyMillis())
                 .isEqualTo(nativeToJavaJniLatencyMillis);
-        assertThat(sStats.getSearchSourceLogTag()).isEqualTo(searchSourceLogTag);
-        assertThat(sStats.getEnabledFeatures()).isEqualTo(enabledFeatures);
+        assertThat(sStats.getParentSearchStats()).isEqualTo(searchStats);
+        assertThat(sStats.getChildSearchStats()).isEqualTo(searchStats);
+        assertThat(sStats.getLiteIndexHitBufferByteSize()).isEqualTo(liteIndexHitBufferByteSize);
+        assertThat(sStats.getLiteIndexHitBufferUnsortedByteSize())
+                .isEqualTo(liteIndexHitBufferUnsortedByteSize);
+        assertThat(sStats.getPageTokenType()).isEqualTo(pageTypeToken);
+        assertThat(sStats.getNumResultStatesEvicted()).isEqualTo(numResultStatesEvicted);
+        assertThat(sStats.getAdditionalPageCount()).isEqualTo(additionalPageCount);
+        assertThat(sStats.getAdditionalPagesReturnedResultCount())
+                .isEqualTo(numResultsReturnedAdditionalPages);
+        assertThat(sStats.getAdditionalPageRetrievalLatencyMillis())
+                .isEqualTo(additionalPagesRetrievalLatency);
+        String expectedString =
+                "QueryStats {\n"
+                    + "package=com.google.test, database=testDataBase, status=2, total_latency=20,"
+                    + " rewrite_search_spec_latency=202,\n"
+                    + "rewrite_search_result_latency=203, java_lock_acquisition_latency=204,"
+                    + " acl_check_latency=205, visibility_score=1,\n"
+                    + "search_source_log_tag=tag, is_first_page=true, requested_page_size=206,"
+                    + " num_results_returned_current_page=207,\n"
+                    + "native_latency=208, ranking_latency=209, document_retrieving_latency=210,"
+                    + " num_results_with_snippets=211,\n"
+                    + "native_lock_acquisition_latency=212, java_to_native_jni_latency=213,"
+                    + " native_to_java_jni_latency=214,\n"
+                    + "join_latency_ms=0, num_joined_results_current_page=0, join_type=0,"
+                    + " lite_index_hit_buffer_byte_size=215,\n"
+                    + "lite_index_hit_buffer_unsorted_byte_size=216\n"
+                    + "page_token_type=3, num_result_states_evicted=217\n"
+                    + "parent_search_stats=SearchStats {\n"
+                    + "query_length=101, num_terms=102, num_namespaces_filtered=103,"
+                    + " num_schema_types_filtered=104,\n"
+                    + "ranking_strategy=105, num_docs_scored=106, parse_query_latency=107,"
+                    + " scoring_latency=108, is_numeric_query=true,\n"
+                    + "num_fetched_hits_lite_index=109, num_fetched_hits_main_index=110,"
+                    + " num_fetched_hits_integer_index=111,\n"
+                    + "query_processor_lexer_extract_token_latency=112,"
+                    + " query_processor_parser_consume_query_latency=113,\n"
+                    + "query_processor_query_visitor_latency=114},\n"
+                    + " child_search_stats=SearchStats {\n"
+                    + "query_length=101, num_terms=102, num_namespaces_filtered=103,"
+                    + " num_schema_types_filtered=104,\n"
+                    + "ranking_strategy=105, num_docs_scored=106, parse_query_latency=107,"
+                    + " scoring_latency=108, is_numeric_query=true,\n"
+                    + "num_fetched_hits_lite_index=109, num_fetched_hits_main_index=110,"
+                    + " num_fetched_hits_integer_index=111,\n"
+                    + "query_processor_lexer_extract_token_latency=112,"
+                    + " query_processor_parser_consume_query_latency=113,\n"
+                    + "query_processor_query_visitor_latency=114}}";
+        assertThat(sStats.toString()).isEqualTo(expectedString);
     }
 
     @Test
@@ -460,6 +654,12 @@ public class AppSearchStatsTest {
         @RemoveStats.DeleteType int deleteType = 2;
         int documentDeletedCount = 3;
         int enabledFeatures = 1;
+        int queryLength = 4;
+        int numTerms = 5;
+        int numNamespacesFiltered = 6;
+        int numSchemaTypesFiltered = 7;
+        int parseQueryLatencyMillis = 8;
+        int documentRemovalLatencyMillis = 9;
 
         final RemoveStats rStats =
                 new RemoveStats.Builder(TEST_PACKAGE_NAME, TEST_DATA_BASE)
@@ -469,6 +669,12 @@ public class AppSearchStatsTest {
                         .setDeleteType(deleteType)
                         .setDeletedDocumentCount(documentDeletedCount)
                         .setLaunchVMEnabled(true)
+                        .setQueryLength(queryLength)
+                        .setNumTerms(numTerms)
+                        .setNumNamespacesFiltered(numNamespacesFiltered)
+                        .setNumSchemaTypesFiltered(numSchemaTypesFiltered)
+                        .setParseQueryLatencyMillis(parseQueryLatencyMillis)
+                        .setDocumentRemovalLatencyMillis(documentRemovalLatencyMillis)
                         .build();
 
         assertThat(rStats.getPackageName()).isEqualTo(TEST_PACKAGE_NAME);
@@ -479,6 +685,13 @@ public class AppSearchStatsTest {
         assertThat(rStats.getDeleteType()).isEqualTo(deleteType);
         assertThat(rStats.getDeletedDocumentCount()).isEqualTo(documentDeletedCount);
         assertThat(rStats.getEnabledFeatures()).isEqualTo(enabledFeatures);
+        assertThat(rStats.getQueryLength()).isEqualTo(queryLength);
+        assertThat(rStats.getNumTerms()).isEqualTo(numTerms);
+        assertThat(rStats.getNumNamespacesFiltered()).isEqualTo(numNamespacesFiltered);
+        assertThat(rStats.getNumSchemaTypesFiltered()).isEqualTo(numSchemaTypesFiltered);
+        assertThat(rStats.getParseQueryLatencyMillis()).isEqualTo(parseQueryLatencyMillis);
+        assertThat(rStats.getDocumentRemovalLatencyMillis())
+                .isEqualTo(documentRemovalLatencyMillis);
     }
 
     @Test
@@ -493,6 +706,9 @@ public class AppSearchStatsTest {
         long nativeStorageSizeBeforeBytes = Integer.MAX_VALUE + 1;
         long nativeStorageSizeAfterBytes = Integer.MAX_VALUE + 2;
         long nativeTimeSinceLastOptimizeMillis = Integer.MAX_VALUE + 3;
+        int indexRestorationMode = 1;
+        int numOriginalNamespaces = 7;
+        int numDeletedNamespaces = 8;
 
         final OptimizeStats oStats =
                 new OptimizeStats.Builder()
@@ -509,6 +725,9 @@ public class AppSearchStatsTest {
                         .setStorageSizeAfterBytes(nativeStorageSizeAfterBytes)
                         .setTimeSinceLastOptimizeMillis(nativeTimeSinceLastOptimizeMillis)
                         .setLaunchVMEnabled(true)
+                        .setIndexRestorationMode(indexRestorationMode)
+                        .setNumOriginalNamespaces(numOriginalNamespaces)
+                        .setNumDeletedNamespaces(numDeletedNamespaces)
                         .build();
 
         assertThat(oStats.getStatusCode()).isEqualTo(TEST_STATUS_CODE);
@@ -527,5 +746,8 @@ public class AppSearchStatsTest {
         assertThat(oStats.getTimeSinceLastOptimizeMillis())
                 .isEqualTo(nativeTimeSinceLastOptimizeMillis);
         assertThat(oStats.getEnabledFeatures()).isEqualTo(enabledFeatures);
+        assertThat(oStats.getIndexRestorationMode()).isEqualTo(indexRestorationMode);
+        assertThat(oStats.getNumOriginalNamespaces()).isEqualTo(numOriginalNamespaces);
+        assertThat(oStats.getNumDeletedNamespaces()).isEqualTo(numDeletedNamespaces);
     }
 }
diff --git a/testing/servicestests/src/com/android/server/appsearch/visibilitystore/VisibilityCheckerImplTest.java b/testing/servicestests/src/com/android/server/appsearch/visibilitystore/VisibilityCheckerImplTest.java
index 5d57e228..4028d696 100644
--- a/testing/servicestests/src/com/android/server/appsearch/visibilitystore/VisibilityCheckerImplTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/visibilitystore/VisibilityCheckerImplTest.java
@@ -41,6 +41,7 @@ import android.annotation.NonNull;
 import android.app.UiAutomation;
 import android.app.appsearch.InternalVisibilityConfig;
 import android.app.appsearch.PackageIdentifier;
+import android.app.appsearch.SchemaVisibilityConfig;
 import android.app.appsearch.SetSchemaRequest;
 import android.app.appsearch.aidl.AppSearchAttributionSource;
 import android.app.appsearch.testutil.AppSearchTestUtils;
@@ -1146,6 +1147,295 @@ public class VisibilityCheckerImplTest {
         }
     }
 
+    @Test
+    public void testSetSchema_visibleToConfig_needMatchAllSettings() throws Exception {
+        // Values for a "foo" client
+        String packageNameFoo = "packageFoo";
+        byte[] sha256CertFoo = new byte[] {10};
+
+        PackageManager mockPackageManager = getMockPackageManager(mContext.getUser());
+        when(mockPackageManager.getPackageUid(eq(packageNameFoo), /* flags= */ anyInt()))
+                .thenReturn(mAttributionSource.getUid());
+
+        String prefix = PrefixUtil.createPrefix("package", "database");
+
+        // Create a VDoc which requires both READ_SMS and access to packageFoo
+        SchemaVisibilityConfig visibleToConfig =
+                new SchemaVisibilityConfig.Builder().addAllowedPackage(
+                                new PackageIdentifier(packageNameFoo, sha256CertFoo))
+                        .addRequiredPermissions(ImmutableSet.of(
+                                SetSchemaRequest.READ_SMS)).build();
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder(/* id= */ prefix + "Schema")
+                        .addVisibleToConfig(visibleToConfig)
+                        .build();
+        mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig));
+
+        mUiAutomation.adoptShellPermissionIdentity(READ_SMS);
+        try {
+            // Only has READ_SMS won't have access.
+            when(mockPackageManager.hasSigningCertificate(
+                    packageNameFoo, sha256CertFoo, PackageManager.CERT_INPUT_SHA256))
+                    .thenReturn(false);
+            assertThat(
+                    mVisibilityChecker.isSchemaSearchableByCaller(
+                            new FrameworkCallerAccess(
+                                    mAttributionSource,
+                                    /* callerHasSystemAccess= */ false,
+                                    /* isForEnterprise= */ false),
+                            "package",
+                            prefix + "Schema",
+                            mVisibilityStore))
+                    .isFalse();
+        } finally {
+            mUiAutomation.dropShellPermissionIdentity();
+        }
+
+        // Only has access to packageFoo won't have access
+        when(mockPackageManager.hasSigningCertificate(
+                packageNameFoo, sha256CertFoo, PackageManager.CERT_INPUT_SHA256))
+                .thenReturn(true);
+        assertThat(
+                mVisibilityChecker.isSchemaSearchableByCaller(
+                        new FrameworkCallerAccess(
+                                mAttributionSource,
+                                /* callerHasSystemAccess= */ false,
+                                /* isForEnterprise= */ false),
+                        "package",
+                        prefix + "Schema",
+                        mVisibilityStore))
+                .isFalse();
+
+        mUiAutomation.adoptShellPermissionIdentity(READ_SMS);
+        try {
+            // has both READ_SMS and access to packageFoo will have access.
+            when(mockPackageManager.hasSigningCertificate(
+                    packageNameFoo, sha256CertFoo, PackageManager.CERT_INPUT_SHA256))
+                    .thenReturn(true);
+            assertThat(
+                    mVisibilityChecker.isSchemaSearchableByCaller(
+                            new FrameworkCallerAccess(
+                                    mAttributionSource,
+                                    /* callerHasSystemAccess= */ false,
+                                    /* isForEnterprise= */ false),
+                            "package",
+                            prefix + "Schema",
+                            mVisibilityStore))
+                    .isTrue();
+        } finally {
+            mUiAutomation.dropShellPermissionIdentity();
+        }
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_ENTERPRISE_VISIBLE_TO_CONFIG)
+    public void testSetSchema_enterpriseVisibleToConfig_withEnterpriseAccessPermission()
+            throws Exception {
+        // Values for a "foo" client
+        String packageNameFoo = "packageFoo";
+        byte[] sha256CertFoo = new byte[] {10};
+
+        PackageManager mockPackageManager = getMockPackageManager(mContext.getUser());
+        when(mockPackageManager.getPackageUid(eq(packageNameFoo), /* flags= */ anyInt()))
+                .thenReturn(mAttributionSource.getUid());
+
+        String prefix = PrefixUtil.createPrefix("package", "database");
+
+        // Create a VDoc which requires both ENTERPRISE_ACCESS and access to packageFoo
+        SchemaVisibilityConfig visibleToConfig =
+                new SchemaVisibilityConfig.Builder().addAllowedPackage(
+                        new PackageIdentifier(packageNameFoo,
+                                sha256CertFoo)).addRequiredPermissions(
+                        ImmutableSet.of(ENTERPRISE_ACCESS)).build();
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder(/* id= */ prefix + "Schema")
+                        .addVisibleToConfig(visibleToConfig)
+                        .build();
+        mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig));
+
+        // Only enterprise call won't have access.
+        when(mockPackageManager.hasSigningCertificate(
+                packageNameFoo, sha256CertFoo, PackageManager.CERT_INPUT_SHA256))
+                .thenReturn(false);
+        assertThat(
+                mVisibilityChecker.isSchemaSearchableByCaller(
+                        new FrameworkCallerAccess(
+                                mAttributionSource,
+                                /* callerHasSystemAccess= */ false,
+                                /* isForEnterprise= */ true),
+                        "package",
+                        prefix + "Schema",
+                        mVisibilityStore))
+                .isFalse();
+
+        // Only has access to packageFoo won't have access
+        when(mockPackageManager.hasSigningCertificate(
+                packageNameFoo, sha256CertFoo, PackageManager.CERT_INPUT_SHA256))
+                .thenReturn(true);
+        assertThat(
+                mVisibilityChecker.isSchemaSearchableByCaller(
+                        new FrameworkCallerAccess(
+                                mAttributionSource,
+                                /* callerHasSystemAccess= */ false,
+                                /* isForEnterprise= */ false),
+                        "package",
+                        prefix + "Schema",
+                        mVisibilityStore))
+                .isFalse();
+
+        // both enterprise call and has access to packageFoo will have access.
+        when(mockPackageManager.hasSigningCertificate(
+                packageNameFoo, sha256CertFoo, PackageManager.CERT_INPUT_SHA256))
+                .thenReturn(true);
+        assertThat(
+                mVisibilityChecker.isSchemaSearchableByCaller(
+                        new FrameworkCallerAccess(
+                                mAttributionSource,
+                                /* callerHasSystemAccess= */ false,
+                                /* isForEnterprise= */ true),
+                        "package",
+                        prefix + "Schema",
+                        mVisibilityStore))
+                .isTrue();
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_ENTERPRISE_VISIBLE_TO_CONFIG)
+    public void testSetSchema_enterpriseVisibleToConfig_enterpriseAccessAndAdditionalPermissionSet()
+            throws Exception {
+        // Values for a "foo" client
+        String packageNameFoo = "packageFoo";
+        byte[] sha256CertFoo = new byte[] {10};
+
+        PackageManager mockPackageManager = getMockPackageManager(mContext.getUser());
+        when(mockPackageManager.getPackageUid(eq(packageNameFoo), /* flags= */ anyInt()))
+                .thenReturn(mAttributionSource.getUid());
+
+        String prefix = PrefixUtil.createPrefix("package", "database");
+
+        // Create a VDoc which requires both ENTERPRISE_ACCESS and access to packageFoo
+        SchemaVisibilityConfig visibleToConfig =
+                new SchemaVisibilityConfig.Builder().addAllowedPackage(
+                        new PackageIdentifier(packageNameFoo,
+                                sha256CertFoo)).addRequiredPermissions(
+                        ImmutableSet.of(ENTERPRISE_ACCESS)).addRequiredPermissions(
+                        ImmutableSet.of(SetSchemaRequest.READ_SMS)).build();
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder(/* id= */ prefix + "Schema")
+                        .addVisibleToConfig(visibleToConfig)
+                        .build();
+        mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig));
+
+        // Satisfy one permission set
+        mUiAutomation.adoptShellPermissionIdentity(READ_SMS);
+        try {
+            // Enterprise call but no access to packageFoo won't have access.
+            when(mockPackageManager.hasSigningCertificate(
+                    packageNameFoo, sha256CertFoo, PackageManager.CERT_INPUT_SHA256))
+                    .thenReturn(false);
+            assertThat(
+                    mVisibilityChecker.isSchemaSearchableByCaller(
+                            new FrameworkCallerAccess(
+                                    mAttributionSource,
+                                    /* callerHasSystemAccess= */ false,
+                                    /* isForEnterprise= */ true),
+                            "package",
+                            prefix + "Schema",
+                            mVisibilityStore))
+                    .isFalse();
+
+            // has READ_SMS and access to packageFoo will have access.
+            when(mockPackageManager.hasSigningCertificate(
+                    packageNameFoo, sha256CertFoo, PackageManager.CERT_INPUT_SHA256))
+                    .thenReturn(true);
+            assertThat(
+                    mVisibilityChecker.isSchemaSearchableByCaller(
+                            new FrameworkCallerAccess(
+                                    mAttributionSource,
+                                    /* callerHasSystemAccess= */ false,
+                                    /* isForEnterprise= */ false),
+                            "package",
+                            prefix + "Schema",
+                            mVisibilityStore))
+                    .isTrue();
+
+            // both enterprise call and has access to packageFoo will have access.
+            when(mockPackageManager.hasSigningCertificate(
+                    packageNameFoo, sha256CertFoo, PackageManager.CERT_INPUT_SHA256))
+                    .thenReturn(true);
+            assertThat(
+                    mVisibilityChecker.isSchemaSearchableByCaller(
+                            new FrameworkCallerAccess(
+                                    mAttributionSource,
+                                    /* callerHasSystemAccess= */ false,
+                                    /* isForEnterprise= */ true),
+                            "package",
+                            prefix + "Schema",
+                            mVisibilityStore))
+                    .isTrue();
+        } finally {
+            mUiAutomation.dropShellPermissionIdentity();
+        }
+    }
+
+    @Test
+    public void testSetSchema_enterpriseVisibleToConfig_withoutEnterpriseAccessPermission()
+            throws Exception {
+        // Values for a "foo" client
+        String packageNameFoo = "packageFoo";
+        byte[] sha256CertFoo = new byte[] {10};
+
+        PackageManager mockPackageManager = getMockPackageManager(mContext.getUser());
+        when(mockPackageManager.getPackageUid(eq(packageNameFoo), /* flags= */ anyInt()))
+                .thenReturn(mAttributionSource.getUid());
+        when(mockPackageManager.hasSigningCertificate(
+                packageNameFoo, sha256CertFoo, PackageManager.CERT_INPUT_SHA256))
+                .thenReturn(true);
+
+        String prefix = PrefixUtil.createPrefix("package", "database");
+
+        // Create a VDoc which requires READ_SMS and access to packageFoo
+        SchemaVisibilityConfig visibleToConfig =
+                new SchemaVisibilityConfig.Builder().addAllowedPackage(
+                        new PackageIdentifier(packageNameFoo,
+                                sha256CertFoo)).addRequiredPermissions(
+                        ImmutableSet.of(SetSchemaRequest.READ_SMS)).build();
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder(/* id= */ prefix + "Schema")
+                        .addVisibleToConfig(visibleToConfig)
+                        .build();
+        mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig));
+
+        mUiAutomation.adoptShellPermissionIdentity(READ_SMS);
+        try {
+            // Enterprise call won't have access since no ENTERPRISE_ACCESS permission
+            assertThat(
+                    mVisibilityChecker.isSchemaSearchableByCaller(
+                            new FrameworkCallerAccess(
+                                    mAttributionSource,
+                                    /* callerHasSystemAccess= */ false,
+                                    /* isForEnterprise= */ true),
+                            "package",
+                            prefix + "Schema",
+                            mVisibilityStore))
+                    .isFalse();
+
+            // Normal call will have access
+            assertThat(
+                    mVisibilityChecker.isSchemaSearchableByCaller(
+                            new FrameworkCallerAccess(
+                                    mAttributionSource,
+                                    /* callerHasSystemAccess= */ false,
+                                    /* isForEnterprise= */ false),
+                            "package",
+                            prefix + "Schema",
+                            mVisibilityStore))
+                    .isTrue();
+        } finally {
+            mUiAutomation.dropShellPermissionIdentity();
+        }
+    }
+
     @Test
     public void testPublicVisibility_mockPackageManager() throws Exception {
         byte[] mockSignature = new byte[32];
```

