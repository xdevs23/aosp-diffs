```diff
diff --git a/PREUPLOAD.cfg b/PREUPLOAD.cfg
index c301397593..68cbdc7d02 100644
--- a/PREUPLOAD.cfg
+++ b/PREUPLOAD.cfg
@@ -1,9 +1,11 @@
 [Builtin Hooks]
 bpfmt = true
 clang_format = true
+rustfmt = true
 
 [Builtin Hooks Options]
 clang_format = --commit ${PREUPLOAD_COMMIT} --style file --extensions c,h,cc,cpp,hpp
+rustfmt = --config-path=rustfmt.toml
 
 [Hook Scripts]
 checkstyle_hook = ${REPO_ROOT}/prebuilts/checkstyle/checkstyle.py --sha ${PREUPLOAD_COMMIT}
@@ -11,3 +13,8 @@ checkstyle_hook = ${REPO_ROOT}/prebuilts/checkstyle/checkstyle.py --sha ${PREUPL
 ktlint_hook = ${REPO_ROOT}/prebuilts/ktlint/ktlint.py --disabled-rules comment-wrapping -f ${PREUPLOAD_FILES}
 
 hidden_api_txt_checksorted_hook = ${REPO_ROOT}/tools/platform-compat/hiddenapi/checksorted_sha.sh ${PREUPLOAD_COMMIT} ${REPO_ROOT}
+
+python_hook = ${REPO_ROOT}/packages/modules/Connectivity/preupload_hook_script.py ${PREUPLOAD_FILES}
+
+# go/alint for details
+alint_hook = ${REPO_ROOT}/vendor/google/tools/alint
diff --git a/TEST_MAPPING b/TEST_MAPPING
index 8592af2859..9f8868c3ef 100644
--- a/TEST_MAPPING
+++ b/TEST_MAPPING
@@ -435,6 +435,23 @@
       "name": "CtsNetTestCasesUpdateStatsPermission"
     }
   ],
+  "tv-presubmit": [
+    {
+      "name": "CtsNetTestCases"
+    },
+    {
+      "name": "CtsNativeNetTestCases"
+    },
+    {
+      "name": "CtsNativeNetDnsTestCases"
+    },
+    {
+      "name": "CtsNetTestCasesInternetPermission"
+    },
+    {
+      "name": "CtsNetTestCasesUpdateStatsPermission"
+    }
+  ],
   "imports": [
     {
       "path": "frameworks/base/core/java/android/net"
diff --git a/Tethering/apex/Android.bp b/Tethering/apex/Android.bp
index 531489ddb6..19e2c6f078 100644
--- a/Tethering/apex/Android.bp
+++ b/Tethering/apex/Android.bp
@@ -116,6 +116,10 @@ apex {
     compat_configs: [
         "connectivity-platform-compat-config",
     ],
+    licenses: [
+        "Android-Apache-2.0",
+        "opensourcerequest",
+    ],
 }
 
 apex_key {
@@ -218,3 +222,21 @@ systemserverclasspath_fragment {
     standalone_contents: ["service-connectivity"],
     apex_available: ["com.android.tethering"],
 }
+
+// Extract the version number of the module from the manifest.json, and zip it as a raw resource for
+// usage in android_test "resource_zips" build rules.
+// The manifest.json is updated with new module versions in release branches when versions are cut.
+java_genrule {
+    name: "connectivity-module-version-as-resource-zip",
+    srcs: [
+        "manifest.json",
+    ],
+    out: ["connectivity-module-version-as-resource.zip"],
+    tools: ["soong_zip"],
+
+    cmd: "mkdir -p $(genDir)/res/raw && " +
+        // The manifest has a line with '"version": 361099999'. Grep for the line, then for the int.
+        "grep -Eo '\"version\": *[0-9]+' $(in) | grep -Eo '[0-9]+' > " +
+        "$(genDir)/res/raw/target_module_version && " +
+        "$(location soong_zip) -o $(out) -C $(genDir)/res -D $(genDir)/res",
+}
diff --git a/Tethering/apishim/31/com/android/networkstack/tethering/apishim/api31/BpfCoordinatorShimImpl.java b/Tethering/apishim/31/com/android/networkstack/tethering/apishim/api31/BpfCoordinatorShimImpl.java
index b460f0d0b1..9b6097d094 100644
--- a/Tethering/apishim/31/com/android/networkstack/tethering/apishim/api31/BpfCoordinatorShimImpl.java
+++ b/Tethering/apishim/31/com/android/networkstack/tethering/apishim/api31/BpfCoordinatorShimImpl.java
@@ -19,7 +19,7 @@ package com.android.networkstack.tethering.apishim.api31;
 import static android.net.netstats.provider.NetworkStatsProvider.QUOTA_UNLIMITED;
 
 import static com.android.net.module.util.NetworkStackConstants.RFC7421_PREFIX_LENGTH;
-import static com.android.networkstack.tethering.TetheringConfiguration.TETHER_ACTIVE_SESSIONS_METRICS;
+import static com.android.networkstack.tethering.TetheringFeatureFlags.TETHER_ACTIVE_SESSIONS_METRICS;
 
 import android.system.ErrnoException;
 import android.system.Os;
diff --git a/Tethering/src/android/net/ip/IpServer.java b/Tethering/src/android/net/ip/IpServer.java
index a651b1b198..e8796b9647 100644
--- a/Tethering/src/android/net/ip/IpServer.java
+++ b/Tethering/src/android/net/ip/IpServer.java
@@ -41,8 +41,9 @@ import static android.system.OsConstants.RT_SCOPE_UNIVERSE;
 
 import static com.android.net.module.util.Inet4AddressUtils.intToInet4AddressHTH;
 import static com.android.net.module.util.NetworkStackConstants.RFC7421_PREFIX_LENGTH;
-import static com.android.networkstack.tethering.TetheringConfiguration.TETHERING_LOCAL_NETWORK_AGENT;
 import static com.android.networkstack.tethering.TetheringConfiguration.USE_SYNC_SM;
+import static com.android.networkstack.tethering.TetheringFeatureFlags.TETHERING_LOCAL_NETWORK_AGENT;
+import static com.android.networkstack.tethering.TetheringFeatureFlags.WIFIP2PGO_LOCAL_NETWORK_AGENT;
 import static com.android.networkstack.tethering.util.PrefixUtils.asIpPrefix;
 import static com.android.networkstack.tethering.util.TetheringMessageBase.BASE_IPSERVER;
 import static com.android.networkstack.tethering.util.TetheringUtils.getTransportTypeForTetherableType;
@@ -334,7 +335,8 @@ public class IpServer extends StateMachineShim {
     private final Handler mHandler;
     private final Context mContext;
 
-    private final boolean mSupportLocalAgent;
+    private final boolean mSupportTetheringLocalAgent;
+    private final boolean mSupportWifiP2pGroupOwnerLocalAgent;
 
     // This will be null if the TetheredState is not entered or feature not supported.
     // This will be only accessed from the IpServer handler thread.
@@ -380,8 +382,10 @@ public class IpServer extends StateMachineShim {
         mServingMode = STATE_AVAILABLE;
 
         // Tethering network agent is supported on V+, and will be rolled out gradually.
-        mSupportLocalAgent = SdkLevel.isAtLeastV()
+        mSupportTetheringLocalAgent = SdkLevel.isAtLeastV()
                 && mDeps.isFeatureEnabled(mContext, TETHERING_LOCAL_NETWORK_AGENT);
+        mSupportWifiP2pGroupOwnerLocalAgent = mSupportTetheringLocalAgent
+                && mDeps.isFeatureEnabled(mContext, WIFIP2PGO_LOCAL_NETWORK_AGENT);
 
         mInitialState = new InitialState();
         mLocalHotspotState = new LocalHotspotState();
@@ -1162,9 +1166,8 @@ public class IpServer extends StateMachineShim {
 
         @SuppressLint("NewApi")
         private void startServingInterface() {
-            // TODO: Enable Network Agent for Wifi P2P Group Owner mode when Network Agent
-            //  for Group Client mode is supported.
-            if (mSupportLocalAgent && getScope() == CONNECTIVITY_SCOPE_GLOBAL) {
+            if (mSupportTetheringLocalAgent && (mSupportWifiP2pGroupOwnerLocalAgent
+                    || getScope() != CONNECTIVITY_SCOPE_LOCAL)) {
                 try {
                     mTetheringAgent = mDeps.makeNetworkAgent(mContext, Looper.myLooper(), TAG,
                             mInterfaceType, mLinkProperties);
diff --git a/Tethering/src/com/android/networkstack/tethering/BpfCoordinator.java b/Tethering/src/com/android/networkstack/tethering/BpfCoordinator.java
index 75ab9eccf3..180791e813 100644
--- a/Tethering/src/com/android/networkstack/tethering/BpfCoordinator.java
+++ b/Tethering/src/com/android/networkstack/tethering/BpfCoordinator.java
@@ -34,7 +34,7 @@ import static com.android.net.module.util.ip.ConntrackMonitor.ConntrackEvent;
 import static com.android.networkstack.tethering.BpfUtils.DOWNSTREAM;
 import static com.android.networkstack.tethering.BpfUtils.UPSTREAM;
 import static com.android.networkstack.tethering.TetheringConfiguration.DEFAULT_TETHER_OFFLOAD_POLL_INTERVAL_MS;
-import static com.android.networkstack.tethering.TetheringConfiguration.TETHER_ACTIVE_SESSIONS_METRICS;
+import static com.android.networkstack.tethering.TetheringFeatureFlags.TETHER_ACTIVE_SESSIONS_METRICS;
 import static com.android.networkstack.tethering.UpstreamNetworkState.isVcnInterface;
 import static com.android.networkstack.tethering.util.TetheringUtils.getTetheringJniLibraryName;
 
diff --git a/Tethering/src/com/android/networkstack/tethering/OffloadHardwareInterface.java b/Tethering/src/com/android/networkstack/tethering/OffloadHardwareInterface.java
index 13a7a22f57..d1cc79dffc 100644
--- a/Tethering/src/com/android/networkstack/tethering/OffloadHardwareInterface.java
+++ b/Tethering/src/com/android/networkstack/tethering/OffloadHardwareInterface.java
@@ -16,7 +16,7 @@
 
 package com.android.networkstack.tethering;
 
-import static com.android.net.module.util.netlink.NetlinkUtils.SOCKET_RECV_BUFSIZE;
+import static com.android.net.module.util.netlink.NetlinkUtils.SOCKET_DUMP_RECV_BUFSIZE;
 import static com.android.net.module.util.netlink.StructNlMsgHdr.NLM_F_DUMP;
 import static com.android.net.module.util.netlink.StructNlMsgHdr.NLM_F_REQUEST;
 
@@ -200,7 +200,7 @@ public class OffloadHardwareInterface {
             final FileDescriptor fd;
             try {
                 fd = NetlinkUtils.netlinkSocketForProto(OsConstants.NETLINK_NETFILTER,
-                        SOCKET_RECV_BUFSIZE);
+                        SOCKET_DUMP_RECV_BUFSIZE);
             } catch (ErrnoException e) {
                 mLog.e("Unable to create conntrack socket " + e);
                 return null;
diff --git a/Tethering/src/com/android/networkstack/tethering/RequestTracker.java b/Tethering/src/com/android/networkstack/tethering/RequestTracker.java
index c91ff586e4..2608e7aaca 100644
--- a/Tethering/src/com/android/networkstack/tethering/RequestTracker.java
+++ b/Tethering/src/com/android/networkstack/tethering/RequestTracker.java
@@ -43,7 +43,7 @@ import java.util.Map;
  * Note: This class is not thread-safe.
  */
 public class RequestTracker {
-    private static final String TAG = RequestTracker.class.getSimpleName();
+    private static final String TAG = "TetheringRequestTracker";
 
     @NonNull
     private final boolean mUseFuzzyMatching;
diff --git a/Tethering/src/com/android/networkstack/tethering/Tethering.java b/Tethering/src/com/android/networkstack/tethering/Tethering.java
index 073063963d..00103d68af 100644
--- a/Tethering/src/com/android/networkstack/tethering/Tethering.java
+++ b/Tethering/src/com/android/networkstack/tethering/Tethering.java
@@ -52,6 +52,7 @@ import static android.net.TetheringManager.TETHER_ERROR_UNAVAIL_IFACE;
 import static android.net.TetheringManager.TETHER_ERROR_UNKNOWN_IFACE;
 import static android.net.TetheringManager.TETHER_ERROR_UNKNOWN_REQUEST;
 import static android.net.TetheringManager.TETHER_ERROR_UNKNOWN_TYPE;
+import static android.net.TetheringManager.TETHER_ERROR_UNSUPPORTED;
 import static android.net.TetheringManager.TETHER_HARDWARE_OFFLOAD_FAILED;
 import static android.net.TetheringManager.TETHER_HARDWARE_OFFLOAD_STARTED;
 import static android.net.TetheringManager.TETHER_HARDWARE_OFFLOAD_STOPPED;
@@ -75,10 +76,6 @@ import static com.android.networkstack.tethering.TetheringConfiguration.TETHER_F
 import static com.android.networkstack.tethering.TetheringNotificationUpdater.DOWNSTREAM_NONE;
 import static com.android.networkstack.tethering.UpstreamNetworkMonitor.isCellular;
 import static com.android.networkstack.tethering.metrics.TetheringStatsLog.CORE_NETWORKING_TERRIBLE_ERROR_OCCURRED;
-import static com.android.networkstack.tethering.metrics.TetheringStatsLog.CORE_NETWORKING_TERRIBLE_ERROR_OCCURRED__ERROR_TYPE__TYPE_LEGACY_TETHER_WITH_TYPE_WIFI;
-import static com.android.networkstack.tethering.metrics.TetheringStatsLog.CORE_NETWORKING_TERRIBLE_ERROR_OCCURRED__ERROR_TYPE__TYPE_LEGACY_TETHER_WITH_TYPE_WIFI_P2P;
-import static com.android.networkstack.tethering.metrics.TetheringStatsLog.CORE_NETWORKING_TERRIBLE_ERROR_OCCURRED__ERROR_TYPE__TYPE_LEGACY_TETHER_WITH_TYPE_WIFI_P2P_SUCCESS;
-import static com.android.networkstack.tethering.metrics.TetheringStatsLog.CORE_NETWORKING_TERRIBLE_ERROR_OCCURRED__ERROR_TYPE__TYPE_LEGACY_TETHER_WITH_TYPE_WIFI_SUCCESS;
 import static com.android.networkstack.tethering.metrics.TetheringStatsLog.CORE_NETWORKING_TERRIBLE_ERROR_OCCURRED__ERROR_TYPE__TYPE_TETHER_WITH_PLACEHOLDER_REQUEST;
 import static com.android.networkstack.tethering.util.TetheringMessageBase.BASE_MAIN_SM;
 import static com.android.networkstack.tethering.util.TetheringUtils.createImplicitLocalOnlyTetheringRequest;
@@ -152,11 +149,11 @@ import com.android.internal.util.StateMachine;
 import com.android.modules.utils.build.SdkLevel;
 import com.android.net.module.util.BaseNetdUnsolicitedEventListener;
 import com.android.net.module.util.CollectionUtils;
+import com.android.net.module.util.FrameworkConnectivityStatsLog;
 import com.android.net.module.util.HandlerUtils;
 import com.android.net.module.util.NetdUtils;
 import com.android.net.module.util.RoutingCoordinatorManager;
 import com.android.net.module.util.SharedLog;
-import com.android.net.module.util.TerribleErrorLog;
 import com.android.networkstack.apishim.common.BluetoothPanShim;
 import com.android.networkstack.apishim.common.BluetoothPanShim.TetheredInterfaceCallbackShim;
 import com.android.networkstack.apishim.common.BluetoothPanShim.TetheredInterfaceRequestShim;
@@ -618,33 +615,40 @@ public class Tethering {
         if (type == TETHERING_BLUETOOTH && SdkLevel.isAtLeastT()) return;
 
         // Cannot happen: on S+, tetherableWigigRegexps is always empty.
-        if (type == TETHERING_WIGIG && SdkLevel.isAtLeastS()) return;
+        if (type == TETHERING_WIGIG
+                && (SdkLevel.isAtLeastS() || !hasSystemFeature(PackageManager.FEATURE_WIFI))) {
+            return;
+        }
 
-        // After V, disallow this legacy codepath from starting tethering of any type:
-        // everything must call ensureIpServerStarted directly.
+        // After V, don't allow this legacy codepath to create IpServers for any tethering type:
+        // everything must call ensureIpServerStarted directly. Also, on any release, don't create
+        // IpServers for WIFI or WIFI_P2P. These types always use the enableIpServing path.
         //
         // Don't touch the teardown path for now. It's more complicated because:
         // - ensureIpServerStarted and ensureIpServerStopped act on different
-        //   tethering types.
+        //   tethering types, and ensureIpServerStopped doesn't look at the type at all.
         // - Depending on the type, ensureIpServerStopped is either called twice (once
         //   on interface down and once on interface removed) or just once (on
-        //   interface removed).
+        //   interface removed). It's not clear whether it's possible to remove one of
+        //   these two calls without causing breakage in the field - for example, it's
+        //   possible that if the code did not call ensureIpServerStopped on wifi, then
+        //   when wifi tethering is disabled and wifi goes into client mode, tethering
+        //   has not brought down the IpServer because the WIFI_AP_STATE_CHANGED_ACTION
+        //   was delayed.
         //
-        // Note that this only affects WIFI and WIFI_P2P. The other types are either
-        // ignored above, or ignored by ensureIpServerStarted. Note that even for WIFI
-        // and WIFI_P2P, this code should not ever run in normal use, because the
-        // hotspot and p2p code do not call tether(). It's possible that this could
-        // happen in the field due to unforeseen OEM modifications. If it does happen,
-        // a terrible error is logged in tether().
         // TODO: fix the teardown path to stop depending on interface state notifications.
         // These are not necessary since most/all link layers have their own teardown
         // notifications, and can race with those notifications.
-        if (enabled && SdkLevel.isAtLeastB()) {
-            return;
-        }
+        if (enabled && SdkLevel.isAtLeastB()) return;
+
+        if (enabled && (type == TETHERING_WIFI || type == TETHERING_WIFI_P2P))  return;
+
+        // In this method, INVALID includes ETHERNET and VIRTUAL, because ifaceNameToType never
+        // returns these. The legacy codepath does not support these.
+        if (enabled && type == TETHERING_INVALID) return;
 
         if (enabled) {
-            ensureIpServerStartedForInterface(iface);
+            ensureIpServerStarted(iface, type, false /* isNcm */);
         } else {
             ensureIpServerStopped(iface);
         }
@@ -704,6 +708,7 @@ public class Tethering {
     void startTethering(final TetheringRequest request, final String callerPkg,
             final IIntResultListener listener) {
         mHandler.post(() -> {
+            mLog.i("startTethering: " + request);
             final int type = request.getTetheringType();
             RequestTracker.AddResult result = mRequestTracker.addPendingRequest(request);
             // If tethering is already pending with a conflicting request, stop tethering before
@@ -733,6 +738,7 @@ public class Tethering {
 
     void stopTethering(int type) {
         mHandler.post(() -> {
+            mLog.i("stopTethering: " + type);
             stopTetheringInternal(type);
         });
     }
@@ -742,6 +748,7 @@ public class Tethering {
         if (!isTetheringWithSoftApConfigEnabled()) return;
         final boolean hasNetworkSettings = hasCallingPermission(NETWORK_SETTINGS);
         mHandler.post(() -> {
+            mLog.i("stopTetheringRequest: " + request);
             if (mRequestTracker.findFuzzyMatchedRequest(request, !hasNetworkSettings) != null) {
                 final int type = request.getTetheringType();
                 stopTetheringInternal(type);
@@ -953,13 +960,15 @@ public class Tethering {
                 // reachable before next onServiceConnected.
                 mIsConnected = false;
 
-                if (mPendingPanRequestListener != null) {
-                    sendTetherResultAndRemoveOnError(
-                            mRequestTracker.getOrCreatePendingRequest(TETHERING_BLUETOOTH),
-                            mPendingPanRequestListener,
-                            TETHER_ERROR_SERVICE_UNAVAIL);
-                }
-                mPendingPanRequestListener = null;
+                // Remove any pending request even if bluetooth tethering is not started.
+                // Call sendTetherResultAndRemoveOnError for convenience (and to update the metrics)
+                // even though mPendingPanRequestListener is guaranteed to be null here (when the
+                // service connects onServiceConnected sets it to null, and whenever the service is
+                // connected, it's never set to non-null).
+                sendTetherResultAndRemoveOnError(
+                        mRequestTracker.getOrCreatePendingRequest(TETHERING_BLUETOOTH),
+                        null /* listener */,
+                        TETHER_ERROR_SERVICE_UNAVAIL);
                 mBluetoothIfaceRequest = null;
                 mBluetoothCallback = null;
                 maybeDisableBluetoothIpServing();
@@ -1132,43 +1141,20 @@ public class Tethering {
         if (type == TETHERING_INVALID) {
             Log.e(TAG, "Ignoring call to legacy tether for unknown iface " + iface);
             sendTetherResult(listener, TETHER_ERROR_UNKNOWN_IFACE);
+            return;
+        }
+
+        if (type == TETHERING_WIFI || type == TETHERING_WIFI_P2P) {
+            // Metrics show no usage of this legacy codepath. Stop supporing it.
+            sendTetherResult(listener, TETHER_ERROR_UNSUPPORTED);
+            return;
         }
 
         TetheringRequest request = mRequestTracker.getNextPendingRequest(type);
         if (request == null) {
             request = createLegacyGlobalScopeTetheringRequest(type);
         }
-        int result = tetherInternal(request, iface);
-        switch (type) {
-            case TETHERING_WIFI:
-                TerribleErrorLog.logTerribleError(TetheringStatsLog::write,
-                        "Legacy tether API called on Wifi iface " + iface,
-                        CORE_NETWORKING_TERRIBLE_ERROR_OCCURRED,
-                        CORE_NETWORKING_TERRIBLE_ERROR_OCCURRED__ERROR_TYPE__TYPE_LEGACY_TETHER_WITH_TYPE_WIFI);
-                if (result == TETHER_ERROR_NO_ERROR) {
-                    TerribleErrorLog.logTerribleError(TetheringStatsLog::write,
-                            "Legacy tether API succeeded on Wifi iface " + iface,
-                            CORE_NETWORKING_TERRIBLE_ERROR_OCCURRED,
-                            CORE_NETWORKING_TERRIBLE_ERROR_OCCURRED__ERROR_TYPE__TYPE_LEGACY_TETHER_WITH_TYPE_WIFI_SUCCESS);
-                }
-                break;
-            case TETHERING_WIFI_P2P:
-                TerribleErrorLog.logTerribleError(TetheringStatsLog::write,
-                        "Legacy tether API called on Wifi P2P iface " + iface,
-                        CORE_NETWORKING_TERRIBLE_ERROR_OCCURRED,
-                        CORE_NETWORKING_TERRIBLE_ERROR_OCCURRED__ERROR_TYPE__TYPE_LEGACY_TETHER_WITH_TYPE_WIFI_P2P);
-                if (result == TETHER_ERROR_NO_ERROR) {
-                    TerribleErrorLog.logTerribleError(TetheringStatsLog::write,
-                            "Legacy tether API succeeded on Wifi P2P iface " + iface,
-                            CORE_NETWORKING_TERRIBLE_ERROR_OCCURRED,
-                            CORE_NETWORKING_TERRIBLE_ERROR_OCCURRED__ERROR_TYPE__TYPE_LEGACY_TETHER_WITH_TYPE_WIFI_P2P_SUCCESS);
-                }
-                break;
-            default:
-                // Do nothing
-                break;
-        }
-        sendTetherResult(listener, result);
+        sendTetherResult(listener, tetherInternal(request, iface));
     }
 
     /**
@@ -1178,11 +1164,12 @@ public class Tethering {
      * processInterfaceStateChanged beforehand, which is only possible for
      *     - WIGIG Pre-S
      *     - BLUETOOTH Pre-T
+     * It was previously supported but no longer allowed for:
      *     - WIFI
      *     - WIFI_P2P.
-     * Note that WIFI and WIFI_P2P already start tethering on their respective ifaces via
-     * WIFI_(AP/P2P_STATE_CHANGED broadcasts, which makes this API redundant for those types unless
-     * those broadcasts are disabled by OEM.
+     * because metrics show that there is no usage of this method for these types in production.
+     * These types start tethering on their respective ifaces via WIFI_(AP/P2P_STATE_CHANGED
+     * broadcasts instead.
      */
     void legacyTether(String iface, final IIntResultListener listener) {
         mHandler.post(() -> handleLegacyTether(iface, listener));
@@ -1206,8 +1193,8 @@ public class Tethering {
         // processed, this will be a no-op and it will not return an error.
         tetherState.ipServer.enable(request);
         if (request.getRequestType() == REQUEST_TYPE_PLACEHOLDER) {
-            TerribleErrorLog.logTerribleError(TetheringStatsLog::write,
-                    "Started tethering with placeholder request: " + request,
+            Log.i(TAG, "Started tethering with placeholder request: " + request);
+            TetheringStatsLog.write(
                     CORE_NETWORKING_TERRIBLE_ERROR_OCCURRED,
                     CORE_NETWORKING_TERRIBLE_ERROR_OCCURRED__ERROR_TYPE__TYPE_TETHER_WITH_PLACEHOLDER_REQUEST);
         }
@@ -1266,13 +1253,6 @@ public class Tethering {
         return mEntitlementMgr.isTetherProvisioningRequired(cfg);
     }
 
-    private int getServedUsbType(boolean forNcmFunction) {
-        // TETHERING_NCM is only used if the device does not use NCM for regular USB tethering.
-        if (forNcmFunction && !mConfig.isUsingNcm()) return TETHERING_NCM;
-
-        return TETHERING_USB;
-    }
-
     // TODO: Figure out how to update for local hotspot mode interfaces.
     private void notifyTetherStatesChanged() {
         if (!isTetheringSupported()) return;
@@ -1692,7 +1672,7 @@ public class Tethering {
     }
 
     private void enableIpServing(@NonNull TetheringRequest request, String ifname, boolean isNcm) {
-        ensureIpServerStartedForType(ifname, request.getTetheringType(), isNcm);
+        ensureIpServerStarted(ifname, request.getTetheringType(), isNcm);
         if (tetherInternal(request, ifname) != TETHER_ERROR_NO_ERROR) {
             Log.e(TAG, "unable start tethering on iface " + ifname);
         }
@@ -1741,6 +1721,12 @@ public class Tethering {
         // After T, tethering always trust the iface pass by state change intent. This allow
         // tethering to deprecate tetherable p2p regexs after T.
         final int type = SdkLevel.isAtLeastT() ? TETHERING_WIFI_P2P : ifaceNameToType(ifname);
+        if (type != TETHERING_WIFI_P2P) {
+            FrameworkConnectivityStatsLog.write(
+                    FrameworkConnectivityStatsLog.CORE_NETWORKING_TERRIBLE_ERROR_OCCURRED,
+                    FrameworkConnectivityStatsLog.CORE_NETWORKING_TERRIBLE_ERROR_OCCURRED__ERROR_TYPE__TYPE_TETHER_WIFIP2P_TYPE_MISMATCH);
+        }
+
         if (!checkTetherableType(type)) {
             mLog.e(ifname + " is not a tetherable iface, ignoring");
             return;
@@ -1791,6 +1777,11 @@ public class Tethering {
                 mLog.e("Cannot enable IP serving in unknown WiFi mode: " + wifiIpMode);
                 return;
         }
+        if (type != TETHERING_WIFI) {
+            FrameworkConnectivityStatsLog.write(
+                    FrameworkConnectivityStatsLog.CORE_NETWORKING_TERRIBLE_ERROR_OCCURRED,
+                    FrameworkConnectivityStatsLog.CORE_NETWORKING_TERRIBLE_ERROR_OCCURRED__ERROR_TYPE__TYPE_TETHER_WIFI_TYPE_MISMATCH);
+        }
 
         // After T, tethering always trust the iface pass by state change intent. This allow
         // tethering to deprecate tetherable wifi regexs after T.
@@ -1813,14 +1804,7 @@ public class Tethering {
     //     - allows requesting either tethering or local hotspot serving states
     //     - only tethers the first matching interface in listInterfaces()
     //       order of a given type
-    private void enableUsbIpServing(boolean forNcmFunction) {
-        // Note: TetheringConfiguration#isUsingNcm can change between the call to
-        // startTethering(TETHERING_USB) and the ACTION_USB_STATE broadcast. If the USB tethering
-        // function changes from NCM to RNDIS, this can lead to Tethering starting NCM tethering
-        // as local-only. But if this happens, the SettingsObserver will call stopTetheringInternal
-        // for both TETHERING_USB and TETHERING_NCM, so the local-only NCM interface will be
-        // stopped immediately.
-        final int tetheringType = getServedUsbType(forNcmFunction);
+    private void enableUsbIpServing(boolean isNcm) {
         String[] ifaces = null;
         try {
             ifaces = mNetd.interfaceGetList();
@@ -1829,17 +1813,24 @@ public class Tethering {
             return;
         }
 
+        // Note: TetheringConfiguration#isUsingNcm can change between the call to
+        // startTethering(TETHERING_USB) and the ACTION_USB_STATE broadcast. If the USB tethering
+        // function changes from NCM to RNDIS, this can lead to Tethering starting NCM tethering
+        // as local-only. But if this happens, the SettingsObserver will call stopTetheringInternal
+        // for both TETHERING_USB and TETHERING_NCM, so the local-only NCM interface will be
+        // stopped immediately.
+        final int tetheringType = (isNcm && !mConfig.isUsingNcm()) ? TETHERING_NCM : TETHERING_USB;
         final TetheringRequest request = mRequestTracker.getOrCreatePendingRequest(tetheringType);
         if (ifaces != null) {
             for (String iface : ifaces) {
                 if (ifaceNameToType(iface) == tetheringType) {
-                    enableIpServing(request, iface, forNcmFunction);
+                    enableIpServing(request, iface, isNcm);
                     return;
                 }
             }
         }
 
-        mLog.e("could not enable IpServer for function " + (forNcmFunction ? "NCM" : "RNDIS"));
+        mLog.e("could not enable IpServer for function " + (isNcm ? "NCM" : "RNDIS"));
     }
 
     private void disableUsbIpServing(boolean forNcmFunction) {
@@ -3083,20 +3074,7 @@ public class Tethering {
         return type != TETHERING_INVALID;
     }
 
-    private void ensureIpServerStartedForInterface(final String iface) {
-        // If we don't care about this type of interface, ignore.
-        final int interfaceType = ifaceNameToType(iface);
-        if (!checkTetherableType(interfaceType)) {
-            mLog.log(iface + " is used for " + interfaceType + " which is not tetherable"
-                     + " (-1 == INVALID is expected on upstream interface)");
-            return;
-        }
-
-        ensureIpServerStartedForType(iface, interfaceType, false /* isNcm */);
-    }
-
-    private void ensureIpServerStartedForType(final String iface, int interfaceType,
-            boolean isNcm) {
+    private void ensureIpServerStarted(final String iface, int interfaceType, boolean isNcm) {
         // If we have already started a TISM for this interface, skip.
         if (mTetherStates.containsKey(iface)) {
             mLog.log("active iface (" + iface + ") reported as added, ignoring");
diff --git a/Tethering/src/com/android/networkstack/tethering/TetheringConfiguration.java b/Tethering/src/com/android/networkstack/tethering/TetheringConfiguration.java
index e2609e7d2f..c6d71abacb 100644
--- a/Tethering/src/com/android/networkstack/tethering/TetheringConfiguration.java
+++ b/Tethering/src/com/android/networkstack/tethering/TetheringConfiguration.java
@@ -25,6 +25,9 @@ import static android.provider.DeviceConfig.NAMESPACE_CONNECTIVITY;
 
 import static com.android.networkstack.apishim.ConstantsShim.KEY_CARRIER_SUPPORTS_TETHERING_BOOL;
 import static com.android.net.module.util.SdkUtil.isAtLeast25Q2;
+import static com.android.networkstack.tethering.TetheringFeatureFlags.TETHER_ENABLE_SYNC_SM;
+import static com.android.networkstack.tethering.TetheringFeatureFlags.TETHER_ENABLE_WEAR_TETHERING;
+import static com.android.networkstack.tethering.TetheringFeatureFlags.TETHER_FORCE_UPSTREAM_AUTOMATIC_VERSION;
 
 import android.content.ContentResolver;
 import android.content.Context;
@@ -103,19 +106,6 @@ public class TetheringConfiguration {
     public static final String USE_LEGACY_WIFI_P2P_DEDICATED_IP =
             "use_legacy_wifi_p2p_dedicated_ip";
 
-    /**
-     * Experiment flag to force choosing upstreams automatically.
-     *
-     * This setting is intended to help force-enable the feature on OEM devices that disabled it
-     * via resource overlays, and later noticed issues. To that end, it overrides
-     * config_tether_upstream_automatic when set to true.
-     *
-     * This flag is enabled if !=0 and less than the module APEX version: see
-     * {@link DeviceConfigUtils#isTetheringFeatureEnabled}. It is also ignored after R, as later
-     * devices should just set config_tether_upstream_automatic to true instead.
-     */
-    public static final String TETHER_FORCE_UPSTREAM_AUTOMATIC_VERSION =
-            "tether_force_upstream_automatic_version";
 
     /**
      * Settings key to foce choosing usb functions for usb tethering.
@@ -125,14 +115,6 @@ public class TetheringConfiguration {
     public static final String TETHER_FORCE_USB_FUNCTIONS =
             "tether_force_usb_functions";
 
-    /**
-     * Experiment flag to enable TETHERING_WEAR.
-     */
-    public static final String TETHER_ENABLE_WEAR_TETHERING =
-            "tether_enable_wear_tethering";
-
-    public static final String TETHER_ENABLE_SYNC_SM = "tether_enable_sync_sm";
-
     /**
      * Default value that used to periodic polls tether offload stats from tethering offload HAL
      * to make the data warnings work.
@@ -142,18 +124,6 @@ public class TetheringConfiguration {
     /** A flag for using synchronous or asynchronous state machine. */
     public static boolean USE_SYNC_SM = true;
 
-    /**
-     * A feature flag to control whether the active sessions metrics should be enabled.
-     * Disabled by default.
-     */
-    public static final String TETHER_ACTIVE_SESSIONS_METRICS = "tether_active_sessions_metrics";
-
-    /**
-     * A feature flag to control whether the tethering local network agent should be enabled.
-     * Disabled by default.
-     */
-    public static final String TETHERING_LOCAL_NETWORK_AGENT = "tethering_local_network_agent";
-
     public final String[] tetherableUsbRegexs;
     public final String[] tetherableWifiRegexs;
     public final String[] tetherableWigigRegexs;
diff --git a/Tethering/src/com/android/networkstack/tethering/TetheringFeatureFlags.java b/Tethering/src/com/android/networkstack/tethering/TetheringFeatureFlags.java
new file mode 100644
index 0000000000..fd4aa510ea
--- /dev/null
+++ b/Tethering/src/com/android/networkstack/tethering/TetheringFeatureFlags.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.networkstack.tethering;
+
+import com.android.net.module.util.DeviceConfigUtils;
+
+/**
+ * The class that contains Tethering feature flags;
+ *
+ * @hide
+ */
+public class TetheringFeatureFlags {
+    /**
+     * A feature flag to control whether the automatic forced choosing upstreams is enabled.
+     *
+     * This setting is intended to help force-enable the feature on OEM devices that disabled it
+     * via resource overlays, and later noticed issues. To that end, it overrides
+     * config_tether_upstream_automatic when set to true.
+     *
+     * This flag is enabled if !=0 and less than the module APEX version: see
+     * {@link DeviceConfigUtils#isTetheringFeatureEnabled}. It is also ignored after R, as later
+     * devices should just set config_tether_upstream_automatic to true instead.
+     */
+    public static final String TETHER_FORCE_UPSTREAM_AUTOMATIC_VERSION =
+            "tether_force_upstream_automatic_version";
+
+    /**
+     * A feature flag to control whether the TETHERING_WEAR is enabled.
+     */
+    public static final String TETHER_ENABLE_WEAR_TETHERING = "tether_enable_wear_tethering";
+
+    /**
+     * A feature flag to control whether the force random prefix base selection is enabled.
+     */
+    public static final String TETHER_FORCE_RANDOM_PREFIX_BASE_SELECTION =
+            "tether_force_random_prefix_base_selection";
+
+    /**
+     * A feature flag to control whether the synchronize state machine is enabled.
+     */
+    public static final String TETHER_ENABLE_SYNC_SM = "tether_enable_sync_sm";
+
+    /**
+     * A feature flag to control whether the active sessions metrics should be enabled.
+     * Disabled by default.
+     */
+    public static final String TETHER_ACTIVE_SESSIONS_METRICS = "tether_active_sessions_metrics";
+
+    /**
+     * A feature flag to control whether the tethering local network agent should be enabled.
+     * Disabled by default.
+     */
+    public static final String TETHERING_LOCAL_NETWORK_AGENT = "tethering_local_network_agent";
+
+    /**
+     * A feature flag to control whether the Wifi P2P Group Owner local network agent
+     * should be enabled. Disabled by default. This depends on TETHERING_LOCAL_AGENT
+     * and will not be enabled if that flag is off.
+     */
+    public static final String WIFIP2PGO_LOCAL_NETWORK_AGENT = "wifip2pgo_local_network_agent";
+}
diff --git a/Tethering/tests/integration/base/android/net/EthernetTetheringTestBase.java b/Tethering/tests/integration/base/android/net/EthernetTetheringTestBase.java
index 1323f28ff7..7f837f1990 100644
--- a/Tethering/tests/integration/base/android/net/EthernetTetheringTestBase.java
+++ b/Tethering/tests/integration/base/android/net/EthernetTetheringTestBase.java
@@ -108,7 +108,7 @@ public abstract class EthernetTetheringTestBase {
     // See TetheredInterfaceRequester.getInterface, isInterfaceForTetheringAvailable.
     private static final int SHORT_TIMEOUT_MS = 1000;
     private static final int TETHER_REACHABILITY_ATTEMPTS = 20;
-    protected static final long WAIT_RA_TIMEOUT_MS = 2000;
+    protected static final long WAIT_RA_TIMEOUT_MS = 10000;
 
     // Address and NAT prefix definition.
     protected static final MacAddress TEST_MAC = MacAddress.fromString("1:2:3:4:5:6");
@@ -296,7 +296,7 @@ public abstract class EthernetTetheringTestBase {
         final long deadline = SystemClock.uptimeMillis() + timeoutMs;
         do {
             byte[] pkt = reader.popPacket(timeoutMs);
-            if (isExpectedIcmpPacket(pkt, true /* hasEth */, false /* isIpv4 */,
+            if (pkt != null && isExpectedIcmpPacket(pkt, true /* hasEth */, false /* isIpv4 */,
                     ICMPV6_ROUTER_ADVERTISEMENT)) {
                 return;
             }
diff --git a/Tethering/tests/integration/src/android/net/EthernetTetheringTest.java b/Tethering/tests/integration/src/android/net/EthernetTetheringTest.java
index d47f4b3294..14795b7320 100644
--- a/Tethering/tests/integration/src/android/net/EthernetTetheringTest.java
+++ b/Tethering/tests/integration/src/android/net/EthernetTetheringTest.java
@@ -93,8 +93,8 @@ import com.android.testutils.DeviceInfoUtils;
 import com.android.testutils.DumpTestUtils;
 import com.android.testutils.NetworkStackModuleTest;
 import com.android.testutils.PollPacketReader;
-import com.android.testutils.RecorderCallback.CallbackEntry;
 import com.android.testutils.TestableNetworkCallback;
+import com.android.testutils.TestableNetworkCallback.Event;
 
 import org.junit.After;
 import org.junit.Rule;
@@ -219,6 +219,7 @@ public class EthernetTetheringTest extends EthernetTetheringTestBase {
 
     // Shamelessly copied from TetheringConfiguration.
     private static final String TETHERING_LOCAL_NETWORK_AGENT = "tethering_local_network_agent";
+    private static final String WIFIP2PGO_LOCAL_NETWORK_AGENT = "wifip2pgo_local_network_agent";
 
     @After
     public void tearDown() throws Exception {
@@ -1245,15 +1246,29 @@ public class EthernetTetheringTest extends EthernetTetheringTestBase {
         }
     }
 
+    private void assumeMatchNonThreadLocalNetworksEnabled() {
+        assumeTrue(runAsShell(READ_COMPAT_CHANGE_CONFIG, LOG_COMPAT_CHANGE,
+                () -> CompatChanges.isChangeEnabled(ENABLE_MATCH_NON_THREAD_LOCAL_NETWORKS)));
+    }
+
     @IgnoreUpTo(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
     @Test
-    public void testLocalAgent_networkCallbacks() throws Exception {
-        final boolean isMatchNonThreadLocalNetworksEnabled = runAsShell(
-                READ_COMPAT_CHANGE_CONFIG, LOG_COMPAT_CHANGE,
-                () -> CompatChanges.isChangeEnabled(ENABLE_MATCH_NON_THREAD_LOCAL_NETWORKS));
-        assumeTrue(isMatchNonThreadLocalNetworksEnabled);
+    public void testTetheringLocalAgent_networkCallbacks() throws Exception {
+        assumeMatchNonThreadLocalNetworksEnabled();
+        mDeviceConfigRule.setConfig(NAMESPACE_TETHERING, TETHERING_LOCAL_NETWORK_AGENT, "1");
+        doTestLocalAgent_networkCallbacks(CONNECTIVITY_SCOPE_GLOBAL);
+    }
 
+    @IgnoreUpTo(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+    @Test
+    public void testWifiP2pGroupOwnerLocalAgent_networkCallbacks() throws Exception {
+        assumeMatchNonThreadLocalNetworksEnabled();
         mDeviceConfigRule.setConfig(NAMESPACE_TETHERING, TETHERING_LOCAL_NETWORK_AGENT, "1");
+        mDeviceConfigRule.setConfig(NAMESPACE_TETHERING, WIFIP2PGO_LOCAL_NETWORK_AGENT, "1");
+        doTestLocalAgent_networkCallbacks(CONNECTIVITY_SCOPE_LOCAL);
+    }
+
+    private void doTestLocalAgent_networkCallbacks(int scope) throws Exception {
         assumeFalse(isInterfaceForTetheringAvailable());
         setIncludeTestInterfaces(true);
 
@@ -1273,17 +1288,30 @@ public class EthernetTetheringTest extends EthernetTetheringTestBase {
                     downstreamIface.getInterfaceName(), iface);
 
             final TetheringRequest request = new TetheringRequest.Builder(TETHERING_ETHERNET)
-                    .setConnectivityScope(CONNECTIVITY_SCOPE_GLOBAL).build();
+                    .setConnectivityScope(scope).build();
             tetheringEventCallback = enableTethering(iface, request, null /* any upstream */);
-            tetheringEventCallback.awaitInterfaceTethered();
+            if (scope == CONNECTIVITY_SCOPE_GLOBAL) {
+                tetheringEventCallback.awaitInterfaceTethered();
+            } else {
+                tetheringEventCallback.awaitInterfaceLocalOnly();
+            }
 
             // Verify NetworkCallback works accordingly.
-            final Network network = networkCallback.expect(CallbackEntry.AVAILABLE).getNetwork();
-            final CallbackEntry.CapabilitiesChanged capEvent =
-                    networkCallback.eventuallyExpect(CallbackEntry.NETWORK_CAPS_UPDATED);
+            final Network network = networkCallback.expect(Event.AVAILABLE).getNetwork();
+            final Event.CapabilitiesChanged capEvent =
+                    networkCallback.eventuallyExpect(Event.NETWORK_CAPS_UPDATED);
             assertEquals(network, capEvent.getNetwork());
             assertTrue(capEvent.getCaps().hasTransport(TRANSPORT_ETHERNET));
             assertTrue(capEvent.getCaps().hasCapability(NET_CAPABILITY_LOCAL_NETWORK));
+
+            // Verify details in the LinkPropertiesChanged event.
+            final Event.LinkPropertiesChanged lpEvent =
+                    networkCallback.eventuallyExpect(Event.LINK_PROPERTIES_CHANGED);
+            assertEquals(network, lpEvent.getNetwork());
+            assertEquals(iface, lpEvent.getLp().getInterfaceName());
+            assertTrue(lpEvent.getLp().hasIPv4Address());
+            // At least one Ipv4 route for the subnet is needed.
+            assertTrue(lpEvent.getLp().getRoutes().size() >= 1);
         } finally {
             stopEthernetTethering(tetheringEventCallback);
             maybeCloseTestInterface(downstreamIface);
diff --git a/Tethering/tests/unit/src/android/net/ip/IpServerTest.java b/Tethering/tests/unit/src/android/net/ip/IpServerTest.java
index dc90d686f0..1d0deff3d8 100644
--- a/Tethering/tests/unit/src/android/net/ip/IpServerTest.java
+++ b/Tethering/tests/unit/src/android/net/ip/IpServerTest.java
@@ -40,7 +40,8 @@ import static android.net.ip.IpServer.getTetherableIpv6Prefixes;
 import static com.android.modules.utils.build.SdkLevel.isAtLeastT;
 import static com.android.modules.utils.build.SdkLevel.isAtLeastV;
 import static com.android.net.module.util.Inet4AddressUtils.intToInet4AddressHTH;
-import static com.android.networkstack.tethering.TetheringConfiguration.TETHERING_LOCAL_NETWORK_AGENT;
+import static com.android.networkstack.tethering.TetheringFeatureFlags.TETHERING_LOCAL_NETWORK_AGENT;
+import static com.android.networkstack.tethering.TetheringFeatureFlags.WIFIP2PGO_LOCAL_NETWORK_AGENT;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -1123,20 +1124,33 @@ public class IpServerTest {
 
     @IgnoreUpTo(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
     @SetFeatureFlagsRule.FeatureFlag(name = TETHERING_LOCAL_NETWORK_AGENT, enabled = false)
+    @SetFeatureFlagsRule.FeatureFlag(name = WIFIP2PGO_LOCAL_NETWORK_AGENT)
     @Test
     public void testTetheringNetworkAgent_tetheringAgentDisabled() throws Exception {
         doTestTetheringNetworkAgent(CONNECTIVITY_SCOPE_GLOBAL, false);
+        // Even if the flag is enabled, no wifip2p network agent if the tethering network
+        // agent feature is not supported.
+        doTestTetheringNetworkAgent(CONNECTIVITY_SCOPE_LOCAL, false);
     }
 
     // Verify Tethering Network Agent feature doesn't affect Wi-fi P2P Group Owner although
     // the code is mostly shared.
     @IgnoreUpTo(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
     @SetFeatureFlagsRule.FeatureFlag(name = TETHERING_LOCAL_NETWORK_AGENT)
+    @SetFeatureFlagsRule.FeatureFlag(name = WIFIP2PGO_LOCAL_NETWORK_AGENT, enabled = false)
     @Test
     public void testTetheringNetworkAgent_p2pGroupOwnerAgentDisabled() throws Exception {
         doTestTetheringNetworkAgent(CONNECTIVITY_SCOPE_LOCAL, false);
     }
 
+    @IgnoreUpTo(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+    @SetFeatureFlagsRule.FeatureFlag(name = TETHERING_LOCAL_NETWORK_AGENT)
+    @SetFeatureFlagsRule.FeatureFlag(name = WIFIP2PGO_LOCAL_NETWORK_AGENT)
+    @Test
+    public void testTetheringNetworkAgent_p2pGroupOwnerAgentEnabled() throws Exception {
+        doTestTetheringNetworkAgent(CONNECTIVITY_SCOPE_LOCAL, true);
+    }
+
     private void doTestTetheringNetworkAgent(int scope, boolean expectAgentEnabled)
             throws Exception {
         initStateMachine(TETHERING_USB);
diff --git a/Tethering/tests/unit/src/com/android/networkstack/tethering/BpfCoordinatorTest.java b/Tethering/tests/unit/src/com/android/networkstack/tethering/BpfCoordinatorTest.java
index b537fb65a3..92ed6fc5b4 100644
--- a/Tethering/tests/unit/src/com/android/networkstack/tethering/BpfCoordinatorTest.java
+++ b/Tethering/tests/unit/src/com/android/networkstack/tethering/BpfCoordinatorTest.java
@@ -61,7 +61,7 @@ import static com.android.networkstack.tethering.BpfCoordinator.toIpv4MappedAddr
 import static com.android.networkstack.tethering.BpfUtils.DOWNSTREAM;
 import static com.android.networkstack.tethering.BpfUtils.UPSTREAM;
 import static com.android.networkstack.tethering.TetheringConfiguration.DEFAULT_TETHER_OFFLOAD_POLL_INTERVAL_MS;
-import static com.android.networkstack.tethering.TetheringConfiguration.TETHER_ACTIVE_SESSIONS_METRICS;
+import static com.android.networkstack.tethering.TetheringFeatureFlags.TETHER_ACTIVE_SESSIONS_METRICS;
 import static com.android.testutils.MiscAsserts.assertSameElements;
 
 import static org.junit.Assert.assertArrayEquals;
diff --git a/Tethering/tests/unit/src/com/android/networkstack/tethering/EntitlementManagerTest.java b/Tethering/tests/unit/src/com/android/networkstack/tethering/EntitlementManagerTest.java
index 7bfdb22cfc..de39665ca3 100644
--- a/Tethering/tests/unit/src/com/android/networkstack/tethering/EntitlementManagerTest.java
+++ b/Tethering/tests/unit/src/com/android/networkstack/tethering/EntitlementManagerTest.java
@@ -40,7 +40,6 @@ import static com.android.dx.mockito.inline.extended.ExtendedMockito.mockitoSess
 import static com.android.networkstack.apishim.ConstantsShim.KEY_CARRIER_SUPPORTS_TETHERING_BOOL;
 import static com.android.testutils.DevSdkIgnoreRule.IgnoreAfter;
 import static com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo;
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -67,6 +66,7 @@ import android.content.pm.ModuleInfo;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.res.Resources;
+import android.os.Build;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.PersistableBundle;
@@ -603,7 +603,7 @@ public final class EntitlementManagerTest {
                 .onTetherProvisioningFailed(TETHERING_WIFI, FAILED_TETHERING_REASON);
     }
 
-    @IgnoreUpTo(SC_V2)
+    @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     @Test
     public void testUiProvisioningMultiUser_aboveT_createContextAsUserThrows() {
         mMockContext.setCreateContextAsUserException(new IllegalStateException());
@@ -611,14 +611,14 @@ public final class EntitlementManagerTest {
         doTestUiProvisioningMultiUser(false, 1);
     }
 
-    @IgnoreUpTo(SC_V2)
+    @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     @Test
     public void testUiProvisioningMultiUser_aboveT() {
         doTestUiProvisioningMultiUser(true, 1);
         doTestUiProvisioningMultiUser(false, 0);
     }
 
-    @IgnoreAfter(SC_V2)
+    @IgnoreAfter(Build.VERSION_CODES.S_V2)
     @Test
     public void testUiProvisioningMultiUser_belowT() {
         doTestUiProvisioningMultiUser(true, 1);
@@ -734,7 +734,7 @@ public final class EntitlementManagerTest {
     }
 
     @Test
-    @IgnoreUpTo(SC_V2)
+    @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void requestLatestTetheringEntitlementResult_carrierDoesNotSupport_noProvisionCount()
             throws Exception {
         setupCarrierConfig(false);
@@ -746,7 +746,7 @@ public final class EntitlementManagerTest {
     }
 
     @Test
-    @IgnoreUpTo(SC_V2)
+    @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void reevaluateSimCardProvisioning_carrierUnsupportAndSimswitch() {
         setupForRequiredProvisioning();
 
@@ -771,7 +771,7 @@ public final class EntitlementManagerTest {
     }
 
     @Test
-    @IgnoreUpTo(SC_V2)
+    @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void startProvisioningIfNeeded_carrierUnsupport()
             throws Exception {
         setupCarrierConfig(false);
diff --git a/Tethering/tests/unit/src/com/android/networkstack/tethering/PrivateAddressCoordinatorTest.java b/Tethering/tests/unit/src/com/android/networkstack/tethering/PrivateAddressCoordinatorTest.java
index ada88fbb65..15653692cd 100644
--- a/Tethering/tests/unit/src/com/android/networkstack/tethering/PrivateAddressCoordinatorTest.java
+++ b/Tethering/tests/unit/src/com/android/networkstack/tethering/PrivateAddressCoordinatorTest.java
@@ -26,6 +26,7 @@ import static android.net.TetheringManager.TETHERING_WIFI;
 import static android.net.TetheringManager.TETHERING_WIFI_P2P;
 import static android.net.ip.IpServer.CMD_NOTIFY_PREFIX_CONFLICT;
 
+import static com.android.net.module.util.PrivateAddressCoordinator.TETHER_FORCE_RANDOM_PREFIX_BASE_SELECTION;
 import static com.android.networkstack.tethering.util.PrefixUtils.asIpPrefix;
 
 import static org.junit.Assert.assertEquals;
@@ -50,7 +51,6 @@ import android.net.LinkProperties;
 import android.net.Network;
 import android.net.NetworkCapabilities;
 import android.net.ip.IpServer;
-import android.os.Build;
 import android.os.IBinder;
 
 import androidx.test.filters.SmallTest;
@@ -58,10 +58,8 @@ import androidx.test.runner.AndroidJUnit4;
 
 import com.android.net.module.util.IIpv4PrefixRequest;
 import com.android.net.module.util.PrivateAddressCoordinator;
-import com.android.testutils.DevSdkIgnoreRule;
 
 import org.junit.Before;
-import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
@@ -73,9 +71,6 @@ import java.util.Arrays;
 @RunWith(AndroidJUnit4.class)
 @SmallTest
 public final class PrivateAddressCoordinatorTest {
-    @Rule
-    public final DevSdkIgnoreRule mIgnoreRule = new DevSdkIgnoreRule();
-
     private static final String TEST_IFNAME = "test0";
 
     @Mock private IpServer mHotspotIpServer;
@@ -236,9 +231,11 @@ public final class PrivateAddressCoordinatorTest {
         assertEquals(usbAddress, newUsbAddress);
 
         final UpstreamNetworkState wifiUpstream = buildUpstreamNetworkState(mWifiNetwork,
-                hotspotAddress, null, makeNetworkCapabilities(TRANSPORT_WIFI));
+                new LinkAddress("192.168.88.23/16"), null,
+                makeNetworkCapabilities(TRANSPORT_WIFI));
         updateUpstreamPrefix(wifiUpstream);
         verify(mHotspotIpServer).sendMessage(IpServer.CMD_NOTIFY_PREFIX_CONFLICT);
+        verify(mUsbIpServer).sendMessage(IpServer.CMD_NOTIFY_PREFIX_CONFLICT);
     }
 
     private UpstreamNetworkState buildUpstreamNetworkState(final Network network,
@@ -326,9 +323,11 @@ public final class PrivateAddressCoordinatorTest {
         assertFalse(localHotspotPrefix.containsPrefix(hotspotPrefix));
     }
 
-    @DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.VANILLA_ICE_CREAM)
     @Test
     public void testStartedPrefixRange() throws Exception {
+        when(mDeps.isFeatureNotChickenedOut(TETHER_FORCE_RANDOM_PREFIX_BASE_SELECTION))
+                .thenReturn(true);
+
         startedPrefixBaseTest("192.168.0.0/16", 0);
 
         startedPrefixBaseTest("192.168.0.0/16", 1);
diff --git a/Tethering/tests/unit/src/com/android/networkstack/tethering/TetheringConfigurationTest.java b/Tethering/tests/unit/src/com/android/networkstack/tethering/TetheringConfigurationTest.java
index 42882c7c3c..99baf27e82 100644
--- a/Tethering/tests/unit/src/com/android/networkstack/tethering/TetheringConfigurationTest.java
+++ b/Tethering/tests/unit/src/com/android/networkstack/tethering/TetheringConfigurationTest.java
@@ -31,6 +31,7 @@ import static com.android.networkstack.tethering.TetheringConfiguration.TETHER_E
 import static com.android.networkstack.tethering.TetheringConfiguration.TETHER_FORCE_USB_FUNCTIONS;
 import static com.android.networkstack.tethering.TetheringConfiguration.TETHER_USB_NCM_FUNCTION;
 import static com.android.networkstack.tethering.TetheringConfiguration.TETHER_USB_RNDIS_FUNCTION;
+import static com.android.networkstack.tethering.TetheringFeatureFlags.TETHER_FORCE_UPSTREAM_AUTOMATIC_VERSION;
 
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
@@ -179,7 +180,7 @@ public class TetheringConfigurationTest {
 
         @Override
         boolean isTetherForceUpstreamAutomaticFeatureEnabled() {
-            return isMockFlagEnabled(TetheringConfiguration.TETHER_FORCE_UPSTREAM_AUTOMATIC_VERSION,
+            return isMockFlagEnabled(TETHER_FORCE_UPSTREAM_AUTOMATIC_VERSION,
                     false /* defaultEnabled */);
         }
 
@@ -639,8 +640,7 @@ public class TetheringConfigurationTest {
     }
 
     private void setTetherForceUpstreamAutomaticFlagEnabled(Boolean enabled) {
-        mDeps.setFeatureEnabled(
-                TetheringConfiguration.TETHER_FORCE_UPSTREAM_AUTOMATIC_VERSION, enabled);
+        mDeps.setFeatureEnabled(TETHER_FORCE_UPSTREAM_AUTOMATIC_VERSION, enabled);
     }
 
     private void assertChooseUpstreamAutomaticallyIs(boolean value) {
@@ -762,28 +762,22 @@ public class TetheringConfigurationTest {
     }
 
     private void setTetherEnableSyncSMFlagEnabled(Boolean enabled) {
-        mDeps.setFeatureEnabled(TetheringConfiguration.TETHER_ENABLE_SYNC_SM, enabled);
+        mDeps.setFeatureEnabled(TetheringFeatureFlags.TETHER_ENABLE_SYNC_SM, enabled);
         new TetheringConfiguration(
                 mMockContext, mLog, INVALID_SUBSCRIPTION_ID, mDeps).readEnableSyncSM(mMockContext);
     }
 
-    private void assertEnableSyncSM(boolean value) {
-        assertEquals(value, TetheringConfiguration.USE_SYNC_SM);
-    }
-
     @Test
     public void testEnableSyncSMFlag() throws Exception {
         // Test default enabled
         setTetherEnableSyncSMFlagEnabled(null);
-        assertEnableSyncSM(true);
+        assertEquals(true, TetheringConfiguration.USE_SYNC_SM);
 
         setTetherEnableSyncSMFlagEnabled(true);
-        assertEnableSyncSM(true);
+        assertEquals(true, TetheringConfiguration.USE_SYNC_SM);
 
-        // Feature is enabled by default after 25Q2 release.
-        if (!SdkUtil.isAtLeast25Q2()) {
-            setTetherEnableSyncSMFlagEnabled(false);
-            assertEnableSyncSM(false);
-        }
+        // Feature is enabled forcefully after 25Q2 release.
+        setTetherEnableSyncSMFlagEnabled(false);
+        assertEquals(SdkUtil.isAtLeast25Q2(), TetheringConfiguration.USE_SYNC_SM);
     }
 }
diff --git a/Tethering/tests/unit/src/com/android/networkstack/tethering/TetheringTest.java b/Tethering/tests/unit/src/com/android/networkstack/tethering/TetheringTest.java
index bbe15b461f..5614a35219 100644
--- a/Tethering/tests/unit/src/com/android/networkstack/tethering/TetheringTest.java
+++ b/Tethering/tests/unit/src/com/android/networkstack/tethering/TetheringTest.java
@@ -57,6 +57,7 @@ import static android.net.TetheringManager.TETHER_ERROR_NO_ERROR;
 import static android.net.TetheringManager.TETHER_ERROR_SERVICE_UNAVAIL;
 import static android.net.TetheringManager.TETHER_ERROR_UNKNOWN_IFACE;
 import static android.net.TetheringManager.TETHER_ERROR_UNKNOWN_REQUEST;
+import static android.net.TetheringManager.TETHER_ERROR_UNSUPPORTED;
 import static android.net.TetheringManager.TETHER_HARDWARE_OFFLOAD_FAILED;
 import static android.net.TetheringManager.TETHER_HARDWARE_OFFLOAD_STARTED;
 import static android.net.TetheringManager.TETHER_HARDWARE_OFFLOAD_STOPPED;
@@ -84,10 +85,10 @@ import static com.android.networkstack.tethering.OffloadHardwareInterface.OFFLOA
 import static com.android.networkstack.tethering.TestConnectivityManager.BROADCAST_FIRST;
 import static com.android.networkstack.tethering.TestConnectivityManager.CALLBACKS_FIRST;
 import static com.android.networkstack.tethering.Tethering.UserRestrictionActionListener;
-import static com.android.networkstack.tethering.TetheringConfiguration.TETHERING_LOCAL_NETWORK_AGENT;
 import static com.android.networkstack.tethering.TetheringConfiguration.TETHER_FORCE_USB_FUNCTIONS;
 import static com.android.networkstack.tethering.TetheringConfiguration.TETHER_USB_NCM_FUNCTION;
 import static com.android.networkstack.tethering.TetheringConfiguration.TETHER_USB_RNDIS_FUNCTION;
+import static com.android.networkstack.tethering.TetheringFeatureFlags.TETHERING_LOCAL_NETWORK_AGENT;
 import static com.android.networkstack.tethering.TetheringNotificationUpdater.DOWNSTREAM_NONE;
 import static com.android.networkstack.tethering.UpstreamNetworkMonitor.EVENT_ON_CAPABILITIES;
 import static com.android.testutils.TestPermissionUtil.runAsShell;
@@ -538,8 +539,8 @@ public class TetheringTest {
         public RoutingCoordinatorManager getRoutingCoordinator(
                 final Context context, SharedLog log) {
             ConnectivityManager cm = context.getSystemService(ConnectivityManager.class);
-            when(mPrivateAddressCoordinatorDependencies.isFeatureEnabled(anyString()))
-                    .thenReturn(false);
+            when(mPrivateAddressCoordinatorDependencies.isFeatureNotChickenedOut(anyString()))
+                    .thenReturn(true);
             RoutingCoordinatorService service = new RoutingCoordinatorService(
                     getINetd(context, log),
                             cm::getAllNetworks,
@@ -1007,23 +1008,11 @@ public class TetheringTest {
         }
         sendWifiApStateChanged(WIFI_AP_STATE_ENABLED);
 
-        // If, and only if, Tethering received an interface status changed then
-        // it creates a IpServer and sends out a broadcast indicating that the
-        // interface is "available".
-        if (emulateInterfaceStatusChanged) {
-            if (!SdkLevel.isAtLeastB()) {
-                // There is 1 IpServer state change event: STATE_AVAILABLE
-                verify(mNotificationUpdater, times(1)).onDownstreamChanged(DOWNSTREAM_NONE);
-                verifyTetheringBroadcast(TEST_WLAN_IFNAME, EXTRA_AVAILABLE_TETHER);
-                verify(mWifiManager).updateInterfaceIpState(
-                        TEST_WLAN_IFNAME, WifiManager.IFACE_IP_MODE_UNSPECIFIED);
-            } else {
-                // Starting in B, ignore the interfaceStatusChanged
-                verify(mNotificationUpdater, never()).onDownstreamChanged(DOWNSTREAM_NONE);
-                verify(mWifiManager, never()).updateInterfaceIpState(
-                        TEST_WLAN_IFNAME, WifiManager.IFACE_IP_MODE_UNSPECIFIED);
-            }
-        }
+        // Wi-Fi tethering ignores interface up events. The behaviour is the same
+        // regardless of whether the interface up event was received or not.
+        verify(mNotificationUpdater, never()).onDownstreamChanged(DOWNSTREAM_NONE);
+        verify(mWifiManager, never()).updateInterfaceIpState(
+                TEST_WLAN_IFNAME, WifiManager.IFACE_IP_MODE_UNSPECIFIED);
         verifyNoMoreInteractions(mNetd);
         verifyNoMoreInteractions(mWifiManager);
     }
@@ -2045,18 +2034,10 @@ public class TetheringTest {
         sendWifiApStateChanged(WIFI_AP_STATE_ENABLED);
         mLooper.dispatchAll();
 
-        if (!SdkLevel.isAtLeastB()) {
-            // There is 1 IpServer state change event: STATE_AVAILABLE from interfaceStatusChanged
-            verify(mNotificationUpdater, times(1)).onDownstreamChanged(DOWNSTREAM_NONE);
-            verifyTetheringBroadcast(TEST_WLAN_IFNAME, EXTRA_AVAILABLE_TETHER);
-            verify(mWifiManager).updateInterfaceIpState(
-                    TEST_WLAN_IFNAME, WifiManager.IFACE_IP_MODE_UNSPECIFIED);
-        } else {
-            // Starting in B, ignore the interfaceStatusChanged
-            verify(mNotificationUpdater, never()).onDownstreamChanged(DOWNSTREAM_NONE);
-            verify(mWifiManager, never()).updateInterfaceIpState(
-                    TEST_WLAN_IFNAME, WifiManager.IFACE_IP_MODE_UNSPECIFIED);
-        }
+        // Wi-Fi tethering ignores interface up events.
+        verify(mNotificationUpdater, never()).onDownstreamChanged(DOWNSTREAM_NONE);
+        verify(mWifiManager, never()).updateInterfaceIpState(
+                TEST_WLAN_IFNAME, WifiManager.IFACE_IP_MODE_UNSPECIFIED);
         verifyNoMoreInteractions(mNetd);
         verifyNoMoreInteractions(mWifiManager);
     }
@@ -3311,6 +3292,10 @@ public class TetheringTest {
 
         @Override
         public void onResult(final int resultCode) {
+            if (mHasResult) {
+                fail("Received result: " + resultCode + ", but we already have a result: "
+                        + mExpectedResult);
+            }
             mHasResult = true;
             if (resultCode != mExpectedResult) {
                 fail("expected result: " + mExpectedResult + " but actual result: " + resultCode);
@@ -3333,11 +3318,9 @@ public class TetheringTest {
         final LinkAddress serverLinkAddr = new LinkAddress("192.168.20.1/24");
         final LinkAddress clientLinkAddr = new LinkAddress("192.168.20.42/24");
         final String serverAddr = "192.168.20.1";
-        final ResultListener firstResult = new ResultListener(TETHER_ERROR_NO_ERROR);
-        final ResultListener secondResult = new ResultListener(TETHER_ERROR_NO_ERROR);
-        final ResultListener thirdResult = new ResultListener(TETHER_ERROR_NO_ERROR);
 
         // Enable USB tethering and check that Tethering starts USB.
+        final ResultListener firstResult = new ResultListener(TETHER_ERROR_NO_ERROR);
         mTethering.startTethering(createTetheringRequest(TETHERING_USB), TEST_CALLER_PKG,
                 firstResult);
         mLooper.dispatchAll();
@@ -3346,6 +3329,7 @@ public class TetheringTest {
         verifyNoMoreInteractions(mUsbManager);
 
         // Enable USB tethering again with the same request and expect no change to USB.
+        final ResultListener secondResult = new ResultListener(TETHER_ERROR_NO_ERROR);
         mTethering.startTethering(createTetheringRequest(TETHERING_USB), TEST_CALLER_PKG,
                 secondResult);
         mLooper.dispatchAll();
@@ -3355,22 +3339,24 @@ public class TetheringTest {
 
         // Enable USB tethering again with the same request but different uid/package and expect no
         // change to USB.
+        final ResultListener thirdResult = new ResultListener(TETHER_ERROR_NO_ERROR);
         TetheringRequest differentUidPackage = createTetheringRequest(TETHERING_USB);
         differentUidPackage.setUid(TEST_CALLER_UID_2);
         differentUidPackage.setPackageName(TEST_CALLER_PKG_2);
-        mTethering.startTethering(differentUidPackage, TEST_CALLER_PKG_2, secondResult);
+        mTethering.startTethering(differentUidPackage, TEST_CALLER_PKG_2, thirdResult);
         mLooper.dispatchAll();
-        secondResult.assertHasResult();
+        thirdResult.assertHasResult();
         verify(mUsbManager, never()).setCurrentFunctions(UsbManager.FUNCTION_NONE);
         reset(mUsbManager);
 
         // Enable USB tethering with a different request and expect that USB is stopped and
         // started.
+        final ResultListener fourthResult = new ResultListener(TETHER_ERROR_NO_ERROR);
         mTethering.startTethering(createTetheringRequest(TETHERING_USB,
                   serverLinkAddr, clientLinkAddr, false, CONNECTIVITY_SCOPE_GLOBAL, null),
-                  TEST_CALLER_PKG, thirdResult);
+                  TEST_CALLER_PKG, fourthResult);
         mLooper.dispatchAll();
-        thirdResult.assertHasResult();
+        fourthResult.assertHasResult();
         verify(mUsbManager, times(1)).setCurrentFunctions(UsbManager.FUNCTION_NONE);
         verify(mUsbManager, times(1)).setCurrentFunctions(UsbManager.FUNCTION_RNDIS);
 
@@ -3415,39 +3401,22 @@ public class TetheringTest {
 
     @Test
     @IgnoreAfter(Build.VERSION_CODES.VANILLA_ICE_CREAM)
-    public void testRequestStaticIpLegacyTether() throws Exception {
+    public void testLegacyTetherUnsupported() throws Exception {
         initTetheringOnTestThread();
 
-        // Call startTethering with static ip
-        final LinkAddress serverLinkAddr = new LinkAddress("192.168.0.123/24");
-        final LinkAddress clientLinkAddr = new LinkAddress("192.168.0.42/24");
-        final String serverAddr = "192.168.0.123";
-        final int clientAddrParceled = 0xc0a8002a;
-        final ArgumentCaptor<DhcpServingParamsParcel> dhcpParamsCaptor =
-                ArgumentCaptor.forClass(DhcpServingParamsParcel.class);
-        mTethering.startTethering(createTetheringRequest(TETHERING_WIFI,
-                        serverLinkAddr, clientLinkAddr, false, CONNECTIVITY_SCOPE_GLOBAL, null),
-                TEST_CALLER_PKG, null);
+        mTethering.interfaceAdded(TEST_WIFI_IFNAME);
         mLooper.dispatchAll();
-        verifyWifiTetheringRequested();
-        mTethering.interfaceStatusChanged(TEST_WLAN_IFNAME, true);
+        mTethering.interfaceStatusChanged(TEST_WIFI_IFNAME, false);
+        mTethering.interfaceStatusChanged(TEST_WIFI_IFNAME, true);
 
-        // Call legacyTether on the interface before the link layer event comes back.
-        // This happens, for example, in pre-T bluetooth tethering: Settings calls startTethering,
-        // and then the bluetooth code calls the tether() API.
-        final ResultListener tetherResult = new ResultListener(TETHER_ERROR_NO_ERROR);
-        mTethering.legacyTether(TEST_WLAN_IFNAME, tetherResult);
+        final ResultListener result = new ResultListener(TETHER_ERROR_UNSUPPORTED);
+        mTethering.legacyTether(TEST_WIFI_IFNAME, result);
         mLooper.dispatchAll();
-        tetherResult.assertHasResult();
+        result.assertHasResult();
 
-        // Verify that the static ip set in startTethering is used
-        verify(mNetd).interfaceSetCfg(argThat(cfg -> serverAddr.equals(cfg.ipv4Addr)));
-        verify(mIpServerDependencies, times(1)).makeDhcpServer(any(), dhcpParamsCaptor.capture(),
-                any());
-        final DhcpServingParamsParcel params = dhcpParamsCaptor.getValue();
-        assertEquals(serverAddr, intToInet4AddressHTH(params.serverAddr).getHostAddress());
-        assertEquals(24, params.serverAddrPrefixLength);
-        assertEquals(clientAddrParceled, params.singleClientAddr);
+        // No IpServer should have been started, so no STATE_AVAILABLE should have been sent, and no
+        // tethering broadcasts should have been sent.
+        assertEquals(0, mIntents.size());
     }
 
     @Test
@@ -4024,6 +3993,38 @@ public class TetheringTest {
         verifyNetdCommandForBtTearDown();
     }
 
+    @Test
+    @IgnoreUpTo(Build.VERSION_CODES.S_V2)
+    public void testPendingBluetoothRequestRemovedWhenPanServiceDisconnectsBeforeIfaceAvailable()
+            throws Exception {
+        initTetheringOnTestThread();
+
+        final ResultListener result = new ResultListener(TETHER_ERROR_NO_ERROR);
+        mockBluetoothSettings(true /* bluetoothOn */, true /* tetheringOn */);
+        mTethering.startTethering(createTetheringRequest(TETHERING_BLUETOOTH),
+                TEST_CALLER_PKG, result);
+        mLooper.dispatchAll();
+        ServiceListener serviceListener =
+                verifySetBluetoothTethering(true /* enable */, true /* bindToPanService */);
+        result.assertHasResult();
+
+        // Mock BT turning off
+        serviceListener.onServiceDisconnected(BluetoothProfile.PAN);
+        mLooper.dispatchAll();
+
+        // Pending request should be removed
+        assertTrue(mTethering.getPendingTetheringRequests().isEmpty());
+        // Mock BT tethering started again should succeed
+        final ResultListener result2 = new ResultListener(TETHER_ERROR_NO_ERROR);
+        mockBluetoothSettings(true /* bluetoothOn */, true /* tetheringOn */);
+        mTethering.startTethering(createTetheringRequest(TETHERING_BLUETOOTH),
+                TEST_CALLER_PKG, result2);
+        serviceListener.onServiceConnected(BluetoothProfile.PAN, mBluetoothPan);
+        mLooper.dispatchAll();
+        verifySetBluetoothTethering(true /* enable */, false /* bindToPanService */);
+        result2.assertHasResult();
+    }
+
     @Test
     @IgnoreAfter(Build.VERSION_CODES.S_V2)
     public void testBluetoothTetheringBeforeT() throws Exception {
@@ -4239,7 +4240,7 @@ public class TetheringTest {
         }
         verify(mBluetoothPan).isTetheringOn();
         verifyNoMoreInteractions(mBluetoothAdapter, mBluetoothPan);
-        reset(mBluetoothAdapter, mBluetoothPan);
+        reset(mBluetoothAdapter, mBluetoothPan, mBluetoothPanShim);
 
         return listener;
     }
diff --git a/bpf/dns_helper/DnsBpfHelper.cpp b/bpf/dns_helper/DnsBpfHelper.cpp
index cf2fa2b736..20add47b60 100644
--- a/bpf/dns_helper/DnsBpfHelper.cpp
+++ b/bpf/dns_helper/DnsBpfHelper.cpp
@@ -42,10 +42,16 @@ static inline void waitForNetProgsLoaded() {
   // infinite loop until success with 5/10/20/40/60/60/60... delay
   for (int delay = 5;; delay *= 2) {
     if (delay > 60) delay = 60;
-    if (base::WaitForProperty("init.svc.mdnsd_netbpfload", "stopped", std::chrono::seconds(delay))
-      && mainlineNetBpfLoadDone()) return;
+    if (base::WaitForProperty("init.svc.mdnsd_netbpfload", "stopped", std::chrono::seconds(delay)))
+      break;
     LOG(WARNING) << "Waited " << delay << "s for init.svc.mdnsd_netbpfload=stopped, still waiting.";
   }
+  if (!mainlineNetBpfLoadDone()) {
+    LOG(ERROR) << "FATAL: init.svc.mdnsd_netbpfload=stopped, yet !mainlineNetBpfLoadDone";
+    // mdnsd_netbpfload is marked 'reboot_on_failure', init should start a reboot very soon now,
+    // spamming logs with an abort is pointless
+    for (;;);
+  }
 }
 
 base::Result<void> DnsBpfHelper::init() {
diff --git a/bpf/headers/include/bpf/BpfClassic.h b/bpf/headers/include/bpf/BpfClassic.h
index 26d8ad5dff..0bfe77baee 100644
--- a/bpf/headers/include/bpf/BpfClassic.h
+++ b/bpf/headers/include/bpf/BpfClassic.h
@@ -48,7 +48,7 @@
 	BPF_JUMP(BPF_JMP | BPF_JGT | BPF_K, (v), 0, 1), \
 	BPF_REJECT
 
-// *THREE* instructions: compare and if *NOT* in range [lo, hi], jump over the reject statement
+// *THREE* instructions: compare and if *IN* range [lo, hi] jump over the reject statement
 #define BPF3_REJECT_IF_NOT_IN_RANGE(lo, hi) \
 	BPF_JUMP(BPF_JMP | BPF_JGE | BPF_K, (lo), 0, 1), \
 	BPF_JUMP(BPF_JMP | BPF_JGT | BPF_K, (hi), 0, 1), \
@@ -97,42 +97,42 @@
 #define BPF_LOAD_IPV4_U8(field) \
 	BPF_LOAD_NET_RELATIVE_U8(({ \
 	  _Static_assert(field_sizeof(struct iphdr, field) == 1, "field of wrong size"); \
-	  offsetof(iphdr, field); \
+	  offsetof(struct iphdr, field); \
 	}))
 
 // Big/Network Endian 16-bit load from IPv4 header field.
 #define BPF_LOAD_IPV4_BE16(field) \
 	BPF_LOAD_NET_RELATIVE_BE16(({ \
 	  _Static_assert(field_sizeof(struct iphdr, field) == 2, "field of wrong size"); \
-	  offsetof(iphdr, field); \
+	  offsetof(struct iphdr, field); \
 	}))
 
 // Big/Network Endian 32-bit load from IPv4 header field.
 #define BPF_LOAD_IPV4_BE32(field) \
 	BPF_LOAD_NET_RELATIVE_BE32(({ \
 	  _Static_assert(field_sizeof(struct iphdr, field) == 4, "field of wrong size"); \
-	  offsetof(iphdr, field); \
+	  offsetof(struct iphdr, field); \
 	}))
 
 // 8-bit load from IPv6 header field.
 #define BPF_LOAD_IPV6_U8(field) \
 	BPF_LOAD_NET_RELATIVE_U8(({ \
 	  _Static_assert(field_sizeof(struct ipv6hdr, field) == 1, "field of wrong size"); \
-	  offsetof(ipv6hdr, field); \
+	  offsetof(struct ipv6hdr, field); \
 	}))
 
 // Big/Network Endian 16-bit load from IPv6 header field.
 #define BPF_LOAD_IPV6_BE16(field) \
 	BPF_LOAD_NET_RELATIVE_BE16(({ \
 	  _Static_assert(field_sizeof(struct ipv6hdr, field) == 2, "field of wrong size"); \
-	  offsetof(ipv6hdr, field); \
+	  offsetof(struct ipv6hdr, field); \
 	}))
 
 // Big/Network Endian 32-bit load from IPv6 header field.
 #define BPF_LOAD_IPV6_BE32(field) \
 	BPF_LOAD_NET_RELATIVE_BE32(({ \
 	  _Static_assert(field_sizeof(struct ipv6hdr, field) == 4, "field of wrong size"); \
-	  offsetof(ipv6hdr, field); \
+	  offsetof(struct ipv6hdr, field); \
 	}))
 
 // Load the length of the IPv4 header into X index register.
diff --git a/bpf/headers/include/bpf/BpfUtils.h b/bpf/headers/include/bpf/BpfUtils.h
index ed08e1afe0..85502ecbd5 100644
--- a/bpf/headers/include/bpf/BpfUtils.h
+++ b/bpf/headers/include/bpf/BpfUtils.h
@@ -42,7 +42,11 @@ const bool isAtLeastS = (api_level >= 31);
 const bool isAtLeastT = (api_level >= 33);
 const bool isAtLeastU = (api_level >= 34);
 const bool isAtLeastV = (api_level >= 35);
-const bool isAtLeast25Q2 = (api_level >= 36);
+const bool isAtLeast25Q2 = (api_level >= 36); // 36.0
+const bool isAtLeast25Q3 = (api_level > 36);  // 36.0+ (TODO: fix this!)
+const bool isAtLeast25Q4 = false;  // 36.1
+const bool isAtLeast26Q1 = false;  // 36.1+
+const bool isAtLeast26Q2 = false;  // 37.0
 
 // See kernel's net/core/sock_diag.c __sock_gen_cookie()
 // the implementation of which guarantees 0 will never be returned,
diff --git a/bpf/headers/include/bpf_helpers.h b/bpf/headers/include/bpf_helpers.h
index 9d6b6f6920..2242daf378 100644
--- a/bpf/headers/include/bpf_helpers.h
+++ b/bpf/headers/include/bpf_helpers.h
@@ -62,9 +62,21 @@
 // Android Mainline BpfLoader when running on Android V (sdk=35)
 #define BPFLOADER_MAINLINE_V_VERSION (BPFLOADER_MAINLINE_U_QPR3_VERSION + 1u)
 
-// Android Mainline BpfLoader when running on Android 25Q2 (sdk=36)
+// Android Mainline BpfLoader when running on Android 25Q2 (sdk=36 aka 36.0)
 #define BPFLOADER_MAINLINE_25Q2_VERSION (BPFLOADER_MAINLINE_V_VERSION + 1u)
 
+// Android Mainline BpfLoader when running on Android 25Q3 (sdk 36.0+)
+#define BPFLOADER_MAINLINE_25Q3_VERSION (BPFLOADER_MAINLINE_25Q2_VERSION + 1u)
+
+// Android Mainline BpfLoader when running on Android 25Q4 (sdk 36.1)
+#define BPFLOADER_MAINLINE_25Q4_VERSION (BPFLOADER_MAINLINE_25Q3_VERSION + 1u)
+
+// Android Mainline BpfLoader when running on Android 26Q1 (sdk 36.1+)
+#define BPFLOADER_MAINLINE_26Q1_VERSION (BPFLOADER_MAINLINE_25Q4_VERSION + 1u)
+
+// Android Mainline BpfLoader when running on Android 26Q2 (sdk 37.0)
+#define BPFLOADER_MAINLINE_26Q2_VERSION (BPFLOADER_MAINLINE_26Q1_VERSION + 1u)
+
 /* For mainline module use, you can #define BPFLOADER_{MIN/MAX}_VER
  * before #include "bpf_helpers.h" to change which bpfloaders will
  * process the resulting .o file.
@@ -143,22 +155,45 @@ struct kver_uint { unsigned int kver; };
 
 // Helpers for writing sdk level specific bpf programs
 //
-// Note: we choose to follow sdk api level values, but there is no real need for this:
-// These just need to be monotonically increasing.  We could also use values ten or even
-// a hundred times larger to leave room for quarters or months.  We may also just use
-// dates or something (2502 or 202506 for 25Q2) or even the mainline bpfloader version...
+// Note: we choose to follow 'ro.build.version.sdk_full'
+// (or just 'sdk' if 'sdk_full' is not available) values,
+// multiplied by 100, with 1 added per QPR.
+// This will (eventually) match our bpfloader versioning scheme.
+//
+// This is just for ease of use, really these are only
+// ever compared to each other, so they only need to be
+// monotonically increasing.
+//
 // For now this easily suffices for our use case.
+//
+// Note: 24Q1 is the first trunk stable release,
+// and thus where quarters start possibly mattering.
+//
+// We leave most of these as commented out documentation,
+// as it's probably a bad idea to actually use them.
 
 struct sdk_level_uint { unsigned int sdk_level; };
 #define SDK_LEVEL_(v) ((struct sdk_level_uint){ .sdk_level = (v) })
-#define SDK_LEVEL_NONE SDK_LEVEL_(0)
-#define SDK_LEVEL_S    SDK_LEVEL_(31) // Android 12
-#define SDK_LEVEL_Sv2  SDK_LEVEL_(32) // Android 12L
-#define SDK_LEVEL_T    SDK_LEVEL_(33) // Android 13
-#define SDK_LEVEL_U    SDK_LEVEL_(34) // Android 14
-#define SDK_LEVEL_V    SDK_LEVEL_(35) // Android 15
-#define SDK_LEVEL_24Q3 SDK_LEVEL_V
-#define SDK_LEVEL_25Q2 SDK_LEVEL_(36) // Android 16
+//      SDK_LEVEL_NONE   SDK_LEVEL_(0)    // mainline implies S+
+#define SDK_LEVEL_S      SDK_LEVEL_(3100) // Android 12     [31]
+//      SDK_LEVEL_Sv2    SDK_LEVEL_(3200) // Android 12L    [32]
+#define SDK_LEVEL_T      SDK_LEVEL_(3300) // Android 13     [33]
+#define SDK_LEVEL_U      SDK_LEVEL_(3400) // Android 14/U   [34]
+//      SDK_LEVEL_U_QPR1 SDK_LEVEL_(3401) // Android 14/U QPR1
+//      SDK_LEVEL_24Q1   SDK_LEVEL_(3402) // Android 14/U QPR2
+//      SDK_LEVEL_24Q2   SDK_LEVEL_(3403) // Android 14/U QPR3
+#define SDK_LEVEL_24Q3   SDK_LEVEL_(3500) // Android 15/V   [35]
+//      SDK_LEVEL_24Q4   SDK_LEVEL_(3501) // Android 15/V QPR1
+//      SDK_LEVEL_25Q1   SDK_LEVEL_(3502) // Android 15/V QPR2
+#define SDK_LEVEL_25Q2   SDK_LEVEL_(3600) // Android 16 (B) [36.0]
+//      SDK_LEVEL_25Q3   SDK_LEVEL_(3601) // Android 16 QPR
+#define SDK_LEVEL_25Q4   SDK_LEVEL_(3610) // Android 16.1   [36.1]
+//      SDK_LEVEL_26Q1   SDK_LEVEL_(3611) // Android 16.1 QPR
+#define SDK_LEVEL_26Q2   SDK_LEVEL_(3700) // Android 17 (C) [37.0]
+//      SDK_LEVEL_26Q3   SDK_LEVEL_(3701) // Android 17 QPR
+#define SDK_LEVEL_26Q4   SDK_LEVEL_(3710) // Android 17.1   [37.1]
+//      SDK_LEVEL_27Q1   SDK_LEVEL_(3711) // Android 17.1 QPR
+#define SDK_LEVEL_27Q2   SDK_LEVEL_(3800) // Android 18     [38.0]
 
 #define SDK_LEVEL_IS_AT_LEAST(lvl, v) ((lvl).sdk_level >= (SDK_LEVEL_##v).sdk_level)
 
@@ -236,6 +271,11 @@ static void* (*bpf_ringbuf_reserve_unsafe)(const struct bpf_map_def* ringbuf,
         BPF_FUNC_ringbuf_reserve;
 static void (*bpf_ringbuf_submit_unsafe)(const void* data, __u64 flags) = (void*)
         BPF_FUNC_ringbuf_submit;
+static void* (*bpf_sk_storage_get_unsafe) (const struct bpf_map_def* sk_storage, const void* sk,
+                                           const void* value, unsigned long long flags) = (void*)
+        BPF_FUNC_sk_storage_get;
+static int (*bpf_sk_storage_delete_unsafe) (const struct bpf_map_def* sk_storage,
+                                            const void* sk) = (void*) BPF_FUNC_sk_storage_delete;
 
 #define BPF_ANNOTATE_KV_PAIR(name, type_key, type_val)  \
         struct ____btf_map_##name {                     \
@@ -246,20 +286,13 @@ static void (*bpf_ringbuf_submit_unsafe)(const void* data, __u64 flags) = (void*
         __attribute__ ((section(".maps." #name), used)) \
                 ____btf_map_##name = { }
 
-#define BPF_ASSERT_LOADER_VERSION(min_loader, ignore_eng, ignore_user, ignore_userdebug) \
-    _Static_assert(                                                                      \
-        (min_loader) >= BPFLOADER_IGNORED_ON_VERSION ||                                  \
-            !((ignore_eng).ignore_on_eng ||                                              \
-              (ignore_user).ignore_on_user ||                                            \
-              (ignore_userdebug).ignore_on_userdebug),                                   \
-        "bpfloader min version must be >= 0.33 in order to use ignored_on");
-
 #define ABSOLUTE(x) ((x) < 0 ? -(x) : (x))
 
-#define DEFAULT_BPF_MAP_FLAGS(type, num_entries, mapflags)    \
-    ( (mapflags) |                                            \
-      ((num_entries) < 0 ? BPF_F_NO_PREALLOC : 0) |           \
-      (type == BPF_MAP_TYPE_LPM_TRIE ? BPF_F_NO_PREALLOC : 0) \
+#define DEFAULT_BPF_MAP_FLAGS(type, num_entries, mapflags)         \
+    ( (mapflags) |                                                 \
+      ((num_entries) < 0 ? BPF_F_NO_PREALLOC : 0) |                \
+      ( (type == BPF_MAP_TYPE_LPM_TRIE ||                          \
+         type == BPF_MAP_TYPE_SK_STORAGE) ? BPF_F_NO_PREALLOC : 0) \
     )
 
 #define DEFINE_BPF_MAP_BASE(the_map, TYPE, keysize, valuesize, num_entries, \
@@ -282,11 +315,7 @@ static void (*bpf_ringbuf_submit_unsafe)(const void* data, __u64 flags) = (void*
         .selinux_context = (selinux),                                       \
         .pin_subdir = (pindir),                                             \
         .shared = (share).shared,                                           \
-        .ignore_on_eng = (ignore_eng).ignore_on_eng,                        \
-        .ignore_on_user = (ignore_user).ignore_on_user,                     \
-        .ignore_on_userdebug = (ignore_userdebug).ignore_on_userdebug,      \
-    };                                                                      \
-    BPF_ASSERT_LOADER_VERSION(minloader, ignore_eng, ignore_user, ignore_userdebug);
+    };
 
 // Type safe macro to declare a ring buffer and related output functions.
 // Compatibility:
@@ -329,6 +358,34 @@ static void (*bpf_ringbuf_submit_unsafe)(const void* data, __u64 flags) = (void*
                            PRIVATE, BPFLOADER_MIN_VER, BPFLOADER_MAX_VER,               \
                            LOAD_ON_ENG, LOAD_ON_USER, LOAD_ON_USERDEBUG)
 
+// Type safe macro to declare a sk storage and related accessor functions.
+// BPF_MAP_TYPE_SK_STORAGE was introduced in kernel 5.2 but this map requires BTF and
+// BTF is enabled on kernel 5.10 or higher.
+#define DEFINE_BPF_SK_STORAGE_EXT(the_map, ValueType, usr, grp, md, selinux, pindir,    \
+                                  share, min_loader, max_loader, ignore_eng,            \
+                                  ignore_user, ignore_userdebug, mapFlags)              \
+    DEFINE_BPF_MAP_BASE(the_map, SK_STORAGE, sizeof(uint32_t), sizeof(ValueType),       \
+                        0, usr, grp, md, selinux, pindir, share,                        \
+                        KVER_5_10, KVER_INF, min_loader, max_loader,                    \
+                        ignore_eng, ignore_user, ignore_userdebug, mapFlags);           \
+    BPF_ANNOTATE_KV_PAIR(the_map, uint32_t, ValueType);                                 \
+                                                                                        \
+    static inline __always_inline __unused ValueType* bpf_##the_map##_get(              \
+            const struct bpf_sock* sk, const ValueType* v, unsigned long long flags) {  \
+        return bpf_sk_storage_get_unsafe(&the_map, sk, v, flags);                       \
+    };                                                                                  \
+                                                                                        \
+    static inline __always_inline __unused int bpf_##the_map##_delete(                  \
+            const struct bpf_sock* sk) {                                                \
+        return bpf_sk_storage_delete_unsafe(&the_map, sk);                              \
+    };
+
+#define DEFINE_BPF_SK_STORAGE(the_map, TypeOfValue)                                      \
+    DEFINE_BPF_SK_STORAGE_EXT(the_map, TypeOfValue,                                      \
+                              AID_ROOT, AID_NET_BW_ACCT, 0060, "fs_bpf_net_shared", "",  \
+                              PRIVATE, BPFLOADER_MIN_VER, BPFLOADER_MAX_VER,             \
+                              LOAD_ON_ENG, LOAD_ON_USER, LOAD_ON_USERDEBUG, 0)
+
 /* There exist buggy kernels with pre-T OS, that due to
  * kernel patch "[ALPS05162612] bpf: fix ubsan error"
  * do not support userspace writes into non-zero index of bpf map arrays.
@@ -473,9 +530,6 @@ static int (*bpf_trace_printk)(const char* fmt, int fmt_size, ...) = (void*) BPF
         .bpfloader_max_ver = (max_loader),                                               \
         .selinux_context = (selinux),                                                    \
         .pin_subdir = (pindir),                                                          \
-        .ignore_on_eng = (ignore_eng).ignore_on_eng,                                     \
-        .ignore_on_user = (ignore_user).ignore_on_user,                                  \
-        .ignore_on_userdebug = (ignore_userdebug).ignore_on_userdebug,                   \
     };                                                                                   \
     SECTION(SECTION_NAME)                                                                \
     int the_prog
diff --git a/bpf/headers/include/bpf_map_def.h b/bpf/headers/include/bpf_map_def.h
index 2e5afca97b..c98f40b4ea 100644
--- a/bpf/headers/include/bpf_map_def.h
+++ b/bpf/headers/include/bpf_map_def.h
@@ -117,25 +117,22 @@ _Static_assert(_Alignof(unsigned long long) == 8, "_Alignof unsigned long long !
 // for maps:
 struct shared_bool { bool shared; };
 #define PRIVATE ((struct shared_bool){ .shared = false })
-#define SHARED ((struct shared_bool){ .shared = true })
+//#define SHARED ((struct shared_bool){ .shared = true })
 
 // for programs:
 struct optional_bool { bool optional; };
 #define MANDATORY ((struct optional_bool){ .optional = false })
 #define OPTIONAL ((struct optional_bool){ .optional = true })
 
-// for both maps and programs:
-struct ignore_on_eng_bool { bool ignore_on_eng; };
-#define LOAD_ON_ENG ((struct ignore_on_eng_bool){ .ignore_on_eng = false })
-#define IGNORE_ON_ENG ((struct ignore_on_eng_bool){ .ignore_on_eng = true })
+// (deprecated) for both maps and programs:
+struct ignore_on_eng_bool { };
+#define LOAD_ON_ENG ((struct ignore_on_eng_bool){ })
 
-struct ignore_on_user_bool { bool ignore_on_user; };
-#define LOAD_ON_USER ((struct ignore_on_user_bool){ .ignore_on_user = false })
-#define IGNORE_ON_USER ((struct ignore_on_user_bool){ .ignore_on_user = true })
+struct ignore_on_user_bool { };
+#define LOAD_ON_USER ((struct ignore_on_user_bool){ })
 
-struct ignore_on_userdebug_bool { bool ignore_on_userdebug; };
-#define LOAD_ON_USERDEBUG ((struct ignore_on_userdebug_bool){ .ignore_on_userdebug = false })
-#define IGNORE_ON_USERDEBUG ((struct ignore_on_userdebug_bool){ .ignore_on_userdebug = true })
+struct ignore_on_userdebug_bool { };
+#define LOAD_ON_USERDEBUG ((struct ignore_on_userdebug_bool){ })
 
 
 // Length of strings (incl. selinux_context and pin_subdir)
@@ -198,21 +195,7 @@ struct bpf_map_def {
 
     bool shared;  // use empty string as 'file' component of pin path - allows cross .o map sharing
 
-    // The following 3 ignore_on_* fields were added in version 0.32 (U). These are ignored in
-    // older bpfloader versions, and zero in programs compiled before 0.32.
-    bool ignore_on_eng:1;
-    bool ignore_on_user:1;
-    bool ignore_on_userdebug:1;
-    // The following 5 ignore_on_* fields were added in version 0.38 (U). These are ignored in
-    // older bpfloader versions, and zero in programs compiled before 0.38.
-    // These are tests on the kernel architecture, ie. they ignore userspace bit-ness.
-    bool ignore_on_arm32:1;
-    bool ignore_on_aarch64:1;
-    bool ignore_on_x86_32:1;
-    bool ignore_on_x86_64:1;
-    bool ignore_on_riscv64:1;
-
-    char pad0[2];  // manually pad up to 4 byte alignment, may be used for extensions in the future
+    char pad0[3];  // manually pad up to 4 byte alignment, may be used for extensions in the future
 
     unsigned int uid;   // uid_t
 };
@@ -235,21 +218,7 @@ struct bpf_prog_def {
 
     bool optional;  // program section (ie. function) may fail to load, continue onto next func.
 
-    // The following 3 ignore_on_* fields were added in version 0.33 (U). These are ignored in
-    // older bpfloader versions, and zero in programs compiled before 0.33.
-    bool ignore_on_eng:1;
-    bool ignore_on_user:1;
-    bool ignore_on_userdebug:1;
-    // The following 5 ignore_on_* fields were added in version 0.38 (U). These are ignored in
-    // older bpfloader versions, and zero in programs compiled before 0.38.
-    // These are tests on the kernel architecture, ie. they ignore userspace bit-ness.
-    bool ignore_on_arm32:1;
-    bool ignore_on_aarch64:1;
-    bool ignore_on_x86_32:1;
-    bool ignore_on_x86_64:1;
-    bool ignore_on_riscv64:1;
-
-    char pad0[2];  // manually pad up to 4 byte alignment, may be used for extensions in the future
+    char pad0[3];  // manually pad up to 4 byte alignment, may be used for extensions in the future
 
     // The following fields were added in version 0.1
     unsigned int bpfloader_min_ver;  // if missing, defaults to 0, ie. v0.0
diff --git a/bpf/loader/NetBpfLoad.cpp b/bpf/loader/NetBpfLoad.cpp
index bdc2e8c609..c61aec34a1 100644
--- a/bpf/loader/NetBpfLoad.cpp
+++ b/bpf/loader/NetBpfLoad.cpp
@@ -16,6 +16,7 @@
 
 #define LOG_TAG "NetBpfLoad"
 
+#include <algorithm>
 #include <arpa/inet.h>
 #include <bpf/btf.h>
 #include <bpf/libbpf.h>
@@ -122,12 +123,6 @@ static constexpr bool specified(domain d) {
     return d != domain::unspecified;
 }
 
-struct Location {
-    const char* const dir = "";
-    const char* const prefix = "";
-    const bool t_plus = true;
-};
-
 // Returns the build type string (from ro.build.type).
 const std::string& getBuildType() {
     static std::string t = GetProperty("ro.build.type", "unknown");
@@ -644,10 +639,11 @@ static bool mapMatchesExpectations(const unique_fd& fd, const string& mapName,
         return true;
     }
 
-    ALOGE("bpf map name %s mismatch: desired/found: "
+    ALOGE("bpf map name %s mismatch: desired/found (errno: %d): "
           "type:%d/%d key:%u/%d value:%u/%d entries:%u/%d flags:%u/%d",
-          mapName.c_str(), type, fd_type, mapDef.key_size, fd_key_size, mapDef.value_size,
-          fd_value_size, mapDef.max_entries, fd_max_entries, desired_map_flags, fd_map_flags);
+          mapName.c_str(), errno, type, fd_type, mapDef.key_size, fd_key_size,
+          mapDef.value_size, fd_value_size, mapDef.max_entries, fd_max_entries,
+          desired_map_flags, fd_map_flags);
     return false;
 }
 
@@ -857,7 +853,7 @@ static int createMaps(const char* elfPath, ifstream& elfFile, vector<unique_fd>&
     if (ret) return ret;
 
     struct btf *btf = NULL;
-    auto scopeGuard = base::make_scope_guard([btf] { if (btf) btf__free(btf); });
+    auto btfGuard = base::make_scope_guard([&btf] { if (btf) btf__free(btf); });
     if (isAtLeastKernelVersion(5, 10, 0)) {
         // Untested on Linux Kernel 5.4, but likely compatible.
         // On Linux Kernels older than 4.18 BPF_BTF_LOAD command doesn't exist.
@@ -910,25 +906,6 @@ static int createMaps(const char* elfPath, ifstream& elfFile, vector<unique_fd>&
             continue;
         }
 
-        if ((md[i].ignore_on_eng && isEng()) || (md[i].ignore_on_user && isUser()) ||
-            (md[i].ignore_on_userdebug && isUserdebug())) {
-            ALOGD("skipping map %s which is ignored on %s builds", mapNames[i].c_str(),
-                  getBuildType().c_str());
-            mapFds.push_back(unique_fd());
-            continue;
-        }
-
-        if ((isArm() && isKernel32Bit() && md[i].ignore_on_arm32) ||
-            (isArm() && isKernel64Bit() && md[i].ignore_on_aarch64) ||
-            (isX86() && isKernel32Bit() && md[i].ignore_on_x86_32) ||
-            (isX86() && isKernel64Bit() && md[i].ignore_on_x86_64) ||
-            (isRiscV() && md[i].ignore_on_riscv64)) {
-            ALOGD("skipping map %s which is ignored on %s", mapNames[i].c_str(),
-                  describeArch());
-            mapFds.push_back(unique_fd());
-            continue;
-        }
-
         enum bpf_map_type type = md[i].type;
         if (type == BPF_MAP_TYPE_LPM_TRIE && !isAtLeastKernelVersion(4, 14, 0)) {
             // On Linux Kernels older than 4.14 this map type doesn't exist - autoskip.
@@ -976,6 +953,7 @@ static int createMaps(const char* elfPath, ifstream& elfFile, vector<unique_fd>&
         if (specified(pin_subdir)) {
             ALOGV("map %s pin_subdir [%-32s] -> %d -> '%s'", mapNames[i].c_str(), md[i].pin_subdir,
                   static_cast<int>(pin_subdir), lookupPinSubdir(pin_subdir));
+            abort();
         }
 
         // Format of pin location is /sys/fs/bpf/<pin_subdir|prefix>map_<objName>_<mapName>
@@ -992,6 +970,7 @@ static int createMaps(const char* elfPath, ifstream& elfFile, vector<unique_fd>&
             saved_errno = errno;
             ALOGD("bpf_create_map reusing map %s, ret: %d", mapNames[i].c_str(), fd.get());
             reuse = true;
+            abort();
         } else {
             union bpf_attr req = {
               .map_type = type,
@@ -1181,23 +1160,6 @@ static int loadCodeSections(const char* elfPath, vector<codeSection>& cs, const
         if (bpfloader_ver < bpfMinVer) continue;
         if (bpfloader_ver >= bpfMaxVer) continue;
 
-        if ((cs[i].prog_def->ignore_on_eng && isEng()) ||
-            (cs[i].prog_def->ignore_on_user && isUser()) ||
-            (cs[i].prog_def->ignore_on_userdebug && isUserdebug())) {
-            ALOGD("cs[%d].name:%s is ignored on %s builds", i, name.c_str(),
-                  getBuildType().c_str());
-            continue;
-        }
-
-        if ((isArm() && isKernel32Bit() && cs[i].prog_def->ignore_on_arm32) ||
-            (isArm() && isKernel64Bit() && cs[i].prog_def->ignore_on_aarch64) ||
-            (isX86() && isKernel32Bit() && cs[i].prog_def->ignore_on_x86_32) ||
-            (isX86() && isKernel64Bit() && cs[i].prog_def->ignore_on_x86_64) ||
-            (isRiscV() && cs[i].prog_def->ignore_on_riscv64)) {
-            ALOGD("cs[%d].name:%s is ignored on %s", i, name.c_str(), describeArch());
-            continue;
-        }
-
         if (specified(selinux_context)) {
             ALOGV("prog %s selinux_context [%-32s] -> %d -> '%s' (%s)", name.c_str(),
                   cs[i].prog_def->selinux_context, static_cast<int>(selinux_context),
@@ -1208,6 +1170,7 @@ static int loadCodeSections(const char* elfPath, vector<codeSection>& cs, const
             ALOGV("prog %s pin_subdir [%-32s] -> %d -> '%s'", name.c_str(),
                   cs[i].prog_def->pin_subdir, static_cast<int>(pin_subdir),
                   lookupPinSubdir(pin_subdir));
+            abort();
         }
 
         // strip any potential $foo suffix
@@ -1399,10 +1362,7 @@ int loadProg(const char* const elfPath, const unsigned int bpfloader_ver,
         ALOGV("map_fd found at %d is %d in %s", i, mapFds[i].get(), elfPath);
 
     ret = readCodeSections(elfFile, cs);
-    // BPF .o's with no programs are only supported by mainline netbpfload,
-    // make sure .o's targeting non-mainline (ie. S) bpfloader don't show up.
-    if (ret == -ENOENT && bpfLoaderMinVer >= BPFLOADER_MAINLINE_S_VERSION)
-        return 0;
+    if (ret == -ENOENT) return 0;
     if (ret) {
         ALOGE("Couldn't read all code sections in %s", elfPath);
         return ret;
@@ -1425,82 +1385,59 @@ static bool exists(const char* const path) {
 }
 
 #define APEXROOT "/apex/com.android.tethering"
-#define BPFROOT APEXROOT "/etc/bpf"
-
-const Location locations[] = {
-        // S+ Tethering mainline module (network_stack): tether offload
-        {
-                .dir = BPFROOT "/tethering/",
-                .prefix = "tethering/",
-                .t_plus = false,
-        },
-        // T+ Tethering mainline module (shared with netd & system server)
-        // netutils_wrapper (for iptables xt_bpf) has access to programs
-        {
-                .dir = BPFROOT "/netd_shared/",
-                .prefix = "netd_shared/",
-        },
-        // T+ Tethering mainline module (shared with netd & system server)
-        // netutils_wrapper has no access, netd has read only access
-        {
-                .dir = BPFROOT "/netd_readonly/",
-                .prefix = "netd_readonly/",
-        },
-        // T+ Tethering mainline module (shared with system server)
-        {
-                .dir = BPFROOT "/net_shared/",
-                .prefix = "net_shared/",
-        },
-        // T+ Tethering mainline module (not shared, just network_stack)
-        {
-                .dir = BPFROOT "/net_private/",
-                .prefix = "net_private/",
-        },
-};
+#define BPFROOT APEXROOT "/etc/bpf/mainline/"
 
-static int loadAllElfObjects(const unsigned int bpfloader_ver, const Location& location) {
-    int retVal = 0;
-    DIR* dir;
-    struct dirent* ent;
+static int loadObject(const unsigned int bpfloader_ver, const char* const prefix,
+                      const char* const fname) {
+    string progPath = string(BPFROOT) + fname;
+    int ret = loadProg(progPath.c_str(), bpfloader_ver, prefix);
+    if (ret) {
+        ALOGE("Failed to load object: %s, ret: %s", progPath.c_str(), std::strerror(-ret));
+        return 1;
+    }
+    ALOGD("Loaded object: %s", progPath.c_str());
+    return 0;
+}
 
-    if ((dir = opendir(location.dir)) != NULL) {
-        while ((ent = readdir(dir)) != NULL) {
-            string s = ent->d_name;
-            if (!EndsWith(s, ".o")) continue;
+static int loadAllObjects(const unsigned int bpfloader_ver) {
+    // S+ Tethering mainline module (network_stack): tether offload
+    // loads under /sys/fs/bpf/tethering:
+    if (loadObject(bpfloader_ver, "tethering/", "offload.o")) return 1;
+    if (loadObject(bpfloader_ver, "tethering/", "test.o")) return 1;
+    if (isAtLeastT) {
+        // T+ Tethering mainline module loads under:
+        // /sys/fs/bpf/net_shared: shared with netd & system server
+        if (loadObject(bpfloader_ver, "net_shared/", "clatd.o")) return 1;
+        if (loadObject(bpfloader_ver, "net_shared/", "dscpPolicy.o")) return 1;
 
-            string progPath(location.dir);
-            progPath += s;
+        // /sys/fs/bpf/netd_shared: shared with netd & system server
+        // - netutils_wrapper (for iptables xt_bpf) has access to programs
 
-            int ret = loadProg(progPath.c_str(), bpfloader_ver, location.prefix);
-            if (ret) {
-                retVal = ret;
-                ALOGE("Failed to load object: %s, ret: %s", progPath.c_str(), std::strerror(-ret));
-            } else {
-                ALOGD("Loaded object: %s", progPath.c_str());
-            }
-        }
-        closedir(dir);
-    }
-    return retVal;
-}
+        // WARNING: Android T+ non-updatable netd depends on both of the
+        // 'netd_shared' & 'netd' strings for xt_bpf programs it loads
+        if (loadObject(bpfloader_ver, "netd_shared/", "netd.o")) return 1;
 
-static int createSysFsBpfSubDir(const char* const prefix) {
-    if (*prefix) {
-        mode_t prevUmask = umask(0);
+        // /sys/fs/bpf/netd_readonly: shared with netd & system server
+        // - netutils_wrapper has no access, netd has read only access
 
-        string s = "/sys/fs/bpf/";
-        s += prefix;
+        // /sys/fs/bpf/net_private: not shared, just network_stack
+    }
+    return 0;
+}
 
-        errno = 0;
-        int ret = mkdir(s.c_str(), S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO);
-        if (ret && errno != EEXIST) {
-            const int err = errno;
-            ALOGE("Failed to create directory: %s, ret: %s", s.c_str(), std::strerror(err));
-            return -err;
-        }
+static int createDir(const char* const dir) {
+    mode_t prevUmask = umask(0);
 
+    errno = 0;
+    int ret = mkdir(dir, S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO);
+    if (ret && errno != EEXIST) {
+        const int err = errno;
         umask(prevUmask);
+        ALOGE("Failed to create directory: %s, ret: %s", dir, std::strerror(err));
+        return -err;
     }
+
+    umask(prevUmask);
     return 0;
 }
 
@@ -1674,6 +1611,10 @@ static int doLoad(char** argv, char * const envp[]) {
     if (runningAsRoot) ++bpfloader_ver;  // [45] BPFLOADER_MAINLINE_U_QPR3_VERSION
     if (isAtLeastV) ++bpfloader_ver;     // [46] BPFLOADER_MAINLINE_V_VERSION
     if (isAtLeast25Q2) ++bpfloader_ver;  // [47] BPFLOADER_MAINLINE_25Q2_VERSION
+    if (isAtLeast25Q3) ++bpfloader_ver;  // [48] BPFLOADER_MAINLINE_25Q3_VERSION
+    if (isAtLeast25Q4) ++bpfloader_ver;  // [49] BPFLOADER_MAINLINE_25Q4_VERSION
+    if (isAtLeast26Q1) ++bpfloader_ver;  // [50] BPFLOADER_MAINLINE_26Q1_VERSION
+    if (isAtLeast26Q2) ++bpfloader_ver;  // [51] BPFLOADER_MAINLINE_26Q2_VERSION
 
     ALOGI("NetBpfLoad v0.%u (%s) api:%d/%d kver:%07x (%s) libbpf: v%u.%u "
           "uid:%d rc:%d%d",
@@ -1720,6 +1661,13 @@ static int doLoad(char** argv, char * const envp[]) {
         return 1;
     }
 
+    // 25Q4 bumps the kernel requirement up to 5.10
+    // see also: //system/netd/tests/kernel_test.cpp TestKernel510
+    if (isAtLeast25Q4 && !isAtLeastKernelVersion(5, 10, 0)) {
+        ALOGE("Android 25Q4 requires kernel 5.10.");
+        return 1;
+    }
+
     // Technically already required by U, but only enforce on V+
     // see also: //system/netd/tests/kernel_test.cpp TestKernel64Bit
     if (isAtLeastV && isKernel32Bit() && isAtLeastKernelVersion(5, 16, 0)) {
@@ -1816,9 +1764,16 @@ static int doLoad(char** argv, char * const envp[]) {
         }
     }
 
-    // On handheld, 6.6 is highest version supported by Android V (sdk=35), so this is for sdk=36+
-    if (!isArm() && isUserspace32bit() && isAtLeastKernelVersion(6, 7, 0)) {
-        ALOGE("64-bit userspace required on 6.7+ kernels.");
+    // Linux 6.12 was an LTS released at the end of 2024 (Nov 17),
+    // and was first supported by Android 16 / 25Q2 (released in June 2025).
+    // The next Linux LTS should be released near the end of 2025,
+    // and will likely be 6.18.
+    // Since officially Android only supports LTS, 6.13+ really means 6.18+,
+    // and won't be supported before 2026, most likely Android 17 / 26Q2.
+    // 6.13+ (implying 26Q2+) requires 64-bit userspace.
+    if (isUserspace32bit() && isAtLeastKernelVersion(6, 13, 0)) {
+        // due to previous check only reachable on Arm && (<=T kernel uprev || TV || Wear)
+        ALOGE("64-bit userspace required on 6.13+ kernels.");
         return 1;
     }
 
@@ -1832,7 +1787,12 @@ static int doLoad(char** argv, char * const envp[]) {
         int v = fscanf(f, "# %d %d %d %d %d #", &y, &q, &a, &b, &c);
         ALOGI("detected %d of 5: %dQ%d api:%d.%d.%d", v, y, q, a, b, c);
         fclose(f);
-        if (v != 5 || y != 2025 || q != 2 || a != 36 || b || c) return 1;
+        if (v != 5) return 1;
+        if (y < 2025 || y > 2099) return 1;
+        if (q < 1 || q > 4) return 1;
+        if (a < 36) return 1;
+        if (b < 0 || b > 4) return 1;
+        if (c < 0) return 1;
     }
 
     // Ensure we can determine the Android build type.
@@ -1873,36 +1833,76 @@ static int doLoad(char** argv, char * const envp[]) {
         if (writeProcSysFile("/proc/sys/net/core/bpf_jit_kallsyms", "1\n")) return 1;
     }
 
+    if (runningAsRoot) {  // implies U QPR3+ and kernel 4.14+
+        // There should not be any programs or maps yet
+        errno = 0;
+        uint32_t progId = bpfGetNextProgId(0);  // expect 0 with errno == ENOENT
+        if (progId || errno != ENOENT) {
+            ALOGE("bpfGetNextProgId(zero) returned %u (errno %d)", progId, errno);
+            return 1;
+        }
+        errno = 0;
+        uint32_t mapId = bpfGetNextMapId(0);  // expect 0 with errno == ENOENT
+        if (mapId || errno != ENOENT) {
+            ALOGE("bpfGetNextMapId(zero) returned %u (errno %d)", mapId, errno);
+            return 1;
+        }
+    } else if (isAtLeastKernelVersion(4, 14, 0)) {  // implies S through U QPR2
+        // bpfGetNext{Prog,Map}Id require 4.14+
+        // furthermore since we're not running as root, we're not the initial
+        // platform bpfloader, so there may already be some maps & programs.
+        uint32_t mapId = 0;
+        while (true) {
+            errno = 0;
+            uint32_t next = bpfGetNextMapId(mapId);
+            if (!next && errno == ENOENT) break;
+            if (next <= mapId) {
+                ALOGE("bpfGetNextMapId(%u) returned %u errno %d", mapId, next, errno);
+                return 1;
+            }
+            mapId = next;
+        }
+        // mapId is now the last map id, creating a new map should change that
+        unique_fd map(createMap(BPF_MAP_TYPE_ARRAY, sizeof(int), sizeof(int), 1, 0));
+        errno = 0;
+        uint32_t next = bpfGetNextMapId(mapId);
+        if (next <= mapId) {
+            // We should fail here on Xiaomi S 4.14.180 due to kernel uapi bug,
+            // which causes bpfGetNextMapId to behave as bpfGetNextProgId,
+            // and thus it should return 0 with errno == ENOENT.
+            ALOGE("bpfGetNextMapId(final %d) returned %d errno %d", mapId, next, errno);
+            return 1;
+        }
+    } else {  // implies S/T with 4.9 kernel
+        // nothing we can do.
+    }
+
     // Create all the pin subdirectories
     // (this must be done first to allow selinux_context and pin_subdir functionality,
     //  which could otherwise fail with ENOENT during object pinning or renaming,
     //  due to ordering issues)
-    for (const auto& location : locations) {
-        if (location.t_plus && !isAtLeastT) continue;
-        if (createSysFsBpfSubDir(location.prefix)) return 1;
-    }
+    if (createDir("/sys/fs/bpf/tethering")) return 1;
+    // This is technically T+ but S also needs it for the 'mainline_done' file.
+    if (createDir("/sys/fs/bpf/netd_shared")) return 1;
 
     if (isAtLeastT) {
-        // Note: there's no actual src dir for fs_bpf_loader .o's,
-        // so it is not listed in 'locations[].prefix'.
-        // This is because this is primarily meant for triggering genfscon rules,
-        // and as such this will likely always be the case.
-        // Thus we need to manually create the /sys/fs/bpf/loader subdirectory.
-        if (createSysFsBpfSubDir("loader")) return 1;
+        if (createDir("/sys/fs/bpf/netd_readonly")) return 1;
+        if (createDir("/sys/fs/bpf/net_shared")) return 1;
+        if (createDir("/sys/fs/bpf/net_private")) return 1;
+
+        // This one is primarily meant for triggering genfscon rules.
+        if (createDir("/sys/fs/bpf/loader")) return 1;
     }
 
     // Load all ELF objects, create programs and maps, and pin them
-    for (const auto& location : locations) {
-        if (location.t_plus && !isAtLeastT) continue;
-        if (loadAllElfObjects(bpfloader_ver, location) != 0) {
-            ALOGE("=== CRITICAL FAILURE LOADING BPF PROGRAMS FROM %s ===", location.dir);
-            ALOGE("If this triggers reliably, you're probably missing kernel options or patches.");
-            ALOGE("If this triggers randomly, you might be hitting some memory allocation "
-                  "problems or startup script race.");
-            ALOGE("--- DO NOT EXPECT SYSTEM TO BOOT SUCCESSFULLY ---");
-            sleep(20);
-            return 2;
-        }
+    if (loadAllObjects(bpfloader_ver)) {
+        ALOGE("=== CRITICAL FAILURE LOADING BPF PROGRAMS ===");
+        ALOGE("If this triggers reliably, you're probably missing kernel options or patches.");
+        ALOGE("If this triggers randomly, you might be hitting some memory allocation "
+              "problems or startup script race.");
+        ALOGE("--- DO NOT EXPECT SYSTEM TO BOOT SUCCESSFULLY ---");
+        sleep(20);
+        return 2;
     }
 
     int key = 1;
@@ -1911,14 +1911,11 @@ static int doLoad(char** argv, char * const envp[]) {
             createMap(BPF_MAP_TYPE_ARRAY, sizeof(key), sizeof(value), 2, 0));
     if (writeToMapEntry(map, &key, &value, BPF_ANY)) {
         ALOGE("Critical kernel bug - failure to write into index 1 of 2 element bpf map array.");
-        return 1;
+        if (isAtLeastT) return 1;
     }
 
-    // on S we haven't created this subdir yet, but we need it for 'mainline_done' flag below
-    if (!isAtLeastT && createSysFsBpfSubDir("netd_shared")) return 1;
-
     // leave a flag that we're done
-    if (createSysFsBpfSubDir("netd_shared/mainline_done")) return 1;
+    if (createDir("/sys/fs/bpf/netd_shared/mainline_done")) return 1;
 
     // platform bpfloader will only succeed when run as root
     if (!runningAsRoot) {
diff --git a/bpf/loader/netbpfload.35rc b/bpf/loader/netbpfload.35rc
index 0fbcb5abdd..683abceb5d 100644
--- a/bpf/loader/netbpfload.35rc
+++ b/bpf/loader/netbpfload.35rc
@@ -1,9 +1,67 @@
 service bpfloader /apex/com.android.tethering/bin/netbpfload
+    # netbpfload will do network bpf loading, then execute /system/bin/bpfloader
     capabilities CHOWN SYS_ADMIN NET_ADMIN
+    # The following group memberships are a workaround for lack of DAC_OVERRIDE
+    # and allow us to open (among other things) files that we created and are
+    # no longer root owned (due to CHOWN) but still have group read access to
+    # one of the following groups.  This is not perfect, but a more correct
+    # solution requires significantly more effort to implement.
     group root graphics network_stack net_admin net_bw_acct net_bw_stats net_raw system
     user root
     file /dev/kmsg w
+    #
+    # Set RLIMIT_MEMLOCK to 1GiB for bpfloader
+    #
+    # Actually only 8MiB would be needed if bpfloader ran as its own uid.
+    #
+    # However, while the rlimit is per-thread, the accounting is system wide.
+    # So, for example, if the graphics stack has already allocated 10MiB of
+    # memlock data before bpfloader even gets a chance to run, it would fail
+    # if its memlock rlimit is only 8MiB - since there would be none left for it.
+    #
+    # bpfloader succeeding is critical to system health, since a failure will
+    # cause netd crashloop and thus system server crashloop... and the only
+    # recovery is a full kernel reboot.
+    #
+    # We've had issues where devices would sometimes (rarely) boot into
+    # a crashloop because bpfloader would occasionally lose a boot time
+    # race against the graphics stack's boot time locked memory allocation.
+    #
+    # Thus bpfloader's memlock has to be 8MB higher then the locked memory
+    # consumption of the root uid anywhere else in the system...
+    # But we don't know what that is for all possible devices...
+    #
+    # Ideally, we'd simply grant bpfloader the IPC_LOCK capability and it
+    # would simply ignore it's memlock rlimit... but it turns that this
+    # capability is not even checked by the kernel's bpf system call.
+    #
+    # As such we simply use 1GiB as a reasonable approximation of infinity.
+    #
     rlimit memlock 1073741824 1073741824
     oneshot
+    #
+    # How to debug bootloops caused by 'bpfloader-failed'.
+    #
+    # 1. On some lower RAM devices (like wembley) you may need to first enable developer mode
+    #    (from the Settings app UI), and change the developer option "Logger buffer sizes"
+    #    from the default (wembley: 64kB) to the maximum (1M) per log buffer.
+    #    Otherwise buffer will overflow before you manage to dump it and you'll get useless logs.
+    #
+    # 2. comment out 'reboot_on_failure reboot,bpfloader-failed' below
+    # 3. rebuild/reflash/reboot
+    # 4. as the device is booting up capture bpfloader logs via:
+    #    adb logcat -s 'bpfloader:*' 'LibBpfLoader:*' 'NetBpfLoad:*' 'NetBpfLoader:*'
+    #
+    # something like:
+    #   $ adb reboot; sleep 1; adb wait-for-device; adb root; sleep 1; adb wait-for-device; adb logcat -s 'bpfloader:*' 'LibBpfLoader:*' 'NetBpfLoad:*' 'NetBpfLoader:*'
+    # will take care of capturing logs as early as possible
+    #
+    # 5. look through the logs from the kernel's bpf verifier that bpfloader dumps out,
+    #    it usually makes sense to search back from the end and find the particular
+    #    bpf verifier failure that caused bpfloader to terminate early with an error code.
+    #    This will probably be something along the lines of 'too many jumps' or
+    #    'cannot prove return value is 0 or 1' or 'unsupported / unknown operation / helper',
+    #    'invalid bpf_context access', etc.
+    #
     reboot_on_failure reboot,bpfloader-failed
     override
diff --git a/bpf/loader/netbpfload.rc b/bpf/loader/netbpfload.rc
index 4cc6284cfc..ca7a8c1dba 100644
--- a/bpf/loader/netbpfload.rc
+++ b/bpf/loader/netbpfload.rc
@@ -1,71 +1,15 @@
+# 2025 2 36 0 1 # 25q3 sdk/api level 36.0 - Android 16 QPR1
+
+# Previous versions (for documentation)
+# 2025 2 36 0 0 1 # 25q3 sdk/api level 36.0 - Android 16 QPR1
 # 2025 2 36 0 0 # 25q2 sdk/api level 36.0 - Android 16 Baklava QPR0
+# (versions before A16 do not include anything here)
 
 # Note: This will actually execute /apex/com.android.tethering/bin/netbpfload
 # by virtue of 'service bpfloader' being overridden by the apex shipped .rc
-# Warning: most of the below settings are irrelevant unless the apex is missing.
+# Warning: the below settings are irrelevant unless the apex is missing.
 service bpfloader /system/bin/false
-    # netbpfload will do network bpf loading, then execute /system/bin/bpfloader
-    #! capabilities CHOWN SYS_ADMIN NET_ADMIN
-    # The following group memberships are a workaround for lack of DAC_OVERRIDE
-    # and allow us to open (among other things) files that we created and are
-    # no longer root owned (due to CHOWN) but still have group read access to
-    # one of the following groups.  This is not perfect, but a more correct
-    # solution requires significantly more effort to implement.
-    #! group root graphics network_stack net_admin net_bw_acct net_bw_stats net_raw system
     user root
-    #
-    # Set RLIMIT_MEMLOCK to 1GiB for bpfloader
-    #
-    # Actually only 8MiB would be needed if bpfloader ran as its own uid.
-    #
-    # However, while the rlimit is per-thread, the accounting is system wide.
-    # So, for example, if the graphics stack has already allocated 10MiB of
-    # memlock data before bpfloader even gets a chance to run, it would fail
-    # if its memlock rlimit is only 8MiB - since there would be none left for it.
-    #
-    # bpfloader succeeding is critical to system health, since a failure will
-    # cause netd crashloop and thus system server crashloop... and the only
-    # recovery is a full kernel reboot.
-    #
-    # We've had issues where devices would sometimes (rarely) boot into
-    # a crashloop because bpfloader would occasionally lose a boot time
-    # race against the graphics stack's boot time locked memory allocation.
-    #
-    # Thus bpfloader's memlock has to be 8MB higher then the locked memory
-    # consumption of the root uid anywhere else in the system...
-    # But we don't know what that is for all possible devices...
-    #
-    # Ideally, we'd simply grant bpfloader the IPC_LOCK capability and it
-    # would simply ignore it's memlock rlimit... but it turns that this
-    # capability is not even checked by the kernel's bpf system call.
-    #
-    # As such we simply use 1GiB as a reasonable approximation of infinity.
-    #
-    #! rlimit memlock 1073741824 1073741824
     oneshot
-    #
-    # How to debug bootloops caused by 'bpfloader-failed'.
-    #
-    # 1. On some lower RAM devices (like wembley) you may need to first enable developer mode
-    #    (from the Settings app UI), and change the developer option "Logger buffer sizes"
-    #    from the default (wembley: 64kB) to the maximum (1M) per log buffer.
-    #    Otherwise buffer will overflow before you manage to dump it and you'll get useless logs.
-    #
-    # 2. comment out 'reboot_on_failure reboot,bpfloader-failed' below
-    # 3. rebuild/reflash/reboot
-    # 4. as the device is booting up capture bpfloader logs via:
-    #    adb logcat -s 'bpfloader:*' 'LibBpfLoader:*' 'NetBpfLoad:*' 'NetBpfLoader:*'
-    #
-    # something like:
-    #   $ adb reboot; sleep 1; adb wait-for-device; adb root; sleep 1; adb wait-for-device; adb logcat -s 'bpfloader:*' 'LibBpfLoader:*' 'NetBpfLoad:*' 'NetBpfLoader:*'
-    # will take care of capturing logs as early as possible
-    #
-    # 5. look through the logs from the kernel's bpf verifier that bpfloader dumps out,
-    #    it usually makes sense to search back from the end and find the particular
-    #    bpf verifier failure that caused bpfloader to terminate early with an error code.
-    #    This will probably be something along the lines of 'too many jumps' or
-    #    'cannot prove return value is 0 or 1' or 'unsupported / unknown operation / helper',
-    #    'invalid bpf_context access', etc.
-    #
     reboot_on_failure reboot,netbpfload-missing
     updatable
diff --git a/bpf/netd/BpfHandler.cpp b/bpf/netd/BpfHandler.cpp
index 680c05eb00..38d3db5b57 100644
--- a/bpf/netd/BpfHandler.cpp
+++ b/bpf/netd/BpfHandler.cpp
@@ -214,11 +214,17 @@ static inline void waitForNetProgsLoaded() {
     // infinite loop until success with 5/10/20/40/60/60/60... delay
     for (int delay = 5;; delay *= 2) {
         if (delay > 60) delay = 60;
-        if (WaitForProperty("init.svc.mdnsd_netbpfload", "stopped", std::chrono::seconds(delay))
-            && mainlineNetBpfLoadDone())
-            return;
+        if (WaitForProperty("init.svc.mdnsd_netbpfload", "stopped", std::chrono::seconds(delay)))
+            break;
         ALOGW("Waited %ds for init.svc.mdnsd_netbpfload=stopped, still waiting...", delay);
     }
+    if (!mainlineNetBpfLoadDone()) {
+        ALOGE("FATAL: init.svc.mdnsd_netbpfload=stopped, yet !mainlineNetBpfLoadDone");
+        // mdnsd_netbpfload is marked 'reboot_on_failure', init should start a reboot very soon now,
+        // spamming logs with an abort is pointless
+        for (;;);
+    }
+    return;
 }
 
 static inline void waitForBpf() {
diff --git a/bpf/progs/Android.bp b/bpf/progs/Android.bp
index 2bfe613bb0..960efda2b8 100644
--- a/bpf/progs/Android.bp
+++ b/bpf/progs/Android.bp
@@ -64,33 +64,31 @@ cc_library_headers {
 // bpf kernel programs
 //
 bpf {
-    name: "dscpPolicy.o",
-    srcs: ["dscpPolicy.c"],
-    sub_dir: "net_shared",
+    name: "clatd.o",
+    srcs: ["clatd.c"],
+    sub_dir: "mainline",
 }
 
 bpf {
-    name: "offload.o",
-    srcs: ["offload.c"],
-    sub_dir: "tethering",
+    name: "dscpPolicy.o",
+    srcs: ["dscpPolicy.c"],
+    sub_dir: "mainline",
 }
 
 bpf {
-    name: "test.o",
-    srcs: ["test.c"],
-    sub_dir: "tethering",
+    name: "netd.o",
+    srcs: ["netd.c"],
+    sub_dir: "mainline",
 }
 
 bpf {
-    name: "clatd.o",
-    srcs: ["clatd.c"],
-    sub_dir: "net_shared",
+    name: "offload.o",
+    srcs: ["offload.c"],
+    sub_dir: "mainline",
 }
 
 bpf {
-    // WARNING: Android T's non-updatable netd depends on 'netd' string for xt_bpf programs it loads
-    name: "netd.o",
-    srcs: ["netd.c"],
-    // WARNING: Android T's non-updatable netd depends on 'netd_shared' string for xt_bpf programs
-    sub_dir: "netd_shared",
+    name: "test.o",
+    srcs: ["test.c"],
+    sub_dir: "mainline",
 }
diff --git a/bpf/progs/clatd.c b/bpf/progs/clatd.c
index f4e4f3bb99..e812e6867f 100644
--- a/bpf/progs/clatd.c
+++ b/bpf/progs/clatd.c
@@ -288,8 +288,8 @@ DEFINE_BPF_PROG("schedcls/egress4/clat_rawip", AID_ROOT, AID_SYSTEM, sched_cls_e
     // We cannot handle IP options, just standard 20 byte == 5 dword minimal IPv4 header
     if (ip4->ihl != 5) return TC_ACT_PIPE;
 
-    // Packet must not be multicast
-    if ((ip4->daddr & htonl(0xf0000000)) == htonl(0xe0000000)) return TC_ACT_PIPE;
+    // Packet must not be multicast, if it is just outright drop it.
+    if ((ip4->daddr & htonl(0xf0000000)) == htonl(0xe0000000)) return TC_ACT_SHOT;
 
     // Calculate the IPv4 one's complement checksum of the IPv4 header.
     __wsum sum4 = 0;
@@ -401,4 +401,3 @@ DEFINE_BPF_PROG("schedcls/egress4/clat_rawip", AID_ROOT, AID_SYSTEM, sched_cls_e
 }
 
 LICENSE("Apache 2.0");
-CRITICAL("Connectivity");
diff --git a/bpf/progs/dscpPolicy.c b/bpf/progs/dscpPolicy.c
index 94d717be5d..fca3fe29e6 100644
--- a/bpf/progs/dscpPolicy.c
+++ b/bpf/progs/dscpPolicy.c
@@ -278,4 +278,3 @@ DEFINE_BPF_PROG_KVER("schedcls/set_dscp_ether", AID_ROOT, AID_SYSTEM, schedcls_s
 }
 
 LICENSE("Apache 2.0");
-CRITICAL("Connectivity");
diff --git a/bpf/progs/netd.c b/bpf/progs/netd.c
index b146e4539e..93ef5c5f21 100644
--- a/bpf/progs/netd.c
+++ b/bpf/progs/netd.c
@@ -81,6 +81,8 @@ DEFINE_BPF_MAP_NO_NETD(ingress_discard_map, HASH, IngressDiscardKey, IngressDisc
 DEFINE_BPF_MAP_RW_NETD(lock_array_test_map, ARRAY, uint32_t, bool, 1)
 DEFINE_BPF_MAP_RW_NETD(lock_hash_test_map, HASH, uint32_t, bool, 1)
 
+DEFINE_BPF_SK_STORAGE(sk_storage, SkStorageValue)
+
 /* never actually used from ebpf */
 DEFINE_BPF_MAP_NO_NETD(iface_index_name_map, HASH, uint32_t, IfaceValue, IFACE_INDEX_NAME_MAP_SIZE)
 
@@ -191,13 +193,17 @@ DEFINE_BPF_MAP_EXT(local_net_blocked_uid_map, HASH, uint32_t, bool, -1000,
             uint64_t packets = 1;                                                                \
             uint64_t bytes = skb->len;                                                           \
             if (bytes > mtu) {                                                                   \
-                bool is_ipv6 = (skb->protocol == htons(ETH_P_IPV6));                             \
-                int ip_overhead = (is_ipv6 ? sizeof(struct ipv6hdr) : sizeof(struct iphdr));     \
-                int tcp_overhead = ip_overhead + sizeof(struct tcphdr) + 12;                     \
-                int mss = mtu - tcp_overhead;                                                    \
-                uint64_t payload = bytes - tcp_overhead;                                         \
-                packets = (payload + mss - 1) / mss;                                             \
-                bytes = tcp_overhead * packets + payload;                                        \
+                const bool is5_4 = KVER_IS_AT_LEAST(kver, 5, 4, 0);                              \
+                const bool is_ipv6 = (skb->protocol == htons(ETH_P_IPV6));                       \
+                const int ip_overhead = is_ipv6 ? sizeof(struct ipv6hdr) : sizeof(struct iphdr); \
+                struct bpf_sock * const sk = is5_4 && skb->sk ? bpf_sk_fullsock(skb->sk) : NULL; \
+                const bool is_tcp = !sk || sk->protocol == IPPROTO_TCP;                          \
+                const int L4_size = is_tcp ? sizeof(struct tcphdr) + 12 : sizeof(struct udphdr); \
+                const int overhead = ip_overhead + L4_size;                                      \
+                const int mss = mtu - overhead;                                                  \
+                const uint64_t payload = bytes - overhead;                                       \
+                packets = is5_4 ? skb->gso_segs : (payload + mss - 1) / mss;                     \
+                bytes = overhead * packets + payload;                                            \
             }                                                                                    \
             if (egress.egress) {                                                                 \
                 __sync_fetch_and_add(&value->txPackets, packets);                                \
@@ -628,11 +634,18 @@ DEFINE_NETD_BPF_PROG_RANGES("cgroupskb/ingress/stats$5_10_u",
     return bpf_traffic_account(skb, INGRESS, KVER_5_10, SDK_LEVEL_U);
 }
 
-// Android T/U/V 4.19 & T/U/V/25Q2 5.4 & T 5.10/5.15
+// Android T/U/V/25Q2 5.4 & T 5.10/5.15
+DEFINE_NETD_BPF_PROG_KVER_RANGE("cgroupskb/ingress/stats$5_4",
+                                bpf_cgroup_ingress_5_4, KVER_5_4, KVER_INF)
+(struct __sk_buff* skb) {
+    return bpf_traffic_account(skb, INGRESS, KVER_5_4, SDK_LEVEL_T);
+}
+
+// Android T/U/V 4.19
 DEFINE_NETD_BPF_PROG_KVER_RANGE("cgroupskb/ingress/stats$4_19",
-                                bpf_cgroup_ingress_4_19, KVER_4_19, KVER_INF)
+                               bpf_cgroup_ingress_4_19, KVER_4_19, KVER_5_4)
 (struct __sk_buff* skb) {
-    return bpf_traffic_account(skb, INGRESS, KVER_4_19, SDK_LEVEL_T);
+return bpf_traffic_account(skb, INGRESS, KVER_4_19, SDK_LEVEL_T);
 }
 
 // Android T 4.9 & T/U 4.14
@@ -668,11 +681,18 @@ DEFINE_NETD_BPF_PROG_RANGES("cgroupskb/egress/stats$5_10_u",
     return bpf_traffic_account(skb, EGRESS, KVER_5_10, SDK_LEVEL_U);
 }
 
-// Android T/U/V 4.19 & T/U/V/25Q2 5.4 & T 5.10/5.15
+// Android T/U/V/25Q2 5.4 & T 5.10/5.15
+DEFINE_NETD_BPF_PROG_KVER_RANGE("cgroupskb/egress/stats$5_4",
+                                bpf_cgroup_egress_5_4, KVER_5_4, KVER_INF)
+(struct __sk_buff* skb) {
+    return bpf_traffic_account(skb, EGRESS, KVER_5_4, SDK_LEVEL_T);
+}
+
+// Android T/U/V 4.19
 DEFINE_NETD_BPF_PROG_KVER_RANGE("cgroupskb/egress/stats$4_19",
-                                bpf_cgroup_egress_4_19, KVER_4_19, KVER_INF)
+                                bpf_cgroup_egress_4_19, KVER_4_19, KVER_5_4)
 (struct __sk_buff* skb) {
-    return bpf_traffic_account(skb, EGRESS, KVER_4_19, SDK_LEVEL_T);
+return bpf_traffic_account(skb, EGRESS, KVER_4_19, SDK_LEVEL_T);
 }
 
 // Android T 4.9 & T/U 4.14
@@ -770,11 +790,26 @@ static __always_inline inline uint8_t get_app_permissions() {
     return permissions ? *permissions : BPF_PERMISSION_INTERNET;
 }
 
-DEFINE_NETD_BPF_PROG_KVER("cgroupsock/inet_create", inet_socket_create, KVER_4_14)
-(__unused struct bpf_sock* sk) {
+static __always_inline inline int inet_socket_create(struct bpf_sock* sk,
+                                                     const struct kver_uint kver) {
+    if (KVER_IS_AT_LEAST(kver, 5, 10, 0)) {
+        SkStorageValue *v = bpf_sk_storage_get(sk, 0, BPF_SK_STORAGE_GET_F_CREATE);
+        if (v) v->cookie = bpf_get_sk_cookie(sk);
+    }
     return (get_app_permissions() & BPF_PERMISSION_INTERNET) ? BPF_ALLOW : BPF_DISALLOW;
 }
 
+DEFINE_NETD_BPF_PROG_KVER("cgroupsock/inet_create$5_10", inet_socket_create_5_10, KVER_5_10)
+(struct bpf_sock* sk) {
+    return inet_socket_create(sk, KVER_5_10);
+}
+
+DEFINE_NETD_BPF_PROG_KVER_RANGE("cgroupsock/inet_create$4_14",
+                                inet_socket_create_4_14, KVER_4_14, KVER_5_10)
+(struct bpf_sock* sk) {
+    return inet_socket_create(sk, KVER_4_14);
+}
+
 DEFINE_NETD_BPF_PROG_KVER("cgroupsockrelease/inet_release", inet_socket_release, KVER_5_10)
 (struct bpf_sock* sk) {
     uint64_t cookie = bpf_get_sk_cookie(sk);
@@ -885,4 +920,3 @@ DEFINE_NETD_V_BPF_PROG_KVER("setsockopt/prog", setsockopt_prog, KVER_5_4)
 }
 
 LICENSE("Apache 2.0");
-CRITICAL("Connectivity and netd");
diff --git a/bpf/progs/netd.h b/bpf/progs/netd.h
index 8400679a2a..aa5f9cc9bf 100644
--- a/bpf/progs/netd.h
+++ b/bpf/progs/netd.h
@@ -90,6 +90,11 @@ typedef struct {
 } PacketTrace;
 STRUCT_SIZE(PacketTrace, 8+4+4 + 4+4 + 2+2 + 1+1+1+1);
 
+typedef struct {
+    uint64_t cookie;
+} SkStorageValue;
+STRUCT_SIZE(SkStorageValue, 8);
+
 // Since we cannot garbage collect the stats map since device boot, we need to make these maps as
 // large as possible. The maximum size of number of map entries we can have is depend on the rlimit
 // of MEM_LOCK granted to netd. The memory space needed by each map can be calculated by the
diff --git a/bpf/progs/offload.c b/bpf/progs/offload.c
index b34fe6fd88..ae6f9aea95 100644
--- a/bpf/progs/offload.c
+++ b/bpf/progs/offload.c
@@ -98,6 +98,7 @@ static inline __always_inline int do_forward6(struct __sk_buff* skb,
     // Let the kernel's stack handle these cases and generate appropriate ICMP errors.
     if (ip6->hop_limit <= 1) TC_PUNT(LOW_TTL);
 
+    int gso_hdr_size = sizeof(struct ipv6hdr);
     // If hardware offload is running and programming flows based on conntrack entries,
     // try not to interfere with it.
     if (ip6->nexthdr == IPPROTO_TCP) {
@@ -117,6 +118,10 @@ static inline __always_inline int do_forward6(struct __sk_buff* skb,
 
         // Do not offload TCP packets with any one of the SYN/FIN/RST flags
         if (tcph->syn || tcph->fin || tcph->rst) TC_PUNT(TCPV6_CONTROL_PACKET);
+
+        gso_hdr_size += tcph->doff * 4;
+    } else if (ip6->nexthdr == IPPROTO_UDP) {
+        gso_hdr_size += sizeof(struct udphdr);
     }
 
     // Protect against forwarding packets sourced from ::1 or fe80::/64 or other weirdness.
@@ -168,21 +173,24 @@ static inline __always_inline int do_forward6(struct __sk_buff* skb,
     // Required IPv6 minimum mtu is 1280, below that not clear what we should do, abort...
     if (v->pmtu < IPV6_MIN_MTU) TC_PUNT(BELOW_IPV6_MTU);
 
-    // Approximate handling of TCP/IPv6 overhead for incoming LRO/GRO packets: default
-    // outbound path mtu of 1500 is not necessarily correct, but worst case we simply
-    // undercount, which is still better then not accounting for this overhead at all.
-    // Note: this really shouldn't be device/path mtu at all, but rather should be
-    // derived from this particular connection's mss (ie. from gro segment size).
-    // This would require a much newer kernel with newer ebpf accessors.
-    // (This is also blindly assuming 12 bytes of tcp timestamp option in tcp header)
+    // Handling of IPv6 overhead for incoming LRO/GRO packets
     uint64_t packets = 1;
     uint64_t L3_bytes = skb->len - l2_header_size;
+    // I don't trust v->pmtu to not be higher then it should be: it might just
+    // be device (instead of path/route/ipv6) mtu and that itself might be wrong...
     if (L3_bytes > v->pmtu) {
-        const int tcp6_overhead = sizeof(struct ipv6hdr) + sizeof(struct tcphdr) + 12;
-        const int mss = v->pmtu - tcp6_overhead;
-        const uint64_t payload = L3_bytes - tcp6_overhead;
-        packets = (payload + mss - 1) / mss;
-        L3_bytes = tcp6_overhead * packets + payload;
+        if (gso_hdr_size == sizeof(struct ipv6hdr)) TC_PUNT(UNKNOWN_IPV6_GSO);
+        const int mss = v->pmtu - gso_hdr_size;
+        const uint64_t payload = L3_bytes - gso_hdr_size;
+        if (KVER_IS_AT_LEAST(kver, 5, 4, 0)) {
+            if (skb->gso_segs <= 1) TC_PUNT(ABOVE_IPV6_PMTU);
+            // ?udp gso frags: gso_size is variable (thus 0), could this fail to trigger?
+            if (gso_hdr_size + skb->gso_size > v->pmtu) TC_PUNT(ABOVE_IPV6_PMTU_GSO);
+            packets = skb->gso_segs;
+        } else {
+            packets = (payload + mss - 1) / mss;
+        }
+        L3_bytes = gso_hdr_size * packets + payload;
     }
 
     // Are we past the limit?  If so, then abort...
@@ -246,14 +254,28 @@ static inline __always_inline int do_forward6(struct __sk_buff* skb,
     return bpf_redirect(v->oif, 0 /* this is effectively BPF_F_EGRESS */);
 }
 
-DEFINE_BPF_PROG("schedcls/tether_downstream6_ether", AID_ROOT, AID_NETWORK_STACK,
-                sched_cls_tether_downstream6_ether)
+// implementation for 5.4+ (can use skb->gso_{segs,size})
+DEFINE_BPF_PROG_KVER("schedcls/tether_downstream6_ether$5_4", AID_ROOT, AID_NETWORK_STACK,
+                     sched_cls_tether_downstream6_ether_5_4, KVER_5_4)
+(struct __sk_buff* skb) {
+    return do_forward6(skb, ETHER, DOWNSTREAM, KVER_5_4);
+}
+
+DEFINE_BPF_PROG_KVER("schedcls/tether_upstream6_ether$5_4", AID_ROOT, AID_NETWORK_STACK,
+                     sched_cls_tether_upstream6_ether_5_4, KVER_5_4)
+(struct __sk_buff* skb) {
+    return do_forward6(skb, ETHER, UPSTREAM, KVER_5_4);
+}
+
+// implementation for 4.9/4.14/4.19
+DEFINE_BPF_PROG_KVER_RANGE("schedcls/tether_downstream6_ether", AID_ROOT, AID_NETWORK_STACK,
+                           sched_cls_tether_downstream6_ether, KVER_NONE, KVER_5_4)
 (struct __sk_buff* skb) {
     return do_forward6(skb, ETHER, DOWNSTREAM, KVER_NONE);
 }
 
-DEFINE_BPF_PROG("schedcls/tether_upstream6_ether", AID_ROOT, AID_NETWORK_STACK,
-                sched_cls_tether_upstream6_ether)
+DEFINE_BPF_PROG_KVER_RANGE("schedcls/tether_upstream6_ether", AID_ROOT, AID_NETWORK_STACK,
+                           sched_cls_tether_upstream6_ether, KVER_NONE, KVER_5_4)
 (struct __sk_buff* skb) {
     return do_forward6(skb, ETHER, UPSTREAM, KVER_NONE);
 }
@@ -271,15 +293,28 @@ DEFINE_BPF_PROG("schedcls/tether_upstream6_ether", AID_ROOT, AID_NETWORK_STACK,
 // and there is a test in kernel/tests/net/test/bpf_test.py testSkbChangeHead()
 // and in system/netd/tests/binder_test.cpp NetdBinderTest TetherOffloadForwarding.
 //
-// Hence, these mandatory (must load successfully) implementations for 4.14+ kernels:
-DEFINE_BPF_PROG_KVER("schedcls/tether_downstream6_rawip$4_14", AID_ROOT, AID_NETWORK_STACK,
-                     sched_cls_tether_downstream6_rawip_4_14, KVER_4_14)
+// Hence, these mandatory (must load successfully) implementations for 5.4+ kernels:
+DEFINE_BPF_PROG_KVER("schedcls/tether_downstream6_rawip$5_4", AID_ROOT, AID_NETWORK_STACK,
+                     sched_cls_tether_downstream6_rawip_5_4, KVER_5_4)
+(struct __sk_buff* skb) {
+    return do_forward6(skb, RAWIP, DOWNSTREAM, KVER_5_4);
+}
+
+DEFINE_BPF_PROG_KVER("schedcls/tether_upstream6_rawip$5_4", AID_ROOT, AID_NETWORK_STACK,
+                     sched_cls_tether_upstream6_rawip_5_4, KVER_5_4)
+(struct __sk_buff* skb) {
+    return do_forward6(skb, RAWIP, UPSTREAM, KVER_5_4);
+}
+
+// and for 4.14/4.19 kernels
+DEFINE_BPF_PROG_KVER_RANGE("schedcls/tether_downstream6_rawip$4_14", AID_ROOT, AID_NETWORK_STACK,
+                           sched_cls_tether_downstream6_rawip_4_14, KVER_4_14, KVER_5_4)
 (struct __sk_buff* skb) {
     return do_forward6(skb, RAWIP, DOWNSTREAM, KVER_4_14);
 }
 
-DEFINE_BPF_PROG_KVER("schedcls/tether_upstream6_rawip$4_14", AID_ROOT, AID_NETWORK_STACK,
-                     sched_cls_tether_upstream6_rawip_4_14, KVER_4_14)
+DEFINE_BPF_PROG_KVER_RANGE("schedcls/tether_upstream6_rawip$4_14", AID_ROOT, AID_NETWORK_STACK,
+                           sched_cls_tether_upstream6_rawip_4_14, KVER_4_14, KVER_5_4)
 (struct __sk_buff* skb) {
     return do_forward6(skb, RAWIP, UPSTREAM, KVER_4_14);
 }
@@ -387,21 +422,28 @@ static inline __always_inline int do_forward4_bottom(struct __sk_buff* skb,
     // Required IPv4 minimum mtu is 68, below that not clear what we should do, abort...
     if (v->pmtu < 68) TC_PUNT(BELOW_IPV4_MTU);
 
-    // Approximate handling of TCP/IPv4 overhead for incoming LRO/GRO packets: default
-    // outbound path mtu of 1500 is not necessarily correct, but worst case we simply
-    // undercount, which is still better then not accounting for this overhead at all.
-    // Note: this really shouldn't be device/path mtu at all, but rather should be
-    // derived from this particular connection's mss (ie. from gro segment size).
-    // This would require a much newer kernel with newer ebpf accessors.
-    // (This is also blindly assuming 12 bytes of tcp timestamp option in tcp header)
+    // Handling of IPv4 overhead for incoming LRO/GRO packets
     uint64_t packets = 1;
     uint64_t L3_bytes = skb->len - l2_header_size;
+    // I don't trust v->pmtu to not be higher then it should be: it might just
+    // be device (instead of path/route) mtu and that itself might be wrong...
     if (L3_bytes > v->pmtu) {
-        const int tcp4_overhead = sizeof(struct iphdr) + sizeof(struct tcphdr) + 12;
-        const int mss = v->pmtu - tcp4_overhead;
-        const uint64_t payload = L3_bytes - tcp4_overhead;
-        packets = (payload + mss - 1) / mss;
-        L3_bytes = tcp4_overhead * packets + payload;
+        // we know it is IPv4 without IP options, and either TCP or UDP
+        const int hdr_sz = sizeof(struct iphdr) + (is_tcp ? tcph->doff * 4 : sizeof(struct udphdr));
+        const uint64_t payload = L3_bytes - hdr_sz;
+        if (KVER_IS_AT_LEAST(kver, 5, 4, 0)) {
+            if (skb->gso_segs <= 1) TC_PUNT(ABOVE_IPV4_PMTU);
+            // ?udp gso frags: gso_size is variable (thus 0), could this fail to trigger?
+            if (hdr_sz + skb->gso_size > v->pmtu) TC_PUNT(ABOVE_IPV4_PMTU_GSO);
+            packets = skb->gso_segs;
+        } else {
+            // pmtu may be larger then hdr_sz + gso_size, thus we may undercount nr of packets,
+            // which is still better then not accounting for this overhead at all.
+            // We cannot punt over-pmtu gso packets without simply disabling offload entirely...
+            const int mss = v->pmtu - hdr_sz;
+            packets = (payload + mss - 1) / mss;
+        }
+        L3_bytes = hdr_sz * packets + payload;
     }
 
     // Are we past the limit?  If so, then abort...
@@ -598,39 +640,74 @@ static inline __always_inline int do_forward4(struct __sk_buff* skb,
     }
 }
 
-// Full featured (required) implementations for 5.8+ kernels (these are S+ by definition)
+// Full featured (required) implementations for 5.10+ kernels (these are S+ by definition)
 
-DEFINE_BPF_PROG_KVER("schedcls/tether_downstream4_rawip$5_8", AID_ROOT, AID_NETWORK_STACK,
-                     sched_cls_tether_downstream4_rawip_5_8, KVER_5_10)
+DEFINE_BPF_PROG_KVER("schedcls/tether_downstream4_rawip$5_10", AID_ROOT, AID_NETWORK_STACK,
+                     sched_cls_tether_downstream4_rawip_5_10, KVER_5_10)
 (struct __sk_buff* skb) {
     return do_forward4(skb, RAWIP, DOWNSTREAM, UPDATETIME, KVER_5_10);
 }
 
-DEFINE_BPF_PROG_KVER("schedcls/tether_upstream4_rawip$5_8", AID_ROOT, AID_NETWORK_STACK,
-                     sched_cls_tether_upstream4_rawip_5_8, KVER_5_10)
+DEFINE_BPF_PROG_KVER("schedcls/tether_upstream4_rawip$5_10", AID_ROOT, AID_NETWORK_STACK,
+                     sched_cls_tether_upstream4_rawip_5_10, KVER_5_10)
 (struct __sk_buff* skb) {
     return do_forward4(skb, RAWIP, UPSTREAM, UPDATETIME, KVER_5_10);
 }
 
-DEFINE_BPF_PROG_KVER("schedcls/tether_downstream4_ether$5_8", AID_ROOT, AID_NETWORK_STACK,
-                     sched_cls_tether_downstream4_ether_5_8, KVER_5_10)
+DEFINE_BPF_PROG_KVER("schedcls/tether_downstream4_ether$5_10", AID_ROOT, AID_NETWORK_STACK,
+                     sched_cls_tether_downstream4_ether_5_10, KVER_5_10)
 (struct __sk_buff* skb) {
     return do_forward4(skb, ETHER, DOWNSTREAM, UPDATETIME, KVER_5_10);
 }
 
-DEFINE_BPF_PROG_KVER("schedcls/tether_upstream4_ether$5_8", AID_ROOT, AID_NETWORK_STACK,
-                     sched_cls_tether_upstream4_ether_5_8, KVER_5_10)
+DEFINE_BPF_PROG_KVER("schedcls/tether_upstream4_ether$5_10", AID_ROOT, AID_NETWORK_STACK,
+                     sched_cls_tether_upstream4_ether_5_10, KVER_5_10)
 (struct __sk_buff* skb) {
     return do_forward4(skb, ETHER, UPSTREAM, UPDATETIME, KVER_5_10);
 }
 
-// Full featured (optional) implementations for 4.14-S, 4.19-S & 5.4-S kernels
-// (optional, because we need to be able to fallback for 4.14/4.19/5.4 pre-S kernels)
+// Full featured (optional) implementations for 5.4-S kernels
+// (optional, because we need to be able to fallback for 5.4 pre-S kernels)
+
+DEFINE_OPTIONAL_BPF_PROG_KVER_RANGE("schedcls/tether_downstream4_rawip$opt54",
+                                    AID_ROOT, AID_NETWORK_STACK,
+                                    sched_cls_tether_downstream4_rawip_opt54,
+                                    KVER_5_4, KVER_5_10)
+(struct __sk_buff* skb) {
+    return do_forward4(skb, RAWIP, DOWNSTREAM, UPDATETIME, KVER_5_4);
+}
+
+DEFINE_OPTIONAL_BPF_PROG_KVER_RANGE("schedcls/tether_upstream4_rawip$opt54",
+                                    AID_ROOT, AID_NETWORK_STACK,
+                                    sched_cls_tether_upstream4_rawip_opt54,
+                                    KVER_5_4, KVER_5_10)
+(struct __sk_buff* skb) {
+    return do_forward4(skb, RAWIP, UPSTREAM, UPDATETIME, KVER_5_4);
+}
+
+DEFINE_OPTIONAL_BPF_PROG_KVER_RANGE("schedcls/tether_downstream4_ether$opt54",
+                                    AID_ROOT, AID_NETWORK_STACK,
+                                    sched_cls_tether_downstream4_ether_opt54,
+                                    KVER_5_4, KVER_5_10)
+(struct __sk_buff* skb) {
+    return do_forward4(skb, ETHER, DOWNSTREAM, UPDATETIME, KVER_5_4);
+}
+
+DEFINE_OPTIONAL_BPF_PROG_KVER_RANGE("schedcls/tether_upstream4_ether$opt54",
+                                    AID_ROOT, AID_NETWORK_STACK,
+                                    sched_cls_tether_upstream4_ether_opt54,
+                                    KVER_5_4, KVER_5_10)
+(struct __sk_buff* skb) {
+    return do_forward4(skb, ETHER, UPSTREAM, UPDATETIME, KVER_5_4);
+}
+
+// Full featured (optional) implementations for 4.14-S & 4.19-S kernels
+// (optional, because we need to be able to fallback for 4.14/4.19 pre-S kernels)
 
 DEFINE_OPTIONAL_BPF_PROG_KVER_RANGE("schedcls/tether_downstream4_rawip$opt",
                                     AID_ROOT, AID_NETWORK_STACK,
                                     sched_cls_tether_downstream4_rawip_opt,
-                                    KVER_4_14, KVER_5_10)
+                                    KVER_4_14, KVER_5_4)
 (struct __sk_buff* skb) {
     return do_forward4(skb, RAWIP, DOWNSTREAM, UPDATETIME, KVER_4_14);
 }
@@ -638,7 +715,7 @@ DEFINE_OPTIONAL_BPF_PROG_KVER_RANGE("schedcls/tether_downstream4_rawip$opt",
 DEFINE_OPTIONAL_BPF_PROG_KVER_RANGE("schedcls/tether_upstream4_rawip$opt",
                                     AID_ROOT, AID_NETWORK_STACK,
                                     sched_cls_tether_upstream4_rawip_opt,
-                                    KVER_4_14, KVER_5_10)
+                                    KVER_4_14, KVER_5_4)
 (struct __sk_buff* skb) {
     return do_forward4(skb, RAWIP, UPSTREAM, UPDATETIME, KVER_4_14);
 }
@@ -646,7 +723,7 @@ DEFINE_OPTIONAL_BPF_PROG_KVER_RANGE("schedcls/tether_upstream4_rawip$opt",
 DEFINE_OPTIONAL_BPF_PROG_KVER_RANGE("schedcls/tether_downstream4_ether$opt",
                                     AID_ROOT, AID_NETWORK_STACK,
                                     sched_cls_tether_downstream4_ether_opt,
-                                    KVER_4_14, KVER_5_10)
+                                    KVER_4_14, KVER_5_4)
 (struct __sk_buff* skb) {
     return do_forward4(skb, ETHER, DOWNSTREAM, UPDATETIME, KVER_4_14);
 }
@@ -654,7 +731,7 @@ DEFINE_OPTIONAL_BPF_PROG_KVER_RANGE("schedcls/tether_downstream4_ether$opt",
 DEFINE_OPTIONAL_BPF_PROG_KVER_RANGE("schedcls/tether_upstream4_ether$opt",
                                     AID_ROOT, AID_NETWORK_STACK,
                                     sched_cls_tether_upstream4_ether_opt,
-                                    KVER_4_14, KVER_5_10)
+                                    KVER_4_14, KVER_5_4)
 (struct __sk_buff* skb) {
     return do_forward4(skb, ETHER, UPSTREAM, UPDATETIME, KVER_4_14);
 }
@@ -750,74 +827,7 @@ DEFINE_BPF_PROG_KVER_RANGE("schedcls/tether_upstream4_ether$stub", AID_ROOT, AID
 
 // ----- XDP Support -----
 
+// java populates this map, and bpf_existence_test requires it on S+
 DEFINE_BPF_MAP_GRW(tether_dev_map, DEVMAP_HASH, uint32_t, uint32_t, 64, AID_NETWORK_STACK)
 
-static inline __always_inline int do_xdp_forward6(__unused struct xdp_md *ctx,
-        __unused const struct rawip_bool rawip, __unused const struct stream_bool stream) {
-    return XDP_PASS;
-}
-
-static inline __always_inline int do_xdp_forward4(__unused struct xdp_md *ctx,
-        __unused const struct rawip_bool rawip, __unused const struct stream_bool stream) {
-    return XDP_PASS;
-}
-
-static inline __always_inline int do_xdp_forward_ether(struct xdp_md *ctx,
-                                                       const struct stream_bool stream) {
-    const void* data = (void*)(long)ctx->data;
-    const void* data_end = (void*)(long)ctx->data_end;
-    const struct ethhdr* eth = data;
-
-    // Make sure we actually have an ethernet header
-    if ((void*)(eth + 1) > data_end) return XDP_PASS;
-
-    if (eth->h_proto == htons(ETH_P_IPV6))
-        return do_xdp_forward6(ctx, ETHER, stream);
-    if (eth->h_proto == htons(ETH_P_IP))
-        return do_xdp_forward4(ctx, ETHER, stream);
-
-    // Anything else we don't know how to handle...
-    return XDP_PASS;
-}
-
-static inline __always_inline int do_xdp_forward_rawip(struct xdp_md *ctx,
-                                                       const struct stream_bool stream) {
-    const void* data = (void*)(long)ctx->data;
-    const void* data_end = (void*)(long)ctx->data_end;
-
-    // The top nibble of both IPv4 and IPv6 headers is the IP version.
-    if (data_end - data < 1) return XDP_PASS;
-    const uint8_t v = (*(uint8_t*)data) >> 4;
-
-    if (v == 6) return do_xdp_forward6(ctx, RAWIP, stream);
-    if (v == 4) return do_xdp_forward4(ctx, RAWIP, stream);
-
-    // Anything else we don't know how to handle...
-    return XDP_PASS;
-}
-
-#define DEFINE_XDP_PROG(str, func) \
-    DEFINE_BPF_PROG_KVER(str, AID_ROOT, AID_NETWORK_STACK, func, KVER_5_10)(struct xdp_md *ctx)
-
-DEFINE_XDP_PROG("xdp/tether_downstream_ether",
-                 xdp_tether_downstream_ether) {
-    return do_xdp_forward_ether(ctx, DOWNSTREAM);
-}
-
-DEFINE_XDP_PROG("xdp/tether_downstream_rawip",
-                 xdp_tether_downstream_rawip) {
-    return do_xdp_forward_rawip(ctx, DOWNSTREAM);
-}
-
-DEFINE_XDP_PROG("xdp/tether_upstream_ether",
-                 xdp_tether_upstream_ether) {
-    return do_xdp_forward_ether(ctx, UPSTREAM);
-}
-
-DEFINE_XDP_PROG("xdp/tether_upstream_rawip",
-                 xdp_tether_upstream_rawip) {
-    return do_xdp_forward_rawip(ctx, UPSTREAM);
-}
-
 LICENSE("Apache 2.0");
-CRITICAL("Connectivity (Tethering)");
diff --git a/bpf/progs/offload.h b/bpf/progs/offload.h
index 1e28f01f7c..a4f72ba4b6 100644
--- a/bpf/progs/offload.h
+++ b/bpf/progs/offload.h
@@ -39,7 +39,12 @@
     ERR(NO_STATS_ENTRY)       \
     ERR(NO_LIMIT_ENTRY)       \
     ERR(BELOW_IPV4_MTU)       \
+    ERR(ABOVE_IPV4_PMTU)      \
+    ERR(ABOVE_IPV4_PMTU_GSO)  \
     ERR(BELOW_IPV6_MTU)       \
+    ERR(ABOVE_IPV6_PMTU)      \
+    ERR(ABOVE_IPV6_PMTU_GSO)  \
+    ERR(UNKNOWN_IPV6_GSO)     \
     ERR(LIMIT_REACHED)        \
     ERR(CHANGE_HEAD_FAILED)   \
     ERR(TOO_SHORT)            \
diff --git a/bpf/progs/test.c b/bpf/progs/test.c
index 4dba6b9878..20a345a524 100644
--- a/bpf/progs/test.c
+++ b/bpf/progs/test.c
@@ -43,4 +43,3 @@ DEFINE_BPF_PROG_KVER("skfilter/match", AID_ROOT, AID_ROOT, match, KVER_INF)
 }
 
 LICENSE("Apache 2.0");
-CRITICAL("Networking xTS tests");
diff --git a/bpf/syscall_wrappers/include/BpfSyscallWrappers.h b/bpf/syscall_wrappers/include/BpfSyscallWrappers.h
index 1d72b7792c..fe7b8c1345 100644
--- a/bpf/syscall_wrappers/include/BpfSyscallWrappers.h
+++ b/bpf/syscall_wrappers/include/BpfSyscallWrappers.h
@@ -235,15 +235,32 @@ inline int detachSingleProgram(bpf_attach_type type, const borrowed_fd& prog_fd,
 }
 
 // Available in 4.12 and later kernels.
-inline int runProgram(const borrowed_fd& prog_fd, const void* data,
-                      const uint32_t data_size) {
-    return bpf(BPF_PROG_RUN, {
-                                     .test = {
-                                             .prog_fd = static_cast<__u32>(prog_fd.get()),
-                                             .data_size_in = data_size,
-                                             .data_in = ptr_to_u64(data),
-                                     },
-                             });
+inline int runProgram(const borrowed_fd &prog_fd, const void *data,
+                      const uint32_t data_size, const void *ctx = nullptr,
+                      const uint32_t ctx_size = 0) {
+    return bpf(BPF_PROG_RUN,
+               {
+                   .test =
+                       {
+                           .prog_fd = static_cast<__u32>(prog_fd.get()),
+                           .data_size_in = data_size,
+                           .data_in = ptr_to_u64(data),
+                           .ctx_size_in = ctx_size,
+                           .ctx_in = ptr_to_u64(ctx),
+                       },
+               });
+}
+
+// 4.14+: returns next id > prog_id, or 0 (and sets errno)
+inline uint32_t bpfGetNextProgId(const uint32_t prog_id) {
+    bpf_attr arg = { .start_id = prog_id };
+    return bpf(BPF_PROG_GET_NEXT_ID, &arg) ? 0 : arg.next_id;
+}
+
+// 4.14+: returns next id > map_id, or 0 (and sets errno)
+inline uint32_t bpfGetNextMapId(const uint32_t map_id) {
+    bpf_attr arg = { .start_id = map_id };
+    return bpf(BPF_MAP_GET_NEXT_ID, &arg) ? 0 : arg.next_id;
 }
 
 // BPF_OBJ_GET_INFO_BY_FD requires 4.14+ kernel
@@ -260,7 +277,7 @@ inline int bpfGetFd ## NAME(const borrowed_fd& fd) { \
         .info_len = sizeof(info), \
         .info = ptr_to_u64(&info), \
     }}; \
-    int rv = bpf(BPF_OBJ_GET_INFO_BY_FD, attr); \
+    int rv = bpf(BPF_OBJ_GET_INFO_BY_FD, &attr); \
     if (rv) return rv; \
     if (attr.info.info_len < offsetof(bpf_ ## TYPE ## _info, FIELD) + sizeof(info.FIELD)) { \
         errno = EOPNOTSUPP; \
diff --git a/bpf/tests/mts/bpf_existence_test.cpp b/bpf/tests/mts/bpf_existence_test.cpp
index 4d5f9b54c7..a6c774f83a 100644
--- a/bpf/tests/mts/bpf_existence_test.cpp
+++ b/bpf/tests/mts/bpf_existence_test.cpp
@@ -37,6 +37,7 @@ using android::bpf::isAtLeastT;
 using android::bpf::isAtLeastU;
 using android::bpf::isAtLeastV;
 using android::bpf::isAtLeast25Q2;
+using android::bpf::isAtLeast25Q4;
 
 #define PLATFORM "/sys/fs/bpf/"
 #define TETHERING "/sys/fs/bpf/tethering/"
@@ -225,6 +226,8 @@ TEST_F(BpfExistenceTest, TestPrograms) {
     if (isAtLeast25Q2) ASSERT_TRUE(isAtLeastKernelVersion(5, 4, 0));
     DO_EXPECT(isAtLeast25Q2, MAINLINE_FOR_25Q2_PLUS);
 
+    if (isAtLeast25Q4) ASSERT_TRUE(isAtLeastKernelVersion(5, 10, 0));
+
     for (const auto& file : mustExist) {
         EXPECT_EQ(0, access(file.c_str(), R_OK)) << file << " does not exist";
     }
diff --git a/clatd/main.c b/clatd/main.c
index 9e5710e600..8fc9edaf08 100644
--- a/clatd/main.c
+++ b/clatd/main.c
@@ -152,7 +152,7 @@ void enable_seccomp(void) {
     // _exit(0)
     BPF2_SECCOMP_ALLOW_IF_EQUAL(__NR_exit_group),    // 94
 
-#if defined(__aarch64__)
+#if defined(__aarch64__) && 0  // disabled
     // Pixels are aarch64 - if we break clatd functionality on them,
     // we *will* notice on GoogleGuest WiFi network (which is ipv6 only)
     BPF_SECCOMP_KILL,
@@ -371,7 +371,9 @@ int main(int argc, char **argv) {
   // TODO: actually perform true DAD
   send_dad(tunnel.write_fd6, &Global_Clatd_Config.ipv6_local_subnet);
 
+#if 0
   enable_seccomp();  // WARNING: from this point forward very limited system calls available.
+#endif
 
   event_loop(&tunnel);
 
diff --git a/common/Android.bp b/common/Android.bp
index 5fabf414e5..acd2349bc9 100644
--- a/common/Android.bp
+++ b/common/Android.bp
@@ -20,11 +20,93 @@ package {
     default_applicable_licenses: ["Android-Apache-2.0"],
 }
 
-build = ["FlaggedApi.bp"]
+aconfig_declarations {
+    name: "com.android.net.flags-aconfig",
+    package: "com.android.net.flags",
+    exportable: true,
+    container: "com.android.tethering",
+    srcs: ["flags.aconfig"],
+    visibility: ["//packages/modules/Connectivity:__subpackages__"],
+}
+
+java_aconfig_library {
+    name: "com.android.net.flags-aconfig-java",
+    aconfig_declarations: "com.android.net.flags-aconfig",
+    defaults: ["framework-minus-apex-aconfig-java-defaults"],
+    min_sdk_version: "30",
+    apex_available: [
+        "com.android.tethering",
+    ],
+}
+
+// This library MUST NOT be available to platform. This is because if the
+// platform depends on a flag, it will not be able to delete that flag until
+// that platform version is no longer supported by mainline. Additionally,
+// there is no any safety mechanism that prevents the module from
+// deleting the flag by mistake, regressing on previous platform versions.
+java_aconfig_library {
+    name: "com.android.net.flags-aconfig-java-export",
+    aconfig_declarations: "com.android.net.flags-aconfig",
+    defaults: ["framework-minus-apex-aconfig-java-defaults"],
+    min_sdk_version: "30",
+    apex_available: [
+        "com.android.wifi",
+    ],
+    mode: "exported",
+}
+
+aconfig_declarations {
+    name: "com.android.net.thread.flags-aconfig",
+    package: "com.android.net.thread.flags",
+    container: "com.android.tethering",
+    srcs: ["thread_flags.aconfig"],
+    visibility: ["//packages/modules/Connectivity:__subpackages__"],
+}
+
+java_aconfig_library {
+    name: "com.android.net.thread.flags-aconfig-java",
+    aconfig_declarations: "com.android.net.thread.flags-aconfig",
+    defaults: ["framework-minus-apex-aconfig-java-defaults"],
+    min_sdk_version: "30",
+    apex_available: [
+        "com.android.tethering",
+    ],
+}
+
+aconfig_declarations {
+    name: "nearby_flags",
+    package: "com.android.nearby.flags",
+    container: "com.android.tethering",
+    srcs: ["nearby_flags.aconfig"],
+    visibility: ["//packages/modules/Connectivity:__subpackages__"],
+}
+
+java_aconfig_library {
+    name: "com.android.nearby.flags-aconfig-java",
+    aconfig_declarations: "nearby_flags",
+    defaults: ["framework-minus-apex-aconfig-java-defaults"],
+    min_sdk_version: "30",
+    apex_available: [
+        "com.android.tethering",
+    ],
+}
 
-// This is a placeholder comment to avoid merge conflicts
-// as the above target may not exist
-// depending on the branch
+aconfig_declarations {
+    name: "com.android.networksecurity.flags-aconfig",
+    package: "com.android.net.ct.flags",
+    container: "com.android.tethering",
+    srcs: ["networksecurity_flags.aconfig"],
+    visibility: ["//packages/modules/Connectivity:__subpackages__"],
+}
+
+java_aconfig_library {
+    name: "networksecurity_flags_java_lib",
+    aconfig_declarations: "com.android.networksecurity.flags-aconfig",
+    min_sdk_version: "30",
+    defaults: ["framework-minus-apex-aconfig-java-defaults"],
+    apex_available: ["com.android.tethering"],
+    visibility: ["//packages/modules/Connectivity:__subpackages__"],
+}
 
 // The library requires the final artifact to contain net-utils-device-common-struct-base.
 java_library {
diff --git a/common/FlaggedApi.bp b/common/FlaggedApi.bp
deleted file mode 100644
index f89ff9d22c..0000000000
--- a/common/FlaggedApi.bp
+++ /dev/null
@@ -1,98 +0,0 @@
-//
-// Copyright (C) 2024 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-aconfig_declarations {
-    name: "com.android.net.flags-aconfig",
-    package: "com.android.net.flags",
-    exportable: true,
-    container: "com.android.tethering",
-    srcs: ["flags.aconfig"],
-    visibility: ["//packages/modules/Connectivity:__subpackages__"],
-}
-
-java_aconfig_library {
-    name: "com.android.net.flags-aconfig-java",
-    aconfig_declarations: "com.android.net.flags-aconfig",
-    defaults: ["framework-minus-apex-aconfig-java-defaults"],
-    min_sdk_version: "30",
-    apex_available: [
-        "com.android.tethering",
-    ],
-}
-
-java_aconfig_library {
-    name: "com.android.net.flags-aconfig-java-export",
-    aconfig_declarations: "com.android.net.flags-aconfig",
-    defaults: ["framework-minus-apex-aconfig-java-defaults"],
-    min_sdk_version: "30",
-    apex_available: [
-        "com.android.wifi",
-    ],
-    mode: "exported",
-}
-
-aconfig_declarations {
-    name: "com.android.net.thread.flags-aconfig",
-    package: "com.android.net.thread.flags",
-    container: "com.android.tethering",
-    srcs: ["thread_flags.aconfig"],
-    visibility: ["//packages/modules/Connectivity:__subpackages__"],
-}
-
-java_aconfig_library {
-    name: "com.android.net.thread.flags-aconfig-java",
-    aconfig_declarations: "com.android.net.thread.flags-aconfig",
-    defaults: ["framework-minus-apex-aconfig-java-defaults"],
-    min_sdk_version: "30",
-    apex_available: [
-        "com.android.tethering",
-    ],
-}
-
-aconfig_declarations {
-    name: "nearby_flags",
-    package: "com.android.nearby.flags",
-    container: "com.android.tethering",
-    srcs: ["nearby_flags.aconfig"],
-    visibility: ["//packages/modules/Connectivity:__subpackages__"],
-}
-
-java_aconfig_library {
-    name: "com.android.nearby.flags-aconfig-java",
-    aconfig_declarations: "nearby_flags",
-    defaults: ["framework-minus-apex-aconfig-java-defaults"],
-    min_sdk_version: "30",
-    apex_available: [
-        "com.android.tethering",
-    ],
-}
-
-aconfig_declarations {
-    name: "com.android.networksecurity.flags-aconfig",
-    package: "com.android.net.ct.flags",
-    container: "com.android.tethering",
-    srcs: ["networksecurity_flags.aconfig"],
-    visibility: ["//packages/modules/Connectivity:__subpackages__"],
-}
-
-java_aconfig_library {
-    name: "networksecurity_flags_java_lib",
-    aconfig_declarations: "com.android.networksecurity.flags-aconfig",
-    min_sdk_version: "30",
-    defaults: ["framework-minus-apex-aconfig-java-defaults"],
-    apex_available: ["com.android.tethering"],
-    visibility: ["//packages/modules/Connectivity:__subpackages__"],
-}
diff --git a/common/flags.aconfig b/common/flags.aconfig
index 51b4fc009f..9fcd981be9 100644
--- a/common/flags.aconfig
+++ b/common/flags.aconfig
@@ -1,8 +1,9 @@
 package: "com.android.net.flags"
 container: "com.android.tethering"
 
-# This file contains aconfig flags for FlaggedAPI annotations
-# Flags used from platform code must be in under frameworks
+# This file contains aconfig flags for toggling features entirely implemented within the tethering
+# module. Flags used from platform code must be in the android.net.platform.flags package in
+# frameworks/base.
 
 flag {
   name: "set_data_saver_via_cm"
@@ -174,3 +175,27 @@ flag {
   bug: "388774939"
   is_fixed_read_only: true
 }
+
+flag {
+  name: "mdns_advertising_improvement"
+  is_exported: true
+  namespace: "android_core_networking"
+  description: "Flag for MDNS advertising quality, reliability and performance improvement"
+  bug: "373270045"
+}
+
+flag {
+  name: "ethernet_desktop_config"
+  namespace: "android_core_networking"
+  description: "The flag controls support for ethernet configuration tracking and store by MAC address."
+  bug: "397536853"
+  is_fixed_read_only: true
+}
+
+flag {
+  name: "qos_filter_ip_range_matching"
+  namespace: "android_core_networking"
+  description: "Flag for API to provide IP address range based QoS socket matching."
+  bug: "406146808"
+  is_fixed_read_only: true
+}
diff --git a/framework-t/api/current.txt b/framework-t/api/current.txt
index d66482cb16..610ec28d6f 100644
--- a/framework-t/api/current.txt
+++ b/framework-t/api/current.txt
@@ -250,6 +250,7 @@ package android.net.nsd {
     method @RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE) public void discoverServices(@NonNull String, int, @NonNull android.net.NetworkRequest, @NonNull java.util.concurrent.Executor, @NonNull android.net.nsd.NsdManager.DiscoveryListener);
     method public void registerService(android.net.nsd.NsdServiceInfo, int, android.net.nsd.NsdManager.RegistrationListener);
     method public void registerService(@NonNull android.net.nsd.NsdServiceInfo, int, @NonNull java.util.concurrent.Executor, @NonNull android.net.nsd.NsdManager.RegistrationListener);
+    method @FlaggedApi("com.android.net.flags.mdns_advertising_improvement") public void registerService(@NonNull android.net.nsd.AdvertisingRequest, @NonNull java.util.concurrent.Executor, @NonNull android.net.nsd.NsdManager.RegistrationListener);
     method public void registerServiceInfoCallback(@NonNull android.net.nsd.NsdServiceInfo, @NonNull java.util.concurrent.Executor, @NonNull android.net.nsd.NsdManager.ServiceInfoCallback);
     method @Deprecated public void resolveService(android.net.nsd.NsdServiceInfo, android.net.nsd.NsdManager.ResolveListener);
     method @Deprecated public void resolveService(@NonNull android.net.nsd.NsdServiceInfo, @NonNull java.util.concurrent.Executor, @NonNull android.net.nsd.NsdManager.ResolveListener);
diff --git a/framework-t/src/android/net/EthernetConfiguration.java b/framework-t/src/android/net/EthernetConfiguration.java
new file mode 100644
index 0000000000..a736bfc506
--- /dev/null
+++ b/framework-t/src/android/net/EthernetConfiguration.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.net;
+
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import java.util.Objects;
+
+/**
+ * This class represents the static IP configuration data such as IP configuration (static IPv4
+ * address, IPv4 gateway, DNS servers, etc.) and network capabilities for a configured ethernet
+ * network interface.
+ *
+ * - Intended Usage and Scope:
+ *   This class implements android.os.Parcelable and resides in the framework JAR. This is
+ *   necessary for being used as an AIDL object to share code with EthernetPortInfo and
+ *   EthernetNetworkUpdateRequest.
+ *
+ * - Future Evolution:
+ *   This class is meant to progressively replace EthernetNetworkUpdateRequest in EthernetManager's
+ *   {@code @SystemApi} and be exposed through {@code @SystemApi} getters as well.
+ *
+ * @hide
+ */
+public class EthernetConfiguration implements Parcelable {
+    /**
+     * Static IP configuration data (static IPv4 address, IPv4 gateway, DNS servers, etc.)
+     */
+    private final IpConfiguration mIpConfiguration;
+
+    /**
+     * This is only for the requestable bits of NetworkCapabilities that an external caller can
+     * pass through a EthernetNetworkUpdateRequest.
+     */
+    private final NetworkCapabilities mNetworkCapabilities;
+
+    public EthernetConfiguration(@NonNull IpConfiguration ipConfiguration,
+            @NonNull NetworkCapabilities capabilities) {
+        Objects.requireNonNull(ipConfiguration);
+        Objects.requireNonNull(capabilities);
+        mIpConfiguration = ipConfiguration;
+        mNetworkCapabilities = capabilities;
+    }
+
+    /**
+     * Get the IpConfiguration object associated with this EthernetConfiguration.
+     */
+    @NonNull
+    public IpConfiguration getIpConfiguration() {
+        return new IpConfiguration(mIpConfiguration);
+    }
+
+    /**
+     * Get the NetworkCapabilities object associated with this EthernetConfiguration.
+     */
+    @NonNull
+    public NetworkCapabilities getNetworkCapabilities() {
+        return new NetworkCapabilities(mNetworkCapabilities);
+    }
+
+    @Override
+    public String toString() {
+        return "IP configurations: " + mIpConfiguration.toString()
+                + "Network capabilities: " + mNetworkCapabilities.toString();
+    }
+
+    @Override
+    public boolean equals(@Nullable Object o) {
+        if (o == this) {
+            return true;
+        }
+
+        if (!(o instanceof EthernetConfiguration)) {
+            return false;
+        }
+
+        final EthernetConfiguration other = (EthernetConfiguration) o;
+        return Objects.equals(this.mIpConfiguration, other.mIpConfiguration)
+                && Objects.equals(this.mNetworkCapabilities, other.mNetworkCapabilities);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(mIpConfiguration, mNetworkCapabilities);
+    }
+
+    /** Implement the Parcelable interface */
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeParcelable(mIpConfiguration, flags);
+        dest.writeParcelable(mNetworkCapabilities, flags);
+    }
+
+    /** Implement the Parcelable interface */
+    public static final @NonNull Creator<EthernetConfiguration> CREATOR =
+            new Creator<EthernetConfiguration>() {
+                @Override
+                public EthernetConfiguration createFromParcel(Parcel in) {
+                    final IpConfiguration config = in.readParcelable(
+                            IpConfiguration.class.getClassLoader());
+                    final NetworkCapabilities capabilities = in.readParcelable(
+                            NetworkCapabilities.class.getClassLoader());
+                    return new EthernetConfiguration(config, capabilities);
+                }
+
+                @Override
+                public EthernetConfiguration[] newArray(int size) {
+                    return new EthernetConfiguration[size];
+                }
+            };
+
+    /** Implement the Parcelable interface */
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+}
diff --git a/framework-t/src/android/net/EthernetNetworkSpecifier.java b/framework-t/src/android/net/EthernetNetworkSpecifier.java
index 90c0361821..30878571cc 100644
--- a/framework-t/src/android/net/EthernetNetworkSpecifier.java
+++ b/framework-t/src/android/net/EthernetNetworkSpecifier.java
@@ -25,57 +25,107 @@ import android.text.TextUtils;
 import java.util.Objects;
 
 /**
- * A {@link NetworkSpecifier} used to identify ethernet interfaces.
+ * A {@link NetworkSpecifier} used to identify ethernet interfaces. Interfaces can be identified
+ * by matching either interface name and/or MAC address.
  */
 public final class EthernetNetworkSpecifier extends NetworkSpecifier implements Parcelable {
-
     /**
-     * Name of the network interface.
+     * Name of the network interface, or null.
      */
-    @NonNull
+    @Nullable
     private final String mInterfaceName;
 
     /**
-     * Create a new EthernetNetworkSpecifier.
+     * MAC address of the network interface, or null.
+     */
+    @Nullable
+    private final MacAddress mMacAddress;
+
+    /**
+     * Create a new EthernetNetworkSpecifier with an interface name.
      * @param interfaceName Name of the ethernet interface the specifier refers to.
      */
     public EthernetNetworkSpecifier(@NonNull String interfaceName) {
         if (TextUtils.isEmpty(interfaceName)) {
-            throw new IllegalArgumentException();
+            throw new IllegalArgumentException("Interface name cannot be null");
         }
         mInterfaceName = interfaceName;
+        mMacAddress = null;
     }
 
     /**
-     * Get the name of the ethernet interface the specifier refers to.
+     * Create a new EthernetNetworkSpecifier. Either interface name or MAC address needs to be
+     * valid.
+     * @param interfaceName Name of the ethernet interface the specifier refers to, or null.
+     * @param macAddress MAC address of the ethernet interface the specifier refers to, or null.
+     * @hide
+     */
+    public EthernetNetworkSpecifier(@Nullable String interfaceName,
+            @Nullable MacAddress macAddress) {
+        if (TextUtils.isEmpty(interfaceName) && macAddress == null) {
+            throw new IllegalArgumentException("Either interface name or MAC address needs to be"
+                    + " valid.");
+        }
+        mInterfaceName = interfaceName;
+        mMacAddress = macAddress;
+    }
+
+    /**
+     * Get the name of the ethernet interface the specifier refers to, or null.
      */
     @Nullable
     public String getInterfaceName() {
-        // This may be null in the future to support specifiers based on data other than the
-        // interface name.
         return mInterfaceName;
     }
 
-    /** @hide */
+    /**
+     * Get the MAC address of the ethernet interface the specifier refers to, or null.
+     * @hide
+     */
+    @Nullable
+    public MacAddress getMacAddress() {
+        return mMacAddress;
+    }
+
+    /**
+     * Check if this specifier can be satisfied by another specifier by interface name or/and MAC
+     * address.
+     * Note that because ethernet Networks always set an EthernetNetworkSpecifier that includes both
+     * interface name and MAC address, the match is asymmetrical.
+     * @hide
+     */
     @Override
     public boolean canBeSatisfiedBy(@Nullable NetworkSpecifier other) {
-        return equals(other);
+        if (!(other instanceof EthernetNetworkSpecifier)) return false;
+        final EthernetNetworkSpecifier rhs = (EthernetNetworkSpecifier) other;
+        // If interface name is specified, match interface name.
+        if (mInterfaceName != null && !mInterfaceName.equals(rhs.mInterfaceName)) {
+            return false;
+        }
+        // If MAC address is specified, match MAC address.
+        if (mMacAddress != null && !mMacAddress.equals(rhs.mMacAddress)) {
+            return false;
+        }
+        return true;
     }
 
     @Override
     public boolean equals(@Nullable Object o) {
         if (!(o instanceof EthernetNetworkSpecifier)) return false;
-        return TextUtils.equals(mInterfaceName, ((EthernetNetworkSpecifier) o).mInterfaceName);
+        EthernetNetworkSpecifier rhs = (EthernetNetworkSpecifier) o;
+        return TextUtils.equals(mInterfaceName, rhs.mInterfaceName)
+                && Objects.equals(mMacAddress, rhs.mMacAddress);
     }
 
     @Override
     public int hashCode() {
-        return Objects.hashCode(mInterfaceName);
+        return Objects.hash(mMacAddress, mInterfaceName);
     }
 
     @Override
     public String toString() {
-        return "EthernetNetworkSpecifier (" + mInterfaceName + ")";
+        return "EthernetNetworkSpecifier ( interface name: " + mInterfaceName
+                + ", MAC address: " + Objects.toString(mMacAddress) + ")";
     }
 
     @Override
@@ -86,12 +136,15 @@ public final class EthernetNetworkSpecifier extends NetworkSpecifier implements
     @Override
     public void writeToParcel(@NonNull Parcel dest, int flags) {
         dest.writeString(mInterfaceName);
+        dest.writeParcelable(mMacAddress, flags);
     }
 
     public static final @NonNull Parcelable.Creator<EthernetNetworkSpecifier> CREATOR =
             new Parcelable.Creator<EthernetNetworkSpecifier>() {
         public EthernetNetworkSpecifier createFromParcel(Parcel in) {
-            return new EthernetNetworkSpecifier(in.readString());
+                    final String ifname = in.readString();
+                    final MacAddress addr = in.readParcelable(MacAddress.class.getClassLoader());
+                    return new EthernetNetworkSpecifier(ifname, addr);
         }
         public EthernetNetworkSpecifier[] newArray(int size) {
             return new EthernetNetworkSpecifier[size];
diff --git a/framework-t/src/android/net/EthernetPortInfo.java b/framework-t/src/android/net/EthernetPortInfo.java
new file mode 100644
index 0000000000..ba811eeb4c
--- /dev/null
+++ b/framework-t/src/android/net/EthernetPortInfo.java
@@ -0,0 +1,215 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.net;
+
+import android.annotation.Nullable;
+import android.net.EthernetManager.InterfaceState;
+import android.net.EthernetManager.Role;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.text.TextUtils;
+
+import java.util.Objects;
+
+/**
+ * A class representing information of an ethernet interface.
+ * EthernetPortInfo is mainly used in network callbacks.
+ * @hide
+ */
+public final class EthernetPortInfo implements Parcelable {
+    // Role of this ethernet interface, one of {@link EthernetManager.ROLE_SERVER},
+    // {@link EthernetManager.ROLE_CLIENT}, or {@link EthernetManager.ROLE_NONE}.
+    @Role
+    private final int mRole;
+
+    // State of this ethernet interface, one of {@link EthernetManager.STATE_LINK_UP},
+    // {@link EthernetManager.STATE_LINK_DOWN}, or {@link EthernetManager.STATE_ABSENT}.
+    @InterfaceState
+    private final int mState;
+
+    // Configuration of this ethernet interface.
+    private final EthernetConfiguration mConfig;
+
+    // Name of this ethernet interface.
+    private final String mInterfaceName;
+
+    // MAC address of this ethernet interface.
+    private final MacAddress mMacAddress;
+
+    // Interface index of this ethernet interface.
+    private final int mInterfaceIndex;
+
+    public EthernetPortInfo(String interfaceName, MacAddress macAddress,
+            int interfaceIndex, EthernetConfiguration config, @Role int role,
+            @InterfaceState int state) {
+        if (role != EthernetManager.ROLE_CLIENT && role != EthernetManager.ROLE_SERVER
+                && role != EthernetManager.ROLE_NONE) {
+            throw new IllegalArgumentException("Interface role is not valid, should be one of "
+                    + "{EthernetManager.ROLE_SERVER, EthernetManager.ROLE_CLIENT, "
+                    + "EthernetManager.ROLE_NONE}.");
+        }
+        mRole = role;
+
+        if (state != EthernetManager.STATE_ABSENT && state != EthernetManager.STATE_LINK_DOWN
+                && state != EthernetManager.STATE_LINK_UP) {
+            throw new IllegalArgumentException("Interface state is not valid, should be one of "
+                    + "{EthernetManager.STATE_ABSENT, EthernetManager.STATE_LINK_DOWN, "
+                    + "EthernetManager.STATE_LINK_UP}.");
+        }
+        mState = state;
+
+        if (TextUtils.isEmpty(interfaceName) || macAddress == null || interfaceIndex <= 0) {
+            throw new IllegalArgumentException("All of interface name, MAC address and interface"
+                    + " index need to be valid.");
+        }
+        mInterfaceName = interfaceName;
+        mMacAddress = macAddress;
+        mInterfaceIndex = interfaceIndex;
+
+        Objects.requireNonNull(config);
+        mConfig = config;
+    }
+
+    /**
+     * Returns role of this ethernet interface, one of {@link EthernetManager.ROLE_SERVER},
+     * {@link EthernetManager.ROLE_CLIENT}, or {@link EthernetManager.ROLE_NONE}.
+     */
+    @Role
+    public int getRole() {
+        return mRole;
+    }
+
+
+    /**
+     * Returns state of this ethernet interface, one of {@link EthernetManager.STATE_LINK_UP},
+     * {@link EthernetManager.STATE_LINK_DOWN}, or {@link EthernetManager.STATE_ABSENT}.
+     */
+    @InterfaceState
+    public int getState() {
+        return mState;
+    }
+
+    /**
+     * Returns the static configuration regarding meteredness. Note that this meteredness is only
+     * configured meteredness, while real meteredness state is only retrievable via
+     * {@link ConnectivityManager}.
+     */
+    public boolean getMeteredConfiguration() {
+        return mConfig.getNetworkCapabilities()
+                .hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);
+    }
+
+    /** Returns the name of this ethernet interface */
+    public String getInterfaceName() {
+        return mInterfaceName;
+    }
+
+    /** Returns the MAC address of this ethernet interface */
+    public MacAddress getMacAddress() {
+        return mMacAddress;
+    }
+
+    /** Returns the interface index of this ethernet interface */
+    public int getInterfaceIndex() {
+        return mInterfaceIndex;
+    }
+
+    /** Returns the configuration of this ethernet interface */
+    public EthernetConfiguration getConfiguration() {
+        return mConfig;
+    }
+
+    /** Returns a NetworkSpecifier that is guaranteed to match with this ethernet interface. */
+    public NetworkSpecifier getNetworkSpecifier() {
+        return new EthernetNetworkSpecifier(mInterfaceName, mMacAddress);
+    }
+
+    @Override
+    public String toString() {
+        return  "Role:" + mRole
+                + ", State:" + mState
+                + ", Configurations: " + mConfig
+                + ", Interface name:" + mInterfaceName
+                + ", MAC address:" + Objects.toString(mMacAddress)
+                + ", Interface index:" + mInterfaceIndex;
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(mRole, mState, mConfig,
+                mInterfaceName, mMacAddress, mInterfaceIndex);
+    }
+
+    @Override
+    public boolean equals(@Nullable Object o) {
+        if (o == this) {
+            return true;
+        }
+
+        if (!(o instanceof EthernetPortInfo)) {
+            return false;
+        }
+
+        final EthernetPortInfo other = (EthernetPortInfo) o;
+        return (this.mRole == other.mRole)
+                && (this.mState == other.mState)
+                && Objects.equals(this.mConfig, other.mConfig)
+                && TextUtils.equals(this.mInterfaceName, other.mInterfaceName)
+                && Objects.equals(this.mMacAddress, other.mMacAddress)
+                && (this.mInterfaceIndex == other.mInterfaceIndex);
+    }
+
+    /** Implement the Parcelable interface */
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(mRole);
+        dest.writeInt(mState);
+        dest.writeParcelable(mConfig, flags);
+        dest.writeString(mInterfaceName);
+        dest.writeParcelable(mMacAddress, flags);
+        dest.writeInt(mInterfaceIndex);
+    }
+
+    /** Implement the Parcelable interface */
+    public static final Creator<EthernetPortInfo> CREATOR =
+            new Creator<EthernetPortInfo>() {
+                @Override
+                public EthernetPortInfo createFromParcel(Parcel in) {
+                    int role = in.readInt();
+                    int state = in.readInt();
+                    EthernetConfiguration config = in.readParcelable(
+                            EthernetConfiguration.class.getClassLoader());
+                    String ifname = in.readString();
+                    MacAddress hwaddr = in.readParcelable(
+                            MacAddress.class.getClassLoader());
+                    int index = in.readInt();
+                    return new EthernetPortInfo(
+                            ifname, hwaddr, index, config, role, state);
+                }
+
+                @Override
+                public EthernetPortInfo[] newArray(int size) {
+                    return new EthernetPortInfo[size];
+                }
+            };
+
+    /** Implement the Parcelable interface */
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+}
diff --git a/framework-t/src/android/net/NetworkIdentity.java b/framework-t/src/android/net/NetworkIdentity.java
index 947a0925c6..a48032b6b4 100644
--- a/framework-t/src/android/net/NetworkIdentity.java
+++ b/framework-t/src/android/net/NetworkIdentity.java
@@ -22,6 +22,9 @@ import static android.net.ConnectivityManager.TYPE_WIFI;
 import static android.net.NetworkTemplate.NETWORK_TYPE_ALL;
 import static android.telephony.SubscriptionManager.INVALID_SUBSCRIPTION_ID;
 
+import static com.android.net.module.util.CollectionUtils.intArrayToSet;
+import static com.android.net.module.util.NetworkCapabilitiesUtils.TYPE_TEST;
+
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
@@ -43,6 +46,7 @@ import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.Objects;
+import java.util.Set;
 
 /**
  * Network definition that includes strong identity. Analogous to combining
@@ -86,9 +90,6 @@ public class NetworkIdentity {
 
     private static final long SUPPORTED_OEM_MANAGED_TYPES = OEM_PAID | OEM_PRIVATE;
 
-    // Need to be synchronized with ConnectivityManager.
-    // TODO: Use {@code ConnectivityManager#*} when visible.
-    static final int TYPE_TEST = 18;
     private static final int MAX_NETWORK_TYPE = TYPE_TEST;
     private static final int MIN_NETWORK_TYPE = TYPE_MOBILE;
 
@@ -101,11 +102,13 @@ public class NetworkIdentity {
     final boolean mMetered;
     final boolean mDefaultNetwork;
     final int mOemManaged;
+    final long mTransportTypesBits;
 
     /** @hide */
     public NetworkIdentity(
             int type, int ratType, @Nullable String subscriberId, @Nullable String wifiNetworkKey,
-            boolean roaming, boolean metered, boolean defaultNetwork, int oemManaged, int subId) {
+            boolean roaming, boolean metered, boolean defaultNetwork, int oemManaged, int subId,
+            long transportTypesBits) {
         mType = type;
         mRatType = ratType;
         mSubscriberId = subscriberId;
@@ -115,25 +118,26 @@ public class NetworkIdentity {
         mDefaultNetwork = defaultNetwork;
         mOemManaged = oemManaged;
         mSubId = subId;
+        mTransportTypesBits = transportTypesBits;
     }
 
     @Override
     public int hashCode() {
         return Objects.hash(mType, mRatType, mSubscriberId, mWifiNetworkKey, mRoaming, mMetered,
-                mDefaultNetwork, mOemManaged, mSubId);
+                mDefaultNetwork, mOemManaged, mSubId, mTransportTypesBits);
     }
 
     @Override
     public boolean equals(@Nullable Object obj) {
-        if (obj instanceof NetworkIdentity) {
-            final NetworkIdentity ident = (NetworkIdentity) obj;
+        if (obj instanceof NetworkIdentity ident) {
             return mType == ident.mType && mRatType == ident.mRatType && mRoaming == ident.mRoaming
                     && Objects.equals(mSubscriberId, ident.mSubscriberId)
                     && Objects.equals(mWifiNetworkKey, ident.mWifiNetworkKey)
                     && mMetered == ident.mMetered
                     && mDefaultNetwork == ident.mDefaultNetwork
                     && mOemManaged == ident.mOemManaged
-                    && mSubId == ident.mSubId;
+                    && mSubId == ident.mSubId
+                    && mTransportTypesBits == ident.mTransportTypesBits;
         }
         return false;
     }
@@ -162,6 +166,8 @@ public class NetworkIdentity {
         builder.append(", defaultNetwork=").append(mDefaultNetwork);
         builder.append(", oemManaged=").append(getOemManagedNames(mOemManaged));
         builder.append(", subId=").append(mSubId);
+        // TODO: Print human friendly names instead.
+        builder.append(", transports=").append(getTransportTypes());
         return builder.append("}").toString();
     }
 
@@ -204,7 +210,7 @@ public class NetworkIdentity {
         proto.write(NetworkIdentityProto.METERED, mMetered);
         proto.write(NetworkIdentityProto.DEFAULT_NETWORK, mDefaultNetwork);
         proto.write(NetworkIdentityProto.OEM_MANAGED_NETWORK, mOemManaged);
-
+        proto.write(NetworkIdentityProto.TRANSPORT_TYPES, mTransportTypesBits);
         proto.end(start);
     }
 
@@ -273,6 +279,14 @@ public class NetworkIdentity {
         return mSubId;
     }
 
+    /**
+     * Get transport types
+     * @hide
+     */
+    public Set<Integer> getTransportTypes() {
+        return intArrayToSet(BitUtils.unpackBits(mTransportTypesBits));
+    }
+
     /**
      * Assemble a {@link NetworkIdentity} from the passed arguments.
      *
@@ -322,6 +336,9 @@ public class NetworkIdentity {
     public static int compare(@NonNull NetworkIdentity left, @NonNull NetworkIdentity right) {
         Objects.requireNonNull(right);
         int res = Integer.compare(left.mType, right.mType);
+        if (res == 0) {
+            res = Long.compare(left.mTransportTypesBits, right.mTransportTypesBits);
+        }
         if (res == 0) {
             res = Integer.compare(left.mRatType, right.mRatType);
         }
@@ -362,6 +379,7 @@ public class NetworkIdentity {
         private boolean mDefaultNetwork;
         private int mOemManaged;
         private int mSubId;
+        private long mTransportTypes;
 
         /**
          * Creates a new Builder.
@@ -377,6 +395,7 @@ public class NetworkIdentity {
             mDefaultNetwork = false;
             mOemManaged = NetworkTemplate.OEM_MANAGED_NO;
             mSubId = INVALID_SUBSCRIPTION_ID;
+            mTransportTypes = 0L;
         }
 
         /**
@@ -389,6 +408,7 @@ public class NetworkIdentity {
          *  - metered
          *  - oemManaged
          *  - wifiNetworkKey
+         *  - transportTypes
          *
          * @param snapshot The target {@link NetworkStateSnapshot} object.
          * @return The builder object.
@@ -397,6 +417,7 @@ public class NetworkIdentity {
         @NonNull
         public Builder setNetworkStateSnapshot(@NonNull NetworkStateSnapshot snapshot) {
             setType(snapshot.getLegacyType());
+            setTransportTypes(intArrayToSet(snapshot.getNetworkCapabilities().getTransportTypes()));
 
             setSubscriberId(snapshot.getSubscriberId());
             setRoaming(!snapshot.getNetworkCapabilities().hasCapability(
@@ -406,6 +427,7 @@ public class NetworkIdentity {
 
             setOemManaged(getOemBitfield(snapshot.getNetworkCapabilities()));
 
+            // TODO: Use the transports instead.
             if (mType == TYPE_WIFI) {
                 final NetworkCapabilities nc = snapshot.getNetworkCapabilities();
                 final TransportInfo transportInfo = nc.getTransportInfo();
@@ -580,6 +602,17 @@ public class NetworkIdentity {
             return this;
         }
 
+        /**
+         * Set the transport types.
+         *
+         * @hide
+         */
+        @NonNull
+        public Builder setTransportTypes(Set<Integer> transportTypes) {
+            mTransportTypes = BitUtils.packBits(CollectionUtils.toIntArray(transportTypes));
+            return this;
+        }
+
         private void ensureValidParameters() {
             // Assert non-mobile network cannot have a ratType.
             if (mType != TYPE_MOBILE && mRatType != NetworkTemplate.NETWORK_TYPE_ALL) {
@@ -602,7 +635,7 @@ public class NetworkIdentity {
         public NetworkIdentity build() {
             ensureValidParameters();
             return new NetworkIdentity(mType, mRatType, mSubscriberId, mWifiNetworkKey,
-                    mRoaming, mMetered, mDefaultNetwork, mOemManaged, mSubId);
+                    mRoaming, mMetered, mDefaultNetwork, mOemManaged, mSubId, mTransportTypes);
         }
     }
 }
diff --git a/framework-t/src/android/net/NetworkIdentitySet.java b/framework-t/src/android/net/NetworkIdentitySet.java
index d88408eef0..a0b3d3dec2 100644
--- a/framework-t/src/android/net/NetworkIdentitySet.java
+++ b/framework-t/src/android/net/NetworkIdentitySet.java
@@ -19,10 +19,17 @@ package android.net;
 import static android.net.ConnectivityManager.TYPE_MOBILE;
 import static android.telephony.SubscriptionManager.INVALID_SUBSCRIPTION_ID;
 
+import static com.android.net.module.util.CollectionUtils.toIntArray;
+import static com.android.net.module.util.NetworkCapabilitiesUtils.deduceTransportTypeForLegacyNetworkType;
+
 import android.annotation.NonNull;
 import android.service.NetworkIdentitySetProto;
 import android.util.proto.ProtoOutputStream;
 
+import androidx.annotation.VisibleForTesting;
+
+import com.android.net.module.util.BitUtils;
+
 import java.io.DataInput;
 import java.io.DataOutput;
 import java.io.IOException;
@@ -44,6 +51,7 @@ public class NetworkIdentitySet extends HashSet<NetworkIdentity> {
     private static final int VERSION_ADD_DEFAULT_NETWORK = 5;
     private static final int VERSION_ADD_OEM_MANAGED_NETWORK = 6;
     private static final int VERSION_ADD_SUB_ID = 7;
+    private static final int VERSION_ADD_TRANSPORT_TYPES = 8;
 
     /**
      * Construct a {@link NetworkIdentitySet} object.
@@ -112,8 +120,23 @@ public class NetworkIdentitySet extends HashSet<NetworkIdentity> {
                 subId = INVALID_SUBSCRIPTION_ID;
             }
 
+            final long transportTypesBits;
+            if (version >= VERSION_ADD_TRANSPORT_TYPES) {
+                transportTypesBits = in.readLong();
+            } else {
+                final int deducedTransport = deduceTransportTypeForLegacyNetworkType(type);
+                if (deducedTransport != -1) {
+                    transportTypesBits = BitUtils.packBits(new int[]{ deducedTransport });
+                } else {
+                    // Ignore legacy or unknown types. This is fine since this means
+                    // the legacy data cannot be queried by transport types,
+                    // which is not even supported now.
+                    transportTypesBits = 0;
+                }
+            }
+
             add(new NetworkIdentity(type, ratType, subscriberId, networkId, roaming, metered,
-                    defaultNetwork, oemNetCapabilities, subId));
+                    defaultNetwork, oemNetCapabilities, subId, transportTypesBits));
         }
     }
 
@@ -122,7 +145,7 @@ public class NetworkIdentitySet extends HashSet<NetworkIdentity> {
      * @hide
      */
     public void writeToStream(DataOutput out) throws IOException {
-        out.writeInt(VERSION_ADD_SUB_ID);
+        out.writeInt(VERSION_ADD_TRANSPORT_TYPES);
         out.writeInt(size());
         for (NetworkIdentity ident : this) {
             out.writeInt(ident.getType());
@@ -134,6 +157,7 @@ public class NetworkIdentitySet extends HashSet<NetworkIdentity> {
             out.writeBoolean(ident.isDefaultNetwork());
             out.writeInt(ident.getOemManaged());
             out.writeInt(ident.getSubId());
+            out.writeLong(BitUtils.packBits(toIntArray(ident.getTransportTypes())));
         }
     }
 
@@ -186,7 +210,13 @@ public class NetworkIdentitySet extends HashSet<NetworkIdentity> {
         return true;
     }
 
-    private static void writeOptionalString(DataOutput out, String value) throws IOException {
+    /**
+     * Writes an optional string to a {@link DataOutput} stream.
+     *
+     * @hide
+     */
+    @VisibleForTesting
+    public static void writeOptionalString(DataOutput out, String value) throws IOException {
         if (value != null) {
             out.writeByte(1);
             out.writeUTF(value);
diff --git a/framework-t/src/android/net/NetworkStats.java b/framework-t/src/android/net/NetworkStats.java
index a2c4fc374e..a50352e463 100644
--- a/framework-t/src/android/net/NetworkStats.java
+++ b/framework-t/src/android/net/NetworkStats.java
@@ -44,6 +44,7 @@ import java.io.PrintWriter;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Arrays;
+import java.util.BitSet;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
@@ -494,6 +495,21 @@ public final class NetworkStats implements Parcelable, Iterable<NetworkStats.Ent
             return this;
         }
 
+        /**
+         * Checks if this entry matches the given filter parameters.
+         * @param uid UID to filter for, or {@link #UID_ALL}.
+         * @param ifaces Interfaces to filter for, or {@link #INTERFACES_ALL}.
+         * @param tag Tag to filter for, or {@link #TAG_ALL}.
+         *
+         * @return true if this entry matches the given filter parameters.
+         * @hide
+         */
+        public boolean matches(int uid, String[] ifaces, int tag) {
+            return (uid == UID_ALL || uid == this.uid)
+                && (tag == TAG_ALL || tag == this.tag)
+                && (ifaces == INTERFACES_ALL || CollectionUtils.contains(ifaces, this.iface));
+        }
+
         @Override
         public String toString() {
             final StringBuilder builder = new StringBuilder();
@@ -1379,10 +1395,7 @@ public final class NetworkStats implements Parcelable, Iterable<NetworkStats.Ent
         if (limitUid == UID_ALL && limitTag == TAG_ALL && limitIfaces == INTERFACES_ALL) {
             return;
         }
-        filter(e -> (limitUid == UID_ALL || limitUid == e.uid)
-                && (limitTag == TAG_ALL || limitTag == e.tag)
-                && (limitIfaces == INTERFACES_ALL
-                    || CollectionUtils.contains(limitIfaces, e.iface)));
+        filter(e -> e.matches(limitUid, limitIfaces, limitTag));
     }
 
     /**
@@ -1410,6 +1423,39 @@ public final class NetworkStats implements Parcelable, Iterable<NetworkStats.Ent
         size = nextOutputEntry;
     }
 
+    /**
+     * Make a filtered copy of the network stats.
+     *
+     * @param limitUid UID to filter for, or {@link #UID_ALL}.
+     * @param limitIfaces Interfaces to filter for, or {@link #INTERFACES_ALL}.
+     * @param limitTag Tag to filter for, or {@link #TAG_ALL}.
+     * @hide
+     */
+    public NetworkStats filteredClone(int limitUid, String[] limitIfaces, int limitTag) {
+        // Compute the size needed for the final NetworkStats object to avoid
+        // overallocation and intermediate copies. Performance experiments
+        // suggest we save a little by avoiding getValues calls on unmatched
+        // entries, even at the allocation cost of a temporary BitSet.
+        BitSet matches = new BitSet(size);
+        NetworkStats.Entry e = null;
+        int filteredSize = 0;
+        for (int i = 0; i < size; i++) {
+            e = getValues(i, e);
+            if (e.matches(limitUid, limitIfaces, limitTag)) {
+                matches.set(i);
+                filteredSize++;
+            }
+        }
+
+        final NetworkStats clone = new NetworkStats(elapsedRealtime, filteredSize);
+        int i = matches.nextSetBit(0);
+        while (i != -1) {
+            clone.insertEntry(getValues(i, e));
+            i = matches.nextSetBit(i + 1);
+        }
+        return clone;
+    }
+
     /** @hide */
     public void dump(String prefix, PrintWriter pw) {
         pw.print(prefix);
diff --git a/framework-t/src/android/net/NetworkTemplate.java b/framework-t/src/android/net/NetworkTemplate.java
index 77b166cc3a..af44cf7da5 100644
--- a/framework-t/src/android/net/NetworkTemplate.java
+++ b/framework-t/src/android/net/NetworkTemplate.java
@@ -37,6 +37,10 @@ import static android.net.NetworkStats.ROAMING_ALL;
 import static android.net.NetworkStats.ROAMING_NO;
 import static android.net.NetworkStats.ROAMING_YES;
 
+import static com.android.net.module.util.NetworkCapabilitiesUtils.TYPE_TEST;
+
+import static java.util.Objects.requireNonNull;
+
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
@@ -53,6 +57,7 @@ import android.util.Log;
 
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.modules.utils.build.SdkLevel;
+import com.android.net.module.util.BitUtils;
 import com.android.net.module.util.CollectionUtils;
 import com.android.net.module.util.NetworkIdentityUtils;
 
@@ -87,6 +92,8 @@ public final class NetworkTemplate implements Parcelable {
             MATCH_BLUETOOTH,
             MATCH_PROXY,
             MATCH_CARRIER,
+            MATCH_TEST,
+            MATCH_ALL,
     })
     public @interface TemplateMatchRule{}
 
@@ -116,6 +123,13 @@ public final class NetworkTemplate implements Parcelable {
      */
     @VisibleForTesting
     public static final int MATCH_TEST = 11;
+    /**
+     * Match rule to match networks with other filters inside the template.
+     *
+     * Note that exactly one transport type is needed to build the template with this match rule.
+     * @hide
+     */
+    public static final int MATCH_ALL = 12;
 
     // TODO: Remove this and replace all callers with WIFI_NETWORK_KEY_ALL.
     /** @hide */
@@ -136,6 +150,10 @@ public final class NetworkTemplate implements Parcelable {
      */
     public static final int NETWORK_TYPE_ALL = -1;
 
+    /** @hide */
+    @VisibleForTesting
+    public static final long TRANSPORT_TYPES_ALL = 0L;
+
     /** @hide */
     @Retention(RetentionPolicy.SOURCE)
     @IntDef(prefix = { "OEM_MANAGED_" }, value = {
@@ -177,6 +195,7 @@ public final class NetworkTemplate implements Parcelable {
             case MATCH_PROXY:
             case MATCH_CARRIER:
             case MATCH_TEST:
+            case MATCH_ALL:
                 return true;
 
             default:
@@ -408,6 +427,8 @@ public final class NetworkTemplate implements Parcelable {
     // Bitfield containing OEM network properties{@code NetworkIdentity#OEM_*}.
     private final int mOemManaged;
 
+    private final long mTransportTypesBits;
+
     private static void checkValidMatchSubscriberIds(int matchRule, String[] matchSubscriberIds) {
         switch (matchRule) {
             // CARRIER templates must always specify a valid subscriber ID.
@@ -457,7 +478,7 @@ public final class NetworkTemplate implements Parcelable {
                 subscriberId != null ? new String[] { subscriberId } : new String[0],
                 wifiNetworkKey != null ? new String[] { wifiNetworkKey } : new String[0],
                 getMeterednessForBackwardsCompatibility(matchRule), ROAMING_ALL,
-                DEFAULT_NETWORK_ALL, NETWORK_TYPE_ALL, OEM_MANAGED_ALL);
+                DEFAULT_NETWORK_ALL, NETWORK_TYPE_ALL, OEM_MANAGED_ALL, TRANSPORT_TYPES_ALL);
         if (matchRule == 6 || matchRule == 7) {
             Log.e(TAG, "Use MATCH_MOBILE with empty subscriberIds or MATCH_WIFI with empty "
                     + "wifiNetworkKeys instead of template with matchRule=" + matchRule);
@@ -493,7 +514,7 @@ public final class NetworkTemplate implements Parcelable {
                 wifiNetworkKey != null ? new String[] { wifiNetworkKey } : new String[0],
                 getMeterednessForBackwardsCompatibility(matchRule),
                 ROAMING_ALL, DEFAULT_NETWORK_ALL, NETWORK_TYPE_ALL,
-                OEM_MANAGED_ALL);
+                OEM_MANAGED_ALL, TRANSPORT_TYPES_ALL);
         // TODO : this is part of hidden-o txt, does that mean it should be annotated with
         // @UnsupportedAppUsage(maxTargetSdk = O)? If yes, can't throwAtLeastU() lest apps
         // targeting O- crash on those devices.
@@ -510,16 +531,17 @@ public final class NetworkTemplate implements Parcelable {
         // subscriberIds.
         this(getBackwardsCompatibleMatchRule(matchRule),
                 matchSubscriberIds == null ? new String[]{} : matchSubscriberIds,
-                matchWifiNetworkKeys, metered, roaming, defaultNetwork, ratType, oemManaged);
+                matchWifiNetworkKeys, metered, roaming, defaultNetwork, ratType, oemManaged,
+                TRANSPORT_TYPES_ALL);
         throwAtLeastU();
     }
 
     /** @hide */
     public NetworkTemplate(int matchRule, String[] matchSubscriberIds,
             String[] matchWifiNetworkKeys, int metered, int roaming, int defaultNetwork,
-            int ratType, int oemManaged) {
-        Objects.requireNonNull(matchWifiNetworkKeys);
-        Objects.requireNonNull(matchSubscriberIds);
+            int ratType, int oemManaged, long transportTypesBits) {
+        requireNonNull(matchWifiNetworkKeys);
+        requireNonNull(matchSubscriberIds);
         mMatchRule = matchRule;
         mMatchSubscriberIds = matchSubscriberIds;
         mMatchWifiNetworkKeys = matchWifiNetworkKeys;
@@ -528,6 +550,7 @@ public final class NetworkTemplate implements Parcelable {
         mDefaultNetwork = defaultNetwork;
         mRatType = ratType;
         mOemManaged = oemManaged;
+        mTransportTypesBits = transportTypesBits;
         checkValidMatchSubscriberIds(matchRule, matchSubscriberIds);
         if (!isKnownMatchRule(matchRule)) {
             throw new IllegalArgumentException("Unknown network template rule " + matchRule
@@ -544,6 +567,7 @@ public final class NetworkTemplate implements Parcelable {
         mDefaultNetwork = in.readInt();
         mRatType = in.readInt();
         mOemManaged = in.readInt();
+        mTransportTypesBits = in.readLong();
     }
 
     @Override
@@ -556,6 +580,7 @@ public final class NetworkTemplate implements Parcelable {
         dest.writeInt(mDefaultNetwork);
         dest.writeInt(mRatType);
         dest.writeInt(mOemManaged);
+        dest.writeLong(mTransportTypesBits);
     }
 
     @Override
@@ -588,6 +613,9 @@ public final class NetworkTemplate implements Parcelable {
         if (mOemManaged != OEM_MANAGED_ALL) {
             builder.append(", oemManaged=").append(getOemManagedNames(mOemManaged));
         }
+        if (mTransportTypesBits != TRANSPORT_TYPES_ALL) {
+            builder.append(", transportTypes=").append(Arrays.toString(getTransportTypes()));
+        }
         return builder.toString();
     }
 
@@ -595,7 +623,7 @@ public final class NetworkTemplate implements Parcelable {
     public int hashCode() {
         return Objects.hash(mMatchRule, Arrays.hashCode(mMatchSubscriberIds),
                 Arrays.hashCode(mMatchWifiNetworkKeys), mMetered, mRoaming, mDefaultNetwork,
-                mRatType, mOemManaged);
+                mRatType, mOemManaged, mTransportTypesBits);
     }
 
     @Override
@@ -609,7 +637,8 @@ public final class NetworkTemplate implements Parcelable {
                     && mRatType == other.mRatType
                     && mOemManaged == other.mOemManaged
                     && Arrays.equals(mMatchSubscriberIds, other.mMatchSubscriberIds)
-                    && Arrays.equals(mMatchWifiNetworkKeys, other.mMatchWifiNetworkKeys);
+                    && Arrays.equals(mMatchWifiNetworkKeys, other.mMatchWifiNetworkKeys)
+                    && mTransportTypesBits == other.mTransportTypesBits;
         }
         return false;
     }
@@ -633,8 +662,15 @@ public final class NetworkTemplate implements Parcelable {
 
     /**
      * Get match rule of the template. See {@code MATCH_*}.
+     *
+     * @throws IllegalStateException if the template is not built from constructors with
+     * match rule, which can occur if the template was created with the
+     * {@link Builder#Builder()} constructor.
      */
     public int getMatchRule() {
+        if (MATCH_ALL == mMatchRule) {
+            throw new IllegalStateException("Match rule is not set");
+        }
         return mMatchRule;
     }
 
@@ -707,6 +743,30 @@ public final class NetworkTemplate implements Parcelable {
         return mRatType;
     }
 
+    /**
+     * Get the transport type filter of the template.
+     *
+     * This is only valid when the template is constructed by using
+     * {@link NetworkTemplate.Builder}.
+     * @hide
+     */
+    public int getTransportType() {
+        if (mTransportTypesBits == TRANSPORT_TYPES_ALL) {
+            throw new IllegalStateException("Transport was not set");
+        }
+        return getTransportTypes()[0];
+    }
+
+    /**
+     * Get the transport types filter of the template.
+     *
+     * @hide
+     */
+    @NonNull
+    public int[] getTransportTypes() {
+        return BitUtils.unpackBits(mTransportTypesBits);
+    }
+
     /**
      * Get the OEM managed filter of the template. See {@code OEM_MANAGED_*} or
      * {@code android.net.NetworkIdentity#OEM_*}.
@@ -723,12 +783,14 @@ public final class NetworkTemplate implements Parcelable {
      */
     @SystemApi(client = MODULE_LIBRARIES)
     public boolean matches(@NonNull NetworkIdentity ident) {
-        Objects.requireNonNull(ident);
+        requireNonNull(ident);
         if (!matchesMetered(ident)) return false;
         if (!matchesRoaming(ident)) return false;
         if (!matchesDefaultNetwork(ident)) return false;
         if (!matchesOemNetwork(ident)) return false;
 
+        // TODO: Convert match rule handling into transport type matches and
+        //  eliminate the need of legacy network types.
         switch (mMatchRule) {
             case MATCH_MOBILE:
                 return matchesMobile(ident);
@@ -744,6 +806,8 @@ public final class NetworkTemplate implements Parcelable {
                 return matchesCarrier(ident);
             case MATCH_TEST:
                 return matchesTest(ident);
+            case MATCH_ALL:
+                return matchesTransportTypes(ident);
             default:
                 // We have no idea what kind of network template we are, so we
                 // just claim not to match anything.
@@ -776,6 +840,13 @@ public final class NetworkTemplate implements Parcelable {
             || (mOemManaged == ident.mOemManaged);
     }
 
+    private boolean matchesTransportTypes(NetworkIdentity ident) {
+        if (this.mTransportTypesBits == TRANSPORT_TYPES_ALL) return true;
+        // Otherwise, for a match, the identity must possess ALL transport types
+        // specified in the template.
+        return (this.mTransportTypesBits & ident.mTransportTypesBits) == this.mTransportTypesBits;
+    }
+
     private boolean matchesCollapsedRatType(NetworkIdentity ident) {
         return mRatType == NETWORK_TYPE_ALL
                 || NetworkStatsManager.getCollapsedRatType(mRatType)
@@ -870,7 +941,7 @@ public final class NetworkTemplate implements Parcelable {
      * all test networks would be matched.
      */
     private boolean matchesTest(NetworkIdentity ident) {
-        return ident.mType == NetworkIdentity.TYPE_TEST
+        return ident.mType == TYPE_TEST
                 && ((CollectionUtils.isEmpty(mMatchWifiNetworkKeys)
                 || CollectionUtils.contains(mMatchWifiNetworkKeys, ident.mWifiNetworkKey)));
     }
@@ -908,6 +979,8 @@ public final class NetworkTemplate implements Parcelable {
                 return "CARRIER";
             case MATCH_TEST:
                 return "TEST";
+            case MATCH_ALL:
+                return "ALL";
             default:
                 return "UNKNOWN(" + matchRule + ")";
         }
@@ -1002,7 +1075,8 @@ public final class NetworkTemplate implements Parcelable {
                         (template.mMatchRule == MATCH_MOBILE
                                 || template.mMatchRule == MATCH_CARRIER)
                                 ? METERED_YES : METERED_ALL,
-                        ROAMING_ALL, DEFAULT_NETWORK_ALL, NETWORK_TYPE_ALL, OEM_MANAGED_ALL);
+                        ROAMING_ALL, DEFAULT_NETWORK_ALL, NETWORK_TYPE_ALL, OEM_MANAGED_ALL,
+                        TRANSPORT_TYPES_ALL);
             }
         }
 
@@ -1039,6 +1113,7 @@ public final class NetworkTemplate implements Parcelable {
         private int mRoaming;
         private int mDefaultNetwork;
         private int mRatType;
+        private long mTransportTypesBits;
 
         // Bitfield containing OEM network properties {@code NetworkIdentity#OEM_*}.
         private int mOemManaged;
@@ -1057,6 +1132,18 @@ public final class NetworkTemplate implements Parcelable {
             mDefaultNetwork = DEFAULT_NETWORK_ALL;
             mRatType = NETWORK_TYPE_ALL;
             mOemManaged = OEM_MANAGED_ALL;
+            mTransportTypesBits = TRANSPORT_TYPES_ALL;
+        }
+
+        /**
+         * Creates a new Builder to construct NetworkTemplate objects.
+         *
+         * Note that {@link #setTransportType} MUST be called to specify
+         * the transport type filter.
+         * @hide
+         */
+        public Builder() {
+            this(MATCH_ALL);
         }
 
         /**
@@ -1068,7 +1155,7 @@ public final class NetworkTemplate implements Parcelable {
          */
         @NonNull
         public Builder setSubscriberIds(@NonNull Set<String> subscriberIds) {
-            Objects.requireNonNull(subscriberIds);
+            requireNonNull(subscriberIds);
             mMatchSubscriberIds.clear();
             mMatchSubscriberIds.addAll(subscriberIds);
             return this;
@@ -1089,7 +1176,7 @@ public final class NetworkTemplate implements Parcelable {
          */
         @NonNull
         public Builder setWifiNetworkKeys(@NonNull Set<String> wifiNetworkKeys) {
-            Objects.requireNonNull(wifiNetworkKeys);
+            requireNonNull(wifiNetworkKeys);
             for (String key : wifiNetworkKeys) {
                 if (key == null) {
                     throw new IllegalArgumentException("Null is not a valid key");
@@ -1151,6 +1238,44 @@ public final class NetworkTemplate implements Parcelable {
             return this;
         }
 
+        /**
+         * Sets the transport type filter for this template.
+         *
+         * This is only valid when the template is constructed by using
+         * {@link NetworkTemplate.Builder}.
+         *
+         * @param transportType {@code NetworkCapabilities#TRANSPORT_*} constant.
+         * @return This {@code Builder} for chaining.
+           @hide
+         */
+        @NonNull
+        public Builder setTransportType(int transportType) {
+            if (mMatchRule != MATCH_ALL) {
+                throw new IllegalArgumentException("setTransportType is only supported for builder"
+                        + " built by default constructor.");
+            }
+            return setTransportTypes(new int[] {transportType});
+        }
+
+        /**
+         * Sets the transport types filter for this template.
+         *
+         * - If the array is empty, matches any transport type (wildcard).
+         * - If not empty, matches networks possessing ALL specified transport types.
+         * For example, a set with {@code TRANSPORT_WIFI} and {@code TRANSPORT_VPN}
+         * requires a network to have both.
+         *
+         * @param transportTypes The array of {@code NetworkCapabilities#TRANSPORT_*} constants.
+         *                       An empty array acts as a wildcard for all transports.
+         * @return This {@code Builder} for chaining.
+         * @hide
+         */
+        @NonNull
+        private Builder setTransportTypes(int[] transportTypes) {
+            mTransportTypesBits = BitUtils.packBits(transportTypes);
+            return this;
+        }
+
         /**
          * Set the OEM managed filter.
          *
@@ -1178,6 +1303,7 @@ public final class NetworkTemplate implements Parcelable {
 
         private void assertRequestableParameters() {
             validateWifiNetworkKeys();
+            validateTransportTypes();
             // TODO: Check all the input are legitimate.
         }
 
@@ -1190,6 +1316,22 @@ public final class NetworkTemplate implements Parcelable {
             }
         }
 
+        /**
+         * Validates that:
+         * 1. For MATCH_ALL, exactly one transport type is specified.
+         * 2. For all other match rules, no transport type should be specified.
+         */
+        private void validateTransportTypes() {
+            final int transportCount = Long.bitCount(mTransportTypesBits);
+            if (mMatchRule != MATCH_ALL && transportCount != 0) {
+                throw new IllegalArgumentException(
+                        "Transports type can't be set with a match rule.");
+            } else if (mMatchRule == MATCH_ALL && transportCount != 1) {
+                throw new IllegalArgumentException(
+                        "Transport type not set (use Builder#setTransportType).");
+            }
+        }
+
         /**
          * Builds the instance of the NetworkTemplate.
          *
@@ -1201,7 +1343,7 @@ public final class NetworkTemplate implements Parcelable {
             return new NetworkTemplate(mMatchRule,
                     mMatchSubscriberIds.toArray(new String[0]),
                     mMatchWifiNetworkKeys.toArray(new String[0]), mMetered, mRoaming,
-                    mDefaultNetwork, mRatType, mOemManaged);
+                    mDefaultNetwork, mRatType, mOemManaged, mTransportTypesBits);
         }
     }
 }
diff --git a/framework-t/src/android/net/nsd/AdvertisingRequest.java b/framework-t/src/android/net/nsd/AdvertisingRequest.java
index a62df65901..c2e7a0c7c9 100644
--- a/framework-t/src/android/net/nsd/AdvertisingRequest.java
+++ b/framework-t/src/android/net/nsd/AdvertisingRequest.java
@@ -52,6 +52,19 @@ public final class AdvertisingRequest implements Parcelable {
      */
     public static final long FLAG_SKIP_PROBING = 1 << 1;
 
+    /**
+     * Don't announce the subtype of the service.
+     * @hide
+     */
+    public static final long FLAG_SKIP_SUBTYPE_ANNOUNCEMENTS = 1L << 63;
+
+    /**
+     * Only for hardware offload, if this flag is set, NsdManager will only send callbacks to
+     * registered OffloadEngine, and not reply to mDNS queries by itself.
+     * @hide
+     */
+    public static final long FLAG_OFFLOAD_ONLY = 1L << 62;
+
     /** @hide */
     @Retention(RetentionPolicy.SOURCE)
     @LongDef(flag = true, prefix = {"FLAG_"}, value = {
diff --git a/framework-t/src/android/net/nsd/NsdManager.java b/framework-t/src/android/net/nsd/NsdManager.java
index 426a92d2bf..d5fa1deabe 100644
--- a/framework-t/src/android/net/nsd/NsdManager.java
+++ b/framework-t/src/android/net/nsd/NsdManager.java
@@ -1353,9 +1353,8 @@ public final class NsdManager {
      * @param listener The listener notifies of a successful registration and is used to
      * unregister this service through a call on {@link #unregisterService}. Cannot be null.
      *
-     * @hide
      */
-//    @FlaggedApi(Flags.ADVERTISE_REQUEST_API)
+    @FlaggedApi(Flags.FLAG_MDNS_ADVERTISING_IMPROVEMENT)
     public void registerService(@NonNull AdvertisingRequest advertisingRequest,
             @NonNull Executor executor,
             @NonNull RegistrationListener listener) {
diff --git a/framework/api/system-current.txt b/framework/api/system-current.txt
index bef29a4283..e631e5d9a4 100644
--- a/framework/api/system-current.txt
+++ b/framework/api/system-current.txt
@@ -433,8 +433,10 @@ package android.net {
   public abstract class QosFilter {
     method @NonNull public abstract android.net.Network getNetwork();
     method public abstract boolean matchesLocalAddress(@NonNull java.net.InetAddress, int, int);
+    method @FlaggedApi("com.android.net.flags.qos_filter_ip_range_matching") public abstract boolean matchesLocalPrefix(@NonNull android.net.IpPrefix, int, int);
     method public boolean matchesProtocol(int);
     method public abstract boolean matchesRemoteAddress(@NonNull java.net.InetAddress, int, int);
+    method @FlaggedApi("com.android.net.flags.qos_filter_ip_range_matching") public abstract boolean matchesRemotePrefix(@NonNull android.net.IpPrefix, int, int);
   }
 
   public final class QosSession implements android.os.Parcelable {
diff --git a/framework/proto/netstats.proto b/framework/proto/netstats.proto
index 3c9f73cc57..24e8714dcf 100644
--- a/framework/proto/netstats.proto
+++ b/framework/proto/netstats.proto
@@ -64,6 +64,8 @@ message NetworkIdentityProto {
   optional bool default_network = 6;
 
   optional int32 oem_managed_network = 7;
+
+  optional int64 transport_types = 8;
 }
 
 // Corresponds to NetworkStatsRecorder.
diff --git a/framework/src/android/net/ConnectivityManager.java b/framework/src/android/net/ConnectivityManager.java
index f8a1293a34..3a7d070670 100644
--- a/framework/src/android/net/ConnectivityManager.java
+++ b/framework/src/android/net/ConnectivityManager.java
@@ -6856,4 +6856,68 @@ public class ConnectivityManager {
             throw e.rethrowFromSystemServer();
         }
     }
+
+    /**
+     * Register QUIC UDP socket and UDP payload that can close QUIC connection.
+     *
+     * When the app loses network access (e.g. due to freezer or firewall chain),
+     * ConnectivityService 1)destroys the registered UDP socket by sending a SOCK_DESTROY netlink
+     * message and 2)sends the registered UDP payload to the server.
+     * This prevents unnecessary modem wakeups caused by packets from the server after the apps
+     * lose network access.
+     *
+     * Additionally, to close QUIC connection for apps that crash or are killed, ConnectivityService
+     * sends the registered UDP payload when it receives a socket destroy diag message for the
+     * registered socket.
+     *
+     * If apps call this method, they must call {@link #unregisterQuicConnectionClosePayload} before
+     * they close the QUIC connection and the socket.
+     * Otherwise, the registered UDP payload will be sent to the server, even if the QUIC connection
+     * was already properly closed. This is because ConnectivityService cannot distinguish whether
+     * the socket was closed due to the app being killed or because the app forgets to call
+     * {@link #unregisterQuicConnectionClosePayload}.
+     *
+     * The registered payload will be sent using the source and destination addresses and ports of
+     * the connected UDP socket provided. So, the app must not reuse the same socket to reconnect
+     * to a different server, even if first calls unregisterQuicConnectionClosePayload. This is
+     * because this method operates asynchronously.
+     *
+     * If the number of registered socket and payload hits the limit, ConnectivityService silently
+     * ignores new registration. ConnectivityService cannot know about this synchronously, but the
+     * caller couldn't really do anything with this information anyway.
+     * TODO: Consider adding a result listener if this API becomes public.
+     *
+     * @param pfd The {@link ParcelFileDescriptor} for the connected UDP socket.
+     *            The registered payload will be sent using the source and destination addresses and
+     *            ports of this connected UDP socket.
+     * @param payload The UDP payload that can close QUIC connection.
+     *
+     * @hide
+     */
+    public void registerQuicConnectionClosePayload(final ParcelFileDescriptor pfd,
+            final byte[] payload) {
+        try {
+            mService.registerQuicConnectionClosePayload(pfd, payload);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * Unregister the QUIC socket previously registered by
+     * {@link #registerQuicConnectionClosePayload}
+     *
+     * This method is a no-op if the provided UDP socket is not registered.
+     *
+     * @param pfd The {@link ParcelFileDescriptor} for the UDP socket.
+     *
+     * @hide
+     */
+    public void unregisterQuicConnectionClosePayload(final ParcelFileDescriptor pfd) {
+        try {
+            mService.unregisterQuicConnectionClosePayload(pfd);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
 }
diff --git a/framework/src/android/net/IConnectivityManager.aidl b/framework/src/android/net/IConnectivityManager.aidl
index a270684c40..0146e729a7 100644
--- a/framework/src/android/net/IConnectivityManager.aidl
+++ b/framework/src/android/net/IConnectivityManager.aidl
@@ -266,4 +266,7 @@ interface IConnectivityManager
     long getEnabledConnectivityManagerFeatures();
 
     boolean isConnectivityServiceFeatureEnabledForTesting(String featureFlag);
+
+    oneway void registerQuicConnectionClosePayload(in ParcelFileDescriptor pfd, in byte[] payload);
+    oneway void unregisterQuicConnectionClosePayload(in ParcelFileDescriptor pfd);
 }
diff --git a/framework/src/android/net/Network.java b/framework/src/android/net/Network.java
index 53f171a017..bc8071277a 100644
--- a/framework/src/android/net/Network.java
+++ b/framework/src/android/net/Network.java
@@ -29,6 +29,7 @@ import android.system.Os;
 import android.system.OsConstants;
 
 import com.android.internal.annotations.GuardedBy;
+import com.android.modules.utils.build.SdkLevel;
 
 import libcore.io.IoUtils;
 import libcore.net.http.Dns;
@@ -102,12 +103,7 @@ public class Network implements Parcelable {
     // and permission checks are made by netd (attempts to bypass Private DNS
     // without appropriate permission are silently turned into vanilla DNS
     // requests). This only affects DNS queries made using this network object.
-    //
-    // It it not parceled to receivers because (a) it can be set or cleared at
-    // anytime and (b) receivers should be explicit about attempts to bypass
-    // Private DNS so that the intent of the code is easily determined and
-    // code search audits are possible.
-    private final transient boolean mPrivateDnsBypass;
+    private final boolean mPrivateDnsBypass;
 
     /**
      * @hide
@@ -170,6 +166,18 @@ public class Network implements Parcelable {
         return new Network(netId, true);
     }
 
+    /**
+     * Obtain a Network object that respects the Private DNS settings when attempting
+     * to use {@link #getAllByName(String)}/{@link #getByName(String)} methods on the given
+     * instance for hostname resolution.
+     *
+     * @hide
+     */
+    // TODO : @SystemApi if this becomes useful.
+    public @NonNull Network getPrivateDnsNonBypassingCopy() {
+        return new Network(netId, false);
+    }
+
     /**
      * Get the unique id of the network.
      *
@@ -497,31 +505,35 @@ public class Network implements Parcelable {
     }
     public void writeToParcel(Parcel dest, int flags) {
         dest.writeInt(netId);
+        if (SdkLevel.isAtLeastB()) {
+            dest.writeBoolean(mPrivateDnsBypass);
+        } else {
+            dest.writeBoolean(false);
+        }
     }
 
     public static final @android.annotation.NonNull Creator<Network> CREATOR =
-        new Creator<Network>() {
-            public Network createFromParcel(Parcel in) {
-                int netId = in.readInt();
-
-                return new Network(netId);
-            }
+            new Creator<>() {
+                public Network createFromParcel(Parcel in) {
+                    final int netId = in.readInt();
+                    final boolean bypass = in.readBoolean();
+                    return new Network(netId, bypass);
+                }
 
-            public Network[] newArray(int size) {
-                return new Network[size];
-            }
-    };
+                public Network[] newArray(int size) {
+                    return new Network[size];
+                }
+            };
 
     @Override
     public boolean equals(@Nullable Object obj) {
-        if (!(obj instanceof Network)) return false;
-        Network other = (Network)obj;
+        if (!(obj instanceof Network other)) return false;
         return this.netId == other.netId;
     }
 
     @Override
     public int hashCode() {
-        return netId * 11;
+        return netId;
     }
 
     @Override
diff --git a/framework/src/android/net/NetworkAgent.java b/framework/src/android/net/NetworkAgent.java
index d5a1ef3e13..509b533b8e 100644
--- a/framework/src/android/net/NetworkAgent.java
+++ b/framework/src/android/net/NetworkAgent.java
@@ -679,6 +679,21 @@ public abstract class NetworkAgent {
                     synchronized (mRegisterLock) {
                         mState = STATE_UNREGISTERED;
                         mConnected = false;
+                        // Nulling out the registry here is necessary for the GC to notice that
+                        // this object can be reclaimed. Because:
+                        //  Here in the client side:
+                        // - the agent is a Binder object to the system server
+                        // - the agent owns the registry
+                        // - the registry is a Binder object from the system server
+                        //  On the system server side:
+                        // - the registry is a NetworkAgentInfo Binder to the client
+                        // - the NetworkAgentInfo owns the NetworkAgent
+                        // - the NetworkAgent is a Binder object from the client
+                        // This means there is a four-way binder interlock preventing the GC from
+                        // noticing these objects can be reclaimed. Nulling out the registry here
+                        // breaks that loop, which the GC can then unwind.
+                        // See b/400358935 for details.
+                        mRegistry = null;
                     }
                     break;
                 }
diff --git a/framework/src/android/net/QosFilter.java b/framework/src/android/net/QosFilter.java
index a731b23c10..c28671085f 100644
--- a/framework/src/android/net/QosFilter.java
+++ b/framework/src/android/net/QosFilter.java
@@ -16,9 +16,12 @@
 
 package android.net;
 
+import android.annotation.FlaggedApi;
 import android.annotation.NonNull;
 import android.annotation.SystemApi;
 
+import com.android.net.flags.Flags;
+
 import java.net.InetAddress;
 
 /**
@@ -93,6 +96,38 @@ public abstract class QosFilter {
     public abstract boolean matchesRemoteAddress(@NonNull InetAddress address,
             int startPort, int endPort);
 
+    /**
+     * Determines whether or not the parameters will be matched with prefix length, source address
+     * and port.
+     *
+     * @param ipPrefix the UE side IP address and prefix length included in IP packet filter set of
+     *     a QoS flow assigned on {@link Network}.
+     * @param startPort the start of UE side port range included in IP packet filter set of a QoS
+     *     flow assigned on {@link Network}.
+     * @param endPort the end of UE side port range included in IP packet filter set of a QoS flow
+     *     assigned on {@link Network}.
+     * @return whether the parameters match the UE side address and port of the filter
+     */
+    @FlaggedApi(Flags.FLAG_QOS_FILTER_IP_RANGE_MATCHING)
+    public abstract boolean matchesLocalPrefix(
+            @NonNull IpPrefix ipPrefix, int startPort, int endPort);
+
+    /**
+     * Determines whether or not the parameters will be matched with prefix length, remote address
+     * and port.
+     *
+     * @param ipPrefix the remote IP address and prefix length included in IP packet filter set of a
+     *     QoS flow assigned on {@link Network}.
+     * @param startPort the start of remote port range included in IP packet filter set of a QoS
+     *     flow assigned on {@link Network}.
+     * @param endPort the end of the remote range included in IP packet filter set of a QoS flow
+     *     assigned on {@link Network}.
+     * @return whether the parameters match the remote address and port of the filter
+     */
+    @FlaggedApi(Flags.FLAG_QOS_FILTER_IP_RANGE_MATCHING)
+    public abstract boolean matchesRemotePrefix(
+            @NonNull IpPrefix ipPrefix, int startPort, int endPort);
+
     /**
      * Determines whether or not the parameter will be matched with this filter.
      *
diff --git a/framework/src/android/net/QosSocketFilter.java b/framework/src/android/net/QosSocketFilter.java
index 5ceeb67127..ecc2af1446 100644
--- a/framework/src/android/net/QosSocketFilter.java
+++ b/framework/src/android/net/QosSocketFilter.java
@@ -36,6 +36,7 @@ import android.util.Log;
 import com.android.internal.annotations.VisibleForTesting;
 
 import java.io.FileDescriptor;
+import java.net.Inet4Address;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Socket;
@@ -179,10 +180,11 @@ public class QosSocketFilter extends QosFilter {
     @Override
     public boolean matchesLocalAddress(@NonNull final InetAddress address, final int startPort,
             final int endPort) {
-        if (mQosSocketInfo.getLocalSocketAddress() == null) {
-            return false;
-        }
-        return matchesAddress(mQosSocketInfo.getLocalSocketAddress(), address, startPort,
+        return matchesLocalPrefix(
+                address instanceof Inet4Address
+                        ? new IpPrefix(address, 32)
+                        : new IpPrefix(address, 128),
+                startPort,
                 endPort);
     }
 
@@ -192,11 +194,33 @@ public class QosSocketFilter extends QosFilter {
     @Override
     public boolean matchesRemoteAddress(@NonNull final InetAddress address, final int startPort,
             final int endPort) {
+        return matchesRemotePrefix(
+                address instanceof Inet4Address
+                        ? new IpPrefix(address, 32)
+                        : new IpPrefix(address, 128),
+                startPort,
+                endPort);
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public boolean matchesLocalPrefix(
+            @NonNull final IpPrefix ipPrefix, final int startPort, final int endPort) {
+        if (mQosSocketInfo.getLocalSocketAddress() == null) {
+            return false;
+        }
+        return matchesAddress(mQosSocketInfo.getLocalSocketAddress(), ipPrefix, startPort, endPort);
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public boolean matchesRemotePrefix(
+            @NonNull final IpPrefix ipPrefix, final int startPort, final int endPort) {
         if (mQosSocketInfo.getRemoteSocketAddress() == null) {
             return false;
         }
-        return matchesAddress(mQosSocketInfo.getRemoteSocketAddress(), address, startPort,
-                endPort);
+        return matchesAddress(
+                mQosSocketInfo.getRemoteSocketAddress(), ipPrefix, startPort, endPort);
     }
 
     /**
@@ -212,25 +236,27 @@ public class QosSocketFilter extends QosFilter {
     }
 
     /**
-     * Called from {@link QosSocketFilter#matchesLocalAddress(InetAddress, int, int)}
-     * and {@link QosSocketFilter#matchesRemoteAddress(InetAddress, int, int)} with the
-     * filterSocketAddress coming from {@link QosSocketInfo#getLocalSocketAddress()}.
-     * <p>
-     * This method exists for testing purposes since {@link QosSocketInfo} couldn't be mocked
-     * due to being final.
+     * Called from {@link QosSocketFilter#matchesLocalPrefix(IpPrefix, int, int)} and {@link
+     * QosSocketFilter#matchesRemotePrefix(IpPrefix, int, int)} with the filterSocketAddress coming
+     * from {@link QosSocketInfo#getLocalSocketAddress()}.
+     *
+     * <p>This method exists for testing purposes since {@link QosSocketInfo} couldn't be mocked due
+     * to being final.
      *
      * @param filterSocketAddress the socket address of the filter
-     * @param address the address to compare the filterSocketAddressWith
+     * @param ipPrefix the IP address with prefix length to compare the filterSocketAddressWith
      * @param startPort the start of the port range to check
      * @param endPort the end of the port range to check
      */
     @VisibleForTesting
-    public static boolean matchesAddress(@NonNull final InetSocketAddress filterSocketAddress,
-            @NonNull final InetAddress address,
-            final int startPort, final int endPort) {
+    public static boolean matchesAddress(
+            @NonNull final InetSocketAddress filterSocketAddress,
+            @NonNull final IpPrefix ipPrefix,
+            final int startPort,
+            final int endPort) {
         return startPort <= filterSocketAddress.getPort()
                 && endPort >= filterSocketAddress.getPort()
-                && (address.isAnyLocalAddress()
-                        || filterSocketAddress.getAddress().equals(address));
+                && (ipPrefix.getAddress().isAnyLocalAddress()
+                        || ipPrefix.contains(filterSocketAddress.getAddress()));
     }
 }
diff --git a/framework/src/android/net/connectivity/ConnectivityCompatChanges.java b/framework/src/android/net/connectivity/ConnectivityCompatChanges.java
index 27d605acf9..c3279306f9 100644
--- a/framework/src/android/net/connectivity/ConnectivityCompatChanges.java
+++ b/framework/src/android/net/connectivity/ConnectivityCompatChanges.java
@@ -111,6 +111,8 @@ public final class ConnectivityCompatChanges {
      * {@link android.net.ConnectivityManager#getActiveNetwork()} always returns null.
      * {@link android.net.ConnectivityManager.NetworkCallback#onBlockedStatusChanged()} is always
      * called with blocked=true.
+     * {@link android.net.ConnectivityManager#requestNetwork} can not bring up metered network if
+     * the uid is restricted from using metered networks.
      * <p>
      * For backwards compatibility, apps running on older releases, or targeting older SDK levels,
      * network access from apps without {@link android.Manifest.permission#INTERNET} permission is
diff --git a/networksecurity/service/src/com/android/server/net/ct/CertificateTransparencyDownloader.java b/networksecurity/service/src/com/android/server/net/ct/CertificateTransparencyDownloader.java
index 41b58fac59..e8e2a98937 100644
--- a/networksecurity/service/src/com/android/server/net/ct/CertificateTransparencyDownloader.java
+++ b/networksecurity/service/src/com/android/server/net/ct/CertificateTransparencyDownloader.java
@@ -32,8 +32,9 @@ import com.android.server.net.ct.DownloadHelper.DownloadStatus;
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.security.GeneralSecurityException;
 import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.Optional;
 
 /** Helper class to download certificate transparency log files. */
@@ -43,22 +44,21 @@ class CertificateTransparencyDownloader extends BroadcastReceiver {
     private static final String TAG = "CertificateTransparencyDownloader";
 
     private final Context mContext;
-    private final DataStore mDataStore;
     private final DownloadHelper mDownloadHelper;
     private final SignatureVerifier mSignatureVerifier;
     private final CertificateTransparencyLogger mLogger;
     private final Collection<CompatibilityVersion> mCompatVersions;
 
+    private final Map<String, Long> mDownloadIds = new HashMap<>();
+
     CertificateTransparencyDownloader(
             Context context,
-            DataStore dataStore,
             DownloadHelper downloadHelper,
             SignatureVerifier signatureVerifier,
             CertificateTransparencyLogger logger,
             Collection<CompatibilityVersion> compatVersions) {
         mContext = context;
         mSignatureVerifier = signatureVerifier;
-        mDataStore = dataStore;
         mDownloadHelper = downloadHelper;
         mLogger = logger;
         mCompatVersions = compatVersions;
@@ -67,8 +67,7 @@ class CertificateTransparencyDownloader extends BroadcastReceiver {
     long startPublicKeyDownload() {
         long downloadId = download(Config.URL_PUBLIC_KEY);
         if (downloadId != -1) {
-            mDataStore.setPropertyLong(Config.PUBLIC_KEY_DOWNLOAD_ID, downloadId);
-            mDataStore.store();
+            mDownloadIds.put(Config.PUBLIC_KEY_DOWNLOAD_ID, downloadId);
         }
         return downloadId;
     }
@@ -76,8 +75,7 @@ class CertificateTransparencyDownloader extends BroadcastReceiver {
     private long startMetadataDownload(CompatibilityVersion compatVersion) {
         long downloadId = download(compatVersion.getMetadataUrl());
         if (downloadId != -1) {
-            mDataStore.setPropertyLong(compatVersion.getMetadataPropertyName(), downloadId);
-            mDataStore.store();
+            mDownloadIds.put(compatVersion.getMetadataPropertyName(), downloadId);
         }
         return downloadId;
     }
@@ -97,8 +95,7 @@ class CertificateTransparencyDownloader extends BroadcastReceiver {
     long startContentDownload(CompatibilityVersion compatVersion) {
         long downloadId = download(compatVersion.getContentUrl());
         if (downloadId != -1) {
-            mDataStore.setPropertyLong(compatVersion.getContentPropertyName(), downloadId);
-            mDataStore.store();
+            mDownloadIds.put(compatVersion.getContentPropertyName(), downloadId);
         }
         return downloadId;
     }
@@ -151,10 +148,9 @@ class CertificateTransparencyDownloader extends BroadcastReceiver {
             return;
         }
 
-        try {
-            mSignatureVerifier.setPublicKeyFrom(publicKeyUri);
-        } catch (GeneralSecurityException | IOException | IllegalArgumentException e) {
-            Log.e(TAG, "Error setting the public Key", e);
+        LogListUpdateStatus updateStatus = mSignatureVerifier.setPublicKeyFrom(publicKeyUri);
+        if (!updateStatus.isPublicKeySet()) {
+            mLogger.logCTLogListUpdateStateChangedEvent(updateStatus);
             return;
         }
 
@@ -237,19 +233,17 @@ class CertificateTransparencyDownloader extends BroadcastReceiver {
 
     @VisibleForTesting
     long getPublicKeyDownloadId() {
-        return mDataStore.getPropertyLong(Config.PUBLIC_KEY_DOWNLOAD_ID, /* defaultValue= */ -1);
+        return mDownloadIds.getOrDefault(Config.PUBLIC_KEY_DOWNLOAD_ID, -1L);
     }
 
     @VisibleForTesting
     long getMetadataDownloadId(CompatibilityVersion compatVersion) {
-        return mDataStore.getPropertyLong(
-                compatVersion.getMetadataPropertyName(), /* defaultValue */ -1);
+        return mDownloadIds.getOrDefault(compatVersion.getMetadataPropertyName(), -1L);
     }
 
     @VisibleForTesting
     long getContentDownloadId(CompatibilityVersion compatVersion) {
-        return mDataStore.getPropertyLong(
-                compatVersion.getContentPropertyName(), /* defaultValue= */ -1);
+        return mDownloadIds.getOrDefault(compatVersion.getContentPropertyName(), -1L);
     }
 
     @VisibleForTesting
diff --git a/networksecurity/service/src/com/android/server/net/ct/CertificateTransparencyJob.java b/networksecurity/service/src/com/android/server/net/ct/CertificateTransparencyJob.java
index 286f3268bf..7240d729b7 100644
--- a/networksecurity/service/src/com/android/server/net/ct/CertificateTransparencyJob.java
+++ b/networksecurity/service/src/com/android/server/net/ct/CertificateTransparencyJob.java
@@ -37,7 +37,6 @@ public class CertificateTransparencyJob extends BroadcastReceiver {
     private static final String TAG = "CertificateTransparencyJob";
 
     private final Context mContext;
-    private final DataStore mDataStore;
     private final CertificateTransparencyDownloader mCertificateTransparencyDownloader;
     private final SignatureVerifier mSignatureVerifier;
     private final Collection<CompatibilityVersion> mCompatVersions;
@@ -50,12 +49,10 @@ public class CertificateTransparencyJob extends BroadcastReceiver {
     /** Creates a new {@link CertificateTransparencyJob} object. */
     public CertificateTransparencyJob(
             Context context,
-            DataStore dataStore,
             CertificateTransparencyDownloader certificateTransparencyDownloader,
             SignatureVerifier signatureVerifier,
             Collection<CompatibilityVersion> compatVersions) {
         mContext = context;
-        mDataStore = dataStore;
         mCertificateTransparencyDownloader = certificateTransparencyDownloader;
         mSignatureVerifier = signatureVerifier;
         mCompatVersions = compatVersions;
@@ -132,7 +129,6 @@ public class CertificateTransparencyJob extends BroadcastReceiver {
     }
 
     private void startDependencies() {
-        mDataStore.load();
         mSignatureVerifier.loadAllowedKeys();
         mContext.registerReceiver(
                 mCertificateTransparencyDownloader,
@@ -147,7 +143,6 @@ public class CertificateTransparencyJob extends BroadcastReceiver {
     private void stopDependencies() {
         mContext.unregisterReceiver(mCertificateTransparencyDownloader);
         mSignatureVerifier.clearAllowedKeys();
-        mDataStore.delete();
 
         if (Config.DEBUG) {
             Log.d(TAG, "CertificateTransparencyJob dependencies stopped.");
diff --git a/networksecurity/service/src/com/android/server/net/ct/CertificateTransparencyLogger.java b/networksecurity/service/src/com/android/server/net/ct/CertificateTransparencyLogger.java
index 2a37d8f778..b9c6d33533 100644
--- a/networksecurity/service/src/com/android/server/net/ct/CertificateTransparencyLogger.java
+++ b/networksecurity/service/src/com/android/server/net/ct/CertificateTransparencyLogger.java
@@ -36,11 +36,14 @@ public interface CertificateTransparencyLogger {
         UNKNOWN_STATE,
         HTTP_ERROR,
         LOG_LIST_INVALID,
+        PUBLIC_KEY_INVALID,
+        PUBLIC_KEY_NOT_ALLOWED,
         PUBLIC_KEY_NOT_FOUND,
         SIGNATURE_INVALID,
         SIGNATURE_NOT_FOUND,
         SIGNATURE_VERIFICATION_FAILED,
         SUCCESS,
+        UNABLE_TO_READ_FILE,
         VERSION_ALREADY_EXISTS
     }
 }
\ No newline at end of file
diff --git a/networksecurity/service/src/com/android/server/net/ct/CertificateTransparencyLoggerImpl.java b/networksecurity/service/src/com/android/server/net/ct/CertificateTransparencyLoggerImpl.java
index f617523f71..bec9cdcaeb 100644
--- a/networksecurity/service/src/com/android/server/net/ct/CertificateTransparencyLoggerImpl.java
+++ b/networksecurity/service/src/com/android/server/net/ct/CertificateTransparencyLoggerImpl.java
@@ -22,11 +22,14 @@ import static com.android.server.net.ct.CertificateTransparencyStatsLog.CERTIFIC
 import static com.android.server.net.ct.CertificateTransparencyStatsLog.CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_STATE_CHANGED__UPDATE_STATUS__FAILURE_HTTP_ERROR;
 import static com.android.server.net.ct.CertificateTransparencyStatsLog.CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_STATE_CHANGED__UPDATE_STATUS__FAILURE_LOG_LIST_INVALID;
 import static com.android.server.net.ct.CertificateTransparencyStatsLog.CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_STATE_CHANGED__UPDATE_STATUS__FAILURE_NO_DISK_SPACE;
+import static com.android.server.net.ct.CertificateTransparencyStatsLog.CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_STATE_CHANGED__UPDATE_STATUS__FAILURE_PUBLIC_KEY_INVALID;
+import static com.android.server.net.ct.CertificateTransparencyStatsLog.CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_STATE_CHANGED__UPDATE_STATUS__FAILURE_PUBLIC_KEY_NOT_ALLOWED;
 import static com.android.server.net.ct.CertificateTransparencyStatsLog.CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_STATE_CHANGED__UPDATE_STATUS__FAILURE_PUBLIC_KEY_NOT_FOUND;
 import static com.android.server.net.ct.CertificateTransparencyStatsLog.CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_STATE_CHANGED__UPDATE_STATUS__FAILURE_SIGNATURE_INVALID;
 import static com.android.server.net.ct.CertificateTransparencyStatsLog.CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_STATE_CHANGED__UPDATE_STATUS__FAILURE_SIGNATURE_NOT_FOUND;
 import static com.android.server.net.ct.CertificateTransparencyStatsLog.CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_STATE_CHANGED__UPDATE_STATUS__FAILURE_SIGNATURE_VERIFICATION;
 import static com.android.server.net.ct.CertificateTransparencyStatsLog.CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_STATE_CHANGED__UPDATE_STATUS__FAILURE_TOO_MANY_REDIRECTS;
+import static com.android.server.net.ct.CertificateTransparencyStatsLog.CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_STATE_CHANGED__UPDATE_STATUS__FAILURE_UNABLE_TO_READ_FILE;
 import static com.android.server.net.ct.CertificateTransparencyStatsLog.CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_STATE_CHANGED__UPDATE_STATUS__FAILURE_UNKNOWN;
 import static com.android.server.net.ct.CertificateTransparencyStatsLog.CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_STATE_CHANGED__UPDATE_STATUS__FAILURE_VERSION_ALREADY_EXISTS;
 import static com.android.server.net.ct.CertificateTransparencyStatsLog.CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_STATE_CHANGED__UPDATE_STATUS__PENDING_WAITING_FOR_WIFI;
@@ -37,32 +40,17 @@ import android.app.DownloadManager;
 /** Implementation for logging to statsd for Certificate Transparency. */
 class CertificateTransparencyLoggerImpl implements CertificateTransparencyLogger {
 
-    private final DataStore mDataStore;
-
-    CertificateTransparencyLoggerImpl(DataStore dataStore) {
-        mDataStore = dataStore;
-    }
-
     @Override
     public void logCTLogListUpdateStateChangedEvent(LogListUpdateStatus updateStatus) {
-        if (updateStatus.isSuccessful()) {
-            resetFailureCount();
-        } else {
-            updateFailureCount();
-        }
-
         int updateState =
                 updateStatus
                         .downloadStatus()
                         .map(s -> downloadStatusToFailureReason(s))
                         .orElseGet(() -> localEnumToStatsLogEnum(updateStatus.state()));
-        int failureCount =
-                mDataStore.getPropertyInt(
-                        Config.LOG_LIST_UPDATE_FAILURE_COUNT, /* defaultValue= */ 0);
 
         logCTLogListUpdateStateChangedEvent(
                 updateState,
-                failureCount,
+                /* failureCount= */ updateStatus.isSuccessful() ? 0 : 1,
                 updateStatus.httpErrorStatusCode(),
                 updateStatus.signature(),
                 updateStatus.logListTimestamp());
@@ -83,27 +71,6 @@ class CertificateTransparencyLoggerImpl implements CertificateTransparencyLogger
                 logListTimestamp);
     }
 
-    /**
-     * Resets the number of consecutive log list update failures in the data store back to zero.
-     */
-    private void resetFailureCount() {
-        mDataStore.setPropertyInt(Config.LOG_LIST_UPDATE_FAILURE_COUNT, /* value= */ 0);
-        mDataStore.store();
-    }
-
-    /**
-     * Updates the data store with the current number of consecutive log list update failures.
-     */
-    private void updateFailureCount() {
-        int failure_count =
-                mDataStore.getPropertyInt(
-                        Config.LOG_LIST_UPDATE_FAILURE_COUNT, /* defaultValue= */ 0);
-        int new_failure_count = failure_count + 1;
-
-        mDataStore.setPropertyInt(Config.LOG_LIST_UPDATE_FAILURE_COUNT, new_failure_count);
-        mDataStore.store();
-    }
-
     /** Converts DownloadStatus reason into failure reason to log. */
     private int downloadStatusToFailureReason(int downloadStatusReason) {
         switch (downloadStatusReason) {
@@ -133,6 +100,10 @@ class CertificateTransparencyLoggerImpl implements CertificateTransparencyLogger
                 return CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_STATE_CHANGED__UPDATE_STATUS__FAILURE_HTTP_ERROR;
             case LOG_LIST_INVALID:
                 return CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_STATE_CHANGED__UPDATE_STATUS__FAILURE_LOG_LIST_INVALID;
+            case PUBLIC_KEY_INVALID:
+                return CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_STATE_CHANGED__UPDATE_STATUS__FAILURE_PUBLIC_KEY_INVALID;
+            case PUBLIC_KEY_NOT_ALLOWED:
+                return CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_STATE_CHANGED__UPDATE_STATUS__FAILURE_PUBLIC_KEY_NOT_ALLOWED;
             case PUBLIC_KEY_NOT_FOUND:
                 return CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_STATE_CHANGED__UPDATE_STATUS__FAILURE_PUBLIC_KEY_NOT_FOUND;
             case SIGNATURE_INVALID:
@@ -143,6 +114,8 @@ class CertificateTransparencyLoggerImpl implements CertificateTransparencyLogger
                 return CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_STATE_CHANGED__UPDATE_STATUS__FAILURE_SIGNATURE_VERIFICATION;
             case SUCCESS:
                 return CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_STATE_CHANGED__UPDATE_STATUS__SUCCESS;
+            case UNABLE_TO_READ_FILE:
+                return CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_STATE_CHANGED__UPDATE_STATUS__FAILURE_UNABLE_TO_READ_FILE;
             case VERSION_ALREADY_EXISTS:
                 return CERTIFICATE_TRANSPARENCY_LOG_LIST_UPDATE_STATE_CHANGED__UPDATE_STATUS__FAILURE_VERSION_ALREADY_EXISTS;
             case UNKNOWN_STATE:
diff --git a/networksecurity/service/src/com/android/server/net/ct/CertificateTransparencyService.java b/networksecurity/service/src/com/android/server/net/ct/CertificateTransparencyService.java
index 5e530c74a6..edf44f4875 100644
--- a/networksecurity/service/src/com/android/server/net/ct/CertificateTransparencyService.java
+++ b/networksecurity/service/src/com/android/server/net/ct/CertificateTransparencyService.java
@@ -52,14 +52,9 @@ public class CertificateTransparencyService extends ICertificateTransparencyMana
 
     /** Creates a new {@link CertificateTransparencyService} object. */
     public CertificateTransparencyService(Context context) {
-        DataStore dataStore = new DataStore(Config.PREFERENCES_FILE);
         SignatureVerifier signatureVerifier = new SignatureVerifier(context);
         Collection<CompatibilityVersion> compatVersions =
                 Arrays.asList(
-                        new CompatibilityVersion(
-                                Config.COMPATIBILITY_VERSION_V1,
-                                Config.URL_SIGNATURE_V1,
-                                Config.URL_LOG_LIST_V1),
                         new CompatibilityVersion(
                                 Config.COMPATIBILITY_VERSION_V2,
                                 Config.URL_SIGNATURE_V2,
@@ -68,13 +63,11 @@ public class CertificateTransparencyService extends ICertificateTransparencyMana
         mCertificateTransparencyJob =
                 new CertificateTransparencyJob(
                         context,
-                        dataStore,
                         new CertificateTransparencyDownloader(
                                 context,
-                                dataStore,
                                 new DownloadHelper(context),
                                 signatureVerifier,
-                                new CertificateTransparencyLoggerImpl(dataStore),
+                                new CertificateTransparencyLoggerImpl(),
                                 compatVersions),
                         signatureVerifier,
                         compatVersions);
diff --git a/networksecurity/service/src/com/android/server/net/ct/CompatibilityVersion.java b/networksecurity/service/src/com/android/server/net/ct/CompatibilityVersion.java
index 0a91963ce4..201d6ad1a0 100644
--- a/networksecurity/service/src/com/android/server/net/ct/CompatibilityVersion.java
+++ b/networksecurity/service/src/com/android/server/net/ct/CompatibilityVersion.java
@@ -32,6 +32,7 @@ import org.json.JSONObject;
 
 import java.io.ByteArrayInputStream;
 import java.io.File;
+import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.file.Files;
@@ -55,8 +56,7 @@ class CompatibilityVersion {
     private final File mVersionDirectory;
     private final File mCurrentLogsDirSymlink;
 
-    CompatibilityVersion(
-            String compatVersion, String metadataUrl, String contentUrl) {
+    CompatibilityVersion(String compatVersion, String metadataUrl, String contentUrl) {
         mCompatVersion = compatVersion;
         mMetadataUrl = metadataUrl;
         mContentUrl = contentUrl;
@@ -79,22 +79,74 @@ class CompatibilityVersion {
      */
     LogListUpdateStatus install(InputStream newContent, LogListUpdateStatus.Builder statusBuilder)
             throws IOException {
-        String content = new String(newContent.readAllBytes(), UTF_8);
+        byte[] contentBytes = newContent.readAllBytes();
+        File logsDir = null;
+        long timestamp;
         try {
-            JSONObject contentJson = new JSONObject(content);
-            return install(
-                    new ByteArrayInputStream(content.getBytes()),
-                    contentJson.getString("version"),
-                    statusBuilder.setLogListTimestamp(contentJson.getLong("log_list_timestamp")));
+            JSONObject contentJson = new JSONObject(new String(contentBytes, UTF_8));
+            logsDir =
+                    new File(mVersionDirectory, LOGS_DIR_PREFIX + contentJson.getString("version"));
+            timestamp = contentJson.getLong("log_list_timestamp");
         } catch (JSONException e) {
             Log.e(TAG, "invalid log list format", e);
-
             return statusBuilder.setState(CTLogListUpdateState.LOG_LIST_INVALID).build();
         }
+
+        if (!shouldInstall(logsDir, timestamp)) {
+            Log.i(TAG, logsDir + " already exists, skipping install.");
+            deleteOldLogDirectories();
+            return statusBuilder
+                    .setLogListTimestamp(timestamp)
+                    .setState(CTLogListUpdateState.VERSION_ALREADY_EXISTS)
+                    .build();
+        }
+
+        return install(
+                new ByteArrayInputStream(contentBytes),
+                logsDir,
+                statusBuilder.setLogListTimestamp(timestamp));
+    }
+
+    boolean shouldInstall(File logsDir, long newTimestamp) throws IOException {
+        // This new version was not seen before, proceed with installation.
+        if (!logsDir.exists()) {
+            return true;
+        }
+
+        // If the symlink has not been updated then the previous installation failed and
+        // this is a re-attempt. Clean-up leftover files and try again.
+        if (!logsDir.getCanonicalPath().equals(mCurrentLogsDirSymlink.getCanonicalPath())) {
+            Log.i(TAG, logsDir + " installation failed, reattempt.");
+            DirectoryUtils.removeDir(logsDir);
+            return true;
+        }
+
+        long existingTimestamp;
+        try (InputStream logListFile =
+                new FileInputStream(new File(logsDir, LOGS_LIST_FILE_NAME))) {
+            existingTimestamp =
+                    new JSONObject(new String(logListFile.readAllBytes(), UTF_8))
+                            .getLong("log_list_timestamp");
+        } catch (JSONException e) {
+            Log.w(TAG, "The existing log list is not a valid JSON file", e);
+            DirectoryUtils.removeDir(logsDir);
+            return true;
+        }
+        // If the previous installation was successful but the new log list has a later timestamp it
+        // means it's a bug fix for a previously broken version.
+        if (existingTimestamp < newTimestamp) {
+            Log.i(TAG, "The new log list has a later timestamp.");
+            DirectoryUtils.removeDir(logsDir);
+            return true;
+        }
+
+        // In all other cases, the update died between steps 5 and 6 and so we cannot delete the
+        // directory since it is in use.
+        return false;
     }
 
     LogListUpdateStatus install(
-            InputStream newContent, String version, LogListUpdateStatus.Builder statusBuilder)
+            InputStream newContent, File newLogsDir, LogListUpdateStatus.Builder statusBuilder)
             throws IOException {
         // To support atomically replacing the old configuration directory with the new
         // there's a bunch of steps. We create a new directory with the logs and then do
@@ -103,32 +155,18 @@ class CompatibilityVersion {
         DirectoryUtils.makeDir(sRootDirectory);
         DirectoryUtils.makeDir(mVersionDirectory);
 
-        File newLogsDir = new File(mVersionDirectory, LOGS_DIR_PREFIX + version);
-        // 2. Handle the corner case where the new directory already exists.
-        if (newLogsDir.exists()) {
-            // If the symlink has already been updated then the update died between steps 6
-            // and 7 and so we cannot delete the directory since it is in use.
-            if (newLogsDir.getCanonicalPath().equals(mCurrentLogsDirSymlink.getCanonicalPath())) {
-                Log.i(TAG, newLogsDir + " already exists, skipping install.");
-                deleteOldLogDirectories();
-                return statusBuilder.setState(CTLogListUpdateState.VERSION_ALREADY_EXISTS).build();
-            }
-            // If the symlink has not been updated then the previous installation failed and
-            // this is a re-attempt. Clean-up leftover files and try again.
-            DirectoryUtils.removeDir(newLogsDir);
-        }
         try {
-            // 3. Create a new logs-<new_version>/ directory to store the new list.
+            // 2. Create a new logs-<new_version>/ directory to store the new list.
             DirectoryUtils.makeDir(newLogsDir);
 
-            // 4. Move the log list json file in logs-<new_version>/ .
+            // 3. Move the log list json file in logs-<new_version>/ .
             File logListFile = new File(newLogsDir, LOGS_LIST_FILE_NAME);
             if (Files.copy(newContent, logListFile.toPath()) == 0) {
                 throw new IOException("The log list appears empty");
             }
             DirectoryUtils.setWorldReadable(logListFile);
 
-            // 5. Create temp symlink. We rename to the target symlink for an atomic update.
+            // 4. Create temp symlink. We rename to the target symlink for an atomic update.
             File tempSymlink = new File(mVersionDirectory, "new_symlink");
             try {
                 Os.symlink(newLogsDir.getCanonicalPath(), tempSymlink.getCanonicalPath());
@@ -136,13 +174,13 @@ class CompatibilityVersion {
                 throw new IOException("Failed to create symlink", e);
             }
 
-            // 6. Update the symlink target, this is the actual update step.
+            // 5. Update the symlink target, this is the actual update step.
             tempSymlink.renameTo(mCurrentLogsDirSymlink.getAbsoluteFile());
         } catch (IOException | RuntimeException e) {
             DirectoryUtils.removeDir(newLogsDir);
             throw e;
         }
-        // 7. Cleanup
+        // 6. Cleanup
         Log.i(TAG, "New logs installed at " + newLogsDir);
         deleteOldLogDirectories();
         return statusBuilder.setState(CTLogListUpdateState.SUCCESS).build();
diff --git a/networksecurity/service/src/com/android/server/net/ct/Config.java b/networksecurity/service/src/com/android/server/net/ct/Config.java
index 72b715aefe..85351696ef 100644
--- a/networksecurity/service/src/com/android/server/net/ct/Config.java
+++ b/networksecurity/service/src/com/android/server/net/ct/Config.java
@@ -15,24 +15,11 @@
  */
 package com.android.server.net.ct;
 
-import android.content.ApexEnvironment;
-
-import com.android.net.module.util.DeviceConfigUtils;
-
-import java.io.File;
-
 /** Class holding the constants used by the CT feature. */
 final class Config {
 
     static final boolean DEBUG = false;
 
-    // preferences file
-    private static final File DEVICE_PROTECTED_DATA_DIR =
-            ApexEnvironment.getApexEnvironment(DeviceConfigUtils.TETHERING_MODULE_NAME)
-                    .getDeviceProtectedDataDir();
-    private static final String PREFERENCES_FILE_NAME = "ct.preferences";
-    static final File PREFERENCES_FILE = new File(DEVICE_PROTECTED_DATA_DIR, PREFERENCES_FILE_NAME);
-
     // CT paths
     static final String CT_ROOT_DIRECTORY_PATH = "/data/misc/keychain/ct/";
     static final String URL_PREFIX = "https://www.gstatic.com/android/certificate_transparency/";
diff --git a/networksecurity/service/src/com/android/server/net/ct/DataStore.java b/networksecurity/service/src/com/android/server/net/ct/DataStore.java
deleted file mode 100644
index 1f99efa8e4..0000000000
--- a/networksecurity/service/src/com/android/server/net/ct/DataStore.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.net.ct;
-
-import android.util.Log;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.util.Optional;
-import java.util.Properties;
-
-/** Class to persist data needed by CT. */
-class DataStore extends Properties {
-
-    private static final String TAG = "CertificateTransparency";
-
-    private final File mPropertyFile;
-
-    DataStore(File file) {
-        super();
-        mPropertyFile = file;
-    }
-
-    void load() {
-        if (!mPropertyFile.exists()) {
-            return;
-        }
-        try (InputStream in = new FileInputStream(mPropertyFile)) {
-            load(in);
-        } catch (IOException | IllegalArgumentException e) {
-            Log.e(TAG, "Error loading property store", e);
-            delete();
-        }
-    }
-
-    void store() {
-        try (OutputStream out = new FileOutputStream(mPropertyFile)) {
-            store(out, "");
-        } catch (IOException e) {
-            Log.e(TAG, "Error storing property store", e);
-        }
-    }
-
-    boolean delete() {
-        clear();
-        return mPropertyFile.delete();
-    }
-
-    long getPropertyLong(String key, long defaultValue) {
-        return Optional.ofNullable(getProperty(key)).map(Long::parseLong).orElse(defaultValue);
-    }
-
-    Object setPropertyLong(String key, long value) {
-        return setProperty(key, Long.toString(value));
-    }
-
-    int getPropertyInt(String key, int defaultValue) {
-        return Optional.ofNullable(getProperty(key)).map(Integer::parseInt).orElse(defaultValue);
-    }
-
-    Object setPropertyInt(String key, int value) {
-        return setProperty(key, Integer.toString(value));
-    }
-}
diff --git a/networksecurity/service/src/com/android/server/net/ct/LogListUpdateStatus.java b/networksecurity/service/src/com/android/server/net/ct/LogListUpdateStatus.java
index 3f9b762b4d..8b27529b45 100644
--- a/networksecurity/service/src/com/android/server/net/ct/LogListUpdateStatus.java
+++ b/networksecurity/service/src/com/android/server/net/ct/LogListUpdateStatus.java
@@ -15,11 +15,14 @@
  */
 package com.android.server.net.ct;
 
+import static com.android.server.net.ct.CertificateTransparencyLogger.CTLogListUpdateState.PUBLIC_KEY_INVALID;
+import static com.android.server.net.ct.CertificateTransparencyLogger.CTLogListUpdateState.PUBLIC_KEY_NOT_ALLOWED;
 import static com.android.server.net.ct.CertificateTransparencyLogger.CTLogListUpdateState.PUBLIC_KEY_NOT_FOUND;
 import static com.android.server.net.ct.CertificateTransparencyLogger.CTLogListUpdateState.SIGNATURE_INVALID;
 import static com.android.server.net.ct.CertificateTransparencyLogger.CTLogListUpdateState.SIGNATURE_NOT_FOUND;
 import static com.android.server.net.ct.CertificateTransparencyLogger.CTLogListUpdateState.SIGNATURE_VERIFICATION_FAILED;
 import static com.android.server.net.ct.CertificateTransparencyLogger.CTLogListUpdateState.SUCCESS;
+import static com.android.server.net.ct.CertificateTransparencyLogger.CTLogListUpdateState.UNABLE_TO_READ_FILE;
 
 import com.android.server.net.ct.CertificateTransparencyLogger.CTLogListUpdateState;
 
@@ -41,12 +44,20 @@ public abstract class LogListUpdateStatus {
 
     abstract Optional<Integer> downloadStatus();
 
+    boolean isPublicKeySet() {
+        // Check that none of the public key setting failures have been set as the state
+        return state() != PUBLIC_KEY_INVALID
+                && state() != PUBLIC_KEY_NOT_ALLOWED
+                && state() != UNABLE_TO_READ_FILE;
+    }
+
     boolean isSignatureVerified() {
         // Check that none of the signature verification failures have been set as the state
         return state() != PUBLIC_KEY_NOT_FOUND
                 && state() != SIGNATURE_INVALID
                 && state() != SIGNATURE_NOT_FOUND
-                && state() != SIGNATURE_VERIFICATION_FAILED;
+                && state() != SIGNATURE_VERIFICATION_FAILED
+                && state() != UNABLE_TO_READ_FILE;
     }
 
     boolean hasSignature() {
diff --git a/networksecurity/service/src/com/android/server/net/ct/SignatureVerifier.java b/networksecurity/service/src/com/android/server/net/ct/SignatureVerifier.java
index 87a497383f..42bba035fb 100644
--- a/networksecurity/service/src/com/android/server/net/ct/SignatureVerifier.java
+++ b/networksecurity/service/src/com/android/server/net/ct/SignatureVerifier.java
@@ -15,10 +15,13 @@
  */
 package com.android.server.net.ct;
 
+import static com.android.server.net.ct.CertificateTransparencyLogger.CTLogListUpdateState.PUBLIC_KEY_INVALID;
+import static com.android.server.net.ct.CertificateTransparencyLogger.CTLogListUpdateState.PUBLIC_KEY_NOT_ALLOWED;
 import static com.android.server.net.ct.CertificateTransparencyLogger.CTLogListUpdateState.PUBLIC_KEY_NOT_FOUND;
 import static com.android.server.net.ct.CertificateTransparencyLogger.CTLogListUpdateState.SIGNATURE_INVALID;
 import static com.android.server.net.ct.CertificateTransparencyLogger.CTLogListUpdateState.SIGNATURE_NOT_FOUND;
 import static com.android.server.net.ct.CertificateTransparencyLogger.CTLogListUpdateState.SIGNATURE_VERIFICATION_FAILED;
+import static com.android.server.net.ct.CertificateTransparencyLogger.CTLogListUpdateState.UNABLE_TO_READ_FILE;
 
 import android.annotation.NonNull;
 import android.annotation.RequiresApi;
@@ -84,28 +87,38 @@ public class SignatureVerifier {
         mPublicKey = Optional.empty();
     }
 
-    void setPublicKeyFrom(Uri file) throws GeneralSecurityException, IOException {
+    LogListUpdateStatus setPublicKeyFrom(Uri file) {
         try (InputStream fileStream = mContext.getContentResolver().openInputStream(file)) {
-            setPublicKey(new String(fileStream.readAllBytes()));
+            return setPublicKey(new String(fileStream.readAllBytes()));
+        } catch (IOException e) {
+            Log.e(TAG, "Could not read the public key file", e);
+            return LogListUpdateStatus.builder().setState(UNABLE_TO_READ_FILE).build();
         }
     }
 
-    void setPublicKey(String publicKey) throws GeneralSecurityException {
+    private LogListUpdateStatus setPublicKey(String publicKey) {
         byte[] decodedPublicKey = null;
+        LogListUpdateStatus.Builder statusBuilder = LogListUpdateStatus.builder();
+
         try {
             decodedPublicKey = Base64.getDecoder().decode(publicKey);
-        } catch (IllegalArgumentException e) {
-            throw new GeneralSecurityException("Invalid public key base64 encoding", e);
-        }
-        setPublicKey(
+            setPublicKey(
                 KeyFactory.getInstance("RSA")
                         .generatePublic(new X509EncodedKeySpec(decodedPublicKey)));
+        } catch (IllegalArgumentException e) {
+            statusBuilder.setState(PUBLIC_KEY_INVALID);
+            Log.w(TAG, "Invalid public key base64 encoding", e);
+        } catch (GeneralSecurityException e) {
+            statusBuilder.setState(PUBLIC_KEY_NOT_ALLOWED);
+            Log.e(TAG, "Public key not in allowlist", e);
+        }
+
+        return statusBuilder.build();
     }
 
     @VisibleForTesting
     void setPublicKey(PublicKey publicKey) throws GeneralSecurityException {
         if (!mAllowedKeys.contains(publicKey)) {
-            // TODO(b/400704086): add logging for this failure.
             throw new GeneralSecurityException("Public key not in allowlist");
         }
         mPublicKey = Optional.of(publicKey);
@@ -144,7 +157,11 @@ public class SignatureVerifier {
             Log.e(TAG, "Key invalid for log list verification", e);
             statusBuilder.setState(SIGNATURE_INVALID);
             return statusBuilder.build();
-        } catch (IOException | GeneralSecurityException e) {
+        } catch (IOException e) {
+            Log.e(TAG, "Could not read log list file", e);
+            statusBuilder.setState(UNABLE_TO_READ_FILE);
+            return statusBuilder.build();
+        } catch (GeneralSecurityException e) {
             Log.e(TAG, "Could not verify new log list", e);
             statusBuilder.setState(SIGNATURE_VERIFICATION_FAILED);
             return statusBuilder.build();
diff --git a/networksecurity/tests/test-apps/Android.bp b/networksecurity/tests/test-apps/Android.bp
new file mode 100644
index 0000000000..2882ca74fb
--- /dev/null
+++ b/networksecurity/tests/test-apps/Android.bp
@@ -0,0 +1,34 @@
+// Copyright (C) 2025 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package {
+    default_team: "trendy_team_rubidium_sdk_runtime",
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+android_app {
+    name: "CertificateTransparencyDemoApp",
+
+    manifest: "AndroidManifest.xml",
+
+    resource_dirs: ["res"],
+    srcs: [
+        "src/**/*.java",
+    ],
+    static_libs: [
+        "androidx-constraintlayout_constraintlayout",
+    ],
+
+    sdk_version: "current",
+}
diff --git a/networksecurity/tests/test-apps/AndroidManifest.xml b/networksecurity/tests/test-apps/AndroidManifest.xml
new file mode 100644
index 0000000000..276eb0fa31
--- /dev/null
+++ b/networksecurity/tests/test-apps/AndroidManifest.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- /*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */ -->
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    package="com.android.ctdemo">
+    <uses-permission android:name="android.permission.INTERNET" />
+    <application
+        android:allowBackup="true"
+        android:label="@string/app_name"
+        android:networkSecurityConfig="@xml/network_security_config"
+        android:supportsRtl="true"
+        android:theme="@style/Theme.AppCompat.DayNight.NoActionBar"
+        tools:targetApi="34">
+        <profileable android:shell="true" />
+        <activity
+            android:name=".MainActivity"
+            android:exported="true">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+</manifest>
diff --git a/networksecurity/tests/test-apps/res/layout/activity_main.xml b/networksecurity/tests/test-apps/res/layout/activity_main.xml
new file mode 100644
index 0000000000..513af95b3a
--- /dev/null
+++ b/networksecurity/tests/test-apps/res/layout/activity_main.xml
@@ -0,0 +1,58 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- /*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */ -->
+<androidx.constraintlayout.widget.ConstraintLayout
+  xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/main"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:paddingLeft="16dp"
+    android:paddingRight="16dp"
+    android:paddingTop="32dp"
+    tools:context=".MainActivity">
+  <LinearLayout
+      android:layout_width="match_parent"
+      android:layout_height="match_parent"
+      android:paddingLeft="16dp"
+      android:paddingRight="16dp"
+      android:paddingTop="32dp"
+      android:orientation="vertical"
+      tools:layout_editor_absoluteX="1dp">
+    <Button
+        android:id="@+id/button_wikipedia"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:text="Connect to wikipedia.org" />
+    <Button
+        android:id="@+id/button_valid_badssl"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:text="Connect to sha256.badssl.com" />
+    <Button
+        android:id="@+id/button_no_sct_badssl"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:text="Connect to no-sct.badssl.com" />
+    <TextView
+        android:id="@+id/textView"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:paddingTop="10dp"
+        android:text="this is empty" />
+  </LinearLayout>
+</androidx.constraintlayout.widget.ConstraintLayout>
\ No newline at end of file
diff --git a/networksecurity/tests/test-apps/res/values/strings.xml b/networksecurity/tests/test-apps/res/values/strings.xml
new file mode 100644
index 0000000000..3c36a8529e
--- /dev/null
+++ b/networksecurity/tests/test-apps/res/values/strings.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- /*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */ -->
+<resources>
+  <string name="app_name">CTDemo</string>
+</resources>
\ No newline at end of file
diff --git a/networksecurity/tests/test-apps/res/xml/network_security_config.xml b/networksecurity/tests/test-apps/res/xml/network_security_config.xml
new file mode 100644
index 0000000000..8cd2446fcb
--- /dev/null
+++ b/networksecurity/tests/test-apps/res/xml/network_security_config.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- /*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */ -->
+<network-security-config>
+  <base-config>
+    <certificateTransparency enabled="true" />
+  </base-config>
+</network-security-config>
\ No newline at end of file
diff --git a/networksecurity/tests/test-apps/src/com/android/ctdemo/MainActivity.java b/networksecurity/tests/test-apps/src/com/android/ctdemo/MainActivity.java
new file mode 100644
index 0000000000..56b56fa31d
--- /dev/null
+++ b/networksecurity/tests/test-apps/src/com/android/ctdemo/MainActivity.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.ctdemo;
+
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Trace;
+import android.view.View;
+import android.widget.Button;
+import android.widget.TextView;
+
+import androidx.appcompat.app.AppCompatActivity;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+public class MainActivity extends AppCompatActivity {
+
+    Handler handler;
+    int cookie;
+
+    private void connectTo(String urlString, TextView textView) {
+        int myCookie = cookie++;
+        URL url = null;
+        long startTime = System.nanoTime();
+        Trace.beginAsyncSection("connectTo", myCookie);
+        try {
+            url = new URL(urlString);
+        } catch (MalformedURLException e) {
+            Trace.endAsyncSection("connectTo", myCookie);
+            handler.post(
+                    new Runnable() {
+                        @Override
+                        public void run() {
+                            textView.setText(e.toString());
+                        }
+                    });
+            return;
+        }
+        HttpURLConnection urlConnection = null;
+        try {
+            urlConnection = (HttpURLConnection) url.openConnection();
+        } catch (IOException e) {
+            Trace.endAsyncSection("connectTo", myCookie);
+            long estimatedTime = (System.nanoTime() - startTime) / 1000;
+            handler.post(
+                    new Runnable() {
+                        @Override
+                        public void run() {
+                            textView.setText("Failure in " + estimatedTime + " us");
+                        }
+                    });
+            return;
+        }
+        try {
+            InputStream in = new BufferedInputStream(urlConnection.getInputStream());
+            in.read();
+        } catch (IOException e) {
+            Trace.endAsyncSection("connectTo", myCookie);
+            long estimatedTime = (System.nanoTime() - startTime) / 1000;
+            handler.post(
+                    new Runnable() {
+                        @Override
+                        public void run() {
+                            textView.setText("Failure in " + estimatedTime + " us");
+                        }
+                    });
+        }
+        Trace.endAsyncSection("connectTo", myCookie);
+        long estimatedTime = (System.nanoTime() - startTime) / 1000;
+        handler.post(
+                new Runnable() {
+                    @Override
+                    public void run() {
+                        textView.setText("Success in " + estimatedTime + " us");
+                    }
+                });
+        urlConnection.disconnect();
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_main);
+        ExecutorService executor = Executors.newSingleThreadExecutor();
+        handler = new Handler(Looper.getMainLooper());
+        Button buttonWikipedia = (Button) findViewById(R.id.button_wikipedia);
+        Button buttonValid = (Button) findViewById(R.id.button_valid_badssl);
+        Button buttonNoSCT = (Button) findViewById(R.id.button_no_sct_badssl);
+        final TextView textView = (TextView) findViewById(R.id.textView);
+        buttonWikipedia.setOnClickListener(
+                new View.OnClickListener() {
+                    public void onClick(View v) {
+                        executor.execute(
+                                new Runnable() {
+                                    @Override
+                                    public void run() {
+                                        connectTo("https://www.android.com", textView);
+                                    }
+                                });
+                    }
+                });
+        buttonValid.setOnClickListener(
+                new View.OnClickListener() {
+                    public void onClick(View v) {
+                        executor.execute(
+                                new Runnable() {
+                                    @Override
+                                    public void run() {
+                                        connectTo("https://sha256.badssl.com/", textView);
+                                    }
+                                });
+                    }
+                });
+        buttonNoSCT.setOnClickListener(
+                new View.OnClickListener() {
+                    public void onClick(View v) {
+                        executor.execute(
+                                new Runnable() {
+                                    @Override
+                                    public void run() {
+                                        connectTo("https://no-sct.badssl.com/", textView);
+                                    }
+                                });
+                    }
+                });
+    }
+}
diff --git a/networksecurity/tests/unit/src/com/android/server/net/ct/CertificateTransparencyDownloaderTest.java b/networksecurity/tests/unit/src/com/android/server/net/ct/CertificateTransparencyDownloaderTest.java
index 956bad57cd..17ea85adf3 100644
--- a/networksecurity/tests/unit/src/com/android/server/net/ct/CertificateTransparencyDownloaderTest.java
+++ b/networksecurity/tests/unit/src/com/android/server/net/ct/CertificateTransparencyDownloaderTest.java
@@ -76,7 +76,6 @@ public class CertificateTransparencyDownloaderTest {
     private PrivateKey mPrivateKey;
     private PublicKey mPublicKey;
     private Context mContext;
-    private DataStore mDataStore;
     private SignatureVerifier mSignatureVerifier;
     private CompatibilityVersion mCompatVersion;
     private CertificateTransparencyDownloader mCertificateTransparencyDownloader;
@@ -93,7 +92,6 @@ public class CertificateTransparencyDownloaderTest {
         mPublicKey = keyPair.getPublic();
 
         mContext = InstrumentationRegistry.getInstrumentation().getContext();
-        mDataStore = new DataStore(File.createTempFile("datastore-test", ".properties"));
         mSignatureVerifier = new SignatureVerifier(mContext);
 
         CompatibilityVersion.setRootDirectoryForTesting(mContext.getFilesDir());
@@ -105,7 +103,6 @@ public class CertificateTransparencyDownloaderTest {
         mCertificateTransparencyDownloader =
                 new CertificateTransparencyDownloader(
                         mContext,
-                        mDataStore,
                         new DownloadHelper(mDownloadManager),
                         mSignatureVerifier,
                         mLogger,
@@ -113,14 +110,12 @@ public class CertificateTransparencyDownloaderTest {
 
         prepareDownloadManager();
         mSignatureVerifier.addAllowedKey(mPublicKey);
-        mDataStore.load();
     }
 
     @After
     public void tearDown() {
         mSignatureVerifier.resetPublicKey();
         mCompatVersion.delete();
-        mDataStore.delete();
     }
 
     @Test
@@ -182,6 +177,59 @@ public class CertificateTransparencyDownloaderTest {
         assertThat(mCertificateTransparencyDownloader.hasMetadataDownloadId()).isFalse();
     }
 
+    @Test
+    public void testDownloader_publicKeyDownloadSuccess_publicKeyFileNotRead_logsFailure()
+            throws Exception {
+        mCertificateTransparencyDownloader.startPublicKeyDownload();
+
+        File publicKeyFile = writePublicKeyToFile(mPublicKey);
+        // Set the public key file to not be readable to simulate an IOException being thrown
+        publicKeyFile.setReadable(false);
+        mCertificateTransparencyDownloader.onReceive(
+                mContext, makePublicKeyDownloadCompleteIntent(publicKeyFile));
+
+        verify(mLogger, times(1))
+                .logCTLogListUpdateStateChangedEvent(
+                        LogListUpdateStatus.builder()
+                                .setState(CTLogListUpdateState.UNABLE_TO_READ_FILE)
+                                .build());
+    }
+
+    @Test
+    public void
+            testDownloader_publicKeyDownloadSuccess_publicKeyNotAllowed_logsFailure()
+                    throws Exception {
+        mCertificateTransparencyDownloader.startPublicKeyDownload();
+        PublicKey notAllowed = KeyPairGenerator.getInstance("RSA").generateKeyPair().getPublic();
+
+        mCertificateTransparencyDownloader.onReceive(
+                mContext, makePublicKeyDownloadCompleteIntent(writePublicKeyToFile(notAllowed)));
+
+        verify(mLogger, times(1))
+                .logCTLogListUpdateStateChangedEvent(
+                        LogListUpdateStatus.builder()
+                                .setState(CTLogListUpdateState.PUBLIC_KEY_NOT_ALLOWED)
+                                .build());
+    }
+
+    @Test
+    public void
+            testDownloader_publicKeyDownloadSuccess_publicKeyInvalidEncoding_logsFailure()
+                    throws Exception {
+        mCertificateTransparencyDownloader.startPublicKeyDownload();
+
+        mCertificateTransparencyDownloader.onReceive(
+                mContext,
+                makePublicKeyDownloadCompleteIntent(
+                        writeToFile("i_am_not_a_base64_encoded_public_key".getBytes())));
+
+        verify(mLogger, times(1))
+                .logCTLogListUpdateStateChangedEvent(
+                        LogListUpdateStatus.builder()
+                                .setState(CTLogListUpdateState.PUBLIC_KEY_INVALID)
+                                .build());
+    }
+
     @Test
     public void
             testDownloader_publicKeyDownloadSuccess_updatePublicKeyFail_doNotStartMetadataDownload()
@@ -216,7 +264,7 @@ public class CertificateTransparencyDownloaderTest {
     }
 
     @Test
-    public void testDownloader_publicKeyDownloadFail_logsFailure() throws Exception {
+    public void testDownloader_publicKeyDownloadFail_logsDownloadFailure() throws Exception {
         mCertificateTransparencyDownloader.startPublicKeyDownload();
 
         mCertificateTransparencyDownloader.onReceive(
@@ -365,6 +413,27 @@ public class CertificateTransparencyDownloaderTest {
                 .isEqualTo(CTLogListUpdateState.PUBLIC_KEY_NOT_FOUND);
     }
 
+    @Test
+    public void testDownloader_contentDownloadSuccess_signatureFileNotRead_logsSingleFailure()
+            throws Exception {
+        File logListFile = makeLogListFile("456");
+        File metadataFile = sign(logListFile);
+        mSignatureVerifier.setPublicKey(mPublicKey);
+        mCertificateTransparencyDownloader.startMetadataDownload();
+
+        mCertificateTransparencyDownloader.onReceive(
+                mContext, makeMetadataDownloadCompleteIntent(mCompatVersion, metadataFile));
+        // Set the log list file to not be readable to simulate an IOException being thrown
+        logListFile.setReadable(false);
+        mCertificateTransparencyDownloader.onReceive(
+                mContext, makeContentDownloadCompleteIntent(mCompatVersion, logListFile));
+
+        verify(mLogger, times(1))
+                .logCTLogListUpdateStateChangedEvent(mUpdateStatusCaptor.capture());
+        assertThat(mUpdateStatusCaptor.getValue().state())
+                .isEqualTo(CTLogListUpdateState.UNABLE_TO_READ_FILE);
+    }
+
     @Test
     public void testDownloader_contentDownloadSuccess_wrongSignatureAlgo_logsSingleFailure()
             throws Exception {
diff --git a/networksecurity/tests/unit/src/com/android/server/net/ct/CompatibilityVersionTest.java b/networksecurity/tests/unit/src/com/android/server/net/ct/CompatibilityVersionTest.java
index 0d15183140..7964350fa3 100644
--- a/networksecurity/tests/unit/src/com/android/server/net/ct/CompatibilityVersionTest.java
+++ b/networksecurity/tests/unit/src/com/android/server/net/ct/CompatibilityVersionTest.java
@@ -120,7 +120,7 @@ public class CompatibilityVersionTest {
 
         try (InputStream inputStream = asStream(logList)) {
             assertThat(mCompatVersion.install(inputStream, LogListUpdateStatus.builder()))
-                    .isEqualTo(getSuccessfulUpdateStatus());
+                    .isEqualTo(getSuccessfulUpdateStatus(LOG_LIST_TIMESTAMP));
         }
 
         File logListFile = mCompatVersion.getLogsFile();
@@ -147,9 +147,9 @@ public class CompatibilityVersionTest {
 
     @Test
     public void testCompatibilityVersion_deleteSuccessfully() throws Exception {
-        try (InputStream inputStream = asStream(makeLogList(/* version= */ "123"))) {
+        try (InputStream inputStream = asStream(makeLogList(/* version= */ "123", "any_content"))) {
             assertThat(mCompatVersion.install(inputStream, LogListUpdateStatus.builder()))
-                    .isEqualTo(getSuccessfulUpdateStatus());
+                    .isEqualTo(getSuccessfulUpdateStatus(LOG_LIST_TIMESTAMP));
         }
 
         mCompatVersion.delete();
@@ -182,27 +182,35 @@ public class CompatibilityVersionTest {
         JSONObject newLogList = makeLogList(existingVersion, "i_am_the_real_content");
         try (InputStream inputStream = asStream(newLogList)) {
             assertThat(mCompatVersion.install(inputStream, LogListUpdateStatus.builder()))
-                    .isEqualTo(getSuccessfulUpdateStatus());
+                    .isEqualTo(getSuccessfulUpdateStatus(LOG_LIST_TIMESTAMP));
         }
 
         assertThat(readAsString(logsListFile)).isEqualTo(newLogList.toString());
     }
 
     @Test
-    public void testCompatibilityVersion_versionAlreadyExists_installFails() throws Exception {
+    public void testCompatibilityVersion_versionAlreadyExists_earlierTimestamp_installFails()
+            throws Exception {
         String existingVersion = "666";
-        JSONObject existingLogList = makeLogList(existingVersion, "i_was_installed_successfully");
+        long existingTimestamp = 123456;
+        JSONObject existingLogList =
+                makeLogList(existingVersion, "i_was_installed_successfully", existingTimestamp);
         try (InputStream inputStream = asStream(existingLogList)) {
             assertThat(mCompatVersion.install(inputStream, LogListUpdateStatus.builder()))
-                    .isEqualTo(getSuccessfulUpdateStatus());
+                    .isEqualTo(getSuccessfulUpdateStatus(existingTimestamp));
         }
 
-        try (InputStream inputStream = asStream(makeLogList(existingVersion, "i_am_ignored"))) {
+        try (InputStream inputStream =
+                asStream(
+                        makeLogList(
+                                existingVersion,
+                                "i_am_same_version_but_older",
+                                existingTimestamp - 1))) {
             assertThat(mCompatVersion.install(inputStream, LogListUpdateStatus.builder()))
                     .isEqualTo(
                             LogListUpdateStatus.builder()
                                     .setState(VERSION_ALREADY_EXISTS)
-                                    .setLogListTimestamp(LOG_LIST_TIMESTAMP)
+                                    .setLogListTimestamp(existingTimestamp - 1)
                                     .build());
         }
 
@@ -210,24 +218,48 @@ public class CompatibilityVersionTest {
                 .isEqualTo(existingLogList.toString());
     }
 
+    @Test
+    public void testCompatibilityVersion_versionAlreadyExists_laterTimestamp_installSucceeds()
+            throws Exception {
+        String existingVersion = "666";
+        long existingTimestamp = 123456L;
+        JSONObject existingLogList =
+                makeLogList(existingVersion, "i_was_installed_successfully", existingTimestamp);
+        try (InputStream inputStream = asStream(existingLogList)) {
+            assertThat(mCompatVersion.install(inputStream, LogListUpdateStatus.builder()))
+                    .isEqualTo(getSuccessfulUpdateStatus(existingTimestamp));
+        }
+
+        JSONObject newLogList =
+                makeLogList(existingVersion, "i_am_same_version_but_newer", existingTimestamp + 1);
+        try (InputStream inputStream = asStream(newLogList)) {
+            assertThat(mCompatVersion.install(inputStream, LogListUpdateStatus.builder()))
+                    .isEqualTo(getSuccessfulUpdateStatus(existingTimestamp + 1));
+        }
+
+        assertThat(readAsString(mCompatVersion.getLogsFile())).isEqualTo(newLogList.toString());
+    }
+
     private static InputStream asStream(JSONObject logList) throws IOException {
         return new ByteArrayInputStream(logList.toString().getBytes());
     }
 
-    private static JSONObject makeLogList(String version) throws JSONException {
-        return new JSONObject()
-                .put("version", version)
-                .put("log_list_timestamp", LOG_LIST_TIMESTAMP);
+    private static JSONObject makeLogList(String version, String content) throws JSONException {
+        return makeLogList(version, content, LOG_LIST_TIMESTAMP);
     }
 
-    private static JSONObject makeLogList(String version, String content) throws JSONException {
-        return makeLogList(version).put("content", content);
+    private static JSONObject makeLogList(String version, String content, long timestamp)
+            throws JSONException {
+        return new JSONObject()
+                .put("version", version)
+                .put("log_list_timestamp", timestamp)
+                .put("content", content);
     }
 
-    private static LogListUpdateStatus getSuccessfulUpdateStatus() {
+    private static LogListUpdateStatus getSuccessfulUpdateStatus(long timestamp) {
         return LogListUpdateStatus.builder()
                 .setState(SUCCESS)
-                .setLogListTimestamp(LOG_LIST_TIMESTAMP)
+                .setLogListTimestamp(timestamp)
                 .build();
     }
 
diff --git a/networksecurity/tests/unit/src/com/android/server/net/ct/DataStoreTest.java b/networksecurity/tests/unit/src/com/android/server/net/ct/DataStoreTest.java
deleted file mode 100644
index 3e670d4f91..0000000000
--- a/networksecurity/tests/unit/src/com/android/server/net/ct/DataStoreTest.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.server.net.ct;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.File;
-import java.io.IOException;
-
-/** Tests for the {@link DataStore}. */
-@RunWith(JUnit4.class)
-public class DataStoreTest {
-
-    private File mTempFile;
-    private DataStore mDataStore;
-
-    @Before
-    public void setUp() throws IOException {
-        mTempFile = File.createTempFile("datastore-test", ".properties");
-        mDataStore = new DataStore(mTempFile);
-    }
-
-    @After
-    public void tearDown() {
-        mTempFile.delete();
-    }
-
-    @Test
-    public void testDataStore_propertyFileCreatedSuccessfully() {
-        assertThat(mTempFile.exists()).isTrue();
-        assertThat(mDataStore.isEmpty()).isTrue();
-    }
-
-    @Test
-    public void testDataStore_propertySet() {
-        String stringProperty = "prop1";
-        String stringValue = "i_am_a_string";
-        String longProperty = "prop3";
-        long longValue = 9000;
-
-        assertThat(mDataStore.getProperty(stringProperty)).isNull();
-        assertThat(mDataStore.getPropertyLong(longProperty, -1)).isEqualTo(-1);
-
-        mDataStore.setProperty(stringProperty, stringValue);
-        mDataStore.setPropertyLong(longProperty, longValue);
-
-        assertThat(mDataStore.getProperty(stringProperty)).isEqualTo(stringValue);
-        assertThat(mDataStore.getPropertyLong(longProperty, -1)).isEqualTo(longValue);
-    }
-
-    @Test
-    public void testDataStore_propertyStore() {
-        String stringProperty = "prop1";
-        String stringValue = "i_am_a_string";
-        String longProperty = "prop3";
-        long longValue = 9000;
-
-        mDataStore.setProperty(stringProperty, stringValue);
-        mDataStore.setPropertyLong(longProperty, longValue);
-        mDataStore.store();
-
-        mDataStore.clear();
-        assertThat(mDataStore.getProperty(stringProperty)).isNull();
-        assertThat(mDataStore.getPropertyLong(longProperty, -1)).isEqualTo(-1);
-
-        mDataStore.load();
-        assertThat(mDataStore.getProperty(stringProperty)).isEqualTo(stringValue);
-        assertThat(mDataStore.getPropertyLong(longProperty, -1)).isEqualTo(longValue);
-    }
-}
diff --git a/preupload_hook_script.py b/preupload_hook_script.py
new file mode 100755
index 0000000000..e2a6401080
--- /dev/null
+++ b/preupload_hook_script.py
@@ -0,0 +1,93 @@
+#!/usr/bin/env python3
+# Copyright 2025, The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+"""Preupload hook to perform necessary checks and formatting on python files."""
+
+import argparse
+import concurrent.futures
+import multiprocessing
+import pathlib
+import shlex
+import subprocess
+import sys
+
+
+def _filter_python_files(files: list[pathlib.Path]) -> list[pathlib.Path]:
+  """Filter a list of files and return a new list of python files only."""
+  return [file for file in files if file.suffix == '.py']
+
+
+def _check_run_shell_command(cmd: str, cwd: str = None) -> None:
+  """Run a shell command and raise error if failed."""
+  if subprocess.run(shlex.split(cmd), cwd=cwd, check=False).returncode:
+    print('Preupload files did not pass Connectivity preupload hook script.')
+    sys.exit(1)
+
+
+def _run_pyformat(files: list[pathlib.Path]) -> None:
+  """Run pyformat on certain projects."""
+  if subprocess.run(
+      shlex.split('which pyformat'),
+      check=False,
+  ).returncode:
+    print('pyformat not available. Please run sudo apt install pyformat.')
+    sys.exit(1)
+
+  def _run_pyformat_on_file(file):
+    completed_process = subprocess.run(
+        shlex.split('pyformat --force_quote_type single ' + file.as_posix()),
+        capture_output=True,
+        check=False,
+    )
+
+    if completed_process.stdout:
+      subprocess.run(
+          shlex.split(
+              'pyformat -i --force_quote_type single ' + file.as_posix()
+          ),
+          check=False,
+      )
+      return True
+    return False
+
+  cpu_count = multiprocessing.cpu_count()
+  with concurrent.futures.ThreadPoolExecutor(max_workers=cpu_count) as executor:
+    need_reformat = executor.map(
+        _run_pyformat_on_file, _filter_python_files(files)
+    )
+
+  if any(need_reformat):
+    print(
+        'Reformatting completed. Please add the modified files to git and rerun'
+        ' the repo preupload hook.'
+    )
+    sys.exit(1)
+
+
+def get_preupload_files() -> list[pathlib.Path]:
+  """Get the list of files to be uploaded."""
+  parser = argparse.ArgumentParser()
+  parser.add_argument('preupload_files', nargs='*', help='Files to upload.')
+  args = parser.parse_args()
+  files_to_upload = args.preupload_files
+  file_paths_to_upload = [
+      pathlib.Path(file).resolve() for file in files_to_upload
+  ]
+  return [file for file in file_paths_to_upload if file.exists()]
+
+
+if __name__ == '__main__':
+  preupload_files = get_preupload_files()
+  _run_pyformat(preupload_files)
diff --git a/remoteauth/OWNERS b/remoteauth/OWNERS
index ee46c1ce66..a05f57d491 100644
--- a/remoteauth/OWNERS
+++ b/remoteauth/OWNERS
@@ -2,7 +2,6 @@
 # Bug template url: http://b/new?component=1145231&template=1715387
 billyhuang@google.com
 boetger@google.com
-derekjedral@google.com
 dlm@google.com
 igorzas@google.com
 jacobhobbie@google.com
diff --git a/rustfmt.toml b/rustfmt.toml
new file mode 120000
index 0000000000..475ba8fde7
--- /dev/null
+++ b/rustfmt.toml
@@ -0,0 +1 @@
+../../../build/soong/scripts/rustfmt.toml
\ No newline at end of file
diff --git a/service-t/src/com/android/server/NsdService.java b/service-t/src/com/android/server/NsdService.java
index 4af8b0e981..7a72f72246 100644
--- a/service-t/src/com/android/server/NsdService.java
+++ b/service-t/src/com/android/server/NsdService.java
@@ -19,11 +19,14 @@ package com.android.server;
 import static android.Manifest.permission.DEVICE_POWER;
 import static android.Manifest.permission.NETWORK_SETTINGS;
 import static android.Manifest.permission.NETWORK_STACK;
+import static android.content.pm.PackageManager.FEATURE_LEANBACK;
 import static android.net.ConnectivityManager.NETID_UNSET;
 import static android.net.NetworkCapabilities.TRANSPORT_VPN;
 import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
 import static android.net.NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK;
+import static android.net.nsd.AdvertisingRequest.FLAG_OFFLOAD_ONLY;
 import static android.net.nsd.AdvertisingRequest.FLAG_SKIP_PROBING;
+import static android.net.nsd.AdvertisingRequest.FLAG_SKIP_SUBTYPE_ANNOUNCEMENTS;
 import static android.net.nsd.NsdManager.MDNS_DISCOVERY_MANAGER_EVENT;
 import static android.net.nsd.NsdManager.MDNS_SERVICE_EVENT;
 import static android.net.nsd.NsdManager.RESOLVE_SERVICE_SUCCEEDED;
@@ -802,6 +805,19 @@ public class NsdService extends INsdManager.Stub {
                 return true;
             }
 
+            private boolean isOffloadOnlyAllowed() {
+                if (!mContext.getPackageManager().hasSystemFeature(FEATURE_LEANBACK)) {
+                    return false;
+                }
+                // The offload-only code path is a fallback for Google Cast on Android TV devices.
+                // To utilize APF-based mDNS offload, the service must be advertised via
+                // NsdManager. However, limitations or edge cases might prevent Google Cast
+                // service advertisement through NsdManager. Until these issues are resolved,
+                // MediaShell can use the offload-only code path to still leverage APF for offload.
+                // This code path is only valid in Android B TV release.
+                return Build.VERSION_CODES.BAKLAVA == Build.VERSION.SDK_INT;
+            }
+
             @Override
             public boolean processMessage(Message msg) {
                 final ClientInfo clientInfo;
@@ -1044,16 +1060,27 @@ public class NsdService extends INsdManager.Stub {
                                         NsdManager.FAILURE_BAD_PARAMETERS, false /* isLegacy */);
                                 break;
                             }
+                            final boolean isOffloadOnly =
+                                    (advertisingRequest.getFlags() & FLAG_OFFLOAD_ONLY) != 0;
+                            if (isOffloadOnly && !isOffloadOnlyAllowed()) {
+                                clientInfo.onRegisterServiceFailedImmediately(clientRequestId,
+                                        NsdManager.FAILURE_BAD_PARAMETERS, false /* isLegacy */);
+                                break;
+                            }
 
                             serviceInfo.setSubtypes(subtypes);
                             maybeStartMonitoringSockets();
                             final boolean skipProbing = (advertisingRequest.getFlags()
-                                    & FLAG_SKIP_PROBING) > 0;
+                                    & FLAG_SKIP_PROBING) != 0;
+                            final boolean skipSubtypeAnnouncements = (advertisingRequest.getFlags()
+                                    & FLAG_SKIP_SUBTYPE_ANNOUNCEMENTS) != 0;
                             final MdnsAdvertisingOptions mdnsAdvertisingOptions =
                                     MdnsAdvertisingOptions.newBuilder()
                                             .setIsOnlyUpdate(isUpdateOnly)
                                             .setSkipProbing(skipProbing)
                                             .setTtl(advertisingRequest.getTtl())
+                                            .setSkipSubtypeAnnouncements(skipSubtypeAnnouncements)
+                                            .setOffloadOnly(isOffloadOnly)
                                             .build();
                             mAdvertiser.addOrUpdateService(transactionId, serviceInfo,
                                     mdnsAdvertisingOptions, clientInfo.mUid);
@@ -1949,6 +1976,10 @@ public class NsdService extends INsdManager.Stub {
                         MdnsFeatureFlags.DEFAULT_CACHED_SERVICES_RETENTION_TIME_MILLISECONDS))
                 .setIsShortHostnamesEnabled(mDeps.isTetheringFeatureNotChickenedOut(
                         mContext, MdnsFeatureFlags.NSD_USE_SHORT_HOSTNAMES))
+                .setIsCacheFlushPerAddressTypeEnabled(mDeps.isTetheringFeatureNotChickenedOut(
+                        mContext, MdnsFeatureFlags.NSD_CACHE_FLUSH_PER_ADDRESS_TYPE))
+                .setIsIgnoreTemporaryIPv6AddressesEnabled(mDeps.isTetheringFeatureNotChickenedOut(
+                        mContext, MdnsFeatureFlags.NSD_IGNORE_TEMPORARY_IPV6_ADDRESSES))
                 .setOverrideProvider(new MdnsFeatureFlags.FlagOverrideProvider() {
                     @Override
                     public boolean isForceEnabledForTest(@NonNull String flag) {
diff --git a/service-t/src/com/android/server/connectivity/mdns/ConnectivityMonitorWithConnectivityManager.java b/service-t/src/com/android/server/connectivity/mdns/ConnectivityMonitorWithConnectivityManager.java
index 87aa0d2295..0f5dc7e10a 100644
--- a/service-t/src/com/android/server/connectivity/mdns/ConnectivityMonitorWithConnectivityManager.java
+++ b/service-t/src/com/android/server/connectivity/mdns/ConnectivityMonitorWithConnectivityManager.java
@@ -16,17 +16,36 @@
 
 package com.android.server.connectivity.mdns;
 
+import android.content.BroadcastReceiver;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.TargetApi;
 import android.content.Context;
 import android.net.ConnectivityManager;
+import android.net.LinkProperties;
 import android.net.Network;
 import android.net.NetworkCapabilities;
 import android.net.NetworkRequest;
+import android.net.wifi.WifiManager;
 import android.os.Build;
+import android.util.ArrayMap;
+import android.util.Pair;
 
+import androidx.annotation.GuardedBy;
+
+import com.android.net.module.util.CollectionUtils;
 import com.android.net.module.util.SharedLog;
 
+import java.net.Inet6Address;
+import java.net.InetAddress;
+import java.net.NetworkInterface;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.function.Predicate;
+
 /** Class for monitoring connectivity changes using {@link ConnectivityManager}. */
 public class ConnectivityMonitorWithConnectivityManager implements ConnectivityMonitor {
     private static final String TAG = "ConnMntrWConnMgr";
@@ -34,6 +53,18 @@ public class ConnectivityMonitorWithConnectivityManager implements ConnectivityM
     private final Listener listener;
     private final ConnectivityManager.NetworkCallback networkCallback;
     private final ConnectivityManager connectivityManager;
+    private final Context context;
+    private final boolean supportsIncludeOtherUidNetworks =
+        Build.VERSION.SDK_INT >= Build.VERSION_CODES.S;
+    private final BroadcastReceiver networkChangedReceiver =
+        new BroadcastReceiver() {
+            @Override
+            public void onReceive(Context context, Intent intent) {
+                notifyConnectivityChange();
+            }
+        };
+    @GuardedBy("knownNetworks")
+    private final ArrayMap<Network, LinkProperties> knownNetworks = new ArrayMap<>();
     // TODO(b/71901993): Ideally we shouldn't need this flag. However we still don't have clues why
     // the receiver is unregistered twice yet.
     private boolean isCallbackRegistered = false;
@@ -45,21 +76,33 @@ public class ConnectivityMonitorWithConnectivityManager implements ConnectivityM
             SharedLog sharedLog) {
         this.listener = listener;
         this.sharedLog = sharedLog;
+        this.context = context;
 
         connectivityManager =
                 (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
         networkCallback =
                 new ConnectivityManager.NetworkCallback() {
                     @Override
-                    public void onAvailable(Network network) {
-                        sharedLog.log("network available.");
-                        lastAvailableNetwork = network;
-                        notifyConnectivityChange();
+                    public void onLinkPropertiesChanged(
+                            @NonNull Network network,
+                            @NonNull LinkProperties linkProperties) {
+                        final boolean newNetwork;
+                        synchronized (knownNetworks) {
+                            newNetwork = knownNetworks.put(network, linkProperties) == null;
+                        }
+                        if (newNetwork) {
+                            sharedLog.log("network available: " + network);
+                            lastAvailableNetwork = network;
+                            notifyConnectivityChange();
+                        }
                     }
 
                     @Override
                     public void onLost(Network network) {
-                        sharedLog.log("network lost.");
+                        sharedLog.log("network lost: " + network);
+                        synchronized (knownNetworks) {
+                            knownNetworks.remove(network);
+                        }
                         notifyConnectivityChange();
                     }
 
@@ -88,10 +131,21 @@ public class ConnectivityMonitorWithConnectivityManager implements ConnectivityM
             return;
         }
 
-        connectivityManager.registerNetworkCallback(
-                new NetworkRequest.Builder().addTransportType(
-                        NetworkCapabilities.TRANSPORT_WIFI).build(),
-                networkCallback);
+        final NetworkRequest.Builder builder =
+            new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI);
+        if (supportsIncludeOtherUidNetworks) {
+            builder.setIncludeOtherUidNetworks(true);
+        }
+        connectivityManager.registerNetworkCallback(builder.build(), networkCallback);
+
+        if (!supportsIncludeOtherUidNetworks) {
+            // Since networks created via ConnectivityManager#requestNetwork with a
+            // WifiNetworkSpecifier cannot be obtained via callbacks before S due to the lack of
+            // setIncludeOtherUidNetworks, register a Wi-Fi BroadcastReceiver to ensure network
+            // state is updated.
+            context.registerReceiver(
+                networkChangedReceiver, new IntentFilter(WifiManager.NETWORK_STATE_CHANGED_ACTION));
+        }
         isCallbackRegistered = true;
     }
 
@@ -105,6 +159,12 @@ public class ConnectivityMonitorWithConnectivityManager implements ConnectivityM
         }
 
         connectivityManager.unregisterNetworkCallback(networkCallback);
+        if (!supportsIncludeOtherUidNetworks) {
+            context.unregisterReceiver(networkChangedReceiver);
+        }
+        synchronized (knownNetworks) {
+            knownNetworks.clear();
+        }
         isCallbackRegistered = false;
     }
 
@@ -113,4 +173,95 @@ public class ConnectivityMonitorWithConnectivityManager implements ConnectivityM
     public Network getAvailableNetwork() {
         return lastAvailableNetwork;
     }
-}
\ No newline at end of file
+
+    /**
+     * Try to guess which network a remote host may be in.
+     *
+     * <p>This is not a perfect guess as it depends on the timing of LinkProperties updates and
+     * interfaces going up/down. Also, it is possible that two interfaces have overlapping prefixes,
+     * in which case it is not possible to know which one is correct from just an address. This is
+     * intended as an incremental improvement for legacy code that cannot use MdnsSocketProvider,
+     * which uses per-Network sockets to avoid this problem.
+     *
+     * @param address The address of a remote host.
+     * @return The SocketKey with Network and interface if it could be determined, or null.
+     */
+    @Nullable
+    public SocketKey guessNetworkOfRemoteHost(@NonNull List<NetworkInterfaceWrapper> knownIfaces,
+            @NonNull InetAddress address) {
+        if (address instanceof Inet6Address && address.isLinkLocalAddress()) {
+            final int scopeId = ((Inet6Address) address).getScopeId();
+            for (NetworkInterfaceWrapper iface : knownIfaces) {
+                if (iface.getIndex() == scopeId) {
+                    return getSocketKeyForInterface(iface.getNetworkInterface());
+                }
+            }
+            return null;
+        }
+        // Find a matching network from the address.
+        final Pair<Network, LinkProperties> match = findMatchingNetwork(lp ->
+                // Do not consider stacked links (lp.getAllRoutes), as they are generally not
+                // compatible with MDNS, and this is consistent with MdnsSocketProvider.
+                // Note LinkProperties does not always contain routes for local subnets before P
+                // (change ID I35b614eebccfd22c4a5270f40256f9be1e25abfb), but on M+ Wi-Fi does add
+                // them from netlink/DHCP.
+                // Look for the address in directly-connected routes (no gateway).
+                // Note RouteInfo#hasGateway would be equivalent and simpler but is API 29+
+                CollectionUtils.any(lp.getRoutes(), r ->
+                      (r.getGateway() == null || r.getGateway().isAnyLocalAddress())
+                      && r.matches(address)));
+        if (match == null) {
+            return null;
+        }
+        // Find a matching interface index for the network.
+        final NetworkInterfaceWrapper netIf = CollectionUtils.findFirst(knownIfaces, iface ->
+                iface.getName().equals(match.second.getInterfaceName()));
+        if (netIf == null) {
+            return null;
+        }
+        return new SocketKey(match.first, netIf.getIndex());
+    }
+
+    @Nullable
+    private SocketKey getSocketKeyForInterface(@Nullable NetworkInterface iface) {
+        if (iface == null) {
+            return null;
+        }
+        final Pair<Network, LinkProperties> match = findMatchingNetwork(
+                lp -> iface.getName().equals(lp.getInterfaceName()));
+        return match == null ? null : new SocketKey(match.first, iface.getIndex());
+    }
+
+    private Pair<Network, LinkProperties> findMatchingNetwork(
+            @NonNull Predicate<LinkProperties> predicate) {
+        final Set<Network> testedNetworks;
+        synchronized (knownNetworks) {
+            for (int i = 0; i < knownNetworks.size(); i++) {
+                final LinkProperties lp = knownNetworks.valueAt(i);
+                // Do not consider stacked links (lp.getAllInterfaceNames), as they are generally
+                // not compatible with MDNS, and this is consistent with MdnsSocketProvider.
+                if (predicate.test(lp)) {
+                    return new Pair<>(knownNetworks.keyAt(i), knownNetworks.valueAt(i));
+                }
+            }
+            testedNetworks = new HashSet<>(knownNetworks.keySet());
+        }
+        if (!supportsIncludeOtherUidNetworks) {
+            // Before S setIncludeOtherUidNetworks cannot be set on the NetworkRequest, so it
+            // will not match networks brought up by apps via networkRequest with a
+            // WifiNetworkSpecifier (which have uids set in their NetworkCapabilities on S+, or
+            // requestor UID set on R-).
+            // Fall back to synchronous methods if no matching network could be found.
+            for (Network network : connectivityManager.getAllNetworks()) {
+                if (testedNetworks.contains(network)) {
+                    continue;
+                }
+                final LinkProperties lp = connectivityManager.getLinkProperties(network);
+                if (lp != null && predicate.test(lp)) {
+                    return new Pair<>(network, lp);
+                }
+            }
+        }
+        return null;
+    }
+}
diff --git a/service-t/src/com/android/server/connectivity/mdns/EnqueueMdnsQueryCallable.java b/service-t/src/com/android/server/connectivity/mdns/EnqueueMdnsQueryCallable.java
index 81ba53081e..856e2054d9 100644
--- a/service-t/src/com/android/server/connectivity/mdns/EnqueueMdnsQueryCallable.java
+++ b/service-t/src/com/android/server/connectivity/mdns/EnqueueMdnsQueryCallable.java
@@ -16,8 +16,6 @@
 
 package com.android.server.connectivity.mdns;
 
-import static com.android.server.connectivity.mdns.MdnsServiceTypeClient.INVALID_TRANSACTION_ID;
-
 import android.annotation.NonNull;
 import android.os.Build;
 import android.text.TextUtils;
@@ -26,6 +24,7 @@ import android.util.Pair;
 import com.android.net.module.util.CollectionUtils;
 import com.android.net.module.util.DnsUtils;
 import com.android.net.module.util.SharedLog;
+import com.android.server.connectivity.mdns.MdnsServiceTypeClient.QuerySentResult;
 import com.android.server.connectivity.mdns.util.MdnsUtils;
 
 import java.io.IOException;
@@ -44,7 +43,7 @@ import java.util.concurrent.Callable;
  * and the list of the subtypes in the query as a {@link Pair}. If a query is failed to build, or if
  * it can not be enqueued, then call to {@link #call()} returns {@code null}.
  */
-public class EnqueueMdnsQueryCallable implements Callable<Pair<Integer, List<String>>> {
+public class EnqueueMdnsQueryCallable implements Callable<QuerySentResult> {
 
     private static final String TAG = "MdnsQueryCallable";
     private static final List<Integer> castShellEmulatorMdnsPorts;
@@ -68,8 +67,6 @@ public class EnqueueMdnsQueryCallable implements Callable<Pair<Integer, List<Str
     private final String[] serviceTypeLabels;
     @NonNull
     private final List<String> subtypes;
-    private final boolean expectUnicastResponse;
-    private final int transactionId;
     @NonNull
     private final SocketKey socketKey;
     private final boolean sendDiscoveryQueries;
@@ -86,13 +83,13 @@ public class EnqueueMdnsQueryCallable implements Callable<Pair<Integer, List<Str
     @NonNull
     private final List<MdnsResponse> existingServices;
     private final boolean isQueryWithKnownAnswer;
+    private final MdnsQueryScheduler.ScheduledQueryTaskArgs taskArgs;
 
     EnqueueMdnsQueryCallable(
             @NonNull MdnsSocketClientBase requestSender,
             @NonNull String serviceType,
             @NonNull Collection<String> subtypes,
-            boolean expectUnicastResponse,
-            int transactionId,
+            MdnsQueryScheduler.ScheduledQueryTaskArgs taskArgs,
             @NonNull SocketKey socketKey,
             boolean onlyUseIpv6OnIpv6OnlyNetworks,
             boolean sendDiscoveryQueries,
@@ -105,8 +102,7 @@ public class EnqueueMdnsQueryCallable implements Callable<Pair<Integer, List<Str
         weakRequestSender = new WeakReference<>(requestSender);
         serviceTypeLabels = TextUtils.split(serviceType, "\\.");
         this.subtypes = new ArrayList<>(subtypes);
-        this.expectUnicastResponse = expectUnicastResponse;
-        this.transactionId = transactionId;
+        this.taskArgs = taskArgs;
         this.socketKey = socketKey;
         this.onlyUseIpv6OnIpv6OnlyNetworks = onlyUseIpv6OnIpv6OnlyNetworks;
         this.sendDiscoveryQueries = sendDiscoveryQueries;
@@ -126,18 +122,23 @@ public class EnqueueMdnsQueryCallable implements Callable<Pair<Integer, List<Str
     // Incompatible return type for override of Callable#call().
     @SuppressWarnings("nullness:override.return.invalid")
     @Override
-    public Pair<Integer, List<String>> call() {
+    public QuerySentResult call() {
         try {
             MdnsSocketClientBase requestSender = weakRequestSender.get();
             if (requestSender == null) {
-                return Pair.create(INVALID_TRANSACTION_ID, new ArrayList<>());
+                return QuerySentResult.createFailedQueryResult(taskArgs);
             }
 
             final List<MdnsRecord> questions = new ArrayList<>();
+            final boolean expectUnicastResponse = taskArgs.config.expectUnicastResponse;
+            final int transactionId = taskArgs.config.getTransactionId();
+            final List<MdnsResponse> resolvedServices = new ArrayList<>();
+            boolean queriedBaseType = false;
 
             if (sendDiscoveryQueries) {
                 // Base service type
                 questions.add(new MdnsPointerRecord(serviceTypeLabels, expectUnicastResponse));
+                queriedBaseType = true;
                 for (String subtype : subtypes) {
                     final String[] labels = MdnsUtils.constructFullSubtype(serviceTypeLabels,
                             MdnsConstants.SUBTYPE_PREFIX + subtype);
@@ -154,6 +155,7 @@ public class EnqueueMdnsQueryCallable implements Callable<Pair<Integer, List<Str
                         response.getTextRecord(), now);
                 boolean renewSrv = !response.hasServiceRecord() || MdnsUtils.isRecordRenewalNeeded(
                         response.getServiceRecord(), now);
+                final int questionsBeforeAdding = questions.size();
                 if (renewSrv && renewTxt) {
                     questions.add(new MdnsAnyRecord(serviceName, expectUnicastResponse));
                 } else {
@@ -176,11 +178,14 @@ public class EnqueueMdnsQueryCallable implements Callable<Pair<Integer, List<Str
                                 host, MdnsRecord.TYPE_AAAA, expectUnicastResponse));
                     }
                 }
+                if (questions.size() > questionsBeforeAdding) {
+                    resolvedServices.add(response);
+                }
             }
 
             if (questions.size() == 0) {
                 // No query to send
-                return Pair.create(INVALID_TRANSACTION_ID, new ArrayList<>());
+                return QuerySentResult.createFailedQueryResult(taskArgs);
             }
 
             // Put the existing ptr records into known-answer section.
@@ -217,11 +222,12 @@ public class EnqueueMdnsQueryCallable implements Callable<Pair<Integer, List<Str
             for (Integer emulatorPort : castShellEmulatorMdnsPorts) {
                 sendPacketToIpv4AndIpv6(requestSender, emulatorPort, queryPacket);
             }
-            return Pair.create(transactionId, subtypes);
+            return new QuerySentResult(
+                    transactionId, subtypes, taskArgs, queriedBaseType, resolvedServices);
         } catch (Exception e) {
             sharedLog.e(String.format("Failed to create mDNS packet for subtype: %s.",
                     TextUtils.join(",", subtypes)), e);
-            return Pair.create(INVALID_TRANSACTION_ID, new ArrayList<>());
+            return QuerySentResult.createFailedQueryResult(taskArgs);
         }
     }
 
@@ -229,7 +235,7 @@ public class EnqueueMdnsQueryCallable implements Callable<Pair<Integer, List<Str
             MdnsPacket mdnsPacket) throws IOException {
         final List<DatagramPacket> packets = dependencies.getDatagramPacketsFromMdnsPacket(
                 packetCreationBuffer, mdnsPacket, address, isQueryWithKnownAnswer);
-        if (expectUnicastResponse) {
+        if (taskArgs.config.expectUnicastResponse) {
             // MdnsMultinetworkSocketClient is only available on T+
             if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU
                     && requestSender instanceof MdnsMultinetworkSocketClient) {
diff --git a/service-t/src/com/android/server/connectivity/mdns/MdnsAdvertiser.java b/service-t/src/com/android/server/connectivity/mdns/MdnsAdvertiser.java
index bd00b706e8..bd7b8b585f 100644
--- a/service-t/src/com/android/server/connectivity/mdns/MdnsAdvertiser.java
+++ b/service-t/src/com/android/server/connectivity/mdns/MdnsAdvertiser.java
@@ -643,7 +643,7 @@ public class MdnsAdvertiser {
         public final @NonNull OffloadServiceInfo mOffloadServiceInfo;
         public final int mServiceId;
 
-        OffloadServiceInfoWrapper(int serviceId, OffloadServiceInfo offloadServiceInfo) {
+        public OffloadServiceInfoWrapper(int serviceId, OffloadServiceInfo offloadServiceInfo) {
             mOffloadServiceInfo = offloadServiceInfo;
             mServiceId = serviceId;
         }
@@ -1027,17 +1027,13 @@ public class MdnsAdvertiser {
         });
     }
 
-    private List<String> getOffloadSubtype(@NonNull NsdServiceInfo nsdServiceInfo) {
-        // Workaround: Google Cast doesn't announce subtypes per DNS-SD/mDNS spec.
-        // Thus, subtypes aren't offloaded; only "_googlecast._tcp" is.
-        // Subtype responses occur when hardware offload is off.
-        // This solution works because Google Cast doesn't follow the intended usage of subtypes in
-        // the spec, as it always discovers for both the subtype+base type, and only uses the mDNS
-        // subtype as an optimization.
-        if (nsdServiceInfo.getServiceType().equals("_googlecast._tcp")) {
+    private List<String> getOffloadSubtype(@NonNull Registration registration) {
+        final NsdServiceInfo serviceInfo = registration.getServiceInfo();
+        // If skipSubtypeAnnouncements is set, we should not offload subtypes.
+        if (registration.mAdvertisingOptions.skipSubtypeAnnouncements()) {
             return new ArrayList<>();
         }
-        return new ArrayList<>(nsdServiceInfo.getSubtypes());
+        return new ArrayList<>(serviceInfo.getSubtypes());
     }
 
     private OffloadServiceInfoWrapper createOffloadService(int serviceId,
@@ -1050,7 +1046,7 @@ public class MdnsAdvertiser {
         final OffloadServiceInfo offloadServiceInfo = new OffloadServiceInfo(
                 new OffloadServiceInfo.Key(nsdServiceInfo.getServiceName(),
                         nsdServiceInfo.getServiceType()),
-                getOffloadSubtype(nsdServiceInfo),
+                getOffloadSubtype(registration),
                 String.join(".", mDeviceHostName),
                 rawOffloadPacket,
                 priority,
diff --git a/service-t/src/com/android/server/connectivity/mdns/MdnsAdvertisingOptions.java b/service-t/src/com/android/server/connectivity/mdns/MdnsAdvertisingOptions.java
index 5133d4f730..3e47c0bbbe 100644
--- a/service-t/src/com/android/server/connectivity/mdns/MdnsAdvertisingOptions.java
+++ b/service-t/src/com/android/server/connectivity/mdns/MdnsAdvertisingOptions.java
@@ -35,14 +35,19 @@ public class MdnsAdvertisingOptions {
     @Nullable
     private final Duration mTtl;
     private final boolean mSkipProbing;
+    private final boolean mSkipSubtypeAnnouncements;
+    private final boolean mIsOffloadOnly;
 
     /**
      * Parcelable constructs for a {@link MdnsAdvertisingOptions}.
      */
-    MdnsAdvertisingOptions(boolean isOnlyUpdate, @Nullable Duration ttl, boolean skipProbing) {
+    MdnsAdvertisingOptions(boolean isOnlyUpdate, @Nullable Duration ttl, boolean skipProbing,
+            boolean skipSubtypeAnnouncements, boolean isOffloadOnly) {
         this.mIsOnlyUpdate = isOnlyUpdate;
         this.mTtl = ttl;
         this.mSkipProbing = skipProbing;
+        this.mSkipSubtypeAnnouncements = skipSubtypeAnnouncements;
+        this.mIsOffloadOnly = isOffloadOnly;
     }
 
     /**
@@ -76,6 +81,13 @@ public class MdnsAdvertisingOptions {
         return mSkipProbing;
     }
 
+    /**
+     * @return {@code true} if this request is an offload only request.
+     */
+    public boolean isOffloadOnly() {
+        return mIsOffloadOnly;
+    }
+
     /**
      * Returns the TTL for all records in a service.
      */
@@ -84,6 +96,13 @@ public class MdnsAdvertisingOptions {
         return mTtl;
     }
 
+    /**
+     * Returns {@code true} if subtype announcements should be skipped.
+     */
+    public boolean skipSubtypeAnnouncements() {
+        return mSkipSubtypeAnnouncements;
+    }
+
     @Override
     public boolean equals(Object other) {
         if (this == other) {
@@ -93,19 +112,41 @@ public class MdnsAdvertisingOptions {
         } else {
             final MdnsAdvertisingOptions otherOptions = (MdnsAdvertisingOptions) other;
             return mIsOnlyUpdate == otherOptions.mIsOnlyUpdate
+                    && mSkipProbing == otherOptions.mSkipProbing
+                    && mSkipSubtypeAnnouncements == otherOptions.mSkipSubtypeAnnouncements
+                    && mIsOffloadOnly == otherOptions.mIsOffloadOnly
                     && Objects.equals(mTtl, otherOptions.mTtl);
         }
     }
 
     @Override
     public int hashCode() {
-        return Objects.hash(mIsOnlyUpdate, mTtl);
+        return Objects.hash(mIsOnlyUpdate, mTtl, mSkipProbing, mSkipSubtypeAnnouncements,
+                mIsOffloadOnly);
     }
 
     @Override
     public String toString() {
-        return "MdnsAdvertisingOptions{" + "mIsOnlyUpdate=" + mIsOnlyUpdate + ", mTtl=" + mTtl
-                + '}';
+        final StringBuilder sb = new StringBuilder();
+        sb.append("MdnsAdvertisingOptions{");
+        if (mIsOnlyUpdate) {
+            sb.append(" isOnlyUpdate");
+        }
+        if (mSkipProbing) {
+            sb.append(" skipProbing");
+        }
+        if (mSkipSubtypeAnnouncements) {
+            sb.append(" skipSubtypeAnnouncements");
+        }
+        if (mTtl != null) {
+            sb.append(" ttl=");
+            sb.append(mTtl);
+        }
+        if (mIsOffloadOnly) {
+            sb.append(" isOffloadOnly");
+        }
+        sb.append(" }");
+        return sb.toString();
     }
 
     /**
@@ -114,6 +155,8 @@ public class MdnsAdvertisingOptions {
     public static final class Builder {
         private boolean mIsOnlyUpdate = false;
         private boolean mSkipProbing = false;
+        private boolean mSkipSubtypeAnnouncements = false;
+        private boolean mIsOffloadOnly = false;
         @Nullable
         private Duration mTtl;
 
@@ -144,11 +187,28 @@ public class MdnsAdvertisingOptions {
             return this;
         }
 
+        /**
+         * Sets whether to skip subtype announcements.
+         */
+        public Builder setSkipSubtypeAnnouncements(boolean skipSubtypeAnnouncements) {
+            this.mSkipSubtypeAnnouncements = skipSubtypeAnnouncements;
+            return this;
+        }
+
+        /**
+         * Sets whether the request is offload only request or not.
+         */
+        public Builder setOffloadOnly(boolean isOffloadOnly) {
+            this.mIsOffloadOnly = isOffloadOnly;
+            return this;
+        }
+
         /**
          * Builds a {@link MdnsAdvertisingOptions} with the arguments supplied to this builder.
          */
         public MdnsAdvertisingOptions build() {
-            return new MdnsAdvertisingOptions(mIsOnlyUpdate, mTtl, mSkipProbing);
+            return new MdnsAdvertisingOptions(mIsOnlyUpdate, mTtl, mSkipProbing,
+                    mSkipSubtypeAnnouncements, mIsOffloadOnly);
         }
     }
 }
diff --git a/service-t/src/com/android/server/connectivity/mdns/MdnsConfigs.java b/service-t/src/com/android/server/connectivity/mdns/MdnsConfigs.java
index d4aeacf29c..bf049c9419 100644
--- a/service-t/src/com/android/server/connectivity/mdns/MdnsConfigs.java
+++ b/service-t/src/com/android/server/connectivity/mdns/MdnsConfigs.java
@@ -89,8 +89,4 @@ public class MdnsConfigs {
     public static boolean allowNetworkInterfaceIndexPropagation() {
         return true;
     }
-
-    public static boolean allowMultipleSrvRecordsPerHost() {
-        return true;
-    }
 }
\ No newline at end of file
diff --git a/service-t/src/com/android/server/connectivity/mdns/MdnsFeatureFlags.java b/service-t/src/com/android/server/connectivity/mdns/MdnsFeatureFlags.java
index 11a374d9c8..5ca65ca336 100644
--- a/service-t/src/com/android/server/connectivity/mdns/MdnsFeatureFlags.java
+++ b/service-t/src/com/android/server/connectivity/mdns/MdnsFeatureFlags.java
@@ -86,6 +86,21 @@ public class MdnsFeatureFlags {
      */
     public static final String NSD_USE_SHORT_HOSTNAMES = "nsd_use_short_hostnames";
 
+    /**
+     * A feature flag to control whether to advertise the temporary IPv6 addresses should be
+     */
+    public static final String NSD_IGNORE_TEMPORARY_IPV6_ADDRESSES =
+            "nsd_ignore_temporary_ipv6_addresses";
+
+    /**
+
+     * A feature flag to control whether to only flush address records when another address record
+     * with the same name, rrtype and rrclass is received (as per RFC6762 10.2), instead of flushing
+     * all address records (A and AAAA) for the same name only.
+     */
+    public static final String NSD_CACHE_FLUSH_PER_ADDRESS_TYPE =
+            "nsd_cache_flush_per_address_type";
+
     /**
      * A feature flag to control the retention time for cached services.
      *
@@ -95,11 +110,24 @@ public class MdnsFeatureFlags {
             "nsd_cached_services_retention_time";
     public static final int DEFAULT_CACHED_SERVICES_RETENTION_TIME_MILLISECONDS = 10000;
 
+    /**
+     * Tag indicating that socket tagging should not be done.
+     *
+     * <p>Corresponds to the same value TrafficStats uses to for "no tag".
+     */
+    public static final int MDNS_SOCKET_THREAD_STATS_TAG_NONE = -1;
+
     /**
      * A feature flag to control whether the accurate delay callback should be enabled.
      */
     public static final String NSD_ACCURATE_DELAY_CALLBACK = "nsd_accurate_delay_callback";
 
+    /**
+     * A feature flag to control whether the optimized expired service removal should be enabled.
+     */
+    public static final String NSD_OPTIMIZED_EXPIRED_SERVICE_REMOVAL =
+            "nsd_optimized_expired_service_removal";
+
     // Flag for offload feature
     public final boolean mIsMdnsOffloadFeatureEnabled;
 
@@ -139,6 +167,22 @@ public class MdnsFeatureFlags {
     // Flag to use shorter (16 characters + .local) hostnames
     public final boolean mIsShortHostnamesEnabled;
 
+    // Flag to enable guessing the Network of received packets in the legacy MdnsSocketClient.
+    public final boolean mIsSocketClientNetworkGuessingEnabled;
+
+    // Flag to only flush address records when another address record with the same name, rrtype and
+    // rrclass is received
+    public final boolean mIsCacheFlushPerAddressTypeEnabled;
+
+    // Flag for optimized expired service removal
+    public final boolean mIsOptimizedExpiredServiceRemovalEnabled;
+
+    // Flag for ignoring temporary IPv6 addresses in advertising
+    public final boolean mIsIgnoreTemporaryIPv6AddressesEnabled;
+
+    // Thread stats tag for MdnsSocketClient
+    public final int mMdnsSocketThreadStatsTag;
+
     @Nullable
     private final FlagOverrideProvider mOverrideProvider;
 
@@ -246,6 +290,15 @@ public class MdnsFeatureFlags {
                 || isForceEnabledForTest(NSD_ACCURATE_DELAY_CALLBACK);
     }
 
+    /**
+     * Indicates whether {@link #NSD_OPTIMIZED_EXPIRED_SERVICE_REMOVAL} is enabled, including for
+     * testing.
+     */
+    public boolean isOptimizedExpiredServiceRemovalEnabled() {
+        return mIsOptimizedExpiredServiceRemovalEnabled
+                || isForceEnabledForTest(NSD_OPTIMIZED_EXPIRED_SERVICE_REMOVAL);
+    }
+
     /**
      * The constructor for {@link MdnsFeatureFlags}.
      */
@@ -262,6 +315,11 @@ public class MdnsFeatureFlags {
             long cachedServicesRetentionTime,
             boolean isAccurateDelayCallbackEnabled,
             boolean isShortHostnamesEnabled,
+            boolean isSocketClientNetworkGuessingEnabled,
+            boolean isCacheFlushPerAddressTypeEnabled,
+            boolean isOptimizedExpiredServiceRemovalEnabled,
+            boolean isIgnoreTemporaryIPv6AddressesEnabled,
+            int mdnsSocketThreadStatsTag,
             @Nullable FlagOverrideProvider overrideProvider) {
         mIsMdnsOffloadFeatureEnabled = isOffloadFeatureEnabled;
         mIncludeInetAddressRecordsInProbing = includeInetAddressRecordsInProbing;
@@ -276,6 +334,11 @@ public class MdnsFeatureFlags {
         mCachedServicesRetentionTime = cachedServicesRetentionTime;
         mIsAccurateDelayCallbackEnabled = isAccurateDelayCallbackEnabled;
         mIsShortHostnamesEnabled = isShortHostnamesEnabled;
+        mIsSocketClientNetworkGuessingEnabled = isSocketClientNetworkGuessingEnabled;
+        mIsCacheFlushPerAddressTypeEnabled = isCacheFlushPerAddressTypeEnabled;
+        mIsOptimizedExpiredServiceRemovalEnabled = isOptimizedExpiredServiceRemovalEnabled;
+        mMdnsSocketThreadStatsTag = mdnsSocketThreadStatsTag;
+        mIsIgnoreTemporaryIPv6AddressesEnabled = isIgnoreTemporaryIPv6AddressesEnabled;
         mOverrideProvider = overrideProvider;
     }
 
@@ -301,6 +364,11 @@ public class MdnsFeatureFlags {
         private long mCachedServicesRetentionTime;
         private boolean mIsAccurateDelayCallbackEnabled;
         private boolean mIsShortHostnamesEnabled;
+        private boolean mIsSocketClientNetworkGuessingEnabled;
+        private boolean mIsCacheFlushPerAddressTypeEnabled;
+        private boolean mIsOptimizedExpiredServiceRemovalEnabled;
+        private boolean mIsIgnoreTemporaryIPv6AddressesEnabled;
+        private int mMdnsSocketThreadStatsTag;
         private FlagOverrideProvider mOverrideProvider;
 
         /**
@@ -320,9 +388,25 @@ public class MdnsFeatureFlags {
             mCachedServicesRetentionTime = DEFAULT_CACHED_SERVICES_RETENTION_TIME_MILLISECONDS;
             mIsAccurateDelayCallbackEnabled = false;
             mIsShortHostnamesEnabled = true; // Default enabled.
+            mIsSocketClientNetworkGuessingEnabled = false;
+            mIsCacheFlushPerAddressTypeEnabled = true; // Default enabled.
+            mIsOptimizedExpiredServiceRemovalEnabled = false;
+            mIsIgnoreTemporaryIPv6AddressesEnabled = true; // Default enabled.
+            mMdnsSocketThreadStatsTag = MDNS_SOCKET_THREAD_STATS_TAG_NONE;
             mOverrideProvider = null;
         }
 
+        /**
+         * Set whether the temporary IPv6 addresses should be ignored.
+         *
+         * @see #NSD_IGNORE_TEMPORARY_IPV6_ADDRESSES
+         */
+        public Builder setIsIgnoreTemporaryIPv6AddressesEnabled(
+                boolean isIgnoreTemporaryIPv6AddressesEnabled) {
+            mIsIgnoreTemporaryIPv6AddressesEnabled = isIgnoreTemporaryIPv6AddressesEnabled;
+            return this;
+        }
+
         /**
          * Set whether the mDNS offload feature is enabled.
          *
@@ -465,6 +549,45 @@ public class MdnsFeatureFlags {
             return this;
         }
 
+        /**
+         * Set whether MdnsSocketClient should try to guess the Network of received packets.
+         */
+        public Builder setIsSocketClientNetworkGuessingEnabled(
+                boolean isSocketClientNetworkGuessingEnabled) {
+            mIsSocketClientNetworkGuessingEnabled = isSocketClientNetworkGuessingEnabled;
+            return this;
+        }
+
+        /**
+         * Set whether the cache flush per address type is enabled.
+         *
+         * @see #NSD_CACHE_FLUSH_PER_ADDRESS_TYPE
+         */
+        public Builder setIsCacheFlushPerAddressTypeEnabled(
+                boolean isCacheFlushPerAddressTypeEnabled) {
+            mIsCacheFlushPerAddressTypeEnabled = isCacheFlushPerAddressTypeEnabled;
+            return this;
+        }
+
+        /**
+         * Set whether the optimized expired service removal is enabled.
+         *
+         * @see #NSD_OPTIMIZED_EXPIRED_SERVICE_REMOVAL
+         */
+        public Builder setIsOptimizedExpiredServiceRemovalEnabled(
+                boolean isOptimizedExpiredServiceRemovalEnabled) {
+            mIsOptimizedExpiredServiceRemovalEnabled = isOptimizedExpiredServiceRemovalEnabled;
+            return this;
+        }
+
+        /**
+         * Set the thread stats tag to use in {@link MdnsSocketClient}.
+         */
+        public Builder setMdnsSocketThreadStatsTag(int mdnsSocketThreadStatsTag) {
+            mMdnsSocketThreadStatsTag = mdnsSocketThreadStatsTag;
+            return this;
+        }
+
         /**
          * Builds a {@link MdnsFeatureFlags} with the arguments supplied to this builder.
          */
@@ -482,6 +605,11 @@ public class MdnsFeatureFlags {
                     mCachedServicesRetentionTime,
                     mIsAccurateDelayCallbackEnabled,
                     mIsShortHostnamesEnabled,
+                    mIsSocketClientNetworkGuessingEnabled,
+                    mIsCacheFlushPerAddressTypeEnabled,
+                    mIsOptimizedExpiredServiceRemovalEnabled,
+                    mIsIgnoreTemporaryIPv6AddressesEnabled,
+                    mMdnsSocketThreadStatsTag,
                     mOverrideProvider);
         }
     }
diff --git a/service-t/src/com/android/server/connectivity/mdns/MdnsInterfaceAdvertiser.java b/service-t/src/com/android/server/connectivity/mdns/MdnsInterfaceAdvertiser.java
index b9b09ed0c8..878fd26211 100644
--- a/service-t/src/com/android/server/connectivity/mdns/MdnsInterfaceAdvertiser.java
+++ b/service-t/src/com/android/server/connectivity/mdns/MdnsInterfaceAdvertiser.java
@@ -276,7 +276,7 @@ public class MdnsInterfaceAdvertiser implements MulticastPacketReader.PacketHand
     public void addService(int id, NsdServiceInfo service,
             @NonNull MdnsAdvertisingOptions advertisingOptions) throws NameConflictException {
         final int replacedExitingService =
-                mRecordRepository.addService(id, service, advertisingOptions.getTtl());
+                mRecordRepository.addService(id, service, advertisingOptions);
         // Cancel announcements for the existing service. This only happens for exiting services
         // (so cancelling exiting announcements), as per RecordRepository.addService.
         if (replacedExitingService >= 0) {
@@ -285,7 +285,7 @@ public class MdnsInterfaceAdvertiser implements MulticastPacketReader.PacketHand
             mAnnouncer.stop(replacedExitingService);
         }
         final MdnsProber.ProbingInfo probingInfo = mRecordRepository.setServiceProbing(id);
-        if (advertisingOptions.skipProbing()) {
+        if (advertisingOptions.skipProbing() || advertisingOptions.isOffloadOnly()) {
             handleProbingFinished(probingInfo);
         } else {
             mProber.startProbing(probingInfo);
diff --git a/service-t/src/com/android/server/connectivity/mdns/MdnsPacketWriter.java b/service-t/src/com/android/server/connectivity/mdns/MdnsPacketWriter.java
index cf788be0d1..1d227adc8d 100644
--- a/service-t/src/com/android/server/connectivity/mdns/MdnsPacketWriter.java
+++ b/service-t/src/com/android/server/connectivity/mdns/MdnsPacketWriter.java
@@ -19,6 +19,7 @@ package com.android.server.connectivity.mdns;
 import com.android.net.module.util.DnsUtils;
 import com.android.server.connectivity.mdns.MdnsServiceInfo.TextEntry;
 
+import java.io.EOFException;
 import java.io.IOException;
 import java.net.DatagramPacket;
 import java.net.SocketAddress;
@@ -241,9 +242,9 @@ public class MdnsPacketWriter {
     }
 
     // Checks if the remaining space in the packet is at least |count|.
-    private void checkRemaining(int count) throws IOException {
+    private void checkRemaining(int count) throws EOFException {
         if (getRemaining() < count) {
-            throw new IOException();
+            throw new EOFException();
         }
     }
 
diff --git a/service-t/src/com/android/server/connectivity/mdns/MdnsRecordRepository.java b/service-t/src/com/android/server/connectivity/mdns/MdnsRecordRepository.java
index bfef5d9204..741550ae66 100644
--- a/service-t/src/com/android/server/connectivity/mdns/MdnsRecordRepository.java
+++ b/service-t/src/com/android/server/connectivity/mdns/MdnsRecordRepository.java
@@ -16,6 +16,8 @@
 
 package com.android.server.connectivity.mdns;
 
+import static android.system.OsConstants.IFA_F_TEMPORARY;
+
 import static com.android.server.connectivity.mdns.MdnsConstants.IPV4_SOCKET_ADDR;
 import static com.android.server.connectivity.mdns.MdnsConstants.IPV6_SOCKET_ADDR;
 import static com.android.server.connectivity.mdns.MdnsConstants.NO_PACKET;
@@ -200,6 +202,8 @@ public class MdnsRecordRepository {
         public final List<RecordInfo<MdnsInetAddressRecord>> addressRecords;
         @NonNull
         public final NsdServiceInfo serviceInfo;
+        @NonNull
+        private final MdnsAdvertisingOptions mAdvertisingOptions;
 
         /**
          * Whether the service is sending exit announcements and will be destroyed soon.
@@ -221,9 +225,6 @@ public class MdnsRecordRepository {
          */
         private boolean isProbing;
 
-        @Nullable
-        private Duration ttl;
-
         /**
          * Create a ServiceRegistration with only update the subType.
          */
@@ -232,17 +233,38 @@ public class MdnsRecordRepository {
             NsdServiceInfo newServiceInfo = new NsdServiceInfo(serviceInfo);
             newServiceInfo.setSubtypes(newSubtypes);
             return new ServiceRegistration(srvRecord.record.getServiceHost(), newServiceInfo,
-                    repliedServiceCount, sentPacketCount, exiting, isProbing, ttl,
+                    repliedServiceCount, sentPacketCount, exiting, isProbing, mAdvertisingOptions,
                     featureFlags);
         }
 
+        /**
+         * Get filtered all records of the service registration.
+         */
+        List<RecordInfo<?>> getFilteredAllRecords() {
+            return CollectionUtils.filter(allRecords,
+                    info -> !mAdvertisingOptions.skipSubtypeAnnouncements() || !isSubtypePtrRecord(
+                            info));
+        }
+
+        /**
+         * Get filtered ptr records of the service registration.
+         */
+        List<RecordInfo<MdnsPointerRecord>> getFilteredPtrRecords() {
+            return CollectionUtils.filter(ptrRecords,
+                    info -> !mAdvertisingOptions.skipSubtypeAnnouncements() || !isSubtypePtrRecord(
+                            info));
+        }
+
+
         /**
          * Create a ServiceRegistration for dns-sd service registration (RFC6763).
          */
         ServiceRegistration(@NonNull String[] deviceHostname, @NonNull NsdServiceInfo serviceInfo,
                 int repliedServiceCount, int sentPacketCount, boolean exiting, boolean isProbing,
-                @Nullable Duration ttl, @NonNull MdnsFeatureFlags featureFlags) {
+                @NonNull MdnsAdvertisingOptions advertisingOptions,
+                @NonNull MdnsFeatureFlags featureFlags) {
             this.serviceInfo = serviceInfo;
+            this.mAdvertisingOptions = advertisingOptions;
 
             final long nonNameRecordsTtlMillis;
             final long nameRecordsTtlMillis;
@@ -251,6 +273,7 @@ public class MdnsRecordRepository {
             // This is typically useful for SRP (Service Registration Protocol:
             // https://datatracker.ietf.org/doc/html/draft-ietf-dnssd-srp-24) Advertising Proxy
             // where all records in a single SRP are required the same TTL.
+            final Duration ttl = advertisingOptions.getTtl();
             if (ttl != null) {
                 nonNameRecordsTtlMillis = ttl.toMillis();
                 nameRecordsTtlMillis = ttl.toMillis();
@@ -396,16 +419,20 @@ public class MdnsRecordRepository {
          * @param serviceInfo Service to advertise
          */
         ServiceRegistration(@NonNull String[] deviceHostname, @NonNull NsdServiceInfo serviceInfo,
-                int repliedServiceCount, int sentPacketCount, @Nullable Duration ttl,
+                int repliedServiceCount, int sentPacketCount,
+                @NonNull MdnsAdvertisingOptions advertisingOptions,
                 @NonNull MdnsFeatureFlags featureFlags) {
             this(deviceHostname, serviceInfo,repliedServiceCount, sentPacketCount,
-                    false /* exiting */, true /* isProbing */, ttl, featureFlags);
+                    false /* exiting */, true /* isProbing */, advertisingOptions, featureFlags);
         }
 
         void setProbing(boolean probing) {
             this.isProbing = probing;
         }
 
+        boolean isActive() {
+            return !exiting && !mAdvertisingOptions.isOffloadOnly();
+        }
     }
 
     /**
@@ -414,6 +441,11 @@ public class MdnsRecordRepository {
     public void updateAddresses(@NonNull List<LinkAddress> newAddresses) {
         mGeneralRecords.clear();
         for (LinkAddress addr : newAddresses) {
+            if (mMdnsFeatureFlags.mIsIgnoreTemporaryIPv6AddressesEnabled && addr.isIpv6()
+                    && (addr.getFlags() & IFA_F_TEMPORARY) != 0) {
+                // Ignore temporary IPv6 addresses
+                continue;
+            }
             final String[] revDnsAddr = getReverseDnsAddress(addr.getAddress());
             mGeneralRecords.add(new RecordInfo<>(
                     null /* serviceInfo */,
@@ -460,12 +492,13 @@ public class MdnsRecordRepository {
      * This may remove/replace any existing service that used the name added but is exiting.
      * @param serviceId A unique service ID.
      * @param serviceInfo Service info to add.
-     * @param ttl the TTL duration for all records of {@code serviceInfo} or {@code null}
+     * @param advertisingOptions the advertiser options for this service.
      * @return If the added service replaced another with a matching name (which was exiting), the
      *         ID of the replaced service.
      * @throws NameConflictException There is already a (non-exiting) service using the name.
      */
-    public int addService(int serviceId, NsdServiceInfo serviceInfo, @Nullable Duration ttl)
+    public int addService(int serviceId, NsdServiceInfo serviceInfo,
+            @NonNull MdnsAdvertisingOptions advertisingOptions)
             throws NameConflictException {
         if (mServices.contains(serviceId)) {
             throw new IllegalArgumentException(
@@ -481,7 +514,7 @@ public class MdnsRecordRepository {
 
         final ServiceRegistration registration = new ServiceRegistration(
                 mDeviceHostname, serviceInfo, NO_PACKET /* repliedServiceCount */,
-                NO_PACKET /* sentPacketCount */, ttl,
+                NO_PACKET /* sentPacketCount */, advertisingOptions,
                 mMdnsFeatureFlags);
         mServices.put(serviceId, registration);
 
@@ -579,16 +612,16 @@ public class MdnsRecordRepository {
     public MdnsAnnouncer.ExitAnnouncementInfo exitService(int id) {
         final ServiceRegistration registration = mServices.get(id);
         if (registration == null) return null;
-        if (registration.exiting) return null;
+        if (!registration.isActive()) return null;
 
-        // Send exit (TTL 0) for the PTR records, if at least one was sent (in particular don't send
-        // if still probing)
-        if (CollectionUtils.all(registration.ptrRecords, r -> r.lastSentTimeMs == 0L)) {
+        registration.exiting = true;
+        final List<RecordInfo<MdnsPointerRecord>> filteredRecords = CollectionUtils.filter(
+                registration.getFilteredPtrRecords(), r -> r.lastSentTimeMs != 0L);
+        if (filteredRecords.isEmpty()) {
             return null;
         }
-
-        registration.exiting = true;
-        final List<MdnsRecord> expiredRecords = CollectionUtils.map(registration.ptrRecords,
+        final List<MdnsRecord> expiredRecords = CollectionUtils.map(
+                filteredRecords,
                 r -> new MdnsPointerRecord(
                         r.record.getName(),
                         0L /* receiptTimeMillis */,
@@ -691,7 +724,9 @@ public class MdnsRecordRepository {
             // Add answers from each service
             for (int i = 0; i < mServices.size(); i++) {
                 final ServiceRegistration registration = mServices.valueAt(i);
-                if (registration.exiting || registration.isProbing) continue;
+                if (!registration.isActive() || registration.isProbing) {
+                    continue;
+                }
                 if (addReplyFromService(question, registration.allRecords, registration.ptrRecords,
                         registration.srvRecord, registration.txtRecord,
                         registration.serviceInfo.getHostname(),
@@ -1093,6 +1128,14 @@ public class MdnsRecordRepository {
         return makeAnnouncementInfo(serviceId, registration);
     }
 
+    private static boolean isSubtypePtrRecord(@NonNull RecordInfo<?> info) {
+        if (!(info.record instanceof MdnsPointerRecord)) {
+            return false;
+        }
+        final String[] recordName = info.record.getName();
+        return recordName.length > 4;
+    }
+
     /**
      * Make the announcement info of the given service ID.
      *
@@ -1125,13 +1168,15 @@ public class MdnsRecordRepository {
                     });
         }
 
+        final List<RecordInfo<?>> filteredAllRecords = registration.getFilteredAllRecords();
         // All service records
-        for (RecordInfo<?> info : registration.allRecords) {
+        for (RecordInfo<?> info : filteredAllRecords) {
             answersSet.add(info.record);
         }
 
+        // ignore all the PTR query with subtype
         addNsecRecordsForUniqueNames(additionalAnswers,
-                mGeneralRecords.iterator(), registration.allRecords.iterator());
+                mGeneralRecords.iterator(), filteredAllRecords.iterator());
 
         return new MdnsAnnouncer.AnnouncementInfo(serviceId,
                 new ArrayList<>(answersSet), additionalAnswers);
@@ -1151,6 +1196,10 @@ public class MdnsRecordRepository {
 
         // Adds all PTR, SRV, TXT, A/AAAA records.
         for (RecordInfo<MdnsPointerRecord> ptrRecord : registration.ptrRecords) {
+            if (registration.mAdvertisingOptions.skipSubtypeAnnouncements() && isSubtypePtrRecord(
+                    ptrRecord)) {
+                continue;
+            }
             answers.add(ptrRecord.record);
         }
         if (registration.srvRecord != null) {
@@ -1199,7 +1248,7 @@ public class MdnsRecordRepository {
             SparseIntArray conflictingWithRecord = new SparseIntArray();
             for (int i = 0; i < mServices.size(); i++) {
                 final ServiceRegistration registration = mServices.valueAt(i);
-                if (registration.exiting) continue;
+                if (!registration.isActive()) continue;
 
                 final RecordConflictType conflictForService =
                         conflictForService(record, registration);
@@ -1365,7 +1414,7 @@ public class MdnsRecordRepository {
         for (int i = 0; i < mServices.size(); ++i) {
             int id = mServices.keyAt(i);
             ServiceRegistration service = mServices.valueAt(i);
-            if (service.exiting) continue;
+            if (!service.isActive()) continue;
             if (DnsUtils.equalsIgnoreDnsCase(service.serviceInfo.getHostname(), hostname)) {
                 consumer.accept(id, service);
             }
@@ -1417,8 +1466,8 @@ public class MdnsRecordRepository {
         if (existing == null) return null;
 
         final ServiceRegistration newService = new ServiceRegistration(mDeviceHostname, newInfo,
-                existing.repliedServiceCount, existing.sentPacketCount, existing.ttl,
-                mMdnsFeatureFlags);
+                existing.repliedServiceCount, existing.sentPacketCount,
+                existing.mAdvertisingOptions, mMdnsFeatureFlags);
         mServices.put(serviceId, newService);
         return makeProbingInfo(serviceId, newService);
     }
@@ -1431,7 +1480,7 @@ public class MdnsRecordRepository {
         if (registration == null) return;
 
         final long now = mDeps.elapsedRealTime();
-        for (RecordInfo<?> record : registration.allRecords) {
+        for (RecordInfo<?> record : registration.getFilteredAllRecords()) {
             record.lastSentTimeMs = now;
             record.lastAdvertisedOnIpv4TimeMs = now;
             record.lastAdvertisedOnIpv6TimeMs = now;
diff --git a/service-t/src/com/android/server/connectivity/mdns/MdnsReplySender.java b/service-t/src/com/android/server/connectivity/mdns/MdnsReplySender.java
index 4708cb62ac..f41d6be8d2 100644
--- a/service-t/src/com/android/server/connectivity/mdns/MdnsReplySender.java
+++ b/service-t/src/com/android/server/connectivity/mdns/MdnsReplySender.java
@@ -33,6 +33,7 @@ import com.android.internal.annotations.VisibleForTesting;
 import com.android.net.module.util.SharedLog;
 import com.android.server.connectivity.mdns.util.MdnsUtils;
 
+import java.io.EOFException;
 import java.io.IOException;
 import java.net.DatagramPacket;
 import java.net.Inet4Address;
@@ -100,6 +101,14 @@ public class MdnsReplySender {
         public void removeMessages(@NonNull Handler handler, int what, @NonNull Object object) {
             handler.removeMessages(what, object);
         }
+
+        /**
+         * @see MdnsUtils#createRawDnsPacket(byte[], MdnsPacket)
+         */
+        public byte[] createRawDnsPacket(@NonNull byte[] buffer, @NonNull MdnsPacket packet)
+                throws IOException {
+            return MdnsUtils.createRawDnsPacket(buffer, packet);
+        }
     }
 
     public MdnsReplySender(@NonNull Looper looper, @NonNull MdnsInterfaceSocket socket,
@@ -210,11 +219,37 @@ public class MdnsReplySender {
             // Skip sending if the socket has not joined the v4/v6 group (there was no address)
             return PACKET_NOT_SENT;
         }
-        final byte[] outBuffer = MdnsUtils.createRawDnsPacket(mPacketCreationBuffer, packet);
+        final byte[] outBuffer = createRawDnsPacket(packet);
         mSocket.send(new DatagramPacket(outBuffer, 0, outBuffer.length, destination));
         return PACKET_SENT;
     }
 
+    private byte[] createRawDnsPacket(MdnsPacket packet)
+            throws IOException {
+        try {
+            return mDependencies.createRawDnsPacket(mPacketCreationBuffer, packet);
+        } catch (EOFException e) {
+            // Try truncating the additional records if the packet is too large.
+            final MdnsPacket packetWithoutAdditionalRecords =
+                    new MdnsPacket(
+                            packet.transactionId,
+                            packet.flags,
+                            packet.questions,
+                            packet.answers,
+                            packet.authorityRecords,
+                            Collections.emptyList() /* additionalRecords */);
+            final byte[] outBuffer =
+                    mDependencies.createRawDnsPacket(
+                            mPacketCreationBuffer, packetWithoutAdditionalRecords);
+            // TODO: The packet may still be too large after truncating the additional records. We
+            // may need to further optimize this.
+            mSharedLog.e(
+                    "The message is too large to fit in a single packet. The additional records are"
+                            + " not included.");
+            return outBuffer;
+        }
+    }
+
     /**
      * Cancel all pending sends.
      */
diff --git a/service-t/src/com/android/server/connectivity/mdns/MdnsResponseDecoder.java b/service-t/src/com/android/server/connectivity/mdns/MdnsResponseDecoder.java
index 52e76ada3e..1abad5e570 100644
--- a/service-t/src/com/android/server/connectivity/mdns/MdnsResponseDecoder.java
+++ b/service-t/src/com/android/server/connectivity/mdns/MdnsResponseDecoder.java
@@ -16,6 +16,9 @@
 
 package com.android.server.connectivity.mdns;
 
+import static com.android.server.connectivity.mdns.MdnsRecord.TYPE_A;
+import static com.android.server.connectivity.mdns.MdnsRecord.TYPE_AAAA;
+
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.net.Network;
@@ -35,8 +38,6 @@ import java.util.Set;
 public class MdnsResponseDecoder {
     public static final int SUCCESS = 0;
     private static final String TAG = "MdnsResponseDecoder";
-    private final boolean allowMultipleSrvRecordsPerHost =
-            MdnsConfigs.allowMultipleSrvRecordsPerHost();
     @Nullable private final String[] serviceType;
     private final MdnsUtils.Clock clock;
 
@@ -129,7 +130,8 @@ public class MdnsResponseDecoder {
     public Pair<Set<MdnsResponse>, ArrayList<MdnsResponse>> augmentResponses(
             @NonNull MdnsPacket mdnsPacket,
             @NonNull Collection<MdnsResponse> existingResponses, int interfaceIndex,
-            @Nullable Network network) {
+            @Nullable Network network,
+            @NonNull MdnsFeatureFlags flags) {
         final ArrayList<MdnsRecord> records = new ArrayList<>(
                 mdnsPacket.questions.size() + mdnsPacket.answers.size()
                         + mdnsPacket.authorityRecords.size() + mdnsPacket.additionalRecords.size());
@@ -217,37 +219,25 @@ public class MdnsResponseDecoder {
             if (record instanceof MdnsInetAddressRecord) {
                 MdnsInetAddressRecord inetRecord = (MdnsInetAddressRecord) record;
                 inetRecords.add(inetRecord);
-                if (allowMultipleSrvRecordsPerHost) {
-                    List<MdnsResponse> matchingResponses =
-                            findResponsesWithHostName(responses, inetRecord.getName());
-                    for (MdnsResponse response : matchingResponses) {
-                        // Per RFC6762 10.2, clear all address records if the cache-flush bit set.
-                        // This bit, the cache-flush bit, tells neighboring hosts
-                        // that this is not a shared record type.  Instead of merging this new
-                        // record additively into the cache in addition to any previous records with
-                        // the same name, rrtype, and rrclass.
-                        // TODO: All old records with that name, rrtype, and rrclass that were
-                        //       received more than one second ago are declared invalid, and marked
-                        //       to expire from the cache in one second.
-                        if (inetRecord.getCacheFlush()) {
+                List<MdnsResponse> matchingResponses =
+                        findResponsesWithHostName(responses, inetRecord.getName());
+                for (MdnsResponse response : matchingResponses) {
+                    // Per RFC6762 10.2, clear all same-type address records if the cache-flush bit
+                    // set.
+                    // This bit, the cache-flush bit, tells neighboring hosts
+                    // that this is not a shared record type.  Instead of merging this new
+                    // record additively into the cache in addition to any previous records with
+                    // the same name, rrtype, and rrclass.
+                    // TODO: All old records with that name, rrtype, and rrclass that were
+                    //       received more than one second ago are declared invalid, and marked
+                    //       to expire from the cache in one second.
+                    if (inetRecord.getCacheFlush()) {
+                        if (!flags.mIsCacheFlushPerAddressTypeEnabled
+                                || inetRecord.getType() == TYPE_A) {
                             response.clearInet4AddressRecords();
-                            response.clearInet6AddressRecords();
                         }
-                    }
-                } else {
-                    MdnsResponse response =
-                            findResponseWithHostName(responses, inetRecord.getName());
-                    if (response != null) {
-                        // Per RFC6762 10.2, clear all address records if the cache-flush bit set.
-                        // This bit, the cache-flush bit, tells neighboring hosts
-                        // that this is not a shared record type.  Instead of merging this new
-                        // record additively into the cache in addition to any previous records with
-                        // the same name, rrtype, and rrclass.
-                        // TODO: All old records with that name, rrtype, and rrclass that were
-                        //       received more than one second ago are declared invalid, and marked
-                        //       to expire from the cache in one second.
-                        if (inetRecord.getCacheFlush()) {
-                            response.clearInet4AddressRecords();
+                        if (!flags.mIsCacheFlushPerAddressTypeEnabled
+                                || inetRecord.getType() == TYPE_AAAA) {
                             response.clearInet6AddressRecords();
                         }
                     }
@@ -257,28 +247,14 @@ public class MdnsResponseDecoder {
 
         // Loop 3-2: Assign addresses, which reference the host name in the SRV record.
         for (MdnsInetAddressRecord inetRecord : inetRecords) {
-            if (allowMultipleSrvRecordsPerHost) {
-                List<MdnsResponse> matchingResponses =
-                        findResponsesWithHostName(responses, inetRecord.getName());
-                for (MdnsResponse response : matchingResponses) {
-                    if (assignInetRecord(response, inetRecord)) {
-                        final MdnsResponse originalResponse = augmentedToOriginal.get(response);
-                        if (originalResponse == null
-                                || !originalResponse.hasIdenticalRecord(inetRecord)) {
-                            modified.add(response);
-                        }
-                    }
-                }
-            } else {
-                MdnsResponse response =
-                        findResponseWithHostName(responses, inetRecord.getName());
-                if (response != null) {
-                    if (assignInetRecord(response, inetRecord)) {
-                        final MdnsResponse originalResponse = augmentedToOriginal.get(response);
-                        if (originalResponse == null
-                                || !originalResponse.hasIdenticalRecord(inetRecord)) {
-                            modified.add(response);
-                        }
+            List<MdnsResponse> matchingResponses =
+                    findResponsesWithHostName(responses, inetRecord.getName());
+            for (MdnsResponse response : matchingResponses) {
+                if (assignInetRecord(response, inetRecord)) {
+                    final MdnsResponse originalResponse = augmentedToOriginal.get(response);
+                    if (originalResponse == null
+                            || !originalResponse.hasIdenticalRecord(inetRecord)) {
+                        modified.add(response);
                     }
                 }
             }
diff --git a/service-t/src/com/android/server/connectivity/mdns/MdnsServiceCache.java b/service-t/src/com/android/server/connectivity/mdns/MdnsServiceCache.java
index 7c72fb1a7d..3c13798fda 100644
--- a/service-t/src/com/android/server/connectivity/mdns/MdnsServiceCache.java
+++ b/service-t/src/com/android/server/connectivity/mdns/MdnsServiceCache.java
@@ -20,6 +20,8 @@ import static com.android.net.module.util.DnsUtils.equalsIgnoreDnsCase;
 import static com.android.net.module.util.DnsUtils.toDnsUpperCase;
 import static com.android.net.module.util.HandlerUtils.ensureRunningOnHandlerThread;
 import static com.android.server.connectivity.mdns.MdnsResponse.EXPIRATION_NEVER;
+import static com.android.server.connectivity.mdns.MdnsServiceTypeClient.REMOVE_SERVICE_AFTER_QUERY_SENT_TIME;
+import static com.android.server.connectivity.mdns.util.MdnsUtils.responseMatchesInstanceNameAndSubtypes;
 
 import static java.lang.Math.min;
 
@@ -30,10 +32,12 @@ import android.os.Looper;
 import android.util.ArrayMap;
 
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.net.module.util.CollectionUtils;
 import com.android.server.connectivity.mdns.util.MdnsUtils;
 
 import java.io.PrintWriter;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
@@ -49,6 +53,9 @@ import java.util.Objects;
  *  to their default value (0, false or null).
  */
 public class MdnsServiceCache {
+    @VisibleForTesting
+    static final long NEVER_SENT_QUERY = -1L;
+
     public static class CacheKey {
         @NonNull final String mUpperCaseServiceType;
         @NonNull final SocketKey mSocketKey;
@@ -82,10 +89,20 @@ public class MdnsServiceCache {
     public static class CachedService {
         @NonNull final MdnsResponse mService;
         boolean mServiceExpired;
+        // The timestamp of the first query sent after the service last received time (from the SRV
+        // record).
+        long mFirstQueryTimeAfterLastUpdate;
 
         CachedService(MdnsResponse service) {
             mService = service;
             mServiceExpired = false;
+            mFirstQueryTimeAfterLastUpdate = NEVER_SENT_QUERY;
+        }
+
+        boolean isServiceQueriedAfterLastUpdate(long now) {
+            return mFirstQueryTimeAfterLastUpdate != NEVER_SENT_QUERY
+                    && (now - mFirstQueryTimeAfterLastUpdate)
+                    >= REMOVE_SERVICE_AFTER_QUERY_SENT_TIME;
         }
     }
 
@@ -124,9 +141,11 @@ public class MdnsServiceCache {
         mClock = clock;
     }
 
-    private List<MdnsResponse> cachedServicesToResponses(List<CachedService> cachedServices) {
+    private List<MdnsResponse> cachedServicesToResponses(List<CachedService> cachedServices,
+            boolean excludeExpiredServices) {
         final List<MdnsResponse> responses = new ArrayList<>();
         for (CachedService cachedService : cachedServices) {
+            if (excludeExpiredServices && cachedService.mServiceExpired) continue;
             responses.add(cachedService.mService);
         }
         return responses;
@@ -139,14 +158,16 @@ public class MdnsServiceCache {
      * @return the set of services which matches the given service type.
      */
     @NonNull
-    public List<MdnsResponse> getCachedServices(@NonNull CacheKey cacheKey) {
+    public List<MdnsResponse> getCachedServices(@NonNull CacheKey cacheKey,
+            boolean excludeExpiredServices) {
         ensureRunningOnHandlerThread(mHandler);
         if (mMdnsFeatureFlags.mIsExpiredServicesRemovalEnabled) {
             maybeRemoveExpiredServices(cacheKey, mClock.elapsedRealtime());
         }
         return mCachedServices.containsKey(cacheKey)
                 ? Collections.unmodifiableList(
-                        cachedServicesToResponses(mCachedServices.get(cacheKey)))
+                        cachedServicesToResponses(mCachedServices.get(cacheKey),
+                                excludeExpiredServices))
                 : Collections.emptyList();
     }
 
@@ -185,7 +206,8 @@ public class MdnsServiceCache {
      * @return the service which matches given conditions.
      */
     @Nullable
-    public MdnsResponse getCachedService(@NonNull String serviceName, @NonNull CacheKey cacheKey) {
+    public MdnsResponse getCachedService(@NonNull String serviceName, @NonNull CacheKey cacheKey,
+            boolean excludeExpiredServices) {
         ensureRunningOnHandlerThread(mHandler);
         if (mMdnsFeatureFlags.mIsExpiredServicesRemovalEnabled) {
             maybeRemoveExpiredServices(cacheKey, mClock.elapsedRealtime());
@@ -195,7 +217,8 @@ public class MdnsServiceCache {
             return null;
         }
         final CachedService cachedService = findMatchedCachedService(cachedServices, serviceName);
-        return cachedService != null ? new MdnsResponse(cachedService.mService) : null;
+        return cachedService != null && !(excludeExpiredServices && cachedService.mServiceExpired)
+                ? new MdnsResponse(cachedService.mService) : null;
     }
 
     static void insertServiceAndSortList(
@@ -321,10 +344,11 @@ public class MdnsServiceCache {
         mHandler.post(()-> callback.onServiceRecordExpired(previousResponse, newResponse));
     }
 
-    static List<CachedService> removeExpiredServices(@NonNull List<CachedService> cachedServices,
-            long now) {
+    private List<CachedService> removeExpiredServices(@NonNull List<CachedService> cachedServices,
+            long now, boolean removeOnlyIfQuerySent) {
         final List<CachedService> removedServices = new ArrayList<>();
         final Iterator<CachedService> iterator = cachedServices.iterator();
+        boolean hasNewlyExpiredService = false;
         while (iterator.hasNext()) {
             final CachedService cachedService = iterator.next();
             // TODO: Check other records (A, AAAA, TXT) ttl time and remove the record if it's
@@ -335,46 +359,74 @@ public class MdnsServiceCache {
                 // early if service is not expired or no service record.
                 break;
             }
+            hasNewlyExpiredService = true;
+            if (removeOnlyIfQuerySent) {
+                // Set service is expired.
+                cachedService.mServiceExpired = true;
+                // Skip removal if no query sent for this expired service.
+                if (!cachedService.isServiceQueriedAfterLastUpdate(now)) {
+                    continue;
+                }
+            }
             // Remove the ttl expired service.
             iterator.remove();
             removedServices.add(cachedService);
         }
+
+        // Update next expiration time.
+        if (hasNewlyExpiredService) {
+            mNextExpirationTime = getNextExpirationTime(now);
+        }
+
         return removedServices;
     }
 
+    /**
+     * Calculates the absolute timestamp for the next service expiration based on cached services.
+     *
+     * If the cache is empty or if all cached services are already expired, this method returns
+     * {@code EXPIRATION_NEVER}.
+     *
+     * @param now The current time.
+     * @return The absolute timestamp when the next service is expected to expire, or
+     *         {@code EXPIRATION_NEVER} if no non-expired services are found in the cache.
+     */
     private long getNextExpirationTime(long now) {
+        ensureRunningOnHandlerThread(mHandler);
         if (mCachedServices.isEmpty()) {
             return EXPIRATION_NEVER;
         }
 
         long minRemainingTtl = EXPIRATION_NEVER;
         for (int i = 0; i < mCachedServices.size(); i++) {
+            final List<CachedService> services = mCachedServices.valueAt(i);
+            final int index = CollectionUtils.indexOf(
+                    services, service -> !service.mServiceExpired);
+            if (index == -1) continue;
             minRemainingTtl = min(minRemainingTtl,
-                    // The empty lists are not kept in the map, so there's always at least one
-                    // element in the list. Therefore, it's fine to get the first element without a
-                    // null check.
-                    mCachedServices.valueAt(i).get(0).mService.getMinRemainingTtl(now));
+                    services.get(index).mService.getMinRemainingTtl(now));
         }
         return minRemainingTtl == EXPIRATION_NEVER ? EXPIRATION_NEVER : now + minRemainingTtl;
     }
 
     /**
-     * Check whether the ttl time is expired on each service and notify to the listeners
+     * Check for expired services, remove them if they meet the removal criteria, and notify
+     * listeners.
+     *
+     * @param cacheKey the target CacheKey.
+     * @param now current time
      */
-    private void maybeRemoveExpiredServices(CacheKey cacheKey, long now) {
+    public void removeExpiredServicesAndNotifyListeners(CacheKey cacheKey, long now) {
         ensureRunningOnHandlerThread(mHandler);
-        if (now < mNextExpirationTime) {
-            // Skip the check if ttl time is not expired.
-            return;
-        }
-
         final List<CachedService> cachedServices = mCachedServices.get(cacheKey);
         if (cachedServices == null) {
             // No such services.
             return;
         }
 
-        final List<CachedService> removedServices = removeExpiredServices(cachedServices, now);
+        final List<CachedService> removedServices = removeExpiredServices(
+                cachedServices, now, mMdnsFeatureFlags.mIsOptimizedExpiredServiceRemovalEnabled);
+
         if (removedServices.isEmpty()) {
             // No expired services.
             return;
@@ -388,9 +440,68 @@ public class MdnsServiceCache {
         if (cachedServices.isEmpty()) {
             mCachedServices.remove(cacheKey);
         }
+    }
 
-        // Update next expiration time.
-        mNextExpirationTime = getNextExpirationTime(now);
+    /**
+     * Check whether the ttl time is expired on each service and notify to the listeners
+     */
+    private void maybeRemoveExpiredServices(CacheKey cacheKey, long now) {
+        ensureRunningOnHandlerThread(mHandler);
+        if (now < mNextExpirationTime) {
+            // Skip the check if ttl time is not expired.
+            return;
+        }
+
+        removeExpiredServicesAndNotifyListeners(cacheKey, now);
+    }
+
+    /**
+     * Update the query time for the cached services
+     *
+     * @param serviceName the target service name.
+     * @param cacheKey the target CacheKey.
+     * @param currentTime current time.
+     */
+    public void updateFirstQueryTimeForCachedServices(@Nullable String serviceName,
+            @NonNull Collection<String> subtypes, @NonNull CacheKey cacheKey, long currentTime) {
+        ensureRunningOnHandlerThread(mHandler);
+        final List<CachedService> cachedServices = mCachedServices.get(cacheKey);
+        if (cachedServices == null) {
+            // No such services.
+            return;
+        }
+        for (CachedService cachedService : cachedServices) {
+            if (cachedService.mFirstQueryTimeAfterLastUpdate != NEVER_SENT_QUERY) continue;
+            if (responseMatchesInstanceNameAndSubtypes(
+                    cachedService.mService, serviceName, subtypes)) {
+                cachedService.mFirstQueryTimeAfterLastUpdate = currentTime;
+            }
+        }
+    }
+
+    @VisibleForTesting
+    long getFirstQueryTimeAfterLastUpdate(@NonNull String serviceName, @NonNull CacheKey cacheKey) {
+        ensureRunningOnHandlerThread(mHandler);
+        final List<CachedService> cachedServices = mCachedServices.get(cacheKey);
+        if (cachedServices == null) {
+            return NEVER_SENT_QUERY;
+        }
+        final CachedService cachedService = findMatchedCachedService(cachedServices, serviceName);
+        return cachedService != null
+                ? cachedService.mFirstQueryTimeAfterLastUpdate : NEVER_SENT_QUERY;
+    }
+
+    /**
+     * Retrieve the current expiration time.
+     * <p>
+     * NOTE: This method exposes internal state ({@code mNextExpirationTime}) for testing purposes.
+     * It should not be used in production code.
+     *
+     * @return The expiration time.
+     */
+    @VisibleForTesting
+    long getCurrentExpiredTime() {
+        return mNextExpirationTime;
     }
 
     /**
@@ -404,7 +515,9 @@ public class MdnsServiceCache {
             pw.println(indent + key);
             for (CachedService cachedService : mCachedServices.valueAt(i)) {
                 pw.println(indent + "  Response{ " + cachedService.mService
-                        + " } Expired=" + cachedService.mServiceExpired);
+                        + " } Expired=" + cachedService.mServiceExpired
+                        + " FirstQueryTimeAfterLastUpdate="
+                        + cachedService.mFirstQueryTimeAfterLastUpdate);
             }
             pw.println();
         }
diff --git a/service-t/src/com/android/server/connectivity/mdns/MdnsServiceInfo.java b/service-t/src/com/android/server/connectivity/mdns/MdnsServiceInfo.java
index a16fcf7e08..0bc0c497cc 100644
--- a/service-t/src/com/android/server/connectivity/mdns/MdnsServiceInfo.java
+++ b/service-t/src/com/android/server/connectivity/mdns/MdnsServiceInfo.java
@@ -57,7 +57,6 @@ public class MdnsServiceInfo implements Parcelable {
                             source.readInt(),
                             source.createStringArrayList(),
                             source.createStringArrayList(),
-                            source.createStringArrayList(),
                             source.createTypedArrayList(TextEntry.CREATOR),
                             source.readInt(),
                             source.readParcelable(Network.class.getClassLoader()),
@@ -79,7 +78,6 @@ public class MdnsServiceInfo implements Parcelable {
     private final List<String> ipv4Addresses;
     @NonNull
     private final List<String> ipv6Addresses;
-    final List<String> textStrings;
     @Nullable
     final List<TextEntry> textEntries;
     private final int interfaceIndex;
@@ -104,7 +102,6 @@ public class MdnsServiceInfo implements Parcelable {
             int port,
             @Nullable String ipv4Address,
             @Nullable String ipv6Address,
-            @Nullable List<String> textStrings,
             @Nullable List<TextEntry> textEntries,
             int interfaceIndex) {
         this(
@@ -115,7 +112,6 @@ public class MdnsServiceInfo implements Parcelable {
                 port,
                 List.of(ipv4Address),
                 List.of(ipv6Address),
-                textStrings,
                 textEntries,
                 interfaceIndex,
                 /* network= */ null,
@@ -135,7 +131,6 @@ public class MdnsServiceInfo implements Parcelable {
             int port,
             @NonNull List<String> ipv4Addresses,
             @NonNull List<String> ipv6Addresses,
-            @Nullable List<String> textStrings,
             @Nullable List<TextEntry> textEntries,
             int interfaceIndex,
             @Nullable Network network,
@@ -150,19 +145,13 @@ public class MdnsServiceInfo implements Parcelable {
         this.port = port;
         this.ipv4Addresses = new ArrayList<>(ipv4Addresses);
         this.ipv6Addresses = new ArrayList<>(ipv6Addresses);
-        this.textStrings = new ArrayList<>();
-        if (textStrings != null) {
-            this.textStrings.addAll(textStrings);
-        }
-        this.textEntries = (textEntries == null) ? null : new ArrayList<>(textEntries);
+        this.textEntries = (textEntries == null)
+                ? Collections.emptyList()
+                : new ArrayList<>(textEntries);
 
-        // The module side sends both {@code textStrings} and {@code textEntries} for backward
-        // compatibility. We should prefer only {@code textEntries} if it's not null.
-        List<TextEntry> entries =
-                (this.textEntries != null) ? this.textEntries : parseTextStrings(this.textStrings);
         // The map of attributes is case-insensitive.
         final Map<String, byte[]> attributes = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
-        for (TextEntry entry : entries) {
+        for (TextEntry entry : this.textEntries) {
             // Per https://datatracker.ietf.org/doc/html/rfc6763#section-6.4, only the first entry
             // of the same key should be accepted:
             // If a client receives a TXT record containing the same key more than once, then the
@@ -175,17 +164,6 @@ public class MdnsServiceInfo implements Parcelable {
         this.expirationTime = Instant.ofEpochSecond(expirationTime.getEpochSecond());
     }
 
-    private static List<TextEntry> parseTextStrings(List<String> textStrings) {
-        List<TextEntry> list = new ArrayList(textStrings.size());
-        for (String textString : textStrings) {
-            TextEntry entry = TextEntry.fromString(textString);
-            if (entry != null) {
-                list.add(entry);
-            }
-        }
-        return Collections.unmodifiableList(list);
-    }
-
     /** Returns the name of this service instance. */
     public String getServiceInstanceName() {
         return serviceInstanceName;
@@ -327,7 +305,6 @@ public class MdnsServiceInfo implements Parcelable {
         out.writeInt(port);
         out.writeStringList(ipv4Addresses);
         out.writeStringList(ipv6Addresses);
-        out.writeStringList(textStrings);
         out.writeTypedList(textEntries);
         out.writeInt(interfaceIndex);
         out.writeParcelable(network, 0);
@@ -344,7 +321,6 @@ public class MdnsServiceInfo implements Parcelable {
                 + ", port: " + port
                 + ", interfaceIndex: " + interfaceIndex
                 + ", network: " + network
-                + ", textStrings: " + textStrings
                 + ", textEntries: " + textEntries
                 + ", expirationTime: " + expirationTime;
     }
diff --git a/service-t/src/com/android/server/connectivity/mdns/MdnsServiceTypeClient.java b/service-t/src/com/android/server/connectivity/mdns/MdnsServiceTypeClient.java
index 95f4fffa7a..f4622265e6 100644
--- a/service-t/src/com/android/server/connectivity/mdns/MdnsServiceTypeClient.java
+++ b/service-t/src/com/android/server/connectivity/mdns/MdnsServiceTypeClient.java
@@ -23,6 +23,7 @@ import static com.android.server.connectivity.mdns.MdnsServiceCache.findMatchedR
 import static com.android.server.connectivity.mdns.MdnsQueryScheduler.ScheduledQueryTaskArgs;
 import static com.android.server.connectivity.mdns.util.MdnsUtils.Clock;
 import static com.android.server.connectivity.mdns.util.MdnsUtils.buildMdnsServiceInfoFromResponse;
+import static com.android.server.connectivity.mdns.util.MdnsUtils.responseMatchesInstanceNameAndSubtypes;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
@@ -64,7 +65,9 @@ public class MdnsServiceTypeClient {
     @VisibleForTesting
     static final int EVENT_START_QUERYTASK = 1;
     static final int EVENT_QUERY_RESULT = 2;
+    static final int EVENT_REMOVE_EXPIRED_SERVICES = 3;
     static final int INVALID_TRANSACTION_ID = -1;
+    static final long REMOVE_SERVICE_AFTER_QUERY_SENT_TIME = 2000L;
 
     private final String serviceType;
     private final String[] serviceTypeLabels;
@@ -128,8 +131,13 @@ public class MdnsServiceTypeClient {
             return discoveredServiceNames.add(DnsUtils.toDnsUpperCase(serviceName));
         }
 
-        void unsetServiceDiscovered(@NonNull String serviceName) {
-            discoveredServiceNames.remove(DnsUtils.toDnsUpperCase(serviceName));
+        /**
+         * Unset the given service name as discovered.
+         *
+         * @return true if the service name was discovered before.
+         */
+        boolean unsetServiceDiscovered(@NonNull String serviceName) {
+            return discoveredServiceNames.remove(DnsUtils.toDnsUpperCase(serviceName));
         }
     }
 
@@ -157,7 +165,7 @@ public class MdnsServiceTypeClient {
                     break;
                 }
                 case EVENT_QUERY_RESULT: {
-                    final QuerySentArguments sentResult = (QuerySentArguments) msg.obj;
+                    final QuerySentResult sentResult = (QuerySentResult) msg.obj;
                     // If a task is cancelled while the Executor is running it, EVENT_QUERY_RESULT
                     // will still be sent when it ends. So use session ID to check if this task
                     // should continue to schedule more.
@@ -168,11 +176,14 @@ public class MdnsServiceTypeClient {
                     if ((sentResult.transactionId != INVALID_TRANSACTION_ID)) {
                         for (int i = 0; i < listeners.size(); i++) {
                             listeners.keyAt(i).onDiscoveryQuerySent(
-                                    sentResult.subTypes, sentResult.transactionId);
+                                    sentResult.queriedSubtypes, sentResult.transactionId);
                         }
                     }
 
-                    tryRemoveServiceAfterTtlExpires();
+                    if (!featureFlags.mIsOptimizedExpiredServiceRemovalEnabled) {
+                        tryRemoveServiceAfterTtlExpires();
+                    }
+
 
                     final long now = clock.elapsedRealtime();
                     lastSentTime = now;
@@ -200,6 +211,42 @@ public class MdnsServiceTypeClient {
                                 handler.obtainMessage(EVENT_START_QUERYTASK, args),
                                 timeToNextTaskMs);
                     }
+                    if (featureFlags.mIsOptimizedExpiredServiceRemovalEnabled) {
+                        // Update the first query time based on the query result
+                        if (sentResult.queriedBaseType) {
+                            serviceCache.updateFirstQueryTimeForCachedServices(
+                                    null /* serviceName */,
+                                    Collections.emptyList() /* subtypes */, cacheKey, now);
+                        }
+                        if (sentResult.queriedSubtypes.size() != 0) {
+                            serviceCache.updateFirstQueryTimeForCachedServices(
+                                    null /* serviceName */,
+                                    sentResult.queriedSubtypes, cacheKey, now);
+                        }
+                        for (MdnsResponse service : sentResult.resolvedServices) {
+                            serviceCache.updateFirstQueryTimeForCachedServices(
+                                    service.getServiceInstanceName(),
+                                    Collections.emptyList() /* subtypes */, cacheKey, now);
+                        }
+
+                        // A query is sent. Schedule a task with a delay to wait for responses, and
+                        // then remove expired services, and notify listeners.
+                        if (scheduler != null) {
+                            scheduler.sendDelayedMessage(
+                                    EVENT_REMOVE_EXPIRED_SERVICES, 0, 0, null /* obj */,
+                                    REMOVE_SERVICE_AFTER_QUERY_SENT_TIME);
+                        } else {
+                            dependencies.sendMessageDelayed(
+                                    handler,
+                                    handler.obtainMessage(EVENT_REMOVE_EXPIRED_SERVICES),
+                                    REMOVE_SERVICE_AFTER_QUERY_SENT_TIME);
+                        }
+                    }
+                    break;
+                }
+                case EVENT_REMOVE_EXPIRED_SERVICES: {
+                    serviceCache.removeExpiredServicesAndNotifyListeners(
+                            cacheKey, clock.elapsedRealtime());
                     break;
                 }
                 default:
@@ -334,13 +381,14 @@ public class MdnsServiceTypeClient {
 
     private List<MdnsResponse> getExistingServices() {
         return featureFlags.isQueryWithKnownAnswerEnabled()
-                ? serviceCache.getCachedServices(cacheKey) : Collections.emptyList();
+                ? serviceCache.getCachedServices(cacheKey, true /* excludeExpiredServices */)
+                : Collections.emptyList();
     }
 
     private void setDelayedTask(ScheduledQueryTaskArgs args, long timeToNextTaskMs) {
         scheduler.removeDelayedMessage(EVENT_START_QUERYTASK);
-        scheduler.sendDelayedMessage(
-                handler.obtainMessage(EVENT_START_QUERYTASK, args), timeToNextTaskMs);
+        scheduler.sendDelayedMessage(EVENT_START_QUERYTASK, 0, 0, args,
+                timeToNextTaskMs);
     }
 
     /**
@@ -362,8 +410,12 @@ public class MdnsServiceTypeClient {
         final ListenerInfo listenerInfo = new ListenerInfo(searchOptions, existingInfo);
         listeners.put(listener, listenerInfo);
         if (existingInfo == null) {
-            for (MdnsResponse existingResponse : serviceCache.getCachedServices(cacheKey)) {
-                if (!responseMatchesOptions(existingResponse, searchOptions)) continue;
+            for (MdnsResponse existingResponse : serviceCache.getCachedServices(
+                    cacheKey, true /* excludeExpiredServices */)) {
+                if (!responseMatchesInstanceNameAndSubtypes(existingResponse,
+                        searchOptions.getResolveInstanceName(), searchOptions.getSubtypes())) {
+                    continue;
+                }
                 final MdnsServiceInfo info = buildMdnsServiceInfoFromResponse(
                         existingResponse, serviceTypeLabels, clock.elapsedRealtime());
                 listener.onServiceNameDiscovered(info, true /* isServiceFromCache */);
@@ -460,26 +512,6 @@ public class MdnsServiceTypeClient {
         ++currentSessionId;
     }
 
-    private boolean responseMatchesOptions(@NonNull MdnsResponse response,
-            @NonNull MdnsSearchOptions options) {
-        final boolean matchesInstanceName = options.getResolveInstanceName() == null
-                // DNS is case-insensitive, so ignore case in the comparison
-                || DnsUtils.equalsIgnoreDnsCase(options.getResolveInstanceName(),
-                response.getServiceInstanceName());
-
-        // If discovery is requiring some subtypes, the response must have one that matches a
-        // requested one.
-        final List<String> responseSubtypes = response.getSubtypes() == null
-                ? Collections.emptyList() : response.getSubtypes();
-        final boolean matchesSubtype = options.getSubtypes().size() == 0
-                || CollectionUtils.any(options.getSubtypes(), requiredSub ->
-                CollectionUtils.any(responseSubtypes, actualSub ->
-                        DnsUtils.equalsIgnoreDnsCase(
-                                MdnsConstants.SUBTYPE_PREFIX + requiredSub, actualSub)));
-
-        return matchesInstanceName && matchesSubtype;
-    }
-
     /**
      * Unregisters {@code listener} from receiving discovery event of mDNS service instances.
      *
@@ -506,7 +538,9 @@ public class MdnsServiceTypeClient {
         ensureRunningOnHandlerThread(handler);
         // Augment the list of current known responses, and generated responses for resolve
         // requests if there is no known response
-        final List<MdnsResponse> cachedList = serviceCache.getCachedServices(cacheKey);
+        // Expired services are also needed because the response may include them.
+        final List<MdnsResponse> cachedList = serviceCache.getCachedServices(
+                cacheKey, false /* excludeExpiredServices */);
         final List<MdnsResponse> currentList = new ArrayList<>(cachedList);
         List<MdnsResponse> additionalResponses = makeResponsesForResolve(socketKey);
         for (MdnsResponse additionalResponse : additionalResponses) {
@@ -517,7 +551,7 @@ public class MdnsServiceTypeClient {
         }
         final Pair<Set<MdnsResponse>, ArrayList<MdnsResponse>> augmentedResult =
                 responseDecoder.augmentResponses(packet, currentList,
-                        socketKey.getInterfaceIndex(), socketKey.getNetwork());
+                        socketKey.getInterfaceIndex(), socketKey.getNetwork(), featureFlags);
 
         final Set<MdnsResponse> modifiedResponse = augmentedResult.first;
         final ArrayList<MdnsResponse> allResponses = augmentedResult.second;
@@ -577,10 +611,18 @@ public class MdnsServiceTypeClient {
     private void notifyRemovedServiceToListeners(@NonNull MdnsResponse response,
             @NonNull String message) {
         for (int i = 0; i < listeners.size(); i++) {
-            if (!responseMatchesOptions(response, listeners.valueAt(i).searchOptions)) continue;
+            if (!responseMatchesInstanceNameAndSubtypes(response,
+                    listeners.valueAt(i).searchOptions.getResolveInstanceName(),
+                    listeners.valueAt(i).searchOptions.getSubtypes())) {
+                continue;
+            }
             final MdnsServiceBrowserListener listener = listeners.keyAt(i);
             if (response.getServiceInstanceName() != null) {
-                listeners.valueAt(i).unsetServiceDiscovered(response.getServiceInstanceName());
+                if (!listeners.valueAt(i).unsetServiceDiscovered(
+                        response.getServiceInstanceName())) {
+                    // Skip the lost callback if this service has not been notified previously
+                    continue;
+                }
                 final MdnsServiceInfo serviceInfo = buildMdnsServiceInfoFromResponse(
                         response, serviceTypeLabels, clock.elapsedRealtime());
                 if (response.isComplete()) {
@@ -596,7 +638,8 @@ public class MdnsServiceTypeClient {
     /** Notify all services are removed because the socket is destroyed. */
     public void notifySocketDestroyed() {
         ensureRunningOnHandlerThread(handler);
-        for (MdnsResponse response : serviceCache.getCachedServices(cacheKey)) {
+        for (MdnsResponse response : serviceCache.getCachedServices(
+                cacheKey, false /* excludeExpiredServices */)) {
             final String name = response.getServiceInstanceName();
             if (name == null) continue;
             notifyRemovedServiceToListeners(response, "Socket destroyed");
@@ -606,8 +649,8 @@ public class MdnsServiceTypeClient {
 
     private void onResponseModified(@NonNull MdnsResponse response) {
         final String serviceInstanceName = response.getServiceInstanceName();
-        final MdnsResponse currentResponse =
-                serviceCache.getCachedService(serviceInstanceName, cacheKey);
+        final MdnsResponse currentResponse = serviceCache.getCachedService(serviceInstanceName,
+                cacheKey, false /* excludeExpiredServices */);
 
         final boolean newInCache = currentResponse == null;
         boolean serviceBecomesComplete = false;
@@ -634,7 +677,11 @@ public class MdnsServiceTypeClient {
             // subtype), service lost callbacks should also be sent; this is not done today as
             // only expiration of SRV records is used, not PTR records used for subtypes, so
             // services never lose PTR record subtypes.
-            if (!responseMatchesOptions(response, listeners.valueAt(i).searchOptions)) continue;
+            if (!responseMatchesInstanceNameAndSubtypes(response,
+                    listeners.valueAt(i).searchOptions.getResolveInstanceName(),
+                    listeners.valueAt(i).searchOptions.getSubtypes())) {
+                continue;
+            }
             final MdnsServiceBrowserListener listener = listeners.keyAt(i);
             final ListenerInfo listenerInfo = listeners.valueAt(i);
             final boolean newServiceFound = listenerInfo.setServiceDiscovered(serviceInstanceName);
@@ -682,8 +729,12 @@ public class MdnsServiceTypeClient {
                     r -> DnsUtils.equalsIgnoreDnsCase(resolveName, r.getServiceInstanceName()))) {
                 continue;
             }
-            MdnsResponse knownResponse =
-                    serviceCache.getCachedService(resolveName, cacheKey);
+            // The "knownResponse" is used by the query to understand what information the cache
+            // already holds, allowing it to determine which records need to be renewed. Therefore,
+            // expired services should always be included in the returned responses to ensure all
+            // their records are renewed.
+            MdnsResponse knownResponse = serviceCache.getCachedService(
+                    resolveName, cacheKey, false /* excludeExpiredServices */);
             if (knownResponse == null) {
                 final ArrayList<String> instanceFullName = new ArrayList<>(
                         serviceTypeLabels.length + 1);
@@ -712,7 +763,8 @@ public class MdnsServiceTypeClient {
     private void tryRemoveServiceAfterTtlExpires() {
         if (!shouldRemoveServiceAfterTtlExpires()) return;
 
-        final Iterator<MdnsResponse> iter = serviceCache.getCachedServices(cacheKey).iterator();
+        final Iterator<MdnsResponse> iter = serviceCache.getCachedServices(
+                cacheKey, false /* excludeExpiredServices */).iterator();
         while (iter.hasNext()) {
             MdnsResponse existingResponse = iter.next();
             if (existingResponse.hasServiceRecord()
@@ -724,16 +776,36 @@ public class MdnsServiceTypeClient {
         }
     }
 
-    private static class QuerySentArguments {
+    public static class QuerySentResult {
         private final int transactionId;
-        private final List<String> subTypes = new ArrayList<>();
+        private final List<String> queriedSubtypes = new ArrayList<>();
         private final ScheduledQueryTaskArgs taskArgs;
+        private final boolean queriedBaseType;
+        private final Collection<MdnsResponse> resolvedServices = new ArrayList<>();
 
-        QuerySentArguments(int transactionId, @NonNull List<String> subTypes,
-                @NonNull ScheduledQueryTaskArgs taskArgs) {
+        QuerySentResult(int transactionId, @NonNull List<String> subTypes,
+                @NonNull ScheduledQueryTaskArgs taskArgs, boolean queriedBaseType,
+                @NonNull Collection<MdnsResponse> resolvedServices) {
             this.transactionId = transactionId;
-            this.subTypes.addAll(subTypes);
+            this.queriedSubtypes.addAll(subTypes);
             this.taskArgs = taskArgs;
+            this.queriedBaseType = queriedBaseType;
+            this.resolvedServices.addAll(resolvedServices);
+        }
+
+
+        /**
+         * Creates a QuerySentResult instance representing a failed query attempt.
+         *
+         * This factory method is used when the query packet could not be sent successfully.
+         *
+         * @param taskArgs The arguments of the task that attempted the query.
+         * @return A QuerySentResult configured to indicate failure.
+         */
+        public static QuerySentResult createFailedQueryResult(
+                @NonNull ScheduledQueryTaskArgs taskArgs) {
+            return new QuerySentResult(INVALID_TRANSACTION_ID, new ArrayList<>(), taskArgs,
+                    false /* queriedBaseType */, Collections.emptyList() /* resolvedServices */);
         }
     }
 
@@ -763,15 +835,14 @@ public class MdnsServiceTypeClient {
 
         @Override
         public void run() {
-            Pair<Integer, List<String>> result;
+            QuerySentResult result;
             try {
                 result =
                         new EnqueueMdnsQueryCallable(
                                 socketClient,
                                 serviceType,
                                 subtypes,
-                                taskArgs.config.expectUnicastResponse,
-                                taskArgs.config.getTransactionId(),
+                                taskArgs,
                                 socketKey,
                                 onlyUseIpv6OnIpv6OnlyNetworks,
                                 sendDiscoveryQueries,
@@ -785,17 +856,16 @@ public class MdnsServiceTypeClient {
             } catch (RuntimeException e) {
                 sharedLog.e(String.format("Failed to run EnqueueMdnsQueryCallable for subtype: %s",
                         TextUtils.join(",", subtypes)), e);
-                result = Pair.create(INVALID_TRANSACTION_ID, new ArrayList<>());
+                result = QuerySentResult.createFailedQueryResult(taskArgs);
             }
-            dependencies.sendMessage(
-                    handler, handler.obtainMessage(EVENT_QUERY_RESULT,
-                            new QuerySentArguments(result.first, result.second, taskArgs)));
+            dependencies.sendMessage(handler, handler.obtainMessage(EVENT_QUERY_RESULT, result));
         }
     }
 
     private long getMinRemainingTtl(long now) {
         long minRemainingTtl = Long.MAX_VALUE;
-        for (MdnsResponse response : serviceCache.getCachedServices(cacheKey)) {
+        for (MdnsResponse response : serviceCache.getCachedServices(
+                cacheKey, false /* excludeExpiredServices */)) {
             if (!response.isComplete()) {
                 continue;
             }
diff --git a/service-t/src/com/android/server/connectivity/mdns/MdnsSocket.java b/service-t/src/com/android/server/connectivity/mdns/MdnsSocket.java
index 653ea6ccad..e69c819299 100644
--- a/service-t/src/com/android/server/connectivity/mdns/MdnsSocket.java
+++ b/service-t/src/com/android/server/connectivity/mdns/MdnsSocket.java
@@ -64,7 +64,6 @@ public class MdnsSocket {
         // Time to live is set 255, which is similar to the jMDNS implementation.
         multicastSocket.setTimeToLive(255);
 
-        // TODO (changed when importing code): consider tagging the socket for data usage
         isOnIPv6OnlyNetwork = false;
     }
 
diff --git a/service-t/src/com/android/server/connectivity/mdns/MdnsSocketClient.java b/service-t/src/com/android/server/connectivity/mdns/MdnsSocketClient.java
index 17e5b312ca..40039c5682 100644
--- a/service-t/src/com/android/server/connectivity/mdns/MdnsSocketClient.java
+++ b/service-t/src/com/android/server/connectivity/mdns/MdnsSocketClient.java
@@ -22,6 +22,7 @@ import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.content.Context;
 import android.net.Network;
+import android.net.TrafficStats;
 import android.net.wifi.WifiManager.MulticastLock;
 import android.os.SystemClock;
 import android.text.format.DateUtils;
@@ -34,6 +35,7 @@ import com.android.server.connectivity.mdns.util.MdnsUtils;
 
 import java.io.IOException;
 import java.net.DatagramPacket;
+import java.net.InetAddress;
 import java.net.Inet4Address;
 import java.net.Inet6Address;
 import java.net.InetSocketAddress;
@@ -145,7 +147,10 @@ public class MdnsSocketClient implements MdnsSocketClientBase {
         shouldStopSocketLoop = false;
         interfaceProvider.startWatchingConnectivityChanges();
         try {
-            // TODO (changed when importing code): consider setting thread stats tag
+            if (mdnsFeatureFlags.mMdnsSocketThreadStatsTag
+                    != MdnsFeatureFlags.MDNS_SOCKET_THREAD_STATS_TAG_NONE) {
+                setThreadStatsTag(mdnsFeatureFlags.mMdnsSocketThreadStatsTag);
+            }
             multicastSocket = createMdnsSocket(MdnsConstants.MDNS_PORT, sharedLog);
             multicastSocket.joinGroup();
             if (useSeparateSocketForUnicast) {
@@ -165,7 +170,10 @@ public class MdnsSocketClient implements MdnsSocketClientBase {
             }
             throw e;
         } finally {
-            // TODO (changed when importing code): consider resetting thread stats tag
+            if (mdnsFeatureFlags.mMdnsSocketThreadStatsTag
+                    != MdnsFeatureFlags.MDNS_SOCKET_THREAD_STATS_TAG_NONE) {
+                clearThreadStatsTag();
+            }
         }
         createAndStartSendThread();
         createAndStartReceiverThreads();
@@ -451,13 +459,32 @@ public class MdnsSocketClient implements MdnsSocketClientBase {
 
                 if (!shouldStopSocketLoop) {
                     String responseType = socket == multicastSocket ? MULTICAST_TYPE : UNICAST_TYPE;
+                    // packet.getAddress() can return:
+                    // an IP address of the machine to which this datagram is being sent or
+                    // from which the datagram was received
+                    // or {@code null} if not set.
+                    final InetAddress packetAddress = packet.getAddress();
+                    final SocketKey key =
+                        (mdnsFeatureFlags.mIsSocketClientNetworkGuessingEnabled && packetAddress != null)
+                            ? interfaceProvider.guessNetworkOfRemoteHost(packetAddress)
+                            : null;
+                    final int interfaceIndex;
+                    if (socket == null || !propagateInterfaceIndex) {
+                        interfaceIndex = MdnsSocket.INTERFACE_INDEX_UNSPECIFIED;
+                    } else if (mdnsFeatureFlags.mIsSocketClientNetworkGuessingEnabled) {
+                        interfaceIndex = key == null
+                                ? MdnsSocket.INTERFACE_INDEX_UNSPECIFIED
+                                : key.getInterfaceIndex();
+                    } else {
+                        // Note this is incorrect: getInterfaceIndex is the last interface that sent
+                        // a packet, not the one that received the packet.
+                        interfaceIndex = socket.getInterfaceIndex();
+                    }
                     processResponsePacket(
                             packet,
                             responseType,
-                            /* interfaceIndex= */ (socket == null || !propagateInterfaceIndex)
-                                    ? MdnsSocket.INTERFACE_INDEX_UNSPECIFIED
-                                    : socket.getInterfaceIndex(),
-                            /* network= */ socket.getNetwork());
+                            interfaceIndex,
+                            key == null ? null : key.getNetwork());
                 }
             } catch (IOException e) {
                 if (!shouldStopSocketLoop) {
@@ -503,6 +530,16 @@ public class MdnsSocketClient implements MdnsSocketClientBase {
         return new MdnsSocket(interfaceProvider, port, sharedLog);
     }
 
+    @VisibleForTesting
+    void setThreadStatsTag(int tag) {
+        TrafficStats.setThreadStatsTag(tag);
+    }
+
+    @VisibleForTesting
+    void clearThreadStatsTag() {
+        TrafficStats.clearThreadStatsTag();
+    }
+
     private void sendPackets(List<DatagramPacket> packets, MdnsSocket socket) {
         String requestType = socket == multicastSocket ? "multicast" : "unicast";
         for (DatagramPacket packet : packets) {
diff --git a/service-t/src/com/android/server/connectivity/mdns/MdnsSocketProvider.java b/service-t/src/com/android/server/connectivity/mdns/MdnsSocketProvider.java
index d91bd112b3..49e4e28d32 100644
--- a/service-t/src/com/android/server/connectivity/mdns/MdnsSocketProvider.java
+++ b/service-t/src/com/android/server/connectivity/mdns/MdnsSocketProvider.java
@@ -17,6 +17,7 @@
 package com.android.server.connectivity.mdns;
 
 import static android.net.NetworkCapabilities.TRANSPORT_CELLULAR;
+import static android.net.NetworkCapabilities.TRANSPORT_THREAD;
 import static android.net.NetworkCapabilities.TRANSPORT_VPN;
 import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
 
@@ -561,8 +562,9 @@ public class MdnsSocketProvider {
     private boolean isMdnsCapableInterface(
             @NonNull NetworkInterfaceWrapper iface, @NonNull int[] transports) {
         try {
-            // Never try mDNS on cellular, or on interfaces with incompatible flags
+            // Never try mDNS on cellular, on Thread, or on interfaces with incompatible flags
             if (CollectionUtils.contains(transports, TRANSPORT_CELLULAR)
+                    || CollectionUtils.contains(transports, TRANSPORT_THREAD)
                     || iface.isLoopback()
                     || iface.isVirtual()
                     || !iface.isUp()) {
diff --git a/service-t/src/com/android/server/connectivity/mdns/MulticastNetworkInterfaceProvider.java b/service-t/src/com/android/server/connectivity/mdns/MulticastNetworkInterfaceProvider.java
index da82e96541..f3f28e725b 100644
--- a/service-t/src/com/android/server/connectivity/mdns/MulticastNetworkInterfaceProvider.java
+++ b/service-t/src/com/android/server/connectivity/mdns/MulticastNetworkInterfaceProvider.java
@@ -21,12 +21,15 @@ import android.annotation.Nullable;
 import android.content.Context;
 import android.net.Network;
 
+import androidx.annotation.GuardedBy;
+
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.net.module.util.SharedLog;
 
 import java.io.IOException;
 import java.net.Inet4Address;
 import java.net.Inet6Address;
+import java.net.InetAddress;
 import java.net.InterfaceAddress;
 import java.net.NetworkInterface;
 import java.net.SocketException;
@@ -44,10 +47,11 @@ public class MulticastNetworkInterfaceProvider {
     private final SharedLog sharedLog;
     private static final boolean PREFER_IPV6 = MdnsConfigs.preferIpv6();
 
+    @GuardedBy("this")
     private final List<NetworkInterfaceWrapper> multicastNetworkInterfaces = new ArrayList<>();
     // Only modifiable from tests.
     @VisibleForTesting
-    ConnectivityMonitor connectivityMonitor;
+    ConnectivityMonitorWithConnectivityManager connectivityMonitor;
     private volatile boolean connectivityChanged = true;
 
     @SuppressWarnings("nullness:methodref.receiver.bound")
@@ -91,6 +95,7 @@ public class MulticastNetworkInterfaceProvider {
         return new ArrayList<>(multicastNetworkInterfaces);
     }
 
+    @GuardedBy("this")
     private void updateMulticastNetworkInterfaces() {
         multicastNetworkInterfaces.clear();
         List<NetworkInterfaceWrapper> networkInterfaceWrappers = getNetworkInterfaces();
@@ -149,6 +154,15 @@ public class MulticastNetworkInterfaceProvider {
         return connectivityMonitor.getAvailableNetwork();
     }
 
+    /**
+     * @see ConnectivityMonitorWithConnectivityManager#guessNetworkOfRemoteHost(List, InetAddress)
+     */
+    @Nullable
+    public synchronized SocketKey guessNetworkOfRemoteHost(@NonNull InetAddress address) {
+        return connectivityMonitor.guessNetworkOfRemoteHost(
+                getMulticastNetworkInterfaces(), address);
+    }
+
     /*** Check whether given network interface can support mdns */
     private static boolean canScanOnInterface(@Nullable NetworkInterfaceWrapper networkInterface,
             @NonNull SharedLog sharedLog) {
diff --git a/service-t/src/com/android/server/connectivity/mdns/NetworkInterfaceWrapper.java b/service-t/src/com/android/server/connectivity/mdns/NetworkInterfaceWrapper.java
index 48c396e6af..105cc6b0a7 100644
--- a/service-t/src/com/android/server/connectivity/mdns/NetworkInterfaceWrapper.java
+++ b/service-t/src/com/android/server/connectivity/mdns/NetworkInterfaceWrapper.java
@@ -57,6 +57,12 @@ public class NetworkInterfaceWrapper {
         return networkInterface.getInterfaceAddresses();
     }
 
+    /** @see java.net.NetworkInterface#getName() */
+    public String getName() {
+        return networkInterface.getName();
+    }
+
+    /** @see java.net.NetworkInterface#getIndex() */
     public int getIndex() {
         return networkInterface.getIndex();
     }
diff --git a/service-t/src/com/android/server/connectivity/mdns/Scheduler.java b/service-t/src/com/android/server/connectivity/mdns/Scheduler.java
index 85a8e76f22..f725dd05e3 100644
--- a/service-t/src/com/android/server/connectivity/mdns/Scheduler.java
+++ b/service-t/src/com/android/server/connectivity/mdns/Scheduler.java
@@ -16,9 +16,8 @@
 
 package com.android.server.connectivity.mdns;
 
-import android.os.Message;
-
 import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 
 /**
  * The interface for scheduler.
@@ -27,7 +26,8 @@ public interface Scheduler {
     /**
      * Set a message to be sent after a specified delay.
      */
-    boolean sendDelayedMessage(@NonNull Message message, long delayMs);
+    boolean sendDelayedMessage(int what, int arg1, int arg2, @Nullable Object obj,
+            long delayMs);
 
     /**
      * Remove a scheduled message.
diff --git a/service-t/src/com/android/server/connectivity/mdns/internal/MdnsRealtimeScheduler.java b/service-t/src/com/android/server/connectivity/mdns/internal/MdnsRealtimeScheduler.java
index eff7085809..1d73a8a7ed 100644
--- a/service-t/src/com/android/server/connectivity/mdns/internal/MdnsRealtimeScheduler.java
+++ b/service-t/src/com/android/server/connectivity/mdns/internal/MdnsRealtimeScheduler.java
@@ -17,9 +17,9 @@
 package com.android.server.connectivity.mdns.internal;
 
 import android.os.Handler;
-import android.os.Message;
 
 import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 
 import com.android.net.module.util.RealtimeScheduler;
 import com.android.server.connectivity.mdns.Scheduler;
@@ -35,8 +35,9 @@ public class MdnsRealtimeScheduler extends RealtimeScheduler implements
         super(handler);
     }
 
-    public boolean sendDelayedMessage(@NonNull Message message, long delayMs) {
-        return super.sendDelayedMessage(message, delayMs);
+    public boolean sendDelayedMessage(int what, int arg1, int arg2, @Nullable Object obj,
+            long delayMs) {
+        return super.sendDelayedMessage(what, arg1, arg2, obj, delayMs);
     }
 
     public void removeDelayedMessage(int what) {
diff --git a/service-t/src/com/android/server/connectivity/mdns/util/MdnsUtils.java b/service-t/src/com/android/server/connectivity/mdns/util/MdnsUtils.java
index 282ca9ab5d..957fe0fa81 100644
--- a/service-t/src/com/android/server/connectivity/mdns/util/MdnsUtils.java
+++ b/service-t/src/com/android/server/connectivity/mdns/util/MdnsUtils.java
@@ -29,6 +29,7 @@ import android.util.ArraySet;
 import android.util.Pair;
 
 import com.android.net.module.util.CollectionUtils;
+import com.android.net.module.util.DnsUtils;
 import com.android.server.connectivity.mdns.MdnsConstants;
 import com.android.server.connectivity.mdns.MdnsInetAddressRecord;
 import com.android.server.connectivity.mdns.MdnsPacket;
@@ -51,6 +52,7 @@ import java.nio.charset.StandardCharsets;
 import java.time.Instant;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
@@ -342,10 +344,8 @@ public class MdnsUtils {
             throw new IllegalStateException(
                     "mDNS response must have non-null service instance name");
         }
-        List<String> textStrings = null;
         List<MdnsServiceInfo.TextEntry> textEntries = null;
         if (response.hasTextRecord()) {
-            textStrings = response.getTextRecord().getStrings();
             textEntries = response.getTextRecord().getEntries();
         }
         Instant now = Instant.now();
@@ -358,10 +358,39 @@ public class MdnsUtils {
                 port,
                 ipv4Addresses,
                 ipv6Addresses,
-                textStrings,
                 textEntries,
                 response.getInterfaceIndex(),
                 response.getNetwork(),
                 now.plusMillis(response.getMinRemainingTtl(elapsedRealtimeMillis)));
     }
+
+    /**
+     * Checks if an MDNS response matches a given instance name and a collection of subtypes.
+     *
+     * <p>This method performs a case-insensitive comparison of the instance name and subtypes,
+     * respecting DNS conventions.
+     *
+     * @param response     The MDNS response to check.
+     * @param instanceName The instance name to match, or null to ignore instance name matching.
+     * @param subtypes     The collection of subtypes to match.
+     * @return {@code true} if the response matches the instance name and at least one of the
+     * specified subtypes (if any), {@code false} otherwise.
+     */
+    public static boolean responseMatchesInstanceNameAndSubtypes(@NonNull MdnsResponse response,
+            @Nullable String instanceName, @NonNull Collection<String> subtypes) {
+        final boolean matchesInstanceName = instanceName == null
+                // DNS is case-insensitive, so ignore case in the comparison
+                || DnsUtils.equalsIgnoreDnsCase(instanceName, response.getServiceInstanceName());
+
+        // If discovery is requiring some subtypes, the response must have one that matches a
+        // requested one.
+        final List<String> responseSubtypes = response.getSubtypes() == null
+                ? Collections.emptyList() : response.getSubtypes();
+        final boolean matchesSubtype = subtypes.size() == 0
+                || CollectionUtils.any(subtypes, requiredSub ->
+                CollectionUtils.any(responseSubtypes, actualSub ->
+                        DnsUtils.equalsIgnoreDnsCase(
+                                MdnsConstants.SUBTYPE_PREFIX + requiredSub, actualSub)));
+        return matchesInstanceName && matchesSubtype;
+    }
 }
\ No newline at end of file
diff --git a/service-t/src/com/android/server/ethernet/EthernetNetworkFactory.java b/service-t/src/com/android/server/ethernet/EthernetNetworkFactory.java
index 1ac99e4649..c0ecc1a2b0 100644
--- a/service-t/src/com/android/server/ethernet/EthernetNetworkFactory.java
+++ b/service-t/src/com/android/server/ethernet/EthernetNetworkFactory.java
@@ -52,6 +52,8 @@ import com.android.net.module.util.InterfaceParams;
 import com.android.server.connectivity.ConnectivityResources;
 
 import java.io.FileDescriptor;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Objects;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
@@ -126,27 +128,41 @@ public class EthernetNetworkFactory {
         mContext.getSystemService(ConnectivityManager.class).registerNetworkProvider(mProvider);
     }
 
+    /** Returns an unordered(!) list of EthernetPort objects tracked by this factory. */
+    public List<EthernetPort> getEthernetPorts() {
+        // Note that while mTrackingInterfaces is a ConcurrentHashMap, it is only ever modified on
+        // the handler thread.
+        final List<EthernetPort> ports = new ArrayList<>(mTrackingInterfaces.size());
+        for (NetworkInterfaceState iface : mTrackingInterfaces.values()) {
+            ports.add(iface.getPort());
+        }
+        return ports;
+    }
+
     /**
      * Returns an array of available interface names. The array is sorted: unrestricted interfaces
      * goes first, then sorted by name.
      */
-    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
-    protected String[] getAvailableInterfaces(boolean includeRestricted) {
+    public String[] getInterfacesSorted(boolean includeRestricted) {
         return mTrackingInterfaces.values()
                 .stream()
                 .filter(iface -> !iface.isRestricted() || includeRestricted)
                 .sorted((iface1, iface2) -> {
-                    int r = Boolean.compare(iface1.isRestricted(), iface2.isRestricted());
-                    return r == 0 ? iface1.name.compareTo(iface2.name) : r;
+                    final int r = Boolean.compare(iface1.isRestricted(), iface2.isRestricted());
+                    final String ifname1 = iface1.getPort().getInterfaceName();
+                    final String ifname2 = iface2.getPort().getInterfaceName();
+                    return r == 0 ? ifname1.compareTo(ifname2) : r;
                 })
-                .map(iface -> iface.name)
+                .map(iface -> iface.getPort().getInterfaceName())
                 .toArray(String[]::new);
     }
 
-    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
-    protected void addInterface(@NonNull final String ifaceName, @NonNull final String hwAddress,
-            @NonNull final IpConfiguration ipConfig,
-            @NonNull final NetworkCapabilities capabilities) {
+    /** Add an interface to the factory. */
+    public void addInterface(EthernetPort port, IpConfiguration ipConfig,
+            NetworkCapabilities capabilities) {
+        final String ifaceName = port.getInterfaceName();
+        final String hwAddress = port.getMacAddress().toString();
+
         if (mTrackingInterfaces.containsKey(ifaceName)) {
             Log.e(TAG, "Interface with name " + ifaceName + " already exists.");
             return;
@@ -161,7 +177,7 @@ public class EthernetNetworkFactory {
         }
 
         final NetworkInterfaceState iface = new NetworkInterfaceState(
-                ifaceName, hwAddress, mHandler, mContext, ipConfig, nc, mProvider, mDeps);
+                port, mHandler, mContext, ipConfig, nc, mProvider, mDeps);
         mTrackingInterfaces.put(ifaceName, iface);
     }
 
@@ -202,9 +218,9 @@ public class EthernetNetworkFactory {
         return;
     }
 
-    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
-    protected boolean removeInterface(String interfaceName) {
-        NetworkInterfaceState iface = mTrackingInterfaces.remove(interfaceName);
+    /** Removes the interface from the factory and returns whether the interface was tracked */
+    public boolean removeInterface(EthernetPort port) {
+        NetworkInterfaceState iface = mTrackingInterfaces.remove(port.getInterfaceName());
         if (iface != null) {
             iface.unregisterNetworkOfferAndStop();
             return true;
@@ -212,13 +228,13 @@ public class EthernetNetworkFactory {
         // TODO(b/236892130): if an interface is currently in server mode, it may not be properly
         // removed.
         // TODO: when false is returned, do not send a STATE_ABSENT callback.
-        Log.w(TAG, interfaceName + " is not tracked and cannot be removed");
+        Log.w(TAG, "removeInterface() failed because port is not tracked " + port);
         return false;
     }
 
     /** Returns true if state has been modified */
-    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
-    protected boolean updateInterfaceLinkState(@NonNull final String ifaceName, final boolean up) {
+    public boolean updateInterfaceLinkState(EthernetPort port, boolean up) {
+        final String ifaceName = port.getInterfaceName();
         if (!hasInterface(ifaceName)) {
             return false;
         }
@@ -244,14 +260,12 @@ public class EthernetNetworkFactory {
         }
 
         NetworkInterfaceState iface = mTrackingInterfaces.get(ifaceName);
-        return iface.mHwAddress;
+        return iface.getPort().getMacAddress().toString();
     }
 
     @VisibleForTesting
     static class NetworkInterfaceState {
-        final String name;
-
-        private final String mHwAddress;
+        private final EthernetPort mPort;
         private final Handler mHandler;
         private final Context mContext;
         private final NetworkProvider mNetworkProvider;
@@ -363,7 +377,7 @@ public class EthernetNetworkFactory {
                     return;
                 }
                 if (DBG) {
-                    Log.d(TAG, String.format("%s: onNetworkNeeded for request: %s", name, request));
+                    Log.d(TAG, String.format("%s: onNetworkNeeded: %s", mPort, request));
                 }
                 // When the network offer is first registered, onNetworkNeeded is called with all
                 // existing requests.
@@ -380,8 +394,7 @@ public class EthernetNetworkFactory {
                     return;
                 }
                 if (DBG) {
-                    Log.d(TAG,
-                            String.format("%s: onNetworkUnneeded for request: %s", name, request));
+                    Log.d(TAG, String.format("%s: onNetworkUnneeded: %s", mPort, request));
                 }
                 if (!mRequestIds.remove(request.requestId)) {
                     // This can only happen if onNetworkNeeded was not called for a request or if
@@ -395,10 +408,10 @@ public class EthernetNetworkFactory {
             }
         }
 
-        NetworkInterfaceState(String ifaceName, String hwAddress, Handler handler, Context context,
+        NetworkInterfaceState(EthernetPort port, Handler handler, Context context,
                 @NonNull IpConfiguration ipConfig, @NonNull NetworkCapabilities capabilities,
                 NetworkProvider networkProvider, Dependencies deps) {
-            name = ifaceName;
+            mPort = port;
             mIpConfig = Objects.requireNonNull(ipConfig);
             mCapabilities = Objects.requireNonNull(capabilities);
             mLegacyType = getLegacyType(mCapabilities);
@@ -406,7 +419,11 @@ public class EthernetNetworkFactory {
             mContext = context;
             mNetworkProvider = networkProvider;
             mDeps = deps;
-            mHwAddress = hwAddress;
+        }
+
+        /** Returns the EthernetPort object */
+        public EthernetPort getPort() {
+            return mPort;
         }
 
         /**
@@ -446,7 +463,7 @@ public class EthernetNetworkFactory {
         void updateInterface(@Nullable final IpConfiguration ipConfig,
                 @Nullable final NetworkCapabilities capabilities) {
             if (DBG) {
-                Log.d(TAG, "updateInterface, iface: " + name
+                Log.d(TAG, "updateInterface, port: " + mPort
                         + ", ipConfig: " + ipConfig + ", old ipConfig: " + mIpConfig
                         + ", capabilities: " + capabilities + ", old capabilities: " + mCapabilities
                 );
@@ -474,11 +491,11 @@ public class EthernetNetworkFactory {
                 return;
             }
             if (DBG) {
-                Log.d(TAG, String.format("Starting Ethernet IpClient(%s)", name));
+                Log.d(TAG, String.format("Starting Ethernet IpClient(%s)", mPort));
             }
 
             mIpClientCallback = new EthernetIpClientCallback();
-            mDeps.makeIpClient(mContext, name, mIpClientCallback);
+            mDeps.makeIpClient(mContext, mPort.getInterfaceName(), mIpClientCallback);
             mIpClientCallback.awaitIpClientStart();
 
             if (mIpConfig.getProxySettings() == ProxySettings.STATIC
@@ -508,7 +525,7 @@ public class EthernetNetworkFactory {
             final NetworkAgentConfig config = new NetworkAgentConfig.Builder()
                     .setLegacyType(mLegacyType)
                     .setLegacyTypeName(NETWORK_TYPE)
-                    .setLegacyExtraInfo(mHwAddress)
+                    .setLegacyExtraInfo(mPort.getMacAddress().toString())
                     .build();
             mNetworkAgent = mDeps.makeEthernetNetworkAgent(mContext, mHandler.getLooper(),
                     mCapabilities, mLinkProperties, config, mNetworkProvider,
@@ -534,8 +551,9 @@ public class EthernetNetworkFactory {
             // There is no point in continuing if the interface is gone as stop() will be triggered
             // by removeInterface() when processed on the handler thread and start() won't
             // work for a non-existent interface.
-            if (null == mDeps.getNetworkInterfaceByName(name)) {
-                if (DBG) Log.d(TAG, name + " is no longer available.");
+            // TODO: consider removing this functionality entirely and maybeRestart() regardless.
+            if (null == mDeps.getNetworkInterfaceByName(mPort.getInterfaceName())) {
+                if (DBG) Log.d(TAG, mPort + " is no longer available.");
                 // Send a callback in case a provisioning request was in progress.
                 return;
             }
@@ -644,7 +662,7 @@ public class EthernetNetworkFactory {
                 // possible that link disappeared in the meantime. In that
                 // case, stop() has already been called and IpClient should not
                 // get restarted to prevent a provisioning failure loop.
-                Log.i(TAG, String.format("maybeRestart() called on stopped interface %s", name));
+                Log.i(TAG, String.format("maybeRestart() called on stopped interface %s", mPort));
                 return;
             }
             if (DBG) Log.d(TAG, "restart IpClient");
@@ -655,9 +673,8 @@ public class EthernetNetworkFactory {
         @Override
         public String toString() {
             return getClass().getSimpleName() + "{ "
-                    + "iface: " + name + ", "
+                    + "port: " + mPort + ", "
                     + "up: " + mLinkUp + ", "
-                    + "hwAddress: " + mHwAddress + ", "
                     + "networkCapabilities: " + mCapabilities + ", "
                     + "networkAgent: " + mNetworkAgent + ", "
                     + "ipClient: " + mIpClient + ","
diff --git a/service-t/src/com/android/server/ethernet/EthernetPort.java b/service-t/src/com/android/server/ethernet/EthernetPort.java
new file mode 100644
index 0000000000..b9d9961dd7
--- /dev/null
+++ b/service-t/src/com/android/server/ethernet/EthernetPort.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ethernet;
+
+import android.annotation.Nullable;
+import android.net.MacAddress;
+import android.text.TextUtils;
+
+import java.util.Objects;
+
+/**
+ * A class representing an ethernet port. This class is used as an internal class to track existing
+ * ethernet interfaces managed by EthernetTracker.
+ */
+public class EthernetPort {
+    private final String mInterfaceName;
+
+    private final MacAddress mMacAddress;
+
+    private final int mInterfaceIndex;
+
+    /**
+     * Creates an EthernetPort for the given interface name, MAC address and index.
+     */
+    public EthernetPort(String interfaceName, MacAddress macAddress, int index) {
+        if (TextUtils.isEmpty(interfaceName) || macAddress == null || index <= 0) {
+            throw new IllegalArgumentException("Ethernet port should have valid interface name, "
+                    + "MAC address and interface index.");
+        }
+
+        mInterfaceName = interfaceName;
+        mMacAddress = macAddress;
+        mInterfaceIndex = index;
+    }
+
+    /**
+     * Get the name of the ethernet interface port.
+     */
+    public String getInterfaceName() {
+        return mInterfaceName;
+    }
+
+    /**
+     * Get the MAC address of the ethernet port.
+     */
+    public MacAddress getMacAddress() {
+        return mMacAddress;
+    }
+
+    /**
+     * Get the interface index of the ethernet port.
+     */
+    public int getInterfaceIndex() {
+        return mInterfaceIndex;
+    }
+
+    @Override
+    public String toString() {
+        return "EthernetPort(" + mInterfaceName + ", ifindex=" + mInterfaceIndex
+                + ", MAC=" + mMacAddress + ")";
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(mMacAddress, mInterfaceName, mInterfaceIndex);
+    }
+
+    @Override
+    public boolean equals(@Nullable Object o) {
+        if (o == this) {
+            return true;
+        }
+
+        if (!(o instanceof EthernetPort)) {
+            return false;
+        }
+
+        final EthernetPort other = (EthernetPort) o;
+        return Objects.equals(this.mInterfaceName, other.mInterfaceName)
+                && Objects.equals(this.mMacAddress, other.mMacAddress)
+                && this.mInterfaceIndex == other.mInterfaceIndex;
+    }
+}
diff --git a/service-t/src/com/android/server/ethernet/EthernetServiceImpl.java b/service-t/src/com/android/server/ethernet/EthernetServiceImpl.java
index 21b9b1d850..3126e48afe 100644
--- a/service-t/src/com/android/server/ethernet/EthernetServiceImpl.java
+++ b/service-t/src/com/android/server/ethernet/EthernetServiceImpl.java
@@ -94,7 +94,7 @@ public class EthernetServiceImpl extends IEthernetManager.Stub {
     @Override
     public String[] getAvailableInterfaces() throws RemoteException {
         PermissionUtils.enforceAccessNetworkStatePermission(mContext, TAG);
-        return mTracker.getClientModeInterfaces(hasUseRestrictedNetworksPermission());
+        return mTracker.getClientModeInterfacesSorted(hasUseRestrictedNetworksPermission());
     }
 
     /**
diff --git a/service-t/src/com/android/server/ethernet/EthernetTracker.java b/service-t/src/com/android/server/ethernet/EthernetTracker.java
index c09a94de3a..b772d6f8ec 100644
--- a/service-t/src/com/android/server/ethernet/EthernetTracker.java
+++ b/service-t/src/com/android/server/ethernet/EthernetTracker.java
@@ -26,6 +26,7 @@ import static android.net.TestNetworkManager.TEST_TAP_PREFIX;
 
 import static com.android.internal.annotations.VisibleForTesting.Visibility.PACKAGE;
 import static com.android.net.module.util.netlink.NetlinkConstants.IFF_UP;
+import static com.android.net.module.util.netlink.NetlinkConstants.RTM_GETLINK;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
@@ -39,12 +40,14 @@ import android.net.IpConfiguration;
 import android.net.IpConfiguration.IpAssignment;
 import android.net.IpConfiguration.ProxySettings;
 import android.net.LinkAddress;
+import android.net.MacAddress;
 import android.net.NetworkCapabilities;
 import android.net.StaticIpConfiguration;
 import android.os.ConditionVariable;
 import android.os.Handler;
 import android.os.RemoteCallbackList;
 import android.os.RemoteException;
+import android.system.Os;
 import android.system.OsConstants;
 import android.text.TextUtils;
 import android.util.ArrayMap;
@@ -62,12 +65,15 @@ import com.android.net.module.util.netlink.NetlinkMessage;
 import com.android.net.module.util.netlink.NetlinkUtils;
 import com.android.net.module.util.netlink.RtNetlinkLinkMessage;
 import com.android.net.module.util.netlink.StructIfinfoMsg;
+import com.android.net.module.util.netlink.StructNlMsgHdr;
 import com.android.server.connectivity.ConnectivityResources;
 
 import java.io.FileDescriptor;
 import java.net.InetAddress;
 import java.net.NetworkInterface;
 import java.net.SocketException;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
 import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.Iterator;
@@ -121,7 +127,7 @@ public class EthernetTracker {
 
     /**
      * Interface names we track. This is a product-dependent regular expression.
-     * Use isValidEthernetInterface to check if a interface name is a valid ethernet interface (this
+     * Use shouldTrackInterface to check if a interface name is a valid ethernet interface (this
      * includes test interfaces if setIncludeTestInterfaces is set to true).
      */
     private final String mIfaceMatch;
@@ -143,7 +149,7 @@ public class EthernetTracker {
     private final Handler mHandler;
     private final EthernetNetworkFactory mFactory;
     private final EthernetConfigStore mConfigStore;
-    private final NetlinkMonitor mNetlinkMonitor;
+    private final EthernetNetlinkMonitor mNetlinkMonitor;
     private final Dependencies mDeps;
 
     private final RemoteCallbackList<IEthernetServiceListener> mListeners =
@@ -154,7 +160,7 @@ public class EthernetTracker {
     // The first interface discovered is set as the mTetheringInterface. It is the interface that is
     // returned when a tethered interface is requested; until then, it remains in client mode. Its
     // current mode is reflected in mTetheringInterfaceMode.
-    private String mTetheringInterface;
+    private EthernetPort mTetheringInterface;
     // If the tethering interface is in server mode, it is not tracked by factory. The HW address
     // must be maintained by the EthernetTracker. Its current mode is reflected in
     // mTetheringInterfaceMode.
@@ -197,18 +203,42 @@ public class EthernetTracker {
                     OsConstants.NETLINK_ROUTE, NetlinkConstants.RTMGRP_LINK);
         }
 
-        private void onNewLink(String ifname, boolean linkUp) {
+        /** Request RTM_GETLINK dump. Resulting callbacks are handled by #processNetlinkMessage. */
+        public void requestLinkDump() {
+            // TODO(b/422484024): Clean up NetlinkMessage classes and add support for building a
+            // generic GETLINK message.
+            // Allocate enough space for struct nlmsghdr + struct rtgenmsg
+            final ByteBuffer buf = ByteBuffer.allocate(StructNlMsgHdr.STRUCT_SIZE + 1);
+            buf.order(ByteOrder.nativeOrder());
+
+            final StructNlMsgHdr nlmsghdr = new StructNlMsgHdr();
+            nlmsghdr.nlmsg_len = buf.capacity();
+            nlmsghdr.nlmsg_type = RTM_GETLINK;
+            nlmsghdr.nlmsg_flags = StructNlMsgHdr.NLM_F_DUMP | StructNlMsgHdr.NLM_F_REQUEST;
+            nlmsghdr.pack(buf);
+
+            // struct rtgenmsg {
+            //   unsigned char rtgen_family;
+            // }
+            buf.put((byte) OsConstants.AF_UNSPEC);
+            buf.flip();
+
+            sendNetlinkMessage(buf);
+        }
+
+        private void onNewLink(EthernetPort port, boolean linkUp) {
+            final String ifname = port.getInterfaceName();
             if (!mFactory.hasInterface(ifname) && !ifname.equals(mTetheringInterface)) {
-                Log.i(TAG, "onInterfaceAdded, iface: " + ifname);
-                maybeTrackInterface(ifname);
+                Log.i(TAG, "onInterfaceAdded: " + port);
+                maybeTrackInterface(port);
             }
-            Log.i(TAG, "interfaceLinkStateChanged, iface: " + ifname + ", up: " + linkUp);
-            updateInterfaceState(ifname, linkUp);
+            Log.i(TAG, "interfaceLinkStateChanged: " + port + ", up: " + linkUp);
+            updateInterfaceState(port, linkUp);
         }
 
-        private void onDelLink(String ifname) {
-            Log.i(TAG, "onInterfaceRemoved, iface: " + ifname);
-            stopTrackingInterface(ifname);
+        private void onDelLink(EthernetPort port) {
+            Log.i(TAG, "onInterfaceRemoved: " + port);
+            stopTrackingInterface(port);
         }
 
         private void processRtNetlinkLinkMessage(RtNetlinkLinkMessage msg) {
@@ -219,18 +249,24 @@ public class EthernetTracker {
             // ignore messages for the loopback interface
             if ((ifinfomsg.flags & OsConstants.IFF_LOOPBACK) != 0) return;
 
-            // check if the received message applies to an ethernet interface.
+            // rtnl_fill_ifinfo sets IFLA_ADDRESS when there is one. This should always be true for
+            // all ethernet interfaces.
+            final MacAddress mac = msg.getHardwareAddress();
+            if (mac == null) return;
+
             final String ifname = msg.getInterfaceName();
-            if (!isValidEthernetInterface(ifname)) return;
+            final EthernetPort port = new EthernetPort(ifname, mac, ifinfomsg.index);
+            // check if the received message applies to an ethernet interface.
+            if (!shouldTrackInterface(port.getInterfaceName())) return;
 
             switch (msg.getHeader().nlmsg_type) {
                 case NetlinkConstants.RTM_NEWLINK:
                     final boolean linkUp = (ifinfomsg.flags & NetlinkConstants.IFF_LOWER_UP) != 0;
-                    onNewLink(ifname, linkUp);
+                    onNewLink(port, linkUp);
                     break;
 
                 case NetlinkConstants.RTM_DELLINK:
-                    onDelLink(ifname);
+                    onDelLink(port);
                     break;
 
                 default:
@@ -301,7 +337,7 @@ public class EthernetTracker {
 
         mHandler.post(() -> {
             mNetlinkMonitor.start();
-            trackAvailableInterfaces();
+            mNetlinkMonitor.requestLinkDump();
         });
     }
 
@@ -421,18 +457,17 @@ public class EthernetTracker {
         return mFactory.hasInterface(iface);
     }
 
-    private List<String> getAllInterfaces() {
-        final ArrayList<String> interfaces = new ArrayList<>(
-                List.of(mFactory.getAvailableInterfaces(/* includeRestricted */ true)));
-
+    /** Returns an unordered(!) list of tracked EthernetPort objects. */
+    private List<EthernetPort> getAllInterfaces() {
+        final List<EthernetPort> interfaces = new ArrayList<>(mFactory.getEthernetPorts());
         if (mTetheringInterfaceMode == INTERFACE_MODE_SERVER && mTetheringInterface != null) {
             interfaces.add(mTetheringInterface);
         }
         return interfaces;
     }
 
-    String[] getClientModeInterfaces(boolean includeRestricted) {
-        return mFactory.getAvailableInterfaces(includeRestricted);
+    String[] getClientModeInterfacesSorted(boolean includeRestricted) {
+        return mFactory.getInterfacesSorted(includeRestricted);
     }
 
     List<String> getEthernetInterfaceList() {
@@ -446,7 +481,7 @@ public class EthernetTracker {
         }
 
         // There is a possible race with setIncludeTestInterfaces() which can affect
-        // isValidEthernetInterface (it returns true for test interfaces if setIncludeTestInterfaces
+        // shouldTrackInterface (it returns true for test interfaces if setIncludeTestInterfaces
         // is set to true).
         // setIncludeTestInterfaces() is only used in tests, and since getEthernetInterfaceList()
         // does not run on the handler thread, the behavior around setIncludeTestInterfaces() is
@@ -455,7 +490,7 @@ public class EthernetTracker {
         // In production code, this has no effect.
         while (ifaces.hasMoreElements()) {
             NetworkInterface iface = ifaces.nextElement();
-            if (isValidEthernetInterface(iface.getName())) interfaceList.add(iface.getName());
+            if (shouldTrackInterface(iface.getName())) interfaceList.add(iface.getName());
         }
         return interfaceList;
     }
@@ -475,11 +510,11 @@ public class EthernetTracker {
                 // Remote process has already died
                 return;
             }
-            for (String iface : getClientModeInterfaces(canUseRestrictedNetworks)) {
+            for (String iface : getClientModeInterfacesSorted(canUseRestrictedNetworks)) {
                 unicastInterfaceStateChange(listener, iface);
             }
             if (mTetheringInterface != null && mTetheringInterfaceMode == INTERFACE_MODE_SERVER) {
-                unicastInterfaceStateChange(listener, mTetheringInterface);
+                unicastInterfaceStateChange(listener, mTetheringInterface.getInterfaceName());
             }
 
             unicastEthernetStateChange(listener, mIsEthernetEnabled);
@@ -494,13 +529,14 @@ public class EthernetTracker {
         mHandler.post(() -> {
             mIncludeTestInterfaces = include;
             if (include) {
-                trackAvailableInterfaces();
+                mNetlinkMonitor.requestLinkDump();
             } else {
                 removeTestData();
                 // remove all test interfaces
-                for (String iface : getAllInterfaces()) {
-                    if (isValidEthernetInterface(iface)) continue;
-                    stopTrackingInterface(iface);
+                for (EthernetPort port : getAllInterfaces()) {
+                    final String iface = port.getInterfaceName();
+                    if (shouldTrackInterface(iface)) continue;
+                    stopTrackingInterface(port);
                 }
             }
         });
@@ -526,16 +562,14 @@ public class EthernetTracker {
         mNetworkCapabilities.keySet().removeIf(iface -> iface.matches(TEST_IFACE_REGEXP));
     }
 
-    public void requestTetheredInterface(ITetheredInterfaceCallback callback) {
+    public void requestTetheredInterface(ITetheredInterfaceCallback cb) {
         mHandler.post(() -> {
-            if (!mTetheredInterfaceRequests.register(callback)) {
+            if (!mTetheredInterfaceRequests.register(cb)) {
                 // Remote process has already died
                 return;
             }
-            if (mTetheringInterfaceMode == INTERFACE_MODE_SERVER) {
-                if (mTetheredInterfaceWasAvailable) {
-                    notifyTetheredInterfaceAvailable(callback, mTetheringInterface);
-                }
+            if (mTetheringInterfaceMode == INTERFACE_MODE_SERVER && mTetheringInterface != null) {
+                notifyTetheredInterfaceAvailable(cb, mTetheringInterface.getInterfaceName());
                 return;
             }
 
@@ -580,7 +614,7 @@ public class EthernetTracker {
             addInterface(mTetheringInterface);
             // when this broadcast is sent, any calls to notifyTetheredInterfaceAvailable or
             // notifyTetheredInterfaceUnavailable have already happened
-            broadcastInterfaceStateChange(mTetheringInterface);
+            broadcastInterfaceStateChange(mTetheringInterface.getInterfaceName());
         }
     }
 
@@ -609,47 +643,48 @@ public class EthernetTracker {
     }
 
     private int getInterfaceMode(final String iface) {
-        if (iface.equals(mTetheringInterface)) {
+        if (mTetheringInterface != null && iface.equals(mTetheringInterface.getInterfaceName())) {
             return mTetheringInterfaceMode;
         }
         return INTERFACE_MODE_CLIENT;
     }
 
-    private void removeInterface(String iface) {
-        mFactory.removeInterface(iface);
-        maybeUpdateServerModeInterfaceState(iface, false);
+    private void removeInterface(EthernetPort port) {
+        mFactory.removeInterface(port);
+        maybeUpdateServerModeInterfaceState(port.getInterfaceName(), false);
     }
 
-    private void stopTrackingInterface(String iface) {
-        removeInterface(iface);
-        if (iface.equals(mTetheringInterface)) {
+    private void stopTrackingInterface(EthernetPort port) {
+        removeInterface(port);
+        final String iface = port.getInterfaceName();
+        if (mTetheringInterface != null && iface.equals(mTetheringInterface.getInterfaceName())) {
             mTetheringInterface = null;
             mTetheringInterfaceHwAddr = null;
         }
         broadcastInterfaceStateChange(iface);
     }
 
-    private void addInterface(String iface) {
-        InterfaceConfigurationParcel config = null;
+    private void addInterface(EthernetPort port) {
+        final String iface = port.getInterfaceName();
+        final InterfaceConfigurationParcel config;
         // Bring up the interface so we get link status indications.
         try {
             // Read the flags before attempting to bring up the interface. If the interface is
             // already running an UP event is created after adding the interface.
             config = NetdUtils.getInterfaceConfigParcel(mNetd, iface);
-            // Only bring the interface up when ethernet is enabled, otherwise set interface down.
-            setInterfaceUpState(iface, mIsEthernetEnabled);
         } catch (IllegalStateException e) {
-            // Either the system is crashing or the interface has disappeared. Just ignore the
-            // error; we haven't modified any state because we only do that if our calls succeed.
-            Log.e(TAG, "Error upping interface " + iface, e);
+            Log.e(TAG, "Failed to addInterface(" + iface + "). getInterfaceConfigParcel failed", e);
+            return;
         }
-
         if (config == null) {
             Log.e(TAG, "Null interface config parcelable for " + iface + ". Bailing out.");
             return;
         }
 
-        final String hwAddress = config.hwAddr;
+        // Only bring the interface up when ethernet is enabled, otherwise set interface down.
+        setInterfaceUpState(iface, mIsEthernetEnabled);
+
+        final String hwAddress = port.getMacAddress().toString();
 
         if (getInterfaceMode(iface) == INTERFACE_MODE_SERVER) {
             maybeUpdateServerModeInterfaceState(iface, true);
@@ -669,7 +704,7 @@ public class EthernetTracker {
 
         IpConfiguration ipConfiguration = getOrCreateIpConfiguration(iface);
         Log.d(TAG, "Tracking interface in client mode: " + iface);
-        mFactory.addInterface(iface, hwAddress, ipConfiguration, nc);
+        mFactory.addInterface(port, ipConfiguration, nc);
 
         // Note: if the interface already has link (e.g., if we crashed and got
         // restarted while it was running), we need to fake a link up notification so we
@@ -678,7 +713,7 @@ public class EthernetTracker {
             // no need to send an interface state change as this is not a true "state change". The
             // callers (maybeTrackInterface() and setTetheringInterfaceMode()) already broadcast the
             // state change.
-            mFactory.updateInterfaceLinkState(iface, true);
+            mFactory.updateInterfaceLinkState(port, true);
         }
     }
 
@@ -701,7 +736,8 @@ public class EthernetTracker {
         cb.onResult(iface);
     }
 
-    private void updateInterfaceState(String iface, boolean up) {
+    private void updateInterfaceState(EthernetPort port, boolean up) {
+        final String iface = port.getInterfaceName();
         final int mode = getInterfaceMode(iface);
         if (mode == INTERFACE_MODE_SERVER) {
             // TODO: support tracking link state for interfaces in server mode.
@@ -709,15 +745,15 @@ public class EthernetTracker {
         }
 
         // If updateInterfaceLinkState returns false, the interface is already in the correct state.
-        if (mFactory.updateInterfaceLinkState(iface, up)) {
+        if (mFactory.updateInterfaceLinkState(port, up)) {
             broadcastInterfaceStateChange(iface);
         }
     }
 
     private void maybeUpdateServerModeInterfaceState(String iface, boolean available) {
-        if (available == mTetheredInterfaceWasAvailable || !iface.equals(mTetheringInterface)) {
-            return;
-        }
+        if (mTetheringInterface == null) return;
+        if (!iface.equals(mTetheringInterface.getInterfaceName())) return;
+        if (available == mTetheredInterfaceWasAvailable) return;
 
         Log.d(TAG, (available ? "Tracking" : "No longer tracking")
                 + " interface in server mode: " + iface);
@@ -735,32 +771,26 @@ public class EthernetTracker {
         mTetheredInterfaceWasAvailable = available;
     }
 
-    private void maybeTrackInterface(String iface) {
+    private void maybeTrackInterface(EthernetPort port) {
+        final String iface = port.getInterfaceName();
         // If we don't already track this interface, and if this interface matches
         // our regex, start tracking it.
-        if (mFactory.hasInterface(iface) || iface.equals(mTetheringInterface)) {
-            if (DBG) Log.w(TAG, "Ignoring already-tracked interface " + iface);
+        if (mFactory.hasInterface(iface) || (getInterfaceMode(iface) == INTERFACE_MODE_SERVER)) {
+            if (DBG) Log.w(TAG, "Ignoring already-tracked " + port);
             return;
         }
-        if (DBG) Log.i(TAG, "maybeTrackInterface: " + iface);
+        if (DBG) Log.i(TAG, "maybeTrackInterface: " + port);
 
         // Do not use an interface for tethering if it has configured NetworkCapabilities.
         if (mTetheringInterface == null && !mNetworkCapabilities.containsKey(iface)) {
-            mTetheringInterface = iface;
+            mTetheringInterface = port;
         }
 
-        addInterface(iface);
+        addInterface(port);
 
         broadcastInterfaceStateChange(iface);
     }
 
-    private void trackAvailableInterfaces() {
-        final List<String> ifaces = getEthernetInterfaceList();
-        for (String iface : ifaces) {
-            maybeTrackInterface(iface);
-        }
-    }
-
     private static class ListenerInfo {
 
         boolean canUseRestrictedNetworks = false;
@@ -782,8 +812,7 @@ public class EthernetTracker {
         mNetworkCapabilities.put(config.mIface, config.mCaps);
 
         if (null != config.mIpConfig) {
-            IpConfiguration ipConfig = parseStaticIpConfiguration(config.mIpConfig);
-            mIpConfigurations.put(config.mIface, ipConfig);
+            mIpConfigurations.put(config.mIface, config.mIpConfig);
         }
     }
 
@@ -792,69 +821,11 @@ public class EthernetTracker {
                 new NetworkCapabilities.Builder(DEFAULT_CAPABILITIES);
         if (isTestIface) {
             builder.addTransportType(NetworkCapabilities.TRANSPORT_TEST);
-            // TODO: do not remove INTERNET capability for test networks.
-            builder.removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET);
         }
 
         return builder.build();
     }
 
-    /**
-     * Parses static IP configuration.
-     *
-     * @param staticIpConfig represents static IP configuration in the following format: {@code
-     * ip=<ip-address/mask> gateway=<ip-address> dns=<comma-sep-ip-addresses>
-     *     domains=<comma-sep-domains>}
-     */
-    @VisibleForTesting
-    static IpConfiguration parseStaticIpConfiguration(String staticIpConfig) {
-        final StaticIpConfiguration.Builder staticIpConfigBuilder =
-                new StaticIpConfiguration.Builder();
-
-        for (String keyValueAsString : staticIpConfig.trim().split(" ")) {
-            if (TextUtils.isEmpty(keyValueAsString)) continue;
-
-            String[] pair = keyValueAsString.split("=");
-            if (pair.length != 2) {
-                throw new IllegalArgumentException("Unexpected token: " + keyValueAsString
-                        + " in " + staticIpConfig);
-            }
-
-            String key = pair[0];
-            String value = pair[1];
-
-            switch (key) {
-                case "ip":
-                    staticIpConfigBuilder.setIpAddress(new LinkAddress(value));
-                    break;
-                case "domains":
-                    staticIpConfigBuilder.setDomains(value);
-                    break;
-                case "gateway":
-                    staticIpConfigBuilder.setGateway(InetAddress.parseNumericAddress(value));
-                    break;
-                case "dns": {
-                    ArrayList<InetAddress> dnsAddresses = new ArrayList<>();
-                    for (String address: value.split(",")) {
-                        dnsAddresses.add(InetAddress.parseNumericAddress(address));
-                    }
-                    staticIpConfigBuilder.setDnsServers(dnsAddresses);
-                    break;
-                }
-                default : {
-                    throw new IllegalArgumentException("Unexpected key: " + key
-                            + " in " + staticIpConfig);
-                }
-            }
-        }
-        return createIpConfiguration(staticIpConfigBuilder.build());
-    }
-
-    private static IpConfiguration createIpConfiguration(
-            @NonNull final StaticIpConfiguration staticIpConfig) {
-        return new IpConfiguration.Builder().setStaticIpConfiguration(staticIpConfig).build();
-    }
-
     private IpConfiguration getOrCreateIpConfiguration(String iface) {
         IpConfiguration ret = mIpConfigurations.get(iface);
         if (ret != null) return ret;
@@ -864,7 +835,7 @@ public class EthernetTracker {
         return ret;
     }
 
-    private boolean isValidEthernetInterface(String iface) {
+    private boolean shouldTrackInterface(String iface) {
         return iface.matches(mIfaceMatch) || isValidTestInterface(iface);
     }
 
@@ -895,8 +866,8 @@ public class EthernetTracker {
             if (mIsEthernetEnabled == enabled) return;
 
             mIsEthernetEnabled = enabled;
-            for (String iface : getAllInterfaces()) {
-                setInterfaceUpState(iface, enabled);
+            for (EthernetPort port : getAllInterfaces()) {
+                setInterfaceUpState(port.getInterfaceName(), enabled);
             }
             broadcastEthernetStateChange(mIsEthernetEnabled);
         });
@@ -931,7 +902,8 @@ public class EthernetTracker {
     }
 
     private void setInterfaceUpState(@NonNull String interfaceName, boolean up) {
-        if (!NetlinkUtils.setInterfaceFlags(interfaceName, up ? IFF_UP : ~IFF_UP)) {
+        if (!NetlinkUtils.setInterfaceFlags(Os.if_nametoindex(interfaceName),
+                up ? IFF_UP : ~IFF_UP)) {
             Log.e(TAG, "Failed to set interface " + interfaceName + (up ? " up" : " down"));
         }
     }
@@ -971,7 +943,7 @@ public class EthernetTracker {
     static class EthernetConfigParser {
         final String mIface;
         final NetworkCapabilities mCaps;
-        final String mIpConfig;
+        @Nullable final IpConfiguration mIpConfig;
 
         private static NetworkCapabilities parseCapabilities(@Nullable String capabilitiesString,
                 boolean isAtLeastB) {
@@ -1042,18 +1014,64 @@ public class EthernetTracker {
             }
         }
 
-        EthernetConfigParser(String configString, boolean isAtLeastB) {
+        @Nullable
+        private static IpConfiguration parseStaticIpConfiguration(String staticIpConfig) {
+            if (TextUtils.isEmpty(staticIpConfig)) return null;
+
+            final StaticIpConfiguration.Builder staticIpConfigBuilder =
+                    new StaticIpConfiguration.Builder();
+
+            for (String keyValueAsString : staticIpConfig.trim().split(" ")) {
+                if (TextUtils.isEmpty(keyValueAsString)) continue;
+
+                final String[] pair = keyValueAsString.split("=");
+                if (pair.length != 2) {
+                    throw new IllegalArgumentException("Unexpected token: " + keyValueAsString
+                            + " in " + staticIpConfig);
+                }
+
+                final String key = pair[0];
+                final String value = pair[1];
+                switch (key) {
+                    case "ip":
+                        staticIpConfigBuilder.setIpAddress(new LinkAddress(value));
+                        break;
+                    case "domains":
+                        staticIpConfigBuilder.setDomains(value);
+                        break;
+                    case "gateway":
+                        staticIpConfigBuilder.setGateway(InetAddress.parseNumericAddress(value));
+                        break;
+                    case "dns": {
+                        ArrayList<InetAddress> dnsAddresses = new ArrayList<>();
+                        for (String address: value.split(",")) {
+                            dnsAddresses.add(InetAddress.parseNumericAddress(address));
+                        }
+                        staticIpConfigBuilder.setDnsServers(dnsAddresses);
+                        break;
+                    }
+                    default: {
+                        throw new IllegalArgumentException("Unexpected key: " + key
+                                + " in " + staticIpConfig);
+                    }
+                }
+            }
+            return new IpConfiguration.Builder()
+                    .setStaticIpConfiguration(staticIpConfigBuilder.build())
+                    .build();
+        }
+
+        EthernetConfigParser(String configString, boolean bplus) {
             Objects.requireNonNull(configString, "EthernetConfigParser requires non-null config");
-            final String[] tokens = configString.split(";", /* limit of tokens */ 4);
-            mIface = tokens[0];
+            final String[] t = configString.split(";", /* limit of tokens */ 4);
+            mIface = t[0];
 
-            final NetworkCapabilities nc =
-                    parseCapabilities(tokens.length > 1 ? tokens[1] : null, isAtLeastB);
-            final int transportType = parseTransportType(tokens.length > 3 ? tokens[3] : null);
+            final NetworkCapabilities nc = parseCapabilities(t.length > 1 ? t[1] : null, bplus);
+            final int transportType = parseTransportType(t.length > 3 ? t[3] : null);
             nc.addTransportType(transportType);
             mCaps = nc;
 
-            mIpConfig = tokens.length > 2 && !TextUtils.isEmpty(tokens[2]) ? tokens[2] : null;
+            mIpConfig = parseStaticIpConfiguration(t.length > 2 ? t[2] : null);
         }
     }
 }
diff --git a/service-t/src/com/android/server/net/NetworkStatsFactory.java b/service-t/src/com/android/server/net/NetworkStatsFactory.java
index c5a69c0551..7d48b71d75 100644
--- a/service-t/src/com/android/server/net/NetworkStatsFactory.java
+++ b/service-t/src/com/android/server/net/NetworkStatsFactory.java
@@ -252,8 +252,6 @@ public class NetworkStatsFactory {
         synchronized (mPersistentDataLock) {
             // Take a reference. If this gets swapped out, we still have the old reference.
             final UnderlyingNetworkInfo[] vpnArray = mUnderlyingNetworkInfos;
-            // Take a defensive copy. mPersistSnapshot is mutated in some cases below
-            final NetworkStats prev = mPersistSnapshot.clone();
 
             requestSwapActiveStatsMapLocked();
             // Stats are always read from the inactive map, so they must be read after the
@@ -266,11 +264,27 @@ public class NetworkStatsFactory {
             mPersistSnapshot.setElapsedRealtime(diff.getElapsedRealtime());
             mPersistSnapshot.combineAllValues(filteredDiff);
 
-            NetworkStats adjustedStats = adjustForTunAnd464Xlat(mPersistSnapshot, prev, vpnArray);
+            // Update the stats adjusted for TunAnd464Xlat
+            // Apply 464xlat adjustments before VPN adjustments. If VPNs are using v4 on a v6 only
+            // network, the overhead is their fault.
+            // No locking here: apply464xlatAdjustments behaves fine with an add-only
+            // ConcurrentHashMap.
+            filteredDiff.apply464xlatAdjustments(mStackedIfaces);
+
+            // Migrate data usage over a VPN to the TUN network.
+            for (UnderlyingNetworkInfo info : vpnArray) {
+                filteredDiff.migrateTun(info.getOwnerUid(), info.getInterface(),
+                        info.getUnderlyingInterfaces());
+                // Filter out debug entries as that may lead to over counting.
+                filteredDiff.filterDebugEntries();
+            }
+
+            // Update mTunAnd464xlatAdjustedStats with migrated stats.
+            mTunAnd464xlatAdjustedStats.combineAllValues(filteredDiff);
+            mTunAnd464xlatAdjustedStats.setElapsedRealtime(filteredDiff.getElapsedRealtime());
 
             // Filter return values
-            adjustedStats.filter(limitUid, limitIfaces, limitTag);
-            return adjustedStats;
+            return mTunAnd464xlatAdjustedStats.filteredClone(limitUid, limitIfaces, limitTag);
         }
     }
 
@@ -309,33 +323,6 @@ public class NetworkStatsFactory {
         return filteredStats;
     }
 
-    @GuardedBy("mPersistentDataLock")
-    private NetworkStats adjustForTunAnd464Xlat(NetworkStats uidDetailStats,
-            NetworkStats previousStats, UnderlyingNetworkInfo[] vpnArray) {
-        // Calculate delta from last snapshot
-        final NetworkStats delta = uidDetailStats.subtract(previousStats);
-
-        // Apply 464xlat adjustments before VPN adjustments. If VPNs are using v4 on a v6 only
-        // network, the overhead is their fault.
-        // No locking here: apply464xlatAdjustments behaves fine with an add-only
-        // ConcurrentHashMap.
-        delta.apply464xlatAdjustments(mStackedIfaces);
-
-        // Migrate data usage over a VPN to the TUN network.
-        for (UnderlyingNetworkInfo info : vpnArray) {
-            delta.migrateTun(info.getOwnerUid(), info.getInterface(),
-                    info.getUnderlyingInterfaces());
-            // Filter out debug entries as that may lead to over counting.
-            delta.filterDebugEntries();
-        }
-
-        // Update mTunAnd464xlatAdjustedStats with migrated delta.
-        mTunAnd464xlatAdjustedStats.combineAllValues(delta);
-        mTunAnd464xlatAdjustedStats.setElapsedRealtime(uidDetailStats.getElapsedRealtime());
-
-        return mTunAnd464xlatAdjustedStats.clone();
-    }
-
     /**
      * Remove stats from {@code mPersistSnapshot} and {@code mTunAnd464xlatAdjustedStats} for the
      * given uids.
diff --git a/service-t/src/com/android/server/net/NetworkStatsService.java b/service-t/src/com/android/server/net/NetworkStatsService.java
index 75d30a91e6..01ff34d8b4 100644
--- a/service-t/src/com/android/server/net/NetworkStatsService.java
+++ b/service-t/src/com/android/server/net/NetworkStatsService.java
@@ -994,7 +994,7 @@ public class NetworkStatsService extends INetworkStatsService.Stub {
                 @NonNull Context ctx) {
             final TrafficStatsRateLimitCacheConfig config =
                     new TrafficStatsRateLimitCacheConfig.Builder()
-                            .setIsCacheEnabled(DeviceConfigUtils.isTetheringFeatureEnabled(
+                            .setIsCacheEnabled(DeviceConfigUtils.isTetheringFeatureNotChickenedOut(
                                     ctx, TRAFFICSTATS_CLIENT_RATE_LIMIT_CACHE_ENABLED_FLAG))
                             .setExpiryDurationMs(getDeviceConfigPropertyInt(
                                     NAMESPACE_TETHERING, TRAFFIC_STATS_CACHE_EXPIRY_DURATION_NAME,
diff --git a/service/Android.bp b/service/Android.bp
index 8b469e4e69..fb74238caf 100644
--- a/service/Android.bp
+++ b/service/Android.bp
@@ -164,6 +164,7 @@ java_library {
         "framework-bluetooth.stubs.module_lib",
         "framework-configinfrastructure.stubs.module_lib",
         "framework-connectivity-pre-jarjar",
+        "framework-connectivity-t-pre-jarjar",
         // The framework-connectivity-t library is only available on T+ platforms
         // so any calls to it must be protected with a check to ensure that it is
         // available. The linter will detect any unprotected calls through an API
@@ -186,6 +187,7 @@ java_library {
     static_libs: [
         // Do not add libs here if they are already included
         // in framework-connectivity
+        "android.net.platform.flags-aconfig-java-export",
         "androidx.annotation_annotation",
         "connectivity-net-module-utils-bpf",
         "connectivity_native_aidl_interface-lateststable-java",
diff --git a/service/ServiceConnectivityResources/res/raw/ct_public_keys.pem b/service/ServiceConnectivityResources/res/raw/ct_public_keys.pem
index 8a5ebbfa46..50c3802737 100644
--- a/service/ServiceConnectivityResources/res/raw/ct_public_keys.pem
+++ b/service/ServiceConnectivityResources/res/raw/ct_public_keys.pem
@@ -41,6 +41,20 @@ clFF7Y1FiI259IPhTKiOIfARJ4BL4Sn8D9c9vpxDYPFl5bCJbspmFpwfzTMDnGVS
 /IlY6Putpv2/lD1B7aQGt1sCAwEAAQ==
 -----END PUBLIC KEY-----
 -----BEGIN PUBLIC KEY-----
+MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAps78mZHoVEvY3VlBZ1b8
+X8Fo9k6wtpu+hUqccXGiYnCYQYKd82fMfmfn8B2pSo9kHo2KEQDAqoCITGkgwMio
+cQ4zWS7+catfv+0rqs6S1qxoz0RI/RIhd1ka16Xab2+756FVZLI+KqBqW3Ir7SAJ
+hClV2yU+IvwPFIXJHWCy0eS3KMFMiCK8ReTjwX8+HXtBdBbzg4WM2+NGuupTvlwj
+mGg31yxBvF3Vc6+3MnpEOL5xa9h8pDpXWBvvIXv6gYpq1S7+GB7HGIm2ndIdZOFl
+twl4DuBnMuRYy3WqQlkzXxNMRW1+fZjnCBWBNMhzCfhtNImn2sNXzTCoT1aHsulA
+avi4/5V2g+8IyP3sRAiyJz3CEkHzruXRxQN7zqtZJqU0+BRf7KYTOvkR5b/uwY3V
+D1i6ct02eEJBsEpC4TPB+BXlC0Lp6nOK8scfGoYbQ49E7ti3azBpk7xoVz9SLYYM
+bSCdx4c3VSprE/BW9kTLheZmclHIneFalIRRuT5LRVlrJchR3PhlmLv/q4RnsUFn
+HIjf3M7UqF9LyY+lO3CI2Zd35qqYfFdazZveHzCNq24FFWfgWGJqWmLTBV7rQebM
+rp3dbI3EbrlhKzVUHTrHLQ7QAVsbAibcPgGfCjGXrIWsLaX63Kfmb6how6YQ9lWY
+tb2vW00woqD2sMPCiGrqjOkCAwEAAQ==
+-----END PUBLIC KEY-----
+-----BEGIN PUBLIC KEY-----
 MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAwMPNecDhLDamK9Rs8W5V
 c0LWZPbk9FNP+budBoFMX46dWyJ75O5e8xY9UhJSBFl8+Itm/rWO/h2zZ6qE3Cq8
 1LYbOg+x+rLnYOcAvD2O7EU73A3RD/vqoUDDVK3cwKMq3ry7CYu+NJW7TRIKV7Ct
@@ -54,3 +68,17 @@ hkTFodvF5ajCQ5maHeIjDkS/Bc/s9CB+/fbSkstDsPMRp/ExyQcEYjKTG5o9Ewyo
 +KGGXS2dSS10Ibl0Zx/S/0ZuZx8ZAxMOIIPpugdkWqHU9thh71dR8zM4KMkEfB8C
 sWLGB1yMuztn9nRUcpiEZTECAwEAAQ==
 -----END PUBLIC KEY-----
+-----BEGIN PUBLIC KEY-----
+MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAwucG90WrpdFHXkJscOBx
+qRMcwfFv8V0+EwTkCK8vIL0t1zRcQNhHD4/vFPxSZoCLMWLy8L0MOI9XWaiKU5Ja
+3bgCk2C1ztzjxUd/CtgDV0T1Cp8Bm+3VUEWaijqRiRhtxlLBqR+b6mng8WnRCyj/
+8bWElFUcdxNOMj1SAtokd9lYsw+XMBZ5G6ajbk7V4Bsh6jSjzdg/Cw8YTVjsWv3V
+M4fkHm9DZJxZEhuXAnuVhbxt3sdNO1cwECk54+lOo4+SH7AN35MdGZnLXWbhku9t
+YtCKMnFvYyKALYakWaHXSTZqi+aoUxU660oEBuDSVXPTKf8GMi/2CWAJE9QYNveV
+M5ws7LXRMssvMkBMN8LX+pQDo34i2d1hZDCfOHnfU2HOeSAzLoiSZSWUZ0ugv+nM
+1mL1zUSxjDmZfQnv8g4L8AuHHQd3wihY0nRjfQUgR/z3efI9fAA3OCEtD7m7byKd
+QsRphXykzPS1O6VuSmm2LyUH2CX5LnQzLhThiwTuoitI0zNotQYRf2B/6pKtpiCs
+Knhj05nsjyuTTIZsSkGrmYLmjU0iKW9GFOy9qGrd4+l222VnZ3tPCKZa57+EehNn
+Tje/6yTk5yCVprVzUzFxFbihRP80X3dgUSkToIWUeeuY76JebbvXJ1z64On77IK0
+eW5XLa/a7tGKzi46iihOp3MCAwEAAQ==
+-----END PUBLIC KEY-----
diff --git a/service/src/com/android/metrics/DefaultNetworkRematchMetrics.java b/service/src/com/android/metrics/DefaultNetworkRematchMetrics.java
new file mode 100644
index 0000000000..cced96c3c5
--- /dev/null
+++ b/service/src/com/android/metrics/DefaultNetworkRematchMetrics.java
@@ -0,0 +1,210 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.metrics;
+
+import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED;
+import static android.net.NetworkCapabilities.NET_CAPABILITY_TEMPORARILY_NOT_METERED;
+import static android.net.NetworkCapabilities.TRANSPORT_SATELLITE;
+import static android.stats.connectivity.MeteredState.METERED_NO;
+import static android.stats.connectivity.MeteredState.METERED_TEMPORARILY_UNMETERED;
+import static android.stats.connectivity.MeteredState.METERED_YES;
+
+import static com.android.net.module.util.FrameworkConnectivityStatsLog.DEFAULT_NETWORK_REMATCH;
+import static com.android.server.ConnectivityService.PREFERENCE_ORDER_SATELLITE_FALLBACK;
+import static com.android.server.ConnectivityStatsLog.DEFAULT_NETWORK_REMATCH__REMATCH_REASON__RMR_UNKNOWN;
+
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.net.NetworkCapabilities;
+import android.stats.connectivity.MeteredState;
+import android.stats.connectivity.ValidatedState;
+
+import androidx.annotation.VisibleForTesting;
+
+import com.android.server.ConnectivityService;
+import com.android.server.ConnectivityStatsLog;
+import com.android.server.connectivity.NetworkAgentInfo;
+
+import java.util.Random;
+import java.util.Set;
+
+/**
+ * Collects and reports metrics regarding default network rematch events.
+ *
+ * This class does not provide thread safety and should be only accessed on the same thread.
+ */
+public class DefaultNetworkRematchMetrics {
+    private final Dependencies mDeps;
+    private final DefaultNetworkRematchInfoList.Builder mBuilder =
+            DefaultNetworkRematchInfoList.newBuilder();
+    private final long mSessionId = new Random().nextLong();
+
+    public DefaultNetworkRematchMetrics() {
+        this(new Dependencies());
+    }
+
+    @VisibleForTesting
+    DefaultNetworkRematchMetrics(Dependencies deps) {
+        mDeps = deps;
+    }
+
+    /** Dependency class */
+    public static class Dependencies {
+        /**
+         * Writes a DEFAULT_NETWORK_REMATCH event to ConnectivityStatsLog.
+         */
+        public void writeStats(long sessionId, int rematchReason,
+                @NonNull DefaultNetworkRematchInfoList list) {
+            ConnectivityStatsLog.write(DEFAULT_NETWORK_REMATCH, sessionId, rematchReason,
+                    list.toByteArray());
+        }
+    }
+
+    /**
+     * Adds a default network reassignment event to the list of events to be logged.
+     *
+     * @param nri The NetworkRequestInfo for the default network request.
+     * @param oldNetwork The previous default network.
+     * @param newNetwork The new default network.
+     */
+    public void addEvent(@NonNull ConnectivityService.NetworkRequestInfo nri,
+            @Nullable NetworkAgentInfo oldNetwork,
+            @Nullable NetworkAgentInfo newNetwork,
+            long satisfiedDurationMs) {
+        // TODO: Record event for network other than satellite after figuring out
+        //  how to deal with the amount of data single device reports.
+        // Only logs for satellite multilayer requests.
+        if (nri.getPreferenceOrderForNetd() != PREFERENCE_ORDER_SATELLITE_FALLBACK) {
+            return;
+        }
+        // Only logs when moving away from a satellite network to another network type.
+        if (oldNetwork == null || !oldNetwork.getCapsNoCopy().hasTransport(TRANSPORT_SATELLITE)) {
+            return;
+        }
+        mBuilder.addDefaultNetworkRematchInfo(
+                getDefaultNetworkRematchInfo(nri, oldNetwork, newNetwork, satisfiedDurationMs));
+    }
+
+    /**
+     * Writes the collected events to the stats log and clears the event list, with reason unknown.
+     */
+    public void writeStatsAndClear() {
+        writeStatsAndClear(DEFAULT_NETWORK_REMATCH__REMATCH_REASON__RMR_UNKNOWN);
+    }
+
+    /**
+     * Writes the collected events to the stats log and clears the event list.
+     */
+    public void writeStatsAndClear(int rematchReason) {
+        if (mBuilder.getDefaultNetworkRematchInfoCount() == 0) return; // Skip.
+        mDeps.writeStats(mSessionId, rematchReason, mBuilder.build());
+        mBuilder.clear();
+    }
+
+    @NonNull
+    private DefaultNetworkRematchInfo getDefaultNetworkRematchInfo(
+            @NonNull ConnectivityService.NetworkRequestInfo nri,
+            @Nullable NetworkAgentInfo oldNetwork, @Nullable NetworkAgentInfo newNetwork,
+            long satisfiedDurationMs) {
+        final DefaultNetworkRematchInfo.Builder infoBuilder =
+                DefaultNetworkRematchInfo.newBuilder();
+        if (oldNetwork != null) {
+            infoBuilder.setOldNetwork(getNetworkDescription(oldNetwork));
+            infoBuilder.setTimeDurationOnOldNetworkSec(
+                    (int) (satisfiedDurationMs / 1000));
+        }
+        if (newNetwork != null) {
+            infoBuilder.setNewNetwork(getNetworkDescription(newNetwork));
+        }
+        infoBuilder.setUidRanges(getUidRangesProto(nri.getUids()));
+        return infoBuilder.build();
+    }
+
+    /**
+     * Creates a NetworkDescription proto from a NetworkAgentInfo.
+     *
+     * @param nai The NetworkAgentInfo to describe.
+     * @return A NetworkDescription proto.
+     */
+    @VisibleForTesting
+    public static NetworkDescription getNetworkDescription(@NonNull final NetworkAgentInfo nai) {
+        final NetworkCapabilities caps = nai.getCapsNoCopy();
+        final NetworkDescription.Builder builder = NetworkDescription.newBuilder();
+        builder.setTransportTypes((int) caps.getTransportTypesInternal());
+        builder.setMeteredState(getMeteredState(caps));
+        builder.setValidatedState(getValidatedState(caps));
+        builder.setScorePolicies(nai.getScore().getPoliciesInternal());
+        builder.setCapabilities(caps.getCapabilitiesInternal());
+        builder.setEnterpriseId(caps.getEnterpriseIdsInternal());
+        return builder.build();
+    }
+
+    /**
+     * Determines the MeteredState from NetworkCapabilities.
+     *
+     * @param caps The NetworkCapabilities of the network.
+     * @return The corresponding MeteredState.
+     */
+    @VisibleForTesting
+    public static MeteredState getMeteredState(@NonNull NetworkCapabilities caps) {
+        if (caps.hasCapability(NET_CAPABILITY_TEMPORARILY_NOT_METERED)) {
+            return METERED_TEMPORARILY_UNMETERED;
+        }
+        if (caps.hasCapability(NET_CAPABILITY_NOT_METERED)) {
+            return METERED_NO;
+        }
+        return METERED_YES;
+    }
+
+    /**
+     * Determines the ValidatedState from NetworkCapabilities.
+     *
+     * @param caps The NetworkCapabilities of the network.
+     * @return The corresponding ValidatedState.
+     */
+    @VisibleForTesting
+    public static ValidatedState getValidatedState(@NonNull NetworkCapabilities caps) {
+        if (caps.hasCapability(NetworkCapabilities.NET_CAPABILITY_CAPTIVE_PORTAL)) {
+            return ValidatedState.VS_PORTAL;
+        }
+        if (caps.hasCapability(NetworkCapabilities.NET_CAPABILITY_PARTIAL_CONNECTIVITY)) {
+            return ValidatedState.VS_PARTIAL;
+        }
+        if (caps.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)) {
+            return ValidatedState.VS_VALID;
+        }
+        return ValidatedState.VS_INVALID;
+    }
+
+    /**
+     * Converts a set of UidRange objects to the UidRanges proto format.
+     *
+     * @param rangeSet The set of UidRange objects.
+     * @return The UidRanges proto.
+     */
+    @VisibleForTesting
+    public static UidRanges getUidRangesProto(@NonNull Set<android.net.UidRange> rangeSet) {
+        final UidRanges.Builder listBuilder = UidRanges.newBuilder();
+        for (android.net.UidRange range : rangeSet) {
+            final UidRange.Builder rangeBuilder = UidRange.newBuilder();
+            rangeBuilder.setBegin(range.start);
+            rangeBuilder.setEnd(range.stop);
+            listBuilder.addUidRange(rangeBuilder.build());
+        }
+        return listBuilder.build();
+    }
+}
diff --git a/service/src/com/android/metrics/SatelliteCoarseUsageMetricsCollector.java b/service/src/com/android/metrics/SatelliteCoarseUsageMetricsCollector.java
new file mode 100644
index 0000000000..7e8e463389
--- /dev/null
+++ b/service/src/com/android/metrics/SatelliteCoarseUsageMetricsCollector.java
@@ -0,0 +1,333 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.metrics;
+
+import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
+import static android.net.NetworkCapabilities.TRANSPORT_SATELLITE;
+
+import static com.android.net.module.util.FrameworkConnectivityStatsLog.CORE_NETWORKING_CRITICAL_BYTES_EVENT_OCCURRED;
+import static com.android.net.module.util.FrameworkConnectivityStatsLog.CORE_NETWORKING_CRITICAL_BYTES_EVENT_OCCURRED__EVENT_TYPE__CRITICAL_BYTES_EVENT_TYPE_SATELLITE_COARSE_RX_USAGE;
+import static com.android.net.module.util.FrameworkConnectivityStatsLog.CORE_NETWORKING_CRITICAL_BYTES_EVENT_OCCURRED__EVENT_TYPE__CRITICAL_BYTES_EVENT_TYPE_SATELLITE_COARSE_TX_USAGE;
+
+import static java.util.concurrent.TimeUnit.HOURS;
+
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.app.usage.NetworkStats;
+import android.app.usage.NetworkStatsManager;
+import android.content.Context;
+import android.net.ConnectivityManager;
+import android.net.Network;
+import android.net.NetworkRequest;
+import android.net.NetworkTemplate;
+import android.os.Handler;
+import android.os.Process;
+import android.util.Log;
+
+import androidx.annotation.VisibleForTesting;
+
+import com.android.internal.util.IndentingPrintWriter;
+import com.android.modules.utils.BackgroundThread;
+import com.android.modules.utils.build.SdkLevel;
+import com.android.net.module.util.FrameworkConnectivityStatsLog;
+
+import javax.annotation.CheckReturnValue;
+
+/**
+ * Monitors satellite network connections to collect overall usage during active
+ * satellite sessions. It uses NetworkStatsManager to query snapshots upon
+ * connection and disconnection, then logs the difference.
+ *
+ * This class does not provide thread safety and should be only accessed on the same thread.
+ */
+public class SatelliteCoarseUsageMetricsCollector {
+    private static final String TAG = SatelliteCoarseUsageMetricsCollector.class.getSimpleName();
+    private static final NetworkTemplate SATELLITE_TEMPLATE;
+
+    static {
+        // To prevent NetworkTemplate#Builder not found error when
+        // initializing CSTest on S-based image.
+        if (SdkLevel.isAtLeastU()) {
+            SATELLITE_TEMPLATE = new NetworkTemplate.Builder()
+                    .setTransportType(TRANSPORT_SATELLITE).build();
+        } else {
+            SATELLITE_TEMPLATE = null;
+        }
+    }
+    /**
+     * The max bucket duration used when storing usage in NetworkStatsService.
+     * See NetworkStatsService#DefaultNetworkStatsSettings#getUidConfig.
+     */
+    private static final long MAX_NETSTATS_BUCKET_DURATION_MS = HOURS.toMillis(2);
+
+    private ConnectivityManager mCm;
+    private NetworkStatsManager mNsm;
+    private final Context mContext;
+    private final Handler mHandler;
+    private final SatelliteNetworkCallback mNetworkCallback = new SatelliteNetworkCallback();
+
+    // Null when no satellite network is connected.
+    @Nullable
+    private MyStatsEntry mSatelliteBaseline = null;
+
+    private final MyStatsEntry mReportedUsage = new MyStatsEntry();
+    private final Dependencies mDeps;
+
+    // The start timestamp used to query the snapshots of data usage.
+    // This must only be accessed on the handler thread.
+    long mStartTime;
+
+    /**
+     * Constructs a helper to monitor satellite network usage.
+     *
+     * @param context The context.
+     */
+    public SatelliteCoarseUsageMetricsCollector(@NonNull Context context) {
+        this(context, new Dependencies());
+    }
+
+    /**
+     * Constructs a helper to monitor satellite network usage.
+     *
+     * @param context The context.
+     */
+    public SatelliteCoarseUsageMetricsCollector(@NonNull Context context,
+            @NonNull Dependencies deps) {
+        mContext = context;
+        mDeps = deps;
+        mHandler = mDeps.getBackgroundThreadHandler();
+    }
+
+    /**
+     * Helper class for test injection.
+     */
+    @VisibleForTesting
+    public static class Dependencies {
+        /**
+         * Reports the given network usage entry to system metrics.
+         */
+        public void reportUsage(MyStatsEntry entry) {
+            FrameworkConnectivityStatsLog.write_non_chained(CORE_NETWORKING_CRITICAL_BYTES_EVENT_OCCURRED,
+                    Process.SYSTEM_UID,
+                    TAG,
+                    CORE_NETWORKING_CRITICAL_BYTES_EVENT_OCCURRED__EVENT_TYPE__CRITICAL_BYTES_EVENT_TYPE_SATELLITE_COARSE_RX_USAGE,
+                    entry.rxBytes);
+            FrameworkConnectivityStatsLog.write_non_chained(CORE_NETWORKING_CRITICAL_BYTES_EVENT_OCCURRED,
+                    Process.SYSTEM_UID,
+                    TAG,
+                    CORE_NETWORKING_CRITICAL_BYTES_EVENT_OCCURRED__EVENT_TYPE__CRITICAL_BYTES_EVENT_TYPE_SATELLITE_COARSE_TX_USAGE,
+                    entry.txBytes);
+        }
+
+        /**
+         * Queries the network stats summary for a given network template.
+         */
+        @NonNull
+        public MyStatsEntry getSummary(@NonNull NetworkStatsManager nsm, long startTime) {
+            final MyStatsEntry ret = new MyStatsEntry();
+            final NetworkStats stats = nsm.querySummary(SATELLITE_TEMPLATE,
+                    startTime, Long.MAX_VALUE);
+            // This null check simplifies testing by avoiding the need to mock
+            // the complex NetworkStats object. In production, this object
+            // is not expected to be null. See ConnectivityServiceIntegrationTest
+            // for context.
+            if (stats == null) {
+                return ret;
+            }
+            final NetworkStats.Bucket recycle = new NetworkStats.Bucket();
+            while (stats.hasNextBucket()) {
+                stats.getNextBucket(recycle);
+                ret.add(new MyStatsEntry(recycle));
+            }
+            return ret;
+        }
+
+        /** Get the background thread handler */
+        @NonNull
+        public Handler getBackgroundThreadHandler() {
+            return BackgroundThread.getHandler();
+        }
+
+        /** Get current time */
+        public long getCurrentTimeMillis() {
+            return System.currentTimeMillis();
+        }
+
+        /** Get max netstats bucket duration */
+        public long getMaxBucketDuration() {
+            return MAX_NETSTATS_BUCKET_DURATION_MS;
+        }
+    }
+
+    @VisibleForTesting
+    public static class MyStatsEntry {
+        public long rxBytes;
+        public long txBytes;
+
+        public MyStatsEntry() {
+            this.rxBytes = 0;
+            this.txBytes = 0;
+        }
+
+        public MyStatsEntry(@NonNull NetworkStats.Bucket bucket) {
+            this.rxBytes = bucket.getRxBytes();
+            this.txBytes = bucket.getTxBytes();
+        }
+
+        public MyStatsEntry(long rxBytes, long txBytes) {
+            this.rxBytes = rxBytes;
+            this.txBytes = txBytes;
+        }
+
+        /**
+         * Adds the stats from another {@link MyStatsEntry} to this entry.
+         *
+         * This method modifies the current object.
+         */
+        public void add(@NonNull MyStatsEntry other) {
+            this.rxBytes += other.rxBytes;
+            this.txBytes += other.txBytes;
+        }
+
+        /**
+         * Subtracts the stats from another {@link MyStatsEntry} to this entry.
+         *
+         * This method modifies the current object.
+         */
+        public void subtract(@NonNull MyStatsEntry other) {
+            this.rxBytes -= other.rxBytes;
+            this.txBytes -= other.txBytes;
+        }
+
+        /**
+         * Adds the stats from another {@link MyStatsEntry} from this entry.
+         *
+         * This method does not modify the current object but returns a new one.
+         */
+        @CheckReturnValue
+        @NonNull
+        public MyStatsEntry plus(@NonNull MyStatsEntry other) {
+            return new MyStatsEntry(rxBytes + other.rxBytes, txBytes + other.txBytes);
+        }
+
+        /**
+         * Subtracts the stats from another {@link MyStatsEntry} from this entry.
+         *
+         * This method does not modify the current object but returns a new one.
+         */
+        @CheckReturnValue
+        @NonNull
+        public MyStatsEntry minus(@NonNull MyStatsEntry other) {
+            return new MyStatsEntry(rxBytes - other.rxBytes, txBytes - other.txBytes);
+        }
+
+        @Override
+        public String toString() {
+            return "{rxBytes=" + rxBytes + ", txBytes=" + txBytes + "}";
+        }
+    }
+
+    private class SatelliteNetworkCallback extends ConnectivityManager.NetworkCallback {
+        /**
+         * Called when a satellite network is lost. Collects and reports the satellite coarse usage
+         * difference.
+         *
+         * Note that multiple satellite networks could occur, for example, when
+         * transitioning from one subscription to another. The amount of usage might
+         * be slightly inaccurate in such cases.
+         *
+         * @param network The Network object that was just lost.
+         */
+        @Override
+        public void onLost(Network network) {
+            // The start time must be matched with the baseline, in order to calculate
+            // the difference.
+            final MyStatsEntry snapshot = mDeps.getSummary(mNsm, mStartTime);
+            // Report diff with metrics.
+            final MyStatsEntry diff = snapshot.minus(mSatelliteBaseline);
+            mDeps.reportUsage(diff);
+            mReportedUsage.add(diff);
+
+            // Fetch another snapshot as a baseline, with a more recent start timestamp.
+            // This is to prevent from fetching too much data.
+            updateStartTimestamp();
+            mSatelliteBaseline = mDeps.getSummary(mNsm, mStartTime);
+            Log.d(TAG, "onLost: Last satellite network " + network + ", Reported usage: " + diff);
+        }
+    }
+
+    // Calculate the start timestamp used for querying data usage snapshots.
+    // This timestamp needs to be early enough to ensure the query window
+    // starts at or before the beginning of the usage bucket in which the
+    // first event occurred. This is achieved by setting the start time
+    // to one bucket duration prior to the calculated bootTimeMillis.
+    //
+    // It is acceptable if this timestamp is not perfectly aligned with exact
+    // bucket boundaries or results in covering some redundant data from before
+    // the event. Any such duplicated or irrelevant data will be effectively
+    // subtracted out when calculating usage from the differences of two snapshots,
+    // provided both snapshots are queried using this same consistent start timestamp.
+    // This must only be called on the handler thread.
+    private void updateStartTimestamp() {
+        mStartTime = mDeps.getCurrentTimeMillis() - mDeps.getMaxBucketDuration();
+    }
+
+    /**
+     * Starts monitoring for satellite network connections.
+     */
+    public void startMonitoring() {
+        if (!SdkLevel.isAtLeastU()) {
+            throw new UnsupportedOperationException(TAG + " is not supported below U");
+        }
+        mHandler.post(() -> handleStartMonitoring());
+    }
+
+    private void handleStartMonitoring() {
+        // Note that in the constructor it is too early to get the managers.
+        mCm = mContext.getSystemService(ConnectivityManager.class);
+        mNsm = mContext.getSystemService(NetworkStatsManager.class);
+        // Note: This might create heavy workload on NetworkStatsService if queried with high
+        // frequency, as the calling UID is system. Each query made with this manager
+        // updates usage stored in files before returning the newest result.
+        // This behavior is not rate-limited because the calling uid is the system UID.
+        mNsm.setPollOnOpen(true);
+        // Get the first baseline.
+        updateStartTimestamp();
+        mSatelliteBaseline = mDeps.getSummary(mNsm, mStartTime);
+
+        final NetworkRequest satelliteRequest = new NetworkRequest.Builder()
+                .clearCapabilities()
+                .addCapability(NET_CAPABILITY_INTERNET)
+                .addTransportType(TRANSPORT_SATELLITE)
+                .build();
+        // The callback uses the shared background thread. Potential delays of
+        // dozens of seconds are acceptable because this class measures coarse
+        // usage after a connection is lost, so the metric's accuracy is not
+        // that sensitive to the timing.
+        // A dedicated thread would be needed if it turns out inaccurate.
+        mCm.registerNetworkCallback(satelliteRequest, mNetworkCallback, mHandler);
+    }
+
+    /** Dump info to dumpsys */
+    public void dump(@NonNull IndentingPrintWriter pw) {
+        pw.println(TAG + ":");
+        pw.increaseIndent();
+        pw.println("Reported usage " + mReportedUsage);
+        pw.decreaseIndent();
+        pw.println();
+    }
+}
diff --git a/service/src/com/android/metrics/stats.proto b/service/src/com/android/metrics/stats.proto
index ecc03779a7..acde9c6e40 100644
--- a/service/src/com/android/metrics/stats.proto
+++ b/service/src/com/android/metrics/stats.proto
@@ -238,8 +238,21 @@ message ConnectivityStateSample {
 
     // Full list of network details (slice by transport / meteredness / internet+validated)
     optional NetworkList networks = 4;
+
+    // Information for satellite access.
+    optional SatelliteAccessInfo satellite_access_info = 5;
 }
 
+/**
+ * Pulls information for satellite access.
+ *
+ * Pulled from:
+ *   packages/modules/Connectivity/service/src/com/android/server/ConnectivityService.java
+ */
+message SatelliteAccessInfo {
+    // Number of satellite network opt-in uids on the device.
+    optional int32 optin_uid_count = 1;
+}
 
 /**
  * Pulls information for network selection rematch info.
@@ -253,27 +266,49 @@ message NetworkSelectionRematchReasonsInfo {
 }
 
 /**
- * Logs rematch information for the default network
+ * Logs rematch event for the default network
  *
  * Logs from:
  *   packages/modules/Connectivity/service/src/com/android/server/ConnectivityService.java
  */
-message DefaultNetworkRematchInfo {
+message DefaultNetworkRematch {
     // The session id comes from each reboot, this is used to correlate the statistics of the
     // networkselect on the same boot
     optional int64 session_id = 1;
 
+    // The reason of network rematch
+    optional .android.stats.connectivity.RematchReason rematch_reason = 2;
+
+    optional DefaultNetworkRematchInfoList default_network_rematch_info_list = 3;
+}
+
+message DefaultNetworkRematchInfoList {
+    repeated DefaultNetworkRematchInfo default_network_rematch_info = 1;
+}
+
+message DefaultNetworkRematchInfo {
     // The information of old device default network
-    optional NetworkDescription old_network = 2;
+    optional NetworkDescription old_network = 1;
 
     // The information of new device default network
-    optional NetworkDescription new_network = 3;
-
-    // The reason of network rematch
-    optional .android.stats.connectivity.RematchReason rematch_reason = 4;
+    optional NetworkDescription new_network = 2;
 
     // The time duration the device kept the old network as the default in seconds
-    optional int32 time_duration_on_old_network_sec = 5;
+    optional int32 time_duration_on_old_network_sec = 3;
+
+    // Uid ranges which applied to this event.
+    optional UidRanges uid_ranges = 4;
+}
+
+message UidRanges {
+    repeated UidRange uid_range = 1;
+}
+
+// Represents a range of UIDs.
+// The range is inclusive, denoted as [begin, end].
+message UidRange {
+    optional int32 begin = 1;
+    optional int32 end = 2;
 }
 
 /**
diff --git a/service/src/com/android/server/ConnectivityService.java b/service/src/com/android/server/ConnectivityService.java
index 929c4ddd85..ccda9c503e 100644
--- a/service/src/com/android/server/ConnectivityService.java
+++ b/service/src/com/android/server/ConnectivityService.java
@@ -23,6 +23,7 @@ import static android.content.pm.PackageManager.FEATURE_LEANBACK;
 import static android.content.pm.PackageManager.FEATURE_WATCH;
 import static android.content.pm.PackageManager.FEATURE_WIFI;
 import static android.content.pm.PackageManager.FEATURE_WIFI_DIRECT;
+import static android.content.pm.PackageManager.GET_PERMISSIONS;
 import static android.content.pm.PackageManager.PERMISSION_GRANTED;
 import static android.net.BpfNetMapsConstants.METERED_ALLOW_CHAINS;
 import static android.net.BpfNetMapsConstants.METERED_DENY_CHAINS;
@@ -102,7 +103,6 @@ import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_VPN;
 import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
 import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
 import static android.net.NetworkCapabilities.NET_CAPABILITY_PARTIAL_CONNECTIVITY;
-import static android.net.NetworkCapabilities.NET_CAPABILITY_TEMPORARILY_NOT_METERED;
 import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
 import static android.net.NetworkCapabilities.NET_ENTERPRISE_ID_1;
 import static android.net.NetworkCapabilities.NET_ENTERPRISE_ID_5;
@@ -133,6 +133,7 @@ import static android.system.OsConstants.ETH_P_ALL;
 import static android.system.OsConstants.IPPROTO_TCP;
 import static android.system.OsConstants.IPPROTO_UDP;
 
+import static com.android.metrics.DefaultNetworkRematchMetrics.getNetworkDescription;
 import static com.android.net.module.util.BpfUtils.BPF_CGROUP_GETSOCKOPT;
 import static com.android.net.module.util.BpfUtils.BPF_CGROUP_INET4_BIND;
 import static com.android.net.module.util.BpfUtils.BPF_CGROUP_INET4_CONNECT;
@@ -155,7 +156,12 @@ import static com.android.net.module.util.PermissionUtils.enforceNetworkStackPer
 import static com.android.net.module.util.PermissionUtils.enforceNetworkStackPermissionOr;
 import static com.android.net.module.util.PermissionUtils.hasAnyPermissionOf;
 import static com.android.server.ConnectivityStatsLog.CONNECTIVITY_STATE_SAMPLE;
+import static com.android.server.ConnectivityStatsLog.DEFAULT_NETWORK_REMATCH__REMATCH_REASON__RMR_NETWORK_DISCONNECTED;
+import static com.android.server.NetIdManager.MAX_NET_ID;
+import static com.android.server.NetIdManager.MIN_NET_ID;
 import static com.android.server.connectivity.ConnectivityFlags.CELLULAR_DATA_INACTIVITY_TIMEOUT;
+import static com.android.server.connectivity.ConnectivityFlags.CLOSE_QUIC_CONNECTION;
+import static com.android.server.connectivity.ConnectivityFlags.CONSTRAINED_DATA_SATELLITE_METRICS;
 import static com.android.server.connectivity.ConnectivityFlags.DELAY_DESTROY_SOCKETS;
 import static com.android.server.connectivity.ConnectivityFlags.INGRESS_TO_VPN_ADDRESS_FILTERING;
 import static com.android.server.connectivity.ConnectivityFlags.NAMESPACE_TETHERING_BOOT;
@@ -185,6 +191,7 @@ import android.content.ContentResolver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.res.XmlResourceParser;
 import android.database.ContentObserver;
@@ -272,6 +279,7 @@ import android.net.netd.aidl.NativeUidRangeConfig;
 import android.net.networkstack.ModuleNetworkStackClient;
 import android.net.networkstack.NetworkStackClientBase;
 import android.net.networkstack.aidl.NetworkMonitorParameters;
+import android.net.platform.flags.Flags;
 import android.net.resolv.aidl.DnsHealthEventParcel;
 import android.net.resolv.aidl.IDnsResolverUnsolicitedEventListener;
 import android.net.resolv.aidl.Nat64PrefixEventParcel;
@@ -302,11 +310,10 @@ import android.os.SystemProperties;
 import android.os.UserHandle;
 import android.os.UserManager;
 import android.provider.Settings;
-import android.stats.connectivity.MeteredState;
 import android.stats.connectivity.RequestType;
-import android.stats.connectivity.ValidatedState;
 import android.sysprop.NetworkProperties;
 import android.system.ErrnoException;
+import android.system.OsConstants;
 import android.telephony.SubscriptionManager;
 import android.telephony.TelephonyManager;
 import android.text.TextUtils;
@@ -329,12 +336,14 @@ import com.android.metrics.ConnectionDurationForTransports;
 import com.android.metrics.ConnectionDurationPerTransports;
 import com.android.metrics.ConnectivitySampleMetricsHelper;
 import com.android.metrics.ConnectivityStateSample;
+import com.android.metrics.DefaultNetworkRematchMetrics;
 import com.android.metrics.NetworkCountForTransports;
 import com.android.metrics.NetworkCountPerTransports;
-import com.android.metrics.NetworkDescription;
 import com.android.metrics.NetworkList;
 import com.android.metrics.NetworkRequestCount;
 import com.android.metrics.RequestCountForType;
+import com.android.metrics.SatelliteAccessInfo;
+import com.android.metrics.SatelliteCoarseUsageMetricsCollector;
 import com.android.modules.utils.BasicShellCommandHandler;
 import com.android.modules.utils.build.SdkLevel;
 import com.android.net.module.util.BaseNetdUnsolicitedEventListener;
@@ -345,14 +354,21 @@ import com.android.net.module.util.CollectionUtils;
 import com.android.net.module.util.DeviceConfigUtils;
 import com.android.net.module.util.HandlerUtils;
 import com.android.net.module.util.InterfaceParams;
+import com.android.net.module.util.LinkPropertiesUtils;
 import com.android.net.module.util.LinkPropertiesUtils.CompareOrUpdateResult;
 import com.android.net.module.util.LinkPropertiesUtils.CompareResult;
 import com.android.net.module.util.LocationPermissionChecker;
 import com.android.net.module.util.PerUidCounter;
 import com.android.net.module.util.PermissionUtils;
 import com.android.net.module.util.RoutingCoordinatorService;
+import com.android.net.module.util.SharedLog;
 import com.android.net.module.util.TcUtils;
+import com.android.net.module.util.ip.NetlinkMonitor;
 import com.android.net.module.util.netlink.InetDiagMessage;
+import com.android.net.module.util.netlink.NetlinkConstants;
+import com.android.net.module.util.netlink.NetlinkMessage;
+import com.android.net.module.util.netlink.RtNetlinkAddressMessage;
+import com.android.net.module.util.netlink.StructIfaddrMsg;
 import com.android.networkstack.apishim.BroadcastOptionsShimImpl;
 import com.android.networkstack.apishim.ConstantsShim;
 import com.android.networkstack.apishim.common.BroadcastOptionsShim;
@@ -361,6 +377,7 @@ import com.android.server.connectivity.ApplicationSelfCertifiedNetworkCapabiliti
 import com.android.server.connectivity.AutodestructReference;
 import com.android.server.connectivity.AutomaticOnOffKeepaliveTracker;
 import com.android.server.connectivity.AutomaticOnOffKeepaliveTracker.AutomaticOnOffKeepalive;
+import com.android.server.connectivity.BroadcastReceiveHelper;
 import com.android.server.connectivity.CarrierPrivilegeAuthenticator;
 import com.android.server.connectivity.ClatCoordinator;
 import com.android.server.connectivity.ConnectivityFlags;
@@ -369,6 +386,7 @@ import com.android.server.connectivity.DnsManager;
 import com.android.server.connectivity.DnsManager.PrivateDnsValidationUpdate;
 import com.android.server.connectivity.DscpPolicyTracker;
 import com.android.server.connectivity.FullScore;
+import com.android.server.connectivity.IntegerRangeUtils;
 import com.android.server.connectivity.InterfaceTracker;
 import com.android.server.connectivity.InvalidTagException;
 import com.android.server.connectivity.KeepaliveResourceUtil;
@@ -389,6 +407,7 @@ import com.android.server.connectivity.PermissionMonitor;
 import com.android.server.connectivity.ProfileNetworkPreferenceInfo;
 import com.android.server.connectivity.ProxyTracker;
 import com.android.server.connectivity.QosCallbackTracker;
+import com.android.server.connectivity.QuicConnectionCloser;
 import com.android.server.connectivity.SatelliteAccessController;
 import com.android.server.connectivity.UidRangeUtils;
 import com.android.server.connectivity.VpnNetworkPreferenceInfo;
@@ -404,6 +423,7 @@ import java.io.InterruptedIOException;
 import java.io.PrintWriter;
 import java.io.Writer;
 import java.net.Inet4Address;
+import java.net.Inet6Address;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.SocketException;
@@ -436,7 +456,9 @@ import java.util.function.Predicate;
 /**
  * @hide
  */
-public class ConnectivityService extends IConnectivityManager.Stub {
+@TargetApi(Build.VERSION_CODES.S)
+public class ConnectivityService extends IConnectivityManager.Stub
+        implements BroadcastReceiveHelper.Delegate {
     private static final String TAG = ConnectivityService.class.getSimpleName();
 
     private static final String DIAG_ARG = "--diag";
@@ -501,8 +523,13 @@ public class ConnectivityService extends IConnectivityManager.Stub {
     static final int MAX_NETWORK_REQUESTS_PER_UID = 100;
 
     // The maximum number of network request allowed for system UIDs before an exception is thrown.
+    // The point of this limit is to help developers find request leaks, so it should be
+    // appropriately low, while allowing plenty of requests for normal use cases.
+    // In the case of the system UIDs, the main consumer of such requests is JobScheduler, which
+    // at most might file one request per UID on the system. Also see b/391114053 for some context
+    // about the specific JobScheduler case and its own self-imposed limit.
     @VisibleForTesting
-    static final int MAX_NETWORK_REQUESTS_PER_SYSTEM_UID = 250;
+    static final int MAX_NETWORK_REQUESTS_PER_SYSTEM_UID = 375;
 
     @VisibleForTesting
     protected int mLingerDelayMs;  // Can't be final, or test subclass constructors can't change it.
@@ -520,6 +547,8 @@ public class ConnectivityService extends IConnectivityManager.Stub {
 
     private final PermissionMonitor mPermissionMonitor;
 
+    private final BroadcastReceiveHelper mBroadcastReceiveHelper;
+
     @VisibleForTesting
     final RequestInfoPerUidCounter mNetworkRequestCounter;
     @VisibleForTesting
@@ -535,6 +564,9 @@ public class ConnectivityService extends IConnectivityManager.Stub {
 
     // Flag to delay callbacks for frozen apps, suppressing duplicate and stale callbacks.
     private final boolean mQueueCallbacksForFrozenApps;
+    // Flag for early link properties update
+    private final boolean mSupportEarlyLinkPropertiesUpdateForVPN;
+    private final boolean mConstrainedDataSatelliteMetrics;
 
     /**
      * Uids ConnectivityService tracks blocked status of to send blocked status callbacks.
@@ -637,7 +669,8 @@ public class ConnectivityService extends IConnectivityManager.Stub {
      * The default request uses PREFERENCE_ORDER_DEFAULT.
      */
     // Used when sending to netd to code for "no order".
-    static final int PREFERENCE_ORDER_NONE = 0;
+    @VisibleForTesting
+    public static final int PREFERENCE_ORDER_NONE = 0;
     // Order for requests that don't code for a per-app preference. As it is
     // out of the valid range, the corresponding order should be
     // PREFERENCE_ORDER_NONE when sending to netd.
@@ -645,6 +678,9 @@ public class ConnectivityService extends IConnectivityManager.Stub {
     static final int PREFERENCE_ORDER_INVALID = Integer.MAX_VALUE;
     // As a security feature, VPNs have the top priority.
     static final int PREFERENCE_ORDER_VPN = 0; // Netd supports only 0 for VPN.
+    // Shell command has the next highest priority.
+    @VisibleForTesting
+    static final int PREFERENCE_ORDER_DEBUG_FALLBACK = 3;
     // Order of per-app OEM preference. See {@link #setOemNetworkPreference}.
     @VisibleForTesting
     static final int PREFERENCE_ORDER_OEM = 10;
@@ -659,8 +695,7 @@ public class ConnectivityService extends IConnectivityManager.Stub {
     static final int PREFERENCE_ORDER_MOBILE_DATA_PREFERERRED = 30;
     // Order of setting satellite network preference fallback when default message application
     // with role_sms role and android.permission.SATELLITE_COMMUNICATION permission detected
-    @VisibleForTesting
-    static final int PREFERENCE_ORDER_SATELLITE_FALLBACK = 40;
+    public static final int PREFERENCE_ORDER_SATELLITE_FALLBACK = 40;
     // Preference order that signifies the network shouldn't be set as a default network for
     // the UIDs, only give them access to it. TODO : replace this with a boolean
     // in NativeUidRangeConfig
@@ -1031,6 +1066,7 @@ public class ConnectivityService extends IConnectivityManager.Stub {
     private final NetworkNotificationManager mNotifier;
     private final LingerMonitor mLingerMonitor;
     private final SatelliteAccessController mSatelliteAccessController;
+    private final SatelliteCoarseUsageMetricsCollector mSatelliteCoarseUsageMetricsCollector;
 
     private final L2capNetworkProvider mL2capNetworkProvider;
 
@@ -1058,6 +1094,7 @@ public class ConnectivityService extends IConnectivityManager.Stub {
     private long mLastWakeLockAcquireTimestamp = 0;
 
     private final IpConnectivityLog mMetricsLog;
+    private final DefaultNetworkRematchMetrics mDefaultNetworkRematchMetrics;
 
     @Nullable private final NetworkRequestStateStatsMetrics mNetworkRequestStateStatsMetrics;
 
@@ -1104,6 +1141,18 @@ public class ConnectivityService extends IConnectivityManager.Stub {
     // Flag to drop packets to VPN addresses ingressing via non-VPN interfaces.
     private final boolean mIngressToVpnAddressFiltering;
 
+    // Flag to close QUIC connection for registered sockets when apps lose network access.
+    private final boolean mCloseQuicConnection;
+
+    // This is null if mCloseQuicConnection is false
+    @Nullable
+    private final QuicConnectionCloser mQuicConnectionCloser;
+
+    // A map from IP address to networks. Only the handler thread is allowed to access this field.
+    @Nullable @VisibleForTesting final Map<InetAddress, Set<NetworkAgentInfo>> mIpToNetworksMap;
+    // NetlinkMonitor for ConnectivityService
+    @Nullable private final AddressUpdateMonitor mAddressUpdateMonitor;
+
     /**
      * Implements support for the legacy "one network per network type" model.
      *
@@ -1449,6 +1498,28 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         }
     }
 
+    /**
+     * Simple NetlinkMonitor. Listen for address changed events from kernel.
+     * All methods except the constructor must be called on the handler thread.
+     */
+    public static class AddressUpdateMonitor extends NetlinkMonitor {
+        private final Consumer<NetlinkMessage> mNetlinkMessageConsumer;
+
+        AddressUpdateMonitor(Handler h, SharedLog log, String tag,
+                Consumer<NetlinkMessage> netlinkMessageConsumer) {
+            super(h, log, tag, OsConstants.NETLINK_ROUTE,
+                    (NetlinkConstants.RTMGRP_IPV4_IFADDR
+                            | NetlinkConstants.RTMGRP_IPV6_IFADDR));
+            mNetlinkMessageConsumer = netlinkMessageConsumer;
+        }
+
+        @Override
+        protected void processNetlinkMessage(
+                @NonNull NetlinkMessage nlMsg, long whenMs) {
+            mNetlinkMessageConsumer.accept(nlMsg);
+        }
+    }
+
     /**
      * Dependencies of ConnectivityService, for injection in tests.
      */
@@ -1478,6 +1549,11 @@ public class ConnectivityService extends IConnectivityManager.Stub {
             return SdkLevel.isAtLeastB();
         }
 
+        /** Get SystemClock.elapsedRealtime() */
+        public long getElapsedRealtime() {
+            return SystemClock.elapsedRealtime();
+        }
+
         /**
          * Get system properties to use in ConnectivityService.
          */
@@ -1632,12 +1708,29 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         @Nullable
         public SatelliteAccessController makeSatelliteAccessController(
                 @NonNull final Context context,
-                Consumer<Set<Integer>> updateSatelliteNetworkFallbackUidCallback,
+                BiConsumer<Set<Integer>, Set<Integer>> updateSatelliteNetworkFallbackUidCallback,
                 @NonNull final Handler connectivityServiceInternalHandler) {
             return new SatelliteAccessController(context, updateSatelliteNetworkFallbackUidCallback,
                     connectivityServiceInternalHandler);
         }
 
+        /**
+         * @see SatelliteCoarseUsageMetricsCollector
+         */
+        @Nullable
+        public SatelliteCoarseUsageMetricsCollector makeSatelliteCoarseUsageMetricsCollector(
+                @NonNull final Context context) {
+            return new SatelliteCoarseUsageMetricsCollector(context);
+        }
+
+        /**
+         * @see DefaultNetworkRematchMetrics
+         */
+        @Nullable
+        public DefaultNetworkRematchMetrics makeDefaultNetworkRematchMetrics() {
+            return new DefaultNetworkRematchMetrics();
+        }
+
         /** Creates an L2capNetworkProvider */
         public L2capNetworkProvider makeL2capNetworkProvider(Context context) {
             return new L2capNetworkProvider(context);
@@ -1809,6 +1902,45 @@ public class ConnectivityService extends IConnectivityManager.Stub {
             InetDiagMessage.destroyLiveTcpSocketsByOwnerUids(ownerUids);
         }
 
+        /**
+         * Destroy live tcp sockets for IP addresses with conditions.
+         *
+         * @param address a local address to destroy sockets
+         * @param netIdRange range of net IDs to destroy sockets
+         * @param uidRanges ranges of UIDs to destroy sockets
+         */
+        public void destroyLiveTcpSocketsByLocalAddress(
+                @NonNull InetAddress address,
+                @Nullable Set<Range<Integer>> netIdRange,
+                @Nullable Set<Range<Integer>> uidRanges)
+                throws SocketException, InterruptedIOException, ErrnoException {
+            InetDiagMessage.destroyLiveTcpSocketsByLocalAddress(address, netIdRange, uidRanges);
+        }
+
+        /**
+         * Destroy live tcp sockets for IP addresses with conditions.
+         *
+         * @param address a local address to destroy sockets
+         * @param interfaceId interface ID
+         */
+        public void destroyLiveTcpSocketsByLocalAddress(
+                @NonNull InetAddress address, int interfaceId)
+                throws SocketException, InterruptedIOException, ErrnoException {
+            InetDiagMessage.destroyLiveTcpSocketsByLocalAddress(address, interfaceId);
+        }
+
+        /**
+         * Call {@link InetDiagMessage#destroyLiveTcpSocketsLackingPermission(int, int)}
+         *
+         * @param netId network ID
+         * @param permission network permission
+         */
+        public void destroyLiveTcpSocketsLackingPermission(
+                int netId, int permission)
+                throws SocketException, InterruptedIOException, ErrnoException {
+            InetDiagMessage.destroyLiveTcpSocketsLackingPermission(netId, permission);
+        }
+
         /**
          * Schedule the evaluation timeout.
          *
@@ -1825,6 +1957,28 @@ public class ConnectivityService extends IConnectivityManager.Stub {
             handler.sendMessageDelayed(
                     handler.obtainMessage(EVENT_INITIAL_EVALUATION_TIMEOUT, network), delayMs);
         }
+
+        /**
+         * Create {@link QuicConnectionCloser}.
+         */
+        public QuicConnectionCloser makeQuicConnectionCloser(
+                final SparseArray<NetworkAgentInfo> networkForNetId, final Handler handler) {
+            return new QuicConnectionCloser(networkForNetId, handler);
+        }
+
+        /** Whether the flag for connectivity service socket destroy is enabled or not. */
+        public boolean flagConnectivityServiceDestroySocket() {
+            return Flags.connectivityServiceDestroySocket();
+        }
+
+        /**
+         * Create a AddressUpdateMonitor instance.
+         */
+        public AddressUpdateMonitor makeAddressUpdateMonitor(
+                @NonNull Handler h, @NonNull SharedLog log, @NonNull String tag,
+                @NonNull Consumer<NetlinkMessage> consumer) {
+            return new AddressUpdateMonitor(h, log, tag, consumer);
+        }
     }
 
     public ConnectivityService(Context context) {
@@ -1857,9 +2011,8 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         mNetworkRequestStateStatsMetrics = mDeps.makeNetworkRequestStateStatsMetrics(mContext);
         final NetworkRequest defaultInternetRequest = createDefaultRequest();
         mDefaultRequest = new NetworkRequestInfo(
-                Process.myUid(), defaultInternetRequest, null,
-                null /* binder */, NetworkCallback.FLAG_INCLUDE_LOCATION_INFO,
-                null /* attributionTags */, DECLARED_METHODS_NONE);
+                Process.myUid(), Collections.singletonList(defaultInternetRequest),
+                PREFERENCE_ORDER_INVALID);
         mNetworkRequests.put(defaultInternetRequest, mDefaultRequest);
         mDefaultNetworkRequests.add(mDefaultRequest);
         mNetworkRequestInfoLogs.log("REGISTER " + mDefaultRequest);
@@ -1919,6 +2072,7 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         mTrackerHandler = new NetworkStateTrackerHandler(mHandlerThread.getLooper());
         mConnectivityDiagnosticsHandler =
                 new ConnectivityDiagnosticsHandler(mHandlerThread.getLooper());
+        mBroadcastReceiveHelper = new BroadcastReceiveHelper(mContext, mHandler, this);
 
         mReleasePendingIntentDelayMs = Settings.Secure.getInt(context.getContentResolver(),
                 ConnectivitySettingsManager.CONNECTIVITY_RELEASE_PENDING_INTENT_DELAY_MS, 5_000);
@@ -1932,7 +2086,7 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
         mLocationPermissionChecker = mDeps.makeLocationPermissionChecker(mContext);
         mRequestRestrictedWifiEnabled = mDeps.isAtLeastU()
-                && mDeps.isFeatureEnabled(context, REQUEST_RESTRICTED_WIFI);
+                && mDeps.isFeatureNotChickenedOut(context, REQUEST_RESTRICTED_WIFI);
         mBackgroundFirewallChainEnabled = mDeps.isAtLeastV() && mDeps.isFeatureNotChickenedOut(
                 context, ConnectivityFlags.BACKGROUND_FIREWALL_CHAIN);
         mUseDeclaredMethodsForCallbacksEnabled =
@@ -1941,6 +2095,8 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         mQueueNetworkAgentEventsInSystemServer = mDeps.isAtLeastB()
                 && mDeps.isFeatureNotChickenedOut(context,
                         ConnectivityFlags.QUEUE_NETWORK_AGENT_EVENTS_IN_SYSTEM_SERVER);
+        mSupportEarlyLinkPropertiesUpdateForVPN = mDeps.isFeatureNotChickenedOut(context,
+                ConnectivityFlags.EARLY_LINK_PROPERTIES_UPDATE_FOR_VPN);
         // registerUidFrozenStateChangedCallback is only available on U+
         mQueueCallbacksForFrozenApps = mDeps.isAtLeastU()
                 && mDeps.isFeatureNotChickenedOut(context, QUEUE_CALLBACKS_FOR_FROZEN_APPS);
@@ -1956,7 +2112,26 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         } else {
             mSatelliteAccessController = null;
         }
+        mConstrainedDataSatelliteMetrics = (mSatelliteAccessController != null)
+                && mDeps.isFeatureNotChickenedOut(mContext, CONSTRAINED_DATA_SATELLITE_METRICS);
+        if (mConstrainedDataSatelliteMetrics) {
+            mSatelliteCoarseUsageMetricsCollector =
+                    mDeps.makeSatelliteCoarseUsageMetricsCollector(mContext);
+            mDefaultNetworkRematchMetrics = mDeps.makeDefaultNetworkRematchMetrics();
+        } else {
+            mSatelliteCoarseUsageMetricsCollector = null;
+            mDefaultNetworkRematchMetrics = null;
+        }
 
+        if (mDeps.flagConnectivityServiceDestroySocket()) {
+            mIpToNetworksMap = new HashMap<>();
+            mAddressUpdateMonitor = mDeps.makeAddressUpdateMonitor(
+                    mHandler, new SharedLog(20, TAG), TAG,
+                    this::processNetlinkAddressUpdateMessage);
+        } else {
+            mIpToNetworksMap = null;
+            mAddressUpdateMonitor = null;
+        }
         // To ensure uid state is synchronized with Network Policy, register for
         // NetworkPolicyManagerService events must happen prior to NetworkPolicyManagerService
         // reading existing policy from disk.
@@ -1986,22 +2161,8 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         mUserManager = (UserManager) context.getSystemService(Context.USER_SERVICE);
 
         mUserAllContext = mContext.createContextAsUser(UserHandle.ALL, 0 /* flags */);
-        // Listen for user add/removes to inform PermissionMonitor.
-        // Should run on mHandler to avoid any races.
-        final IntentFilter userIntentFilter = new IntentFilter();
-        userIntentFilter.addAction(Intent.ACTION_USER_ADDED);
-        userIntentFilter.addAction(Intent.ACTION_USER_REMOVED);
-        mUserAllContext.registerReceiver(mUserIntentReceiver, userIntentFilter,
-                null /* broadcastPermission */, mHandler);
-
-        // Listen to package add/removes for netd
-        final IntentFilter packageIntentFilter = new IntentFilter();
-        packageIntentFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
-        packageIntentFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
-        packageIntentFilter.addAction(Intent.ACTION_PACKAGE_REPLACED);
-        packageIntentFilter.addDataScheme("package");
-        mUserAllContext.registerReceiver(mPackageIntentReceiver, packageIntentFilter,
-                null /* broadcastPermission */, mHandler);
+        // TODO: Move all intent receivers to the helper class.
+        mBroadcastReceiveHelper.registerReceivers();
 
         // This is needed for pre-V devices to propagate the data saver status
         // to the BPF map. This isn't supported before Android T because BPF maps are
@@ -2133,6 +2294,16 @@ public class ConnectivityService extends IConnectivityManager.Stub {
                 && mDeps.isFeatureNotChickenedOut(mContext, INGRESS_TO_VPN_ADDRESS_FILTERING);
 
         mL2capNetworkProvider = mDeps.makeL2capNetworkProvider(mContext);
+
+        // QUIC connection close is triggered by freezer (U+) or background firewall chain (V+).
+        // TODO: Allow other firewall chains to close QUIC connection and enable this flag on T+
+        mCloseQuicConnection = mDeps.isAtLeastU()
+                && mDeps.isFeatureNotChickenedOut(context, CLOSE_QUIC_CONNECTION);
+        if (mCloseQuicConnection) {
+            mQuicConnectionCloser = mDeps.makeQuicConnectionCloser(mNetworkForNetId, mHandler);
+        } else {
+            mQuicConnectionCloser = null;
+        }
     }
 
     /**
@@ -2236,15 +2407,21 @@ public class ConnectivityService extends IConnectivityManager.Stub {
     }
 
     /**
-     * Called when satellite network fallback uids at {@link SatelliteAccessController}
+     * Called when satellite network fallback uids from the {@link SatelliteAccessController}
      * cache was updated based on {@link
-     * android.app.role.OnRoleHoldersChangedListener#onRoleHoldersChanged(String, UserHandle)},
-     * to create multilayer request with preference order
-     * {@link #PREFERENCE_ORDER_SATELLITE_FALLBACK} there on.
-     *
+     * android.app.role.OnRoleHoldersChangedListener#onRoleHoldersChanged(String, UserHandle)}
+     * and self-certified applications, to create multilayer request with preference order
+     * {@link #PREFERENCE_ORDER_SATELLITE_FALLBACK}.
      */
-    private void updateSatelliteNetworkPreferenceUids(Set<Integer> satelliteNetworkFallbackUids) {
-        handleSetSatelliteNetworkPreference(satelliteNetworkFallbackUids);
+    private void updateSatelliteNetworkPreferenceUids(
+            @NonNull final Set<Integer> messagingRoleUids,
+            @NonNull final Set<Integer> optinUids
+    ) {
+        if (CollectionUtils.containsAny(messagingRoleUids, optinUids)) {
+            throw new IllegalArgumentException("There can be no overlap between the "
+                    + "messagingRoleUids and the optinUids for satellite");
+        }
+        handleSetSatelliteNetworkPreference(messagingRoleUids, optinUids);
     }
 
     private void handleAlwaysOnNetworkRequest(
@@ -2261,10 +2438,8 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         }
 
         if (enable) {
-            handleRegisterNetworkRequest(new NetworkRequestInfo(
-                    Process.myUid(), networkRequest, null /* messenger */, null /* binder */,
-                    NetworkCallback.FLAG_INCLUDE_LOCATION_INFO,
-                    null /* attributionTags */, DECLARED_METHODS_NONE));
+            handleRegisterNetworkRequest(new NetworkRequestInfo(Process.myUid(),
+                    Collections.singletonList(networkRequest), PREFERENCE_ORDER_INVALID));
         } else {
             handleReleaseNetworkRequest(networkRequest, Process.SYSTEM_UID,
                     /* callOnUnavailable */ false);
@@ -2705,7 +2880,8 @@ public class ConnectivityService extends IConnectivityManager.Stub {
                 sample.getNetworkCountPerTransports().toByteArray(),
                 sample.getConnectionDurationPerTransports().toByteArray(),
                 sample.getNetworkRequestCount().toByteArray(),
-                sample.getNetworks().toByteArray());
+                sample.getNetworks().toByteArray(),
+                sample.getSatelliteAccessInfo().toByteArray());
     }
 
     /**
@@ -2723,6 +2899,9 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         builder.setConnectionDurationPerTransports(sampleConnectionDuration(mNetworkAgentInfos));
         builder.setNetworkRequestCount(sampleNetworkRequestCount(mNetworkRequests.values()));
         builder.setNetworks(sampleNetworks(mNetworkAgentInfos));
+        if (mConstrainedDataSatelliteMetrics) {
+            builder.setSatelliteAccessInfo(sampleSatelliteAccessInfo(mSatelliteAccessController));
+        }
         return builder.build();
     }
 
@@ -2791,37 +2970,18 @@ public class ConnectivityService extends IConnectivityManager.Stub {
     private static NetworkList sampleNetworks(@NonNull final ArraySet<NetworkAgentInfo> nais) {
         final NetworkList.Builder builder = NetworkList.newBuilder();
         for (final NetworkAgentInfo nai : nais) {
-            final NetworkCapabilities nc = nai.networkCapabilities;
-            final NetworkDescription.Builder d = NetworkDescription.newBuilder();
-            d.setTransportTypes((int) nc.getTransportTypesInternal());
-            final MeteredState meteredState;
-            if (nc.hasCapability(NET_CAPABILITY_TEMPORARILY_NOT_METERED)) {
-                meteredState = MeteredState.METERED_TEMPORARILY_UNMETERED;
-            } else if (nc.hasCapability(NET_CAPABILITY_NOT_METERED)) {
-                meteredState = MeteredState.METERED_NO;
-            } else {
-                meteredState = MeteredState.METERED_YES;
-            }
-            d.setMeteredState(meteredState);
-            final ValidatedState validatedState;
-            if (nc.hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL)) {
-                validatedState = ValidatedState.VS_PORTAL;
-            } else if (nc.hasCapability(NET_CAPABILITY_PARTIAL_CONNECTIVITY)) {
-                validatedState = ValidatedState.VS_PARTIAL;
-            } else if (nc.hasCapability(NET_CAPABILITY_VALIDATED)) {
-                validatedState = ValidatedState.VS_VALID;
-            } else {
-                validatedState = ValidatedState.VS_INVALID;
-            }
-            d.setValidatedState(validatedState);
-            d.setScorePolicies(nai.getScore().getPoliciesInternal());
-            d.setCapabilities(nc.getCapabilitiesInternal());
-            d.setEnterpriseId(nc.getEnterpriseIdsInternal());
-            builder.addNetworkDescription(d);
+            builder.addNetworkDescription(getNetworkDescription(nai));
         }
         return builder.build();
     }
 
+    @NonNull
+    private static SatelliteAccessInfo sampleSatelliteAccessInfo(
+            @NonNull final SatelliteAccessController controller) {
+        final int optInUidCount = controller.getCachedOptInUidsCount();
+        return SatelliteAccessInfo.newBuilder().setOptinUidCount(optInUidCount).build();
+    }
+
     @Override
     public boolean isNetworkSupported(int networkType) {
         enforceAccessPermission();
@@ -3687,6 +3847,11 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         } catch (SocketException | InterruptedIOException | ErrnoException e) {
             loge("Failed to destroy sockets: " + e);
         }
+
+        if (mCloseQuicConnection) {
+            mQuicConnectionCloser.closeQuicConnectionByUids(uids);
+        }
+
         mDestroySocketPendingUids.clear();
     }
 
@@ -4134,15 +4299,31 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         // Since mApps in PermissionMonitor needs to be populated first to ensure that
         // listening network request which is sent by MultipathPolicyTracker won't be added
         // NET_CAPABILITY_FOREGROUND capability. Thus, MultipathPolicyTracker.start() must
-        // be called after PermissionMonitor#startMonitoring().
-        // Calling PermissionMonitor#startMonitoring() in systemReadyInternal() and the
+        // be called after PermissionMonitor#initialize().
+        // Calling PermissionMonitor#initialize() in systemReadyInternal() and the
         // MultipathPolicyTracker.start() is called in NetworkPolicyManagerService#systemReady()
         // to ensure the tracking will be initialized correctly.
-        final ConditionVariable startMonitoringDone = new ConditionVariable();
+        final ConditionVariable permissionMonitorInitializeDone = new ConditionVariable();
         mHandler.post(() -> {
-            mPermissionMonitor.startMonitoring();
-            startMonitoringDone.open();
+            mPermissionMonitor.initialize();
+            // Calling mBroadcastReceiveHelper.callCallbackForInitialUsers() after
+            // PermissionMonitor#initialize() ensures that the internal lists
+            // (mUidsAllowedOnRestrictedNetworks and mUsersTrafficPermissions) in
+            // PermissionMonitor are prepared before processing initial users.
+            // While technically the onUserAdded callback (triggered by
+            // callCallbackForInitialUsers) handles sending network and traffic
+            // permissions to netd and bpf, which depend on these lists, moving
+            // this call before initialize would necessitate performing these
+            // actions again within initialize, leading to redundant work.
+            // Therefore, keeping callCallbackForInitialUsers() in this order is the
+            // safest approach to avoid duplicated operations and ensure the
+            // permission lists are ready when the initial user callbacks are invoked.
+            mBroadcastReceiveHelper.callOnUserAddedForExistingUsers();
+            permissionMonitorInitializeDone.open();
         });
+        if (mAddressUpdateMonitor != null) {
+            mHandler.post(() -> mAddressUpdateMonitor.start());
+        }
         mProxyTracker.loadGlobalProxy();
         registerDnsResolverUnsolicitedEventListener();
 
@@ -4185,9 +4366,13 @@ public class ConnectivityService extends IConnectivityManager.Stub {
                 CONNECTIVITY_STATE_SAMPLE, this::sampleConnectivityStateToStatsEvent);
         // Wait PermissionMonitor to finish the permission update. Then MultipathPolicyTracker won't
         // have permission problem. While CV#block() is unbounded in time and can in principle block
-        // forever, this replaces a synchronous call to PermissionMonitor#startMonitoring, which
+        // forever, this replaces a synchronous call to PermissionMonitor#initialize, which
         // could have blocked forever too.
-        startMonitoringDone.block();
+        permissionMonitorInitializeDone.block();
+
+        if (mConstrainedDataSatelliteMetrics) {
+            mSatelliteCoarseUsageMetricsCollector.startMonitoring();
+        }
     }
 
     /**
@@ -4510,17 +4695,46 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         mPermissionMonitor.dump(pw);
         pw.decreaseIndent();
 
+        pw.println();
+        if (mSatelliteAccessController != null) {
+            mSatelliteAccessController.dump(pw);
+        }
+        if (mConstrainedDataSatelliteMetrics) {
+            mSatelliteCoarseUsageMetricsCollector.dump(pw);
+        }
+
         pw.println();
         pw.println("Legacy network activity:");
         pw.increaseIndent();
         mNetworkActivityTracker.dump(pw);
         pw.decreaseIndent();
 
+        pw.println();
+        pw.println("Close QUIC connection: " + mCloseQuicConnection);
+        if (mCloseQuicConnection) {
+            mQuicConnectionCloser.dump(pw);
+        }
+
         pw.println();
         pw.println("Multicast routing supported: " +
                 (mMulticastRoutingCoordinatorService != null));
         pw.println("Background firewall chain enabled: " + mBackgroundFirewallChainEnabled);
         pw.println("IngressToVpnAddressFiltering: " + mIngressToVpnAddressFiltering);
+
+        if (mIpToNetworksMap != null) {
+            pw.println();
+            pw.println("mIpToNetworksMap:");
+            pw.increaseIndent();
+            for (Map.Entry<InetAddress, Set<NetworkAgentInfo>> info : mIpToNetworksMap.entrySet()) {
+                StringBuilder sb = new StringBuilder();
+                sb.append(info.getKey()).append(": ");
+                for (NetworkAgentInfo nai : info.getValue()) {
+                    sb.append("{").append(nai.network).append("}");
+                }
+                pw.println(sb);
+            }
+            pw.decreaseIndent();
+        }
     }
 
     private void dumpNetworks(IndentingPrintWriter pw) {
@@ -4639,7 +4853,8 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         }
     }
 
-    private void dumpAllRequestInfoLogsToLogcat() {
+    @VisibleForTesting
+    protected void dumpAllRequestInfoLogsToLogcat() {
         try (PrintWriter logPw = new PrintWriter(new Writer() {
             @Override
             public void write(final char[] cbuf, final int off, final int len) {
@@ -5470,6 +5685,10 @@ public class ConnectivityService extends IConnectivityManager.Stub {
                 && !caps.hasTransport(TRANSPORT_THREAD));
     }
 
+    private boolean shouldUpdateLinkPropertiesEarlyForVPNNetwork(@NonNull NetworkAgentInfo nai) {
+        return mSupportEarlyLinkPropertiesUpdateForVPN && nai.isVPN();
+    }
+
     private boolean shouldCreateNativeNetwork(@NonNull NetworkAgentInfo nai,
             @NonNull NetworkInfo.State state) {
         if (nai.isCreated()) return false;
@@ -5599,7 +5818,14 @@ public class ConnectivityService extends IConnectivityManager.Stub {
                 // TODO : setting the satisfier is in fact the job of the rematch. Teach the
                 // rematch not to keep disconnected agents instead of setting it here; this
                 // will also allow removing updating the offers below.
+                if (mConstrainedDataSatelliteMetrics && mDefaultNetworkRequests.contains(nri)) {
+                    // Must be called before satisfier changes to get satisfied time.
+                    // See NRI#getSatisfiedTime().
+                    mDefaultNetworkRematchMetrics.addEvent(nri, currentNetwork, null,
+                            mDeps.getElapsedRealtime() - nri.getSatisfiedTime());
+                }
                 nri.setSatisfier(null, null);
+
                 for (final NetworkOfferInfo noi : mNetworkOffers) {
                     informOffer(nri, noi.offer, mNetworkRanker);
                 }
@@ -5611,6 +5837,19 @@ public class ConnectivityService extends IConnectivityManager.Stub {
                 }
             }
         }
+        // This has to be called before rematch because rematch collects and builds
+        // another event. When a default network(1) disconnects, this call reports a
+        // network1->null reassignment for default network requests. A subsequent
+        // rematch (rematchAllNetworksAndRequests) will then report a null->network2
+        // event if a new network(2) takes over as default.
+        // This two-step reporting (network1->null, then null->network2) instead of
+        // a direct network1->network2 is a result of current architectural within
+        // ConnectivityService. This can be resolved if the TODO before setSatisfier
+        // above is fixed.
+        if (mConstrainedDataSatelliteMetrics) {
+            mDefaultNetworkRematchMetrics.writeStatsAndClear(
+                    DEFAULT_NETWORK_REMATCH__REMATCH_REASON__RMR_NETWORK_DISCONNECTED);
+        }
         nai.clearInactivityState();
         // TODO: mLegacyTypeTracker.remove seems redundant given there's a full rematch right after.
         //  Currently, deleting it breaks tests that check for the default network disconnecting.
@@ -5642,8 +5881,14 @@ public class ConnectivityService extends IConnectivityManager.Stub {
 
         // Delayed teardown.
         if (nai.isCreated() && !nai.isDestroyed()) {
+            destroyLiveTcpSocketsLackingPermission(
+                    nai, getNetworkPermission(nai.networkCapabilities), INetd.PERMISSION_SYSTEM);
             try {
                 mNetd.networkSetPermissionForNetwork(nai.network.netId, INetd.PERMISSION_SYSTEM);
+                // Call again in case sockets were opened after the first time : see
+                // updateNetworkPermissions
+                destroyLiveTcpSocketsLackingPermission(nai,
+                        getNetworkPermission(nai.networkCapabilities), INetd.PERMISSION_SYSTEM);
             } catch (RemoteException e) {
                 Log.d(TAG, "Error marking network restricted during teardown: ", e);
             }
@@ -5772,6 +6017,7 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         } catch (RemoteException | ServiceSpecificException e) {
             loge("Exception destroying network(networkDestroy): " + e);
         }
+        updateIpAddressesAndDestroySockets(nai, nai.linkProperties, null);
         try {
             mDnsResolver.destroyNetworkCache(nai.network.getNetId());
         } catch (RemoteException | ServiceSpecificException e) {
@@ -5787,6 +6033,10 @@ public class ConnectivityService extends IConnectivityManager.Stub {
             mDeps.disableIngressRateLimit(nai.linkProperties.getInterfaceName());
         }
 
+        // Removes the interfaces associated with the network being destroyed from the tracker.
+        for (String interfaceName : nai.linkProperties.getAllInterfaceNames()) {
+            mInterfaceTracker.removeInterface(interfaceName);
+        }
         nai.setDestroyed();
         nai.onNetworkDestroyed();
     }
@@ -5975,46 +6225,48 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         // For example, declaring it a potential satisfier would keep an unvalidated destroyed
         // candidate after it's been replaced by another unvalidated network.
         if (candidate.isDestroyed()) return false;
-        // Listen requests won't keep up a network satisfying it. If this is not a multilayer
-        // request, return immediately. For multilayer requests, check to see if any of the
-        // multilayer requests may have a potential satisfier.
-        if (!nri.isMultilayerRequest() && (nri.mRequests.get(0).isListen()
-                || nri.mRequests.get(0).isListenForBest())) {
-            return false;
-        }
+
         for (final NetworkRequest req : nri.mRequests) {
-            // This multilayer listen request is satisfied therefore no further requests need to be
-            // evaluated deeming this network not a potential satisfier.
-            if ((req.isListen() || req.isListenForBest()) && nri.getActiveRequest() == req) {
+            // If the active request is of a type that does not cause the network to be kept up,
+            // the network cannot be a potential satisfier: even if there are requests after this
+            // request in the list, they cannot become the active request, and therefore, cannot
+            // cause this network to be kept up.
+            // Note that this determination can only be made after evaluating previous requests in
+            // the array, because those requests might make the network a potential satisfier even
+            // if they are not currently active (e.g., they might currently be satisfied by another
+            // network with a higher score than this one).
+            if (!req.isRequest() && nri.getActiveRequest() == req) {
                 return false;
             }
-            // As non-multilayer listen requests have already returned, the below would only happen
-            // for a multilayer request therefore continue to the next request if available.
-            if (req.isListen() || req.isListenForBest()) {
-                continue;
-            }
-            // If there is hope for this network might validate and subsequently become the best
-            // network for that request, then it is needed. Note that this network can't already
-            // be the best for this request, or it would be the current satisfier, and therefore
-            // there would be no need to call this method to find out if it is a *potential*
-            // satisfier ("unneeded", the only caller, only calls this if this network currently
-            // satisfies no request).
-            if (candidate.satisfies(req)) {
-                // As soon as a network is found that satisfies a request, return. Specifically for
-                // multilayer requests, returning as soon as a NetworkAgentInfo satisfies a request
-                // is important so as to not evaluate lower priority requests further in
-                // nri.mRequests.
-                final NetworkAgentInfo champion = req.equals(nri.getActiveRequest())
-                        ? nri.getSatisfier() : null;
-                // Note that this catches two important cases:
-                // 1. Unvalidated cellular will not be reaped when unvalidated WiFi
-                //    is currently satisfying the request.  This is desirable when
-                //    cellular ends up validating but WiFi does not.
-                // 2. Unvalidated WiFi will not be reaped when validated cellular
-                //    is currently satisfying the request.  This is desirable when
-                //    WiFi ends up validating and out scoring cellular.
-                return mNetworkRanker.mightBeat(req, champion, candidate.getValidatedScoreable());
-            }
+
+            // This request type does not cause the network to be kept up and therefore does not
+            // cause the network to be a potential satisfier. Later requests in the list might.
+            if (!req.isRequest()) continue;
+
+            // The network can never be a potential satisfier for the request because it does not
+            // satisfy it. Later requests in the list might.
+            if (!candidate.satisfies(req)) continue;
+
+            // This request could cause the network to be kept up if and only if it could become the
+            // best network for the request by validating.
+            // Note that this network can't already be the best for this request, or it would be the
+            // current satisfier. Because this code is only called if the candidate network is
+            // satisfying zero requests, there are only two cases here:
+            // - The request is not being satisfied by any network (i.e., getActiveRequest() is not
+            //   this request).
+            // - The request is satisfied by another network and this network might (or might not)
+            //   beat it by validating.
+            // Note that this catches two important cases:
+            // 1. Unvalidated cellular will not be reaped when unvalidated WiFi
+            //    is currently satisfying the request.  This is desirable when
+            //    cellular ends up validating but WiFi does not.
+            // 2. Unvalidated WiFi will not be reaped when validated cellular
+            //    is currently satisfying the request.  This is desirable when
+            //    WiFi ends up validating and out scoring cellular.
+            if (req != nri.getActiveRequest()) return true;
+
+            final NetworkAgentInfo champion = nri.getSatisfier();
+            return mNetworkRanker.mightBeat(req, champion, candidate.getValidatedScoreable());
         }
 
         return false;
@@ -6643,7 +6895,7 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         pw.println("Config restrict:               " + configRestrict);
         pw.println("Actively prefer bad wifi:      " + activelyPreferBadWifi());
 
-        final String settingValue = mMultinetworkPolicyTracker.getAvoidBadWifiSetting();
+        final String settingValue = mMultinetworkPolicyTracker.readAvoidBadWifiFromSettings();
         String description;
         // Can't use a switch statement because strings are legal case labels, but null is not.
         if ("0".equals(settingValue)) {
@@ -7675,14 +7927,24 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         }
     }
 
-    private void onUserAdded(@NonNull final UserHandle user) {
+    @Override
+    public void onUserAdded(@NonNull final UserHandle user) {
         if (mOemNetworkPreferences.getNetworkPreferences().size() > 0) {
             handleSetOemNetworkPreference(mOemNetworkPreferences, null);
         }
         updateProfileAllowedNetworks();
+        final List<PackageInfo> apps = mContext.getPackageManager()
+                .getInstalledPackagesAsUser(GET_PERMISSIONS, user.getIdentifier());
+        if (mPermissionMonitor.useBroadcastReceiveHelper()) {
+            mPermissionMonitor.onUserAddedWithInstalledPackageList(user, apps);
+        }
+        if (mSatelliteAccessController != null) {
+            mSatelliteAccessController.onUserAddedWithInstalledPackageList(user, apps);
+        }
     }
 
-    private void onUserRemoved(@NonNull final UserHandle user) {
+    @Override
+    public void onUserRemoved(@NonNull final UserHandle user) {
         // If there was a network preference for this user, remove it.
         handleSetProfileNetworkPreference(
                 List.of(new ProfileNetworkPreferenceInfo(user, null, true,
@@ -7691,9 +7953,52 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         if (mOemNetworkPreferences.getNetworkPreferences().size() > 0) {
             handleSetOemNetworkPreference(mOemNetworkPreferences, null);
         }
+        if (mPermissionMonitor.useBroadcastReceiveHelper()) {
+            mPermissionMonitor.onUserRemoved(user);
+        }
+        if (mSatelliteAccessController != null) {
+            mSatelliteAccessController.onUserRemoved(user);
+        }
+    }
+
+    @Override
+    public void onPackageAdded(@NonNull final String packageName, final int uid) {
+        handlePackageChanged(packageName);
+        if (mPermissionMonitor.useBroadcastReceiveHelper()) {
+            mPermissionMonitor.onPackageAdded(packageName, uid);
+        }
+        if (mSatelliteAccessController != null) {
+            mSatelliteAccessController.onPackageAdded(packageName, uid);
+        }
+    }
+
+    @Override
+    public void onPackageRemoved(@NonNull final String packageName, final int uid) {
+        handlePackageChanged(packageName);
+        if (mPermissionMonitor.useBroadcastReceiveHelper()) {
+            mPermissionMonitor.onPackageRemoved(packageName, uid);
+        }
+        if (mSatelliteAccessController != null) {
+            mSatelliteAccessController.onPackageRemoved(packageName, uid);
+        }
+    }
+
+    @Override
+    public void onPackageReplaced(@NonNull final String packageName, final int uid) {
+        handlePackageChanged(packageName);
+    }
+
+    @Override
+    public void onExternalApplicationsAvailable(@Nullable String[] pkgList) {
+        if (mPermissionMonitor.useBroadcastReceiveHelper()) {
+            mPermissionMonitor.onExternalApplicationsAvailable(pkgList);
+        }
+        if (mSatelliteAccessController != null) {
+            mSatelliteAccessController.onExternalApplicationsAvailable((pkgList));
+        }
     }
 
-    private void onPackageChanged(@NonNull final String packageName) {
+    private void handlePackageChanged(@NonNull final String packageName) {
         // This is necessary in case a package is added or removed, but also when it's replaced to
         // run as a new UID by its manifest rules. Also, if a separate package shares the same UID
         // as one in the preferences, then it should follow the same routing as that other package,
@@ -7709,45 +8014,6 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         }
     }
 
-    private final BroadcastReceiver mUserIntentReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            ensureRunningOnConnectivityServiceThread();
-            final String action = intent.getAction();
-            final UserHandle user = intent.getParcelableExtra(Intent.EXTRA_USER);
-
-            // User should be filled for below intents, check the existence.
-            if (user == null) {
-                Log.wtf(TAG, intent.getAction() + " broadcast without EXTRA_USER");
-                return;
-            }
-
-            if (Intent.ACTION_USER_ADDED.equals(action)) {
-                onUserAdded(user);
-            } else if (Intent.ACTION_USER_REMOVED.equals(action)) {
-                onUserRemoved(user);
-            }  else {
-                Log.wtf(TAG, "received unexpected intent: " + action);
-            }
-        }
-    };
-
-    private final BroadcastReceiver mPackageIntentReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            ensureRunningOnConnectivityServiceThread();
-            switch (intent.getAction()) {
-                case Intent.ACTION_PACKAGE_ADDED:
-                case Intent.ACTION_PACKAGE_REMOVED:
-                case Intent.ACTION_PACKAGE_REPLACED:
-                    onPackageChanged(intent.getData().getSchemeSpecificPart());
-                    break;
-                default:
-                    Log.wtf(TAG, "received unexpected intent: " + intent.getAction());
-            }
-        }
-    };
-
     @RequiresApi(Build.VERSION_CODES.TIRAMISU)
     private final BroadcastReceiver mDataSaverReceiver = new BroadcastReceiver() {
         @Override
@@ -7827,8 +8093,7 @@ public class ConnectivityService extends IConnectivityManager.Stub {
      * Tracks info about the requester.
      * Also used to notice when the calling process dies so as to self-expire
      */
-    @VisibleForTesting
-    protected class NetworkRequestInfo implements IBinder.DeathRecipient {
+    public class NetworkRequestInfo implements IBinder.DeathRecipient {
         // The requests to be satisfied in priority order. Non-multilayer requests will only have a
         // single NetworkRequest in mRequests.
         final List<NetworkRequest> mRequests;
@@ -7862,6 +8127,7 @@ public class ConnectivityService extends IConnectivityManager.Stub {
                 @Nullable final NetworkRequest activeRequest) {
             mSatisfier = satisfier;
             mActiveRequest = activeRequest;
+            mSatisfiedTime = mDeps.getElapsedRealtime();
         }
 
         // The network currently satisfying this NRI. Only one request in an NRI can have a
@@ -7872,6 +8138,16 @@ public class ConnectivityService extends IConnectivityManager.Stub {
             return mSatisfier;
         }
 
+        private long mSatisfiedTime = mDeps.getElapsedRealtime();
+
+        /**
+         * Get timestamp (SystemClock.elapsedRealtime()) when is set or removed.
+         * Resets when the satisfier changes.
+         */
+        public long getSatisfiedTime() {
+            return mSatisfiedTime;
+        }
+
         // The request in mRequests assigned to a network agent. This is null if none of the
         // requests in mRequests can be satisfied. This member has the constraint of only being
         // accessible on the handler thread.
@@ -7956,76 +8232,75 @@ public class ConnectivityService extends IConnectivityManager.Stub {
          * Get the list of UIDs this nri applies to.
          */
         @NonNull
-        Set<UidRange> getUids() {
+        public Set<UidRange> getUids() {
             // networkCapabilities.getUids() returns a defensive copy.
             // multilayer requests will all have the same uids so return the first one.
             final Set<UidRange> uids = mRequests.get(0).networkCapabilities.getUidRanges();
             return (null == uids) ? new ArraySet<>() : uids;
         }
 
-        NetworkRequestInfo(int asUid, @NonNull final NetworkRequest r,
-                @Nullable final PendingIntent pi, @Nullable String callingAttributionTag) {
-            this(asUid, Collections.singletonList(r), r, pi, callingAttributionTag,
-                    PREFERENCE_ORDER_INVALID);
-        }
-
-        NetworkRequestInfo(int asUid, @NonNull final List<NetworkRequest> r,
+        /** Internal-only constructor, used by the other constructors. */
+        private NetworkRequestInfo(int asUid, @NonNull final List<NetworkRequest> r,
                 @NonNull final NetworkRequest requestForCallback, @Nullable final PendingIntent pi,
+                @Nullable Messenger messenger, @Nullable IBinder binder,
+                @NetworkCallback.Flag int callbackFlags, int declaredMethodsFlags,
                 @Nullable String callingAttributionTag, final int preferenceOrder) {
+            if (pi != null) {
+                // Got passed a PendingIntent.
+                if (messenger != null || binder != null
+                        || callbackFlags != NetworkCallback.FLAG_NONE
+                        || declaredMethodsFlags != DECLARED_METHODS_NONE) {
+                    throw new IllegalArgumentException(
+                            "NRI with PendingIntent cannot pass in callback parameters");
+                }
+            }
             ensureAllNetworkRequestsHaveSupportedType(r);
             mRequests = initializeRequests(r);
             mNetworkRequestForCallback = requestForCallback;
             mPendingIntent = pi;
-            mMessenger = null;
-            mBinder = null;
+            mMessenger = messenger;
+            mBinder = binder;
             mPid = getCallingPid();
             mUid = mDeps.getCallingUid();
             mAsUid = asUid;
             mPerUidCounter = getRequestCounter(this);
-            /**
-             * Location sensitive data not included in pending intent. Only included in
-             * {@link NetworkCallback}.
-             */
-            mCallbackFlags = NetworkCallback.FLAG_NONE;
+            mCallbackFlags = callbackFlags;
             mCallingAttributionTag = callingAttributionTag;
             mPreferenceOrder = preferenceOrder;
-            mDeclaredMethodsFlags = DECLARED_METHODS_NONE;
+            mDeclaredMethodsFlags = declaredMethodsFlags;
+            linkDeathRecipient();
         }
 
-        NetworkRequestInfo(int asUid, @NonNull final NetworkRequest r, @Nullable final Messenger m,
-                @Nullable final IBinder binder,
-                @NetworkCallback.Flag int callbackFlags,
-                @Nullable String callingAttributionTag, int declaredMethodsFlags) {
-            this(asUid, Collections.singletonList(r), r, m, binder, callbackFlags,
-                    callingAttributionTag, declaredMethodsFlags);
+        /** Constructs a NetworkRequestInfo for a PendingIntent-based API */
+        NetworkRequestInfo(int asUid, @NonNull final NetworkRequest request,
+                @Nullable final PendingIntent pi, @Nullable String callingAttributionTag) {
+            this(asUid, Collections.singletonList(request), request, pi, null /* messenger */,
+                    null /* binder */, NetworkCallback.FLAG_NONE, DECLARED_METHODS_NONE,
+                    callingAttributionTag, PREFERENCE_ORDER_INVALID);
         }
 
+        /* Constructs a NetworkRequestInfo for a NetworkCallback-based API */
         NetworkRequestInfo(int asUid, @NonNull final List<NetworkRequest> r,
                 @NonNull final NetworkRequest requestForCallback, @Nullable final Messenger m,
-                @Nullable final IBinder binder,
+                @Nullable final IBinder b,
                 @NetworkCallback.Flag int callbackFlags,
                 @Nullable String callingAttributionTag, int declaredMethodsFlags) {
-            super();
-            ensureAllNetworkRequestsHaveSupportedType(r);
-            mRequests = initializeRequests(r);
-            mNetworkRequestForCallback = requestForCallback;
-            mMessenger = m;
-            mBinder = binder;
-            mPid = getCallingPid();
-            mUid = mDeps.getCallingUid();
-            mAsUid = asUid;
-            mPendingIntent = null;
-            mPerUidCounter = getRequestCounter(this);
-            mCallbackFlags = callbackFlags;
-            mCallingAttributionTag = callingAttributionTag;
-            mPreferenceOrder = PREFERENCE_ORDER_INVALID;
-            mDeclaredMethodsFlags = declaredMethodsFlags;
-            linkDeathRecipient();
+            // In multilayer request, or for a TRACK_DEFAULT request that tracks a per-app default
+            // network, requestForCallback is not the same as the first request.
+            this(asUid, r, requestForCallback, null /* pi */, m, b, callbackFlags,
+                    declaredMethodsFlags, callingAttributionTag, PREFERENCE_ORDER_INVALID);
+        }
+
+        /* Constructs a NetworkRequestInfo for internal system usage */
+        NetworkRequestInfo(int asUid, @NonNull final List<NetworkRequest> r, int preferenceOrder) {
+            this(asUid, r, r.get(0), null /* pi */, null /* messenger */,
+                    null /* binder */, NetworkCallback.FLAG_NONE, DECLARED_METHODS_NONE,
+                    null /* callingAttributionTag */, preferenceOrder);
+
         }
 
         NetworkRequestInfo(@NonNull final NetworkRequestInfo nri,
                 @NonNull final List<NetworkRequest> r) {
-            super();
             ensureAllNetworkRequestsHaveSupportedType(r);
             mRequests = initializeRequests(r);
             mNetworkRequestForCallback = nri.getNetworkRequestForCallback();
@@ -8049,6 +8324,7 @@ public class ConnectivityService extends IConnectivityManager.Stub {
                 }
                 setSatisfier(satisfier, activeRequest);
             }
+            mSatisfiedTime = nri.mSatisfiedTime;
             mMatchedNetIdWhenFrozen = nri.mMatchedNetIdWhenFrozen;
             mQueuedCallbacks = nri.mQueuedCallbacks;
             mMessenger = nri.mMessenger;
@@ -8066,16 +8342,6 @@ public class ConnectivityService extends IConnectivityManager.Stub {
             linkDeathRecipient();
         }
 
-        NetworkRequestInfo(int asUid, @NonNull final NetworkRequest r) {
-            this(asUid, Collections.singletonList(r), PREFERENCE_ORDER_INVALID);
-        }
-
-        NetworkRequestInfo(int asUid, @NonNull final List<NetworkRequest> r,
-                final int preferenceOrder) {
-            this(asUid, r, r.get(0), null /* pi */, null /* callingAttributionTag */,
-                    preferenceOrder);
-        }
-
         // True if this NRI is being satisfied. It also accounts for if the nri has its satisifer
         // set to the mNoServiceNetwork in which case mActiveRequest will be null thus returning
         // false.
@@ -8304,7 +8570,8 @@ public class ConnectivityService extends IConnectivityManager.Stub {
             return mPreferenceOrder < target.mPreferenceOrder;
         }
 
-        int getPreferenceOrderForNetd() {
+        /** Return the preference order. */
+        public int getPreferenceOrderForNetd() {
             if (mPreferenceOrder >= PREFERENCE_ORDER_NONE
                     && mPreferenceOrder <= PREFERENCE_ORDER_LOWEST) {
                 return mPreferenceOrder;
@@ -8804,10 +9071,21 @@ public class ConnectivityService extends IConnectivityManager.Stub {
             // Policy already enforced.
             return;
         }
-        final boolean isRestrictedOnMeteredNetworks = mDeps.isAtLeastV()
-                ? mBpfNetMaps.isUidRestrictedOnMeteredNetworks(uid)
-                : BinderUtils.withCleanCallingIdentity(() ->
-                        mPolicyManager.isUidRestrictedOnMeteredNetworks(uid));
+        final boolean isRestrictedOnMeteredNetworks;
+        if (mDeps.isAtLeastV()) {
+            if (mDeps.isChangeEnabled(NETWORK_BLOCKED_WITHOUT_INTERNET_PERMISSION, uid)) {
+                isRestrictedOnMeteredNetworks =
+                        mBpfNetMaps.isUidRestrictedOnMeteredNetworks(uid);
+            } else {
+                // If the change is disabled and the uid does not have Internet permission,
+                // uid is considered to be allowed to bring up metered networks.
+                isRestrictedOnMeteredNetworks = hasInternetPermission(uid)
+                        && mBpfNetMaps.isUidRestrictedOnMeteredNetworks(uid);
+            }
+        } else {
+            isRestrictedOnMeteredNetworks = BinderUtils.withCleanCallingIdentity(() ->
+                    mPolicyManager.isUidRestrictedOnMeteredNetworks(uid));
+        }
         if (isRestrictedOnMeteredNetworks) {
             // If UID is restricted, don't allow them to bring up metered APNs.
             networkCapabilities.addCapability(NET_CAPABILITY_NOT_METERED);
@@ -8976,7 +9254,8 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(),
                 NetworkRequest.Type.LISTEN);
         NetworkRequestInfo nri =
-                new NetworkRequestInfo(callingUid, networkRequest, messenger, binder, callbackFlags,
+                new NetworkRequestInfo(callingUid, Collections.singletonList(networkRequest),
+                        networkRequest, messenger, binder, callbackFlags,
                         callingAttributionTag, declaredMethodsFlag);
         if (VDBG) log("listenForNetwork for " + nri);
 
@@ -9528,7 +9807,7 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         nai.notifyRegistered(networkMonitor);
         NetworkInfo networkInfo = nai.networkInfo;
         updateNetworkInfo(nai, networkInfo);
-        if (nai.isVPN()) updateVpnUids(nai, null, nai.networkCapabilities);
+        maybeUpdateVpnUids(nai, null, nai.networkCapabilities);
         nai.processEnqueuedMessages(mTrackerHandler::handleMessage);
     }
 
@@ -9759,12 +10038,104 @@ public class ConnectivityService extends IConnectivityManager.Stub {
             }
             networkAgent.networkMonitor().notifyLinkPropertiesChanged(
                     new LinkProperties(newLp, true /* parcelSensitiveFields */));
+            updateIpAddressesAndDestroySockets(networkAgent, oldLp, newLp);
             notifyNetworkCallbacks(networkAgent, CALLBACK_IP_CHANGED);
         }
 
         mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
     }
 
+    private void updateIpAddressesAndDestroySockets(
+            NetworkAgentInfo nai, LinkProperties oldLp, LinkProperties newLp) {
+        ensureRunningOnConnectivityServiceThread();
+        if (mIpToNetworksMap == null) {
+            return;
+        }
+
+        final CompareResult<LinkAddress> result =
+                LinkPropertiesUtils.compareAllAddresses(oldLp, newLp);
+
+        if (!result.added.isEmpty()) {
+            for (LinkAddress la : result.added) {
+                if (la.getAddress() instanceof Inet6Address
+                        && la.getAddress().isLinkLocalAddress()) {
+                    // Some NetworkAgents may not report IPv6 link local address to CS, thus socket
+                    // destruction on the address will be done at handling RTM_DELADDR and the
+                    // address doesn't need to be added to mIpToNetworksMap.
+                    continue;
+                }
+                mIpToNetworksMap.computeIfAbsent(la.getAddress(), k -> new ArraySet<>()).add(nai);
+            }
+        }
+
+        if (!result.removed.isEmpty()) {
+            for (LinkAddress la : result.removed) {
+                if (la.getAddress() instanceof Inet6Address
+                        && la.getAddress().isLinkLocalAddress()) {
+                    continue;
+                }
+                final Set<NetworkAgentInfo> networks = mIpToNetworksMap.get(la.getAddress());
+                destroySocketsForRemovedAddress(la.getAddress(), nai, networks);
+                if (networks != null) {
+                    networks.remove(nai);
+                    if (networks.isEmpty()) {
+                        mIpToNetworksMap.remove(la.getAddress());
+                    }
+                }
+            }
+        }
+    }
+
+    private void destroySocketsForRemovedAddress(
+            InetAddress address,
+            @NonNull NetworkAgentInfo targetNai,
+            @NonNull Set<NetworkAgentInfo> networks) {
+        // Logic to destroy sockets(MIN_NET_ID ~ MAX_NET_ID) on networks managed by this service
+        // when IP addresses are removed. Sockets(0 ~ MIN_NET_ID - 1) are for OEM network or legacy
+        // local network. Those are not tracked by this service, thus will be destroyed at the
+        // RTM_DELADDR event handling.
+        final Set<Range<Integer>> netIdRangeSet;
+        final Set<Range<Integer>> uidRangeSet;
+        if (networks.size() == 1) {
+            // Removed IP address was in single network.
+            netIdRangeSet = Set.of(Range.create(MIN_NET_ID, MAX_NET_ID));
+            uidRangeSet = null;
+        } else if (CollectionUtils.all(networks, nai -> !nai.isVPN())) {
+            // If all networks are not VPNs, other networks with the same IP address can be exempted
+            // from this socket destruction. Since there may be remaining socket's which has Fwmark
+            // matched to previously disconnected VPN's netId, It's intended destroying sockets not
+            // matched to exempt networks rather than sockets matched to the target network.
+            final List<Integer> exemptNetIds = new ArrayList<>();
+            for (NetworkAgentInfo nai : networks) {
+                if (nai.network.netId != targetNai.network.netId) {
+                    exemptNetIds.add(nai.network.netId);
+                }
+            }
+            netIdRangeSet = IntegerRangeUtils.rangeWithoutValues(
+                    Range.create(MIN_NET_ID, MAX_NET_ID), exemptNetIds);
+            uidRangeSet = null;
+        } else if (CollectionUtils.all(networks, NetworkAgentInfo::isVPN)) {
+            // Since the UID ranges of VPN networks cannot overlap with each other, if all networks
+            // with the corresponding address were VPNs, sockets included in the UID range of the
+            // target network are selectively removed.
+            netIdRangeSet = Set.of(Range.create(MIN_NET_ID, MAX_NET_ID));
+            uidRangeSet = targetNai.networkCapabilities.getUids();
+        } else {
+            // If there is at least one VPN network among multiple networks with the same address,
+            // there may be sockets with Fwmark value which does not match the netId (e.g. Socket
+            // connections on non-bypassable VPN or socket connections fallen out of split tunnel
+            // for the bypassable VPN), and it is currently too complicated to distinguish them.
+            // Thus sockets in whole netId range will be destroyed based on local IP address.
+            netIdRangeSet = Set.of(Range.create(MIN_NET_ID, MAX_NET_ID));
+            uidRangeSet = null;
+        }
+        try {
+            mDeps.destroyLiveTcpSocketsByLocalAddress(address, netIdRangeSet, uidRangeSet);
+        } catch (SocketException | InterruptedIOException | ErrnoException e) {
+            loge("Exception destroy TCP sockets on local address: ", e);
+        }
+    }
+
     private void applyInitialLinkProperties(@NonNull NetworkAgentInfo nai) {
         updateLinkProperties(nai, new LinkProperties(nai.linkProperties), null);
     }
@@ -10323,8 +10694,14 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         final int oldPermission = getNetworkPermission(nai.networkCapabilities);
         final int newPermission = getNetworkPermission(newNc);
         if (oldPermission != newPermission && nai.isCreated() && !nai.isVPN()) {
+            destroyLiveTcpSocketsLackingPermission(nai, oldPermission, newPermission);
             try {
                 mNetd.networkSetPermissionForNetwork(nai.network.getNetId(), newPermission);
+                // Destroy sockets again in case any were opened after
+                // destroySocketsLackingPermission is called above and before the permissions is
+                // changed. These sockets won't be able to send any RST packets because they are now
+                // no longer routed, but at least the apps will get errors.
+                destroyLiveTcpSocketsLackingPermission(nai, oldPermission, newPermission);
             } catch (RemoteException | ServiceSpecificException e) {
                 loge("Exception in networkSetPermissionForNetwork: " + e);
             }
@@ -10545,7 +10922,7 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         updateNetworkPermissions(nai, newNc);
         final NetworkCapabilities prevNc = nai.getAndSetNetworkCapabilities(newNc);
 
-        updateVpnUids(nai, prevNc, newNc);
+        maybeUpdateVpnUids(nai, prevNc, newNc);
         updateAllowedUids(nai, prevNc, newNc);
         nai.updateScoreForNetworkAgentUpdate();
 
@@ -10715,10 +11092,8 @@ public class ConnectivityService extends IConnectivityManager.Stub {
             final NetworkRequest nr = new NetworkRequest(newCaps, ConnectivityManager.TYPE_NONE,
                     nextNetworkRequestId(), LISTEN_FOR_BEST);
             configBuilder.setUpstreamSelector(nr);
-            final NetworkRequestInfo nri = new NetworkRequestInfo(
-                    nai.creatorUid, nr, null /* messenger */, null /* binder */,
-                    0 /* callbackFlags */, null /* attributionTag */,
-                    DECLARED_METHODS_NONE);
+            final NetworkRequestInfo nri = new NetworkRequestInfo(nai.creatorUid,
+                    Collections.singletonList(nr), PREFERENCE_ORDER_INVALID);
             if (null != oldSatisfier) {
                 // Set the old satisfier in the new NRI so that the rematch will see any changes
                 nri.setSatisfier(oldSatisfier, nr);
@@ -10897,8 +11272,9 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         }
     }
 
-    private void updateVpnUids(@NonNull NetworkAgentInfo nai, @Nullable NetworkCapabilities prevNc,
-            @Nullable NetworkCapabilities newNc) {
+    private void maybeUpdateVpnUids(@NonNull NetworkAgentInfo nai,
+            @Nullable NetworkCapabilities prevNc, @Nullable NetworkCapabilities newNc) {
+        if (!nai.isVPN()) return;
         Set<UidRange> prevRanges = null == prevNc ? null : prevNc.getUidRanges();
         Set<UidRange> newRanges = null == newNc ? null : newNc.getUidRanges();
         if (null == prevRanges) prevRanges = new ArraySet<>();
@@ -11319,6 +11695,22 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         }
     }
 
+    private void writeStatsForDefaultNetworkChanges(@NonNull final NetworkReassignment changes) {
+        if (!mConstrainedDataSatelliteMetrics) return;
+        for (final NetworkRequestInfo defaultRequestInfo : mDefaultNetworkRequests) {
+            final NetworkReassignment.RequestReassignment reassignment =
+                    changes.getReassignment(defaultRequestInfo);
+            if (null == reassignment) {
+                continue;
+            }
+            mDefaultNetworkRematchMetrics.addEvent(defaultRequestInfo,
+                    reassignment.mOldNetwork, reassignment.mNewNetwork,
+                    mDeps.getElapsedRealtime() - defaultRequestInfo.getSatisfiedTime());
+        }
+        // TODO: fill rematch reason.
+        mDefaultNetworkRematchMetrics.writeStatsAndClear();
+    }
+
     private void resetHttpProxyForNonDefaultNetwork(NetworkAgentInfo oldDefaultNetwork) {
         if (null == oldDefaultNetwork) return;
         // The network stopped being the default. If it was using a PAC proxy, then the
@@ -11757,7 +12149,11 @@ public class ConnectivityService extends IConnectivityManager.Stub {
             if (nai.isBackgroundNetwork()) oldBgNetworks.add(nai);
         }
 
-        // First, update the lists of satisfied requests in the network agents. This is necessary
+        // This needs to be called before NRI#setSatisfier() because the NRI#getSatisfiedTime()
+        // will be reset when that happens.
+        writeStatsForDefaultNetworkChanges(changes);
+
+        // Update the lists of satisfied requests in the network agents. This is necessary
         // because some code later depends on this state to be correct, most prominently computing
         // the linger status.
         for (final NetworkReassignment.RequestReassignment event :
@@ -12149,7 +12545,8 @@ public class ConnectivityService extends IConnectivityManager.Stub {
             // interfaces and routing rules have been added, DNS servers programmed, etc.
             // For VPNs, this must be done before the capabilities are updated, because as soon as
             // that happens, UIDs are routed to the network.
-            if (shouldCreateNetworksImmediately(networkAgent.getCapsNoCopy())) {
+            if (shouldCreateNetworksImmediately(networkAgent.getCapsNoCopy())
+                    || shouldUpdateLinkPropertiesEarlyForVPNNetwork(networkAgent)) {
                 applyInitialLinkProperties(networkAgent);
             }
 
@@ -12174,7 +12571,8 @@ public class ConnectivityService extends IConnectivityManager.Stub {
             networkAgent.getAndSetNetworkCapabilities(networkAgent.networkCapabilities);
 
             handlePerNetworkPrivateDnsConfig(networkAgent, mDnsManager.getPrivateDnsConfig());
-            if (!shouldCreateNetworksImmediately(networkAgent.getCapsNoCopy())) {
+            if (!(shouldCreateNetworksImmediately(networkAgent.getCapsNoCopy())
+                    || shouldUpdateLinkPropertiesEarlyForVPNNetwork(networkAgent))) {
                 applyInitialLinkProperties(networkAgent);
             } else {
                 // The network was created when the agent registered, and the LinkProperties are
@@ -12280,9 +12678,7 @@ public class ConnectivityService extends IConnectivityManager.Stub {
             if (!mQueueNetworkAgentEventsInSystemServer) {
                 networkAgent.disconnect();
             }
-            if (networkAgent.isVPN()) {
-                updateVpnUids(networkAgent, networkAgent.networkCapabilities, null);
-            }
+            maybeUpdateVpnUids(networkAgent, networkAgent.networkCapabilities, null);
             disconnectAndDestroyNetwork(networkAgent);
             if (networkAgent.isVPN()) {
                 // As the active or bound network changes for apps, broadcast the default proxy, as
@@ -12711,6 +13107,32 @@ public class ConnectivityService extends IConnectivityManager.Stub {
             }
         }
 
+        private void setDebugFallbackNetworkForUid(int uid, int transportType) {
+            final NetworkCapabilities nc = new NetworkCapabilities()
+                    .addTransportType(transportType)
+                    .addCapability(NET_CAPABILITY_INTERNET)
+                    .removeCapability(NET_CAPABILITY_NOT_RESTRICTED)
+                    .removeCapability(NET_CAPABILITY_NOT_BANDWIDTH_CONSTRAINED);
+            Set<Integer> uids = Set.of(uid);
+            Set<NetworkRequestInfo> nris = createNrisForFallbackDefault(uids, nc,
+                    PREFERENCE_ORDER_DEBUG_FALLBACK);
+            addPerAppDefaultNetworkRequests(nris);
+        }
+
+        private void clearDebugFallbackNetworkForUid(int uid) {
+            removeDefaultNetworkRequests((nri) ->
+                    nri.getPreferenceOrderForNetd() == PREFERENCE_ORDER_DEBUG_FALLBACK
+                    && nri.getUids().equals(Set.of(new UidRange(uid, uid))));
+            // Calling addPerAppDefaultNetworkRequests with an empty set here is necessary to
+            // make sure that the default network callbacks filed by this UID track the
+            // correct default network request.
+            // ConnectivityService makes sure that default network callbacks filed by UIDs track
+            // the correct default requests by removing and re-filing all of these requests
+            // whenever any of the default requests change. This work is done by
+            // addPerAppDefaultNetworkRequests. See its implementation for details.
+            addPerAppDefaultNetworkRequests(new ArraySet<>());
+        }
+
         @Override
         public int onCommand(String cmd) {
             if (cmd == null) {
@@ -12859,6 +13281,24 @@ public class ConnectivityService extends IConnectivityManager.Stub {
                         pw.println(ret);
                         return 0;
                     }
+                    case "set-debug-fallback-network-for-uid":
+                    case "clear-debug-fallback-network-for-uid": {
+                        if (!Build.isDebuggable()) {
+                            throw new SecurityException(
+                                    "Setting per-UID fallback network requires debuggable build");
+                        }
+                        final int uid = Integer.parseInt(getNextArg());
+                        boolean set = cmd.startsWith("set");
+                        final int transportType = set ? Integer.parseInt(getNextArg()) : TYPE_NONE;
+                        mHandler.post(() -> {
+                            clearDebugFallbackNetworkForUid(uid);
+                            if (set) {
+                                setDebugFallbackNetworkForUid(uid, transportType);
+                            }
+                            rematchAllNetworksAndRequests();
+                        });
+                        return 0;
+                    }
                     default:
                         return handleDefaultCommands(cmd);
                 }
@@ -12891,6 +13331,13 @@ public class ConnectivityService extends IConnectivityManager.Stub {
             pw.println("    Set the allow bit in FIREWALL_CHAIN_BACKGROUND for the given uid.");
             pw.println("  get-background-networking-enabled-for-uid [uid]");
             pw.println("    Get the allow bit in FIREWALL_CHAIN_BACKGROUND for the given uid.");
+            if (Build.isDebuggable()) {
+                pw.println("  set-debug-fallback-network-for-uid [uid] [transport]");
+                pw.println("    Sets [uid] to use [transport] as its default network when there is"
+                        + " no system default network.");
+                pw.println("  clear-per-debug-fallback-network-for-uid [uid]");
+                pw.println("    Clears a previous set-debug-fallback-network-for-uid command");
+            }
         }
     }
 
@@ -13463,7 +13910,8 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         // nri is not bound to the death of callback. Instead, callback.bindToDeath() is set in
         // handleRegisterConnectivityDiagnosticsCallback(). nri will be cleaned up as part of the
         // callback's binder death.
-        final NetworkRequestInfo nri = new NetworkRequestInfo(callingUid, requestWithId);
+        final NetworkRequestInfo nri = new NetworkRequestInfo(callingUid /* asUid */,
+                Collections.singletonList(requestWithId), PREFERENCE_ORDER_INVALID);
         nri.mPerUidCounter.incrementCountOrThrow(nri.mUid);
         final ConnectivityDiagnosticsCallbackInfo cbInfo =
                 new ConnectivityDiagnosticsCallbackInfo(callback, nri, callingPackageName);
@@ -14324,25 +14772,45 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         );
     }
 
-    ArraySet<NetworkRequestInfo> createMultiLayerNrisFromSatelliteNetworkFallbackUids(
-            @NonNull final Set<Integer> uids) {
+    ArraySet<NetworkRequestInfo> createNrisForFallbackDefault(
+            @NonNull final Set<Integer> uids, NetworkCapabilities cap, int preferenceOrder) {
         final List<NetworkRequest> requests = new ArrayList<>();
 
         // request: track default(unrestricted internet network)
         requests.add(createDefaultInternetRequestForTransport(
                 TYPE_NONE, NetworkRequest.Type.TRACK_DEFAULT));
 
-        // request: Satellite internet, satellite network could be restricted or constrained
-        final NetworkCapabilities cap = new NetworkCapabilities.Builder()
+        requests.add(createNetworkRequest(NetworkRequest.Type.REQUEST, cap));
+        return createNrisForPreferenceOrder(uids, requests, preferenceOrder);
+    }
+
+    ArraySet<NetworkRequestInfo> createMultiLayerNrisFromSatelliteNetworkFallbackUids(
+            @NonNull final Set<Integer> messagingRoleUids,
+            @NonNull final Set<Integer> optinUids
+    ) {
+        // The messaging role UIDs should use any Internet-providing satellite network as
+        // a fallback, even if it is restricted.
+        final NetworkCapabilities messagingCap = new NetworkCapabilities.Builder()
                 .addCapability(NET_CAPABILITY_INTERNET)
                 .addCapability(NET_CAPABILITY_NOT_VCN_MANAGED)
                 .removeCapability(NET_CAPABILITY_NOT_RESTRICTED)
                 .removeCapability(NET_CAPABILITY_NOT_BANDWIDTH_CONSTRAINED)
                 .addTransportType(NetworkCapabilities.TRANSPORT_SATELLITE)
                 .build();
-        requests.add(createNetworkRequest(NetworkRequest.Type.REQUEST, cap));
+        final ArraySet<NetworkRequestInfo> requests = createNrisForFallbackDefault(
+                messagingRoleUids, messagingCap, PREFERENCE_ORDER_SATELLITE_FALLBACK);
 
-        return createNrisForPreferenceOrder(uids, requests, PREFERENCE_ORDER_SATELLITE_FALLBACK);
+        // The apps that have opt-in should use any Internet-providing satellite network
+        // as a fallback, but not if it is restricted.
+        final NetworkCapabilities optinCap = new NetworkCapabilities.Builder()
+                .addCapability(NET_CAPABILITY_INTERNET)
+                .addCapability(NET_CAPABILITY_NOT_VCN_MANAGED)
+                .removeCapability(NET_CAPABILITY_NOT_BANDWIDTH_CONSTRAINED)
+                .addTransportType(NetworkCapabilities.TRANSPORT_SATELLITE)
+                .build();
+        requests.addAll(createNrisForFallbackDefault(
+                optinUids, optinCap, PREFERENCE_ORDER_SATELLITE_FALLBACK));
+        return requests;
     }
 
     private void handleMobileDataPreferredUidsChanged() {
@@ -14355,10 +14823,12 @@ public class ConnectivityService extends IConnectivityManager.Stub {
     }
 
     private void handleSetSatelliteNetworkPreference(
-            @NonNull final Set<Integer> satelliteNetworkPreferredUids) {
+            @NonNull final Set<Integer> messagingRoleUids,
+            @NonNull final Set<Integer> optinUids
+    ) {
         removeDefaultNetworkRequestsForPreference(PREFERENCE_ORDER_SATELLITE_FALLBACK);
         addPerAppDefaultNetworkRequests(
-                createMultiLayerNrisFromSatelliteNetworkFallbackUids(satelliteNetworkPreferredUids)
+                createMultiLayerNrisFromSatelliteNetworkFallbackUids(messagingRoleUids, optinUids)
         );
         // Finally, rematch.
         rematchAllNetworksAndRequests();
@@ -14552,17 +15022,39 @@ public class ConnectivityService extends IConnectivityManager.Stub {
         }
     }
 
+    /** Removes all default network requests matching the specified filter. */
+    private void removeDefaultNetworkRequests(Predicate<NetworkRequestInfo> filter) {
+        // Remove all requests in mDefaultNetworkRequests except the ones that match the filter.
+        final Set<NetworkRequestInfo> toRemove = new ArraySet<>(mDefaultNetworkRequests);
+        toRemove.removeIf(filter.negate());
+        handleRemoveNetworkRequests(toRemove);
+    }
+
     private void removeDefaultNetworkRequestsForPreference(final int preferenceOrder) {
-        // Skip the requests which are set by other network preference. Because the uid range rules
-        // should stay in netd.
-        final Set<NetworkRequestInfo> requests = new ArraySet<>(mDefaultNetworkRequests);
-        requests.removeIf(request -> request.mPreferenceOrder != preferenceOrder);
-        handleRemoveNetworkRequests(requests);
+        removeDefaultNetworkRequests((nri) -> nri.mPreferenceOrder == preferenceOrder);
     }
 
+    /**
+     * Add a list of NRIs as default requests, and update per-app callbacks that track them.
+     */
+    // TODO : this method gathers and updates the callbacks tracking the per-app NRIs, which
+    // is confusing for a method called "add". Importantly, callers of the
+    // removeDefaultNetworkRequest* methods above must call this after they call the remove
+    // method, or any callback tracking a removed method will not be updated.
+    // Adding the defaults to mDefaultNetworkRequests must happen before gathering the callbacks
+    // to update, but registering the nris in the argument must happen after doing so.
     private void addPerAppDefaultNetworkRequests(@NonNull final Set<NetworkRequestInfo> nris) {
         ensureRunningOnConnectivityServiceThread();
         mDefaultNetworkRequests.addAll(nris);
+        // getPerAppCallbackRequestsToUpdate gathers all the per-app callbacks that either
+        // - have been tracking a per-app default nri so far (see isPerAppTrackedNri), or
+        // - should now be tracking a per-app default nri (which is why mDefaultNetworkRequests
+        //   need to be updated before calling it).
+        // All of these requests will be removed below and re-created in such a way as to
+        // now track the new default nri for this UID (including if this is the system
+        // default nri), by copying the list of requests in the default nri, but copying
+        // the callbackForRequest (so it can continue updating the same callback) and the
+        // current satisfier (so the rematch will know what the old satisfier was).
         final ArraySet<NetworkRequestInfo> perAppCallbackRequestsToUpdate =
                 getPerAppCallbackRequestsToUpdate();
         final ArraySet<NetworkRequestInfo> nrisToRegister = new ArraySet<>(nris);
@@ -15121,8 +15613,91 @@ public class ConnectivityService extends IConnectivityManager.Stub {
                 return mIngressToVpnAddressFiltering;
             case QUEUE_NETWORK_AGENT_EVENTS_IN_SYSTEM_SERVER:
                 return mQueueNetworkAgentEventsInSystemServer;
+            case CLOSE_QUIC_CONNECTION:
+                return mCloseQuicConnection;
             default:
                 throw new IllegalArgumentException("Unknown flag: " + featureFlag);
         }
     }
+
+    @Override
+    public void registerQuicConnectionClosePayload(final ParcelFileDescriptor pfd,
+            final byte[] payload) {
+        if (!mCloseQuicConnection) {
+            IoUtils.closeQuietly(pfd);
+            return;
+        }
+        // pfd is closed by registerQuicConnectionClosePayload
+        mQuicConnectionCloser.registerQuicConnectionClosePayload(mDeps.getCallingUid(),
+                pfd, payload);
+    }
+
+    @Override
+    public void unregisterQuicConnectionClosePayload(final ParcelFileDescriptor pfd) {
+        if (!mCloseQuicConnection) {
+            IoUtils.closeQuietly(pfd);
+            return;
+        }
+        // pfd is closed by unregisterQuicConnectionClosePayload
+        mQuicConnectionCloser.unregisterQuicConnectionClosePayload(pfd);
+    }
+
+    // Currently this only handles message type RTM_DELADDR to destroy sockets for the deleted
+    // address, we could make this a dispatcher method if we have more use cases in the future.
+    private void processNetlinkAddressUpdateMessage(NetlinkMessage nlMsg) {
+        if (!(nlMsg instanceof RtNetlinkAddressMessage msg)) {
+            return;
+        }
+        if (msg.getHeader().nlmsg_type != NetlinkConstants.RTM_DELADDR) {
+            return;
+        }
+
+        final StructIfaddrMsg ifaddrMsg = msg.getIfaddrHeader();
+        final InetAddress removedAddress = msg.getIpAddress();
+        if (removedAddress instanceof Inet6Address && removedAddress.isLinkLocalAddress()) {
+            try {
+                mDeps.destroyLiveTcpSocketsByLocalAddress(removedAddress, ifaddrMsg.index);
+            } catch (SocketException | InterruptedIOException | ErrnoException e) {
+                loge("Exception destroying TCP sockets on local address with interfaceId: ", e);
+            }
+        } else {
+            // Range of netId for networks that ConnectivityService isn't aware of. OEM & legacy
+            // local networks are included in this scope.
+            try {
+                mDeps.destroyLiveTcpSocketsByLocalAddress(
+                        removedAddress,
+                        Set.of(Range.create(0, MIN_NET_ID - 1)), null /* uidRanges */
+                );
+            } catch (SocketException | InterruptedIOException | ErrnoException e) {
+                loge("Exception destroy TCP sockets on local address: ", e);
+            }
+        }
+    }
+
+    private void destroyLiveTcpSocketsLackingPermission(
+            NetworkAgentInfo nai, int oldPermission, int newPermission) {
+        if (!mDeps.flagConnectivityServiceDestroySocket()) {
+            return;
+        }
+        // Virtual network doesn't have permission set.
+        if (!isPermissionMoreRestrictive(oldPermission, newPermission) || nai.isVPN()) {
+            return;
+        }
+        try {
+            mDeps.destroyLiveTcpSocketsLackingPermission(
+                    nai.network.netId, newPermission);
+        } catch (SocketException | InterruptedIOException | ErrnoException e) {
+            loge("Exception destroy TCP sockets lacking permission: " + e);
+        }
+    }
+
+    private boolean isPermissionMoreRestrictive(int oldPermission, int newPermission) {
+        return switch (newPermission) {
+            case INetd.PERMISSION_NONE -> false;
+            case INetd.PERMISSION_NETWORK -> oldPermission == INetd.PERMISSION_NONE;
+            case INetd.PERMISSION_SYSTEM -> oldPermission == INetd.PERMISSION_NONE
+                    || oldPermission == INetd.PERMISSION_NETWORK;
+            default -> throw new IllegalArgumentException("Invalid permission");
+        };
+    }
 }
diff --git a/service/src/com/android/server/L2capNetworkProvider.java b/service/src/com/android/server/L2capNetworkProvider.java
index 149979ffa8..459a573f7f 100644
--- a/service/src/com/android/server/L2capNetworkProvider.java
+++ b/service/src/com/android/server/L2capNetworkProvider.java
@@ -251,7 +251,6 @@ public class L2capNetworkProvider {
         private final Set<L2capNetwork> mL2capNetworks = new ArraySet<>();
 
         private class AcceptThread extends Thread {
-            private static final int TIMEOUT_MS = 500;
             private final BluetoothServerSocket mServerSocket;
 
             public AcceptThread(BluetoothServerSocket serverSocket) {
diff --git a/service/src/com/android/server/connectivity/AutodestructReference.java b/service/src/com/android/server/connectivity/AutodestructReference.java
index 009a43e582..bb1abba237 100644
--- a/service/src/com/android/server/connectivity/AutodestructReference.java
+++ b/service/src/com/android/server/connectivity/AutodestructReference.java
@@ -39,4 +39,9 @@ public class AutodestructReference<T> {
         if (null == obj) throw new NullPointerException("Already autodestructed");
         return obj;
     }
+
+    @Override
+    public String toString() {
+        return "Autodestruct<" + mHeld.getAcquire() + ">";
+    }
 }
diff --git a/service/src/com/android/server/connectivity/BroadcastReceiveHelper.java b/service/src/com/android/server/connectivity/BroadcastReceiveHelper.java
new file mode 100644
index 0000000000..988d33f099
--- /dev/null
+++ b/service/src/com/android/server/connectivity/BroadcastReceiveHelper.java
@@ -0,0 +1,278 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.connectivity;
+
+import android.annotation.NonNull;
+import android.annotation.SuppressLint;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.util.Log;
+
+import com.android.net.module.util.HandlerUtils;
+
+import java.util.List;
+import java.util.function.Consumer;
+
+/**
+ * Helper class for ConnectivityService to listen for broadcast intents and
+ * provide callbacks on a given {@link HandlerThread}.
+ */
+public class BroadcastReceiveHelper {
+    private static final String TAG = BroadcastReceiveHelper.class.getSimpleName();
+    private final Context mContext;
+    private final Handler mHandler;
+    private final Delegate mCallback;
+    private final DeferredBroadcastReceiver mPackageIntentReceiver;
+    private final DeferredBroadcastReceiver mUserIntentReceiver;
+    private final DeferredBroadcastReceiver mExternalAppIntentReceiver;
+
+    /**
+     * Interface defining the callback methods for package and user related events.
+     */
+    public interface Delegate {
+        /**
+         * Called when a new package has been installed.
+         *
+         * @param packageName The name of the package that was added.
+         * @param uid         The user ID of the application that was added.
+         */
+        void onPackageAdded(String packageName, int uid);
+
+        /**
+         * Called when a package has been uninstalled.
+         *
+         * @param packageName The name of the package that was removed.
+         * @param uid         The user ID of the application that was removed.
+         */
+        void onPackageRemoved(String packageName, int uid);
+
+        /**
+         * Called when an existing package has been replaced with a new version.
+         *
+         * @param packageName The name of the package that was replaced.
+         * @param uid         The user ID of the application that was replaced.
+         */
+        void onPackageReplaced(String packageName, int uid);
+
+        /**
+         * Called when the availability of external applications changes.
+         *
+         * @param pkgList An array of package names that have become available.
+         */
+        void onExternalApplicationsAvailable(String[] pkgList);
+
+        /**
+         * Called when a new user has been added to the device.
+         *
+         * Note that {@link #callOnUserAddedForExistingUsers} will iterate through all
+         * existing users on the device and triggers the {@link Delegate#onUserAdded(UserHandle)}
+         * callback inline for each user.
+         * This is needed to ensure the callback is invoked for users
+         * that were present before this listener was started.
+         *
+         * @param userHandle The {@link UserHandle} of the user that was added.
+         */
+        void onUserAdded(UserHandle userHandle);
+
+        /**
+         * Called when a user has been removed from the device.
+         *
+         * @param userHandle The {@link UserHandle} of the user that was removed.
+         */
+        void onUserRemoved(UserHandle userHandle);
+    }
+
+    /**
+     * Constructs a new {@code ConnectivityBroadcastReceiveHelper}.
+     *
+     * @param context The {@link Context} to register the broadcast receiver.
+     * @param handler The handler where the callback methods will be executed.
+     * @param callback The {@link Delegate} implementation that will receive the broadcast events.
+     */
+    public BroadcastReceiveHelper(@NonNull Context context,
+            @NonNull final Handler handler, @NonNull Delegate callback) {
+        mContext = context;
+        mHandler = handler;
+        mCallback = callback;
+        mPackageIntentReceiver = new DeferredBroadcastReceiver(mHandler, this::handlePackageIntent);
+        mExternalAppIntentReceiver =
+                new DeferredBroadcastReceiver(mHandler, this::handleExternalAppIntent);
+        mUserIntentReceiver = new DeferredBroadcastReceiver(mHandler, this::handleUserIntent);
+    }
+
+    /**
+     * Registers the broadcast receivers for package and user related intents.
+     * The callbacks for these events will be executed on the {@link HandlerThread}
+     * provided in the constructor.
+     */
+    public void registerReceivers() {
+        final Context userAllContext = mContext.createContextAsUser(UserHandle.ALL, 0 /* flags */);
+
+        // Listen to user events.
+        final IntentFilter userIntentFilter = new IntentFilter();
+        userIntentFilter.addAction(Intent.ACTION_USER_ADDED);
+        userIntentFilter.addAction(Intent.ACTION_USER_REMOVED);
+        userAllContext.registerReceiver(mUserIntentReceiver, userIntentFilter,
+                null /* broadcastPermission */, mHandler);
+
+        // Listen to package change events.
+        final IntentFilter packageIntentFilter = new IntentFilter();
+        packageIntentFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
+        packageIntentFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
+        packageIntentFilter.addAction(Intent.ACTION_PACKAGE_REPLACED);
+        packageIntentFilter.addDataScheme("package");
+        userAllContext.registerReceiver(mPackageIntentReceiver, packageIntentFilter,
+                null /* broadcastPermission */, mHandler);
+
+        // For PermissionMonitor, listen to EXTERNAL_APPLICATIONS_AVAILABLE is that an app
+        // becoming available means it may need to gain a permission. But an app that becomes
+        // unavailable can neither gain nor lose permissions on that account, it just can no
+        // longer run. Thus, doesn't need to listen to EXTERNAL_APPLICATIONS_UNAVAILABLE.
+        final IntentFilter externalIntentFilter =
+                new IntentFilter(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);
+        userAllContext.registerReceiver(mExternalAppIntentReceiver, externalIntentFilter,
+                null /* broadcastPermission */, mHandler);
+    }
+
+    /**
+     * Iterates through all existing users on the device and trigger the
+     * {@link Delegate#onUserAdded(UserHandle)} callback inline for each user.
+     * This method should be called to ensure the callback is invoked for users
+     * that were present before this listener was started.
+     */
+    @SuppressLint("MissingPermission")
+    public void callOnUserAddedForExistingUsers() {
+        HandlerUtils.ensureRunningOnHandlerThread(mHandler);
+        final UserManager userManager = mContext.getSystemService(UserManager.class);
+        final List<UserHandle> users = userManager.getUserHandles(true /* excludeDying */);
+        for (final UserHandle user : users) {
+            mCallback.onUserAdded(user);
+        }
+    }
+
+    /**
+     * Unregisters the broadcast receiver, stopping the listener from receiving further events.
+     * It's important to call this method when the listener is no longer needed to avoid
+     * potential resource leaks.
+     */
+    public void unregisterReceivers() {
+        try {
+            mContext.unregisterReceiver(mPackageIntentReceiver);
+            mContext.unregisterReceiver(mUserIntentReceiver);
+            mContext.unregisterReceiver(mExternalAppIntentReceiver);
+        } catch (IllegalArgumentException e) {
+            // Receiver was not registered
+        }
+    }
+
+    /**
+     * A light-weighted {@link BroadcastReceiver} that dispatches the
+     * received {@link Intent} handling using a {@link Handler}.
+     *
+     * <p>This class is for offloading potentially time-consuming or blocking
+     * operations triggered by broadcast events, preventing Application Not Responding
+     * (ANR) errors.</p>
+     */
+    private static class DeferredBroadcastReceiver extends BroadcastReceiver {
+        private final Handler mHandler;
+        private final Consumer<Intent> mIntentConsumer;
+
+        DeferredBroadcastReceiver(@NonNull Handler handler,
+                @NonNull Consumer<Intent> intentConsumer) {
+            mHandler = handler;
+            mIntentConsumer = intentConsumer;
+        }
+
+        @Override
+        public void onReceive(Context context, @NonNull Intent intent) {
+            HandlerUtils.ensureRunningOnHandlerThread(mHandler);
+            mHandler.post(() -> mIntentConsumer.accept(intent));
+        }
+    }
+
+    private void handlePackageIntent(Intent intent) {
+        HandlerUtils.ensureRunningOnHandlerThread(mHandler);
+        final int uid = intent.getIntExtra(Intent.EXTRA_UID, -1);
+        final Uri packageData = intent.getData();
+        // AOSP never sends null data in the intent (see
+        // BroadcastHelper#sendPostInstallBroadcasts)
+        // but OEMs may have modified this code.
+        if (packageData == null) {
+            Log.wtf(TAG, "Intent received with null data: " + intent);
+            return;
+        }
+        final String packageName = packageData.getSchemeSpecificPart();
+
+        switch (intent.getAction()) {
+            case Intent.ACTION_PACKAGE_ADDED: {
+                mCallback.onPackageAdded(packageName, uid);
+                break;
+            }
+            case Intent.ACTION_PACKAGE_REMOVED: {
+                mCallback.onPackageRemoved(packageName, uid);
+                break;
+            }
+            case Intent.ACTION_PACKAGE_REPLACED: {
+                mCallback.onPackageReplaced(packageName, uid);
+                break;
+            }
+            default:
+                Log.wtf(TAG, "received unexpected intent: " + intent.getAction());
+        }
+    }
+
+    private void handleExternalAppIntent(Intent intent) {
+        HandlerUtils.ensureRunningOnHandlerThread(mHandler);
+        switch (intent.getAction()) {
+            case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE: {
+                final String[] pkgList =
+                        intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
+                mCallback.onExternalApplicationsAvailable(pkgList);
+                break;
+            }
+            default:
+                Log.wtf(TAG, "received unexpected intent: " + intent.getAction());
+        }
+    }
+
+    private void handleUserIntent(Intent intent) {
+        HandlerUtils.ensureRunningOnHandlerThread(mHandler);
+        final String action = intent.getAction();
+        final UserHandle user = intent.getParcelableExtra(Intent.EXTRA_USER);
+
+        // User should be filled for below intents, check the existence.
+        if (user == null) {
+            Log.wtf(TAG, intent.getAction() + " broadcast without EXTRA_USER");
+            return;
+        }
+
+        if (Intent.ACTION_USER_ADDED.equals(action)) {
+            mCallback.onUserAdded(user);
+        } else if (Intent.ACTION_USER_REMOVED.equals(action)) {
+            mCallback.onUserRemoved(user);
+        }  else {
+            Log.wtf(TAG, "received unexpected intent: " + action);
+        }
+    }
+}
diff --git a/service/src/com/android/server/connectivity/CarrierPrivilegeAuthenticator.java b/service/src/com/android/server/connectivity/CarrierPrivilegeAuthenticator.java
index 14a935f546..84475fea36 100644
--- a/service/src/com/android/server/connectivity/CarrierPrivilegeAuthenticator.java
+++ b/service/src/com/android/server/connectivity/CarrierPrivilegeAuthenticator.java
@@ -97,7 +97,7 @@ public class CarrierPrivilegeAuthenticator {
         mContext = c;
         mTelephonyManager = t;
         mTelephonyManagerShim = telephonyManagerShim;
-        mUseCallbacksForServiceChanged = deps.isFeatureEnabled(
+        mUseCallbacksForServiceChanged = deps.isFeatureNotChickenedOut(
                 c, CARRIER_SERVICE_CHANGED_USE_CALLBACK);
         mRequestRestrictedWifiEnabled = requestRestrictedWifiEnabled;
         mListener = listener;
@@ -159,10 +159,10 @@ public class CarrierPrivilegeAuthenticator {
         }
 
         /**
-         * @see DeviceConfigUtils#isTetheringFeatureEnabled
+         * @see DeviceConfigUtils#isTetheringFeatureNotChickenedOut
          */
-        public boolean isFeatureEnabled(Context context, String name) {
-            return DeviceConfigUtils.isTetheringFeatureEnabled(context, name);
+        public boolean isFeatureNotChickenedOut(Context context, String name) {
+            return DeviceConfigUtils.isTetheringFeatureNotChickenedOut(context, name);
         }
     }
 
diff --git a/service/src/com/android/server/connectivity/ConnectivityFlags.java b/service/src/com/android/server/connectivity/ConnectivityFlags.java
index 74bd2351ac..19c97fee1d 100644
--- a/service/src/com/android/server/connectivity/ConnectivityFlags.java
+++ b/service/src/com/android/server/connectivity/ConnectivityFlags.java
@@ -65,6 +65,36 @@ public final class ConnectivityFlags {
     public static final String QUEUE_NETWORK_AGENT_EVENTS_IN_SYSTEM_SERVER =
             "queue_network_agent_events_in_system_server";
 
+    public static final String CLOSE_QUIC_CONNECTION = "close_quic_connection";
+
+    public static final String CONSTRAINED_DATA_SATELLITE_OPTIN =
+            "constrained_data_satellite_optin";
+
+    public static final String CONSTRAINED_DATA_SATELLITE_METRICS =
+            "constrained_data_satellite_metrics";
+
+    /**
+     * A feature flag to control whether the early link properties update for vpn should be enabled.
+     *
+     * Note: This feature is automatically enabled if the flag
+     *       QUEUE_NETWORK_AGENT_EVENTS_IN_SYSTEM_SERVER is enabled.
+     */
+    public static final String EARLY_LINK_PROPERTIES_UPDATE_FOR_VPN =
+            "early_link_properties_update_for_vpn";
+
+    /**
+     * Kill switch for the PermissionMonitor refactoring that centralizes intent
+     * receiving and dispatching within the {@link BroadcastReceiveHelper}.
+     * If enabled, the refactored logic in {@link BroadcastReceiveHelper} will be used.
+     * If disabled, the PermissionMonitor will revert to its previous implementation
+     * for receiving and dispatching intents.
+     *
+     * This flag is introduced as a risk mitigation strategy in case issues are
+     * discovered with the new refactored implementation.
+     */
+    public static final String USE_BROADCAST_RECEIVE_HELPER_FOR_PERMISSION_MONITOR =
+            "use_broadcast_receive_helper_for_permission_monitor";
+
     private boolean mNoRematchAllRequestsOnRegister;
 
     /**
diff --git a/service/src/com/android/server/connectivity/IntegerRangeUtils.java b/service/src/com/android/server/connectivity/IntegerRangeUtils.java
new file mode 100644
index 0000000000..d67db4649d
--- /dev/null
+++ b/service/src/com/android/server/connectivity/IntegerRangeUtils.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.connectivity;
+
+import android.util.ArraySet;
+import android.util.Range;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import com.android.net.module.util.CollectionUtils;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+
+public final class IntegerRangeUtils {
+    /**
+     * Remove given Integer list from the source Integer range and return a set of ranges.
+     * @param source Integer range from which Integer list will be removed
+     * @param exempt Integer list to be removed from the source.
+     * @return a set of Integer ranges which doesn't have exempted Integer list.
+     */
+    public static Set<Range<Integer>> rangeWithoutValues(
+            @NonNull Range<Integer> source, @Nullable List<Integer> exempt) {
+        final Set<Range<Integer>> rangeSet = new ArraySet<>();
+        final List<Integer> exemptInRange = exempt != null
+                ? CollectionUtils.filter(exempt, source::contains) : null;
+        if (exemptInRange == null || exemptInRange.isEmpty()) {
+            rangeSet.add(source);
+            return rangeSet;
+        }
+        Collections.sort(exemptInRange);
+        int start = source.getLower();
+        for (int i = 0; i < exemptInRange.size(); i++) {
+            int end = exemptInRange.get(i);
+            if (end > start) {
+                rangeSet.add(Range.create(start, end - 1));
+            }
+            start = end + 1;
+        }
+        if (start <= source.getUpper()) {
+            rangeSet.add(Range.create(start, source.getUpper()));
+        }
+        return rangeSet;
+    }
+}
diff --git a/service/src/com/android/server/connectivity/InterfaceTracker.java b/service/src/com/android/server/connectivity/InterfaceTracker.java
index 0b4abeb9cc..c6686afcc2 100644
--- a/service/src/com/android/server/connectivity/InterfaceTracker.java
+++ b/service/src/com/android/server/connectivity/InterfaceTracker.java
@@ -22,6 +22,7 @@ import android.system.Os;
 import android.util.ArrayMap;
 import android.util.Log;
 
+import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.BpfNetMaps;
 
@@ -39,6 +40,7 @@ public class InterfaceTracker {
     }
     private static final String TAG = "InterfaceTracker";
     private final Dependencies mDeps;
+    @GuardedBy("mInterfaceMap")
     private final Map<String, Integer> mInterfaceMap;
 
     public InterfaceTracker(final Context context) {
diff --git a/service/src/com/android/server/connectivity/MultinetworkPolicyTracker.java b/service/src/com/android/server/connectivity/MultinetworkPolicyTracker.java
index 93018bb61a..561a7934aa 100644
--- a/service/src/com/android/server/connectivity/MultinetworkPolicyTracker.java
+++ b/service/src/com/android/server/connectivity/MultinetworkPolicyTracker.java
@@ -16,10 +16,13 @@
 
 package com.android.server.connectivity;
 
+import static android.content.pm.PackageManager.FEATURE_TELEPHONY_SUBSCRIPTION;
 import static android.net.ConnectivitySettingsManager.NETWORK_AVOID_BAD_WIFI;
 import static android.net.ConnectivitySettingsManager.NETWORK_METERED_MULTIPATH_PREFERENCE;
 
+import android.annotation.IntDef;
 import android.annotation.NonNull;
+import android.annotation.Nullable;
 import android.annotation.TargetApi;
 import android.content.BroadcastReceiver;
 import android.content.ContentResolver;
@@ -29,20 +32,29 @@ import android.content.IntentFilter;
 import android.content.res.Resources;
 import android.database.ContentObserver;
 import android.net.Uri;
+import android.net.platform.flags.Flags;
 import android.os.Build;
 import android.os.Handler;
+import android.os.PersistableBundle;
 import android.provider.DeviceConfig;
 import android.provider.Settings;
+import android.telephony.CarrierConfigManager;
 import android.telephony.SubscriptionManager;
 import android.telephony.TelephonyCallback;
 import android.telephony.TelephonyManager;
+import android.util.ArrayMap;
 import android.util.Log;
 
 import com.android.connectivity.resources.R;
+import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.modules.utils.BackgroundThread;
 import com.android.modules.utils.build.SdkLevel;
 import com.android.net.module.util.DeviceConfigUtils;
+import com.android.net.module.util.HandlerUtils;
 
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.Executor;
@@ -66,6 +78,36 @@ import java.util.concurrent.RejectedExecutionException;
  * @hide
  */
 public class MultinetworkPolicyTracker {
+    private class CarrierConfigChangeListener
+            implements CarrierConfigManager.CarrierConfigChangeListener {
+        /**
+         * Must be called on the background thread.
+         */
+        @Override
+        public void onCarrierConfigChanged(
+                    int slotIndex, int subId, int carrierId, int specificCarrierId) {
+            updateAvoidBadWifiFromCarrierConfigBackground(subId);
+        }
+    }
+
+    /**
+     * Indicates that the "Avoid Bad Wi-Fi" setting originates from a resource.
+     */
+    private static final int FROM_RESOURCE = 0;
+
+    /**
+     * Indicates that the "Avoid Bad Wi-Fi" setting originates from carrier configuration.
+     */
+    private static final int FROM_CARRIER_CONFIG = 1;
+
+    /**
+     * Defines the set of possible integer constants for AvoidBadWifiSource.
+     * This annotation provides compile-time type safety.
+     */
+    @IntDef({FROM_RESOURCE, FROM_CARRIER_CONFIG})
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface AvoidBadWifiSource {}
+
     private static String TAG = MultinetworkPolicyTracker.class.getSimpleName();
 
     // See Dependencies#getConfigActivelyPreferBadWifi
@@ -79,7 +121,15 @@ public class MultinetworkPolicyTracker {
     private final ContentResolver mResolver;
     private final SettingObserver mSettingObserver;
     private final BroadcastReceiver mBroadcastReceiver;
-
+    private final @AvoidBadWifiSource int mAvoidBadWifiSource;
+    // This will be null if the FLAG_AVOID_BAD_WIFI_FROM_CARRIER_CONFIG is off
+    private final @Nullable CarrierConfigManager mCarrierConfigManager;
+    private final @Nullable CarrierConfigChangeListener mCarrierConfigChangeListener;
+
+    // This will be accessed by background and handler thread
+    @GuardedBy("mAvoidBadWifiCarrierConfigForSubIdMap")
+    private final ArrayMap<Integer, Boolean> mAvoidBadWifiCarrierConfigForSubIdMap =
+            new ArrayMap<>();
     private volatile boolean mAvoidBadWifi = true;
     private volatile int mMeteredMultipathPreference;
     private int mActiveSubId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
@@ -90,6 +140,11 @@ public class MultinetworkPolicyTracker {
      */
     @VisibleForTesting
     public static class Dependencies {
+        private boolean isCarrierConfigValid(PersistableBundle config) {
+            return config == null || config.isEmpty()
+                || !CarrierConfigManager.isConfigForIdentifiedCarrier(config);
+        }
+
         /**
          * @see DeviceConfigUtils#getDeviceConfigPropertyInt
          */
@@ -119,6 +174,43 @@ public class MultinetworkPolicyTracker {
             return SubscriptionManager.getResourcesForSubId(
                     resources.getResourcesContext(), activeSubId);
         }
+
+        @VisibleForTesting
+        protected boolean readAvoidBadWifiFromCarrierConfig(
+                @NonNull final CarrierConfigManager ccm, final int subId) {
+            // Defaults to true to avoid potentially poor Wi-Fi and improve user experience.
+            final boolean defaultConfig = true;
+            if (subId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
+                return defaultConfig;
+            }
+
+            PersistableBundle config = null;
+
+            try {
+                config = ccm.getConfigForSubId(subId,
+                        CarrierConfigManager.KEY_AVOID_BAD_WIFI_BOOL
+                );
+            } catch (RuntimeException e) {
+                Log.e(TAG, "Failed to get config from carrier config", e);
+            }
+
+            if (isCarrierConfigValid(config)) {
+                // If the "avoid bad Wi-Fi" setting is not defined in the carrier-specific config,
+                // retrieve the default configuration.
+                config = CarrierConfigManager.getDefaultConfig();
+            }
+
+            return config.getBoolean(CarrierConfigManager.KEY_AVOID_BAD_WIFI_BOOL, defaultConfig);
+        }
+
+        protected boolean getAvoidBadWifiFromCarrierConfigFeature() {
+            return Flags.avoidBadWifiFromCarrierConfig();
+        }
+
+        protected Handler getBackgroundThreadHandler() {
+            return BackgroundThread.getHandler();
+        }
+
     }
     private final Dependencies mDeps;
 
@@ -164,7 +256,7 @@ public class MultinetworkPolicyTracker {
     protected class ActiveDataSubscriptionIdListener extends TelephonyCallback
             implements TelephonyCallback.ActiveDataSubscriptionIdListener {
         @Override
-        public void onActiveDataSubscriptionIdChanged(int subId) {
+        public void onActiveDataSubscriptionIdChanged(final int subId) {
             mActiveSubId = subId;
             reevaluateInternal();
         }
@@ -193,8 +285,20 @@ public class MultinetworkPolicyTracker {
             }
         };
 
-        updateAvoidBadWifi();
-        updateMeteredMultipathPreference();
+        if (mDeps.getAvoidBadWifiFromCarrierConfigFeature()) {
+            mAvoidBadWifiSource = FROM_CARRIER_CONFIG;
+            mCarrierConfigManager =
+                mContext.getPackageManager().hasSystemFeature(FEATURE_TELEPHONY_SUBSCRIPTION)
+                ? mContext.getSystemService(CarrierConfigManager.class)
+                : null;
+            mCarrierConfigChangeListener = new CarrierConfigChangeListener();
+        } else {
+            mAvoidBadWifiSource = FROM_RESOURCE;
+            mCarrierConfigManager = null;
+            mCarrierConfigChangeListener = null;
+            updateAvoidBadWifi();
+            updateMeteredMultipathPreference();
+        }
     }
 
     // TODO: Set the mini sdk to 31 and remove @TargetApi annotation when b/205923322 is addressed.
@@ -212,8 +316,20 @@ public class MultinetworkPolicyTracker {
         final Executor handlerExecutor = new HandlerExecutor(mHandler);
         mContext.getSystemService(TelephonyManager.class).registerTelephonyCallback(
                 handlerExecutor, new ActiveDataSubscriptionIdListener());
-        mDeps.addOnDevicePropertiesChangedListener(handlerExecutor,
+
+        if (mCarrierConfigManager != null) {
+            mCarrierConfigManager.registerCarrierConfigChangeListener(
+                    BackgroundThread.getExecutor(), mCarrierConfigChangeListener
+            );
+
+            // This ensures the latest carrier configuration is read.
+            final int subId = mActiveSubId;
+            mDeps.getBackgroundThreadHandler().post(() ->
+                    updateAvoidBadWifiFromCarrierConfigBackground(subId));
+        } else {
+            mDeps.addOnDevicePropertiesChangedListener(handlerExecutor,
                 properties -> reevaluateInternal());
+        }
 
         reevaluate();
     }
@@ -222,6 +338,11 @@ public class MultinetworkPolicyTracker {
         mResolver.unregisterContentObserver(mSettingObserver);
 
         mContext.unregisterReceiver(mBroadcastReceiver);
+        if (mCarrierConfigManager != null) {
+            mCarrierConfigManager.unregisterCarrierConfigChangeListener(
+                    mCarrierConfigChangeListener
+            );
+        }
     }
 
     public boolean getAvoidBadWifi() {
@@ -287,10 +408,13 @@ public class MultinetworkPolicyTracker {
      * Whether we should display a notification when wifi becomes unvalidated.
      */
     public boolean shouldNotifyWifiUnvalidated() {
-        return configRestrictsAvoidBadWifi() && getAvoidBadWifiSetting() == null;
+        return configRestrictsAvoidBadWifi() && readAvoidBadWifiFromSettings() == null;
     }
 
-    public String getAvoidBadWifiSetting() {
+    /**
+     * Retrieves the "avoid bad Wi-Fi" setting from the global settings.
+     */
+    public String readAvoidBadWifiFromSettings() {
         return Settings.Global.getString(mResolver, NETWORK_AVOID_BAD_WIFI);
     }
 
@@ -332,20 +456,109 @@ public class MultinetworkPolicyTracker {
         updateMeteredMultipathPreference();
     }
 
-    public boolean updateAvoidBadWifi() {
-        final boolean settingAvoidBadWifi = "1".equals(getAvoidBadWifiSetting());
-        final boolean prevAvoid = mAvoidBadWifi;
-        mAvoidBadWifi = settingAvoidBadWifi || !configRestrictsAvoidBadWifi();
+    /**
+     * Reads the avoid bad Wi-Fi setting from the cache for a specific subscription ID.
+     * If no value is found for the given subId, it defaults to true.
+     */
+    private boolean readAvoidBadWifiFromCache(int subId) {
+        synchronized (mAvoidBadWifiCarrierConfigForSubIdMap) {
+            return mAvoidBadWifiCarrierConfigForSubIdMap.getOrDefault(subId, true);
+        }
+    }
 
-        final boolean prevActive = mActivelyPreferBadWifi;
-        final Boolean deviceConfigPreferBadWifi = deviceConfigActivelyPreferBadWifi();
-        if (null == deviceConfigPreferBadWifi) {
-            mActivelyPreferBadWifi = configActivelyPrefersBadWifi();
-        } else {
-            mActivelyPreferBadWifi = deviceConfigPreferBadWifi;
+    /**
+     * Updates the cached avoid bad Wi-Fi setting for a specific subscription ID.
+     */
+    private void updateAvoidBadWifiCache(int subId, boolean enable) {
+        synchronized (mAvoidBadWifiCarrierConfigForSubIdMap) {
+            mAvoidBadWifiCarrierConfigForSubIdMap.put(subId, enable);
+        }
+    }
+
+    /**
+     * Updates the local cache of the "avoid bad Wi-Fi" setting from the carrier config
+     * for a specific subscription ID.
+     * Must be called on the handler thread.
+     */
+    private void updateAvoidBadWifiFromCarrierConfig(int subId, boolean enable) {
+        updateAvoidBadWifiCache(subId, enable);
+
+        if (subId == mActiveSubId) {
+            reevaluateInternal();
+        }
+    }
+
+    /**
+     * Retrieves the "avoid bad Wi-Fi" setting from the carrier configuration for the given subId,
+     * and updates the local cache asynchronously on the handler thread.
+     * Must be called on the background thread, because it makes an IPC to the phone process.
+     * It must not be called on the CS handler thread.
+     */
+    private void updateAvoidBadWifiFromCarrierConfigBackground(int subId) {
+        HandlerUtils.ensureRunningOnHandlerThread(mDeps.getBackgroundThreadHandler());
+
+        if (subId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
+            return;
         }
 
-        return mAvoidBadWifi != prevAvoid || mActivelyPreferBadWifi != prevActive;
+        // CarrierConfigManager#getConfigForSubId() is supported
+        // only when system has FEATURE_TELEPHONY_SUBSCRIPTION
+        final boolean config =
+                mDeps.readAvoidBadWifiFromCarrierConfig(mCarrierConfigManager, subId);
+        mHandler.post(() -> updateAvoidBadWifiFromCarrierConfig(subId, config));
+    }
+
+    /**
+     * Updates the "avoid bad Wi-Fi" setting.
+     * Depending on whether the carrier config feature is enabled, this method uses different logic:
+     *
+     * If carrier config feature is ON (Android U+ and 25Q4+):
+     * - Forces "actively prefer bad Wi-Fi" to true.
+     * - Checks a system setting first. If it is enabled, we should avoid bad Wi-Fi.
+     * - If the system setting isn't available, it uses a cached value from the carrier config
+     *   for the current subId.
+     *
+     * If carrier config feature is OFF:
+     * - "Avoid bad Wi-Fi" is true if the system setting is enabled OR
+     *    if the carrier doesn't restrict avoiding bad Wi-Fi.
+     * - "Actively prefer bad Wi-Fi" is based on a device-specific setting,
+     *    falling back to the carrier config if the device setting isn't available.
+     *
+     * Returns true if either the "avoid bad Wi-Fi" or "actively prefer bad Wi-Fi" setting changed,
+     * false otherwise.
+     */
+    public boolean updateAvoidBadWifi() {
+        final boolean prevAvoid = mAvoidBadWifi;
+        switch (mAvoidBadWifiSource) {
+            case FROM_CARRIER_CONFIG:
+                // Force update activelyPreferBadWifi since it will always be true in Android U+,
+                // and mAvoidBadWifiFromCarrierConfigFeature is a trunk stable flag
+                // that only exists in 25Q4+
+                mActivelyPreferBadWifi = true;
+                final String settingAvoidBadWifiStr = readAvoidBadWifiFromSettings();
+                if (settingAvoidBadWifiStr != null) {
+                    mAvoidBadWifi = "1".equals(settingAvoidBadWifiStr);
+                } else {
+                    // Retrieve the avoid bad Wi-Fi setting from the local cache to avoid potential
+                    // issues or blocking from the IPC call getAvoidBadWifiCarrierConfigForSubId().
+                    mAvoidBadWifi = readAvoidBadWifiFromCache(mActiveSubId);
+                }
+                return mAvoidBadWifi != prevAvoid;
+            case FROM_RESOURCE:
+                final boolean settingAvoidBadWifi = "1".equals(readAvoidBadWifiFromSettings());
+                mAvoidBadWifi = settingAvoidBadWifi || !configRestrictsAvoidBadWifi();
+                final boolean prevActive = mActivelyPreferBadWifi;
+                final Boolean deviceConfigPreferBadWifi = deviceConfigActivelyPreferBadWifi();
+                if (null == deviceConfigPreferBadWifi) {
+                    mActivelyPreferBadWifi = configActivelyPrefersBadWifi();
+                } else {
+                    mActivelyPreferBadWifi = deviceConfigPreferBadWifi;
+                }
+                return mAvoidBadWifi != prevAvoid || mActivelyPreferBadWifi != prevActive;
+            default:
+                Log.wtf(TAG, "Unexpected avoid bad Wi-Fi source: " + mAvoidBadWifiSource);
+                return false;
+        }
     }
 
     /**
diff --git a/service/src/com/android/server/connectivity/PermissionMonitor.java b/service/src/com/android/server/connectivity/PermissionMonitor.java
index 5de5f61ff1..48f68051d1 100755
--- a/service/src/com/android/server/connectivity/PermissionMonitor.java
+++ b/service/src/com/android/server/connectivity/PermissionMonitor.java
@@ -30,6 +30,7 @@ import static android.net.connectivity.ConnectivityCompatChanges.RESTRICT_LOCAL_
 import static android.os.Process.INVALID_UID;
 import static android.os.Process.SYSTEM_UID;
 
+import static com.android.server.connectivity.ConnectivityFlags.USE_BROADCAST_RECEIVE_HELPER_FOR_PERMISSION_MONITOR;
 import static com.android.server.connectivity.NetworkPermissions.PERMISSION_NETWORK;
 import static com.android.server.connectivity.NetworkPermissions.PERMISSION_NONE;
 import static com.android.server.connectivity.NetworkPermissions.PERMISSION_SYSTEM;
@@ -40,6 +41,7 @@ import static com.android.net.module.util.CollectionUtils.toIntArray;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.annotation.SuppressLint;
 import android.app.compat.CompatChanges;
 import android.content.AttributionSource;
 import android.content.BroadcastReceiver;
@@ -76,6 +78,7 @@ import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.util.IndentingPrintWriter;
 import com.android.modules.utils.build.SdkLevel;
 import com.android.net.module.util.CollectionUtils;
+import com.android.net.module.util.DeviceConfigUtils;
 import com.android.net.module.util.SharedLog;
 import com.android.networkstack.apishim.ProcessShimImpl;
 import com.android.networkstack.apishim.common.ProcessShim;
@@ -90,8 +93,6 @@ import java.util.Set;
 /**
  * A utility class to inform Netd of UID permissions.
  * Does a mass update at boot and then monitors for app install/remove.
- *
- * @hide
  */
 public class PermissionMonitor {
     private static final String TAG = "PermissionMonitor";
@@ -163,10 +164,15 @@ public class PermissionMonitor {
 
     private static final int MAX_PERMISSION_UPDATE_LOGS = 40;
     private final SharedLog mPermissionUpdateLogs = new SharedLog(MAX_PERMISSION_UPDATE_LOGS, TAG);
+    private final boolean mUseBroadcastReceiveHelper;
 
-    private BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
+    private final BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent intent) {
+            if (mUseBroadcastReceiveHelper) {
+                throw new IllegalStateException(
+                        "This should only be called if UseBroadcastReceiveHelper is false");
+            }
             final String action = intent.getAction();
 
             if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {
@@ -240,6 +246,13 @@ public class PermissionMonitor {
             return BpfNetMaps.isAtLeast25Q2() &&
                     CompatChanges.isChangeEnabled(RESTRICT_LOCAL_NETWORK, uid);
         }
+
+        /**
+         * @see DeviceConfigUtils#isTetheringFeatureNotChickenedOut
+         */
+        public boolean isFeatureNotChickenedOut(Context context, String name) {
+            return DeviceConfigUtils.isTetheringFeatureNotChickenedOut(context, name);
+        }
     }
 
     private static class MultiSet<T> {
@@ -285,7 +298,6 @@ public class PermissionMonitor {
             @NonNull final Dependencies deps,
             @NonNull final HandlerThread thread) {
         mPackageManager = context.getPackageManager();
-        mUserManager = (UserManager) context.getSystemService(Context.USER_SERVICE);
         mSystemConfigManager = context.getSystemService(SystemConfigManager.class);
         mPermissionManager = context.getSystemService(PermissionManager.class);
         mPermissionChangeListener = new PermissionChangeListener();
@@ -301,6 +313,13 @@ public class PermissionMonitor {
             // restrictions can only occur after this registration has completed.
             mPackageManager.addOnPermissionsChangeListener(mPermissionChangeListener);
         }
+        mUseBroadcastReceiveHelper = mDeps.isFeatureNotChickenedOut(
+                mContext, USE_BROADCAST_RECEIVE_HELPER_FOR_PERMISSION_MONITOR);
+        if (!mUseBroadcastReceiveHelper) {
+            mUserManager = context.getSystemService(UserManager.class);
+        } else {
+            mUserManager = null;
+        }
     }
 
     @VisibleForTesting
@@ -319,9 +338,7 @@ public class PermissionMonitor {
         if (hasSdkSandbox(uid)){
             // SDKs in the SDK RT cannot hold runtime permissions
             final int sdkSandboxUid = sProcessShim.toSdkSandboxUid(uid);
-            if (!mBpfNetMaps.isUidBlockedFromUsingLocalNetwork(sdkSandboxUid)) {
-                mBpfNetMaps.addUidToLocalNetBlockMap(sdkSandboxUid);
-            }
+            mBpfNetMaps.addUidToLocalNetBlockMap(sdkSandboxUid);
         }
     }
 
@@ -349,10 +366,6 @@ public class PermissionMonitor {
         return targetPermission > currentPermission;
     }
 
-    private List<PackageInfo> getInstalledPackagesAsUser(final UserHandle user) {
-        return mPackageManager.getInstalledPackagesAsUser(GET_PERMISSIONS, user.getIdentifier());
-    }
-
     private synchronized void updateAllApps(final List<PackageInfo> apps) {
         for (PackageInfo app : apps) {
             final int appId = app.applicationInfo != null
@@ -457,35 +470,44 @@ public class PermissionMonitor {
         return appIdsPerm;
     }
 
-    // Intended to be called only once at startup, after the system is ready. Installs a broadcast
-    // receiver to monitor ongoing UID changes, so this shouldn't/needn't be called again.
-    public synchronized void startMonitoring() {
-        log("Monitoring");
+    /**
+     * Initializer of this class.
+     *
+     * Intended to be called only once at startup, in the systemReady phase.
+     * This shouldn't/needn't be called again.
+     */
+    @SuppressLint("MissingPermission")
+    public synchronized void initialize() {
+        log("Initialize");
 
         final Handler handler = new Handler(mThread.getLooper());
         final Context userAllContext = mContext.createContextAsUser(UserHandle.ALL, 0 /* flags */);
-        final IntentFilter intentFilter = new IntentFilter();
-        intentFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
-        intentFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
-        intentFilter.addDataScheme("package");
-        userAllContext.registerReceiver(
-                mIntentReceiver, intentFilter, null /* broadcastPermission */, handler);
-
-        // Listen to EXTERNAL_APPLICATIONS_AVAILABLE is that an app becoming available means it may
-        // need to gain a permission. But an app that becomes unavailable can neither gain nor lose
-        // permissions on that account, it just can no longer run. Thus, doesn't need to listen to
-        // EXTERNAL_APPLICATIONS_UNAVAILABLE.
-        final IntentFilter externalIntentFilter =
-                new IntentFilter(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);
-        userAllContext.registerReceiver(
-                mIntentReceiver, externalIntentFilter, null /* broadcastPermission */, handler);
-
-        // Listen for user add/remove.
-        final IntentFilter userIntentFilter = new IntentFilter();
-        userIntentFilter.addAction(Intent.ACTION_USER_ADDED);
-        userIntentFilter.addAction(Intent.ACTION_USER_REMOVED);
-        userAllContext.registerReceiver(
-                mIntentReceiver, userIntentFilter, null /* broadcastPermission */, handler);
+
+        if (!mUseBroadcastReceiveHelper) {
+            final IntentFilter intentFilter = new IntentFilter();
+            intentFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
+            intentFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
+            intentFilter.addDataScheme("package");
+            userAllContext.registerReceiver(
+                    mIntentReceiver, intentFilter, null /* broadcastPermission */, handler);
+
+            // Listen to EXTERNAL_APPLICATIONS_AVAILABLE is that an app becoming
+            // available means it may need to gain a permission. But an app that
+            // becomes unavailable can neither gain nor lose permissions on that
+            // account, it just can no longer run. Thus, doesn't need to listen to
+            // EXTERNAL_APPLICATIONS_UNAVAILABLE.
+            final IntentFilter externalIntentFilter =
+                    new IntentFilter(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);
+            userAllContext.registerReceiver(
+                    mIntentReceiver, externalIntentFilter, null /* broadcastPermission */, handler);
+
+            // Listen for user add/remove.
+            final IntentFilter userIntentFilter = new IntentFilter();
+            userIntentFilter.addAction(Intent.ACTION_USER_ADDED);
+            userIntentFilter.addAction(Intent.ACTION_USER_REMOVED);
+            userAllContext.registerReceiver(
+                    mIntentReceiver, userIntentFilter, null /* broadcastPermission */, handler);
+        }
 
         // Register UIDS_ALLOWED_ON_RESTRICTED_NETWORKS setting observer
         mDeps.registerContentObserver(
@@ -507,12 +529,24 @@ public class PermissionMonitor {
         // are not specific to any particular user.
         mUsersTrafficPermissions.put(UserHandle.ALL, getSystemTrafficPerm());
 
-        final List<UserHandle> usrs = mUserManager.getUserHandles(true /* excludeDying */);
-        // Update netd permissions for all users.
-        for (UserHandle user : usrs) {
-            onUserAdded(user);
+        if (!mUseBroadcastReceiveHelper) {
+            final List<UserHandle> usrs = mUserManager.getUserHandles(true /* excludeDying */);
+            // Update netd permissions for all users.
+            for (UserHandle user : usrs) {
+                onUserAdded(user);
+            }
         }
-        log("Users: " + mUsers.size() + ", UidToNetworkPerm: " + mUidToNetworkPerm.size());
+
+        log("UidToNetworkPerm: " + mUidToNetworkPerm.size());
+    }
+
+    /**
+     * Indicates whether the BroadcastReceiveHelper should be used by PermissionMonitor.
+     *
+     * This flag value is initialized in the constructor, ensuring consistency across sub-modules.
+     */
+    public boolean useBroadcastReceiveHelper() {
+        return mUseBroadcastReceiveHelper;
     }
 
     @VisibleForTesting
@@ -620,19 +654,28 @@ public class PermissionMonitor {
         }
     }
 
+    @SuppressLint("MissingPermission")
+    private synchronized void onUserAdded(@NonNull UserHandle user) {
+        if (mUseBroadcastReceiveHelper) {
+            throw new IllegalStateException(
+                    "This should only be called if UseBroadcastReceiveHelper is false");
+        }
+        final List<PackageInfo> apps =  mPackageManager.getInstalledPackagesAsUser(
+                GET_PERMISSIONS, user.getIdentifier());
+        onUserAddedWithInstalledPackageList(user, apps);
+    }
+
     /**
      * Called when a user is added. See {link #ACTION_USER_ADDED}.
      *
-     * @param user The integer userHandle of the added user. See {@link #EXTRA_USER_HANDLE}.
-     *
-     * @hide
+     * @param user The userHandle of the added user. See {@link #EXTRA_USER_HANDLE}.
+     * @param apps The list of packages which is installed on the user.
      */
-    @VisibleForTesting
-    synchronized void onUserAdded(@NonNull UserHandle user) {
+    public synchronized void onUserAddedWithInstalledPackageList(@NonNull UserHandle user,
+            @NonNull List<PackageInfo> apps) {
+        ensureRunningOnHandlerThread();
         mUsers.add(user);
 
-        final List<PackageInfo> apps = getInstalledPackagesAsUser(user);
-
         // Save all apps in mAllApps
         updateAllApps(apps);
 
@@ -655,12 +698,10 @@ public class PermissionMonitor {
     /**
      * Called when an user is removed. See {link #ACTION_USER_REMOVED}.
      *
-     * @param user The integer userHandle of the removed user. See {@link #EXTRA_USER_HANDLE}.
-     *
-     * @hide
+     * @param user The userHandle of the removed user. See {@link #EXTRA_USER_HANDLE}.
      */
-    @VisibleForTesting
-    synchronized void onUserRemoved(@NonNull UserHandle user) {
+    public synchronized void onUserRemoved(@NonNull UserHandle user) {
+        ensureRunningOnHandlerThread();
         mUsers.remove(user);
 
         // Remove uids network permissions that belongs to the user.
@@ -842,11 +883,9 @@ public class PermissionMonitor {
      *
      * @param packageName The name of the new package.
      * @param uid The uid of the new package.
-     *
-     * @hide
      */
-    @VisibleForTesting
-    synchronized void onPackageAdded(@NonNull final String packageName, final int uid) {
+    public synchronized void onPackageAdded(@NonNull final String packageName, final int uid) {
+        ensureRunningOnHandlerThread();
         // Update uid permission.
         updateAppIdTrafficPermission(uid);
         // Get the appId permission from all users then send the latest permission to netd.
@@ -907,11 +946,9 @@ public class PermissionMonitor {
      *
      * @param packageName The name of the removed package or null.
      * @param uid containing the integer uid previously assigned to the package.
-     *
-     * @hide
      */
-    @VisibleForTesting
-    synchronized void onPackageRemoved(@NonNull final String packageName, final int uid) {
+    public synchronized void onPackageRemoved(@NonNull final String packageName, final int uid) {
+        ensureRunningOnHandlerThread();
         // Update uid permission.
         updateAppIdTrafficPermission(uid);
         if (BpfNetMaps.isAtLeast25Q2()) {
@@ -1187,8 +1224,6 @@ public class PermissionMonitor {
      *
      * @param appId the appId of the package installed
      * @param permissions the permissions the app requested and netd cares about.
-     *
-     * @hide
      */
     @VisibleForTesting
     void sendPackagePermissionsForAppId(int appId, int permissions) {
@@ -1206,8 +1241,6 @@ public class PermissionMonitor {
      *
      * @param netdPermissionsAppIds integer pairs of appIds and the permission granted to it. If the
      * permission is 0, revoke all permissions of that appId.
-     *
-     * @hide
      */
     @VisibleForTesting
     void sendAppIdsTrafficPermission(SparseIntArray netdPermissionsAppIds) {
@@ -1309,7 +1342,13 @@ public class PermissionMonitor {
                 + ", remove=" + removedUids);
     }
 
-    private synchronized void onExternalApplicationsAvailable(String[] pkgList) {
+    /**
+     * Called when external applications are available.
+     *
+     * @param pkgList The package names of the external applications.
+     */
+    public synchronized void onExternalApplicationsAvailable(String[] pkgList) {
+        ensureRunningOnHandlerThread();
         if (CollectionUtils.isEmpty(pkgList)) {
             Log.e(TAG, "No available external application.");
             return;
diff --git a/service/src/com/android/server/connectivity/QuicConnectionCloser.java b/service/src/com/android/server/connectivity/QuicConnectionCloser.java
new file mode 100644
index 0000000000..c4fe5b8621
--- /dev/null
+++ b/service/src/com/android/server/connectivity/QuicConnectionCloser.java
@@ -0,0 +1,415 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.connectivity;
+
+import static android.system.OsConstants.ENOENT;
+import static android.system.OsConstants.SOL_SOCKET;
+import static android.system.OsConstants.SO_SNDTIMEO;
+
+import android.annotation.NonNull;
+import android.annotation.TargetApi;
+import android.net.Network;
+import android.net.NetworkUtils;
+import android.os.Build;
+import android.os.Handler;
+import android.os.ParcelFileDescriptor;
+import android.system.ErrnoException;
+import android.system.Os;
+import android.system.StructTimeval;
+import android.util.ArrayMap;
+import android.util.IndentingPrintWriter;
+import android.util.Log;
+import android.util.SparseArray;
+
+import com.android.internal.annotations.GuardedBy;
+import com.android.internal.annotations.VisibleForTesting;
+import com.android.net.module.util.HandlerUtils;
+import com.android.net.module.util.SharedLog;
+import com.android.net.module.util.SkDestroyListener;
+import com.android.net.module.util.netlink.InetDiagMessage;
+
+import libcore.io.IoUtils;
+
+import java.io.FileDescriptor;
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.DatagramSocket;
+import java.net.InetSocketAddress;
+import java.net.SocketException;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Consumer;
+
+@TargetApi(Build.VERSION_CODES.S)
+public class QuicConnectionCloser {
+    private static final String TAG = QuicConnectionCloser.class.getSimpleName();
+
+    private static final int SOCKET_WRITE_TIMEOUT_MS = 100;
+
+    // Map from socket cookie to QUIC connection close information
+    private final Map<Long, QuicConnectionCloseInfo>
+            mRegisteredQuicConnectionCloseInfos = new ArrayMap<>();
+
+    // The maximum number of QUIC connection close information entries that can be registered
+    // concurrently.
+    private static final int MAX_REGISTERED_QUIC_CONNECTION_CLOSE_INFO = 1000;
+
+    private final Handler mHandler;
+
+    // Reference to ConnectivityService#mNetworkForNetId, must be synchronized on itself.
+    // mHandler in this class is associated with the ConnectivityService handler thread.
+    // The only code that can update mNetworkForNetId runs on that thread, so no entries can be
+    // updated while the code in this class is running on mHandler thread.
+    @GuardedBy("mNetworkForNetId")
+    private final SparseArray<NetworkAgentInfo> mNetworkForNetId;
+
+    @NonNull
+    private final Dependencies mDeps;
+
+    /**
+     * Class to store the necessary information for closing a QUIC connection.
+     */
+    private static class QuicConnectionCloseInfo {
+        public final int uid;
+        public final int netId;
+        public final long cookie;
+        public final InetSocketAddress src;
+        public final InetSocketAddress dst;
+        public final byte[] payload;
+
+        QuicConnectionCloseInfo(int uid, int netId, long cookie, InetSocketAddress src,
+                InetSocketAddress dst, byte[] payload) {
+            this.uid = uid;
+            this.netId = netId;
+            this.cookie = cookie;
+            this.src = src;
+            this.dst = dst;
+            this.payload = payload;
+        }
+
+        @Override
+        public String toString() {
+            return "QuicConnectionCloseInfo{"
+                    + "uid: " + uid
+                    + ", netId: " + netId
+                    + ", cookie: " + cookie
+                    + ", src: " + src
+                    + ", dst: " + dst
+                    + ", payload length: " + payload.length
+                    + "}";
+        }
+    }
+
+    public static class Dependencies {
+        /**
+         * Send a UDP packet with the specified source and destination address and port over the
+         * specified network.
+         *
+         * @param network The {@link Network} over which the UDP packet will be sent.
+         * @param src     The source {@link InetSocketAddress} of the UDP packet to be sent.
+         * @param dst     The destination {@link InetSocketAddress} of the UDP packet to be sent.
+         * @param payload The UDP payload to be sent.
+         */
+        public void sendQuicConnectionClosePayload(final Network network,
+                final InetSocketAddress src, final InetSocketAddress dst, final byte[] payload)
+                throws IOException, ErrnoException {
+            final DatagramSocket socket = new DatagramSocket(src);
+            network.bindSocket(socket);
+            socket.connect(dst);
+            Os.setsockoptTimeval(socket.getFileDescriptor$(), SOL_SOCKET, SO_SNDTIMEO,
+                    StructTimeval.fromMillis(SOCKET_WRITE_TIMEOUT_MS));
+            Os.write(socket.getFileDescriptor$(), payload, 0 /* byteOffset */, payload.length);
+        }
+
+        /**
+         * Call {@link InetDiagMessage#destroyUdpSocket}
+         */
+        public void destroyUdpSocket(final InetSocketAddress src, final InetSocketAddress dst,
+                final long cookie)
+                throws SocketException, InterruptedIOException, ErrnoException {
+            InetDiagMessage.destroyUdpSocket(src, dst, cookie);
+        }
+
+        /**
+         * Call {@link SkDestroyListener#makeSkDestroyListener}
+         */
+        public SkDestroyListener makeSkDestroyListener(final Consumer<InetDiagMessage> consumer,
+                final Handler handler) {
+            return SkDestroyListener.makeSkDestroyListener(consumer, false /* monitorTcpSocket */,
+                    true /* monitorUdpSocket */, handler, new SharedLog(TAG));
+        }
+
+        /**
+         * Call {@link NetworkUtils#getSocketCookie}
+         */
+        public long getSocketCookie(final FileDescriptor fd) throws ErrnoException {
+            return NetworkUtils.getSocketCookie(fd);
+        }
+
+        /**
+         * Call {@link Os#getsockoptInt}
+         */
+        public int getsockoptInt(final FileDescriptor fd, final int level, final int option)
+                throws ErrnoException {
+            return Os.getsockoptInt(fd, level, option);
+        }
+
+        /**
+         * Call {@link Os#getsockname}}
+         */
+        public InetSocketAddress getsockname(final FileDescriptor fd) throws ErrnoException {
+            return (InetSocketAddress) Os.getsockname(fd);
+        }
+
+        /**
+         * Call {@link Os#getpeername}
+         */
+        public InetSocketAddress getpeername(final FileDescriptor fd) throws ErrnoException {
+            return (InetSocketAddress) Os.getpeername(fd);
+        }
+    }
+
+    public QuicConnectionCloser(final SparseArray<NetworkAgentInfo> networkForNetId,
+            final Handler handler) {
+        this(networkForNetId, handler, new Dependencies());
+    }
+
+    @VisibleForTesting
+    public QuicConnectionCloser(final SparseArray<NetworkAgentInfo> networkForNetId,
+            final Handler handler, final Dependencies deps) {
+        mNetworkForNetId = networkForNetId;
+        mHandler = handler;
+        mDeps = deps;
+
+        // handleUdpSocketDestroy must be posted to the thread to avoid racing with
+        // handleUnregisterQuicConnectionCloseInfo, even though they both run on the same thread.
+        // Specifically, the following can happen:
+        // unregisterQuicConnectionClosePayload posts handleUnregisterQuicConnectionCloseInfo to
+        // the handler and then closes the fd.
+        // The close() will cause the kernel to enqueue a netlink message to the SkDestroyHandler's
+        // fd.
+        // It's possible that the MessageQueue of the handler sees both the SkDestroyHandler's fd
+        // and the MessageQueue fd go active at the same time, and chooses to run the netlink
+        // event first.
+        // As a result, handleUdpSocketDestroy runs before handleUnregisterQuicConnectionCloseInfo,
+        // and the code incorrectly sends a close packet for a socket that the app has already
+        // unregistered.
+        // Posting handleUdpSocketDestroy to the handler ensures that it always runs after
+        // handleUnregisterQuicConnectionCloseInfo. It doesn't matter if the
+        // handleUdpSocketDestroy is delayed, because it will only send a packet if
+        // mRegisteredQuicConnectionCloseInfos contains the socket cookie, and socket cookies are
+        // never reused.
+        final SkDestroyListener udpSkDestroyListener = mDeps.makeSkDestroyListener(
+                (inetDiagMessage) -> handler.post(() -> handleUdpSocketDestroy(inetDiagMessage)),
+                handler);
+        handler.post(udpSkDestroyListener::start);
+    }
+
+    private void ensureRunningOnHandlerThread() {
+        HandlerUtils.ensureRunningOnHandlerThread(mHandler);
+    }
+
+    /**
+     * Close registered QUIC connection by uids
+     *
+     * @param uids target uids to close QUIC connections
+     */
+    public void closeQuicConnectionByUids(final Set<Integer> uids) {
+        ensureRunningOnHandlerThread();
+
+        for (Iterator<Map.Entry<Long, QuicConnectionCloseInfo>> it =
+                mRegisteredQuicConnectionCloseInfos.entrySet().iterator(); it.hasNext();) {
+            final QuicConnectionCloseInfo info = it.next().getValue();
+            if (uids.contains(info.uid)) {
+                closeQuicConnection(info, true /* destroySocket */);
+                it.remove();
+            }
+        }
+    }
+
+    private NetworkAgentInfo getNetworkAgentInfoForNetId(int netId) {
+        synchronized (mNetworkForNetId) {
+            return mNetworkForNetId.get(netId);
+        }
+    }
+
+    private void closeQuicConnection(final QuicConnectionCloseInfo info,
+            final boolean destroySocket) {
+        ensureRunningOnHandlerThread();
+
+        Log.d(TAG, "Close QUIC socket for " + info + ", destroySocket=" + destroySocket);
+        final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(info.netId);
+        if (nai == null) return; // The network has gone away already
+
+        final boolean isLoopbackConnection = info.dst.getAddress().isLoopbackAddress();
+        final boolean lpContainsSourceAddress =
+                nai.linkProperties.getAddresses().contains(info.src.getAddress());
+        if (!isLoopbackConnection && !lpContainsSourceAddress) {
+            // The device should not send a packet with an unused source address.
+            // Loopback connections are closed exceptionally to simplify device local testing.
+            return;
+        }
+
+        if (destroySocket) {
+            try {
+                mDeps.destroyUdpSocket(info.src, info.dst, info.cookie);
+            } catch (ErrnoException | SocketException | InterruptedIOException e) {
+                if (e instanceof ErrnoException && ((ErrnoException) e).errno == ENOENT) {
+                    // This can happen if the socket is already closed, but unregister message is
+                    // not processed yet.
+                    return;
+                }
+                Log.e(TAG, "Failed to destroy QUIC socket for " + info + ": " + e);
+                return;
+            }
+        }
+
+        try {
+            mDeps.sendQuicConnectionClosePayload(nai.network(), info.src, info.dst, info.payload);
+        } catch (ErrnoException | IOException e) {
+            Log.e(TAG, "Failed to send registered QUIC connection close payload for "
+                    + info + ": " + e);
+        }
+    }
+
+    /**
+     * Close QUIC connection if the registered socket was destroyed
+     *
+     * @param inetDiagMessage {@link InetDiagMessage} received from kernel
+     */
+    private void handleUdpSocketDestroy(final InetDiagMessage inetDiagMessage) {
+        ensureRunningOnHandlerThread();
+
+        final long cookie = inetDiagMessage.inetDiagMsg.id.cookie;
+        final QuicConnectionCloseInfo info = mRegisteredQuicConnectionCloseInfos.remove(cookie);
+        if (info == null) {
+            // Destroyed socket is not registered or already unregistered.
+            return;
+        }
+
+        // App registered a QUIC connection close payload and this socket, but the socket was
+        // closed before the socket was unregistered.
+        // This can happen if the app crashes or is killed.
+        closeQuicConnection(info, false /* destroySocket */);
+    }
+
+    /**
+     * Register the QUIC connection close information
+     *
+     * @param info {@link QuicConnectionCloseInfo} to register
+     */
+    private void handleRegisterQuicConnectionCloseInfo(final QuicConnectionCloseInfo info) {
+        ensureRunningOnHandlerThread();
+
+        if (mRegisteredQuicConnectionCloseInfos.size()
+                >= MAX_REGISTERED_QUIC_CONNECTION_CLOSE_INFO) {
+            Log.e(TAG, "Failed to register QUIC connection close information."
+                    + " number of registered information exceeded "
+                    + MAX_REGISTERED_QUIC_CONNECTION_CLOSE_INFO);
+            return;
+        }
+        mRegisteredQuicConnectionCloseInfos.put(info.cookie, info);
+    }
+
+    // TODO: Use OsConstants.SO_MARK once this API is available
+    private static final int SO_MARK = 36;
+
+    /**
+     * Register QUIC socket and connection close payload
+     *
+     * @param uid The uid of the socket owner
+     * @param pfd The {@link ParcelFileDescriptor} for the connected UDP socket.
+     * @param payload The UDP payload that can close QUIC connection.
+     */
+    public void registerQuicConnectionClosePayload(final int uid, final ParcelFileDescriptor pfd,
+            final byte[] payload) {
+        try {
+            final FileDescriptor fd = pfd.getFileDescriptor();
+            // See FWMARK_NET_ID_MASK in Fwmark.h
+            final int netId = mDeps.getsockoptInt(fd, SOL_SOCKET, SO_MARK) & 0xffff;
+            // The peer name could change if the socket is reconnected to a different server.
+            // But, it is the caller's responsibility to avoid this, as explicitly stated in the
+            // Javadoc of ConnectivityManager#registerQuicConnectionClosePayload.
+            final QuicConnectionCloseInfo info = new QuicConnectionCloseInfo(
+                    uid,
+                    netId,
+                    mDeps.getSocketCookie(fd),
+                    mDeps.getsockname(fd),
+                    mDeps.getpeername(fd),
+                    payload);
+            mHandler.post(() -> handleRegisterQuicConnectionCloseInfo(info));
+        } catch (ErrnoException e) {
+            Log.e(TAG, "Failed to register QUIC connection close information", e);
+        } finally {
+            // |pfd| must remain open until the message is posted to the handler thread, because
+            // doing so ensures that the socket is not closed even if the app calls close().
+            // Keeping it open avoids the following threading issue with SkDestroyListener :
+            // If the PFD was closed before posting the message, then SkDestroyListener might
+            // get a "socket destroyed" message from Netlink immediately and post to the handler
+            // thread before this method posts its own message, resulting in a leak of the
+            // mRegisteredQuicConnectionCloseInfo entry.
+            // While the PFD is held, Netlink will not send the socket destroy message to
+            // SkDestroyListener, and thus the message posted by SkDestroyListener as
+            // a reaction to it will be processed after the message posted by this method.
+            IoUtils.closeQuietly(pfd);
+        }
+    }
+
+    /**
+     * Unregister the QUIC connection close information
+     *
+     * @param cookie cookie of the socket whose connection close information should be unregistered
+     */
+    private void handleUnregisterQuicConnectionCloseInfo(final long cookie) {
+        ensureRunningOnHandlerThread();
+
+        mRegisteredQuicConnectionCloseInfos.remove(cookie);
+    }
+
+    /**
+     * Unregister the QUIC socket
+     *
+     * @param pfd The {@link ParcelFileDescriptor} for the UDP socket.
+     */
+    public void unregisterQuicConnectionClosePayload(final ParcelFileDescriptor pfd) {
+        try {
+            final long cookie = mDeps.getSocketCookie(pfd.getFileDescriptor());
+            mHandler.post(() -> handleUnregisterQuicConnectionCloseInfo(cookie));
+        } catch (ErrnoException e) {
+            Log.e(TAG, "Failed to unregister QUIC connection close information: " + e);
+        } finally {
+            // |pfd| must be closed after posting the message to the handler thread to avoid the
+            // threading issue with SkDestroyListener.
+            // See the comment in registerQuicConnectionClosePayload.
+            IoUtils.closeQuietly(pfd);
+        }
+    }
+
+    /**
+     * Dump QUIC connection closer information
+     */
+    public void dump(final IndentingPrintWriter pw) {
+        pw.println("Registered QUIC connection close information: "
+                + mRegisteredQuicConnectionCloseInfos.size());
+        pw.increaseIndent();
+        for (QuicConnectionCloseInfo info: mRegisteredQuicConnectionCloseInfos.values()) {
+            pw.println(info);
+        }
+        pw.decreaseIndent();
+    }
+}
diff --git a/service/src/com/android/server/connectivity/SatelliteAccessController.java b/service/src/com/android/server/connectivity/SatelliteAccessController.java
index 2cdc932a12..4e804b9c02 100644
--- a/service/src/com/android/server/connectivity/SatelliteAccessController.java
+++ b/service/src/com/android/server/connectivity/SatelliteAccessController.java
@@ -16,49 +16,79 @@
 
 package com.android.server.connectivity;
 
+import static android.os.Process.INVALID_UID;
+
+import static com.android.server.connectivity.ConnectivityFlags.CONSTRAINED_DATA_SATELLITE_OPTIN;
+
 import android.Manifest;
 import android.annotation.NonNull;
 import android.app.role.OnRoleHoldersChangedListener;
 import android.app.role.RoleManager;
-import android.content.BroadcastReceiver;
 import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
 import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
+import android.os.Bundle;
 import android.os.Handler;
-import android.os.Process;
 import android.os.UserHandle;
-import android.os.UserManager;
+import android.text.TextUtils;
+import android.util.ArrayMap;
 import android.util.ArraySet;
-import android.util.Log;
 import android.util.SparseArray;
 
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.util.IndentingPrintWriter;
+import com.android.net.module.util.CollectionUtils;
+import com.android.net.module.util.DeviceConfigUtils;
+import com.android.net.module.util.HandlerUtils;
+import com.android.net.module.util.SharedLog;
 
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.Executor;
-import java.util.function.Consumer;
+import java.util.function.BiConsumer;
+
+import javax.annotation.CheckReturnValue;
 
 /**
  * Tracks the uid of all the default messaging application which are role_sms role and
  * satellite_communication permission complaint and requests ConnectivityService to create multi
  * layer request with satellite internet access support for the default message application.
- * @hide
+ *
+ * Note that this class is not thread safe and should only be accessed on the handler
+ * thread, except {@link #start()}.
  */
 public class SatelliteAccessController {
     private static final String TAG = SatelliteAccessController.class.getSimpleName();
+    // Shamelessly copied from telephony/satellite/SatelliteManager.java.
+    // TODO: Import from SatelliteManager when it is available.
+    @VisibleForTesting
+    public static final String PROPERTY_SATELLITE_DATA_OPTIMIZED =
+            "android.telephony.PROPERTY_SATELLITE_DATA_OPTIMIZED";
+    // This value is taken from android.os.UserHandle#PER_USER_RANGE.
+    @VisibleForTesting
+    public static final int PER_USER_RANGE = 100000;
+    private static final int MAX_LOG_ENTRIES = 50;
     private final Context mContext;
     private final Dependencies mDeps;
     private final DefaultMessageRoleListener mDefaultMessageRoleListener;
-    private final Consumer<Set<Integer>> mCallback;
+    private final BiConsumer<Set<Integer>, Set<Integer>> mCallback;
     private final Handler mConnectivityServiceHandler;
+    private final boolean mSupportConstrainedDataSatelliteOptIn;
+    private final SharedLog mLog = new SharedLog(MAX_LOG_ENTRIES, TAG);
 
     // At this sparseArray, Key is userId and values are uids of SMS apps that are allowed
     // to use satellite network as fallback.
-    private final SparseArray<Set<Integer>> mAllUsersSatelliteNetworkFallbackUidCache =
-            new SparseArray<>();
+    private final SparseArray<Set<Integer>> mSatelliteRoleSmsUids = new SparseArray<>();
+
+    // Set of UIDs that have declared the
+    // {@code android.telephony.PROPERTY_SATELLITE_DATA_OPTIMIZED} meta-data
+    // with a value of package name in their manifest file. This variable will only be
+    // accessed on the handler thread.
+    // See {@link SatelliteManager#PROPERTY_SATELLITE_DATA_OPTIMIZED}.
+    private final Set<Integer> mSatelliteDataOptInUids = new ArraySet<>();
+
+    private final ArrayMap<UserHandle, PackageManager> mUserPackageManagers = new ArrayMap<>();
 
     /**
      *  Monitor {@link android.app.role.OnRoleHoldersChangedListener#onRoleHoldersChanged(String,
@@ -69,9 +99,10 @@ public class SatelliteAccessController {
             implements OnRoleHoldersChangedListener {
         @Override
         public void onRoleHoldersChanged(String role, UserHandle userHandle) {
-            if (RoleManager.ROLE_SMS.equals(role)) {
-                Log.i(TAG, "ROLE_SMS Change detected ");
-                onRoleSmsChanged(userHandle);
+            HandlerUtils.ensureRunningOnHandlerThread(mConnectivityServiceHandler);
+            if (RoleManager.ROLE_SMS.equals(role) && updateSatelliteRoleSmsUids(userHandle)) {
+                mLog.i("ROLE_SMS Change detected ");
+                reportSatelliteNetworkFallbackUids();
             }
         }
 
@@ -80,13 +111,13 @@ public class SatelliteAccessController {
                 mDeps.addOnRoleHoldersChangedListenerAsUser(
                         mConnectivityServiceHandler::post, this, UserHandle.ALL);
             } catch (RuntimeException e) {
-                Log.wtf(TAG, "Could not register satellite controller listener due to " + e);
+                mLog.wtf("Could not register satellite controller listener due to " + e);
             }
         }
     }
 
     public SatelliteAccessController(@NonNull final Context c,
-            Consumer<Set<Integer>> callback,
+            BiConsumer<Set<Integer>, Set<Integer>> callback,
             @NonNull final Handler connectivityServiceInternalHandler) {
         this(c, new Dependencies(c), callback, connectivityServiceInternalHandler);
     }
@@ -108,43 +139,50 @@ public class SatelliteAccessController {
                 @NonNull OnRoleHoldersChangedListener listener, UserHandle user) {
             mRoleManager.addOnRoleHoldersChangedListenerAsUser(executor, listener, user);
         }
+
+        /** Return whether constrained data satellite opt-in is supported. */
+        public boolean supportConstrainedDataSatelliteOptIn(Context context) {
+            return DeviceConfigUtils.isTetheringFeatureNotChickenedOut(context,
+                    CONSTRAINED_DATA_SATELLITE_OPTIN);
+        }
     }
 
     @VisibleForTesting
     SatelliteAccessController(@NonNull final Context c, @NonNull final Dependencies deps,
-            Consumer<Set<Integer>> callback,
+            BiConsumer<Set<Integer>, Set<Integer>> callback,
             @NonNull final Handler connectivityServiceInternalHandler) {
         mContext = c;
         mDeps = deps;
         mDefaultMessageRoleListener = new DefaultMessageRoleListener();
         mCallback = callback;
         mConnectivityServiceHandler = connectivityServiceInternalHandler;
+        mSupportConstrainedDataSatelliteOptIn = mDeps.supportConstrainedDataSatelliteOptIn(c);
     }
 
-    private Set<Integer> updateSatelliteNetworkFallbackUidListCache(List<String> packageNames,
+    @NonNull
+    private Set<Integer> getRoleSmsUidsWithSatellitePermission(List<String> packageNames,
             @NonNull UserHandle userHandle) {
-        Set<Integer> fallbackUids = new ArraySet<>();
-        PackageManager pm =
-                mContext.createContextAsUser(userHandle, 0).getPackageManager();
+        final Set<Integer> roleSmsUids = new ArraySet<>();
+        final PackageManager pm = getPackageManagerForUser(userHandle);
         if (pm != null) {
             for (String packageName : packageNames) {
                 // Check if SATELLITE_COMMUNICATION permission is enabled for default sms
-                // application package before adding it part of satellite network fallback uid
+                // application package before adding it part of satellite network role-sms uid
                 // cache list.
                 if (isSatellitePermissionEnabled(pm, packageName)) {
                     int uid = getUidForPackage(pm, packageName);
-                    if (uid != Process.INVALID_UID) {
-                        fallbackUids.add(uid);
+                    if (uid != INVALID_UID) {
+                        roleSmsUids.add(uid);
                     }
                 }
             }
         } else {
-            Log.wtf(TAG, "package manager found null");
+            mLog.wtf("package manager found null for user " + userHandle);
         }
-        return fallbackUids;
+        return roleSmsUids;
     }
 
-    //Check if satellite communication is enabled for the package
+    // Check if satellite communication is enabled for the package
     private boolean isSatellitePermissionEnabled(PackageManager packageManager,
             String packageName) {
         return packageManager.checkPermission(
@@ -154,106 +192,292 @@ public class SatelliteAccessController {
 
     private int getUidForPackage(PackageManager packageManager, String pkgName) {
         if (pkgName == null) {
-            return Process.INVALID_UID;
+            return INVALID_UID;
         }
         try {
             ApplicationInfo applicationInfo = packageManager.getApplicationInfo(pkgName, 0);
             return applicationInfo.uid;
         } catch (PackageManager.NameNotFoundException exception) {
-            Log.e(TAG, "Unable to find uid for package: " + pkgName);
+            mLog.e("Unable to find uid for package: " + pkgName);
         }
-        return Process.INVALID_UID;
+        return INVALID_UID;
     }
 
-    // on Role sms change triggered by OnRoleHoldersChangedListener()
-    private void onRoleSmsChanged(@NonNull UserHandle userHandle) {
+    @CheckReturnValue
+    private boolean updateSatelliteRoleSmsUids(@NonNull UserHandle userHandle) {
         int userId = userHandle.getIdentifier();
-        if (userId == Process.INVALID_UID) {
-            Log.wtf(TAG, "Invalid User Id");
-            return;
+        if (userId == INVALID_UID) {
+            mLog.wtf("Invalid User Id for userHandle:" + userHandle);
+            return false;
         }
 
         //Returns empty list if no package exists
         final List<String> packageNames =
                 mDeps.getRoleHoldersAsUser(RoleManager.ROLE_SMS, userHandle);
 
-        // Store previous satellite fallback uid available
-        final Set<Integer> prevUidsForUser =
-                mAllUsersSatelliteNetworkFallbackUidCache.get(userId, new ArraySet<>());
-
-        Log.i(TAG, "currentUser : role_sms_packages: " + userId + " : " + packageNames);
+        // Store previous satellite role sms uid available
+        final Set<Integer> prevUidsForUser = mSatelliteRoleSmsUids.get(userId, new ArraySet<>());
         final Set<Integer> newUidsForUser =
-                updateSatelliteNetworkFallbackUidListCache(packageNames, userHandle);
-        Log.i(TAG, "satellite_fallback_uid: " + newUidsForUser);
+                getRoleSmsUidsWithSatellitePermission(packageNames, userHandle);
 
         // on Role change, update the multilayer request at ConnectivityService with updated
-        // satellite network fallback uid cache list of multiple users as applicable
+        // satellite network role-sms uid cache list of multiple users as applicable
         if (newUidsForUser.equals(prevUidsForUser)) {
-            return;
+            return false;
         }
 
-        mAllUsersSatelliteNetworkFallbackUidCache.put(userId, newUidsForUser);
-
-        // Update all users fallback cache for user, send cs fallback to update ML request
-        reportSatelliteNetworkFallbackUids();
+        mSatelliteRoleSmsUids.put(userId, newUidsForUser);
+        return true;
     }
 
     private void reportSatelliteNetworkFallbackUids() {
         // Merge all uids of multiple users available
-        Set<Integer> mergedSatelliteNetworkFallbackUidCache = new ArraySet<>();
-        for (int i = 0; i < mAllUsersSatelliteNetworkFallbackUidCache.size(); i++) {
-            mergedSatelliteNetworkFallbackUidCache.addAll(
-                    mAllUsersSatelliteNetworkFallbackUidCache.valueAt(i));
+        final Set<Integer> mergedSatelliteRoleSmsUids = new ArraySet<>();
+        for (int i = 0; i < mSatelliteRoleSmsUids.size(); i++) {
+            mergedSatelliteRoleSmsUids.addAll(mSatelliteRoleSmsUids.valueAt(i));
         }
-        Log.i(TAG, "merged uid list for multi layer request : "
-                + mergedSatelliteNetworkFallbackUidCache);
+        mLog.i("SmsRoleUids:" + mergedSatelliteRoleSmsUids
+                + " Opt-InUids:" + mSatelliteDataOptInUids);
 
         // trigger multiple layer request for satellite network fallback of multi user uids
-        mCallback.accept(mergedSatelliteNetworkFallbackUidCache);
+        final ArraySet<Integer> optInUids = new ArraySet(mSatelliteDataOptInUids);
+        // If the same UID is in both sets, keep it only in the first one, which grant
+        // stronger privilege to access the satellite network.
+        optInUids.removeAll(mergedSatelliteRoleSmsUids);
+        mCallback.accept(mergedSatelliteRoleSmsUids, optInUids);
     }
 
     public void start() {
-        mConnectivityServiceHandler.post(this::updateAllUserRoleSmsUids);
-
         // register sms OnRoleHoldersChangedListener
         mDefaultMessageRoleListener.register();
+    }
 
-        // Monitor for User removal intent, to update satellite fallback uids.
-        IntentFilter userRemovedFilter = new IntentFilter(Intent.ACTION_USER_REMOVED);
-        mContext.registerReceiver(new BroadcastReceiver() {
-            @Override
-            public void onReceive(Context context, Intent intent) {
-                final String action = intent.getAction();
-                if (Intent.ACTION_USER_REMOVED.equals(action)) {
-                    final UserHandle userHandle = intent.getParcelableExtra(Intent.EXTRA_USER);
-                    if (userHandle == null) return;
-                    updateSatelliteFallbackUidListOnUserRemoval(userHandle.getIdentifier());
-                } else {
-                    Log.wtf(TAG, "received unexpected intent: " + action);
-                }
+    @CheckReturnValue
+    private boolean updateSatelliteRoleSmsUidListOnUserRemoval(int userIdRemoved) {
+        mLog.i("user id removed:" + userIdRemoved);
+        if (mSatelliteRoleSmsUids.contains(userIdRemoved)) {
+            mSatelliteRoleSmsUids.remove(userIdRemoved);
+            return true; // Changed.
+        }
+        return false; // Unchanged.
+    }
+
+    /**
+     * Called when a user is added. See {link #ACTION_USER_ADDED}.
+     *
+     * Note that this method will also be called at start up once on the handler thread
+     * to iterate through all existing users.
+     *
+     * @param userHandle The userHandle of the added user. See {@link #EXTRA_USER_HANDLE}.
+     * @param apps The list of packages which is installed on the user.
+     */
+    public void onUserAddedWithInstalledPackageList(@NonNull UserHandle userHandle,
+            @NonNull List<PackageInfo> apps) {
+        HandlerUtils.ensureRunningOnHandlerThread(mConnectivityServiceHandler);
+        // Store PackageManager for user for later use.
+        final PackageManager pmForUser = getPackageManagerForUser(userHandle);
+
+        // Obtain uids with role sms and satellite communication permission for the added user.
+        final boolean roleSmsUidsChanged = updateSatelliteRoleSmsUids(userHandle);
+
+        boolean optInUidsChanged = false;
+        if (mSupportConstrainedDataSatelliteOptIn) {
+            final Set<Integer> satelliteDataOptInUidsForUser =
+                    getSatelliteDataOptInUidsForUser(pmForUser, apps);
+            if (satelliteDataOptInUidsForUser.size() > 0) {
+                mLog.i("Add SatelliteDataOptInUids for user " + userHandle + ": "
+                        + satelliteDataOptInUidsForUser);
+                mSatelliteDataOptInUids.addAll(satelliteDataOptInUidsForUser);
+                optInUidsChanged = true;
             }
-        }, userRemovedFilter, null, mConnectivityServiceHandler);
+        }
+        if (roleSmsUidsChanged || optInUidsChanged) {
+            reportSatelliteNetworkFallbackUids();
+        }
+    }
+
+    /**
+     * Called when a user is removed. See {link #ACTION_USER_REMOVED}.
+     *
+     * @param userHandle The integer userHandle of the removed user. See {@link #EXTRA_USER_HANDLE}.
+     */
+    public void onUserRemoved(@NonNull UserHandle userHandle) {
+        HandlerUtils.ensureRunningOnHandlerThread(mConnectivityServiceHandler);
+        final boolean smsRoleUidsChanged =
+                updateSatelliteRoleSmsUidListOnUserRemoval(userHandle.getIdentifier());
+        final boolean satelliteOptInUidsChanged;
+        mUserPackageManagers.remove(userHandle);
+        if (mSupportConstrainedDataSatelliteOptIn) {
+            satelliteOptInUidsChanged =
+                    removeSatelliteDataOptInUidsForUser(userHandle.getIdentifier());
+        } else {
+            satelliteOptInUidsChanged = false;
+        }
+        if (smsRoleUidsChanged || satelliteOptInUidsChanged) {
+            reportSatelliteNetworkFallbackUids();
+        }
+    }
+
+    /**
+     * Called when a package is added.
+     *
+     * @param packageName The name of the new package.
+     * @param uid The uid of the new package.
+     */
+    public void onPackageAdded(@NonNull final String packageName, final int uid) {
+        HandlerUtils.ensureRunningOnHandlerThread(mConnectivityServiceHandler);
+        if (!mSupportConstrainedDataSatelliteOptIn) return;
+        if (addSatelliteDataOptInUid(packageName, uid)) {
+            reportSatelliteNetworkFallbackUids();
+        }
+    }
 
+    @CheckReturnValue
+    private boolean addSatelliteDataOptInUid(@NonNull final String packageName, final int uid) {
+        if (mSupportConstrainedDataSatelliteOptIn
+                && isSatelliteDataOptimizedApp(getPackageManagerForUid(uid), packageName)) {
+            mSatelliteDataOptInUids.add(uid);
+            return true;
+        }
+        return false;
     }
 
-    private void updateAllUserRoleSmsUids() {
-        UserManager userManager = mContext.getSystemService(UserManager.class);
-        // get existing user handles of available users
-        List<UserHandle> existingUsers = userManager.getUserHandles(true /*excludeDying*/);
+    /**
+     * Called when the availability of external applications changes.
+     *
+     * @param pkgList An array of package names that have become available.
+     */
+    public void onExternalApplicationsAvailable(String[] pkgList) {
+        HandlerUtils.ensureRunningOnHandlerThread(mConnectivityServiceHandler);
+        if (!mSupportConstrainedDataSatelliteOptIn) return;
+        if (CollectionUtils.isEmpty(pkgList)) {
+            mLog.e("No available external application.");
+            return;
+        }
 
-        // Iterate through the user handles and obtain their uids with role sms and satellite
-        // communication permission
-        Log.i(TAG, "existing users: " + existingUsers);
-        for (UserHandle userHandle : existingUsers) {
-            onRoleSmsChanged(userHandle);
+        boolean added = false;
+        for (String app : pkgList) {
+            for (final PackageManager pm : mUserPackageManagers.values()) {
+                final int uid = getUidForPackage(pm, app);
+                if (uid != INVALID_UID && addSatelliteDataOptInUid(app, uid)) {
+                    added = true;
+                }
+            }
         }
+        if (added) {
+            reportSatelliteNetworkFallbackUids();
+        }
+    }
+
+    @NonNull
+    private PackageManager getPackageManagerForUid(int uid) {
+        return getPackageManagerForUser(UserHandle.getUserHandleForUid(uid));
     }
 
-    private void updateSatelliteFallbackUidListOnUserRemoval(int userIdRemoved) {
-        Log.i(TAG, "user id removed:" + userIdRemoved);
-        if (mAllUsersSatelliteNetworkFallbackUidCache.contains(userIdRemoved)) {
-            mAllUsersSatelliteNetworkFallbackUidCache.remove(userIdRemoved);
+    /**
+     * Called when a package is removed.
+     *
+     * @param packageName The name of the removed package or null.
+     * @param uid containing the integer uid previously assigned to the package.
+     */
+    public void onPackageRemoved(@NonNull final String packageName, final int uid) {
+        HandlerUtils.ensureRunningOnHandlerThread(mConnectivityServiceHandler);
+        if (!mSupportConstrainedDataSatelliteOptIn) return;
+
+        // Scan for all apps sharing the same uid.
+        final PackageManager pmForUser = getPackageManagerForUid(uid);
+        final String [] pkgs = pmForUser.getPackagesForUid(uid);
+        if (pkgs != null) {
+            for (String pkg : pkgs) {
+                if (!pkg.equals(packageName) && isSatelliteDataOptimizedApp(pmForUser, pkg)) {
+                    return; // Early return if another satellite-optimized app shares the UID
+                }
+            }
+        }
+        // If the loop completes without returning, it means no other
+        // satellite-optimized app shares the UID.
+        final boolean removed = mSatelliteDataOptInUids.remove(uid);
+        if (removed) {
             reportSatelliteNetworkFallbackUids();
         }
     }
+
+    @NonNull
+    private Set<Integer> getSatelliteDataOptInUidsForUser(@NonNull PackageManager pmForUser,
+            @NonNull List<PackageInfo> apps) {
+        final ArraySet<Integer> uids = new ArraySet<>();
+        for (PackageInfo app : apps) {
+            if (null == app.applicationInfo || app.applicationInfo.uid < 0) continue;
+            if (isSatelliteDataOptimizedApp(pmForUser, app.packageName)) {
+                uids.add(app.applicationInfo.uid);
+            }
+        }
+        return uids;
+    }
+
+    private boolean isSatelliteDataOptimizedApp(@NonNull PackageManager pmForUser,
+            @NonNull String packageName) {
+        try {
+            final ApplicationInfo applicationInfo = pmForUser.getApplicationInfo(
+                    packageName, PackageManager.GET_META_DATA);
+            final Bundle metaData = applicationInfo.metaData;
+            if (metaData == null) return false;
+            // Retrieve the value as a generic Object to avoid Bundle warning log
+            // flooding when the format is mismatched.
+            final Object rawValue = metaData.get(PROPERTY_SATELLITE_DATA_OPTIMIZED);
+            if (rawValue == null) return false; // No expected meta-data.
+
+            // Check if the retrieved object is a matched String.
+            if (rawValue instanceof String
+                    && TextUtils.equals((String) rawValue, packageName)) {
+                return true;
+            }
+            // Logging if the value is not expected (e.g., Boolean, wrong package name).
+            mLog.i("Wrong meta-data format: " + packageName);
+            return false;
+        } catch (PackageManager.NameNotFoundException e) {
+            return false;
+        }
+    }
+
+    // Return true if changed.
+    @CheckReturnValue
+    private boolean removeSatelliteDataOptInUidsForUser(int userIdToRemove) {
+        return mSatelliteDataOptInUids.removeIf(uid -> uid / PER_USER_RANGE == userIdToRemove);
+    }
+
+    @NonNull
+    private PackageManager getPackageManagerForUser(UserHandle user) {
+        PackageManager pm = mUserPackageManagers.get(user);
+        if (pm == null) {
+            pm = mContext.createContextAsUser(user, 0 /* flag */).getPackageManager();
+            mUserPackageManagers.put(user, pm);
+        }
+        return pm;
+    }
+
+    // Return cached opt-in uid list for metrics sampling.
+    // Should only be called on handler thread.
+    public int getCachedOptInUidsCount() {
+        return mSatelliteDataOptInUids.size();
+    }
+
+    /** Dump info to dumpsys */
+    public void dump(@NonNull IndentingPrintWriter pw) {
+        HandlerUtils.ensureRunningOnHandlerThread(mConnectivityServiceHandler);
+        pw.println("SatelliteAccessController:");
+        pw.increaseIndent();
+        pw.println("SupportConstrainedDataSatelliteOptIn: "
+                + mSupportConstrainedDataSatelliteOptIn);
+        pw.print("Role-Sms Uids: ");
+        pw.print(mSatelliteRoleSmsUids);
+        pw.println();
+        pw.print("Opt-In Uids: ");
+        pw.print(mSatelliteDataOptInUids);
+        pw.println();
+        pw.println("Log:");
+        mLog.reverseDump(pw);
+        pw.decreaseIndent();
+        pw.println();
+    }
 }
diff --git a/service/src/com/android/server/net/L2capPacketForwarder.java b/service/src/com/android/server/net/L2capPacketForwarder.java
index 8420d60dde..a2a04b16d1 100644
--- a/service/src/com/android/server/net/L2capPacketForwarder.java
+++ b/service/src/com/android/server/net/L2capPacketForwarder.java
@@ -24,7 +24,6 @@ import android.os.Handler;
 import android.os.ParcelFileDescriptor;
 import android.system.ErrnoException;
 import android.system.Os;
-import android.system.OsConstants;
 import android.util.Log;
 
 import com.android.internal.annotations.VisibleForTesting;
@@ -74,10 +73,6 @@ public class L2capPacketForwarder {
          * bytes[] must be of size >= off + len.
          */
         void write(byte[] bytes, int off, int len) throws IOException;
-        /** Disallow further receptions, shutdown(fd, SHUT_RD) */
-        void shutdownRead();
-        /** Disallow further transmissions, shutdown(fd, SHUT_WR) */
-        void shutdownWrite();
         /** Close the fd */
         void close();
     }
@@ -124,30 +119,6 @@ public class L2capPacketForwarder {
             mOutputStream.write(bytes, off, len);
         }
 
-        @Override
-        public void shutdownRead() {
-            // BluetoothSocket does not expose methods to shutdown read / write individually;
-            // however, BluetoothSocket#close() shuts down both read and write and is safe to be
-            // called multiple times from any thread.
-            try {
-                mSocket.close();
-            } catch (IOException e) {
-                Log.w(TAG, "shutdownRead: Failed to close BluetoothSocket", e);
-            }
-        }
-
-        @Override
-        public void shutdownWrite() {
-            // BluetoothSocket does not expose methods to shutdown read / write individually;
-            // however, BluetoothSocket#close() shuts down both read and write and is safe to be
-            // called multiple times from any thread.
-            try {
-                mSocket.close();
-            } catch (IOException e) {
-                Log.w(TAG, "shutdownWrite: Failed to close BluetoothSocket", e);
-            }
-        }
-
         @Override
         public void close() {
             // BluetoothSocket#close() is safe to be called multiple times.
@@ -160,10 +131,10 @@ public class L2capPacketForwarder {
     }
 
     @VisibleForTesting
-    public static class FdWrapper implements IReadWriteFd {
+    public static class TunWrapper implements IReadWriteFd {
         private final ParcelFileDescriptor mFd;
 
-        public FdWrapper(ParcelFileDescriptor fd) {
+        public TunWrapper(ParcelFileDescriptor fd) {
             mFd = fd;
         }
 
@@ -190,24 +161,6 @@ public class L2capPacketForwarder {
             }
         }
 
-        @Override
-        public void shutdownRead() {
-            try {
-                Os.shutdown(mFd.getFileDescriptor(), OsConstants.SHUT_RD);
-            } catch (ErrnoException e) {
-                Log.w(TAG, "shutdownRead: Failed to shutdown(fd, SHUT_RD)", e);
-            }
-        }
-
-        @Override
-        public void shutdownWrite() {
-            try {
-                Os.shutdown(mFd.getFileDescriptor(), OsConstants.SHUT_WR);
-            } catch (ErrnoException e) {
-                Log.w(TAG, "shutdownWrite: Failed to shutdown(fd, SHUT_WR)", e);
-            }
-        }
-
         @Override
         public void close() {
             try {
@@ -283,16 +236,14 @@ public class L2capPacketForwarder {
             }
         }
 
-        public void tearDown() {
+        public void requestStop() {
             mIsRunning = false;
-            mReadFd.shutdownRead();
-            mWriteFd.shutdownWrite();
         }
     }
 
     public L2capPacketForwarder(Handler handler, ParcelFileDescriptor tunFd, BluetoothSocket socket,
             boolean compressHdrs, ICallback cb) {
-        this(handler, new FdWrapper(tunFd), new BluetoothSocketWrapper(socket), compressHdrs, cb);
+        this(handler, new TunWrapper(tunFd), new BluetoothSocketWrapper(socket), compressHdrs, cb);
     }
 
     @VisibleForTesting
@@ -316,14 +267,10 @@ public class L2capPacketForwarder {
      * This operation closes both the passed tun fd and BluetoothSocket.
      **/
     public void tearDown() {
-        // Destroying both threads first guarantees that both read and write side of FD have been
-        // shutdown.
-        mIngressThread.tearDown();
-        mEgressThread.tearDown();
-
-        // In order to interrupt a blocking read on the BluetoothSocket, the BluetoothSocket must be
-        // closed (which triggers shutdown()). This means, the BluetoothSocket must be closed inside
-        // L2capPacketForwarder. Tear down the tun fd alongside it for consistency.
+        mIngressThread.requestStop();
+        mEgressThread.requestStop();
+
+        // BluetoothSocket#close() as well as closing the tun fd interrupts any blocking operations.
         mTunFd.close();
         mL2capFd.close();
 
diff --git a/staticlibs/Android.bp b/staticlibs/Android.bp
index abfc4473d4..9702715c92 100644
--- a/staticlibs/Android.bp
+++ b/staticlibs/Android.bp
@@ -81,6 +81,30 @@ java_library {
     },
 }
 
+// Contains staticlibs classes for use by NetworkStack
+java_library {
+    name: "net-utils-networkstack",
+    srcs: [
+        "device/com/android/net/module/util/ProcfsParsingUtils.java",
+        "device/com/android/net/module/util/dhcp6/*.java",
+        "framework/com/android/net/module/util/HexDump.java",
+    ],
+    sdk_version: "module_current",
+    min_sdk_version: "30",
+    target_sdk_version: "30",
+    visibility: [
+        "//packages/modules/Connectivity/tests:__subpackages__",
+        "//packages/modules/NetworkStack:__subpackages__",
+    ],
+    libs: [
+        "androidx.annotation_annotation",
+        "framework-annotations-lib",
+        "framework-connectivity.stubs.module_lib",
+        "net-utils-device-common-struct",
+        "net-utils-device-common-struct-base",
+    ],
+}
+
 java_library {
     name: "net-utils-dnspacket-common",
     srcs: [
@@ -229,6 +253,9 @@ java_library {
         "net-utils-device-common-struct",
         "net-utils-device-common-struct-base",
     ],
+    static_libs: [
+        "netd_aidl_interface-lateststable-java",
+    ],
     apex_available: [
         "com.android.tethering",
         "//apex_available:platform",
@@ -463,6 +490,9 @@ java_library {
         "framework-configinfrastructure.stubs.module_lib",
         "framework-connectivity.stubs.module_lib",
     ],
+    static_libs: [
+        "net-utils-framework-common",
+    ],
     lint: {
         strict_updatability_linting: true,
         error_checks: ["NewApi"],
diff --git a/staticlibs/device/com/android/net/module/util/FdEventsReader.java b/staticlibs/device/com/android/net/module/util/FdEventsReader.java
index f88883bf22..e6c01416b9 100644
--- a/staticlibs/device/com/android/net/module/util/FdEventsReader.java
+++ b/staticlibs/device/com/android/net/module/util/FdEventsReader.java
@@ -141,6 +141,11 @@ public abstract class FdEventsReader<BufferType> {
         return mPacketsReceived;
     }
 
+    /** Returns the FileDescriptor if the FdEventsReader is running, null otherwise. */
+    protected FileDescriptor getFd() {
+        return isRunning() ? mFd : null;
+    }
+
     /**
      * Subclasses MUST create the listening socket here, including setting all desired socket
      * options, interface or address/port binding, etc. The socket MUST be created nonblocking.
diff --git a/staticlibs/device/com/android/net/module/util/FeatureVersions.java b/staticlibs/device/com/android/net/module/util/FeatureVersions.java
index d0cf3fd2ca..78ef94a4ec 100644
--- a/staticlibs/device/com/android/net/module/util/FeatureVersions.java
+++ b/staticlibs/device/com/android/net/module/util/FeatureVersions.java
@@ -54,6 +54,8 @@ public class FeatureVersions {
     // The flag that enables this feature is in NetworkStack.
     public static final long FEATURE_DDR_IN_CONNECTIVITY =
             CONNECTIVITY_MODULE_ID + 35_11_00_000L;
+    // DnsResolver needs to support RESOLV_TRY_ALL_SERVERS when querying the SVCB record for
+    // the feature to behave properly.
     public static final long FEATURE_DDR_IN_DNSRESOLVER =
-            DNS_RESOLVER_MODULE_ID + 35_11_00_000L;
+            DNS_RESOLVER_MODULE_ID + 36_07_00_000L;
 }
diff --git a/staticlibs/device/com/android/net/module/util/PrivateAddressCoordinator.java b/staticlibs/device/com/android/net/module/util/PrivateAddressCoordinator.java
index 2ce5b86b01..e21d27127e 100644
--- a/staticlibs/device/com/android/net/module/util/PrivateAddressCoordinator.java
+++ b/staticlibs/device/com/android/net/module/util/PrivateAddressCoordinator.java
@@ -33,14 +33,13 @@ import android.net.LinkAddress;
 import android.net.LinkProperties;
 import android.net.Network;
 import android.net.NetworkCapabilities;
-import android.os.Build;
 import android.os.RemoteException;
+import android.provider.DeviceConfig;
 import android.util.ArrayMap;
 
 import androidx.annotation.Nullable;
 
 import com.android.internal.annotations.VisibleForTesting;
-import com.android.modules.utils.build.SdkLevel;
 
 import java.io.PrintWriter;
 import java.net.Inet4Address;
@@ -69,6 +68,9 @@ public class PrivateAddressCoordinator {
     // WARNING: Keep in sync with chooseDownstreamAddress
     public static final int PREFIX_LENGTH = 24;
 
+    public static final String TETHER_FORCE_RANDOM_PREFIX_BASE_SELECTION =
+            "tether_force_random_prefix_base_selection";
+
     // Upstream monitor would be stopped when tethering is down. When tethering restart, downstream
     // address may be requested before coordinator get current upstream notification. To ensure
     // coordinator do not select conflict downstream prefix, mUpstreamPrefixMap would not be cleared
@@ -97,14 +99,14 @@ public class PrivateAddressCoordinator {
         }
 
         /**
-         * Check whether or not one specific experimental feature is enabled according to {@link
-         * DeviceConfigUtils}.
+         * Check whether one specific experimental feature in Tethering module
+         * from {@link DeviceConfig} is not disabled.
          *
          * @param featureName The feature's name to look up.
          * @return true if this feature is enabled, or false if disabled.
          */
-        public boolean isFeatureEnabled(String featureName) {
-            return DeviceConfigUtils.isTetheringFeatureEnabled(mContext, featureName);
+        public boolean isFeatureNotChickenedOut(String featureName) {
+            return DeviceConfigUtils.isTetheringFeatureNotChickenedOut(mContext, featureName);
         }
     }
 
@@ -257,15 +259,8 @@ public class PrivateAddressCoordinator {
         return null;
     }
 
-    // TODO: Remove this method when SdkLevel.isAtLeastB() is fixed, aosp is at sdk level 36 or use
-    //  NetworkStackUtils.isAtLeast25Q2 when it is moved to a static lib.
-    public static boolean isAtLeast25Q2() {
-        return SdkLevel.isAtLeastB()  || (SdkLevel.isAtLeastV()
-                && "Baklava".equals(Build.VERSION.CODENAME));
-    }
-
     private int getRandomPrefixIndex() {
-        if (!isAtLeast25Q2()) return 0;
+        if (!mDeps.isFeatureNotChickenedOut(TETHER_FORCE_RANDOM_PREFIX_BASE_SELECTION)) return 0;
 
         final int random = getRandomInt() & 0xffffff;
         // This is to select the starting prefix range (/8, /12, or /16) instead of the actual
diff --git a/staticlibs/device/com/android/net/module/util/ProcfsParsingUtils.java b/staticlibs/device/com/android/net/module/util/ProcfsParsingUtils.java
new file mode 100644
index 0000000000..44fc94121b
--- /dev/null
+++ b/staticlibs/device/com/android/net/module/util/ProcfsParsingUtils.java
@@ -0,0 +1,355 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.net.module.util;
+
+import android.annotation.NonNull;
+import android.net.InetAddresses;
+import android.net.MacAddress;
+import android.util.Log;
+
+import com.android.internal.annotations.VisibleForTesting;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.net.Inet4Address;
+import java.net.Inet6Address;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.List;
+
+public final class ProcfsParsingUtils {
+    public static final String TAG = ProcfsParsingUtils.class.getSimpleName();
+
+    private static final Inet4Address IPV4_ADDR_ALL_HOST_MULTICAST =
+            (Inet4Address) InetAddresses.parseNumericAddress("224.0.0.1");
+
+    private static final String IPV6_CONF_PATH = "/proc/sys/net/ipv6/conf/";
+    private static final String IPV6_ANYCAST_PATH = "/proc/net/anycast6";
+    private static final String ETHER_MCAST_PATH = "/proc/net/dev_mcast";
+    private static final String IPV4_MCAST_PATH = "/proc/net/igmp";
+    private static final String IPV6_MCAST_PATH = "/proc/net/igmp6";
+    private static final String IPV4_DEFAULT_TTL_PATH = "/proc/sys/net/ipv4/ip_default_ttl";
+
+    private ProcfsParsingUtils() {
+    }
+
+    /**
+     * Reads the contents of a text file line by line.
+     *
+     * @param filePath The absolute path to the file to read.
+     * @return A List of Strings where each String represents a line from the file.
+     *         If an error occurs during reading, an empty list is returned, and an error is logged.
+     */
+    private static List<String> readFile(final String filePath) {
+        final List<String> lines = new ArrayList<>();
+        try (BufferedReader reader =
+                     Files.newBufferedReader(Paths.get(filePath), StandardCharsets.UTF_8)) {
+            String line;
+            while ((line = reader.readLine()) != null) {
+                lines.add(line);
+            }
+        } catch (IOException e) {
+            Log.wtf(TAG, "failed to read " + filePath, e);
+        }
+
+        return lines;
+    }
+
+    /**
+     * Parses the Neighbor Discovery traffic class from a list of strings.
+     *
+     * This function expects a list containing a single string representing the ND traffic class.
+     * If the list is empty or contains multiple lines, it assumes a default traffic class of 0.
+     *
+     * @param lines A list of strings, ideally containing one line with the ND traffic class.
+     * @return The parsed ND traffic class as an integer, or 0 if the input is invalid.
+     */
+    @VisibleForTesting
+    public static int parseNdTrafficClass(final List<String> lines) {
+        if (lines.size() != 1) {
+            return 0;   // default
+        }
+
+        return Integer.parseInt(lines.get(0));
+    }
+
+    /**
+     * Parses the default TTL value from the procfs file lines.
+     */
+    @VisibleForTesting
+    public static int parseDefaultTtl(final List<String> lines) {
+        if (lines.size() != 1) {
+            return 64;  // default ttl value as per rfc1700
+        }
+        try {
+            // ttl must be in the range [1, 255]
+            return Math.max(1, Math.min(255, Integer.parseInt(lines.get(0))));
+        } catch (NumberFormatException e) {
+            Log.e(TAG, "failed to parse default ttl.", e);
+            return 64; // default ttl value as per rfc1700
+        }
+    }
+
+    /**
+     * Parses anycast6 addresses associated with a specific interface from a list of strings.
+     *
+     * This function searches the input list for a line containing the specified interface name.
+     * If found, it extracts the IPv6 address from that line and
+     * converts it into an `Inet6Address` object.
+     *
+     * @param lines   A list of strings where each line is expected to contain
+     *                interface and address information.
+     * @param ifname  The name of the network interface to search for.
+     * @return        A list of The `Inet6Address` representing the anycast address
+     *                associated with the specified interface,
+     *                If an error occurs during parsing, an empty list is returned.
+     */
+    @VisibleForTesting
+    public static List<Inet6Address> parseAnycast6Addresses(
+            @NonNull List<String> lines, @NonNull String ifname) {
+        final List<Inet6Address> addresses = new ArrayList<>();
+        try {
+            for (String line : lines) {
+                final String[] fields = line.split("\\s+");
+                if (!fields[1].equals(ifname)) {
+                    continue;
+                }
+
+                final byte[] addr = HexDump.hexStringToByteArray(fields[2]);
+                addresses.add((Inet6Address) InetAddress.getByAddress(addr));
+            }
+        } catch (UnknownHostException e) {
+            Log.wtf("failed to convert to Inet6Address.", e);
+            addresses.clear();
+        }
+        return addresses;
+    }
+
+    /**
+     * Parses Ethernet multicast MAC addresses with a specific interface from a list of strings.
+     *
+     * @param lines A list of strings, each containing interface and MAC address information.
+     * @param ifname The name of the network interface for which to extract multicast addresses.
+     * @return A list of MacAddress objects representing the parsed multicast addresses.
+     */
+    @VisibleForTesting
+    public static List<MacAddress> parseEtherMulticastAddresses(
+            @NonNull List<String> lines, @NonNull String ifname) {
+        final List<MacAddress> addresses = new ArrayList<>();
+        for (String line: lines) {
+            final String[] fields = line.split("\\s+");
+            if (!fields[1].equals(ifname)) {
+                continue;
+            }
+
+            final byte[] addr = HexDump.hexStringToByteArray(fields[4]);
+            addresses.add(MacAddress.fromBytes(addr));
+        }
+
+        return addresses;
+    }
+
+    /**
+     * Parses IPv6 multicast addresses associated with a specific interface from a list of strings.
+     *
+     * @param lines A list of strings, each containing interface and IPv6 address information.
+     * @param ifname The name of the network interface for which to extract multicast addresses.
+     * @return A list of Inet6Address objects representing the parsed IPv6 multicast addresses.
+     *         If an error occurs during parsing, an empty list is returned.
+     */
+    @VisibleForTesting
+    public static List<Inet6Address> parseIPv6MulticastAddresses(
+            @NonNull List<String> lines, @NonNull String ifname) {
+        final List<Inet6Address> addresses = new ArrayList<>();
+        try {
+            for (String line: lines) {
+                final String[] fields = line.split("\\s+");
+                if (!fields[1].equals(ifname)) {
+                    continue;
+                }
+
+                final byte[] addr = HexDump.hexStringToByteArray(fields[2]);
+                addresses.add((Inet6Address) InetAddress.getByAddress(addr));
+            }
+        } catch (UnknownHostException e) {
+            Log.wtf(TAG, "failed to convert to Inet6Address.", e);
+            addresses.clear();
+        }
+
+        return addresses;
+    }
+
+    /**
+     * Parses IPv4 multicast addresses associated with a specific interface from a list of strings.
+     *
+     * @param lines A list of strings, each containing interface and IPv4 address information.
+     * @param ifname The name of the network interface for which to extract multicast addresses.
+     * @param endian The byte order of the address, almost always use native order.
+     * @return A list of Inet4Address objects representing the parsed IPv4 multicast addresses.
+     *         If an error occurs during parsing,
+     *         a list contains IPv4 all host (224.0.0.1) is returned.
+     */
+    @VisibleForTesting
+    public static List<Inet4Address> parseIPv4MulticastAddresses(
+            @NonNull List<String> lines, @NonNull String ifname, @NonNull ByteOrder endian) {
+        final List<Inet4Address> ipAddresses = new ArrayList<>();
+
+        try {
+            String name = "";
+            // parse output similar to `ip maddr` command (iproute2/ip/ipmaddr.c#read_igmp())
+            for (String line : lines) {
+                final String[] parts = line.trim().split("\\s+");
+                if (!line.startsWith("\t")) {
+                    name = parts[1];
+                    if (name.endsWith(":")) {
+                        name = name.substring(0, name.length() - 1);
+                    }
+                    continue;
+                }
+
+                if (!name.equals(ifname)) {
+                    continue;
+                }
+
+                final String hexIp = parts[0];
+                final byte[] ipArray = HexDump.hexStringToByteArray(hexIp);
+                final byte[] convertArray =
+                    (endian == ByteOrder.LITTLE_ENDIAN)
+                        ? convertIPv4BytesToBigEndian(ipArray) : ipArray;
+                final Inet4Address ipv4Address =
+                        (Inet4Address) InetAddress.getByAddress(convertArray);
+
+                ipAddresses.add(ipv4Address);
+            }
+        } catch (Exception e) {
+            Log.wtf(TAG, "failed to convert to Inet4Address.", e);
+            // always return IPv4 all host address (224.0.0.1) if any error during parsing.
+            // this aligns with kernel behavior, it will join 224.0.0.1 when the interface is up.
+            ipAddresses.clear();
+            ipAddresses.add(IPV4_ADDR_ALL_HOST_MULTICAST);
+        }
+
+        return ipAddresses;
+    }
+
+    /**
+     * Converts an IPv4 address from little-endian byte order to big-endian byte order.
+     *
+     * @param bytes The IPv4 address in little-endian byte order.
+     * @return The IPv4 address in big-endian byte order.
+     */
+    private static byte[] convertIPv4BytesToBigEndian(byte[] bytes) {
+        final ByteBuffer buffer = ByteBuffer.wrap(bytes);
+        buffer.order(ByteOrder.LITTLE_ENDIAN);
+        final ByteBuffer bigEndianBuffer = ByteBuffer.allocate(4);
+        bigEndianBuffer.order(ByteOrder.BIG_ENDIAN);
+        bigEndianBuffer.putInt(buffer.getInt());
+        return bigEndianBuffer.array();
+    }
+
+    /**
+     * Returns the default TTL value for IPv4 packets.
+     */
+    public static int getIpv4DefaultTtl() {
+        return parseDefaultTtl(readFile(IPV4_DEFAULT_TTL_PATH));
+    }
+
+    /**
+     * Returns the default HopLimit value for IPv6 packets.
+     */
+    public static int getIpv6DefaultHopLimit(@NonNull String ifname) {
+        final String hopLimitPath = IPV6_CONF_PATH + ifname + "/hop_limit";
+        return parseDefaultTtl(readFile(hopLimitPath));
+    }
+
+    /**
+     * Returns the traffic class for the specified interface.
+     * The function loads the existing traffic class from the file
+     * `/proc/sys/net/ipv6/conf/{ifname}/ndisc_tclass`. If the file does not exist, the
+     * function returns 0.
+     *
+     * @param ifname The name of the interface.
+     * @return The traffic class for the interface.
+     */
+    public static int getNdTrafficClass(final String ifname) {
+        final String ndTcPath = IPV6_CONF_PATH + ifname + "/ndisc_tclass";
+        final List<String> lines = readFile(ndTcPath);
+        return parseNdTrafficClass(lines);
+    }
+
+    /**
+     * The function loads the existing IPv6 anycast address from the file `/proc/net/anycast6`.
+     * If the file does not exist or the interface is not found, the function
+     * returns an empty list.
+     *
+     * @param ifname The name of the interface.
+     * @return A list of the IPv6 anycast addresses for the interface.
+     */
+    public static List<Inet6Address> getAnycast6Addresses(@NonNull String ifname) {
+        final List<String> lines = readFile(IPV6_ANYCAST_PATH);
+        return parseAnycast6Addresses(lines, ifname);
+    }
+
+    /**
+     * The function loads the existing Ethernet multicast addresses from
+     * the file `/proc/net/dev_mcast`.
+     * If the file does not exist or the interface is not found, the function returns empty list.
+     *
+     * @param ifname The name of the interface.
+     * @return A list of MacAddress objects representing the multicast addresses
+     *         found for the interface.
+     *         If the file cannot be read or there are no addresses, an empty list is returned.
+     */
+    public static List<MacAddress> getEtherMulticastAddresses(@NonNull String ifname) {
+        final List<String> lines = readFile(ETHER_MCAST_PATH);
+        return parseEtherMulticastAddresses(lines, ifname);
+    }
+
+    /**
+     * The function loads the existing IPv6 multicast addresses from the file `/proc/net/igmp6`.
+     * If the file does not exist or the interface is not found, the function returns empty list.
+     *
+     * @param ifname The name of the network interface to query.
+     * @return A list of Inet6Address objects representing the IPv6 multicast addresses
+     *         found for the interface.
+     *         If the file cannot be read or there are no addresses, an empty list is returned.
+     */
+    public static List<Inet6Address> getIpv6MulticastAddresses(@NonNull String ifname) {
+        final List<String> lines = readFile(IPV6_MCAST_PATH);
+        return parseIPv6MulticastAddresses(lines, ifname);
+    }
+
+    /**
+     * The function loads the existing IPv4 multicast addresses from the file `/proc/net/igmp6`.
+     * If the file does not exist or the interface is not found, the function returns empty list.
+     *
+     * @param ifname The name of the network interface to query.
+     * @return A list of Inet4Address objects representing the IPv4 multicast addresses
+     *         found for the interface.
+     *         If the file cannot be read or there are no addresses, an empty list is returned.
+     */
+    public static List<Inet4Address> getIPv4MulticastAddresses(@NonNull String ifname) {
+        final List<String> lines = readFile(IPV4_MCAST_PATH);
+        // follow the same pattern as NetlinkMonitor#handlePacket() for device's endian order
+        return parseIPv4MulticastAddresses(lines, ifname, ByteOrder.nativeOrder());
+    }
+}
diff --git a/staticlibs/device/com/android/net/module/util/RealtimeScheduler.java b/staticlibs/device/com/android/net/module/util/RealtimeScheduler.java
index 2d952237fa..4b3a143106 100644
--- a/staticlibs/device/com/android/net/module/util/RealtimeScheduler.java
+++ b/staticlibs/device/com/android/net/module/util/RealtimeScheduler.java
@@ -19,6 +19,7 @@ package com.android.net.module.util;
 import static android.os.MessageQueue.OnFileDescriptorEventListener.EVENT_ERROR;
 import static android.os.MessageQueue.OnFileDescriptorEventListener.EVENT_INPUT;
 
+import android.annotation.Nullable;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
@@ -218,12 +219,16 @@ public class RealtimeScheduler {
      *
      * If delayMs is less than or equal to 0, the message will be sent immediately.
      *
-     * @param msg the message to be sent
+     * @param what Value to assign to the returned Message.what field.
+     * @param arg1 Value to assign to the returned Message.arg1 field.
+     * @param arg2 Value to assign to the returned Message.arg2 field.
+     * @param obj Value to assign to the returned Message.obj field.
      * @param delayMs the delay time in milliseconds
      * @return true if the message is scheduled successfully, false otherwise.
      */
-    public boolean sendDelayedMessage(Message msg, long delayMs) {
-
+    public boolean sendDelayedMessage(int what, int arg1, int arg2, @Nullable Object obj,
+            long delayMs) {
+        final Message msg = mHandler.obtainMessage(what, arg1, arg2, obj);
         return enqueueTask(new MessageTask(msg, SystemClock.elapsedRealtime() + delayMs), delayMs);
     }
 
diff --git a/staticlibs/device/com/android/net/module/util/Struct.java b/staticlibs/device/com/android/net/module/util/Struct.java
index 69ca678c71..fec2c5bd94 100644
--- a/staticlibs/device/com/android/net/module/util/Struct.java
+++ b/staticlibs/device/com/android/net/module/util/Struct.java
@@ -123,6 +123,9 @@ public class Struct {
         EUI48,       // IEEE Extended Unique Identifier, a 48-bits long MAC address in network order
         Ipv4Address, // IPv4 address in network order
         Ipv6Address, // IPv6 address in network order
+        IpAddress,   // IP address in network order. IPv4 address is written to byte format as 
+                     // v4-mapped-v6 address. IpAddress should be used over Ipv6Address when 
+                     // the field wants to contain both v4 and v6 addresses.
     }
 
     /**
@@ -212,6 +215,9 @@ public class Struct {
             case Ipv6Address:
                 if (fieldType == Inet6Address.class) return;
                 break;
+            case IpAddress:
+                if (fieldType == InetAddress.class) return;
+                break;
             default:
                 throw new IllegalArgumentException("Unknown type" + annotation.type());
         }
@@ -254,6 +260,7 @@ public class Struct {
                 length = 4;
                 break;
             case Ipv6Address:
+            case IpAddress:
                 length = 16;
                 break;
             default:
@@ -442,6 +449,17 @@ public class Struct {
                     throw new IllegalArgumentException("illegal length of IP address", e);
                 }
                 break;
+            case IpAddress:
+                final byte[] ipAddress = new byte[16];
+                buf.get(ipAddress);
+                try {
+                    // InetAddress.getByAddress converts v4-mapped-v6 address to v4 address
+                    // internally and returns Inet4Address, otherwise returns Inet6Address.
+                    value = InetAddress.getByAddress(null /* host */, ipAddress);
+                } catch (UnknownHostException e) {
+                    throw new IllegalArgumentException("illegal length of IP address", e);
+                }
+                break;
             default:
                 throw new IllegalArgumentException("Unknown type:" + fieldInfo.annotation.type());
         }
@@ -533,6 +551,13 @@ public class Struct {
                 final byte[] address = ((InetAddress) value).getAddress();
                 output.put(address);
                 break;
+            case IpAddress:
+                InetAddress inetAddress = (InetAddress) value;
+                if (inetAddress instanceof Inet4Address) {
+                    inetAddress = InetAddressUtils.v4MappedV6Address((Inet4Address) value);
+                }
+                output.put(inetAddress.getAddress());
+                break;
             default:
                 throw new IllegalArgumentException("Unknown type:" + fieldInfo.annotation.type());
         }
@@ -749,7 +774,8 @@ public class Struct {
             } else if (fieldInfos[i].annotation.type() == Type.ByteArray) {
                 sb.append("0x").append(HexDump.toHexString((byte[]) value));
             } else if (fieldInfos[i].annotation.type() == Type.Ipv4Address
-                    || fieldInfos[i].annotation.type() == Type.Ipv6Address) {
+                    || fieldInfos[i].annotation.type() == Type.Ipv6Address
+                    || fieldInfos[i].annotation.type() == Type.IpAddress) {
                 sb.append(((InetAddress) value).getHostAddress());
             } else {
                 sb.append(value.toString());
diff --git a/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6AddrRegInformPacket.java b/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6AddrRegInformPacket.java
new file mode 100644
index 0000000000..265c41ffa8
--- /dev/null
+++ b/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6AddrRegInformPacket.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.net.module.util.dhcp6;
+
+import static com.android.net.module.util.NetworkStackConstants.DHCP_MAX_LENGTH;
+
+import androidx.annotation.NonNull;
+
+import java.nio.ByteBuffer;
+
+/**
+ * DHCPv6 ADDR-REG-INFORM packet class, a client sends an an ADDR-REG-INFORM message to register
+ * an IPv6 address is in use to DHCPv6 addr-reg server.
+ *
+ * https://www.rfc-editor.org/rfc/rfc9686.html#section-4.2
+ */
+public class Dhcp6AddrRegInformPacket extends Dhcp6Packet {
+    /**
+     * Generates a ADDR-REG-INFORM packet with the specified parameters.
+     */
+    Dhcp6AddrRegInformPacket(int transId, int elapsedTime, @NonNull final byte[] clientDuid,
+            @NonNull final byte[] iaAddress) {
+        super(transId, elapsedTime, clientDuid, null /* serverDuid */, null /* iapd */);
+        mIaAddress = iaAddress;
+    }
+
+    /**
+     * Build a DHCPv6 ADDR-REG-INFORM message with the specific parameters.
+     */
+    public ByteBuffer buildPacket() {
+        final ByteBuffer packet = ByteBuffer.allocate(DHCP_MAX_LENGTH);
+        final int msgTypeAndTransId = (DHCP6_MESSAGE_TYPE_ADDR_REG_INFORM << 24) | mTransId;
+        packet.putInt(msgTypeAndTransId);
+
+        addTlv(packet, DHCP6_CLIENT_IDENTIFIER, mClientDuid);
+        addTlv(packet, DHCP6_ELAPSED_TIME, (short) (mElapsedTime & 0xFFFF));
+        addTlv(packet, DHCP6_IA_ADDR, mIaAddress);
+
+        packet.flip();
+        return packet;
+    }
+}
diff --git a/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6AdvertisePacket.java b/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6AdvertisePacket.java
new file mode 100644
index 0000000000..57dfb07c3c
--- /dev/null
+++ b/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6AdvertisePacket.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.net.module.util.dhcp6;
+
+import androidx.annotation.NonNull;
+
+import java.nio.ByteBuffer;
+
+/**
+ * DHCPv6 ADVERTISE packet class, a server sends an Advertise message to indicate that it's
+ * available for DHCP service, in response to a Solicit message received from a client.
+ *
+ * https://tools.ietf.org/html/rfc8415#page-24
+ */
+public class Dhcp6AdvertisePacket extends Dhcp6Packet {
+    /**
+     * Generates an advertise packet with the specified parameters.
+     */
+    Dhcp6AdvertisePacket(int transId, @NonNull final byte[] clientDuid,
+            @NonNull final byte[] serverDuid, final byte[] iapd) {
+        super(transId, 0 /* elapsedTime */, clientDuid, serverDuid, iapd);
+    }
+
+    /**
+     * Build a DHCPv6 Advertise message with the specific parameters.
+     */
+    public ByteBuffer buildPacket() {
+        final ByteBuffer packet = ByteBuffer.allocate(DHCP_MAX_LENGTH);
+        final int msgTypeAndTransId = (DHCP6_MESSAGE_TYPE_ADVERTISE << 24) | mTransId;
+        packet.putInt(msgTypeAndTransId);
+
+        addTlv(packet, DHCP6_CLIENT_IDENTIFIER, mClientDuid);
+        addTlv(packet, DHCP6_SERVER_IDENTIFIER, mServerDuid);
+        addTlv(packet, DHCP6_IA_PD, mIaPd);
+
+        packet.flip();
+        return packet;
+    }
+}
diff --git a/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6Packet.java b/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6Packet.java
new file mode 100644
index 0000000000..d93c1a2071
--- /dev/null
+++ b/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6Packet.java
@@ -0,0 +1,796 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.net.module.util.dhcp6;
+
+import android.net.MacAddress;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import com.android.internal.annotations.VisibleForTesting;
+import com.android.net.module.util.HexDump;
+import com.android.net.module.util.Struct;
+import com.android.net.module.util.structs.IaPdOption;
+import com.android.net.module.util.structs.IaPrefixOption;
+
+import java.nio.BufferUnderflowException;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Objects;
+import java.util.OptionalInt;
+
+/**
+ * Defines basic data and operations needed to build and use packets for the
+ * DHCPv6 protocol. Subclasses create the specific packets used at each
+ * stage of the negotiation.
+ *
+ * @hide
+ */
+public class Dhcp6Packet {
+    private static final String TAG = Dhcp6Packet.class.getSimpleName();
+    /** DHCP constants copied from NetworkStackConstants.java */
+    protected static final int DHCP_MAX_LENGTH = 1500;
+    protected static final int DHCP_MAX_OPTION_LEN = 255;
+
+    /**
+     * DHCPv6 Message Type.
+     */
+    public static final byte DHCP6_MESSAGE_TYPE_SOLICIT = 1;
+    public static final byte DHCP6_MESSAGE_TYPE_ADVERTISE = 2;
+    public static final byte DHCP6_MESSAGE_TYPE_REQUEST = 3;
+    public static final byte DHCP6_MESSAGE_TYPE_CONFIRM = 4;
+    public static final byte DHCP6_MESSAGE_TYPE_RENEW = 5;
+    public static final byte DHCP6_MESSAGE_TYPE_REBIND = 6;
+    public static final byte DHCP6_MESSAGE_TYPE_REPLY = 7;
+    public static final byte DHCP6_MESSAGE_TYPE_RELEASE = 8;
+    public static final byte DHCP6_MESSAGE_TYPE_DECLINE = 9;
+    public static final byte DHCP6_MESSAGE_TYPE_RECONFIGURE = 10;
+    public static final byte DHCP6_MESSAGE_TYPE_INFORMATION_REQUEST = 11;
+    public static final byte DHCP6_MESSAGE_TYPE_RELAY_FORW = 12;
+    public static final byte DHCP6_MESSAGE_TYPE_RELAY_REPL = 13;
+    public static final byte DHCP6_MESSAGE_TYPE_ADDR_REG_INFORM = 36;
+    public static final byte DHCP6_MESSAGE_TYPE_ADDR_REG_REPLY = 37;
+
+    /**
+     * DHCPv6 Optional Type: Client Identifier.
+     * DHCPv6 message from client must have this option.
+     */
+    public static final byte DHCP6_CLIENT_IDENTIFIER = 1;
+    @NonNull
+    protected final byte[] mClientDuid;
+
+    /**
+     * DHCPv6 Optional Type: Server Identifier.
+     */
+    public static final byte DHCP6_SERVER_IDENTIFIER = 2;
+    @Nullable
+    protected final byte[] mServerDuid;
+
+    /**
+     * DHCPv6 Optional Type: IA Address option.
+     */
+    public static final byte DHCP6_IA_ADDR = 5;
+    @Nullable
+    protected byte[] mIaAddress;
+
+    /**
+     * DHCPv6 Optional Type: Option Request Option.
+     */
+    public static final byte DHCP6_OPTION_REQUEST_OPTION = 6;
+
+    /**
+     * DHCPv6 Optional Type: Elapsed time.
+     * This time is expressed in hundredths of a second.
+     */
+    public static final byte DHCP6_ELAPSED_TIME = 8;
+    protected final int mElapsedTime;
+
+    /**
+     * DHCPv6 Optional Type: Status Code.
+     */
+    public static final byte DHCP6_STATUS_CODE = 13;
+    private static final byte MIN_STATUS_CODE_OPT_LEN = 6;
+    protected short mStatusCode;
+
+    public static final short STATUS_SUCCESS           = 0;
+    public static final short STATUS_UNSPEC_FAIL       = 1;
+    public static final short STATUS_NO_ADDRS_AVAIL    = 2;
+    public static final short STATUS_NO_BINDING        = 3;
+    public static final short STATUS_NOT_ONLINK        = 4;
+    public static final short STATUS_USE_MULTICAST     = 5;
+    public static final short STATUS_NO_PREFIX_AVAIL   = 6;
+
+    /**
+     * DHCPv6 zero-length Optional Type: Rapid Commit. Per RFC4039, both DHCPDISCOVER and DHCPACK
+     * packet may include this option.
+     */
+    public static final byte DHCP6_RAPID_COMMIT = 14;
+    public boolean mRapidCommit;
+
+    /**
+     * DHCPv6 Optional Type: IA_PD.
+     */
+    public static final byte DHCP6_IA_PD = 25;
+    @NonNull
+    protected final byte[] mIaPd;
+    @NonNull
+    protected PrefixDelegation mPrefixDelegation;
+
+    /**
+     * DHCPv6 Optional Type: IA Prefix Option.
+     */
+    public static final byte DHCP6_IAPREFIX = 26;
+
+    /**
+     * DHCPv6 Optional Type: SOL_MAX_RT.
+     */
+    public static final byte DHCP6_SOL_MAX_RT = 82;
+    private OptionalInt mSolMaxRt;
+
+    /**
+     * DHCPv6 zero-length Optional Type: The Address Registration option. Per RFC9686, the client
+     * can discover if the DHCPv6 infrastructure supports address registration by including this
+     * option in the Option Request options that it sends.
+     */
+    public static final short DHCP6_OPTION_ADDR_REG_ENABLE = 148;
+    public boolean mAddrRegEnable;
+
+    /**
+     * The transaction identifier used in this particular DHCPv6 negotiation
+     */
+    protected final int mTransId;
+
+    /**
+     * The unique identifier for IA_NA, IA_TA, IA_PD used in this particular DHCPv6 negotiation
+     */
+    protected int mIaid;
+    // Per rfc8415#section-12, the IAID MUST be consistent across restarts.
+    // Since currently only one IAID is supported, a well-known value can be used (0).
+    public static final int IAID = 0;
+
+    Dhcp6Packet(int transId, int elapsedTime, @NonNull final byte[] clientDuid,
+            final byte[] serverDuid, @NonNull final byte[] iapd) {
+        mTransId = transId;
+        mElapsedTime = elapsedTime;
+        mClientDuid = clientDuid;
+        mServerDuid = serverDuid;
+        mIaPd = iapd;
+    }
+
+    /**
+     * Returns the transaction ID.
+     */
+    public int getTransactionId() {
+        return mTransId;
+    }
+
+    /**
+     * Returns decoded IA_PD options associated with IA_ID.
+     */
+    public PrefixDelegation getPrefixDelegation() {
+        return mPrefixDelegation;
+    }
+
+    /**
+     * Returns IAID associated to IA_PD.
+     */
+    public int getIaid() {
+        return mIaid;
+    }
+
+    /**
+     * Returns the client's DUID.
+     */
+    @NonNull
+    public byte[] getClientDuid() {
+        return mClientDuid;
+    }
+
+    /**
+     * Returns the server's DUID.
+     */
+    @Nullable
+    public byte[] getServerDuid() {
+        return mServerDuid;
+    }
+
+    /**
+     * Returns the IA Address option.
+     */
+    @Nullable
+    public byte[] getIaAddress() {
+        return mIaAddress;
+    }
+
+    /**
+     * Returns the SOL_MAX_RT option value in milliseconds.
+     */
+    public OptionalInt getSolMaxRtMs() {
+        return mSolMaxRt;
+    }
+
+    /** Returns the OPTION_STATUS_CODE value as defined in rfc8415#section-21.13 */
+    public Short getStatusCode() {
+        return mStatusCode;
+    }
+
+    /**
+     * A class to take DHCPv6 IA_PD option allocated from server.
+     * https://www.rfc-editor.org/rfc/rfc8415.html#section-21.21
+     */
+    public static class PrefixDelegation {
+        public final int iaid;
+        public final int t1;
+        public final int t2;
+        @NonNull
+        public final List<IaPrefixOption> ipos;
+        public final short statusCode;
+
+        @VisibleForTesting
+        public PrefixDelegation(int iaid, int t1, int t2,
+                @NonNull final List<IaPrefixOption> ipos, short statusCode) {
+            Objects.requireNonNull(ipos);
+            this.iaid = iaid;
+            this.t1 = t1;
+            this.t2 = t2;
+            this.ipos = ipos;
+            this.statusCode = statusCode;
+        }
+
+        public PrefixDelegation(int iaid, int t1, int t2,
+                @NonNull final List<IaPrefixOption> ipos) {
+            this(iaid, t1, t2, ipos, STATUS_SUCCESS /* statusCode */);
+        }
+
+        /**
+         * Check whether or not the IA_PD option in DHCPv6 message is valid.
+         *
+         * TODO: ensure that the prefix has a reasonable lifetime, and the timers aren't too short.
+         */
+        public boolean isValid() {
+            if (iaid != IAID) {
+                Log.w(TAG, "IA_ID doesn't match, expected: " + IAID + ", actual: " + iaid);
+                return false;
+            }
+            if (t1 < 0 || t2 < 0) {
+                Log.e(TAG, "IA_PD option with invalid T1 " + t1 + " or T2 " + t2);
+                return false;
+            }
+            // Generally, t1 must be smaller or equal to t2 (except when t2 is 0).
+            if (t2 != 0 && t1 > t2) {
+                Log.e(TAG, "IA_PD option with T1 " + t1 + " greater than T2 " + t2);
+                return false;
+            }
+            return true;
+        }
+
+        /**
+         * Decode an IA_PD option from the byte buffer.
+         */
+        public static PrefixDelegation decode(@NonNull final ByteBuffer buffer)
+                throws ParseException {
+            try {
+                final int iaid = buffer.getInt();
+                final int t1 = buffer.getInt();
+                final int t2 = buffer.getInt();
+                final List<IaPrefixOption> ipos = new ArrayList<IaPrefixOption>();
+                short statusCode = STATUS_SUCCESS;
+                while (buffer.remaining() > 0) {
+                    final int original = buffer.position();
+                    final short optionType = buffer.getShort();
+                    final int optionLen = buffer.getShort() & 0xFFFF;
+                    switch (optionType) {
+                        case DHCP6_IAPREFIX:
+                            buffer.position(original);
+                            final IaPrefixOption ipo = Struct.parse(IaPrefixOption.class, buffer);
+                            Log.d(TAG, "IA Prefix Option: " + ipo);
+                            ipos.add(ipo);
+                            break;
+                        case DHCP6_STATUS_CODE:
+                            statusCode = buffer.getShort();
+                            // Skip the status message if any.
+                            if (optionLen > 2) {
+                                skipOption(buffer, optionLen - 2);
+                            }
+                            break;
+                        default:
+                            skipOption(buffer, optionLen);
+                    }
+                }
+                return new PrefixDelegation(iaid, t1, t2, ipos, statusCode);
+            } catch (BufferUnderflowException e) {
+                throw new ParseException(e.getMessage());
+            }
+        }
+
+        /**
+         * Build an IA_PD option from given specific parameters, including IA_PREFIX options.
+         */
+        public ByteBuffer build() {
+            return build(ipos);
+        }
+
+        /**
+         * Build an IA_PD option from given specific parameters, including IA_PREFIX options.
+         *
+         * Per RFC8415 section 21.13 if the Status Code option does not appear in a message in
+         * which the option could appear, the status of the message is assumed to be Success. So
+         * only put the Status Code option in IA_PD when the status code is not Success.
+         */
+        public ByteBuffer build(@NonNull final List<IaPrefixOption> input) {
+            final ByteBuffer iapd = ByteBuffer.allocate(IaPdOption.LENGTH
+                    + Struct.getSize(IaPrefixOption.class) * input.size()
+                    + (statusCode != STATUS_SUCCESS ? MIN_STATUS_CODE_OPT_LEN : 0));
+            iapd.putInt(iaid);
+            iapd.putInt(t1);
+            iapd.putInt(t2);
+            for (IaPrefixOption ipo : input) {
+                ipo.writeToByteBuffer(iapd);
+            }
+            if (statusCode != STATUS_SUCCESS) {
+                iapd.putShort(DHCP6_STATUS_CODE);
+                iapd.putShort((short) 2);
+                iapd.putShort(statusCode);
+            }
+            iapd.flip();
+            return iapd;
+        }
+
+        /**
+         * Return valid IA prefix options to be used and extended in the Reply message. It may
+         * return empty list if there isn't any valid IA prefix option in the Reply message.
+         *
+         * TODO: ensure that the prefix has a reasonable lifetime, and the timers aren't too short.
+         * and handle status code such as NoPrefixAvail.
+         */
+        public List<IaPrefixOption> getValidIaPrefixes() {
+            final List<IaPrefixOption> validIpos = new ArrayList<IaPrefixOption>();
+            for (IaPrefixOption ipo : ipos) {
+                if (!ipo.isValid()) continue;
+                validIpos.add(ipo);
+            }
+            return validIpos;
+        }
+
+        @Override
+        public String toString() {
+            return String.format("Prefix Delegation, iaid: %s, t1: %s, t2: %s, status code: %s,"
+                    + " IA prefix options: %s", iaid, t1, t2, statusCodeToString(statusCode), ipos);
+        }
+
+        /**
+         * Compare the preferred lifetime in the IA prefix optin list and return the minimum one.
+         */
+        public long getMinimalPreferredLifetime() {
+            long min = Long.MAX_VALUE;
+            for (IaPrefixOption ipo : ipos) {
+                min = (ipo.preferred != 0 && min > ipo.preferred) ? ipo.preferred : min;
+            }
+            return min;
+        }
+
+        /**
+         * Compare the valid lifetime in the IA prefix optin list and return the minimum one.
+         */
+        public long getMinimalValidLifetime() {
+            long min = Long.MAX_VALUE;
+            for (IaPrefixOption ipo : ipos) {
+                min = (ipo.valid != 0 && min > ipo.valid) ? ipo.valid : min;
+            }
+            return min;
+        }
+
+        /**
+         * Return IA prefix option list to be renewed/rebound.
+         *
+         * Per RFC8415#section-18.2.4, client must not include any prefixes that it didn't obtain
+         * from server or that are no longer valid (that have a valid lifetime of 0). Section-18.3.4
+         * also mentions that server can inform client that it will not extend the prefix by setting
+         * T1 and T2 to values equal to the valid lifetime, so in this case client has no point in
+         * renewing as well.
+         */
+        public List<IaPrefixOption> getRenewableIaPrefixes() {
+            final List<IaPrefixOption> toBeRenewed = getValidIaPrefixes();
+            toBeRenewed.removeIf(ipo -> ipo.preferred == 0 && ipo.valid == 0);
+            toBeRenewed.removeIf(ipo -> t1 == ipo.valid && t2 == ipo.valid);
+            return toBeRenewed;
+        }
+    }
+
+    /**
+     * DHCPv6 packet parsing exception.
+     */
+    public static class ParseException extends Exception {
+        ParseException(String msg) {
+            super(msg);
+        }
+    }
+
+    private static String statusCodeToString(short statusCode) {
+        switch (statusCode) {
+            case STATUS_SUCCESS:
+                return "Success";
+            case STATUS_UNSPEC_FAIL:
+                return "UnspecFail";
+            case STATUS_NO_ADDRS_AVAIL:
+                return "NoAddrsAvail";
+            case STATUS_NO_BINDING:
+                return "NoBinding";
+            case STATUS_NOT_ONLINK:
+                return "NotOnLink";
+            case STATUS_USE_MULTICAST:
+                return "UseMulticast";
+            case STATUS_NO_PREFIX_AVAIL:
+                return "NoPrefixAvail";
+            default:
+                return "Unknown";
+        }
+    }
+
+    private static void skipOption(@NonNull final ByteBuffer packet, int optionLen)
+            throws BufferUnderflowException {
+        for (int i = 0; i < optionLen; i++) {
+            packet.get();
+        }
+    }
+
+    /**
+     * Creates a concrete Dhcp6Packet from the supplied ByteBuffer.
+     *
+     * The buffer only starts with a UDP encapsulation (i.e. DHCPv6 message). A subset of the
+     * optional parameters are parsed and are stored in object fields. Client/Server message
+     * format:
+     *
+     *  0                   1                   2                   3
+     *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+     * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+     * |    msg-type   |               transaction-id                  |
+     * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+     * |                                                               |
+     * .                            options                            .
+     * .                 (variable number and length)                  .
+     * |                                                               |
+     * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+     */
+    private static Dhcp6Packet decode(@NonNull final ByteBuffer packet) throws ParseException {
+        int elapsedTime = 0;
+        byte[] iapd = null;
+        byte[] iaAddress = null;
+        byte[] serverDuid = null;
+        byte[] clientDuid = null;
+        short statusCode = STATUS_SUCCESS;
+        boolean rapidCommit = false;
+        boolean addrRegEnable = false;
+        int solMaxRt = 0;
+        PrefixDelegation pd = null;
+
+        packet.order(ByteOrder.BIG_ENDIAN);
+
+        // DHCPv6 message contents.
+        final int msgTypeAndTransId = packet.getInt();
+        final byte messageType = (byte) (msgTypeAndTransId >> 24);
+        final int transId = msgTypeAndTransId & 0xffffff;
+
+        /**
+         * Parse DHCPv6 options, option format:
+         *
+         * 0                   1                   2                   3
+         * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+         * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         * |          option-code          |           option-len          |
+         * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         * |                          option-data                          |
+         * |                      (option-len octets)                      |
+         * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         */
+        while (packet.hasRemaining()) {
+            try {
+                final short optionType = packet.getShort();
+                final int optionLen = packet.getShort() & 0xFFFF;
+                int expectedLen = 0;
+
+                switch(optionType) {
+                    case DHCP6_SERVER_IDENTIFIER:
+                        expectedLen = optionLen;
+                        final byte[] sduid = new byte[expectedLen];
+                        packet.get(sduid, 0 /* offset */, expectedLen);
+                        serverDuid = sduid;
+                        break;
+                    case DHCP6_CLIENT_IDENTIFIER:
+                        expectedLen = optionLen;
+                        final byte[] cduid = new byte[expectedLen];
+                        packet.get(cduid, 0 /* offset */, expectedLen);
+                        clientDuid = cduid;
+                        break;
+                    case DHCP6_IA_PD:
+                        expectedLen = optionLen;
+                        final byte[] bytes = new byte[expectedLen];
+                        packet.get(bytes, 0 /* offset */, expectedLen);
+                        iapd = bytes;
+                        pd = PrefixDelegation.decode(ByteBuffer.wrap(iapd));
+                        break;
+                    case DHCP6_RAPID_COMMIT:
+                        expectedLen = 0;
+                        rapidCommit = true;
+                        break;
+                    case DHCP6_ELAPSED_TIME:
+                        expectedLen = 2;
+                        elapsedTime = (int) (packet.getShort() & 0xFFFF);
+                        break;
+                    case DHCP6_STATUS_CODE:
+                        expectedLen = optionLen;
+                        statusCode = packet.getShort();
+                        // Skip the status message (if any), which is a UTF-8 encoded text string
+                        // suitable for display to the end user, but is not useful for Dhcp6Client
+                        // to decide how to properly handle the status code.
+                        if (optionLen - 2 > 0) {
+                            skipOption(packet, optionLen - 2);
+                        }
+                        break;
+                    case DHCP6_IA_ADDR:
+                        expectedLen = optionLen;
+                        final byte[] iaAddressBytes = new byte[16];
+                        packet.get(iaAddressBytes, 0 /* offset */, 16);
+                        iaAddress = iaAddressBytes;
+                        // TODO: support parsing preferred and valid lifetime.
+                        packet.getInt(); // preferred lifetime
+                        packet.getInt(); // valid lifetime
+                        // IAaddr-options are currently unsupported, skip over them.
+                        final int remainingBytesLength = optionLen - 16 - 8;
+                        if (remainingBytesLength > 0) {
+                            skipOption(packet, remainingBytesLength);
+                        }
+                        break;
+                    case DHCP6_SOL_MAX_RT:
+                        expectedLen = 4;
+                        solMaxRt = packet.getInt();
+                        break;
+                    case DHCP6_OPTION_ADDR_REG_ENABLE:
+                        expectedLen = 0;
+                        addrRegEnable = true;
+                        break;
+                    default:
+                        expectedLen = optionLen;
+                        // BufferUnderflowException will be thrown if option is truncated.
+                        skipOption(packet, optionLen);
+                        break;
+                }
+                if (expectedLen != optionLen) {
+                    throw new ParseException(
+                            "Invalid length " + optionLen + " for option " + optionType
+                                    + ", expected " + expectedLen);
+                }
+            } catch (BufferUnderflowException e) {
+                throw new ParseException(e.getMessage());
+            }
+        }
+
+        Dhcp6Packet newPacket;
+
+        switch(messageType) {
+            case DHCP6_MESSAGE_TYPE_SOLICIT:
+                newPacket = new Dhcp6SolicitPacket(transId, elapsedTime, clientDuid, iapd,
+                        rapidCommit);
+                break;
+            case DHCP6_MESSAGE_TYPE_ADVERTISE:
+                newPacket = new Dhcp6AdvertisePacket(transId, clientDuid, serverDuid, iapd);
+                break;
+            case DHCP6_MESSAGE_TYPE_REQUEST:
+                newPacket = new Dhcp6RequestPacket(transId, elapsedTime, clientDuid, serverDuid,
+                        iapd);
+                break;
+            case DHCP6_MESSAGE_TYPE_REPLY:
+                newPacket = new Dhcp6ReplyPacket(transId, clientDuid, serverDuid, iapd,
+                        rapidCommit);
+                break;
+            case DHCP6_MESSAGE_TYPE_RENEW:
+                newPacket = new Dhcp6RenewPacket(transId, elapsedTime, clientDuid, serverDuid,
+                        iapd);
+                break;
+            case DHCP6_MESSAGE_TYPE_REBIND:
+                newPacket = new Dhcp6RebindPacket(transId, elapsedTime, clientDuid, iapd);
+                break;
+            case DHCP6_MESSAGE_TYPE_ADDR_REG_INFORM:
+                newPacket = new Dhcp6AddrRegInformPacket(transId, elapsedTime, clientDuid,
+                        iaAddress);
+                break;
+            default:
+                throw new ParseException("Unimplemented DHCP6 message type %d" + messageType);
+        }
+
+        if (pd != null) {
+            newPacket.mPrefixDelegation = pd;
+            newPacket.mIaid = pd.iaid;
+        }
+        newPacket.mStatusCode = statusCode;
+        newPacket.mRapidCommit = rapidCommit;
+        newPacket.mSolMaxRt =
+                (solMaxRt >= 60 && solMaxRt <= 86400)
+                        ? OptionalInt.of(solMaxRt * 1000)
+                        : OptionalInt.empty();
+        newPacket.mAddrRegEnable = addrRegEnable;
+
+        return newPacket;
+    }
+
+    /**
+     * Parse a packet from an array of bytes, stopping at the given length.
+     */
+    public static Dhcp6Packet decode(@NonNull final byte[] packet, int length)
+            throws ParseException {
+        final ByteBuffer buffer = ByteBuffer.wrap(packet, 0, length).order(ByteOrder.BIG_ENDIAN);
+        return decode(buffer);
+    }
+
+    /**
+     * Follow RFC8415 section 18.2.9 and 18.2.10 to check if the received DHCPv6 message is valid.
+     */
+    public boolean isValid(int transId, @NonNull final byte[] clientDuid) {
+        if (mClientDuid == null) {
+            Log.e(TAG, "DHCPv6 message without Client DUID option");
+            return false;
+        }
+        if (!Arrays.equals(mClientDuid, clientDuid)) {
+            Log.e(TAG, "Unexpected client DUID " + HexDump.toHexString(mClientDuid)
+                    + ", expected " + HexDump.toHexString(clientDuid));
+            return false;
+        }
+        if (mTransId != transId) {
+            Log.e(TAG, "Unexpected transaction ID " + mTransId + ", expected " + transId);
+            return false;
+        }
+        if (mPrefixDelegation == null) {
+            Log.e(TAG, "DHCPv6 message without IA_PD option, ignoring");
+            return false;
+        }
+        if (!mPrefixDelegation.isValid()) {
+            Log.e(TAG, "DHCPv6 message takes invalid IA_PD option, ignoring");
+            return false;
+        }
+        //TODO: check if the status code is success or not.
+        return true;
+    }
+
+    /**
+     * Returns the client DUID, follows RFC 8415 and creates a client DUID
+     * based on the link-layer address(DUID-LL).
+     *
+     * TODO: use Struct to build and parse DUID.
+     *
+     * 0                   1                   2                   3
+     * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+     * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+     * |         DUID-Type (3)         |    hardware type (16 bits)    |
+     * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+     * .                                                               .
+     * .             link-layer address (variable length)              .
+     * .                                                               .
+     * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+     */
+    public static byte[] createClientDuid(@NonNull final MacAddress macAddress) {
+        final byte[] duid = new byte[10];
+        // type: Link-layer address(3)
+        duid[0] = (byte) 0x00;
+        duid[1] = (byte) 0x03;
+        // hardware type: Ethernet(1)
+        duid[2] = (byte) 0x00;
+        duid[3] = (byte) 0x01;
+        System.arraycopy(macAddress.toByteArray() /* src */, 0 /* srcPos */, duid /* dest */,
+                4 /* destPos */, 6 /* length */);
+        return duid;
+    }
+
+    /**
+     * Adds an optional parameter containing an array of bytes.
+     */
+    protected static void addTlv(ByteBuffer buf, short type, @NonNull byte[] payload) {
+        if (payload.length > DHCP_MAX_OPTION_LEN) {
+            throw new IllegalArgumentException("DHCP option too long: "
+                    + payload.length + " vs. " + DHCP_MAX_OPTION_LEN);
+        }
+        buf.putShort(type);
+        buf.putShort((short) payload.length);
+        buf.put(payload);
+    }
+
+    /**
+     * Adds an optional parameter containing a short integer.
+     */
+    protected static void addTlv(ByteBuffer buf, short type, short value) {
+        buf.putShort(type);
+        buf.putShort((short) 2);
+        buf.putShort(value);
+    }
+
+    /**
+     * Adds an optional parameter containing zero-length value.
+     */
+    protected static void addTlv(ByteBuffer buf, short type) {
+        buf.putShort(type);
+        buf.putShort((short) 0);
+    }
+
+    /**
+     * Builds a DHCPv6 SOLICIT packet from the required specified parameters.
+     */
+    public static ByteBuffer buildSolicitPacket(int transId, long millisecs,
+            @NonNull final byte[] iapd, @NonNull final byte[] clientDuid, boolean rapidCommit) {
+        final Dhcp6SolicitPacket pkt =
+                new Dhcp6SolicitPacket(transId, (int) (millisecs / 10) /* elapsed time */,
+                        clientDuid, iapd, rapidCommit);
+        return pkt.buildPacket();
+    }
+
+    /**
+     * Builds a DHCPv6 ADVERTISE packet from the required specified parameters.
+     */
+    public static ByteBuffer buildAdvertisePacket(int transId, @NonNull final byte[] iapd,
+            @NonNull final byte[] clientDuid, @NonNull final byte[] serverDuid) {
+        final Dhcp6AdvertisePacket pkt =
+                new Dhcp6AdvertisePacket(transId, clientDuid, serverDuid, iapd);
+        return pkt.buildPacket();
+    }
+
+    /**
+     * Builds a DHCPv6 REPLY packet from the required specified parameters.
+     */
+    public static ByteBuffer buildReplyPacket(int transId, @NonNull final byte[] iapd,
+            @NonNull final byte[] clientDuid, @NonNull final byte[] serverDuid,
+            boolean rapidCommit) {
+        final Dhcp6ReplyPacket pkt =
+                new Dhcp6ReplyPacket(transId, clientDuid, serverDuid, iapd, rapidCommit);
+        return pkt.buildPacket();
+    }
+
+    /**
+     * Builds a DHCPv6 REQUEST packet from the required specified parameters.
+     */
+    public static ByteBuffer buildRequestPacket(int transId, long millisecs,
+            @NonNull final byte[] iapd, @NonNull final byte[] clientDuid,
+            @NonNull final byte[] serverDuid) {
+        final Dhcp6RequestPacket pkt =
+                new Dhcp6RequestPacket(transId, (int) (millisecs / 10) /* elapsed time */,
+                        clientDuid, serverDuid, iapd);
+        return pkt.buildPacket();
+    }
+
+    /**
+     * Builds a DHCPv6 RENEW packet from the required specified parameters.
+     */
+    public static ByteBuffer buildRenewPacket(int transId, long millisecs,
+            @NonNull final byte[] iapd, @NonNull final byte[] clientDuid,
+            @NonNull final byte[] serverDuid) {
+        final Dhcp6RenewPacket pkt =
+                new Dhcp6RenewPacket(transId, (int) (millisecs / 10) /* elapsed time */, clientDuid,
+                        serverDuid, iapd);
+        return pkt.buildPacket();
+    }
+
+    /**
+     * Builds a DHCPv6 REBIND packet from the required specified parameters.
+     */
+    public static ByteBuffer buildRebindPacket(int transId, long millisecs,
+            @NonNull final byte[] iapd, @NonNull final byte[] clientDuid) {
+        final Dhcp6RebindPacket pkt = new Dhcp6RebindPacket(transId,
+                (int) (millisecs / 10) /* elapsed time */, clientDuid, iapd);
+        return pkt.buildPacket();
+    }
+}
diff --git a/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6RebindPacket.java b/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6RebindPacket.java
new file mode 100644
index 0000000000..5f795fe37a
--- /dev/null
+++ b/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6RebindPacket.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.net.module.util.dhcp6;
+
+import androidx.annotation.NonNull;
+
+import java.nio.ByteBuffer;
+
+/**
+ * DHCPv6 REBIND packet class, a client sends a Rebind message to any available server to extend
+ * the lifetimes on the leases assigned to the client and to update other configuration parameters.
+ * This message is sent after a client receives no response to a Renew message.
+ *
+ * https://tools.ietf.org/html/rfc8415#page-24
+ */
+public class Dhcp6RebindPacket extends Dhcp6Packet {
+    /**
+     * Generates a rebind packet with the specified parameters.
+     */
+    Dhcp6RebindPacket(int transId, int elapsedTime, @NonNull final byte[] clientDuid,
+            @NonNull final byte[] iapd) {
+        super(transId, elapsedTime, clientDuid, null /* serverDuid */, iapd);
+    }
+
+    /**
+     * Build a DHCPv6 Rebind message with the specific parameters.
+     */
+    public ByteBuffer buildPacket() {
+        final ByteBuffer packet = ByteBuffer.allocate(DHCP_MAX_LENGTH);
+        final int msgTypeAndTransId = (DHCP6_MESSAGE_TYPE_REBIND << 24) | mTransId;
+        packet.putInt(msgTypeAndTransId);
+
+        addTlv(packet, DHCP6_CLIENT_IDENTIFIER, getClientDuid());
+        addTlv(packet, DHCP6_ELAPSED_TIME, (short) (mElapsedTime & 0xFFFF));
+        addTlv(packet, DHCP6_IA_PD, mIaPd);
+
+        packet.flip();
+        return packet;
+    }
+}
diff --git a/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6RenewPacket.java b/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6RenewPacket.java
new file mode 100644
index 0000000000..7dc7267959
--- /dev/null
+++ b/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6RenewPacket.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.net.module.util.dhcp6;
+
+import androidx.annotation.NonNull;
+
+import java.nio.ByteBuffer;
+
+/**
+ * DHCPv6 RENEW packet class, a client sends an Renew message to the server that originally
+ * provided the client's leases and configuration parameters to extend the lifetimes on the
+ * leases assigned to the client and to update other configuration parameters.
+ *
+ * https://tools.ietf.org/html/rfc8415#page-24
+ */
+public class Dhcp6RenewPacket extends Dhcp6Packet {
+    /**
+     * Generates a renew packet with the specified parameters.
+     */
+    Dhcp6RenewPacket(int transId, int elapsedTime, @NonNull final byte[] clientDuid,
+            @NonNull final byte[] serverDuid, final byte[] iapd) {
+        super(transId, elapsedTime, clientDuid, serverDuid, iapd);
+    }
+
+    /**
+     * Build a DHCPv6 Renew message with the specific parameters.
+     */
+    public ByteBuffer buildPacket() {
+        final ByteBuffer packet = ByteBuffer.allocate(DHCP_MAX_LENGTH);
+        final int msgTypeAndTransId = (DHCP6_MESSAGE_TYPE_RENEW << 24) | mTransId;
+        packet.putInt(msgTypeAndTransId);
+
+        addTlv(packet, DHCP6_SERVER_IDENTIFIER, mServerDuid);
+        addTlv(packet, DHCP6_CLIENT_IDENTIFIER, mClientDuid);
+        addTlv(packet, DHCP6_ELAPSED_TIME, (short) (mElapsedTime & 0xFFFF));
+        addTlv(packet, DHCP6_IA_PD, mIaPd);
+
+        packet.flip();
+        return packet;
+    }
+}
diff --git a/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6ReplyPacket.java b/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6ReplyPacket.java
new file mode 100644
index 0000000000..74ccee2a60
--- /dev/null
+++ b/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6ReplyPacket.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.net.module.util.dhcp6;
+
+import androidx.annotation.NonNull;
+
+import java.nio.ByteBuffer;
+
+/**
+ * DHCPv6 REPLY packet class, a server sends an Reply message containing assigned leases
+ * and configuration parameters in response to a Solicit, Request, Renew or Rebind messages
+ * received from a client.
+ *
+ * https://tools.ietf.org/html/rfc8415#page-24
+ */
+public class Dhcp6ReplyPacket extends Dhcp6Packet {
+    /**
+     * Generates a reply packet with the specified parameters.
+     */
+    Dhcp6ReplyPacket(int transId, @NonNull final byte[] clientDuid,
+            @NonNull final byte[] serverDuid, final byte[] iapd, boolean rapidCommit) {
+        super(transId, 0 /* elapsedTime */, clientDuid, serverDuid, iapd);
+        mRapidCommit = rapidCommit;
+    }
+
+    /**
+     * Build a DHCPv6 Reply message with the specific parameters.
+     */
+    public ByteBuffer buildPacket() {
+        final ByteBuffer packet = ByteBuffer.allocate(DHCP_MAX_LENGTH);
+        final int msgTypeAndTransId = (DHCP6_MESSAGE_TYPE_REPLY << 24) | mTransId;
+        packet.putInt(msgTypeAndTransId);
+
+        addTlv(packet, DHCP6_CLIENT_IDENTIFIER, mClientDuid);
+        addTlv(packet, DHCP6_SERVER_IDENTIFIER, mServerDuid);
+        addTlv(packet, DHCP6_IA_PD, mIaPd);
+        if (mRapidCommit) {
+            addTlv(packet, DHCP6_RAPID_COMMIT);
+        }
+
+        packet.flip();
+        return packet;
+    }
+}
diff --git a/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6RequestPacket.java b/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6RequestPacket.java
new file mode 100644
index 0000000000..cfb16437db
--- /dev/null
+++ b/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6RequestPacket.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.net.module.util.dhcp6;
+
+import androidx.annotation.NonNull;
+
+import java.nio.ByteBuffer;
+
+/**
+ * DHCPv6 REQUEST packet class, a client sends a Request message to request configuration
+ * parameters, including addresses and/or delegated prefixes from a specific server.
+ *
+ * https://tools.ietf.org/html/rfc8415#page-24
+ */
+public class Dhcp6RequestPacket extends Dhcp6Packet {
+    /**
+     * Generates a request packet with the specified parameters.
+     */
+    Dhcp6RequestPacket(int transId, int elapsedTime, @NonNull final byte[] clientDuid,
+            @NonNull final byte[] serverDuid, final byte[] iapd) {
+        super(transId, elapsedTime, clientDuid, serverDuid, iapd);
+    }
+
+    /**
+     * Build a DHCPv6 Request message with the specific parameters.
+     */
+    public ByteBuffer buildPacket() {
+        final ByteBuffer packet = ByteBuffer.allocate(DHCP_MAX_LENGTH);
+        final int msgTypeAndTransId = (DHCP6_MESSAGE_TYPE_REQUEST << 24) | mTransId;
+        packet.putInt(msgTypeAndTransId);
+
+        addTlv(packet, DHCP6_SERVER_IDENTIFIER, mServerDuid);
+        addTlv(packet, DHCP6_CLIENT_IDENTIFIER, mClientDuid);
+        addTlv(packet, DHCP6_ELAPSED_TIME, (short) (mElapsedTime & 0xFFFF));
+        addTlv(packet, DHCP6_IA_PD, mIaPd);
+        addTlv(packet, DHCP6_OPTION_REQUEST_OPTION, DHCP6_SOL_MAX_RT);
+
+        packet.flip();
+        return packet;
+    }
+}
diff --git a/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6SolicitPacket.java b/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6SolicitPacket.java
new file mode 100644
index 0000000000..ff86052f64
--- /dev/null
+++ b/staticlibs/device/com/android/net/module/util/dhcp6/Dhcp6SolicitPacket.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.net.module.util.dhcp6;
+
+import androidx.annotation.NonNull;
+
+import java.nio.ByteBuffer;
+
+/**
+ * DHCPv6 SOLICIT packet class, a client sends a Solicit message to locate DHCPv6 servers.
+ *
+ * https://tools.ietf.org/html/rfc8415#page-24
+ */
+public class Dhcp6SolicitPacket extends Dhcp6Packet {
+    /**
+     * Generates a solicit packet with the specified parameters.
+     */
+    Dhcp6SolicitPacket(int transId, int elapsedTime, @NonNull final byte[] clientDuid,
+            final byte[] iapd, boolean rapidCommit) {
+        super(transId, elapsedTime, clientDuid, null /* serverDuid */, iapd);
+        mRapidCommit = rapidCommit;
+    }
+
+    /**
+     * Build a DHCPv6 Solicit message with the specific parameters.
+     */
+    public ByteBuffer buildPacket() {
+        final ByteBuffer packet = ByteBuffer.allocate(DHCP_MAX_LENGTH);
+        final int msgTypeAndTransId = (DHCP6_MESSAGE_TYPE_SOLICIT << 24) | mTransId;
+        packet.putInt(msgTypeAndTransId);
+
+        addTlv(packet, DHCP6_ELAPSED_TIME, (short) (mElapsedTime & 0xFFFF));
+        addTlv(packet, DHCP6_CLIENT_IDENTIFIER, mClientDuid);
+        addTlv(packet, DHCP6_IA_PD, mIaPd);
+        addTlv(packet, DHCP6_OPTION_REQUEST_OPTION, DHCP6_SOL_MAX_RT);
+        if (mRapidCommit) {
+            addTlv(packet, DHCP6_RAPID_COMMIT);
+        }
+
+        packet.flip();
+        return packet;
+    }
+}
diff --git a/staticlibs/device/com/android/net/module/util/ip/NetlinkMonitor.java b/staticlibs/device/com/android/net/module/util/ip/NetlinkMonitor.java
index 15a46337a3..b4309e76ba 100644
--- a/staticlibs/device/com/android/net/module/util/ip/NetlinkMonitor.java
+++ b/staticlibs/device/com/android/net/module/util/ip/NetlinkMonitor.java
@@ -41,6 +41,7 @@ import com.android.net.module.util.netlink.NetlinkMessage;
 import com.android.net.module.util.netlink.NetlinkUtils;
 
 import java.io.FileDescriptor;
+import java.io.InterruptedIOException;
 import java.net.SocketAddress;
 import java.net.SocketException;
 import java.nio.ByteBuffer;
@@ -95,6 +96,29 @@ public class NetlinkMonitor extends PacketReader {
         this(h, log, tag, family, bindGroups, DEFAULT_SOCKET_RECV_BUFSIZE);
     }
 
+    /**
+     * Send a netlink message on the underlying netlink socket.
+     *
+     * Any responses will be processed by {@link #processNetlinkMessage}. This is particularly
+     * useful to request a dump of the current state when the {@link NetlinkMonitor} is first
+     * created.
+     * This prevents having an application to open multiple netlink sockets of the same family (for
+     * example by using a utility function in {@link NetlinkUtils} which can introduce races.
+     *
+     * TODO(b/422484024): add builder support to NetlinkMessage and accept a NetlinkMessage object
+     * rather than a ByteBuffer.
+     */
+    public void sendNetlinkMessage(ByteBuffer msg) {
+        if (!isRunning()) throw new IllegalStateException("NetlinkMonitor must be running");
+
+        final FileDescriptor fd = getFd();
+        try {
+            Os.write(fd, msg);
+        } catch (ErrnoException | InterruptedIOException e) {
+            Log.e(mTag, "Failed to send netlink message", e);
+        }
+    }
+
     @Override
     protected FileDescriptor createFd() {
         FileDescriptor fd = null;
diff --git a/staticlibs/device/com/android/net/module/util/netlink/InetDiagMessage.java b/staticlibs/device/com/android/net/module/util/netlink/InetDiagMessage.java
index c9a89ec1dd..100987910f 100644
--- a/staticlibs/device/com/android/net/module/util/netlink/InetDiagMessage.java
+++ b/staticlibs/device/com/android/net/module/util/netlink/InetDiagMessage.java
@@ -24,9 +24,9 @@ import static android.system.OsConstants.IPPROTO_TCP;
 import static android.system.OsConstants.IPPROTO_UDP;
 import static android.system.OsConstants.NETLINK_INET_DIAG;
 
+import static com.android.net.module.util.netlink.NetlinkConstants.SOCKDIAG_MSG_HEADER_SIZE;
 import static com.android.net.module.util.netlink.NetlinkConstants.SOCK_DESTROY;
 import static com.android.net.module.util.netlink.NetlinkConstants.SOCK_DIAG_BY_FAMILY;
-import static com.android.net.module.util.netlink.NetlinkConstants.SOCKDIAG_MSG_HEADER_SIZE;
 import static com.android.net.module.util.netlink.NetlinkConstants.stringForAddressFamily;
 import static com.android.net.module.util.netlink.NetlinkConstants.stringForProtocol;
 import static com.android.net.module.util.netlink.NetlinkUtils.DEFAULT_RECV_BUFSIZE;
@@ -37,6 +37,7 @@ import static com.android.net.module.util.netlink.NetlinkUtils.connectToKernel;
 import static com.android.net.module.util.netlink.StructNlMsgHdr.NLM_F_DUMP;
 import static com.android.net.module.util.netlink.StructNlMsgHdr.NLM_F_REQUEST;
 
+import android.net.INetd;
 import android.net.util.SocketUtils;
 import android.os.Process;
 import android.os.SystemClock;
@@ -48,6 +49,9 @@ import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.annotation.VisibleForTesting;
 
+import com.android.net.module.util.CollectionUtils;
+import com.android.net.module.util.InetAddressUtils;
+
 import java.io.FileDescriptor;
 import java.io.IOException;
 import java.io.InterruptedIOException;
@@ -61,6 +65,7 @@ import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Objects;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Consumer;
@@ -76,6 +81,13 @@ import java.util.function.Predicate;
 public class InetDiagMessage extends NetlinkMessage {
     public static final String TAG = "InetDiagMessage";
     private static final int TIMEOUT_MS = 500;
+    /** Bitmask position for 'explicitlySelected' in Fwmark.h */
+    public static final int EXPLICITLY_SELECTED_BIT_SHIFT = 16;
+    /** Bitmask position for 'Permission' in Fwmark.h */
+    public static final int PERMISSION_SHIFT = 18;
+
+    /** FWMARK_NET_ID_MASK in Fwmark.h */
+    public static final int FWMARK_NET_ID_MASK = 0xFFFF;
 
     /**
      * Construct an inet_diag_req_v2 message. This method will throw
@@ -342,20 +354,27 @@ public class InetDiagMessage extends NetlinkMessage {
             FileDescriptor destroyFd, int proto, Predicate<InetDiagMessage> filter)
             throws SocketException, InterruptedIOException, ErrnoException {
         AtomicInteger destroyedSockets = new AtomicInteger(0);
-        Consumer<InetDiagMessage> handleNlDumpMsg = (diagMsg) -> {
-            if (filter.test(diagMsg)) {
-                try {
-                    sendNetlinkDestroyRequest(destroyFd, proto, diagMsg.inetDiagMsg.id,
-                            diagMsg.inetDiagMsg.idiag_family, 1 << diagMsg.inetDiagMsg.idiag_state);
-                    destroyedSockets.getAndIncrement();
-                } catch (InterruptedIOException | ErrnoException e) {
-                    if (!(e instanceof ErrnoException
-                            && ((ErrnoException) e).errno == ENOENT)) {
-                        Log.e(TAG, "Failed to destroy socket: diagMsg=" + diagMsg + ", " + e);
+        Consumer<InetDiagMessage> handleNlDumpMsg =
+                diagMsg -> {
+                    if (filter.test(diagMsg)) {
+                        try {
+                            sendNetlinkDestroyRequest(
+                                    destroyFd,
+                                    proto,
+                                    diagMsg.inetDiagMsg.id,
+                                    diagMsg.inetDiagMsg.idiag_family,
+                                    1 << diagMsg.inetDiagMsg.idiag_state);
+                            destroyedSockets.getAndIncrement();
+                        } catch (InterruptedIOException | ErrnoException e) {
+                            if (!(e instanceof ErrnoException
+                                    && ((ErrnoException) e).errno == ENOENT)) {
+                                Log.e(
+                                        TAG,
+                                        "Failed to destroy socket: diagMsg=" + diagMsg + ", " + e);
+                            }
+                        }
                     }
-                }
-            }
-        };
+                };
 
         NetlinkUtils.<InetDiagMessage>getAndProcessNetlinkDumpMessages(dumpReq,
                 NETLINK_INET_DIAG, InetDiagMessage.class, handleNlDumpMsg);
@@ -388,6 +407,26 @@ public class InetDiagMessage extends NetlinkMessage {
         return false;
     }
 
+    private static boolean containsMarkMatchedToNetId(
+            InetDiagMessage msg, @NonNull Set<Range<Integer>> netIdRanges) {
+        final StructNlAttr attr = findInetDiagMarkAttr(msg);
+        if (attr == null) return false;
+
+        final Integer fwMark = attr.getValueAsInteger();
+        if (fwMark == null) return false;
+        return CollectionUtils.any(
+                netIdRanges, range -> range.contains(fwMark & FWMARK_NET_ID_MASK));
+    }
+
+    private static StructNlAttr findInetDiagMarkAttr(InetDiagMessage msg) {
+        for (StructNlAttr attr : msg.nlAttrs) {
+            if (attr.nla_type == NetlinkUtils.INET_DIAG_MARK) {
+                return attr;
+            }
+        }
+        return null;
+    }
+
     private static boolean isLoopbackAddress(InetAddress addr) {
         if (addr.isLoopbackAddress()) return true;
         if (!(addr instanceof Inet6Address)) return false;
@@ -415,6 +454,17 @@ public class InetDiagMessage extends NetlinkMessage {
                 || srcAddr.equals(dstAddr);
     }
 
+    /** This returns the time taken to perform socket destruction including time spent in sleep. */
+    private static long destroyLiveTcpSockets(Predicate<InetDiagMessage> filter)
+            throws SocketException, InterruptedIOException, ErrnoException {
+        final long startTimeMs = SystemClock.elapsedRealtime();
+        destroySockets(
+                IPPROTO_TCP,
+                TCP_ALIVE_STATE_FILTER,
+                diagMsg -> filter.test(diagMsg) && !isLoopback(diagMsg) && !isAdbSocket(diagMsg));
+        return SystemClock.elapsedRealtime() - startTimeMs;
+    }
+
     private static void destroySockets(int proto, int states, Predicate<InetDiagMessage> filter)
             throws ErrnoException, SocketException, InterruptedIOException {
         FileDescriptor destroyFd = null;
@@ -425,7 +475,6 @@ public class InetDiagMessage extends NetlinkMessage {
 
             for (int family : List.of(AF_INET, AF_INET6)) {
                 byte[] req = makeNetlinkDumpRequest(proto, states, family);
-
                 try {
                     final int destroyedSockets = processNetlinkDumpAndDestroySockets(
                             req, destroyFd, proto, filter);
@@ -456,34 +505,27 @@ public class InetDiagMessage extends NetlinkMessage {
      */
     public static void destroyLiveTcpSockets(Set<Range<Integer>> ranges, Set<Integer> exemptUids)
             throws SocketException, InterruptedIOException, ErrnoException {
-        final long startTimeMs = SystemClock.elapsedRealtime();
-        destroySockets(IPPROTO_TCP, TCP_ALIVE_STATE_FILTER,
-                (diagMsg) -> !exemptUids.contains(diagMsg.inetDiagMsg.idiag_uid)
-                        && containsUid(diagMsg, ranges)
-                        && !isLoopback(diagMsg)
-                        && !isAdbSocket(diagMsg));
-        final long durationMs = SystemClock.elapsedRealtime() - startTimeMs;
+        final long durationMs =
+                destroyLiveTcpSockets(
+                        diagMsg ->
+                                !exemptUids.contains(diagMsg.inetDiagMsg.idiag_uid)
+                                        && containsUid(diagMsg, ranges));
         Log.d(TAG, "Destroyed live tcp sockets for uids=" + ranges + " exemptUids=" + exemptUids
                 + " in " + durationMs + "ms");
     }
 
     /**
-     * Close tcp sockets that match the following condition
-     *  1. TCP status is one of TCP_ESTABLISHED, TCP_SYN_SENT, and TCP_SYN_RECV
-     *  2. Owner uid of socket is in the targetUids
-     *  3. Socket is not loopback
-     *  4. Socket is not adb socket
+     * Close tcp sockets that match the following condition 1. TCP status is one of TCP_ESTABLISHED,
+     * TCP_SYN_SENT, and TCP_SYN_RECV 2. Owner uid of socket is in the targetUids 3. Socket is not
+     * loopback 4. Socket is not adb socket
      *
      * @param ownerUids target uids to close sockets
      */
-    public static void destroyLiveTcpSocketsByOwnerUids(Set<Integer> ownerUids)
+    public static void destroyLiveTcpSocketsByOwnerUids(@NonNull Set<Integer> ownerUids)
             throws SocketException, InterruptedIOException, ErrnoException {
-        final long startTimeMs = SystemClock.elapsedRealtime();
-        destroySockets(IPPROTO_TCP, TCP_ALIVE_STATE_FILTER,
-                (diagMsg) -> ownerUids.contains(diagMsg.inetDiagMsg.idiag_uid)
-                        && !isLoopback(diagMsg)
-                        && !isAdbSocket(diagMsg));
-        final long durationMs = SystemClock.elapsedRealtime() - startTimeMs;
+        Objects.requireNonNull(ownerUids);
+        final long durationMs =
+                destroyLiveTcpSockets(diagMsg -> ownerUids.contains(diagMsg.inetDiagMsg.idiag_uid));
         Log.d(TAG, "Destroyed live tcp sockets for uids=" + ownerUids + " in " + durationMs + "ms");
     }
 
@@ -491,7 +533,7 @@ public class InetDiagMessage extends NetlinkMessage {
      * Close the udp socket which can be uniquely identified with the cookie and other information.
      */
     public static void destroyUdpSocket(final InetSocketAddress src, final InetSocketAddress dst,
-            final int ifIndex, final long cookie)
+            final long cookie)
             throws ErrnoException, SocketException, InterruptedIOException {
         FileDescriptor fd = null;
 
@@ -502,7 +544,7 @@ public class InetDiagMessage extends NetlinkMessage {
             final StructInetDiagSockId id = new StructInetDiagSockId(
                     src,
                     dst,
-                    ifIndex,
+                    0 /* ifIndex */,
                     cookie
             );
             sendNetlinkDestroyRequest(fd, IPPROTO_UDP, id, (short) family, 0 /* state */);
@@ -511,6 +553,185 @@ public class InetDiagMessage extends NetlinkMessage {
         }
     }
 
+    /**
+     * Close tcp sockets that match the following condition 1. TCP status is one of TCP_ESTABLISHED,
+     * TCP_SYN_SENT, and TCP_SYN_RECV 2. Local address of socket is equal to the given address 3.
+     * Socket is not loopback 4. Socket is not adb socket 5. Sockets satisfying given
+     * conditions(netId ranges, UID ranges).
+     *
+     * @param address a local address to destroy sockets
+     * @param netIdRanges ranges of net IDs need to be matched
+     * @param uidRanges ranges of UIDs to destroy sockets
+     */
+    public static void destroyLiveTcpSocketsByLocalAddress(
+            @NonNull InetAddress address,
+            @Nullable Set<Range<Integer>> netIdRanges,
+            @Nullable Set<Range<Integer>> uidRanges)
+            throws SocketException, InterruptedIOException, ErrnoException {
+        final long durationMs =
+                destroyLiveTcpSockets(
+                        diagMsg -> matchesLocalAddressWithNetworkAndUser(
+                                address, netIdRanges, uidRanges, diagMsg));
+        Log.d(
+                TAG,
+                "Destroyed live tcp sockets for local address "
+                        + address
+                        + ", netIdRanges"
+                        + netIdRanges
+                        + ", uidRanges:"
+                        + uidRanges
+                        + " in "
+                        + durationMs
+                        + "ms");
+    }
+
+    /**
+     * Close tcp sockets that match the following condition 1. TCP status is one of TCP_ESTABLISHED,
+     * TCP_SYN_SENT, and TCP_SYN_RECV 2. Local address of socket is equal to the given address 3.
+     * Socket is not loopback 4. Socket is not adb socket 5. Sockets satisfying given
+     * conditions(interface ID).
+     *
+     * @param address a local address to destroy sockets
+     * @param interfaceId interface id needs to be referred for destroying sockets.
+     */
+    public static void destroyLiveTcpSocketsByLocalAddress(
+            @NonNull InetAddress address, int interfaceId)
+            throws SocketException, InterruptedIOException, ErrnoException {
+        final long durationMs =
+                destroyLiveTcpSockets(
+                        diagMsg ->
+                                matchesLocalAddressWithInterfaceId(address, interfaceId, diagMsg));
+        Log.d(
+                TAG,
+                "Destroyed live tcp sockets for local address "
+                        + address
+                        + ", interfaceId:"
+                        + interfaceId
+                        + " in "
+                        + durationMs
+                        + "ms");
+    }
+
+    /**
+     * Returns whether the |diagMsg| matches the following conditions : - is for a socket with the
+     * passed address - is on one of the passed netIds - belongs to an app with one of the passed
+     * UIDs
+     *
+     * @param address local address to compare
+     * @param netIdRanges a range of net IDs that needs to be matched. If null, netId is not
+     *     considered in this match result.
+     * @param uidRanges ranges of UIDs to destroy sockets, If null, netId is not considered in this
+     *     match result.
+     * @param diagMsg {@link InetDiagMessage} retrieved from kernel.
+     */
+    @VisibleForTesting
+    public static boolean matchesLocalAddressWithNetworkAndUser(
+            @NonNull InetAddress address,
+            @Nullable Set<Range<Integer>> netIdRanges,
+            @Nullable Set<Range<Integer>> uidRanges,
+            @NonNull InetDiagMessage diagMsg) {
+        if (!matchesLocalAddress(address, diagMsg)) {
+            // Socket's local address should be matched to the given address.
+            return false;
+        }
+        if (netIdRanges != null && !containsMarkMatchedToNetId(diagMsg, netIdRanges)) {
+            return false;
+        }
+        return uidRanges == null || containsUid(diagMsg, uidRanges);
+    }
+
+    /**
+     * Returns whether the address of InetDiagMessage matches the given address.
+     *
+     * @param address local address to compare
+     * @param interfaceId interface id to be referred. If it's 0, interface id is not considered in
+     *     this match result.
+     * @param diagMsg {@link InetDiagMessage} retrieved from kernel.
+     */
+    @VisibleForTesting
+    public static boolean matchesLocalAddressWithInterfaceId(
+            @NonNull InetAddress address, int interfaceId, @NonNull InetDiagMessage diagMsg) {
+        return (interfaceId == 0 || interfaceId == diagMsg.inetDiagMsg.id.ifIndex)
+                && matchesLocalAddress(address, diagMsg);
+    }
+
+    private static boolean matchesLocalAddress(
+            @NonNull InetAddress address, @NonNull InetDiagMessage diagMsg) {
+        final InetAddress addressDiag = diagMsg.inetDiagMsg.id.locSocketAddress.getAddress();
+        return address.equals(addressDiag)
+                || (address instanceof Inet4Address
+                        && addressDiag instanceof Inet6Address
+                        && addressDiag.equals(
+                                // TODO: Improve performance for computing this. b/418877261
+                                InetAddressUtils.v4MappedV6Address((Inet4Address) address)));
+    }
+
+    /**
+     * Close tcp sockets that match the following condition 1. TCP status is one of TCP_ESTABLISHED,
+     * TCP_SYN_SENT, and TCP_SYN_RECV 2. Socket is not loopback 3. Socket is not adb socket 4.
+     * Sockets on the specified netId where: - The opening app no longer has permission to use this
+     * network, or: - The opening app does have permission, but did not explicitly select this
+     * network.
+     *
+     * @param netId a network identifier needs to be referred for destroying sockets.
+     * @param permission network permission, available values are INetd.PERMISSION_NETWORK or
+     *     INetd.PERMISSION_SYSTEM.
+     */
+    public static void destroyLiveTcpSocketsLackingPermission(int netId, int permission)
+            throws SocketException, InterruptedIOException, ErrnoException {
+        if (permission != INetd.PERMISSION_NETWORK && permission != INetd.PERMISSION_SYSTEM) {
+            throw new IllegalArgumentException("Invalid permission");
+        }
+        final long durationMs =
+                destroyLiveTcpSockets(diagMsg -> isLackingPermission(netId, permission, diagMsg));
+        Log.d(
+                TAG,
+                "Destroyed live tcp sockets for lacking permission for netId:"
+                        + netId
+                        + " and permission:"
+                        + permission
+                        + " in "
+                        + durationMs
+                        + "ms");
+    }
+
+    /**
+     * Returns whether the opening app lacking permission or not. "isLacking" because an app is not
+     * lacking a permission on a mismatched netId, while it's not true that it would
+     * "holdPermission"
+     *
+     * @param netId network ID to compare
+     * @param permission network permission defined in INetd.aidl
+     * @param diagMsg {@link InetDiagMessage} retrieved from kernel.
+     */
+    @VisibleForTesting
+    public static boolean isLackingPermission(
+            int netId, int permission, @NonNull InetDiagMessage diagMsg) {
+        final int netdPermission = convertToNetdPermission(permission);
+        StructNlAttr attr = findInetDiagMarkAttr(diagMsg);
+        if (attr == null) return false;
+        final Integer fwMark = attr.getValueAsInteger();
+        if (fwMark == null) return false;
+        if ((fwMark & FWMARK_NET_ID_MASK) != netId) return false;
+        // Makes a mask to find matching sockets where:
+        // 1. The opening app no longer has permission to use this network, or:
+        // 2. The opening app does have permission, but did not explicitly select this network.
+        final int mask =
+                netdPermission << PERMISSION_SHIFT | 1 << EXPLICITLY_SELECTED_BIT_SHIFT;
+        return (fwMark & mask) != mask;
+    }
+
+    private static int convertToNetdPermission(int permission) {
+        // CS will destroy sockets lacking permission instead of Netd, and it follows permission
+        // value defined in INetd. However socket's Fwmark value follows Permission.h, thus we need
+        // conversion.
+        return switch (permission) {
+            case INetd.PERMISSION_NETWORK -> INetd.PERMISSION_NETWORK;
+            case INetd.PERMISSION_SYSTEM -> INetd.PERMISSION_SYSTEM | INetd.PERMISSION_NETWORK;
+            default -> INetd.PERMISSION_NONE;
+        };
+    }
+
     @Override
     public String toString() {
         return "InetDiagMessage{ "
diff --git a/staticlibs/device/com/android/net/module/util/netlink/NetlinkUtils.java b/staticlibs/device/com/android/net/module/util/netlink/NetlinkUtils.java
index 2420e7ad7e..1c642ae29b 100644
--- a/staticlibs/device/com/android/net/module/util/netlink/NetlinkUtils.java
+++ b/staticlibs/device/com/android/net/module/util/netlink/NetlinkUtils.java
@@ -87,7 +87,7 @@ public class NetlinkUtils {
 
     public static final int DEFAULT_RECV_BUFSIZE = 8 * 1024;
     public static final int SOCKET_RECV_BUFSIZE = 64 * 1024;
-    public static final int SOCKET_DUMP_RECV_BUFSIZE = 128 * 1024;
+    public static final int SOCKET_DUMP_RECV_BUFSIZE = 1024 * 1024;
 
     /**
      * Return whether the input ByteBuffer contains enough remaining bytes for
@@ -474,18 +474,18 @@ public class NetlinkUtils {
     /**
      * Sends a netlink request to set flags for given interface
      *
-     * @param interfaceName The name of the network interface to query.
+     * @param ifIndex The index of the network interface to configure.
      * @param flags power-of-two integer flags to set or unset. A flag to set should be passed as
      *        is as a power-of-two value, and a flag to remove should be passed inversed as -1 with
      *        a single bit down. For example: IFF_UP, ~IFF_BROADCAST...
      * @return true if the request finished successfully, otherwise false.
      */
-    public static boolean setInterfaceFlags(@NonNull String interfaceName, int... flags) {
+    public static boolean setInterfaceFlags(int ifIndex, int... flags) {
         final RtNetlinkLinkMessage ntMsg =
-                RtNetlinkLinkMessage.createSetFlagsMessage(interfaceName, /*seqNo*/ 0, flags);
+                RtNetlinkLinkMessage.createSetFlagsMessage(ifIndex, /*seqNo*/ 0, flags);
         if (ntMsg == null) {
-            Log.e(TAG, "Failed to create message to set interface flags for interface "
-                    + interfaceName + ", input flags are: " + Arrays.toString(flags));
+            Log.e(TAG, "Failed to create message to set interface flags for interface with index: "
+                    + ifIndex + ", input flags are: " + Arrays.toString(flags));
             return false;
         }
         final byte[] msg = ntMsg.pack(ByteOrder.nativeOrder());
@@ -493,7 +493,7 @@ public class NetlinkUtils {
             NetlinkUtils.sendOneShotKernelMessage(NETLINK_ROUTE, msg);
             return true;
         } catch (ErrnoException e) {
-            Log.e(TAG, "Failed to set flags for: " + interfaceName, e);
+            Log.e(TAG, "Failed to set flags for interface with index: " + ifIndex, e);
             return false;
         }
     }
@@ -501,20 +501,20 @@ public class NetlinkUtils {
     /**
      * Sends a netlink request to set MTU for given interface
      *
-     * @param interfaceName The name of the network interface to query.
+     * @param ifIndex The index of the network interface to configure.
      * @param mtu MTU value to set for the interface.
      * @return true if the request finished successfully, otherwise false.
      */
-    public static boolean setInterfaceMtu(@NonNull String interfaceName, int mtu) {
+    public static boolean setInterfaceMtu(int ifIndex, int mtu) {
         if (mtu < 68) {
             Log.e(TAG, "Invalid mtu: " + mtu + ", mtu should be greater than 68 referring RFC791");
             return false;
         }
         final RtNetlinkLinkMessage ntMsg =
-                RtNetlinkLinkMessage.createSetMtuMessage(interfaceName, /*seqNo*/ 0, mtu);
+                RtNetlinkLinkMessage.createSetMtuMessage(ifIndex, /*seqNo*/ 0, mtu);
         if (ntMsg == null) {
             Log.e(TAG, "Failed to create message to set MTU to " + mtu
-                    + "for interface " + interfaceName);
+                    + "for interface with index: " + ifIndex);
             return false;
         }
         final byte[] msg = ntMsg.pack(ByteOrder.nativeOrder());
@@ -522,7 +522,7 @@ public class NetlinkUtils {
             NetlinkUtils.sendOneShotKernelMessage(NETLINK_ROUTE, msg);
             return true;
         } catch (ErrnoException e) {
-            Log.e(TAG, "Failed to set MTU to " + mtu + " for: " + interfaceName, e);
+            Log.e(TAG, "Failed to set MTU to " + mtu + " for interface with index: " + ifIndex, e);
             return false;
         }
     }
diff --git a/staticlibs/device/com/android/net/module/util/netlink/RtNetlinkLinkMessage.java b/staticlibs/device/com/android/net/module/util/netlink/RtNetlinkLinkMessage.java
index 5d49fa33d3..8c36ed8344 100644
--- a/staticlibs/device/com/android/net/module/util/netlink/RtNetlinkLinkMessage.java
+++ b/staticlibs/device/com/android/net/module/util/netlink/RtNetlinkLinkMessage.java
@@ -227,58 +227,44 @@ public class RtNetlinkLinkMessage extends NetlinkMessage {
     /**
      * Create a link message to set the operational state (up or down) of a network interface.
      *
-     * @param interfaceName  The network interface name.
+     * @param ifIndex  The network interface index of the network interface to set state.
      * @param sequenceNumber The sequence number to use for the Netlink message.
      * @param isUp           {@code true} to set the interface up, {@code false} to set it down.
-     * @return A `RtNetlinkLinkMessage` instance configured to set the link state.
+     * @return A `RtNetlinkLinkMessage` instance configured to set the link state, or return null
+     *         in case of an error.
      */
     @Nullable
-    public static RtNetlinkLinkMessage createSetLinkStateMessage(@NonNull String interfaceName,
+    public static RtNetlinkLinkMessage createSetLinkStateMessage(int ifIndex,
             int sequenceNumber, boolean isUp) {
-        return createSetLinkStateMessage(interfaceName, sequenceNumber, isUp, new OsAccess());
-    }
-
-    @VisibleForTesting
-    @Nullable
-    protected static RtNetlinkLinkMessage createSetLinkStateMessage(@NonNull String interfaceName,
-            int sequenceNumber, boolean isUp, OsAccess osAccess) {
-        final int interfaceIndex = osAccess.if_nametoindex(interfaceName);
-        if (interfaceIndex == OsAccess.INVALID_INTERFACE_INDEX) {
+        if (ifIndex <= 0) {
             return null;
         }
 
         return RtNetlinkLinkMessage.build(
                 new StructNlMsgHdr(0, RTM_NEWLINK, NLM_F_REQUEST_ACK, sequenceNumber),
-                new StructIfinfoMsg((short) AF_UNSPEC, (short) 0, interfaceIndex,
+                new StructIfinfoMsg((short) AF_UNSPEC, (short) 0, ifIndex,
                                     isUp ? IFF_UP : 0, IFF_UP), DEFAULT_MTU, null, null);
     }
 
     /**
      * Create a link message to rename the network interface.
      *
-     * @param interfaceName  The network interface name.
+     * @param ifIndex  The network interface index of the network interface to rename.
      * @param sequenceNumber The sequence number to use for the Netlink message.
      * @param newName        The new name of the network interface.
-     * @return A `RtNetlinkLinkMessage` instance configured to rename the network interface.
+     * @return A `RtNetlinkLinkMessage` instance configured to rename the network interface,
+     *         or return null in case of an error.
      */
     @Nullable
-    public static RtNetlinkLinkMessage createSetLinkNameMessage(@NonNull String interfaceName,
+    public static RtNetlinkLinkMessage createSetLinkNameMessage(int ifIndex,
             int sequenceNumber, @NonNull String newName) {
-        return createSetLinkNameMessage(interfaceName, sequenceNumber, newName, new OsAccess());
-    }
-
-    @VisibleForTesting
-    @Nullable
-    protected static RtNetlinkLinkMessage createSetLinkNameMessage(@NonNull String interfaceName,
-            int sequenceNumber, @NonNull String newName, OsAccess osAccess) {
-        final int interfaceIndex = osAccess.if_nametoindex(interfaceName);
-        if (interfaceIndex == OsAccess.INVALID_INTERFACE_INDEX) {
+        if (ifIndex <= 0) {
             return null;
         }
 
         return RtNetlinkLinkMessage.build(
                 new StructNlMsgHdr(0, RTM_NEWLINK, NLM_F_REQUEST_ACK, sequenceNumber),
-                new StructIfinfoMsg((short) AF_UNSPEC, (short) 0, interfaceIndex, 0, 0),
+                new StructIfinfoMsg((short) AF_UNSPEC, (short) 0, ifIndex, 0, 0),
                 DEFAULT_MTU, null, newName);
     }
 
@@ -286,28 +272,21 @@ public class RtNetlinkLinkMessage extends NetlinkMessage {
      * Creates an {@link RtNetlinkLinkMessage} instance that can be used to get the link information
      * of a network interface.
      *
-     * @param interfaceName The name of the network interface to query.
+     * @param ifIndex The index of the network interface to query.
      * @param sequenceNumber The sequence number for the Netlink message.
-     * @return An `RtNetlinkLinkMessage` instance representing the request to query the interface.
+     * @return An `RtNetlinkLinkMessage` instance representing the request to query the interface,
+     *         or return null in case of an error.
      */
     @Nullable
-    public static RtNetlinkLinkMessage createGetLinkMessage(@NonNull String interfaceName,
+    public static RtNetlinkLinkMessage createGetLinkMessage(int ifIndex,
             int sequenceNumber) {
-        return createGetLinkMessage(interfaceName, sequenceNumber, new OsAccess());
-    }
-
-    @VisibleForTesting
-    @Nullable
-    protected static RtNetlinkLinkMessage createGetLinkMessage(@NonNull String interfaceName,
-            int sequenceNumber, @NonNull OsAccess osAccess) {
-        final int interfaceIndex = osAccess.if_nametoindex(interfaceName);
-        if (interfaceIndex == OsAccess.INVALID_INTERFACE_INDEX) {
+        if (ifIndex <= 0) {
             return null;
         }
 
         return RtNetlinkLinkMessage.build(
                 new StructNlMsgHdr(0, RTM_GETLINK, NLM_F_REQUEST_ACK, sequenceNumber),
-                new StructIfinfoMsg((short) AF_UNSPEC, (short) 0, interfaceIndex, 0, 0),
+                new StructIfinfoMsg((short) AF_UNSPEC, (short) 0, ifIndex, 0, 0),
                 DEFAULT_MTU, null, null);
     }
 
@@ -315,27 +294,18 @@ public class RtNetlinkLinkMessage extends NetlinkMessage {
      * Creates an {@link RtNetlinkLinkMessage} instance that can be used to set the flags of a
      * network interface.
      *
-     * @param interfaceName The name of the network interface to query.
+     * @param ifIndex The index of the network interface to configure.
      * @param sequenceNumber The sequence number for the Netlink message.
      * @param flags power-of-two integer flags to set or unset. A flag to set should be passed as
      *        is as a power-of-two value, and a flag to remove should be passed inversed as -1 with
      *        a single bit down. For example: IFF_UP, ~IFF_BROADCAST...
-     * @return An `RtNetlinkLinkMessage` instance representing the request to query the interface.
+     * @return An `RtNetlinkLinkMessage` instance representing the request to query the interface,
+     *         or return null in case of an error.
      */
     @Nullable
-    public static RtNetlinkLinkMessage createSetFlagsMessage(@NonNull String interfaceName,
+    public static RtNetlinkLinkMessage createSetFlagsMessage(int ifIndex,
             int sequenceNumber, int... flags) {
-        return createSetFlagsMessage(
-                interfaceName, sequenceNumber, new OsAccess(), flags);
-    }
-
-    @VisibleForTesting
-    @Nullable
-    protected static RtNetlinkLinkMessage createSetFlagsMessage(
-            @NonNull String interfaceName, int sequenceNumber, @NonNull OsAccess osAccess,
-            int... flags) {
-        final int interfaceIndex = osAccess.if_nametoindex(interfaceName);
-        if (interfaceIndex == OsAccess.INVALID_INTERFACE_INDEX) {
+        if (ifIndex <= 0) {
             return null;
         }
 
@@ -358,7 +328,7 @@ public class RtNetlinkLinkMessage extends NetlinkMessage {
         return RtNetlinkLinkMessage.build(
                 new StructNlMsgHdr(
                         /*payloadLen*/ 0, RTM_NEWLINK, NLM_F_REQUEST_ACK, sequenceNumber),
-                new StructIfinfoMsg((short) AF_UNSPEC, /*type*/ 0, interfaceIndex,
+                new StructIfinfoMsg((short) AF_UNSPEC, /*type*/ 0, ifIndex,
                         flagsBits, changeBits),
                 DEFAULT_MTU, /*hardwareAddress*/ null, /*interfaceName*/ null);
     }
@@ -367,29 +337,21 @@ public class RtNetlinkLinkMessage extends NetlinkMessage {
      * Creates an {@link RtNetlinkLinkMessage} instance that can be used to set the MTU of a
      * network interface.
      *
-     * @param interfaceName The name of the network interface to query.
+     * @param ifIndex The index of the network interface to configure.
      * @param sequenceNumber The sequence number for the Netlink message.
      * @param mtu MTU value to set for the interface.
-     * @return An `RtNetlinkLinkMessage` instance representing the request to query the interface.
+     * @return An `RtNetlinkLinkMessage` instance representing the request to query the interface,
+     *         or return null in case of an error.
      */
     @Nullable
-    public static RtNetlinkLinkMessage createSetMtuMessage(@NonNull String interfaceName,
+    public static RtNetlinkLinkMessage createSetMtuMessage(int ifIndex,
             int sequenceNumber, int mtu) {
-        return createSetMtuMessage(
-            interfaceName, sequenceNumber, mtu, new OsAccess());
-    }
-
-    @VisibleForTesting
-    @Nullable
-    protected static RtNetlinkLinkMessage createSetMtuMessage(@NonNull String interfaceName,
-            int sequenceNumber, int mtu, @NonNull OsAccess osAccess) {
-        final int interfaceIndex = osAccess.if_nametoindex(interfaceName);
-        if (interfaceIndex == OsAccess.INVALID_INTERFACE_INDEX) {
+        if (ifIndex <= 0) {
             return null;
         }
         return RtNetlinkLinkMessage.build(
             new StructNlMsgHdr(/*payloadLen*/ 0, RTM_NEWLINK, NLM_F_REQUEST_ACK , sequenceNumber),
-            new StructIfinfoMsg((short) AF_UNSPEC, /*type*/ 0, interfaceIndex,
+            new StructIfinfoMsg((short) AF_UNSPEC, /*type*/ 0, ifIndex,
                 /*flags*/ 0, /*change*/ 0),
             mtu, /*hardwareAddress*/ null, /*interfaceName*/ null);
     }
diff --git a/staticlibs/framework/com/android/net/module/util/CollectionUtils.java b/staticlibs/framework/com/android/net/module/util/CollectionUtils.java
index 760d849d42..df8d9f6030 100644
--- a/staticlibs/framework/com/android/net/module/util/CollectionUtils.java
+++ b/staticlibs/framework/com/android/net/module/util/CollectionUtils.java
@@ -19,6 +19,7 @@ package com.android.net.module.util;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.util.ArrayMap;
+import android.util.ArraySet;
 import android.util.Pair;
 import android.util.SparseArray;
 
@@ -27,6 +28,7 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 import java.util.Objects;
+import java.util.Set;
 import java.util.function.Function;
 import java.util.function.Predicate;
 
@@ -51,6 +53,18 @@ public final class CollectionUtils {
         return collection == null || collection.isEmpty();
     }
 
+    /**
+     * Convert an int array to a Integer set.
+     */
+    @NonNull
+    public static Set<Integer> intArrayToSet(@NonNull int[] array) {
+        final Set<Integer> set = new ArraySet<>();
+        for (int item : array) {
+            set.add(item);
+        }
+        return set;
+    }
+
     /**
      * Returns an int array from the given Integer list.
      */
diff --git a/staticlibs/framework/com/android/net/module/util/LinkPropertiesUtils.java b/staticlibs/framework/com/android/net/module/util/LinkPropertiesUtils.java
index e271f64902..4760dfca5f 100644
--- a/staticlibs/framework/com/android/net/module/util/LinkPropertiesUtils.java
+++ b/staticlibs/framework/com/android/net/module/util/LinkPropertiesUtils.java
@@ -146,6 +146,23 @@ public final class LinkPropertiesUtils {
                 right != null ? right.getLinkAddresses() : null);
     }
 
+    /**
+     * Compares the all addresses including stacked addresses in {@code left} LinkProperties with
+     * {@code right} LinkProperties, examining only addresses on the base link.
+     *
+     * @param left A LinkProperties with the old list of all addresses.
+     * @param right A LinkProperties with the new list of all addresses.
+     * @return the differences between the addresses.
+     */
+    public static @NonNull CompareResult<LinkAddress> compareAllAddresses(
+            @Nullable LinkProperties left, @Nullable LinkProperties right) {
+        /*
+         * Same logic as compareAddresses()
+         */
+        return new CompareResult<>(left != null ? left.getAllLinkAddresses() : null,
+                right != null ? right.getAllLinkAddresses() : null);
+    }
+
     /**
      * Compares {@code left} {@code LinkProperties} allLinkAddresses against the {@code right}.
      *
diff --git a/staticlibs/framework/com/android/net/module/util/NetworkCapabilitiesUtils.java b/staticlibs/framework/com/android/net/module/util/NetworkCapabilitiesUtils.java
index 7066131618..710022caaa 100644
--- a/staticlibs/framework/com/android/net/module/util/NetworkCapabilitiesUtils.java
+++ b/staticlibs/framework/com/android/net/module/util/NetworkCapabilitiesUtils.java
@@ -16,6 +16,12 @@
 
 package com.android.net.module.util;
 
+import static android.net.ConnectivityManager.TYPE_BLUETOOTH;
+import static android.net.ConnectivityManager.TYPE_ETHERNET;
+import static android.net.ConnectivityManager.TYPE_MOBILE;
+import static android.net.ConnectivityManager.TYPE_PROXY;
+import static android.net.ConnectivityManager.TYPE_VPN;
+import static android.net.ConnectivityManager.TYPE_WIFI;
 import static android.net.NetworkCapabilities.NET_CAPABILITY_BIP;
 import static android.net.NetworkCapabilities.NET_CAPABILITY_CBS;
 import static android.net.NetworkCapabilities.NET_CAPABILITY_DUN;
@@ -40,13 +46,13 @@ import static android.net.NetworkCapabilities.TRANSPORT_BLUETOOTH;
 import static android.net.NetworkCapabilities.TRANSPORT_CELLULAR;
 import static android.net.NetworkCapabilities.TRANSPORT_ETHERNET;
 import static android.net.NetworkCapabilities.TRANSPORT_SATELLITE;
+import static android.net.NetworkCapabilities.TRANSPORT_TEST;
 import static android.net.NetworkCapabilities.TRANSPORT_USB;
 import static android.net.NetworkCapabilities.TRANSPORT_VPN;
 import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
 import static android.net.NetworkCapabilities.TRANSPORT_WIFI_AWARE;
 
 import static com.android.net.module.util.BitUtils.packBits;
-import static com.android.net.module.util.BitUtils.unpackBits;
 
 import android.annotation.NonNull;
 import android.net.NetworkCapabilities;
@@ -58,6 +64,10 @@ import com.android.internal.annotations.VisibleForTesting;
  * @hide
  */
 public final class NetworkCapabilitiesUtils {
+    // Need to be synchronized with ConnectivityManager.
+    // TODO: Use {@code ConnectivityManager#*} when visible.
+    public static final int TYPE_TEST = 18;
+
     // Transports considered to classify networks in UI, in order of which transport should be
     // surfaced when there are multiple transports. Transports not in this list do not have
     // an ordering preference (in practice they will have a deterministic order based on the
@@ -150,6 +160,32 @@ public final class NetworkCapabilitiesUtils {
         return transports[0];
     }
 
+    /**
+     * Deduces the primary NetworkCapabilities.TRANSPORT_* type from a legacy
+     * ConnectivityManager.TYPE_* network type.
+     *
+     * This is used to deduce transport type for legacy persistent NetworkStats files
+     * with NetworkIdentitySet version under VERSION_ADD_TRANSPORT_TYPES.
+     *
+     * @param legacyNetworkType One of the deprecated ConnectivityManager.TYPE_* constants
+     *        (e.g., ConnectivityManager.TYPE_WIFI, ConnectivityManager.TYPE_MOBILE).
+     * @return The corresponding NetworkCapabilities.TRANSPORT_* constant, or
+     *         -1 if no direct or clear mapping exists or unknown.
+     */
+    public static int deduceTransportTypeForLegacyNetworkType(int legacyNetworkType) {
+        return switch (legacyNetworkType) {
+            case TYPE_WIFI -> TRANSPORT_WIFI;
+            case TYPE_MOBILE -> TRANSPORT_CELLULAR;
+            case TYPE_ETHERNET -> TRANSPORT_ETHERNET;
+            case TYPE_VPN -> TRANSPORT_VPN;
+            // TYPE_PROXY (deprecated) historically represented a network primarily
+            // for proxying traffic, often over Bluetooth (e.g., on Wear OS devices
+            // tethered to a phone). See ProxyNetworkAgent (deprecated) for more detail.
+            case TYPE_BLUETOOTH, TYPE_PROXY -> TRANSPORT_BLUETOOTH;
+            case TYPE_TEST -> TRANSPORT_TEST;
+            default -> -1; // Ignore legacy types such as TYPE_WIMAX, TYPE_MOBILE_*, etc.
+        };
+    }
 
     /**
      * Infers that all the capabilities it provides are typically provided by restricted networks
diff --git a/staticlibs/framework/com/android/net/module/util/SdkUtil.java b/staticlibs/framework/com/android/net/module/util/SdkUtil.java
index 63558dd18c..1acb156c54 100644
--- a/staticlibs/framework/com/android/net/module/util/SdkUtil.java
+++ b/staticlibs/framework/com/android/net/module/util/SdkUtil.java
@@ -52,6 +52,6 @@ public class SdkUtil {
 
     /** Checks if the device is running on a release version of Android Baklava or newer */
     public static boolean isAtLeast25Q2() {
-        return SDK_INT >= 36  || (SDK_INT == 35 && "Baklava".equals(Build.VERSION.CODENAME));
+        return SDK_INT >= 36 || (SDK_INT == 35 && "Baklava".equals(Build.VERSION.CODENAME));
     }
 }
diff --git a/staticlibs/tests/unit/host/python/adb_utils_test.py b/staticlibs/tests/unit/host/python/adb_utils_test.py
index 8fcca375f6..319991e5fa 100644
--- a/staticlibs/tests/unit/host/python/adb_utils_test.py
+++ b/staticlibs/tests/unit/host/python/adb_utils_test.py
@@ -29,12 +29,12 @@ class TestAdbUtils(base_test.BaseTestClass, parameterized.TestCase):
   def setup_test(self):
     self.mock_ad = MagicMock()  # Mock Android device object
     self.mock_ad.log = MagicMock()
-    self.mock_ad.adb.shell.return_value = b""  # Default empty return for shell
+    self.mock_ad.adb.shell.return_value = b''  # Default empty return for shell
 
   @patch(
-      "net_tests_utils.host.python.adb_utils.expect_dumpsys_state_with_retry"
+      'net_tests_utils.host.python.adb_utils.expect_dumpsys_state_with_retry'
   )
-  @patch("net_tests_utils.host.python.adb_utils._set_screen_state")
+  @patch('net_tests_utils.host.python.adb_utils._set_screen_state')
   def test_set_doze_mode_enable(
       self, mock_set_screen_state, mock_expect_dumpsys_state
   ):
@@ -42,29 +42,29 @@ class TestAdbUtils(base_test.BaseTestClass, parameterized.TestCase):
     mock_set_screen_state.assert_called_once_with(self.mock_ad, False)
 
   @patch(
-      "net_tests_utils.host.python.adb_utils.expect_dumpsys_state_with_retry"
+      'net_tests_utils.host.python.adb_utils.expect_dumpsys_state_with_retry'
   )
   def test_set_doze_mode_disable(self, mock_expect_dumpsys_state):
     adb_utils.set_doze_mode(self.mock_ad, False)
 
-  @patch("net_tests_utils.host.python.adb_utils._get_screen_state")
+  @patch('net_tests_utils.host.python.adb_utils._get_screen_state')
   def test_set_screen_state_success(self, mock_get_screen_state):
     mock_get_screen_state.side_effect = [False, True]  # Simulate toggle
     adb_utils._set_screen_state(self.mock_ad, True)
 
-  @patch("net_tests_utils.host.python.adb_utils._get_screen_state")
+  @patch('net_tests_utils.host.python.adb_utils._get_screen_state')
   def test_set_screen_state_failure(self, mock_get_screen_state):
     mock_get_screen_state.return_value = False  # State doesn't change
     with asserts.assert_raises(UnexpectedBehaviorError):
       adb_utils._set_screen_state(self.mock_ad, True)
 
   @parameterized.parameters(
-      ("Awake", True),
-      ("Asleep", False),
-      ("Dozing", False),
-      ("SomeOtherState", False),
+      ('Awake', True),
+      ('Asleep', False),
+      ('Dozing', False),
+      ('SomeOtherState', False),
   )  # Declare inputs for state_str and expected_result.
-  @patch("net_tests_utils.host.python.adb_utils.get_value_of_key_from_dumpsys")
+  @patch('net_tests_utils.host.python.adb_utils.get_value_of_key_from_dumpsys')
   def test_get_screen_state(self, state_str, expected_result, mock_get_value):
     mock_get_value.return_value = state_str
     asserts.assert_equal(
@@ -73,44 +73,44 @@ class TestAdbUtils(base_test.BaseTestClass, parameterized.TestCase):
 
   def test_get_value_of_key_from_dumpsys(self):
     self.mock_ad.adb.shell.return_value = (
-        b"mWakefulness=Awake\nmOtherKey=SomeValue"
+        b'mWakefulness=Awake\nmOtherKey=SomeValue'
     )
     result = adb_utils.get_value_of_key_from_dumpsys(
-        self.mock_ad, "power", "mWakefulness"
+        self.mock_ad, 'power', 'mWakefulness'
     )
-    asserts.assert_equal(result, "Awake")
+    asserts.assert_equal(result, 'Awake')
 
   @parameterized.parameters(
-      (True, ["true"]),
-      (False, ["false"]),
+      (True, ['true']),
+      (False, ['false']),
       (
           True,
-          ["false", "true"],
+          ['false', 'true'],
       ),  # Expect True, get False which is unexpected, then get True
       (
           False,
-          ["true", "false"],
+          ['true', 'false'],
       ),  # Expect False, get True which is unexpected, then get False
   )  # Declare inputs for expected_state and returned_value
-  @patch("net_tests_utils.host.python.adb_utils.get_value_of_key_from_dumpsys")
+  @patch('net_tests_utils.host.python.adb_utils.get_value_of_key_from_dumpsys')
   def test_expect_dumpsys_state_with_retry_success(
       self, expected_state, returned_value, mock_get_value
   ):
     mock_get_value.side_effect = returned_value
     # Verify the method returns and does not throw.
     adb_utils.expect_dumpsys_state_with_retry(
-        self.mock_ad, "service", "key", expected_state, 0
+        self.mock_ad, 'service', 'key', expected_state, 0
     )
 
-  @patch("net_tests_utils.host.python.adb_utils.get_value_of_key_from_dumpsys")
+  @patch('net_tests_utils.host.python.adb_utils.get_value_of_key_from_dumpsys')
   def test_expect_dumpsys_state_with_retry_failure(self, mock_get_value):
-    mock_get_value.return_value = "false"
+    mock_get_value.return_value = 'false'
     with asserts.assert_raises(UnexpectedBehaviorError):
       adb_utils.expect_dumpsys_state_with_retry(
-          self.mock_ad, "service", "key", True, 0
+          self.mock_ad, 'service', 'key', True, 0
       )
 
-  @patch("net_tests_utils.host.python.adb_utils.get_value_of_key_from_dumpsys")
+  @patch('net_tests_utils.host.python.adb_utils.get_value_of_key_from_dumpsys')
   def test_expect_dumpsys_state_with_retry_not_found(self, mock_get_value):
     # Simulate the get_value_of_key_from_dumpsys cannot find the give key.
     mock_get_value.return_value = None
@@ -118,5 +118,5 @@ class TestAdbUtils(base_test.BaseTestClass, parameterized.TestCase):
     # Expect the function to raise UnexpectedBehaviorError due to the exception
     with asserts.assert_raises(UnexpectedBehaviorError):
       adb_utils.expect_dumpsys_state_with_retry(
-          self.mock_ad, "service", "key", True
+          self.mock_ad, 'service', 'key', True
       )
diff --git a/staticlibs/tests/unit/host/python/apf_utils_test.py b/staticlibs/tests/unit/host/python/apf_utils_test.py
index 55fbe58c7a..6bf7a962a5 100644
--- a/staticlibs/tests/unit/host/python/apf_utils_test.py
+++ b/staticlibs/tests/unit/host/python/apf_utils_test.py
@@ -24,22 +24,23 @@ from net_tests_utils.host.python.apf_utils import (
     UnsupportedOperationException,
     get_apf_capabilities,
     get_apf_counter,
-    get_apf_counters_from_dumpsys,
-    get_ipv4_addresses,
-    get_non_tentative_ipv6_addresses,
+    get_apf_counters_from_cmd,
     get_exclude_all_host_ipv6_multicast_addresses,
     get_hardware_address,
-    is_send_raw_packet_downstream_supported,
+    get_ipv4_addresses,
+    get_matched_packet_counts,
+    get_non_tentative_ipv6_addresses,
+    is_apf_dump_counters_supported,
     is_packet_capture_supported,
+    is_send_raw_packet_downstream_supported,
+    send_raw_packet_downstream,
     start_capture_packets,
     stop_capture_packets,
-    get_matched_packet_counts,
-    send_raw_packet_downstream,
 )
 from net_tests_utils.host.python.assert_utils import UnexpectedBehaviorError
 
-TEST_IFACE_NAME = "eth0"
-TEST_PACKET_IN_HEX = "AABBCCDDEEFF"
+TEST_IFACE_NAME = 'eth0'
+TEST_PACKET_IN_HEX = 'AABBCCDDEEFF'
 
 
 class TestApfUtils(base_test.BaseTestClass, parameterized.TestCase):
@@ -50,56 +51,27 @@ class TestApfUtils(base_test.BaseTestClass, parameterized.TestCase):
   def setup_test(self):
     self.mock_ad = MagicMock()  # Mock Android device object
 
-  @patch("net_tests_utils.host.python.adb_utils.get_dumpsys_for_service")
-  def test_get_apf_counters_from_dumpsys_success(
-      self, mock_get_dumpsys: MagicMock
-  ) -> None:
-    mock_get_dumpsys.return_value = """
-IpClient.wlan0
-  APF packet counters:
-    COUNTER_NAME1: 123
-    COUNTER_NAME2: 456
-"""
-    counters = get_apf_counters_from_dumpsys(self.mock_ad, "wlan0")
-    asserts.assert_equal(counters, {"COUNTER_NAME1": 123, "COUNTER_NAME2": 456})
-
-  @patch("net_tests_utils.host.python.adb_utils.get_dumpsys_for_service")
-  def test_get_apf_counters_from_dumpsys_exceptions(
-      self, mock_get_dumpsys: MagicMock
-  ) -> None:
-    test_cases = [
-        "",
-        "IpClient.wlan0\n",
-        "IpClient.wlan0\n APF packet counters:\n",
-        """
-IpClient.wlan1
-  APF packet counters:
-    COUNTER_NAME1: 123
-    COUNTER_NAME2: 456
-""",
-    ]
-
-    for dumpsys_output in test_cases:
-      mock_get_dumpsys.return_value = dumpsys_output
-      with asserts.assert_raises(PatternNotFoundException):
-        get_apf_counters_from_dumpsys(self.mock_ad, "wlan0")
-
-  @patch("net_tests_utils.host.python.apf_utils.get_apf_counters_from_dumpsys")
+  @patch('net_tests_utils.host.python.apf_utils.get_apf_counters_from_cmd')
   def test_get_apf_counter(self, mock_get_counters: MagicMock) -> None:
-    iface = "wlan0"
+    iface = 'wlan0'
     mock_get_counters.return_value = {
-        "COUNTER_NAME1": 123,
-        "COUNTER_NAME2": 456,
+        'COUNTER_NAME1': '123',
+        'COUNTER_NAME2': '456',
+        'COUNTER_NAME3': '[ERROR: impossible]',
     }
     asserts.assert_equal(
-        get_apf_counter(self.mock_ad, iface, "COUNTER_NAME1"), 123
+        get_apf_counter(self.mock_ad, iface, 'COUNTER_NAME1'), 123
+    )
+    # Invalid counter value
+    asserts.assert_equal(
+        get_apf_counter(self.mock_ad, iface, 'COUNTER_NAME3'), -1
     )
     # Not found
     asserts.assert_equal(
-        get_apf_counter(self.mock_ad, iface, "COUNTER_NAME3"), 0
+        get_apf_counter(self.mock_ad, iface, 'COUNTER_NAME4'), 0
     )
 
-  @patch("net_tests_utils.host.python.adb_utils.adb_shell")
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
   def test_get_hardware_address_success(
       self, mock_adb_shell: MagicMock
   ) -> None:
@@ -111,21 +83,19 @@ IpClient.wlan1
 47: wlan1: <BROADCAST,MULTICAST> mtu 1500 qdisc ...
  link/ether 6a:16:81:ff:82:9b brd ff:ff:ff:ff:ff:ff
 """
-    mac_address = get_hardware_address(self.mock_ad, "wlan0")
-    asserts.assert_equal(mac_address, "72:05:77:82:21:E0")
+    mac_address = get_hardware_address(self.mock_ad, 'wlan0')
+    asserts.assert_equal(mac_address, '72:05:77:82:21:E0')
 
-  @patch("net_tests_utils.host.python.adb_utils.adb_shell")
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
   def test_get_hardware_address_not_found(
       self, mock_adb_shell: MagicMock
   ) -> None:
-    mock_adb_shell.return_value = "Some output without MAC address"
+    mock_adb_shell.return_value = 'Some output without MAC address'
     with asserts.assert_raises(PatternNotFoundException):
-      get_hardware_address(self.mock_ad, "wlan0")
+      get_hardware_address(self.mock_ad, 'wlan0')
 
-  @patch("net_tests_utils.host.python.adb_utils.adb_shell")
-  def test_get_ipv4_addresses_success(
-      self, mock_adb_shell: MagicMock
-  ) -> None:
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
+  def test_get_ipv4_addresses_success(self, mock_adb_shell: MagicMock) -> None:
     mock_adb_shell.return_value = """
 54: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 state UP qlen 1000
     inet 192.168.195.162/24 brd 192.168.195.255 scope global wlan0
@@ -133,18 +103,18 @@ IpClient.wlan1
     inet 192.168.200.1/24 brd 192.168.200.255 scope global wlan0
        valid_lft forever preferred_lft forever
 """
-    ip_addresses = get_ipv4_addresses(self.mock_ad, "wlan0")
-    asserts.assert_equal(ip_addresses, ["192.168.195.162", "192.168.200.1"])
+    ip_addresses = get_ipv4_addresses(self.mock_ad, 'wlan0')
+    asserts.assert_equal(ip_addresses, ['192.168.195.162', '192.168.200.1'])
 
-  @patch("net_tests_utils.host.python.adb_utils.adb_shell")
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
   def test_get_ipv4_addresses_not_found(
       self, mock_adb_shell: MagicMock
   ) -> None:
-    mock_adb_shell.return_value = ""
-    ip_addresses = get_ipv4_addresses(self.mock_ad, "wlan0")
+    mock_adb_shell.return_value = ''
+    ip_addresses = get_ipv4_addresses(self.mock_ad, 'wlan0')
     asserts.assert_equal(ip_addresses, [])
 
-  @patch("net_tests_utils.host.python.adb_utils.adb_shell")
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
   def test_get_non_tentative_ipv6_addresses_success(
       self, mock_adb_shell: MagicMock
   ) -> None:
@@ -157,22 +127,23 @@ IpClient.wlan1
     inet6 fe80::3aff:2199:2d8e:20d1/64 scope link noprefixroute
         valid_lft forever preferred_lft forever
 """
-    ip_addresses = get_non_tentative_ipv6_addresses(self.mock_ad, "wlan0")
-    asserts.assert_equal(ip_addresses,
-                         ["fe80::10a3:5dff:fe52:de32",
-                          "2001:b400:e53f:164e:9c1e:780e:d1:4658",
-                          "fe80::3aff:2199:2d8e:20d1"])
-
-  @patch("net_tests_utils.host.python.adb_utils.adb_shell")
-  def test_get_ipv6_address_not_found(
-          self, mock_adb_shell: MagicMock
-  ) -> None:
-    mock_adb_shell.return_value = ""
-    ip_addresses = get_non_tentative_ipv6_addresses(self.mock_ad, "wlan0")
-    asserts.assert_equal(ip_addresses, [])
+    ip_addresses = get_non_tentative_ipv6_addresses(self.mock_ad, 'wlan0')
+    asserts.assert_equal(
+        ip_addresses,
+        [
+            'fe80::10a3:5dff:fe52:de32',
+            '2001:b400:e53f:164e:9c1e:780e:d1:4658',
+            'fe80::3aff:2199:2d8e:20d1',
+        ],
+    )
 
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
+  def test_get_ipv6_address_not_found(self, mock_adb_shell: MagicMock) -> None:
+    mock_adb_shell.return_value = ''
+    ip_addresses = get_non_tentative_ipv6_addresses(self.mock_ad, 'wlan0')
+    asserts.assert_equal(ip_addresses, [])
 
-  @patch("net_tests_utils.host.python.adb_utils.adb_shell")
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
   def test_get_exclude_all_host_ipv6_multicast_addresses_success(
       self, mock_adb_shell: MagicMock
   ) -> None:
@@ -183,39 +154,43 @@ IpClient.wlan1
         inet6 ff02::1
         inet6 ff01::1
 """
-    ip_addresses = get_exclude_all_host_ipv6_multicast_addresses(self.mock_ad, "wlan0")
-    asserts.assert_equal(ip_addresses,
-                         ["ff02::1:ff99:37b0",
-                          "ff02::1:ffb7:cba2"])
+    ip_addresses = get_exclude_all_host_ipv6_multicast_addresses(
+        self.mock_ad, 'wlan0'
+    )
+    asserts.assert_equal(
+        ip_addresses, ['ff02::1:ff99:37b0', 'ff02::1:ffb7:cba2']
+    )
 
-  @patch("net_tests_utils.host.python.adb_utils.adb_shell")
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
   def test_get_exclude_all_host_ipv6_multicast_addresses_not_found(
-          self, mock_adb_shell: MagicMock
+      self, mock_adb_shell: MagicMock
   ) -> None:
-    mock_adb_shell.return_value = ""
-    ip_addresses = get_exclude_all_host_ipv6_multicast_addresses(self.mock_ad, "wlan0")
+    mock_adb_shell.return_value = ''
+    ip_addresses = get_exclude_all_host_ipv6_multicast_addresses(
+        self.mock_ad, 'wlan0'
+    )
     asserts.assert_equal(ip_addresses, [])
 
-  @patch("net_tests_utils.host.python.adb_utils.adb_shell")
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
   def test_send_raw_packet_downstream_success(
       self, mock_adb_shell: MagicMock
   ) -> None:
-    mock_adb_shell.return_value = ""  # Successful command output
+    mock_adb_shell.return_value = ''  # Successful command output
     send_raw_packet_downstream(
         self.mock_ad, TEST_IFACE_NAME, TEST_PACKET_IN_HEX
     )
     mock_adb_shell.assert_called_once_with(
         self.mock_ad,
-        "cmd network_stack send-raw-packet-downstream"
-        f" {TEST_IFACE_NAME} {TEST_PACKET_IN_HEX}",
+        'cmd network_stack send-raw-packet-downstream'
+        f' {TEST_IFACE_NAME} {TEST_PACKET_IN_HEX}',
     )
 
-  @patch("net_tests_utils.host.python.adb_utils.adb_shell")
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
   def test_send_raw_packet_downstream_failure(
       self, mock_adb_shell: MagicMock
   ) -> None:
     mock_adb_shell.return_value = (  # Unexpected command output
-        "Any Unexpected Output"
+        'Any Unexpected Output'
     )
     with asserts.assert_raises(UnexpectedBehaviorError):
       send_raw_packet_downstream(
@@ -223,15 +198,15 @@ IpClient.wlan1
       )
     asserts.assert_true(
         is_send_raw_packet_downstream_supported(self.mock_ad),
-        "Send raw packet should be supported.",
+        'Send raw packet should be supported.',
     )
 
-  @patch("net_tests_utils.host.python.adb_utils.adb_shell")
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
   def test_send_raw_packet_downstream_unsupported(
       self, mock_adb_shell: MagicMock
   ) -> None:
     mock_adb_shell.side_effect = AdbError(
-        cmd="", stdout="Unknown command", stderr="", ret_code=3
+        cmd='', stdout='Unknown command', stderr='', ret_code=3
     )
     with asserts.assert_raises(UnsupportedOperationException):
       send_raw_packet_downstream(
@@ -239,154 +214,185 @@ IpClient.wlan1
       )
     asserts.assert_false(
         is_send_raw_packet_downstream_supported(self.mock_ad),
-        "Send raw packet should not be supported.",
+        'Send raw packet should not be supported.',
     )
 
-  @patch("net_tests_utils.host.python.adb_utils.adb_shell")
-  def test_start_capture_success(
-          self, mock_adb_shell: MagicMock
-  ) -> None:
-      mock_adb_shell.return_value = "success"  # Successful command output
-      start_capture_packets(
-          self.mock_ad, TEST_IFACE_NAME
-      )
-      mock_adb_shell.assert_called_once_with(
-          self.mock_ad,
-          "cmd network_stack capture start"
-          f" {TEST_IFACE_NAME}"
-      )
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
+  def test_start_capture_success(self, mock_adb_shell: MagicMock) -> None:
+    mock_adb_shell.return_value = 'success'  # Successful command output
+    start_capture_packets(self.mock_ad, TEST_IFACE_NAME)
+    mock_adb_shell.assert_called_once_with(
+        self.mock_ad, f'cmd network_stack capture start {TEST_IFACE_NAME}'
+    )
 
-  @patch("net_tests_utils.host.python.adb_utils.adb_shell")
-  def test_start_capture_failure(
-          self, mock_adb_shell: MagicMock
-  ) -> None:
-      mock_adb_shell.return_value = (  # Unexpected command output
-          "Any Unexpected Output"
-      )
-      with asserts.assert_raises(UnexpectedBehaviorError):
-          start_capture_packets(
-              self.mock_ad, TEST_IFACE_NAME
-          )
-      asserts.assert_true(
-          is_packet_capture_supported(self.mock_ad),
-          "Start capturing packets should be supported.",
-      )
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
+  def test_start_capture_failure(self, mock_adb_shell: MagicMock) -> None:
+    mock_adb_shell.return_value = (  # Unexpected command output
+        'Any Unexpected Output'
+    )
+    with asserts.assert_raises(UnexpectedBehaviorError):
+      start_capture_packets(self.mock_ad, TEST_IFACE_NAME)
+    asserts.assert_true(
+        is_packet_capture_supported(self.mock_ad),
+        'Start capturing packets should be supported.',
+    )
 
-  @patch("net_tests_utils.host.python.adb_utils.adb_shell")
-  def test_start_capture_unsupported(
-          self, mock_adb_shell: MagicMock
-  ) -> None:
-      mock_adb_shell.side_effect = AdbError(
-          cmd="", stdout="Unknown command", stderr="", ret_code=3
-      )
-      with asserts.assert_raises(UnsupportedOperationException):
-          start_capture_packets(
-              self.mock_ad, TEST_IFACE_NAME
-          )
-      asserts.assert_false(
-          is_packet_capture_supported(self.mock_ad),
-          "Start capturing packets should not be supported.",
-      )
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
+  def test_start_capture_unsupported(self, mock_adb_shell: MagicMock) -> None:
+    mock_adb_shell.side_effect = AdbError(
+        cmd='', stdout='Unknown command', stderr='', ret_code=3
+    )
+    with asserts.assert_raises(UnsupportedOperationException):
+      start_capture_packets(self.mock_ad, TEST_IFACE_NAME)
+    asserts.assert_false(
+        is_packet_capture_supported(self.mock_ad),
+        'Start capturing packets should not be supported.',
+    )
 
-  @patch("net_tests_utils.host.python.adb_utils.adb_shell")
-  def test_stop_capture_success(
-          self, mock_adb_shell: MagicMock
-  ) -> None:
-      mock_adb_shell.return_value = "success"  # Successful command output
-      stop_capture_packets(
-          self.mock_ad, TEST_IFACE_NAME
-      )
-      mock_adb_shell.assert_called_once_with(
-          self.mock_ad,
-          "cmd network_stack capture stop"
-          f" {TEST_IFACE_NAME}"
-      )
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
+  def test_stop_capture_success(self, mock_adb_shell: MagicMock) -> None:
+    mock_adb_shell.return_value = 'success'  # Successful command output
+    stop_capture_packets(self.mock_ad, TEST_IFACE_NAME)
+    mock_adb_shell.assert_called_once_with(
+        self.mock_ad, f'cmd network_stack capture stop {TEST_IFACE_NAME}'
+    )
+
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
+  def test_stop_capture_failure(self, mock_adb_shell: MagicMock) -> None:
+    mock_adb_shell.return_value = (  # Unexpected command output
+        'Any Unexpected Output'
+    )
+    with asserts.assert_raises(UnexpectedBehaviorError):
+      stop_capture_packets(self.mock_ad, TEST_IFACE_NAME)
+    asserts.assert_true(
+        is_packet_capture_supported(self.mock_ad),
+        'Stop capturing packets should be supported.',
+    )
+
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
+  def test_stop_capture_unsupported(self, mock_adb_shell: MagicMock) -> None:
+    mock_adb_shell.side_effect = AdbError(
+        cmd='', stdout='Unknown command', stderr='', ret_code=3
+    )
+    with asserts.assert_raises(UnsupportedOperationException):
+      stop_capture_packets(self.mock_ad, TEST_IFACE_NAME)
+    asserts.assert_false(
+        is_packet_capture_supported(self.mock_ad),
+        'Stop capturing packets should not be supported.',
+    )
 
-  @patch("net_tests_utils.host.python.adb_utils.adb_shell")
-  def test_stop_capture_failure(
-          self, mock_adb_shell: MagicMock
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
+  def test_get_matched_packet_counts_success(
+      self, mock_adb_shell: MagicMock
   ) -> None:
-      mock_adb_shell.return_value = (  # Unexpected command output
-          "Any Unexpected Output"
-      )
-      with asserts.assert_raises(UnexpectedBehaviorError):
-          stop_capture_packets(
-              self.mock_ad, TEST_IFACE_NAME
-          )
-      asserts.assert_true(
-          is_packet_capture_supported(self.mock_ad),
-          "Stop capturing packets should be supported.",
-      )
+    mock_adb_shell.return_value = '10'  # Successful command output
+    get_matched_packet_counts(self.mock_ad, TEST_IFACE_NAME, TEST_PACKET_IN_HEX)
+    mock_adb_shell.assert_called_once_with(
+        self.mock_ad,
+        'cmd network_stack capture matched-packet-counts'
+        f' {TEST_IFACE_NAME} {TEST_PACKET_IN_HEX}',
+    )
 
-  @patch("net_tests_utils.host.python.adb_utils.adb_shell")
-  def test_stop_capture_unsupported(
-          self, mock_adb_shell: MagicMock
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
+  def test_get_matched_packet_counts_failure(
+      self, mock_adb_shell: MagicMock
   ) -> None:
-      mock_adb_shell.side_effect = AdbError(
-          cmd="", stdout="Unknown command", stderr="", ret_code=3
-      )
-      with asserts.assert_raises(UnsupportedOperationException):
-          stop_capture_packets(
-              self.mock_ad, TEST_IFACE_NAME
-          )
-      asserts.assert_false(
-          is_packet_capture_supported(self.mock_ad),
-          "Stop capturing packets should not be supported.",
+    mock_adb_shell.return_value = (  # Unexpected command output
+        'Any Unexpected Output'
+    )
+    with asserts.assert_raises(UnexpectedBehaviorError):
+      get_matched_packet_counts(
+          self.mock_ad, TEST_IFACE_NAME, TEST_PACKET_IN_HEX
       )
+    asserts.assert_true(
+        is_packet_capture_supported(self.mock_ad),
+        'Get matched packet counts should be supported.',
+    )
 
-  @patch("net_tests_utils.host.python.adb_utils.adb_shell")
-  def test_get_matched_packet_counts_success(
-          self, mock_adb_shell: MagicMock
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
+  def test_get_matched_packet_counts_unsupported(
+      self, mock_adb_shell: MagicMock
   ) -> None:
-      mock_adb_shell.return_value = "10"  # Successful command output
+    mock_adb_shell.side_effect = AdbError(
+        cmd='', stdout='Unknown command', stderr='', ret_code=3
+    )
+    with asserts.assert_raises(UnsupportedOperationException):
       get_matched_packet_counts(
           self.mock_ad, TEST_IFACE_NAME, TEST_PACKET_IN_HEX
       )
-      mock_adb_shell.assert_called_once_with(
-          self.mock_ad,
-          "cmd network_stack capture matched-packet-counts"
-          f" {TEST_IFACE_NAME} {TEST_PACKET_IN_HEX}"
-      )
+    asserts.assert_false(
+        is_packet_capture_supported(self.mock_ad),
+        'Get matched packet counts should not be supported.',
+    )
 
-  @patch("net_tests_utils.host.python.adb_utils.adb_shell")
-  def test_get_matched_packet_counts_failure(
-          self, mock_adb_shell: MagicMock
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
+  def test_get_apf_counters_from_cmd_success(
+      self, mock_adb_shell: MagicMock
   ) -> None:
-      mock_adb_shell.return_value = (  # Unexpected command output
-          "Any Unexpected Output"
-      )
-      with asserts.assert_raises(UnexpectedBehaviorError):
-          get_matched_packet_counts(
-              self.mock_ad, TEST_IFACE_NAME, TEST_PACKET_IN_HEX
-          )
-      asserts.assert_true(
-          is_packet_capture_supported(self.mock_ad),
-          "Get matched packet counts should be supported.",
-      )
+    mock_adb_shell.return_value = """
+        NDIANNESS: 305419896
+        TOTAL_PACKETS: 157553
+        FILTER_AGE_SECONDS: 356
+        FILTER_AGE_16384THS: 5836719
+        APF_VERSION: 6000
+        APF_PROGRAM_ID: 25
+        PASSED_ARP_UNICAST_REPLY: 7
+        PASSED_IPV4: 14
+        PASSED_IPV4_UNICAST: 153472
+        PASSED_IPV6_ICMP: 1
+        PASSED_IPV6_NON_ICMP: 2764
+        PASSED_IPV6_UNICAST_NON_ICMP: 970
+        PASSED_RA: 6
+        DROPPED_RA: 2
+        DROPPED_IPV4_BROADCAST_ADDR: 48
+        DROPPED_IPV4_BROADCAST_NET: 63
+        DROPPED_IPV4_MULTICAST: 30
+        DROPPED_IPV6_NS_OTHER_HOST: 6
+        DROPPED_IPV6_NS_REPLIED_NON_DAD: 9
+        DROPPED_ETHERTYPE_NOT_ALLOWED: 58
+        DROPPED_ARP_OTHER_HOST: 89
+        DROPPED_ARP_REQUEST_REPLIED: 13
+      """
+    get_apf_counters_from_cmd(self.mock_ad, TEST_IFACE_NAME)
+    mock_adb_shell.assert_called_once_with(
+        self.mock_ad, f'cmd network_stack apf {TEST_IFACE_NAME} dump-counters'
+    )
 
-  @patch("net_tests_utils.host.python.adb_utils.adb_shell")
-  def test_get_matched_packet_counts_unsupported(
-          self, mock_adb_shell: MagicMock
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
+  def test_get_apf_counters_from_cmd_failure(
+      self, mock_adb_shell: MagicMock
   ) -> None:
-      mock_adb_shell.side_effect = AdbError(
-          cmd="", stdout="Unknown command", stderr="", ret_code=3
-      )
-      with asserts.assert_raises(UnsupportedOperationException):
-          get_matched_packet_counts(
-              self.mock_ad, TEST_IFACE_NAME, TEST_PACKET_IN_HEX
-          )
-      asserts.assert_false(
-          is_packet_capture_supported(self.mock_ad),
-          "Get matched packet counts should not be supported.",
-      )
+    mock_adb_shell.return_value = (  # Unexpected command output
+        'Any Unexpected Output'
+    )
+    with asserts.assert_raises(UnexpectedBehaviorError):
+      get_apf_counters_from_cmd(self.mock_ad, TEST_IFACE_NAME)
+    asserts.assert_true(
+        is_packet_capture_supported(self.mock_ad),
+        'Dump APF packet counters should be supported.',
+    )
+
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
+  def test_get_apf_counters_from_cmd_unsupported(
+      self, mock_adb_shell: MagicMock
+  ) -> None:
+    mock_adb_shell.side_effect = AdbError(
+        cmd='', stdout='Unknown command', stderr='', ret_code=3
+    )
+    with asserts.assert_raises(UnsupportedOperationException):
+      get_apf_counters_from_cmd(self.mock_ad, TEST_IFACE_NAME)
+    asserts.assert_false(
+        is_apf_dump_counters_supported(self.mock_ad),
+        'Dump APF packet counters should not be supported.',
+    )
 
   @parameterized.parameters(
-      ("2,2048,1", ApfCapabilities(2, 2048, 1)),  # Valid input
-      ("3,1024,0", ApfCapabilities(3, 1024, 0)),  # Valid input
-      ("invalid,output", ApfCapabilities(0, 0, 0)),  # Invalid input
-      ("", ApfCapabilities(0, 0, 0)),  # Empty input
+      ('2,2048,1', ApfCapabilities(2, 2048, 1)),  # Valid input
+      ('3,1024,0', ApfCapabilities(3, 1024, 0)),  # Valid input
+      ('invalid,output', ApfCapabilities(0, 0, 0)),  # Invalid input
+      ('', ApfCapabilities(0, 0, 0)),  # Empty input
   )
-  @patch("net_tests_utils.host.python.adb_utils.adb_shell")
+  @patch('net_tests_utils.host.python.adb_utils.adb_shell')
   def test_get_apf_capabilities(
       self, mock_output, expected_result, mock_adb_shell
   ):
@@ -395,7 +401,7 @@ IpClient.wlan1
     mock_adb_shell.return_value = mock_output
 
     # Call the function under test
-    result = get_apf_capabilities(self.mock_ad, "wlan0")
+    result = get_apf_capabilities(self.mock_ad, 'wlan0')
 
     # Assert that the result matches the expected result
     asserts.assert_equal(result, expected_result)
diff --git a/staticlibs/tests/unit/host/python/assert_utils_test.py b/staticlibs/tests/unit/host/python/assert_utils_test.py
index 1d85a1212f..6f6ba09a7c 100644
--- a/staticlibs/tests/unit/host/python/assert_utils_test.py
+++ b/staticlibs/tests/unit/host/python/assert_utils_test.py
@@ -15,7 +15,10 @@
 from mobly import asserts
 from mobly import base_test
 from net_tests_utils.host.python.assert_utils import (
-    UnexpectedBehaviorError, UnexpectedExceptionError, expect_with_retry, expect_throws
+    UnexpectedBehaviorError,
+    UnexpectedExceptionError,
+    expect_throws,
+    expect_with_retry,
 )
 
 
@@ -56,7 +59,7 @@ class TestAssertUtils(base_test.BaseTestClass):
         retry_interval_sec=0,
     )
     asserts.assert_false(
-        retry_action_called, "retry_action called."
+        retry_action_called, 'retry_action called.'
     )  # Assert retry_action was NOT called
 
   def test_retry_action_not_called_failed(self):
@@ -75,7 +78,7 @@ class TestAssertUtils(base_test.BaseTestClass):
           retry_interval_sec=0,
       )
     asserts.assert_false(
-        retry_action_called, "retry_action called."
+        retry_action_called, 'retry_action called.'
     )  # Assert retry_action was NOT called
 
   def test_retry_action_called(self):
@@ -93,23 +96,23 @@ class TestAssertUtils(base_test.BaseTestClass):
           max_retries=2,
           retry_interval_sec=0,
       )
-    asserts.assert_true(retry_action_called, "retry_action not called.")
+    asserts.assert_true(retry_action_called, 'retry_action not called.')
 
   def test_expect_exception_throws(self):
-      def raise_unexpected_behavior_error():
-          raise UnexpectedBehaviorError()
+    def raise_unexpected_behavior_error():
+      raise UnexpectedBehaviorError()
 
-      expect_throws(raise_unexpected_behavior_error, UnexpectedBehaviorError)
+    expect_throws(raise_unexpected_behavior_error, UnexpectedBehaviorError)
 
   def test_unexpect_exception_throws(self):
-      def raise_value_error():
-          raise ValueError()
+    def raise_value_error():
+      raise ValueError()
 
-      with asserts.assert_raises(UnexpectedExceptionError):
-          expect_throws(raise_value_error, UnexpectedBehaviorError)
+    with asserts.assert_raises(UnexpectedExceptionError):
+      expect_throws(raise_value_error, UnexpectedBehaviorError)
 
   def test_no_exception_throws(self):
-      def raise_no_error():
-          return
+    def raise_no_error():
+      return
 
-      expect_throws(raise_no_error, UnexpectedBehaviorError)
\ No newline at end of file
+    expect_throws(raise_no_error, UnexpectedBehaviorError)
diff --git a/staticlibs/tests/unit/host/python/run_tests.py b/staticlibs/tests/unit/host/python/run_tests.py
index fa6a310293..14f3587e72 100644
--- a/staticlibs/tests/unit/host/python/run_tests.py
+++ b/staticlibs/tests/unit/host/python/run_tests.py
@@ -21,7 +21,7 @@ from host.python.assert_utils_test import TestAssertUtils
 from mobly import suite_runner
 
 
-if __name__ == "__main__":
+if __name__ == '__main__':
   # For MoblyBinaryHostTest, this entry point will be called twice:
   # 1. List tests.
   #   <mobly-par-file-name> -- --list_tests
diff --git a/staticlibs/tests/unit/src/com/android/net/module/util/CollectionUtilsTest.kt b/staticlibs/tests/unit/src/com/android/net/module/util/CollectionUtilsTest.kt
index 1aa943e015..84548fbe5d 100644
--- a/staticlibs/tests/unit/src/com/android/net/module/util/CollectionUtilsTest.kt
+++ b/staticlibs/tests/unit/src/com/android/net/module/util/CollectionUtilsTest.kt
@@ -19,15 +19,16 @@ package com.android.net.module.util
 import android.util.SparseArray
 import androidx.test.filters.SmallTest
 import androidx.test.runner.AndroidJUnit4
+import com.android.net.module.util.CollectionUtils.intArrayToSet
 import kotlin.test.assertContentEquals
-import org.junit.Test
-import org.junit.runner.RunWith
 import kotlin.test.assertEquals
 import kotlin.test.assertFailsWith
 import kotlin.test.assertFalse
 import kotlin.test.assertNull
 import kotlin.test.assertSame
 import kotlin.test.assertTrue
+import org.junit.Test
+import org.junit.runner.RunWith
 
 @RunWith(AndroidJUnit4::class)
 @SmallTest
@@ -144,13 +145,19 @@ class CollectionUtilsTest {
         val listAE = listOf("A", "B", "C", "D", "E")
         val list15 = listOf(1, 2, 3, 4, 5)
         // Normal #zip returns kotlin.Pair, not android.util.Pair
-        assertEquals(list15.zip(listAE).map { android.util.Pair(it.first, it.second) },
-                CollectionUtils.zip(list15, listAE))
+        assertEquals(
+                list15.zip(listAE).map { android.util.Pair(it.first, it.second) },
+                CollectionUtils.zip(list15, listAE)
+        )
         val listNull = listOf("A", null, "B", "C", "D")
-        assertEquals(list15.zip(listNull).map { android.util.Pair(it.first, it.second) },
-                CollectionUtils.zip(list15, listNull))
-        assertEquals(emptyList<android.util.Pair<Int, Int>>(),
-                CollectionUtils.zip(emptyList<Int>(), emptyList<Int>()))
+        assertEquals(
+                list15.zip(listNull).map { android.util.Pair(it.first, it.second) },
+                CollectionUtils.zip(list15, listNull)
+        )
+        assertEquals(
+                emptyList<android.util.Pair<Int, Int>>(),
+                CollectionUtils.zip(emptyList<Int>(), emptyList<Int>())
+        )
         assertFailsWith<IllegalArgumentException> {
             // Different size
             CollectionUtils.zip(listOf(1, 2), list15)
@@ -280,4 +287,12 @@ class CollectionUtilsTest {
                 CollectionUtils.appendArray(String::class.java, stringArr1, "4", "5", "6")
         )
     }
+
+    @Test
+    fun intArrayToSet_arrayWithDuplicateElements_returnsSetWithUniqueElements() {
+        val inputArray = intArrayOf(1, 2, 2, 3, 4, 4, 4, 5, 1)
+        val expectedSet = setOf(1, 2, 3, 4, 5)
+        val result = intArrayToSet(inputArray)
+        assertEquals(expectedSet, result)
+    }
 }
diff --git a/staticlibs/tests/unit/src/com/android/net/module/util/NetUtilsTest.java b/staticlibs/tests/unit/src/com/android/net/module/util/NetUtilsTest.java
index 9e635c2124..c12dfe0497 100644
--- a/staticlibs/tests/unit/src/com/android/net/module/util/NetUtilsTest.java
+++ b/staticlibs/tests/unit/src/com/android/net/module/util/NetUtilsTest.java
@@ -16,8 +16,6 @@
 
 package com.android.net.module.util;
 
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotEquals;
@@ -27,6 +25,7 @@ import static org.junit.Assert.assertTrue;
 import android.net.InetAddresses;
 import android.net.IpPrefix;
 import android.net.RouteInfo;
+import android.os.Build;
 
 import androidx.test.runner.AndroidJUnit4;
 
@@ -115,7 +114,7 @@ public final class NetUtilsTest {
         assertNotEquals(V6_EXPECTED, route);
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testSelectBestRouteWithExcludedRoutes() {
         final List<RouteInfo> routes = new ArrayList<>();
 
@@ -140,4 +139,3 @@ public final class NetUtilsTest {
         assertNull(route);
     }
 }
-
diff --git a/staticlibs/tests/unit/src/com/android/net/module/util/RealtimeSchedulerTest.kt b/staticlibs/tests/unit/src/com/android/net/module/util/RealtimeSchedulerTest.kt
index 30b530f3d0..45e3ffc201 100644
--- a/staticlibs/tests/unit/src/com/android/net/module/util/RealtimeSchedulerTest.kt
+++ b/staticlibs/tests/unit/src/com/android/net/module/util/RealtimeSchedulerTest.kt
@@ -46,10 +46,10 @@ class RealtimeSchedulerTest {
     private class TestHandler(looper: Looper) : Handler(looper) {
         override fun handleMessage(msg: Message) {
             val pair = msg.obj as Pair<ConditionVariable, MutableList<Long>>
-            val cv = pair.first
-            cv.open()
             val executionTimes = pair.second
             executionTimes.add(SystemClock.elapsedRealtime())
+            val cv = pair.first
+            cv.open()
         }
     }
     private val thread = HandlerThread(RealtimeSchedulerTest::class.simpleName).apply { start() }
@@ -109,20 +109,15 @@ class RealtimeSchedulerTest {
             val cv = ConditionVariable()
             handler.post {
                 scheduler.sendDelayedMessage(
-                    Message.obtain(handler, MSG_ID_0, Pair(ConditionVariable(), executionTimes)), 0)
+                    MSG_ID_0, 0, 0, Pair(ConditionVariable(), executionTimes), 0)
                 scheduler.sendDelayedMessage(
-                    Message.obtain(handler, MSG_ID_1, Pair(ConditionVariable(), executionTimes)),
-                    200)
+                    MSG_ID_1, 0, 0, Pair(ConditionVariable(), executionTimes), 200)
                 scheduler.sendDelayedMessage(
-                    Message.obtain(handler, MSG_ID_4, Pair(ConditionVariable(), executionTimes)),
-                    250)
+                    MSG_ID_4, 0, 0, Pair(ConditionVariable(), executionTimes), 250)
                 scheduler.removeDelayedMessage(MSG_ID_4)
                 scheduler.sendDelayedMessage(
-                    Message.obtain(handler, MSG_ID_2, Pair(ConditionVariable(), executionTimes)),
-                    100)
-                scheduler.sendDelayedMessage(
-                    Message.obtain(handler, MSG_ID_3, Pair(cv, executionTimes)),
-                    300)
+                    MSG_ID_2, 0, 0, Pair(ConditionVariable(), executionTimes), 100)
+                scheduler.sendDelayedMessage(MSG_ID_3, 0, 0, Pair(cv, executionTimes), 300)
             }
             cv.block(TIMEOUT_MS)
             assertEquals(4, executionTimes.size)
diff --git a/staticlibs/tests/unit/src/com/android/net/module/util/StructTest.java b/staticlibs/tests/unit/src/com/android/net/module/util/StructTest.java
index 0c2605ff63..c5a922643c 100644
--- a/staticlibs/tests/unit/src/com/android/net/module/util/StructTest.java
+++ b/staticlibs/tests/unit/src/com/android/net/module/util/StructTest.java
@@ -809,6 +809,31 @@ public class StructTest {
                                    toByteBuffer("c0a86401" + "20010db8000300040005000600070008")));
     }
 
+    public static class InetAddressMessage extends Struct {
+        @Field(order = 0, type = Type.IpAddress) public final InetAddress ipAddress;
+
+        InetAddressMessage(final InetAddress ipAddress) {
+            this.ipAddress = ipAddress;
+        }
+    }
+
+    @Test
+    public void testV4AddressInIpAddress() {
+        final InetAddressMessage msg = doParsingMessageTest(
+                "00000000000000000000ffffc0a86401", InetAddressMessage.class, ByteOrder.BIG_ENDIAN);
+        assertEquals(TEST_IPV4_ADDRESS, msg.ipAddress);
+        assertArrayEquals(toByteBuffer("00000000000000000000ffffc0a86401").array(),
+                msg.writeToBytes(ByteOrder.BIG_ENDIAN));
+    }
+    @Test
+    public void testV6AddressInIpAddress() {
+        final InetAddressMessage msg = doParsingMessageTest(
+                "20010db8000300040005000600070008", InetAddressMessage.class, ByteOrder.BIG_ENDIAN);
+        assertEquals(TEST_IPV6_ADDRESS, msg.ipAddress);
+        assertArrayEquals(toByteBuffer("20010db8000300040005000600070008").array(),
+                msg.writeToBytes(ByteOrder.BIG_ENDIAN));
+    }
+
     public static class FullTypeMessage extends Struct {
         @Field(order = 0, type = Type.U8) public final short u8;
         @Field(order = 1, type = Type.U16) public final int u16;
@@ -827,12 +852,13 @@ public class StructTest {
         @Field(order = 14, type = Type.EUI48) public final MacAddress eui48;
         @Field(order = 15, type = Type.Ipv4Address) public final Inet4Address ipv4Address;
         @Field(order = 16, type = Type.Ipv6Address) public final Inet6Address ipv6Address;
+        @Field(order = 17, type = Type.IpAddress) public final InetAddress ipAddress;
 
         FullTypeMessage(final short u8, final int u16, final long u32, final long u63,
                 final BigInteger u64, final byte s8, final short s16, final int s32, final long s64,
                 final int ube16, final long ube32, final long ube63, final BigInteger ube64,
                 final byte[] bytes, final MacAddress eui48, final Inet4Address ipv4Address,
-                final Inet6Address ipv6Address) {
+                final Inet6Address ipv6Address, final InetAddress ipAddress) {
             this.u8 = u8;
             this.u16 = u16;
             this.u32 = u32;
@@ -850,38 +876,52 @@ public class StructTest {
             this.eui48 = eui48;
             this.ipv4Address = ipv4Address;
             this.ipv6Address = ipv6Address;
+            this.ipAddress = ipAddress;
         }
     }
 
     private static final String FULL_TYPE_DATA = "ff" + "ffff" + "ffffffff" + "7fffffffffffffff"
             + "ffffffffffffffff" + "7f" + "7fff" + "7fffffff" + "7fffffffffffffff" + "7fff"
             + "7fffffff" + "7fffffffffffffff" + "ffffffffffffffff" + "20010db80003000400050006"
-            + "001122334455" + "c0a86401" + "20010db8000300040005000600070008";
+            + "001122334455" + "c0a86401" + "20010db8000300040005000600070008"
+            + "00000000000000000000ffffc0a86401";
     private static final String FULL_TYPE_DATA_DIFF_MAC = "ff" + "ffff" + "ffffffff"
             + "7fffffffffffffff" + "ffffffffffffffff" + "7f" + "7fff" + "7fffffff"
             + "7fffffffffffffff" + "7fff" + "7fffffff" + "7fffffffffffffff" + "ffffffffffffffff"
             + "20010db80003000400050006" + "112233445566"
-            + "c0a86401" + "20010db8000300040005000600070008";
+            + "c0a86401" + "20010db8000300040005000600070008"
+            + "00000000000000000000ffffc0a86401";
     private static final String FULL_TYPE_DATA_DIFF_LONG = "ff" + "ffff" + "ffffffff"
             + "7ffffffffffffffe" + "ffffffffffffffff" + "7f" + "7fff" + "7fffffff"
             + "7fffffffffffffff" + "7fff" + "7fffffff" + "7fffffffffffffff" + "ffffffffffffffff"
             + "20010db80003000400050006" + "001122334455"
-            + "c0a86401" + "20010db8000300040005000600070008";
+            + "c0a86401" + "20010db8000300040005000600070008"
+            + "00000000000000000000ffffc0a86401";
     private static final String FULL_TYPE_DATA_DIFF_INTEGER = "ff" + "ffff" + "ffffffff"
             + "7fffffffffffffff" + "ffffffffffffffff" + "7f" + "7fff" + "7fffffff"
             + "7fffffffffffffff" + "7fff" + "ffffff7f" + "7fffffffffffffff" + "ffffffffffffffff"
             + "20010db80003000400050006" + "001122334455"
-            + "c0a86401" + "20010db8000300040005000600070008";
+            + "c0a86401" + "20010db8000300040005000600070008"
+            + "00000000000000000000ffffc0a86401";
     private static final String FULL_TYPE_DATA_DIFF_IPV4 = "ff" + "ffff" + "ffffffff"
             + "7fffffffffffffff" + "ffffffffffffffff" + "7f" + "7fff" + "7fffffff"
             + "7fffffffffffffff" + "7fff" + "ffffff7f" + "7fffffffffffffff" + "ffffffffffffffff"
             + "20010db80003000400050006" + "001122334455"
-            + "c0a81010" + "20010db8000300040005000600070008";
+            + "c0a81010" + "20010db8000300040005000600070008"
+            + "00000000000000000000ffffc0a86401";
     private static final String FULL_TYPE_DATA_DIFF_IPV6 = "ff" + "ffff" + "ffffffff"
             + "7fffffffffffffff" + "ffffffffffffffff" + "7f" + "7fff" + "7fffffff"
             + "7fffffffffffffff" + "7fff" + "ffffff7f" + "7fffffffffffffff" + "ffffffffffffffff"
             + "20010db80003000400050006" + "001122334455"
-            + "c0a86401" + "20010db800030004000500060007000a";
+            + "c0a86401" + "20010db800030004000500060007000a"
+            + "00000000000000000000ffffc0a86401";
+
+    private static final String FULL_TYPE_DATA_DIFF_IP = "ff" + "ffff" + "ffffffff"
+            + "7fffffffffffffff" + "ffffffffffffffff" + "7f" + "7fff" + "7fffffff"
+            + "7fffffffffffffff" + "7fff" + "7fffffff" + "7fffffffffffffff" + "ffffffffffffffff"
+            + "20010db80003000400050006" + "001122334455" + "c0a86401"
+            + "20010db8000300040005000600070008" + "20010db8000300040005000600070008";
+
     @Test
     public void testStructClass_equals() {
         final FullTypeMessage msg = doParsingMessageTest(FULL_TYPE_DATA, FullTypeMessage.class,
@@ -904,8 +944,9 @@ public class StructTest {
         assertEquals(MacAddress.fromString("00:11:22:33:44:55"), msg.eui48);
         assertEquals(TEST_IPV4_ADDRESS, msg.ipv4Address);
         assertEquals(TEST_IPV6_ADDRESS, msg.ipv6Address);
+        assertEquals(TEST_IPV4_ADDRESS, msg.ipAddress);
 
-        assertEquals(98, msg.getSize(FullTypeMessage.class));
+        assertEquals(114, msg.getSize(FullTypeMessage.class));
         assertArrayEquals(toByteBuffer(FULL_TYPE_DATA).array(),
                 msg.writeToBytes(ByteOrder.BIG_ENDIAN));
 
@@ -914,7 +955,8 @@ public class StructTest {
                 new BigInteger("18446744073709551615"), (byte) 0x7f, (short) 0x7fff,
                 (int) 0x7fffffff, (long) 0x7fffffffffffffffL, (int) 0x7fff, (long) 0x7fffffffL,
                 (long) 0x7fffffffffffffffL, new BigInteger("18446744073709551615"), TEST_PREFIX64,
-                MacAddress.fromString("00:11:22:33:44:55"), TEST_IPV4_ADDRESS, TEST_IPV6_ADDRESS);
+                MacAddress.fromString("00:11:22:33:44:55"), TEST_IPV4_ADDRESS, TEST_IPV6_ADDRESS,
+                TEST_IPV4_ADDRESS);
         assertTrue(msg.equals(msg1));
     }
 
@@ -936,12 +978,13 @@ public class StructTest {
         @Field(order = 14, type = Type.EUI48) public final MacAddress eui48;
         @Field(order = 15, type = Type.Ipv4Address) public final Inet4Address ipv4Address;
         @Field(order = 16, type = Type.Ipv6Address) public final Inet6Address ipv6Address;
+        @Field(order = 17, type = Type.IpAddress) public final InetAddress ipAddress;
 
         FullTypeMessageWithDupType(final short u8, final int u16, final long u32, final long u63,
                 final BigInteger u64, final byte s8, final short s16, final int s32, final long s64,
                 final int ube16, final long ube32, final long ube63, final BigInteger ube64,
                 final byte[] bytes, final MacAddress eui48, final Inet4Address ipv4Address,
-                final Inet6Address ipv6Address) {
+                final Inet6Address ipv6Address, final InetAddress ipAddress) {
             this.u8 = u8;
             this.u16 = u16;
             this.u32 = u32;
@@ -959,6 +1002,7 @@ public class StructTest {
             this.eui48 = eui48;
             this.ipv4Address = ipv4Address;
             this.ipv6Address = ipv6Address;
+            this.ipAddress = ipAddress;
         }
     }
 
@@ -1012,6 +1056,12 @@ public class StructTest {
                 FullTypeMessage.class, ByteOrder.BIG_ENDIAN);
         assertNotEquals(msg.ipv6Address, msg6.ipv6Address);
         assertFalse(msg.equals(msg6));
+
+        // With different IP address.
+        final FullTypeMessage msg7 = doParsingMessageTest(FULL_TYPE_DATA_DIFF_IP,
+                FullTypeMessage.class, ByteOrder.BIG_ENDIAN);
+        assertNotEquals(msg.ipAddress, msg7.ipAddress);
+        assertFalse(msg.equals(msg7));
     }
 
     @Test
@@ -1023,7 +1073,8 @@ public class StructTest {
                 + " bytes: 0x20010DB80003000400050006,"
                 + " eui48: 00:11:22:33:44:55,"
                 + " ipv4Address: 192.168.100.1,"
-                + " ipv6Address: 2001:db8:3:4:5:6:7:8";
+                + " ipv6Address: 2001:db8:3:4:5:6:7:8,"
+                + " ipAddress: 192.168.100.1";
 
         final FullTypeMessage msg = doParsingMessageTest(FULL_TYPE_DATA, FullTypeMessage.class,
                 ByteOrder.BIG_ENDIAN);
@@ -1037,14 +1088,15 @@ public class StructTest {
                 + " s32: 2147483647, s64: 9223372036854775807, ube16: 32767, ube32: 2147483647,"
                 + " ube63: 9223372036854775807, ube64: 18446744073709551615,"
                 + " bytes: null, eui48: null, ipv4Address: 192.168.100.1,"
-                + " ipv6Address: null";
+                + " ipv6Address: null, ipAddress: 192.168.100.1";
 
         final FullTypeMessage msg = new FullTypeMessage((short) 0xff, (int) 0xffff,
                 (long) 0xffffffffL, (long) 0x7fffffffffffffffL,
                 null /* u64 */, (byte) 0x7f, (short) 0x7fff,
                 (int) 0x7fffffff, (long) 0x7fffffffffffffffL, (int) 0x7fff, (long) 0x7fffffffL,
                 (long) 0x7fffffffffffffffL, new BigInteger("18446744073709551615"),
-                null /* bytes */, null /* eui48 */, TEST_IPV4_ADDRESS, null /* ipv6Address */);
+                null /* bytes */, null /* eui48 */, TEST_IPV4_ADDRESS, null /* ipv6Address */,
+                TEST_IPV4_ADDRESS);
         assertEquals(expected, msg.toString());
     }
 
diff --git a/staticlibs/tests/unit/src/com/android/net/module/util/TrackRecordTest.kt b/staticlibs/tests/unit/src/com/android/net/module/util/TrackRecordTest.kt
index 8e320d0d4e..d18ae9cf29 100644
--- a/staticlibs/tests/unit/src/com/android/net/module/util/TrackRecordTest.kt
+++ b/staticlibs/tests/unit/src/com/android/net/module/util/TrackRecordTest.kt
@@ -184,6 +184,25 @@ class TrackRecordTest {
         assertTrue(delay >= SHORT_TIMEOUT)
     }
 
+    @Test
+    fun testPollFrom() {
+        val readHead = ArrayTrackRecord<Int>().newReadHead()
+        readHead.add(3)
+        readHead.add(6)
+        readHead.add(7)
+        readHead.add(10)
+        assertEquals(0, readHead.mark)
+        assertEquals(3, readHead.poll(timeoutMs = 1, pos = 0) { it == 3 })
+        assertEquals(1, readHead.mark)
+        assertEquals(7, readHead.poll(timeoutMs = 1, pos = 0) { it == 7 })
+        assertEquals(3, readHead.mark)
+        // Do not advance the read head since the found element is after the current head
+        assertEquals(6, readHead.poll(timeoutMs = 1, pos = 0) { it == 6 })
+        assertEquals(3, readHead.mark)
+        assertNull(readHead.poll(timeoutMs = 1, pos = 1) { it == 3 })
+        assertEquals(4, readHead.mark)
+    }
+
     @Test
     fun testConcurrentPollDisallowed() {
         val failures = AtomicInteger(0)
diff --git a/staticlibs/tests/unit/src/com/android/net/module/util/netlink/InetDiagSocketTest.java b/staticlibs/tests/unit/src/com/android/net/module/util/netlink/InetDiagSocketTest.java
index b44e428547..2662f8132e 100644
--- a/staticlibs/tests/unit/src/com/android/net/module/util/netlink/InetDiagSocketTest.java
+++ b/staticlibs/tests/unit/src/com/android/net/module/util/netlink/InetDiagSocketTest.java
@@ -36,10 +36,13 @@ import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
+import android.annotation.NonNull;
+import android.net.INetd;
 import android.net.InetAddresses;
 import android.util.ArraySet;
 import android.util.Range;
 
+import androidx.annotation.Nullable;
 import androidx.test.filters.SmallTest;
 import androidx.test.runner.AndroidJUnit4;
 
@@ -56,6 +59,7 @@ import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.util.List;
 import java.util.Set;
+import java.util.function.Predicate;
 
 @RunWith(AndroidJUnit4.class)
 @SmallTest
@@ -800,4 +804,201 @@ public class InetDiagSocketTest {
         doTestIsAdbSocket(ROOT_UID, false /* expected */);
         doTestIsAdbSocket(appUid, false /* expected */);
     }
+
+    private static final String INET_DIAG_MSG_MAPPED6 =
+            // struct nlmsghdr
+            "6C000000" // length = 108
+                    + "1400" // type = SOCK_DIAG_BY_FAMILY
+                    + "0000" // flags
+                    + "00000000" // seqno
+                    + "f5220000" // pid
+                    // struct inet_diag_msg
+                    + "0a" // family = AF_INET6
+                    + "02" // idiag_state = 2
+                    + "10" // idiag_timer = 16
+                    + "20" // idiag_retrans = 32
+                    // inet_diag_sockid
+                    + "a845" // idiag_sport = 43077
+                    + "01bb" // idiag_dport = 443
+                    + "00000000000000000000ffffc0000201" // idiag_src = ::FFFF:192.0.2.1
+                    + "00000000000000000000ffffc0000202" // idiag_dst = ::FFFF:192.0.2.2
+                    + "08000000" // idiag_if = 8
+                    + "6300000000000000" // idiag_cookie = 99
+                    + "30000000" // idiag_expires = 48
+                    + "40000000" // idiag_rqueue = 64
+                    + "50000000" // idiag_wqueue = 80
+                    + "39300000" // idiag_uid = 12345
+                    + "851a0000" // idiag_inode = 6789
+                    + "0500" // len = 5
+                    + "0800" // type = 8
+                    + "00000000" // data
+                    + "0800" // len = 8
+                    + "0F00" // type = 15(INET_DIAG_MARK)
+                    + "65000500" // Fwmark netId:101, explicitlySelected: true, permission: network
+                    + "0400" // len = 4
+                    + "0200"; // type = 2
+
+    private static final String INET_DIAG_MSG_MAPPED6_OEM_NET_ID =
+            // struct nlmsghdr
+            "6C000000" // length = 108
+                    + "1400" // type = SOCK_DIAG_BY_FAMILY
+                    + "0000" // flags
+                    + "00000000" // seqno
+                    + "f5220000" // pid
+                    // struct inet_diag_msg
+                    + "0a" // family = AF_INET6
+                    + "02" // idiag_state = 2
+                    + "10" // idiag_timer = 16
+                    + "20" // idiag_retrans = 32
+                    // inet_diag_sockid
+                    + "a845" // idiag_sport = 43077
+                    + "01bb" // idiag_dport = 443
+                    + "00000000000000000000ffffc0000201" // idiag_src = ::FFFF:192.0.2.1
+                    + "00000000000000000000ffffc0000202" // idiag_dst = ::FFFF:192.0.2.2
+                    + "08000000" // idiag_if = 8
+                    + "6300000000000000" // idiag_cookie = 99
+                    + "30000000" // idiag_expires = 48
+                    + "40000000" // idiag_rqueue = 64
+                    + "50000000" // idiag_wqueue = 80
+                    + "39300000" // idiag_uid = 12345
+                    + "851a0000" // idiag_inode = 6789
+                    + "0500" // len = 5
+                    + "0800" // type = 8
+                    + "00000000" // data
+                    + "0800" // len = 8
+                    + "0F00" // type = 15(INET_DIAG_MARK)
+                    + "23000500" // Fwmark netId:35, explicitlySelected: true, permission: network
+                    + "0400" // len = 4
+                    + "0200"; // type = 2
+
+    private boolean matchesDestroyCondition(
+            @NonNull String nlmsg, @NonNull Predicate<InetDiagMessage> condition) {
+        final byte[] nlMsgByte = HexEncoding.decode(nlmsg.toCharArray(), false);
+        final ByteBuffer byteBuffer = ByteBuffer.wrap(nlMsgByte);
+        byteBuffer.order(ByteOrder.nativeOrder());
+        final NetlinkMessage msg = NetlinkMessage.parse(byteBuffer, NETLINK_INET_DIAG);
+        final InetDiagMessage inetDiagMsg = (InetDiagMessage) msg;
+        return condition.test(inetDiagMsg);
+    }
+
+    private void doTestMatchingLocalAddress(
+            boolean expected,
+            @NonNull InetAddress address,
+            @Nullable Set<Range<Integer>> netIdRanges,
+            @Nullable Set<Range<Integer>> uidRanges,
+            @NonNull String nlmsg) {
+        assertEquals(
+                expected,
+                matchesDestroyCondition(
+                        nlmsg,
+                        diagMsg ->
+                                InetDiagMessage.matchesLocalAddressWithNetworkAndUser(
+                                        address, netIdRanges, uidRanges, diagMsg)));
+    }
+
+    private void doTestMatchingLocalAddress(
+            boolean expected,
+            @NonNull InetAddress address,
+            int interfaceId,
+            @NonNull String nlmsg) {
+        assertEquals(
+                expected,
+                matchesDestroyCondition(
+                        nlmsg,
+                        diagMsg ->
+                                InetDiagMessage.matchesLocalAddressWithInterfaceId(
+                                        address, interfaceId, diagMsg)));
+    }
+
+    private void doTestIsLackingPermission(
+            boolean expected, int netId, int permission, @NonNull String nlmsg) {
+        assertEquals(
+                expected,
+                matchesDestroyCondition(
+                        nlmsg,
+                        diagMsg ->
+                                InetDiagMessage.isLackingPermission(netId, permission, diagMsg)));
+    }
+
+    @Test
+    public void testMatchingDestroyConditionAddressOnly() {
+        doTestMatchingLocalAddress(
+                true, /* expected */
+                InetAddresses.parseNumericAddress("2001:db8::3"),
+                null, /* netIdRange */
+                null, /* uidRanges */
+                INET_DIAG_MSG_HEX2);
+        doTestMatchingLocalAddress(
+                true, /* expected */
+                InetAddresses.parseNumericAddress("192.0.2.1"),
+                Set.of(new Range<>(100, 65535)),
+                null, /* uidRanges */
+                INET_DIAG_MSG_MAPPED6);
+    }
+
+    @Test
+    public void testMatchingDestroyConditionForInterfaceId() {
+        doTestMatchingLocalAddress(
+                false /* expected */,
+                InetAddresses.parseNumericAddress("192.0.2.1"),
+                7 /* interfaceId */,
+                INET_DIAG_MSG_MAPPED6);
+        doTestMatchingLocalAddress(
+                true /* expected */,
+                InetAddresses.parseNumericAddress("192.0.2.1"),
+                8 /* interfaceId */,
+                INET_DIAG_MSG_MAPPED6);
+    }
+
+    @Test
+    public void testMatchingDestroyConditionForNetIdRange() {
+        doTestMatchingLocalAddress(
+                false /* expected */,
+                InetAddresses.parseNumericAddress("192.0.2.1"),
+                Set.of(new Range<>(0, 99)),
+                null /* uidRanges */,
+                INET_DIAG_MSG_MAPPED6);
+        doTestMatchingLocalAddress(
+                true /* expected */,
+                InetAddresses.parseNumericAddress("192.0.2.1"),
+                Set.of(new Range<>(0, 99)),
+                null /* uidRanges */,
+                INET_DIAG_MSG_MAPPED6_OEM_NET_ID);
+        doTestMatchingLocalAddress(
+                false /* expected */,
+                InetAddresses.parseNumericAddress("192.0.2.1"),
+                Set.of(new Range<>(100, 100), new Range<>(102, 65535)),
+                null /* uidRanges */,
+                INET_DIAG_MSG_MAPPED6);
+        doTestMatchingLocalAddress(
+                true /* expected */,
+                InetAddresses.parseNumericAddress("192.0.2.1"),
+                Set.of(new Range<>(0, 20), new Range<>(100, 65535)),
+                null /* uidRanges */,
+                INET_DIAG_MSG_MAPPED6);
+    }
+
+    @Test
+    public void testMatchingDestroyConditionForUidRanges() {
+        doTestMatchingLocalAddress(
+                true /* expected */,
+                InetAddresses.parseNumericAddress("2001:db8::3"),
+                Set.of(new Range<>(100, 65535)),
+                Set.of(new Range<>(12000, 12346)),
+                INET_DIAG_MSG_HEX2);
+    }
+
+    @Test
+    public void testIsLackingPermission() {
+        int systemPermission = INetd.PERMISSION_SYSTEM;
+        int netPermission = INetd.PERMISSION_NETWORK;
+        doTestIsLackingPermission(
+                true /* expected */, 101 /* netId */, systemPermission, INET_DIAG_MSG_MAPPED6);
+        doTestIsLackingPermission(
+                false /* expected */, 100 /* netId */, systemPermission, INET_DIAG_MSG_MAPPED6);
+        doTestIsLackingPermission(
+                false /* expected */, 101 /* netId */, netPermission, INET_DIAG_MSG_MAPPED6);
+        doTestIsLackingPermission(
+                true /* expected */, 2693 /* netId */, systemPermission, INET_DIAG_MSG_HEX2);
+    }
 }
diff --git a/staticlibs/tests/unit/src/com/android/net/module/util/netlink/RtNetlinkLinkMessageTest.java b/staticlibs/tests/unit/src/com/android/net/module/util/netlink/RtNetlinkLinkMessageTest.java
index 08cab03b36..dca47eec60 100644
--- a/staticlibs/tests/unit/src/com/android/net/module/util/netlink/RtNetlinkLinkMessageTest.java
+++ b/staticlibs/tests/unit/src/com/android/net/module/util/netlink/RtNetlinkLinkMessageTest.java
@@ -24,7 +24,6 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.when;
 
 import android.net.MacAddress;
 import android.system.OsConstants;
@@ -35,7 +34,6 @@ import com.android.net.module.util.HexDump;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.mockito.Mock;
 import org.mockito.junit.MockitoJUnitRunner;
 
 import java.nio.ByteBuffer;
@@ -44,9 +42,6 @@ import java.nio.ByteOrder;
 @RunWith(MockitoJUnitRunner.class)
 @SmallTest
 public class RtNetlinkLinkMessageTest {
-    @Mock
-    private OsAccess mOsAccess;
-
     // An example of the full RTM_NEWLINK message.
     private static final String RTM_NEWLINK_HEX =
             "64000000100000000000000000000000"   // struct nlmsghr
@@ -194,15 +189,12 @@ public class RtNetlinkLinkMessageTest {
         final String expectedHexBytes =
                 "20000000100005006824000000000000"     // struct nlmsghdr
                 + "00000000080000000100000001000000";  // struct ifinfomsg
-        final String interfaceName = "wlan0";
         final int interfaceIndex = 8;
         final int sequenceNumber = 0x2468;
         final boolean isUp = true;
 
-        when(mOsAccess.if_nametoindex(interfaceName)).thenReturn(interfaceIndex);
-
         final RtNetlinkLinkMessage msg = RtNetlinkLinkMessage.createSetLinkStateMessage(
-                interfaceName, sequenceNumber, isUp, mOsAccess);
+                interfaceIndex, sequenceNumber, isUp);
         assertNotNull(msg);
         final byte[] bytes = msg.pack(ByteOrder.LITTLE_ENDIAN);  // For testing.
         assertEquals(expectedHexBytes, HexDump.toHexString(bytes));
@@ -213,15 +205,12 @@ public class RtNetlinkLinkMessageTest {
         final String expectedHexBytes =
                 "20000000100005006824000000000000"     // struct nlmsghdr
                         + "00000000080000000000000001000000";  // struct ifinfomsg
-        final String interfaceName = "wlan0";
         final int interfaceIndex = 8;
         final int sequenceNumber = 0x2468;
         final boolean isUp = false;
 
-        when(mOsAccess.if_nametoindex(interfaceName)).thenReturn(interfaceIndex);
-
         final RtNetlinkLinkMessage msg = RtNetlinkLinkMessage.createSetLinkStateMessage(
-                interfaceName, sequenceNumber, isUp, mOsAccess);
+                interfaceIndex, sequenceNumber, isUp);
         assertNotNull(msg);
         final byte[] bytes = msg.pack(ByteOrder.LITTLE_ENDIAN);  // For testing.
         assertEquals(expectedHexBytes, HexDump.toHexString(bytes));
@@ -229,14 +218,12 @@ public class RtNetlinkLinkMessageTest {
 
     @Test
     public void testCreateSetLinkStateMessage_InvalidInterface() {
-        final String interfaceName = "wlan0";
+        final int interfaceIndex = OsAccess.INVALID_INTERFACE_INDEX;
         final int sequenceNumber = 0x2468;
         final boolean isUp = false;
 
-        when(mOsAccess.if_nametoindex(interfaceName)).thenReturn(OsAccess.INVALID_INTERFACE_INDEX);
-
         final RtNetlinkLinkMessage msg = RtNetlinkLinkMessage.createSetLinkStateMessage(
-                interfaceName, sequenceNumber, isUp, mOsAccess);
+                interfaceIndex, sequenceNumber, isUp);
         assertNull(msg);
     }
 
@@ -246,15 +233,12 @@ public class RtNetlinkLinkMessageTest {
                 "2C000000100005006824000000000000"   // struct nlmsghdr
                 + "00000000080000000000000000000000" // struct ifinfomsg
                 + "0A000300776C616E31000000";        // IFLA_IFNAME(wlan1)
-        final String interfaceName = "wlan0";
         final int interfaceIndex = 8;
         final int sequenceNumber = 0x2468;
         final String newName = "wlan1";
 
-        when(mOsAccess.if_nametoindex(interfaceName)).thenReturn(interfaceIndex);
-
         final RtNetlinkLinkMessage msg = RtNetlinkLinkMessage.createSetLinkNameMessage(
-                interfaceName, sequenceNumber, newName, mOsAccess);
+                interfaceIndex, sequenceNumber, newName);
         assertNotNull(msg);
         final byte[] bytes = msg.pack(ByteOrder.LITTLE_ENDIAN);  // For testing.
         assertEquals(expectedHexBytes, HexDump.toHexString(bytes));
@@ -262,28 +246,23 @@ public class RtNetlinkLinkMessageTest {
 
     @Test
     public void testCreateSetLinkNameMessage_InterfaceNotFound() {
-        final String interfaceName = "wlan0";
+        final int interfaceIndex = OsAccess.INVALID_INTERFACE_INDEX;
         final int sequenceNumber = 0x2468;
         final String newName = "wlan1";
 
-        when(mOsAccess.if_nametoindex(interfaceName)).thenReturn(OsAccess.INVALID_INTERFACE_INDEX);
-
         assertNull(RtNetlinkLinkMessage.createSetLinkNameMessage(
-                interfaceName, sequenceNumber, newName, mOsAccess));
+                interfaceIndex, sequenceNumber, newName));
     }
 
     @Test
     public void testCreateSetLinkNameMessage_InvalidNewName() {
-        final String interfaceName = "wlan0";
         final int interfaceIndex = 8;
         final int sequenceNumber = 0x2468;
 
-        when(mOsAccess.if_nametoindex(interfaceName)).thenReturn(interfaceIndex);
-
         final String[] invalidNames = {"", "interface_name_longer_than_limit"};
         for (String invalidName : invalidNames) {
             assertNull(RtNetlinkLinkMessage.createSetLinkNameMessage(
-                    interfaceName, sequenceNumber, invalidName, mOsAccess));
+                    interfaceIndex, sequenceNumber, invalidName));
         }
     }
 
@@ -292,14 +271,11 @@ public class RtNetlinkLinkMessageTest {
         final String expectedHexBytes =
                 "20000000120005006824000000000000"    // struct nlmsghdr
                 + "00000000080000000000000000000000"; // struct ifinfomsg
-        final String interfaceName = "wlan0";
         final int interfaceIndex = 8;
         final int sequenceNumber = 0x2468;
 
-        when(mOsAccess.if_nametoindex(interfaceName)).thenReturn(interfaceIndex);
-
         final RtNetlinkLinkMessage msg = RtNetlinkLinkMessage.createGetLinkMessage(
-                interfaceName, sequenceNumber, mOsAccess);
+                interfaceIndex, sequenceNumber);
         assertNotNull(msg);
         final byte[] bytes = msg.pack(ByteOrder.LITTLE_ENDIAN);  // For testing.
         assertEquals(expectedHexBytes, HexDump.toHexString(bytes));
@@ -310,16 +286,12 @@ public class RtNetlinkLinkMessageTest {
         final String expectedHexBytes =
                 "20000000100005006824000000000000"    // struct nlmsghdr
                         + "00000000080000000100000001000100"; // struct ifinfomsg
-        final String interfaceName = "wlan0";
         final int interfaceIndex = 8;
         final int sequenceNumber = 0x2468;
 
-        when(mOsAccess.if_nametoindex(interfaceName)).thenReturn(interfaceIndex);
-
         final RtNetlinkLinkMessage msg = RtNetlinkLinkMessage.createSetFlagsMessage(
-                interfaceName,
+                interfaceIndex,
                 sequenceNumber,
-                mOsAccess,
                 NetlinkConstants.IFF_UP,
                 ~NetlinkConstants.IFF_LOWER_UP);
         assertNotNull(msg);
@@ -332,18 +304,14 @@ public class RtNetlinkLinkMessageTest {
         final String expectedHexBytes =
                 "280000001000050068240000000000000000000008000000"   // struct nlmsghdr
                         + "000000000000000008000400DC050000"; // struct ifinfomsg
-        final String interfaceName = "wlan0";
         final int interfaceIndex = 8;
         final int sequenceNumber = 0x2468;
         final int mtu = 1500;
 
-        when(mOsAccess.if_nametoindex(interfaceName)).thenReturn(interfaceIndex);
-
         final RtNetlinkLinkMessage msg = RtNetlinkLinkMessage.createSetMtuMessage(
-                interfaceName,
+                interfaceIndex,
                 sequenceNumber,
-                mtu,
-                mOsAccess);
+                mtu);
         assertNotNull(msg);
         final byte[] bytes = msg.pack(ByteOrder.LITTLE_ENDIAN);  // For testing.
         assertEquals(expectedHexBytes, HexDump.toHexString(bytes));
diff --git a/staticlibs/tests/unit/src/com/android/testutils/HandlerUtilsTest.kt b/staticlibs/tests/unit/src/com/android/testutils/HandlerUtilsTest.kt
index 440b836cc9..b08d785a3c 100644
--- a/staticlibs/tests/unit/src/com/android/testutils/HandlerUtilsTest.kt
+++ b/staticlibs/tests/unit/src/com/android/testutils/HandlerUtilsTest.kt
@@ -19,46 +19,51 @@ package com.android.testutils
 import android.os.Handler
 import android.os.HandlerThread
 import com.android.testutils.FunctionalUtils.ThrowingSupplier
+import kotlin.random.Random
 import kotlin.test.assertEquals
 import kotlin.test.assertFailsWith
 import kotlin.test.assertNull
 import org.junit.Test
 import org.junit.runner.RunWith
-import org.junit.runners.JUnit4
 
 private const val ATTEMPTS = 50 // Causes testWaitForIdle to take about 150ms on aosp_crosshatch-eng
 private const val TIMEOUT_MS = 1000
 
-@RunWith(JUnit4::class)
+@DevSdkIgnoreRunner.MonitorThreadLeak
+@RunWith(DevSdkIgnoreRunner::class)
 class HandlerUtilsTest {
     @Test
     fun testWaitForIdle() {
         val handlerThread = HandlerThread("testHandler").apply { start() }
+        tryTest {
+            // Tests that waitForIdle can be called many times without ill impact if the service is
+            // already idle.
+            repeat(ATTEMPTS) {
+                handlerThread.waitForIdle(TIMEOUT_MS)
+            }
 
-        // Tests that waitForIdle can be called many times without ill impact if the service is
-        // already idle.
-        repeat(ATTEMPTS) {
-            handlerThread.waitForIdle(TIMEOUT_MS)
-        }
-
-        // Tests that calling waitForIdle waits for messages to be processed. Use both an
-        // inline runnable that's instantiated at each loop run and a runnable that's instantiated
-        // once for all.
-        val tempRunnable = object : Runnable {
-            // Use StringBuilder preferentially to StringBuffer because StringBuilder is NOT
-            // thread-safe. It's part of the point that both runnables run on the same thread
-            // so if anything is wrong in that space it's better to opportunistically use a class
-            // where things might go wrong, even if there is no guarantee of failure.
-            var memory = StringBuilder()
-            override fun run() {
-                memory.append("b")
+            // Tests that calling waitForIdle waits for messages to be processed. Use both an
+            // inline runnable that's instantiated at each loop run and a runnable that's
+            // instantiated once for all.
+            val tempRunnable = object : Runnable {
+                // Use StringBuilder preferentially to StringBuffer because StringBuilder is NOT
+                // thread-safe. It's part of the point that both runnables run on the same thread
+                // so if anything is wrong in that space it's better to opportunistically use a
+                // class where things might go wrong, even if there is no guarantee of failure.
+                var memory = StringBuilder()
+                override fun run() {
+                    memory.append("b")
+                }
             }
-        }
-        repeat(ATTEMPTS) { i ->
-            handlerThread.threadHandler.post { tempRunnable.memory.append("a"); }
-            handlerThread.threadHandler.post(tempRunnable)
-            handlerThread.waitForIdle(TIMEOUT_MS)
-            assertEquals(tempRunnable.memory.toString(), "ab".repeat(i + 1))
+            repeat(ATTEMPTS) { i ->
+                handlerThread.threadHandler.post { tempRunnable.memory.append("a"); }
+                handlerThread.threadHandler.post(tempRunnable)
+                handlerThread.waitForIdle(TIMEOUT_MS)
+                assertEquals(tempRunnable.memory.toString(), "ab".repeat(i + 1))
+            }
+        } cleanup {
+            handlerThread.quitSafely()
+            handlerThread.join()
         }
     }
 
@@ -67,22 +72,49 @@ class HandlerUtilsTest {
     @Test
     fun testVisibleOnHandlerThread() {
         val handlerThread = HandlerThread("testHandler").apply { start() }
-        val handler = Handler(handlerThread.looper)
+        tryTest {
+            val handler = Handler(handlerThread.looper)
 
-        repeat(ATTEMPTS) { attempt ->
-            var x = -10
-            var y = -11
-            y = visibleOnHandlerThread(handler, ThrowingSupplier<Int> { x = attempt; attempt })
-            assertEquals(attempt, x)
-            assertEquals(attempt, y)
-            handler.post { assertEquals(attempt, x) }
-        }
+            repeat(ATTEMPTS) { attempt ->
+                var x = -10
+                var y = -11
+                y = visibleOnHandlerThread(handler, ThrowingSupplier<Int> { x = attempt; attempt })
+                assertEquals(attempt, x)
+                assertEquals(attempt, y)
+                handler.post { assertEquals(attempt, x) }
+            }
+
+            assertFailsWith<IllegalArgumentException> {
+                visibleOnHandlerThread(handler) { throw IllegalArgumentException() }
+            }
 
-        assertFailsWith<IllegalArgumentException> {
-            visibleOnHandlerThread(handler) { throw IllegalArgumentException() }
+            // Null values may be returned by the supplier
+            assertNull(visibleOnHandlerThread(handler, ThrowingSupplier<Nothing?> { null }))
+        } cleanup {
+            handlerThread.quitSafely()
+            handlerThread.join()
         }
+    }
+
+    @Test
+    fun testPostAndWait() {
+        val handlerThread = HandlerThread("testHandler").apply { start() }
+        tryTest {
+            val handler = Handler(handlerThread.looper)
 
-        // Null values may be returned by the supplier
-        assertNull(visibleOnHandlerThread(handler, ThrowingSupplier<Nothing?> { null }))
+            assertFailsWith<RuntimeException> {
+                handler.postAndWait { throw RuntimeException() }
+            }
+
+            val result1 = Random.nextInt()
+            val result = handler.postAndWait {
+                assertEquals(handlerThread, Thread.currentThread())
+                result1
+            }
+            assertEquals(result, result1)
+        } cleanup {
+            handlerThread.quitSafely()
+            handlerThread.join()
+        }
     }
 }
diff --git a/staticlibs/tests/unit/src/com/android/testutils/TestableNetworkCallbackTest.kt b/staticlibs/tests/unit/src/com/android/testutils/TestableNetworkCallbackTest.kt
index e838bdc564..c35013da86 100644
--- a/staticlibs/tests/unit/src/com/android/testutils/TestableNetworkCallbackTest.kt
+++ b/staticlibs/tests/unit/src/com/android/testutils/TestableNetworkCallbackTest.kt
@@ -21,20 +21,20 @@ import android.net.LinkAddress
 import android.net.LinkProperties
 import android.net.Network
 import android.net.NetworkCapabilities
-import com.android.testutils.RecorderCallback.CallbackEntry
-import com.android.testutils.RecorderCallback.CallbackEntry.Available
-import com.android.testutils.RecorderCallback.CallbackEntry.BlockedStatus
-import com.android.testutils.RecorderCallback.CallbackEntry.CapabilitiesChanged
-import com.android.testutils.RecorderCallback.CallbackEntry.Companion.AVAILABLE
-import com.android.testutils.RecorderCallback.CallbackEntry.Companion.BLOCKED_STATUS
-import com.android.testutils.RecorderCallback.CallbackEntry.Companion.LINK_PROPERTIES_CHANGED
-import com.android.testutils.RecorderCallback.CallbackEntry.Companion.LOSING
-import com.android.testutils.RecorderCallback.CallbackEntry.Companion.LOST
-import com.android.testutils.RecorderCallback.CallbackEntry.Companion.NETWORK_CAPS_UPDATED
-import com.android.testutils.RecorderCallback.CallbackEntry.Companion.RESUMED
-import com.android.testutils.RecorderCallback.CallbackEntry.Companion.SUSPENDED
-import com.android.testutils.RecorderCallback.CallbackEntry.Companion.UNAVAILABLE
-import com.android.testutils.RecorderCallback.CallbackEntry.LinkPropertiesChanged
+import com.android.testutils.TestableNetworkCallback.Event
+import com.android.testutils.TestableNetworkCallback.Event.Available
+import com.android.testutils.TestableNetworkCallback.Event.BlockedStatus
+import com.android.testutils.TestableNetworkCallback.Event.CapabilitiesChanged
+import com.android.testutils.TestableNetworkCallback.Event.Companion.AVAILABLE
+import com.android.testutils.TestableNetworkCallback.Event.Companion.BLOCKED_STATUS
+import com.android.testutils.TestableNetworkCallback.Event.Companion.LINK_PROPERTIES_CHANGED
+import com.android.testutils.TestableNetworkCallback.Event.Companion.LOSING
+import com.android.testutils.TestableNetworkCallback.Event.Companion.LOST
+import com.android.testutils.TestableNetworkCallback.Event.Companion.NETWORK_CAPS_UPDATED
+import com.android.testutils.TestableNetworkCallback.Event.Companion.RESUMED
+import com.android.testutils.TestableNetworkCallback.Event.Companion.SUSPENDED
+import com.android.testutils.TestableNetworkCallback.Event.Companion.UNAVAILABLE
+import com.android.testutils.TestableNetworkCallback.Event.LinkPropertiesChanged
 import kotlin.reflect.KClass
 import kotlin.test.assertEquals
 import kotlin.test.assertFails
@@ -170,19 +170,19 @@ class TestableNetworkCallbackTest {
         val net = Network(193)
         val netCaps = NetworkCapabilities().addTransportType(CELLULAR)
         // Check that expecting callbackThat anything fails when no callback has been received.
-        assertFails { mCallback.expect<CallbackEntry>(timeoutMs = SHORT_TIMEOUT_MS) { true } }
+        assertFails { mCallback.expect<Event>(timeoutMs = SHORT_TIMEOUT_MS) { true } }
 
         // Basic test for true and false
         mCallback.onAvailable(net)
         mCallback.expect<Available> { true }
         mCallback.onAvailable(net)
-        assertFails { mCallback.expect<CallbackEntry>(timeoutMs = SHORT_TIMEOUT_MS) { false } }
+        assertFails { mCallback.expect<Event>(timeoutMs = SHORT_TIMEOUT_MS) { false } }
 
         // Try a positive and a negative case
         mCallback.onBlockedStatusChanged(net, true)
-        mCallback.expect<CallbackEntry> { cb -> cb is BlockedStatus && cb.blocked }
+        mCallback.expect<Event> { cb -> cb is BlockedStatus && cb.blocked }
         mCallback.onCapabilitiesChanged(net, netCaps)
-        assertFails { mCallback.expect<CallbackEntry>(timeoutMs = SHORT_TIMEOUT_MS) { cb ->
+        assertFails { mCallback.expect<Event>(timeoutMs = SHORT_TIMEOUT_MS) { cb ->
             cb is CapabilitiesChanged && cb.caps.hasTransport(WIFI)
         } }
     }
@@ -410,24 +410,24 @@ class TestableNetworkCallbackTest {
 
 private object TNCInterpreter : ConcurrentInterpreter<TestableNetworkCallback>(interpretTable)
 
-val EntryList = CallbackEntry::class.sealedSubclasses.map { it.simpleName }.joinToString("|")
-private fun callbackEntryFromString(name: String): KClass<out CallbackEntry> {
-    return CallbackEntry::class.sealedSubclasses.first { it.simpleName == name }
+val EntryList = Event::class.sealedSubclasses.map { it.simpleName }.joinToString("|")
+private fun callbackEntryFromString(name: String): KClass<out Event> {
+    return Event::class.sealedSubclasses.first { it.simpleName == name }
 }
 
 @SuppressLint("NewApi") // Uses hidden APIs, which the linter would identify as missing APIs.
 private val interpretTable = listOf<InterpretMatcher<TestableNetworkCallback>>(
     // Interpret "Available(xx)" as "call to onAvailable with netId xx", and likewise for
     // all callback types. This is implemented above by enumerating the subclasses of
-    // CallbackEntry and reading their simpleName.
+    // Event and reading their simpleName.
     Regex("""(.*)\s+=\s+($EntryList)\((\d+)\)""") to { i, cb, t ->
         val record = i.interpret(t.strArg(1), cb)
         assertTrue(callbackEntryFromString(t.strArg(2)).isInstance(record))
-        // Strictly speaking testing for is CallbackEntry is useless as it's been tested above
+        // Strictly speaking testing for is Event is useless as it's been tested above
         // but the compiler can't figure things out from the isInstance call. It does understand
-        // from the assertTrue(is CallbackEntry) that this is true, which allows to access
+        // from the assertTrue(is Event) that this is true, which allows to access
         // the 'network' member below.
-        assertTrue(record is CallbackEntry)
+        assertTrue(record is Event)
         assertEquals(record.network.netId, t.intArg(3))
     },
     // Interpret "onAvailable(xx)" as calling "onAvailable" with a netId of xx, and likewise for
@@ -451,7 +451,7 @@ private val interpretTable = listOf<InterpretMatcher<TestableNetworkCallback>>(
     },
     Regex("""poll\((\d+)\)""") to { i, cb, t -> cb.poll(t.timeArg(1)) },
     // Interpret "eventually(Available(xx), timeout)" as calling eventuallyExpect that expects
-    // CallbackEntry.AVAILABLE with netId of xx within timeout*INTERPRET_TIME_UNIT timeout, and
+    // Event.AVAILABLE with netId of xx within timeout*INTERPRET_TIME_UNIT timeout, and
     // likewise for all callback types.
     Regex("""eventually\(($EntryList)\((\d+)\),\s+(\d+)\)""") to { i, cb, t ->
         val net = Network(t.intArg(2))
diff --git a/staticlibs/tests/unit/src/com/android/testutils/TestableNetworkCallbackTestJava.java b/staticlibs/tests/unit/src/com/android/testutils/TestableNetworkCallbackTestJava.java
index 4570d0aecb..da1cbe4dc0 100644
--- a/staticlibs/tests/unit/src/com/android/testutils/TestableNetworkCallbackTestJava.java
+++ b/staticlibs/tests/unit/src/com/android/testutils/TestableNetworkCallbackTestJava.java
@@ -16,7 +16,7 @@
 
 package com.android.testutils;
 
-import static com.android.testutils.RecorderCallback.CallbackEntry.AVAILABLE;
+import static com.android.testutils.TestableNetworkCallback.Event.AVAILABLE;
 import static com.android.testutils.TestableNetworkCallbackKt.anyNetwork;
 
 import static org.junit.Assume.assumeTrue;
diff --git a/staticlibs/testutils/Android.bp b/staticlibs/testutils/Android.bp
index b59ccc6292..24257eb569 100644
--- a/staticlibs/testutils/Android.bp
+++ b/staticlibs/testutils/Android.bp
@@ -60,19 +60,13 @@ java_library {
         "hostdevice/**/*.kt",
     ],
     host_supported: true,
+    sdk_version: "module_current",
     visibility: [
         "//packages/modules/Connectivity/staticlibs/tests:__subpackages__",
         "//packages/modules/Connectivity/staticlibs/client-libs/tests:__subpackages__",
         "//packages/modules/Connectivity/tests/cts/hostside",
+        "//external/cronet:__subpackages__",
     ],
-    // There are downstream branches using an old version of Kotlin
-    // that used to reserve the right to make breaking changes to the
-    // Result type and disallowed returning an instance of it.
-    // Later versions allowed this and there was never a change,
-    // so no matter the version returning Result is always fine,
-    // but on sc-mainline-prod the compiler rejects it without
-    // the following flag.
-    kotlincflags: ["-Xallow-result-return-type"],
     libs: [
         "jsr305",
     ],
diff --git a/staticlibs/testutils/app/connectivitychecker/src/com/android/testutils/connectivitypreparer/ConnectivityCheckTest.kt b/staticlibs/testutils/app/connectivitychecker/src/com/android/testutils/connectivitypreparer/ConnectivityCheckTest.kt
index c42d9e57fc..de175ce15d 100644
--- a/staticlibs/testutils/app/connectivitychecker/src/com/android/testutils/connectivitypreparer/ConnectivityCheckTest.kt
+++ b/staticlibs/testutils/app/connectivitychecker/src/com/android/testutils/connectivitypreparer/ConnectivityCheckTest.kt
@@ -34,8 +34,8 @@ import com.android.net.module.util.NetworkStackConstants.IPV4_ADDR_ANY
 import com.android.net.module.util.NetworkStackConstants.IPV6_ADDR_ANY
 import com.android.testutils.AutoReleaseNetworkCallbackRule
 import com.android.testutils.ConnectUtil
-import com.android.testutils.RecorderCallback.CallbackEntry.CapabilitiesChanged
-import com.android.testutils.RecorderCallback.CallbackEntry.LinkPropertiesChanged
+import com.android.testutils.TestableNetworkCallback.Event.CapabilitiesChanged
+import com.android.testutils.TestableNetworkCallback.Event.LinkPropertiesChanged
 import com.android.testutils.runAsShell
 import com.android.testutils.tryTest
 import java.io.IOException
diff --git a/staticlibs/testutils/devicetests/com/android/testutils/AutoCloseTestInterfaceRule.kt b/staticlibs/testutils/devicetests/com/android/testutils/AutoCloseTestInterfaceRule.kt
index 89de0b3d7a..2b625f6573 100644
--- a/staticlibs/testutils/devicetests/com/android/testutils/AutoCloseTestInterfaceRule.kt
+++ b/staticlibs/testutils/devicetests/com/android/testutils/AutoCloseTestInterfaceRule.kt
@@ -20,6 +20,7 @@ import android.Manifest.permission.MANAGE_TEST_NETWORKS
 import android.content.Context
 import android.net.TestNetworkInterface
 import android.net.TestNetworkManager
+import android.net.TestNetworkManager.TestInterfaceRequest
 import org.junit.rules.TestRule
 import org.junit.runner.Description
 import org.junit.runners.model.Statement
@@ -40,6 +41,14 @@ class AutoCloseTestInterfaceRule(
         }
     }
 
+    fun createTestInterface(req: TestInterfaceRequest): TestNetworkInterface {
+        return runAsShell(MANAGE_TEST_NETWORKS) {
+            tnm.createTestInterface(req)
+        }.also {
+            ifaces.add(it)
+        }
+    }
+
     private fun closeAllInterfaces() {
         // TODO: wait on RTM_DELLINK before proceeding.
         for (iface in ifaces) {
diff --git a/staticlibs/testutils/devicetests/com/android/testutils/AutoReleaseNetworkCallbackRule.kt b/staticlibs/testutils/devicetests/com/android/testutils/AutoReleaseNetworkCallbackRule.kt
index be6947f231..31a12df75f 100644
--- a/staticlibs/testutils/devicetests/com/android/testutils/AutoReleaseNetworkCallbackRule.kt
+++ b/staticlibs/testutils/devicetests/com/android/testutils/AutoReleaseNetworkCallbackRule.kt
@@ -16,14 +16,18 @@
 
 package com.android.testutils
 
+import android.content.pm.PackageManager.FEATURE_TELEPHONY
+import android.content.pm.PackageManager.FEATURE_WIFI
 import android.net.ConnectivityManager
 import android.net.ConnectivityManager.NetworkCallback
 import android.net.Network
 import android.net.NetworkCapabilities
+import android.net.NetworkCapabilities.TRANSPORT_CELLULAR
+import android.net.NetworkCapabilities.TRANSPORT_WIFI
 import android.net.NetworkRequest
 import android.os.Handler
 import androidx.test.platform.app.InstrumentationRegistry
-import com.android.testutils.RecorderCallback.CallbackEntry
+import com.android.testutils.TestableNetworkCallback.Event.Available
 import java.util.Collections
 import kotlin.test.fail
 import org.junit.rules.TestRule
@@ -58,9 +62,11 @@ class AutoReleaseNetworkCallbackRule : NetworkCallbackHelper(), TestRule {
  * Helps file [NetworkCallback]s to request or watch networks, keeping track of them for cleanup.
  */
 open class NetworkCallbackHelper {
-    private val cm by lazy {
+    private val context by lazy {
         InstrumentationRegistry.getInstrumentation().context
-            .getSystemService(ConnectivityManager::class.java)
+    }
+    private val cm by lazy {
+        context.getSystemService(ConnectivityManager::class.java)
             ?: fail("ConnectivityManager not found")
     }
     private val cbToCleanup = Collections.synchronizedSet(mutableSetOf<NetworkCallback>())
@@ -76,19 +82,19 @@ open class NetworkCallbackHelper {
         if (cellRequestCb != null) {
             fail("Cell network was already requested")
         }
-        val cb = requestNetwork(
-            NetworkRequest.Builder()
-                .addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR)
-                .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
-                .build()
-        )
+        val cb = requestNetwork(getInternetRequest(TRANSPORT_CELLULAR))
         cellRequestCb = cb
-        return cb.expect<CallbackEntry.Available>(
+        return cb.expect<Available>(
             errorMsg = "Cell network not available. " +
                     "Please ensure the device has working mobile data."
         ).network
     }
 
+    private fun getInternetRequest(transportType: Int) = NetworkRequest.Builder()
+        .addTransportType(transportType)
+        .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
+        .build()
+
     /**
      * Unrequest a cell network requested through [requestCell].
      */
@@ -98,6 +104,24 @@ open class NetworkCallbackHelper {
         cellRequestCb = null
     }
 
+    /**
+     * Request a cell network if supported by the device.
+     */
+    fun requestCellIfSupported() = if (context.packageManager.hasSystemFeature(FEATURE_TELEPHONY)) {
+        requestNetwork(getInternetRequest(TRANSPORT_CELLULAR))
+    } else {
+        null
+    }
+
+    /**
+     * Request a Wi-Fi network if supported by the device.
+     */
+    fun requestWifiIfSupported() = if (context.packageManager.hasSystemFeature(FEATURE_WIFI)) {
+        requestNetwork(getInternetRequest(TRANSPORT_WIFI))
+    } else {
+        null
+    }
+
     private fun <T> addCallback(
         cb: T,
         registrar: (NetworkCallback) -> Unit
diff --git a/staticlibs/testutils/devicetests/com/android/testutils/CarrierConfigRule.kt b/staticlibs/testutils/devicetests/com/android/testutils/CarrierConfigRule.kt
index 076398e2f8..0dc2b42437 100644
--- a/staticlibs/testutils/devicetests/com/android/testutils/CarrierConfigRule.kt
+++ b/staticlibs/testutils/devicetests/com/android/testutils/CarrierConfigRule.kt
@@ -25,7 +25,6 @@ import android.content.Intent
 import android.content.IntentFilter
 import android.content.pm.PackageManager
 import android.os.ConditionVariable
-import android.os.ParcelFileDescriptor
 import android.os.PersistableBundle
 import android.os.Process
 import android.telephony.CarrierConfigManager
@@ -37,10 +36,11 @@ import android.telephony.TelephonyManager.CarrierPrivilegesCallback
 import android.util.Log
 import androidx.test.platform.app.InstrumentationRegistry
 import com.android.modules.utils.build.SdkLevel
+import com.android.net.module.util.ArrayTrackRecord
 import com.android.testutils.runAsShell
+import com.android.testutils.runCommandInShell
 import com.android.testutils.tryTest
 import java.security.MessageDigest
-import kotlin.test.assertEquals
 import kotlin.test.assertNotNull
 import kotlin.test.assertTrue
 import org.junit.rules.TestRule
@@ -62,6 +62,21 @@ class CarrierConfigRule : TestRule {
     private val context by lazy { InstrumentationRegistry.getInstrumentation().context }
     private val uiAutomation by lazy { InstrumentationRegistry.getInstrumentation().uiAutomation }
     private val ccm by lazy { context.getSystemService(CarrierConfigManager::class.java) }
+    private val tm by lazy { context.getSystemService(TelephonyManager::class.java) }
+    private val certHash by lazy {
+        val signatures = context.packageManager.getPackageInfo(
+            context.opPackageName,
+            PackageManager.GET_SIGNATURES
+        ).signatures
+
+        val digest = MessageDigest.getInstance("SHA-256")
+        val result = signatures?.get(0)?.toByteArray()?.let {
+            bytesToHexString(digest.digest(it))
+        }
+
+        if (result == null) Log.e(TAG, "Can't get cert!")
+        result
+    }
 
     // Map of (subId) -> (original values of overridden settings)
     private val originalConfigs = mutableMapOf<Int, PersistableBundle>()
@@ -103,14 +118,30 @@ class CarrierConfigRule : TestRule {
     }
 
     private fun overrideConfigAndWait(subId: Int, config: PersistableBundle) {
-        val changeReceiver = ConfigChangeReceiver(subId)
-        context.registerReceiver(changeReceiver, IntentFilter(ACTION_CARRIER_CONFIG_CHANGED))
-        ccm.overrideConfig(subId, config)
-        assertTrue(
-            changeReceiver.cv.block(CARRIER_CONFIG_CHANGE_TIMEOUT_MS),
-            "Timed out waiting for config change for subId $subId"
-        )
-        context.unregisterReceiver(changeReceiver)
+        runAsShell(MODIFY_PHONE_STATE) {
+            val changeReceiver = ConfigChangeReceiver(subId)
+            context.registerReceiver(changeReceiver, IntentFilter(ACTION_CARRIER_CONFIG_CHANGED))
+            ccm.overrideConfig(subId, config)
+            assertTrue(
+                changeReceiver.cv.block(CARRIER_CONFIG_CHANGE_TIMEOUT_MS),
+                "Timed out waiting for config change for subId $subId"
+            )
+            context.unregisterReceiver(changeReceiver)
+        }
+
+        // Carrier privilege status may not be reset yet even after receiving
+        // ACTION_CARRIER_CONFIG_CHANGED, so make sure to also wait for
+        // CarrierPrivilegesCallback before proceeding.
+        if (SdkLevel.isAtLeastT()) {
+            config.getStringArray(
+                CarrierConfigManager.KEY_CARRIER_CERTIFICATE_STRING_ARRAY
+            )?.let {
+                eventuallyExpectCarrierPrivilegesChangedOnSubId(
+                    subId,
+                    it.contains(certHash)
+                )
+            }
+        }
     }
 
     /**
@@ -130,20 +161,12 @@ class CarrierConfigRule : TestRule {
         }
         originalConfig.putAll(previousValues)
 
-        runAsShell(MODIFY_PHONE_STATE) {
-            overrideConfigAndWait(subId, config)
-        }
-    }
-
-    private fun runShellCommand(cmd: String) {
-        val fd: ParcelFileDescriptor = uiAutomation.executeShellCommand(cmd)
-        fd.close() // Don't care about the output.
+        overrideConfigAndWait(subId, config)
     }
 
     /**
      * Converts a byte array into a String of hexadecimal characters.
      *
-     * @param bytes an array of bytes
      * @return hex string representation of bytes array
      */
     private fun bytesToHexString(bytes: ByteArray?): String? {
@@ -169,59 +192,34 @@ class CarrierConfigRule : TestRule {
             )
         }
 
-        fun getCertHash(): String {
-            val pkgInfo = context.packageManager.getPackageInfo(
-                context.opPackageName,
-                PackageManager.GET_SIGNATURES
+        val hasPrivilege = getCarrierPrivilegesOnSubId(subId).uids.contains(Process.myUid())
+        if (hasPrivilege == hold) {
+            Log.w(
+                TAG,
+                "Package ${context.opPackageName} is already ${if (hold) "" else "not "}privileged"
             )
-            val digest = MessageDigest.getInstance("SHA-256")
-            val certHash = digest.digest(pkgInfo.signatures!![0]!!.toByteArray())
-            return bytesToHexString(certHash)!!
+            return
         }
 
-        val tm = context.getSystemService(TelephonyManager::class.java)!!
+        val currentCertStrings = runAsShell(READ_PHONE_STATE) {
+            ccm.getConfigForSubIdCompat(
+                subId,
+                setOf(CarrierConfigManager.KEY_CARRIER_CERTIFICATE_STRING_ARRAY)
+            )
+        }.getStringArray(CarrierConfigManager.KEY_CARRIER_CERTIFICATE_STRING_ARRAY) ?: arrayOf()
 
-        val cv = ConditionVariable()
-        val cpb = PrivilegeWaiterCallback(cv)
-        // The lambda below is capturing |cpb|, whose type inherits from a class that appeared in
-        // T. This means the lambda will compile as a private method of this class taking a
-        // PrivilegeWaiterCallback argument. As JUnit uses reflection to enumerate all methods
-        // including private methods, this would fail with a link error when running on S-.
-        // To solve this, make the lambda serializable, which causes the compiler to emit a
-        // synthetic class instead of a synthetic method.
-        tryTest @JvmSerializableLambda {
-            val slotIndex = SubscriptionManager.getSlotIndex(subId)!!
-            runAsShell(READ_PRIVILEGED_PHONE_STATE) @JvmSerializableLambda {
-                tm.registerCarrierPrivilegesCallback(slotIndex, { it.run() }, cpb)
-            }
-            // Wait for the callback to be registered
-            assertTrue(cv.block(CARRIER_CONFIG_CHANGE_TIMEOUT_MS),
-                "Can't register CarrierPrivilegesCallback")
-            if (cpb.hasPrivilege == hold) {
-                if (hold) {
-                    Log.w(TAG, "Package ${context.opPackageName} already is privileged")
-                } else {
-                    Log.w(TAG, "Package ${context.opPackageName} already isn't privileged")
-                }
-                return@tryTest
-            }
-            cv.close()
-            if (hold) {
-                addConfigOverrides(subId, PersistableBundle().also {
-                    it.putStringArray(CarrierConfigManager.KEY_CARRIER_CERTIFICATE_STRING_ARRAY,
-                        arrayOf(getCertHash()))
-                })
-            } else {
-                cleanUpNow()
-            }
-            assertTrue(cv.block(CARRIER_CONFIG_CHANGE_TIMEOUT_MS),
-                "Timed out waiting for CarrierPrivilegesCallback")
-            assertEquals(cpb.hasPrivilege, hold, "Couldn't set carrier privilege")
-        } cleanup @JvmSerializableLambda {
-            runAsShell(READ_PRIVILEGED_PHONE_STATE) @JvmSerializableLambda {
-                tm.unregisterCarrierPrivilegesCallback(cpb)
-            }
+        val hashes = if (hold) {
+            currentCertStrings + certHash
+        } else {
+            currentCertStrings.subtract(setOf(certHash)).toTypedArray()
         }
+
+        addConfigOverrides(subId, PersistableBundle().apply {
+            putStringArray(
+                CarrierConfigManager.KEY_CARRIER_CERTIFICATE_STRING_ARRAY,
+                hashes
+            )
+        })
     }
 
     /**
@@ -234,32 +232,36 @@ class CarrierConfigRule : TestRule {
      */
     fun dropCarrierPrivilege(subId: Int) = setHoldCarrierPrivilege(false, subId)
 
+    /**
+     * Setting carrier service package was added in U QPR1, so check for that.
+     *
+     * In T and below, return false. In V and above, return true as this must work.
+     * In U, test for the command presence. That means the test can be disabled by
+     * removing that command in QPR1+, but this would indicate malicious intent.
+     */
+    fun isSettingCarrierServicePackageSupported(): Boolean {
+        if (SdkLevel.isAtLeastV()) return true
+        // A T device with this command present should not be held accountable to have it work
+        if (!SdkLevel.isAtLeastU()) return false
+        return !runCommandInShell("cmd phone set-carrier-service-package-override")
+                .startsWith("Unknown command")
+    }
+
     /**
      * Sets the carrier service package override for the given subscription ID. A null argument will
      * clear any previously-set override.
      */
     fun setCarrierServicePackageOverride(subId: Int, pkg: String?) {
-        if (!SdkLevel.isAtLeastU()) {
+        if (!isSettingCarrierServicePackageSupported()) {
             throw UnsupportedOperationException(
                 "Setting carrier service package override requires at least U SDK"
             )
         }
 
-        val tm = context.getSystemService(TelephonyManager::class.java)!!
-
         val cv = ConditionVariable()
         val cpb = CarrierServiceChangedWaiterCallback(cv)
-        // The lambda below is capturing |cpb|, whose type inherits from a class that appeared in
-        // T. This means the lambda will compile as a private method of this class taking a
-        // PrivilegeWaiterCallback argument. As JUnit uses reflection to enumerate all methods
-        // including private methods, this would fail with a link error when running on S-.
-        // To solve this, make the lambda serializable, which causes the compiler to emit a
-        // synthetic class instead of a synthetic method.
-        tryTest @JvmSerializableLambda {
-            val slotIndex = SubscriptionManager.getSlotIndex(subId)!!
-            runAsShell(READ_PRIVILEGED_PHONE_STATE) @JvmSerializableLambda {
-                tm.registerCarrierPrivilegesCallback(slotIndex, { it.run() }, cpb)
-            }
+        tryTest {
+            tm.registerCarrierPrivilegesCallbackWithPermission(subId, cpb)
             // Wait for the callback to be registered
             assertTrue(cv.block(CARRIER_CONFIG_CHANGE_TIMEOUT_MS),
                 "Can't register CarrierPrivilegesCallback")
@@ -275,28 +277,87 @@ class CarrierConfigRule : TestRule {
                 if (null == pkg) {
                     // There is a bug in clear-carrier-service-package-override where not adding
                     // the -s argument will use the wrong slot index : b/299604822
-                    runShellCommand("cmd phone clear-carrier-service-package-override" +
+                    runCommandInShell("cmd phone clear-carrier-service-package-override" +
                             " -s $subId")
                 } else {
-                    runShellCommand("cmd phone set-carrier-service-package-override $pkg" +
+                    runCommandInShell("cmd phone set-carrier-service-package-override $pkg" +
                             " -s $subId")
                 }
             }
             assertTrue(cv.block(CARRIER_CONFIG_CHANGE_TIMEOUT_MS),
                 "Can't modify carrier service package")
-        } cleanup @JvmSerializableLambda {
-            runAsShell(READ_PRIVILEGED_PHONE_STATE) @JvmSerializableLambda {
-                tm.unregisterCarrierPrivilegesCallback(cpb)
-            }
+        } cleanup {
+            tm.unregisterCarrierPrivilegesCallbackWithPermission(cpb)
         }
     }
 
-    private class PrivilegeWaiterCallback(private val cv: ConditionVariable) :
-        CarrierPrivilegesCallback {
-        var hasPrivilege = false
+    private fun TelephonyManager.registerCarrierPrivilegesCallbackWithPermission(
+        subId: Int,
+        cpb: CarrierPrivilegesCallback
+    ) =
+        runAsShell(READ_PRIVILEGED_PHONE_STATE) {
+            registerCarrierPrivilegesCallback(
+                SubscriptionManager.getSlotIndex(subId)!!,
+                { it.run() },
+                cpb
+            )
+        }
+
+    private fun TelephonyManager.unregisterCarrierPrivilegesCallbackWithPermission(
+        cpb: CarrierPrivilegesCallback
+    ) =
+        runAsShell(READ_PRIVILEGED_PHONE_STATE) {
+            unregisterCarrierPrivilegesCallback(cpb)
+        }
+
+    private class PrivilegeWaiterCallback() : CarrierPrivilegesCallback {
+        data class CarrierPrivileges(val packages: Set<String>, val uids: Set<Int>)
+        private val history = ArrayTrackRecord<CarrierPrivileges>().ReadHead()
+
         override fun onCarrierPrivilegesChanged(p: MutableSet<String>, uids: MutableSet<Int>) {
-            hasPrivilege = uids.contains(Process.myUid())
-            cv.open()
+            history.add(CarrierPrivileges(p, uids))
+        }
+
+        fun expectCarrierPrivilegesChanged(): CarrierPrivileges {
+            return eventuallyExpectCarrierPrivilegesChanged { true }
+        }
+
+        fun eventuallyExpectCarrierPrivilegesChanged(
+            predicate: (CarrierPrivileges) -> Boolean
+        ): CarrierPrivileges {
+            val result = history.poll(
+                CARRIER_CONFIG_CHANGE_TIMEOUT_MS,
+                predicate
+            )
+            assertNotNull(result, "onCarrierPrivilegesChanged not received!")
+            return result
+        }
+    }
+
+    private fun getCarrierPrivilegesOnSubId(
+        subId: Int
+    ): PrivilegeWaiterCallback.CarrierPrivileges {
+        val cpb = PrivilegeWaiterCallback()
+        return tryTest {
+            tm.registerCarrierPrivilegesCallbackWithPermission(subId, cpb)
+            cpb.expectCarrierPrivilegesChanged()
+        } cleanup {
+            tm.unregisterCarrierPrivilegesCallbackWithPermission(cpb)
+        }
+    }
+
+    private fun eventuallyExpectCarrierPrivilegesChangedOnSubId(
+        subId: Int,
+        expectedPrivilege: Boolean
+    ): PrivilegeWaiterCallback.CarrierPrivileges {
+        val cpb = PrivilegeWaiterCallback()
+        return tryTest {
+            tm.registerCarrierPrivilegesCallbackWithPermission(subId, cpb)
+            cpb.eventuallyExpectCarrierPrivilegesChanged {
+                it.uids.contains(Process.myUid()) == expectedPrivilege
+            }
+        } cleanup {
+            tm.unregisterCarrierPrivilegesCallbackWithPermission(cpb)
         }
     }
 
@@ -317,19 +378,14 @@ class CarrierConfigRule : TestRule {
      * test case unless cleaning up earlier is required.
      */
     fun cleanUpNow() {
-        runAsShell(MODIFY_PHONE_STATE) {
-            originalConfigs.forEach { (subId, config) ->
-                try {
-                    // Do not use null as the config to reset, as it would reset configs that may
-                    // have been set by target preparers such as
-                    // ConnectivityTestTargetPreparer / CarrierConfigSetupTest.
-                    overrideConfigAndWait(subId, config)
-                } catch (e: Throwable) {
-                    Log.e(TAG, "Error resetting carrier config for subId $subId")
-                }
+        originalConfigs.forEach { (subId, config) ->
+            try {
+                overrideConfigAndWait(subId, config)
+            } catch (e: Throwable) {
+                Log.e(TAG, "Error resetting carrier config for subId $subId: $e", e)
             }
-            originalConfigs.clear()
         }
+        originalConfigs.clear()
         originalCarrierServicePackages.forEach { (subId, pkg) ->
             setCarrierServicePackageOverride(subId, pkg)
         }
diff --git a/staticlibs/testutils/devicetests/com/android/testutils/ConnectUtil.kt b/staticlibs/testutils/devicetests/com/android/testutils/ConnectUtil.kt
index d60ab5960f..9045598439 100644
--- a/staticlibs/testutils/devicetests/com/android/testutils/ConnectUtil.kt
+++ b/staticlibs/testutils/devicetests/com/android/testutils/ConnectUtil.kt
@@ -35,8 +35,8 @@ import android.os.ParcelFileDescriptor
 import android.os.SystemClock
 import android.util.Log
 import androidx.test.platform.app.InstrumentationRegistry.getInstrumentation
-import com.android.testutils.RecorderCallback.CallbackEntry
-import com.android.testutils.RecorderCallback.CallbackEntry.CapabilitiesChanged
+import com.android.testutils.TestableNetworkCallback.Event
+import com.android.testutils.TestableNetworkCallback.Event.CapabilitiesChanged
 import java.util.concurrent.CompletableFuture
 import java.util.concurrent.TimeUnit
 import kotlin.test.assertNotNull
@@ -242,7 +242,7 @@ class ConnectUtil(private val context: Context) {
     }
 }
 
-private inline fun <reified T : CallbackEntry> TestableNetworkCallback.eventuallyExpect(
+private inline fun <reified T : Event> TestableNetworkCallback.eventuallyExpect(
     errorMsg: String,
     crossinline predicate: (T) -> Boolean = { true }
 ): T = history.poll(defaultTimeoutMs, mark) { it is T && predicate(it) }.also {
diff --git a/staticlibs/testutils/devicetests/com/android/testutils/ConnectivityDiagnosticsCollector.kt b/staticlibs/testutils/devicetests/com/android/testutils/ConnectivityDiagnosticsCollector.kt
index 1db57655ad..3c3cdedf88 100644
--- a/staticlibs/testutils/devicetests/com/android/testutils/ConnectivityDiagnosticsCollector.kt
+++ b/staticlibs/testutils/devicetests/com/android/testutils/ConnectivityDiagnosticsCollector.kt
@@ -43,6 +43,7 @@ import android.util.Log
 import androidx.annotation.RequiresApi
 import androidx.test.platform.app.InstrumentationRegistry
 import com.android.modules.utils.build.SdkLevel.isAtLeastS
+import com.android.testutils.com.android.testutils.getTargetModuleVersion
 import java.io.ByteArrayOutputStream
 import java.io.CharArrayWriter
 import java.io.File
@@ -339,6 +340,7 @@ class ConnectivityDiagnosticsCollector : BaseMetricListener() {
             headerObj.put("shellPermissionsUnavailable", true)
         }
         failureHeader = headerObj.apply {
+            put("targetModuleVersion", getTargetModuleVersion())
             put("time", DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(ZonedDateTime.now()))
             put(
                 "wifiEnabled",
diff --git a/staticlibs/testutils/devicetests/com/android/testutils/DefaultNetworkRestoreMonitor.kt b/staticlibs/testutils/devicetests/com/android/testutils/DefaultNetworkRestoreMonitor.kt
index dd52d0b307..104ddde447 100644
--- a/staticlibs/testutils/devicetests/com/android/testutils/DefaultNetworkRestoreMonitor.kt
+++ b/staticlibs/testutils/devicetests/com/android/testutils/DefaultNetworkRestoreMonitor.kt
@@ -16,6 +16,7 @@
 
 package com.android.testutils
 
+import android.annotation.SuppressLint
 import android.content.Context
 import android.content.pm.PackageManager
 import android.net.ConnectivityManager
@@ -23,6 +24,7 @@ import android.net.Network
 import android.net.NetworkCapabilities
 import com.android.internal.annotations.VisibleForTesting
 import com.android.net.module.util.BitUtils
+import com.android.testutils.TestableNetworkCallback.Event.CapabilitiesChanged
 import java.util.concurrent.CompletableFuture
 import java.util.concurrent.TimeUnit
 import org.junit.runner.Description
@@ -41,7 +43,10 @@ class DefaultNetworkRestoreMonitor(
     val cm = ctx.getSystemService(ConnectivityManager::class.java)!!
     val pm = ctx.packageManager
     val listener = object : RunListener() {
+        @SuppressLint("WrongConstant") // transportNamesOf wants @Transport annotation
         override fun testFinished(desc: Description) {
+            fun ConnectivityManager.activeNetworkCaps() =
+                activeNetwork?.let { getNetworkCapabilities(it) }
             // Only the first method that does not restore the default network should be blamed.
             if (firstFailure != null) {
                 return
@@ -49,15 +54,16 @@ class DefaultNetworkRestoreMonitor(
             val cb = TestableNetworkCallback()
             cm.registerDefaultNetworkCallback(cb)
             try {
-                cb.eventuallyExpect<RecorderCallback.CallbackEntry.CapabilitiesChanged>(
-                    timeoutMs = timeoutMs
-                ) {
+                cb.eventuallyExpect<CapabilitiesChanged>(timeoutMs = timeoutMs) {
                     BitUtils.packBits(it.caps.transportTypes) == initialTransports &&
                             it.caps.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)
                 }
             } catch (e: AssertionError) {
-                firstFailure = IllegalStateException(desc.methodName + " does not restore the" +
-                        "default network, initialTransports = $initialTransports", e)
+                val expectedTransports = BitUtils.unpackBits(initialTransports)
+                firstFailure = IllegalStateException(desc.methodName + " does not restore the " +
+                        "default network. Default network has caps ${cm.activeNetworkCaps()} ; " +
+                        "expected a network with transports = " +
+                        NetworkCapabilities.transportNamesOf(expectedTransports))
             } finally {
                 cm.unregisterNetworkCallback(cb)
             }
@@ -79,10 +85,7 @@ class DefaultNetworkRestoreMonitor(
 
         val capFuture = CompletableFuture<NetworkCapabilities>()
         val cb = object : ConnectivityManager.NetworkCallback() {
-            override fun onCapabilitiesChanged(
-                    network: Network,
-                    cap: NetworkCapabilities
-            ) {
+            override fun onCapabilitiesChanged(network: Network, cap: NetworkCapabilities) {
                 capFuture.complete(cap)
             }
         }
@@ -103,9 +106,7 @@ class DefaultNetworkRestoreMonitor(
     fun reportResultAndCleanUp(desc: Description) {
         notifier.fireTestStarted(desc)
         if (firstFailure != null) {
-            notifier.fireTestFailure(
-                    Failure(desc, firstFailure)
-            )
+            notifier.fireTestFailure(Failure(desc, firstFailure))
         }
         notifier.fireTestFinished(desc)
         notifier.removeListener(listener)
diff --git a/staticlibs/testutils/devicetests/com/android/testutils/DevSdkIgnoreRule.kt b/staticlibs/testutils/devicetests/com/android/testutils/DevSdkIgnoreRule.kt
index 46229b0cd2..ebeb590922 100644
--- a/staticlibs/testutils/devicetests/com/android/testutils/DevSdkIgnoreRule.kt
+++ b/staticlibs/testutils/devicetests/com/android/testutils/DevSdkIgnoreRule.kt
@@ -25,11 +25,9 @@ import org.junit.rules.TestRule
 import org.junit.runner.Description
 import org.junit.runners.model.Statement
 
+// TODO : remove uses in /cts/ and remove
 @Deprecated("Use Build.VERSION_CODES", ReplaceWith("Build.VERSION_CODES.S_V2"))
 const val SC_V2 = Build.VERSION_CODES.S_V2
-// TODO: Remove this when Build.VERSION_CODES.VANILLA_ICE_CREAM is available in all branches
-// where this code builds
-const val VANILLA_ICE_CREAM = 35 // Bui1ld.VERSION_CODES.VANILLA_ICE_CREAM
 
 private val MAX_TARGET_SDK_ANNOTATION_RE = Pattern.compile("MaxTargetSdk([0-9]+)$")
 private val targetSdk = InstrumentationRegistry.getContext().applicationInfo.targetSdkVersion
diff --git a/staticlibs/testutils/devicetests/com/android/testutils/DevSdkIgnoreRunner.kt b/staticlibs/testutils/devicetests/com/android/testutils/DevSdkIgnoreRunner.kt
index d00ae525cd..8b1ecba77a 100644
--- a/staticlibs/testutils/devicetests/com/android/testutils/DevSdkIgnoreRunner.kt
+++ b/staticlibs/testutils/devicetests/com/android/testutils/DevSdkIgnoreRunner.kt
@@ -139,7 +139,7 @@ class DevSdkIgnoreRunner(private val klass: Class<*>) : Runner(), Filterable, So
         }
 
         val networkRestoreMonitor = if (restoreDefaultNetwork) {
-            DefaultNetworkRestoreMonitor(ctx, notifier).apply{
+            DefaultNetworkRestoreMonitor(ctx, notifier).apply {
                 init(ConnectUtil(ctx))
             }
         } else {
diff --git a/tests/cts/net/util/java/android/net/cts/util/EthernetTestInterface.kt b/staticlibs/testutils/devicetests/com/android/testutils/EthernetTestInterface.kt
similarity index 91%
rename from tests/cts/net/util/java/android/net/cts/util/EthernetTestInterface.kt
rename to staticlibs/testutils/devicetests/com/android/testutils/EthernetTestInterface.kt
index 20cfa1d3f0..1bcfede8a9 100644
--- a/tests/cts/net/util/java/android/net/cts/util/EthernetTestInterface.kt
+++ b/staticlibs/testutils/devicetests/com/android/testutils/EthernetTestInterface.kt
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package android.net.cts.util
+package com.android.testutils
 
 import android.Manifest.permission.NETWORK_SETTINGS
 import android.content.Context
@@ -24,13 +24,10 @@ import android.net.EthernetManager.STATE_ABSENT
 import android.net.EthernetManager.STATE_LINK_UP
 import android.net.IpConfiguration
 import android.net.TestNetworkInterface
-import android.net.cts.util.EthernetTestInterface.EthernetStateListener.CallbackEntry.InterfaceStateChanged
 import android.os.Handler
 import android.util.Log
 import com.android.net.module.util.ArrayTrackRecord
-import com.android.testutils.PollPacketReader
-import com.android.testutils.runAsShell
-import com.android.testutils.waitForIdle
+import com.android.testutils.EthernetTestInterface.EthernetStateListener.Event.InterfaceStateChanged
 import java.net.NetworkInterface
 import kotlin.concurrent.Volatile
 import kotlin.test.assertNotNull
@@ -50,15 +47,15 @@ class EthernetTestInterface(
     val testIface: TestNetworkInterface
 ) {
     private class EthernetStateListener(private val trackedIface: String) : InterfaceStateListener {
-        val events = ArrayTrackRecord<CallbackEntry>().newReadHead()
+        val events = ArrayTrackRecord<Event>().newReadHead()
 
-        sealed class CallbackEntry {
+        sealed class Event {
             data class InterfaceStateChanged(
                 val iface: String,
                 val state: Int,
                 val role: Int,
                 val cfg: IpConfiguration?
-            ) : CallbackEntry()
+            ) : Event()
         }
 
         override fun onInterfaceStateChanged(
diff --git a/staticlibs/testutils/devicetests/com/android/testutils/HandlerUtils.kt b/staticlibs/testutils/devicetests/com/android/testutils/HandlerUtils.kt
index f00ca116c7..9b6101756c 100644
--- a/staticlibs/testutils/devicetests/com/android/testutils/HandlerUtils.kt
+++ b/staticlibs/testutils/devicetests/com/android/testutils/HandlerUtils.kt
@@ -21,7 +21,6 @@ package com.android.testutils
 import android.os.ConditionVariable
 import android.os.Handler
 import android.os.HandlerThread
-import android.util.Log
 import com.android.testutils.FunctionalUtils.ThrowingRunnable
 import com.android.testutils.FunctionalUtils.ThrowingSupplier
 import java.lang.Exception
@@ -64,15 +63,27 @@ fun waitForIdleSerialExecutor(executor: Executor, timeoutMs: Long) {
  * To achieve this, this method runs the passed block on the handler and blocks this thread
  * until it's executed, so keep in mind this method will block, (including, if the handler isn't
  * running, blocking forever).
+ *
+ * This method is not guaranteed to run the passed supplier on the handler thread.
+ */
+fun <T> visibleOnHandlerThread(handler: Handler, supplier: ThrowingSupplier<T>): T =
+    handler.postAndWait(supplier::get)
+
+/** Overload of visibleOnHandlerThread but executes a block of code that does not return a value. */
+inline fun visibleOnHandlerThread(handler: Handler, r: ThrowingRunnable) {
+    visibleOnHandlerThread(handler, ThrowingSupplier { r.run() })
+}
+
+/**
+ * Run a block on a handler and wait for the result.
  */
-fun <T> visibleOnHandlerThread(handler: Handler, supplier: ThrowingSupplier<T>): T {
+inline fun <T> Handler.postAndWait(crossinline what: () -> T): T {
     val cv = ConditionVariable()
     var rv: Result<T> = Result.failure(RuntimeException("Not run"))
-    handler.post {
+    post {
         try {
-            rv = Result.success(supplier.get())
+            rv = Result.success(what())
         } catch (exception: Exception) {
-            Log.e(TAG, "visibleOnHandlerThread caught exception", exception)
             rv = Result.failure(exception)
         }
         cv.open()
@@ -83,8 +94,3 @@ fun <T> visibleOnHandlerThread(handler: Handler, supplier: ThrowingSupplier<T>):
     cv.block()
     return rv.getOrThrow()
 }
-
-/** Overload of visibleOnHandlerThread but executes a block of code that does not return a value. */
-inline fun visibleOnHandlerThread(handler: Handler, r: ThrowingRunnable){
-    visibleOnHandlerThread(handler, ThrowingSupplier<Unit> { r.run() })
-}
diff --git a/staticlibs/testutils/devicetests/com/android/testutils/NdResponder.kt b/staticlibs/testutils/devicetests/com/android/testutils/NdResponder.kt
new file mode 100644
index 0000000000..3fae993354
--- /dev/null
+++ b/staticlibs/testutils/devicetests/com/android/testutils/NdResponder.kt
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+package com.android.testutils
+
+import android.net.IpPrefix
+import android.net.MacAddress
+import android.system.OsConstants.IPPROTO_ICMPV6
+import android.util.Log
+import com.android.net.module.util.NetworkStackConstants.ETHER_TYPE_IPV6
+import com.android.net.module.util.NetworkStackConstants.ICMPV6_NEIGHBOR_SOLICITATION
+import com.android.net.module.util.NetworkStackConstants.ICMPV6_ROUTER_SOLICITATION
+import com.android.net.module.util.Struct
+import com.android.net.module.util.structs.EthernetHeader
+import com.android.net.module.util.structs.Icmpv6Header
+import com.android.net.module.util.structs.Ipv6Header
+import com.android.net.module.util.structs.NsHeader
+import java.io.FileOutputStream
+import java.io.IOException
+import java.net.Inet6Address
+import java.nio.ByteBuffer
+import java.util.concurrent.ConcurrentHashMap
+import kotlin.random.Random
+
+private const val TAG = "NdResponder"
+
+class NdResponder(
+    val packetReader: PollPacketReader,
+    val prefix: IpPrefix,
+) : PacketResponder(packetReader, ::isRsOrNs, TAG) {
+    companion object {
+        private fun isRsOrNs(packet: ByteArray): Boolean {
+            val buffer = ByteBuffer.wrap(packet)
+            val ethHeader = Struct.parse(EthernetHeader::class.java, buffer)
+            if (ethHeader.etherType.toInt() != ETHER_TYPE_IPV6) return false
+
+            val ipv6Header = Struct.parse(Ipv6Header::class.java, buffer)
+            if (ipv6Header.nextHeader.toInt() != IPPROTO_ICMPV6) return false
+
+            val icmpv6Header = Struct.parse(Icmpv6Header::class.java, buffer)
+            return icmpv6Header.type.toInt() == ICMPV6_ROUTER_SOLICITATION ||
+                    icmpv6Header.type.toInt() == ICMPV6_NEIGHBOR_SOLICITATION
+        }
+
+        private fun makeRandomPrefix(): IpPrefix {
+            val prefixBytes = IpPrefix("2001:db8::/64").address.address
+            Random.Default.nextBytes(prefixBytes, fromIndex = 4, toIndex = 16)
+            return IpPrefix(prefixBytes, 64)
+        }
+    }
+
+    data class NeighborEntry(
+        val macAddr: MacAddress,
+        val ipAddr: Inet6Address,
+        val ra: RaPkt?, // null if neighbor is not a router.
+    )
+    private val neighborMap: ConcurrentHashMap<Inet6Address, NeighborEntry> = ConcurrentHashMap()
+
+    constructor(packetReader: PollPacketReader) : this(packetReader, makeRandomPrefix())
+
+    /**
+     * Adds a new router to be advertised.
+     * @param mac the mac address of the router.
+     * @param ip the link-local address of the router.
+     */
+    fun addRouterEntry(mac: MacAddress, ip: Inet6Address) {
+        val ra = RaPkt()
+                .addPioOption(prefix = prefix.toString(), flags = "LA")
+                .addRdnssOption(dns = "2001:4860:4860::8888,2001:4860:4860::8844")
+        addRouterEntry(mac, ip, ra)
+    }
+
+    fun addRouterEntry(mac: MacAddress, ip: Inet6Address, ra: RaPkt) {
+        neighborMap.put(ip, NeighborEntry(mac, ip, ra))
+    }
+
+    /**
+     * Adds a new neighbor to be advertised.
+     * @param mac the mac address of the neighbor.
+     * @param ip the link-local address of the neighbor.
+     */
+    fun addNeighborEntry(mac: MacAddress, ip: Inet6Address) {
+        neighborMap.put(ip, NeighborEntry(mac, ip, null))
+    }
+
+    private fun sendPacket(reader: PollPacketReader, packet: ByteArray) {
+        try {
+            // Note: PollPacketReader#createFd() is just a getter for the underlying fd.
+            FileOutputStream(reader.createFd()).use { it.write(packet) }
+        } catch (e: IOException) {
+            // Throwing an exception here will crash the test process.
+            Log.e(TAG, "Failed to send packet", e)
+        }
+    }
+
+    private fun replyToRouterSolicitation(reader: PollPacketReader, dstMac: MacAddress) {
+        neighborMap.forEach { (ip, neigh) ->
+            val ra = neigh.ra
+            if (ra == null) return@forEach // continue
+            // TODO: add prefix to neighborMap
+            val ether = EtherPkt(src = neigh.macAddr, dst = dstMac)
+            val ip6 = Ip6Pkt(src = neigh.ipAddr.hostAddress, dst = "ff02::1")
+            val p = ether / ip6 / ra
+            sendPacket(reader, p.build())
+        }
+    }
+
+    private fun replyToNeighborSolicitation(
+        reader: PollPacketReader,
+        dstMac: MacAddress,
+        dstIp: Inet6Address,
+        targetIp: Inet6Address
+    ) {
+        val neighbor = neighborMap.get(targetIp)
+        if (neighbor == null) return
+
+        val ether = EtherPkt(dst = dstMac, src = neighbor.macAddr)
+        val ipv6 = Ip6Pkt(src = neighbor.ipAddr, dst = dstIp)
+        val flags = if (neighbor.ra == null) "SO" else "RSO"
+        val na = NaPkt(targetIp.hostAddress, flags)
+                .addTllaOption(neighbor.macAddr)
+        val p = ether / ipv6 / na
+        sendPacket(reader, p.build())
+    }
+
+    protected override fun replyToPacket(packet: ByteArray, reader: PollPacketReader) {
+        val buf = ByteBuffer.wrap(packet)
+        // Messages are filtered by parent class, so it is safe to assume that packet is either an
+        // RS or NS.
+        val ethHdr = Struct.parse(EthernetHeader::class.java, buf)
+        val ipv6Hdr = Struct.parse(Ipv6Header::class.java, buf)
+        val icmpv6Header = Struct.parse(Icmpv6Header::class.java, buf)
+
+        when (icmpv6Header.type.toInt()) {
+            ICMPV6_ROUTER_SOLICITATION -> replyToRouterSolicitation(reader, ethHdr.srcMac)
+            ICMPV6_NEIGHBOR_SOLICITATION -> {
+                val nsHeader = Struct.parse(NsHeader::class.java, buf)
+                replyToNeighborSolicitation(reader, ethHdr.srcMac, ipv6Hdr.srcIp, nsHeader.target)
+            }
+        }
+    }
+}
diff --git a/staticlibs/testutils/devicetests/com/android/testutils/PacketBridge.kt b/staticlibs/testutils/devicetests/com/android/testutils/PacketBridge.kt
index 0b736d1615..5eeaee38cb 100644
--- a/staticlibs/testutils/devicetests/com/android/testutils/PacketBridge.kt
+++ b/staticlibs/testutils/devicetests/com/android/testutils/PacketBridge.kt
@@ -28,7 +28,7 @@ import android.net.TestNetworkInterface
 import android.net.TestNetworkManager
 import android.net.TestNetworkSpecifier
 import android.os.Binder
-import com.android.testutils.RecorderCallback.CallbackEntry.Available
+import com.android.testutils.TestableNetworkCallback.Event.Available
 import java.net.InetAddress
 import libcore.io.IoUtils
 
diff --git a/staticlibs/testutils/devicetests/com/android/testutils/PacketBuilderUtils.kt b/staticlibs/testutils/devicetests/com/android/testutils/PacketBuilderUtils.kt
new file mode 100644
index 0000000000..1c7c50e118
--- /dev/null
+++ b/staticlibs/testutils/devicetests/com/android/testutils/PacketBuilderUtils.kt
@@ -0,0 +1,805 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+// Ktlint forces a blank line between declarations with comments which wastes space in enum
+// declarations.
+@file:Suppress("ktlint:standard:spacing-between-declarations-with-comments")
+
+package com.android.testutils
+
+import android.net.IpPrefix
+import android.net.MacAddress
+import com.android.internal.util.HexDump
+import com.android.net.module.util.IpUtils
+import java.io.ByteArrayOutputStream
+import java.net.Inet4Address
+import java.net.Inet6Address
+import java.net.InetAddress
+import java.nio.ByteBuffer
+import java.util.EnumSet
+import kotlin.random.Random
+
+class PacketBuilder(outerPacket: Packet, innerPacket: Packet) {
+    private data class PacketHolder(
+            /** Points to the last encapsulating packet that includes a pseudo header (IPv4 or IPv6)
+             * for the purpose of checksum calculation. May be null if no such packet exists. */
+            val pseudoHeaderPacket: PseudoHeaderPacket?,
+            val packet: Packet,
+    )
+    private var lastPseudoHeaderPacket: PseudoHeaderPacket? = null
+    /** Collects packets in order, where the outermost packet is at index 0. */
+    private val packetCollector = ArrayList<PacketHolder>()
+
+    private fun addPacket(p: Packet) {
+        if (p is PseudoHeaderPacket) {
+            lastPseudoHeaderPacket = p
+        }
+        packetCollector.add(PacketHolder(lastPseudoHeaderPacket, p))
+    }
+
+    init {
+        addPacket(outerPacket)
+        addPacket(innerPacket)
+    }
+
+    operator fun div(p: Packet): PacketBuilder {
+        addPacket(p)
+        return this
+    }
+
+    fun build(): ByteArray {
+        var payload: FinalizedPacket? = null
+        for (holder in packetCollector.reversed()) {
+            payload = holder.packet.build(payload, holder.pseudoHeaderPacket)
+        }
+
+        // payload is guaranteed non-null as PacketBuilder is created with at least two packets.
+        return payload!!.bytes
+    }
+
+    override fun toString(): String {
+        return HexDump.toHexString(build())
+    }
+}
+
+/** Interface to support PacketBuilder syntax, i.e. {@code val p = ether / ipv6 / icmpv6} */
+interface Packet {
+    operator fun div(p: Packet): PacketBuilder {
+        return PacketBuilder(this, p)
+    }
+    fun build(payload: FinalizedPacket?, pseudo: PseudoHeaderPacket?): FinalizedPacket
+}
+
+interface PseudoHeaderPacket : Packet {
+    /**
+     * Calculates the partial checksum (i.e. pseudo header checksum) to be used as a seed value for
+     * the higher layer checksum calculation.
+     */
+    fun calculatePseudoHeaderCsum(proto: Byte, length: Int): Int
+}
+
+/**
+ * Represents a packet that has been built. Depending on the type of packet, it includes additional
+ * information on top of the ByteArray.
+ */
+interface FinalizedPacket {
+    val bytes: ByteArray
+}
+
+data class L2Packet(override val bytes: ByteArray) : FinalizedPacket
+// Some L3 packets can be carried by an L3 packet (e.g. 6in4), so consider adding proto to L3Packet.
+data class L3Packet(override val bytes: ByteArray, val etherType: Short) : FinalizedPacket
+data class L4Packet(override val bytes: ByteArray, val proto: Byte) : FinalizedPacket
+
+private interface Flags {
+    val value: Int
+}
+
+private fun <E> EnumSet<E>.toByte(): Byte where E : Enum<E>, E : Flags {
+    val result = this.fold(0) { result, next -> result or next.value }
+    return result.toByte()
+}
+
+private inline fun <reified E> enumSetOfFlags(str: String): EnumSet<E>
+        where E : Enum<E>, E : Flags {
+    val result = EnumSet.noneOf(E::class.java)
+    for (char in str) {
+        result.add(enumValueOf<E>(char.uppercase()))
+    }
+    return result
+}
+
+private fun calculatePacketCsum(
+        packetBuffer: ByteBuffer,
+        pseudo: PseudoHeaderPacket,
+        proto: Byte,
+): Short {
+    val csum = pseudo.calculatePseudoHeaderCsum(proto, packetBuffer.limit())
+    return IpUtils.checksum(packetBuffer, csum, 0 /*start*/, packetBuffer.limit()).toShort()
+}
+
+/**
+ * Class that facilitates the creation of NA packets.
+ *
+ * @param target The IPv6 address of the target.
+ * @param flags The Neighbor Advertisement flags.
+ */
+class NaPkt(
+    target: Inet6Address,
+    flags: EnumSet<NaFlags>,
+) : Packet {
+    /**
+     * Convenience constructor accepting parameters as Strings.
+     *
+     * @param target Target IPv6 address as a String; e.g. {@code "2001:db8::1"}.
+     * @param flags Neighbor Advertisement flags as a String; e.g. {@code "RS"}
+     */
+    constructor(target: String, flags: String = "RO") :
+        this(Inet6Address.getByName(target) as Inet6Address, enumSetOfFlags<NaFlags>(flags))
+
+    enum class NaFlags(override val value: Int) : Flags {
+        /** Router flag: indicates that the sender is a router. */
+        R(0x80),
+        /** Solicited flag: indicates the advertisement was sent in response to a solicitation. */
+        S(0x40),
+        /** Override flag: indicates the advertisement should override an existing cache entry. */
+        O(0x20),
+    }
+
+    val outputStream = ByteArrayOutputStream()
+    init {
+        val naHeader = ByteBuffer.allocate(24)
+        naHeader.put(136.toByte()) // Type = 136 (Neighbor Advertisement)
+        naHeader.put(0) // Code = 0
+        naHeader.putShort(0) // Checksum = 0 (ignored)
+        naHeader.put(flags.toByte())
+        naHeader.put(0) // reserved
+        naHeader.putShort(0) // reserved
+        naHeader.put(target.address) // Target address
+        naHeader.flip()
+        outputStream.write(naHeader.array())
+    }
+
+    /** Add Target Link-Layer Address Option */
+    fun addTllaOption(lla: MacAddress): NaPkt {
+        val llao = ByteBuffer.allocate(8)
+        llao.put(2) // Type = 2 (Target Link-layer Address)
+        llao.put(1) // Length in units of 8 octets
+        llao.put(lla.toByteArray())
+        llao.flip()
+        outputStream.write(llao.array())
+        return this
+    }
+
+    /**
+     * Add Target Link-Layer Address Option
+     *
+     * @param lla Link-Layer Address as a String; e.g. {@code "0:0:5e:0:53:0"}
+     */
+    fun addTllaOption(lla: String): NaPkt {
+        return addTllaOption(MacAddress.fromString(lla))
+    }
+
+    override fun build(payload: FinalizedPacket?, pseudo: PseudoHeaderPacket?): FinalizedPacket {
+        require(payload == null)
+        require(pseudo != null)
+
+        val packetBytes = outputStream.toByteArray()
+        val packetBuffer = ByteBuffer.wrap(packetBytes)
+        val proto: Byte = 58
+        val csum = calculatePacketCsum(packetBuffer, pseudo, proto)
+        packetBuffer.position(2)
+        packetBuffer.putShort(csum)
+        return L4Packet(proto = proto, bytes = packetBytes)
+    }
+}
+
+/**
+ * Class that facilitates the creation of RA packets.
+ *
+ * Default argument values reflect the rfc4861 defaults where applicable.
+ *
+ * @param lft lifetime of the default router in seconds.
+ * @param reachableTime The time, in milliseconds, that a node assumes a neighbor is reachable.
+ * @param retransTimer The time, in milliseconds, between retransmitted NS messages.
+ * @param flags The Router Advertisement flags.
+ */
+class RaPkt(
+    private val lft: Short,
+    private val reachableTime: Int,
+    private val retransTimer: Int,
+    private val flags: EnumSet<RaFlags>,
+) : Packet {
+    /**
+     * Convenience constructor accepting flags parameter as String
+     *
+     * @param lft lifetime of the default router in seconds.
+     * @param reachableTime The time, in milliseconds, that a node assumes a neighbor is reachable.
+     * @param retransTimer The time, in milliseconds, between retransmitted NS messages.
+     * @param flags The Router Advertisement flags as a String; e.g. {@code "MO"}. Defaults to "".
+     */
+    constructor(
+        lft: Short = 1800,
+        reachableTime: Int = 0,
+        retransTimer: Int = 0,
+        flags: String = "",
+    ) : this(lft, reachableTime, retransTimer, enumSetOfFlags<RaFlags>(flags))
+
+    enum class RaFlags(override val value: Int) : Flags {
+        /** Managed address configuration: indicates addresses are available via DHCPv6. */
+        M(0x80),
+        /** Other configuration: indicates other configuration info is available via DHCPv6. */
+        O(0x40),
+    }
+
+    val outputStream = ByteArrayOutputStream()
+    init {
+        val raHeader = ByteBuffer.allocate(16)
+        raHeader.put(134.toByte()) // Type = 134 (Router Advertisement)
+        raHeader.put(0) // Code = 0
+        raHeader.putShort(0) // Checksum = 0 (filled in later)
+        raHeader.put(255.toByte()) // Cur Hop Limit
+        raHeader.put(flags.toByte())
+        raHeader.putShort(lft)
+        raHeader.putInt(reachableTime)
+        raHeader.putInt(retransTimer)
+        raHeader.flip()
+        outputStream.write(raHeader.array())
+    }
+
+    enum class PioFlags(override val value: Int) : Flags {
+        /** On-Link: indicates that this prefix can be used for on-link determination. */
+        L(0x80),
+        /** Autonomous address-configuration: indicates that this prefix can be used for SLAAC. */
+        A(0x40),
+        /** Router Address: obsolete. */
+        R(0x20),
+        /** PD Preferred: indicates that the network prefers the use of DHCPv6-PD over SLAAC. */
+        P(0x10),
+    }
+
+    /**
+     * Add a Prefix Information Option
+     *
+     * @param prefix The prefix of an IPv6 address.
+     * @param valid The time, in seconds, that the prefix is valid for on-link determination.
+     * @param preferred The time, in seconds, that SLAAC-generated addresses remain preferred.
+     * @param flags The Prefix Information Option flags.
+     */
+    fun addPioOption(
+            prefix: IpPrefix,
+            valid: Int,
+            preferred: Int,
+            flags: EnumSet<PioFlags>,
+    ): RaPkt {
+        if (!prefix.isIPv6()) throw IllegalArgumentException("Invalid prefix")
+        val pio = ByteBuffer.allocate(32)
+        pio.put(3) // Type = 3
+        pio.put(4) // Length = 4 (*8)
+        pio.put(prefix.prefixLength.toByte()) // Prefix Length
+        pio.put(flags.toByte()) // Flags
+        pio.putInt(valid) // Valid Lifetime
+        pio.putInt(preferred) // Preferred Lifetime
+        pio.putInt(0) // Reserved2
+        pio.put(prefix.rawAddress)
+        pio.flip()
+        outputStream.write(pio.array())
+        return this
+    }
+
+    /**
+     * Add a Prefix Information Option
+     *
+     * @param prefix The IPv6 prefix as a String; e.g. {@code "2001:db8::/64"}
+     * @param valid The time, in seconds, that the prefix is valid for on-link determination.
+     * @param preferred The time, in seconds, that SLAAC-generated addresses remain preferred.
+     * @param flags The PIO flags as a String; e.g. {@code "LA"}
+     */
+    fun addPioOption(
+            prefix: String,
+            valid: Int = 2592000,
+            preferred: Int = 604800,
+            flags: String = "L",
+    ): RaPkt {
+        return addPioOption(IpPrefix(prefix), valid, preferred, enumSetOfFlags<PioFlags>(flags))
+    }
+
+    /** Add a Recursive DNS Server Option
+     *
+     * @param dns The list of DNS servers.
+     * @param lft The time, in seconds, over which the DNS servers may be used for resolution.
+     */
+    fun addRdnssOption(dns: List<Inet6Address>, lft: Int): RaPkt {
+        val length = 1 + (dns.size * 2)
+        val rdnss = ByteBuffer.allocate(length * 8) // length is in units of 8 octets.
+        rdnss.put(25) // Type = 25
+        rdnss.put(length.toByte()) // Length = 1 + number of dns servers * 2 in units of 8 octets.
+        rdnss.putShort(0) // Reserved
+        rdnss.putInt(lft)
+        for (dnsServer in dns) {
+            rdnss.put(dnsServer.address)
+        }
+        rdnss.flip()
+        outputStream.write(rdnss.array())
+        return this
+    }
+
+    /** Add a Recursive DNS Server Option
+     *
+     * @param dns The list of DNS servers as a String; e.g. {@code "2001:db8:1,2001:db8:2"}
+     * @param lft The time, in seconds, over which the DNS servers may be used for resolution.
+     */
+    fun addRdnssOption(dns: String, lft: Int = 1800): RaPkt {
+        val dnsServers = dns.split(",").map { InetAddress.getByName(it) as Inet6Address }
+        return addRdnssOption(dnsServers, lft)
+    }
+
+    /** Add a Route Information Option
+     *
+     * @param prefix The IPv6 prefix of the route.
+     * @param lft The lifetime of the route in seconds.
+     */
+    fun addRioOption(prefix: IpPrefix, lft: Int): RaPkt {
+        val rio = ByteBuffer.allocate(24)
+        rio.put(24) // Type = 24
+        rio.put(3) // Length = 3 -- TODO: support variable prefix length
+        rio.put(prefix.prefixLength.toByte())
+        // TODO: support setting pref
+        rio.put(0) // res (3 bits) | pref (2 bits) | res (3 bits)
+        rio.putInt(lft)
+        rio.put(prefix.rawAddress)
+        rio.flip()
+        outputStream.write(rio.array())
+        return this
+    }
+
+    /** Add a Route Information Option
+     *
+     * @param prefix The IPv6 prefix of the route as a String; e.g. {@code "2001:db8::/48"}
+     * @param lft The lifetime of the route in seconds.
+     */
+    fun addRioOption(prefix: String, lft: Int = 1800): RaPkt {
+        return addRioOption(IpPrefix(prefix), lft)
+    }
+
+    /** Add a PREF64 Option
+     *
+     * @param prefix The PREF64 prefix.
+     * @param lft The lifetime of the PREF64 prefix in seconds.
+     */
+    fun addPref64Option(prefix: IpPrefix, lft: Int): RaPkt {
+        val pref64 = ByteBuffer.allocate(16)
+        pref64.put(38) // Type = 38
+        pref64.put(2) // Length = 2 (*8)
+        val scaledLifetime = lft and 0xfff8
+        val plc = when (prefix.prefixLength) {
+            96 -> 0
+            64 -> 1
+            56 -> 2
+            48 -> 3
+            40 -> 4
+            32 -> 5
+            else -> throw IllegalArgumentException("Invalid pref64 prefix length")
+        }
+        pref64.putShort((scaledLifetime or plc).toShort()) // Scaled lft (13 bits) | plc (3 bits)
+        pref64.put(prefix.rawAddress, 0 /*offset*/, 12 /*length*/) // highest 96 bits of prefix.
+        pref64.flip()
+        outputStream.write(pref64.array())
+        return this
+    }
+
+    /** Add a PREF64 Option
+     *
+     * @param prefix The PREF64 prefix as a String; e.g. {@code "2001:db8::/64"}
+     * @param lft The lifetime of the PREF64 prefix in seconds.
+     */
+    fun addPref64Option(prefix: String, lft: Int = 1800): RaPkt {
+        return addPref64Option(IpPrefix(prefix), lft)
+    }
+
+    /** Add Source Link-Layer Address Option */
+    fun addSllaOption(lla: MacAddress): RaPkt {
+        val llao = ByteBuffer.allocate(8)
+        llao.put(1) // Type = 1 (Source Link-layer Address)
+        llao.put(1) // Length in units of 8 octets
+        llao.put(lla.toByteArray())
+        llao.flip()
+        outputStream.write(llao.array())
+        return this
+    }
+
+    /**
+     * Add Source Link-Layer Address Option
+     *
+     * @param lla Link-Layer Address as a String; e.g. {@code "0:0:5e:0:53:0"}
+     */
+    fun addSllaOption(lla: String): RaPkt {
+        return addSllaOption(MacAddress.fromString(lla))
+    }
+
+    override fun build(payload: FinalizedPacket?, pseudo: PseudoHeaderPacket?): FinalizedPacket {
+        require(payload == null)
+        require(pseudo != null)
+
+        val packetBytes = outputStream.toByteArray()
+        val packetBuffer = ByteBuffer.wrap(packetBytes)
+        val proto: Byte = 58
+        val csum = calculatePacketCsum(packetBuffer, pseudo, proto)
+        packetBuffer.position(2)
+        packetBuffer.putShort(csum)
+        return L4Packet(proto = proto, bytes = packetBytes)
+    }
+}
+
+/** Class that facilitates the creation of generic L5 data packets. */
+class DataPkt(data: ByteArray) : Packet {
+    constructor(data: String) : this(data.toByteArray())
+
+    val outputStream = ByteArrayOutputStream()
+    init {
+        outputStream.write(data)
+    }
+
+    override fun build(payload: FinalizedPacket?, pseudo: PseudoHeaderPacket?): FinalizedPacket {
+        if (payload != null) {
+            outputStream.write(payload.bytes)
+        }
+        return object : FinalizedPacket { override val bytes = outputStream.toByteArray() }
+    }
+}
+
+class Dhcp6IaPdOpt(
+    private val iaid: Int,
+    private val t1: Int = 0,
+    private val t2: Int = 0,
+) : Packet {
+
+    private val outputStream = ByteArrayOutputStream()
+    init {
+        val bb = ByteBuffer.allocate(16)
+                .putShort(25) // OPTION_IA_PD
+                .putShort(0) // Length filled in later
+                .putInt(iaid)
+                .putInt(t1)
+                .putInt(t2)
+        bb.flip()
+        outputStream.write(bb.array())
+    }
+
+    fun addIaPrefixOption(prefix: IpPrefix, preferred: Int, valid: Int): Dhcp6IaPdOpt {
+        val bb = ByteBuffer.allocate(29)
+                .putShort(26) // OPTION_IAPREFIX
+                .putShort(25) // Length without IAprefix-options
+                .putInt(preferred)
+                .putInt(valid)
+                .put(prefix.prefixLength.toByte())
+                .put(prefix.rawAddress)
+        bb.flip()
+        outputStream.write(bb.array())
+        return this
+    }
+
+    fun addIaPrefixOption(prefix: String, preferred: Int = 900, valid: Int = 1800): Dhcp6IaPdOpt {
+        return addIaPrefixOption(IpPrefix(prefix), preferred, valid)
+    }
+
+    override fun build(payload: FinalizedPacket?, pseudo: PseudoHeaderPacket?): FinalizedPacket {
+        // Fix up the length *before* appending payload.
+        val bytes = outputStream.toByteArray()
+        val bb = ByteBuffer.wrap(bytes)
+        bb.position(2)
+        // Note that option-len does not include the type (2 bytes) and len (2 bytes) fields
+        bb.putShort((bytes.size - 4).toShort())
+
+        val tempStream = ByteArrayOutputStream()
+        tempStream.write(bytes)
+        if (payload != null) tempStream.write(payload.bytes)
+
+        return object : FinalizedPacket {
+            override val bytes = tempStream.toByteArray()
+        }
+    }
+}
+
+/** Class that facilitates the creation of DHCPv6 packets. */
+class Dhcp6Pkt(
+        private val type: Type,
+        private val transId: Int,
+) : Packet {
+    enum class Type(val value: Byte) {
+        SOLICIT(1),
+        ADVERTISE(2),
+        REQUEST(3),
+        CONFIRM(4),
+        RENEW(5),
+        REBIND(6),
+        REPLY(7),
+        RELEASE(8),
+        DECLINE(9),
+        RECONFIGURE(10),
+        INFORMATION_REQUEST(11), // INFORMATION-REQUEST
+        RELAY_FORW(12),          // RELAY-FORW
+        RELAY_REPL(13);          // RELAY-REPL
+
+        companion object {
+            fun fromString(str: String) = valueOf(str.replace('-', '_'))
+        }
+    }
+
+    constructor(type: String, transId: Int) : this(Type.fromString(type), transId)
+
+    private val outputStream = ByteArrayOutputStream()
+    init {
+        require(transId <= 0xffffff)
+        val dhcp6Header = ByteBuffer.allocate(4)
+            .putInt((type.value.toInt() shl 24) or transId)
+        dhcp6Header.flip()
+        outputStream.write(dhcp6Header.array())
+    }
+
+    fun addClientIdentifierOption(duid: ByteArray): Dhcp6Pkt {
+        require(duid.size <= 0xffff)
+        val bb = ByteBuffer.allocate(4 + duid.size)
+                .putShort(1) // OPTION_CLIENTID
+                .putShort(duid.size.toShort())
+                .put(duid)
+        bb.flip()
+        outputStream.write(bb.array())
+        return this
+    }
+
+    fun addServerIdentifierOption(duid: ByteArray): Dhcp6Pkt {
+        require(duid.size <= 0xffff)
+        val bb = ByteBuffer.allocate(4 + duid.size)
+                .putShort(2) // OPTION_SERVERID
+                .putShort(duid.size.toShort())
+                .put(duid)
+        bb.flip()
+        outputStream.write(bb.array())
+        return this
+    }
+
+    fun addSolMaxRtOption(solMaxRt: Int): Dhcp6Pkt {
+        val bb = ByteBuffer.allocate(8)
+                .putShort(82) // OPTION_SOL_MAX_RT
+                .putShort(4)
+                .putInt(solMaxRt)
+        bb.flip()
+        outputStream.write(bb.array())
+        return this
+    }
+
+    fun addRapidCommitOption(): Dhcp6Pkt {
+        val bb = ByteBuffer.allocate(4)
+                .putShort(14) // OPTION_RAPID_COMMIT
+                .putShort(0)
+        bb.flip()
+        outputStream.write(bb.array())
+        return this
+    }
+
+    override fun build(payload: FinalizedPacket?, pseudo: PseudoHeaderPacket?): FinalizedPacket {
+        if (payload != null) outputStream.write(payload.bytes)
+        return object : FinalizedPacket {
+            override val bytes = outputStream.toByteArray()
+        }
+    }
+}
+
+/**
+ * Class that facilitates the creation of UDP packets.
+ *
+ * Use the {@link DataPkt} for carrying a payload.
+ */
+class UdpPkt(
+        private val sport: Short,
+        private val dport: Short,
+) : Packet {
+    constructor(sport: Int = Random.nextInt(1, 65536), dport: Int = Random.nextInt(1, 65536)) :
+        this(sport.toShort(), dport.toShort())
+
+    override fun build(payload: FinalizedPacket?, pseudo: PseudoHeaderPacket?): FinalizedPacket {
+        require(pseudo != null)
+
+        val udpHeader = ByteBuffer.allocate(8)
+            .putShort(sport)
+            .putShort(dport)
+            .putShort(0) // length; to be filled in later.
+            .putShort(0) // checksum; to be filled in later.
+        udpHeader.flip()
+        val outputStream = ByteArrayOutputStream()
+        outputStream.write(udpHeader.array())
+        if (payload != null) {
+            outputStream.write(payload.bytes)
+        }
+        val packetBytes = outputStream.toByteArray()
+        val packetBuffer = ByteBuffer.wrap(packetBytes)
+
+        // Insert length into UDP header
+        packetBuffer.position(4)
+        packetBuffer.putShort(packetBytes.size.toShort())
+
+        // Insert checksum into UDP header
+        val proto: Byte = 17
+        val csum = calculatePacketCsum(packetBuffer, pseudo, proto)
+        packetBuffer.position(6)
+        packetBuffer.putShort(csum)
+        return L4Packet(proto = proto, bytes = packetBytes)
+    }
+}
+
+/** Class that facilitates the creation of IPv6 packets. */
+class Ip6Pkt(
+        private val src: Inet6Address,
+        private val dst: Inet6Address,
+        private val hlim: Byte = 255.toByte(),
+) : PseudoHeaderPacket {
+    constructor(src: String, dst: String, hlim: Int = 255) : this(
+            InetAddress.getByName(src) as Inet6Address,
+            InetAddress.getByName(dst) as Inet6Address,
+            hlim.toByte(),
+    )
+
+    private val tc = 0
+    private val flowlabel = 0
+
+    override fun build(payload: FinalizedPacket?, pseudo: PseudoHeaderPacket?): FinalizedPacket {
+        require(payload != null)
+        require(payload is L4Packet)
+
+        val ipv6Header = ByteBuffer.allocate(40)
+        ipv6Header.putInt((6 shl 28) or (tc shl 20) or flowlabel)
+        ipv6Header.putShort(payload.bytes.size.toShort())
+        ipv6Header.put(payload.proto)
+        ipv6Header.put(hlim)
+        ipv6Header.put(src.address)
+        ipv6Header.put(dst.address)
+        ipv6Header.flip()
+
+        val outputStream = ByteArrayOutputStream()
+        outputStream.write(ipv6Header.array())
+        outputStream.write(payload.bytes)
+        return L3Packet(etherType = 0x86dd.toShort(), bytes = outputStream.toByteArray())
+    }
+
+    override fun calculatePseudoHeaderCsum(proto: Byte, length: Int): Int {
+        // Calculates the checksum over the src and dst IPv6 addresses.
+        // TODO: assemble IPv6 header in constructor and let build() update payload length and
+        // proto instead.
+        val buffer = ByteBuffer.allocate((2 * 16) + 4 + 2)
+        buffer.put(src.address)
+        buffer.put(dst.address)
+        buffer.putInt(length)
+        buffer.putShort(proto.toShort())
+        buffer.flip()
+        // Note that IpUtils.checksum() flips the result, so it is flipped back here.
+        return IpUtils.checksum(buffer, 0 /*seed*/, 0 /*start*/, buffer.limit()) xor 0xffff
+    }
+}
+
+/**
+ * Class that facilitates the creation of IPv4 packets.
+ *
+ * Options are not currently supported.
+ */
+class Ip4Pkt(
+        private val src: Inet4Address,
+        private val dst: Inet4Address,
+) : PseudoHeaderPacket {
+    constructor(src: String, dst: String) : this(
+            InetAddress.getByName(src) as Inet4Address,
+            InetAddress.getByName(dst) as Inet4Address,
+    )
+
+    private val tos: Byte = 0
+    private val identification: Short = 0
+    private val flags = 0
+    private val fragoff = 0
+    private val ttl = 255.toByte()
+
+    override fun build(payload: FinalizedPacket?, pseudo: PseudoHeaderPacket?): FinalizedPacket {
+        require(payload != null)
+        require(payload is L4Packet)
+
+        //  0                   1                   2                   3
+        //  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+        // +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+        // |Version|  IHL  |Type of Service|          Total Length         |
+        // +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+        // |         Identification        |Flags|      Fragment Offset    |
+        // +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+        // |  Time to Live |    Protocol   |         Header Checksum       |
+        // +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+        // |                       Source Address                          |
+        // +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+        // |                    Destination Address                        |
+        // +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+        // |                    Options                    |    Padding    |
+        // +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+        val ipv4Header = ByteBuffer.allocate(20)
+                .put(((4 /*version*/ shl 4) or 5 /*IHL*/).toByte())
+                .put(tos)
+                .putShort((20 + payload.bytes.size).toShort())
+                .putShort(identification)
+                .putShort(((flags shl 13) or fragoff).toShort())
+                .put(ttl)
+                .put(payload.proto)
+                .putShort(0 /*csum; to be filled in later*/)
+                .put(src.address)
+                .put(dst.address)
+        ipv4Header.flip()
+
+        val csum = IpUtils.checksum(ipv4Header, 0 /*seed*/, 0 /*start*/, ipv4Header.limit())
+        ipv4Header.position(10)
+        ipv4Header.putShort(csum.toShort())
+
+        val outputStream = ByteArrayOutputStream()
+        outputStream.write(ipv4Header.array())
+        outputStream.write(payload.bytes)
+        return L3Packet(etherType = 0x0800.toShort(), bytes = outputStream.toByteArray())
+    }
+
+    override fun calculatePseudoHeaderCsum(proto: Byte, length: Int): Int {
+        val buffer = ByteBuffer.allocate(12)
+                .put(src.address)
+                .put(dst.address)
+                .put(0)
+                .put(proto)
+                .putShort(length.toShort())
+        buffer.flip()
+        // Note that IpUtils.checksum() flips the result, so it is flipped back here.
+        return IpUtils.checksum(buffer, 0 /*seed*/, 0 /*start*/, buffer.limit()) xor 0xffff
+    }
+}
+
+/**
+ * Class that facilitates the creation of ethernet packets.
+ *
+ * Example code:
+ *
+ * <pre>
+ * {@code
+ * val ether = EtherPkt(src = "1:2:3:4:5:6", dst = "1:1:1:1:1:1")
+ * val ipv6 = Ip6Pkt(src = "fe80::1", dst = "fe80::2")
+ * val ra = RaPkt(lft = 50, reachableTime = 100, flags = "O")
+ *         .addPioOption(prefix = "2001:db8::1/64", flags = "LA")
+ * val p = ether / ipv6 / ra
+ * val bytes = p.build()
+ * }
+ * </pre>
+ **/
+class EtherPkt(
+        private val dst: MacAddress,
+        private val src: MacAddress,
+    ) : Packet {
+    constructor(dst: String, src: String) :
+        this(MacAddress.fromString(dst), MacAddress.fromString(src))
+
+    override fun build(payload: FinalizedPacket?, pseudo: PseudoHeaderPacket?): FinalizedPacket {
+        require(payload != null)
+        require(payload is L3Packet)
+
+        val ethernetHeader = ByteBuffer.allocate(14)
+        ethernetHeader.put(dst.toByteArray())
+        ethernetHeader.put(src.toByteArray())
+        ethernetHeader.putShort(payload.etherType)
+        ethernetHeader.flip()
+
+        val outputStream = ByteArrayOutputStream()
+        outputStream.write(ethernetHeader.array())
+        outputStream.write(payload.bytes)
+        return L2Packet(bytes = outputStream.toByteArray())
+    }
+}
diff --git a/staticlibs/testutils/devicetests/com/android/testutils/PollPacketReader.java b/staticlibs/testutils/devicetests/com/android/testutils/PollPacketReader.java
index dbc7eb0c00..b90696659c 100644
--- a/staticlibs/testutils/devicetests/com/android/testutils/PollPacketReader.java
+++ b/staticlibs/testutils/devicetests/com/android/testutils/PollPacketReader.java
@@ -29,6 +29,7 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.Arrays;
+import java.util.List;
 import java.util.function.Predicate;
 
 import kotlin.Lazy;
@@ -110,6 +111,13 @@ public class PollPacketReader extends PacketReader {
         return mReadHead.getValue().poll(timeoutMs, filter::test);
     }
 
+    /**
+     * Get all packets received since before the start of the last poll operation.
+     */
+    public List<byte[]> backtrace() {
+        return mReadHead.getValue().backtrace();
+    }
+
     /**
      * Get the {@link ArrayTrackRecord} that records all packets received by the reader since its
      * creation.
diff --git a/staticlibs/testutils/devicetests/com/android/testutils/RouterAdvertisementResponder.java b/staticlibs/testutils/devicetests/com/android/testutils/RouterAdvertisementResponder.java
deleted file mode 100644
index 6709555f3a..0000000000
--- a/staticlibs/testutils/devicetests/com/android/testutils/RouterAdvertisementResponder.java
+++ /dev/null
@@ -1,208 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.testutils;
-
-import static android.system.OsConstants.IPPROTO_ICMPV6;
-
-import static com.android.net.module.util.NetworkStackConstants.ETHER_TYPE_IPV6;
-import static com.android.net.module.util.NetworkStackConstants.ICMPV6_ND_OPTION_SLLA;
-import static com.android.net.module.util.NetworkStackConstants.ICMPV6_ND_OPTION_TLLA;
-import static com.android.net.module.util.NetworkStackConstants.ICMPV6_NEIGHBOR_SOLICITATION;
-import static com.android.net.module.util.NetworkStackConstants.ICMPV6_ROUTER_SOLICITATION;
-import static com.android.net.module.util.NetworkStackConstants.IPV6_ADDR_ALL_NODES_MULTICAST;
-import static com.android.net.module.util.NetworkStackConstants.NEIGHBOR_ADVERTISEMENT_FLAG_OVERRIDE;
-import static com.android.net.module.util.NetworkStackConstants.NEIGHBOR_ADVERTISEMENT_FLAG_ROUTER;
-import static com.android.net.module.util.NetworkStackConstants.NEIGHBOR_ADVERTISEMENT_FLAG_SOLICITED;
-import static com.android.net.module.util.NetworkStackConstants.PIO_FLAG_AUTONOMOUS;
-import static com.android.net.module.util.NetworkStackConstants.PIO_FLAG_ON_LINK;
-
-import android.net.InetAddresses;
-import android.net.IpPrefix;
-import android.net.MacAddress;
-import android.util.ArrayMap;
-import android.util.Log;
-import android.util.Pair;
-
-import com.android.net.module.util.Ipv6Utils;
-import com.android.net.module.util.Struct;
-import com.android.net.module.util.structs.EthernetHeader;
-import com.android.net.module.util.structs.Icmpv6Header;
-import com.android.net.module.util.structs.Ipv6Header;
-import com.android.net.module.util.structs.LlaOption;
-import com.android.net.module.util.structs.NsHeader;
-import com.android.net.module.util.structs.PrefixInformationOption;
-import com.android.net.module.util.structs.RdnssOption;
-
-import java.io.IOException;
-import java.net.Inet6Address;
-import java.nio.ByteBuffer;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Random;
-
-/**
- * ND (RA & NA) responder class useful for tests that require a provisioned IPv6 interface.
- * TODO: rename to NdResponder
- */
-public class RouterAdvertisementResponder extends PacketResponder {
-    private static final String TAG = "RouterAdvertisementResponder";
-    private static final Inet6Address DNS_SERVER =
-            (Inet6Address) InetAddresses.parseNumericAddress("2001:4860:4860::64");
-    private final PollPacketReader mPacketReader;
-    // Maps IPv6 address to MacAddress and isRouter boolean.
-    private final Map<Inet6Address, Pair<MacAddress, Boolean>> mNeighborMap = new ArrayMap<>();
-    private final IpPrefix mPrefix;
-
-    public RouterAdvertisementResponder(PollPacketReader packetReader, IpPrefix prefix) {
-        super(packetReader, RouterAdvertisementResponder::isRsOrNs, TAG);
-        mPacketReader = packetReader;
-        mPrefix = Objects.requireNonNull(prefix);
-    }
-
-    public RouterAdvertisementResponder(PollPacketReader packetReader) {
-        this(packetReader, makeRandomPrefix());
-    }
-
-    private static IpPrefix makeRandomPrefix() {
-        final byte[] prefixBytes = new IpPrefix("2001:db8::/64").getAddress().getAddress();
-        final Random r = new Random();
-        for (int i = 4; i < 8; i++) {
-            prefixBytes[i] = (byte) r.nextInt();
-        }
-        return new IpPrefix(prefixBytes, 64);
-    }
-
-    /** Returns true if the packet is a router solicitation or neighbor solicitation message. */
-    private static boolean isRsOrNs(byte[] packet) {
-        final ByteBuffer buffer = ByteBuffer.wrap(packet);
-        final EthernetHeader ethHeader = Struct.parse(EthernetHeader.class, buffer);
-        if (ethHeader.etherType != ETHER_TYPE_IPV6) {
-            return false;
-        }
-        final Ipv6Header ipv6Header = Struct.parse(Ipv6Header.class, buffer);
-        if (ipv6Header.nextHeader != IPPROTO_ICMPV6) {
-            return false;
-        }
-        final Icmpv6Header icmpv6Header = Struct.parse(Icmpv6Header.class, buffer);
-        return icmpv6Header.type == ICMPV6_ROUTER_SOLICITATION
-            || icmpv6Header.type == ICMPV6_NEIGHBOR_SOLICITATION;
-    }
-
-    /**
-     * Adds a new router to be advertised.
-     * @param mac the mac address of the router.
-     * @param ip the link-local address of the router.
-     */
-    public void addRouterEntry(MacAddress mac, Inet6Address ip) {
-        mNeighborMap.put(ip, new Pair<>(mac, true));
-    }
-
-    /**
-     * Adds a new neighbor to be advertised.
-     * @param mac the mac address of the neighbor.
-     * @param ip the link-local address of the neighbor.
-     */
-    public void addNeighborEntry(MacAddress mac, Inet6Address ip) {
-        mNeighborMap.put(ip, new Pair<>(mac, false));
-    }
-
-    /**
-     * @return the prefix that is announced in the Router Advertisements sent by this object.
-     */
-    public IpPrefix getPrefix() {
-        return mPrefix;
-    }
-
-    private ByteBuffer buildPrefixOption() {
-        return PrefixInformationOption.build(
-                mPrefix, (byte) (PIO_FLAG_ON_LINK | PIO_FLAG_AUTONOMOUS),
-                3600 /* valid lifetime */, 3600 /* preferred lifetime */);
-    }
-
-    private ByteBuffer buildRdnssOption() {
-        return RdnssOption.build(3600/*lifetime, must be at least 120*/, DNS_SERVER);
-    }
-
-    private ByteBuffer buildSllaOption(MacAddress srcMac) {
-        return LlaOption.build((byte) ICMPV6_ND_OPTION_SLLA, srcMac);
-    }
-
-    private ByteBuffer buildRaPacket(MacAddress srcMac, MacAddress dstMac, Inet6Address srcIp) {
-        return Ipv6Utils.buildRaPacket(srcMac, dstMac, srcIp, IPV6_ADDR_ALL_NODES_MULTICAST,
-                (byte) 0 /*M=0, O=0*/, 3600 /*lifetime*/, 0 /*reachableTime, unspecified*/,
-                0/*retransTimer, unspecified*/, buildPrefixOption(), buildRdnssOption(),
-                buildSllaOption(srcMac));
-    }
-
-    private static void sendResponse(PollPacketReader reader, ByteBuffer buffer) {
-        try {
-            reader.sendResponse(buffer);
-        } catch (IOException e) {
-            // Throwing an exception here will crash the test process. Let's stick to logging, as
-            // the test will fail either way.
-            Log.e(TAG, "Failed to send buffer", e);
-        }
-    }
-
-    private void replyToRouterSolicitation(PollPacketReader reader, MacAddress dstMac) {
-        for (Map.Entry<Inet6Address, Pair<MacAddress, Boolean>> it : mNeighborMap.entrySet()) {
-            final boolean isRouter = it.getValue().second;
-            if (!isRouter) {
-                continue;
-            }
-            final ByteBuffer raResponse = buildRaPacket(it.getValue().first, dstMac, it.getKey());
-            sendResponse(reader, raResponse);
-        }
-    }
-
-    private void replyToNeighborSolicitation(PollPacketReader reader, MacAddress dstMac,
-            Inet6Address dstIp, Inet6Address targetIp) {
-        final Pair<MacAddress, Boolean> neighbor = mNeighborMap.get(targetIp);
-        if (neighbor == null) {
-            return;
-        }
-
-        final MacAddress srcMac = neighbor.first;
-        final boolean isRouter = neighbor.second;
-        int flags = NEIGHBOR_ADVERTISEMENT_FLAG_SOLICITED | NEIGHBOR_ADVERTISEMENT_FLAG_OVERRIDE;
-        if (isRouter) {
-            flags |= NEIGHBOR_ADVERTISEMENT_FLAG_ROUTER;
-        }
-
-        final ByteBuffer tlla = LlaOption.build((byte) ICMPV6_ND_OPTION_TLLA, srcMac);
-        final ByteBuffer naResponse = Ipv6Utils.buildNaPacket(srcMac, dstMac, targetIp, dstIp,
-                flags, targetIp, tlla);
-        sendResponse(reader, naResponse);
-    }
-
-    @Override
-    protected void replyToPacket(byte[] packet, PollPacketReader reader) {
-        final ByteBuffer buf = ByteBuffer.wrap(packet);
-        // Messages are filtered by parent class, so it is safe to assume that packet is either an
-        // RS or NS.
-        final EthernetHeader ethHdr = Struct.parse(EthernetHeader.class, buf);
-        final Ipv6Header ipv6Hdr = Struct.parse(Ipv6Header.class, buf);
-        final Icmpv6Header icmpv6Header = Struct.parse(Icmpv6Header.class, buf);
-
-        if (icmpv6Header.type == ICMPV6_ROUTER_SOLICITATION) {
-            replyToRouterSolicitation(reader, ethHdr.srcMac);
-        } else if (icmpv6Header.type == ICMPV6_NEIGHBOR_SOLICITATION) {
-            final NsHeader nsHeader = Struct.parse(NsHeader.class, buf);
-            replyToNeighborSolicitation(reader, ethHdr.srcMac, ipv6Hdr.srcIp, nsHeader.target);
-        }
-    }
-}
diff --git a/staticlibs/testutils/devicetests/com/android/testutils/TestableNetworkAgent.kt b/staticlibs/testutils/devicetests/com/android/testutils/TestableNetworkAgent.kt
index 1a82c5b346..3d00e86b2e 100644
--- a/staticlibs/testutils/devicetests/com/android/testutils/TestableNetworkAgent.kt
+++ b/staticlibs/testutils/devicetests/com/android/testutils/TestableNetworkAgent.kt
@@ -45,21 +45,21 @@ import android.system.OsConstants.SOCK_DGRAM
 import com.android.modules.utils.build.SdkLevel.isAtLeastS
 import com.android.net.module.util.ArrayTrackRecord
 import com.android.testutils.CompatUtil.makeTestNetworkSpecifier
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnAddKeepalivePacketFilter
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnAutomaticReconnectDisabled
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnBandwidthUpdateRequested
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnDscpPolicyStatusUpdated
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnNetworkCreated
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnNetworkDestroyed
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnNetworkUnwanted
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnRegisterQosCallback
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnRemoveKeepalivePacketFilter
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnSaveAcceptUnvalidated
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnSignalStrengthThresholdsUpdated
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnStartSocketKeepalive
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnStopSocketKeepalive
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnUnregisterQosCallback
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnValidationStatus
+import com.android.testutils.TestableNetworkAgent.Event.OnAddKeepalivePacketFilter
+import com.android.testutils.TestableNetworkAgent.Event.OnAutomaticReconnectDisabled
+import com.android.testutils.TestableNetworkAgent.Event.OnBandwidthUpdateRequested
+import com.android.testutils.TestableNetworkAgent.Event.OnDscpPolicyStatusUpdated
+import com.android.testutils.TestableNetworkAgent.Event.OnNetworkCreated
+import com.android.testutils.TestableNetworkAgent.Event.OnNetworkDestroyed
+import com.android.testutils.TestableNetworkAgent.Event.OnNetworkUnwanted
+import com.android.testutils.TestableNetworkAgent.Event.OnRegisterQosCallback
+import com.android.testutils.TestableNetworkAgent.Event.OnRemoveKeepalivePacketFilter
+import com.android.testutils.TestableNetworkAgent.Event.OnSaveAcceptUnvalidated
+import com.android.testutils.TestableNetworkAgent.Event.OnSignalStrengthThresholdsUpdated
+import com.android.testutils.TestableNetworkAgent.Event.OnStartSocketKeepalive
+import com.android.testutils.TestableNetworkAgent.Event.OnStopSocketKeepalive
+import com.android.testutils.TestableNetworkAgent.Event.OnUnregisterQosCallback
+import com.android.testutils.TestableNetworkAgent.Event.OnValidationStatus
 import java.net.NetworkInterface
 import java.net.SocketException
 import java.time.Duration
@@ -193,34 +193,34 @@ public open class TestableNetworkAgent(
 
     val DEFAULT_TIMEOUT_MS = 5000L
 
-    val history = ArrayTrackRecord<CallbackEntry>().newReadHead()
+    val history = ArrayTrackRecord<Event>().newReadHead()
 
-    sealed class CallbackEntry {
-        object OnBandwidthUpdateRequested : CallbackEntry()
-        object OnNetworkUnwanted : CallbackEntry()
+    sealed class Event {
+        object OnBandwidthUpdateRequested : Event()
+        object OnNetworkUnwanted : Event()
         data class OnAddKeepalivePacketFilter(
             val slot: Int,
             val packet: KeepalivePacketData
-        ) : CallbackEntry()
-        data class OnRemoveKeepalivePacketFilter(val slot: Int) : CallbackEntry()
+        ) : Event()
+        data class OnRemoveKeepalivePacketFilter(val slot: Int) : Event()
         data class OnStartSocketKeepalive(
             val slot: Int,
             val interval: Int,
             val packet: KeepalivePacketData
-        ) : CallbackEntry()
-        data class OnStopSocketKeepalive(val slot: Int) : CallbackEntry()
-        data class OnSaveAcceptUnvalidated(val accept: Boolean) : CallbackEntry()
-        object OnAutomaticReconnectDisabled : CallbackEntry()
-        data class OnValidationStatus(val status: Int, val uri: Uri?) : CallbackEntry()
-        data class OnSignalStrengthThresholdsUpdated(val thresholds: IntArray) : CallbackEntry()
-        object OnNetworkCreated : CallbackEntry()
-        object OnNetworkDestroyed : CallbackEntry()
-        data class OnDscpPolicyStatusUpdated(val policyId: Int, val status: Int) : CallbackEntry()
+        ) : Event()
+        data class OnStopSocketKeepalive(val slot: Int) : Event()
+        data class OnSaveAcceptUnvalidated(val accept: Boolean) : Event()
+        object OnAutomaticReconnectDisabled : Event()
+        data class OnValidationStatus(val status: Int, val uri: Uri?) : Event()
+        data class OnSignalStrengthThresholdsUpdated(val thresholds: IntArray) : Event()
+        object OnNetworkCreated : Event()
+        object OnNetworkDestroyed : Event()
+        data class OnDscpPolicyStatusUpdated(val policyId: Int, val status: Int) : Event()
         data class OnRegisterQosCallback(
             val callbackId: Int,
             val filter: QosFilter
-        ) : CallbackEntry()
-        data class OnUnregisterQosCallback(val callbackId: Int) : CallbackEntry()
+        ) : Event()
+        data class OnUnregisterQosCallback(val callbackId: Int) : Event()
     }
 
     override fun onBandwidthUpdateRequested() {
@@ -306,19 +306,19 @@ public open class TestableNetworkAgent(
         assertEquals("", it.uri.toString())
     }
 
-    inline fun <reified T : CallbackEntry> expectCallback(): T {
+    inline fun <reified T : Event> expectCallback(): T {
         val foundCallback = history.poll(DEFAULT_TIMEOUT_MS)
         assertTrue(foundCallback is T, "Expected ${T::class} but found $foundCallback")
         return foundCallback
     }
 
-    inline fun <reified T : CallbackEntry> expectCallback(valid: (T) -> Boolean) {
+    inline fun <reified T : Event> expectCallback(valid: (T) -> Boolean) {
         val foundCallback = history.poll(DEFAULT_TIMEOUT_MS)
         assertTrue(foundCallback is T, "Expected ${T::class} but found $foundCallback")
         assertTrue(valid(foundCallback), "Unexpected callback : $foundCallback")
     }
 
-    inline fun <reified T : CallbackEntry> eventuallyExpect() =
+    inline fun <reified T : Event> eventuallyExpect() =
             history.poll(DEFAULT_TIMEOUT_MS) { it is T }.also {
                 assertNotNull(it, "Callback ${T::class} not received")
     } as T
diff --git a/staticlibs/testutils/devicetests/com/android/testutils/TestableNetworkCallback.kt b/staticlibs/testutils/devicetests/com/android/testutils/TestableNetworkCallback.kt
index d9c51e5201..ccf72c8a7d 100644
--- a/staticlibs/testutils/devicetests/com/android/testutils/TestableNetworkCallback.kt
+++ b/staticlibs/testutils/devicetests/com/android/testutils/TestableNetworkCallback.kt
@@ -24,18 +24,18 @@ import android.net.NetworkCapabilities
 import android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED
 import android.util.Log
 import com.android.net.module.util.ArrayTrackRecord
-import com.android.testutils.RecorderCallback.CallbackEntry.Available
-import com.android.testutils.RecorderCallback.CallbackEntry.BlockedStatus
-import com.android.testutils.RecorderCallback.CallbackEntry.BlockedStatusInt
-import com.android.testutils.RecorderCallback.CallbackEntry.CapabilitiesChanged
-import com.android.testutils.RecorderCallback.CallbackEntry.LinkPropertiesChanged
-import com.android.testutils.RecorderCallback.CallbackEntry.LocalInfoChanged
-import com.android.testutils.RecorderCallback.CallbackEntry.Losing
-import com.android.testutils.RecorderCallback.CallbackEntry.Lost
-import com.android.testutils.RecorderCallback.CallbackEntry.Reserved
-import com.android.testutils.RecorderCallback.CallbackEntry.Resumed
-import com.android.testutils.RecorderCallback.CallbackEntry.Suspended
-import com.android.testutils.RecorderCallback.CallbackEntry.Unavailable
+import com.android.testutils.TestableNetworkCallback.Event.Available
+import com.android.testutils.TestableNetworkCallback.Event.BlockedStatus
+import com.android.testutils.TestableNetworkCallback.Event.BlockedStatusInt
+import com.android.testutils.TestableNetworkCallback.Event.CapabilitiesChanged
+import com.android.testutils.TestableNetworkCallback.Event.LinkPropertiesChanged
+import com.android.testutils.TestableNetworkCallback.Event.LocalInfoChanged
+import com.android.testutils.TestableNetworkCallback.Event.Losing
+import com.android.testutils.TestableNetworkCallback.Event.Lost
+import com.android.testutils.TestableNetworkCallback.Event.Reserved
+import com.android.testutils.TestableNetworkCallback.Event.Resumed
+import com.android.testutils.TestableNetworkCallback.Event.Suspended
+import com.android.testutils.TestableNetworkCallback.Event.Unavailable
 import kotlin.reflect.KClass
 import kotlin.test.assertEquals
 import kotlin.test.assertNotNull
@@ -45,64 +45,73 @@ object NULL_NETWORK : Network(-1)
 object ANY_NETWORK : Network(-2)
 fun anyNetwork() = ANY_NETWORK
 
-private val DEFAULT_TAG = RecorderCallback::class.simpleName
+private val DEFAULT_TAG = TestableNetworkCallback::class.simpleName
     ?: fail("Could not determine class name")
 
-open class RecorderCallback private constructor(
-    private val backingRecord: ArrayTrackRecord<CallbackEntry>,
-    val logTag: String
+private const val DEFAULT_TIMEOUT = 30_000L // ms
+private const val DEFAULT_NO_CALLBACK_TIMEOUT = 200L // ms
+private val NOOP = Runnable {}
+
+/**
+ * See comments on the public constructor below for a description of the arguments.
+ */
+open class TestableNetworkCallback private constructor(
+    src: TestableNetworkCallback?,
+    val defaultTimeoutMs: Long,
+    private val defaultNoCallbackTimeoutMs: Long,
+    private val waiterFunc: Runnable,
+    private val logTag: String
 ) : NetworkCallback() {
-    public constructor(logTag: String = DEFAULT_TAG) : this(ArrayTrackRecord(), logTag)
-    protected constructor(src: RecorderCallback?, logTag: String) : this(
-        src?.backingRecord ?: ArrayTrackRecord(),
-        logTag
-    )
+    private val backingRecord: ArrayTrackRecord<Event> =
+        src?.backingRecord ?: ArrayTrackRecord()
+    val history: ArrayTrackRecord<Event>.ReadHead = backingRecord.newReadHead()
+    val mark get() = history.mark
 
-    sealed class CallbackEntry {
+    sealed class Event {
         // To get equals(), hashcode(), componentN() etc for free, the child classes of
         // this class are data classes. But while data classes can inherit from other classes,
         // they may only have visible members in the constructors, so they couldn't declare
-        // a constructor with a non-val arg to pass to CallbackEntry. Instead, force all
+        // a constructor with a non-val arg to pass to Event. Instead, force all
         // subclasses to implement a `network' property, which can be done in a data class
         // constructor by specifying override.
         abstract val network: Network
 
-        data class Reserved private constructor(
-                override val network: Network,
-                val caps: NetworkCapabilities
-        ): CallbackEntry() {
+        data class Reserved(
+            override val network: Network,
+            val caps: NetworkCapabilities
+        ) : Event() {
             constructor(caps: NetworkCapabilities) : this(NULL_NETWORK, caps)
         }
-        data class Available(override val network: Network) : CallbackEntry()
+        data class Available(override val network: Network) : Event()
         data class CapabilitiesChanged(
             override val network: Network,
             val caps: NetworkCapabilities
-        ) : CallbackEntry()
+        ) : Event()
         data class LinkPropertiesChanged(
             override val network: Network,
             val lp: LinkProperties
-        ) : CallbackEntry()
+        ) : Event()
         data class LocalInfoChanged(
             override val network: Network,
             val info: LocalNetworkInfo
-        ) : CallbackEntry()
-        data class Suspended(override val network: Network) : CallbackEntry()
-        data class Resumed(override val network: Network) : CallbackEntry()
-        data class Losing(override val network: Network, val maxMsToLive: Int) : CallbackEntry()
-        data class Lost(override val network: Network) : CallbackEntry()
-        data class Unavailable private constructor(
+        ) : Event()
+        data class Suspended(override val network: Network) : Event()
+        data class Resumed(override val network: Network) : Event()
+        data class Losing(override val network: Network, val maxMsToLive: Int) : Event()
+        data class Lost(override val network: Network) : Event()
+        data class Unavailable(
             override val network: Network
-        ) : CallbackEntry() {
+        ) : Event() {
             constructor() : this(NULL_NETWORK)
         }
         data class BlockedStatus(
             override val network: Network,
             val blocked: Boolean
-        ) : CallbackEntry()
+        ) : Event()
         data class BlockedStatusInt(
             override val network: Network,
             val reason: Int
-        ) : CallbackEntry()
+        ) : Event()
 
         // Convenience constants for expecting a type
         companion object {
@@ -133,9 +142,6 @@ open class RecorderCallback private constructor(
         }
     }
 
-    val history = backingRecord.newReadHead()
-    val mark get() = history.mark
-
     override fun onReserved(caps: NetworkCapabilities) {
         Log.d(logTag, "onReserved $caps")
         history.add(Reserved(caps))
@@ -196,22 +202,7 @@ open class RecorderCallback private constructor(
         Log.d(logTag, "onUnavailable")
         history.add(Unavailable())
     }
-}
 
-private const val DEFAULT_TIMEOUT = 30_000L // ms
-private const val DEFAULT_NO_CALLBACK_TIMEOUT = 200L // ms
-private val NOOP = Runnable {}
-
-/**
- * See comments on the public constructor below for a description of the arguments.
- */
-open class TestableNetworkCallback private constructor(
-    src: TestableNetworkCallback?,
-    val defaultTimeoutMs: Long,
-    val defaultNoCallbackTimeoutMs: Long,
-    val waiterFunc: Runnable,
-    logTag: String
-) : RecorderCallback(src, logTag) {
     /**
      * Construct a testable network callback.
      * @param timeoutMs the default timeout for expecting a callback. Default 30 seconds. This
@@ -260,7 +251,7 @@ open class TestableNetworkCallback private constructor(
      * Long.MAX_VALUE.
      */
     @JvmOverloads
-    fun poll(timeoutMs: Long = defaultTimeoutMs, predicate: (CallbackEntry) -> Boolean = { true }) =
+    fun poll(timeoutMs: Long = defaultTimeoutMs, predicate: (Event) -> Boolean = { true }) =
             history.poll(timeoutMs, predicate)
 
     /*****
@@ -269,13 +260,13 @@ open class TestableNetworkCallback private constructor(
      * passed predicate. If no callback is received within the timeout, these methods fail.
      */
     @JvmOverloads
-    fun <T : CallbackEntry> expect(
+    fun <T : Event> expect(
         type: KClass<T>,
         network: Network = ANY_NETWORK,
         timeoutMs: Long = defaultTimeoutMs,
         errorMsg: String? = null,
         test: (T) -> Boolean = { true }
-    ) = expect<CallbackEntry>(network, timeoutMs, errorMsg) {
+    ) = expect<Event>(network, timeoutMs, errorMsg) {
         if (type.isInstance(it)) {
             test(it as T) // Cast can't fail since type.isInstance(it) and type: KClass<T>
         } else {
@@ -284,7 +275,7 @@ open class TestableNetworkCallback private constructor(
     } as T
 
     @JvmOverloads
-    fun <T : CallbackEntry> expect(
+    fun <T : Event> expect(
         type: KClass<T>,
         network: HasNetwork,
         timeoutMs: Long = defaultTimeoutMs,
@@ -297,7 +288,7 @@ open class TestableNetworkCallback private constructor(
     // there is no need to explicitly define versions without the test predicate.
     // Without |network|
     @JvmOverloads
-    fun <T : CallbackEntry> expect(
+    fun <T : Event> expect(
         type: KClass<T>,
         timeoutMs: Long,
         errorMsg: String?,
@@ -306,7 +297,7 @@ open class TestableNetworkCallback private constructor(
 
     // Without |timeout|, in Network and HasNetwork versions
     @JvmOverloads
-    fun <T : CallbackEntry> expect(
+    fun <T : Event> expect(
         type: KClass<T>,
         network: Network,
         errorMsg: String?,
@@ -314,7 +305,7 @@ open class TestableNetworkCallback private constructor(
     ) = expect(type, network, defaultTimeoutMs, errorMsg, test)
 
     @JvmOverloads
-    fun <T : CallbackEntry> expect(
+    fun <T : Event> expect(
         type: KClass<T>,
         network: HasNetwork,
         errorMsg: String?,
@@ -322,16 +313,14 @@ open class TestableNetworkCallback private constructor(
     ) = expect(type, network.network, defaultTimeoutMs, errorMsg, test)
 
     // Without |errorMsg|, in Network and HasNetwork versions
-    @JvmOverloads
-    fun <T : CallbackEntry> expect(
+    fun <T : Event> expect(
         type: KClass<T>,
         network: Network,
         timeoutMs: Long,
         test: (T) -> Boolean
     ) = expect(type, network, timeoutMs, null, test)
 
-    @JvmOverloads
-    fun <T : CallbackEntry> expect(
+    fun <T : Event> expect(
         type: KClass<T>,
         network: HasNetwork,
         timeoutMs: Long,
@@ -340,7 +329,7 @@ open class TestableNetworkCallback private constructor(
 
     // Without |network| or |timeout|
     @JvmOverloads
-    fun <T : CallbackEntry> expect(
+    fun <T : Event> expect(
         type: KClass<T>,
         errorMsg: String?,
         test: (T) -> Boolean = { true }
@@ -348,36 +337,33 @@ open class TestableNetworkCallback private constructor(
 
     // Without |network| or |errorMsg|
     @JvmOverloads
-    fun <T : CallbackEntry> expect(
+    fun <T : Event> expect(
         type: KClass<T>,
         timeoutMs: Long,
         test: (T) -> Boolean = { true }
     ) = expect(type, ANY_NETWORK, timeoutMs, null, test)
 
     // Without |timeout| or |errorMsg|, in Network and HasNetwork versions
-    @JvmOverloads
-    fun <T : CallbackEntry> expect(
+    fun <T : Event> expect(
         type: KClass<T>,
         network: Network,
         test: (T) -> Boolean
     ) = expect(type, network, defaultTimeoutMs, null, test)
 
-    @JvmOverloads
-    fun <T : CallbackEntry> expect(
+    fun <T : Event> expect(
         type: KClass<T>,
         network: HasNetwork,
         test: (T) -> Boolean
     ) = expect(type, network.network, defaultTimeoutMs, null, test)
 
     // Without |network| or |timeout| or |errorMsg|
-    @JvmOverloads
-    fun <T : CallbackEntry> expect(
+    fun <T : Event> expect(
         type: KClass<T>,
         test: (T) -> Boolean
     ) = expect(type, ANY_NETWORK, defaultTimeoutMs, null, test)
 
     // Kotlin reified versions. Don't call methods above, or the predicate would need to be noinline
-    inline fun <reified T : CallbackEntry> expect(
+    inline fun <reified T : Event> expect(
         network: Network = ANY_NETWORK,
         timeoutMs: Long = defaultTimeoutMs,
         errorMsg: String? = null,
@@ -399,13 +385,7 @@ open class TestableNetworkCallback private constructor(
                 }
             } as T
 
-    // "Nothing" is the return type to declare a function never returns a value.
-    fun failWithErrorReason(errorMsg: String?, errorReason: String): Nothing {
-        val message = if (errorMsg != null) "$errorMsg : $errorReason" else errorReason
-        fail(message)
-    }
-
-    inline fun <reified T : CallbackEntry> expect(
+    inline fun <reified T : Event> expect(
         network: HasNetwork,
         timeoutMs: Long = defaultTimeoutMs,
         errorMsg: String? = null,
@@ -421,13 +401,13 @@ open class TestableNetworkCallback private constructor(
     @JvmOverloads
     fun assertNoCallback(
         timeoutMs: Long = defaultNoCallbackTimeoutMs,
-        valid: (CallbackEntry) -> Boolean = { true }
+        valid: (Event) -> Boolean = { true }
     ) {
         waiterFunc.run()
         history.poll(timeoutMs) { valid(it) }?.let { fail("Expected no callback but got $it") }
     }
 
-    fun assertNoCallback(valid: (CallbackEntry) -> Boolean) =
+    fun assertNoCallback(valid: (Event) -> Boolean) =
             assertNoCallback(defaultNoCallbackTimeoutMs, valid)
 
     /*****
@@ -436,7 +416,7 @@ open class TestableNetworkCallback private constructor(
      * Any callback of the wrong type, or doesn't match the optional predicate, is ignored.
      * They fail if no callback matching the predicate is received within the timeout.
      */
-    inline fun <reified T : CallbackEntry> eventuallyExpect(
+    inline fun <reified T : Event> eventuallyExpect(
         timeoutMs: Long = defaultTimeoutMs,
         from: Int = mark,
         crossinline predicate: (T) -> Boolean = { true }
@@ -449,7 +429,7 @@ open class TestableNetworkCallback private constructor(
     } as T
 
     @JvmOverloads
-    fun <T : CallbackEntry> eventuallyExpect(
+    fun <T : Event> eventuallyExpect(
         type: KClass<T>,
         timeoutMs: Long = defaultTimeoutMs,
         predicate: (cb: T) -> Boolean = { true }
@@ -461,7 +441,7 @@ open class TestableNetworkCallback private constructor(
         )
     } as T
 
-    fun <T : CallbackEntry> eventuallyExpect(
+    fun <T : Event> eventuallyExpect(
         type: KClass<T>,
         timeoutMs: Long = defaultTimeoutMs,
         from: Int = mark,
diff --git a/staticlibs/testutils/devicetests/com/android/testutils/TestableNetworkOfferCallback.kt b/staticlibs/testutils/devicetests/com/android/testutils/TestableNetworkOfferCallback.kt
index a0078d21d7..cd0143e318 100644
--- a/staticlibs/testutils/devicetests/com/android/testutils/TestableNetworkOfferCallback.kt
+++ b/staticlibs/testutils/devicetests/com/android/testutils/TestableNetworkOfferCallback.kt
@@ -23,14 +23,20 @@ import android.util.Log
 import com.android.net.module.util.ArrayTrackRecord
 import kotlin.test.fail
 
-class TestableNetworkOfferCallback(val timeoutMs: Long, private val noCallbackTimeoutMs: Long)
-            : NetworkProvider.NetworkOfferCallback {
+private const val DEFAULT_TIMEOUT = 30_000L // ms
+private const val DEFAULT_NO_CALLBACK_TIMEOUT = 200L // ms
+
+class TestableNetworkOfferCallback(
+    val timeoutMs: Long = DEFAULT_TIMEOUT,
+    private val noCallbackTimeoutMs: Long = DEFAULT_NO_CALLBACK_TIMEOUT,
+) : NetworkProvider.NetworkOfferCallback {
     private val TAG = this::class.simpleName
-    val history = ArrayTrackRecord<CallbackEntry>().newReadHead()
+    val history = ArrayTrackRecord<Event>().newReadHead()
+    val mark get() = history.mark
 
-    sealed class CallbackEntry {
-        data class OnNetworkNeeded(val request: NetworkRequest) : CallbackEntry()
-        data class OnNetworkUnneeded(val request: NetworkRequest) : CallbackEntry()
+    sealed class Event {
+        data class Needed(val request: NetworkRequest) : Event()
+        data class Unneeded(val request: NetworkRequest) : Event()
     }
 
     /**
@@ -39,7 +45,7 @@ class TestableNetworkOfferCallback(val timeoutMs: Long, private val noCallbackTi
      */
     override fun onNetworkNeeded(request: NetworkRequest) {
         Log.d(TAG, "onNetworkNeeded $request")
-        history.add(CallbackEntry.OnNetworkNeeded(request))
+        history.add(Event.Needed(request))
     }
 
     /**
@@ -47,25 +53,53 @@ class TestableNetworkOfferCallback(val timeoutMs: Long, private val noCallbackTi
      */
     override fun onNetworkUnneeded(request: NetworkRequest) {
         Log.d(TAG, "onNetworkUnneeded $request")
-        history.add(CallbackEntry.OnNetworkUnneeded(request))
+        history.add(Event.Unneeded(request))
     }
 
-    inline fun <reified T : CallbackEntry> expectCallbackThat(
-        crossinline predicate: (T) -> Boolean
+    inline fun <reified T : Event> expect(
+        errorMsg: String? = null,
+        predicate: (T) -> Boolean = { true }
     ): T {
-        val event = history.poll(timeoutMs)
-                ?: fail("Did not receive callback after ${timeoutMs}ms")
-        if (event !is T || !predicate(event)) fail("Received unexpected callback $event")
-        return event
+        val nextEntry = history.poll(timeoutMs) ?: failWithErrorReason(errorMsg,
+            "Did not receive ${T::class.simpleName} after ${timeoutMs}ms")
+        if (nextEntry !is T) {
+            failWithErrorReason(
+                errorMsg,
+                "Expected callback ${T::class.simpleName}, got $nextEntry"
+            )
+        }
+        if (!predicate(nextEntry)) {
+            failWithErrorReason(errorMsg, "Callback doesn't match predicate: $nextEntry")
+        }
+        return nextEntry
     }
 
+    // TODO : remove when there are no callers
+    @Deprecated("Use expect instead of expectCallbackThat")
+    inline fun <reified T : Event> expectCallbackThat(
+        crossinline predicate: (T) -> Boolean
+    ): T = expect<T>(null, predicate)
+
+    inline fun <reified T : Event> eventuallyExpect(
+        errorMsg: String? = null,
+        from: Int = mark,
+        crossinline predicate: (T) -> Boolean = { true }
+    ) = history.poll(timeoutMs, from) { it is T && predicate(it) }.also {
+        if (null == it) {
+            failWithErrorReason(
+                errorMsg,
+                "Callback ${T::class} not received within ${timeoutMs}ms."
+            )
+        }
+    } as T
+
     fun expectOnNetworkNeeded(capabilities: NetworkCapabilities) =
-            expectCallbackThat<CallbackEntry.OnNetworkNeeded> {
+            expectCallbackThat<Event.Needed> {
                 it.request.canBeSatisfiedBy(capabilities)
             }
 
     fun expectOnNetworkUnneeded(capabilities: NetworkCapabilities) =
-            expectCallbackThat<CallbackEntry.OnNetworkUnneeded> {
+            expectCallbackThat<Event.Unneeded> {
                 it.request.canBeSatisfiedBy(capabilities)
             }
 
@@ -73,4 +107,4 @@ class TestableNetworkOfferCallback(val timeoutMs: Long, private val noCallbackTi
         val cb = history.poll(noCallbackTimeoutMs)
         if (null != cb) fail("Expected no callback but got $cb")
     }
-}
\ No newline at end of file
+}
diff --git a/staticlibs/testutils/devicetests/com/android/testutils/VersionUtil.kt b/staticlibs/testutils/devicetests/com/android/testutils/VersionUtil.kt
new file mode 100644
index 0000000000..3129c76114
--- /dev/null
+++ b/staticlibs/testutils/devicetests/com/android/testutils/VersionUtil.kt
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@file:JvmName("VersionUtil")
+
+package com.android.testutils.com.android.testutils
+
+import androidx.test.platform.app.InstrumentationRegistry
+
+/**
+ * Value for [getTargetModuleVersion] that indicates that no manifest is available in the test.
+ */
+const val MODULE_VERSION_NO_MANIFEST = -1
+
+/**
+ * Get the version of the module targeted by the current test.
+ *
+ * <p>This reads the value of the target_module_version resource from the resources of the test
+ * package. That resource must be configured in build rules (via "resources" or "resource_zips") for
+ * the test.
+ */
+fun getTargetModuleVersion(): Int {
+    val ctx = InstrumentationRegistry.getInstrumentation().context
+    val res = ctx.resources
+    val resId = res.getIdentifier("target_module_version", "raw", ctx.packageName)
+    if (resId == 0) {
+        return MODULE_VERSION_NO_MANIFEST
+    }
+    return res.openRawResource(resId).reader().use {
+        it.readText().trim(' ', '\n').toInt()
+    }
+}
diff --git a/staticlibs/testutils/host/python/adb_utils.py b/staticlibs/testutils/host/python/adb_utils.py
index 13c06464fd..e3260a9920 100644
--- a/staticlibs/testutils/host/python/adb_utils.py
+++ b/staticlibs/testutils/host/python/adb_utils.py
@@ -12,36 +12,41 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 
+import logging
 import re
+import time
+import types
+from mobly import utils
 from mobly.controllers import android_device
+from mobly.controllers.android_device_lib import adb
 from net_tests_utils.host.python import assert_utils
 
-BYTE_DECODE_UTF_8 = "utf-8"
+BYTE_DECODE_UTF_8 = 'utf-8'
 
 
 def set_doze_mode(ad: android_device.AndroidDevice, enable: bool) -> None:
   if enable:
-    adb_shell(ad, "cmd battery unplug")
+    adb_shell(ad, 'cmd battery unplug')
     expect_dumpsys_state_with_retry(
-        ad, "deviceidle", key="mCharging", expected_state=False
+        ad, 'deviceidle', key='mCharging', expected_state=False
     )
     _set_screen_state(ad, False)
-    adb_shell(ad, "dumpsys deviceidle enable deep")
+    adb_shell(ad, 'dumpsys deviceidle enable deep')
     expect_dumpsys_state_with_retry(
-        ad, "deviceidle", key="mDeepEnabled", expected_state=True
+        ad, 'deviceidle', key='mDeepEnabled', expected_state=True
     )
-    adb_shell(ad, "dumpsys deviceidle force-idle deep")
+    adb_shell(ad, 'dumpsys deviceidle force-idle deep')
     expect_dumpsys_state_with_retry(
-        ad, "deviceidle", key="mForceIdle", expected_state=True
+        ad, 'deviceidle', key='mForceIdle', expected_state=True
     )
   else:
-    adb_shell(ad, "cmd battery reset")
+    adb_shell(ad, 'cmd battery reset')
     expect_dumpsys_state_with_retry(
-        ad, "deviceidle", key="mCharging", expected_state=True
+        ad, 'deviceidle', key='mCharging', expected_state=True
     )
-    adb_shell(ad, "dumpsys deviceidle unforce")
+    adb_shell(ad, 'dumpsys deviceidle unforce')
     expect_dumpsys_state_with_retry(
-        ad, "deviceidle", key="mForceIdle", expected_state=False
+        ad, 'deviceidle', key='mForceIdle', expected_state=False
     )
 
 
@@ -51,13 +56,13 @@ def _set_screen_state(
   assert_utils.expect_with_retry(
       predicate=lambda: _get_screen_state(ad) == target_state,
       retry_action=lambda: adb_shell(
-          ad, "input keyevent KEYCODE_POWER"
+          ad, 'input keyevent KEYCODE_POWER'
       ),  # Toggle power key again when retry.
   )
 
 
 def _get_screen_state(ad: android_device.AndroidDevice) -> bool:
-  return get_value_of_key_from_dumpsys(ad, "power", "mWakefulness") == "Awake"
+  return get_value_of_key_from_dumpsys(ad, 'power', 'mWakefulness') == 'Awake'
 
 
 def get_value_of_key_from_dumpsys(
@@ -66,12 +71,12 @@ def get_value_of_key_from_dumpsys(
   output = get_dumpsys_for_service(ad, service)
   # Search for key=value pattern from the dumpsys output.
   # e.g. mWakefulness=Awake
-  pattern = rf"{key}=(.*)"
+  pattern = rf'{key}=(.*)'
   # Only look for the first occurrence.
   match = re.search(pattern, output)
   if match:
     ad.log.debug(
-        "Getting key-value from dumpsys: " + key + "=" + match.group(1)
+        'Getting key-value from dumpsys: ' + key + '=' + match.group(1)
     )
     return match.group(1)
   else:
@@ -100,7 +105,74 @@ def expect_dumpsys_state_with_retry(
 def get_dumpsys_for_service(
     ad: android_device.AndroidDevice, service: str
 ) -> str:
-  return adb_shell(ad, "dumpsys " + service)
+  return adb_shell(ad, 'dumpsys ' + service)
+
+
+def unroot_adb(self) -> bytes:
+  """Executes the 'adb unroot' command on the device with retry logic.
+
+  This method is intended to be dynamically attached to an AdbProxy instance
+  (or similar object) that provides an '_exec_adb_cmd' method for executing
+  ADB commands. It attempts to unroot the device, and if an AdbError occurs,
+  it retries the command a specified number of times with an exponentially
+  increasing delay.
+
+  Args:
+    self: The instance of the ADB client (e.g., an AdbProxy object) that has the
+      '_exec_adb_cmd' method available to run ADB commands.
+
+  Returns:
+    bytes: The raw byte output from the 'adb unroot' command's successful
+      execution.
+
+  Raises:
+    adb.AdbError: If the 'adb unroot' command fails after all specified
+      retry attempts.
+  """
+  retry_interval = adb.ADB_ROOT_RETRY_ATTEMPT_INTERVAL_SEC
+  for attempt in range(adb.ADB_ROOT_RETRY_ATTEMPTS):
+    try:
+      # Assuming 'self' here is an object that has a '_exec_adb_cmd' method,
+      # similar to your original 'root' method's context (e.g., an AdbProxy).
+      return self._exec_adb_cmd(
+          'unroot', args=None, shell=False, timeout=None, stderr=None
+      )
+    except adb.AdbError as e:
+      if attempt + 1 < adb.ADB_ROOT_RETRY_ATTEMPTS:
+        # Decode stderr for logging, as Mobly often provides bytes
+        decoded_stderr = e.stderr.decode('utf-8', errors='ignore').strip()
+        logging.error(
+            f'Retry the command "{utils.cli_cmd_to_string(e.cmd)}" since Error'
+            f' "{decoded_stderr}" occurred (attempt'
+            f' {attempt + 1}/{adb.ADB_ROOT_RETRY_ATTEMPTS}).'
+        )
+        time.sleep(retry_interval)
+        retry_interval *= 2
+      else:
+        raise e
+
+
+def unroot(ad: android_device.AndroidDevice):
+  """Dynamically unroots an Android device by attaching 'unroot_adb' to its ADB proxy.
+
+  This function addresses a potential issue where Mobly might attempt to root
+  a device upon registration. When running user or userdebug builds,
+  this automatic rooting can lead to unexpected or inconsistent device behavior.
+  To mitigate this, this function temporarily attaches the 'unroot_adb' method
+  to the device's ADB proxy (`ad.adb`), executes it, and then removes it,
+  ensuring the device returns to an unrooted state and the ADB proxy's state
+  remains clean.
+
+  Args:
+    ad: The `android_device.AndroidDevice` instance to be unrooted.
+  """
+  attach_method_name = 'unroot_adb'
+  try:
+    setattr(ad.adb, attach_method_name, types.MethodType(unroot_adb, ad.adb))
+    getattr(ad.adb, attach_method_name)()
+    ad.adb.wait_for_device()
+  finally:
+    delattr(ad.adb, attach_method_name)
 
 
 def adb_shell(ad: android_device.AndroidDevice, shell_cmd: str) -> str:
@@ -113,6 +185,6 @@ def adb_shell(ad: android_device.AndroidDevice, shell_cmd: str) -> str:
   Returns:
     string, replies from adb shell command.
   """
-  ad.log.debug("Executing adb shell %s", shell_cmd)
+  ad.log.debug('Executing adb shell %s', shell_cmd)
   data = ad.adb.shell(shell_cmd)
   return data.decode(BYTE_DECODE_UTF_8).strip()
diff --git a/staticlibs/testutils/host/python/apf_test_base.py b/staticlibs/testutils/host/python/apf_test_base.py
index c9cda417a3..b0fe28fdf3 100644
--- a/staticlibs/testutils/host/python/apf_test_base.py
+++ b/staticlibs/testutils/host/python/apf_test_base.py
@@ -12,10 +12,11 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 
+import time
 from mobly import asserts
 from net_tests_utils.host.python import adb_utils, apf_utils, assert_utils, multi_devices_test_base, tether_utils
 from net_tests_utils.host.python.tether_utils import UpstreamType
-import time
+
 
 class ApfTestBase(multi_devices_test_base.MultiDevicesTestBase):
 
@@ -25,8 +26,8 @@ class ApfTestBase(multi_devices_test_base.MultiDevicesTestBase):
     # Check test preconditions.
     asserts.abort_class_if(
         not self.client.isAtLeastV(),
-        "Do not enforce the test until V+ since chipset potential bugs are"
-        " expected to be fixed on V+ releases.",
+        'Do not enforce the test until V+ since chipset potential bugs are'
+        ' expected to be fixed on V+ releases.',
     )
     tether_utils.assume_hotspot_test_preconditions(
         self.serverDevice, self.clientDevice, UpstreamType.NONE
@@ -35,9 +36,14 @@ class ApfTestBase(multi_devices_test_base.MultiDevicesTestBase):
         not apf_utils.is_send_raw_packet_downstream_supported(
             self.serverDevice
         ),
-        "NetworkStack is too old to support send raw packet, skip test.",
+        'NetworkStack is too old to support send raw packet, skip test.',
     )
 
+    asserts.abort_class_if(
+        self.client.hasAutomotiveFeature(),
+        'APF GMS-VSR requirements do not apply to automotive devices, skip'
+        ' test.',
+    )
     # Fetch device properties and storing them locally for later use.
     # TODO: refactor to separate instances to store client and server device
     self.server_iface_name, client_network = (
@@ -104,35 +110,35 @@ class ApfTestBase(multi_devices_test_base.MultiDevicesTestBase):
       self, send_packet: str, counter_name: str, receive_packet: str
   ) -> None:
     try:
-        apf_utils.start_capture_packets(self.serverDevice, self.server_iface_name)
-
-        count_before_test = apf_utils.get_apf_counter(
-            self.clientDevice,
-            self.client_iface_name,
-            counter_name,
-        )
-
-        apf_utils.send_raw_packet_downstream(
-            self.serverDevice, self.server_iface_name, send_packet
-        )
-
+      apf_utils.start_capture_packets(self.serverDevice, self.server_iface_name)
+
+      count_before_test = apf_utils.get_apf_counter(
+          self.clientDevice,
+          self.client_iface_name,
+          counter_name,
+      )
+
+      apf_utils.send_raw_packet_downstream(
+          self.serverDevice, self.server_iface_name, send_packet
+      )
+
+      assert_utils.expect_with_retry(
+          lambda: apf_utils.get_matched_packet_counts(
+              self.serverDevice, self.server_iface_name, receive_packet
+          )
+          == 1
+      )
+
+      # TODO: re-enable once the test passes reliably.
+      if False:
         assert_utils.expect_with_retry(
-            lambda: apf_utils.get_matched_packet_counts(
-                self.serverDevice, self.server_iface_name, receive_packet
+            lambda: apf_utils.get_apf_counter(
+                self.clientDevice,
+                self.client_iface_name,
+                counter_name,
             )
-            == 1
+            > count_before_test
         )
 
-        # TODO: re-enable once the test passes reliably.
-        if False:
-            assert_utils.expect_with_retry(
-                lambda: apf_utils.get_apf_counter(
-                    self.clientDevice,
-                    self.client_iface_name,
-                    counter_name,
-                )
-                > count_before_test
-            )
-
     finally:
-        apf_utils.stop_capture_packets(self.serverDevice, self.server_iface_name)
+      apf_utils.stop_capture_packets(self.serverDevice, self.server_iface_name)
diff --git a/staticlibs/testutils/host/python/apf_utils.py b/staticlibs/testutils/host/python/apf_utils.py
index 4835c23c56..3a1c8f5e3e 100644
--- a/staticlibs/testutils/host/python/apf_utils.py
+++ b/staticlibs/testutils/host/python/apf_utils.py
@@ -13,12 +13,12 @@
 #  limitations under the License.
 
 from dataclasses import dataclass
+import functools
 import re
 from mobly import asserts
 from mobly.controllers import android_device
 from mobly.controllers.android_device_lib.adb import AdbError
 from net_tests_utils.host.python import adb_utils, assert_utils
-import functools
 
 
 class PatternNotFoundException(Exception):
@@ -32,57 +32,32 @@ class UnsupportedOperationException(Exception):
 def get_apf_counter(
     ad: android_device.AndroidDevice, iface: str, counter_name: str
 ) -> int:
-  counters = get_apf_counters_from_dumpsys(ad, iface)
-  return counters.get(counter_name, 0)
+  counters = get_apf_counters_from_cmd(ad, iface)
+  try:
+    return int(counters.get(counter_name, 0))
+  except ValueError:
+    return -1
 
 
-def get_apf_counters_from_dumpsys(
+def get_apf_counters_from_cmd(
     ad: android_device.AndroidDevice, iface_name: str
 ) -> dict:
-  dumpsys = adb_utils.get_dumpsys_for_service(ad, "network_stack")
-
-  # Extract IpClient section of the specified interface.
-  # This takes inputs like:
-  # IpClient.wlan0
-  #   ...
-  # IpClient.wlan1
-  #   ...
-  iface_pattern = re.compile(
-      r"^IpClient\." + iface_name + r"\n" + r"((^\s.*\n)+)", re.MULTILINE
-  )
-  iface_result = iface_pattern.search(dumpsys)
-  if iface_result is None:
-    raise PatternNotFoundException("Cannot find IpClient for " + iface_name)
-
-  # Extract APF counters section from IpClient section, which looks like:
-  #     APF packet counters:
-  #       COUNTER_NAME: VALUE
-  #       ....
-  apf_pattern = re.compile(
-      r"APF packet counters:.*\n.(\s+[A-Z_0-9]+: \d+\n)+", re.MULTILINE
-  )
-  apf_result = apf_pattern.search(iface_result.group(0))
-  if apf_result is None:
-    raise PatternNotFoundException(
-        "Cannot find APF counters in text: " + iface_result.group(0)
-    )
-
-  # Extract key-value pairs from APF counters section into a list of tuples,
-  # e.g. [('COUNTER1', '1'), ('COUNTER2', '2')].
-  counter_pattern = re.compile(r"(?P<name>[A-Z_0-9]+): (?P<value>\d+)")
-  counter_result = counter_pattern.findall(apf_result.group(0))
-  if counter_result is None:
-    raise PatternNotFoundException(
-        "Cannot extract APF counters in text: " + apf_result.group(0)
-    )
+  cmd = f'cmd network_stack apf {iface_name} dump-counters'
+  output = AdbOutputHandler(ad, cmd).get_output()
+  data_dict = {}
+  for line in output.strip().split('\n'):
+    if line:  # Ensure the line is not empty
+      # split only at the first colon
+      parts = line.split(':', 1)
+      if len(parts) == 2:
+        data_dict[parts[0]] = parts[1]
+      else:
+        raise assert_utils.UnexpectedBehaviorError(
+            f'Got unexpected output: {output}.'
+        )
 
-  # Convert into a dict.
-  result = {}
-  for key, value_str in counter_result:
-    result[key] = int(value_str)
+  return data_dict
 
-  ad.log.debug("Getting apf counters: " + str(result))
-  return result
 
 def get_ipv4_addresses(
     ad: android_device.AndroidDevice, iface_name: str
@@ -107,8 +82,8 @@ def get_ipv4_addresses(
   #         valid_lft forever preferred_lft forever
   #     inet 192.168.1.1/24 brd 192.168.1.255 scope global wlan2
   #         valid_lft forever preferred_lft forever
-  output = adb_utils.adb_shell(ad, f"ip -4 address show {iface_name}")
-  pattern = r"inet\s+(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\/\d+"
+  output = adb_utils.adb_shell(ad, f'ip -4 address show {iface_name}')
+  pattern = r'inet\s+(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\/\d+'
   matches = re.findall(pattern, output)
 
   if matches:
@@ -116,12 +91,14 @@ def get_ipv4_addresses(
   else:
     return []
 
+
 def get_non_tentative_ipv6_addresses(
     ad: android_device.AndroidDevice, iface_name: str
 ) -> list[str]:
   """Retrieves the non-tentative IPv6 addresses of a given interface on an Android device.
 
-  This function executes an ADB shell command (`ip -6 address show -tentative`) to get the
+  This function executes an ADB shell command (`ip -6 address show -tentative`)
+  to get the
   network interface information and extracts the IPv6 address from the output.
   If devices have no IPv6 address, raise PatternNotFoundException.
 
@@ -139,8 +116,10 @@ def get_non_tentative_ipv6_addresses(
   #         valid_lft forever preferred_lft forever
   #     inet6 fe80::1233:aadb:3d32:1234/64 scope link
   #         valid_lft forever preferred_lft forever
-  output = adb_utils.adb_shell(ad, f"ip -6 address show -tentative {iface_name}")
-  pattern = r"inet6\s+([0-9a-fA-F:]+)\/\d+"
+  output = adb_utils.adb_shell(
+      ad, f'ip -6 address show -tentative {iface_name}'
+  )
+  pattern = r'inet6\s+([0-9a-fA-F:]+)\/\d+'
   matches = re.findall(pattern, output)
 
   if matches:
@@ -148,13 +127,15 @@ def get_non_tentative_ipv6_addresses(
   else:
     return []
 
+
 def get_exclude_all_host_ipv6_multicast_addresses(
     ad: android_device.AndroidDevice, iface_name: str
 ) -> list[str]:
   """Retrieves the IPv6 multicast addresses of a given interface on an Android device.
 
   This function executes an ADB shell command (`ip -6 maddr show`) to get the
-  network interface information and extracts the IPv6 multicast address from the output.
+  network interface information and extracts the IPv6 multicast address from the
+  output.
   If devices have no IPv6 multicast address, raise PatternNotFoundException.
 
   Args:
@@ -171,15 +152,16 @@ def get_exclude_all_host_ipv6_multicast_addresses(
   #         inet6 ff02::1:ffb7:cba2 users 2
   #         inet6 ff02::1
   #         inet6 ff01::1
-  output = adb_utils.adb_shell(ad, f"ip -6 maddr show {iface_name}")
-  pattern = r"inet6\s+([a-fA-F0-9:]+)(?:\s+users\s+\d+)?"
+  output = adb_utils.adb_shell(ad, f'ip -6 maddr show {iface_name}')
+  pattern = r'inet6\s+([a-fA-F0-9:]+)(?:\s+users\s+\d+)?'
   matches = re.findall(pattern, output)
 
   if matches:
-    return [addr for addr in matches if addr not in ("ff02::1", "ff01::1")]
+    return [addr for addr in matches if addr not in ('ff02::1', 'ff01::1')]
   else:
     return []
 
+
 def get_hardware_address(
     ad: android_device.AndroidDevice, iface_name: str
 ) -> str:
@@ -195,7 +177,7 @@ def get_hardware_address(
   """
 
   # Run the "ip link" command and get its output.
-  ip_link_output = adb_utils.adb_shell(ad, f"ip link")
+  ip_link_output = adb_utils.adb_shell(ad, f'ip link')
 
   # Regular expression to extract the MAC address.
   # Parse hardware address from ip link output like below:
@@ -205,34 +187,52 @@ def get_hardware_address(
   #    link/ether 72:05:77:82:21:e0 brd ff:ff:ff:ff:ff:ff
   # 47: wlan1: <BROADCAST,MULTICAST> mtu 1500 qdisc ...
   #    link/ether 6a:16:81:ff:82:9b brd ff:ff:ff:ff:ff:ff"
-  pattern = rf"{iface_name}:.*?link/ether (([0-9a-fA-F]{{2}}:){{5}}[0-9a-fA-F]{{2}})"
+  pattern = (
+      rf'{iface_name}:.*?link/ether (([0-9a-fA-F]{{2}}:){{5}}[0-9a-fA-F]{{2}})'
+  )
   match = re.search(pattern, ip_link_output, re.DOTALL)
 
   if match:
     return match.group(1).upper()  # Extract the MAC address string.
   else:
     raise PatternNotFoundException(
-        "Cannot get hardware address for " + iface_name
+        'Cannot get hardware address for ' + iface_name
     )
 
+
 def is_packet_capture_supported(
-        ad: android_device.AndroidDevice,
+    ad: android_device.AndroidDevice,
 ) -> bool:
 
   try:
     # Invoke the shell command with empty argument and see how NetworkStack respond.
     # If supported, an IllegalArgumentException with help page will be printed.
     assert_utils.expect_throws(
-      lambda: start_capture_packets(ad, ""),
-      assert_utils.UnexpectedBehaviorError
+        lambda: start_capture_packets(ad, ''),
+        assert_utils.UnexpectedBehaviorError,
     )
     assert_utils.expect_throws(
-      lambda: stop_capture_packets(ad, ""),
-      assert_utils.UnexpectedBehaviorError
+        lambda: stop_capture_packets(ad, ''),
+        assert_utils.UnexpectedBehaviorError,
     )
     assert_utils.expect_throws(
-      lambda: get_matched_packet_counts(ad, "", ""),
-      assert_utils.UnexpectedBehaviorError
+        lambda: get_matched_packet_counts(ad, '', ''),
+        assert_utils.UnexpectedBehaviorError,
+    )
+  except assert_utils.UnexpectedExceptionError:
+    return False
+
+  # If no UnsupportOperationException is thrown, regard it as supported
+  return True
+
+
+def is_apf_dump_counters_supported(ad: android_device.AndroidDevice) -> bool:
+  try:
+    # Invoke the shell command with empty argument and see how NetworkStack respond.
+    # If supported, an IllegalArgumentException with help page will be printed.
+    assert_utils.expect_throws(
+        lambda: get_apf_counters_from_cmd(ad, ''),
+        assert_utils.UnexpectedBehaviorError,
     )
   except assert_utils.UnexpectedExceptionError:
     return False
@@ -240,13 +240,14 @@ def is_packet_capture_supported(
   # If no UnsupportOperationException is thrown, regard it as supported
   return True
 
+
 def is_send_raw_packet_downstream_supported(
     ad: android_device.AndroidDevice,
 ) -> bool:
   try:
     # Invoke the shell command with empty argument and see how NetworkStack respond.
     # If supported, an IllegalArgumentException with help page will be printed.
-    send_raw_packet_downstream(ad, "", "")
+    send_raw_packet_downstream(ad, '', '')
   except assert_utils.UnexpectedBehaviorError:
     return True
   except UnsupportedOperationException:
@@ -285,18 +286,21 @@ def send_raw_packet_downstream(
         representation of a packet starting from L2 header.
   """
 
-  cmd = f"cmd network_stack send-raw-packet-downstream {iface_name} {packet_in_hex}"
+  cmd = (
+      'cmd network_stack send-raw-packet-downstream'
+      f' {iface_name} {packet_in_hex}'
+  )
 
   # Expect no output or Unknown command if NetworkStack is too old. Throw otherwise.
   adb_output = AdbOutputHandler(ad, cmd).get_output()
   if adb_output:
     raise assert_utils.UnexpectedBehaviorError(
-      f"Got unexpected output: {adb_output} for command: {cmd}."
+        f'Got unexpected output: {adb_output} for command: {cmd}.'
     )
 
+
 def start_capture_packets(
-        ad: android_device.AndroidDevice,
-        iface_name: str
+    ad: android_device.AndroidDevice, iface_name: str
 ) -> None:
   """Starts packet capturing on a specified network interface.
 
@@ -309,18 +313,18 @@ def start_capture_packets(
     ad: The Android device object.
     iface_name: The name of the network interface (e.g., "wlan0").
   """
-  cmd = f"cmd network_stack capture start {iface_name}"
+  cmd = f'cmd network_stack capture start {iface_name}'
 
   # Expect no output or Unknown command if NetworkStack is too old. Throw otherwise.
   adb_output = AdbOutputHandler(ad, cmd).get_output()
-  if adb_output != "success":
+  if adb_output != 'success':
     raise assert_utils.UnexpectedBehaviorError(
-      f"Got unexpected output: {adb_output} for command: {cmd}."
+        f'Got unexpected output: {adb_output} for command: {cmd}.'
     )
 
+
 def stop_capture_packets(
-        ad: android_device.AndroidDevice,
-        iface_name: str
+    ad: android_device.AndroidDevice, iface_name: str
 ) -> None:
   """Stops packet capturing on a specified network interface.
 
@@ -332,19 +336,18 @@ def stop_capture_packets(
     ad: The Android device object.
     iface_name: The name of the network interface (e.g., "wlan0").
   """
-  cmd = f"cmd network_stack capture stop {iface_name}"
+  cmd = f'cmd network_stack capture stop {iface_name}'
 
   # Expect no output or Unknown command if NetworkStack is too old. Throw otherwise.
   adb_output = AdbOutputHandler(ad, cmd).get_output()
-  if adb_output != "success":
+  if adb_output != 'success':
     raise assert_utils.UnexpectedBehaviorError(
-      f"Got unexpected output: {adb_output} for command: {cmd}."
+        f'Got unexpected output: {adb_output} for command: {cmd}.'
     )
 
+
 def get_matched_packet_counts(
-        ad: android_device.AndroidDevice,
-        iface_name: str,
-        packet_in_hex: str
+    ad: android_device.AndroidDevice, iface_name: str, packet_in_hex: str
 ) -> int:
   """Gets the number of captured packets matching a specific hexadecimal pattern.
 
@@ -361,7 +364,10 @@ def get_matched_packet_counts(
   Returns:
     The number of matched packets as an integer.
   """
-  cmd = f"cmd network_stack capture matched-packet-counts {iface_name} {packet_in_hex}"
+  cmd = (
+      'cmd network_stack capture matched-packet-counts'
+      f' {iface_name} {packet_in_hex}'
+  )
 
   # Expect no output or Unknown command if NetworkStack is too old. Throw otherwise.
   adb_output = AdbOutputHandler(ad, cmd).get_output()
@@ -369,9 +375,10 @@ def get_matched_packet_counts(
     return int(adb_output)
   except ValueError as e:
     raise assert_utils.UnexpectedBehaviorError(
-      f"Got unexpected exception: {e} for command: {cmd}."
+        f'Got unexpected exception: {e} for command: {cmd}.'
     )
 
+
 @dataclass
 class ApfCapabilities:
   """APF program support capabilities.
@@ -404,9 +411,9 @@ class ApfCapabilities:
   def __str__(self):
     """Returns a user-friendly string representation of the APF capabilities."""
     return (
-        f"APF Version: {self.apf_version_supported}\n"
-        f"Ram Size: {self.apf_ram_size} bytes\n"
-        f"Packet Format: {self.apf_packet_format}"
+        f'APF Version: {self.apf_version_supported}\n'
+        f'Ram Size: {self.apf_ram_size} bytes\n'
+        f'Packet Format: {self.apf_packet_format}'
     )
 
 
@@ -414,10 +421,10 @@ def get_apf_capabilities(
     ad: android_device.AndroidDevice, iface_name: str
 ) -> ApfCapabilities:
   output = adb_utils.adb_shell(
-      ad, f"cmd network_stack apf {iface_name} capabilities"
+      ad, f'cmd network_stack apf {iface_name} capabilities'
   )
   try:
-    values = [int(value_str) for value_str in output.split(",")]
+    values = [int(value_str) for value_str in output.split(',')]
   except ValueError:
     return ApfCapabilities(0, 0, 0)  # Conversion to integer failed
   return ApfCapabilities(values[0], values[1], values[2])
@@ -429,43 +436,55 @@ def assume_apf_version_support_at_least(
   caps = get_apf_capabilities(ad, iface_name)
   asserts.abort_class_if(
       caps.apf_version_supported < expected_version,
-      f"Supported apf version {caps.apf_version_supported} < expected version"
-      f" {expected_version}",
+      f'Supported apf version {caps.apf_version_supported} < expected version'
+      f' {expected_version}',
   )
 
+
 def at_least_B():
   def decorator(test_function):
     @functools.wraps(test_function)
     def wrapper(self, *args, **kwargs):
       asserts.abort_class_if(
-        (not hasattr(self, 'client')) or (not hasattr(self.client, 'isAtLeastB')),
-        "no valid client attribute"
+          (not hasattr(self, 'client'))
+          or (not hasattr(self.client, 'isAtLeastB')),
+          'no valid client attribute',
       )
 
-      asserts.abort_class_if(not self.client.isAtLeastB(), "client device is not Android B+")
+      asserts.abort_class_if(
+          not self.client.isAtLeastB(), 'client device is not Android B+'
+      )
       return test_function(self, *args, **kwargs)
+
     return wrapper
+
   return decorator
 
+
 def apf_ram_at_least(size):
   def decorator(test_function):
     @functools.wraps(test_function)
     def wrapper(self, *args, **kwargs):
       asserts.abort_class_if(
-        (not hasattr(self, 'clientDevice')) or (not hasattr(self, 'client_iface_name')),
-        "no valid client attribute"
+          (not hasattr(self, 'clientDevice'))
+          or (not hasattr(self, 'client_iface_name')),
+          'no valid client attribute',
       )
 
       caps = get_apf_capabilities(self.clientDevice, self.client_iface_name)
       asserts.skip_if(
-        caps.apf_ram_size < size,
-        f'APF rame size {caps.apf_ram_size} < {size}'
+          caps.apf_ram_size < size,
+          f'APF rame size {caps.apf_ram_size} < {size}',
       )
       return test_function(self, *args, **kwargs)
+
     return wrapper
+
   return decorator
 
+
 class AdbOutputHandler:
+
   def __init__(self, ad, cmd):
     self._ad = ad
     self._cmd = cmd
@@ -475,8 +494,6 @@ class AdbOutputHandler:
       return adb_utils.adb_shell(self._ad, self._cmd)
     except AdbError as e:
       output = str(e.stdout)
-      if "Unknown command" in output:
-        raise UnsupportedOperationException(
-          f"{self._cmd} is not supported."
-        )
-      return output
\ No newline at end of file
+      if 'Unknown command' in output:
+        raise UnsupportedOperationException(f'{self._cmd} is not supported.')
+      return output
diff --git a/staticlibs/testutils/host/python/assert_utils.py b/staticlibs/testutils/host/python/assert_utils.py
index 40094a2946..12cf4f50d7 100644
--- a/staticlibs/testutils/host/python/assert_utils.py
+++ b/staticlibs/testutils/host/python/assert_utils.py
@@ -19,9 +19,11 @@ from typing import Callable
 class UnexpectedBehaviorError(Exception):
   """Raised when there is an unexpected behavior during applying a procedure."""
 
+
 class UnexpectedExceptionError(Exception):
   """Raised when there is an unexpected exception throws during applying a procedure"""
 
+
 def expect_with_retry(
     predicate: Callable[[], bool],
     retry_action: Callable[[], None] = None,
@@ -41,19 +43,20 @@ def expect_with_retry(
       time.sleep(retry_interval_sec)
 
   raise UnexpectedBehaviorError(
-      "Predicate didn't become true after " + str(max_retries) + " retries."
+      "Predicate didn't become true after " + str(max_retries) + ' retries.'
   )
 
+
 def expect_throws(runnable: callable, exception_class) -> None:
   try:
     runnable()
-    raise UnexpectedBehaviorError("Expected an exception, but none was thrown")
+    raise UnexpectedBehaviorError('Expected an exception, but none was thrown')
   except exception_class:
     pass
   except UnexpectedBehaviorError as e:
     raise e
   except Exception as e:
-      raise UnexpectedExceptionError(
-        f"Expected exception of type {exception_class.__name__}, "
-        f"but got {type(e).__name__}: {e}"
-      )
\ No newline at end of file
+    raise UnexpectedExceptionError(
+        f'Expected exception of type {exception_class.__name__}, '
+        f'but got {type(e).__name__}: {e}'
+    )
diff --git a/staticlibs/testutils/host/python/mdns_utils.py b/staticlibs/testutils/host/python/mdns_utils.py
index 1234e54605..315762e5e1 100644
--- a/staticlibs/testutils/host/python/mdns_utils.py
+++ b/staticlibs/testutils/host/python/mdns_utils.py
@@ -23,10 +23,10 @@ def assume_mdns_test_preconditions(
   discovery = discovery_device.connectivity_multi_devices_snippet
 
   asserts.skip_if(
-      not advertising.isAtLeastT(), "Advertising device SDK is lower than T."
+      not advertising.isAtLeastT(), 'Advertising device SDK is lower than T.'
   )
   asserts.skip_if(
-      not discovery.isAtLeastT(), "Discovery device SDK is lower than T."
+      not discovery.isAtLeastT(), 'Discovery device SDK is lower than T.'
   )
 
 
diff --git a/staticlibs/testutils/host/python/multi_devices_test_base.py b/staticlibs/testutils/host/python/multi_devices_test_base.py
index 72bac0cb2b..a0b15ccd98 100644
--- a/staticlibs/testutils/host/python/multi_devices_test_base.py
+++ b/staticlibs/testutils/host/python/multi_devices_test_base.py
@@ -24,11 +24,13 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 
+from mobly import asserts
 from mobly import base_test
 from mobly import utils
 from mobly.controllers import android_device
+from net_tests_utils.host.python import adb_utils
 
-CONNECTIVITY_MULTI_DEVICES_SNIPPET_PACKAGE = "com.google.snippet.connectivity"
+CONNECTIVITY_MULTI_DEVICES_SNIPPET_PACKAGE = 'com.google.snippet.connectivity'
 
 
 class MultiDevicesTestBase(base_test.BaseTestClass):
@@ -39,9 +41,22 @@ class MultiDevicesTestBase(base_test.BaseTestClass):
         android_device, min_number=2
     )
 
+    if self.clientDevice.is_adb_root:
+      adb_utils.unroot(self.clientDevice)
+
+    if self.serverDevice.is_adb_root:
+      adb_utils.unroot(self.serverDevice)
+
+    asserts.assert_false(
+        self.clientDevice.is_adb_root, 'client device should be unroot'
+    )
+    asserts.assert_false(
+        self.serverDevice.is_adb_root, 'server device should be unroot'
+    )
+
     def setup_device(device):
       device.load_snippet(
-          "connectivity_multi_devices_snippet",
+          'connectivity_multi_devices_snippet',
           CONNECTIVITY_MULTI_DEVICES_SNIPPET_PACKAGE,
       )
 
diff --git a/staticlibs/testutils/host/python/tether_utils.py b/staticlibs/testutils/host/python/tether_utils.py
index 710f8a80a7..5c22e265d2 100644
--- a/staticlibs/testutils/host/python/tether_utils.py
+++ b/staticlibs/testutils/host/python/tether_utils.py
@@ -32,7 +32,7 @@ def generate_uuid32_base64() -> str:
       str: The Base64-encoded UUID32 string. Which is 22 characters.
   """
   # Strip padding characters to make it safer for hotspot name length limit.
-  return base64.b64encode(uuid.uuid1().bytes).decode("utf-8").strip("=")
+  return base64.b64encode(uuid.uuid1().bytes).decode('utf-8').strip('=')
 
 
 def assume_hotspot_test_preconditions(
@@ -44,23 +44,23 @@ def assume_hotspot_test_preconditions(
   client = client_device.connectivity_multi_devices_snippet
 
   # Assert pre-conditions specific to each upstream type.
-  asserts.skip_if(not client.hasWifiFeature(), "Client requires Wifi feature")
+  asserts.skip_if(not client.hasWifiFeature(), 'Client requires Wifi feature')
   asserts.skip_if(
-      not server.hasHotspotFeature(), "Server requires hotspot feature"
+      not server.hasHotspotFeature(), 'Server requires hotspot feature'
   )
   if upstream_type == UpstreamType.CELLULAR:
     asserts.skip_if(
-        not server.hasTelephonyFeature(), "Server requires Telephony feature"
+        not server.hasTelephonyFeature(), 'Server requires Telephony feature'
     )
   elif upstream_type == UpstreamType.WIFI:
     asserts.skip_if(
         not server.isStaApConcurrencySupported(),
-        "Server requires Wifi AP + STA concurrency",
+        'Server requires Wifi AP + STA concurrency',
     )
   elif upstream_type == UpstreamType.NONE:
     pass
   else:
-    raise ValueError(f"Invalid upstream type: {upstream_type}")
+    raise ValueError(f'Invalid upstream type: {upstream_type}')
 
 
 def setup_hotspot_and_client_for_upstream_type(
@@ -84,11 +84,11 @@ def setup_hotspot_and_client_for_upstream_type(
   elif upstream_type == UpstreamType.NONE:
     pass
   else:
-    raise ValueError(f"Invalid upstream type: {upstream_type}")
+    raise ValueError(f'Invalid upstream type: {upstream_type}')
 
   # Generate ssid/passphrase with random characters to make sure nearby devices won't
   # connect unexpectedly. Note that total length of ssid cannot go over 32.
-  test_ssid = "HOTSPOT-" + generate_uuid32_base64()
+  test_ssid = 'HOTSPOT-' + generate_uuid32_base64()
   test_passphrase = generate_uuid32_base64()
 
   # Create a hotspot with fixed SSID and password.
diff --git a/staticlibs/testutils/host/python/wifip2p_utils.py b/staticlibs/testutils/host/python/wifip2p_utils.py
index ef6af75708..4b7ebbfacb 100644
--- a/staticlibs/testutils/host/python/wifip2p_utils.py
+++ b/staticlibs/testutils/host/python/wifip2p_utils.py
@@ -25,13 +25,13 @@ def assume_wifi_p2p_test_preconditions(
   client = client_device.connectivity_multi_devices_snippet
 
   # Assert pre-conditions
-  asserts.skip_if(not server.hasWifiFeature(), "Server requires Wifi feature")
-  asserts.skip_if(not client.hasWifiFeature(), "Client requires Wifi feature")
+  asserts.skip_if(not server.hasWifiFeature(), 'Server requires Wifi feature')
+  asserts.skip_if(not client.hasWifiFeature(), 'Client requires Wifi feature')
   asserts.skip_if(
-      not server.isP2pSupported(), "Server requires Wi-fi P2P feature"
+      not server.isP2pSupported(), 'Server requires Wi-fi P2P feature'
   )
   asserts.skip_if(
-      not client.isP2pSupported(), "Client requires Wi-fi P2P feature"
+      not client.isP2pSupported(), 'Client requires Wi-fi P2P feature'
   )
 
 
@@ -51,34 +51,20 @@ def setup_wifi_p2p_server_and_client(
   client_name = client.getDeviceName()
 
   # Generate Wi-Fi P2P group passphrase with random characters.
-  group_name = "DIRECT-" + tether_utils.generate_uuid32_base64()
+  # network name must starts with prefix "DIRECT-", followed by any two
+  # random chars from the set ('A' - 'Z', 'a' - 'z', '0' - '9')
+  # This follows the documentation on WifiP2pConfig.Builder#setNetworkName.
+  group_name = 'DIRECT-XY' + tether_utils.generate_uuid32_base64()
   group_passphrase = tether_utils.generate_uuid32_base64()
 
   # Server creates a Wi-Fi P2P group
   server.createGroup(group_name, group_passphrase)
 
-  # Start Wi-Fi P2p peers discovery on both devices
-  server.startPeersDiscovery()
-  client.startPeersDiscovery()
-
-  # Ensure the target device has been discovered
-  server_address = client.ensureDeviceDiscovered(server_name)
-  client_address = server.ensureDeviceDiscovered(client_name)
-
-  # Server invites the device to the group
-  server.inviteDeviceToGroup(group_name, group_passphrase, client_address)
-
-  # Wait for a p2p connection changed intent to ensure the invitation has been
-  # received.
-  client.waitForP2pConnectionChanged(True, group_name)
-  # Accept the group invitation
-  client.acceptGroupInvitation(server_address)
-
-  # Server waits for connection request from client and accept joining
-  server.waitForPeerConnectionRequestAndAcceptJoining(client_address)
+  # Client connects to the group
+  client.connectToGroup(group_name, group_passphrase)
 
   # Wait for a p2p connection changed intent to ensure joining the group
-  client.waitForP2pConnectionChanged(False, group_name)
+  client.waitForP2pConnectionChanged(group_name)
 
   # Ensure Wi-Fi P2P connected on both devices
   client.ensureDeviceConnected(server_name)
diff --git a/staticlibs/testutils/hostdevice/com/android/net/module/util/TrackRecord.kt b/staticlibs/testutils/hostdevice/com/android/net/module/util/TrackRecord.kt
index f24e4f184d..123efd7283 100644
--- a/staticlibs/testutils/hostdevice/com/android/net/module/util/TrackRecord.kt
+++ b/staticlibs/testutils/hostdevice/com/android/net/module/util/TrackRecord.kt
@@ -255,7 +255,7 @@ class ArrayTrackRecord<E> : TrackRecord<E> {
          * the last element in the queue if null is returned. This means this method will always
          * skip elements that do not match the predicate, even if it returns null.
          *
-         * This method can only be used by the thread that created this ManagedRecordingQueue.
+         * This method can only be used by the thread that created this ReadHead.
          * If used on another thread, this throws IllegalStateException.
          *
          * @param timeoutMs how long, in milliseconds, to wait at most (best effort approximation).
@@ -278,8 +278,57 @@ class ArrayTrackRecord<E> : TrackRecord<E> {
         }
 
         /**
-         * Returns a list of events that were observed since the last time poll() was called on this
-         * ReadHead.
+         * Returns the first element after the mark, optionally blocking until one is available,
+         * or null if no such element can be found within the timeout.
+         * If a predicate is given, only elements matching the predicate are returned.
+         *
+         * Upon return, the mark will be advanced up to the point of the returned element (or
+         * after the last element in the queue if not found) if and only if that element was
+         * found after the current mark. This means this method will always skip elements that
+         * do not match the predicate even if it returns null, and repeated calls with the
+         * same position will advance the mark up to the last of the found elements.
+         *
+         * This method can only be used by the thread that created this ReadHead.
+         * If used on another thread, this throws IllegalStateException.
+         *
+         * Typical usage would be to check for multiple elements in any order. For example,
+         * val mark = readHead.mark
+         * readHead.poll(timeout, mark) { it matches condition 1 }
+         * readHead.poll(timeout, mark) { it matches condition 2 }
+         * readHead.poll(timeout, mark) { it matches condition 3 }
+         * The above would check that starting at the mark, there are three events, one matching
+         * each condition, in any order. A caller could further check that there were no other
+         * event beside the 3 checked with something like
+         * assertEquals(readHead.mark - mark, 3)
+         *
+         * @param timeoutMs how long, in milliseconds, to wait at most (best effort approximation).
+         * @param pos the position in the underlying track record where to start the search.
+         * @param predicate a predicate to filter elements to be returned.
+         * @return an element matching the predicate, or null if timeout.
+         */
+        override fun poll(timeoutMs: Long, pos: Int, predicate: (E) -> Boolean): E? {
+            val stamp = slock.tryWriteLock()
+            if (0L == stamp) concurrentAccessDetected()
+            pollMark = readHead
+            try {
+                lock.withLock {
+                    val index = pollForIndexReadLocked(timeoutMs, pos, predicate)
+                    when {
+                        index < 0 -> readHead = size
+                        index >= readHead -> readHead = index + 1
+                        // else do nothing, the element was found prior to the read head so
+                        // don't move the read head
+                    }
+                    return getOrNull(index)
+                }
+            } finally {
+                slock.unlockWrite(stamp)
+            }
+        }
+
+        /**
+         * Returns a list of events that were observed since before the last poll() operation on
+         * this ReadHead.
          *
          * @return list of events since poll() was called.
          */
diff --git a/staticlibs/testutils/hostdevice/com/android/testutils/MiscAsserts.kt b/staticlibs/testutils/hostdevice/com/android/testutils/MiscAsserts.kt
index 176546a4c0..de797b0ba4 100644
--- a/staticlibs/testutils/hostdevice/com/android/testutils/MiscAsserts.kt
+++ b/staticlibs/testutils/hostdevice/com/android/testutils/MiscAsserts.kt
@@ -142,4 +142,12 @@ fun assertEventuallyTrue(
         }
         Thread.sleep(pollIntervalMs)
     }
-}
\ No newline at end of file
+}
+
+// "Nothing" is the return type to declare a function never returns a value. This is useful
+// because the compiler will know the branch of the code calling this does not return, which
+// lets check exhaustivity, infer return types, nullability and smart casts.
+fun failWithErrorReason(errorMsg: String?, errorReason: String): Nothing {
+    val message = if (errorMsg != null) "$errorMsg : $errorReason" else errorReason
+    fail(message)
+}
diff --git a/tests/common/Android.bp b/tests/common/Android.bp
index 60a02fb7be..4ecb23c043 100644
--- a/tests/common/Android.bp
+++ b/tests/common/Android.bp
@@ -155,6 +155,10 @@ java_defaults {
         // if sdk_version="" this gets automatically included, but here we need to add manually.
         "framework-res",
     ],
+    // Tests must check a large number of deprecated methods and warning about it
+    // sends hundreds of warning lines flooding the useful warnings.
+    kotlincflags: ["-Xsuppress-warning=DEPRECATION"],
+    // TODO: add "-Xwarning-level=CheckResult:error" when Kotlin 2.2.0 is out
 }
 
 // defaults for tests that need to build against framework-connectivity's @hide APIs, but also
@@ -178,6 +182,10 @@ java_defaults {
         // if sdk_version="" this gets automatically included, but here we need to add manually.
         "framework-res",
     ],
+    // Tests must check a large number of deprecated methods and warning about it
+    // sends hundreds of warning lines flooding the useful warnings.
+    kotlincflags: ["-Xsuppress-warning=DEPRECATION"],
+    // TODO: add "-Xwarning-level=CheckResult:error" when Kotlin 2.2.0 is out
     defaults_visibility: ["//packages/modules/Connectivity/tests:__subpackages__"],
 }
 
diff --git a/tests/common/java/android/net/EthernetNetworkManagementExceptionTest.java b/tests/common/java/android/net/EthernetNetworkManagementExceptionTest.java
index 84b6e54daa..c7dfb7d037 100644
--- a/tests/common/java/android/net/EthernetNetworkManagementExceptionTest.java
+++ b/tests/common/java/android/net/EthernetNetworkManagementExceptionTest.java
@@ -16,11 +16,12 @@
 
 package android.net;
 
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
 import static com.android.testutils.ParcelUtils.assertParcelingIsLossless;
 
 import static org.junit.Assert.assertEquals;
 
+import android.os.Build;
+
 import androidx.test.filters.SmallTest;
 
 import com.android.testutils.DevSdkIgnoreRule;
@@ -29,7 +30,7 @@ import com.android.testutils.DevSdkIgnoreRunner;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-@DevSdkIgnoreRule.IgnoreUpTo(SC_V2) // TODO: Use to Build.VERSION_CODES.SC_V2 when available
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 @RunWith(DevSdkIgnoreRunner.class)
 @SmallTest
 public class EthernetNetworkManagementExceptionTest {
diff --git a/tests/common/java/android/net/NetworkCapabilitiesTest.java b/tests/common/java/android/net/NetworkCapabilitiesTest.java
index 3fc2af0fb0..499b52d3be 100644
--- a/tests/common/java/android/net/NetworkCapabilitiesTest.java
+++ b/tests/common/java/android/net/NetworkCapabilitiesTest.java
@@ -66,7 +66,6 @@ import static android.os.Process.INVALID_UID;
 import static com.android.modules.utils.build.SdkLevel.isAtLeastS;
 import static com.android.modules.utils.build.SdkLevel.isAtLeastT;
 import static com.android.modules.utils.build.SdkLevel.isAtLeastV;
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
 import static com.android.testutils.MiscAsserts.assertEmpty;
 import static com.android.testutils.MiscAsserts.assertThrows;
 import static com.android.testutils.ParcelUtils.assertParcelingIsLossless;
@@ -322,7 +321,7 @@ public class NetworkCapabilitiesTest {
         }
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testSetAllowedUids() {
         final NetworkCapabilities nc = new NetworkCapabilities();
         assertThrows(NullPointerException.class, () -> nc.setAllowedUids(null));
@@ -478,7 +477,7 @@ public class NetworkCapabilitiesTest {
         assertFalse(nr.satisfiedByNetworkCapabilities(new NetworkCapabilities()));
     }
 
-    @Test @IgnoreUpTo(SC_V2) // TODO: Use to Build.VERSION_CODES.SC_V2 when available
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testPrioritizeLatencyAndBandwidth() {
         NetworkCapabilities netCap = new NetworkCapabilities();
         netCap.addCapability(NET_CAPABILITY_PRIORITIZE_LATENCY);
@@ -927,7 +926,7 @@ public class NetworkCapabilitiesTest {
         } catch (IllegalStateException expected) { }
     }
 
-    @Test @IgnoreUpTo(SC_V2) // TODO: Use to Build.VERSION_CODES.SC_V2 when available
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testEnterpriseId() {
         final NetworkCapabilities nc1 = new NetworkCapabilities.Builder()
                 .addCapability(NET_CAPABILITY_ENTERPRISE)
@@ -1522,7 +1521,7 @@ public class NetworkCapabilitiesTest {
         assertTrue(reservationNc.satisfiedByNetworkCapabilities(offerNc));
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testReservationIdEquals() {
         final NetworkCapabilities nc = new NetworkCapabilities();
         nc.setReservationId(42);
diff --git a/tests/common/java/android/net/NetworkProviderTest.kt b/tests/common/java/android/net/NetworkProviderTest.kt
index 0d35960057..ef1cbcc9b1 100644
--- a/tests/common/java/android/net/NetworkProviderTest.kt
+++ b/tests/common/java/android/net/NetworkProviderTest.kt
@@ -21,9 +21,9 @@ import android.content.Context
 import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_VCN_MANAGED
 import android.net.NetworkCapabilities.NET_CAPABILITY_TRUSTED
 import android.net.NetworkCapabilities.TRANSPORT_TEST
-import android.net.NetworkProviderTest.TestNetworkCallback.CallbackEntry.OnUnavailable
-import android.net.NetworkProviderTest.TestNetworkProvider.CallbackEntry.OnNetworkRequestWithdrawn
-import android.net.NetworkProviderTest.TestNetworkProvider.CallbackEntry.OnNetworkRequested
+import android.net.NetworkProviderTest.TestNetworkCallback.Event.OnUnavailable
+import android.net.NetworkProviderTest.TestNetworkProvider.Event.OnNetworkRequestWithdrawn
+import android.net.NetworkProviderTest.TestNetworkProvider.Event.OnNetworkRequested
 import android.os.Build
 import android.os.Handler
 import android.os.HandlerThread
@@ -85,15 +85,15 @@ class NetworkProviderTest {
     private class TestNetworkProvider(context: Context, looper: Looper) :
             NetworkProvider(context, looper, PROVIDER_NAME) {
         private val TAG = this::class.simpleName
-        private val seenEvents = ArrayTrackRecord<CallbackEntry>().newReadHead()
+        private val seenEvents = ArrayTrackRecord<Event>().newReadHead()
 
-        sealed class CallbackEntry {
+        sealed class Event {
             data class OnNetworkRequested(
                 val request: NetworkRequest,
                 val score: Int,
                 val id: Int
-            ) : CallbackEntry()
-            data class OnNetworkRequestWithdrawn(val request: NetworkRequest) : CallbackEntry()
+            ) : Event()
+            data class OnNetworkRequestWithdrawn(val request: NetworkRequest) : Event()
         }
 
         override fun onNetworkRequested(request: NetworkRequest, score: Int, id: Int) {
@@ -106,7 +106,7 @@ class NetworkProviderTest {
             seenEvents.add(OnNetworkRequestWithdrawn(request))
         }
 
-        inline fun <reified T : CallbackEntry> eventuallyExpectCallbackThat(
+        inline fun <reified T : Event> eventuallyExpectCallbackThat(
             crossinline predicate: (T) -> Boolean
         ) = seenEvents.poll(DEFAULT_TIMEOUT_MS) { it is T && predicate(it) }
                 ?: fail("Did not receive callback after ${DEFAULT_TIMEOUT_MS}ms")
@@ -356,16 +356,16 @@ class NetworkProviderTest {
     }
 
     private class TestNetworkCallback : ConnectivityManager.NetworkCallback() {
-        private val seenEvents = ArrayTrackRecord<CallbackEntry>().newReadHead()
-        sealed class CallbackEntry {
-            object OnUnavailable : CallbackEntry()
+        private val seenEvents = ArrayTrackRecord<Event>().newReadHead()
+        sealed class Event {
+            object OnUnavailable : Event()
         }
 
         override fun onUnavailable() {
             seenEvents.add(OnUnavailable)
         }
 
-        inline fun <reified T : CallbackEntry> expectCallback(
+        inline fun <reified T : Event> expectCallback(
             crossinline predicate: (T) -> Boolean
         ) = seenEvents.poll(DEFAULT_TIMEOUT_MS) { it is T && predicate(it) }
     }
diff --git a/tests/common/java/android/net/NetworkTest.java b/tests/common/java/android/net/NetworkTest.java
index 86d2463ce2..580beabe63 100644
--- a/tests/common/java/android/net/NetworkTest.java
+++ b/tests/common/java/android/net/NetworkTest.java
@@ -32,6 +32,7 @@ import com.android.testutils.ConnectivityModuleTest;
 import com.android.testutils.DevSdkIgnoreRule;
 import com.android.testutils.DevSdkIgnoreRule.IgnoreAfter;
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo;
+import com.android.testutils.ParcelUtils;
 
 import org.junit.Rule;
 import org.junit.Test;
@@ -200,4 +201,37 @@ public class NetworkTest {
         assertNotEquals(copy.netId, copy.getNetIdForResolv());
         assertNotEquals(mNetwork.getNetIdForResolv(), copy.getNetIdForResolv());
     }
+
+    // Connectivity module was not supported until S
+    @Test @IgnoreUpTo(Build.VERSION_CODES.R)
+    @ConnectivityModuleTest
+    public void testGetNonPrivateDnsBypassingCopy() {
+        final Network bypass = mNetwork.getPrivateDnsBypassingCopy();
+        final Network nonBypass = bypass.getPrivateDnsNonBypassingCopy();
+        assertEquals(mNetwork.netId, nonBypass.netId);
+        assertEquals(nonBypass.netId, nonBypass.getNetIdForResolv());
+        assertEquals(mNetwork.getNetIdForResolv(), nonBypass.getNetIdForResolv());
+        assertNotEquals(mNetwork.getNetIdForResolv(), bypass.getNetIdForResolv());
+    }
+
+    // Only run this test on V and below
+    @Test @IgnoreAfter(Build.VERSION_CODES.VANILLA_ICE_CREAM)
+    @ConnectivityModuleTest
+    public void testParcelingRoundTripBeforeB() {
+        // Before B, the netID for resolv is not parceled.
+        final Network bypass =
+                ParcelUtils.parcelingRoundTrip(mNetwork.getPrivateDnsBypassingCopy());
+        assertEquals(mNetwork.netId, bypass.netId);
+        assertEquals(mNetwork.getNetIdForResolv(), bypass.getNetIdForResolv());
+    }
+
+    // Only run this test on B and after
+    @Test @IgnoreUpTo(Build.VERSION_CODES.VANILLA_ICE_CREAM)
+    @ConnectivityModuleTest
+    public void testParcelingRoundTripFromB() {
+        final Network bypass =
+                ParcelUtils.parcelingRoundTrip(mNetwork.getPrivateDnsBypassingCopy());
+        assertEquals(mNetwork.netId, bypass.netId);
+        assertNotEquals(mNetwork.getNetIdForResolv(), bypass.getNetIdForResolv());
+    }
 }
diff --git a/tests/common/java/android/net/netstats/NetworkStatsCollectionTest.kt b/tests/common/java/android/net/netstats/NetworkStatsCollectionTest.kt
index 368a519552..2b7e52fa9d 100644
--- a/tests/common/java/android/net/netstats/NetworkStatsCollectionTest.kt
+++ b/tests/common/java/android/net/netstats/NetworkStatsCollectionTest.kt
@@ -19,10 +19,10 @@ package android.net.netstats
 import android.net.NetworkIdentity
 import android.net.NetworkStatsCollection
 import android.net.NetworkStatsHistory
+import android.os.Build
 import androidx.test.filters.SmallTest
 import com.android.testutils.ConnectivityModuleTest
 import com.android.testutils.DevSdkIgnoreRule
-import com.android.testutils.SC_V2
 import org.junit.Rule
 import org.junit.Test
 import org.junit.runner.RunWith
@@ -36,7 +36,7 @@ import kotlin.test.fail
 class NetworkStatsCollectionTest {
     @Rule
     @JvmField
-    val ignoreRule = DevSdkIgnoreRule(ignoreClassUpTo = SC_V2)
+    val ignoreRule = DevSdkIgnoreRule(ignoreClassUpTo = Build.VERSION_CODES.S_V2)
 
     @Test
     fun testBuilder() {
diff --git a/tests/common/java/android/net/netstats/NetworkStatsHistoryTest.kt b/tests/common/java/android/net/netstats/NetworkStatsHistoryTest.kt
index a6c9f3cebd..a001dfcac2 100644
--- a/tests/common/java/android/net/netstats/NetworkStatsHistoryTest.kt
+++ b/tests/common/java/android/net/netstats/NetworkStatsHistoryTest.kt
@@ -17,11 +17,11 @@
 package android.net.netstats
 
 import android.net.NetworkStatsHistory
+import android.os.Build
 import android.text.format.DateUtils
 import androidx.test.filters.SmallTest
 import com.android.testutils.ConnectivityModuleTest
 import com.android.testutils.DevSdkIgnoreRule
-import com.android.testutils.SC_V2
 import org.junit.Rule
 import org.junit.Test
 import org.junit.runner.RunWith
@@ -34,7 +34,7 @@ import kotlin.test.assertEquals
 class NetworkStatsHistoryTest {
     @Rule
     @JvmField
-    val ignoreRule = DevSdkIgnoreRule(ignoreClassUpTo = SC_V2)
+    val ignoreRule = DevSdkIgnoreRule(ignoreClassUpTo = Build.VERSION_CODES.S_V2)
 
     @Test
     fun testBuilder() {
diff --git a/tests/common/java/android/net/netstats/NetworkTemplateTest.kt b/tests/common/java/android/net/netstats/NetworkTemplateTest.kt
index 1b55be9725..0eb28afbf6 100644
--- a/tests/common/java/android/net/netstats/NetworkTemplateTest.kt
+++ b/tests/common/java/android/net/netstats/NetworkTemplateTest.kt
@@ -16,6 +16,8 @@
 
 package android.net.netstats
 
+import android.net.NetworkCapabilities.TRANSPORT_CELLULAR
+import android.net.NetworkCapabilities.TRANSPORT_WIFI
 import android.net.NetworkStats.DEFAULT_NETWORK_ALL
 import android.net.NetworkStats.METERED_ALL
 import android.net.NetworkStats.METERED_YES
@@ -30,11 +32,11 @@ import android.net.NetworkTemplate.MATCH_PROXY
 import android.net.NetworkTemplate.MATCH_WIFI
 import android.net.NetworkTemplate.NETWORK_TYPE_ALL
 import android.net.NetworkTemplate.OEM_MANAGED_ALL
+import android.net.NetworkTemplate.TRANSPORT_TYPES_ALL
 import android.os.Build
 import android.telephony.TelephonyManager
 import com.android.testutils.ConnectivityModuleTest
 import com.android.testutils.DevSdkIgnoreRule
-import com.android.testutils.SC_V2
 import kotlin.test.assertEquals
 import kotlin.test.assertFailsWith
 import org.junit.Rule
@@ -45,13 +47,14 @@ import org.junit.runners.JUnit4
 private const val TEST_IMSI1 = "imsi"
 private const val TEST_WIFI_KEY1 = "wifiKey1"
 private const val TEST_WIFI_KEY2 = "wifiKey2"
+private const val INVALID_TRANSPORT = 100
 
 @RunWith(JUnit4::class)
 @ConnectivityModuleTest
 class NetworkTemplateTest {
     @Rule
     @JvmField
-    val ignoreRule = DevSdkIgnoreRule(ignoreClassUpTo = SC_V2)
+    val ignoreRule = DevSdkIgnoreRule(ignoreClassUpTo = Build.VERSION_CODES.S_V2)
 
     @Test
     fun testBuilderMatchRules() {
@@ -67,9 +70,17 @@ class NetworkTemplateTest {
         listOf(MATCH_MOBILE, MATCH_CARRIER).forEach { matchRule ->
             NetworkTemplate.Builder(matchRule).setSubscriberIds(setOf(TEST_IMSI1))
                     .setMeteredness(METERED_YES).build().let {
-                        val expectedTemplate = NetworkTemplate(matchRule, arrayOf(TEST_IMSI1),
-                                emptyArray<String>(), METERED_YES, ROAMING_ALL, DEFAULT_NETWORK_ALL,
-                                NETWORK_TYPE_ALL, OEM_MANAGED_ALL)
+                        val expectedTemplate = NetworkTemplate(
+                                matchRule,
+                                arrayOf(TEST_IMSI1),
+                                emptyArray<String>() /*wifiNetworkKey*/,
+                                METERED_YES,
+                                ROAMING_ALL,
+                                DEFAULT_NETWORK_ALL,
+                                NETWORK_TYPE_ALL,
+                                OEM_MANAGED_ALL,
+                                TRANSPORT_TYPES_ALL
+                        )
                         assertEquals(expectedTemplate, it)
                     }
         }
@@ -79,9 +90,17 @@ class NetworkTemplateTest {
         listOf(MATCH_MOBILE, MATCH_CARRIER).forEach { matchRule ->
             NetworkTemplate.Builder(matchRule).setSubscriberIds(setOf(TEST_IMSI1))
                     .setRoaming(ROAMING_YES).setMeteredness(METERED_YES).build().let {
-                        val expectedTemplate = NetworkTemplate(matchRule, arrayOf(TEST_IMSI1),
-                                emptyArray<String>(), METERED_YES, ROAMING_YES, DEFAULT_NETWORK_ALL,
-                                NETWORK_TYPE_ALL, OEM_MANAGED_ALL)
+                        val expectedTemplate = NetworkTemplate(
+                                matchRule,
+                                arrayOf(TEST_IMSI1),
+                                emptyArray<String>() /*wifiNetworkKey*/,
+                                METERED_YES,
+                                ROAMING_YES,
+                                DEFAULT_NETWORK_ALL,
+                                NETWORK_TYPE_ALL,
+                                OEM_MANAGED_ALL,
+                                TRANSPORT_TYPES_ALL
+                        )
                         assertEquals(expectedTemplate, it)
                     }
         }
@@ -103,14 +122,15 @@ class NetworkTemplateTest {
         } else {
             NetworkTemplate.Builder(MATCH_MOBILE).setSubscriberIds(setOf(null)).build().let {
                 val expectedTemplate = NetworkTemplate(
-                    MATCH_MOBILE,
-                    arrayOfNulls<String>(1) /*subscriberIds*/,
-                    emptyArray<String>() /*wifiNetworkKey*/,
-                    METERED_ALL,
-                    ROAMING_ALL,
-                    DEFAULT_NETWORK_ALL,
-                    NETWORK_TYPE_ALL,
-                    OEM_MANAGED_ALL
+                        MATCH_MOBILE,
+                        arrayOfNulls<String>(1) /*subscriberIds*/,
+                        emptyArray<String>() /*wifiNetworkKey*/,
+                        METERED_ALL,
+                        ROAMING_ALL,
+                        DEFAULT_NETWORK_ALL,
+                        NETWORK_TYPE_ALL,
+                        OEM_MANAGED_ALL,
+                        TRANSPORT_TYPES_ALL
                 )
                 assertEquals(expectedTemplate, it)
             }
@@ -119,10 +139,17 @@ class NetworkTemplateTest {
         // Verify template which matches metered cellular networks,
         // regardless of IMSI. See buildTemplateMobileWildcard.
         NetworkTemplate.Builder(MATCH_MOBILE).setMeteredness(METERED_YES).build().let {
-            val expectedTemplate = NetworkTemplate(MATCH_MOBILE,
-                    emptyArray<String>() /*subscriberIds*/, emptyArray<String>() /*wifiNetworkKey*/,
-                    METERED_YES, ROAMING_ALL, DEFAULT_NETWORK_ALL, NETWORK_TYPE_ALL,
-                    OEM_MANAGED_ALL)
+            val expectedTemplate = NetworkTemplate(
+                    MATCH_MOBILE,
+                    emptyArray<String>() /*subscriberIds*/,
+                    emptyArray<String>() /*wifiNetworkKey*/,
+                    METERED_YES,
+                    ROAMING_ALL,
+                    DEFAULT_NETWORK_ALL,
+                    NETWORK_TYPE_ALL,
+                    OEM_MANAGED_ALL,
+                    TRANSPORT_TYPES_ALL
+            )
             assertEquals(expectedTemplate, it)
         }
 
@@ -130,18 +157,34 @@ class NetworkTemplateTest {
         NetworkTemplate.Builder(MATCH_MOBILE).setSubscriberIds(setOf(TEST_IMSI1))
                 .setMeteredness(METERED_YES).setRatType(TelephonyManager.NETWORK_TYPE_UMTS)
                 .build().let {
-                    val expectedTemplate = NetworkTemplate(MATCH_MOBILE, arrayOf(TEST_IMSI1),
-                            emptyArray<String>(), METERED_YES, ROAMING_ALL, DEFAULT_NETWORK_ALL,
-                            TelephonyManager.NETWORK_TYPE_UMTS, OEM_MANAGED_ALL)
+                    val expectedTemplate = NetworkTemplate(
+                            MATCH_MOBILE,
+                            arrayOf(TEST_IMSI1),
+                            emptyArray<String>() /*wifiNetworkKey*/,
+                            METERED_YES,
+                            ROAMING_ALL,
+                            DEFAULT_NETWORK_ALL,
+                            TelephonyManager.NETWORK_TYPE_UMTS,
+                            OEM_MANAGED_ALL,
+                            TRANSPORT_TYPES_ALL
+                    )
                     assertEquals(expectedTemplate, it)
                 }
 
         // Verify template which matches all wifi networks,
         // regardless of Wifi Network Key. See buildTemplateWifiWildcard and buildTemplateWifi.
         NetworkTemplate.Builder(MATCH_WIFI).build().let {
-            val expectedTemplate = NetworkTemplate(MATCH_WIFI,
-                    emptyArray<String>() /*subscriberIds*/, emptyArray<String>(), METERED_ALL,
-                    ROAMING_ALL, DEFAULT_NETWORK_ALL, NETWORK_TYPE_ALL, OEM_MANAGED_ALL)
+            val expectedTemplate = NetworkTemplate(
+                    MATCH_WIFI,
+                    emptyArray<String>() /*subscriberIds*/,
+                    emptyArray<String>() /*wifiNetworkKey*/,
+                    METERED_ALL,
+                    ROAMING_ALL,
+                    DEFAULT_NETWORK_ALL,
+                    NETWORK_TYPE_ALL,
+                    OEM_MANAGED_ALL,
+                    TRANSPORT_TYPES_ALL
+            )
             assertEquals(expectedTemplate, it)
         }
 
@@ -149,9 +192,17 @@ class NetworkTemplateTest {
         // See buildTemplateWifi(wifiNetworkKey).
         NetworkTemplate.Builder(MATCH_WIFI).setWifiNetworkKeys(setOf(TEST_WIFI_KEY1)).build().let {
             val expectedTemplate =
-                    NetworkTemplate(MATCH_WIFI, emptyArray<String>() /*subscriberIds*/,
-                    arrayOf(TEST_WIFI_KEY1), METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL,
-                    NETWORK_TYPE_ALL, OEM_MANAGED_ALL)
+                    NetworkTemplate(
+                            MATCH_WIFI,
+                            emptyArray<String>() /*subscriberIds*/,
+                            arrayOf(TEST_WIFI_KEY1),
+                            METERED_ALL,
+                            ROAMING_ALL,
+                            DEFAULT_NETWORK_ALL,
+                            NETWORK_TYPE_ALL,
+                            OEM_MANAGED_ALL,
+                            TRANSPORT_TYPES_ALL
+                    )
             assertEquals(expectedTemplate, it)
         }
 
@@ -159,9 +210,17 @@ class NetworkTemplateTest {
         // given Wifi Network Key, and IMSI. See buildTemplateWifi(wifiNetworkKey, subscriberId).
         NetworkTemplate.Builder(MATCH_WIFI).setSubscriberIds(setOf(TEST_IMSI1))
                 .setWifiNetworkKeys(setOf(TEST_WIFI_KEY1)).build().let {
-                    val expectedTemplate = NetworkTemplate(MATCH_WIFI, arrayOf(TEST_IMSI1),
-                            arrayOf(TEST_WIFI_KEY1), METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL,
-                            NETWORK_TYPE_ALL, OEM_MANAGED_ALL)
+                    val expectedTemplate = NetworkTemplate(
+                            MATCH_WIFI,
+                            arrayOf(TEST_IMSI1),
+                            arrayOf(TEST_WIFI_KEY1),
+                            METERED_ALL,
+                            ROAMING_ALL,
+                            DEFAULT_NETWORK_ALL,
+                            NETWORK_TYPE_ALL,
+                            OEM_MANAGED_ALL,
+                            TRANSPORT_TYPES_ALL
+                    )
                     assertEquals(expectedTemplate, it)
                 }
 
@@ -169,10 +228,17 @@ class NetworkTemplateTest {
         // See buildTemplateEthernet and buildTemplateBluetooth.
         listOf(MATCH_ETHERNET, MATCH_BLUETOOTH, MATCH_PROXY).forEach { matchRule ->
             NetworkTemplate.Builder(matchRule).build().let {
-                val expectedTemplate = NetworkTemplate(matchRule,
-                        emptyArray<String>() /*subscriberIds*/, emptyArray<String>(),
-                        METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, NETWORK_TYPE_ALL,
-                        OEM_MANAGED_ALL)
+                val expectedTemplate = NetworkTemplate(
+                        matchRule,
+                        emptyArray<String>() /*subscriberIds*/,
+                        emptyArray<String>() /*wifiNetworkKey*/,
+                        METERED_ALL,
+                        ROAMING_ALL,
+                        DEFAULT_NETWORK_ALL,
+                        NETWORK_TYPE_ALL,
+                        OEM_MANAGED_ALL,
+                        TRANSPORT_TYPES_ALL
+                )
                 assertEquals(expectedTemplate, it)
             }
         }
@@ -183,15 +249,23 @@ class NetworkTemplateTest {
         // Verify template builder which generates same template with the given different
         // sequence keys.
         NetworkTemplate.Builder(MATCH_WIFI).setWifiNetworkKeys(
-                setOf(TEST_WIFI_KEY1, TEST_WIFI_KEY2)).build().let {
+                setOf(TEST_WIFI_KEY1, TEST_WIFI_KEY2)
+        ).build().let {
             val expectedTemplate = NetworkTemplate.Builder(MATCH_WIFI).setWifiNetworkKeys(
-                    setOf(TEST_WIFI_KEY2, TEST_WIFI_KEY1)).build()
+                    setOf(TEST_WIFI_KEY2, TEST_WIFI_KEY1)
+            ).build()
             assertEquals(expectedTemplate, it)
         }
 
         // Verify template which matches non-wifi networks with the given key is invalid.
-        listOf(MATCH_MOBILE, MATCH_CARRIER, MATCH_ETHERNET, MATCH_BLUETOOTH, -1,
-                Integer.MAX_VALUE).forEach { matchRule ->
+        listOf(
+                MATCH_MOBILE,
+                MATCH_CARRIER,
+                MATCH_ETHERNET,
+                MATCH_BLUETOOTH,
+                -1,
+                Integer.MAX_VALUE
+        ).forEach { matchRule ->
             assertFailsWith<IllegalArgumentException> {
                 NetworkTemplate.Builder(matchRule).setWifiNetworkKeys(setOf(TEST_WIFI_KEY1)).build()
             }
@@ -204,11 +278,68 @@ class NetworkTemplateTest {
 
         // Verify template which matches wifi wildcard with the given empty key set.
         NetworkTemplate.Builder(MATCH_WIFI).setWifiNetworkKeys(setOf<String>()).build().let {
-            val expectedTemplate = NetworkTemplate(MATCH_WIFI,
-                    emptyArray<String>() /*subscriberIds*/, emptyArray<String>(),
-                    METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, NETWORK_TYPE_ALL,
-                    OEM_MANAGED_ALL)
+            val expectedTemplate = NetworkTemplate(
+                    MATCH_WIFI,
+                    emptyArray<String>() /*subscriberIds*/,
+                    emptyArray<String>() /*wifiNetworkKey*/,
+                    METERED_ALL,
+                    ROAMING_ALL,
+                    DEFAULT_NETWORK_ALL,
+                    NETWORK_TYPE_ALL,
+                    OEM_MANAGED_ALL,
+                    TRANSPORT_TYPES_ALL
+            )
             assertEquals(expectedTemplate, it)
         }
     }
+
+    /**
+     * Tests the successful setting and retrieval of a transport type.
+     */
+    @Test
+    fun testSetAndGetTransportType() {
+        val template = NetworkTemplate.Builder()
+                .setTransportType(TRANSPORT_CELLULAR)
+                .build()
+
+        assertFailsWith<IllegalStateException> { template.matchRule }
+        assertEquals(TRANSPORT_CELLULAR, template.transportType)
+    }
+
+    /**
+     * Verifies that if `setTransportType` is called multiple times, the last value supplied is used.
+     */
+    @Test
+    fun testMultipleSetTransportTypeOverrides() {
+        val template = NetworkTemplate.Builder()
+                .setTransportType(TRANSPORT_CELLULAR).setTransportType(TRANSPORT_WIFI).build()
+        assertEquals(TRANSPORT_WIFI, template.transportType)
+    }
+
+    /**
+     * Verifies that building a template with a transport type set for a
+     * non-transport match rule throws an IllegalArgumentException.
+     */
+    @Test(expected = IllegalArgumentException::class)
+    fun testSetTransportType_withNonTransportRuleThrows() {
+        NetworkTemplate.Builder(MATCH_WIFI).setTransportType(TRANSPORT_CELLULAR)
+    }
+
+    /**
+     * Verifies that building a template with a non-transport match rule throws an
+     * IllegalStateException when getTransportType() calls.
+     */
+    @Test(expected = IllegalStateException::class)
+    fun testNonTransportRule_getTransportThrows() {
+        val template = NetworkTemplate.Builder(MATCH_WIFI).build()
+        template.transportType
+    }
+
+    /**
+     * Verifies template built with default constructor but doesn't specify transport throws.
+     */
+    @Test(expected = IllegalArgumentException::class)
+    fun testGetTransportType_whenNotSetThrows() {
+        NetworkTemplate.Builder().build()
+    }
 }
diff --git a/tests/cts/hostside/Android.bp b/tests/cts/hostside/Android.bp
index 0b4375a8a8..18032cddad 100644
--- a/tests/cts/hostside/Android.bp
+++ b/tests/cts/hostside/Android.bp
@@ -47,6 +47,7 @@ java_test_host {
     ],
     static_libs: [
         "modules-utils-build-testing",
+        "net-tests-utils-host-common",
     ],
     // Tag this module as a cts test artifact
     test_suites: [
diff --git a/tests/cts/hostside/AndroidTest.xml b/tests/cts/hostside/AndroidTest.xml
index 03ea17827f..6e13b88646 100644
--- a/tests/cts/hostside/AndroidTest.xml
+++ b/tests/cts/hostside/AndroidTest.xml
@@ -25,6 +25,7 @@
     <option name="config-descriptor:metadata" key="mainline-param" value="com.google.android.tethering.apex" />
 
     <target_preparer class="com.android.compatibility.common.tradefed.targetprep.LocationCheck" />
+    <target_preparer class="com.android.testutils.ConnectivityTestTargetPreparer" />
 
     <!-- Enabling change id ALLOW_TEST_API_ACCESS allows that package to access @TestApi methods -->
     <target_preparer class="com.android.tradefed.targetprep.RunCommandTargetPreparer">
diff --git a/tests/cts/hostside/app/src/com/android/cts/net/hostside/VpnTest.java b/tests/cts/hostside/app/src/com/android/cts/net/hostside/VpnTest.java
old mode 100755
new mode 100644
index 29e2ebb205..b6bceabb70
--- a/tests/cts/hostside/app/src/com/android/cts/net/hostside/VpnTest.java
+++ b/tests/cts/hostside/app/src/com/android/cts/net/hostside/VpnTest.java
@@ -19,8 +19,8 @@ package com.android.cts.net.hostside;
 import static android.Manifest.permission.MANAGE_TEST_NETWORKS;
 import static android.Manifest.permission.NETWORK_SETTINGS;
 import static android.Manifest.permission.READ_DEVICE_CONFIG;
-import static android.Manifest.permission.WRITE_DEVICE_CONFIG;
 import static android.Manifest.permission.WRITE_ALLOWLISTED_DEVICE_CONFIG;
+import static android.Manifest.permission.WRITE_DEVICE_CONFIG;
 import static android.content.Context.RECEIVER_EXPORTED;
 import static android.content.pm.PackageManager.FEATURE_TELEPHONY;
 import static android.content.pm.PackageManager.FEATURE_WIFI;
@@ -52,8 +52,8 @@ import static com.android.cts.net.hostside.VpnTest.TestSocketKeepaliveCallback.C
 import static com.android.cts.net.hostside.VpnTest.TestSocketKeepaliveCallback.CallbackType.ON_STARTED;
 import static com.android.cts.net.hostside.VpnTest.TestSocketKeepaliveCallback.CallbackType.ON_STOPPED;
 import static com.android.testutils.Cleanup.testAndCleanup;
-import static com.android.testutils.RecorderCallback.CallbackEntry.BLOCKED_STATUS_INT;
 import static com.android.testutils.TestPermissionUtil.runAsShell;
+import static com.android.testutils.TestableNetworkCallback.Event.BLOCKED_STATUS_INT;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -130,9 +130,8 @@ import com.android.testutils.AutoReleaseNetworkCallbackRule;
 import com.android.testutils.ConnectUtil;
 import com.android.testutils.DevSdkIgnoreRule;
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo;
-import com.android.testutils.RecorderCallback;
-import com.android.testutils.RecorderCallback.CallbackEntry;
 import com.android.testutils.TestableNetworkCallback;
+import com.android.testutils.TestableNetworkCallback.Event;
 
 import org.junit.After;
 import org.junit.Before;
@@ -886,14 +885,14 @@ public class VpnTest {
 
     private void expectUnderlyingNetworks(TestableNetworkCallback callback,
             @Nullable List<Network> expectUnderlyingNetworks) {
-        callback.eventuallyExpect(RecorderCallback.CallbackEntry.NETWORK_CAPS_UPDATED,
+        callback.eventuallyExpect(TestableNetworkCallback.Event.NETWORK_CAPS_UPDATED,
                 NETWORK_CALLBACK_TIMEOUT_MS,
                 entry -> (Objects.equals(expectUnderlyingNetworks,
                         entry.getCaps().getUnderlyingNetworks())));
     }
 
     private void expectVpnNetwork(TestableNetworkCallback callback) {
-        callback.eventuallyExpect(RecorderCallback.CallbackEntry.NETWORK_CAPS_UPDATED,
+        callback.eventuallyExpect(TestableNetworkCallback.Event.NETWORK_CAPS_UPDATED,
                 NETWORK_CALLBACK_TIMEOUT_MS,
                 entry -> entry.getCaps().hasTransport(TRANSPORT_VPN));
     }
@@ -1009,7 +1008,7 @@ public class VpnTest {
             registerDefaultNetworkCallback(myUidCallback);
             myUidCallback.expectAvailableCallbacks(defaultNetwork, false /* suspended */,
                     true /* validated */, false /* blocked */, TIMEOUT_MS);
-            myUidCallback.expect(CallbackEntry.NETWORK_CAPS_UPDATED, defaultNetwork);
+            myUidCallback.expect(Event.NETWORK_CAPS_UPDATED, defaultNetwork);
         }
 
         FileDescriptor fd = openSocketFdInOtherApp(TEST_HOST, 80, TIMEOUT_MS);
@@ -1030,7 +1029,7 @@ public class VpnTest {
         checkTrafficOnVpn();
 
         final Network vpnNetwork = mCM.getActiveNetwork();
-        myUidCallback.eventuallyExpect(CallbackEntry.NETWORK_CAPS_UPDATED,
+        myUidCallback.eventuallyExpect(Event.NETWORK_CAPS_UPDATED,
                 NETWORK_CALLBACK_TIMEOUT_MS,
                 entry -> entry.getNetwork().equals(vpnNetwork)
                         && entry.getCaps().hasCapability(NET_CAPABILITY_VALIDATED));
@@ -1065,8 +1064,8 @@ public class VpnTest {
     }
 
     private void assertNoCallbackExceptCapOrLpChange(TestableNetworkCallback callback) {
-        callback.assertNoCallback(c -> !(c instanceof CallbackEntry.CapabilitiesChanged
-                || c instanceof CallbackEntry.LinkPropertiesChanged));
+        callback.assertNoCallback(c -> !(c instanceof Event.CapabilitiesChanged
+                || c instanceof Event.LinkPropertiesChanged));
     }
 
     @Test
@@ -1182,12 +1181,12 @@ public class VpnTest {
         final Network defaultNetwork = mCM.getActiveNetwork();
         final TestableNetworkCallback cb = new TestableNetworkCallback();
         registerDefaultNetworkCallback(cb);
-        cb.expect(CallbackEntry.AVAILABLE, defaultNetwork);
+        cb.expect(Event.AVAILABLE, defaultNetwork);
         final NetworkCapabilities cap =
-                cb.expect(CallbackEntry.NETWORK_CAPS_UPDATED, defaultNetwork).getCaps();
+                cb.expect(Event.NETWORK_CAPS_UPDATED, defaultNetwork).getCaps();
         final LinkProperties lp =
-                cb.expect(CallbackEntry.LINK_PROPERTIES_CHANGED, defaultNetwork).getLp();
-        cb.expect(CallbackEntry.BLOCKED_STATUS, defaultNetwork);
+                cb.expect(Event.LINK_PROPERTIES_CHANGED, defaultNetwork).getLp();
+        cb.expect(Event.BLOCKED_STATUS, defaultNetwork);
 
         // Setup VPN
         final FileDescriptor fd = openSocketFdInOtherApp(TEST_HOST, 80, TIMEOUT_MS);
@@ -1932,7 +1931,7 @@ public class VpnTest {
 
             // The VPN will be the only default network for the app, so it's expected to receive
             // onLost() callback.
-            defaultNetworkCallback.eventuallyExpect(CallbackEntry.LOST);
+            defaultNetworkCallback.eventuallyExpect(Event.LOST);
 
             final ArrayList<Network> underlyingNetworks = new ArrayList<>();
             underlyingNetworks.add(defaultNetwork);
@@ -1944,14 +1943,14 @@ public class VpnTest {
             expectVpnNetwork(defaultNetworkCallback);
         }, /* cleanup */ () -> {
                 stopVpn();
-                defaultNetworkCallback.eventuallyExpect(CallbackEntry.LOST);
+                defaultNetworkCallback.eventuallyExpect(Event.LOST);
             }, /* cleanup */ () -> {
                 runWithShellPermissionIdentity(() -> {
                     mCM.setVpnDefaultForUids(session, new ArraySet<>());
                 }, NETWORK_SETTINGS);
                 // The default network of the app will be changed back to wifi when the VPN network
                 // preference feature is disabled.
-                defaultNetworkCallback.eventuallyExpect(CallbackEntry.AVAILABLE,
+                defaultNetworkCallback.eventuallyExpect(Event.AVAILABLE,
                         NETWORK_CALLBACK_TIMEOUT_MS,
                         entry -> defaultNetwork.equals(entry.getNetwork()));
             });
@@ -2133,7 +2132,7 @@ public class VpnTest {
                     BLOCKED_REASON_NONE, NETWORK_CALLBACK_TIMEOUT_MS);
         }
         public void onBlockedStatusChanged(Network network, int blockedReasons) {
-            getHistory().add(new CallbackEntry.BlockedStatusInt(network, blockedReasons));
+            getHistory().add(new Event.BlockedStatusInt(network, blockedReasons));
         }
     }
 }
diff --git a/tests/cts/multidevices/Android.bp b/tests/cts/multidevices/Android.bp
index bf73848b93..00fb93409c 100644
--- a/tests/cts/multidevices/Android.bp
+++ b/tests/cts/multidevices/Android.bp
@@ -21,8 +21,8 @@ python_test_host {
     name: "CtsConnectivityMultiDevicesTestCases",
     main: "run_tests.py",
     srcs: [
-        // "apfv4_test.py",
-        // "apfv6_test.py",
+        "apfv4_test.py",
+        "apfv6_test.py",
         "connectivity_multi_devices_test.py",
         "run_tests.py",
     ],
diff --git a/tests/cts/multidevices/apfv4_test.py b/tests/cts/multidevices/apfv4_test.py
index 2f212fcdc9..6071d40769 100644
--- a/tests/cts/multidevices/apfv4_test.py
+++ b/tests/cts/multidevices/apfv4_test.py
@@ -12,19 +12,20 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 
+import time
 from absl.testing import parameterized
 from mobly import asserts
 from net_tests_utils.host.python import apf_test_base, apf_utils
 from scapy.layers.l2 import Ether
-import time
 
 # Constants.
-COUNTER_DROPPED_ETHERTYPE_NOT_ALLOWED = "DROPPED_ETHERTYPE_NOT_ALLOWED"
-ETHER_BROADCAST_ADDR = "FFFFFFFFFFFF"
+COUNTER_DROPPED_ETHERTYPE_NOT_ALLOWED = 'DROPPED_ETHERTYPE_NOT_ALLOWED'
+ETHER_BROADCAST_ADDR = 'FFFFFFFFFFFF'
 MIN_PACKET_SIZE = 60
 
 
 class ApfV4Test(apf_test_base.ApfTestBase, parameterized.TestCase):
+
   def setup_class(self):
     super().setup_class()
     # Check apf version preconditions.
@@ -35,7 +36,7 @@ class ApfV4Test(apf_test_base.ApfTestBase, parameterized.TestCase):
       # Enforce APFv4 support for Android 14+ VSR.
       asserts.assert_true(
           caps.apf_version_supported >= 4,
-          "APFv4 became mandatory in Android 14 VSR.",
+          'APFv4 became mandatory in Android 14 VSR.',
       )
     else:
       # Skip tests for APF version < 4 before Android 14 VSR.
@@ -48,18 +49,22 @@ class ApfV4Test(apf_test_base.ApfTestBase, parameterized.TestCase):
   # Tests can use any disallowed packet type. Currently,
   # several ethertypes from the legacy ApfFilter denylist are used.
   @parameterized.parameters(
-      0x88a2,  # ATA over Ethernet
-      0x88a4,  # EtherCAT
-      0x88b8,  # GOOSE (Generic Object Oriented Substation event)
-      0x88cd,  # SERCOS III
-      0x88e3,  # Media Redundancy Protocol (IEC62439-2)
+      0x88A2,  # ATA over Ethernet
+      0x88A4,  # EtherCAT
+      0x88B8,  # GOOSE (Generic Object Oriented Substation event)
+      0x88CD,  # SERCOS III
+      0x88E3,  # Media Redundancy Protocol (IEC62439-2)
   )  # Declare inputs for state_str and expected_result.
   def test_apf_drop_ethertype_not_allowed(self, blocked_ether_type):
-    eth = Ether(src=self.server_mac_address, dst=self.client_mac_address, type=blocked_ether_type)
+    eth = Ether(
+        src=self.server_mac_address,
+        dst=self.client_mac_address,
+        type=blocked_ether_type,
+    )
     packet = bytes(eth).hex()
 
     # Add zero padding up to minimum ethernet frame length
-    packet = packet.ljust(MIN_PACKET_SIZE * 2, "0")
+    packet = packet.ljust(MIN_PACKET_SIZE * 2, '0')
 
     # Pause packet sending between tests to avoid APF disablement due to high throughput.
     time.sleep(3)
diff --git a/tests/cts/multidevices/apfv6_test.py b/tests/cts/multidevices/apfv6_test.py
index e06af65339..4512c2d3fe 100644
--- a/tests/cts/multidevices/apfv6_test.py
+++ b/tests/cts/multidevices/apfv6_test.py
@@ -13,198 +13,208 @@
 #  limitations under the License.
 
 from mobly import asserts
-from scapy.layers.inet import IP, ICMP, IPOption_Router_Alert
+from net_tests_utils.host.python import adb_utils, apf_test_base, apf_utils, assert_utils
+from scapy.contrib.igmpv3 import IGMPv3, IGMPv3gr, IGMPv3mq, IGMPv3mr
+from scapy.layers.inet import ICMP, IP, IPOption_Router_Alert
 from scapy.layers.inet6 import (
-    IPv6,
-    IPv6ExtHdrHopByHop,
-    ICMPv6EchoRequest,
     ICMPv6EchoReply,
+    ICMPv6EchoRequest,
+    ICMPv6MLDMultAddrRec,
     ICMPv6MLQuery2,
     ICMPv6MLReport2,
-    ICMPv6MLDMultAddrRec,
-    ICMPv6NDOptSrcLLAddr,
     ICMPv6NDOptDstLLAddr,
-    ICMPv6ND_NS,
+    ICMPv6NDOptSrcLLAddr,
     ICMPv6ND_NA,
-    RouterAlert
+    ICMPv6ND_NS,
+    IPv6,
+    IPv6ExtHdrHopByHop,
+    RouterAlert,
 )
 from scapy.layers.l2 import ARP, Ether
-from scapy.contrib.igmpv3 import IGMPv3, IGMPv3mq, IGMPv3mr, IGMPv3gr
-from net_tests_utils.host.python import apf_test_base, apf_utils, adb_utils, assert_utils
 
 APFV6_VERSION = 6000
 ARP_OFFLOAD_REPLY_LEN = 60
 
+
 class ApfV6Test(apf_test_base.ApfTestBase):
-    def setup_class(self):
-        super().setup_class()
-
-        # Skip tests for APF version < 6000
-        apf_utils.assume_apf_version_support_at_least(
-            self.clientDevice, self.client_iface_name, APFV6_VERSION
-        )
-
-    def teardown_class(self):
-        # force to stop capture on the server device if any test case failed
-        try:
-            apf_utils.stop_capture_packets(self.serverDevice, self.server_iface_name)
-        except assert_utils.UnexpectedBehaviorError:
-            pass
-        super().teardown_class()
-
-    def test_unicast_arp_request_offload(self):
-        eth = Ether(src=self.server_mac_address, dst=self.client_mac_address)
-        arp = ARP(
-            op=1,
-            psrc=self.server_ipv4_addresses[0],
-            pdst=self.client_ipv4_addresses[0],
-            hwsrc=self.server_mac_address
-        )
-        arp_request = bytes(eth/arp).hex()
-
-        eth = Ether(src=self.client_mac_address, dst=self.server_mac_address)
-        arp = ARP(
-            op=2,
-            psrc=self.client_ipv4_addresses[0],
-            pdst=self.server_ipv4_addresses[0],
-            hwsrc=self.client_mac_address,
-            hwdst=self.server_mac_address
-        )
-        expected_arp_reply = bytes(eth/arp).hex()
-
-        # Add zero padding up to 60 bytes, since APFv6 ARP offload always sent out 60 bytes reply
-        expected_arp_reply = expected_arp_reply.ljust(ARP_OFFLOAD_REPLY_LEN * 2, "0")
-
-        self.send_packet_and_expect_reply_received(
-            arp_request, "DROPPED_ARP_REQUEST_REPLIED", expected_arp_reply
-        )
-
-    def test_non_dad_ipv6_neighbor_solicitation_offload(self):
-        eth = Ether(src=self.server_mac_address, dst=self.client_mac_address)
-        ip = IPv6(src=self.server_ipv6_addresses[0], dst=self.client_ipv6_addresses[0])
-        icmpv6 = ICMPv6ND_NS(tgt=self.client_ipv6_addresses[0])
-        opt = ICMPv6NDOptSrcLLAddr(lladdr=self.server_mac_address)
-        neighbor_solicitation = bytes(eth/ip/icmpv6/opt).hex()
-
-        eth = Ether(src=self.client_mac_address, dst=self.server_mac_address)
-        ip = IPv6(src=self.client_ipv6_addresses[0], dst=self.server_ipv6_addresses[0])
-        icmpv6 = ICMPv6ND_NA(tgt=self.client_ipv6_addresses[0], R=1, S=1, O=1)
-        opt = ICMPv6NDOptDstLLAddr(lladdr=self.client_mac_address)
-        expected_neighbor_advertisement = bytes(eth/ip/icmpv6/opt).hex()
-        self.send_packet_and_expect_reply_received(
-            neighbor_solicitation,
-            "DROPPED_IPV6_NS_REPLIED_NON_DAD",
-            expected_neighbor_advertisement
-        )
-
-    @apf_utils.at_least_B()
-    def test_ipv4_icmp_echo_request_offload(self):
-        eth = Ether(src=self.server_mac_address, dst=self.client_mac_address)
-        ip = IP(src=self.server_ipv4_addresses[0], dst=self.client_ipv4_addresses[0])
-        icmp = ICMP(id=1, seq=123)
-        echo_request = bytes(eth/ip/icmp/b"hello").hex()
-
-        eth = Ether(src=self.client_mac_address, dst=self.server_mac_address)
-        ip = IP(src=self.client_ipv4_addresses[0], dst=self.server_ipv4_addresses[0])
-        icmp = ICMP(type=0, id=1, seq=123)
-        expected_echo_reply = bytes(eth/ip/icmp/b"hello").hex()
-        self.send_packet_and_expect_reply_received(
-            echo_request, "DROPPED_IPV4_PING_REQUEST_REPLIED", expected_echo_reply
-        )
-
-    @apf_utils.at_least_B()
-    @apf_utils.apf_ram_at_least(3000)
-    def test_ipv6_icmp_echo_request_offload(self):
-        eth = Ether(src=self.server_mac_address, dst=self.client_mac_address)
-        ip = IPv6(src=self.server_ipv6_addresses[0], dst=self.client_ipv6_addresses[0])
-        icmp = ICMPv6EchoRequest(id=1, seq=123)
-        echo_request = bytes(eth/ip/icmp/b"hello").hex()
-
-        eth = Ether(src=self.client_mac_address, dst=self.server_mac_address)
-        ip = IPv6(src=self.client_ipv6_addresses[0], dst=self.server_ipv6_addresses[0])
-        icmp = ICMPv6EchoReply(id=1, seq=123)
-        expected_echo_reply = bytes(eth/ip/icmp/b"hello").hex()
-
-        self.send_packet_and_expect_reply_received(
-            echo_request, "DROPPED_IPV6_ICMP6_ECHO_REQUEST_REPLIED", expected_echo_reply
-        )
-
-    def is_running_as_root(self):
-        uid = adb_utils.adb_shell(self.clientDevice, "id -u")
-        return uid == "0"
-
-    @apf_utils.at_least_B()
-    def test_igmpv3_general_query_offload(self):
-        if not self.is_running_as_root():
-            return
-        # use unicast to replace multicast ether dst to prevent flaky due to DTIM skip
-        ether = Ether(src=self.server_mac_address, dst=self.client_mac_address)
-        ip = IP(
-            src=self.server_ipv4_addresses[0],
-            dst='224.0.0.1',
-            options=[IPOption_Router_Alert()]
-        )
-        igmp = IGMPv3(type=0x11)/IGMPv3mq()
-        igmpv3_general_query = bytes(ether/ip/igmp).hex()
-
-        mcast_addrs = ['239.0.0.1', '239.0.0.2', '239.0.0.3']
-
-        for addr in mcast_addrs:
-            adb_utils.adb_shell(
-                self.clientDevice,
-                f'ip addr add {addr}/32 dev {self.client_iface_name} autojoin'
-            )
-
-        ether = Ether(src=self.client_mac_address, dst='01:00:5e:00:00:16')
-        ip = IP(
-            src=self.client_ipv4_addresses[0],
-            dst='224.0.0.22',
-            options=[IPOption_Router_Alert()],
-            id=0,
-            flags="DF"
-        )
-        igmpv3_hdr = IGMPv3(type=0x22)
-        mcast_records = []
-        for addr in mcast_addrs:
-            mcast_records.append(IGMPv3gr(rtype=2, maddr=addr))
-
-        igmp = IGMPv3mr(records=mcast_records)
-        expected_igmpv3_report = bytes(ether/ip/igmpv3_hdr/igmp).hex()
-        try:
-            self.send_packet_and_expect_reply_received(
-                igmpv3_general_query,
-                "DROPPED_IGMP_V3_GENERAL_QUERY_REPLIED",
-                expected_igmpv3_report
-            )
-        finally:
-            for addr in mcast_addrs:
-                adb_utils.adb_shell(
-                    self.clientDevice,
-                    f'ip addr del {addr}/32 dev {self.client_iface_name}'
-                )
-
-    @apf_utils.at_least_B()
-    @apf_utils.apf_ram_at_least(3000)
-    def test_mldv2_general_query_offload(self):
-        # use unicast to replace multicast ether dst to prevent flaky due to DTIM skip
-        ether = Ether(src=self.server_mac_address, dst=self.client_mac_address)
-        ip = IPv6(src=self.server_ipv6_addresses[0], dst='ff02::1', hlim=1)
-        hopOpts = IPv6ExtHdrHopByHop(options=[RouterAlert(otype=5)])
-        mld = ICMPv6MLQuery2()
-        mldv2_general_query = bytes(ether/ip/hopOpts/mld).hex()
-
-        ether = Ether(src=self.client_mac_address, dst='33:33:00:00:00:16')
-        ip = IPv6(src=self.client_ipv6_addresses[0], dst='ff02::16', hlim=1)
-
-        mcast_addrs = apf_utils.get_exclude_all_host_ipv6_multicast_addresses(
-            self.clientDevice, self.client_iface_name
-        )
-
-        mld_records = []
-        for addr in mcast_addrs:
-            mld_records.append(ICMPv6MLDMultAddrRec(dst=addr, rtype=2))
-        mld = ICMPv6MLReport2(records=mld_records)
-        expected_mldv2_report = bytes(ether/ip/hopOpts/mld).hex()
-        self.send_packet_and_expect_reply_received(
-            mldv2_general_query, "DROPPED_IPV6_MLD_V2_GENERAL_QUERY_REPLIED", expected_mldv2_report
-        )
+
+  def setup_class(self):
+    super().setup_class()
+
+    # Skip tests for APF version < 6000
+    apf_utils.assume_apf_version_support_at_least(
+        self.clientDevice, self.client_iface_name, APFV6_VERSION
+    )
+
+  def teardown_class(self):
+    # force to stop capture on the server device if any test case failed
+    try:
+      apf_utils.stop_capture_packets(self.serverDevice, self.server_iface_name)
+    except assert_utils.UnexpectedBehaviorError:
+      pass
+    super().teardown_class()
+
+  def test_unicast_arp_request_offload(self):
+    eth = Ether(src=self.server_mac_address, dst=self.client_mac_address)
+    arp = ARP(
+        op=1,
+        psrc=self.server_ipv4_addresses[0],
+        pdst=self.client_ipv4_addresses[0],
+        hwsrc=self.server_mac_address,
+    )
+    arp_request = bytes(eth / arp).hex()
+
+    eth = Ether(src=self.client_mac_address, dst=self.server_mac_address)
+    arp = ARP(
+        op=2,
+        psrc=self.client_ipv4_addresses[0],
+        pdst=self.server_ipv4_addresses[0],
+        hwsrc=self.client_mac_address,
+        hwdst=self.server_mac_address,
+    )
+    expected_arp_reply = bytes(eth / arp).hex()
+
+    # Add zero padding up to 60 bytes, since APFv6 ARP offload always sent out 60 bytes reply
+    expected_arp_reply = expected_arp_reply.ljust(
+        ARP_OFFLOAD_REPLY_LEN * 2, '0'
+    )
+
+    self.send_packet_and_expect_reply_received(
+        arp_request, 'DROPPED_ARP_REQUEST_REPLIED', expected_arp_reply
+    )
+
+  def test_non_dad_ipv6_neighbor_solicitation_offload(self):
+    eth = Ether(src=self.server_mac_address, dst=self.client_mac_address)
+    ip = IPv6(
+        src=self.server_ipv6_addresses[0], dst=self.client_ipv6_addresses[0]
+    )
+    icmpv6 = ICMPv6ND_NS(tgt=self.client_ipv6_addresses[0])
+    opt = ICMPv6NDOptSrcLLAddr(lladdr=self.server_mac_address)
+    neighbor_solicitation = bytes(eth / ip / icmpv6 / opt).hex()
+
+    eth = Ether(src=self.client_mac_address, dst=self.server_mac_address)
+    ip = IPv6(
+        src=self.client_ipv6_addresses[0], dst=self.server_ipv6_addresses[0]
+    )
+    icmpv6 = ICMPv6ND_NA(tgt=self.client_ipv6_addresses[0], R=1, S=1, O=1)
+    opt = ICMPv6NDOptDstLLAddr(lladdr=self.client_mac_address)
+    expected_neighbor_advertisement = bytes(eth / ip / icmpv6 / opt).hex()
+    self.send_packet_and_expect_reply_received(
+        neighbor_solicitation,
+        'DROPPED_IPV6_NS_REPLIED_NON_DAD',
+        expected_neighbor_advertisement,
+    )
+
+  @apf_utils.at_least_B()
+  def test_ipv4_icmp_echo_request_offload(self):
+    eth = Ether(src=self.server_mac_address, dst=self.client_mac_address)
+    ip = IP(
+        src=self.server_ipv4_addresses[0], dst=self.client_ipv4_addresses[0]
+    )
+    icmp = ICMP(id=1, seq=123)
+    echo_request = bytes(eth / ip / icmp / b'hello').hex()
+
+    eth = Ether(src=self.client_mac_address, dst=self.server_mac_address)
+    ip = IP(
+        src=self.client_ipv4_addresses[0], dst=self.server_ipv4_addresses[0]
+    )
+    icmp = ICMP(type=0, id=1, seq=123)
+    expected_echo_reply = bytes(eth / ip / icmp / b'hello').hex()
+    self.send_packet_and_expect_reply_received(
+        echo_request, 'DROPPED_IPV4_PING_REQUEST_REPLIED', expected_echo_reply
+    )
+
+  @apf_utils.at_least_B()
+  @apf_utils.apf_ram_at_least(3000)
+  def test_ipv6_icmp_echo_request_offload(self):
+    eth = Ether(src=self.server_mac_address, dst=self.client_mac_address)
+    ip = IPv6(
+        src=self.server_ipv6_addresses[0], dst=self.client_ipv6_addresses[0]
+    )
+    icmp = ICMPv6EchoRequest(id=1, seq=123)
+    echo_request = bytes(eth / ip / icmp / b'hello').hex()
+
+    eth = Ether(src=self.client_mac_address, dst=self.server_mac_address)
+    ip = IPv6(
+        src=self.client_ipv6_addresses[0], dst=self.server_ipv6_addresses[0]
+    )
+    icmp = ICMPv6EchoReply(id=1, seq=123)
+    expected_echo_reply = bytes(eth / ip / icmp / b'hello').hex()
+
+    self.send_packet_and_expect_reply_received(
+        echo_request,
+        'DROPPED_IPV6_ICMP6_ECHO_REQUEST_REPLIED',
+        expected_echo_reply,
+    )
+
+  @apf_utils.at_least_B()
+  def test_igmpv3_general_query_offload(self):
+    # use unicast to replace multicast ether dst to prevent flaky due to DTIM skip
+    ether = Ether(src=self.server_mac_address, dst=self.client_mac_address)
+    ip = IP(
+        src=self.server_ipv4_addresses[0],
+        dst='224.0.0.1',
+        options=[IPOption_Router_Alert()],
+    )
+    igmp = IGMPv3(type=0x11) / IGMPv3mq()
+    igmpv3_general_query = bytes(ether / ip / igmp).hex()
+
+    mcast_addrs = ['239.0.0.1', '239.0.0.2', '239.0.0.3']
+
+    self.client.createMulticastSocket(self.client_iface_name)
+    for addr in mcast_addrs:
+      self.client.joinMulticastGroup(addr)
+
+    ether = Ether(src=self.client_mac_address, dst='01:00:5e:00:00:16')
+    ip = IP(
+        src=self.client_ipv4_addresses[0],
+        dst='224.0.0.22',
+        options=[IPOption_Router_Alert()],
+        id=0,
+        flags='DF',
+    )
+    igmpv3_hdr = IGMPv3(type=0x22)
+    mcast_records = []
+    for addr in mcast_addrs:
+      mcast_records.append(IGMPv3gr(rtype=2, maddr=addr))
+
+    igmp = IGMPv3mr(records=mcast_records)
+    expected_igmpv3_report = bytes(ether / ip / igmpv3_hdr / igmp).hex()
+    try:
+      self.send_packet_and_expect_reply_received(
+          igmpv3_general_query,
+          'DROPPED_IGMP_V3_GENERAL_QUERY_REPLIED',
+          expected_igmpv3_report,
+      )
+    finally:
+      for addr in mcast_addrs:
+        self.client.leaveMulticastGroup(addr)
+      self.client.destroyMulticastSocket()
+
+  @apf_utils.at_least_B()
+  @apf_utils.apf_ram_at_least(3000)
+  def test_mldv2_general_query_offload(self):
+    # use unicast to replace multicast ether dst to prevent flaky due to DTIM skip
+    ether = Ether(src=self.server_mac_address, dst=self.client_mac_address)
+    ip = IPv6(src=self.server_ipv6_addresses[0], dst='ff02::1', hlim=1)
+    hopOpts = IPv6ExtHdrHopByHop(options=[RouterAlert(otype=5)])
+    mld = ICMPv6MLQuery2()
+    mldv2_general_query = bytes(ether / ip / hopOpts / mld).hex()
+
+    ether = Ether(src=self.client_mac_address, dst='33:33:00:00:00:16')
+    ip = IPv6(src=self.client_ipv6_addresses[0], dst='ff02::16', hlim=1)
+
+    mcast_addrs = apf_utils.get_exclude_all_host_ipv6_multicast_addresses(
+        self.clientDevice, self.client_iface_name
+    )
+
+    mld_records = []
+    for addr in mcast_addrs:
+      mld_records.append(ICMPv6MLDMultAddrRec(dst=addr, rtype=2))
+    mld = ICMPv6MLReport2(records=mld_records)
+    expected_mldv2_report = bytes(ether / ip / hopOpts / mld).hex()
+    self.send_packet_and_expect_reply_received(
+        mldv2_general_query,
+        'DROPPED_IPV6_MLD_V2_GENERAL_QUERY_REPLIED',
+        expected_mldv2_report,
+    )
diff --git a/tests/cts/multidevices/run_tests.py b/tests/cts/multidevices/run_tests.py
index 1ac43b9ab9..3b4afc8238 100644
--- a/tests/cts/multidevices/run_tests.py
+++ b/tests/cts/multidevices/run_tests.py
@@ -15,11 +15,13 @@
 """Main entrypoint for all of test cases."""
 
 import sys
+from apfv4_test import ApfV4Test
+from apfv6_test import ApfV6Test
 from connectivity_multi_devices_test import ConnectivityMultiDevicesTest
 from mobly import suite_runner
 
 
-if __name__ == "__main__":
+if __name__ == '__main__':
   # For MoblyBinaryHostTest, this entry point will be called twice:
   # 1. List tests.
   #   <mobly-par-file-name> -- --list_tests
@@ -30,8 +32,10 @@ if __name__ == "__main__":
   # While the parameters before "--" is for the infrastructure,
   # ignore them if any. Also, do not alter parameters if there
   # is no "--", in case the binary is invoked manually.
-  if "--" in sys.argv:
-    index = sys.argv.index("--")
+  if '--' in sys.argv:
+    index = sys.argv.index('--')
     sys.argv = sys.argv[:1] + sys.argv[index + 1 :]
   # TODO: make the tests can be executed without manually list classes.
-  suite_runner.run_suite([ConnectivityMultiDevicesTest], sys.argv)
+  suite_runner.run_suite(
+      [ConnectivityMultiDevicesTest, ApfV4Test, ApfV6Test], sys.argv
+  )
diff --git a/tests/cts/multidevices/snippet/Android.bp b/tests/cts/multidevices/snippet/Android.bp
index c94087e2e6..9e1878331e 100644
--- a/tests/cts/multidevices/snippet/Android.bp
+++ b/tests/cts/multidevices/snippet/Android.bp
@@ -16,6 +16,20 @@ package {
     default_applicable_licenses: ["Android-Apache-2.0"],
 }
 
+java_library {
+    name: "ConnectivityWifiP2pMultiDevicesSnippetLib",
+    srcs: [
+        "Wifip2pMultiDevicesSnippet.kt",
+    ],
+    static_libs: [
+        "mobly-snippet-lib",
+        "cts-net-utils",
+    ],
+    visibility: [
+        "//packages/modules/Connectivity/tests/cts/tethering",
+    ],
+}
+
 android_test_helper_app {
     name: "connectivity_multi_devices_snippet",
     defaults: [
diff --git a/tests/cts/multidevices/snippet/ConnectivityMultiDevicesSnippet.kt b/tests/cts/multidevices/snippet/ConnectivityMultiDevicesSnippet.kt
index e1c6bf1874..9f01abaf4f 100644
--- a/tests/cts/multidevices/snippet/ConnectivityMultiDevicesSnippet.kt
+++ b/tests/cts/multidevices/snippet/ConnectivityMultiDevicesSnippet.kt
@@ -18,6 +18,7 @@ package com.google.snippet.connectivity
 
 import android.Manifest.permission.NETWORK_SETTINGS
 import android.Manifest.permission.OVERRIDE_WIFI_CONFIG
+import android.content.pm.PackageManager.FEATURE_AUTOMOTIVE
 import android.content.pm.PackageManager.FEATURE_TELEPHONY
 import android.content.pm.PackageManager.FEATURE_WIFI
 import android.net.ConnectivityManager
@@ -41,11 +42,15 @@ import com.android.modules.utils.build.SdkLevel
 import com.android.testutils.AutoReleaseNetworkCallbackRule
 import com.android.testutils.ConnectUtil
 import com.android.testutils.NetworkCallbackHelper
-import com.android.testutils.RecorderCallback.CallbackEntry.CapabilitiesChanged
 import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.CapabilitiesChanged
 import com.android.testutils.runAsShell
 import com.google.android.mobly.snippet.Snippet
 import com.google.android.mobly.snippet.rpc.Rpc
+import java.net.InetAddress
+import java.net.InetSocketAddress
+import java.net.MulticastSocket
+import java.net.NetworkInterface
 import org.junit.Rule
 
 class ConnectivityMultiDevicesSnippet : Snippet {
@@ -59,6 +64,7 @@ class ConnectivityMultiDevicesSnippet : Snippet {
     private val cbHelper = NetworkCallbackHelper()
     private val ctsTetheringUtils = CtsTetheringUtils(context)
     private var oldSoftApConfig: SoftApConfiguration? = null
+    private var multicastSocket: MulticastSocket? = null
 
     override fun shutdown() {
         cbHelper.unregisterAll()
@@ -81,6 +87,9 @@ class ConnectivityMultiDevicesSnippet : Snippet {
     @Rpc(description = "Check whether the device has telephony feature.")
     fun hasTelephonyFeature() = pm.hasSystemFeature(FEATURE_TELEPHONY)
 
+    @Rpc(description = "Check whether the device has automotive feature.")
+    fun hasAutomotiveFeature() = pm.hasSystemFeature(FEATURE_AUTOMOTIVE)
+
     @Rpc(description = "Check whether the device supporters AP + STA concurrency.")
     fun isStaApConcurrencySupported() = wifiManager.isStaApConcurrencySupported()
 
@@ -211,4 +220,50 @@ class ConnectivityMultiDevicesSnippet : Snippet {
             }
         }
     }
+
+    @Rpc(description = "Create multicast socket")
+    fun createMulticastSocket(ifname: String) {
+        if (multicastSocket != null) {
+            throw IllegalStateException("multicast socket is not null")
+        }
+
+        multicastSocket = MulticastSocket()
+        multicastSocket?.networkInterface = NetworkInterface.getByName(ifname)
+    }
+
+    @Rpc(description = "Destroy multicast socket")
+    fun destroyMulticastSocket() {
+        if (multicastSocket == null) {
+            throw IllegalStateException("multicast socket is null")
+        }
+
+        multicastSocket?.close()
+        multicastSocket = null
+    }
+
+    @Rpc(description = "Join multicast group")
+    fun joinMulticastGroup(multicastGroup: String) {
+        if (multicastSocket == null) {
+            throw IllegalStateException("multicast socket is null")
+        }
+
+        val groupToJoin = InetAddress.getByName(multicastGroup)
+        multicastSocket?.joinGroup(
+            InetSocketAddress(groupToJoin, 0),
+            multicastSocket?.networkInterface
+        )
+    }
+
+    @Rpc(description = "Leave multicast group")
+    fun leaveMulticastGroup(multicastGroup: String) {
+        if (multicastSocket == null) {
+            throw IllegalStateException("multicast socket is null")
+        }
+
+        val groupToLeave = InetAddress.getByName(multicastGroup)
+        multicastSocket?.leaveGroup(
+            InetSocketAddress(groupToLeave, 0),
+            multicastSocket?.networkInterface
+        )
+    }
 }
diff --git a/tests/cts/multidevices/snippet/MdnsMultiDevicesSnippet.kt b/tests/cts/multidevices/snippet/MdnsMultiDevicesSnippet.kt
index 1b288df95a..1ed54a8ab3 100644
--- a/tests/cts/multidevices/snippet/MdnsMultiDevicesSnippet.kt
+++ b/tests/cts/multidevices/snippet/MdnsMultiDevicesSnippet.kt
@@ -20,6 +20,7 @@ import android.net.nsd.NsdManager
 import android.net.nsd.NsdServiceInfo
 import androidx.test.platform.app.InstrumentationRegistry
 import com.android.testutils.NsdDiscoveryRecord
+import com.android.testutils.NsdDiscoveryRecord.DiscoveryEvent.DiscoveryStarted
 import com.android.testutils.NsdDiscoveryRecord.DiscoveryEvent.DiscoveryStopped
 import com.android.testutils.NsdRegistrationRecord
 import com.android.testutils.NsdRegistrationRecord.RegistrationEvent.ServiceRegistered
@@ -58,6 +59,10 @@ class MdnsMultiDevicesSnippet : Snippet {
 
     @Rpc(description = "Unregister a mDns service")
     fun unregisterMDnsService() {
+        if (!(registrationRecord.poll(timeoutMs = 0, pos = 0) is ServiceRegistered)) {
+            // Ignore unregistration if the service has not registered
+            return
+        }
         nsdManager.unregisterService(registrationRecord)
         registrationRecord.expectCallback<ServiceUnregistered>()
     }
@@ -86,6 +91,10 @@ class MdnsMultiDevicesSnippet : Snippet {
 
     @Rpc(description = "Stop discovery")
     fun stopMDnsServiceDiscovery() {
+        if (!(discoveryRecord.poll(timeoutMs = 0, pos = 0) is DiscoveryStarted)) {
+            // Ignore discovery stop if discovery has not started
+            return
+        }
         nsdManager.stopServiceDiscovery(discoveryRecord)
         discoveryRecord.expectCallbackEventually<DiscoveryStopped>()
     }
diff --git a/tests/cts/multidevices/snippet/Wifip2pMultiDevicesSnippet.kt b/tests/cts/multidevices/snippet/Wifip2pMultiDevicesSnippet.kt
index 3816537a7d..c5af0b389b 100644
--- a/tests/cts/multidevices/snippet/Wifip2pMultiDevicesSnippet.kt
+++ b/tests/cts/multidevices/snippet/Wifip2pMultiDevicesSnippet.kt
@@ -16,25 +16,20 @@
 
 package com.google.snippet.connectivity
 
-import android.Manifest.permission.MANAGE_WIFI_NETWORK_SELECTION
 import android.content.BroadcastReceiver
 import android.content.Context
 import android.content.Intent
 import android.content.IntentFilter
 import android.content.pm.PackageManager.FEATURE_WIFI_DIRECT
-import android.net.MacAddress
 import android.net.wifi.p2p.WifiP2pConfig
 import android.net.wifi.p2p.WifiP2pDevice
-import android.net.wifi.p2p.WifiP2pDeviceList
 import android.net.wifi.p2p.WifiP2pGroup
 import android.net.wifi.p2p.WifiP2pManager
 import androidx.test.platform.app.InstrumentationRegistry
 import com.android.net.module.util.ArrayTrackRecord
-import com.android.testutils.runAsShell
 import com.google.android.mobly.snippet.Snippet
 import com.google.android.mobly.snippet.rpc.Rpc
 import com.google.snippet.connectivity.Wifip2pMultiDevicesSnippet.Wifip2pIntentReceiver.IntentReceivedEvent.ConnectionChanged
-import com.google.snippet.connectivity.Wifip2pMultiDevicesSnippet.Wifip2pIntentReceiver.IntentReceivedEvent.PeersChanged
 import java.util.concurrent.CompletableFuture
 import java.util.concurrent.TimeUnit
 import kotlin.test.assertNotNull
@@ -57,7 +52,6 @@ class Wifip2pMultiDevicesSnippet : Snippet {
         sealed class IntentReceivedEvent {
             abstract val intent: Intent
             data class ConnectionChanged(override val intent: Intent) : IntentReceivedEvent()
-            data class PeersChanged(override val intent: Intent) : IntentReceivedEvent()
         }
 
         override fun onReceive(context: Context, intent: Intent) {
@@ -65,9 +59,6 @@ class Wifip2pMultiDevicesSnippet : Snippet {
                 WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION -> {
                     history.add(ConnectionChanged(intent))
                 }
-                WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION -> {
-                    history.add(PeersChanged(intent))
-                }
             }
         }
 
@@ -126,12 +117,12 @@ class Wifip2pMultiDevicesSnippet : Snippet {
 
     @Rpc(description = "Wait for a p2p connection changed intent and check the group")
     @Suppress("DEPRECATION")
-    fun waitForP2pConnectionChanged(ignoreGroupCheck: Boolean, groupName: String) {
+    fun waitForP2pConnectionChanged(groupName: String) {
         wifip2pIntentReceiver.eventuallyExpectedIntent<ConnectionChanged>() {
             val p2pGroup: WifiP2pGroup? =
                     it.intent.getParcelableExtra(WifiP2pManager.EXTRA_WIFI_P2P_GROUP)
             val groupMatched = p2pGroup?.networkName == groupName
-            return@eventuallyExpectedIntent ignoreGroupCheck || groupMatched
+            return@eventuallyExpectedIntent groupMatched
         }
     }
 
@@ -154,61 +145,15 @@ class Wifip2pMultiDevicesSnippet : Snippet {
         createGroupFuture.get(TIMEOUT_MS, TimeUnit.MILLISECONDS)
 
         // Ensure the Wi-Fi P2P group is created.
-        waitForP2pConnectionChanged(false, groupName)
-    }
-
-    @Rpc(description = "Start Wi-Fi P2P peers discovery")
-    fun startPeersDiscovery() {
-        // Start discovery Wi-Fi P2P peers
-        wifip2pManager.discoverPeers(wifip2pChannel, null)
-
-        // Ensure the discovery is started
-        val p2pDiscoveryStartedFuture = CompletableFuture<Boolean>()
-        wifip2pManager.requestDiscoveryState(wifip2pChannel) { state ->
-            if (state == WifiP2pManager.WIFI_P2P_DISCOVERY_STARTED) {
-                p2pDiscoveryStartedFuture.complete(true)
-            }
-        }
-        p2pDiscoveryStartedFuture.get(TIMEOUT_MS, TimeUnit.MILLISECONDS)
-    }
-
-    /**
-     * Get the device address from the given intent that matches the given device name.
-     *
-     * @param peersChangedIntent the intent to get the device address from
-     * @param deviceName the target device name
-     * @return the address of the target device or null if no devices match.
-     */
-    @Suppress("DEPRECATION")
-    private fun getDeviceAddress(peersChangedIntent: Intent, deviceName: String): String? {
-        val peers: WifiP2pDeviceList? =
-                peersChangedIntent.getParcelableExtra(WifiP2pManager.EXTRA_P2P_DEVICE_LIST)
-        return peers?.deviceList?.firstOrNull { it.deviceName == deviceName }?.deviceAddress
-    }
-
-    /**
-     * Ensure the given device has been discovered and returns the associated device address for
-     * connection.
-     *
-     * @param deviceName the target device name
-     * @return the address of the target device.
-     */
-    @Rpc(description = "Ensure the target Wi-Fi P2P device is discovered")
-    fun ensureDeviceDiscovered(deviceName: String): String {
-        val changedEvent = wifip2pIntentReceiver.eventuallyExpectedIntent<PeersChanged>() {
-            return@eventuallyExpectedIntent getDeviceAddress(it.intent, deviceName) != null
-        }
-        return getDeviceAddress(changedEvent.intent, deviceName)
-                ?: fail("Missing device in filtered intent")
+        waitForP2pConnectionChanged(groupName)
     }
 
-    @Rpc(description = "Invite a Wi-Fi P2P device to the group")
-    fun inviteDeviceToGroup(groupName: String, groupPassphrase: String, deviceAddress: String) {
-        // Connect to the device to send invitation
+    @Rpc(description = "Connect to the group")
+    fun connectToGroup(groupName: String, groupPassphrase: String) {
+        // Connect to the p2p group with config
         val wifip2pConfig = WifiP2pConfig.Builder()
                 .setNetworkName(groupName)
                 .setPassphrase(groupPassphrase)
-                .setDeviceAddress(MacAddress.fromString(deviceAddress))
                 .build()
         val connectedFuture = CompletableFuture<Boolean>()
         wifip2pManager.connect(
@@ -224,76 +169,6 @@ class Wifip2pMultiDevicesSnippet : Snippet {
         connectedFuture.get(TIMEOUT_MS, TimeUnit.MILLISECONDS)
     }
 
-    private fun runExternalApproverForGroupProcess(
-            deviceAddress: String,
-            isGroupInvitation: Boolean
-    ) {
-        val peer = MacAddress.fromString(deviceAddress)
-        runAsShell(MANAGE_WIFI_NETWORK_SELECTION) {
-            val connectionRequestFuture = CompletableFuture<Boolean>()
-            val attachedFuture = CompletableFuture<Boolean>()
-            wifip2pManager.addExternalApprover(
-                    wifip2pChannel,
-                    peer,
-                    object : WifiP2pManager.ExternalApproverRequestListener {
-                        override fun onAttached(deviceAddress: MacAddress) {
-                            attachedFuture.complete(true)
-                        }
-                        override fun onDetached(deviceAddress: MacAddress, reason: Int) = Unit
-                        override fun onConnectionRequested(
-                                requestType: Int,
-                                config: WifiP2pConfig,
-                                device: WifiP2pDevice
-                        ) {
-                            connectionRequestFuture.complete(true)
-                        }
-                        override fun onPinGenerated(deviceAddress: MacAddress, pin: String) = Unit
-                    }
-            )
-            if (isGroupInvitation) attachedFuture.get(TIMEOUT_MS, TimeUnit.MILLISECONDS) else
-                connectionRequestFuture.get(TIMEOUT_MS, TimeUnit.MILLISECONDS)
-
-            val resultFuture = CompletableFuture<Boolean>()
-            wifip2pManager.setConnectionRequestResult(
-                    wifip2pChannel,
-                    peer,
-                    WifiP2pManager.CONNECTION_REQUEST_ACCEPT,
-                    object : WifiP2pManager.ActionListener {
-                        override fun onFailure(reason: Int) = Unit
-                        override fun onSuccess() {
-                            resultFuture.complete(true)
-                        }
-                    }
-            )
-            resultFuture.get(TIMEOUT_MS, TimeUnit.MILLISECONDS)
-
-            val removeFuture = CompletableFuture<Boolean>()
-            wifip2pManager.removeExternalApprover(
-                    wifip2pChannel,
-                    peer,
-                    object : WifiP2pManager.ActionListener {
-                        override fun onFailure(reason: Int) = Unit
-                        override fun onSuccess() {
-                            removeFuture.complete(true)
-                        }
-                    }
-            )
-            removeFuture.get(TIMEOUT_MS, TimeUnit.MILLISECONDS)
-        }
-    }
-
-    @Rpc(description = "Accept P2P group invitation from device")
-    fun acceptGroupInvitation(deviceAddress: String) {
-        // Accept the Wi-Fi P2P group invitation
-        runExternalApproverForGroupProcess(deviceAddress, true /* isGroupInvitation */)
-    }
-
-    @Rpc(description = "Wait for connection request from the peer and accept joining")
-    fun waitForPeerConnectionRequestAndAcceptJoining(deviceAddress: String) {
-        // Wait for connection request from the peer and accept joining
-        runExternalApproverForGroupProcess(deviceAddress, false /* isGroupInvitation */)
-    }
-
     @Rpc(description = "Ensure the target device is connected")
     fun ensureDeviceConnected(deviceName: String) {
         // Retrieve peers and ensure the target device is connected
diff --git a/tests/cts/net/Android.bp b/tests/cts/net/Android.bp
index 1ba581a8d4..9aa4f8036f 100644
--- a/tests/cts/net/Android.bp
+++ b/tests/cts/net/Android.bp
@@ -21,13 +21,28 @@ java_defaults {
     name: "CtsNetTestCasesDefaults",
     defaults: [
         "cts_defaults",
-        "framework-connectivity-test-defaults",
     ],
 
     // Include both the 32 and 64 bit versions
     compile_multilib: "both",
 
+    sdk_version: "module_current",
     libs: [
+        "framework-annotations-lib",
+        "framework-connectivity.impl",
+        "framework-connectivity-b.impl",
+        "framework-connectivity-t.impl",
+        "framework-tethering.impl",
+        "framework-configinfrastructure.stubs.module_lib",
+        "framework-bluetooth.stubs.module_lib",
+        "android.net.ipsec.ike.stubs.module_lib",
+        "framework-wifi.stubs.module_lib",
+
+        // module_current stubs will hide test_stubs symbols in classes that also have module API
+        // (for example UserManager#isVisibleBackgroundUsersSupported is test API but UserManager
+        // is picked up from module lib stubs so that method will not be there). But test_stubs
+        // still provide stubs for classes that are only test API, such as VintfRuntimeInfo.
+        "android_test_stubs_current",
         "voip-common",
         "android.test.base.stubs",
     ],
@@ -53,11 +68,13 @@ java_defaults {
         "cts-net-utils",
         "CtsNetTestsNonUpdatableLib",
         "ctstestrunner-axt",
+        "DhcpPacketLib",
         "junit",
         "junit-params",
         "modules-utils-build",
         "net-tests-utils",
         "net-utils-framework-common",
+        "NetworkStackApiCurrentShims",
         "truth",
         "TetheringIntegrationTestsBaseLib",
     ],
@@ -65,6 +82,7 @@ java_defaults {
     min_sdk_version: "30",
     per_testcase_directory: true,
     host_required: ["net-tests-utils-host-common"],
+    host_common_data: [":net-tests-utils-host-common"],
     test_config_template: "AndroidTestTemplate.xml",
     data: [
         ":ConnectivityTestPreparer",
@@ -88,11 +106,6 @@ android_test {
     name: "CtsNetTestCases",
     defaults: [
         "CtsNetTestCasesDefaults",
-        "ConnectivityNextEnableDefaults",
-    ],
-    static_libs: [
-        "DhcpPacketLib",
-        "NetworkStackApiCurrentShims",
     ],
     test_suites: [
         "automotive-general-tests",
@@ -101,24 +114,13 @@ android_test {
         "mcts-tethering",
         "general-tests",
     ],
-}
-
-java_defaults {
-    name: "CtsNetTestCasesApiStableDefaults",
-    // TODO: CTS should not depend on the entirety of the networkstack code.
-    static_libs: [
-        "DhcpPacketLib",
-        "NetworkStackApiStableShims",
-    ],
-    jni_uses_sdk_apis: true,
-    min_sdk_version: "30",
+    resource_zips: [":connectivity-module-version-as-resource-zip"],
 }
 
 java_defaults {
     name: "CtsNetTestCasesMaxTargetSdkDefaults",
     defaults: [
         "CtsNetTestCasesDefaults",
-        "CtsNetTestCasesApiStableDefaults",
     ],
     test_suites: [
         "cts",
@@ -134,6 +136,14 @@ android_test {
     target_sdk_version: "33",
     package_name: "android.net.cts.maxtargetsdk33",
     instrumentation_target_package: "android.net.cts.maxtargetsdk33",
+    test_options: {
+        test_runner_options: [
+            {
+                name: "include-annotation",
+                value: "com.android.testutils.filters.CtsNetTestCasesMaxTargetSdk33",
+            },
+        ],
+    },
 }
 
 android_test {
@@ -142,6 +152,14 @@ android_test {
     target_sdk_version: "31",
     package_name: "android.net.cts.maxtargetsdk31", // CTS package names must be unique.
     instrumentation_target_package: "android.net.cts.maxtargetsdk31",
+    test_options: {
+        test_runner_options: [
+            {
+                name: "include-annotation",
+                value: "com.android.testutils.filters.CtsNetTestCasesMaxTargetSdk31",
+            },
+        ],
+    },
 }
 
 android_test {
@@ -150,6 +168,14 @@ android_test {
     target_sdk_version: "30",
     package_name: "android.net.cts.maxtargetsdk30", // CTS package names must be unique.
     instrumentation_target_package: "android.net.cts.maxtargetsdk30",
+    test_options: {
+        test_runner_options: [
+            {
+                name: "include-annotation",
+                value: "com.android.testutils.filters.CtsNetTestCasesMaxTargetSdk30",
+            },
+        ],
+    },
 }
 
 android_test_helper_app {
diff --git a/tests/cts/net/AndroidTestTemplate.xml b/tests/cts/net/AndroidTestTemplate.xml
index cb0e57539a..de21efc2ce 100644
--- a/tests/cts/net/AndroidTestTemplate.xml
+++ b/tests/cts/net/AndroidTestTemplate.xml
@@ -47,18 +47,10 @@
         <option name="hidden-api-checks" value="false" />
         <option name="isolated-storage" value="false" />
         <option name="instrumentation-arg" key="test-module-name" value="{MODULE}" />
-        <!-- Test filter that allows test APKs to select which tests they want to run by annotating
-             those tests with an annotation matching the name of the APK.
-
-             This allows us to maintain one AndroidTestTemplate.xml for all CtsNetTestCases*.apk,
-             and have CtsNetTestCases run all tests, but have CtsNetTestCasesMaxTargetSdk31 run only
-             tests that require target SDK 31.
-
-             This relies on the fact that if the class specified in include-annotation exists, then
-             the runner will only run the tests annotated with that annotation, but if it does not,
-             the runner will run all the tests. -->
-        <option name="include-annotation" value="com.android.testutils.filters.{MODULE}" />
         <option name="device-listeners" value="com.android.testutils.ConnectivityDiagnosticsCollector" />
+        <!-- Extra configuration specified in the build rules (.bp). In particular, they may specify
+         include-annotation filters to only run a subset of the test cases. -->
+        {EXTRA_TEST_RUNNER_CONFIGS}
     </test>
     <metrics_collector class="com.android.tradefed.device.metric.FilePullerLogCollector">
         <!-- Pattern matching the fileKey used by ConnectivityDiagnosticsCollector when calling addFileMetric -->
diff --git a/tests/cts/net/api23Test/Android.bp b/tests/cts/net/api23Test/Android.bp
index 7d93c3ac7d..856f171de8 100644
--- a/tests/cts/net/api23Test/Android.bp
+++ b/tests/cts/net/api23Test/Android.bp
@@ -57,4 +57,6 @@ android_test {
     ],
     per_testcase_directory: true,
     sdk_version: "test_current",
+    host_required: ["net-tests-utils-host-common"],
+    host_common_data: [":net-tests-utils-host-common"],
 }
diff --git a/tests/cts/net/api23Test/AndroidTest.xml b/tests/cts/net/api23Test/AndroidTest.xml
index fcc73f38da..cc5568b3f7 100644
--- a/tests/cts/net/api23Test/AndroidTest.xml
+++ b/tests/cts/net/api23Test/AndroidTest.xml
@@ -25,6 +25,10 @@
         <option name="test-file-name" value="CtsNetApi23TestCases.apk" />
         <option name="test-file-name" value="CtsNetTestAppForApi23.apk" />
     </target_preparer>
+    <target_preparer class="com.android.testutils.ConnectivityTestTargetPreparer">
+        <!-- The tests require a working Wi-Fi network only -->
+        <option name="ignore-mobile-data-check" value="true" />
+    </target_preparer>
     <test class="com.android.tradefed.testtype.AndroidJUnitTest" >
         <option name="package" value="android.net.cts.api23test" />
         <option name="hidden-api-checks" value="false" />
diff --git a/tests/cts/net/jni/Android.bp b/tests/cts/net/jni/Android.bp
index fbf4f29df5..9ac15881f1 100644
--- a/tests/cts/net/jni/Android.bp
+++ b/tests/cts/net/jni/Android.bp
@@ -26,6 +26,9 @@ cc_defaults {
         "-Wno-format",
         "-Wno-unused-parameter",
     ],
+    header_libs: [
+        "libbase_headers",
+    ],
     shared_libs: [
         "libandroid",
         "libnativehelper_compat_libc++",
diff --git a/tests/cts/net/jni/NativeMultinetworkJni.cpp b/tests/cts/net/jni/NativeMultinetworkJni.cpp
index 1d848ec0ea..d4fa365934 100644
--- a/tests/cts/net/jni/NativeMultinetworkJni.cpp
+++ b/tests/cts/net/jni/NativeMultinetworkJni.cpp
@@ -33,10 +33,15 @@
 
 #include <string>
 
+#include <android-base/scopeguard.h>
+#include <android-base/unique_fd.h>
 #include <android/log.h>
 #include <android/multinetwork.h>
 #include <nativehelper/JNIHelp.h>
 
+using android::base::make_scope_guard;
+using android::base::unique_fd;
+
 #define LOGD(fmt, ...) \
         __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, fmt, ##__VA_ARGS__)
 
@@ -437,28 +442,25 @@ JNIEXPORT jobject Java_android_net_cts_MultinetworkApiTest_runDatagramCheck(
 
     static const char kPort[] = "443";
     int rval = android_getaddrinfofornetwork(handle, kHostname, kPort, &kHints, &res);
+    auto res_guard = make_scope_guard([res] { freeaddrinfo(res); });
     if (rval != 0) {
         LOGD("android_getaddrinfofornetwork(%llu, %s) returned rval=%d errno=%d",
               handle, kHostname, rval, errno);
-        freeaddrinfo(res);
         return create_query_test_result(env, 0, 0, errno);
     }
 
     // Rely upon getaddrinfo sorting the best destination to the front.
-    int fd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
-    if (fd < 0) {
+    auto fd = unique_fd(socket(res->ai_family, res->ai_socktype, res->ai_protocol));
+    if (!fd.ok()) {
         LOGD("socket(%d, %d, %d) failed, errno=%d",
               res->ai_family, res->ai_socktype, res->ai_protocol, errno);
-        freeaddrinfo(res);
         return create_query_test_result(env, 0, 0, errno);
     }
 
-    rval = android_setsocknetwork(handle, fd);
+    rval = android_setsocknetwork(handle, fd.get());
     LOGD("android_setprocnetwork(%llu, %d) returned rval=%d errno=%d",
-          handle, fd, rval, errno);
+          handle, fd.get(), rval, errno);
     if (rval != 0) {
-        close(fd);
-        freeaddrinfo(res);
         return create_query_test_result(env, 0, 0, errno);
     }
 
@@ -478,10 +480,8 @@ JNIEXPORT jobject Java_android_net_cts_MultinetworkApiTest_runDatagramCheck(
                 .sin_addr = { .s_addr = INADDR_ANY },
             };
         }
-        if (bind(fd, (sockaddr *)&src_addr, src_addrlen) != 0) {
+        if (bind(fd.get(), (sockaddr *)&src_addr, src_addrlen) != 0) {
             LOGD("Error binding to port %d", src_port);
-            close(fd);
-            freeaddrinfo(res);
             return create_query_test_result(env, 0, 0, errno);
         }
     }
@@ -490,16 +490,12 @@ JNIEXPORT jobject Java_android_net_cts_MultinetworkApiTest_runDatagramCheck(
     sockaddr_ntop(res->ai_addr, res->ai_addrlen, addrstr, sizeof(addrstr));
     LOGD("Attempting connect() to %s ...", addrstr);
 
-    rval = connect(fd, res->ai_addr, res->ai_addrlen);
+    rval = connect(fd.get(), res->ai_addr, res->ai_addrlen);
     if (rval != 0) {
-        close(fd);
-        freeaddrinfo(res);
         return create_query_test_result(env, 0, 0, errno);
     }
-    freeaddrinfo(res);
 
-    if (getsockname(fd, (struct sockaddr *)&src_addr, &src_addrlen) != 0) {
-        close(fd);
+    if (getsockname(fd.get(), (struct sockaddr *)&src_addr, &src_addrlen) != 0) {
         return create_query_test_result(env, 0, 0, errno);
     }
     sockaddr_ntop((const struct sockaddr *)&src_addr, sizeof(src_addr), addrstr, sizeof(addrstr));
@@ -512,14 +508,13 @@ JNIEXPORT jobject Java_android_net_cts_MultinetworkApiTest_runDatagramCheck(
         socket_src_port = ntohs(reinterpret_cast<sockaddr_in*>(&src_addr)->sin_port);
     } else {
         LOGD("Invalid source address family %d", src_addr.ss_family);
-        close(fd);
         return create_query_test_result(env, 0, 0, EAFNOSUPPORT);
     }
 
     // Don't let reads or writes block indefinitely.
     const struct timeval timeo = { 2, 0 };  // 2 seconds
-    setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &timeo, sizeof(timeo));
-    setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &timeo, sizeof(timeo));
+    setsockopt(fd.get(), SOL_SOCKET, SO_RCVTIMEO, &timeo, sizeof(timeo));
+    setsockopt(fd.get(), SOL_SOCKET, SO_SNDTIMEO, &timeo, sizeof(timeo));
 
     // For reference see:
     //     https://datatracker.ietf.org/doc/html/draft-ietf-quic-invariants
@@ -539,15 +534,14 @@ JNIEXPORT jobject Java_android_net_cts_MultinetworkApiTest_runDatagramCheck(
     int i, errnum = 0;
 
     for (i = 0; i < MAX_RETRIES; i++) {
-        sent = send(fd, quic_packet, sizeof(quic_packet), 0);
+        sent = send(fd.get(), quic_packet, sizeof(quic_packet), 0);
         if (sent < (ssize_t)sizeof(quic_packet)) {
             errnum = errno;
             LOGD("send(QUIC packet) returned sent=%zd, errno=%d", sent, errnum);
-            close(fd);
             return create_query_test_result(env, socket_src_port, i + 1, errnum);
         }
 
-        rcvd = recv(fd, response, sizeof(response), 0);
+        rcvd = recv(fd.get(), response, sizeof(response), 0);
         if (rcvd > 0) {
             break;
         } else {
@@ -561,7 +555,6 @@ JNIEXPORT jobject Java_android_net_cts_MultinetworkApiTest_runDatagramCheck(
         if (rcvd <= 0) {
             LOGD("Does this network block UDP port %s?", kPort);
         }
-        close(fd);
         return create_query_test_result(env, socket_src_port, i + 1,
                 rcvd <= 0 ? errnum : EPROTO);
     }
@@ -569,12 +562,9 @@ JNIEXPORT jobject Java_android_net_cts_MultinetworkApiTest_runDatagramCheck(
     int conn_id_cmp = memcmp(quic_packet + 6, response + 7, 8);
     if (conn_id_cmp != 0) {
         LOGD("sent and received connection IDs do not match");
-        close(fd);
         return create_query_test_result(env, socket_src_port, i + 1, EPROTO);
     }
 
     // TODO: Replace this quick 'n' dirty test with proper QUIC-capable code.
-
-    close(fd);
     return create_query_test_result(env, socket_src_port, i + 1, 0);
 }
diff --git a/tests/cts/net/native/Android.bp b/tests/cts/net/native/Android.bp
deleted file mode 100644
index 3f2459278c..0000000000
--- a/tests/cts/net/native/Android.bp
+++ /dev/null
@@ -1,61 +0,0 @@
-// Copyright (C) 2017 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// Build the unit tests.
-
-package {
-    default_team: "trendy_team_fwk_core_networking",
-    default_applicable_licenses: ["Android-Apache-2.0"],
-}
-
-cc_test {
-    name: "CtsNativeNetTestCases",
-
-    compile_multilib: "both",
-    multilib: {
-        lib32: {
-            suffix: "32",
-        },
-        lib64: {
-            suffix: "64",
-        },
-    },
-
-    srcs: [
-        "src/BpfCompatTest.cpp",
-    ],
-
-    shared_libs: [
-        "libbase",
-        "liblog",
-    ],
-
-    static_libs: [
-        "libbpf_android",
-        "libgtest",
-        "libmodules-utils-build",
-    ],
-
-    // Tag this module as a cts test artifact
-    test_suites: [
-        "cts",
-        "general-tests",
-    ],
-
-    cflags: [
-        "-Werror",
-        "-Wall",
-    ],
-
-}
diff --git a/tests/cts/net/native/AndroidTest.xml b/tests/cts/net/native/AndroidTest.xml
deleted file mode 100644
index 70d788a34a..0000000000
--- a/tests/cts/net/native/AndroidTest.xml
+++ /dev/null
@@ -1,32 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright 2017 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<configuration description="Config for CTS Native Network test cases">
-    <option name="test-suite-tag" value="cts" />
-    <option name="config-descriptor:metadata" key="component" value="networking" />
-    <option name="config-descriptor:metadata" key="parameter" value="instant_app" />
-    <option name="config-descriptor:metadata" key="parameter" value="multi_abi" />
-    <option name="config-descriptor:metadata" key="parameter" value="secondary_user" />
-    <target_preparer class="com.android.compatibility.common.tradefed.targetprep.FilePusher">
-        <option name="cleanup" value="true" />
-        <option name="push" value="CtsNativeNetTestCases->/data/local/tmp/CtsNativeNetTestCases" />
-        <option name="append-bitness" value="true" />
-    </target_preparer>
-    <test class="com.android.tradefed.testtype.GTest" >
-        <option name="native-test-device-path" value="/data/local/tmp" />
-        <option name="module-name" value="CtsNativeNetTestCases" />
-        <option name="runtime-hint" value="1m" />
-    </test>
-</configuration>
diff --git a/tests/cts/net/native/dns/Android.bp b/tests/cts/net/native/dns/Android.bp
index 8138598f0b..a9d0440e69 100644
--- a/tests/cts/net/native/dns/Android.bp
+++ b/tests/cts/net/native/dns/Android.bp
@@ -45,6 +45,7 @@ cc_defaults {
     // To be compatible with R devices, the min_sdk_version must be 30.
     min_sdk_version: "30",
     host_required: ["net-tests-utils-host-common"],
+    host_common_data: [":net-tests-utils-host-common"],
 }
 
 cc_test {
diff --git a/tests/cts/net/native/src/BpfCompatTest.cpp b/tests/cts/net/native/src/BpfCompatTest.cpp
deleted file mode 100644
index e2fdd3d6ac..0000000000
--- a/tests/cts/net/native/src/BpfCompatTest.cpp
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless requied by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-#define LOG_TAG "BpfCompatTest"
-
-#include <fstream>
-
-#include <gtest/gtest.h>
-
-#include "android-modules-utils/sdk_level.h"
-
-#include "libbpf_android.h"
-
-using namespace android::bpf;
-
-void doBpfStructSizeTest(const char *elfPath, unsigned mapSz, unsigned progSz) {
-  std::ifstream elfFile(elfPath, std::ios::in | std::ios::binary);
-  ASSERT_TRUE(elfFile.is_open());
-
-  EXPECT_EQ(mapSz, readSectionUint("size_of_bpf_map_def", elfFile, 0));
-  EXPECT_EQ(progSz, readSectionUint("size_of_bpf_prog_def", elfFile, 0));
-}
-
-TEST(BpfTest, bpfStructSizeTest) {
-  if (android::modules::sdklevel::IsAtLeastV()) {
-    // Due to V+ using mainline netbpfload, there is no longer a need to
-    // enforce consistency between platform and mainline bpf .o files.
-    GTEST_SKIP() << "V+ device.";
-  } else if (android::modules::sdklevel::IsAtLeastU()) {
-    doBpfStructSizeTest("/system/etc/bpf/gpuMem.o", 120, 92);
-    doBpfStructSizeTest("/system/etc/bpf/timeInState.o", 120, 92);
-  } else if (android::modules::sdklevel::IsAtLeastT()) {
-    doBpfStructSizeTest("/system/etc/bpf/gpu_mem.o", 116, 92);
-    doBpfStructSizeTest("/system/etc/bpf/time_in_state.o", 116, 92);
-  } else if (android::modules::sdklevel::IsAtLeastS()) {
-    // These files were moved to mainline in Android T
-    doBpfStructSizeTest("/system/etc/bpf/netd.o", 48, 28);
-    doBpfStructSizeTest("/system/etc/bpf/clatd.o", 48, 28);
-  } else {
-    // There is no mainline bpf code before S.
-    GTEST_SKIP() << "R- device.";
-  }
-}
-
-int main(int argc, char **argv) {
-  testing::InitGoogleTest(&argc, argv);
-  return RUN_ALL_TESTS();
-}
diff --git a/tests/cts/net/src/android/net/cts/ApfIntegrationTest.kt b/tests/cts/net/src/android/net/cts/ApfIntegrationTest.kt
index 7dbb9b24a9..a731e31932 100644
--- a/tests/cts/net/src/android/net/cts/ApfIntegrationTest.kt
+++ b/tests/cts/net/src/android/net/cts/ApfIntegrationTest.kt
@@ -19,8 +19,10 @@
 
 package android.net.cts
 
+import android.Manifest.permission
 import android.content.pm.PackageManager.FEATURE_AUTOMOTIVE
 import android.content.pm.PackageManager.FEATURE_LEANBACK
+import android.content.pm.PackageManager.FEATURE_WATCH
 import android.content.pm.PackageManager.FEATURE_WIFI
 import android.net.ConnectivityManager
 import android.net.Network
@@ -71,7 +73,8 @@ import com.android.compatibility.common.util.PropertyUtil.getVsrApiLevel
 import com.android.compatibility.common.util.SystemUtil.runShellCommand
 import com.android.compatibility.common.util.SystemUtil.runShellCommandOrThrow
 import com.android.compatibility.common.util.VsrTest
-import com.android.internal.util.HexDump
+import com.android.modules.utils.build.SdkLevel
+import com.android.net.module.util.HexDump
 import com.android.net.module.util.NetworkStackConstants.ETHER_ADDR_LEN
 import com.android.net.module.util.NetworkStackConstants.ETHER_DST_ADDR_OFFSET
 import com.android.net.module.util.NetworkStackConstants.ETHER_HEADER_LEN
@@ -83,11 +86,12 @@ import com.android.testutils.DevSdkIgnoreRule
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
 import com.android.testutils.DevSdkIgnoreRunner
 import com.android.testutils.NetworkStackModuleTest
-import com.android.testutils.RecorderCallback.CallbackEntry.Available
-import com.android.testutils.RecorderCallback.CallbackEntry.LinkPropertiesChanged
 import com.android.testutils.SkipPresubmit
 import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.Available
+import com.android.testutils.TestableNetworkCallback.Event.LinkPropertiesChanged
 import com.android.testutils.pollingCheck
+import com.android.testutils.runAsShell
 import com.android.testutils.waitForIdle
 import com.google.common.truth.Expect
 import com.google.common.truth.Truth.assertThat
@@ -106,6 +110,7 @@ import kotlin.test.assertNotNull
 import org.junit.After
 import org.junit.AfterClass
 import org.junit.Assume.assumeFalse
+import org.junit.Assume.assumeTrue
 import org.junit.Before
 import org.junit.BeforeClass
 import org.junit.Rule
@@ -117,6 +122,8 @@ private const val TIMEOUT_MS = 2000L
 private const val RCV_BUFFER_SIZE = 1480
 private const val PING_HEADER_LENGTH = 8
 
+open class FromU<Type>(val value: Type)
+
 @AppModeFull(reason = "CHANGE_NETWORK_STATE permission can't be granted to instant apps")
 @RunWith(DevSdkIgnoreRunner::class)
 @RequiresDevice
@@ -130,6 +137,8 @@ class ApfIntegrationTest {
         private val context = InstrumentationRegistry.getInstrumentation().context
         private val powerManager = context.getSystemService(PowerManager::class.java)!!
         private val wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG)
+        private var isLowPowerStandbyOriginalEnabled: Boolean = false
+        private var originalPolicy: FromU<PowerManager.LowPowerStandbyPolicy?>? = null
 
         fun turnScreenOff() {
             if (!wakeLock.isHeld()) wakeLock.acquire()
@@ -163,7 +172,37 @@ class ApfIntegrationTest {
             val packageManager = context.getPackageManager()
             val userManager = context.getSystemService(UserManager::class.java)!!
             return (packageManager.hasSystemFeature(FEATURE_AUTOMOTIVE) &&
-                    userManager.isVisibleBackgroundUsersSupported)
+                    // isVisibleBackgroundUsersSupported is @TestApi, but this test should build
+                    // against module API stubs, which do not include it (b/409931932).
+                    userManager.javaClass.getMethod("isVisibleBackgroundUsersSupported")
+                        .invoke(userManager) as Boolean)
+        }
+
+        private fun disableLowPowerStandby() {
+            if (!SdkLevel.isAtLeastU()) {
+                return
+            }
+            runAsShell(permission.DEVICE_POWER) {
+                if (powerManager.isLowPowerStandbySupported) {
+                    isLowPowerStandbyOriginalEnabled = powerManager.isLowPowerStandbyEnabled
+                    originalPolicy = FromU(powerManager.lowPowerStandbyPolicy)
+                    powerManager.isLowPowerStandbyEnabled = false
+                    Log.i(TAG, "Low power standby is supported, disabling it temporary.")
+                }
+            }
+        }
+
+        private fun restoreLowPowerStandby() {
+            if (!SdkLevel.isAtLeastU()) {
+                return
+            }
+            runAsShell(permission.DEVICE_POWER) {
+                if (powerManager.isLowPowerStandbySupported) {
+                    powerManager.isLowPowerStandbyEnabled = isLowPowerStandbyOriginalEnabled
+                    powerManager.lowPowerStandbyPolicy = originalPolicy?.value
+                    Log.i(TAG, "Reset Low power standby to original state.")
+                }
+            }
         }
 
         @BeforeClass
@@ -180,12 +219,14 @@ class ApfIntegrationTest {
             Thread.sleep(1000)
             // TODO: check that there is no active wifi network. Otherwise, ApfFilter has already been
             // created.
+            disableLowPowerStandby()
         }
 
         @AfterClass
         @JvmStatic
         fun tearDownOnce() {
             turnScreenOn()
+            restoreLowPowerStandby()
         }
     }
 
@@ -312,6 +353,10 @@ class ApfIntegrationTest {
             isTvDeviceSupportFullNetworkingUnder2w()
         )
 
+        // APF GMS-VSR requirements don't apply to automotive devices. There is no power benefit to
+        // running APF on automotive as the device has almost infinite battery power.
+        assumeFalse("Skip test: automotive device", pm.hasSystemFeature(FEATURE_AUTOMOTIVE))
+
         networkCallback = TestableNetworkCallback()
         cm.requestNetwork(
                 NetworkRequest.Builder()
@@ -351,15 +396,28 @@ class ApfIntegrationTest {
         }
     }
 
+    private fun shouldEnforceApfSupport(vsrApiLevel: Int): Boolean {
+        // Note: GMS-VSR requirements related to APFv4/APFv6 are only applicable to handheld
+        // and tablet devices. GTVS requirements related to APFv6 are only applicable to TV devices.
+        // For Wear OS devices, APFv4/APFv6 will not be enforced until Wear OS 7.
+        if (pm.hasSystemFeature(FEATURE_WATCH)) {
+            // Enforce APF on watch post VSR-16.
+            return vsrApiLevel > 202504
+        }
+        return vsrApiLevel >= 34
+    }
+
     @VsrTest(
         requirements = ["VSR-5.3.12-001", "VSR-5.3.12-003", "VSR-5.3.12-004", "VSR-5.3.12-009",
             "VSR-5.3.12-012"]
     )
     @Test
     fun testApfCapabilities() {
+        // If APF is supported, the version must be valid.
+        assertThat(caps.apfVersionSupported).isAnyOf(0, 2, 3, 4, 6000, 6100)
         // APF became mandatory in Android 14 VSR.
         val vsrApiLevel = getVsrApiLevel()
-        assume().that(vsrApiLevel).isAtLeast(34)
+        assumeTrue(shouldEnforceApfSupport(vsrApiLevel))
 
         // DEVICEs launching with Android 14 with CHIPSETs that set ro.board.first_api_level to 34:
         // - [GMS-VSR-5.3.12-003] MUST return 4 or higher as the APF version number from calls to
@@ -434,8 +492,8 @@ class ApfIntegrationTest {
     @SkipPresubmit(reason = "This test takes longer than 1 minute, do not run it on presubmit.")
     // APF integration is mostly broken before V, only run the full read / write test on V+.
     @IgnoreUpTo(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
-    // Increase timeout for test to 15 minutes to accommodate device with large APF RAM.
-    @Test(timeout = 15 * 60 * 1000)
+    // Increase timeout for test to 20 minutes to accommodate device with large APF RAM.
+    @Test(timeout = 20 * 60 * 1000)
     fun testReadWriteProgram() {
         assumeApfVersionSupportAtLeast(4)
 
diff --git a/tests/cts/net/src/android/net/cts/CaptivePortalTest.kt b/tests/cts/net/src/android/net/cts/CaptivePortalTest.kt
index 1389be7757..460c21b9b9 100644
--- a/tests/cts/net/src/android/net/cts/CaptivePortalTest.kt
+++ b/tests/cts/net/src/android/net/cts/CaptivePortalTest.kt
@@ -48,7 +48,7 @@ import com.android.net.module.util.NetworkStackConstants.TEST_CAPTIVE_PORTAL_HTT
 import com.android.net.module.util.NetworkStackConstants.TEST_CAPTIVE_PORTAL_HTTP_URL
 import com.android.testutils.AutoReleaseNetworkCallbackRule
 import com.android.testutils.DeviceConfigRule
-import com.android.testutils.RecorderCallback.CallbackEntry.CapabilitiesChanged
+import com.android.testutils.TestableNetworkCallback.Event.CapabilitiesChanged
 import com.android.testutils.SkipMainlinePresubmit
 import com.android.testutils.TestHttpServer
 import com.android.testutils.TestHttpServer.Request
diff --git a/tests/cts/net/src/android/net/cts/ConnectivityDiagnosticsManagerTest.java b/tests/cts/net/src/android/net/cts/ConnectivityDiagnosticsManagerTest.java
index faaadeeb43..b5a31ad8c3 100644
--- a/tests/cts/net/src/android/net/cts/ConnectivityDiagnosticsManagerTest.java
+++ b/tests/cts/net/src/android/net/cts/ConnectivityDiagnosticsManagerTest.java
@@ -82,10 +82,10 @@ import androidx.test.InstrumentationRegistry;
 
 import com.android.compatibility.common.util.SystemUtil;
 import com.android.compatibility.common.util.ThrowingRunnable;
-import com.android.internal.telephony.uicc.IccUtils;
-import com.android.internal.util.ArrayUtils;
 import com.android.modules.utils.build.SdkLevel;
 import com.android.net.module.util.ArrayTrackRecord;
+import com.android.net.module.util.CollectionUtils;
+import com.android.net.module.util.HexDump;
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo;
 import com.android.testutils.DevSdkIgnoreRunner;
 import com.android.testutils.com.android.testutils.CarrierConfigRule;
@@ -280,7 +280,7 @@ public class ConnectivityDiagnosticsManagerTest {
                         mContext.getOpPackageName(), PackageManager.GET_SIGNATURES);
         final MessageDigest md = MessageDigest.getInstance(SHA_256);
         final byte[] certHash = md.digest(pkgInfo.signatures[0].toByteArray());
-        return IccUtils.bytesToHexString(certHash);
+        return HexDump.toHexString(certHash);
     }
 
     private void doBroadcastCarrierConfigsAndVerifyOnConnectivityReportAvailable(
@@ -680,7 +680,7 @@ public class ConnectivityDiagnosticsManagerTest {
             final String[] certs = carrierConfigs.getStringArray(
                     CarrierConfigManager.KEY_CARRIER_CERTIFICATE_STRING_ARRAY);
             try {
-                if (ArrayUtils.contains(certs, getCertHashForThisPackage())) {
+                if (CollectionUtils.contains(certs, getCertHashForThisPackage())) {
                     // Received an update for this package's cert hash - countdown and exit
                     mLatch.countDown();
                 }
diff --git a/tests/cts/net/src/android/net/cts/ConnectivityFrameworkInitializerTiramisuTest.kt b/tests/cts/net/src/android/net/cts/ConnectivityFrameworkInitializerTiramisuTest.kt
index 049372f576..61139330c3 100644
--- a/tests/cts/net/src/android/net/cts/ConnectivityFrameworkInitializerTiramisuTest.kt
+++ b/tests/cts/net/src/android/net/cts/ConnectivityFrameworkInitializerTiramisuTest.kt
@@ -17,11 +17,11 @@
 package android.net.cts
 
 import android.net.nsd.NsdManager
+import android.os.Build
 import androidx.test.platform.app.InstrumentationRegistry
 import com.android.networkstack.apishim.ConnectivityFrameworkInitShimImpl
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
 import com.android.testutils.DevSdkIgnoreRunner
-import com.android.testutils.SC_V2
 import org.junit.Test
 import org.junit.runner.RunWith
 import kotlin.test.assertNotNull
@@ -30,7 +30,7 @@ private val cfiShim = ConnectivityFrameworkInitShimImpl.newInstance()
 
 @RunWith(DevSdkIgnoreRunner::class)
 // ConnectivityFrameworkInitializerTiramisu was added in T
-@IgnoreUpTo(SC_V2) // TODO: Use to Build.VERSION_CODES.SC_V2 when available
+@IgnoreUpTo(Build.VERSION_CODES.S_V2)
 class ConnectivityFrameworkInitializerTiramisuTest {
     @Test
     fun testServicesRegistered() {
diff --git a/tests/cts/net/src/android/net/cts/ConnectivityManagerTest.java b/tests/cts/net/src/android/net/cts/ConnectivityManagerTest.java
index 87c2b9e5d1..a758b57b6c 100644
--- a/tests/cts/net/src/android/net/cts/ConnectivityManagerTest.java
+++ b/tests/cts/net/src/android/net/cts/ConnectivityManagerTest.java
@@ -21,12 +21,14 @@ import static android.Manifest.permission.ACCESS_FINE_LOCATION;
 import static android.Manifest.permission.ACCESS_NETWORK_STATE;
 import static android.Manifest.permission.CONNECTIVITY_INTERNAL;
 import static android.Manifest.permission.CONNECTIVITY_USE_RESTRICTED_NETWORKS;
+import static android.Manifest.permission.MANAGE_TEST_NETWORKS;
 import static android.Manifest.permission.NETWORK_FACTORY;
 import static android.Manifest.permission.NETWORK_SETTINGS;
 import static android.Manifest.permission.NETWORK_SETUP_WIZARD;
 import static android.Manifest.permission.NETWORK_STACK;
 import static android.Manifest.permission.READ_DEVICE_CONFIG;
 import static android.Manifest.permission.TETHER_PRIVILEGED;
+import static android.content.pm.PackageManager.FEATURE_AUTOMOTIVE;
 import static android.content.pm.PackageManager.FEATURE_BLUETOOTH;
 import static android.content.pm.PackageManager.FEATURE_ETHERNET;
 import static android.content.pm.PackageManager.FEATURE_TELEPHONY;
@@ -96,10 +98,14 @@ import static android.net.cts.util.CtsNetUtils.TEST_HOST;
 import static android.net.cts.util.CtsTetheringUtils.TestTetheringEventCallback;
 import static android.os.MessageQueue.OnFileDescriptorEventListener.EVENT_INPUT;
 import static android.os.Process.INVALID_UID;
-import static android.provider.Settings.Global.NETWORK_METERED_MULTIPATH_PREFERENCE;
 import static android.system.OsConstants.AF_INET;
 import static android.system.OsConstants.AF_INET6;
 import static android.system.OsConstants.AF_UNSPEC;
+import static android.system.OsConstants.ECONNABORTED;
+import static android.system.OsConstants.EDESTADDRREQ;
+import static android.system.OsConstants.IPPROTO_UDP;
+import static android.system.OsConstants.POLLIN;
+import static android.system.OsConstants.SOCK_DGRAM;
 
 import static com.android.compatibility.common.util.SystemUtil.callWithShellPermissionIdentity;
 import static com.android.compatibility.common.util.SystemUtil.runShellCommand;
@@ -112,7 +118,6 @@ import static com.android.networkstack.apishim.ConstantsShim.BLOCKED_REASON_NONE
 import static com.android.networkstack.apishim.ConstantsShim.RECEIVER_EXPORTED;
 import static com.android.networkstack.apishim.ConstantsShim.RECEIVER_NOT_EXPORTED;
 import static com.android.testutils.Cleanup.testAndCleanup;
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
 import static com.android.testutils.MiscAsserts.assertEventuallyTrue;
 import static com.android.testutils.MiscAsserts.assertThrows;
 import static com.android.testutils.TestNetworkTrackerKt.initTestNetwork;
@@ -182,14 +187,18 @@ import android.os.ConditionVariable;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.MessageQueue;
+import android.os.ParcelFileDescriptor;
 import android.os.Process;
-import android.os.ServiceManager;
+import android.os.RemoteException;
 import android.os.SystemClock;
 import android.os.UserHandle;
 import android.os.VintfRuntimeInfo;
 import android.platform.test.annotations.AppModeFull;
 import android.provider.DeviceConfig;
 import android.provider.Settings;
+import android.system.ErrnoException;
+import android.system.Os;
+import android.system.StructPollfd;
 import android.telephony.SubscriptionManager;
 import android.telephony.TelephonyManager;
 import android.text.TextUtils;
@@ -201,10 +210,13 @@ import androidx.test.filters.RequiresDevice;
 import androidx.test.platform.app.InstrumentationRegistry;
 
 import com.android.compatibility.common.util.DynamicConfigDeviceSide;
-import com.android.internal.util.ArrayUtils;
 import com.android.modules.utils.build.SdkLevel;
 import com.android.net.module.util.CollectionUtils;
 import com.android.net.module.util.DnsPacket;
+import com.android.net.module.util.Struct;
+import com.android.net.module.util.structs.Ipv4Header;
+import com.android.net.module.util.structs.Ipv6Header;
+import com.android.net.module.util.structs.UdpHeader;
 import com.android.networkstack.apishim.ConnectivityManagerShimImpl;
 import com.android.networkstack.apishim.ConstantsShim;
 import com.android.networkstack.apishim.NetworkInformationShimImpl;
@@ -220,7 +232,7 @@ import com.android.testutils.DevSdkIgnoreRunner;
 import com.android.testutils.DeviceConfigRule;
 import com.android.testutils.DeviceInfoUtils;
 import com.android.testutils.DumpTestUtils;
-import com.android.testutils.RecorderCallback.CallbackEntry;
+import com.android.testutils.TestableNetworkCallback.Event;
 import com.android.testutils.SkipPresubmit;
 import com.android.testutils.TestHttpServer;
 import com.android.testutils.TestNetworkTracker;
@@ -228,6 +240,7 @@ import com.android.testutils.TestableNetworkCallback;
 
 import junit.framework.AssertionFailedError;
 
+import libcore.io.IoUtils;
 import libcore.io.Streams;
 
 import org.junit.After;
@@ -253,6 +266,7 @@ import java.net.MalformedURLException;
 import java.net.Socket;
 import java.net.SocketException;
 import java.net.URL;
+import java.nio.ByteBuffer;
 import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -327,6 +341,8 @@ public class ConnectivityManagerTest {
     public static final int MIN_SUPPORTED_CELLULAR_KEEPALIVE_COUNT = 1;
     public static final int MIN_SUPPORTED_WIFI_KEEPALIVE_COUNT = 3;
 
+    private static final String NETWORK_METERED_MULTIPATH_PREFERENCE_SETTING =
+            "network_metered_multipath_preference";
     private static final String NETWORK_METERED_MULTIPATH_PREFERENCE_RES_NAME =
             "config_networkMeteredMultipathPreference";
     private static final String KEEPALIVE_ALLOWED_UNPRIVILEGED_RES_NAME =
@@ -352,6 +368,15 @@ public class ConnectivityManagerTest {
     // Re-connecting to the AP, obtaining an IP address, revalidating can take a long time
     private static final long WIFI_CONNECT_TIMEOUT_MS = 60_000L;
 
+    // Timeout for waiting the QUIC connection close information registration/unregistration
+    private static final long QUIC_CONNECTION_CLOSE_INFO_REGISTRATION_TIMEOUT_MS = 500L;
+
+    // Timeout for waiting the QUIC connection close packet to be sent
+    private static final long QUIC_CONNECTION_CLOSE_PACKET_TIMEOUT_MS = 200L;
+
+    // Name of the feature flag for closing quic connection
+    private static final String CLOSE_QUIC_CONNECTION = "close_quic_connection";
+
     private Context mContext;
     private Instrumentation mInstrumentation;
     private ConnectivityManager mCm;
@@ -457,7 +482,10 @@ public class ConnectivityManagerTest {
             final TestableNetworkCallback callback =
                     networkCallbackRule.registerDefaultNetworkCallback();
             assertNotNull("Couldn't restore Internet connectivity",
-                    callback.eventuallyExpect(CallbackEntry.AVAILABLE));
+                    callback.eventuallyExpect(Event.NETWORK_CAPS_UPDATED,
+                            NETWORK_CALLBACK_TIMEOUT_MS,
+                            entry -> ((Event.CapabilitiesChanged) entry)
+                                    .getCaps().hasCapability(NET_CAPABILITY_VALIDATED)));
         });
     }
 
@@ -567,8 +595,9 @@ public class ConnectivityManagerTest {
         assertNotEquals(SubscriptionManager.INVALID_SUBSCRIPTION_ID, subId);
 
         // Get subscriber Id from telephony manager.
-        final TelephonyManager tm = mContext.getSystemService(TelephonyManager.class);
-        return runWithShellPermissionIdentity(() -> tm.getSubscriberId(subId),
+        final TelephonyManager tm = mContext.getSystemService(TelephonyManager.class)
+                .createForSubscriptionId(subId);
+        return runWithShellPermissionIdentity(() -> tm.getSubscriberId(),
                 android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
     }
 
@@ -627,7 +656,7 @@ public class ConnectivityManagerTest {
             // callbacks. This is guaranteed to succeed because the callback is registered
             // before getAllNetworkStateSnapshots is called.
             final LinkProperties lpFromSnapshot = snapshot.getLinkProperties();
-            allNetworkLinkPropertiesListener.eventuallyExpect(CallbackEntry.LINK_PROPERTIES_CHANGED,
+            allNetworkLinkPropertiesListener.eventuallyExpect(Event.LINK_PROPERTIES_CHANGED,
                     NETWORK_CALLBACK_TIMEOUT_MS, 0 /* mark */, entry ->
                             entry.getNetwork().equals(network)
                                     && entry.getLp().equals(lpFromSnapshot));
@@ -662,7 +691,7 @@ public class ConnectivityManagerTest {
         return null;
     }
 
-    @DevSdkIgnoreRule.IgnoreUpTo(SC_V2)
+    @DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
     @AppModeFull(reason = "Cannot get installed packages in instant app mode")
     @Test
     public void testGetRedactedLinkPropertiesForPackage() throws Exception {
@@ -751,7 +780,7 @@ public class ConnectivityManagerTest {
     }
 
     @ConnectivityModuleTest
-    @DevSdkIgnoreRule.IgnoreUpTo(SC_V2)
+    @DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
     @AppModeFull(reason = "Cannot get installed packages in instant app mode")
     @Test
     public void testGetRedactedNetworkCapabilitiesForPackage() throws Exception {
@@ -1046,14 +1075,6 @@ public class ConnectivityManagerTest {
     }
 
     private boolean hasEthernetService() {
-        // On Q creating EthernetManager from a thread that does not have a looper (like the test
-        // thread) crashes because it tried to use Looper.myLooper() through the default Handler
-        // constructor to run onAvailabilityChanged callbacks. Use ServiceManager to check whether
-        // the service exists instead.
-        // TODO: remove once Q is no longer supported in MTS, as ServiceManager is hidden API
-        if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.Q) {
-            return ServiceManager.getService(Context.ETHERNET_SERVICE) != null;
-        }
         return mContext.getSystemService(Context.ETHERNET_SERVICE) != null;
     }
 
@@ -1113,9 +1134,9 @@ public class ConnectivityManagerTest {
                 .build();
     }
 
-    private boolean hasPrivateDnsValidated(CallbackEntry entry, Network networkForPrivateDns) {
+    private boolean hasPrivateDnsValidated(Event entry, Network networkForPrivateDns) {
         if (!networkForPrivateDns.equals(entry.getNetwork())) return false;
-        final NetworkCapabilities nc = ((CallbackEntry.CapabilitiesChanged) entry).getCaps();
+        final NetworkCapabilities nc = ((Event.CapabilitiesChanged) entry).getCaps();
         return !nc.isPrivateDnsBroken() && nc.hasCapability(NET_CAPABILITY_VALIDATED);
     }
 
@@ -1133,18 +1154,19 @@ public class ConnectivityManagerTest {
         try {
             // Verifying the good private DNS sever
             mCtsNetUtils.setPrivateDnsStrictMode(goodPrivateDnsServer);
-            cb.eventuallyExpect(CallbackEntry.NETWORK_CAPS_UPDATED, NETWORK_CALLBACK_TIMEOUT_MS,
+            cb.eventuallyExpect(Event.NETWORK_CAPS_UPDATED, NETWORK_CALLBACK_TIMEOUT_MS,
                     entry -> hasPrivateDnsValidated(entry, networkForPrivateDns));
 
             // Verifying the broken private DNS sever
             mCtsNetUtils.setPrivateDnsStrictMode(invalidPrivateDnsServer);
-            cb.eventuallyExpect(CallbackEntry.NETWORK_CAPS_UPDATED, NETWORK_CALLBACK_TIMEOUT_MS,
-                    entry -> (((CallbackEntry.CapabilitiesChanged) entry).getCaps()
+            cb.eventuallyExpect(Event.NETWORK_CAPS_UPDATED, NETWORK_CALLBACK_TIMEOUT_MS,
+                    entry -> (((Event.CapabilitiesChanged) entry).getCaps()
                     .isPrivateDnsBroken()) && networkForPrivateDns.equals(entry.getNetwork()));
         } finally {
             mCtsNetUtils.restorePrivateDnsSetting();
             // Toggle networks to make sure they are re-validated
             mCtsNetUtils.reconnectWifiIfSupported();
+            ensureWifiIsValidatedIfSupported();
             mCtsNetUtils.reconnectCellIfSupported();
         }
     }
@@ -1193,22 +1215,22 @@ public class ConnectivityManagerTest {
         // Now we should expect to get a network callback about availability of the wifi
         // network even if it was already connected as a state-based action when the callback
         // is registered.
-        wifiNetwork = callback.eventuallyExpect(CallbackEntry.AVAILABLE).getNetwork();
+        wifiNetwork = callback.eventuallyExpect(Event.AVAILABLE).getNetwork();
         assertNotNull("Did not receive onAvailable for TRANSPORT_WIFI request",
                 wifiNetwork);
 
         final Network defaultNetwork = defaultTrackingCallback.eventuallyExpect(
-                CallbackEntry.AVAILABLE).getNetwork();
+                Event.AVAILABLE).getNetwork();
         assertNotNull("Did not receive onAvailable on default network callback",
                 defaultNetwork);
 
         if (TestUtils.shouldTestSApis()) {
-            systemDefaultCallback.eventuallyExpect(CallbackEntry.AVAILABLE);
-            final Network perUidNetwork = perUidCallback.eventuallyExpect(CallbackEntry.AVAILABLE)
+            systemDefaultCallback.eventuallyExpect(Event.AVAILABLE);
+            final Network perUidNetwork = perUidCallback.eventuallyExpect(Event.AVAILABLE)
                     .getNetwork();
             assertEquals(defaultNetwork, perUidNetwork);
             final Network bestMatchingNetwork = bestMatchingCallback.eventuallyExpect(
-                    CallbackEntry.AVAILABLE).getNetwork();
+                    Event.AVAILABLE).getNetwork();
             assertEquals(defaultNetwork, bestMatchingNetwork);
         }
     }
@@ -1391,7 +1413,7 @@ public class ConnectivityManagerTest {
             if (firstIntent != null) mCm.unregisterNetworkCallback(firstIntent);
             if (secondIntent != null) mCm.unregisterNetworkCallback(secondIntent);
             if (receiver != null) mContext.unregisterReceiver(receiver);
-            mCtsNetUtils.ensureWifiConnected();
+            ensureWifiIsValidatedIfSupported();
         }
     }
 
@@ -1438,7 +1460,7 @@ public class ConnectivityManagerTest {
                         .build());
 
         // Wait to get callback for availability of internet
-        callback.eventuallyExpect(CallbackEntry.AVAILABLE).getNetwork();
+        callback.eventuallyExpect(Event.AVAILABLE).getNetwork();
     }
 
     /**
@@ -1462,7 +1484,7 @@ public class ConnectivityManagerTest {
                 100 /* timeoutMs */);
         try {
             // Wait to get callback for unavailability of requested network
-            callback.eventuallyExpect(CallbackEntry.UNAVAILABLE, 2_000 /* timeoutMs */);
+            callback.eventuallyExpect(Event.UNAVAILABLE, 2_000 /* timeoutMs */);
         } finally {
             if (previousWifiEnabledState) {
                 mCtsNetUtils.connectToWifi();
@@ -1489,6 +1511,7 @@ public class ConnectivityManagerTest {
         assumeTrue(mPackageManager.hasSystemFeature(FEATURE_WIFI));
 
         mCtsNetUtils.reconnectWifiAndWaitForConnectivityAction();
+        ensureWifiIsValidatedIfSupported();
     }
 
     /** Verify restricted networks cannot be requested. */
@@ -1579,7 +1602,7 @@ public class ConnectivityManagerTest {
         }
 
         return networkCallback.eventuallyExpect(
-                CallbackEntry.NETWORK_CAPS_UPDATED,
+                Event.NETWORK_CAPS_UPDATED,
                 // Changing meteredness on wifi involves reconnecting, which can take several
                 // seconds (involves re-associating, DHCP...).
                 NETWORK_CALLBACK_TIMEOUT_MS,
@@ -1626,7 +1649,7 @@ public class ConnectivityManagerTest {
 
     private int getCurrentMeteredMultipathPreference(ContentResolver resolver) {
         final String rawMeteredPref = Settings.Global.getString(resolver,
-                NETWORK_METERED_MULTIPATH_PREFERENCE);
+                NETWORK_METERED_MULTIPATH_PREFERENCE_SETTING);
         return TextUtils.isEmpty(rawMeteredPref)
             ? getIntResourceForName(NETWORK_METERED_MULTIPATH_PREFERENCE_RES_NAME)
             : Integer.parseInt(rawMeteredPref);
@@ -1657,11 +1680,11 @@ public class ConnectivityManagerTest {
         final String ssid = unquoteSSID(getSSID());
         final String oldMeteredSetting = getWifiMeteredStatus(ssid);
         final String oldMeteredMultipathPreference = Settings.Global.getString(
-                resolver, NETWORK_METERED_MULTIPATH_PREFERENCE);
+                resolver, NETWORK_METERED_MULTIPATH_PREFERENCE_SETTING);
         try {
             final int initialMeteredPreference = getCurrentMeteredMultipathPreference(resolver);
             int newMeteredPreference = findNextPrefValue(resolver);
-            Settings.Global.putString(resolver, NETWORK_METERED_MULTIPATH_PREFERENCE,
+            Settings.Global.putString(resolver, NETWORK_METERED_MULTIPATH_PREFERENCE_SETTING,
                     Integer.toString(newMeteredPreference));
             // Wifi meteredness changes from unmetered to metered will disconnect and reconnect
             // since R.
@@ -1675,7 +1698,7 @@ public class ConnectivityManagerTest {
 
             final int oldMeteredPreference = newMeteredPreference;
             newMeteredPreference = findNextPrefValue(resolver);
-            Settings.Global.putString(resolver, NETWORK_METERED_MULTIPATH_PREFERENCE,
+            Settings.Global.putString(resolver, NETWORK_METERED_MULTIPATH_PREFERENCE_SETTING,
                     Integer.toString(newMeteredPreference));
             assertEquals(mCm.getNetworkCapabilities(network).hasCapability(
                     NET_CAPABILITY_NOT_METERED), false);
@@ -1689,7 +1712,7 @@ public class ConnectivityManagerTest {
             assertMultipathPreferenceIsEventually(network, newMeteredPreference,
                     ConnectivityManager.MULTIPATH_PREFERENCE_UNMETERED);
         } finally {
-            Settings.Global.putString(resolver, NETWORK_METERED_MULTIPATH_PREFERENCE,
+            Settings.Global.putString(resolver, NETWORK_METERED_MULTIPATH_PREFERENCE_SETTING,
                     oldMeteredMultipathPreference);
             setWifiMeteredStatus(ssid, oldMeteredSetting);
         }
@@ -2253,10 +2276,10 @@ public class ConnectivityManagerTest {
 
         try (Socket socket = new Socket()) {
             // Verify that the network is restricted.
-            testNetworkCb.eventuallyExpect(CallbackEntry.NETWORK_CAPS_UPDATED,
+            testNetworkCb.eventuallyExpect(Event.NETWORK_CAPS_UPDATED,
                     NETWORK_CALLBACK_TIMEOUT_MS,
                     entry -> network.equals(entry.getNetwork())
-                            && (!((CallbackEntry.CapabilitiesChanged) entry).getCaps()
+                            && (!((Event.CapabilitiesChanged) entry).getCaps()
                             .hasCapability(NET_CAPABILITY_NOT_RESTRICTED)));
             // CtsNetTestCases package doesn't hold CONNECTIVITY_USE_RESTRICTED_NETWORKS, so it
             // does not allow to bind socket to restricted network.
@@ -2278,7 +2301,7 @@ public class ConnectivityManagerTest {
         // Ensure that CONNECTIVITY_USE_RESTRICTED_NETWORKS isn't granted to this package.
         final PackageInfo app = mPackageManager.getPackageInfo(mContext.getPackageName(),
                 GET_PERMISSIONS);
-        final int index = ArrayUtils.indexOf(
+        final int index = CollectionUtils.indexOf(
                 app.requestedPermissions, CONNECTIVITY_USE_RESTRICTED_NETWORKS);
         assertTrue(index >= 0);
         assertTrue(app.requestedPermissionsFlags[index] != PERMISSION_GRANTED);
@@ -2374,12 +2397,13 @@ public class ConnectivityManagerTest {
             }
             if (supportTelephony) {
                 telephonyCb.eventuallyExpect(
-                        CallbackEntry.AVAILABLE, CELL_DATA_AVAILABLE_TIMEOUT_MS);
+                        Event.AVAILABLE, CELL_DATA_AVAILABLE_TIMEOUT_MS);
             }
         } finally {
             // Restore the previous state of airplane mode and permissions:
             runShellCommand("cmd connectivity airplane-mode "
                     + (isAirplaneModeEnabled ? "enable" : "disable"));
+            ensureWifiIsValidatedIfSupported();
         }
     }
 
@@ -2389,16 +2413,16 @@ public class ConnectivityManagerTest {
         waitForAvailable(cb);
     }
 
-    private void waitForAvailable(@NonNull final TestableNetworkCallback cb) {
-        cb.eventuallyExpect(CallbackEntry.AVAILABLE, NETWORK_CALLBACK_TIMEOUT_MS,
-                c -> c instanceof CallbackEntry.Available);
+    private Event.Available waitForAvailable(@NonNull final TestableNetworkCallback cb) {
+        return cb.eventuallyExpect(Event.AVAILABLE, NETWORK_CALLBACK_TIMEOUT_MS,
+                c -> c instanceof Event.Available);
     }
 
     private void waitForTransport(
             @NonNull final TestableNetworkCallback cb, final int expectedTransport) {
-        cb.eventuallyExpect(CallbackEntry.NETWORK_CAPS_UPDATED,
+        cb.eventuallyExpect(Event.NETWORK_CAPS_UPDATED,
                 NETWORK_CALLBACK_TIMEOUT_MS,
-                entry -> ((CallbackEntry.CapabilitiesChanged) entry).getCaps()
+                entry -> ((Event.CapabilitiesChanged) entry).getCaps()
                         .hasTransport(expectedTransport));
     }
 
@@ -2410,8 +2434,8 @@ public class ConnectivityManagerTest {
     }
 
     private void waitForLost(@NonNull final TestableNetworkCallback cb) {
-        cb.eventuallyExpect(CallbackEntry.LOST, NETWORK_CALLBACK_TIMEOUT_MS,
-                c -> c instanceof CallbackEntry.Lost);
+        cb.eventuallyExpect(Event.LOST, NETWORK_CALLBACK_TIMEOUT_MS,
+                c -> c instanceof Event.Lost);
     }
 
     private void setAndVerifyAirplaneMode(Boolean expectedResult)
@@ -2498,7 +2522,7 @@ public class ConnectivityManagerTest {
         // Registering a callback here guarantees onCapabilitiesChanged is called immediately
         // because WiFi network should be connected.
         final NetworkCapabilities nc = callback.eventuallyExpect(
-                CallbackEntry.NETWORK_CAPS_UPDATED, NETWORK_CALLBACK_TIMEOUT_MS).getCaps();
+                Event.NETWORK_CAPS_UPDATED, NETWORK_CALLBACK_TIMEOUT_MS).getCaps();
         // Verify if ssid is contained in the NetworkCapabilities received from callback.
         assertEquals(hasSsid, Pattern.compile(ssid).matcher(nc.toString()).find());
     }
@@ -2564,10 +2588,10 @@ public class ConnectivityManagerTest {
             // non-listen requests will get available callback before it can be put into
             // background if no foreground request can be satisfied. Thus, wait for a short
             // period is needed to let foreground capability go away.
-            callback.eventuallyExpect(CallbackEntry.NETWORK_CAPS_UPDATED,
+            callback.eventuallyExpect(Event.NETWORK_CAPS_UPDATED,
                     NETWORK_CALLBACK_TIMEOUT_MS,
-                    c -> c instanceof CallbackEntry.CapabilitiesChanged
-                            && !((CallbackEntry.CapabilitiesChanged) c).getCaps()
+                    c -> c instanceof Event.CapabilitiesChanged
+                            && !((Event.CapabilitiesChanged) c).getCaps()
                             .hasCapability(NET_CAPABILITY_FOREGROUND));
             final NetworkCapabilities nc = mCm.getNetworkCapabilities(testNetwork);
             assertFalse("expected background network, but got " + nc,
@@ -2577,7 +2601,7 @@ public class ConnectivityManagerTest {
             runWithShellPermissionIdentity(() -> {
                 if (null != n) {
                     tnm.teardownTestNetwork(n);
-                    callback.eventuallyExpect(CallbackEntry.LOST,
+                    callback.eventuallyExpect(Event.LOST,
                             NETWORK_CALLBACK_TIMEOUT_MS,
                             lost -> n.equals(lost.getNetwork()));
                 }
@@ -2592,16 +2616,16 @@ public class ConnectivityManagerTest {
                     BLOCKED_REASON_NONE, NETWORK_CALLBACK_TIMEOUT_MS);
         }
         public void eventuallyExpectBlockedStatusCallback(Network network, int blockedStatus) {
-            super.eventuallyExpect(CallbackEntry.BLOCKED_STATUS_INT, NETWORK_CALLBACK_TIMEOUT_MS,
+            super.eventuallyExpect(Event.BLOCKED_STATUS_INT, NETWORK_CALLBACK_TIMEOUT_MS,
                     (it) -> it.getNetwork().equals(network) && it.getReason() == blockedStatus);
         }
         public void onBlockedStatusChanged(Network network, int blockedReasons) {
             Log.v(TAG, "onBlockedStatusChanged " + network + " " + blockedReasons);
-            getHistory().add(new CallbackEntry.BlockedStatusInt(network, blockedReasons));
+            getHistory().add(new Event.BlockedStatusInt(network, blockedReasons));
         }
         private void assertNoBlockedStatusCallback() {
             super.assertNoCallback(NO_CALLBACK_TIMEOUT_MS,
-                    c -> c instanceof CallbackEntry.BlockedStatus);
+                    c -> c instanceof Event.BlockedStatus);
         }
     }
 
@@ -2639,7 +2663,7 @@ public class ConnectivityManagerTest {
         final DetailedBlockedStatusCallback otherUidCallback = new DetailedBlockedStatusCallback();
 
         final int myUid = Process.myUid();
-        final int otherUid = UserHandle.getUid(5, Process.FIRST_APPLICATION_UID);
+        final int otherUid = UserHandle.of(5).getUid(Process.FIRST_APPLICATION_UID);
         final Handler handler = new Handler(Looper.getMainLooper());
 
         networkCallbackRule.registerDefaultNetworkCallback(myUidCallback, handler);
@@ -2647,7 +2671,7 @@ public class ConnectivityManagerTest {
                 () -> networkCallbackRule.registerDefaultNetworkCallbackForUid(
                         otherUid, otherUidCallback, handler), NETWORK_SETTINGS);
 
-        final Network defaultNetwork = myUidCallback.expect(CallbackEntry.AVAILABLE).getNetwork();
+        final Network defaultNetwork = myUidCallback.expect(Event.AVAILABLE).getNetwork();
         final List<DetailedBlockedStatusCallback> allCallbacks =
                 List.of(myUidCallback, otherUidCallback);
         for (DetailedBlockedStatusCallback callback : allCallbacks) {
@@ -2809,7 +2833,7 @@ public class ConnectivityManagerTest {
             ConnectivitySettingsManager.setPrivateDnsMode(mContext, curPrivateDnsMode);
             tetherUtils.unregisterTetheringEventCallback(tetherEventCallback);
             tetherUtils.stopAllTethering();
-            mCtsNetUtils.ensureWifiConnected();
+            ensureWifiIsValidatedIfSupported();
         }
     }
 
@@ -2894,14 +2918,14 @@ public class ConnectivityManagerTest {
 
             // Validate that an unmetered network is used over other networks.
             waitForAvailable(defaultCallback, wifiNetwork);
-            systemDefaultCallback.eventuallyExpect(CallbackEntry.AVAILABLE,
+            systemDefaultCallback.eventuallyExpect(Event.AVAILABLE,
                     NETWORK_CALLBACK_TIMEOUT_MS, cb -> wifiNetwork.equals(cb.getNetwork()));
 
             // Validate that when setting unmetered to metered, unmetered is lost and replaced by
             // the network with the TEST transport. Also wait for validation here, in case there
             // is a bug that's only visible when the network is validated.
             setWifiMeteredStatusAndWait(ssid, true /* isMetered */, true /* waitForValidation */);
-            defaultCallback.eventuallyExpect(CallbackEntry.LOST, NETWORK_CALLBACK_TIMEOUT_MS,
+            defaultCallback.eventuallyExpect(Event.LOST, NETWORK_CALLBACK_TIMEOUT_MS,
                     l -> l.getNetwork().equals(wifiNetwork));
             waitForAvailable(defaultCallback, tnt.getNetwork());
             // Depending on if this device has cellular connectivity or not, multiple available
@@ -2914,7 +2938,7 @@ public class ConnectivityManagerTest {
                 runWithShellPermissionIdentity(tnt::teardown);
                 // The other callbacks (LP or NC changes) would receive before LOST callback. Use
                 // eventuallyExpect to check callback for avoiding test flake.
-                defaultCallback.eventuallyExpect(CallbackEntry.LOST, NETWORK_CALLBACK_TIMEOUT_MS,
+                defaultCallback.eventuallyExpect(Event.LOST, NETWORK_CALLBACK_TIMEOUT_MS,
                         lost -> tnt.getNetwork().equals(lost.getNetwork()));
                 waitForAvailable(defaultCallback);
             }, /* cleanup */ () -> {
@@ -2950,11 +2974,11 @@ public class ConnectivityManagerTest {
                     OemNetworkPreferences.OEM_NETWORK_PREFERENCE_TEST_ONLY);
             registerTestOemNetworkPreferenceCallbacks(defaultCallback, systemDefaultCallback);
             waitForAvailable(defaultCallback, testNetwork);
-            systemDefaultCallback.eventuallyExpect(CallbackEntry.AVAILABLE,
+            systemDefaultCallback.eventuallyExpect(Event.AVAILABLE,
                     NETWORK_CALLBACK_TIMEOUT_MS, cb -> wifiNetwork.equals(cb.getNetwork()));
         }, /* cleanup */ () -> {
                 runWithShellPermissionIdentity(tnt::teardown);
-                defaultCallback.eventuallyExpect(CallbackEntry.LOST, NETWORK_CALLBACK_TIMEOUT_MS,
+                defaultCallback.eventuallyExpect(Event.LOST, NETWORK_CALLBACK_TIMEOUT_MS,
                         cb -> testNetwork.equals(cb.getNetwork()));
 
                 // This network preference should only ever use the test network therefore available
@@ -3054,6 +3078,12 @@ public class ConnectivityManagerTest {
         }
     }
 
+    private void ensureWifiIsValidatedIfSupported() {
+        if (mPackageManager.hasSystemFeature(FEATURE_WIFI)) {
+            new ConnectUtil(mContext).ensureWifiValidated();
+        }
+    }
+
     @AppModeFull(reason = "WRITE_DEVICE_CONFIG permission can't be granted to instant apps")
     @Test
     public void testAcceptPartialConnectivity_validatedNetwork() throws Exception {
@@ -3075,7 +3105,7 @@ public class ConnectivityManagerTest {
             expectNetworkHasCapability(network, NET_CAPABILITY_VALIDATED, WIFI_CONNECT_TIMEOUT_MS);
         } finally {
             mHttpServer.stop();
-            mTestValidationConfigRule.runAfterNextCleanup(this::reconnectWifi);
+            mTestValidationConfigRule.runAfterNextCleanup(this::reconnectWifiAndEnsureValidated);
         }
     }
 
@@ -3098,14 +3128,14 @@ public class ConnectivityManagerTest {
                 mCm.setAcceptPartialConnectivity(network, false /* accept */, false /* always */);
             });
             // Reject partial connectivity network should cause the network being torn down
-            assertEquals(network, cb.eventuallyExpect(CallbackEntry.LOST).getNetwork());
+            assertEquals(network, cb.eventuallyExpect(Event.LOST).getNetwork());
         } finally {
             mHttpServer.stop();
             // Wifi will not automatically reconnect to the network. ensureWifiDisconnected cannot
             // apply here. Thus, turn off wifi first and restart to restore.
             mTestValidationConfigRule.runAfterNextCleanup(() -> {
                 mCtsNetUtils.disableWifi();
-                mCtsNetUtils.ensureWifiConnected();
+                ensureWifiIsValidatedIfSupported();
             });
         }
     }
@@ -3151,7 +3181,7 @@ public class ConnectivityManagerTest {
             // apply here. Thus, turn off wifi first and restart to restore.
             mTestValidationConfigRule.runAfterNextCleanup(() -> {
                 mCtsNetUtils.disableWifi();
-                mCtsNetUtils.ensureWifiConnected();
+                ensureWifiIsValidatedIfSupported();
             });
         }
     }
@@ -3183,9 +3213,9 @@ public class ConnectivityManagerTest {
                     makeWifiNetworkRequest());
 
             // Verify wifi is the default network.
-            defaultCb.eventuallyExpect(CallbackEntry.AVAILABLE, NETWORK_CALLBACK_TIMEOUT_MS,
+            defaultCb.eventuallyExpect(Event.AVAILABLE, NETWORK_CALLBACK_TIMEOUT_MS,
                     entry -> wifiNetwork.equals(entry.getNetwork()));
-            wifiCb.eventuallyExpect(CallbackEntry.AVAILABLE, NETWORK_CALLBACK_TIMEOUT_MS,
+            wifiCb.eventuallyExpect(Event.AVAILABLE, NETWORK_CALLBACK_TIMEOUT_MS,
                     entry -> wifiNetwork.equals(entry.getNetwork()));
             assertTrue(mCm.getNetworkCapabilities(wifiNetwork).hasCapability(
                     NET_CAPABILITY_VALIDATED));
@@ -3195,33 +3225,33 @@ public class ConnectivityManagerTest {
             configTestServer(Status.INTERNAL_ERROR, Status.INTERNAL_ERROR);
             mCm.reportNetworkConnectivity(wifiNetwork, false);
             // Default network should stay on unvalidated wifi because avoid bad wifi is disabled.
-            defaultCb.eventuallyExpect(CallbackEntry.NETWORK_CAPS_UPDATED,
+            defaultCb.eventuallyExpect(Event.NETWORK_CAPS_UPDATED,
                     NETWORK_CALLBACK_TIMEOUT_MS,
-                    entry -> !((CallbackEntry.CapabilitiesChanged) entry).getCaps()
+                    entry -> !((Event.CapabilitiesChanged) entry).getCaps()
                             .hasCapability(NET_CAPABILITY_VALIDATED));
-            wifiCb.eventuallyExpect(CallbackEntry.NETWORK_CAPS_UPDATED,
+            wifiCb.eventuallyExpect(Event.NETWORK_CAPS_UPDATED,
                     NETWORK_CALLBACK_TIMEOUT_MS,
-                    entry -> !((CallbackEntry.CapabilitiesChanged) entry).getCaps()
+                    entry -> !((Event.CapabilitiesChanged) entry).getCaps()
                             .hasCapability(NET_CAPABILITY_VALIDATED));
 
             runAsShell(NETWORK_SETTINGS, () -> {
                 mCm.setAvoidUnvalidated(wifiNetwork);
             });
             // Default network should be updated to validated cellular network.
-            defaultCb.eventuallyExpect(CallbackEntry.AVAILABLE, NETWORK_CALLBACK_TIMEOUT_MS,
+            defaultCb.eventuallyExpect(Event.AVAILABLE, NETWORK_CALLBACK_TIMEOUT_MS,
                     entry -> cellNetwork.equals(entry.getNetwork()));
             // The network should not validate again.
             wifiCb.assertNoCallback(NO_CALLBACK_TIMEOUT_MS, c -> isValidatedCaps(c));
         } finally {
             resetAvoidBadWifi(previousAvoidBadWifi);
             mHttpServer.stop();
-            mTestValidationConfigRule.runAfterNextCleanup(this::reconnectWifi);
+            mTestValidationConfigRule.runAfterNextCleanup(this::reconnectWifiAndEnsureValidated);
         }
     }
 
-    private boolean isValidatedCaps(CallbackEntry c) {
-        if (!(c instanceof CallbackEntry.CapabilitiesChanged)) return false;
-        final CallbackEntry.CapabilitiesChanged capsChanged = (CallbackEntry.CapabilitiesChanged) c;
+    private boolean isValidatedCaps(Event c) {
+        if (!(c instanceof Event.CapabilitiesChanged)) return false;
+        final Event.CapabilitiesChanged capsChanged = (Event.CapabilitiesChanged) c;
         return capsChanged.getCaps().hasCapability(NET_CAPABILITY_VALIDATED);
     }
 
@@ -3245,7 +3275,7 @@ public class ConnectivityManagerTest {
 
     private Network expectNetworkHasCapability(Network network, int expectedNetCap, long timeout) {
         return networkCallbackRule.registerNetworkCallback(new NetworkRequest.Builder().build())
-                .eventuallyExpect(CallbackEntry.NETWORK_CAPS_UPDATED, timeout,
+                .eventuallyExpect(Event.NETWORK_CAPS_UPDATED, timeout,
                         cb -> cb.getNetwork().equals(network)
                                 && cb.getCaps().hasCapability(expectedNetCap)).getNetwork();
     }
@@ -3264,9 +3294,9 @@ public class ConnectivityManagerTest {
         mHttpServer.start();
     }
 
-    private Network reconnectWifi() {
+    private Network reconnectWifiAndEnsureValidated() {
         mCtsNetUtils.ensureWifiDisconnected(null /* wifiNetworkToCheck */);
-        return mCtsNetUtils.ensureWifiConnected();
+        return new ConnectUtil(mContext).ensureWifiValidated();
     }
 
     private Network prepareValidatedNetwork() throws Exception {
@@ -3280,10 +3310,7 @@ public class ConnectivityManagerTest {
         prepareHttpServer();
         configTestServer(Status.NO_CONTENT, Status.NO_CONTENT);
         // Disconnect wifi first then start wifi network with configuration.
-        final Network wifiNetwork = reconnectWifi();
-
-        return expectNetworkHasCapability(wifiNetwork, NET_CAPABILITY_VALIDATED,
-                WIFI_CONNECT_TIMEOUT_MS);
+        return reconnectWifiAndEnsureValidated();
     }
 
     private Network preparePartialConnectivity() throws Exception {
@@ -3360,7 +3387,7 @@ public class ConnectivityManagerTest {
         testAndCleanup(() -> {
             // New default network connected will trigger a network activity notification.
             if (supportWifi) {
-                mCtsNetUtils.ensureWifiConnected();
+                ensureWifiIsValidatedIfSupported();
             } else {
                 networkCallbackRule.requestCell();
             }
@@ -3379,8 +3406,8 @@ public class ConnectivityManagerTest {
     private void assertNoCallbackExceptCapOrLpChange(
             @NonNull final TestableNetworkCallback cb) {
         cb.assertNoCallback(NO_CALLBACK_TIMEOUT_MS,
-                c -> !(c instanceof CallbackEntry.CapabilitiesChanged
-                        || c instanceof CallbackEntry.LinkPropertiesChanged));
+                c -> !(c instanceof Event.CapabilitiesChanged
+                        || c instanceof Event.LinkPropertiesChanged));
     }
 
     @AppModeFull(reason = "Cannot get WifiManager in instant app mode")
@@ -3391,6 +3418,9 @@ public class ConnectivityManagerTest {
                 && mPackageManager.hasSystemFeature(FEATURE_TELEPHONY);
         assumeTrue("testMobileDataPreferredUidsWithCallback cannot execute"
                 + " unless device supports both WiFi and telephony", canRunTest);
+        // TODO(b/404186833): re-enable
+        assumeFalse("testMobileDataPreferredUids is broken on automotive",
+                mPackageManager.hasSystemFeature(FEATURE_AUTOMOTIVE));
 
         final int uid = mPackageManager.getPackageUid(mContext.getPackageName(), 0 /* flag */);
         final Set<Integer> mobileDataPreferredUids =
@@ -3426,7 +3456,7 @@ public class ConnectivityManagerTest {
             newMobileDataPreferredUids.add(uid);
             ConnectivitySettingsManager.setMobileDataPreferredUids(
                     mContext, newMobileDataPreferredUids);
-            defaultTrackingCb.eventuallyExpect(CallbackEntry.AVAILABLE, NETWORK_CALLBACK_TIMEOUT_MS,
+            defaultTrackingCb.eventuallyExpect(Event.AVAILABLE, NETWORK_CALLBACK_TIMEOUT_MS,
                     entry -> cellNetwork.equals(entry.getNetwork()));
             // No change for system default network. Expect no callback except CapabilitiesChanged
             // or LinkPropertiesChanged which may be triggered randomly from wifi network.
@@ -3439,7 +3469,7 @@ public class ConnectivityManagerTest {
             newMobileDataPreferredUids.remove(uid);
             ConnectivitySettingsManager.setMobileDataPreferredUids(
                     mContext, newMobileDataPreferredUids);
-            defaultTrackingCb.eventuallyExpect(CallbackEntry.AVAILABLE, NETWORK_CALLBACK_TIMEOUT_MS,
+            defaultTrackingCb.eventuallyExpect(Event.AVAILABLE, NETWORK_CALLBACK_TIMEOUT_MS,
                     entry -> wifiNetwork.equals(entry.getNetwork()));
             // No change for system default network. Expect no callback except CapabilitiesChanged
             // or LinkPropertiesChanged which may be triggered randomly from wifi network.
@@ -3542,10 +3572,10 @@ public class ConnectivityManagerTest {
 
         try (Socket socket = new Socket()) {
             // Verify that the network is restricted.
-            testNetworkCb.eventuallyExpect(CallbackEntry.NETWORK_CAPS_UPDATED,
+            testNetworkCb.eventuallyExpect(Event.NETWORK_CAPS_UPDATED,
                     NETWORK_CALLBACK_TIMEOUT_MS,
                     entry -> network.equals(entry.getNetwork())
-                            && (!((CallbackEntry.CapabilitiesChanged) entry).getCaps()
+                            && (!((Event.CapabilitiesChanged) entry).getCaps()
                             .hasCapability(NET_CAPABILITY_NOT_RESTRICTED)));
             // CtsNetTestCases package doesn't hold CONNECTIVITY_USE_RESTRICTED_NETWORKS, so it
             // does not allow to bind socket to restricted network.
@@ -3566,10 +3596,10 @@ public class ConnectivityManagerTest {
                 // Uid is in allowed list. Try file network request again.
                 networkCallbackRule.requestNetwork(restrictedRequest, restrictedNetworkCb);
                 // Verify that the network is restricted.
-                restrictedNetworkCb.eventuallyExpect(CallbackEntry.NETWORK_CAPS_UPDATED,
+                restrictedNetworkCb.eventuallyExpect(Event.NETWORK_CAPS_UPDATED,
                         NETWORK_CALLBACK_TIMEOUT_MS,
                         entry -> network.equals(entry.getNetwork())
-                                && (!((CallbackEntry.CapabilitiesChanged) entry).getCaps()
+                                && (!((Event.CapabilitiesChanged) entry).getCaps()
                                 .hasCapability(NET_CAPABILITY_NOT_RESTRICTED)));
             }
         } finally {
@@ -3588,7 +3618,7 @@ public class ConnectivityManagerTest {
         assertTrue(dumpOutput, dumpOutput.contains("Active default network"));
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testDumpBpfNetMaps() throws Exception {
         final String[] args = new String[] {"--short", "trafficcontroller"};
         String dumpOutput = DumpTestUtils.dumpServiceWithShellPermission(
@@ -3703,7 +3733,7 @@ public class ConnectivityManagerTest {
         }, NETWORK_SETTINGS);
     }
 
-    @Test @IgnoreUpTo(SC_V2) @ConnectivityModuleTest
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2) @ConnectivityModuleTest
     @AppModeFull(reason = "Socket cannot bind in instant app mode")
     public void testFirewallBlockingDozable() {
         doTestFirewallBlocking(FIREWALL_CHAIN_DOZABLE, ALLOWLIST);
@@ -3717,43 +3747,43 @@ public class ConnectivityManagerTest {
         doTestFirewallBlocking(FIREWALL_CHAIN_BACKGROUND, ALLOWLIST);
     }
 
-    @Test @IgnoreUpTo(SC_V2) @ConnectivityModuleTest
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2) @ConnectivityModuleTest
     @AppModeFull(reason = "Socket cannot bind in instant app mode")
     public void testFirewallBlockingPowersave() {
         doTestFirewallBlocking(FIREWALL_CHAIN_POWERSAVE, ALLOWLIST);
     }
 
-    @Test @IgnoreUpTo(SC_V2) @ConnectivityModuleTest
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2) @ConnectivityModuleTest
     @AppModeFull(reason = "Socket cannot bind in instant app mode")
     public void testFirewallBlockingRestricted() {
         doTestFirewallBlocking(FIREWALL_CHAIN_RESTRICTED, ALLOWLIST);
     }
 
-    @Test @IgnoreUpTo(SC_V2) @ConnectivityModuleTest
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2) @ConnectivityModuleTest
     @AppModeFull(reason = "Socket cannot bind in instant app mode")
     public void testFirewallBlockingLowPowerStandby() {
         doTestFirewallBlocking(FIREWALL_CHAIN_LOW_POWER_STANDBY, ALLOWLIST);
     }
 
-    @Test @IgnoreUpTo(SC_V2) @ConnectivityModuleTest
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2) @ConnectivityModuleTest
     @AppModeFull(reason = "Socket cannot bind in instant app mode")
     public void testFirewallBlockingStandby() {
         doTestFirewallBlocking(FIREWALL_CHAIN_STANDBY, DENYLIST);
     }
 
-    @Test @IgnoreUpTo(SC_V2) @ConnectivityModuleTest
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2) @ConnectivityModuleTest
     @AppModeFull(reason = "Socket cannot bind in instant app mode")
     public void testFirewallBlockingOemDeny1() {
         doTestFirewallBlocking(FIREWALL_CHAIN_OEM_DENY_1, DENYLIST);
     }
 
-    @Test @IgnoreUpTo(SC_V2) @ConnectivityModuleTest
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2) @ConnectivityModuleTest
     @AppModeFull(reason = "Socket cannot bind in instant app mode")
     public void testFirewallBlockingOemDeny2() {
         doTestFirewallBlocking(FIREWALL_CHAIN_OEM_DENY_2, DENYLIST);
     }
 
-    @Test @IgnoreUpTo(SC_V2) @ConnectivityModuleTest
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2) @ConnectivityModuleTest
     @AppModeFull(reason = "Socket cannot bind in instant app mode")
     public void testFirewallBlockingOemDeny3() {
         doTestFirewallBlocking(FIREWALL_CHAIN_OEM_DENY_3, DENYLIST);
@@ -4006,7 +4036,7 @@ public class ConnectivityManagerTest {
 
         final DetailedBlockedStatusCallback cb = new DetailedBlockedStatusCallback();
         networkCallbackRule.registerDefaultNetworkCallback(cb);
-        final Network network = cb.expect(CallbackEntry.AVAILABLE).getNetwork();
+        final Network network = cb.expect(Event.AVAILABLE).getNetwork();
         testAndCleanup(() -> {
             // Disable chain and set RULE_DENY on target chain
             runWithShellPermissionIdentity(() -> {
@@ -4056,7 +4086,7 @@ public class ConnectivityManagerTest {
 
         final DetailedBlockedStatusCallback cb = new DetailedBlockedStatusCallback();
         networkCallbackRule.registerDefaultNetworkCallback(cb);
-        final Network network = cb.expect(CallbackEntry.AVAILABLE).getNetwork();
+        final Network network = cb.expect(Event.AVAILABLE).getNetwork();
         testAndCleanup(() -> {
             cb.eventuallyExpectBlockedStatusCallback(network, BLOCKED_REASON_NONE);
 
@@ -4131,4 +4161,306 @@ public class ConnectivityManagerTest {
         assertThrows(UnsupportedOperationException.class, () -> mCm.tether("iface"));
         assertThrows(UnsupportedOperationException.class, () -> mCm.untether("iface"));
     }
+
+    private ParcelFileDescriptor setupTestNetworkAndGetFd() {
+        return runWithShellPermissionIdentity(() -> {
+            final TestNetworkManager tnm = mContext.getSystemService(TestNetworkManager.class);
+            final List<LinkAddress> linkAddresses = List.of(new LinkAddress("192.0.2.2/24"),
+                    new LinkAddress("2001:db8:1:2::2/64"));
+            final TestNetworkInterface iface = tnm.createTunInterface(linkAddresses);
+            tnm.setupTestNetwork(iface.getInterfaceName(), new Binder());
+            return iface.getFileDescriptor();
+        }, MANAGE_TEST_NETWORKS);
+    }
+
+    private Network getTestNetwork() {
+        final TestableNetworkCallback callback = networkCallbackRule.requestNetwork(
+                new NetworkRequest.Builder()
+                        .removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN)
+                        .removeCapability(NetworkCapabilities.NET_CAPABILITY_TRUSTED)
+                        .addTransportType(TRANSPORT_TEST)
+                        .build()
+        );
+        return waitForAvailable(callback).getNetwork();
+    }
+
+    private void waitForQuicConnectionCloseInfoRegistration(final int myUid,
+            final boolean expectRegistered)
+            throws ErrnoException, RemoteException, InterruptedException {
+        final long timeout = SystemClock.elapsedRealtime()
+                + QUIC_CONNECTION_CLOSE_INFO_REGISTRATION_TIMEOUT_MS;
+        while (timeout > SystemClock.elapsedRealtime()) {
+            if (DumpTestUtils.dumpServiceWithShellPermission(
+                    Context.CONNECTIVITY_SERVICE, "--short")
+                    .contains("QuicConnectionCloseInfo{uid: " + myUid) == expectRegistered) {
+                return;
+            }
+            Thread.sleep(50);
+        }
+        fail("Failed to register/unregister QUIC connection close information in "
+                + QUIC_CONNECTION_CLOSE_INFO_REGISTRATION_TIMEOUT_MS
+                + "ms, expectRegistered=" + expectRegistered);
+    }
+
+    private void doTestRegisterQuicConnectionClosePayload(final boolean isV6,
+            final boolean unregister, final boolean closeSocket, final boolean blockNetwork,
+            final boolean expectPacketSent) throws Exception {
+        final InetAddress dstAddress = isV6 ? InetAddresses.parseNumericAddress("2001:db8:1:2::3")
+                : InetAddresses.parseNumericAddress("192.0.2.3");
+        final InetSocketAddress dstSockAddress = new InetSocketAddress(dstAddress, 443);
+        final int myUid = Process.myUid();
+
+        final ParcelFileDescriptor tunFd = setupTestNetworkAndGetFd();
+        final Network testNetwork = getTestNetwork();
+
+        // Firewall chain status will be restored after the test.
+        final boolean wasChainEnabled = runWithShellPermissionIdentity(() ->
+                mCm.getFirewallChainEnabled(FIREWALL_CHAIN_BACKGROUND), NETWORK_SETTINGS);
+        final int previousUidFirewallRule = runWithShellPermissionIdentity(() ->
+                mCm.getUidFirewallRule(FIREWALL_CHAIN_BACKGROUND, myUid), NETWORK_SETTINGS);
+        runWithShellPermissionIdentity(() -> {
+            mCm.setFirewallChainEnabled(FIREWALL_CHAIN_BACKGROUND, true /* enable */);
+            mCm.setUidFirewallRule(FIREWALL_CHAIN_BACKGROUND, myUid, FIREWALL_RULE_ALLOW);
+        }, NETWORK_SETTINGS);
+
+        final FileDescriptor sock = Os.socket(isV6 ? AF_INET6 : AF_INET, SOCK_DGRAM, IPPROTO_UDP);
+        final ParcelFileDescriptor pfd = ParcelFileDescriptor.fromFd(sock.getInt$());
+        testNetwork.bindSocket(sock);
+        Os.connect(sock, dstSockAddress);
+        final InetSocketAddress srcSockAddress = (InetSocketAddress) Os.getsockname(sock);
+
+        testAndCleanup(() -> {
+            final Random random = new Random();
+            final byte[] payload = new byte[100];
+            random.nextBytes(payload);
+
+            // register/unregisterQuicConnectionClosePayload are oneway binder calls,
+            // while setUidFirewallRule is a two-way binder call. So if
+            // setUidFirewallRule is called immediately after them, it's possible that
+            // setUidFirewallRule could be processed before them.
+            // To ensure that uid networking is blocked after the connection close information
+            // is registered/unregistered, wait for the registration/unregistration.
+            mCm.registerQuicConnectionClosePayload(pfd, payload);
+            waitForQuicConnectionCloseInfoRegistration(myUid, true /* expectRegistered */);
+            if (unregister) {
+                mCm.unregisterQuicConnectionClosePayload(pfd);
+                waitForQuicConnectionCloseInfoRegistration(myUid, false /* expectRegistered */);
+            }
+
+            if (closeSocket) {
+                Os.close(sock);
+                pfd.close();
+            }
+
+            if (blockNetwork) {
+                runWithShellPermissionIdentity(() ->
+                        mCm.setUidFirewallRule(FIREWALL_CHAIN_BACKGROUND, myUid,
+                                FIREWALL_RULE_DENY), NETWORK_SETTINGS);
+            }
+
+            final long timeout = SystemClock.elapsedRealtime()
+                    + QUIC_CONNECTION_CLOSE_PACKET_TIMEOUT_MS;
+            long remainingTimeMs;
+            while ((remainingTimeMs = timeout - SystemClock.elapsedRealtime()) > 0) {
+                final StructPollfd pollfd = new StructPollfd();
+                pollfd.events = (short) POLLIN;
+                pollfd.fd = tunFd.getFileDescriptor();
+                final int ret = Os.poll(new StructPollfd[] { pollfd }, (int) remainingTimeMs);
+                if (ret == 0) {
+                    continue;
+                }
+
+                final byte[] recvData = new byte[200];
+                final int readSize = Os.read(tunFd.getFileDescriptor(), recvData,
+                        0 /* byteOffset */, recvData.length);
+
+                if (readSize < payload.length
+                        || !Arrays.equals(payload, 0, payload.length,
+                        recvData, readSize - payload.length, readSize)) {
+                    continue;
+                }
+                // If the control comes here then the payload was received, otherwise poll would
+                // have returned 0 or the test above would have matched it and gone to continue.
+                if (!expectPacketSent) {
+                    fail("Unexpectedly received the QUIC connection close packet.");
+                }
+
+                final ByteBuffer buf = ByteBuffer.wrap(recvData, 0 /* offset */, readSize);
+                if (isV6) {
+                    final Ipv6Header header = Struct.parse(Ipv6Header.class, buf);
+                    assertEquals(srcSockAddress.getAddress(), header.srcIp);
+                    assertEquals(dstSockAddress.getAddress(), header.dstIp);
+                } else {
+                    final Ipv4Header header = Struct.parse(Ipv4Header.class, buf);
+                    assertEquals(srcSockAddress.getAddress(), header.srcIp);
+                    assertEquals(dstSockAddress.getAddress(), header.dstIp);
+                }
+                final UdpHeader udpHeader = Struct.parse(UdpHeader.class, buf);
+                assertEquals(srcSockAddress.getPort(), udpHeader.srcPort);
+                assertEquals(dstSockAddress.getPort(), udpHeader.dstPort);
+                assertEquals(payload.length + Struct.getSize(UdpHeader.class), udpHeader.length);
+
+                if (!closeSocket) {
+                    // After the socket is destroyed and QUIC connection is closed by
+                    // ConnectivityService, writing to the UDP socket should throw.
+                    try {
+                        Os.write(sock, payload, 0 /* byteOffset */, payload.length);
+                        fail("Write to the destroyed socket must throw.");
+                    } catch (ErrnoException e) {
+                        assertEquals(EDESTADDRREQ, e.errno);
+                    }
+                    try {
+                        Os.sendto(sock, payload, 0 /* byteOffset */,
+                                payload.length, 0 /* flags */, dstSockAddress);
+                        fail("Sendto with the destroyed socket must throw.");
+                    } catch (ErrnoException e) {
+                        assertEquals(ECONNABORTED, e.errno);
+                    }
+                }
+                return;
+            }
+            if (expectPacketSent) {
+                fail("Did not receive the QUIC connection close packet.");
+            }
+        }, /* cleanup */ () -> {
+            runWithShellPermissionIdentity(() -> {
+                mContext.getSystemService(TestNetworkManager.class).teardownTestNetwork(
+                        testNetwork);
+            }, MANAGE_TEST_NETWORKS);
+            IoUtils.closeQuietly(tunFd);
+            IoUtils.closeQuietly(sock);
+            IoUtils.closeQuietly(pfd);
+        }, /* cleanup */ () -> {
+            // Restore firewall chain global status
+            runWithShellPermissionIdentity(() -> {
+                mCm.setFirewallChainEnabled(FIREWALL_CHAIN_BACKGROUND, wasChainEnabled);
+            }, NETWORK_SETTINGS);
+        }, /* cleanup */ () -> {
+            // Restore firewall chain status for myUid
+            runWithShellPermissionIdentity(() -> {
+                try {
+                    mCm.setUidFirewallRule(FIREWALL_CHAIN_BACKGROUND, myUid,
+                            previousUidFirewallRule);
+                } catch (IllegalStateException ignored) {
+                    // Removing match causes an exception when the rule entry for the uid does
+                    // not exist. But this is fine and can be ignored.
+                }
+            }, NETWORK_SETTINGS);
+        });
+    }
+
+    // This test is skipped on U and older releases because QUIC connection close can be triggered
+    // by the freezer (U+) or the background firewall chain (V+), but the freezer cannot be tested.
+    // TODO: Enable this test on T+ once other firewall chains can trigger QUIC connection close.
+    @Test
+    @IgnoreUpTo(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+    @ConnectivityModuleTest
+    @AppModeFull(reason = "Cannot create test network in instant app mode")
+    public void testRegisterQuicConnectionClosePayload_blockNetwork() throws Exception {
+        assumeTrue(mCm.isConnectivityServiceFeatureEnabledForTesting(CLOSE_QUIC_CONNECTION));
+
+        // Network is blocked while the connection close payload is registered.
+        // Packet should be sent.
+        doTestRegisterQuicConnectionClosePayload(
+                false /* isV6 */, false /* unregister */, false /* closeSocket */,
+                true /* blockNetwork */, true /* expectPacketSent */);
+        doTestRegisterQuicConnectionClosePayload(
+                true /* isV6 */, false /* unregister */, false /* closeSocket */,
+                true /* blockNetwork */, true /* expectPacketSent */);
+
+        // Network is blocked after the connection close payload is unregistered.
+        // Packet should not be sent.
+        doTestRegisterQuicConnectionClosePayload(
+                false /* isV6 */, true /* unregister */, false /* closeSocket */,
+                true /* blockNetwork */, false /* expectPacketSent */);
+        doTestRegisterQuicConnectionClosePayload(
+                true /* isV6 */, true /* unregister */, false /* closeSocket */,
+                true /* blockNetwork */, false /* expectPacketSent */);
+    }
+
+    // TODO: Enable this test on T+ once other firewall chains can trigger QUIC connection close.
+    @Test
+    @IgnoreUpTo(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+    @ConnectivityModuleTest
+    @AppModeFull(reason = "Cannot create test network in instant app mode")
+    public void testRegisterQuicConnectionClosePayload_closeSocket() throws Exception {
+        assumeTrue(mCm.isConnectivityServiceFeatureEnabledForTesting(CLOSE_QUIC_CONNECTION));
+
+        // Registered socket is closed while the connection close payload is registered.
+        // Packet should be sent. This simulates that apps crash or are killed.
+        doTestRegisterQuicConnectionClosePayload(
+                false /* isV6 */, false /* unregister */, true /* closeSocket */,
+                false /* blockNetwork */, true /* expectPacketSent */);
+        doTestRegisterQuicConnectionClosePayload(
+                true /* isV6 */, false /* unregister */, true /* closeSocket */,
+                false /* blockNetwork */, true /* expectPacketSent */);
+    }
+
+    /**
+     * Repeat register a connection close payload, unregister it, and then close the socket.
+     * The registered payload must not be sent because it is unregistered before the socket
+     * is closed.
+     * This test tries to detect threading issues between
+     * register/unregisterQuicConnectionClosePayload and socket destroy message handling.
+     */
+    @Test
+    @IgnoreUpTo(Build.VERSION_CODES.R)
+    @ConnectivityModuleTest
+    @AppModeFull(reason = "Cannot create test network in instant app mode")
+    public void testRegisterQuicConnectionClosePayload_closeSocketAfterUnregister()
+            throws Exception {
+        assumeTrue(mCm.isConnectivityServiceFeatureEnabledForTesting(CLOSE_QUIC_CONNECTION));
+
+        final ParcelFileDescriptor tunFd = setupTestNetworkAndGetFd();
+        final Network testNetwork = getTestNetwork();
+
+        final Random random = new Random();
+        final byte[] payload = new byte[100];
+        random.nextBytes(payload);
+
+        final InetSocketAddress dstSockAddress =
+                new InetSocketAddress(InetAddresses.parseNumericAddress("2001:db8:1:2::3"), 443);
+        for (int i = 0; i < 100; i++) {
+            final FileDescriptor sock = Os.socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
+            testNetwork.bindSocket(sock);
+            Os.connect(sock, dstSockAddress);
+
+            final ParcelFileDescriptor pfd = ParcelFileDescriptor.fromFd(sock.getInt$());
+            mCm.registerQuicConnectionClosePayload(pfd, payload);
+            mCm.unregisterQuicConnectionClosePayload(pfd);
+            Os.close(sock);
+            pfd.close();
+        }
+
+        testAndCleanup(() -> {
+            final long timeout = SystemClock.elapsedRealtime()
+                    + QUIC_CONNECTION_CLOSE_PACKET_TIMEOUT_MS;
+            long remainingTimeMs;
+            while ((remainingTimeMs = timeout - SystemClock.elapsedRealtime()) > 0) {
+                StructPollfd pollfd = new StructPollfd();
+                pollfd.events = (short) POLLIN;
+                pollfd.fd = tunFd.getFileDescriptor();
+                final int ret = Os.poll(new StructPollfd[]{pollfd}, (int) remainingTimeMs);
+                if (ret == 0) {
+                    continue;
+                }
+
+                final byte[] recvData = new byte[200];
+                final int readSize = Os.read(tunFd.getFileDescriptor(), recvData,
+                        0 /* byteOffset */, recvData.length);
+                if (readSize < payload.length
+                        || !Arrays.equals(payload, 0, payload.length,
+                        recvData, readSize - payload.length, readSize)) {
+                    continue;
+                }
+                fail("Unexpectedly received the QUIC connection close packet.");
+            }
+        }, /* cleanup */ () -> {
+            runWithShellPermissionIdentity(() -> {
+                mContext.getSystemService(TestNetworkManager.class).teardownTestNetwork(
+                        testNetwork);
+            }, MANAGE_TEST_NETWORKS);
+            IoUtils.closeQuietly(tunFd);
+        });
+    }
 }
diff --git a/tests/cts/net/src/android/net/cts/DhcpOptionTest.kt b/tests/cts/net/src/android/net/cts/DhcpOptionTest.kt
index 555dd87bc8..a6b4c2e091 100644
--- a/tests/cts/net/src/android/net/cts/DhcpOptionTest.kt
+++ b/tests/cts/net/src/android/net/cts/DhcpOptionTest.kt
@@ -17,10 +17,10 @@
 package android.net.cts
 
 import android.net.DhcpOption
+import android.os.Build
 import androidx.test.filters.SmallTest
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
 import com.android.testutils.DevSdkIgnoreRunner
-import com.android.testutils.SC_V2
 import org.junit.Assert.assertArrayEquals
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertNull
@@ -28,7 +28,7 @@ import org.junit.runner.RunWith
 import org.junit.Test
 
 @SmallTest
-@IgnoreUpTo(SC_V2) // TODO: Use to Build.VERSION_CODES.SC_V2 when available
+@IgnoreUpTo(Build.VERSION_CODES.S_V2)
 @RunWith(DevSdkIgnoreRunner::class)
 class DhcpOptionTest {
     private val DHCP_OPTION_TYPE: Byte = 2
diff --git a/tests/cts/net/src/android/net/cts/DnsResolverTapTest.kt b/tests/cts/net/src/android/net/cts/DnsResolverTapTest.kt
index ff608f287f..85ada4d3b4 100644
--- a/tests/cts/net/src/android/net/cts/DnsResolverTapTest.kt
+++ b/tests/cts/net/src/android/net/cts/DnsResolverTapTest.kt
@@ -38,8 +38,8 @@ import com.android.testutils.AutoReleaseNetworkCallbackRule
 import com.android.testutils.DeviceConfigRule
 import com.android.testutils.DnsResolverModuleTest
 import com.android.testutils.IPv6UdpFilter
-import com.android.testutils.RecorderCallback.CallbackEntry.LinkPropertiesChanged
-import com.android.testutils.RouterAdvertisementResponder
+import com.android.testutils.NdResponder
+import com.android.testutils.TestableNetworkCallback.Event.LinkPropertiesChanged
 import com.android.testutils.TapPacketReaderRule
 import com.android.testutils.TestableNetworkAgent
 import com.android.testutils.TestDnsPacket
@@ -92,7 +92,7 @@ class DnsResolverTapTest {
     @get:Rule(order = 4)
     val cbRule = AutoReleaseNetworkCallbackRule()
 
-    private val ndResponder by lazy { RouterAdvertisementResponder(packetReaderRule.reader) }
+    private val ndResponder by lazy { NdResponder(packetReaderRule.reader) }
     private val dnsServerAddr by lazy {
         parseNumericAddress("fe80::124%${packetReaderRule.iface.interfaceName}") as Inet6Address
     }
@@ -182,4 +182,4 @@ class DnsResolverTapTest {
         doCancellationTest("test2.example.com",
             waitTimeForNoRetryAfterCancellationMs = timeWithRetryWhenNotCancelled + 50L)
     }
-}
\ No newline at end of file
+}
diff --git a/tests/cts/net/src/android/net/cts/DnsResolverTest.java b/tests/cts/net/src/android/net/cts/DnsResolverTest.java
index b66b853552..f3b53c687d 100644
--- a/tests/cts/net/src/android/net/cts/DnsResolverTest.java
+++ b/tests/cts/net/src/android/net/cts/DnsResolverTest.java
@@ -22,11 +22,10 @@ import static android.net.DnsResolver.FLAG_NO_CACHE_LOOKUP;
 import static android.net.DnsResolver.TYPE_A;
 import static android.net.DnsResolver.TYPE_AAAA;
 import static android.net.NetworkCapabilities.TRANSPORT_CELLULAR;
-import static android.net.cts.util.CtsNetUtils.TestNetworkCallback;
 import static android.provider.DeviceConfig.NAMESPACE_CONNECTIVITY;
 import static android.system.OsConstants.ETIMEDOUT;
 
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
+import static com.android.testutils.Cleanup.testAndCleanup;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -38,32 +37,35 @@ import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.content.ContentResolver;
 import android.content.Context;
-import android.content.pm.PackageManager;
 import android.net.ConnectivityManager;
 import android.net.DnsResolver;
 import android.net.Network;
 import android.net.NetworkCapabilities;
-import android.net.NetworkRequest;
 import android.net.ParseException;
 import android.net.cts.util.CtsNetUtils;
+import android.os.Build;
 import android.os.CancellationSignal;
 import android.os.Handler;
 import android.os.Looper;
 import android.platform.test.annotations.AppModeFull;
 import android.provider.Settings;
 import android.system.ErrnoException;
+import android.util.ArraySet;
 import android.util.Log;
 
 import androidx.test.InstrumentationRegistry;
 import androidx.test.runner.AndroidJUnit4;
 
 import com.android.net.module.util.DnsPacket;
+import com.android.testutils.AutoReleaseNetworkCallbackRule;
 import com.android.testutils.ConnectivityDiagnosticsCollector;
 import com.android.testutils.DevSdkIgnoreRule;
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo;
 import com.android.testutils.DeviceConfigRule;
 import com.android.testutils.DnsResolverModuleTest;
+import com.android.testutils.TestableNetworkCallback.Event;
 import com.android.testutils.SkipPresubmit;
+import com.android.testutils.TestableNetworkCallback;
 
 import org.junit.After;
 import org.junit.Before;
@@ -78,6 +80,7 @@ import java.net.Inet6Address;
 import java.net.InetAddress;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Set;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
@@ -89,6 +92,8 @@ public class DnsResolverTest {
     public static final DeviceConfigRule DEVICE_CONFIG_CLASS_RULE = new DeviceConfigRule();
     @Rule
     public final DevSdkIgnoreRule ignoreRule = new DevSdkIgnoreRule();
+    @Rule
+    public final AutoReleaseNetworkCallbackRule callbackRule = new AutoReleaseNetworkCallbackRule();
 
     private static final String TAG = "DnsResolverTest";
     private static final char[] HEX_CHARS = {
@@ -122,14 +127,11 @@ public class DnsResolverTest {
     private Context mContext;
     private ContentResolver mCR;
     private ConnectivityManager mCM;
-    private PackageManager mPackageManager;
     private CtsNetUtils mCtsNetUtils;
     private Executor mExecutor;
     private Executor mExecutorInline;
     private DnsResolver mDns;
 
-    private TestNetworkCallback mWifiRequestCallback = null;
-
     /**
      * @see BeforeClass
      */
@@ -154,15 +156,13 @@ public class DnsResolverTest {
         mCR = mContext.getContentResolver();
         mCtsNetUtils = new CtsNetUtils(mContext);
         mCtsNetUtils.storePrivateDnsSetting();
-        mPackageManager = mContext.getPackageManager();
+        callbackRule.requestCellIfSupported();
+        callbackRule.requestWifiIfSupported();
     }
 
     @After
     public void tearDown() throws Exception {
         mCtsNetUtils.restorePrivateDnsSetting();
-        if (mWifiRequestCallback != null) {
-            mCM.unregisterNetworkCallback(mWifiRequestCallback);
-        }
     }
 
     private static void maybeToggleWifiAndCell() throws Exception {
@@ -181,36 +181,21 @@ public class DnsResolverTest {
         return new String(hexChars);
     }
 
-    private Network[] getTestableNetworks() {
-        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_WIFI)) {
-            // File a NetworkRequest for Wi-Fi, so it connects even if a higher-scoring
-            // network, such as Ethernet, is already connected.
-            final NetworkRequest request = new NetworkRequest.Builder()
-                    .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
-                    .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
-                    .build();
-            mWifiRequestCallback = new TestNetworkCallback();
-            mCM.requestNetwork(request, mWifiRequestCallback);
-            mCtsNetUtils.ensureWifiConnected();
-        }
-        final ArrayList<Network> testableNetworks = new ArrayList<Network>();
-        for (Network network : mCM.getAllNetworks()) {
-            final NetworkCapabilities nc = mCM.getNetworkCapabilities(network);
-            if (nc != null
-                    && nc.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED)
-                    && nc.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)) {
-                testableNetworks.add(network);
-            }
-        }
+    /**
+     * Get all testable networks, and null to represent the default network.
+     */
+    private Set<Network> getTestableNetworksAndNull() {
+        final Set<Network> networks = new ArraySet<>();
+        networks.addAll(mCtsNetUtils.getTestableNetworks());
+        networks.add(null);
+        return networks;
+    }
 
-        assertTrue(
-                "This test requires that at least one network be connected. " +
-                        "Please ensure that the device is connected to a network.",
-                testableNetworks.size() >= 1);
-        // In order to test query with null network, add null as an element.
-        // Test cases which query with null network will go on default network.
-        testableNetworks.add(null);
-        return testableNetworks.toArray(new Network[0]);
+    private Network getDefaultNetwork() {
+        final TestableNetworkCallback cb = callbackRule.registerDefaultNetworkCallback();
+        return testAndCleanup(
+                () -> cb.eventuallyExpect(Event.AVAILABLE, TIMEOUT_MS).getNetwork(),
+                () -> callbackRule.unregisterNetworkCallback(cb));
     }
 
     static private void assertGreaterThan(String msg, int first, int second) {
@@ -421,7 +406,7 @@ public class DnsResolverTest {
 
     public void doTestRawQuery(Executor executor) throws InterruptedException {
         final String msg = "RawQuery " + TEST_DOMAIN;
-        for (Network network : getTestableNetworks()) {
+        for (Network network : getTestableNetworksAndNull()) {
             final VerifyCancelCallback callback = new VerifyCancelCallback(msg);
             mDns.rawQuery(network, TEST_DOMAIN, CLASS_IN, TYPE_AAAA, FLAG_NO_CACHE_LOOKUP,
                     executor, null, callback);
@@ -448,7 +433,7 @@ public class DnsResolverTest {
                 0x00, 0x01  /* Class */
         };
         final String msg = "RawQuery blob " + byteArrayToHexString(blob);
-        for (Network network : getTestableNetworks()) {
+        for (Network network : getTestableNetworksAndNull()) {
             final VerifyCancelCallback callback = new VerifyCancelCallback(msg);
             mDns.rawQuery(network, blob, FLAG_NO_CACHE_LOOKUP, executor, null, callback);
 
@@ -461,7 +446,7 @@ public class DnsResolverTest {
     public void doTestRawQueryRoot(Executor executor) throws InterruptedException {
         final String dname = "";
         final String msg = "RawQuery empty dname(ROOT) ";
-        for (Network network : getTestableNetworks()) {
+        for (Network network : getTestableNetworksAndNull()) {
             final VerifyCancelCallback callback = new VerifyCancelCallback(msg);
             mDns.rawQuery(network, dname, CLASS_IN, TYPE_AAAA, FLAG_NO_CACHE_LOOKUP,
                     executor, null, callback);
@@ -476,10 +461,10 @@ public class DnsResolverTest {
     public void doTestRawQueryNXDomain(Executor executor) throws InterruptedException {
         final String msg = "RawQuery " + TEST_NX_DOMAIN;
 
-        for (Network network : getTestableNetworks()) {
+        for (Network network : getTestableNetworksAndNull()) {
             final NetworkCapabilities nc = (network != null)
                     ? mCM.getNetworkCapabilities(network)
-                    : mCM.getNetworkCapabilities(mCM.getActiveNetwork());
+                    : mCM.getNetworkCapabilities(getDefaultNetwork());
             assertNotNull("Couldn't determine NetworkCapabilities for " + network, nc);
             // Some cellular networks configure their DNS servers never to return NXDOMAIN, so don't
             // test NXDOMAIN on these DNS servers.
@@ -501,10 +486,11 @@ public class DnsResolverTest {
         // Enable private DNS strict mode and set server to dns.google before doing NxDomain test.
         // b/144521720
         mCtsNetUtils.setPrivateDnsStrictMode(GOOGLE_PRIVATE_DNS_SERVER);
-        for (Network network :  getTestableNetworks()) {
-            final Network networkForPrivateDns =
-                    (network != null) ? network : mCM.getActiveNetwork();
+        for (Network network : getTestableNetworksAndNull()) {
+            final Network networkForPrivateDns = (network != null) ? network : getDefaultNetwork();
             assertNotNull("Can't find network to await private DNS on", networkForPrivateDns);
+            Log.i(TAG, "Waiting for private DNS setting on " + networkForPrivateDns
+                    + " (testable network: " + network + ")");
             mCtsNetUtils.awaitPrivateDnsSetting(msg + " wait private DNS setting timeout",
                     networkForPrivateDns, GOOGLE_PRIVATE_DNS_SERVER, true);
             final VerifyCancelCallback callback = new VerifyCancelCallback(msg);
@@ -523,7 +509,7 @@ public class DnsResolverTest {
         // Start a DNS query and the cancel it immediately. Use VerifyCancelCallback to expect
         // that the query is cancelled before it succeeds. If it is not cancelled before it
         // succeeds, retry the test until it is.
-        for (Network network : getTestableNetworks()) {
+        for (Network network : getTestableNetworksAndNull()) {
             boolean retry = false;
             int round = 0;
             do {
@@ -553,7 +539,7 @@ public class DnsResolverTest {
         // Start a DNS query and the cancel it immediately. Use VerifyCancelCallback to expect
         // that the query is cancelled before it succeeds. If it is not cancelled before it
         // succeeds, retry the test until it is.
-        for (Network network : getTestableNetworks()) {
+        for (Network network : getTestableNetworksAndNull()) {
             boolean retry = false;
             int round = 0;
             do {
@@ -579,7 +565,7 @@ public class DnsResolverTest {
     @Test
     public void testCancelBeforeQuery() throws InterruptedException {
         final String msg = "Test cancelled RawQuery " + TEST_DOMAIN;
-        for (Network network : getTestableNetworks()) {
+        for (Network network : getTestableNetworksAndNull()) {
             final VerifyCancelCallback callback = new VerifyCancelCallback(msg);
             final CancellationSignal cancelSignal = new CancellationSignal();
             cancelSignal.cancel();
@@ -713,7 +699,7 @@ public class DnsResolverTest {
 
     public void doTestQueryForInetAddress(Executor executor) throws InterruptedException {
         final String msg = "Test query for InetAddress " + TEST_DOMAIN;
-        for (Network network : getTestableNetworks()) {
+        for (Network network : getTestableNetworksAndNull()) {
             final VerifyCancelInetAddressCallback callback =
                     new VerifyCancelInetAddressCallback(msg, null);
             mDns.query(network, TEST_DOMAIN, FLAG_NO_CACHE_LOOKUP, executor, null, callback);
@@ -731,7 +717,7 @@ public class DnsResolverTest {
         // Start a DNS query and the cancel it immediately. Use VerifyCancelInetAddressCallback to
         // expect that the query is cancelled before it succeeds. If it is not cancelled before it
         // succeeds, retry the test until it is.
-        for (Network network : getTestableNetworks()) {
+        for (Network network : getTestableNetworksAndNull()) {
             boolean retry = false;
             int round = 0;
             do {
@@ -757,7 +743,7 @@ public class DnsResolverTest {
 
     public void doTestQueryForInetAddressIpv4(Executor executor) throws InterruptedException {
         final String msg = "Test query for IPv4 InetAddress " + TEST_DOMAIN;
-        for (Network network : getTestableNetworks()) {
+        for (Network network : getTestableNetworksAndNull()) {
             final VerifyCancelInetAddressCallback callback =
                     new VerifyCancelInetAddressCallback(msg, null);
             mDns.query(network, TEST_DOMAIN, TYPE_A, FLAG_NO_CACHE_LOOKUP,
@@ -773,7 +759,7 @@ public class DnsResolverTest {
 
     public void doTestQueryForInetAddressIpv6(Executor executor) throws InterruptedException {
         final String msg = "Test query for IPv6 InetAddress " + TEST_DOMAIN;
-        for (Network network : getTestableNetworks()) {
+        for (Network network : getTestableNetworksAndNull()) {
             final VerifyCancelInetAddressCallback callback =
                     new VerifyCancelInetAddressCallback(msg, null);
             mDns.query(network, TEST_DOMAIN, TYPE_AAAA, FLAG_NO_CACHE_LOOKUP,
@@ -789,19 +775,21 @@ public class DnsResolverTest {
 
     @Test
     public void testPrivateDnsBypass() throws InterruptedException {
+        final String dataStallRecoveryOnBadNetworkSetting =
+                "data_stall_recovery_on_bad_network";
         final String dataStallSetting = Settings.Global.getString(mCR,
-                Settings.Global.DATA_STALL_RECOVERY_ON_BAD_NETWORK);
-        Settings.Global.putInt(mCR, Settings.Global.DATA_STALL_RECOVERY_ON_BAD_NETWORK, 0);
+                dataStallRecoveryOnBadNetworkSetting);
+        Settings.Global.putInt(mCR, dataStallRecoveryOnBadNetworkSetting, 0);
         try {
             doTestPrivateDnsBypass();
         } finally {
-            Settings.Global.putString(mCR, Settings.Global.DATA_STALL_RECOVERY_ON_BAD_NETWORK,
+            Settings.Global.putString(mCR, dataStallRecoveryOnBadNetworkSetting,
                     dataStallSetting);
         }
     }
 
     private void doTestPrivateDnsBypass() throws InterruptedException {
-        final Network[] testNetworks = getTestableNetworks();
+        final Set<Network> testNetworks = getTestableNetworksAndNull();
 
         // Set an invalid private DNS server
         mCtsNetUtils.setPrivateDnsStrictMode(INVALID_PRIVATE_DNS_SERVER);
@@ -868,7 +856,7 @@ public class DnsResolverTest {
     }
 
     public void doTestContinuousQueries(Executor executor) throws InterruptedException {
-        for (Network network : getTestableNetworks()) {
+        for (Network network : getTestableNetworksAndNull()) {
             for (int i = 0; i < QUERY_TIMES ; ++i) {
                 // query v6/v4 in turn
                 boolean queryV6 = (i % 2 == 0);
@@ -890,7 +878,7 @@ public class DnsResolverTest {
     }
 
     /** Verifies that DnsResolver.DnsException can be subclassed and its constructor re-used. */
-    @Test @IgnoreUpTo(SC_V2) // TODO: Use to Build.VERSION_CODES.SC_V2 when available
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testDnsExceptionConstructor() throws InterruptedException {
         class TestDnsException extends DnsResolver.DnsException {
             TestDnsException(int code, @Nullable Throwable cause) {
diff --git a/tests/cts/net/src/android/net/cts/DscpPolicyTest.kt b/tests/cts/net/src/android/net/cts/DscpPolicyTest.kt
index d531e7abee..a058ba9cd6 100644
--- a/tests/cts/net/src/android/net/cts/DscpPolicyTest.kt
+++ b/tests/cts/net/src/android/net/cts/DscpPolicyTest.kt
@@ -46,6 +46,8 @@ import android.net.TestNetworkInterface
 import android.net.TestNetworkManager
 import android.net.TestNetworkManager.TestInterfaceRequest
 import android.net.cts.util.CtsNetUtils.TestNetworkCallback
+import android.os.Build
+import android.os.Handler
 import android.os.HandlerThread
 import android.os.SystemClock
 import android.platform.test.annotations.AppModeFull
@@ -70,12 +72,12 @@ import com.android.testutils.ArpResponder
 import com.android.testutils.CompatUtil
 import com.android.testutils.ConnectivityModuleTest
 import com.android.testutils.DevSdkIgnoreRule
-import com.android.testutils.RouterAdvertisementResponder
-import com.android.testutils.SC_V2
+import com.android.testutils.NdResponder
 import com.android.testutils.PollPacketReader
+import com.android.testutils.SC_V2
 import com.android.testutils.TestableNetworkAgent
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnDscpPolicyStatusUpdated
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnNetworkCreated
+import com.android.testutils.TestableNetworkAgent.Event.OnDscpPolicyStatusUpdated
+import com.android.testutils.TestableNetworkAgent.Event.OnNetworkCreated
 import com.android.testutils.TestableNetworkCallback
 import com.android.testutils.assertParcelingIsLossless
 import com.android.testutils.runAsShell
@@ -114,7 +116,7 @@ private const val IPV6_ADDRESS_WAIT_TIME_MS = 10_000L
 class DscpPolicyTest {
     @JvmField
     @Rule
-    val ignoreRule = DevSdkIgnoreRule(ignoreClassUpTo = SC_V2)
+    val ignoreRule = DevSdkIgnoreRule(ignoreClassUpTo = Build.VERSION_CODES.S_V2)
 
     private val LOCAL_IPV4_ADDRESS = InetAddresses.parseNumericAddress("192.0.2.1")
     private val TEST_TARGET_IPV4_ADDR =
@@ -138,7 +140,7 @@ class DscpPolicyTest {
     private lateinit var tunNetworkCallback: TestNetworkCallback
     private lateinit var reader: PollPacketReader
     private lateinit var arpResponder: ArpResponder
-    private lateinit var raResponder: RouterAdvertisementResponder
+    private lateinit var ndResponder: NdResponder
 
     private fun getKernelVersion(): IntArray {
         // Example:
@@ -175,16 +177,16 @@ class DscpPolicyTest {
 
         handlerThread.start()
         reader = PollPacketReader(
-                handlerThread.threadHandler,
+                Handler(handlerThread.looper),
                 iface.fileDescriptor.fileDescriptor,
                 MAX_PACKET_LENGTH)
         reader.startAsyncForTest()
 
         arpResponder = ArpResponder(reader, mapOf(TEST_TARGET_IPV4_ADDR to TEST_TARGET_MAC_ADDR))
         arpResponder.start()
-        raResponder = RouterAdvertisementResponder(reader)
-        raResponder.addRouterEntry(TEST_TARGET_MAC_ADDR, TEST_ROUTER_IPV6_ADDR)
-        raResponder.start()
+        ndResponder = NdResponder(reader)
+        ndResponder.addRouterEntry(TEST_TARGET_MAC_ADDR, TEST_ROUTER_IPV6_ADDR)
+        ndResponder.start()
     }
 
     @After
@@ -192,7 +194,7 @@ class DscpPolicyTest {
         if (!kernelIsAtLeast(5, 15)) {
             return
         }
-        raResponder.stop()
+        ndResponder.stop()
         arpResponder.stop()
 
         agentsToCleanUp.forEach { it.unregister() }
@@ -226,7 +228,7 @@ class DscpPolicyTest {
     private fun waitForGlobalIpv6Address(network: Network): Inet6Address {
         // Wait for global IPv6 address to be available
         var inet6Addr: Inet6Address? = null
-        val onLinkPrefix = raResponder.prefix
+        val onLinkPrefix = ndResponder.prefix
         val startTime = SystemClock.elapsedRealtime()
         while (SystemClock.elapsedRealtime() - startTime < IPV6_ADDRESS_WAIT_TIME_MS) {
             SystemClock.sleep(50 /* ms */)
diff --git a/tests/cts/net/src/android/net/cts/EthernetManagerTest.kt b/tests/cts/net/src/android/net/cts/EthernetManagerTest.kt
index 9f3213206f..6b3bfdaaf9 100644
--- a/tests/cts/net/src/android/net/cts/EthernetManagerTest.kt
+++ b/tests/cts/net/src/android/net/cts/EthernetManagerTest.kt
@@ -52,8 +52,8 @@ import android.net.StaticIpConfiguration
 import android.net.TestNetworkInterface
 import android.net.TestNetworkManager
 import android.net.TestNetworkManager.TestInterfaceRequest
-import android.net.cts.EthernetManagerTest.EthernetStateListener.CallbackEntry.EthernetStateChanged
-import android.net.cts.EthernetManagerTest.EthernetStateListener.CallbackEntry.InterfaceStateChanged
+import android.net.cts.EthernetManagerTest.EthernetStateListener.Event.EthernetStateChanged
+import android.net.cts.EthernetManagerTest.EthernetStateListener.Event.InterfaceStateChanged
 import android.os.Build
 import android.os.Handler
 import android.os.Looper
@@ -68,11 +68,11 @@ import com.android.testutils.ConnectivityModuleTest
 import com.android.testutils.DevSdkIgnoreRule
 import com.android.testutils.DevSdkIgnoreRunner
 import com.android.testutils.DeviceInfoUtils.isKernelVersionAtLeast
-import com.android.testutils.RecorderCallback.CallbackEntry.Available
-import com.android.testutils.RecorderCallback.CallbackEntry.CapabilitiesChanged
-import com.android.testutils.RecorderCallback.CallbackEntry.LinkPropertiesChanged
-import com.android.testutils.RecorderCallback.CallbackEntry.Lost
-import com.android.testutils.RouterAdvertisementResponder
+import com.android.testutils.NdResponder
+import com.android.testutils.TestableNetworkCallback.Event.Available
+import com.android.testutils.TestableNetworkCallback.Event.CapabilitiesChanged
+import com.android.testutils.TestableNetworkCallback.Event.LinkPropertiesChanged
+import com.android.testutils.TestableNetworkCallback.Event.Lost
 import com.android.testutils.PollPacketReader
 import com.android.testutils.TestableNetworkCallback
 import com.android.testutils.assertThrows
@@ -156,10 +156,10 @@ class EthernetManagerTest {
     ) {
         private val tapInterface: TestNetworkInterface
         private val packetReader: PollPacketReader
-        private val raResponder: RouterAdvertisementResponder
+        private val ndResponder: NdResponder
         private val tnm: TestNetworkManager
         val name get() = tapInterface.interfaceName
-        val onLinkPrefix get() = raResponder.prefix
+        val onLinkPrefix get() = ndResponder.prefix
 
         init {
             tnm = runAsShell(MANAGE_TEST_NETWORKS) {
@@ -183,13 +183,13 @@ class EthernetManagerTest {
                     tapInterface.fileDescriptor.fileDescriptor,
                     mtu
             )
-            raResponder = RouterAdvertisementResponder(packetReader)
+            ndResponder = NdResponder(packetReader)
             val iidString = "fe80::${Integer.toHexString(Random().nextInt(65536))}"
             val linklocal = InetAddresses.parseNumericAddress(iidString) as Inet6Address
-            raResponder.addRouterEntry(MacAddress.fromString("01:23:45:67:89:ab"), linklocal)
+            ndResponder.addRouterEntry(MacAddress.fromString("01:23:45:67:89:ab"), linklocal)
 
             packetReader.startAsyncForTest()
-            raResponder.start()
+            ndResponder.start()
         }
 
         // WARNING: this function requires kernel support. Call assumeChangingCarrierSupported() at
@@ -201,27 +201,27 @@ class EthernetManagerTest {
         }
 
         fun destroy() {
-            raResponder.stop()
+            ndResponder.stop()
             handler.post({ packetReader.stop() })
             handler.waitForIdle(TIMEOUT_MS)
         }
     }
 
     private open class EthernetStateListener private constructor(
-        private val history: ArrayTrackRecord<CallbackEntry>
+        private val history: ArrayTrackRecord<Event>
     ) : InterfaceStateListener, IntConsumer,
-                TrackRecord<EthernetStateListener.CallbackEntry> by history {
+                TrackRecord<EthernetStateListener.Event> by history {
         constructor() : this(ArrayTrackRecord())
 
         val events = history.newReadHead()
 
-        sealed class CallbackEntry {
+        sealed class Event {
             data class InterfaceStateChanged(
                 val iface: String,
                 val state: Int,
                 val role: Int,
                 val configuration: IpConfiguration?
-            ) : CallbackEntry() {
+            ) : Event() {
                 override fun toString(): String {
                     val stateString = when (state) {
                         STATE_ABSENT -> "STATE_ABSENT"
@@ -240,7 +240,7 @@ class EthernetManagerTest {
                 }
             }
 
-            data class EthernetStateChanged(val state: Int) : CallbackEntry() {
+            data class EthernetStateChanged(val state: Int) : Event() {
                 override fun toString(): String {
                     val stateString = when (state) {
                         ETHERNET_STATE_ENABLED -> "ETHERNET_STATE_ENABLED"
@@ -265,7 +265,7 @@ class EthernetManagerTest {
             add(EthernetStateChanged(state))
         }
 
-        fun <T : CallbackEntry> expectCallback(expected: T): T {
+        fun <T : Event> expectCallback(expected: T): T {
             val event = events.poll(TIMEOUT_MS)
             assertEquals(expected, event)
             return event as T
@@ -283,7 +283,7 @@ class EthernetManagerTest {
                 InterfaceStateChanged(iface, state, role,
                         if (state != STATE_ABSENT) DEFAULT_IP_CONFIGURATION else null)
 
-        fun eventuallyExpect(expected: CallbackEntry) {
+        fun eventuallyExpect(expected: Event) {
             val cb = events.poll(TIMEOUT_MS) { it == expected }
             assertNotNull(cb, "Never received expected $expected. Received: ${events.backtrace()}")
         }
@@ -535,11 +535,6 @@ class EthernetManagerTest {
         NetworkRequest.Builder(NetworkRequest(ETH_REQUEST))
             .setNetworkSpecifier(EthernetNetworkSpecifier(ifaceName)).build()
 
-    // b/233534110: eventuallyExpect<Lost>() does not advance ReadHead, use
-    // eventuallyExpect(Lost::class) instead.
-    private fun TestableNetworkCallback.eventuallyExpectLost(n: Network? = null) =
-        eventuallyExpect(Lost::class) { n?.equals(it.network) ?: true }
-
     private fun TestableNetworkCallback.assertNeverLost(n: Network? = null) =
         assertNoCallback { it is Lost && (n?.equals(it.network) ?: true) }
 
@@ -550,8 +545,7 @@ class EthernetManagerTest {
         expect<CapabilitiesChanged> { it.caps.networkSpecifier == EthernetNetworkSpecifier(name) }
 
     private fun TestableNetworkCallback.eventuallyExpectCapabilities(nc: NetworkCapabilities) {
-        // b/233534110: eventuallyExpect<CapabilitiesChanged>() does not advance ReadHead.
-        eventuallyExpect(CapabilitiesChanged::class) {
+        eventuallyExpect<CapabilitiesChanged> {
             // CS may mix in additional capabilities, so NetworkCapabilities#equals cannot be used.
             // Check if all expected capabilities are present instead.
             it is CapabilitiesChanged && nc.capabilities.all { c -> it.caps.hasCapability(c) }
@@ -561,8 +555,7 @@ class EthernetManagerTest {
     private fun TestableNetworkCallback.eventuallyExpectLpForStaticConfig(
         config: StaticIpConfiguration
     ) {
-        // b/233534110: eventuallyExpect<LinkPropertiesChanged>() does not advance ReadHead.
-        eventuallyExpect(LinkPropertiesChanged::class) {
+        eventuallyExpect<LinkPropertiesChanged> {
             it is LinkPropertiesChanged && it.lp.linkAddresses.any { la ->
                 la.isSameAddressAs(config.ipAddress)
             }
@@ -618,7 +611,12 @@ class EthernetManagerTest {
         // see aosp/2123900.
         try {
             // assumeException does not exist.
-            requestTetheredInterface().expectOnAvailable(NO_CALLBACK_TIMEOUT_MS)
+            val listener = requestTetheredInterface()
+            // Force requestTetheredInterface() to be processed before proceeding by calling
+            // setEthernetEnabled() which always waits on a callback and is guaranteed to be
+            // processed after requestTetheredInterface().
+            setEthernetEnabled(ethernetEnabled)
+            listener.expectOnAvailable(0)
             // interface used for tethering is available, throw an assumption error.
             assumeTrue(false)
         } catch (e: TimeoutException) {
@@ -626,8 +624,8 @@ class EthernetManagerTest {
             // tethering.
             releaseTetheredInterface()
             // Force releaseTetheredInterface() to be processed before proceeding by calling
-            // setEthernetEnabled(true) which always waits on a callback.
-            setEthernetEnabled(true)
+            // setEthernetEnabled() which always waits on a callback.
+            setEthernetEnabled(ethernetEnabled)
         }
     }
 
@@ -669,6 +667,36 @@ class EthernetManagerTest {
         listener.assertNoCallback()
     }
 
+    @Test
+    fun testCallbacks_withRunningInterfaces() {
+        // Do not run this test when unrestricted interfaces are present. Refer to testCallbacks.
+        assumeNoInterfaceForTetheringAvailable()
+
+        // The interfaces must be created before setIncludeTestInterfaces is set to false, so the
+        // test can ensure that the RTM_NEWLINK has been processed before proceeding.
+        val iface1 = createInterface()
+        val iface2 = createInterface()
+        val iface3 = createInterface()
+
+        // Prevent test interfaces from being tracked and wait for the call to be processed by
+        // calling setEthernetEnabled() which waits on a completion callback.
+        setIncludeTestInterfaces(false)
+        setEthernetEnabled(true)
+
+        val listener = EthernetStateListener()
+        addInterfaceStateListener(listener)
+        listener.assertNoCallback()
+
+        // Include test interfaces again, and ensure that they are tracked properly.
+        setIncludeTestInterfaces(true)
+        setEthernetEnabled(true)
+
+        listener.expectCallback(iface1, STATE_LINK_UP, ROLE_CLIENT)
+        listener.expectCallback(iface2, STATE_LINK_UP, ROLE_CLIENT)
+        listener.expectCallback(iface3, STATE_LINK_UP, ROLE_CLIENT)
+        listener.assertNoCallback()
+    }
+
     @Test
     fun testGetInterfaceList() {
         // Create two test interfaces and check the return list contains the interface names.
@@ -703,7 +731,7 @@ class EthernetManagerTest {
 
         cb.assertNeverLost()
         releaseRequest(cb)
-        listenerCb.eventuallyExpectLost(network)
+        listenerCb.eventuallyExpect<Lost>() { network.equals(it.network) }
     }
 
     @Test
@@ -721,7 +749,7 @@ class EthernetManagerTest {
         // remove interface before network request has been removed
         cb.assertNeverLost()
         removeInterface(iface)
-        cb.eventuallyExpectLost()
+        cb.eventuallyExpect<Lost>()
     }
 
     @Test
@@ -737,7 +765,7 @@ class EthernetManagerTest {
         removeInterface(iface1)
         cb.assertNeverLost()
         removeInterface(iface2)
-        cb.eventuallyExpectLost()
+        cb.eventuallyExpect<Lost>()
     }
 
     @Test
@@ -753,7 +781,7 @@ class EthernetManagerTest {
 
         // remove iface1 and verify the request brings up iface2
         removeInterface(iface1)
-        cb.eventuallyExpectLost(network)
+        cb.eventuallyExpect<Lost>() { network.equals(it.network) }
         cb.expect<Available>()
     }
 
@@ -796,7 +824,7 @@ class EthernetManagerTest {
 
         cb2.assertNeverLost()
         releaseRequest(cb2)
-        listener.eventuallyExpectLost(network)
+        listener.eventuallyExpect<Lost>() { network.equals(it.network) }
     }
 
     @Test
@@ -813,7 +841,7 @@ class EthernetManagerTest {
         cb.expect<Available>()
 
         iface.setCarrierEnabled(false)
-        cb.eventuallyExpectLost()
+        cb.eventuallyExpect<Lost>()
     }
 
     // TODO: move to MTS
@@ -821,8 +849,7 @@ class EthernetManagerTest {
     fun testNetworkRequest_linkPropertiesUpdate() {
         val iface = createInterface()
         val cb = requestNetwork(ETH_REQUEST)
-        // b/233534110: eventuallyExpect<LinkPropertiesChanged>() does not advance ReadHead
-        cb.eventuallyExpect(LinkPropertiesChanged::class) {
+        cb.eventuallyExpect<LinkPropertiesChanged> {
             it is LinkPropertiesChanged && it.lp.addresses.any {
                 address -> iface.onLinkPrefix.contains(address)
             }
@@ -859,7 +886,7 @@ class EthernetManagerTest {
         cb.assertNeverLost()
 
         disableInterface(iface).expectResult(iface.name)
-        cb.eventuallyExpectLost()
+        cb.eventuallyExpect<Lost>()
 
         enableInterface(iface).expectResult(iface.name)
         cb.expect<Available>()
@@ -970,7 +997,7 @@ class EthernetManagerTest {
         // Request the restricted network as the shell with CONNECTIVITY_USE_RESTRICTED_NETWORKS.
         val cb = runAsShell(CONNECTIVITY_USE_RESTRICTED_NETWORKS) { requestNetwork(request) }
         val network = cb.expect<Available>().network
-        cb.assertNeverLost(network)
+        cb.assertNeverLost()
 
         // The network is restricted therefore binding to it when available will fail.
         Socket().use { socket ->
@@ -985,7 +1012,11 @@ class EthernetManagerTest {
 
         // UpdateConfiguration() currently does a restart on the ethernet interface therefore lost
         // will be expected first before available, as part of the restart.
-        cb.expect<Lost>(network)
+        // Note: this uses eventuallyExpect, because depending on how the DAD timers align, there
+        // may be 1 or 2 onLinkPropertiesChanged() callbacks. It is possible for that second
+        // onLinkPropertiesChanged() to arrive after assertNeverLost() returns.
+        // TODO: consider disabling DAD for these tests.
+        cb.eventuallyExpect<Lost>()
         val updatedNetwork = cb.expect<Available>().network
         // With the test process UID allowed, binding to a restricted network should be successful.
         Socket().use { socket -> updatedNetwork.bindSocket(socket) }
@@ -1026,7 +1057,7 @@ class EthernetManagerTest {
         cb.expect<Available>()
 
         iface.setCarrierEnabled(false)
-        cb.eventuallyExpectLost()
+        cb.eventuallyExpect<Lost>()
 
         updateConfiguration(iface, STATIC_IP_CONFIGURATION, TEST_CAPS).expectResult(iface.name)
         cb.assertNoCallback()
diff --git a/tests/cts/net/src/android/net/cts/EthernetNetworkUpdateRequestTest.java b/tests/cts/net/src/android/net/cts/EthernetNetworkUpdateRequestTest.java
index c8ee0c7202..11ac24b2da 100644
--- a/tests/cts/net/src/android/net/cts/EthernetNetworkUpdateRequestTest.java
+++ b/tests/cts/net/src/android/net/cts/EthernetNetworkUpdateRequestTest.java
@@ -18,8 +18,6 @@ package android.net.cts;
 
 import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED;
 
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertThrows;
@@ -29,6 +27,7 @@ import android.net.EthernetNetworkUpdateRequest;
 import android.net.IpConfiguration;
 import android.net.NetworkCapabilities;
 import android.net.StaticIpConfiguration;
+import android.os.Build;
 
 import androidx.test.filters.SmallTest;
 
@@ -39,7 +38,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 
 @SmallTest
-@DevSdkIgnoreRule.IgnoreUpTo(SC_V2) // TODO: Use to Build.VERSION_CODES.SC_V2 when available
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 @RunWith(DevSdkIgnoreRunner.class)
 public class EthernetNetworkUpdateRequestTest {
     private static final NetworkCapabilities DEFAULT_CAPS =
diff --git a/tests/cts/net/src/android/net/cts/Ikev2VpnTest.java b/tests/cts/net/src/android/net/cts/Ikev2VpnTest.java
index cb55bd5dad..86363969ee 100644
--- a/tests/cts/net/src/android/net/cts/Ikev2VpnTest.java
+++ b/tests/cts/net/src/android/net/cts/Ikev2VpnTest.java
@@ -22,9 +22,8 @@ import static android.net.NetworkCapabilities.TRANSPORT_VPN;
 import static android.net.cts.util.CtsNetUtils.TestNetworkCallback;
 
 import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;
-import static com.android.modules.utils.build.SdkLevel.isAtLeastU;
 import static com.android.modules.utils.build.SdkLevel.isAtLeastT;
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
+import static com.android.modules.utils.build.SdkLevel.isAtLeastU;
 
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
@@ -34,12 +33,11 @@ import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeTrue;
 import static org.junit.Assume.assumeFalse;
+import static org.junit.Assume.assumeTrue;
 
 import android.Manifest;
 import android.annotation.NonNull;
-import android.app.AppOpsManager;
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.PackageManager;
@@ -61,7 +59,7 @@ import android.text.TextUtils;
 
 import androidx.test.InstrumentationRegistry;
 
-import com.android.internal.util.HexDump;
+import com.android.net.module.util.HexDump;
 import com.android.networkstack.apishim.ConstantsShim;
 import com.android.networkstack.apishim.VpnManagerShimImpl;
 import com.android.networkstack.apishim.common.VpnManagerShim;
@@ -69,8 +67,8 @@ import com.android.networkstack.apishim.common.VpnProfileStateShim;
 import com.android.testutils.DevSdkIgnoreRule;
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo;
 import com.android.testutils.DevSdkIgnoreRunner;
-import com.android.testutils.RecorderCallback.CallbackEntry;
 import com.android.testutils.TestableNetworkCallback;
+import com.android.testutils.TestableNetworkCallback.Event;
 
 import org.bouncycastle.x509.X509V1CertificateGenerator;
 import org.junit.After;
@@ -99,6 +97,10 @@ import javax.security.auth.x500.X500Principal;
 public class Ikev2VpnTest {
     private static final String TAG = Ikev2VpnTest.class.getSimpleName();
 
+    // TODO: make AppOpsManager.OP_ACTIVATE_VPN API
+    private static final int OP_ACTIVATE_VPN = 47;
+    private static final int OP_ACTIVATE_PLATFORM_VPN = 94;
+
     @Rule
     public final DevSdkIgnoreRule ignoreRule = new DevSdkIgnoreRule();
 
@@ -219,8 +221,8 @@ public class Ikev2VpnTest {
         for (TestableNetworkCallback callback : mCallbacksToUnregister) {
             sCM.unregisterNetworkCallback(callback);
         }
-        setAppop(AppOpsManager.OP_ACTIVATE_VPN, false);
-        setAppop(AppOpsManager.OP_ACTIVATE_PLATFORM_VPN, false);
+        setAppop(OP_ACTIVATE_VPN, false);
+        setAppop(OP_ACTIVATE_PLATFORM_VPN, false);
 
         // Make sure the VpnProfile is not provisioned already.
         sVpnMgr.stopProvisionedVpnProfile();
@@ -265,14 +267,22 @@ public class Ikev2VpnTest {
             builder.setAutomaticNattKeepaliveTimerEnabled(automaticNattKeepaliveTimerEnabled);
         }
 
-        // TODO: replace it in alternative way to remove the hidden method usage
         if (isRestrictedToTestNetworks) {
-            builder.restrictToTestNetworks();
+            restrictToTestNetworks(builder);
         }
 
         return builder.build();
     }
 
+    private void restrictToTestNetworks(@NonNull Ikev2VpnProfile.Builder builder) {
+        try {
+            // TODO: replace it in alternative way to remove the hidden method usage
+            builder.getClass().getMethod("restrictToTestNetworks").invoke(builder);
+        } catch (ReflectiveOperationException e) {
+            throw new AssertionError(e);
+        }
+    }
+
     private Ikev2VpnProfile buildIkev2VpnProfileIkeTunConnParams(
             final boolean isRestrictedToTestNetworks, final boolean requiresValidation,
             final boolean testIpv6) throws Exception {
@@ -288,9 +298,8 @@ public class Ikev2VpnTest {
                         .setMaxMtu(TEST_MTU)
                         .setMetered(false);
 
-        // TODO: replace it in alternative way to remove the hidden method usage
         if (isRestrictedToTestNetworks) {
-            builder.restrictToTestNetworks();
+            restrictToTestNetworks(builder);
         }
         return builder.build();
     }
@@ -335,7 +344,8 @@ public class Ikev2VpnTest {
         assertTrue(profile.isBypassable());
         assertFalse(profile.isMetered());
         assertEquals(TEST_MTU, profile.getMaxMtu());
-        assertFalse(profile.isRestrictedToTestNetworks());
+        assertFalse((boolean) profile.getClass().getMethod("isRestrictedToTestNetworks")
+                .invoke(profile));
     }
 
     public void doTestBuildIkev2VpnProfilePsk(final boolean requiresValidation) throws Exception {
@@ -358,7 +368,7 @@ public class Ikev2VpnTest {
         }
     }
 
-    @IgnoreUpTo(SC_V2)
+    @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     @Test
     public void testBuildIkev2VpnProfileWithIkeTunnelConnectionParams() throws Exception {
         assumeTrue(mCtsNetUtils.hasIpsecTunnelsFeature());
@@ -427,8 +437,8 @@ public class Ikev2VpnTest {
             throws Exception {
         assumeTrue(mCtsNetUtils.hasIpsecTunnelsFeature());
 
-        setAppop(AppOpsManager.OP_ACTIVATE_VPN, hasActivateVpn);
-        setAppop(AppOpsManager.OP_ACTIVATE_PLATFORM_VPN, hasActivatePlatformVpn);
+        setAppop(OP_ACTIVATE_VPN, hasActivateVpn);
+        setAppop(OP_ACTIVATE_PLATFORM_VPN, hasActivatePlatformVpn);
 
         final Ikev2VpnProfile profile = buildIkev2VpnProfilePsk(TEST_SERVER_ADDR_V6,
                 false /* isRestrictedToTestNetworks */, false /* requiresValidation */);
@@ -472,19 +482,19 @@ public class Ikev2VpnTest {
     public void testDeleteVpnProfile() throws Exception {
         assumeTrue(mCtsNetUtils.hasIpsecTunnelsFeature());
 
-        setAppop(AppOpsManager.OP_ACTIVATE_PLATFORM_VPN, true);
+        setAppop(OP_ACTIVATE_PLATFORM_VPN, true);
 
         final Ikev2VpnProfile profile = buildIkev2VpnProfilePsk(TEST_SERVER_ADDR_V6,
                 false /* isRestrictedToTestNetworks */, false /* requiresValidation */);
         assertNull(sVpnMgr.provisionVpnProfile(profile));
 
         // Verify that deleting the profile works (even without the appop)
-        setAppop(AppOpsManager.OP_ACTIVATE_PLATFORM_VPN, false);
+        setAppop(OP_ACTIVATE_PLATFORM_VPN, false);
         sVpnMgr.deleteProvisionedVpnProfile();
 
         // Test that the profile was deleted - starting it should throw an IAE.
         try {
-            setAppop(AppOpsManager.OP_ACTIVATE_PLATFORM_VPN, true);
+            setAppop(OP_ACTIVATE_PLATFORM_VPN, true);
             sVpnMgr.startProvisionedVpnProfile();
             fail("Expected IllegalArgumentException due to missing profile");
         } catch (IllegalArgumentException expected) {
@@ -495,8 +505,8 @@ public class Ikev2VpnTest {
     public void testStartVpnProfileNoPreviousConsent() throws Exception {
         assumeTrue(mCtsNetUtils.hasIpsecTunnelsFeature());
 
-        setAppop(AppOpsManager.OP_ACTIVATE_VPN, false);
-        setAppop(AppOpsManager.OP_ACTIVATE_PLATFORM_VPN, false);
+        setAppop(OP_ACTIVATE_VPN, false);
+        setAppop(OP_ACTIVATE_PLATFORM_VPN, false);
 
         // Make sure the VpnProfile is not provisioned already.
         sVpnMgr.stopProvisionedVpnProfile();
@@ -518,7 +528,7 @@ public class Ikev2VpnTest {
         boolean hasNat = !testIpv6;
 
         // Requires MANAGE_TEST_NETWORKS to provision a test-mode profile.
-        mCtsNetUtils.setAppopPrivileged(AppOpsManager.OP_ACTIVATE_PLATFORM_VPN, true);
+        mCtsNetUtils.setAppopPrivileged(OP_ACTIVATE_PLATFORM_VPN, true);
 
         final Ikev2VpnProfile profile = testIkeTunConnParams
                 ? buildIkev2VpnProfileIkeTunConnParams(true /* isRestrictedToTestNetworks */,
@@ -555,7 +565,7 @@ public class Ikev2VpnTest {
                 HexDump.hexStringToByteArray(authResp));
 
         // Verify the VPN network came up
-        final Network vpnNetwork = cb.expect(CallbackEntry.AVAILABLE).getNetwork();
+        final Network vpnNetwork = cb.expect(Event.AVAILABLE).getNetwork();
 
         if (testSessionKey) {
             final VpnProfileStateShim profileState = mVmShim.getProvisionedVpnProfileState();
@@ -569,8 +579,8 @@ public class Ikev2VpnTest {
                 && c.hasCapability(NET_CAPABILITY_INTERNET)
                 && !c.hasCapability(NET_CAPABILITY_VALIDATED)
                 && Process.myUid() == c.getOwnerUid());
-        cb.expect(CallbackEntry.LINK_PROPERTIES_CHANGED, vpnNetwork);
-        cb.expect(CallbackEntry.BLOCKED_STATUS, vpnNetwork);
+        cb.expect(Event.LINK_PROPERTIES_CHANGED, vpnNetwork);
+        cb.expect(Event.BLOCKED_STATUS, vpnNetwork);
 
         // A VPN that requires validation is initially not validated, while one that doesn't
         // immediately validate automatically. Because this VPN can't actually access Internet,
@@ -582,15 +592,15 @@ public class Ikev2VpnTest {
         // misuse VPN network itself as the underlying network. The fix is not available without
         // SDK > T platform. Thus, verify this only on T+ platform.
         if (!requiresValidation && isAtLeastT()) {
-            cb.eventuallyExpect(CallbackEntry.NETWORK_CAPS_UPDATED, TIMEOUT_MS,
-                    entry -> ((CallbackEntry.CapabilitiesChanged) entry).getCaps()
+            cb.eventuallyExpect(Event.NETWORK_CAPS_UPDATED, TIMEOUT_MS,
+                    entry -> ((Event.CapabilitiesChanged) entry).getCaps()
                             .hasCapability(NET_CAPABILITY_VALIDATED));
         }
 
         sVpnMgr.stopProvisionedVpnProfile();
         // Using expectCallback may cause the test to be flaky since test may receive other
         // callbacks such as linkproperties change.
-        cb.eventuallyExpect(CallbackEntry.LOST, TIMEOUT_MS,
+        cb.eventuallyExpect(Event.LOST, TIMEOUT_MS,
                 lost -> vpnNetwork.equals(lost.getNetwork()));
     }
 
@@ -653,62 +663,62 @@ public class Ikev2VpnTest {
                         testIpv6Only, requiresValidation, testSessionKey , testIkeTunConnParams)));
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testStartStopVpnProfileV4() throws Exception {
         doTestStartStopVpnProfile(false /* testIpv6Only */, false /* requiresValidation */,
                 false /* testSessionKey */, false /* testIkeTunConnParams */);
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testStartStopVpnProfileV4WithValidation() throws Exception {
         doTestStartStopVpnProfile(false /* testIpv6Only */, true /* requiresValidation */,
                 false /* testSessionKey */, false /* testIkeTunConnParams */);
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testStartStopVpnProfileV6() throws Exception {
         doTestStartStopVpnProfile(true /* testIpv6Only */, false /* requiresValidation */,
                 false /* testSessionKey */, false /* testIkeTunConnParams */);
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testStartStopVpnProfileV6WithValidation() throws Exception {
         doTestStartStopVpnProfile(true /* testIpv6Only */, true /* requiresValidation */,
                 false /* testSessionKey */, false /* testIkeTunConnParams */);
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testStartStopVpnProfileIkeTunConnParamsV4() throws Exception {
         doTestStartStopVpnProfile(false /* testIpv6Only */, false /* requiresValidation */,
                 false /* testSessionKey */, true /* testIkeTunConnParams */);
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testStartStopVpnProfileIkeTunConnParamsV4WithValidation() throws Exception {
         doTestStartStopVpnProfile(false /* testIpv6Only */, true /* requiresValidation */,
                 false /* testSessionKey */, true /* testIkeTunConnParams */);
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testStartStopVpnProfileIkeTunConnParamsV6() throws Exception {
         doTestStartStopVpnProfile(true /* testIpv6Only */, false /* requiresValidation */,
                 false /* testSessionKey */, true /* testIkeTunConnParams */);
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testStartStopVpnProfileIkeTunConnParamsV6WithValidation() throws Exception {
         doTestStartStopVpnProfile(true /* testIpv6Only */, true /* requiresValidation */,
                 false /* testSessionKey */, true /* testIkeTunConnParams */);
     }
 
-    @IgnoreUpTo(SC_V2)
+    @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     @Test
     public void testStartProvisionedVpnV4ProfileSession() throws Exception {
         doTestStartStopVpnProfile(false /* testIpv6Only */, false /* requiresValidation */,
                 true /* testSessionKey */, false /* testIkeTunConnParams */);
     }
 
-    @IgnoreUpTo(SC_V2)
+    @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     @Test
     public void testStartProvisionedVpnV6ProfileSession() throws Exception {
         doTestStartStopVpnProfile(true /* testIpv6Only */, false /* requiresValidation */,
diff --git a/tests/cts/net/src/android/net/cts/IpSecManagerTunnelTest.java b/tests/cts/net/src/android/net/cts/IpSecManagerTunnelTest.java
index f2c6d337a9..2f8ab032ad 100644
--- a/tests/cts/net/src/android/net/cts/IpSecManagerTunnelTest.java
+++ b/tests/cts/net/src/android/net/cts/IpSecManagerTunnelTest.java
@@ -16,7 +16,6 @@
 
 package android.net.cts;
 
-import static android.app.AppOpsManager.OP_MANAGE_IPSEC_TUNNELS;
 import static android.net.IpSecManager.UdpEncapsulationSocket;
 import static android.net.cts.IpSecManagerTest.assumeExperimentalIpv6UdpEncapSupported;
 import static android.net.cts.IpSecManagerTest.assumeRequestIpSecTransformStateSupported;
@@ -87,6 +86,9 @@ import java.net.NetworkInterface;
 public class IpSecManagerTunnelTest extends IpSecBaseTest {
     @Rule public final DevSdkIgnoreRule ignoreRule = new DevSdkIgnoreRule();
 
+    // TODO: make AppOpsManager.OP_MANAGE_IPSEC_TUNNELS API
+    private static final int OP_MANAGE_IPSEC_TUNNELS = 75;
+
     private static final String TAG = IpSecManagerTunnelTest.class.getSimpleName();
 
     private static final InetAddress LOCAL_OUTER_4 = InetAddress.parseNumericAddress("192.0.2.1");
diff --git a/tests/cts/net/src/android/net/cts/MultinetworkApiTest.java b/tests/cts/net/src/android/net/cts/MultinetworkApiTest.java
index c67443e1d1..14ef98a401 100644
--- a/tests/cts/net/src/android/net/cts/MultinetworkApiTest.java
+++ b/tests/cts/net/src/android/net/cts/MultinetworkApiTest.java
@@ -16,19 +16,15 @@
 
 package android.net.cts;
 
-import static android.content.pm.PackageManager.FEATURE_TELEPHONY;
-import static android.content.pm.PackageManager.FEATURE_WIFI;
 import static android.net.NetworkCapabilities.TRANSPORT_CELLULAR;
 import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
 import static android.provider.DeviceConfig.NAMESPACE_CONNECTIVITY;
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
-import android.content.ContentResolver;
 import android.content.Context;
 import android.net.ConnectivityManager;
 import android.net.Network;
@@ -38,7 +34,6 @@ import android.net.cts.util.CtsNetUtils;
 import android.platform.test.annotations.AppModeFull;
 import android.system.ErrnoException;
 import android.system.OsConstants;
-import android.util.ArraySet;
 import android.util.Log;
 
 import androidx.test.platform.app.InstrumentationRegistry;
@@ -56,7 +51,6 @@ import org.junit.runner.RunWith;
 
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Set;
 
 @DevSdkIgnoreRunner.RestoreDefaultNetwork
 @RunWith(DevSdkIgnoreRunner.class)
@@ -110,23 +104,25 @@ public class MultinetworkApiTest {
     private static native void runResNnxDomainCheck(long networkHandle);
 
 
-    private ContentResolver mCR;
     private ConnectivityManager mCM;
     private CtsNetUtils mCtsNetUtils;
-    private Context mContext;
-    private Network mRequestedCellNetwork;
 
     @Before
     public void setUp() throws Exception {
-        mContext = InstrumentationRegistry.getInstrumentation().getContext();
-        mCM = mContext.getSystemService(ConnectivityManager.class);
-        mCR = mContext.getContentResolver();
-        mCtsNetUtils = new CtsNetUtils(mContext);
+        final Context context = InstrumentationRegistry.getInstrumentation().getContext();
+        mCM = context.getSystemService(ConnectivityManager.class);
+        mCtsNetUtils = new CtsNetUtils(context);
+        // In instant mode, do not request cell or Wi-Fi connection, as this requires the
+        // CHANGE_NETWORK_STATE permission which cannot be granted.
+        if (!context.getApplicationInfo().isInstantApp()) {
+            mNetworkCallbackRule.requestCellIfSupported();
+            mNetworkCallbackRule.requestWifiIfSupported();
+        }
     }
 
     @Test
     public void testGetaddrinfo() throws Exception {
-        for (Network network : getTestableNetworks()) {
+        for (Network network : mCtsNetUtils.getTestableNetworks()) {
             int errno = runGetaddrinfoCheck(network.getNetworkHandle());
             if (errno != 0) {
                 throw new ErrnoException(
@@ -142,7 +138,7 @@ public class MultinetworkApiTest {
         assertNull(mCM.getProcessDefaultNetwork());
         assertEquals(0, NetworkUtils.getBoundNetworkForProcess());
 
-        for (Network network : getTestableNetworks()) {
+        for (Network network : mCtsNetUtils.getTestableNetworks()) {
             mCM.setProcessDefaultNetwork(null);
             assertNull(mCM.getProcessDefaultNetwork());
 
@@ -161,7 +157,7 @@ public class MultinetworkApiTest {
             mCM.setProcessDefaultNetwork(null);
         }
 
-        for (Network network : getTestableNetworks()) {
+        for (Network network : mCtsNetUtils.getTestableNetworks()) {
             NetworkUtils.bindProcessToNetwork(0);
             assertNull(mCM.getBoundNetworkForProcess());
 
@@ -182,7 +178,7 @@ public class MultinetworkApiTest {
     @Test
     @AppModeFull(reason = "CHANGE_NETWORK_STATE permission can't be granted to instant apps")
     public void testSetsocknetwork() throws Exception {
-        for (Network network : getTestableNetworks()) {
+        for (Network network : mCtsNetUtils.getTestableNetworks()) {
             int errno = runSetsocknetwork(network.getNetworkHandle());
             if (errno != 0) {
                 throw new ErrnoException(
@@ -236,7 +232,7 @@ public class MultinetworkApiTest {
 
     @Test
     public void testNativeDatagramTransmission() throws Exception {
-        for (Network network : getTestableNetworks()) {
+        for (Network network : mCtsNetUtils.getTestableNetworks()) {
             final QueryTestResult result = runDatagramCheck(network.getNetworkHandle(),
                     0 /* sourcePort */);
             if (result.errNo == 0) {
@@ -273,7 +269,7 @@ public class MultinetworkApiTest {
     @Test
     public void testNetworkHandle() throws Exception {
         // Test Network -> NetworkHandle -> Network results in the same Network.
-        for (Network network : getTestableNetworks()) {
+        for (Network network : mCtsNetUtils.getTestableNetworks()) {
             long networkHandle = network.getNetworkHandle();
             Network newNetwork = Network.fromNetworkHandle(networkHandle);
             assertEquals(newNetwork, network);
@@ -296,7 +292,7 @@ public class MultinetworkApiTest {
 
     @Test
     public void testResNApi() throws Exception {
-        for (Network network : getTestableNetworks()) {
+        for (Network network : mCtsNetUtils.getTestableNetworks()) {
             // Throws AssertionError directly in jni function if test fail.
             runResNqueryCheck(network.getNetworkHandle());
             runResNsendCheck(network.getNetworkHandle());
@@ -332,7 +328,7 @@ public class MultinetworkApiTest {
         // b/144521720
         try {
             mCtsNetUtils.setPrivateDnsStrictMode(GOOGLE_PRIVATE_DNS_SERVER);
-            for (Network network : getTestableNetworks()) {
+            for (Network network : mCtsNetUtils.getTestableNetworks()) {
               // Wait for private DNS setting to propagate.
               mCtsNetUtils.awaitPrivateDnsSetting("NxDomain test wait private DNS setting timeout",
                         network, GOOGLE_PRIVATE_DNS_SERVER, true);
@@ -342,52 +338,4 @@ public class MultinetworkApiTest {
             mCtsNetUtils.restorePrivateDnsSetting();
         }
     }
-
-    /**
-     * Get all testable Networks with internet capability.
-     */
-    private Set<Network> getTestableNetworks() throws InterruptedException {
-        // Calling requestNetwork() to request a cell or Wi-Fi network via CtsNetUtils or
-        // NetworkCallbackRule requires the CHANGE_NETWORK_STATE permission. This permission cannot
-        // be granted to instant apps. Therefore, return currently available testable networks
-        // directly in instant mode.
-        if (mContext.getApplicationInfo().isInstantApp()) {
-            return new ArraySet<>(mCtsNetUtils.getTestableNetworks());
-        }
-
-        // Obtain cell and Wi-Fi through CtsNetUtils (which uses NetworkCallbacks), as they may have
-        // just been reconnected by the test using NetworkCallbacks, so synchronous calls may not
-        // yet return them (synchronous calls and callbacks should not be mixed for a given
-        // Network).
-        final Set<Network> testableNetworks = new ArraySet<>();
-        if (mContext.getPackageManager().hasSystemFeature(FEATURE_TELEPHONY)) {
-            if (mRequestedCellNetwork == null) {
-                mRequestedCellNetwork = mNetworkCallbackRule.requestCell();
-            }
-            assertNotNull("Cell network requested but not obtained", mRequestedCellNetwork);
-            testableNetworks.add(mRequestedCellNetwork);
-        }
-
-        if (mContext.getPackageManager().hasSystemFeature(FEATURE_WIFI)) {
-            testableNetworks.add(mCtsNetUtils.ensureWifiConnected());
-        }
-
-        // Obtain other networks through the synchronous API, if any.
-        for (Network network : mCtsNetUtils.getTestableNetworks()) {
-            final NetworkCapabilities nc = mCM.getNetworkCapabilities(network);
-            if (nc != null
-                    && !nc.hasTransport(TRANSPORT_WIFI)
-                    && !nc.hasTransport(TRANSPORT_CELLULAR)) {
-                testableNetworks.add(network);
-            }
-        }
-
-        // In practice this should not happen as getTestableNetworks throws if there is no network
-        // at all.
-        assertFalse("This device does not support WiFi nor cell data, and does not have any other "
-                        + "network connected. This test requires at least one internet-providing "
-                        + "network.",
-                testableNetworks.isEmpty());
-        return testableNetworks;
-    }
 }
diff --git a/tests/cts/net/src/android/net/cts/NetworkAgentTest.kt b/tests/cts/net/src/android/net/cts/NetworkAgentTest.kt
index 02a5d1f654..b2d988f1aa 100644
--- a/tests/cts/net/src/android/net/cts/NetworkAgentTest.kt
+++ b/tests/cts/net/src/android/net/cts/NetworkAgentTest.kt
@@ -75,9 +75,9 @@ import android.net.TransportInfo
 import android.net.Uri
 import android.net.VpnManager
 import android.net.VpnTransportInfo
-import android.net.cts.NetworkAgentTest.TestableQosCallback.CallbackEntry.OnError
-import android.net.cts.NetworkAgentTest.TestableQosCallback.CallbackEntry.OnQosSessionAvailable
-import android.net.cts.NetworkAgentTest.TestableQosCallback.CallbackEntry.OnQosSessionLost
+import android.net.cts.NetworkAgentTest.TestableQosCallback.Event.OnError
+import android.net.cts.NetworkAgentTest.TestableQosCallback.Event.OnQosSessionAvailable
+import android.net.cts.NetworkAgentTest.TestableQosCallback.Event.OnQosSessionLost
 import android.net.wifi.WifiInfo
 import android.os.Build
 import android.os.Handler
@@ -96,7 +96,6 @@ import android.telephony.SubscriptionManager
 import android.telephony.TelephonyManager
 import android.telephony.data.EpsBearerQosSessionAttributes
 import android.util.ArraySet
-import android.util.DebugUtils.valueToString
 import androidx.test.InstrumentationRegistry
 import com.android.compatibility.common.util.SystemUtil.runShellCommand
 import com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity
@@ -112,27 +111,27 @@ import com.android.testutils.ConnectivityModuleTest
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
 import com.android.testutils.DevSdkIgnoreRunner
 import com.android.testutils.PollPacketReader
-import com.android.testutils.RecorderCallback.CallbackEntry.Available
-import com.android.testutils.RecorderCallback.CallbackEntry.BlockedStatus
-import com.android.testutils.RecorderCallback.CallbackEntry.CapabilitiesChanged
-import com.android.testutils.RecorderCallback.CallbackEntry.LinkPropertiesChanged
-import com.android.testutils.RecorderCallback.CallbackEntry.Losing
-import com.android.testutils.RecorderCallback.CallbackEntry.Lost
 import com.android.testutils.TestableNetworkAgent
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnAddKeepalivePacketFilter
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnAutomaticReconnectDisabled
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnBandwidthUpdateRequested
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnNetworkCreated
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnNetworkDestroyed
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnNetworkUnwanted
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnRegisterQosCallback
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnRemoveKeepalivePacketFilter
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnSaveAcceptUnvalidated
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnStartSocketKeepalive
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnStopSocketKeepalive
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnUnregisterQosCallback
-import com.android.testutils.TestableNetworkAgent.CallbackEntry.OnValidationStatus
+import com.android.testutils.TestableNetworkAgent.Event.OnAddKeepalivePacketFilter
+import com.android.testutils.TestableNetworkAgent.Event.OnAutomaticReconnectDisabled
+import com.android.testutils.TestableNetworkAgent.Event.OnBandwidthUpdateRequested
+import com.android.testutils.TestableNetworkAgent.Event.OnNetworkCreated
+import com.android.testutils.TestableNetworkAgent.Event.OnNetworkDestroyed
+import com.android.testutils.TestableNetworkAgent.Event.OnNetworkUnwanted
+import com.android.testutils.TestableNetworkAgent.Event.OnRegisterQosCallback
+import com.android.testutils.TestableNetworkAgent.Event.OnRemoveKeepalivePacketFilter
+import com.android.testutils.TestableNetworkAgent.Event.OnSaveAcceptUnvalidated
+import com.android.testutils.TestableNetworkAgent.Event.OnStartSocketKeepalive
+import com.android.testutils.TestableNetworkAgent.Event.OnStopSocketKeepalive
+import com.android.testutils.TestableNetworkAgent.Event.OnUnregisterQosCallback
+import com.android.testutils.TestableNetworkAgent.Event.OnValidationStatus
 import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.Available
+import com.android.testutils.TestableNetworkCallback.Event.BlockedStatus
+import com.android.testutils.TestableNetworkCallback.Event.CapabilitiesChanged
+import com.android.testutils.TestableNetworkCallback.Event.LinkPropertiesChanged
+import com.android.testutils.TestableNetworkCallback.Event.Losing
+import com.android.testutils.TestableNetworkCallback.Event.Lost
 import com.android.testutils.assertThrows
 import com.android.testutils.com.android.testutils.CarrierConfigRule
 import com.android.testutils.runAsShell
@@ -183,7 +182,6 @@ private const val DEFAULT_TIMEOUT_MS = 5000L
 private const val QUEUE_NETWORK_AGENT_EVENTS_IN_SYSTEM_SERVER =
     "queue_network_agent_events_in_system_server"
 
-
 // When waiting for a NetworkCallback to determine there was no timeout, waiting is the
 // only possible thing (the relevant handler is the one in the real ConnectivityService,
 // and then there is the Binder call), so have a short timeout for this as it will be
@@ -244,7 +242,6 @@ class NetworkAgentTest {
             QUEUE_NETWORK_AGENT_EVENTS_IN_SYSTEM_SERVER
         )
 
-
     @Before
     fun setUp() {
         instrumentation.getUiAutomation().adoptShellPermissionIdentity()
@@ -706,7 +703,9 @@ class NetworkAgentTest {
         val specifier = when {
             transports.size != 1 -> null
             TRANSPORT_ETHERNET in transports -> EthernetNetworkSpecifier("testInterface")
-            TRANSPORT_CELLULAR in transports -> TelephonyNetworkSpecifier(subId)
+            TRANSPORT_CELLULAR in transports -> {
+                TelephonyNetworkSpecifier.Builder().setSubscriptionId(subId).build()
+            }
             else -> null
         }
         val transportInfo = if (TRANSPORT_WIFI in transports && SdkLevel.isAtLeastV()) {
@@ -777,9 +776,9 @@ class NetworkAgentTest {
                     expectUidsPresent = false
             )
 
-            // The tools to set the carrier service package override do not exist before U,
+            // The tools to set the carrier service package override do not exist before U QPR1,
             // so there is no way to test the rest of this test on < U.
-            if (!SdkLevel.isAtLeastU()) return@tryTest
+            if (!carrierConfigRule.isSettingCarrierServicePackageSupported()) return@tryTest
             // Acquiring carrier privilege is necessary to override the carrier service package.
             val defaultSlotIndex = SubscriptionManager.getSlotIndex(defaultSubId)
             carrierConfigRule.acquireCarrierPrivilege(defaultSubId)
@@ -973,12 +972,11 @@ class NetworkAgentTest {
         // underlying networks, and because not congested, not roaming, and not suspended are the
         // default anyway. It's still useful as an extra check though.
         vpnNc = mCM.getNetworkCapabilities(agent.network!!)!!
-        for (cap in listOf(
-            NET_CAPABILITY_NOT_CONGESTED,
-            NET_CAPABILITY_NOT_ROAMING,
-            NET_CAPABILITY_NOT_SUSPENDED
+        for ((cap, capStr) in listOf(
+            NET_CAPABILITY_NOT_CONGESTED to "NET_CAPABILITY_NOT_CONGESTED",
+            NET_CAPABILITY_NOT_ROAMING to "NET_CAPABILITY_NOT_ROAMING",
+            NET_CAPABILITY_NOT_SUSPENDED to "NET_CAPABILITY_NOT_SUSPENDED"
         )) {
-            val capStr = valueToString(NetworkCapabilities::class.java, "NET_CAPABILITY_", cap)
             if (defaultNetworkCapabilities.hasCapability(cap) && !vpnNc.hasCapability(cap)) {
                 fail("$capStr not propagated from underlying: $defaultNetworkCapabilities")
             }
@@ -1267,7 +1265,7 @@ class NetworkAgentTest {
                 .addCapability(NET_CAPABILITY_NOT_VCN_MANAGED)
                 .build(),
             bestMatchingCb,
-            mHandlerThread.threadHandler
+            Handler(mHandlerThread.looper)
         )
 
         val (agent1, _) = createConnectedNetworkAgent(specifier = "AGENT-1")
@@ -1312,13 +1310,13 @@ class NetworkAgentTest {
     }
 
     private class TestableQosCallback : QosCallback() {
-        val history = ArrayTrackRecord<CallbackEntry>().newReadHead()
+        val history = ArrayTrackRecord<Event>().newReadHead()
 
-        sealed class CallbackEntry {
+        sealed class Event {
             data class OnQosSessionAvailable(val sess: QosSession, val attr: QosSessionAttributes) :
-                CallbackEntry()
-            data class OnQosSessionLost(val sess: QosSession) : CallbackEntry()
-            data class OnError(val ex: QosCallbackException) : CallbackEntry()
+                Event()
+            data class OnQosSessionLost(val sess: QosSession) : Event()
+            data class OnError(val ex: QosCallbackException) : Event()
         }
 
         override fun onQosSessionAvailable(sess: QosSession, attr: QosSessionAttributes) {
@@ -1333,13 +1331,13 @@ class NetworkAgentTest {
             history.add(OnError(ex))
         }
 
-        inline fun <reified T : CallbackEntry> expectCallback(): T {
+        inline fun <reified T : Event> expectCallback(): T {
             val foundCallback = history.poll(DEFAULT_TIMEOUT_MS)
             assertTrue(foundCallback is T, "Expected ${T::class} but found $foundCallback")
             return foundCallback
         }
 
-        inline fun <reified T : CallbackEntry> expectCallback(valid: (T) -> Boolean) {
+        inline fun <reified T : Event> expectCallback(valid: (T) -> Boolean) {
             val foundCallback = history.poll(DEFAULT_TIMEOUT_MS)
             assertTrue(foundCallback is T, "Expected ${T::class} but found $foundCallback")
             assertTrue(valid(foundCallback), "Unexpected callback : $foundCallback")
@@ -1394,6 +1392,25 @@ class NetworkAgentTest {
                 agent.expectCallback<OnRegisterQosCallback>().let {
                     callbackId = it.callbackId
                     assertTrue(it.filter.matchesProtocol(proto))
+                    if (Build.VERSION.SDK_INT_FULL > Build.VERSION_CODES_FULL.BAKLAVA) {
+                        // Available from SDK version 36.1 (25Q4)
+                        // This test is only validating QosFilter address match APIs can be called.
+                        // Detail functionality checks are executed on QosSocketFilterTest.
+                        // Verify the match of test socket's Local address, currently the test
+                        // socket binds to the loopback address.
+                        assertTrue(it.filter.matchesLocalPrefix(
+                            IpPrefix(InetAddress.getLoopbackAddress(), 128),
+                            0,
+                            65535
+                        ))
+                        // Since the test socket doesn't connect to the remote address, we expect
+                        // unmatched result.
+                        assertFalse(it.filter.matchesRemotePrefix(
+                            IpPrefix(InetAddress.getLoopbackAddress(), 128),
+                            0,
+                            65535
+                        ))
+                    }
                 }
 
                 assertFailsWith<QosCallbackRegistrationException>(
@@ -1589,14 +1606,22 @@ class NetworkAgentTest {
     private fun createEpsAttributes(qci: Int = 1): EpsBearerQosSessionAttributes {
         val remoteAddresses = ArrayList<InetSocketAddress>()
         remoteAddresses.add(InetSocketAddress(REMOTE_ADDRESS, 80))
-        return EpsBearerQosSessionAttributes(
-            qci,
-            2,
-            3,
-            4,
-            5,
-            remoteAddresses
-        )
+        return EpsBearerQosSessionAttributes::class.java
+            .getConstructor(
+                Int::class.java,
+                Long::class.java,
+                Long::class.java,
+                Long::class.java,
+                Long::class.java,
+                List::class.java
+            ).newInstance(
+                qci,
+                2,
+                3,
+                4,
+                5,
+                remoteAddresses
+            )
     }
 
     fun sendAndExpectUdpPacket(
@@ -2016,4 +2041,42 @@ class NetworkAgentTest {
         val agent = createNetworkAgent()
         agent.unregister()
     }
+
+    fun getBinderProxyCount(): Int {
+        // Call gc before checking binder proxy count.
+        System.gc()
+        System.runFinalization()
+        System.gc()
+
+        // Extracts the number of binder proxy objects from the `dumpsys meminfo` output.
+        // Expects a line in the format: "Local Binders: 13 Proxy Binders: 30".
+        val dumpOutput = ("dumpsys meminfo " + Process.myPid()).execute()
+        val line = dumpOutput.split("\n").firstOrNull { it.contains("Proxy Binders:") }
+        assertNotNull(line, "Dumpsys does not contain \"Proxy Binders:\", output: $dumpOutput")
+
+        val matched = Regex("Proxy Binders:\\s*(\\d+)").find(line)
+        assertNotNull(matched, "Failed to parse, line: $line")
+
+        return matched.groupValues[1].toInt()
+    }
+
+    @Test
+    fun testRegisterUnregisterDoesNotLeakBinderProxy() {
+        val startCount = getBinderProxyCount()
+
+        for (i in 1..30) {
+            val agent = createNetworkAgent(realContext)
+            agent.register()
+            agent.unregister()
+        }
+
+        val deadline = SystemClock.elapsedRealtime() + DEFAULT_TIMEOUT_MS
+        var endCount: Int
+        do {
+            endCount = getBinderProxyCount()
+            if (endCount - startCount < 10) return
+            SystemClock.sleep(50 /* ms */)
+        } while (SystemClock.elapsedRealtime() < deadline)
+        fail("Binder Proxy is leaked: $startCount -> $endCount")
+    }
 }
diff --git a/tests/cts/net/src/android/net/cts/NetworkReservationTest.kt b/tests/cts/net/src/android/net/cts/NetworkReservationTest.kt
index f43b92799d..cc4aaf51fa 100644
--- a/tests/cts/net/src/android/net/cts/NetworkReservationTest.kt
+++ b/tests/cts/net/src/android/net/cts/NetworkReservationTest.kt
@@ -47,9 +47,9 @@ import com.android.compatibility.common.util.SystemUtil.runShellCommandOrThrow
 import com.android.testutils.ConnectivityModuleTest
 import com.android.testutils.DevSdkIgnoreRule
 import com.android.testutils.DevSdkIgnoreRunner
-import com.android.testutils.RecorderCallback.CallbackEntry.Reserved
-import com.android.testutils.RecorderCallback.CallbackEntry.Unavailable
 import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.Reserved
+import com.android.testutils.TestableNetworkCallback.Event.Unavailable
 import com.android.testutils.TestableNetworkOfferCallback
 import com.android.testutils.pollingCheck
 import com.android.testutils.runAsShell
@@ -83,7 +83,7 @@ private val ETHERNET_REQUEST = NetworkRequest.Builder()
         .addTransportType(TRANSPORT_TEST)
         .removeCapability(NET_CAPABILITY_TRUSTED)
         .build()
-private const val TIMEOUT_MS = 5_000L
+private const val TIMEOUT_MS = 30_000L
 private const val NO_CB_TIMEOUT_MS = 200L
 
 // TODO: integrate with CSNetworkReservationTest and move to common tests.
diff --git a/tests/cts/net/src/android/net/cts/NetworkScoreTest.kt b/tests/cts/net/src/android/net/cts/NetworkScoreTest.kt
index e660b1e679..a85e478daf 100644
--- a/tests/cts/net/src/android/net/cts/NetworkScoreTest.kt
+++ b/tests/cts/net/src/android/net/cts/NetworkScoreTest.kt
@@ -35,8 +35,8 @@ import androidx.test.InstrumentationRegistry
 import com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
 import com.android.testutils.DevSdkIgnoreRunner
-import com.android.testutils.RecorderCallback.CallbackEntry
 import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event
 import com.android.testutils.TestableNetworkCallback.HasNetwork
 import org.junit.After
 import org.junit.Before
@@ -91,7 +91,7 @@ class NetworkScoreTest {
         agentsToCleanUp.forEach {
             Log.i(TAG, "Unregister agent for net ${it.network}")
             it.unregister()
-            agentCleanUpCb.eventuallyExpect<CallbackEntry.Lost> { cb -> cb.network == it.network }
+            agentCleanUpCb.eventuallyExpect<Event.Lost> { cb -> cb.network == it.network }
         }
         mCm.unregisterNetworkCallback(agentCleanUpCb)
 
diff --git a/tests/cts/net/src/android/net/cts/NetworkStatsBinderTest.java b/tests/cts/net/src/android/net/cts/NetworkStatsBinderTest.java
index 65daf575ff..b2e2554510 100644
--- a/tests/cts/net/src/android/net/cts/NetworkStatsBinderTest.java
+++ b/tests/cts/net/src/android/net/cts/NetworkStatsBinderTest.java
@@ -36,7 +36,7 @@ import android.os.RemoteException;
 
 import androidx.test.InstrumentationRegistry;
 
-import com.android.internal.util.CollectionUtils;
+import com.android.net.module.util.CollectionUtils;
 import com.android.testutils.ConnectivityModuleTest;
 import com.android.testutils.DevSdkIgnoreRule;
 import com.android.testutils.DevSdkIgnoreRunner;
@@ -67,7 +67,7 @@ public class NetworkStatsBinderTest {
     private int getFirstAppUidThat(@NonNull Predicate<Integer> predicate) {
         PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
         List<PackageInfo> apps = pm.getInstalledPackages(0 /* flags */);
-        final PackageInfo match = CollectionUtils.find(apps,
+        final PackageInfo match = CollectionUtils.findFirst(apps,
                 it -> it.applicationInfo != null && predicate.test(it.applicationInfo.uid));
         if (match != null) return match.applicationInfo.uid;
         return INVALID_UID;
diff --git a/tests/cts/net/src/android/net/cts/NetworkStatsManagerTest.java b/tests/cts/net/src/android/net/cts/NetworkStatsManagerTest.java
index eb2dbf7a98..03e14ab064 100644
--- a/tests/cts/net/src/android/net/cts/NetworkStatsManagerTest.java
+++ b/tests/cts/net/src/android/net/cts/NetworkStatsManagerTest.java
@@ -33,8 +33,6 @@ import static android.net.netstats.NetworkStatsDataMigrationUtils.PREFIX_UID;
 import static android.net.netstats.NetworkStatsDataMigrationUtils.PREFIX_UID_TAG;
 import static android.net.netstats.NetworkStatsDataMigrationUtils.PREFIX_XT;
 
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -79,8 +77,8 @@ import com.android.testutils.ConnectivityDiagnosticsCollector;
 import com.android.testutils.ConnectivityModuleTest;
 import com.android.testutils.DevSdkIgnoreRule;
 import com.android.testutils.DevSdkIgnoreRunner;
-import com.android.testutils.RecorderCallback.CallbackEntry;
 import com.android.testutils.TestableNetworkCallback;
+import com.android.testutils.TestableNetworkCallback.Event;
 
 import org.junit.After;
 import org.junit.Before;
@@ -194,7 +192,7 @@ public class NetworkStatsManagerTest {
                             networkCallbackRule.requestNetwork(buildRequestForTransport(
                                     NetworkCapabilities.TRANSPORT_WIFI),
                                     mRequestNetworkCb, TIMEOUT_MILLIS);
-                            return mRequestNetworkCb.expect(CallbackEntry.AVAILABLE,
+                            return mRequestNetworkCb.expect(Event.AVAILABLE,
                                     "Wifi network not available. "
                                             + "Please ensure the device has working wifi."
                             ).getNetwork();
@@ -216,7 +214,7 @@ public class NetworkStatsManagerTest {
                             networkCallbackRule.requestNetwork(buildRequestForTransport(
                                             NetworkCapabilities.TRANSPORT_CELLULAR),
                                     mRequestNetworkCb, TIMEOUT_MILLIS);
-                            return mRequestNetworkCb.expect(CallbackEntry.AVAILABLE,
+                            return mRequestNetworkCb.expect(Event.AVAILABLE,
                                     "Cell network not available. "
                                             + "Please ensure the device has working mobile data."
                             ).getNetwork();
@@ -368,7 +366,7 @@ public class NetworkStatsManagerTest {
         // interested attributes are not mutable, and not expected to be
         // changed during the test.
         final NetworkCapabilities caps = networkInterface.mRequestNetworkCb.expect(
-                CallbackEntry.NETWORK_CAPS_UPDATED, network).getCaps();
+                Event.NETWORK_CAPS_UPDATED, network).getCaps();
         networkInterface.setMetered(!caps.hasCapability(
                 NetworkCapabilities.NET_CAPABILITY_NOT_METERED));
         networkInterface.setRoaming(!caps.hasCapability(
@@ -915,7 +913,7 @@ public class NetworkStatsManagerTest {
         }
     }
 
-    @DevSdkIgnoreRule.IgnoreUpTo(SC_V2)
+    @DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
     @Test
     public void testDataMigrationUtils() throws Exception {
         final List<String> prefixes = List.of(PREFIX_UID, PREFIX_XT, PREFIX_UID_TAG);
diff --git a/tests/cts/net/src/android/net/cts/NetworkValidationTest.kt b/tests/cts/net/src/android/net/cts/NetworkValidationTest.kt
index aad072c643..8db6e28b12 100644
--- a/tests/cts/net/src/android/net/cts/NetworkValidationTest.kt
+++ b/tests/cts/net/src/android/net/cts/NetworkValidationTest.kt
@@ -35,6 +35,7 @@ import android.net.dhcp.DhcpPacket.DHCP_MESSAGE_TYPE
 import android.net.dhcp.DhcpPacket.DHCP_MESSAGE_TYPE_DISCOVER
 import android.net.dhcp.DhcpPacket.DHCP_MESSAGE_TYPE_REQUEST
 import android.net.dhcp.DhcpRequestPacket
+import android.os.Handler
 import android.os.HandlerThread
 import android.platform.test.annotations.AppModeFull
 import androidx.test.platform.app.InstrumentationRegistry
@@ -45,23 +46,24 @@ import com.android.net.module.util.NetworkStackConstants.IPV4_ADDR_ANY
 import com.android.testutils.AutoCloseTestInterfaceRule
 import com.android.testutils.DhcpClientPacketFilter
 import com.android.testutils.DhcpOptionFilter
-import com.android.testutils.RecorderCallback.CallbackEntry
 import com.android.testutils.PollPacketReader
 import com.android.testutils.TestHttpServer
 import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.CapabilitiesChanged
+import com.android.testutils.TestableNetworkCallback.Event.LinkPropertiesChanged
 import com.android.testutils.runAsShell
 import fi.iki.elonen.NanoHTTPD.Response.Status
+import java.net.Inet4Address
+import kotlin.test.assertEquals
+import kotlin.test.assertNotNull
+import kotlin.test.assertTrue
+import kotlin.test.fail
 import org.junit.After
 import org.junit.Assume.assumeFalse
 import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
 import org.junit.runner.RunWith
-import java.net.Inet4Address
-import kotlin.test.assertEquals
-import kotlin.test.assertNotNull
-import kotlin.test.assertTrue
-import kotlin.test.fail
 
 private const val MAX_PACKET_LENGTH = 1500
 private const val TEST_TIMEOUT_MS = 10_000L
@@ -92,6 +94,7 @@ class NetworkValidationTest {
             .addTransportType(TRANSPORT_TEST).build()
     private val ethRequestCb = TestableNetworkCallback()
 
+    private var readerHandler: Handler? = null
     private lateinit var iface: TestNetworkInterface
     private lateinit var reader: PollPacketReader
     private lateinit var capportUrl: Uri
@@ -118,8 +121,9 @@ class NetworkValidationTest {
         iface = testInterfaceRule.createTapInterface()
 
         handlerThread.start()
+        readerHandler = Handler(handlerThread.looper)
         reader = PollPacketReader(
-                handlerThread.threadHandler,
+                readerHandler,
                 iface.fileDescriptor.fileDescriptor,
                 MAX_PACKET_LENGTH)
         reader.startAsyncForTest()
@@ -139,7 +143,7 @@ class NetworkValidationTest {
         runAsShell(NETWORK_SETTINGS) { eth.setIncludeTestInterfaces(false) }
 
         httpServer.stop()
-        handlerThread.threadHandler.post { reader.stop() }
+        readerHandler?.post { reader.stop() }
         handlerThread.quitSafely()
         handlerThread.join()
     }
@@ -177,10 +181,11 @@ class NetworkValidationTest {
             cm.registerNetworkCallback(ethRequest, testCb)
 
             try {
-                val ncCb = testCb.eventuallyExpect<CallbackEntry.CapabilitiesChanged> {
+                val mark = testCb.mark
+                val ncCb = testCb.eventuallyExpect<CapabilitiesChanged>(from = mark) {
                     it.caps.hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL)
                 }
-                testCb.eventuallyExpect<CallbackEntry.LinkPropertiesChanged> {
+                testCb.eventuallyExpect<LinkPropertiesChanged>(from = mark) {
                     it.network == ncCb.network && it.lp.captivePortalData != null
                 }.lp
             } finally {
diff --git a/tests/cts/net/src/android/net/cts/NsdManagerDownstreamTetheringTest.kt b/tests/cts/net/src/android/net/cts/NsdManagerDownstreamTetheringTest.kt
index 19738994c7..97556f54a2 100644
--- a/tests/cts/net/src/android/net/cts/NsdManagerDownstreamTetheringTest.kt
+++ b/tests/cts/net/src/android/net/cts/NsdManagerDownstreamTetheringTest.kt
@@ -20,7 +20,6 @@ import android.net.LinkAddress
 import android.net.TetheringManager.CONNECTIVITY_SCOPE_LOCAL
 import android.net.TetheringManager.TETHERING_ETHERNET
 import android.net.TetheringManager.TetheringRequest
-import android.net.cts.util.EthernetTestInterface
 import android.net.nsd.NsdManager
 import android.os.Build
 import android.os.Handler
@@ -31,6 +30,7 @@ import com.android.testutils.AutoCloseTestInterfaceRule
 import com.android.testutils.ConnectivityModuleTest
 import com.android.testutils.DevSdkIgnoreRule
 import com.android.testutils.DevSdkIgnoreRunner
+import com.android.testutils.EthernetTestInterface
 import com.android.testutils.NsdDiscoveryRecord
 import com.android.testutils.pollForQuery
 import com.android.testutils.tryTest
@@ -104,7 +104,7 @@ class NsdManagerDownstreamTetheringTest : EthernetTetheringTestBase() {
             nsdManager.discoverServices(serviceType, NsdManager.PROTOCOL_DNS_SD, discoveryRecord)
             discoveryRecord.expectCallback<NsdDiscoveryRecord.DiscoveryEvent.DiscoveryStarted>()
             assertNotNull(downstreamReader.pollForQuery("$serviceType.local", 12 /* type PTR */))
-        } cleanupStep {
+        } cleanup {
             nsdManager.stopServiceDiscovery(discoveryRecord)
             discoveryRecord.expectCallback<NsdDiscoveryRecord.DiscoveryEvent.DiscoveryStopped>()
         }
@@ -137,7 +137,7 @@ class NsdManagerDownstreamTetheringTest : EthernetTetheringTestBase() {
             val downstreamReader = downstreamIface.packetReader
             assertNotNull(downstreamReader.pollForQuery("$serviceType.local", 12 /* type PTR */))
             // TODO: Add another test to check packet reply can trigger serviceFound.
-        } cleanupStep {
+        } cleanup {
             nsdManager.stopServiceDiscovery(discoveryRecord)
             discoveryRecord.expectCallback<NsdDiscoveryRecord.DiscoveryEvent.DiscoveryStopped>()
         }
diff --git a/tests/cts/net/src/android/net/cts/NsdManagerTest.kt b/tests/cts/net/src/android/net/cts/NsdManagerTest.kt
index ee31f1af3a..db3c4837f4 100644
--- a/tests/cts/net/src/android/net/cts/NsdManagerTest.kt
+++ b/tests/cts/net/src/android/net/cts/NsdManagerTest.kt
@@ -92,8 +92,8 @@ import com.android.testutils.NsdServiceInfoCallbackRecord.ServiceInfoCallbackEve
 import com.android.testutils.NsdServiceInfoCallbackRecord.ServiceInfoCallbackEvent.ServiceUpdatedLost
 import com.android.testutils.NsdServiceInfoCallbackRecord.ServiceInfoCallbackEvent.UnregisterCallbackSucceeded
 import com.android.testutils.PollPacketReader
-import com.android.testutils.RecorderCallback.CallbackEntry.CapabilitiesChanged
-import com.android.testutils.RecorderCallback.CallbackEntry.LinkPropertiesChanged
+import com.android.testutils.TestableNetworkCallback.Event.CapabilitiesChanged
+import com.android.testutils.TestableNetworkCallback.Event.LinkPropertiesChanged
 import com.android.testutils.TestDnsPacket
 import com.android.testutils.TestableNetworkAgent
 import com.android.testutils.TestableNetworkCallback
diff --git a/tests/cts/net/src/android/net/cts/PacProxyManagerTest.java b/tests/cts/net/src/android/net/cts/PacProxyManagerTest.java
index b462f71434..0667b235b8 100644
--- a/tests/cts/net/src/android/net/cts/PacProxyManagerTest.java
+++ b/tests/cts/net/src/android/net/cts/PacProxyManagerTest.java
@@ -23,7 +23,6 @@ import static com.android.testutils.TestPermissionUtil.runAsShell;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
-import static org.junit.Assume.assumeTrue;
 
 import android.app.Instrumentation;
 import android.content.BroadcastReceiver;
@@ -45,7 +44,6 @@ import android.util.Range;
 import androidx.test.InstrumentationRegistry;
 
 import com.android.compatibility.common.util.RequiredFeatureRule;
-
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo;
 import com.android.testutils.DevSdkIgnoreRunner;
 import com.android.testutils.TestHttpServer;
@@ -133,8 +131,10 @@ public final class PacProxyManagerTest {
 
         @Override
         public void onReceive(Context context, Intent intent) {
-            final ProxyInfo proxy = (ProxyInfo) intent.getExtra(Proxy.EXTRA_PROXY_INFO,
-                    ProxyInfo.buildPacProxy(Uri.EMPTY));
+            ProxyInfo proxy = intent.getParcelableExtra("android.intent.extra.PROXY_INFO");
+            if (proxy == null) {
+                proxy = ProxyInfo.buildPacProxy(Uri.EMPTY);
+            }
             // ProxyTracker sends sticky broadcast which will receive the last broadcast while
             // register the intent receiver. That is, if system never receives the intent then
             // it won't receive an intent when register the receiver. How many intents will be
diff --git a/tests/cts/net/src/android/net/cts/RateLimitTest.java b/tests/cts/net/src/android/net/cts/RateLimitTest.java
index 36b98fc570..bd1698bd8a 100644
--- a/tests/cts/net/src/android/net/cts/RateLimitTest.java
+++ b/tests/cts/net/src/android/net/cts/RateLimitTest.java
@@ -24,7 +24,6 @@ import static androidx.test.InstrumentationRegistry.getContext;
 
 import static com.android.net.module.util.NetworkStackConstants.ETHER_MTU;
 import static com.android.net.module.util.NetworkStackConstants.IPV4_ADDR_ANY;
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
 import static com.android.testutils.TestPermissionUtil.runAsShell;
 
 import static org.junit.Assert.assertEquals;
@@ -48,6 +47,7 @@ import android.net.RouteInfo;
 import android.net.TestNetworkInterface;
 import android.net.TestNetworkManager;
 import android.net.TestNetworkSpecifier;
+import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.SystemClock;
@@ -81,7 +81,7 @@ import java.util.stream.Collectors;
 
 @AppModeFull(reason = "Instant apps cannot access /dev/tun, so createTunInterface fails")
 @RunWith(DevSdkIgnoreRunner.class)
-@DevSdkIgnoreRule.IgnoreUpTo(SC_V2)
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 public class RateLimitTest {
     // cannot be final as it gets initialized inside ensureKernelConfigLoaded().
     private static HashSet<String> sKernelConfig;
diff --git a/tests/cts/net/src/android/net/cts/SSLCertificateSocketFactoryTest.java b/tests/cts/net/src/android/net/cts/SSLCertificateSocketFactoryTest.java
deleted file mode 100644
index 1a780a7eb5..0000000000
--- a/tests/cts/net/src/android/net/cts/SSLCertificateSocketFactoryTest.java
+++ /dev/null
@@ -1,348 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.net.cts;
-
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-import android.net.SSLCertificateSocketFactory;
-import android.platform.test.annotations.AppModeFull;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.net.SocketAddress;
-import java.net.UnknownHostException;
-import java.util.Arrays;
-import java.util.List;
-import java.util.stream.Collectors;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSession;
-import libcore.javax.net.ssl.SSLConfigurationAsserts;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class SSLCertificateSocketFactoryTest {
-    // TEST_HOST should point to a web server with a valid TLS certificate.
-    private static final String TEST_HOST = "www.google.com";
-    private static final int HTTPS_PORT = 443;
-    private HostnameVerifier mDefaultVerifier;
-    private SSLCertificateSocketFactory mSocketFactory;
-    private InetAddress mLocalAddress;
-    // InetAddress obtained by resolving TEST_HOST.
-    private InetAddress mTestHostAddress;
-    // SocketAddress combining mTestHostAddress and HTTPS_PORT.
-    private List<SocketAddress> mTestSocketAddresses;
-
-    @Before
-    public void setUp() {
-        // Expected state before each test method is that
-        // HttpsURLConnection.getDefaultHostnameVerifier() will return the system default.
-        mDefaultVerifier = HttpsURLConnection.getDefaultHostnameVerifier();
-        mSocketFactory = (SSLCertificateSocketFactory)
-            SSLCertificateSocketFactory.getDefault(1000 /* handshakeTimeoutMillis */);
-        assertNotNull(mSocketFactory);
-        InetAddress[] addresses;
-        try {
-            addresses = InetAddress.getAllByName(TEST_HOST);
-        } catch (UnknownHostException uhe) {
-            throw new AssertionError(
-                "Unable to test SSLCertificateSocketFactory: cannot resolve " + TEST_HOST, uhe);
-        }
-
-        mTestSocketAddresses = Arrays.stream(addresses)
-            .map(addr -> new InetSocketAddress(addr, HTTPS_PORT))
-            .collect(Collectors.toList());
-
-        // Find the local and remote IP addresses which will be used to connect to TEST_HOST.
-        try {
-            Socket testSocket = new Socket(TEST_HOST, HTTPS_PORT);
-            mLocalAddress = testSocket.getLocalAddress();
-            mTestHostAddress = testSocket.getInetAddress();
-            testSocket.close();
-        } catch (IOException ioe) {
-            throw new AssertionError(""
-                + "Unable to test SSLCertificateSocketFactory: cannot connect to "
-                + TEST_HOST, ioe);
-        }
-    }
-
-    // Restore the system default hostname verifier after each test.
-    @After
-    public void restoreDefaultHostnameVerifier() {
-        HttpsURLConnection.setDefaultHostnameVerifier(mDefaultVerifier);
-    }
-
-    @Test
-    public void testDefaultConfiguration() throws Exception {
-        SSLConfigurationAsserts.assertSSLSocketFactoryDefaultConfiguration(mSocketFactory);
-    }
-
-    @Test
-    public void testAccessProperties() {
-        mSocketFactory.getSupportedCipherSuites();
-        mSocketFactory.getDefaultCipherSuites();
-    }
-
-    /**
-     * Tests the {@code createSocket()} cases which are expected to fail with {@code IOException}.
-     */
-    @Test
-    @AppModeFull(reason = "Socket cannot bind in instant app mode")
-    public void createSocket_io_error_expected() {
-        // Connect to the localhost HTTPS port. Should result in connection refused IOException
-        // because no service should be listening on that port.
-        InetAddress localhostAddress = InetAddress.getLoopbackAddress();
-        try {
-            mSocketFactory.createSocket(localhostAddress, HTTPS_PORT);
-            fail();
-        } catch (IOException e) {
-            // expected
-        }
-
-        // Same, but also binding to a local address.
-        try {
-            mSocketFactory.createSocket(localhostAddress, HTTPS_PORT, localhostAddress, 0);
-            fail();
-        } catch (IOException e) {
-            // expected
-        }
-
-        // Same, wrapping an existing plain socket which is in an unconnected state.
-        try {
-            Socket socket = new Socket();
-            mSocketFactory.createSocket(socket, "localhost", HTTPS_PORT, true);
-            fail();
-        } catch (IOException e) {
-            // expected
-        }
-    }
-
-    /**
-     * Tests hostname verification for
-     * {@link SSLCertificateSocketFactory#createSocket(String, int)}.
-     *
-     * <p>This method should return a socket which is fully connected (i.e. TLS handshake complete)
-     * and whose peer TLS certificate has been verified to have the correct hostname.
-     *
-     * <p>{@link SSLCertificateSocketFactory} is documented to verify hostnames using
-     * the {@link HostnameVerifier} returned by
-     * {@link HttpsURLConnection#getDefaultHostnameVerifier}, so this test connects twice,
-     * once with the system default {@link HostnameVerifier} which is expected to succeed,
-     * and once after installing a {@link NegativeHostnameVerifier} which will cause
-     * {@link SSLCertificateSocketFactory#verifyHostname} to throw a
-     * {@link SSLPeerUnverifiedException}.
-     *
-     * <p>These tests only test the hostname verification logic in SSLCertificateSocketFactory,
-     * other TLS failure modes and the default HostnameVerifier are tested elsewhere, see
-     * {@link com.squareup.okhttp.internal.tls.HostnameVerifierTest} and
-     * https://android.googlesource.com/platform/external/boringssl/+/refs/heads/master/src/ssl/test
-     *
-     * <p>Tests the following behaviour:-
-     * <ul>
-     * <li>TEST_SERVER is available and has a valid TLS certificate
-     * <li>{@code createSocket()} verifies the remote hostname is correct using
-     *     {@link HttpsURLConnection#getDefaultHostnameVerifier}
-     * <li>{@link SSLPeerUnverifiedException} is thrown when the remote hostname is invalid
-     * </ul>
-     *
-     * <p>See also http://b/2807618.
-     */
-    @Test
-    public void createSocket_simple_with_hostname_verification() throws Exception {
-        Socket socket = mSocketFactory.createSocket(TEST_HOST, HTTPS_PORT);
-        assertConnectedSocket(socket);
-        socket.close();
-
-        HttpsURLConnection.setDefaultHostnameVerifier(new NegativeHostnameVerifier());
-        try {
-            mSocketFactory.createSocket(TEST_HOST, HTTPS_PORT);
-            fail();
-        } catch (SSLPeerUnverifiedException expected) {
-            // expected
-        }
-    }
-
-    /**
-     * Tests hostname verification for
-     * {@link SSLCertificateSocketFactory#createSocket(Socket, String, int, boolean)}.
-     *
-     * <p>This method should return a socket which is fully connected (i.e. TLS handshake complete)
-     * and whose peer TLS certificate has been verified to have the correct hostname.
-     *
-     * <p>The TLS socket returned is wrapped around the plain socket passed into
-     * {@code createSocket()}.
-     *
-     * <p>See {@link #createSocket_simple_with_hostname_verification()} for test methodology.
-     */
-    @Test
-    public void createSocket_wrapped_with_hostname_verification() throws Exception {
-        Socket underlying = new Socket(TEST_HOST, HTTPS_PORT);
-        Socket socket = mSocketFactory.createSocket(underlying, TEST_HOST, HTTPS_PORT, true);
-        assertConnectedSocket(socket);
-        socket.close();
-
-        HttpsURLConnection.setDefaultHostnameVerifier(new NegativeHostnameVerifier());
-        try {
-            underlying = new Socket(TEST_HOST, HTTPS_PORT);
-            mSocketFactory.createSocket(underlying, TEST_HOST, HTTPS_PORT, true);
-            fail();
-        } catch (SSLPeerUnverifiedException expected) {
-            // expected
-        }
-    }
-
-    /**
-     * Tests hostname verification for
-     * {@link SSLCertificateSocketFactory#createSocket(String, int, InetAddress, int)}.
-     *
-     * <p>This method should return a socket which is fully connected (i.e. TLS handshake complete)
-     * and whose peer TLS certificate has been verified to have the correct hostname.
-     *
-     * <p>The TLS socket returned is also bound to the local address determined in {@link #setUp} to
-     * be used for connections to TEST_HOST, and a wildcard port.
-     *
-     * <p>See {@link #createSocket_simple_with_hostname_verification()} for test methodology.
-     */
-    @Test
-    @AppModeFull(reason = "Socket cannot bind in instant app mode")
-    public void createSocket_bound_with_hostname_verification() throws Exception {
-        Socket socket = mSocketFactory.createSocket(TEST_HOST, HTTPS_PORT, mLocalAddress, 0);
-        assertConnectedSocket(socket);
-        socket.close();
-
-        HttpsURLConnection.setDefaultHostnameVerifier(new NegativeHostnameVerifier());
-        try {
-            mSocketFactory.createSocket(TEST_HOST, HTTPS_PORT, mLocalAddress, 0);
-            fail();
-        } catch (SSLPeerUnverifiedException expected) {
-            // expected
-        }
-    }
-
-    /**
-     * Tests hostname verification for
-     * {@link SSLCertificateSocketFactory#createSocket(InetAddress, int)}.
-     *
-     * <p>This method should return a socket which the documentation describes as "unconnected",
-     * which actually means that the socket is fully connected at the TCP layer but TLS handshaking
-     * and hostname verification have not yet taken place.
-     *
-     * <p>Behaviour is tested by installing a {@link NegativeHostnameVerifier} and by calling
-     * {@link #assertConnectedSocket} to ensure TLS handshaking but no hostname verification takes
-     * place.  Next, {@link SSLCertificateSocketFactory#verifyHostname} is called to ensure
-     * that hostname verification is using the {@link HostnameVerifier} returned by
-     * {@link HttpsURLConnection#getDefaultHostnameVerifier} as documented.
-     *
-     * <p>Tests the following behaviour:-
-     * <ul>
-     * <li>TEST_SERVER is available and has a valid TLS certificate
-     * <li>{@code createSocket()} does not verify the remote hostname
-     * <li>Calling {@link SSLCertificateSocketFactory#verifyHostname} on the returned socket
-     *     throws {@link SSLPeerUnverifiedException} if the remote hostname is invalid
-     * </ul>
-     */
-    @Test
-    public void createSocket_simple_no_hostname_verification() throws Exception{
-        HttpsURLConnection.setDefaultHostnameVerifier(new NegativeHostnameVerifier());
-        Socket socket = mSocketFactory.createSocket(mTestHostAddress, HTTPS_PORT);
-        // Need to provide the expected hostname here or the TLS handshake will
-        // be unable to supply SNI to the remote host.
-        mSocketFactory.setHostname(socket, TEST_HOST);
-        assertConnectedSocket(socket);
-        try {
-          SSLCertificateSocketFactory.verifyHostname(socket, TEST_HOST);
-          fail();
-        } catch (SSLPeerUnverifiedException expected) {
-            // expected
-        }
-        HttpsURLConnection.setDefaultHostnameVerifier(mDefaultVerifier);
-        SSLCertificateSocketFactory.verifyHostname(socket, TEST_HOST);
-        socket.close();
-    }
-
-    /**
-     * Tests hostname verification for
-     * {@link SSLCertificateSocketFactory#createSocket(InetAddress, int, InetAddress, int)}.
-     *
-     * <p>This method should return a socket which the documentation describes as "unconnected",
-     * which actually means that the socket is fully connected at the TCP layer but TLS handshaking
-     * and hostname verification have not yet taken place.
-     *
-     * <p>The TLS socket returned is also bound to the local address determined in {@link #setUp} to
-     * be used for connections to TEST_HOST, and a wildcard port.
-     *
-     * <p>See {@link #createSocket_simple_no_hostname_verification()} for test methodology.
-     */
-    @Test
-    @AppModeFull(reason = "Socket cannot bind in instant app mode")
-    public void createSocket_bound_no_hostname_verification() throws Exception{
-        HttpsURLConnection.setDefaultHostnameVerifier(new NegativeHostnameVerifier());
-        Socket socket =
-            mSocketFactory.createSocket(mTestHostAddress, HTTPS_PORT, mLocalAddress, 0);
-        // Need to provide the expected hostname here or the TLS handshake will
-        // be unable to supply SNI to the peer.
-        mSocketFactory.setHostname(socket, TEST_HOST);
-        assertConnectedSocket(socket);
-        try {
-          SSLCertificateSocketFactory.verifyHostname(socket, TEST_HOST);
-          fail();
-        } catch (SSLPeerUnverifiedException expected) {
-            // expected
-        }
-        HttpsURLConnection.setDefaultHostnameVerifier(mDefaultVerifier);
-        SSLCertificateSocketFactory.verifyHostname(socket, TEST_HOST);
-        socket.close();
-    }
-
-    /**
-     * Asserts a socket is fully connected to the expected peer.
-     *
-     * <p>For the variants of createSocket which verify the remote hostname,
-     * {@code socket} should already be fully connected.
-     *
-     * <p>For the non-verifying variants, retrieving the input stream will trigger a TLS handshake
-     * and so may throw an exception, for example if the peer's certificate is invalid.
-     *
-     * <p>Does no hostname verification.
-     */
-    private void assertConnectedSocket(Socket socket) throws Exception {
-        assertNotNull(socket);
-        assertTrue(socket.isConnected());
-        assertNotNull(socket.getInputStream());
-        assertNotNull(socket.getOutputStream());
-        assertTrue(mTestSocketAddresses.contains(socket.getRemoteSocketAddress()));
-    }
-
-    /**
-     * A HostnameVerifier which always returns false to simulate a server returning a
-     * certificate which does not match the expected hostname.
-     */
-    private static class NegativeHostnameVerifier implements HostnameVerifier {
-        @Override
-        public boolean verify(String hostname, SSLSession sslSession) {
-            return false;
-        }
-    }
-}
diff --git a/tests/cts/net/util/java/android/net/cts/util/CtsNetUtils.java b/tests/cts/net/util/java/android/net/cts/util/CtsNetUtils.java
index 173d13f6d5..1d8e66d77f 100644
--- a/tests/cts/net/util/java/android/net/cts/util/CtsNetUtils.java
+++ b/tests/cts/net/util/java/android/net/cts/util/CtsNetUtils.java
@@ -18,14 +18,18 @@ package android.net.cts.util;
 
 import static android.Manifest.permission.MODIFY_PHONE_STATE;
 import static android.Manifest.permission.NETWORK_SETTINGS;
+import static android.content.pm.PackageManager.FEATURE_TELEPHONY;
+import static android.content.pm.PackageManager.FEATURE_WIFI;
 import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
 import static android.net.NetworkCapabilities.TRANSPORT_CELLULAR;
 import static android.net.NetworkCapabilities.TRANSPORT_TEST;
+import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
 
 import static com.android.compatibility.common.util.PropertyUtil.getFirstApiLevel;
 import static com.android.testutils.TestPermissionUtil.runAsShell;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -59,6 +63,7 @@ import android.system.OsConstants;
 import android.telephony.SubscriptionManager;
 import android.telephony.TelephonyManager;
 import android.text.TextUtils;
+import android.util.ArraySet;
 import android.util.Log;
 
 import androidx.annotation.Nullable;
@@ -69,6 +74,8 @@ import com.android.compatibility.common.util.SystemUtil;
 import com.android.modules.utils.build.SdkLevel;
 import com.android.net.module.util.ConnectivitySettingsUtils;
 import com.android.testutils.ConnectUtil;
+import com.android.testutils.TestableNetworkCallback;
+import com.android.testutils.TestableNetworkCallback.Event;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -76,11 +83,14 @@ import java.io.OutputStream;
 import java.net.InetSocketAddress;
 import java.net.Socket;
 import java.util.ArrayList;
+import java.util.List;
 import java.util.Objects;
+import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
+import java.util.function.Predicate;
 
 public final class CtsNetUtils {
     private static final String TAG = CtsNetUtils.class.getSimpleName();
@@ -162,6 +172,7 @@ public final class CtsNetUtils {
                 new NetworkRequest.Builder()
                         .clearCapabilities()
                         .addTransportType(TRANSPORT_TEST)
+                        .addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED)
                         .setNetworkSpecifier(ifname)
                         .build();
 
@@ -512,12 +523,15 @@ public final class CtsNetUtils {
         final NetworkCallback callback = new NetworkCallback() {
             @Override
             public void onLinkPropertiesChanged(Network n, LinkProperties lp) {
-                Log.i(TAG, "Link properties of network " + n + " changed to " + lp);
+                Log.i(TAG,  "Waiting for the private DNS server to change to " + server + " on "
+                        + network + ": Link properties of network " + n
+                        + " changed with private DNS server " + lp.getPrivateDnsServerName()
+                        + ", full LinkProperties: " + lp);
                 if (requiresValidatedServer && lp.getValidatedPrivateDnsServers().isEmpty()) {
                     return;
                 }
-                Log.i(TAG, "Set private DNS server to " + server);
                 if (network.equals(n) && Objects.equals(server, lp.getPrivateDnsServerName())) {
+                    Log.i(TAG, "Set private DNS server to " + server + " on " + network);
                     latch.countDown();
                 }
             }
@@ -541,23 +555,69 @@ public final class CtsNetUtils {
 
     /**
      * Get all testable Networks with internet capability.
+     *
+     * <p>At least cellular and Wi-Fi networks are expected to be returned when supported, so tests
+     * must ensure that network requests are filed for them (so they are up) before calling this
+     * method.
      */
-    public Network[] getTestableNetworks() {
+    public Set<Network> getTestableNetworks() {
+        // Calling requestNetwork() to request a cell or Wi-Fi network via CtsNetUtils or
+        // NetworkCallbackRule requires the CHANGE_NETWORK_STATE permission. This permission cannot
+        // be granted to instant apps. Therefore, return currently available testable networks
+        // directly in instant mode.
+        if (mContext.getApplicationInfo().isInstantApp()) {
+            return new ArraySet<>(getTestableNetworks(nc -> true));
+        }
+
+        // Obtain cell and Wi-Fi through NetworkCallbacks, as they may have just been reconnected by
+        // the test using NetworkCallbacks, so synchronous calls may not yet return them
+        // (synchronous calls and callbacks should not be mixed for a given Network).
+        final Set<Network> testableNetworks = new ArraySet<>();
+        if (mContext.getPackageManager().hasSystemFeature(FEATURE_TELEPHONY)) {
+            final String errorMsg = "No cell network obtained within timeout. Ensure that the "
+                    + "device has working mobile data, and that the test has filed a request for "
+                    + "TRANSPORT_CELLULAR before calling getTestableNetworks().";
+            final TestableNetworkCallback cb = new TestableNetworkCallback();
+            mCm.registerNetworkCallback(new NetworkRequest.Builder()
+                    .addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR)
+                    .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
+                    .build(), cb);
+            final Network cellNetwork = cb.expect(Event.AVAILABLE, errorMsg).getNetwork();
+            mCm.unregisterNetworkCallback(cb);
+            testableNetworks.add(cellNetwork);
+        }
+
+        if (mContext.getPackageManager().hasSystemFeature(FEATURE_WIFI)) {
+            testableNetworks.add(ensureWifiConnected());
+        }
+
+        // Obtain other networks through the synchronous API, if any.
+        testableNetworks.addAll(getTestableNetworks(nc ->
+                !nc.hasTransport(TRANSPORT_WIFI) && !nc.hasTransport(TRANSPORT_CELLULAR)));
+
+        // If Wi-Fi or cell are supported testableNetworks won't be empty as per previous assertions
+        assertFalse("This device does not support Wi-Fi nor cell data, and does not have any other "
+                        + "network connected. This test requires at least one internet-providing "
+                        + "network.",
+                testableNetworks.isEmpty());
+        return testableNetworks;
+    }
+
+    /**
+     * Get all testable Networks with internet capability.
+     */
+    private List<Network> getTestableNetworks(Predicate<NetworkCapabilities> filter) {
         final ArrayList<Network> testableNetworks = new ArrayList<Network>();
         for (Network network : mCm.getAllNetworks()) {
             final NetworkCapabilities nc = mCm.getNetworkCapabilities(network);
             if (nc != null
                     && nc.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED)
-                    && nc.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)) {
+                    && nc.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
+                    && filter.test(nc)) {
                 testableNetworks.add(network);
             }
         }
-
-        assertTrue("This test requires that at least one public Internet-providing"
-                        + " network be connected. Please ensure that the device is connected to"
-                        + " a network.",
-                testableNetworks.size() >= 1);
-        return testableNetworks.toArray(new Network[0]);
+        return testableNetworks;
     }
 
     /**
diff --git a/tests/cts/netpermission/internetpermission/Android.bp b/tests/cts/netpermission/internetpermission/Android.bp
index 71d2b6e032..82f8c30f26 100644
--- a/tests/cts/netpermission/internetpermission/Android.bp
+++ b/tests/cts/netpermission/internetpermission/Android.bp
@@ -31,6 +31,7 @@ android_test {
         "general-tests",
     ],
     host_required: ["net-tests-utils-host-common"],
+    host_common_data: [":net-tests-utils-host-common"],
     sdk_version: "test_current",
     data: [
         ":ConnectivityTestPreparer",
diff --git a/tests/cts/netpermission/updatestatspermission/Android.bp b/tests/cts/netpermission/updatestatspermission/Android.bp
index 0ff98e701c..ba8a7d7102 100644
--- a/tests/cts/netpermission/updatestatspermission/Android.bp
+++ b/tests/cts/netpermission/updatestatspermission/Android.bp
@@ -39,4 +39,5 @@ android_test {
     ],
     data: [":ConnectivityTestPreparer"],
     host_required: ["net-tests-utils-host-common"],
+    host_common_data: [":net-tests-utils-host-common"],
 }
diff --git a/tests/cts/tethering/Android.bp b/tests/cts/tethering/Android.bp
index a1e0797490..b14e7e0065 100644
--- a/tests/cts/tethering/Android.bp
+++ b/tests/cts/tethering/Android.bp
@@ -30,9 +30,12 @@ java_defaults {
 
     srcs: [
         "src/**/*.java",
+        "src/**/*.kt",
     ],
 
     static_libs: [
+        "ConnectivityWifiP2pMultiDevicesSnippetLib",
+        "Harrier",
         "TetheringCommonTests",
         "com.android.net.flags-aconfig-java",
         "compatibility-device-util-axt",
@@ -53,6 +56,7 @@ java_defaults {
     platform_apis: true,
     min_sdk_version: "30",
     host_required: ["net-tests-utils-host-common"],
+    host_common_data: [":net-tests-utils-host-common"],
 }
 
 // Tethering CTS tests for development and release. These tests always target the platform SDK
diff --git a/tests/cts/tethering/AndroidManifest.xml b/tests/cts/tethering/AndroidManifest.xml
index bad722bb0f..aede2d724e 100644
--- a/tests/cts/tethering/AndroidManifest.xml
+++ b/tests/cts/tethering/AndroidManifest.xml
@@ -20,6 +20,9 @@
 
     <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
     <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
+    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
+    <uses-permission android:name="android.permission.NEARBY_WIFI_DEVICES"
+                     android:usesPermissionFlags="neverForLocation" />
 
     <application android:debuggable="true">
         <uses-library android:name="android.test.runner" />
diff --git a/tests/cts/tethering/AndroidTestTemplate.xml b/tests/cts/tethering/AndroidTestTemplate.xml
index dd5b23e3a2..215565423b 100644
--- a/tests/cts/tethering/AndroidTestTemplate.xml
+++ b/tests/cts/tethering/AndroidTestTemplate.xml
@@ -17,8 +17,16 @@
     <option name="test-suite-tag" value="cts" />
     <option name="config-descriptor:metadata" key="component" value="networking" />
     <option name="config-descriptor:metadata" key="token" value="SIM_CARD" />
+    <!-- The 'run_on_secondary_user' parameter triggers a second test iteration
+         targeting secondary users. This is only applicable to tests explicitly marked
+         with @UserTest(UserType.SECONDARY_USER) or @RequireRunOnSecondaryUser.
+    -->
+    <option name="config-descriptor:metadata" key="parameter" value="run_on_secondary_user" />
     <option name="config-descriptor:metadata" key="parameter" value="not_instant_app" />
     <option name="config-descriptor:metadata" key="parameter" value="not_multi_abi" />
+    <!-- '[not_]secondary_user' is mandatory to declare the tests could [not] be run on
+         the secondary user. See CtsConfigLoadingTest#testConfigurationLoad.
+    -->
     <option name="config-descriptor:metadata" key="parameter" value="secondary_user" />
     <option name="config-descriptor:metadata" key="mainline-param" value="CaptivePortalLoginGoogle.apk+NetworkStackGoogle.apk+com.google.android.resolv.apex+com.google.android.tethering.apex" />
     <option name="not-shardable" value="true" />
@@ -30,7 +38,19 @@
     </target_preparer>
     <test class="com.android.tradefed.testtype.AndroidJUnitTest" >
         <option name="package" value="android.tethering.cts" />
+        <option name="device-listeners" value="com.android.testutils.ConnectivityDiagnosticsCollector" />
+        <!-- Tests with these annotations should only be ran with their corresponding
+             configurations, e.g. Tests with the RequireRunOnWorkProfile annotation should be
+             ran with the run_on_work_profile configuration. Exclude these tests from running
+             with the normal configuration. See go/bedstead-devicestate#androidtestxml
+        -->
+        <option name="exclude-annotation" value="com.android.bedstead.multiuser.annotations.RequireRunOnSecondaryUser" />
     </test>
+    <metrics_collector class="com.android.tradefed.device.metric.FilePullerLogCollector">
+        <!-- Pattern matching the fileKey used by ConnectivityDiagnosticsCollector when calling addFileMetric -->
+        <option name="pull-pattern-keys" value="com.android.testutils.ConnectivityDiagnosticsCollector.*"/>
+        <option name="collect-on-run-ended-only" value="true" />
+    </metrics_collector>
 
     <object type="module_controller" class="com.android.tradefed.testtype.suite.module.MainlineTestModuleController">
         <option name="mainline-module-package-name" value="com.google.android.tethering" />
diff --git a/tests/cts/tethering/src/android/tethering/cts/TetheringManagerTest.java b/tests/cts/tethering/src/android/tethering/cts/TetheringManagerTest.java
index 92d58e6133..c5e604fb65 100644
--- a/tests/cts/tethering/src/android/tethering/cts/TetheringManagerTest.java
+++ b/tests/cts/tethering/src/android/tethering/cts/TetheringManagerTest.java
@@ -15,10 +15,14 @@
  */
 package android.tethering.test;
 
+import static android.Manifest.permission.CREATE_USERS;
+import static android.Manifest.permission.INTERACT_ACROSS_USERS;
 import static android.Manifest.permission.MODIFY_PHONE_STATE;
 import static android.Manifest.permission.TETHER_PRIVILEGED;
 import static android.Manifest.permission.WRITE_SETTINGS;
+import static android.app.ActivityManager.getCurrentUser;
 import static android.content.pm.PackageManager.FEATURE_TELEPHONY;
+import static android.content.pm.PackageManager.MATCH_SYSTEM_ONLY;
 import static android.net.NetworkCapabilities.NET_CAPABILITY_DUN;
 import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
 import static android.net.NetworkCapabilities.TRANSPORT_CELLULAR;
@@ -37,6 +41,7 @@ import static android.net.TetheringManager.TETHER_ERROR_ENTITLEMENT_UNKNOWN;
 import static android.net.TetheringManager.TETHER_ERROR_NO_CHANGE_TETHERING_PERMISSION;
 import static android.net.TetheringManager.TETHER_ERROR_NO_ERROR;
 import static android.net.TetheringManager.TETHER_ERROR_UNKNOWN_REQUEST;
+import static android.net.TetheringManager.TETHER_ERROR_UNSUPPORTED;
 import static android.net.cts.util.CtsTetheringUtils.isAnyIfaceMatch;
 import static android.os.Process.INVALID_UID;
 
@@ -58,6 +63,7 @@ import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
 import android.net.ConnectivityManager;
 import android.net.LinkAddress;
 import android.net.Network;
@@ -75,23 +81,30 @@ import android.net.cts.util.CtsTetheringUtils.TestTetheringEventCallback;
 import android.net.wifi.SoftApConfiguration;
 import android.net.wifi.WifiManager;
 import android.net.wifi.WifiSsid;
+import android.os.Build;
 import android.os.Bundle;
 import android.os.PersistableBundle;
 import android.os.ResultReceiver;
+import android.os.UserHandle;
 import android.telephony.CarrierConfigManager;
 import android.telephony.SubscriptionManager;
 import android.telephony.TelephonyManager;
 
 import androidx.annotation.NonNull;
 import androidx.test.InstrumentationRegistry;
-import androidx.test.runner.AndroidJUnit4;
 
+import com.android.bedstead.harrier.BedsteadJUnit4;
+import com.android.bedstead.harrier.DeviceState;
+import com.android.bedstead.harrier.UserType;
+import com.android.bedstead.harrier.annotations.UserTest;
 import com.android.modules.utils.build.SdkLevel;
+import com.android.testutils.ConnectivityDiagnosticsCollector;
 import com.android.testutils.ParcelUtils;
 import com.android.testutils.com.android.testutils.CarrierConfigRule;
 
 import org.junit.After;
 import org.junit.Before;
+import org.junit.ClassRule;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -100,15 +113,19 @@ import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import java.util.Objects;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
 import java.util.function.Consumer;
 
-@RunWith(AndroidJUnit4.class)
+@RunWith(BedsteadJUnit4.class)
 public class TetheringManagerTest {
     @Rule
     public final CarrierConfigRule mCarrierConfigRule = new CarrierConfigRule();
+    @ClassRule
+    @Rule
+    public static final DeviceState sDeviceState = new DeviceState();
 
     private Context mContext;
 
@@ -122,6 +139,11 @@ public class TetheringManagerTest {
     private CtsTetheringUtils mCtsTetheringUtils;
 
     private static final int DEFAULT_TIMEOUT_MS = 60_000;
+    private static final String TETHERING_CONNECTOR_CLASS = "android.net.ITetheringConnector";
+    // String replacement is needed to prevent the class name from being modified
+    // by NetworkStack JarJar rules.
+    private static final String NETWORKSTACK_CONNECTOR_CLASS =
+            "android$net$INetworkStackConnector".replace('$', '.');
 
     @Before
     public void setUp() throws Exception {
@@ -411,28 +433,20 @@ public class TetheringManagerTest {
                     mCtsTetheringUtils.startWifiTethering(tetherEventCallback, softApConfig);
 
             assertNotNull(tetheredIface);
+            final String wifiTetheringIface = tetheredIface.getInterface();
             if  (SdkLevel.isAtLeastB()) {
                 assertEquals(softApConfig, tetheredIface.getSoftApConfiguration());
             }
 
             mCtsTetheringUtils.stopWifiTethering(tetherEventCallback);
 
-            if (!SdkLevel.isAtLeastB()) {
-                final String wifiTetheringIface = tetheredIface.getInterface();
-                try {
-                    final int ret = runAsShell(TETHER_PRIVILEGED,
-                            () -> mTM.tether(wifiTetheringIface));
-                    // There is no guarantee that the wifi interface will be available after
-                    // disabling the hotspot, so don't fail the test if the call to tether() fails.
-                    if (ret == TETHER_ERROR_NO_ERROR) {
-                        // If calling #tether successful, there is a callback to tell the result of
-                        // tethering setup.
-                        tetherEventCallback.expectErrorOrTethered(
-                                new TetheringInterface(TETHERING_WIFI, wifiTetheringIface));
-                    }
-                } finally {
-                    runAsShell(TETHER_PRIVILEGED, () -> mTM.untether(wifiTetheringIface));
-                }
+            if (SdkLevel.isAtLeastB()) {
+                assertThrows(UnsupportedOperationException.class,
+                        () -> runAsShell(TETHER_PRIVILEGED,
+                                () -> mTM.tether(wifiTetheringIface)));
+            } else {
+                final int ret = runAsShell(TETHER_PRIVILEGED, () -> mTM.tether(wifiTetheringIface));
+                assertEquals(TETHER_ERROR_UNSUPPORTED, ret);
             }
         } finally {
             mCtsTetheringUtils.unregisterTetheringEventCallback(tetherEventCallback);
@@ -477,6 +491,18 @@ public class TetheringManagerTest {
 
             mCtsTetheringUtils.stopAllTethering();
             tetherEventCallback.expectNoTetheringActive();
+        } catch (Throwable e) {
+            if (Build.VERSION.SDK_INT == Build.VERSION_CODES.TIRAMISU) {
+                // This test fails on T devices in rare cases due to hostapd hanging. Log the
+                // hostapd callstack to help analyze the failure the next time it happens.
+                final ConnectivityDiagnosticsCollector collector =
+                        ConnectivityDiagnosticsCollector.getInstance();
+                if (collector != null) {
+                    collector.collectCommandOutput(
+                            "getprop init.svc_debug_pid.hostapd | xargs debuggerd -b", "sh", e);
+                }
+            }
+            throw e;
         } finally {
             mCtsTetheringUtils.unregisterTetheringEventCallback(tetherEventCallback);
         }
@@ -896,4 +922,30 @@ public class TetheringManagerTest {
             mCtsTetheringUtils.unregisterTetheringEventCallback(tetherEventCallback);
         }
     }
+
+    // Verify the existence of the Tethering/NetworkStack package for the current user.
+    // This test will be executed on both SYSTEM and FULL users.
+    @Test
+    @UserTest({UserType.INITIAL_USER, UserType.SECONDARY_USER})
+    public void testCreatePackageContextAsUser() throws PackageManager.NameNotFoundException {
+        final List<String> packageNames = List.of(
+                resolvePackageName(TETHERING_CONNECTOR_CLASS),
+                resolvePackageName(NETWORKSTACK_CONNECTOR_CLASS));
+        // Permission CREATE_USERS is required for Android R or below.
+        final int currentUserId = runAsShell(CREATE_USERS, INTERACT_ACROSS_USERS,
+                () -> getCurrentUser());
+        final UserHandle currentUser = UserHandle.of(currentUserId);
+        for (String packageName : packageNames) {
+            mContext.createPackageContextAsUser(packageName, 0 /* flags */, currentUser);
+        }
+    }
+
+    @NonNull
+    private String resolvePackageName(@NonNull String action) {
+        final Intent intent = new Intent(action);
+        final List<ResolveInfo> resolveInfoList = mContext.getPackageManager()
+                .queryIntentServices(intent, MATCH_SYSTEM_ONLY);
+        assertFalse("Failed to resolve package for " + action, resolveInfoList.isEmpty());
+        return Objects.requireNonNull(resolveInfoList.get(0).getComponentInfo().packageName);
+    }
 }
diff --git a/tests/cts/tethering/src/android/tethering/cts/TetheringWifiP2pTest.kt b/tests/cts/tethering/src/android/tethering/cts/TetheringWifiP2pTest.kt
new file mode 100644
index 0000000000..ac05a56f00
--- /dev/null
+++ b/tests/cts/tethering/src/android/tethering/cts/TetheringWifiP2pTest.kt
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.tethering.cts
+
+import android.Manifest.permission.LOG_COMPAT_CHANGE
+import android.Manifest.permission.READ_COMPAT_CHANGE_CONFIG
+import android.Manifest.permission.TETHER_PRIVILEGED
+import android.app.compat.CompatChanges
+import android.content.pm.PackageManager
+import android.net.NetworkCapabilities.NET_CAPABILITY_LOCAL_NETWORK
+import android.net.NetworkCapabilities.TRANSPORT_WIFI
+import android.net.NetworkRequest
+import android.net.TetheringManager
+import android.net.connectivity.ConnectivityCompatChanges
+import android.os.Build
+import android.provider.DeviceConfig
+import android.text.TextUtils
+import androidx.test.platform.app.InstrumentationRegistry
+import com.android.testutils.AutoReleaseNetworkCallbackRule
+import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
+import com.android.testutils.DevSdkIgnoreRunner
+import com.android.testutils.DeviceConfigRule
+import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.Available
+import com.android.testutils.TestableNetworkCallback.Event.CapabilitiesChanged
+import com.android.testutils.TestableNetworkCallback.Event.LinkPropertiesChanged
+import com.android.testutils.runAsShell
+import com.google.snippet.connectivity.Wifip2pMultiDevicesSnippet
+import java.util.Random
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertTrue
+import org.junit.Assume.assumeTrue
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+
+@IgnoreUpTo(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+@RunWith(DevSdkIgnoreRunner::class)
+class TetheringWifiP2pTest {
+    // For manipulating feature flag before and after testing.
+    @get:Rule
+    val deviceConfigRule = DeviceConfigRule()
+
+    @get:Rule
+    val networkCallbackRule = AutoReleaseNetworkCallbackRule()
+
+    companion object {
+        // Shamelessly copied from TetheringConfiguration.
+        private const val TETHERING_LOCAL_NETWORK_AGENT = "tethering_local_network_agent"
+        private const val WIFIP2PGO_LOCAL_NETWORK_AGENT = "wifip2pgo_local_network_agent"
+    }
+
+    private val context = InstrumentationRegistry.getInstrumentation().getTargetContext()
+    private val pm = context.packageManager!!
+    private val tm = context.getSystemService(TetheringManager::class.java)
+
+    private fun assumeMatchNonThreadLocalNetworksEnabled() {
+        assumeTrue(runAsShell<Boolean>(READ_COMPAT_CHANGE_CONFIG, LOG_COMPAT_CHANGE) {
+            CompatChanges.isChangeEnabled(
+                    ConnectivityCompatChanges.ENABLE_MATCH_NON_THREAD_LOCAL_NETWORKS
+            )
+        })
+    }
+
+    private fun getRandomString(): String {
+        return "%09d".format(Random().nextInt(1_000_000_000))
+    }
+
+    @Test
+    fun testWifiP2pGoNetworkAgent_networkCallbacks() {
+        // Check preconditions.
+        assumeMatchNonThreadLocalNetworksEnabled()
+        assumeTrue(pm.hasSystemFeature(PackageManager.FEATURE_WIFI))
+        assumeTrue(pm.hasSystemFeature(PackageManager.FEATURE_WIFI_DIRECT))
+        // Wifi P2p Group Owner mode still need tethering support in order to get
+        // onLocalOnlyInterfacesChanged callbacks.
+        assumeTrue(runAsShell(TETHER_PRIVILEGED) { tm.isTetheringSupported() })
+        deviceConfigRule.setConfig(
+                DeviceConfig.NAMESPACE_TETHERING,
+                TETHERING_LOCAL_NETWORK_AGENT,
+                "1"
+        )
+        deviceConfigRule.setConfig(
+                DeviceConfig.NAMESPACE_TETHERING,
+                WIFIP2PGO_LOCAL_NETWORK_AGENT,
+                "1"
+        )
+
+        val cb = TestableNetworkCallback()
+        val request = NetworkRequest.Builder().addCapability(NET_CAPABILITY_LOCAL_NETWORK)
+                .addTransportType(TRANSPORT_WIFI).build()
+        networkCallbackRule.registerNetworkCallback(request, cb)
+
+        val wifiP2pSnippet = Wifip2pMultiDevicesSnippet()
+        try {
+            wifiP2pSnippet.startWifiP2p()
+            wifiP2pSnippet.createGroup("DIRECT-" + getRandomString(), getRandomString())
+
+            val availableEvent = cb.expect<Available>()
+            // Verify Capabilities.
+            val capEvent = cb.eventuallyExpect<CapabilitiesChanged>()
+            assertEquals(availableEvent.network, capEvent.network)
+            assertTrue(capEvent.caps.hasCapability(NET_CAPABILITY_LOCAL_NETWORK))
+            assertTrue(capEvent.caps.hasTransport(TRANSPORT_WIFI))
+
+            // Verify LinkProperties.
+            val lpEvent = cb.eventuallyExpect<LinkPropertiesChanged>()
+            assertEquals(capEvent.network, lpEvent.network)
+            assertFalse(TextUtils.isEmpty(lpEvent.lp.interfaceName))
+            // At least 1 Ipv4 address and route.
+            assertTrue(lpEvent.lp.hasIPv4Address())
+            assertTrue(lpEvent.lp.routes.size >= 1)
+        } finally {
+            wifiP2pSnippet.stopWifiP2p()
+        }
+    }
+}
diff --git a/tests/integration/Android.bp b/tests/integration/Android.bp
index 6c3b7a0710..b9f67e1181 100644
--- a/tests/integration/Android.bp
+++ b/tests/integration/Android.bp
@@ -51,6 +51,7 @@ android_test {
         "kotlin-reflect",
         "mockito-target-extended-minus-junit4",
         "net-tests-utils",
+        "net-utils-networkstack",
         "service-connectivity-pre-jarjar",
         "service-connectivity-tiramisu-pre-jarjar",
         "services.net",
diff --git a/tests/integration/src/android/net/ClatTest.kt b/tests/integration/src/android/net/ClatTest.kt
new file mode 100644
index 0000000000..68e6d64c12
--- /dev/null
+++ b/tests/integration/src/android/net/ClatTest.kt
@@ -0,0 +1,233 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+package android.net
+
+import android.Manifest.permission.CHANGE_NETWORK_STATE
+import android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET
+import android.net.NetworkCapabilities.NET_CAPABILITY_TRUSTED
+import android.net.NetworkCapabilities.TRANSPORT_ETHERNET
+import android.net.NetworkCapabilities.TRANSPORT_TEST
+import android.net.TestNetworkManager.TestInterfaceRequest
+import android.os.Build
+import android.os.Handler
+import android.os.HandlerThread
+import android.platform.test.annotations.AppModeFull
+import android.system.Os
+import android.system.OsConstants.AF_INET
+import android.system.OsConstants.IPPROTO_UDP
+import android.system.OsConstants.SOCK_DGRAM
+import androidx.test.platform.app.InstrumentationRegistry
+import com.android.net.module.util.ProcfsParsingUtils
+import com.android.testutils.AutoCloseTestInterfaceRule
+import com.android.testutils.DataPkt
+import com.android.testutils.DevSdkIgnoreRule
+import com.android.testutils.DevSdkIgnoreRunner
+import com.android.testutils.EtherPkt
+import com.android.testutils.EthernetTestInterface
+import com.android.testutils.Ip6Pkt
+import com.android.testutils.NdResponder
+import com.android.testutils.RaPkt
+import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.LinkPropertiesChanged
+import com.android.testutils.UdpPkt
+import com.android.testutils.runAsShell
+import com.google.common.truth.Truth.assertThat
+import java.io.FileDescriptor
+import java.net.Inet4Address
+import java.net.Inet6Address
+import java.net.InetAddress
+import java.net.InetSocketAddress
+import java.nio.ByteBuffer
+import kotlin.test.fail
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+
+private const val TAG = "ClatTest"
+private const val SHORT_TIMEOUT_MS = 200L
+private const val TIMEOUT_MS = 2000L
+
+private val REQUEST: NetworkRequest = NetworkRequest.Builder()
+        .addTransportType(TRANSPORT_ETHERNET)
+        .addTransportType(TRANSPORT_TEST)
+        .removeCapability(NET_CAPABILITY_INTERNET)
+        .removeCapability(NET_CAPABILITY_TRUSTED)
+        .build()
+private val ROUTER_MAC = MacAddress.fromString("01:02:03:04:05:06")
+private val ROUTER_V6 = InetAddress.getByName("fe80::0102:03ff:fe04:0506") as Inet6Address
+
+// For ByteArray.toHexString
+@kotlin.ExperimentalStdlibApi
+@AppModeFull(reason = "Instant apps can't access EthernetManager")
+@RunWith(DevSdkIgnoreRunner::class)
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
+class ClatTest {
+    private val context = InstrumentationRegistry.getInstrumentation().context
+    private val cm = context.getSystemService(ConnectivityManager::class.java)!!
+    private val handlerThread = HandlerThread("$TAG thread").apply { start() }
+    private val handler = Handler(handlerThread.looper)
+    private val registeredCallbacks = ArrayList<TestableNetworkCallback>()
+
+    // Cannot be initialized before setUp as eventuallyExpect<LinkPropertiesChanged>() can fail.
+    private lateinit var lp: LinkProperties
+    private lateinit var network: Network
+    private var socket: FileDescriptor? = null
+
+    @get:Rule
+    val testInterfaceRule = AutoCloseTestInterfaceRule(context)
+
+    private val iface: EthernetTestInterface
+    init {
+        val req = TestInterfaceRequest.Builder().setTap().build()
+        val tap = testInterfaceRule.createTestInterface(req)
+        iface = EthernetTestInterface(context, handler, tap)
+    }
+
+    private val localMac = iface.testIface.macAddress!!
+
+    // Available after provisioning.
+    private lateinit var clatV6Addr: Inet6Address
+
+    private val ndResponder = NdResponder(iface.packetReader).apply {
+        val ra = RaPkt()
+                .addPioOption(prefix = prefix.toString(), flags = "LA")
+                .addRdnssOption(dns = "2001:4860:4860::8888,2001:4860:4860::8844")
+                .addPref64Option(prefix = "64:ff9b::/96")
+        addRouterEntry(ROUTER_MAC, ROUTER_V6, ra)
+        start()
+    }
+
+    private fun requestNetwork(request: NetworkRequest): TestableNetworkCallback {
+        val cb = TestableNetworkCallback()
+        runAsShell(CHANGE_NETWORK_STATE) {
+            cm.requestNetwork(request, cb, handler)
+            registeredCallbacks.add(cb)
+        }
+        return cb
+    }
+
+    @Before
+    fun setUp() {
+        val cb = requestNetwork(REQUEST)
+
+        // Wait for the clat interface to be created.
+        var linkPropertiesChanged: LinkPropertiesChanged
+        do {
+            linkPropertiesChanged = cb.eventuallyExpect<LinkPropertiesChanged>()
+        } while (linkPropertiesChanged.lp.stackedLinks.isEmpty())
+
+        network = linkPropertiesChanged.network
+        lp = linkPropertiesChanged.lp
+
+        clatV6Addr = ProcfsParsingUtils.getAnycast6Addresses(iface.name).get(0)
+    }
+
+    @After
+    fun tearDown() {
+        if (socket != null) {
+            Os.close(socket)
+        }
+        for (cb in registeredCallbacks) {
+            cm.unregisterNetworkCallback(cb)
+        }
+        // TODO: AutoCloseTestInterfaceRule should destroy associated EthernetTestInterface.
+        iface.destroy()
+        handlerThread.quitSafely()
+        handlerThread.join()
+    }
+
+    fun LinkProperties.getInet4Address(): Inet4Address {
+        val las = getAllLinkAddresses()
+        for (la in las) {
+            if (la.isIpv4()) return la.address as Inet4Address
+        }
+        // If the v4- interface is present, this cannot happen.
+        fail("LinkProperties did not include an IPv4 address")
+    }
+
+    fun expectPacket(expectedPacket: ByteArray) {
+        val p = iface.packetReader.poll(TIMEOUT_MS) {
+            it.contentEquals(expectedPacket)
+        }
+        assertThat(p).isNotNull()
+    }
+
+    /** Assert that no packet from the clat source address was received */
+    fun expectNoClatPacket() {
+        val p = iface.packetReader.poll(SHORT_TIMEOUT_MS) {
+            val src = ByteArray(16)
+            val buf = ByteBuffer.wrap(it)
+            buf.position(14 + 8)
+            buf.get(src)
+            val srcAddr = Inet6Address.getByAddress(src)
+            clatV6Addr.equals(srcAddr)
+        }
+        assertThat(p).isNull()
+    }
+
+    @Test
+    fun testClatEgress() {
+        socket = Os.socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)
+        network.bindSocket(socket)
+        Os.connect(socket, InetAddress.getByName("1.2.3.4"), 12345)
+        val sockaddr = Os.getsockname(socket) as InetSocketAddress
+        val localPort = sockaddr.port
+        val buf = ByteBuffer.wrap("test data".toByteArray())
+        Os.write(socket, buf)
+
+        val ether = EtherPkt(dst = ROUTER_MAC, src = localMac)
+        val ipv6 = Ip6Pkt(src = clatV6Addr.hostAddress!!, dst = "64:ff9b::1.2.3.4", hlim = 64)
+        val udp = UdpPkt(sport = localPort, dport = 12345)
+        val payload = DataPkt(buf.array())
+        val pkt = ether / ipv6 / udp / payload
+        expectPacket(pkt.build())
+    }
+
+    @Test
+    fun testClatIngress() {
+        socket = Os.socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)
+        network.bindSocket(socket)
+        Os.bind(socket, lp.getInet4Address(), 0)
+        val sockaddr = Os.getsockname(socket) as InetSocketAddress
+        val localPort = sockaddr.port
+
+        val ether = EtherPkt(dst = localMac, src = ROUTER_MAC)
+        val ipv6 = Ip6Pkt(src = "64:ff9b::1.2.3.4", dst = clatV6Addr.hostAddress!!)
+        val udp = UdpPkt(sport = 12345, dport = localPort)
+        val data = "more test data"
+        val payload = DataPkt(data)
+        val pkt = ether / ipv6 / udp / payload
+        iface.packetReader.sendResponse(ByteBuffer.wrap(pkt.build()))
+
+        val buf = ByteBuffer.allocate(data.length)
+        Os.read(socket, buf)
+        assertThat(buf.array()).isEqualTo(data.toByteArray())
+    }
+
+    @Test
+    fun testEgressDropsMulticast() {
+        socket = Os.socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)
+        network.bindSocket(socket)
+
+        val buf = ByteBuffer.wrap("test".toByteArray())
+        Os.sendto(socket, buf, 0 /*flags*/, InetAddress.getByName("224.0.0.251"), 12345 /*port*/)
+        Os.sendto(socket, buf, 0 /*flags*/, InetAddress.getByName("234.42.42.42"), 123 /*port*/)
+        expectNoClatPacket()
+    }
+}
diff --git a/tests/integration/src/android/net/Dhcp6PdTest.kt b/tests/integration/src/android/net/Dhcp6PdTest.kt
new file mode 100644
index 0000000000..748b258044
--- /dev/null
+++ b/tests/integration/src/android/net/Dhcp6PdTest.kt
@@ -0,0 +1,325 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+package android.net
+
+import android.Manifest.permission.CHANGE_NETWORK_STATE
+import android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET
+import android.net.NetworkCapabilities.NET_CAPABILITY_TRUSTED
+import android.net.NetworkCapabilities.TRANSPORT_ETHERNET
+import android.net.NetworkCapabilities.TRANSPORT_TEST
+import android.net.TestNetworkManager.TestInterfaceRequest
+import android.os.Build
+import android.os.Handler
+import android.os.HandlerThread
+import android.platform.test.annotations.AppModeFull
+import android.provider.DeviceConfig.NAMESPACE_CONNECTIVITY
+import androidx.test.platform.app.InstrumentationRegistry
+import com.android.net.module.util.dhcp6.Dhcp6Packet
+import com.android.net.module.util.dhcp6.Dhcp6RebindPacket
+import com.android.net.module.util.dhcp6.Dhcp6SolicitPacket
+import com.android.testutils.AutoCloseTestInterfaceRule
+import com.android.testutils.DevSdkIgnoreRule
+import com.android.testutils.DevSdkIgnoreRunner
+import com.android.testutils.DeviceConfigRule
+import com.android.testutils.Dhcp6IaPdOpt
+import com.android.testutils.Dhcp6Pkt
+import com.android.testutils.EtherPkt
+import com.android.testutils.EthernetTestInterface
+import com.android.testutils.Ip6Pkt
+import com.android.testutils.NdResponder
+import com.android.testutils.PacketBuilder
+import com.android.testutils.RaPkt
+import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.Available
+import com.android.testutils.TestableNetworkCallback.Event.LinkPropertiesChanged
+import com.android.testutils.UdpPkt
+import com.android.testutils.runAsShell
+import com.google.common.truth.Truth.assertThat
+import java.net.Inet6Address
+import java.net.InetAddress
+import java.nio.ByteBuffer
+import kotlin.test.assertIs
+import kotlin.test.assertNotNull
+import kotlin.test.assertNull
+import org.junit.After
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+
+private const val TAG = "Dhcp6PdTest"
+private const val SHORT_TIMEOUT_MS = 200L
+private const val TIMEOUT_MS = 20_000L
+
+private const val DHCP6_PFLAG_CONFIG = "ipclient_dhcpv6_pd_preferred_flag_version"
+
+private val REQUEST: NetworkRequest = NetworkRequest.Builder()
+        .addTransportType(TRANSPORT_ETHERNET)
+        .addTransportType(TRANSPORT_TEST)
+        .removeCapability(NET_CAPABILITY_INTERNET)
+        .removeCapability(NET_CAPABILITY_TRUSTED)
+        .build()
+private val ROUTER_MAC = MacAddress.fromString("01:02:03:04:05:06")
+private val ROUTER_V6 = InetAddress.getByName("fe80::1") as Inet6Address
+private val RA_WITH_PFLAG = RaPkt()
+            .addPioOption(prefix = "2001:db8::/64", flags = "LAP")
+            .addRdnssOption(dns = "2001:4860:4860::8888,2001:4860:4860::8844")
+            .addSllaOption(ROUTER_MAC)
+
+@AppModeFull(reason = "Instant apps can't access EthernetManager")
+@RunWith(DevSdkIgnoreRunner::class)
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
+class Dhcp6PdTest {
+    private val context = InstrumentationRegistry.getInstrumentation().context
+    private val cm = context.getSystemService(ConnectivityManager::class.java)!!
+    private val handlerThread = HandlerThread("$TAG thread").apply { start() }
+    private val handler = Handler(handlerThread.looper)
+    private val networkCallback = TestableNetworkCallback().also {
+        runAsShell(CHANGE_NETWORK_STATE) {
+            val request = NetworkRequest.Builder()
+                    .addTransportType(TRANSPORT_ETHERNET)
+                    .addTransportType(TRANSPORT_TEST)
+                    .removeCapability(NET_CAPABILITY_INTERNET)
+                    .removeCapability(NET_CAPABILITY_TRUSTED)
+                    .build()
+            cm.requestNetwork(request, it, handler)
+        }
+    }
+
+    @get:Rule(order = 1)
+    val deviceConfigRule = DeviceConfigRule().apply {
+        setConfig(NAMESPACE_CONNECTIVITY, DHCP6_PFLAG_CONFIG, "1")
+    }
+
+    @get:Rule(order = 2)
+    val testInterfaceRule = AutoCloseTestInterfaceRule(context)
+
+    private val iface: EthernetTestInterface
+    init {
+        val req = TestInterfaceRequest.Builder().setTap().build()
+        val tap = testInterfaceRule.createTestInterface(req)
+        iface = EthernetTestInterface(context, handler, tap)
+    }
+    private val localMac = iface.testIface.macAddress!!
+    private val ndResponder = NdResponder(iface.packetReader).apply { start() }
+
+    @After
+    fun tearDown() {
+        cm.unregisterNetworkCallback(networkCallback)
+        // TODO: AutoCloseTestInterfaceRule should destroy associated EthernetTestInterface.
+        iface.destroy()
+        handlerThread.quitSafely()
+        handlerThread.join()
+    }
+
+    private fun eventuallyExpectPacket(predicate: (ByteArray) -> Boolean): ByteArray {
+        val p = iface.packetReader.poll(TIMEOUT_MS) {
+            it != null && predicate(it)
+        }
+        assertNotNull(p)
+        return p
+    }
+
+    private fun assertNoPacket(predicate: (ByteArray) -> Boolean) {
+        val p = iface.packetReader.poll(SHORT_TIMEOUT_MS) {
+            it != null && predicate(it)
+        }
+        assertNull(p)
+    }
+
+    private fun assertNoDhcp6Packet() {
+        assertNoPacket(::isDhcp6Packet)
+    }
+
+    private fun isDhcp6Packet(p: ByteArray): Boolean {
+        val bb = ByteBuffer.wrap(p)
+        bb.position(6 + 6)
+        val etherType = bb.getShort()
+        if ((etherType.toInt() and 0xffff) != 0x86dd) return false
+
+        bb.position(14 + 6)
+        val nextHeader = bb.get()
+        if (nextHeader.toInt() != 17) return false
+
+        bb.position(14 + 40 + 2)
+        val dport = bb.getShort()
+        if (dport.toInt() != 547) return false
+
+        return true
+    }
+
+    private inline fun <reified T : Dhcp6Packet> expectDhcp6Packet(): Pair<Inet6Address, T> {
+        val l2bytes = eventuallyExpectPacket(::isDhcp6Packet)
+
+        // Read src v6 address from byte array.
+        val arr = ByteArray(16)
+        val bb = ByteBuffer.wrap(l2bytes)
+        bb.position(14 + 8)
+        bb.get(arr)
+        val srcAddr = InetAddress.getByAddress(arr) as Inet6Address
+
+        val dhcp6bytes = l2bytes.drop(14 + 40 + 8).toByteArray()
+        val packet = Dhcp6Packet.decode(dhcp6bytes, dhcp6bytes.size)
+        assertIs<T>(packet)
+        return Pair(srcAddr, packet as T)
+    }
+
+    private fun EthernetTestInterface.sendPacket(p: PacketBuilder) {
+        packetReader.sendResponse(ByteBuffer.wrap(p.build()))
+    }
+
+    @Test
+    fun testSolicit_triggeredByPflag() {
+        ndResponder.addRouterEntry(ROUTER_MAC, ROUTER_V6, RA_WITH_PFLAG)
+        expectDhcp6Packet<Dhcp6SolicitPacket>()
+        networkCallback.assertNoCallback()
+    }
+
+    @Test
+    fun testProvisioning_triggeredByPflag() {
+        ndResponder.addRouterEntry(ROUTER_MAC, ROUTER_V6, RA_WITH_PFLAG)
+        val (srcAddr, solicit) = expectDhcp6Packet<Dhcp6SolicitPacket>()
+
+        val ether = EtherPkt(src = ROUTER_MAC, dst = localMac)
+        val ipv6 = Ip6Pkt(src = ROUTER_V6, dst = srcAddr)
+        val udp = UdpPkt(sport = 547, dport = 546)
+        val dhcp6 = Dhcp6Pkt(type = "REPLY", transId = solicit.transactionId)
+                .addRapidCommitOption()
+                .addClientIdentifierOption(solicit.clientDuid)
+                .addServerIdentifierOption(byteArrayOf(1, 2, 3, 4, 5, 6))
+        val dhcp6_pd = Dhcp6IaPdOpt(iaid = solicit.iaid)
+                .addIaPrefixOption(prefix = "2001:db8:1234::/64")
+        val pkt = ether / ipv6 / udp / dhcp6 / dhcp6_pd
+        iface.sendPacket(pkt)
+
+        networkCallback.expect<Available>()
+    }
+
+    @Test
+    fun testProvisioning_triggeredByMultiplePrefixesWithPflag() {
+        ndResponder.addRouterEntry(ROUTER_MAC, ROUTER_V6, RA_WITH_PFLAG)
+        val (srcAddr, solicit) = expectDhcp6Packet<Dhcp6SolicitPacket>()
+
+        run {
+            val ether = EtherPkt(src = ROUTER_MAC, dst = localMac)
+            val ipv6 = Ip6Pkt(src = ROUTER_V6, dst = srcAddr)
+            val udp = UdpPkt(sport = 547, dport = 546)
+            val dhcp6 = Dhcp6Pkt(type = "REPLY", transId = solicit.transactionId)
+                .addRapidCommitOption()
+                .addClientIdentifierOption(solicit.clientDuid)
+                .addServerIdentifierOption(byteArrayOf(1, 2, 3, 4, 5, 6))
+            val dhcp6_pd = Dhcp6IaPdOpt(iaid = solicit.iaid)
+                .addIaPrefixOption(prefix = "2001:db8:1234::/64")
+            val pkt = ether / ipv6 / udp / dhcp6 / dhcp6_pd
+            iface.sendPacket(pkt)
+        }
+
+        networkCallback.expect<Available>()
+
+        run {
+            val ether = EtherPkt(src = "f4:34:f0:64:52:fe", dst = "33:33:00:00:00:01")
+            val ipv6 = Ip6Pkt(src = "fe80::12", dst = "ff02::1")
+            val ra = RaPkt(lft = 360, retransTimer = 360)
+                .addPioOption(prefix = "2002:db8:1::/64", flags = "LAP")
+            iface.sendPacket(ether / ipv6 / ra)
+        }
+
+        expectDhcp6Packet<Dhcp6RebindPacket>()
+    }
+
+    @Test
+    fun testProvisioning_withTwoPrefixes() {
+        val ra = RaPkt()
+            .addPioOption(prefix = "2001:db8::/64", flags = "LAP")
+            .addPioOption(prefix = "fd00::/48", flags = "LAP")
+            .addRdnssOption(dns = "2001:4860:4860::8888,2001:4860:4860::8844")
+        ndResponder.addRouterEntry(ROUTER_MAC, ROUTER_V6, ra)
+        val (srcAddr, solicit) = expectDhcp6Packet<Dhcp6SolicitPacket>()
+
+        val ether = EtherPkt(src = ROUTER_MAC, dst = localMac)
+        val ipv6 = Ip6Pkt(src = ROUTER_V6, dst = srcAddr)
+        val udp = UdpPkt(sport = 547, dport = 546)
+        val dhcp6 = Dhcp6Pkt(type = "REPLY", transId = solicit.transactionId)
+                .addRapidCommitOption()
+                .addClientIdentifierOption(solicit.clientDuid)
+                .addServerIdentifierOption(byteArrayOf(5, 4, 3, 2, 1))
+        val dhcp6_pd = Dhcp6IaPdOpt(iaid = solicit.iaid)
+                .addIaPrefixOption(prefix = "fd00::/48")
+                .addIaPrefixOption(prefix = "2001:db8:1234::/64")
+        val pkt = ether / ipv6 / udp / dhcp6 / dhcp6_pd
+        iface.sendPacket(pkt)
+
+        val lp = networkCallback.eventuallyExpect<LinkPropertiesChanged>().lp
+        val prefixes = lp.linkAddresses.map { it -> IpPrefix(it.address, it.prefixLength) }
+        // TODO: Should the stack also derive an address from fd00::/48?
+        assertThat(prefixes).containsExactly(IpPrefix("fe80::/64"), IpPrefix("2001:db8:1234::/64"))
+    }
+
+    @Test
+    fun testProvisioning_withMultihomingConfiguration() {
+        // Configure two routers.
+        run {
+            val ra = RaPkt()
+                .addPioOption(prefix = "2001:db8:1::/64", flags = "LAP")
+                .addRdnssOption(dns = "2001:4860:4860::8888,2001:4860:4860::8844")
+            ndResponder.addRouterEntry(ROUTER_MAC, ROUTER_V6, ra)
+        }
+        run {
+            val ra = RaPkt()
+                .addPioOption(prefix = "2001:db8:2::/64", flags = "LAP")
+                .addRdnssOption(dns = "2001:4860:4860::8888,2001:4860:4860::8844")
+            val mac = MacAddress.fromString("9:8:7:6:5:4")
+            val ip = InetAddress.getByName("fe80::2") as Inet6Address
+            ndResponder.addRouterEntry(mac, ip, ra)
+        }
+        val (srcAddr, solicit) = expectDhcp6Packet<Dhcp6SolicitPacket>()
+
+        val ether = EtherPkt(src = "42:42:42:42:42:42", dst = localMac.toString())
+        val ipv6 = Ip6Pkt(src = "fe80::42", dst = srcAddr.hostAddress!!)
+        val udp = UdpPkt(sport = 547, dport = 546)
+        val dhcp6 = Dhcp6Pkt(type = "REPLY", transId = solicit.transactionId)
+                .addRapidCommitOption()
+                .addClientIdentifierOption(solicit.clientDuid)
+                .addServerIdentifierOption(byteArrayOf(5, 4, 3, 2, 1))
+        val dhcp6_pd = Dhcp6IaPdOpt(iaid = solicit.iaid)
+                .addIaPrefixOption(prefix = "2001:db8:1:1234::/64")
+                .addIaPrefixOption(prefix = "2001:db8:2:1234::/64")
+        val pkt = ether / ipv6 / udp / dhcp6 / dhcp6_pd
+        iface.sendPacket(pkt)
+
+        val lp = networkCallback.eventuallyExpect<LinkPropertiesChanged>().lp
+        val prefixes = lp.linkAddresses.map { it -> IpPrefix(it.address, it.prefixLength) }
+        assertThat(prefixes).containsExactly(
+                IpPrefix("fe80::/64"),
+                IpPrefix("2001:db8:1:1234::/64"),
+                IpPrefix("2001:db8:2:1234::/64")
+        )
+    }
+
+    @Test
+    fun testSolicit_notTriggeredByLinkLocalPrefix() {
+        // RA includes a SLAAC prefix to ensure the heuristic does not trigger.
+        val ra = RaPkt()
+            .addPioOption(prefix = "2001:db8:1::/64", flags = "LA")
+            .addPioOption(prefix = "fe80:42::/64", flags = "LP")
+            .addRdnssOption(dns = "2001:4860::8888")
+        ndResponder.addRouterEntry(ROUTER_MAC, ROUTER_V6, ra)
+        // Expect network Available to wait for RA arrival
+        networkCallback.expect<Available>()
+        // Ensure that no Solicit was sent.
+        assertNoDhcp6Packet()
+    }
+}
diff --git a/tests/integration/src/com/android/server/net/integrationtests/ConnectivityServiceIntegrationTest.kt b/tests/integration/src/com/android/server/net/integrationtests/ConnectivityServiceIntegrationTest.kt
index de392156ee..563ced89e5 100644
--- a/tests/integration/src/com/android/server/net/integrationtests/ConnectivityServiceIntegrationTest.kt
+++ b/tests/integration/src/com/android/server/net/integrationtests/ConnectivityServiceIntegrationTest.kt
@@ -67,12 +67,11 @@ import com.android.server.connectivity.ProxyTracker
 import com.android.server.connectivity.SatelliteAccessController
 import com.android.testutils.DevSdkIgnoreRunner
 import com.android.testutils.DeviceInfoUtils
-import com.android.testutils.RecorderCallback.CallbackEntry.LinkPropertiesChanged
 import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.LinkPropertiesChanged
 import com.android.testutils.runAsShell
 import com.android.testutils.tryTest
 import java.util.function.BiConsumer
-import java.util.function.Consumer
 import kotlin.test.assertEquals
 import kotlin.test.assertNotNull
 import kotlin.test.assertTrue
@@ -303,7 +302,7 @@ class ConnectivityServiceIntegrationTest {
 
         override fun makeSatelliteAccessController(
             context: Context,
-            updateSatellitePreferredUid: Consumer<MutableSet<Int>>?,
+            updateSatellitePreferredUid: BiConsumer<Set<Int>, Set<Int>>,
             connectivityServiceInternalHandler: Handler
         ): SatelliteAccessController? = mock(
             SatelliteAccessController::class.java
diff --git a/tests/integration/src/com/android/server/net/integrationtests/NetworkStatsIntegrationTest.kt b/tests/integration/src/com/android/server/net/integrationtests/NetworkStatsIntegrationTest.kt
index 4780c5d4b9..1d7b54d116 100644
--- a/tests/integration/src/com/android/server/net/integrationtests/NetworkStatsIntegrationTest.kt
+++ b/tests/integration/src/com/android/server/net/integrationtests/NetworkStatsIntegrationTest.kt
@@ -44,7 +44,7 @@ import com.android.server.net.integrationtests.NetworkStatsIntegrationTest.Direc
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
 import com.android.testutils.DevSdkIgnoreRunner
 import com.android.testutils.PacketBridge
-import com.android.testutils.RecorderCallback.CallbackEntry.LinkPropertiesChanged
+import com.android.testutils.TestableNetworkCallback.Event.LinkPropertiesChanged
 import com.android.testutils.TestDnsServer
 import com.android.testutils.TestHttpServer
 import com.android.testutils.TestableNetworkCallback
diff --git a/tests/unit/java/android/net/EthernetConfigurationTest.java b/tests/unit/java/android/net/EthernetConfigurationTest.java
new file mode 100644
index 0000000000..30c0d7c5ed
--- /dev/null
+++ b/tests/unit/java/android/net/EthernetConfigurationTest.java
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.net;
+
+import static com.android.testutils.ParcelUtils.assertParcelingIsLossless;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.assertTrue;
+
+import android.os.Build;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.modules.utils.build.SdkLevel;
+import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo;
+import com.android.testutils.DevSdkIgnoreRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.net.InetAddress;
+import java.util.ArrayList;
+
+@SmallTest
+@IgnoreUpTo(Build.VERSION_CODES.S_V2)
+@RunWith(DevSdkIgnoreRunner.class)
+public class EthernetConfigurationTest {
+    // Setup 2 different IP configurations for building different ethernet configurations.
+    private IpConfiguration mIpConfiguration1;
+    private IpConfiguration mIpConfiguration2;
+    private NetworkCapabilities mNetworkCapabilities;
+
+    @Before
+    public void setUp() {
+        LinkAddress linkAddr = new LinkAddress("192.168.1.100/25");
+        InetAddress gateway = InetAddresses.parseNumericAddress("192.168.1.1");
+        InetAddress dns1 = InetAddresses.parseNumericAddress("8.8.8.8");
+        InetAddress dns2 = InetAddresses.parseNumericAddress("8.8.4.4");
+        ArrayList<InetAddress> dnsServers = new ArrayList<>();
+        dnsServers.add(dns1);
+        dnsServers.add(dns2);
+        StaticIpConfiguration staticIpConfig = new StaticIpConfiguration.Builder()
+                .setIpAddress(linkAddr)
+                .setGateway(gateway)
+                .setDnsServers(dnsServers)
+                .build();
+        ProxyInfo proxy1 = ProxyInfo.buildDirectProxy("test1", 8888);
+        ProxyInfo proxy2 = ProxyInfo.buildDirectProxy("test2", 8888);
+
+        mIpConfiguration1 = new IpConfiguration.Builder()
+                .setStaticIpConfiguration(staticIpConfig)
+                .setHttpProxy(proxy1)
+                .build();
+        mIpConfiguration2 = new IpConfiguration.Builder()
+                .setStaticIpConfiguration(staticIpConfig)
+                .setHttpProxy(proxy2)
+                .build();
+
+        mNetworkCapabilities = new NetworkCapabilities.Builder()
+                .addTransportType(NetworkCapabilities.TRANSPORT_ETHERNET)
+                .build();
+    }
+
+    private void assertIpConfigurationEqual(IpConfiguration source, IpConfiguration target) {
+        assertEquals(source.getIpAssignment(), target.getIpAssignment());
+        assertEquals(source.getProxySettings(), target.getProxySettings());
+        assertEquals(source.getHttpProxy(), target.getHttpProxy());
+        assertEquals(source.getStaticIpConfiguration(), target.getStaticIpConfiguration());
+    }
+
+    private void assertNetworkCapabilitiesEqual(
+            NetworkCapabilities source, NetworkCapabilities target) {
+        assertTrue(source.equalsNetCapabilities(target));
+    }
+
+    @Test
+    public void testConstructor() {
+        EthernetConfiguration config =
+                new EthernetConfiguration(mIpConfiguration1, mNetworkCapabilities);
+        assertIpConfigurationEqual(config.getIpConfiguration(), mIpConfiguration1);
+        assertNetworkCapabilitiesEqual(config.getNetworkCapabilities(), mNetworkCapabilities);
+    }
+
+    @Test
+    public void testConstructorWithNullIpConfig() {
+        assertThrows(NullPointerException.class,
+                () -> new EthernetConfiguration(null, mNetworkCapabilities));
+    }
+
+    @Test
+    public void testConstructorWithNulNetCapabilities() {
+        assertThrows(NullPointerException.class,
+                () -> new EthernetConfiguration(mIpConfiguration1, null));
+    }
+
+    @Test
+    public void testHashCodeConsistency() {
+        EthernetConfiguration config =
+                new EthernetConfiguration(mIpConfiguration1, mNetworkCapabilities);
+        int hash1 = config.hashCode();
+        int hash2 = config.hashCode();
+        assertEquals(hash1, hash2);
+    }
+
+    @Test
+    public void testHashCodeOfDifferentConfig() {
+        EthernetConfiguration config1 =
+                new EthernetConfiguration(mIpConfiguration1, mNetworkCapabilities);
+        EthernetConfiguration config2 =
+                new EthernetConfiguration(mIpConfiguration2, mNetworkCapabilities);
+        int hash1 = config1.hashCode();
+        int hash2 = config2.hashCode();
+        assertNotEquals(hash1, hash2);
+    }
+
+    @Test
+    public void testHashCodeOfTheSameConfig() {
+        EthernetConfiguration config1 =
+                new EthernetConfiguration(mIpConfiguration1, mNetworkCapabilities);
+        EthernetConfiguration config2 =
+                new EthernetConfiguration(mIpConfiguration1, mNetworkCapabilities);
+        int hash1 = config1.hashCode();
+        int hash2 = config2.hashCode();
+        assertEquals(hash1, hash2);
+    }
+
+    @Test
+    public void testToString() {
+        EthernetConfiguration config =
+                new EthernetConfiguration(mIpConfiguration1, mNetworkCapabilities);
+        String expect;
+        // After version V, NOT_BANDWIDTH_CONSTRAINED is added to network capabiltiies by default
+        // while devices before V do not have this default capability.
+        if (SdkLevel.isAtLeastV()) {
+            expect = "IP configurations: IP assignment: STATIC\n"
+                    + "Static configuration: IP address 192.168.1.100/25 Gateway 192.168.1.1 "
+                    + " DNS servers: [ 8.8.8.8 8.8.4.4 ] Domains \n"
+                    + "Proxy settings: PAC\n"
+                    + "HTTP proxy: [test1] 8888\n"
+                    + "Network capabilities: [ Transports: ETHERNET Capabilities: NOT_RESTRICTED"
+                    + "&TRUSTED&NOT_VPN&NOT_BANDWIDTH_CONSTRAINED UnderlyingNetworks: Null]";
+        } else {
+            expect = "IP configurations: IP assignment: STATIC\n"
+                    + "Static configuration: IP address 192.168.1.100/25 Gateway 192.168.1.1 "
+                    + " DNS servers: [ 8.8.8.8 8.8.4.4 ] Domains \n"
+                    + "Proxy settings: PAC\n"
+                    + "HTTP proxy: [test1] 8888\n"
+                    + "Network capabilities: [ Transports: ETHERNET Capabilities: NOT_RESTRICTED"
+                    + "&TRUSTED&NOT_VPN UnderlyingNetworks: Null]";
+        }
+        assertEquals(config.toString(), expect);
+    }
+
+    @Test
+    public void testParcel() {
+        EthernetConfiguration config =
+                new EthernetConfiguration(mIpConfiguration1, mNetworkCapabilities);
+        assertParcelingIsLossless(config);
+    }
+}
diff --git a/tests/unit/java/android/net/EthernetNetworkUpdateRequestTest.java b/tests/unit/java/android/net/EthernetNetworkUpdateRequestTest.java
index ca9558b7f7..718ca0a73d 100644
--- a/tests/unit/java/android/net/EthernetNetworkUpdateRequestTest.java
+++ b/tests/unit/java/android/net/EthernetNetworkUpdateRequestTest.java
@@ -16,11 +16,12 @@
 
 package android.net;
 
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
 import static com.android.testutils.ParcelUtils.assertParcelingIsLossless;
 
 import static org.junit.Assert.assertThrows;
 
+import android.os.Build;
+
 import com.android.testutils.DevSdkIgnoreRule;
 import com.android.testutils.DevSdkIgnoreRunner;
 
@@ -28,7 +29,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 
 @RunWith(DevSdkIgnoreRunner.class)
-@DevSdkIgnoreRule.IgnoreUpTo(SC_V2)
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 public class EthernetNetworkUpdateRequestTest {
     private IpConfiguration buildIpConfiguration() {
         return new IpConfiguration.Builder().setHttpProxy(
diff --git a/tests/unit/java/android/net/EthernetPortInfoTest.java b/tests/unit/java/android/net/EthernetPortInfoTest.java
new file mode 100644
index 0000000000..6061f091f5
--- /dev/null
+++ b/tests/unit/java/android/net/EthernetPortInfoTest.java
@@ -0,0 +1,245 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.net;
+
+import static com.android.testutils.ParcelUtils.assertParcelingIsLossless;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertThrows;
+
+import android.os.Build;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.modules.utils.build.SdkLevel;
+import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo;
+import com.android.testutils.DevSdkIgnoreRunner;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.net.InetAddress;
+import java.util.ArrayList;
+
+@SmallTest
+@IgnoreUpTo(Build.VERSION_CODES.S_V2)
+@RunWith(DevSdkIgnoreRunner.class)
+public class EthernetPortInfoTest {
+    private final String mTestInterfaceName1 = "eth0";
+    private final MacAddress mTestMacAddress1 = MacAddress.fromString("0A:1B:2C:3D:4E:5F");
+    private final int mTestInterfaceIndex1 = 1;
+
+    private final String mTestInterfaceName2 = "eth1";
+    private final MacAddress mTestMacAddress2 = MacAddress.fromString("DE:AD:BE:EF:00:01");
+    private final int mTestInterfaceIndex2 = 2;
+
+    private EthernetConfiguration mConfig1;
+    private EthernetConfiguration mConfig2;
+    private NetworkCapabilities mNetworkCapabilities;
+    private EthernetPortInfo mEthernetPortInfo1;
+    private EthernetPortInfo mEthernetPortInfo2;
+
+    @Before
+    public void setUp() {
+        LinkAddress linkAddr = new LinkAddress("192.168.1.100/25");
+        InetAddress gateway = InetAddresses.parseNumericAddress("192.168.1.1");
+        InetAddress dns1 = InetAddresses.parseNumericAddress("8.8.8.8");
+        InetAddress dns2 = InetAddresses.parseNumericAddress("8.8.4.4");
+        ArrayList<InetAddress> dnsServers = new ArrayList<>();
+        dnsServers.add(dns1);
+        dnsServers.add(dns2);
+        StaticIpConfiguration staticIpConfig = new StaticIpConfiguration.Builder()
+                .setIpAddress(linkAddr)
+                .setGateway(gateway)
+                .setDnsServers(dnsServers)
+                .build();
+        ProxyInfo proxy1 = ProxyInfo.buildDirectProxy("test1", 8888);
+        ProxyInfo proxy2 = ProxyInfo.buildDirectProxy("test2", 8888);
+
+        IpConfiguration ipConfig1 = new IpConfiguration.Builder()
+                .setStaticIpConfiguration(staticIpConfig)
+                .setHttpProxy(proxy1)
+                .build();
+        IpConfiguration ipConfig2 = new IpConfiguration.Builder()
+                .setStaticIpConfiguration(staticIpConfig)
+                .setHttpProxy(proxy2)
+                .build();
+
+        mNetworkCapabilities = new NetworkCapabilities.Builder()
+                .addTransportType(NetworkCapabilities.TRANSPORT_ETHERNET)
+                .build();
+        mConfig1 = new EthernetConfiguration(ipConfig1, mNetworkCapabilities);
+        mConfig2 = new EthernetConfiguration(ipConfig2, mNetworkCapabilities);
+
+        mEthernetPortInfo1 = new EthernetPortInfo(
+                mTestInterfaceName1, mTestMacAddress1, mTestInterfaceIndex1, mConfig1,
+                EthernetManager.ROLE_CLIENT, EthernetManager.STATE_LINK_UP);
+        mEthernetPortInfo2 = new EthernetPortInfo(
+                mTestInterfaceName2, mTestMacAddress2, mTestInterfaceIndex2, mConfig2,
+                EthernetManager.ROLE_CLIENT, EthernetManager.STATE_LINK_UP);
+    }
+
+    @Test
+    public void testConstructor() {
+        EthernetPortInfo portInfo = new EthernetPortInfo(
+                mTestInterfaceName1, mTestMacAddress1, mTestInterfaceIndex1, mConfig1,
+                EthernetManager.ROLE_CLIENT, EthernetManager.STATE_LINK_UP);
+        assertEquals(portInfo.getInterfaceName(), mTestInterfaceName1);
+        assertEquals(portInfo.getMacAddress(), mTestMacAddress1);
+        assertEquals(portInfo.getInterfaceIndex(), mTestInterfaceIndex1);
+        assertEquals(portInfo.getConfiguration(), mConfig1);
+        assertEquals(portInfo.getMeteredConfiguration(),
+                mNetworkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED));
+        assertEquals(portInfo.getRole(), EthernetManager.ROLE_CLIENT);
+        assertEquals(portInfo.getState(), EthernetManager.STATE_LINK_UP);
+    }
+
+    @Test
+    public void testConstructorWithNullIfname() {
+        assertThrows("All of interface name, MAC address and interface"
+                        + " index need to be valid.",
+                IllegalArgumentException.class,
+                () -> new EthernetPortInfo(
+                        null, mTestMacAddress1, mTestInterfaceIndex1, mConfig1,
+                        EthernetManager.ROLE_CLIENT, EthernetManager.STATE_LINK_UP));
+    }
+
+    @Test
+    public void testConstructorWithEmptyIfname() {
+        assertThrows("All of interface name, MAC address and interface"
+                        + " index need to be valid.",
+                IllegalArgumentException.class,
+                () -> new EthernetPortInfo(
+                        "", mTestMacAddress1, mTestInterfaceIndex1, mConfig1,
+                        EthernetManager.ROLE_CLIENT, EthernetManager.STATE_LINK_UP));
+    }
+
+    @Test
+    public void testConstructorWithNullAddress() {
+        assertThrows("All of interface name, MAC address and interface"
+                        + " index need to be valid.",
+                IllegalArgumentException.class,
+                () -> new EthernetPortInfo(
+                        mTestInterfaceName1, null, mTestInterfaceIndex1, mConfig1,
+                        EthernetManager.ROLE_CLIENT, EthernetManager.STATE_LINK_UP));
+    }
+
+    @Test
+    public void testConstructorWithInvalidIndex() {
+        assertThrows("All of interface name, MAC address and interface"
+                        + " index need to be valid.",
+                IllegalArgumentException.class,
+                () -> new EthernetPortInfo(
+                        mTestInterfaceName1, mTestMacAddress1, 0, mConfig1,
+                        EthernetManager.ROLE_CLIENT, EthernetManager.STATE_LINK_UP));
+    }
+
+    @Test
+    public void testConstructorWithNullConfig() {
+        assertThrows(NullPointerException.class,
+                () -> new EthernetPortInfo(
+                        mTestInterfaceName1, mTestMacAddress1, mTestInterfaceIndex1, null,
+                        EthernetManager.ROLE_CLIENT, EthernetManager.STATE_LINK_UP));
+    }
+
+    @Test
+    public void testConstructorWithInvalidRole() {
+        assertThrows("Interface role is not valid, should be one of "
+                        + "{EthernetManager.ROLE_SERVER, EthernetManager.ROLE_CLIENT, "
+                        + "EthernetManager.ROLE_NONE}.",
+                IllegalArgumentException.class,
+                () -> new EthernetPortInfo(
+                        mTestInterfaceName1, mTestMacAddress1, mTestInterfaceIndex1, mConfig1,
+                        -1, EthernetManager.STATE_LINK_UP));
+    }
+
+    @Test
+    public void testConstructorWithInvalidInterfaceState() {
+        assertThrows("Interface state is not valid, should be one of "
+                        + "{EthernetManager.STATE_ABSENT, EthernetManager.STATE_LINK_DOWN, "
+                        + "EthernetManager.STATE_LINK_UP}.",
+                IllegalArgumentException.class,
+                () -> new EthernetPortInfo(
+                mTestInterfaceName1, mTestMacAddress1, mTestInterfaceIndex1, mConfig1,
+                EthernetManager.ROLE_CLIENT, -1));
+    }
+
+    @Test
+    public void testHashCodeConsistency() {
+        int hash1 = mEthernetPortInfo1.hashCode();
+        int hash2 = mEthernetPortInfo1.hashCode();
+        assertEquals(hash1, hash2);
+    }
+
+    @Test
+    public void testHashCodeOfDifferentConfig() {
+        int hash1 = mEthernetPortInfo1.hashCode();
+        int hash2 = mEthernetPortInfo2.hashCode();
+        assertNotEquals(hash1, hash2);
+    }
+
+    @Test
+    public void testHashCodeOfTheSameConfig() {
+        EthernetPortInfo portInfo1 = new EthernetPortInfo(
+                mTestInterfaceName1, mTestMacAddress1, mTestInterfaceIndex1, mConfig1,
+                EthernetManager.ROLE_CLIENT, EthernetManager.STATE_LINK_UP);
+        EthernetPortInfo portInfo2 = new EthernetPortInfo(
+                mTestInterfaceName1, mTestMacAddress1, mTestInterfaceIndex1, mConfig1,
+                EthernetManager.ROLE_CLIENT, EthernetManager.STATE_LINK_UP);
+        int hash1 = portInfo1.hashCode();
+        int hash2 = portInfo2.hashCode();
+        assertEquals(hash1, hash2);
+    }
+
+    @Test
+    public void testToString() {
+        String expect;
+        // For devices with SDK level at least V, NOT_BANDWIDTH_CONSTRAINED is included as a
+        // default capability.
+        if (SdkLevel.isAtLeastV()) {
+            expect = "Role:1, State:2, Configurations: IP configurations: "
+                    + "IP assignment: STATIC\n"
+                    + "Static configuration: IP address 192.168.1.100/25 Gateway 192.168.1.1 "
+                    + " DNS servers: [ 8.8.8.8 8.8.4.4 ] Domains \n"
+                    + "Proxy settings: PAC\n"
+                    + "HTTP proxy: [test1] 8888\n"
+                    + "Network capabilities: [ Transports: ETHERNET Capabilities: "
+                    + "NOT_RESTRICTED&TRUSTED&NOT_VPN&NOT_BANDWIDTH_CONSTRAINED "
+                    + "UnderlyingNetworks: Null], Interface name:eth0, "
+                    + "MAC address:0a:1b:2c:3d:4e:5f, Interface index:1";
+        } else {
+            expect = "Role:1, State:2, Configurations: IP configurations: "
+                    + "IP assignment: STATIC\n"
+                    + "Static configuration: IP address 192.168.1.100/25 Gateway 192.168.1.1 "
+                    + " DNS servers: [ 8.8.8.8 8.8.4.4 ] Domains \n"
+                    + "Proxy settings: PAC\n"
+                    + "HTTP proxy: [test1] 8888\n"
+                    + "Network capabilities: [ Transports: ETHERNET Capabilities: "
+                    + "NOT_RESTRICTED&TRUSTED&NOT_VPN UnderlyingNetworks: Nu"
+                    + "ll], Interface name:eth0, MAC address:0a:1b:2c:3d:4e:5f, Interface index:1";
+
+        }
+        assertEquals(mEthernetPortInfo1.toString(), expect);
+    }
+
+    @Test
+    public void testParcel() {
+        assertParcelingIsLossless(mEthernetPortInfo1);
+    }
+}
diff --git a/tests/unit/java/android/net/NetworkIdentitySetTest.kt b/tests/unit/java/android/net/NetworkIdentitySetTest.kt
index d61ebf97be..cf94e84d4c 100644
--- a/tests/unit/java/android/net/NetworkIdentitySetTest.kt
+++ b/tests/unit/java/android/net/NetworkIdentitySetTest.kt
@@ -17,15 +17,32 @@
 package android.net
 
 import android.content.Context
+import android.net.ConnectivityManager.TYPE_BLUETOOTH
+import android.net.ConnectivityManager.TYPE_ETHERNET
 import android.net.ConnectivityManager.TYPE_MOBILE
+import android.net.ConnectivityManager.TYPE_VPN
+import android.net.ConnectivityManager.TYPE_WIFI
+import android.net.ConnectivityManager.TYPE_WIMAX
+import android.net.NetworkCapabilities.TRANSPORT_BLUETOOTH
+import android.net.NetworkCapabilities.TRANSPORT_CELLULAR
+import android.net.NetworkCapabilities.TRANSPORT_ETHERNET
+import android.net.NetworkCapabilities.TRANSPORT_TEST
+import android.net.NetworkCapabilities.TRANSPORT_VPN
+import android.net.NetworkCapabilities.TRANSPORT_WIFI
+import android.net.NetworkIdentitySet.writeOptionalString
 import android.os.Build
 import android.telephony.TelephonyManager
+import com.android.net.module.util.NetworkCapabilitiesUtils.TYPE_TEST
 import com.android.testutils.DevSdkIgnoreRule
 import com.android.testutils.DevSdkIgnoreRunner
+import java.io.ByteArrayInputStream
+import java.io.ByteArrayOutputStream
+import java.io.DataInputStream
+import java.io.DataOutputStream
+import kotlin.test.assertEquals
 import org.junit.Test
 import org.junit.runner.RunWith
 import org.mockito.Mockito.mock
-import kotlin.test.assertEquals
 
 private const val TEST_IMSI1 = "testimsi1"
 
@@ -34,22 +51,54 @@ private const val TEST_IMSI1 = "testimsi1"
 class NetworkIdentitySetTest {
     private val mockContext = mock(Context::class.java)
 
-    private fun buildMobileNetworkStateSnapshot(
-        caps: NetworkCapabilities,
-        subscriberId: String
+    private fun buildMobileNetworkStateSnapshot(subscriberId: String) =
+            buildNetworkStateSnapshot(NetworkCapabilities(), subscriberId, TYPE_MOBILE)
+
+    private fun buildNetworkStateSnapshot(
+            caps: NetworkCapabilities,
+            subscriberId: String,
+            legacyNetworkType: Int
     ): NetworkStateSnapshot {
-        return NetworkStateSnapshot(mock(Network::class.java), caps,
-                LinkProperties(), subscriberId, TYPE_MOBILE)
+        return NetworkStateSnapshot(
+                mock(Network::class.java),
+                caps,
+                LinkProperties(),
+                subscriberId,
+                legacyNetworkType
+        )
+    }
+
+    private fun buildNetworkIdentity(
+            legacyNetworkType: Int,
+            vararg transportTypes: Int
+    ): NetworkIdentity {
+        val caps = NetworkCapabilities().apply {
+            transportTypes.forEach {
+                addTransportType(it)
+            }
+        }
+        return NetworkIdentity.buildNetworkIdentity(
+                mockContext,
+                buildNetworkStateSnapshot(caps, TEST_IMSI1, legacyNetworkType),
+                false,
+                0
+        )
     }
 
     @Test
     fun testCompare() {
-        val ident1 = NetworkIdentity.buildNetworkIdentity(mockContext,
-            buildMobileNetworkStateSnapshot(NetworkCapabilities(), TEST_IMSI1),
-            false /* defaultNetwork */, TelephonyManager.NETWORK_TYPE_UMTS)
-        val ident2 = NetworkIdentity.buildNetworkIdentity(mockContext,
-            buildMobileNetworkStateSnapshot(NetworkCapabilities(), TEST_IMSI1),
-            true /* defaultNetwork */, TelephonyManager.NETWORK_TYPE_UMTS)
+        val ident1 = NetworkIdentity.buildNetworkIdentity(
+                mockContext,
+                buildMobileNetworkStateSnapshot(TEST_IMSI1),
+                false /* defaultNetwork */,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
+        val ident2 = NetworkIdentity.buildNetworkIdentity(
+                mockContext,
+                buildMobileNetworkStateSnapshot(TEST_IMSI1),
+                true /* defaultNetwork */,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
 
         // Verify that the results of comparing two empty sets are equal
         assertEquals(0, NetworkIdentitySet.compare(NetworkIdentitySet(), NetworkIdentitySet()))
@@ -63,4 +112,76 @@ class NetworkIdentitySetTest {
         assertEquals(0, NetworkIdentitySet.compare(identSet1, identSet1))
         assertEquals(-1, NetworkIdentitySet.compare(identSet1, identSet2))
     }
+
+    @Test
+    fun testTransportTypesSerialization() {
+        val originalSet = NetworkIdentitySet()
+        originalSet.add(buildNetworkIdentity(TYPE_MOBILE, TRANSPORT_CELLULAR))
+        originalSet.add(buildNetworkIdentity(TYPE_WIFI, TRANSPORT_VPN, TRANSPORT_WIFI))
+
+        val baos = ByteArrayOutputStream()
+        val outDataStream = DataOutputStream(baos)
+        originalSet.writeToStream(outDataStream)
+
+        val bais = ByteArrayInputStream(baos.toByteArray())
+        val inDataStream = DataInputStream(bais)
+        val deserializedSet = NetworkIdentitySet(inDataStream)
+
+        assertEquals(originalSet, deserializedSet)
+    }
+
+    /**
+     * Writes a single NetworkIdentity to the stream in a specific older version format.
+     * This simulates an old saved state.
+     * Version: VERSION_ADD_SUB_ID (7), which does NOT include transportTypesBits explicitly.
+     */
+    private fun writeNetworkIdentityV7(out: DataOutputStream, ident: NetworkIdentity) {
+        out.writeInt(7) // Write the old version number
+        out.writeInt(1) // Number of identities in the set
+        out.writeInt(ident.type)
+        out.writeInt(ident.ratType)
+        writeOptionalString(out, ident.subscriberId)
+        writeOptionalString(out, ident.wifiNetworkKey)
+        out.writeBoolean(ident.isRoaming)
+        out.writeBoolean(ident.isMetered)
+        out.writeBoolean(ident.isDefaultNetwork)
+        out.writeInt(ident.oemManaged)
+        out.writeInt(ident.subId)
+        // V7 and earlier versions DO NOT write transportTypesBits
+    }
+
+    @Test
+    fun testMigrateToSupportTransportTypes() {
+        doTestMigrateToSupportTransportTypes(TYPE_MOBILE, TRANSPORT_CELLULAR)
+        doTestMigrateToSupportTransportTypes(TYPE_WIFI, TRANSPORT_WIFI)
+        doTestMigrateToSupportTransportTypes(TYPE_BLUETOOTH, TRANSPORT_BLUETOOTH)
+        doTestMigrateToSupportTransportTypes(TYPE_ETHERNET, TRANSPORT_ETHERNET)
+        doTestMigrateToSupportTransportTypes(TYPE_VPN, TRANSPORT_VPN)
+        doTestMigrateToSupportTransportTypes(TYPE_TEST, TRANSPORT_TEST)
+        doTestMigrateToSupportTransportTypes(TYPE_WIMAX)
+    }
+
+    private fun doTestMigrateToSupportTransportTypes(
+            legacyNetworkType: Int,
+            vararg expectedTransportTypes: Int
+    ) {
+        val ident = buildNetworkIdentity(legacyNetworkType)
+
+        val baos = ByteArrayOutputStream()
+        val outDataStream = DataOutputStream(baos)
+        writeNetworkIdentityV7(outDataStream, ident)
+
+        val bais = ByteArrayInputStream(baos.toByteArray())
+        val inDataStream = DataInputStream(bais)
+        val deserializedSet = NetworkIdentitySet(inDataStream)
+
+        // Prepare the expected identity set, verify the transport type deduced from
+        // the legacy network type.
+        val expectedIdent = buildNetworkIdentity(legacyNetworkType, *expectedTransportTypes)
+        val expectedSet = NetworkIdentitySet().also {
+            it.add(expectedIdent)
+        }
+
+        assertEquals(expectedSet, deserializedSet)
+    }
 }
diff --git a/tests/unit/java/android/net/NetworkIdentityTest.kt b/tests/unit/java/android/net/NetworkIdentityTest.kt
index 9667f8fbd3..60f35c270d 100644
--- a/tests/unit/java/android/net/NetworkIdentityTest.kt
+++ b/tests/unit/java/android/net/NetworkIdentityTest.kt
@@ -16,6 +16,7 @@
 
 package android.net
 
+import android.app.usage.NetworkStatsManager
 import android.content.Context
 import android.net.ConnectivityManager.MAX_NETWORK_TYPE
 import android.net.ConnectivityManager.TYPE_ETHERNET
@@ -23,22 +24,26 @@ import android.net.ConnectivityManager.TYPE_MOBILE
 import android.net.ConnectivityManager.TYPE_NONE
 import android.net.ConnectivityManager.TYPE_WIFI
 import android.net.NetworkCapabilities.TRANSPORT_CELLULAR
+import android.net.NetworkCapabilities.TRANSPORT_ETHERNET
+import android.net.NetworkCapabilities.TRANSPORT_SATELLITE
+import android.net.NetworkCapabilities.TRANSPORT_VPN
+import android.net.NetworkCapabilities.TRANSPORT_WIFI
 import android.net.NetworkIdentity.OEM_NONE
 import android.net.NetworkIdentity.OEM_PAID
 import android.net.NetworkIdentity.OEM_PRIVATE
 import android.net.NetworkIdentity.getOemBitfield
-import android.app.usage.NetworkStatsManager
-import android.telephony.TelephonyManager
 import android.os.Build
+import android.telephony.TelephonyManager
+import com.android.net.module.util.BitUtils
 import com.android.testutils.DevSdkIgnoreRule
 import com.android.testutils.DevSdkIgnoreRunner
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.Mockito.mock
 import kotlin.test.assertEquals
 import kotlin.test.assertFailsWith
 import kotlin.test.assertFalse
 import kotlin.test.assertTrue
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.Mockito.mock
 
 private const val TEST_WIFI_KEY = "testwifikey"
 private const val TEST_IMSI1 = "testimsi1"
@@ -52,11 +57,16 @@ class NetworkIdentityTest {
     private val mockContext = mock(Context::class.java)
 
     private fun buildMobileNetworkStateSnapshot(
-        caps: NetworkCapabilities,
-        subscriberId: String
+            caps: NetworkCapabilities,
+            subscriberId: String
     ): NetworkStateSnapshot {
-        return NetworkStateSnapshot(mock(Network::class.java), caps,
-                LinkProperties(), subscriberId, TYPE_MOBILE)
+        return NetworkStateSnapshot(
+                mock(Network::class.java),
+                caps,
+                LinkProperties(),
+                subscriberId,
+                TYPE_MOBILE
+        )
     }
 
     @Test
@@ -87,18 +97,24 @@ class NetworkIdentityTest {
     @Test
     fun testIsMetered() {
         // Verify network is metered.
-        val netIdent1 = NetworkIdentity.buildNetworkIdentity(mockContext,
+        val netIdent1 = NetworkIdentity.buildNetworkIdentity(
+                mockContext,
                 buildMobileNetworkStateSnapshot(NetworkCapabilities(), TEST_IMSI1),
-                false /* defaultNetwork */, TelephonyManager.NETWORK_TYPE_UMTS)
+                false /* defaultNetwork */,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
         assertTrue(netIdent1.isMetered())
 
         // Verify network is not metered because it has NET_CAPABILITY_NOT_METERED capability.
         val capsNotMetered = NetworkCapabilities.Builder().apply {
             addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED)
         }.build()
-        val netIdent2 = NetworkIdentity.buildNetworkIdentity(mockContext,
+        val netIdent2 = NetworkIdentity.buildNetworkIdentity(
+                mockContext,
                 buildMobileNetworkStateSnapshot(capsNotMetered, TEST_IMSI1),
-                false /* defaultNetwork */, TelephonyManager.NETWORK_TYPE_UMTS)
+                false /* defaultNetwork */,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
         assertFalse(netIdent2.isMetered())
 
         // In current design, a network that has NET_CAPABILITY_TEMPORARILY_NOT_METERED
@@ -106,9 +122,12 @@ class NetworkIdentityTest {
         val capsTempNotMetered = NetworkCapabilities().apply {
             setCapability(NetworkCapabilities.NET_CAPABILITY_TEMPORARILY_NOT_METERED, true)
         }
-        val netIdent3 = NetworkIdentity.buildNetworkIdentity(mockContext,
+        val netIdent3 = NetworkIdentity.buildNetworkIdentity(
+                mockContext,
                 buildMobileNetworkStateSnapshot(capsTempNotMetered, TEST_IMSI1),
-                false /* defaultNetwork */, TelephonyManager.NETWORK_TYPE_UMTS)
+                false /* defaultNetwork */,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
         assertTrue(netIdent3.isMetered())
     }
 
@@ -122,15 +141,20 @@ class NetworkIdentityTest {
             setNetworkSpecifier(specifier1)
         }
         val identFromSnapshot = NetworkIdentity.Builder().setNetworkStateSnapshot(
-                buildMobileNetworkStateSnapshot(oemPrivateRoamingNotMeteredCap, TEST_IMSI1))
+                buildMobileNetworkStateSnapshot(oemPrivateRoamingNotMeteredCap, TEST_IMSI1)
+        )
                 .setDefaultNetwork(true)
                 .setRatType(TelephonyManager.NETWORK_TYPE_UMTS)
                 .setSubId(TEST_SUBID1)
                 .build()
-        val identFromLegacyBuild = NetworkIdentity.buildNetworkIdentity(mockContext,
+        val identFromLegacyBuild = NetworkIdentity.buildNetworkIdentity(
+                mockContext,
                 buildMobileNetworkStateSnapshot(oemPrivateRoamingNotMeteredCap, TEST_IMSI1),
-                true /* defaultNetwork */, TelephonyManager.NETWORK_TYPE_UMTS)
-        val identFromConstructor = NetworkIdentity(TYPE_MOBILE,
+                true /* defaultNetwork */,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
+        val identFromConstructor = NetworkIdentity(
+                TYPE_MOBILE,
                 TelephonyManager.NETWORK_TYPE_UMTS,
                 TEST_IMSI1,
                 null /* wifiNetworkKey */,
@@ -138,7 +162,9 @@ class NetworkIdentityTest {
                 false /* metered */,
                 true /* defaultNetwork */,
                 NetworkTemplate.OEM_MANAGED_PRIVATE,
-                TEST_SUBID1)
+                TEST_SUBID1,
+                BitUtils.packBits(intArrayOf(TRANSPORT_CELLULAR))
+        )
         assertEquals(identFromLegacyBuild, identFromSnapshot)
         assertEquals(identFromConstructor, identFromSnapshot)
 
@@ -180,8 +206,12 @@ class NetworkIdentityTest {
     @Test
     fun testBuilder_ratType() {
         // Assert illegal ratTypes cannot make an identity.
-        listOf(Integer.MIN_VALUE, NetworkTemplate.NETWORK_TYPE_ALL,
-                NetworkStatsManager.NETWORK_TYPE_5G_NSA - 1, Integer.MAX_VALUE)
+        listOf(
+                Integer.MIN_VALUE,
+                NetworkTemplate.NETWORK_TYPE_ALL,
+                NetworkStatsManager.NETWORK_TYPE_5G_NSA - 1,
+                Integer.MAX_VALUE
+        )
                 .forEach {
                     assertFailsWith<IllegalArgumentException> {
                         NetworkIdentity.Builder()
@@ -208,8 +238,12 @@ class NetworkIdentityTest {
     @Test
     fun testBuilder_oemManaged() {
         // Assert illegal oemManage values cannot make an identity.
-        listOf(Integer.MIN_VALUE, NetworkTemplate.OEM_MANAGED_ALL, NetworkTemplate.OEM_MANAGED_YES,
-                Integer.MAX_VALUE)
+        listOf(
+                Integer.MIN_VALUE,
+                NetworkTemplate.OEM_MANAGED_ALL,
+                NetworkTemplate.OEM_MANAGED_YES,
+                Integer.MAX_VALUE
+        )
                 .forEach { oemManaged ->
                     assertFailsWith<IllegalArgumentException> {
                         NetworkIdentity.Builder()
@@ -220,9 +254,13 @@ class NetworkIdentityTest {
                 }
 
         // Verify legitimate oem managed values can make an identity.
-        listOf(NetworkTemplate.OEM_MANAGED_NO, NetworkTemplate.OEM_MANAGED_PAID,
-                NetworkTemplate.OEM_MANAGED_PRIVATE, NetworkTemplate.OEM_MANAGED_PAID or
-                NetworkTemplate.OEM_MANAGED_PRIVATE)
+        listOf(
+                NetworkTemplate.OEM_MANAGED_NO,
+                NetworkTemplate.OEM_MANAGED_PAID,
+                NetworkTemplate.OEM_MANAGED_PRIVATE,
+                NetworkTemplate.OEM_MANAGED_PAID or
+                NetworkTemplate.OEM_MANAGED_PRIVATE
+        )
                 .forEach { oemManaged ->
                     NetworkIdentity.Builder()
                             .setOemManaged(oemManaged)
@@ -245,14 +283,54 @@ class NetworkIdentityTest {
             setNetworkSpecifier(specifier2)
         }
 
-        val netIdent1 = NetworkIdentity.buildNetworkIdentity(mockContext,
+        val netIdent1 = NetworkIdentity.buildNetworkIdentity(
+                mockContext,
                 buildMobileNetworkStateSnapshot(capSUBID1, TEST_IMSI1),
-                false /* defaultNetwork */, TelephonyManager.NETWORK_TYPE_UMTS)
+                false,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
         assertEquals(TEST_SUBID1, netIdent1.getSubId())
 
-        val netIdent2 = NetworkIdentity.buildNetworkIdentity(mockContext,
+        val netIdent2 = NetworkIdentity.buildNetworkIdentity(
+                mockContext,
                 buildMobileNetworkStateSnapshot(capSUBID2, TEST_IMSI2),
-                false /* defaultNetwork */, TelephonyManager.NETWORK_TYPE_UMTS)
+                false,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
         assertEquals(TEST_SUBID2, netIdent2.getSubId())
     }
+
+    @Test
+    fun testSetTransportTypes() {
+        doTestSetTransportTypes(setOf())
+        doTestSetTransportTypes(setOf(TRANSPORT_WIFI))
+        doTestSetTransportTypes(setOf(TRANSPORT_CELLULAR, TRANSPORT_VPN, TRANSPORT_ETHERNET))
+    }
+
+    private fun doTestSetTransportTypes(transportTypes: Set<Int>) {
+        val identity = NetworkIdentity.Builder()
+                .setType(TYPE_MOBILE) // legacy type, for builder compatibility
+                .setTransportTypes(transportTypes)
+                .build()
+        assertEquals(transportTypes.toSet(), identity.transportTypes)
+    }
+
+    @Test
+    fun testTransportTypes_fromNetworkStateSnapshot() {
+        val caps = NetworkCapabilities().apply {
+            addTransportType(TRANSPORT_SATELLITE)
+            addTransportType(TRANSPORT_VPN)
+            addTransportType(TRANSPORT_WIFI)
+        }
+        val identity = NetworkIdentity.buildNetworkIdentity(
+                mockContext,
+                buildMobileNetworkStateSnapshot(caps, TEST_IMSI1),
+                false,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
+        assertEquals(
+                setOf(TRANSPORT_SATELLITE, TRANSPORT_VPN, TRANSPORT_WIFI),
+                identity.transportTypes
+        )
+    }
 }
diff --git a/tests/unit/java/android/net/NetworkStatsAccessTest.java b/tests/unit/java/android/net/NetworkStatsAccessTest.java
index 8b86211112..616faeae44 100644
--- a/tests/unit/java/android/net/NetworkStatsAccessTest.java
+++ b/tests/unit/java/android/net/NetworkStatsAccessTest.java
@@ -16,8 +16,6 @@
 
 package android.net;
 
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
-
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Mockito.doCallRealMethod;
 import static org.mockito.Mockito.when;
@@ -28,6 +26,7 @@ import android.app.AppOpsManager;
 import android.app.admin.DevicePolicyManager;
 import android.content.Context;
 import android.content.pm.PackageManager;
+import android.os.Build;
 import android.telephony.TelephonyManager;
 
 import androidx.test.filters.SmallTest;
@@ -44,7 +43,7 @@ import org.mockito.MockitoAnnotations;
 
 @RunWith(DevSdkIgnoreRunner.class)
 @SmallTest
-@DevSdkIgnoreRule.IgnoreUpTo(SC_V2) // TODO: Use to Build.VERSION_CODES.SC_V2 when available
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 public class NetworkStatsAccessTest {
     private static final String TEST_PKG = "com.example.test";
     private static final int TEST_PID = 1234;
diff --git a/tests/unit/java/android/net/NetworkStatsCollectionTest.java b/tests/unit/java/android/net/NetworkStatsCollectionTest.java
index 81557f85c5..5d6f980772 100644
--- a/tests/unit/java/android/net/NetworkStatsCollectionTest.java
+++ b/tests/unit/java/android/net/NetworkStatsCollectionTest.java
@@ -17,6 +17,7 @@
 package android.net;
 
 import static android.net.ConnectivityManager.TYPE_MOBILE;
+import static android.net.NetworkCapabilities.TRANSPORT_CELLULAR;
 import static android.net.NetworkIdentity.OEM_NONE;
 import static android.net.NetworkStats.DEFAULT_NETWORK_NO;
 import static android.net.NetworkStats.IFACE_ALL;
@@ -33,7 +34,6 @@ import static android.text.format.DateUtils.HOUR_IN_MILLIS;
 import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
 
 import static com.android.net.module.util.NetworkStatsUtils.multiplySafeByRational;
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
 import static com.android.testutils.MiscAsserts.assertThrows;
 
 import static org.junit.Assert.assertArrayEquals;
@@ -44,6 +44,7 @@ import static org.junit.Assert.fail;
 import android.annotation.NonNull;
 import android.content.res.Resources;
 import android.net.NetworkStatsCollection.Key;
+import android.os.Build;
 import android.os.Process;
 import android.os.UserHandle;
 import android.telephony.SubscriptionPlan;
@@ -56,6 +57,7 @@ import androidx.test.InstrumentationRegistry;
 import androidx.test.filters.SmallTest;
 
 import com.android.frameworks.tests.net.R;
+import com.android.net.module.util.BitUtils;
 import com.android.testutils.DevSdkIgnoreRule;
 import com.android.testutils.DevSdkIgnoreRunner;
 
@@ -89,7 +91,7 @@ import java.util.Set;
  */
 @RunWith(DevSdkIgnoreRunner.class)
 @SmallTest
-@DevSdkIgnoreRule.IgnoreUpTo(SC_V2) // TODO: Use to Build.VERSION_CODES.SC_V2 when available
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 public class NetworkStatsCollectionTest {
     @Rule
     public final DevSdkIgnoreRule ignoreRule = new DevSdkIgnoreRule();
@@ -249,7 +251,8 @@ public class NetworkStatsCollectionTest {
         final NetworkStats.Entry entry = new NetworkStats.Entry();
         final NetworkIdentitySet identSet = new NetworkIdentitySet();
         identSet.add(new NetworkIdentity(TYPE_MOBILE, TelephonyManager.NETWORK_TYPE_UNKNOWN,
-                TEST_IMSI, null, false, true, true, OEM_NONE, TEST_SUBID));
+                TEST_IMSI, null, false, true, true, OEM_NONE, TEST_SUBID,
+                BitUtils.packBits(new int[]{TRANSPORT_CELLULAR})));
 
         int myUid = Process.myUid();
         int otherUidInSameUser = Process.myUid() + 1;
@@ -511,7 +514,8 @@ public class NetworkStatsCollectionTest {
         final NetworkStatsCollection large = new NetworkStatsCollection(HOUR_IN_MILLIS);
         final NetworkIdentitySet ident = new NetworkIdentitySet();
         ident.add(new NetworkIdentity(ConnectivityManager.TYPE_MOBILE, -1, TEST_IMSI, null,
-                false, true, true, OEM_NONE, TEST_SUBID));
+                false, true, true, OEM_NONE, TEST_SUBID,
+                BitUtils.packBits(new int[] {TRANSPORT_CELLULAR})));
         large.recordData(ident, UID_ALL, SET_ALL, TAG_NONE, TIME_A, TIME_B,
                 new NetworkStats.Entry(IFACE_ALL, UID_ALL, SET_DEFAULT, TAG_NONE, METERED_NO,
                 ROAMING_NO, DEFAULT_NETWORK_NO, 12_730_893_164L, 1, 0, 0, 0));
diff --git a/tests/unit/java/android/net/NetworkStatsRecorderTest.java b/tests/unit/java/android/net/NetworkStatsRecorderTest.java
index 7d039b6e02..a0b36bb0e9 100644
--- a/tests/unit/java/android/net/NetworkStatsRecorderTest.java
+++ b/tests/unit/java/android/net/NetworkStatsRecorderTest.java
@@ -27,7 +27,6 @@ import static android.text.format.DateUtils.HOUR_IN_MILLIS;
 import static com.android.server.ConnectivityStatsLog.NETWORK_STATS_RECORDER_FILE_OPERATED__RECORDER_PREFIX__PREFIX_UID;
 import static com.android.server.ConnectivityStatsLog.NETWORK_STATS_RECORDER_FILE_OPERATED__RECORDER_PREFIX__PREFIX_UIDTAG;
 import static com.android.server.ConnectivityStatsLog.NETWORK_STATS_RECORDER_FILE_OPERATED__RECORDER_PREFIX__PREFIX_XT;
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
 
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.anyLong;
@@ -43,6 +42,7 @@ import android.net.NetworkIdentity;
 import android.net.NetworkIdentitySet;
 import android.net.NetworkStats;
 import android.net.NetworkStatsCollection;
+import android.os.Build;
 import android.os.DropBoxManager;
 
 import androidx.test.filters.SmallTest;
@@ -67,7 +67,7 @@ import java.io.IOException;
 
 @RunWith(DevSdkIgnoreRunner.class)
 @SmallTest
-@DevSdkIgnoreRule.IgnoreUpTo(SC_V2)
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 public final class NetworkStatsRecorderTest {
     private static final String TAG = NetworkStatsRecorderTest.class.getSimpleName();
 
diff --git a/tests/unit/java/android/net/NetworkStatsTest.java b/tests/unit/java/android/net/NetworkStatsTest.java
index 70ddc17242..ca88f6d627 100644
--- a/tests/unit/java/android/net/NetworkStatsTest.java
+++ b/tests/unit/java/android/net/NetworkStatsTest.java
@@ -42,6 +42,7 @@ import static org.junit.Assert.assertTrue;
 
 import android.os.Build;
 import android.os.Process;
+import android.os.Trace;
 import android.util.ArrayMap;
 
 import androidx.test.filters.SmallTest;
@@ -844,6 +845,66 @@ public class NetworkStatsTest {
         assertEquals(entry3, stats.getValues(1, null));
     }
 
+    @Test
+    public void testFilteredClone() {
+        final int testUid = 10101;
+        NetworkStats.Entry entry1 = new NetworkStats.Entry(
+                "test1", 10100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO,
+                DEFAULT_NETWORK_NO, 50000L, 25L, 100000L, 50L, 0L);
+
+        NetworkStats.Entry entry2 = new NetworkStats.Entry(
+                "test2", testUid, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO,
+                DEFAULT_NETWORK_NO, 50000L, 25L, 100000L, 50L, 0L);
+
+        NetworkStats.Entry entry3 = new NetworkStats.Entry(
+                "test3", testUid, SET_DEFAULT, 123, METERED_NO, ROAMING_NO,
+                DEFAULT_NETWORK_NO, 50000L, 25L, 100000L, 50L, 0L);
+
+        NetworkStats stats = new NetworkStats(TEST_START, 3)
+                .insertEntry(entry1)
+                .insertEntry(entry2)
+                .insertEntry(entry3);
+
+        NetworkStats filtered = stats.filteredClone(testUid, INTERFACES_ALL, TAG_ALL);
+
+        assertEquals(3, stats.size());
+        assertEquals(entry1, stats.getValues(0, null));
+        assertEquals(entry2, stats.getValues(1, null));
+        assertEquals(entry3, stats.getValues(2, null));
+
+        assertEquals(2, filtered.size());
+        assertEquals(entry2, filtered.getValues(0, null));
+        assertEquals(entry3, filtered.getValues(1, null));
+    }
+
+    @Test
+    public void testFilteredPerformance() {
+        final int size = 100000;
+        NetworkStats stats = new NetworkStats(TEST_START, size);
+        for (int i = 0; i < size; ++i) {
+          NetworkStats.Entry entry = new NetworkStats.Entry(
+              "test", 10100 + i % 100, SET_DEFAULT, i % 2, METERED_NO, ROAMING_NO,
+              DEFAULT_NETWORK_NO, 50000L, 25L, 100000L, 50L, 0L);
+          stats.insertEntry(entry);
+        }
+
+        final int iterations = 1000;
+        final int filterTag = 0;
+        final int filterUid = 10100;
+
+        Trace.beginSection("MajorityFilter");
+        for (int i = 0; i < iterations; ++i) {
+          stats.filteredClone(UID_ALL, INTERFACES_ALL, filterTag);
+        }
+        Trace.endSection();
+
+        Trace.beginSection("MinorityFilter");
+        for (int i = 0; i < iterations; ++i) {
+          stats.filteredClone(filterUid, INTERFACES_ALL, TAG_ALL);
+        }
+        Trace.endSection();
+    }
+
     @Test
     public void testFilter_InterfaceFilter() {
         final String testIf1 = "testif1";
diff --git a/tests/unit/java/android/net/NetworkTemplateTest.kt b/tests/unit/java/android/net/NetworkTemplateTest.kt
index a8414ca8a9..1435cd01e7 100644
--- a/tests/unit/java/android/net/NetworkTemplateTest.kt
+++ b/tests/unit/java/android/net/NetworkTemplateTest.kt
@@ -21,7 +21,10 @@ import android.content.Context
 import android.net.ConnectivityManager.TYPE_MOBILE
 import android.net.ConnectivityManager.TYPE_TEST
 import android.net.ConnectivityManager.TYPE_WIFI
+import android.net.NetworkCapabilities.TRANSPORT_CELLULAR
+import android.net.NetworkCapabilities.TRANSPORT_SATELLITE
 import android.net.NetworkCapabilities.TRANSPORT_TEST
+import android.net.NetworkCapabilities.TRANSPORT_VPN
 import android.net.NetworkCapabilities.TRANSPORT_WIFI
 import android.net.NetworkIdentity.OEM_NONE
 import android.net.NetworkIdentity.OEM_PAID
@@ -40,6 +43,7 @@ import android.net.NetworkTemplate.NETWORK_TYPE_ALL
 import android.net.NetworkTemplate.OEM_MANAGED_ALL
 import android.net.NetworkTemplate.OEM_MANAGED_NO
 import android.net.NetworkTemplate.OEM_MANAGED_YES
+import android.net.NetworkTemplate.TRANSPORT_TYPES_ALL
 import android.net.NetworkTemplate.buildTemplateMobileAll
 import android.net.NetworkTemplate.buildTemplateMobileWildcard
 import android.net.NetworkTemplate.buildTemplateWifiWildcard
@@ -79,26 +83,37 @@ class NetworkTemplateTest {
 
     private fun buildMobileNetworkState(subscriberId: String): NetworkStateSnapshot =
             buildNetworkState(TYPE_MOBILE, subscriberId = subscriberId)
-    private fun buildWifiNetworkState(subscriberId: String?, wifiKey: String?):
-            NetworkStateSnapshot = buildNetworkState(TYPE_WIFI,
-            subscriberId = subscriberId, wifiKey = wifiKey)
+    private fun buildWifiNetworkState(
+            subscriberId: String?,
+            wifiKey: String?
+    ): NetworkStateSnapshot = buildNetworkState(
+            TYPE_WIFI,
+            subscriberId = subscriberId,
+            wifiKey = wifiKey
+    )
 
     private fun buildNetworkState(
-        type: Int,
-        subscriberId: String? = null,
-        wifiKey: String? = null,
-        oemManaged: Int = OEM_NONE,
-        metered: Boolean = true
+            type: Int,
+            subscriberId: String? = null,
+            wifiKey: String? = null,
+            oemManaged: Int = OEM_NONE,
+            metered: Boolean = true,
+            transportTypes: IntArray = intArrayOf(),
     ): NetworkStateSnapshot {
         `when`(mockWifiInfo.getNetworkKey()).thenReturn(wifiKey)
         val lp = LinkProperties()
         val caps = NetworkCapabilities().apply {
             setCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED, !metered)
             setCapability(NetworkCapabilities.NET_CAPABILITY_NOT_ROAMING, true)
-            setCapability(NetworkCapabilities.NET_CAPABILITY_OEM_PAID,
-                    (oemManaged and OEM_PAID) == OEM_PAID)
-            setCapability(NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE,
-                    (oemManaged and OEM_PRIVATE) == OEM_PRIVATE)
+            setCapability(
+                    NetworkCapabilities.NET_CAPABILITY_OEM_PAID,
+                    (oemManaged and OEM_PAID) == OEM_PAID
+            )
+            setCapability(
+                    NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE,
+                    (oemManaged and OEM_PRIVATE) == OEM_PRIVATE
+            )
+            setTransportTypes(transportTypes)
             if (type == TYPE_TEST) {
                 wifiKey?.let { TestNetworkSpecifier(it) }?.let {
                     // Must have a single non-test transport specified to use setNetworkSpecifier.
@@ -127,19 +142,36 @@ class NetworkTemplateTest {
     fun testWifiWildcardMatches() {
         val templateWifiWildcard = buildTemplateWifiWildcard()
 
-        val identMobileImsi1 = buildNetworkIdentity(mockContext,
+        val identMobileImsi1 = buildNetworkIdentity(
+                mockContext,
                 buildMobileNetworkState(TEST_IMSI1),
-                false, TelephonyManager.NETWORK_TYPE_UMTS)
+                false,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
         val identWifiImsiNullKey1 = buildNetworkIdentity(
-                mockContext, buildWifiNetworkState(null, TEST_WIFI_KEY1), true, 0)
+                mockContext,
+                buildWifiNetworkState(null, TEST_WIFI_KEY1),
+                true,
+                0
+        )
         val identWifiImsi1Key1 = buildNetworkIdentity(
-                mockContext, buildWifiNetworkState(TEST_IMSI1, TEST_WIFI_KEY1), true, 0)
+                mockContext,
+                buildWifiNetworkState(TEST_IMSI1, TEST_WIFI_KEY1),
+                true,
+                0
+        )
         // This identity with a null wifiNetworkKey is to test matchesWifiNetworkKey won't crash
         // the system when a null wifiNetworkKey is provided, which happens because of a bug in wifi
         // and it should still match the wifi wildcard template. See b/266598304.
         val identWifiNullKey = buildNetworkIdentity(
-                mockContext, buildWifiNetworkState(null /* subscriberId */,
-                null /* wifiNetworkKey */), true, 0)
+                mockContext,
+                buildWifiNetworkState(
+                        null /* subscriberId */,
+                        null /* wifiNetworkKey */
+                ),
+                true,
+                0
+        )
 
         templateWifiWildcard.assertDoesNotMatch(identMobileImsi1)
         templateWifiWildcard.assertMatches(identWifiImsiNullKey1)
@@ -159,26 +191,57 @@ class NetworkTemplateTest {
                 .setWifiNetworkKeys(setOf(TEST_WIFI_KEY1)).build()
         val templateWifiKeyAllImsi1 = NetworkTemplate.Builder(MATCH_WIFI)
                 .setSubscriberIds(setOf(TEST_IMSI1)).build()
-        val templateNullWifiKey = NetworkTemplate(MATCH_WIFI,
-                emptyArray<String>() /* subscriberIds */, arrayOf(null) /* wifiNetworkKeys */,
-                METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, NETWORK_TYPE_ALL, OEM_MANAGED_ALL)
-
-        val identMobile1 = buildNetworkIdentity(mockContext, buildMobileNetworkState(TEST_IMSI1),
-                false, TelephonyManager.NETWORK_TYPE_UMTS)
+        val templateNullWifiKey = NetworkTemplate(
+                MATCH_WIFI,
+                emptyArray<String>() /* subscriberIds */,
+                arrayOf(null) /* wifiNetworkKeys */,
+                METERED_ALL,
+                ROAMING_ALL,
+                DEFAULT_NETWORK_ALL,
+                NETWORK_TYPE_ALL,
+                OEM_MANAGED_ALL,
+                TRANSPORT_TYPES_ALL
+        )
+
+        val identMobile1 = buildNetworkIdentity(
+                mockContext,
+                buildMobileNetworkState(TEST_IMSI1),
+                false,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
         val identWifiImsiNullKey1 = buildNetworkIdentity(
-                mockContext, buildWifiNetworkState(null, TEST_WIFI_KEY1), true, 0)
+                mockContext,
+                buildWifiNetworkState(null, TEST_WIFI_KEY1),
+                true,
+                0
+        )
         val identWifiImsi1Key1 = buildNetworkIdentity(
-                mockContext, buildWifiNetworkState(TEST_IMSI1, TEST_WIFI_KEY1), true, 0)
+                mockContext,
+                buildWifiNetworkState(TEST_IMSI1, TEST_WIFI_KEY1),
+                true,
+                0
+        )
         val identWifiImsi2Key1 = buildNetworkIdentity(
-                mockContext, buildWifiNetworkState(TEST_IMSI2, TEST_WIFI_KEY1), true, 0)
+                mockContext,
+                buildWifiNetworkState(TEST_IMSI2, TEST_WIFI_KEY1),
+                true,
+                0
+        )
         val identWifiImsi1Key2 = buildNetworkIdentity(
-                mockContext, buildWifiNetworkState(TEST_IMSI1, TEST_WIFI_KEY2), true, 0)
+                mockContext,
+                buildWifiNetworkState(TEST_IMSI1, TEST_WIFI_KEY2),
+                true,
+                0
+        )
         // This identity with a null wifiNetworkKey is to test the matchesWifiNetworkKey won't crash
         // the system when a null wifiNetworkKey is provided, which would happen in some unknown
         // cases, see b/266598304.
         val identWifiNullKey = buildNetworkIdentity(
-                mockContext, buildWifiNetworkState(null /* subscriberId */,
-                null /* wifiNetworkKey */), true, 0)
+                mockContext,
+                buildWifiNetworkState(null /* subscriberId */, null /* wifiNetworkKey */),
+                true,
+                0
+        )
 
         // Verify that template with WiFi Network Key only matches any subscriberId and
         // specific WiFi Network Key.
@@ -240,16 +303,33 @@ class NetworkTemplateTest {
                 .setSubscriberIds(setOf(TEST_IMSI2))
                 .setRatType(TelephonyManager.NETWORK_TYPE_UMTS).build()
 
-        val mobileImsi1 = buildNetworkState(TYPE_MOBILE, TEST_IMSI1, null /* wifiKey */,
-                OEM_NONE, true /* metered */)
-        val identMobile1 = buildNetworkIdentity(mockContext, mobileImsi1,
-                false /* defaultNetwork */, TelephonyManager.NETWORK_TYPE_UMTS)
+        val mobileImsi1 = buildNetworkState(
+                TYPE_MOBILE,
+                TEST_IMSI1,
+                null /* wifiKey */,
+                OEM_NONE,
+                true /* metered */
+        )
+        val identMobile1 = buildNetworkIdentity(
+                mockContext,
+                mobileImsi1,
+                false /* defaultNetwork */,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
         val mobileImsi2 = buildMobileNetworkState(TEST_IMSI2)
-        val identMobile2Umts = buildNetworkIdentity(mockContext, mobileImsi2,
-                false /* defaultNetwork */, TelephonyManager.NETWORK_TYPE_UMTS)
+        val identMobile2Umts = buildNetworkIdentity(
+                mockContext,
+                mobileImsi2,
+                false /* defaultNetwork */,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
 
         val identWifiImsi1Key1 = buildNetworkIdentity(
-                mockContext, buildWifiNetworkState(TEST_IMSI1, TEST_WIFI_KEY1), true, 0)
+                mockContext,
+                buildWifiNetworkState(TEST_IMSI1, TEST_WIFI_KEY1),
+                true,
+                0
+        )
 
         // Verify that the template matches type and the subscriberId.
         templateMobileImsi1.assertMatches(identMobile1)
@@ -269,11 +349,19 @@ class NetworkTemplateTest {
         val templateMobileNullImsiWithRatType = NetworkTemplate.Builder(MATCH_MOBILE)
                 .setRatType(TelephonyManager.NETWORK_TYPE_UMTS).build()
         val mobileImsi1 = buildMobileNetworkState(TEST_IMSI1)
-        val identMobile1 = buildNetworkIdentity(mockContext, mobileImsi1,
-                false /* defaultNetwork */, TelephonyManager.NETWORK_TYPE_UMTS)
+        val identMobile1 = buildNetworkIdentity(
+                mockContext,
+                mobileImsi1,
+                false /* defaultNetwork */,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
         val mobileImsi2 = buildMobileNetworkState(TEST_IMSI2)
-        val identMobile2 = buildNetworkIdentity(mockContext, mobileImsi2,
-                false /* defaultNetwork */, TelephonyManager.NETWORK_TYPE_LTE)
+        val identMobile2 = buildNetworkIdentity(
+                mockContext,
+                mobileImsi2,
+                false /* defaultNetwork */,
+                TelephonyManager.NETWORK_TYPE_LTE
+        )
 
         // Verify that the template matches any subscriberId.
         templateMobileWildcard.assertMatches(identMobile1)
@@ -282,7 +370,11 @@ class NetworkTemplateTest {
         templateMobileNullImsiWithRatType.assertDoesNotMatch(identMobile2)
 
         val identWifiImsi1Key1 = buildNetworkIdentity(
-                mockContext, buildWifiNetworkState(TEST_IMSI1, TEST_WIFI_KEY1), true, 0)
+                mockContext,
+                buildWifiNetworkState(TEST_IMSI1, TEST_WIFI_KEY1),
+                true,
+                0
+        )
 
         // Verify that the different type does not match.
         templateMobileWildcard.assertDoesNotMatch(identWifiImsi1Key1)
@@ -297,14 +389,32 @@ class NetworkTemplateTest {
             .setWifiNetworkKeys(setOf(TEST_WIFI_KEY2)).build()
         val templateTestAll = NetworkTemplate.Builder(MATCH_TEST).build()
 
-        val stateWifiKey1 = buildNetworkState(TYPE_WIFI, null /* subscriberId */, TEST_WIFI_KEY1,
-            OEM_NONE, true /* metered */)
-        val stateTestKey1 = buildNetworkState(TYPE_TEST, null /* subscriberId */, TEST_WIFI_KEY1,
-            OEM_NONE, true /* metered */)
-        val identWifi1 = buildNetworkIdentity(mockContext, stateWifiKey1,
-            false /* defaultNetwork */, NetworkTemplate.NETWORK_TYPE_ALL)
-        val identTest1 = buildNetworkIdentity(mockContext, stateTestKey1,
-            false /* defaultNetwork */, NETWORK_TYPE_ALL)
+        val stateWifiKey1 = buildNetworkState(
+                TYPE_WIFI,
+                null /* subscriberId */,
+                TEST_WIFI_KEY1,
+                OEM_NONE,
+                true /* metered */
+        )
+        val stateTestKey1 = buildNetworkState(
+                TYPE_TEST,
+                null /* subscriberId */,
+                TEST_WIFI_KEY1,
+                OEM_NONE,
+                true /* metered */
+        )
+        val identWifi1 = buildNetworkIdentity(
+                mockContext,
+                stateWifiKey1,
+                false /* defaultNetwork */,
+                NETWORK_TYPE_ALL
+        )
+        val identTest1 = buildNetworkIdentity(
+                mockContext,
+                stateTestKey1,
+                false /* defaultNetwork */,
+                NETWORK_TYPE_ALL
+        )
 
         // Verify that the template matches corresponding type and the subscriberId.
         templateTestKey1.assertDoesNotMatch(identWifi1)
@@ -322,28 +432,63 @@ class NetworkTemplateTest {
                 .setSubscriberIds(setOf(TEST_IMSI1)).build()
 
         val mobileImsi1 = buildMobileNetworkState(TEST_IMSI1)
-        val mobileImsi1Unmetered = buildNetworkState(TYPE_MOBILE, TEST_IMSI1,
-                null /* wifiKey */, OEM_NONE, false /* metered */)
+        val mobileImsi1Unmetered = buildNetworkState(
+                TYPE_MOBILE,
+                TEST_IMSI1,
+                null /* wifiKey */,
+                OEM_NONE,
+                false /* metered */
+        )
         val mobileImsi2 = buildMobileNetworkState(TEST_IMSI2)
-        val wifiKey1 = buildWifiNetworkState(null /* subscriberId */,
-                TEST_WIFI_KEY1)
+        val wifiKey1 = buildWifiNetworkState(
+                null /* subscriberId */,
+                TEST_WIFI_KEY1
+        )
         val wifiImsi1Key1 = buildWifiNetworkState(TEST_IMSI1, TEST_WIFI_KEY1)
-        val wifiImsi1Key1Unmetered = buildNetworkState(TYPE_WIFI, TEST_IMSI1,
-                TEST_WIFI_KEY1, OEM_NONE, false /* metered */)
-
-        val identMobileImsi1Metered = buildNetworkIdentity(mockContext,
-                mobileImsi1, false /* defaultNetwork */, TelephonyManager.NETWORK_TYPE_UMTS)
-        val identMobileImsi1Unmetered = buildNetworkIdentity(mockContext,
-                mobileImsi1Unmetered, false /* defaultNetwork */,
-                TelephonyManager.NETWORK_TYPE_UMTS)
-        val identMobileImsi2Metered = buildNetworkIdentity(mockContext,
-                mobileImsi2, false /* defaultNetwork */, TelephonyManager.NETWORK_TYPE_UMTS)
+        val wifiImsi1Key1Unmetered = buildNetworkState(
+                TYPE_WIFI,
+                TEST_IMSI1,
+                TEST_WIFI_KEY1,
+                OEM_NONE,
+                false /* metered */
+        )
+
+        val identMobileImsi1Metered = buildNetworkIdentity(
+                mockContext,
+                mobileImsi1,
+                false /* defaultNetwork */,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
+        val identMobileImsi1Unmetered = buildNetworkIdentity(
+                mockContext,
+                mobileImsi1Unmetered,
+                false /* defaultNetwork */,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
+        val identMobileImsi2Metered = buildNetworkIdentity(
+                mockContext,
+                mobileImsi2,
+                false /* defaultNetwork */,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
         val identWifiKey1Metered = buildNetworkIdentity(
-                mockContext, wifiKey1, true /* defaultNetwork */, 0 /* subType */)
+                mockContext,
+                wifiKey1,
+                true /* defaultNetwork */,
+                0 /* subType */
+        )
         val identCarrierWifiImsi1Metered = buildNetworkIdentity(
-                mockContext, wifiImsi1Key1, true /* defaultNetwork */, 0 /* subType */)
-        val identCarrierWifiImsi1NonMetered = buildNetworkIdentity(mockContext,
-                wifiImsi1Key1Unmetered, true /* defaultNetwork */, 0 /* subType */)
+                mockContext,
+                wifiImsi1Key1,
+                true /* defaultNetwork */,
+                0 /* subType */
+        )
+        val identCarrierWifiImsi1NonMetered = buildNetworkIdentity(
+                mockContext,
+                wifiImsi1Key1Unmetered,
+                true /* defaultNetwork */,
+                0 /* subType */
+        )
 
         templateCarrierImsi1Metered.assertMatches(identMobileImsi1Metered)
         templateCarrierImsi1Metered.assertDoesNotMatch(identMobileImsi1Unmetered)
@@ -357,10 +502,20 @@ class NetworkTemplateTest {
     @Test
     fun testRatTypeGroupMatches() {
         val stateMobileImsi1Metered = buildMobileNetworkState(TEST_IMSI1)
-        val stateMobileImsi1NonMetered = buildNetworkState(TYPE_MOBILE, TEST_IMSI1,
-                null /* wifiKey */, OEM_NONE, false /* metered */)
-        val stateMobileImsi2NonMetered = buildNetworkState(TYPE_MOBILE, TEST_IMSI2,
-                null /* wifiKey */, OEM_NONE, false /* metered */)
+        val stateMobileImsi1NonMetered = buildNetworkState(
+                TYPE_MOBILE,
+                TEST_IMSI1,
+                null /* wifiKey */,
+                OEM_NONE,
+                false /* metered */
+        )
+        val stateMobileImsi2NonMetered = buildNetworkState(
+                TYPE_MOBILE,
+                TEST_IMSI2,
+                null /* wifiKey */,
+                OEM_NONE,
+                false /* metered */
+        )
 
         // Build UMTS template that matches mobile identities with RAT in the same
         // group with any IMSI. See {@link NetworkTemplate#getCollapsedRatType}.
@@ -385,29 +540,72 @@ class NetworkTemplateTest {
                 .setRatType(TelephonyManager.NETWORK_TYPE_UNKNOWN).build()
 
         val identUmtsMetered = buildNetworkIdentity(
-                mockContext, stateMobileImsi1Metered, false, TelephonyManager.NETWORK_TYPE_UMTS)
+                mockContext,
+                stateMobileImsi1Metered,
+                false,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
         val identHsdpaMetered = buildNetworkIdentity(
-                mockContext, stateMobileImsi1Metered, false, TelephonyManager.NETWORK_TYPE_HSDPA)
+                mockContext,
+                stateMobileImsi1Metered,
+                false,
+                TelephonyManager.NETWORK_TYPE_HSDPA
+        )
         val identLteMetered = buildNetworkIdentity(
-                mockContext, stateMobileImsi1Metered, false, TelephonyManager.NETWORK_TYPE_LTE)
+                mockContext,
+                stateMobileImsi1Metered,
+                false,
+                TelephonyManager.NETWORK_TYPE_LTE
+        )
         val identCombinedMetered = buildNetworkIdentity(
-                mockContext, stateMobileImsi1Metered, false, NetworkTemplate.NETWORK_TYPE_ALL)
-        val identImsi2UmtsMetered = buildNetworkIdentity(mockContext,
-                buildMobileNetworkState(TEST_IMSI2), false, TelephonyManager.NETWORK_TYPE_UMTS)
+                mockContext,
+                stateMobileImsi1Metered,
+                false,
+                NETWORK_TYPE_ALL
+        )
+        val identImsi2UmtsMetered = buildNetworkIdentity(
+                mockContext,
+                buildMobileNetworkState(TEST_IMSI2),
+                false,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
         val identWifi = buildNetworkIdentity(
-                mockContext, buildWifiNetworkState(null, TEST_WIFI_KEY1), true, 0)
+                mockContext,
+                buildWifiNetworkState(null, TEST_WIFI_KEY1),
+                true,
+                0
+        )
 
         val identUmtsNonMetered = buildNetworkIdentity(
-                mockContext, stateMobileImsi1NonMetered, false, TelephonyManager.NETWORK_TYPE_UMTS)
+                mockContext,
+                stateMobileImsi1NonMetered,
+                false,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
         val identHsdpaNonMetered = buildNetworkIdentity(
-                mockContext, stateMobileImsi1NonMetered, false,
-                TelephonyManager.NETWORK_TYPE_HSDPA)
+                mockContext,
+                stateMobileImsi1NonMetered,
+                false,
+                TelephonyManager.NETWORK_TYPE_HSDPA
+        )
         val identLteNonMetered = buildNetworkIdentity(
-                mockContext, stateMobileImsi1NonMetered, false, TelephonyManager.NETWORK_TYPE_LTE)
+                mockContext,
+                stateMobileImsi1NonMetered,
+                false,
+                TelephonyManager.NETWORK_TYPE_LTE
+        )
         val identCombinedNonMetered = buildNetworkIdentity(
-                mockContext, stateMobileImsi1NonMetered, false, NetworkTemplate.NETWORK_TYPE_ALL)
-        val identImsi2UmtsNonMetered = buildNetworkIdentity(mockContext,
-                stateMobileImsi2NonMetered, false, TelephonyManager.NETWORK_TYPE_UMTS)
+                mockContext,
+                stateMobileImsi1NonMetered,
+                false,
+                NETWORK_TYPE_ALL
+        )
+        val identImsi2UmtsNonMetered = buildNetworkIdentity(
+                mockContext,
+                stateMobileImsi2NonMetered,
+                false,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
 
         // Assert that identity with the same RAT and meteredness matches.
         // Verify metered template.
@@ -486,9 +684,17 @@ class NetworkTemplateTest {
         val templateImsi1 = NetworkTemplate.Builder(MATCH_MOBILE).setMeteredness(METERED_YES)
                 .setSubscriberIds(setOf(TEST_IMSI1)).setRatType(TelephonyManager.NETWORK_TYPE_UMTS)
                 .build()
-        val dupTemplateImsi1 = NetworkTemplate(MATCH_MOBILE, arrayOf(TEST_IMSI1),
-                emptyArray<String>(), METERED_YES, ROAMING_ALL, DEFAULT_NETWORK_ALL,
-                TelephonyManager.NETWORK_TYPE_UMTS, OEM_MANAGED_ALL)
+        val dupTemplateImsi1 = NetworkTemplate(
+                MATCH_MOBILE,
+                arrayOf(TEST_IMSI1),
+                emptyArray<String>() /* wifiNetworkKey */,
+                METERED_YES,
+                ROAMING_ALL,
+                DEFAULT_NETWORK_ALL,
+                TelephonyManager.NETWORK_TYPE_UMTS,
+                OEM_MANAGED_ALL,
+                TRANSPORT_TYPES_ALL
+        )
         val templateImsi2 = NetworkTemplate.Builder(MATCH_MOBILE).setMeteredness(METERED_YES)
                 .setSubscriberIds(setOf(TEST_IMSI2)).setRatType(TelephonyManager.NETWORK_TYPE_UMTS)
                 .build()
@@ -498,10 +704,19 @@ class NetworkTemplateTest {
         assertNotEquals(templateImsi1, templateImsi2)
 
         val templateWifiKey1 = NetworkTemplate.Builder(MATCH_WIFI)
-                .setWifiNetworkKeys(setOf(TEST_WIFI_KEY1)).build()
-        val dupTemplateWifiKey1 = NetworkTemplate(MATCH_WIFI, emptyArray<String>(),
-                arrayOf(TEST_WIFI_KEY1), METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL,
-                NETWORK_TYPE_ALL, OEM_MANAGED_ALL)
+                .setWifiNetworkKeys(setOf(TEST_WIFI_KEY1))
+                .build()
+        val dupTemplateWifiKey1 = NetworkTemplate(
+                MATCH_WIFI,
+                emptyArray<String>(),
+                arrayOf(TEST_WIFI_KEY1),
+                METERED_ALL,
+                ROAMING_ALL,
+                DEFAULT_NETWORK_ALL,
+                NETWORK_TYPE_ALL,
+                OEM_MANAGED_ALL,
+                TRANSPORT_TYPES_ALL
+        )
         val templateWifiKey2 = NetworkTemplate.Builder(MATCH_WIFI)
                 .setWifiNetworkKeys(setOf(TEST_WIFI_KEY2)).build()
 
@@ -512,18 +727,42 @@ class NetworkTemplateTest {
 
     @Test
     fun testParcelUnparcel() {
-        val templateMobile = NetworkTemplate(MATCH_MOBILE, arrayOf(TEST_IMSI1),
-                emptyArray<String>(), METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL,
-                TelephonyManager.NETWORK_TYPE_LTE, OEM_MANAGED_ALL)
-        val templateWifi = NetworkTemplate(MATCH_WIFI, emptyArray<String>(),
-                arrayOf(TEST_WIFI_KEY1), METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 0,
-                OEM_MANAGED_ALL)
-        val templateOem = NetworkTemplate(MATCH_MOBILE, emptyArray<String>(),
-                emptyArray<String>(), METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 0,
-                OEM_MANAGED_YES)
-        assertParcelSane(templateMobile, 8)
-        assertParcelSane(templateWifi, 8)
-        assertParcelSane(templateOem, 8)
+        val templateMobile = NetworkTemplate(
+                MATCH_MOBILE,
+                arrayOf(TEST_IMSI1),
+                emptyArray<String>() /* wifiNetworkKey */,
+                METERED_ALL,
+                ROAMING_ALL,
+                DEFAULT_NETWORK_ALL,
+                TelephonyManager.NETWORK_TYPE_LTE,
+                OEM_MANAGED_ALL,
+                0x12345678L
+        )
+        val templateWifi = NetworkTemplate(
+                MATCH_WIFI,
+                emptyArray<String>() /* subscriberIds */,
+                arrayOf(TEST_WIFI_KEY1),
+                METERED_ALL,
+                ROAMING_ALL,
+                DEFAULT_NETWORK_ALL,
+                0,
+                OEM_MANAGED_ALL,
+                0xDEADBEEFL
+        )
+        val templateOem = NetworkTemplate(
+                MATCH_MOBILE,
+                emptyArray<String>() /* subscriberIds */,
+                emptyArray<String>() /* wifiNetworkKey */,
+                METERED_ALL,
+                ROAMING_ALL,
+                DEFAULT_NETWORK_ALL,
+                0,
+                OEM_MANAGED_YES,
+                0xFFFFFFFFL
+        )
+        assertParcelSane(templateMobile, 9)
+        assertParcelSane(templateWifi, 9)
+        assertParcelSane(templateOem, 9)
     }
 
     // Verify NETWORK_TYPE_* constants in NetworkTemplate do not conflict with
@@ -538,8 +777,14 @@ class NetworkTemplateTest {
 
     @Test
     fun testOemNetworkConstants() {
-        val constantValues = arrayOf(OEM_MANAGED_YES, OEM_MANAGED_ALL, OEM_MANAGED_NO,
-                OEM_PAID, OEM_PRIVATE, OEM_PAID or OEM_PRIVATE)
+        val constantValues = arrayOf(
+                OEM_MANAGED_YES,
+                OEM_MANAGED_ALL,
+                OEM_MANAGED_NO,
+                OEM_PAID,
+                OEM_PRIVATE,
+                OEM_PAID or OEM_PRIVATE
+        )
 
         // Verify that "not OEM managed network" constants are equal.
         assertEquals(OEM_MANAGED_NO, OEM_NONE)
@@ -578,23 +823,55 @@ class NetworkTemplateTest {
         val matchWifiNetworkKeys =
                 if (templateWifiKey == null) emptyArray<String>() else arrayOf(templateWifiKey)
 
-        val templateOemYes = NetworkTemplate(matchType, matchSubscriberIds,
-                matchWifiNetworkKeys, METERED_ALL, ROAMING_ALL,
-                DEFAULT_NETWORK_ALL, NETWORK_TYPE_ALL, OEM_MANAGED_YES)
-        val templateOemAll = NetworkTemplate(matchType, matchSubscriberIds,
-                matchWifiNetworkKeys, METERED_ALL, ROAMING_ALL,
-                DEFAULT_NETWORK_ALL, NETWORK_TYPE_ALL, OEM_MANAGED_ALL)
+        val templateOemYes = NetworkTemplate(
+                matchType,
+                matchSubscriberIds,
+                matchWifiNetworkKeys,
+                METERED_ALL,
+                ROAMING_ALL,
+                DEFAULT_NETWORK_ALL,
+                NETWORK_TYPE_ALL,
+                OEM_MANAGED_YES,
+                TRANSPORT_TYPES_ALL
+        )
+        val templateOemAll = NetworkTemplate(
+                matchType,
+                matchSubscriberIds,
+                matchWifiNetworkKeys,
+                METERED_ALL,
+                ROAMING_ALL,
+                DEFAULT_NETWORK_ALL,
+                NETWORK_TYPE_ALL,
+                OEM_MANAGED_ALL,
+                TRANSPORT_TYPES_ALL
+        )
 
         for (identityOemManagedState in oemManagedStates) {
-            val ident = buildNetworkIdentity(mockContext, buildNetworkState(networkType,
-                    subscriberId, identWifiKey, identityOemManagedState),
-                    /*defaultNetwork=*/false, /*subType=*/0)
+            val ident = buildNetworkIdentity(
+                    mockContext,
+                    buildNetworkState(
+                            networkType,
+                            subscriberId,
+                            identWifiKey,
+                            identityOemManagedState
+                    ),
+                    false /* defaultNetwork */,
+                    0 /* subType */
+            )
 
             // Create a template with each OEM managed type and match it against the NetworkIdentity
             for (templateOemManagedState in oemManagedStates) {
-                val template = NetworkTemplate(matchType, matchSubscriberIds,
-                        matchWifiNetworkKeys, METERED_ALL, ROAMING_ALL,
-                        DEFAULT_NETWORK_ALL, NETWORK_TYPE_ALL, templateOemManagedState)
+                val template = NetworkTemplate(
+                        matchType,
+                        matchSubscriberIds,
+                        matchWifiNetworkKeys,
+                        METERED_ALL,
+                        ROAMING_ALL,
+                        DEFAULT_NETWORK_ALL,
+                        NETWORK_TYPE_ALL,
+                        templateOemManagedState,
+                        TRANSPORT_TYPES_ALL
+                )
                 if (identityOemManagedState == templateOemManagedState) {
                     template.assertMatches(ident)
                 } else {
@@ -616,29 +893,87 @@ class NetworkTemplateTest {
     fun testOemManagedMatchesIdent() {
         matchOemManagedIdent(TYPE_MOBILE, MATCH_MOBILE, subscriberId = TEST_IMSI1)
         matchOemManagedIdent(TYPE_MOBILE, MATCH_MOBILE)
-        matchOemManagedIdent(TYPE_WIFI, MATCH_WIFI, templateWifiKey = TEST_WIFI_KEY1,
-                identWifiKey = TEST_WIFI_KEY1)
+        matchOemManagedIdent(
+                TYPE_WIFI,
+                MATCH_WIFI,
+                templateWifiKey = TEST_WIFI_KEY1,
+                identWifiKey = TEST_WIFI_KEY1
+        )
         matchOemManagedIdent(TYPE_WIFI, MATCH_WIFI, identWifiKey = TEST_WIFI_KEY1)
     }
 
+    @Test
+    fun testTransportTypesMatches() {
+        val identSatellite = NetworkIdentity.Builder()
+                .setType(TYPE_MOBILE)
+                .setTransportTypes(setOf(TRANSPORT_SATELLITE))
+                .build()
+        val identCellularVpn = NetworkIdentity.Builder()
+                .setType(TYPE_MOBILE)
+                .setTransportTypes(setOf(TRANSPORT_CELLULAR, TRANSPORT_VPN))
+                .build()
+        val identCellular = NetworkIdentity.Builder()
+                .setType(TYPE_MOBILE)
+                .setTransportTypes(setOf(TRANSPORT_CELLULAR))
+                .build()
+
+        val templateCellular = NetworkTemplate.Builder()
+                .setTransportType(TRANSPORT_CELLULAR)
+                .build()
+        val templateSatellite = NetworkTemplate.Builder()
+                .setTransportType(TRANSPORT_SATELLITE)
+                .build()
+
+        // 1. Template requiring TRANSPORT_CELLULAR
+        templateCellular.assertDoesNotMatch(identSatellite)
+        templateCellular.assertMatches(identCellularVpn)
+        templateCellular.assertMatches(identCellular)
+
+        // 2. Template requiring TRANSPORT_SATELLITE
+        templateSatellite.assertMatches(identSatellite)
+        templateSatellite.assertDoesNotMatch(identCellularVpn)
+        templateSatellite.assertDoesNotMatch(identCellular)
+    }
+
     @Test
     fun testNormalize() {
         var mergedImsiList = arrayOf(TEST_IMSI1, TEST_IMSI2)
-        val identMobileImsi1 = buildNetworkIdentity(mockContext,
-                buildMobileNetworkState(TEST_IMSI1), false /* defaultNetwork */,
-                TelephonyManager.NETWORK_TYPE_UMTS)
-        val identMobileImsi2 = buildNetworkIdentity(mockContext,
-                buildMobileNetworkState(TEST_IMSI2), false /* defaultNetwork */,
-                TelephonyManager.NETWORK_TYPE_UMTS)
-        val identMobileImsi3 = buildNetworkIdentity(mockContext,
-                buildMobileNetworkState(TEST_IMSI3), false /* defaultNetwork */,
-                TelephonyManager.NETWORK_TYPE_UMTS)
+        val identMobileImsi1 = buildNetworkIdentity(
+                mockContext,
+                buildMobileNetworkState(TEST_IMSI1),
+                false /* defaultNetwork */,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
+        val identMobileImsi2 = buildNetworkIdentity(
+                mockContext,
+                buildMobileNetworkState(TEST_IMSI2),
+                false /* defaultNetwork */,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
+        val identMobileImsi3 = buildNetworkIdentity(
+                mockContext,
+                buildMobileNetworkState(TEST_IMSI3),
+                false /* defaultNetwork */,
+                TelephonyManager.NETWORK_TYPE_UMTS
+        )
         val identWifiImsi1Key1 = buildNetworkIdentity(
-                mockContext, buildWifiNetworkState(TEST_IMSI1, TEST_WIFI_KEY1), true, 0)
+                mockContext,
+                buildWifiNetworkState(TEST_IMSI1, TEST_WIFI_KEY1),
+                true,
+                0
+        )
         val identWifiImsi2Key1 = buildNetworkIdentity(
-                mockContext, buildWifiNetworkState(TEST_IMSI2, TEST_WIFI_KEY1), true, 0)
+                mockContext,
+                buildWifiNetworkState(TEST_IMSI2, TEST_WIFI_KEY1),
+                true,
+                0
+        )
         val identWifiImsi3WifiKey1 = buildNetworkIdentity(
-                mockContext, buildWifiNetworkState(TEST_IMSI3, TEST_WIFI_KEY1), true, 0)
+                mockContext,
+                buildWifiNetworkState(TEST_IMSI3, TEST_WIFI_KEY1),
+                true,
+                0
+        )
 
         normalize(buildTemplateMobileAll(TEST_IMSI1), mergedImsiList).also {
             it.assertMatches(identMobileImsi1)
diff --git a/tests/unit/java/android/net/QosSocketFilterTest.java b/tests/unit/java/android/net/QosSocketFilterTest.java
index 6820b4048c..c2e65fdae2 100644
--- a/tests/unit/java/android/net/QosSocketFilterTest.java
+++ b/tests/unit/java/android/net/QosSocketFilterTest.java
@@ -52,50 +52,95 @@ public class QosSocketFilterTest {
     public void testPortExactMatch() {
         final InetAddress addressA = InetAddresses.parseNumericAddress("1.2.3.4");
         final InetAddress addressB = InetAddresses.parseNumericAddress("1.2.3.4");
-        assertTrue(QosSocketFilter.matchesAddress(
-                new InetSocketAddress(addressA, 10), addressB, 10, 10));
+        assertTrue(
+                QosSocketFilter.matchesAddress(
+                        new InetSocketAddress(addressA, 10), new IpPrefix(addressB, 32), 10, 10));
     }
 
     @Test
     public void testPortLessThanStart() {
         final InetAddress addressA = InetAddresses.parseNumericAddress("1.2.3.4");
         final InetAddress addressB = InetAddresses.parseNumericAddress("1.2.3.4");
-        assertFalse(QosSocketFilter.matchesAddress(
-                new InetSocketAddress(addressA, 8), addressB, 10, 10));
+        assertFalse(
+                QosSocketFilter.matchesAddress(
+                        new InetSocketAddress(addressA, 8), new IpPrefix(addressB, 32), 10, 10));
     }
 
     @Test
     public void testPortGreaterThanEnd() {
         final InetAddress addressA = InetAddresses.parseNumericAddress("1.2.3.4");
         final InetAddress addressB = InetAddresses.parseNumericAddress("1.2.3.4");
-        assertFalse(QosSocketFilter.matchesAddress(
-                new InetSocketAddress(addressA, 18), addressB, 10, 10));
+        assertFalse(
+                QosSocketFilter.matchesAddress(
+                        new InetSocketAddress(addressA, 18), new IpPrefix(addressB, 32), 10, 10));
     }
 
     @Test
     public void testPortBetweenStartAndEnd() {
         final InetAddress addressA = InetAddresses.parseNumericAddress("1.2.3.4");
         final InetAddress addressB = InetAddresses.parseNumericAddress("1.2.3.4");
-        assertTrue(QosSocketFilter.matchesAddress(
-                new InetSocketAddress(addressA, 10), addressB, 8, 18));
+        assertTrue(
+                QosSocketFilter.matchesAddress(
+                        new InetSocketAddress(addressA, 10), new IpPrefix(addressB, 32), 8, 18));
     }
 
     @Test
     public void testAddressesDontMatch() {
         final InetAddress addressA = InetAddresses.parseNumericAddress("1.2.3.4");
         final InetAddress addressB = InetAddresses.parseNumericAddress("1.2.3.5");
-        assertFalse(QosSocketFilter.matchesAddress(
-                new InetSocketAddress(addressA, 10), addressB, 10, 10));
+        assertFalse(
+                QosSocketFilter.matchesAddress(
+                        new InetSocketAddress(addressA, 10), new IpPrefix(addressB, 32), 10, 10));
     }
 
     @Test
     public void testAddressMatchWithAnyLocalAddresses() {
         final InetAddress addressA = InetAddresses.parseNumericAddress("1.2.3.4");
         final InetAddress addressB = InetAddresses.parseNumericAddress("0.0.0.0");
-        assertTrue(QosSocketFilter.matchesAddress(
-                new InetSocketAddress(addressA, 10), addressB, 10, 10));
-        assertFalse(QosSocketFilter.matchesAddress(
-                new InetSocketAddress(addressB, 10), addressA, 10, 10));
+        assertTrue(
+                QosSocketFilter.matchesAddress(
+                        new InetSocketAddress(addressA, 10), new IpPrefix(addressB, 32), 10, 10));
+        assertFalse(
+                QosSocketFilter.matchesAddress(
+                        new InetSocketAddress(addressB, 10), new IpPrefix(addressA, 32), 10, 10));
+    }
+
+    @Test
+    public void testAddressMatchWithPrefixLength() {
+        final InetAddress addressA = InetAddresses.parseNumericAddress("1.2.3.100");
+        final InetAddress addressB = InetAddresses.parseNumericAddress("1.2.3.132");
+        final InetAddress addressC = InetAddresses.parseNumericAddress("1.2.3.96");
+        final InetAddress addressD = InetAddresses.parseNumericAddress("2001:2:3:5::13:D17");
+        final InetAddress addressE = InetAddresses.parseNumericAddress("2001:2:3:4::13:D17");
+        final InetAddress addressF = InetAddresses.parseNumericAddress("2001:2:3:5::");
+        final InetAddress addressG = InetAddresses.parseNumericAddress("135.23.185.35");
+        final InetAddress addressH = InetAddresses.parseNumericAddress("135.23.186.127");
+        final InetAddress addressI = InetAddresses.parseNumericAddress("135.23.183.127");
+
+        assertTrue(
+                QosSocketFilter.matchesAddress(
+                        new InetSocketAddress(addressA, 10), new IpPrefix(addressC, 27), 10, 10));
+        assertFalse(
+                QosSocketFilter.matchesAddress(
+                        new InetSocketAddress(addressB, 10), new IpPrefix(addressC, 27), 10, 10));
+        assertTrue(
+                QosSocketFilter.matchesAddress(
+                        new InetSocketAddress(addressG, 10), new IpPrefix(addressH, 22), 10, 10));
+        assertFalse(
+                QosSocketFilter.matchesAddress(
+                        new InetSocketAddress(addressI, 10), new IpPrefix(addressH, 22), 10, 10));
+        assertTrue(
+                QosSocketFilter.matchesAddress(
+                        new InetSocketAddress(addressD, 10), new IpPrefix(addressF, 64), 10, 10));
+        assertFalse(
+                QosSocketFilter.matchesAddress(
+                        new InetSocketAddress(addressE, 10), new IpPrefix(addressF, 64), 10, 10));
+        assertFalse(
+                QosSocketFilter.matchesAddress(
+                        new InetSocketAddress(addressA, 10), new IpPrefix(addressF, 64), 10, 10));
+        assertTrue(
+                QosSocketFilter.matchesAddress(
+                        new InetSocketAddress(addressD, 10), new IpPrefix(addressD, 128), 10, 10));
     }
 
     @Test
diff --git a/tests/unit/java/android/net/netstats/NetworkStatsDataMigrationUtilsTest.kt b/tests/unit/java/android/net/netstats/NetworkStatsDataMigrationUtilsTest.kt
index aa5a246aba..8da680a77c 100644
--- a/tests/unit/java/android/net/netstats/NetworkStatsDataMigrationUtilsTest.kt
+++ b/tests/unit/java/android/net/netstats/NetworkStatsDataMigrationUtilsTest.kt
@@ -17,12 +17,12 @@
 package android.net.netstats
 
 import android.net.NetworkStatsCollection
+import android.os.Build
 import androidx.test.InstrumentationRegistry
 import androidx.test.filters.SmallTest
 import com.android.frameworks.tests.net.R
 import com.android.testutils.DevSdkIgnoreRule
 import com.android.testutils.DevSdkIgnoreRunner
-import com.android.testutils.SC_V2
 import org.junit.Before
 import org.junit.Test
 import org.junit.runner.RunWith
@@ -37,7 +37,7 @@ private const val BUCKET_DURATION_MS = 2 * 60 * 60 * 1000L
 
 @RunWith(DevSdkIgnoreRunner::class)
 @SmallTest
-@DevSdkIgnoreRule.IgnoreUpTo(SC_V2) // TODO: Use to Build.VERSION_CODES.SC_V2 when available
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 class NetworkStatsDataMigrationUtilsTest {
     @Before
     fun setup() {
diff --git a/tests/unit/java/com/android/metrics/ConnectivitySampleMetricsTest.kt b/tests/unit/java/com/android/metrics/ConnectivitySampleMetricsTest.kt
index 8a9286fb6a..9fb8d61f4e 100644
--- a/tests/unit/java/com/android/metrics/ConnectivitySampleMetricsTest.kt
+++ b/tests/unit/java/com/android/metrics/ConnectivitySampleMetricsTest.kt
@@ -35,6 +35,7 @@ import androidx.test.filters.SmallTest
 import com.android.net.module.util.BitUtils
 import com.android.server.CSTest
 import com.android.server.FromS
+import com.android.server.connectivity.ConnectivityFlags.CONSTRAINED_DATA_SATELLITE_METRICS
 import com.android.server.connectivity.FullScore
 import com.android.server.connectivity.FullScore.POLICY_IS_UNMETERED
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
@@ -46,6 +47,7 @@ import kotlin.test.fail
 import org.junit.Assert.assertTrue
 import org.junit.Test
 import org.junit.runner.RunWith
+import org.mockito.Mockito.doReturn
 
 private fun <T> Handler.onHandler(f: () -> T): T {
     val future = CompletableFuture<T>()
@@ -215,13 +217,12 @@ class ConnectivitySampleMetricsTest : CSTest() {
         }
     }
 
-
     @Test
     fun testSampleConnectivityState_NetworkRequest() {
         val requestCount = 5
-        fileNetworkRequest(RT_APP, requestCount);
-        fileNetworkRequest(RT_SYSTEM, requestCount, SYSTEM_UID);
-        fileNetworkRequest(RT_SYSTEM_ON_BEHALF_OF_APP, requestCount, SYSTEM_UID);
+        fileNetworkRequest(RT_APP, requestCount)
+        fileNetworkRequest(RT_SYSTEM, requestCount, SYSTEM_UID)
+        fileNetworkRequest(RT_SYSTEM_ON_BEHALF_OF_APP, requestCount, SYSTEM_UID)
 
         val stats = csHandler.onHandler { service.sampleConnectivityState() }
 
@@ -246,4 +247,24 @@ class ConnectivitySampleMetricsTest : CSTest() {
                 "found ${systemOnBehalfOfAppRequest.requestCount}",
                 systemOnBehalfOfAppRequest.requestCount >= requestCount)
     }
+
+    @Test
+    fun testSampleConnectivityState_satelliteAccessInfo() {
+        doTestSampleConnectivityState_satelliteAccessInfo(true)
+    }
+
+    @FeatureFlags(flags = [Flag(CONSTRAINED_DATA_SATELLITE_METRICS, false)])
+    @Test
+    fun testSampleConnectivityState_satelliteAccessInfo_disabled() {
+        doTestSampleConnectivityState_satelliteAccessInfo(false)
+    }
+
+    private fun doTestSampleConnectivityState_satelliteAccessInfo(expectUpdated: Boolean) {
+        val statsBefore = csHandler.onHandler { service.sampleConnectivityState() }
+        assertEquals(0, statsBefore.satelliteAccessInfo.optinUidCount)
+
+        doReturn(3).`when`(satelliteAccessController).cachedOptInUidsCount
+        val statsAfter = csHandler.onHandler { service.sampleConnectivityState() }
+        assertEquals(if (expectUpdated) 3 else 0, statsAfter.satelliteAccessInfo.optinUidCount)
+    }
 }
diff --git a/tests/unit/java/com/android/metrics/DefaultNetworkRematchMetricsTest.kt b/tests/unit/java/com/android/metrics/DefaultNetworkRematchMetricsTest.kt
new file mode 100644
index 0000000000..967a59be00
--- /dev/null
+++ b/tests/unit/java/com/android/metrics/DefaultNetworkRematchMetricsTest.kt
@@ -0,0 +1,252 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.metrics
+
+import android.net.NetworkCapabilities
+import android.net.NetworkCapabilities.NET_CAPABILITY_CAPTIVE_PORTAL
+import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED
+import android.net.NetworkCapabilities.NET_CAPABILITY_PARTIAL_CONNECTIVITY
+import android.net.NetworkCapabilities.NET_CAPABILITY_TEMPORARILY_NOT_METERED
+import android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED
+import android.net.NetworkCapabilities.TRANSPORT_SATELLITE
+import android.net.UidRange
+import android.os.Build
+import android.stats.connectivity.MeteredState.METERED_NO
+import android.stats.connectivity.MeteredState.METERED_TEMPORARILY_UNMETERED
+import android.stats.connectivity.MeteredState.METERED_YES
+import android.stats.connectivity.ValidatedState.VS_INVALID
+import android.stats.connectivity.ValidatedState.VS_PARTIAL
+import android.stats.connectivity.ValidatedState.VS_PORTAL
+import android.stats.connectivity.ValidatedState.VS_VALID
+import com.android.metrics.DefaultNetworkRematchMetrics.Dependencies
+import com.android.server.ConnectivityService
+import com.android.server.ConnectivityService.PREFERENCE_ORDER_NONE
+import com.android.server.ConnectivityService.PREFERENCE_ORDER_SATELLITE_FALLBACK
+import com.android.server.connectivity.FullScore
+import com.android.server.connectivity.NetworkAgentInfo
+import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
+import com.android.testutils.DevSdkIgnoreRunner
+import kotlin.test.assertEquals
+import kotlin.test.assertTrue
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.ArgumentCaptor
+import org.mockito.Mockito.any
+import org.mockito.Mockito.anyInt
+import org.mockito.Mockito.anyLong
+import org.mockito.Mockito.clearInvocations
+import org.mockito.Mockito.doReturn
+import org.mockito.Mockito.mock
+import org.mockito.Mockito.never
+import org.mockito.Mockito.times
+import org.mockito.Mockito.verify
+
+@RunWith(DevSdkIgnoreRunner::class)
+@IgnoreUpTo(Build.VERSION_CODES.TIRAMISU)
+class DefaultNetworkRematchMetricsTest {
+
+    private val deps = mock(Dependencies::class.java)
+
+    private val nc = mock(NetworkCapabilities::class.java).also {
+        doReturn(1L shl TRANSPORT_SATELLITE).`when`(it).transportTypesInternal
+        doReturn(0L).`when`(it).capabilitiesInternal
+        doReturn(true).`when`(it).hasTransport(TRANSPORT_SATELLITE)
+    }
+
+    private val score = mock(FullScore::class.java).also {
+        doReturn(0L).`when`(it).policiesInternal
+    }
+
+    private val oldNai = mock(NetworkAgentInfo::class.java).also {
+        doReturn(nc).`when`(it).capsNoCopy
+        doReturn(score).`when`(it).score
+    }
+
+    private val newNai = mock(NetworkAgentInfo::class.java).also {
+        doReturn(nc).`when`(it).capsNoCopy
+        doReturn(score).`when`(it).score
+    }
+
+    private val nri = mock(ConnectivityService.NetworkRequestInfo::class.java).also {
+                doReturn(PREFERENCE_ORDER_SATELLITE_FALLBACK).`when`(it).preferenceOrderForNetd
+                doReturn(emptySet<UidRange>()).`when`(it).uids
+            }
+
+    private val infoListCaptor = ArgumentCaptor.forClass(DefaultNetworkRematchInfoList::class.java)
+
+    private val metrics = DefaultNetworkRematchMetrics(deps)
+
+    @Test
+    fun testAddEvent_wrongPreference_isIgnored() {
+        doReturn(PREFERENCE_ORDER_NONE).`when`(nri).preferenceOrderForNetd
+
+        metrics.addEvent(nri, oldNai, newNai, 0L)
+        metrics.writeStatsAndClear()
+
+        verify(deps, never()).writeStats(anyLong(), anyInt(), any())
+    }
+
+    @Test
+    fun testAddEvent_notFromSatellite_isIgnored() {
+        // Setup: The old network is not a satellite network. The mock for its capabilities
+        // will return false when checked for the SATELLITE transport type.
+        val nonSatelliteCaps = mock(NetworkCapabilities::class.java)
+        doReturn(false).`when`(nonSatelliteCaps).hasTransport(TRANSPORT_SATELLITE)
+        doReturn(nonSatelliteCaps).`when`(oldNai).capsNoCopy
+
+        // Action: Attempt to add the event and write stats.
+        metrics.addEvent(nri, oldNai, newNai, 0L)
+        metrics.writeStatsAndClear()
+
+        // Verification: The event should be ignored, so writeStats should never be called.
+        verify(deps, never()).writeStats(anyLong(), anyInt(), any())
+    }
+
+    @Test
+    fun testAddEvent_validRequest_isAdded() {
+        metrics.addEvent(nri, oldNai, newNai, 0L)
+        metrics.writeStatsAndClear()
+
+        verify(deps, times(1)).writeStats(anyLong(), anyInt(), any())
+    }
+
+    @Test
+    fun testWriteStats_noEvents_doesNothing() {
+        metrics.writeStatsAndClear()
+        verify(deps, never()).writeStats(anyLong(), anyInt(), any())
+    }
+
+    @Test
+    fun testWriteStats_withEvents_writesAndClears() {
+        // Setup: Define the time the network satisfied time and the current time.
+        val satisfiedDurationMs = 120_000L
+
+        // First call: Add event and write
+        metrics.addEvent(nri, oldNai, newNai, satisfiedDurationMs)
+        metrics.writeStatsAndClear()
+
+        verify(deps, times(1)).writeStats(anyLong(), anyInt(), infoListCaptor.capture())
+        val capturedList = infoListCaptor.value
+        assertEquals(1, capturedList.defaultNetworkRematchInfoList.size)
+        val info = capturedList.defaultNetworkRematchInfoList[0]
+        assertEquals((satisfiedDurationMs / 1000).toInt(), info.timeDurationOnOldNetworkSec)
+
+        // Second call: Should do nothing as events are cleared
+        clearInvocations(deps)
+        metrics.writeStatsAndClear()
+        verify(deps, never()).writeStats(anyLong(), anyInt(), any())
+    }
+
+    @Test
+    fun testGetMeteredState() {
+        // Temporarily Unmetered should be checked first
+        val tempUnmeteredCaps = mock(NetworkCapabilities::class.java)
+        doReturn(true).`when`(tempUnmeteredCaps)
+                .hasCapability(NET_CAPABILITY_TEMPORARILY_NOT_METERED)
+        doReturn(true).`when`(tempUnmeteredCaps)
+                .hasCapability(NET_CAPABILITY_NOT_METERED)
+        assertEquals(
+            METERED_TEMPORARILY_UNMETERED,
+            DefaultNetworkRematchMetrics.getMeteredState(tempUnmeteredCaps)
+        )
+
+        // Not Metered
+        val notMeteredCaps = mock(NetworkCapabilities::class.java)
+        doReturn(true).`when`(notMeteredCaps).hasCapability(NET_CAPABILITY_NOT_METERED)
+        assertEquals(METERED_NO, DefaultNetworkRematchMetrics.getMeteredState(notMeteredCaps))
+
+        // Metered (default)
+        val meteredCaps = mock(NetworkCapabilities::class.java)
+        assertEquals(METERED_YES, DefaultNetworkRematchMetrics.getMeteredState(meteredCaps))
+    }
+
+    @Test
+    fun testGetValidatedState() {
+        // Valid
+        val validatedCaps = mock(NetworkCapabilities::class.java)
+        doReturn(true).`when`(validatedCaps).hasCapability(NET_CAPABILITY_VALIDATED)
+        assertEquals(VS_VALID, DefaultNetworkRematchMetrics.getValidatedState(validatedCaps))
+
+        // Captive Portal
+        val portalCaps = mock(NetworkCapabilities::class.java)
+        doReturn(true).`when`(portalCaps).hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL)
+        assertEquals(VS_PORTAL, DefaultNetworkRematchMetrics.getValidatedState(portalCaps))
+
+        // Partial Connectivity
+        val partialCaps = mock(NetworkCapabilities::class.java)
+        doReturn(true).`when`(partialCaps).hasCapability(NET_CAPABILITY_PARTIAL_CONNECTIVITY)
+        assertEquals(VS_PARTIAL, DefaultNetworkRematchMetrics.getValidatedState(partialCaps))
+
+        // Invalid
+        val invalidCaps = mock(NetworkCapabilities::class.java).also {
+            doReturn(false).`when`(it).hasCapability(NET_CAPABILITY_VALIDATED)
+            doReturn(false).`when`(it).hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL)
+            doReturn(false).`when`(it).hasCapability(NET_CAPABILITY_PARTIAL_CONNECTIVITY)
+        }
+        assertEquals(VS_INVALID, DefaultNetworkRematchMetrics.getValidatedState(invalidCaps))
+    }
+
+    @Test
+    fun testGetUidRangesProto() {
+        val uids = setOf(UidRange(1000, 1000), UidRange(2000, 3000))
+        doReturn(uids).`when`(nri).uids
+
+        metrics.addEvent(nri, oldNai, null, 0L)
+        metrics.writeStatsAndClear()
+
+        verify(deps).writeStats(anyLong(), anyInt(), infoListCaptor.capture())
+        val capturedInfo = infoListCaptor.value.defaultNetworkRematchInfoList[0]
+
+        val capturedRanges = capturedInfo.uidRanges.uidRangeList
+        assertEquals(2, capturedRanges.size)
+        assertTrue(capturedRanges.any { it.begin == 1000 && it.end == 1000 })
+        assertTrue(capturedRanges.any { it.begin == 2000 && it.end == 3000 })
+    }
+
+    @Test
+    fun testGetNetworkDescription() {
+        val transports = 0x67890ABL
+        val capsInternal = 12345L
+        val scorePoliciesInternal = 0xDEADBEEFL
+        val enterpriseIds = 0x03
+
+        val caps = mock(NetworkCapabilities::class.java).also {
+            doReturn(transports).`when`(it).transportTypesInternal
+            doReturn(true).`when`(it).hasCapability(NET_CAPABILITY_VALIDATED)
+            doReturn(true).`when`(it).hasCapability(NET_CAPABILITY_NOT_METERED)
+            doReturn(capsInternal).`when`(it).capabilitiesInternal
+            doReturn(enterpriseIds).`when`(it).enterpriseIdsInternal
+        }
+        val score = mock(FullScore::class.java).also {
+            doReturn(scorePoliciesInternal).`when`(it).policiesInternal
+        }
+
+        val nai = mock(NetworkAgentInfo::class.java).also {
+            doReturn(caps).`when`(it).capsNoCopy
+            doReturn(score).`when`(it).score
+        }
+
+        val description = DefaultNetworkRematchMetrics.getNetworkDescription(nai)
+
+        assertEquals(transports.toInt(), description.transportTypes)
+        assertEquals(VS_VALID, description.validatedState)
+        assertEquals(METERED_NO, description.meteredState)
+        assertEquals(capsInternal, description.capabilities)
+        assertEquals(scorePoliciesInternal, description.scorePolicies)
+        assertEquals(enterpriseIds, description.enterpriseId)
+    }
+}
diff --git a/tests/unit/java/com/android/metrics/SatelliteCoarseUsageMetricsCollectorTest.kt b/tests/unit/java/com/android/metrics/SatelliteCoarseUsageMetricsCollectorTest.kt
new file mode 100644
index 0000000000..5bde5e4bbc
--- /dev/null
+++ b/tests/unit/java/com/android/metrics/SatelliteCoarseUsageMetricsCollectorTest.kt
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.metrics
+
+import android.app.usage.NetworkStatsManager
+import android.content.Context
+import android.net.ConnectivityManager
+import android.net.Network
+import android.os.Build
+import android.os.Handler
+import android.os.Looper
+import com.android.metrics.SatelliteCoarseUsageMetricsCollector.MyStatsEntry
+import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
+import com.android.testutils.DevSdkIgnoreRunner
+import com.android.testutils.waitForIdle
+import kotlin.test.assertEquals
+import org.junit.Assert.assertNotNull
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.ArgumentCaptor
+import org.mockito.ArgumentMatchers.any
+import org.mockito.ArgumentMatchers.anyLong
+import org.mockito.ArgumentMatchers.eq
+import org.mockito.InOrder
+import org.mockito.Mockito.doReturn
+import org.mockito.Mockito.inOrder
+import org.mockito.Mockito.mock
+import org.mockito.Mockito.never
+import org.mockito.Mockito.verify
+
+/**
+ * Unit tests for [SatelliteCoarseUsageMetricsCollector].
+ * These tests mock Android system services and the custom Dependencies class
+ * to verify the behavior of the collector during satellite network events,
+ * using MockK for mocking and argument capturing.
+ */
+@RunWith(DevSdkIgnoreRunner::class)
+@IgnoreUpTo(Build.VERSION_CODES.TIRAMISU)
+class SatelliteCoarseUsageMetricsCollectorTest {
+    companion object {
+        const val THREAD_BLOCK_TIMEOUT_MS = 1000L
+        const val TEST_BUCKET_DURATION_MS = 10L
+    }
+
+    private val mockCm = mock(ConnectivityManager::class.java)
+    private val mockNsm = mock(NetworkStatsManager::class.java)
+    private val mockCtx = mock(Context::class.java).also {
+        doReturn(mockCm).`when`(it).getSystemService(ConnectivityManager::class.java)
+        doReturn(mockNsm).`when`(it).getSystemService(NetworkStatsManager::class.java)
+    }
+    private val handler = Handler(Looper.getMainLooper())
+    private val mockDeps = mock(SatelliteCoarseUsageMetricsCollector.Dependencies::class.java)
+            .also {
+                doReturn(handler).`when`(it).backgroundThreadHandler
+                doReturn(TEST_BUCKET_DURATION_MS).`when`(it).maxBucketDuration
+            }
+    private val collector = SatelliteCoarseUsageMetricsCollector(mockCtx, mockDeps)
+
+    // Return the network callback for listening network changes.
+    private fun startMonitoring(): ConnectivityManager.NetworkCallback {
+        val cbCaptor = ArgumentCaptor.forClass(ConnectivityManager.NetworkCallback::class.java)
+        collector.startMonitoring()
+        handler.waitForIdle(THREAD_BLOCK_TIMEOUT_MS)
+        verify(mockCm).registerNetworkCallback(any(), cbCaptor.capture(), any())
+        return cbCaptor.value.also {
+            assertNotNull(it)
+        }
+    }
+
+    private fun mockGetSummary(rxBytes: Long, txBytes: Long) {
+        val statsEntry = MyStatsEntry(rxBytes, txBytes)
+        doReturn(statsEntry).`when`(mockDeps).getSummary(any(), anyLong())
+    }
+
+    private fun assertReportedUsage(inOrder: InOrder, rxBytes: Long, txBytes: Long) {
+        val reportedUsageCaptor = ArgumentCaptor.forClass(MyStatsEntry::class.java)
+        inOrder.verify(mockDeps).reportUsage(reportedUsageCaptor.capture())
+
+        val reportedUsage = reportedUsageCaptor.value
+        assertEquals(rxBytes, reportedUsage.rxBytes)
+        assertEquals(txBytes, reportedUsage.txBytes)
+    }
+
+    private fun mockTime(time: Long) {
+        doReturn(time).`when`(mockDeps).currentTimeMillis
+    }
+
+    @Test
+    fun testSingleNetwork() {
+        val mockNet = mock(Network::class.java)
+        val inOrder = inOrder(mockDeps)
+        mockTime(1000)
+        mockGetSummary(100, 50)
+        val cb = startMonitoring()
+        inOrder.verify(mockDeps).getSummary(any(), eq(1000 - TEST_BUCKET_DURATION_MS))
+
+        // Advance time, Simulate losing the network. This triggers two getSummary calls:
+        // 1. The first call uses the original start time to calculate the usage difference.
+        // 2. The second call creates a new baseline with an updated start time.
+        mockTime(2000)
+        mockGetSummary(300, 150)
+        cb.onLost(mockNet)
+        inOrder.verify(mockDeps).getSummary(any(), eq(1000 - TEST_BUCKET_DURATION_MS))
+        assertReportedUsage(inOrder, 200, 100)
+        inOrder.verify(mockDeps).getSummary(any(), eq(2000 - TEST_BUCKET_DURATION_MS))
+    }
+
+    // Test multiple satellite networks. This could happen when telephony creates
+    // satellite networks with different types of services (e.g., MMS, internet).
+    @Test
+    fun testMultipleNetworks() {
+        // Mock multiple networks, ensuring they are identified as distinct.
+        val mockNet1 = Network(1)
+        val mockNet2 = Network(2)
+        val inOrder = inOrder(mockDeps)
+
+        // Simulate baseline.
+        mockTime(1000)
+        mockGetSummary(100, 50)
+        val cb = startMonitoring()
+        inOrder.verify(mockDeps).getSummary(any(), eq(1000 - TEST_BUCKET_DURATION_MS))
+
+        // Simulate onAvailable events, verify nothing happens.
+        mockTime(2000)
+        cb.onAvailable(mockNet1)
+        cb.onAvailable(mockNet2)
+        inOrder.verify(mockDeps, never()).reportUsage(any())
+
+        // Simulate first network lost (not the last), simulate no change at all,
+        // verify reportUsage is invoked with zero bytes.
+        mockTime(3000)
+        cb.onLost(mockNet1)
+        inOrder.verify(mockDeps).getSummary(any(), eq(1000 - TEST_BUCKET_DURATION_MS))
+        assertReportedUsage(inOrder, 0L, 0L)
+        inOrder.verify(mockDeps).getSummary(any(), eq(3000 - TEST_BUCKET_DURATION_MS))
+
+        // Simulate second network lost (the last one).
+        mockTime(4000)
+        mockGetSummary(300, 150)
+        cb.onLost(mockNet2)
+        inOrder.verify(mockDeps).getSummary(any(), eq(3000 - TEST_BUCKET_DURATION_MS))
+        assertReportedUsage(inOrder, 200L, 100L)
+        inOrder.verify(mockDeps).getSummary(any(), eq(4000 - TEST_BUCKET_DURATION_MS))
+    }
+
+    @Test
+    fun testMyStatsEntryPlusSubtract() {
+        val entry1 = MyStatsEntry(10, 20)
+        val entry2 = MyStatsEntry(5, 10)
+        val result = entry1.plus(entry2)
+        assertEquals(15L, result.rxBytes)
+        assertEquals(30L, result.txBytes)
+        entry1.subtract(entry2)
+        assertEquals(5L, entry1.rxBytes)
+        assertEquals(10L, entry1.txBytes)
+    }
+
+    @Test
+    fun testMyStatsEntryMinusAdd() {
+        val entry1 = MyStatsEntry(100, 200)
+        val entry2 = MyStatsEntry(10, 20)
+        val result = entry1.minus(entry2)
+        assertEquals(90L, result.rxBytes)
+        assertEquals(180L, result.txBytes)
+        entry1.add(entry2)
+        assertEquals(110L, entry1.rxBytes)
+        assertEquals(220L, entry1.txBytes)
+    }
+}
diff --git a/tests/unit/java/com/android/server/ConnectivityServiceTest.java b/tests/unit/java/com/android/server/ConnectivityServiceTest.java
old mode 100755
new mode 100644
index fefc8bfbdc..08be2ecf03
--- a/tests/unit/java/com/android/server/ConnectivityServiceTest.java
+++ b/tests/unit/java/com/android/server/ConnectivityServiceTest.java
@@ -179,7 +179,6 @@ import static com.android.testutils.ConcurrentUtils.await;
 import static com.android.testutils.ConcurrentUtils.durationOf;
 import static com.android.testutils.DevSdkIgnoreRule.IgnoreAfter;
 import static com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo;
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
 import static com.android.testutils.FunctionalUtils.ignoreExceptions;
 import static com.android.testutils.HandlerUtils.visibleOnHandlerThread;
 import static com.android.testutils.HandlerUtils.waitForIdleSerialExecutor;
@@ -190,16 +189,16 @@ import static com.android.testutils.MiscAsserts.assertLength;
 import static com.android.testutils.MiscAsserts.assertRunsInAtMost;
 import static com.android.testutils.MiscAsserts.assertSameElements;
 import static com.android.testutils.MiscAsserts.assertThrows;
-import static com.android.testutils.RecorderCallback.CallbackEntry.AVAILABLE;
-import static com.android.testutils.RecorderCallback.CallbackEntry.BLOCKED_STATUS;
-import static com.android.testutils.RecorderCallback.CallbackEntry.BLOCKED_STATUS_INT;
-import static com.android.testutils.RecorderCallback.CallbackEntry.LINK_PROPERTIES_CHANGED;
-import static com.android.testutils.RecorderCallback.CallbackEntry.LOSING;
-import static com.android.testutils.RecorderCallback.CallbackEntry.LOST;
-import static com.android.testutils.RecorderCallback.CallbackEntry.NETWORK_CAPS_UPDATED;
-import static com.android.testutils.RecorderCallback.CallbackEntry.RESUMED;
-import static com.android.testutils.RecorderCallback.CallbackEntry.SUSPENDED;
-import static com.android.testutils.RecorderCallback.CallbackEntry.UNAVAILABLE;
+import static com.android.testutils.TestableNetworkCallback.Event.AVAILABLE;
+import static com.android.testutils.TestableNetworkCallback.Event.BLOCKED_STATUS;
+import static com.android.testutils.TestableNetworkCallback.Event.BLOCKED_STATUS_INT;
+import static com.android.testutils.TestableNetworkCallback.Event.LINK_PROPERTIES_CHANGED;
+import static com.android.testutils.TestableNetworkCallback.Event.LOSING;
+import static com.android.testutils.TestableNetworkCallback.Event.LOST;
+import static com.android.testutils.TestableNetworkCallback.Event.NETWORK_CAPS_UPDATED;
+import static com.android.testutils.TestableNetworkCallback.Event.RESUMED;
+import static com.android.testutils.TestableNetworkCallback.Event.SUSPENDED;
+import static com.android.testutils.TestableNetworkCallback.Event.UNAVAILABLE;
 import static com.android.testutils.TestPermissionUtil.runAsShell;
 
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -215,12 +214,12 @@ import static org.junit.Assume.assumeFalse;
 import static org.junit.Assume.assumeTrue;
 import static org.mockito.AdditionalMatchers.aryEq;
 import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.ArgumentMatchers.argThat;
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.ArgumentMatchers.isNull;
-import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.clearInvocations;
@@ -392,6 +391,8 @@ import com.android.internal.net.VpnConfig;
 import com.android.internal.util.WakeupMessage;
 import com.android.internal.util.test.BroadcastInterceptingContext;
 import com.android.internal.util.test.FakeSettingsProvider;
+import com.android.metrics.DefaultNetworkRematchMetrics;
+import com.android.metrics.SatelliteCoarseUsageMetricsCollector;
 import com.android.modules.utils.build.SdkLevel;
 import com.android.net.module.util.ArrayTrackRecord;
 import com.android.net.module.util.BaseNetdUnsolicitedEventListener;
@@ -406,7 +407,6 @@ import com.android.server.ConnectivityService.ConnectivityDiagnosticsCallbackInf
 import com.android.server.ConnectivityService.NetworkRequestInfo;
 import com.android.server.ConnectivityServiceTest.ConnectivityServiceDependencies.DestroySocketsWrapper;
 import com.android.server.ConnectivityServiceTest.ConnectivityServiceDependencies.ReportedInterfaces;
-import com.android.server.L2capNetworkProvider;
 import com.android.server.connectivity.ApplicationSelfCertifiedNetworkCapabilities;
 import com.android.server.connectivity.AutomaticOnOffKeepaliveTracker;
 import com.android.server.connectivity.CarrierPrivilegeAuthenticator;
@@ -434,8 +434,8 @@ import com.android.testutils.FunctionalUtils.Function3;
 import com.android.testutils.FunctionalUtils.ThrowingConsumer;
 import com.android.testutils.FunctionalUtils.ThrowingRunnable;
 import com.android.testutils.HandlerUtils;
-import com.android.testutils.RecorderCallback.CallbackEntry;
 import com.android.testutils.TestableNetworkCallback;
+import com.android.testutils.TestableNetworkCallback.Event;
 import com.android.testutils.TestableNetworkOfferCallback;
 
 import libcore.junit.util.compat.CoreCompatChangeRule.DisableCompatChanges;
@@ -652,6 +652,8 @@ public class ConnectivityServiceTest {
     @Mock SubscriptionManager mSubscriptionManager;
     @Mock KeepaliveTracker.Dependencies mMockKeepaliveTrackerDependencies;
     @Mock SatelliteAccessController mSatelliteAccessController;
+    @Mock SatelliteCoarseUsageMetricsCollector mSatelliteCoarseUsageMetricsCollector;
+    @Mock DefaultNetworkRematchMetrics mDefaultNetworkRematchMetrics;
 
     // BatteryStatsManager is final and cannot be mocked with regular mockito, so just mock the
     // underlying binder calls.
@@ -690,7 +692,7 @@ public class ConnectivityServiceTest {
         // Map of permission name -> PermissionManager.Permission_{GRANTED|DENIED} constant
         // For permissions granted across the board, the key is only the permission name.
         // For permissions only granted to a combination of uid/pid, the key
-        // is "<permission name>,<pid>,<uid>". PID+UID permissons have priority over generic ones.
+        // is "<permission name>,<pid>,<uid>". PID+UID permissions have priority over generic ones.
         private final HashMap<String, Integer> mMockedPermissions = new HashMap<>();
 
         private void mockStringResource(int resId) {
@@ -2090,11 +2092,22 @@ public class ConnectivityServiceTest {
         @Override
         public SatelliteAccessController makeSatelliteAccessController(
                 @NonNull final Context context,
-                Consumer<Set<Integer>> updateSatelliteNetworkFallbackUidCallback,
+                BiConsumer<Set<Integer>, Set<Integer>> updateSatelliteNetworkFallbackUidCallback,
                 @NonNull final Handler connectivityServiceInternalHandler) {
             return mSatelliteAccessController;
         }
 
+        @Override
+        public SatelliteCoarseUsageMetricsCollector makeSatelliteCoarseUsageMetricsCollector(
+                @NonNull final Context context) {
+            return mSatelliteCoarseUsageMetricsCollector;
+        }
+
+        @Override
+        public DefaultNetworkRematchMetrics makeDefaultNetworkRematchMetrics() {
+            return mDefaultNetworkRematchMetrics;
+        }
+
         @Override
         public boolean intentFilterEquals(final PendingIntent a, final PendingIntent b) {
             return runAsShell(GET_INTENT_SENDER_INTENT, () -> a.intentFilterEquals(b));
@@ -2183,8 +2196,6 @@ public class ConnectivityServiceTest {
         public boolean isFeatureEnabled(Context context, String name) {
             switch (name) {
                 case ConnectivityFlags.NO_REMATCH_ALL_REQUESTS_ON_REGISTER:
-                case ConnectivityFlags.CARRIER_SERVICE_CHANGED_USE_CALLBACK:
-                case ConnectivityFlags.REQUEST_RESTRICTED_WIFI:
                 case ConnectivityFlags.USE_DECLARED_METHODS_FOR_CALLBACKS:
                 case ConnectivityFlags.QUEUE_CALLBACKS_FOR_FROZEN_APPS:
                 case ConnectivityFlags.BACKGROUND_FIREWALL_CHAIN:
@@ -2205,9 +2216,13 @@ public class ConnectivityServiceTest {
                 case ConnectivityFlags.INGRESS_TO_VPN_ADDRESS_FILTERING:
                 case ConnectivityFlags.BACKGROUND_FIREWALL_CHAIN:
                 case ConnectivityFlags.DELAY_DESTROY_SOCKETS:
+                case ConnectivityFlags.REQUEST_RESTRICTED_WIFI:
                 case ConnectivityFlags.USE_DECLARED_METHODS_FOR_CALLBACKS:
                 case ConnectivityFlags.QUEUE_CALLBACKS_FOR_FROZEN_APPS:
                 case ConnectivityFlags.QUEUE_NETWORK_AGENT_EVENTS_IN_SYSTEM_SERVER:
+                case ConnectivityFlags.CLOSE_QUIC_CONNECTION:
+                case ConnectivityFlags.EARLY_LINK_PROPERTIES_UPDATE_FOR_VPN:
+                case ConnectivityFlags.CONSTRAINED_DATA_SATELLITE_METRICS:
                     return true;
                 default:
                     throw new UnsupportedOperationException("Unknown flag " + name
@@ -2410,6 +2425,11 @@ public class ConnectivityServiceTest {
         public boolean shouldEnforceLocalNetRestrictions(int uid) {
             return false;
         }
+
+        @Override
+        public boolean isFeatureNotChickenedOut(Context context, String name) {
+            return true;
+        }
     }
 
     private class AutomaticOnOffKeepaliveTrackerDependencies
@@ -3382,8 +3402,8 @@ public class ConnectivityServiceTest {
                     ConnectivityServiceTest.this::waitForIdle);
         }
 
-        public CallbackEntry.Losing expectLosing(final HasNetwork n, final long timeoutMs) {
-            final CallbackEntry.Losing losing = expect(LOSING, n, timeoutMs);
+        public Event.Losing expectLosing(final HasNetwork n, final long timeoutMs) {
+            final Event.Losing losing = expect(LOSING, n, timeoutMs);
             final int maxMsToLive = losing.getMaxMsToLive();
             if (maxMsToLive < 0 || maxMsToLive > mService.mLingerDelayMs) {
                 // maxMsToLive is the value that was received in the onLosing callback. That must
@@ -3398,7 +3418,7 @@ public class ConnectivityServiceTest {
             return losing;
         }
 
-        public CallbackEntry.Losing expectLosing(final HasNetwork n) {
+        public Event.Losing expectLosing(final HasNetwork n) {
             return expectLosing(n, getDefaultTimeoutMs());
         }
     }
@@ -3463,9 +3483,9 @@ public class ConnectivityServiceTest {
         cb.assertNoCallback();
         mWiFiAgent.connect(false);
         cb.expectAvailableCallbacksUnvalidated(mWiFiAgent);
-        final CallbackEntry found = CollectionUtils.findLast(cb.getHistory(),
-                it -> it instanceof CallbackEntry.CapabilitiesChanged);
-        assertTrue(((CallbackEntry.CapabilitiesChanged) found).getCaps()
+        final Event found = CollectionUtils.findLast(cb.getHistory(),
+                it -> it instanceof Event.CapabilitiesChanged);
+        assertTrue(((Event.CapabilitiesChanged) found).getCaps()
                 .hasCapability(NET_CAPABILITY_TEMPORARILY_NOT_METERED));
         cb.assertNoCallback();
         mCm.unregisterNetworkCallback(cb);
@@ -3513,16 +3533,16 @@ public class ConnectivityServiceTest {
 
         b = expectConnectivityAction(2);
         mWiFiAgent.disconnect();
-        genericNetworkCallback.expect(CallbackEntry.LOST, mWiFiAgent);
-        wifiNetworkCallback.expect(CallbackEntry.LOST, mWiFiAgent);
+        genericNetworkCallback.expect(Event.LOST, mWiFiAgent);
+        wifiNetworkCallback.expect(Event.LOST, mWiFiAgent);
         cellNetworkCallback.assertNoCallback();
         b.expectBroadcast();
         assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
 
         b = expectConnectivityAction(1);
         mCellAgent.disconnect();
-        genericNetworkCallback.expect(CallbackEntry.LOST, mCellAgent);
-        cellNetworkCallback.expect(CallbackEntry.LOST, mCellAgent);
+        genericNetworkCallback.expect(Event.LOST, mCellAgent);
+        cellNetworkCallback.expect(Event.LOST, mCellAgent);
         b.expectBroadcast();
         assertNoCallbacks(genericNetworkCallback, wifiNetworkCallback, cellNetworkCallback);
 
@@ -7610,7 +7630,7 @@ public class ConnectivityServiceTest {
         final int CALLBACKS = 88;
         final int DIFF_INTENTS = 10;
         final int SAME_INTENTS = 10;
-        final int SYSTEM_ONLY_MAX_REQUESTS = 250;
+        final int SYSTEM_ONLY_MAX_REQUESTS = 375;
         // CALLBACKS + DIFF_INTENTS + 1 (same intent)
         // = MAX_REQUESTS - 1, since the capacity is MAX_REQUEST - 1.
         assertEquals(MAX_REQUESTS - 1, CALLBACKS + DIFF_INTENTS + 1);
@@ -7877,7 +7897,7 @@ public class ConnectivityServiceTest {
         networkAgent.connect(true);
         networkCallback.expect(AVAILABLE, networkAgent);
         networkCallback.expect(NETWORK_CAPS_UPDATED, networkAgent);
-        CallbackEntry.LinkPropertiesChanged cbi =
+        Event.LinkPropertiesChanged cbi =
                 networkCallback.expect(LINK_PROPERTIES_CHANGED, networkAgent);
         networkCallback.expect(BLOCKED_STATUS, networkAgent);
         networkCallback.expectCaps(networkAgent, c -> c.hasCapability(NET_CAPABILITY_VALIDATED));
@@ -8475,7 +8495,7 @@ public class ConnectivityServiceTest {
         reset(mMockDnsResolver);
         cellNetworkCallback.expect(AVAILABLE, mCellAgent);
         cellNetworkCallback.expect(NETWORK_CAPS_UPDATED, mCellAgent);
-        CallbackEntry.LinkPropertiesChanged cbi = cellNetworkCallback.expect(
+        Event.LinkPropertiesChanged cbi = cellNetworkCallback.expect(
                 LINK_PROPERTIES_CHANGED, mCellAgent);
         cellNetworkCallback.expect(BLOCKED_STATUS, mCellAgent);
         cellNetworkCallback.assertNoCallback();
@@ -8542,7 +8562,7 @@ public class ConnectivityServiceTest {
         waitForIdle();
         cellNetworkCallback.expect(AVAILABLE, mCellAgent);
         cellNetworkCallback.expect(NETWORK_CAPS_UPDATED, mCellAgent);
-        CallbackEntry.LinkPropertiesChanged cbi = cellNetworkCallback.expect(
+        Event.LinkPropertiesChanged cbi = cellNetworkCallback.expect(
                 LINK_PROPERTIES_CHANGED, mCellAgent);
         cellNetworkCallback.expect(BLOCKED_STATUS, mCellAgent);
         cellNetworkCallback.assertNoCallback();
@@ -9821,7 +9841,7 @@ public class ConnectivityServiceTest {
             super.expectAvailableThenValidatedCallbacks(n.getNetwork(), blockedStatus, TIMEOUT_MS);
         }
         public void onBlockedStatusChanged(Network network, int blockedReasons) {
-            getHistory().add(new CallbackEntry.BlockedStatusInt(network, blockedReasons));
+            getHistory().add(new Event.BlockedStatusInt(network, blockedReasons));
         }
     }
 
@@ -10075,7 +10095,7 @@ public class ConnectivityServiceTest {
 
         // Expect exactly one blocked callback for each agent.
         for (int i = 0; i < agents.length; i++) {
-            final CallbackEntry e = callback.expect(BLOCKED_STATUS, TIMEOUT_MS,
+            final Event e = callback.expect(BLOCKED_STATUS, TIMEOUT_MS,
                     c -> c.getBlocked() == blocked);
             final Network network = e.getNetwork();
             assertTrue("Received unexpected blocked callback for network " + network,
@@ -10599,7 +10619,7 @@ public class ConnectivityServiceTest {
         reset(mBpfNetMaps);
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testSetUidFirewallRule() throws Exception {
         doTestSetUidFirewallRule(FIREWALL_CHAIN_DOZABLE, FIREWALL_RULE_DENY);
         doTestSetUidFirewallRule(FIREWALL_CHAIN_STANDBY, FIREWALL_RULE_ALLOW);
@@ -10618,7 +10638,7 @@ public class ConnectivityServiceTest {
         doTestSetUidFirewallRule(FIREWALL_CHAIN_METERED_DENY_ADMIN, FIREWALL_RULE_ALLOW);
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testSetFirewallChainEnabled() throws Exception {
         final List<Integer> firewallChains = new ArrayList<>(Arrays.asList(
                 FIREWALL_CHAIN_DOZABLE,
@@ -10697,7 +10717,7 @@ public class ConnectivityServiceTest {
         reset(mBpfNetMaps);
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testReplaceFirewallChain() {
         doTestReplaceFirewallChain(FIREWALL_CHAIN_DOZABLE);
         doTestReplaceFirewallChain(FIREWALL_CHAIN_STANDBY);
@@ -10713,7 +10733,7 @@ public class ConnectivityServiceTest {
         doTestReplaceFirewallChain(FIREWALL_CHAIN_OEM_DENY_3);
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testInvalidFirewallChain() throws Exception {
         final int uid = 1001;
         final Class<IllegalArgumentException> expected = IllegalArgumentException.class;
@@ -10723,7 +10743,7 @@ public class ConnectivityServiceTest {
                 () -> mCm.setUidFirewallRule(100 /* chain */, uid, FIREWALL_RULE_ALLOW));
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testInvalidFirewallRule() throws Exception {
         final Class<IllegalArgumentException> expected = IllegalArgumentException.class;
         assertThrows(expected,
@@ -11927,7 +11947,7 @@ public class ConnectivityServiceTest {
         final LinkProperties testLinkProperties = new LinkProperties();
         testLinkProperties.setHttpProxy(initialProxyInfo);
         mWiFiAgent.sendLinkProperties(testLinkProperties);
-        wifiCallback.expect(CallbackEntry.LINK_PROPERTIES_CHANGED, mWiFiAgent);
+        wifiCallback.expect(Event.LINK_PROPERTIES_CHANGED, mWiFiAgent);
         cellCallback.assertNoCallback();
 
         // At first the local PAC proxy server is unstarted (see the description of what the local
@@ -11960,7 +11980,7 @@ public class ConnectivityServiceTest {
         final ProxyInfo servingProxyInfo = new ProxyInfo(pacUrl, 2097);
         final ExpectedBroadcast servingProxyBroadcast = expectProxyChangeAction(servingProxyInfo);
         mService.simulateUpdateProxyInfo(mWiFiAgent.getNetwork(), servingProxyInfo);
-        wifiCallback.expect(CallbackEntry.LINK_PROPERTIES_CHANGED, mWiFiAgent);
+        wifiCallback.expect(Event.LINK_PROPERTIES_CHANGED, mWiFiAgent);
         cellCallback.assertNoCallback();
         servingProxyBroadcast.expectBroadcast();
 
@@ -11992,14 +12012,14 @@ public class ConnectivityServiceTest {
                 lp -> lp.getLp().getHttpProxy().getPort() == -1
                         && lp.getLp().getHttpProxy().isPacProxy());
         // Wifi is lingered as it was the default but is no longer serving any request.
-        wifiCallback.expect(CallbackEntry.LOSING, mWiFiAgent);
+        wifiCallback.expect(Event.LOSING, mWiFiAgent);
 
         // Now arrange for Ethernet to have a PAC proxy.
         final ProxyInfo ethProxy = ProxyInfo.buildPacProxy(ethPacUrl);
         final LinkProperties ethLinkProperties = new LinkProperties();
         ethLinkProperties.setHttpProxy(ethProxy);
         mEthernetAgent.sendLinkProperties(ethLinkProperties);
-        ethernetCallback.expect(CallbackEntry.LINK_PROPERTIES_CHANGED, mEthernetAgent);
+        ethernetCallback.expect(Event.LINK_PROPERTIES_CHANGED, mEthernetAgent);
         // Default network is Ethernet
         assertEquals(ethProxy, mService.getProxyForNetwork(null));
         assertEquals(ethProxy, mService.getProxyForNetwork(mEthernetAgent.getNetwork()));
@@ -12019,7 +12039,7 @@ public class ConnectivityServiceTest {
         final ExpectedBroadcast servingEthProxyBroadcast = expectProxyChangeAction(servingEthProxy);
         final ExpectedBroadcast servingProxyBroadcast2 = expectProxyChangeAction(servingProxyInfo);
         mService.simulateUpdateProxyInfo(mEthernetAgent.getNetwork(), servingEthProxy);
-        ethernetCallback.expect(CallbackEntry.LINK_PROPERTIES_CHANGED, mEthernetAgent);
+        ethernetCallback.expect(Event.LINK_PROPERTIES_CHANGED, mEthernetAgent);
         assertEquals(servingEthProxy, mService.getProxyForNetwork(null));
         assertEquals(servingEthProxy, mService.getProxyForNetwork(mEthernetAgent.getNetwork()));
         assertEquals(initialProxyInfo, mService.getProxyForNetwork(mWiFiAgent.getNetwork()));
@@ -12028,7 +12048,7 @@ public class ConnectivityServiceTest {
 
         // Ethernet disconnects, back to WiFi
         mEthernetAgent.disconnect();
-        ethernetCallback.expect(CallbackEntry.LOST, mEthernetAgent);
+        ethernetCallback.expect(Event.LOST, mEthernetAgent);
 
         // WiFi is now the default network again. However, the local proxy server does not serve
         // WiFi at this time, so at this time a proxy with port -1 is still the correct value.
@@ -12051,7 +12071,7 @@ public class ConnectivityServiceTest {
         // starts up. This should cause a LP event to inform clients of the port to access the
         // proxy server for wifi.
         mService.simulateUpdateProxyInfo(mWiFiAgent.getNetwork(), servingProxyInfo);
-        wifiCallback.expect(CallbackEntry.LINK_PROPERTIES_CHANGED, mWiFiAgent);
+        wifiCallback.expect(Event.LINK_PROPERTIES_CHANGED, mWiFiAgent);
         assertEquals(servingProxyInfo, mService.getProxyForNetwork(null));
         assertEquals(servingProxyInfo, mService.getProxyForNetwork(mWiFiAgent.getNetwork()));
         assertNull(mService.getProxyForNetwork(mCellAgent.getNetwork()));
@@ -12065,7 +12085,7 @@ public class ConnectivityServiceTest {
                 proxy -> proxy == null || TextUtils.isEmpty(proxy.getHost()));
         mWiFiAgent.disconnect();
         emptyProxyBroadcast.expectBroadcast();
-        wifiCallback.expect(CallbackEntry.LOST, mWiFiAgent);
+        wifiCallback.expect(Event.LOST, mWiFiAgent);
         assertNull(mService.getProxyForNetwork(null));
         assertNull(mService.getLinkProperties(mCellAgent.getNetwork()).getHttpProxy());
         assertNull(mService.getGlobalProxy());
@@ -12095,7 +12115,7 @@ public class ConnectivityServiceTest {
         final ProxyInfo servingProxyInfo = new ProxyInfo(pacUrl, 2097);
         final ExpectedBroadcast servingProxyBroadcast = expectProxyChangeAction(servingProxyInfo);
         mService.simulateUpdateProxyInfo(mWiFiAgent.getNetwork(), servingProxyInfo);
-        wifiCallback.expect(CallbackEntry.LINK_PROPERTIES_CHANGED, mWiFiAgent);
+        wifiCallback.expect(Event.LINK_PROPERTIES_CHANGED, mWiFiAgent);
         servingProxyBroadcast.expectBroadcast();
 
         // Now disconnect Wi-Fi and make sure there is a broadcast for some empty proxy. Whether
@@ -12104,7 +12124,7 @@ public class ConnectivityServiceTest {
         final ExpectedBroadcast emptyProxyBroadcast = expectProxyChangeAction(
                 proxy -> proxy == null || TextUtils.isEmpty(proxy.getHost()));
         mWiFiAgent.disconnect();
-        wifiCallback.expect(CallbackEntry.LOST, mWiFiAgent);
+        wifiCallback.expect(Event.LOST, mWiFiAgent);
         emptyProxyBroadcast.expectBroadcast();
     }
 
@@ -13949,7 +13969,7 @@ public class ConnectivityServiceTest {
                         && session.getSessionType() == QosSession.TYPE_NR_BEARER));
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testQosCallbackAvailableOnValidationError() throws Exception {
         mQosCallbackMockHelper = new QosCallbackMockHelper();
         final NetworkAgentWrapper wrapper = mQosCallbackMockHelper.mAgentWrapper;
@@ -13985,7 +14005,7 @@ public class ConnectivityServiceTest {
                 .onError(eq(QosCallbackException.EX_TYPE_FILTER_SOCKET_REMOTE_ADDRESS_CHANGED));
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testQosCallbackLostOnValidationError() throws Exception {
         mQosCallbackMockHelper = new QosCallbackMockHelper();
         final int sessionId = 10;
@@ -18478,7 +18498,7 @@ public class ConnectivityServiceTest {
                 null /* callingAttributionTag */));
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testUpdateRateLimit_EnableDisable() throws Exception {
         final LinkProperties wifiLp = new LinkProperties();
         wifiLp.setInterfaceName(WIFI_IFNAME);
@@ -18517,7 +18537,7 @@ public class ConnectivityServiceTest {
                 it -> it.first == cellLp.getInterfaceName() && it.second == -1));
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testUpdateRateLimit_WhenNewNetworkIsAdded() throws Exception {
         final LinkProperties wifiLp = new LinkProperties();
         wifiLp.setInterfaceName(WIFI_IFNAME);
@@ -18543,7 +18563,7 @@ public class ConnectivityServiceTest {
                 && it.second == rateLimitInBytesPerSec));
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testUpdateRateLimit_OnlyAffectsInternetCapableNetworks() throws Exception {
         final LinkProperties wifiLp = new LinkProperties();
         wifiLp.setInterfaceName(WIFI_IFNAME);
@@ -18561,7 +18581,7 @@ public class ConnectivityServiceTest {
         assertNull(readHeadWifi.poll(TIMEOUT_MS, it -> it.first == wifiLp.getInterfaceName()));
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testUpdateRateLimit_DisconnectingResetsRateLimit()
             throws Exception {
         // Steps:
@@ -18597,7 +18617,7 @@ public class ConnectivityServiceTest {
         assertNull(readHeadWifi.poll(TIMEOUT_MS, it -> it.first == wifiLp.getInterfaceName()));
     }
 
-    @Test @IgnoreUpTo(SC_V2)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.S_V2)
     public void testUpdateRateLimit_UpdateExistingRateLimit() throws Exception {
         final LinkProperties wifiLp = new LinkProperties();
         wifiLp.setInterfaceName(WIFI_IFNAME);
@@ -18627,7 +18647,7 @@ public class ConnectivityServiceTest {
                         && it.second == 2000));
     }
 
-    @Test @IgnoreAfter(SC_V2)
+    @Test @IgnoreAfter(Build.VERSION_CODES.S_V2)
     public void testUpdateRateLimit_DoesNothingBeforeT() throws Exception {
         final LinkProperties wifiLp = new LinkProperties();
         wifiLp.setInterfaceName(WIFI_IFNAME);
diff --git a/tests/unit/java/com/android/server/NsdServiceTest.java b/tests/unit/java/com/android/server/NsdServiceTest.java
index 979e0a154a..86f177ac6e 100644
--- a/tests/unit/java/com/android/server/NsdServiceTest.java
+++ b/tests/unit/java/com/android/server/NsdServiceTest.java
@@ -23,6 +23,7 @@ import static android.app.ActivityManager.RunningAppProcessInfo.IMPORTANCE_CACHE
 import static android.app.ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND;
 import static android.app.ActivityManager.RunningAppProcessInfo.IMPORTANCE_GONE;
 import static android.app.ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE;
+import static android.content.pm.PackageManager.FEATURE_LEANBACK;
 import static android.content.pm.PackageManager.PERMISSION_DENIED;
 import static android.content.pm.PackageManager.PERMISSION_GRANTED;
 import static android.net.InetAddresses.parseNumericAddress;
@@ -55,10 +56,12 @@ import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assume.assumeTrue;
 import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.ArgumentMatchers.argThat;
 import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.doCallRealMethod;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.eq;
@@ -96,6 +99,7 @@ import android.net.nsd.NsdManager.ResolveListener;
 import android.net.nsd.NsdManager.ServiceInfoCallback;
 import android.net.nsd.NsdServiceInfo;
 import android.net.nsd.OffloadEngine;
+import android.net.nsd.OffloadServiceInfo;
 import android.net.wifi.WifiManager;
 import android.os.Binder;
 import android.os.Build;
@@ -203,6 +207,7 @@ public class NsdServiceTest {
     HandlerThread mThread;
     TestHandler mHandler;
     NsdService mService;
+    MdnsAdvertiser.AdvertiserCallback mAdvertiserCallback;
 
     private static class LinkToDeathRecorder extends Binder {
         IBinder.DeathRecipient mDr;
@@ -244,8 +249,10 @@ public class NsdServiceTest {
         doReturn(mSocketProvider).when(mDeps).makeMdnsSocketProvider(any(), any(), any(), any());
         doReturn(DEFAULT_RUNNING_APP_ACTIVE_IMPORTANCE_CUTOFF).when(mDeps).getDeviceConfigInt(
                 eq(NsdService.MDNS_CONFIG_RUNNING_APP_ACTIVE_IMPORTANCE_CUTOFF), anyInt());
-        doReturn(mAdvertiser).when(mDeps).makeMdnsAdvertiser(any(), any(), any(), any(), any(),
-                any());
+        doAnswer(inv -> {
+            mAdvertiserCallback = (MdnsAdvertiser.AdvertiserCallback) inv.getArguments()[2];
+            return mAdvertiser;
+        }).when(mDeps).makeMdnsAdvertiser(any(), any(), any(), any(), any(), any());
         doReturn(mMetrics).when(mDeps).makeNetworkNsdReportedMetrics(anyInt());
         doReturn(mClock).when(mDeps).makeClock();
         doReturn(TEST_TIME_MS).when(mClock).elapsedRealtime();
@@ -546,7 +553,6 @@ public class NsdServiceTest {
                 12345, /* port */
                 List.of(IPV4_ADDRESS),
                 List.of(IPV6_ADDRESS),
-                List.of(), /* textStrings */
                 List.of(), /* textEntries */
                 interfaceIdx, /* interfaceIndex */
                 null /* network */,
@@ -1025,7 +1031,6 @@ public class NsdServiceTest {
                 PORT,
                 List.of(IPV4_ADDRESS),
                 List.of(IPV6_ADDRESS),
-                List.of() /* textStrings */,
                 List.of() /* textEntries */,
                 1234,
                 network,
@@ -1056,7 +1061,6 @@ public class NsdServiceTest {
                 PORT,
                 List.of(v4Address),
                 List.of(v6Address),
-                List.of() /* textStrings */,
                 List.of() /* textEntries */,
                 1234,
                 network,
@@ -1189,7 +1193,6 @@ public class NsdServiceTest {
                 12345, /* port */
                 List.of(IPV4_ADDRESS),
                 List.of(IPV6_ADDRESS),
-                List.of(), /* textStrings */
                 List.of(), /* textEntries */
                 1234, /* interfaceIndex */
                 network,
@@ -1211,7 +1214,6 @@ public class NsdServiceTest {
                 0, /* port */
                 List.of(), /* ipv4Address */
                 List.of(), /* ipv6Address */
-                null, /* textStrings */
                 null, /* textEntries */
                 1234, /* interfaceIndex */
                 network,
@@ -1333,7 +1335,6 @@ public class NsdServiceTest {
                 PORT,
                 List.of(IPV4_ADDRESS),
                 List.of("2001:db8::1", "2001:db8::2"),
-                List.of() /* textStrings */,
                 List.of(MdnsServiceInfo.TextEntry.fromBytes(new byte[]{
                         'k', 'e', 'y', '=', (byte) 0xFF, (byte) 0xFE})) /* textEntries */,
                 1234,
@@ -1656,6 +1657,54 @@ public class NsdServiceTest {
                 .onRegistrationFailed(any(), eq(FAILURE_BAD_PARAMETERS));
     }
 
+    @Test
+    public void testAdvertiseOffloadOnly_FailsForNonTv() {
+        setMdnsAdvertiserEnabled();
+        doReturn(false).when(mPackageManager).hasSystemFeature(FEATURE_LEANBACK);
+        final NsdManager client = connectClient(mService);
+        final RegistrationListener regListener = mock(RegistrationListener.class);
+        final ArgumentCaptor<MdnsAdvertiser.AdvertiserCallback> cbCaptor =
+                ArgumentCaptor.forClass(MdnsAdvertiser.AdvertiserCallback.class);
+        verify(mDeps).makeMdnsAdvertiser(any(), any(), cbCaptor.capture(), any(), any(), any());
+
+        final NsdServiceInfo regInfo = new NsdServiceInfo("Service custom TTL", SERVICE_TYPE);
+        regInfo.setPort(1234);
+        final AdvertisingRequest request =
+                new AdvertisingRequest.Builder(regInfo, NsdManager.PROTOCOL_DNS_SD)
+                        .setFlags(AdvertisingRequest.FLAG_OFFLOAD_ONLY).build();
+        client.registerService(request, Runnable::run, regListener);
+        waitForIdle();
+
+        verify(regListener, timeout(TIMEOUT_MS))
+                .onRegistrationFailed(any(), eq(FAILURE_BAD_PARAMETERS));
+    }
+
+    @Test
+    public void testAdvertiseOffloadOnly_SupportForTvRunningAndroidB() {
+        assumeTrue(Build.VERSION_CODES.BAKLAVA == Build.VERSION.SDK_INT);
+        setMdnsAdvertiserEnabled();
+        doReturn(true).when(mPackageManager).hasSystemFeature(FEATURE_LEANBACK);
+        final NsdManager client = connectClient(mService);
+        final RegistrationListener regListener = mock(RegistrationListener.class);
+        final ArgumentCaptor<MdnsAdvertiser.AdvertiserCallback> cbCaptor =
+                ArgumentCaptor.forClass(MdnsAdvertiser.AdvertiserCallback.class);
+        verify(mDeps).makeMdnsAdvertiser(any(), any(), cbCaptor.capture(), any(), any(), any());
+
+        final NsdServiceInfo regInfo = new NsdServiceInfo("Service custom TTL", SERVICE_TYPE);
+        regInfo.setPort(1234);
+        final AdvertisingRequest request =
+                new AdvertisingRequest.Builder(regInfo, NsdManager.PROTOCOL_DNS_SD)
+                        .setFlags(AdvertisingRequest.FLAG_OFFLOAD_ONLY).build();
+        client.registerService(request, Runnable::run, regListener);
+        waitForIdle();
+
+        final ArgumentCaptor<MdnsAdvertisingOptions> optionsCaptor =
+                ArgumentCaptor.forClass(MdnsAdvertisingOptions.class);
+        verify(mAdvertiser).addOrUpdateService(anyInt(), any(),
+                optionsCaptor.capture(), anyInt());
+        assertTrue(optionsCaptor.getValue().isOffloadOnly());
+    }
+
     @Test
     public void testStopServiceResolutionWithMdnsDiscoveryManager() {
         setMdnsDiscoveryManagerEnabled();
@@ -2040,6 +2089,61 @@ public class NsdServiceTest {
         client.unregisterOffloadEngine(offloadEngine);
     }
 
+    private OffloadEngine registerOffloadEngine(String interfaceName) {
+        final NsdManager client = connectClient(mService);
+        final OffloadEngine offloadEngine = mock(OffloadEngine.class);
+        doReturn(PERMISSION_GRANTED).when(mContext).checkCallingOrSelfPermission(
+                REGISTER_NSD_OFFLOAD_ENGINE);
+        client.registerOffloadEngine(interfaceName, OffloadEngine.OFFLOAD_TYPE_REPLY,
+                OffloadEngine.OFFLOAD_CAPABILITY_BYPASS_MULTICAST_LOCK, Runnable::run,
+                offloadEngine);
+        waitForIdle();
+        return offloadEngine;
+    }
+
+    @Test
+    @EnableCompatChanges(ENABLE_PLATFORM_MDNS_BACKEND)
+    @DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+    public void testRegisterOffloadEngine_sendAllOffloadServiceInfos() {
+        final String interfaceName = "iface";
+        final OffloadServiceInfo info = new OffloadServiceInfo(
+                new OffloadServiceInfo.Key("_testService", "_testType"), List.of("_sub1", "_sub2"),
+                "Android.local", new byte[] { 0x1, 0x2, 0x3 }, 1 /* priority */,
+                OffloadEngine.OFFLOAD_TYPE_REPLY);
+        doReturn(List.of(new MdnsAdvertiser.OffloadServiceInfoWrapper(123, info)))
+                .when(mAdvertiser).getAllInterfaceOffloadServiceInfos(interfaceName);
+        final OffloadEngine offloadEngine = registerOffloadEngine(interfaceName);
+        // Verify that the OffloadServiceInfo retrieves from the advertiser and then sends it to
+        // the OffloadEngine.
+        verify(mAdvertiser).getAllInterfaceOffloadServiceInfos(interfaceName);
+        verify(offloadEngine).onOffloadServiceUpdated(info);
+    }
+
+    @Test
+    @EnableCompatChanges(ENABLE_PLATFORM_MDNS_BACKEND)
+    @DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+    public void testRegisterOffloadEngine_OffloadServiceUpdatedAndRemoved() {
+        final String interfaceName = "iface";
+        final OffloadServiceInfo info = new OffloadServiceInfo(
+                new OffloadServiceInfo.Key("_testService", "_testType"), List.of("_sub1", "_sub2"),
+                "Android.local", new byte[] { 0x1, 0x2, 0x3 }, 1 /* priority */,
+                OffloadEngine.OFFLOAD_TYPE_REPLY);
+        doReturn(Collections.emptyList()).when(mAdvertiser)
+                .getAllInterfaceOffloadServiceInfos(anyString());
+        final OffloadEngine offloadEngine = registerOffloadEngine(interfaceName);
+        // Verify that the OffloadServiceInfo retrieves from the advertiser and that no info is
+        // sent to the OffloadEngine.
+        verify(mAdvertiser).getAllInterfaceOffloadServiceInfos(interfaceName);
+        verify(offloadEngine, never()).onOffloadServiceUpdated(any());
+        // onOffloadStartOrUpdate callback triggered. The OffloadServiceInfo update should be sent
+        // to the OffloadEngine.
+        mAdvertiserCallback.onOffloadStartOrUpdate(interfaceName, info);
+        verify(offloadEngine).onOffloadServiceUpdated(info);
+        // onOffloadStop callback triggered. The OffloadServiceInfo removal should be sent to the
+        // OffloadEngine.
+        mAdvertiserCallback.onOffloadStop(interfaceName, info);
+        verify(offloadEngine).onOffloadServiceRemoved(info);
+    }
 
     private void waitForIdle() {
         HandlerUtils.waitForIdle(mHandler, TIMEOUT_MS);
diff --git a/tests/unit/java/com/android/server/connectivity/BroadcastReceiveHelperTest.kt b/tests/unit/java/com/android/server/connectivity/BroadcastReceiveHelperTest.kt
new file mode 100644
index 0000000000..70dc322a86
--- /dev/null
+++ b/tests/unit/java/com/android/server/connectivity/BroadcastReceiveHelperTest.kt
@@ -0,0 +1,306 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.connectivity
+
+import android.content.BroadcastReceiver
+import android.content.Context
+import android.content.Intent
+import android.content.Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE
+import android.content.Intent.ACTION_PACKAGE_ADDED
+import android.content.Intent.ACTION_PACKAGE_REMOVED
+import android.content.Intent.ACTION_PACKAGE_REPLACED
+import android.content.Intent.ACTION_USER_ADDED
+import android.content.Intent.ACTION_USER_REMOVED
+import android.content.Intent.EXTRA_CHANGED_PACKAGE_LIST
+import android.content.Intent.EXTRA_UID
+import android.content.Intent.EXTRA_USER
+import android.net.Uri
+import android.os.Handler
+import android.os.HandlerThread
+import android.os.UserHandle
+import android.os.UserManager
+import com.android.compatibility.common.util.MoreMatchers.anyOrNull
+import com.android.server.connectivity.BroadcastReceiveHelper.Delegate
+import com.android.testutils.DevSdkIgnoreRunner
+import com.android.testutils.waitForIdle
+import org.junit.After
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.ArgumentCaptor
+import org.mockito.ArgumentMatchers.argThat
+import org.mockito.ArgumentMatchers.eq
+import org.mockito.Mockito.doReturn
+import org.mockito.Mockito.mock
+import org.mockito.Mockito.times
+import org.mockito.Mockito.verify
+
+private const val TEST_PACKAGE_NAME = "com.example.app"
+private const val TEST_UID = 1000
+private const val TIMEOUT_MS = 2000
+
+private inline fun <reified T> any() = org.mockito.Mockito.any(T::class.java)
+
+@DevSdkIgnoreRunner.MonitorThreadLeak
+@RunWith(DevSdkIgnoreRunner::class)
+class BroadcastReceiveHelperTest {
+    private val mockContext = mock(Context::class.java)
+    private val mockDelegate = mock(Delegate::class.java)
+    private val mockUserManager = mock(UserManager::class.java)
+
+    // Create an InOrder object to verify the sequence of delegate calls.
+    private val delegateInOrderVerifier = org.mockito.Mockito.inOrder(mockDelegate)
+
+    // lateinit is used here because thread and handler need to be initialized in the
+    // @Before setUp method.
+    private lateinit var handlerThread: HandlerThread
+    private lateinit var handler: Handler
+    private lateinit var broadcastReceiveHelper: BroadcastReceiveHelper
+    private lateinit var packageReceiver: BroadcastReceiver
+    private lateinit var externalAppReceiver: BroadcastReceiver
+    private lateinit var userReceiver: BroadcastReceiver
+
+    @Before
+    fun setUp() {
+        handlerThread = HandlerThread("TestThread")
+        handlerThread.start()
+        handler = Handler(handlerThread.looper)
+        broadcastReceiveHelper = BroadcastReceiveHelper(mockContext, handler, mockDelegate)
+
+        // Capture intent receivers.
+        doReturn(mockUserManager).`when`(mockContext).getSystemService(UserManager::class.java)
+        doReturn(mockContext).`when`(mockContext).createContextAsUser(UserHandle.ALL, 0)
+        broadcastReceiveHelper.registerReceivers()
+        userReceiver = captureIntentReceiver(ACTION_USER_ADDED)
+        packageReceiver = captureIntentReceiver(ACTION_PACKAGE_ADDED)
+        externalAppReceiver = captureIntentReceiver(ACTION_EXTERNAL_APPLICATIONS_AVAILABLE)
+    }
+
+    private fun captureIntentReceiver(action: String): BroadcastReceiver {
+        val receiverCaptor = ArgumentCaptor.forClass(BroadcastReceiver::class.java)
+        verify(mockContext, times(1)).registerReceiver(
+                receiverCaptor.capture(),
+                argThat { it.hasAction(action) },
+                anyOrNull(String::class.java),
+                eq(handler)
+        )
+        // Return the first match.
+        return receiverCaptor.value
+    }
+
+    @After
+    fun tearDown() {
+        broadcastReceiveHelper.unregisterReceivers()
+        handlerThread.quitSafely()
+        handlerThread.join()
+    }
+
+    @Test
+    fun testPackageAdded() {
+        val intent = Intent(ACTION_PACKAGE_ADDED).apply {
+            data = Uri.fromParts("package", TEST_PACKAGE_NAME, null)
+            putExtra(EXTRA_UID, TEST_UID)
+        }
+        processOnHandlerThread { packageReceiver.onReceive(mockContext, intent) }
+        delegateInOrderVerifier.verify(mockDelegate).onPackageAdded(TEST_PACKAGE_NAME, TEST_UID)
+        delegateInOrderVerifier.verifyNoMoreInteractions()
+    }
+
+    @Test
+    fun testPackageRemoved() {
+        val intent = Intent(ACTION_PACKAGE_REMOVED).apply {
+            data = Uri.fromParts("package", TEST_PACKAGE_NAME, null)
+            putExtra(EXTRA_UID, TEST_UID)
+        }
+        processOnHandlerThread { packageReceiver.onReceive(mockContext, intent) }
+        delegateInOrderVerifier.verify(mockDelegate).onPackageRemoved(TEST_PACKAGE_NAME, TEST_UID)
+        delegateInOrderVerifier.verifyNoMoreInteractions()
+    }
+
+    @Test
+    fun testPackageReplaced() {
+        val intent = Intent(ACTION_PACKAGE_REPLACED).apply {
+            data = Uri.fromParts("package", TEST_PACKAGE_NAME, null)
+            putExtra(EXTRA_UID, TEST_UID)
+        }
+        processOnHandlerThread { packageReceiver.onReceive(mockContext, intent) }
+        delegateInOrderVerifier.verify(mockDelegate).onPackageReplaced(TEST_PACKAGE_NAME, TEST_UID)
+        delegateInOrderVerifier.verifyNoMoreInteractions()
+    }
+
+    @Test
+    fun testExternalAppsAvailable() {
+        val packageList = arrayOf("com.example.app1", "com.example.app2")
+        val intent = Intent(ACTION_EXTERNAL_APPLICATIONS_AVAILABLE).apply {
+            putExtra(EXTRA_CHANGED_PACKAGE_LIST, packageList)
+        }
+        processOnHandlerThread { externalAppReceiver.onReceive(mockContext, intent) }
+        delegateInOrderVerifier.verify(mockDelegate).onExternalApplicationsAvailable(packageList)
+        delegateInOrderVerifier.verifyNoMoreInteractions()
+    }
+
+    @Test
+    fun testUserAdded() {
+        val userHandle = mock(UserHandle::class.java)
+        val intent = Intent(ACTION_USER_ADDED).apply {
+            putExtra(EXTRA_USER, userHandle)
+        }
+        processOnHandlerThread { userReceiver.onReceive(mockContext, intent) }
+        delegateInOrderVerifier.verify(mockDelegate).onUserAdded(userHandle)
+        delegateInOrderVerifier.verifyNoMoreInteractions()
+    }
+
+    @Test
+    fun testUserRemoved() {
+        val userHandle = mock(UserHandle::class.java)
+        val intent = Intent(ACTION_USER_REMOVED).apply {
+            putExtra(EXTRA_USER, userHandle)
+        }
+        processOnHandlerThread { userReceiver.onReceive(mockContext, intent) }
+        delegateInOrderVerifier.verify(mockDelegate).onUserRemoved(userHandle)
+        delegateInOrderVerifier.verifyNoMoreInteractions()
+    }
+
+    @Test
+    fun testUnregisterReceivers() {
+        broadcastReceiveHelper.unregisterReceivers()
+        verify(mockContext).unregisterReceiver(userReceiver)
+        verify(mockContext).unregisterReceiver(packageReceiver)
+        verify(mockContext).unregisterReceiver(externalAppReceiver)
+    }
+
+    @Test
+    fun testBroadcastOrder() {
+        val numEvents = 50
+        val random = java.util.Random()
+        val eventList = mutableListOf<Intent>()
+
+        // Function to append a test package name extra.
+        fun Intent.withPackageNameForIndex(index: Int): Intent {
+            data = Uri.fromParts("package", "com.example.app$index", null)
+            putExtra(EXTRA_UID, index)
+            return this
+        }
+
+        // Function to append a mock UserHandle extra.
+        fun Intent.withUserHandleForIndex(index: Int): Intent {
+            putExtra(EXTRA_USER, UserHandle.of(index))
+            return this
+        }
+
+        // Generate a list of 50 random actions and their corresponding intents.
+        repeat(numEvents) { index ->
+            val intent = when (random.nextInt(6)) {
+                0 -> Intent(ACTION_PACKAGE_ADDED).withPackageNameForIndex(index)
+                1 -> Intent(ACTION_PACKAGE_REMOVED).withPackageNameForIndex(index)
+                2 -> Intent(ACTION_PACKAGE_REPLACED).withPackageNameForIndex(index)
+                3 -> Intent(ACTION_EXTERNAL_APPLICATIONS_AVAILABLE).apply {
+                    val packageList = arrayOf("com.example.app$index")
+                    putExtra(EXTRA_CHANGED_PACKAGE_LIST, packageList)
+                }
+
+                4 -> Intent(ACTION_USER_ADDED).withUserHandleForIndex(index)
+                5 -> Intent(ACTION_USER_REMOVED).withUserHandleForIndex(index)
+
+                else -> throw IllegalStateException("Unexpected random number")
+            }
+            eventList.add(intent)
+        }
+
+        // Post all intents to the handler thread at once.
+        eventList.forEach {
+            handler.post {
+                when (it.action) {
+                    ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED, ACTION_PACKAGE_REPLACED ->
+                        packageReceiver.onReceive(mockContext, it)
+
+                    ACTION_EXTERNAL_APPLICATIONS_AVAILABLE ->
+                        externalAppReceiver.onReceive(mockContext, it)
+
+                    ACTION_USER_ADDED, ACTION_USER_REMOVED ->
+                        userReceiver.onReceive(mockContext, it)
+                }
+            }
+        }
+
+        // Wait for all intents to be processed at once.
+        handler.waitForIdle(TIMEOUT_MS)
+
+        // Verify the order of delegate calls.
+        eventList.forEach {
+            when (it.action) {
+                ACTION_PACKAGE_ADDED -> delegateInOrderVerifier.verify(mockDelegate)
+                        .onPackageAdded(
+                                it.data?.schemeSpecificPart!!,
+                                it.getIntExtra(EXTRA_UID, -1)
+                        )
+
+                ACTION_PACKAGE_REMOVED -> delegateInOrderVerifier.verify(mockDelegate)
+                        .onPackageRemoved(
+                                it.data?.schemeSpecificPart!!,
+                                it.getIntExtra(EXTRA_UID, -1)
+                        )
+
+                ACTION_PACKAGE_REPLACED -> delegateInOrderVerifier.verify(mockDelegate)
+                        .onPackageReplaced(
+                                it.data?.schemeSpecificPart!!,
+                                it.getIntExtra(EXTRA_UID, -1)
+                        )
+
+                ACTION_EXTERNAL_APPLICATIONS_AVAILABLE ->
+                    delegateInOrderVerifier.verify(mockDelegate)
+                            .onExternalApplicationsAvailable(it.getStringArrayExtra(
+                                    EXTRA_CHANGED_PACKAGE_LIST
+                            )!!)
+
+                ACTION_USER_ADDED -> delegateInOrderVerifier.verify(mockDelegate)
+                        .onUserAdded(it.getParcelableExtra(EXTRA_USER)!!)
+
+                ACTION_USER_REMOVED -> delegateInOrderVerifier.verify(mockDelegate)
+                        .onUserRemoved(it.getParcelableExtra(EXTRA_USER)!!)
+            }
+        }
+
+        // Ensure no other calls were made to the delegate.
+        delegateInOrderVerifier.verifyNoMoreInteractions()
+    }
+
+    private fun processOnHandlerThread(function: Runnable) {
+        handler.post { function.run() }
+        // Wait twice since the onReceive defers actual handling logic to another message.
+        // See BroadcastReceiveHelper#HandlerPostReceiver.
+        handler.waitForIdle(HANDLER_TIMEOUT_MS)
+        handler.waitForIdle(HANDLER_TIMEOUT_MS)
+    }
+
+    @Test
+    fun testCallOnUserAddedForInitialUsers() {
+        // Mock existing users.
+        val existingUser1 = mock(UserHandle::class.java)
+        val existingUser2 = mock(UserHandle::class.java)
+        val existingUsers = listOf(existingUser1, existingUser2)
+        doReturn(existingUsers).`when`(mockUserManager).getUserHandles(any())
+        // Make sure there is no interactions.
+        delegateInOrderVerifier.verifyNoMoreInteractions()
+
+        // Verify that onUserAdded is called for each existing user.
+        processOnHandlerThread { broadcastReceiveHelper.callOnUserAddedForExistingUsers() }
+        delegateInOrderVerifier.verify(mockDelegate).onUserAdded(existingUser1)
+        delegateInOrderVerifier.verify(mockDelegate).onUserAdded(existingUser2)
+        delegateInOrderVerifier.verifyNoMoreInteractions()
+    }
+}
diff --git a/tests/unit/java/com/android/server/connectivity/CarrierPrivilegeAuthenticatorTest.java b/tests/unit/java/com/android/server/connectivity/CarrierPrivilegeAuthenticatorTest.java
index ab81abc030..54ac4fb3ba 100644
--- a/tests/unit/java/com/android/server/connectivity/CarrierPrivilegeAuthenticatorTest.java
+++ b/tests/unit/java/com/android/server/connectivity/CarrierPrivilegeAuthenticatorTest.java
@@ -141,7 +141,7 @@ public class CarrierPrivilegeAuthenticatorTest {
         mHandlerThread = new HandlerThread(CarrierPrivilegeAuthenticatorTest.class.getSimpleName());
         mUseCallbacks = useCallbacks;
         final Dependencies deps = mock(Dependencies.class);
-        doReturn(useCallbacks).when(deps).isFeatureEnabled(any() /* context */,
+        doReturn(useCallbacks).when(deps).isFeatureNotChickenedOut(any() /* context */,
                 eq(CARRIER_SERVICE_CHANGED_USE_CALLBACK));
         doReturn(mHandlerThread).when(deps).makeHandlerThread();
         doReturn(SUBSCRIPTION_COUNT).when(mTelephonyManager).getActiveModemCount();
diff --git a/tests/unit/java/com/android/server/connectivity/IntegerRangeUtilsTest.java b/tests/unit/java/com/android/server/connectivity/IntegerRangeUtilsTest.java
new file mode 100644
index 0000000000..b290459446
--- /dev/null
+++ b/tests/unit/java/com/android/server/connectivity/IntegerRangeUtilsTest.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.connectivity;
+
+import static org.junit.Assert.assertEquals;
+
+import android.os.Build;
+import android.util.Range;
+
+import com.android.testutils.DevSdkIgnoreRule;
+import com.android.testutils.DevSdkIgnoreRunner;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.List;
+import java.util.Set;
+
+/**
+ * Tests for IntegerRangeUtils.
+ */
+@RunWith(DevSdkIgnoreRunner.class)
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.R)
+public class IntegerRangeUtilsTest {
+    @Test
+    @DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.R)
+    public void testRangeWithoutValues() {
+        final Range<Integer> source1 = Range.create(100, 200);
+        // Basic separation after excluding exempt Integer list.
+        final List<Integer> exempt1 = List.of(110, 170);
+        final Set<Range<Integer>> expected1 = Set.of(
+                Range.create(100, 109),
+                Range.create(111, 169),
+                Range.create(171, 200));
+        // Check continuous exempt list.
+        final List<Integer> exempt2 = List.of(110, 111, 112, 114);
+        final Set<Range<Integer>> expected2 = Set.of(
+                Range.create(100, 109),
+                Range.create(113, 113),
+                Range.create(115, 200));
+        // Check handling exempted Integer on the edge of range.
+        final List<Integer> exempt3 = List.of(100, 199, 200);
+        final Set<Range<Integer>> expected3 = Set.of(
+                Range.create(101, 198)
+        );
+        final List<Integer> exempt4 = List.of(100, 101, 102, 200);
+        final Set<Range<Integer>> expected4 = Set.of(
+                Range.create(103, 199)
+        );
+        // Check handling exempted Integer list out of the source range.
+        final List<Integer> exempt5 = List.of(99, 201);
+        final Set<Range<Integer>> expected5 = Set.of(
+                Range.create(100, 200)
+        );
+        final List<Integer> exempt6 = List.of(99, 150, 200, 201);
+        final Set<Range<Integer>> expected6 = Set.of(
+                Range.create(100, 149),
+                Range.create(151, 199)
+        );
+        // Check handling unordered exempted Integer list.
+        final List<Integer> exempt7 = List.of(200, 99, 201, 150, 117);
+        final Set<Range<Integer>> expected7 = Set.of(
+                Range.create(100, 116),
+                Range.create(118, 149),
+                Range.create(151, 199)
+        );
+        assertEquals(expected1, IntegerRangeUtils.rangeWithoutValues(source1, exempt1));
+        assertEquals(expected2, IntegerRangeUtils.rangeWithoutValues(source1, exempt2));
+        assertEquals(expected3, IntegerRangeUtils.rangeWithoutValues(source1, exempt3));
+        assertEquals(expected4, IntegerRangeUtils.rangeWithoutValues(source1, exempt4));
+        assertEquals(expected5, IntegerRangeUtils.rangeWithoutValues(source1, exempt5));
+        assertEquals(expected6, IntegerRangeUtils.rangeWithoutValues(source1, exempt6));
+        assertEquals(expected7, IntegerRangeUtils.rangeWithoutValues(source1, exempt7));
+        // Check the case that source range is included in exempted list.
+        final Range<Integer> source2 = Range.create(100, 101);
+        final List<Integer> exempt8 = List.of(99, 100, 101);
+        final Set<Range<Integer>> expected8 = Set.of();
+        assertEquals(expected8, IntegerRangeUtils.rangeWithoutValues(source2, exempt8));
+    }
+}
diff --git a/tests/unit/java/com/android/server/connectivity/MultinetworkPolicyTrackerTest.kt b/tests/unit/java/com/android/server/connectivity/MultinetworkPolicyTrackerTest.kt
index f19ba4f5c7..fd75f8ef72 100644
--- a/tests/unit/java/com/android/server/connectivity/MultinetworkPolicyTrackerTest.kt
+++ b/tests/unit/java/com/android/server/connectivity/MultinetworkPolicyTrackerTest.kt
@@ -17,34 +17,44 @@
 package com.android.server.connectivity
 
 import android.content.Context
+import android.content.pm.PackageManager
 import android.content.res.Resources
 import android.net.ConnectivityManager.MULTIPATH_PREFERENCE_HANDOVER
 import android.net.ConnectivityManager.MULTIPATH_PREFERENCE_PERFORMANCE
 import android.net.ConnectivityManager.MULTIPATH_PREFERENCE_RELIABILITY
 import android.net.ConnectivitySettingsManager.NETWORK_AVOID_BAD_WIFI
 import android.net.ConnectivitySettingsManager.NETWORK_METERED_MULTIPATH_PREFERENCE
+import android.net.platform.flags.Flags.FLAG_AVOID_BAD_WIFI_FROM_CARRIER_CONFIG
 import android.os.Build
 import android.os.Handler
 import android.os.test.TestLooper
 import android.provider.Settings
+import android.telephony.CarrierConfigManager
 import android.telephony.SubscriptionInfo
 import android.telephony.SubscriptionManager
 import android.telephony.TelephonyManager
 import android.test.mock.MockContentResolver
 import androidx.test.filters.SmallTest
 import com.android.connectivity.resources.R
+import com.android.internal.os.BackgroundThread
 import com.android.internal.util.test.FakeSettingsProvider
 import com.android.modules.utils.build.SdkLevel
 import com.android.server.connectivity.MultinetworkPolicyTracker.ActiveDataSubscriptionIdListener
 import com.android.testutils.DevSdkIgnoreRule
 import com.android.testutils.DevSdkIgnoreRunner
+import com.android.testutils.com.android.testutils.SetFeatureFlagsRule
+import com.android.testutils.com.android.testutils.SetFeatureFlagsRule.FeatureFlag
+import com.android.testutils.postAndWait
 import org.junit.After
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertFalse
 import org.junit.Assert.assertTrue
+import org.junit.Assume.assumeTrue
 import org.junit.Before
+import org.junit.Rule
 import org.junit.Test
 import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
 import org.mockito.ArgumentCaptor
 import org.mockito.ArgumentMatchers.anyInt
 import org.mockito.Mockito.any
@@ -62,60 +72,177 @@ const val HANDLER_TIMEOUT_MS = 400
  * Build, install and run with:
  * atest FrameworksNetTest:MultinetworkPolicyTrackerTest
  */
+// This test class is initialized with 'supportCarrierConfigManager',
+// which indicates whether CarrierConfigManager is supported. This value
+// is 'false' if FEATURE_TELEPHONY_SUBSCRIPTION is not supported on the device.
 @RunWith(DevSdkIgnoreRunner::class)
 @SmallTest
 @DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.R)
-class MultinetworkPolicyTrackerTest {
+class MultinetworkPolicyTrackerTest(private val supportCarrierConfigManager: Boolean) {
+    companion object {
+        @Parameterized.Parameters
+        @JvmStatic
+        fun data() = listOf(false, true)
+    }
+
+    // This wrapper class prevents JUnit from attempting to load unsupported system classes
+    // that are present in the System Test (S/T) image, which would otherwise cause test failures.
+    private class CarrierConfigChangeRunner(
+        val csLooper: TestLooper,
+        val bgHandler: Handler,
+        val listener: CarrierConfigManager.CarrierConfigChangeListener
+    ) {
+
+        fun runCarrierConfigChangeOnBackgroundThread(subId: Int) {
+            bgHandler.postAndWait {
+                    listener.onCarrierConfigChanged(
+                        0, /* logicalSlotIndex */
+                        subId, /* subscriptionId */
+                        0, /* carrierId */
+                        0 /* specificCarrierId */
+                    )
+                }
+                csLooper.dispatchNext()
+        }
+    }
+
+    private val featureFlags = HashSet<String>()
+
+    var carrierConfigManager: CarrierConfigManager? = null
+
+    // This will set feature flags from @FeatureFlag annotations
+    // into the map before setUp() runs.
+    @get:Rule
+    val setFeatureFlagsRule = SetFeatureFlagsRule(
+        { name, enabled ->
+            if (enabled == true) featureFlags.add(name) else featureFlags.remove(name) },
+        { name -> featureFlags.contains(name) }
+    )
+
+    @get:Rule
+    val ignoreRule = DevSdkIgnoreRule()
+
     private val resources = mock(Resources::class.java).also {
         doReturn(0).`when`(it).getInteger(R.integer.config_networkAvoidBadWifi)
         doReturn(0).`when`(it).getInteger(R.integer.config_activelyPreferBadWifi)
     }
+
     private val telephonyManager = mock(TelephonyManager::class.java)
     private val subscriptionManager = mock(SubscriptionManager::class.java).also {
         doReturn(null).`when`(it).getActiveSubscriptionInfo(anyInt())
     }
+    private val packageManager = mock(PackageManager::class.java).also {
+        doReturn(true).`when`(it)
+            .hasSystemFeature(PackageManager.FEATURE_TELEPHONY_SUBSCRIPTION)
+    }
     private val resolver = MockContentResolver().apply {
         addProvider(Settings.AUTHORITY, FakeSettingsProvider()) }
     private val context = mock(Context::class.java).also {
         doReturn(Context.TELEPHONY_SERVICE).`when`(it)
-                .getSystemServiceName(TelephonyManager::class.java)
+            .getSystemServiceName(TelephonyManager::class.java)
         doReturn(telephonyManager).`when`(it).getSystemService(Context.TELEPHONY_SERVICE)
         if (it.getSystemService(TelephonyManager::class.java) == null) {
             // Test is using mockito extended
             doCallRealMethod().`when`(it).getSystemService(TelephonyManager::class.java)
         }
         doReturn(subscriptionManager).`when`(it)
-                .getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE)
+            .getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE)
         doReturn(resolver).`when`(it).contentResolver
         doReturn(resources).`when`(it).resources
         doReturn(it).`when`(it).createConfigurationContext(any())
+        doReturn(packageManager).`when`(it).packageManager
         Settings.Global.putString(resolver, NETWORK_AVOID_BAD_WIFI, "1")
         ConnectivityResources.setResourcesContextForTest(it)
     }
     private val csLooper = TestLooper()
     private val handler = Handler(csLooper.looper)
-    private val trackerDependencies = MultinetworkPolicyTrackerTestDependencies(resources)
-    private val tracker = MultinetworkPolicyTracker(context, handler,
-            null /* avoidBadWifiCallback */, trackerDependencies)
+    private val bgHandler = BackgroundThread.getHandler()
+    private val trackerDependencies =
+        MultinetworkPolicyTrackerTestDependencies(resources)
 
+    // this needs to be initialized in setUp() because
+    // the featureFlag from the annotation is not ready here
+    private lateinit var tracker: MultinetworkPolicyTracker
     private fun assertMultipathPreference(preference: Int) {
-        Settings.Global.putString(resolver, NETWORK_METERED_MULTIPATH_PREFERENCE,
-                preference.toString())
+        Settings.Global.putString(
+            resolver,
+            NETWORK_METERED_MULTIPATH_PREFERENCE,
+                preference.toString()
+        )
         tracker.updateMeteredMultipathPreference()
         assertEquals(preference, tracker.meteredMultipathPreference)
     }
 
+    private fun runOnActiveDataSubscriptionIdChanged() {
+        val testSubId = 1000
+        val subscriptionInfo = SubscriptionInfo(testSubId, ""/* iccId */, 1/* iccId */,
+            "TMO"/* displayName */, "TMO"/* carrierName */, 1/* nameSource */, 1/* iconTint */,
+            "123"/* number */, 1/* roaming */, null/* icon */, "310"/* mcc */, "210"/* mnc */,
+            ""/* countryIso */, false/* isEmbedded */, null/* nativeAccessRules */,
+            "1"/* cardString */)
+        doReturn(subscriptionInfo).`when`(subscriptionManager).getActiveSubscriptionInfo(testSubId)
+
+        // Modify avoidBadWifi and meteredMultipathPreference settings value and local variables in
+        // MultinetworkPolicyTracker should be also updated after subId changed.
+        Settings.Global.putString(resolver, NETWORK_AVOID_BAD_WIFI, "0")
+        Settings.Global.putString(
+            resolver,
+            NETWORK_METERED_MULTIPATH_PREFERENCE,
+            MULTIPATH_PREFERENCE_PERFORMANCE.toString()
+        )
+
+        assertTrue(tracker.avoidBadWifi)
+
+        val listenerCaptor = ArgumentCaptor.forClass(
+            ActiveDataSubscriptionIdListener::class.java
+        )
+        verify(telephonyManager, times(1))
+            .registerTelephonyCallback(any(), listenerCaptor.capture())
+        val listener = listenerCaptor.value
+        csLooper.dispatchAll()
+
+        // Mock the carrier configuration to return false
+        trackerDependencies.setAvoidBadWifiCarrierConfigForSubId(testSubId, false)
+        listener.onActiveDataSubscriptionIdChanged(testSubId)
+
+        // Check if avoidBadWifi and meteredMultipathPreference values have been updated.
+        assertFalse(tracker.avoidBadWifi)
+        assertEquals(MULTIPATH_PREFERENCE_PERFORMANCE, tracker.meteredMultipathPreference)
+    }
+
     @Before
     fun setUp() {
+        trackerDependencies.setAvoidBadWifiFromCarrierConfigFeature(
+            featureFlags.contains(FLAG_AVOID_BAD_WIFI_FROM_CARRIER_CONFIG)
+        )
+
+        if (supportCarrierConfigManager) {
+            carrierConfigManager = mock(CarrierConfigManager::class.java)
+        } else {
+            carrierConfigManager = null
+        }
+
+        doReturn(carrierConfigManager).`when`(context)
+            .getSystemService(CarrierConfigManager::class.java)
+
+        trackerDependencies.setBackgroundThreadHandler(bgHandler)
+        tracker = MultinetworkPolicyTracker(
+            context,
+            handler,
+            null /* avoidBadWifiCallback */,
+            trackerDependencies
+        )
         tracker.start()
     }
 
     @After
     fun tearDown() {
         ConnectivityResources.setResourcesContextForTest(null)
+        trackerDependencies.resetAvoidBadWifiCarrierConfigForSubIdMap()
     }
 
     @Test
+    @FeatureFlag(name = FLAG_AVOID_BAD_WIFI_FROM_CARRIER_CONFIG, false)
     fun testUpdateMeteredMultipathPreference() {
         assertMultipathPreference(MULTIPATH_PREFERENCE_HANDOVER)
         assertMultipathPreference(MULTIPATH_PREFERENCE_RELIABILITY)
@@ -123,6 +250,7 @@ class MultinetworkPolicyTrackerTest {
     }
 
     @Test
+    @FeatureFlag(name = FLAG_AVOID_BAD_WIFI_FROM_CARRIER_CONFIG, false)
     fun testUpdateAvoidBadWifi() {
         doReturn(0).`when`(resources).getInteger(R.integer.config_activelyPreferBadWifi)
         Settings.Global.putString(resolver, NETWORK_AVOID_BAD_WIFI, "0")
@@ -165,32 +293,124 @@ class MultinetworkPolicyTrackerTest {
     }
 
     @Test
-    fun testOnActiveDataSubscriptionIdChanged() {
-        val testSubId = 1000
-        val subscriptionInfo = SubscriptionInfo(testSubId, ""/* iccId */, 1/* iccId */,
-                "TMO"/* displayName */, "TMO"/* carrierName */, 1/* nameSource */, 1/* iconTint */,
-                "123"/* number */, 1/* roaming */, null/* icon */, "310"/* mcc */, "210"/* mnc */,
-                ""/* countryIso */, false/* isEmbedded */, null/* nativeAccessRules */,
-                "1"/* cardString */)
-        doReturn(subscriptionInfo).`when`(subscriptionManager).getActiveSubscriptionInfo(testSubId)
+    @FeatureFlag(name = FLAG_AVOID_BAD_WIFI_FROM_CARRIER_CONFIG, false)
+    fun testOnActiveDataSubscriptionIdChangedFromResources() {
+        runOnActiveDataSubscriptionIdChanged()
+    }
 
-        // Modify avoidBadWifi and meteredMultipathPreference settings value and local variables in
-        // MultinetworkPolicyTracker should be also updated after subId changed.
+    @Test
+    @FeatureFlag(name = FLAG_AVOID_BAD_WIFI_FROM_CARRIER_CONFIG, true)
+    @DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.BAKLAVA)
+    fun testOnActiveDataSubscriptionIdChangedFromCarrierConfig() {
+        runOnActiveDataSubscriptionIdChanged()
+    }
+
+    @Test
+    @FeatureFlag(name = FLAG_AVOID_BAD_WIFI_FROM_CARRIER_CONFIG, true)
+    @DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.BAKLAVA)
+    fun testAvoidBadWifiWithGlobalSetting() {
+        val activeSubId = 1000
+        // Mock the initial global setting to false
         Settings.Global.putString(resolver, NETWORK_AVOID_BAD_WIFI, "0")
-        Settings.Global.putString(resolver, NETWORK_METERED_MULTIPATH_PREFERENCE,
-                MULTIPATH_PREFERENCE_PERFORMANCE.toString())
+        // Mock the initial carrier configuration to return true
+        trackerDependencies.setAvoidBadWifiCarrierConfigForSubId(activeSubId, true)
+
+        val listenerCaptor = ArgumentCaptor.forClass(
+            ActiveDataSubscriptionIdListener::class.java
+        )
+        verify(telephonyManager, times(1))
+            .registerTelephonyCallback(any(), listenerCaptor.capture())
+        val listener = listenerCaptor.value
+        csLooper.dispatchAll()
 
+        // Simulate a change in the active data subscription ID to activeSubId.
+        listener.onActiveDataSubscriptionIdChanged(activeSubId)
+
+        // Assert that the tracker's avoidBadWifi flag is false based on global setting
+        assertFalse(tracker.avoidBadWifi)
+        assertTrue(tracker.activelyPreferBadWifi)
+
+        // Mock the initial global setting to true
+        Settings.Global.putString(resolver, NETWORK_AVOID_BAD_WIFI, "1")
+        // Mock the initial carrier configuration to return false
+        trackerDependencies.setAvoidBadWifiCarrierConfigForSubId(activeSubId, false)
+
+        // Assert that the tracker's avoidBadWifi flag is true based on global setting
+        assertTrue(tracker.updateAvoidBadWifi())
         assertTrue(tracker.avoidBadWifi)
+        assertTrue(tracker.activelyPreferBadWifi)
+    }
+
+    @Test
+    @FeatureFlag(name = FLAG_AVOID_BAD_WIFI_FROM_CARRIER_CONFIG, true)
+    @DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.BAKLAVA)
+    fun testUpdateAvoidBadWifiOnCarrierConfigChange() {
+        assumeTrue(
+            "skip test if carrierConfigManager is not supported",
+            supportCarrierConfigManager
+        )
 
+        // Mock the initial global setting to null
+        Settings.Global.putString(resolver, NETWORK_AVOID_BAD_WIFI, null)
+
+        val activeSubId = 1000
         val listenerCaptor = ArgumentCaptor.forClass(
-                ActiveDataSubscriptionIdListener::class.java)
+            ActiveDataSubscriptionIdListener::class.java
+        )
         verify(telephonyManager, times(1))
-                .registerTelephonyCallback(any(), listenerCaptor.capture())
+            .registerTelephonyCallback(any(), listenerCaptor.capture())
         val listener = listenerCaptor.value
-        listener.onActiveDataSubscriptionIdChanged(testSubId)
+        // Simulate a change in the active data subscription ID to activeSubId.
+        listener.onActiveDataSubscriptionIdChanged(activeSubId)
 
-        // Check if avoidBadWifi and meteredMultipathPreference values have been updated.
+        val carrierConfiglistenCaptor = ArgumentCaptor.forClass(
+            CarrierConfigManager.CarrierConfigChangeListener::class.java
+        )
+
+        // Mock the initial carrier configuration to return false
+        trackerDependencies.setAvoidBadWifiCarrierConfigForSubId(activeSubId, false)
+        verify(carrierConfigManager, times(1))
+            ?.registerCarrierConfigChangeListener(any(), carrierConfiglistenCaptor.capture())
+
+        val carrierConfiglistener = carrierConfiglistenCaptor.value
+        // dispatch for the first carrier config initialization on the handler thread
+        csLooper.dispatchAll()
+
+        val runner = CarrierConfigChangeRunner(csLooper, bgHandler, carrierConfiglistener)
+        // Simulate a carrier configuration change for the initial activeSubId (1000),
+        // with avoid bad Wi-Fi set to false.
+        runner.runCarrierConfigChangeOnBackgroundThread(activeSubId)
+
+        // Assert that the tracker's avoidBadWifi flag is false after the carrier config change.
         assertFalse(tracker.avoidBadWifi)
-        assertEquals(MULTIPATH_PREFERENCE_PERFORMANCE, tracker.meteredMultipathPreference)
+        assertTrue(tracker.activelyPreferBadWifi)
+
+        // Mock the carrier configuration to now return true for KEY_AVOID_BAD_WIFI_BOOL.
+        trackerDependencies.setAvoidBadWifiCarrierConfigForSubId(activeSubId, true)
+        // Simulate another carrier configuration change for the same activeSubId (1000),
+        // now with avoid bad Wi-Fi set to true.
+        runner.runCarrierConfigChangeOnBackgroundThread(activeSubId)
+
+        // Assert that the tracker's avoidBadWifi flag is now true.
+        assertTrue(tracker.avoidBadWifi)
+        assertTrue(tracker.activelyPreferBadWifi)
+
+        val changedActiveSubId = 1001
+        // Mock the carrier configuration to return false
+        trackerDependencies.setAvoidBadWifiCarrierConfigForSubId(changedActiveSubId, false)
+        // Simulate a carrier configuration change for a different subscription ID.
+        runner.runCarrierConfigChangeOnBackgroundThread(changedActiveSubId)
+
+        // Assert that the tracker's avoidBadWifi flag remains true,
+        // because the config change was for a non-active subscription.
+        assertTrue(tracker.avoidBadWifi)
+        assertTrue(tracker.activelyPreferBadWifi)
+
+        // Simulate a change in the active data subscription ID to the new ID (1001).
+        listener.onActiveDataSubscriptionIdChanged(changedActiveSubId)
+        // Assert that the tracker's avoidBadWifi flag is now false,
+        // reflecting the carrier config of the new active subscription.
+        assertFalse(tracker.avoidBadWifi)
+        assertTrue(tracker.activelyPreferBadWifi)
     }
 }
diff --git a/tests/unit/java/com/android/server/connectivity/MultinetworkPolicyTrackerTestDependencies.kt b/tests/unit/java/com/android/server/connectivity/MultinetworkPolicyTrackerTestDependencies.kt
index 4c82c7688d..0103fd906e 100644
--- a/tests/unit/java/com/android/server/connectivity/MultinetworkPolicyTrackerTestDependencies.kt
+++ b/tests/unit/java/com/android/server/connectivity/MultinetworkPolicyTrackerTestDependencies.kt
@@ -1,33 +1,60 @@
 package com.android.server.connectivity
 
 import android.content.res.Resources
+import android.os.Handler
 import android.provider.DeviceConfig
 import android.provider.DeviceConfig.NAMESPACE_CONNECTIVITY
 import android.provider.DeviceConfig.OnPropertiesChangedListener
+import android.telephony.CarrierConfigManager
 import com.android.internal.annotations.GuardedBy
+import com.android.internal.os.BackgroundThread
 import com.android.server.connectivity.MultinetworkPolicyTracker.CONFIG_ACTIVELY_PREFER_BAD_WIFI
 import java.util.concurrent.Executor
 
-class MultinetworkPolicyTrackerTestDependencies(private val resources: Resources) :
-        MultinetworkPolicyTracker.Dependencies() {
+class MultinetworkPolicyTrackerTestDependencies(
+    private val resources: Resources
+) : MultinetworkPolicyTracker.Dependencies() {
     @GuardedBy("listeners")
     private var configActivelyPreferBadWifi = 0
+
     // TODO : move this to an actual fake device config object
     @GuardedBy("listeners")
     private val listeners = mutableListOf<Pair<Executor, OnPropertiesChangedListener>>()
 
+    private var avoidBadWifiFromCarrierConfigFeature = false
+    private val avoidBadWifiCarrierConfigForSubIdMap = HashMap<Int, Boolean>()
+    private var backgroundThreadHandler = BackgroundThread.getHandler()
+
     fun putConfigActivelyPreferBadWifi(value: Int) {
         synchronized(listeners) {
             if (value == configActivelyPreferBadWifi) return
             configActivelyPreferBadWifi = value
-            val p = DeviceConfig.Properties(NAMESPACE_CONNECTIVITY,
-                    mapOf(CONFIG_ACTIVELY_PREFER_BAD_WIFI to value.toString()))
+            val p = DeviceConfig.Properties(
+                NAMESPACE_CONNECTIVITY,
+                mapOf(CONFIG_ACTIVELY_PREFER_BAD_WIFI to value.toString())
+            )
             listeners.forEach { (executor, listener) ->
                 executor.execute { listener.onPropertiesChanged(p) }
             }
         }
     }
 
+    fun setAvoidBadWifiFromCarrierConfigFeature(value: Boolean) {
+        avoidBadWifiFromCarrierConfigFeature = value
+    }
+
+    fun setAvoidBadWifiCarrierConfigForSubId(subId: Int, value: Boolean) {
+        avoidBadWifiCarrierConfigForSubIdMap[subId] = value
+    }
+
+    fun resetAvoidBadWifiCarrierConfigForSubIdMap() {
+        avoidBadWifiCarrierConfigForSubIdMap.clear()
+    }
+
+    fun setBackgroundThreadHandler(handler: Handler) {
+        backgroundThreadHandler = handler
+    }
+
     override fun getConfigActivelyPreferBadWifi(): Int {
         return synchronized(listeners) { configActivelyPreferBadWifi }
     }
@@ -42,5 +69,17 @@ class MultinetworkPolicyTrackerTestDependencies(private val resources: Resources
     }
 
     override fun getResourcesForActiveSubId(res: ConnectivityResources, id: Int): Resources =
-            resources
+        resources
+
+    override fun readAvoidBadWifiFromCarrierConfig(
+        ccm: CarrierConfigManager,
+        subId: Int
+    ): Boolean =
+        avoidBadWifiCarrierConfigForSubIdMap.getOrDefault(subId, true)
+
+    public override fun getAvoidBadWifiFromCarrierConfigFeature(): Boolean =
+        avoidBadWifiFromCarrierConfigFeature
+
+    public override fun getBackgroundThreadHandler(): Handler =
+        backgroundThreadHandler
 }
diff --git a/tests/unit/java/com/android/server/connectivity/MultipathPolicyTrackerTest.java b/tests/unit/java/com/android/server/connectivity/MultipathPolicyTrackerTest.java
index d1bf40ed56..dd4e606028 100644
--- a/tests/unit/java/com/android/server/connectivity/MultipathPolicyTrackerTest.java
+++ b/tests/unit/java/com/android/server/connectivity/MultipathPolicyTrackerTest.java
@@ -27,7 +27,6 @@ import static android.provider.Settings.Global.NETWORK_DEFAULT_DAILY_MULTIPATH_Q
 
 import static com.android.server.net.NetworkPolicyManagerInternal.QUOTA_TYPE_MULTIPATH;
 import static com.android.server.net.NetworkPolicyManagerService.OPPORTUNISTIC_QUOTA_UNKNOWN;
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
 
 import static org.junit.Assert.assertNotNull;
 import static org.mockito.ArgumentMatchers.any;
@@ -406,7 +405,7 @@ public class MultipathPolicyTrackerTest {
                 any(), eq(DataUnit.MEGABYTES.toBytes(14)), any(), any());
     }
 
-    @DevSdkIgnoreRule.IgnoreUpTo(SC_V2)
+    @DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
     @Test
     public void testOnThresholdReached() {
         prepareGetMultipathPreferenceTest(
diff --git a/tests/unit/java/com/android/server/connectivity/PermissionMonitorTest.java b/tests/unit/java/com/android/server/connectivity/PermissionMonitorTest.java
index ec9c6b0e48..04cb639b30 100644
--- a/tests/unit/java/com/android/server/connectivity/PermissionMonitorTest.java
+++ b/tests/unit/java/com/android/server/connectivity/PermissionMonitorTest.java
@@ -24,6 +24,7 @@ import static android.Manifest.permission.INTERNET;
 import static android.Manifest.permission.NEARBY_WIFI_DEVICES;
 import static android.Manifest.permission.NETWORK_STACK;
 import static android.Manifest.permission.OBSERVE_GRANT_REVOKE_PERMISSIONS;
+import static android.Manifest.permission.READ_DEVICE_CONFIG;
 import static android.Manifest.permission.UPDATE_DEVICE_STATS;
 import static android.content.pm.ApplicationInfo.PRIVATE_FLAG_OEM;
 import static android.content.pm.ApplicationInfo.PRIVATE_FLAG_PRODUCT;
@@ -45,9 +46,9 @@ import static android.net.connectivity.ConnectivityCompatChanges.RESTRICT_LOCAL_
 import static android.os.Process.SYSTEM_UID;
 import static android.permission.PermissionManager.PERMISSION_GRANTED;
 
+import static com.android.server.connectivity.ConnectivityFlags.USE_BROADCAST_RECEIVE_HELPER_FOR_PERMISSION_MONITOR;
 import static com.android.server.connectivity.PermissionMonitor.isHigherNetworkPermission;
 import static com.android.testutils.TestPermissionUtil.runAsShell;
-import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo;
 
 import static junit.framework.Assert.fail;
 
@@ -109,8 +110,11 @@ import com.android.networkstack.apishim.ProcessShimImpl;
 import com.android.networkstack.apishim.common.ProcessShim;
 import com.android.server.BpfNetMaps;
 import com.android.testutils.DevSdkIgnoreRule;
+import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo;
 import com.android.testutils.DevSdkIgnoreRunner;
 import com.android.testutils.HandlerUtils;
+import com.android.testutils.com.android.testutils.SetFeatureFlagsRule;
+import com.android.testutils.com.android.testutils.SetFeatureFlagsRule.FeatureFlag;
 
 import libcore.junit.util.compat.CoreCompatChangeRule.EnableCompatChanges;
 
@@ -128,6 +132,7 @@ import org.mockito.invocation.InvocationOnMock;
 
 import java.lang.reflect.Array;
 import java.util.Arrays;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Set;
 
@@ -137,6 +142,17 @@ import java.util.Set;
 public class PermissionMonitorTest {
     @Rule
     public TestRule compatChangeRule = new PlatformCompatChangeRule();
+
+    final HashMap<String, Boolean> mFeatureFlags = new HashMap<>();
+    // This will set feature flags from @FeatureFlag annotations
+    // into the map before setUp() runs.
+    @Rule
+    public final SetFeatureFlagsRule mSetFeatureFlagsRule =
+            new SetFeatureFlagsRule((name, enabled) -> {
+                mFeatureFlags.put(name, enabled);
+                return null;
+            }, (name) -> mFeatureFlags.getOrDefault(name, false));
+
     private static final int MOCK_USER_ID1 = 0;
     private static final int MOCK_USER_ID2 = 1;
     private static final int MOCK_USER_ID3 = 2;
@@ -202,8 +218,7 @@ public class PermissionMonitorTest {
     public void setUp() throws Exception {
         MockitoAnnotations.initMocks(this);
         when(mContext.getPackageManager()).thenReturn(mPackageManager);
-        when(mContext.getSystemService(eq(Context.USER_SERVICE))).thenReturn(mUserManager);
-        doReturn(List.of(MOCK_USER1)).when(mUserManager).getUserHandles(eq(true));
+        when(mContext.getSystemService(UserManager.class)).thenReturn(mUserManager);
         when(mContext.getSystemService(PermissionManager.class)).thenReturn(mPermissionManager);
         when(mContext.getSystemServiceName(SystemConfigManager.class))
                 .thenReturn(Context.SYSTEM_CONFIG_SERVICE);
@@ -225,6 +240,8 @@ public class PermissionMonitorTest {
         // Set DEVICE_INITIAL_SDK_INT to Q that SYSTEM_UID won't have restricted network permission
         // by default.
         doReturn(VERSION_Q).when(mDeps).getDeviceFirstSdkInt();
+        doAnswer(invocation -> mFeatureFlags.getOrDefault((String) invocation.getArgument(1), true))
+                .when(mDeps).isFeatureNotChickenedOut(any(), anyString());
 
         mHandlerThread = new HandlerThread("PermissionMonitorTest");
         mPermissionMonitor = new PermissionMonitor(
@@ -234,9 +251,6 @@ public class PermissionMonitorTest {
 
         // Start the HandlerThread after PermissionMonitor created as CS current behavior.
         mHandlerThread.start();
-
-        doReturn(List.of()).when(mPackageManager).getInstalledPackagesAsUser(anyInt(), anyInt());
-        onUserAdded(MOCK_USER1);
     }
 
     @After
@@ -341,12 +355,13 @@ public class PermissionMonitorTest {
         return packageInfo;
     }
 
-    private void startMonitoring() {
-        processOnHandlerThread(() -> mPermissionMonitor.startMonitoring());
+    private void initialize() {
+        processOnHandlerThread(() -> mPermissionMonitor.initialize());
     }
 
-    private void onUserAdded(UserHandle user) {
-        processOnHandlerThread(() -> mPermissionMonitor.onUserAdded(user));
+    private void onUserAddedWithInstalledPackageList(UserHandle user, List<PackageInfo> apps) {
+        processOnHandlerThread(() ->
+                mPermissionMonitor.onUserAddedWithInstalledPackageList(user, apps));
     }
 
     private void onUserRemoved(UserHandle user) {
@@ -361,6 +376,10 @@ public class PermissionMonitorTest {
         processOnHandlerThread(() -> mPermissionMonitor.onPackageRemoved(packageName, uid));
     }
 
+    private void onExternalApplicationsAvailable(String [] pkgList) {
+        processOnHandlerThread(() -> mPermissionMonitor.onExternalApplicationsAvailable(pkgList));
+    }
+
     private void sendAppIdsTrafficPermission(SparseIntArray netdPermissionsAppIds) {
         processOnHandlerThread(() ->
                 mPermissionMonitor.sendAppIdsTrafficPermission(netdPermissionsAppIds));
@@ -799,7 +818,7 @@ public class PermissionMonitorTest {
                 CHANGE_NETWORK_STATE);
 
         // Add user MOCK_USER1.
-        onUserAdded(MOCK_USER1);
+        onUserAddedWithInstalledPackageList(MOCK_USER1, List.of());
         // Add SYSTEM_PACKAGE2, expect only have network permission.
         addPackageForUsers(new UserHandle[]{MOCK_USER1}, SYSTEM_PACKAGE2, SYSTEM_APPID1);
         mNetdMonitor.expectNetworkPerm(PERMISSION_NETWORK, new UserHandle[]{MOCK_USER1},
@@ -814,10 +833,8 @@ public class PermissionMonitorTest {
                 buildPackageInfo(SYSTEM_PACKAGE1, SYSTEM_APP_UID21,
                         CONNECTIVITY_USE_RESTRICTED_NETWORKS),
                 buildPackageInfo(SYSTEM_PACKAGE2, SYSTEM_APP_UID21, CHANGE_NETWORK_STATE));
-        doReturn(pkgs).when(mPackageManager).getInstalledPackagesAsUser(eq(GET_PERMISSIONS),
-                eq(MOCK_USER_ID2));
         // Add user MOCK_USER2.
-        onUserAdded(MOCK_USER2);
+        onUserAddedWithInstalledPackageList(MOCK_USER2, pkgs);
         mNetdMonitor.expectNetworkPerm(PERMISSION_SYSTEM, new UserHandle[]{MOCK_USER1, MOCK_USER2},
                 SYSTEM_APPID1);
 
@@ -888,9 +905,7 @@ public class PermissionMonitorTest {
         final PackageInfo packageInfo = buildAndMockPackageInfoWithPermissions(
                 MOCK_PACKAGE1, MOCK_UID11, CHANGE_NETWORK_STATE);
         // Set package for all users on devices
-        doReturn(List.of(packageInfo)).when(mPackageManager)
-                .getInstalledPackagesAsUser(anyInt(), eq(MOCK_USER1.getIdentifier()));
-        onUserAdded(MOCK_USER1);
+        onUserAddedWithInstalledPackageList(MOCK_USER1, List.of(packageInfo));
 
         assertFalse(mBpfMapMonitor.hasLocalNetPermissions(MOCK_UID11));
         if (hasSdkSandbox(MOCK_UID11)) {
@@ -910,9 +925,7 @@ public class PermissionMonitorTest {
         final PackageInfo packageInfo = buildAndMockPackageInfoWithPermissions(
                 MOCK_PACKAGE1, MOCK_UID11, CHANGE_NETWORK_STATE);
         // Set package for all users on devices
-        doReturn(List.of(packageInfo)).when(mPackageManager)
-                .getInstalledPackagesAsUser(anyInt(), eq(MOCK_USER1.getIdentifier()));
-        onUserAdded(MOCK_USER1);
+        onUserAddedWithInstalledPackageList(MOCK_USER1, List.of(packageInfo));
         assertFalse(mBpfMapMonitor.hasLocalNetPermissions(MOCK_UID11));
 
         onUserRemoved(MOCK_USER1);
@@ -921,15 +934,14 @@ public class PermissionMonitorTest {
 
     private void doTestUidFilteringDuringVpnConnectDisconnectAndUidUpdates(@Nullable String ifName)
             throws Exception {
-        doReturn(List.of(
+        final List<PackageInfo> pkgs = List.of(
                 buildPackageInfo(SYSTEM_PACKAGE1, SYSTEM_APP_UID11, CHANGE_NETWORK_STATE,
                         CONNECTIVITY_USE_RESTRICTED_NETWORKS),
                 buildPackageInfo(MOCK_PACKAGE1, MOCK_UID11),
                 buildPackageInfo(MOCK_PACKAGE2, MOCK_UID12),
-                buildPackageInfo(SYSTEM_PACKAGE2, VPN_UID)))
-                .when(mPackageManager).getInstalledPackagesAsUser(eq(GET_PERMISSIONS), anyInt());
-        buildAndMockPackageInfoWithPermissions(MOCK_PACKAGE1, MOCK_UID11);
-        startMonitoring();
+                buildPackageInfo(SYSTEM_PACKAGE2, VPN_UID));
+        initialize();
+        onUserAddedWithInstalledPackageList(MOCK_USER1, pkgs);
         // Every app on user 0 except MOCK_UID12 is subject to the VPN.
         final Set<UidRange> vpnRange1 = Set.of(
                 new UidRange(0, MOCK_UID12 - 1),
@@ -979,15 +991,13 @@ public class PermissionMonitorTest {
 
     private void doTestUidFilteringDuringPackageInstallAndUninstall(@Nullable String ifName) throws
             Exception {
-        doReturn(List.of(
+        final List<PackageInfo> pkgs = List.of(
                 buildPackageInfo(SYSTEM_PACKAGE1, SYSTEM_APP_UID11, CHANGE_NETWORK_STATE,
                         NETWORK_STACK, CONNECTIVITY_USE_RESTRICTED_NETWORKS),
-                buildPackageInfo(SYSTEM_PACKAGE2, VPN_UID)))
-                .when(mPackageManager).getInstalledPackagesAsUser(eq(GET_PERMISSIONS), anyInt());
-        buildAndMockPackageInfoWithPermissions(MOCK_PACKAGE1, MOCK_UID11);
-        doReturn(List.of(MOCK_USER1, MOCK_USER2)).when(mUserManager).getUserHandles(eq(true));
-
-        startMonitoring();
+                buildPackageInfo(SYSTEM_PACKAGE2, VPN_UID));
+        initialize();
+        onUserAddedWithInstalledPackageList(MOCK_USER1, pkgs);
+        onUserAddedWithInstalledPackageList(MOCK_USER2, pkgs);
         final Set<UidRange> vpnRange = Set.of(UidRange.createForUser(MOCK_USER1),
                 UidRange.createForUser(MOCK_USER2));
         mPermissionMonitor.onVpnUidRangesAdded(ifName, vpnRange, VPN_UID);
@@ -1018,14 +1028,14 @@ public class PermissionMonitorTest {
     @Test
     @EnableCompatChanges(RESTRICT_LOCAL_NETWORK)
     public void testLockdownUidFilteringWithLockdownEnableDisable() {
-        doReturn(List.of(
+        final List<PackageInfo> pkgs = List.of(
                 buildPackageInfo(SYSTEM_PACKAGE1, SYSTEM_APP_UID11, CHANGE_NETWORK_STATE,
                         CONNECTIVITY_USE_RESTRICTED_NETWORKS),
                 buildPackageInfo(MOCK_PACKAGE1, MOCK_UID11),
                 buildPackageInfo(MOCK_PACKAGE2, MOCK_UID12),
-                buildPackageInfo(SYSTEM_PACKAGE2, VPN_UID)))
-                .when(mPackageManager).getInstalledPackagesAsUser(eq(GET_PERMISSIONS), anyInt());
-        startMonitoring();
+                buildPackageInfo(SYSTEM_PACKAGE2, VPN_UID));
+        initialize();
+        onUserAddedWithInstalledPackageList(MOCK_USER1, pkgs);
         // Every app on user 0 except MOCK_UID12 is subject to the VPN.
         final UidRange[] lockdownRange = {
                 new UidRange(0, MOCK_UID12 - 1),
@@ -1050,13 +1060,13 @@ public class PermissionMonitorTest {
     @Test
     @EnableCompatChanges(RESTRICT_LOCAL_NETWORK)
     public void testLockdownUidFilteringWithLockdownEnableDisableWithMultiAdd() {
-        doReturn(List.of(
+        final List<PackageInfo> pkgs = List.of(
                 buildPackageInfo(SYSTEM_PACKAGE1, SYSTEM_APP_UID11, CHANGE_NETWORK_STATE,
                         CONNECTIVITY_USE_RESTRICTED_NETWORKS),
                 buildPackageInfo(MOCK_PACKAGE1, MOCK_UID11),
-                buildPackageInfo(SYSTEM_PACKAGE2, VPN_UID)))
-                .when(mPackageManager).getInstalledPackagesAsUser(eq(GET_PERMISSIONS), anyInt());
-        startMonitoring();
+                buildPackageInfo(SYSTEM_PACKAGE2, VPN_UID));
+        initialize();
+        onUserAddedWithInstalledPackageList(MOCK_USER1, pkgs);
         // MOCK_UID11 is subject to the VPN.
         final UidRange range = new UidRange(MOCK_UID11, MOCK_UID11);
         final UidRange[] lockdownRange = {range};
@@ -1092,13 +1102,14 @@ public class PermissionMonitorTest {
     @Test
     @EnableCompatChanges(RESTRICT_LOCAL_NETWORK)
     public void testLockdownUidFilteringWithLockdownEnableDisableWithMultiAddAndOverlap() {
-        doReturn(List.of(buildPackageInfo(SYSTEM_PACKAGE1, SYSTEM_APP_UID11, CHANGE_NETWORK_STATE,
+        final List<PackageInfo> pkgs = List.of(
+                buildPackageInfo(SYSTEM_PACKAGE1, SYSTEM_APP_UID11, CHANGE_NETWORK_STATE,
                         CONNECTIVITY_USE_RESTRICTED_NETWORKS),
                 buildPackageInfo(MOCK_PACKAGE1, MOCK_UID13),
                 buildPackageInfo(MOCK_PACKAGE2, MOCK_UID14),
-                buildPackageInfo(SYSTEM_PACKAGE2, VPN_UID)))
-                .when(mPackageManager).getInstalledPackagesAsUser(eq(GET_PERMISSIONS), anyInt());
-        startMonitoring();
+                buildPackageInfo(SYSTEM_PACKAGE2, VPN_UID));
+        initialize();
+        onUserAddedWithInstalledPackageList(MOCK_USER1, pkgs);
         // MOCK_UID13 is subject to the VPN.
         final UidRange range1 = new UidRange(MOCK_UID13, MOCK_UID13);
         final UidRange[] lockdownRange1 = {range1};
@@ -1153,13 +1164,13 @@ public class PermissionMonitorTest {
     @Test
     @EnableCompatChanges(RESTRICT_LOCAL_NETWORK)
     public void testLockdownUidFilteringWithLockdownEnableDisableWithDuplicates() {
-        doReturn(List.of(
+        final List<PackageInfo> pkgs = List.of(
                 buildPackageInfo(SYSTEM_PACKAGE1, SYSTEM_APP_UID11, CHANGE_NETWORK_STATE,
                         CONNECTIVITY_USE_RESTRICTED_NETWORKS),
                 buildPackageInfo(MOCK_PACKAGE1, MOCK_UID11),
-                buildPackageInfo(SYSTEM_PACKAGE2, VPN_UID)))
-                .when(mPackageManager).getInstalledPackagesAsUser(eq(GET_PERMISSIONS), anyInt());
-        startMonitoring();
+                buildPackageInfo(SYSTEM_PACKAGE2, VPN_UID));
+        initialize();
+        onUserAddedWithInstalledPackageList(MOCK_USER1, pkgs);
         // MOCK_UID11 is subject to the VPN.
         final UidRange range = new UidRange(MOCK_UID11, MOCK_UID11);
         final UidRange[] lockdownRangeDuplicates = {range, range};
@@ -1188,14 +1199,14 @@ public class PermissionMonitorTest {
     @Test
     @EnableCompatChanges(RESTRICT_LOCAL_NETWORK)
     public void testLockdownUidFilteringWithInstallAndUnInstall() {
-        doReturn(List.of(
+        final List<PackageInfo> pkgs = List.of(
                 buildPackageInfo(SYSTEM_PACKAGE1, SYSTEM_APP_UID11, CHANGE_NETWORK_STATE,
                         NETWORK_STACK, CONNECTIVITY_USE_RESTRICTED_NETWORKS),
-                buildPackageInfo(SYSTEM_PACKAGE2, VPN_UID)))
-                .when(mPackageManager).getInstalledPackagesAsUser(eq(GET_PERMISSIONS), anyInt());
-        doReturn(List.of(MOCK_USER1, MOCK_USER2)).when(mUserManager).getUserHandles(eq(true));
+                buildPackageInfo(SYSTEM_PACKAGE2, VPN_UID));
 
-        startMonitoring();
+        initialize();
+        onUserAddedWithInstalledPackageList(MOCK_USER1, pkgs);
+        onUserAddedWithInstalledPackageList(MOCK_USER2, pkgs);
         final UidRange[] lockdownRange = {
                 UidRange.createForUser(MOCK_USER1),
                 UidRange.createForUser(MOCK_USER2)
@@ -1279,6 +1290,7 @@ public class PermissionMonitorTest {
     @Test
     @EnableCompatChanges(RESTRICT_LOCAL_NETWORK)
     public void testPackageInstall() throws Exception {
+        onUserAddedWithInstalledPackageList(MOCK_USER1, List.of());
         addPackage(MOCK_PACKAGE1, MOCK_UID11, INTERNET, UPDATE_DEVICE_STATS);
         mBpfMapMonitor.expectTrafficPerm(PERMISSION_TRAFFIC_ALL, MOCK_APPID1);
 
@@ -1306,6 +1318,7 @@ public class PermissionMonitorTest {
     @Test
     @EnableCompatChanges(RESTRICT_LOCAL_NETWORK)
     public void testPackageInstallSharedUid() throws Exception {
+        onUserAddedWithInstalledPackageList(MOCK_USER1, List.of());
         addPackage(MOCK_PACKAGE1, MOCK_UID11, INTERNET, UPDATE_DEVICE_STATS);
         mBpfMapMonitor.expectTrafficPerm(PERMISSION_TRAFFIC_ALL, MOCK_APPID1);
 
@@ -1318,6 +1331,7 @@ public class PermissionMonitorTest {
     @Test
     @EnableCompatChanges(RESTRICT_LOCAL_NETWORK)
     public void testPackageUninstallBasic() throws Exception {
+        onUserAddedWithInstalledPackageList(MOCK_USER1, List.of());
         addPackage(MOCK_PACKAGE1, MOCK_UID11, INTERNET, UPDATE_DEVICE_STATS);
         mBpfMapMonitor.expectTrafficPerm(PERMISSION_TRAFFIC_ALL, MOCK_APPID1);
 
@@ -1345,6 +1359,7 @@ public class PermissionMonitorTest {
     @Test
     @EnableCompatChanges(RESTRICT_LOCAL_NETWORK)
     public void testPackageRemoveThenAdd() throws Exception {
+        onUserAddedWithInstalledPackageList(MOCK_USER1, List.of());
         addPackage(MOCK_PACKAGE1, MOCK_UID11, INTERNET, UPDATE_DEVICE_STATS);
         mBpfMapMonitor.expectTrafficPerm(PERMISSION_TRAFFIC_ALL, MOCK_APPID1);
 
@@ -1381,6 +1396,7 @@ public class PermissionMonitorTest {
     @Test
     @EnableCompatChanges(RESTRICT_LOCAL_NETWORK)
     public void testPackageUpdate() throws Exception {
+        onUserAddedWithInstalledPackageList(MOCK_USER1, List.of());
         addPackage(MOCK_PACKAGE1, MOCK_UID11);
         mBpfMapMonitor.expectTrafficPerm(PERMISSION_NONE, MOCK_APPID1);
 
@@ -1391,6 +1407,7 @@ public class PermissionMonitorTest {
     @Test
     @EnableCompatChanges(RESTRICT_LOCAL_NETWORK)
     public void testPackageUninstallWithMultiplePackages() throws Exception {
+        onUserAddedWithInstalledPackageList(MOCK_USER1, List.of());
         addPackage(MOCK_PACKAGE1, MOCK_UID11, INTERNET, UPDATE_DEVICE_STATS);
         mBpfMapMonitor.expectTrafficPerm(PERMISSION_TRAFFIC_ALL, MOCK_APPID1);
 
@@ -1411,7 +1428,7 @@ public class PermissionMonitorTest {
         // necessary permission.
         final Context realContext = InstrumentationRegistry.getContext();
         final PermissionMonitor monitor = runAsShell(
-                OBSERVE_GRANT_REVOKE_PERMISSIONS,
+                OBSERVE_GRANT_REVOKE_PERMISSIONS, READ_DEVICE_CONFIG,
                 () -> new PermissionMonitor(realContext, mNetdService, mBpfNetMaps, mHandlerThread)
         );
         final PackageManager manager = realContext.getPackageManager();
@@ -1428,7 +1445,8 @@ public class PermissionMonitorTest {
         when(mSystemConfigManager.getSystemPermissionUids(eq(UPDATE_DEVICE_STATS)))
                 .thenReturn(new int[]{ MOCK_UID12 });
 
-        startMonitoring();
+        initialize();
+        onUserAddedWithInstalledPackageList(MOCK_USER1, List.of());
         mBpfMapMonitor.expectTrafficPerm(PERMISSION_INTERNET, MOCK_APPID1);
         mBpfMapMonitor.expectTrafficPerm(PERMISSION_TRAFFIC_ALL, MOCK_APPID2);
     }
@@ -1462,12 +1480,15 @@ public class PermissionMonitorTest {
 
     @Test
     @EnableCompatChanges(RESTRICT_LOCAL_NETWORK)
-    public void testIntentReceiver() throws Exception {
-        startMonitoring();
+    @FeatureFlag(name = USE_BROADCAST_RECEIVE_HELPER_FOR_PERMISSION_MONITOR, enabled = false)
+    public void testUidPermissionWhenPackageAddedRemovedWithIntent() throws Exception {
+        doReturn(List.of(MOCK_USER1)).when(mUserManager).getUserHandles(eq(true));
+        initialize();
+        assertFalse(mPermissionMonitor.useBroadcastReceiveHelper());
+
         final BroadcastReceiver receiver = expectBroadcastReceiver(
                 Intent.ACTION_PACKAGE_ADDED, Intent.ACTION_PACKAGE_REMOVED);
-
-        // Verify receiving PACKAGE_ADDED intent.
+        // Add/Remove package and verify uid permissions.
         final Intent addedIntent = new Intent(Intent.ACTION_PACKAGE_ADDED,
                 Uri.fromParts("package", MOCK_PACKAGE1, null /* fragment */));
         addedIntent.putExtra(Intent.EXTRA_UID, MOCK_UID11);
@@ -1476,7 +1497,6 @@ public class PermissionMonitorTest {
         receiver.onReceive(mContext, addedIntent);
         mBpfMapMonitor.expectTrafficPerm(PERMISSION_TRAFFIC_ALL, MOCK_APPID1);
 
-        // Verify receiving PACKAGE_REMOVED intent.
         when(mPackageManager.getPackagesForUid(MOCK_UID11)).thenReturn(new String[]{});
         final Intent removedIntent = new Intent(Intent.ACTION_PACKAGE_REMOVED,
                 Uri.fromParts("package", MOCK_PACKAGE1, null /* fragment */));
@@ -1485,6 +1505,20 @@ public class PermissionMonitorTest {
         mBpfMapMonitor.expectTrafficPerm(PERMISSION_UNINSTALLED, MOCK_APPID1);
     }
 
+    @Test
+    @EnableCompatChanges(RESTRICT_LOCAL_NETWORK)
+    public void testUidPermissionWhenPackageAddedRemoved() throws Exception {
+        assertTrue(mPermissionMonitor.useBroadcastReceiveHelper());
+        initialize();
+        onUserAddedWithInstalledPackageList(MOCK_USER1, List.of());
+
+        // Add/Remove package and verify uid permissions.
+        addPackage(MOCK_PACKAGE1, MOCK_UID11, INTERNET, UPDATE_DEVICE_STATS);
+        mBpfMapMonitor.expectTrafficPerm(PERMISSION_TRAFFIC_ALL, MOCK_APPID1);
+        removePackage(MOCK_PACKAGE1, MOCK_UID11);
+        mBpfMapMonitor.expectTrafficPerm(PERMISSION_UNINSTALLED, MOCK_APPID1);
+    }
+
     private ContentObserver expectRegisterContentObserver(Uri expectedUri) {
         final ArgumentCaptor<ContentObserver> captor =
                 ArgumentCaptor.forClass(ContentObserver.class);
@@ -1502,7 +1536,7 @@ public class PermissionMonitorTest {
     @Test
     @EnableCompatChanges(RESTRICT_LOCAL_NETWORK)
     public void testUidsAllowedOnRestrictedNetworksChanged() throws Exception {
-        startMonitoring();
+        initialize();
         final ContentObserver contentObserver = expectRegisterContentObserver(
                 Settings.Global.getUriFor(UIDS_ALLOWED_ON_RESTRICTED_NETWORKS));
 
@@ -1535,7 +1569,7 @@ public class PermissionMonitorTest {
     @Test
     @EnableCompatChanges(RESTRICT_LOCAL_NETWORK)
     public void testUidsAllowedOnRestrictedNetworksChangedWithSharedUid() throws Exception {
-        startMonitoring();
+        initialize();
         final ContentObserver contentObserver = expectRegisterContentObserver(
                 Settings.Global.getUriFor(UIDS_ALLOWED_ON_RESTRICTED_NETWORKS));
 
@@ -1569,7 +1603,7 @@ public class PermissionMonitorTest {
     @Test
     @EnableCompatChanges(RESTRICT_LOCAL_NETWORK)
     public void testUidsAllowedOnRestrictedNetworksChangedWithMultipleUsers() throws Exception {
-        startMonitoring();
+        initialize();
         final ContentObserver contentObserver = expectRegisterContentObserver(
                 Settings.Global.getUriFor(UIDS_ALLOWED_ON_RESTRICTED_NETWORKS));
 
@@ -1588,9 +1622,7 @@ public class PermissionMonitorTest {
         // Add user MOCK_USER2.
         final List<PackageInfo> pkgs = List.of(buildPackageInfo(MOCK_PACKAGE1, MOCK_UID21));
         buildAndMockPackageInfoWithPermissions(MOCK_PACKAGE2, MOCK_UID22);
-        doReturn(pkgs).when(mPackageManager)
-                .getInstalledPackagesAsUser(eq(GET_PERMISSIONS), eq(MOCK_USER_ID2));
-        onUserAdded(MOCK_USER2);
+        onUserAddedWithInstalledPackageList(MOCK_USER2, pkgs);
         // MOCK_APPID1 in MOCK_USER1 should have SYSTEM permission but in MOCK_USER2 should have no
         // permissions. And MOCK_APPID2 has no permissions in either users.
         mNetdMonitor.expectNetworkPerm(PERMISSION_SYSTEM, new UserHandle[]{MOCK_USER1},
@@ -1626,25 +1658,20 @@ public class PermissionMonitorTest {
     public void testOnExternalApplicationsAvailable() throws Exception {
         // Initial the permission state. MOCK_PACKAGE1 and MOCK_PACKAGE2 are installed on external
         // and have different uids. There has no permission for both uids.
-        doReturn(List.of(
+        final List<PackageInfo> pkgs = List.of(
                 buildPackageInfo(MOCK_PACKAGE1, MOCK_UID11),
-                buildPackageInfo(MOCK_PACKAGE2, MOCK_UID12)))
-                .when(mPackageManager).getInstalledPackagesAsUser(eq(GET_PERMISSIONS), anyInt());
-        startMonitoring();
+                buildPackageInfo(MOCK_PACKAGE2, MOCK_UID12));
+        initialize();
+        onUserAddedWithInstalledPackageList(MOCK_USER1, pkgs);
         mNetdMonitor.expectNoNetworkPerm(new UserHandle[]{MOCK_USER1}, MOCK_APPID1, MOCK_APPID2);
         mBpfMapMonitor.expectTrafficPerm(PERMISSION_NONE, MOCK_APPID1, MOCK_APPID2);
 
-        final BroadcastReceiver receiver = expectBroadcastReceiver(
-                Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);
-        // Verify receiving EXTERNAL_APPLICATIONS_AVAILABLE intent and update permission to netd.
-        final Intent externalIntent = new Intent(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);
-        externalIntent.putExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST,
-                new String[] { MOCK_PACKAGE1 , MOCK_PACKAGE2});
+        // Call onExternalApplicationsAvailable and verify update permission to netd.
         buildAndMockPackageInfoWithPermissions(MOCK_PACKAGE1, MOCK_UID11,
                 CONNECTIVITY_USE_RESTRICTED_NETWORKS, INTERNET);
         buildAndMockPackageInfoWithPermissions(MOCK_PACKAGE2, MOCK_UID12, CHANGE_NETWORK_STATE,
                 UPDATE_DEVICE_STATS);
-        receiver.onReceive(mContext, externalIntent);
+        onExternalApplicationsAvailable(new String[] { MOCK_PACKAGE1 , MOCK_PACKAGE2});
         mNetdMonitor.expectNetworkPerm(PERMISSION_SYSTEM, new UserHandle[]{MOCK_USER1},
                 MOCK_APPID1);
         mNetdMonitor.expectNetworkPerm(PERMISSION_NETWORK, new UserHandle[]{MOCK_USER1},
@@ -1655,11 +1682,10 @@ public class PermissionMonitorTest {
 
     @Test
     @EnableCompatChanges(RESTRICT_LOCAL_NETWORK)
-    public void testOnExternalApplicationsAvailable_AppsNotRegisteredOnStartMonitoring()
+    public void testOnExternalApplicationsAvailable_AppsNotRegisteredOnInitialize()
             throws Exception {
-        startMonitoring();
-        final BroadcastReceiver receiver = expectBroadcastReceiver(
-                Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);
+        initialize();
+        onUserAddedWithInstalledPackageList(MOCK_USER1, List.of());
 
         // Initial the permission state. MOCK_PACKAGE1 and MOCK_PACKAGE2 are installed on external
         // and have different uids. There has no permission for both uids.
@@ -1668,11 +1694,8 @@ public class PermissionMonitorTest {
         buildAndMockPackageInfoWithPermissions(MOCK_PACKAGE2, MOCK_UID12, CHANGE_NETWORK_STATE,
                 UPDATE_DEVICE_STATS);
 
-        // Verify receiving EXTERNAL_APPLICATIONS_AVAILABLE intent and update permission to netd.
-        final Intent externalIntent = new Intent(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);
-        externalIntent.putExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST,
-                new String[] { MOCK_PACKAGE1 , MOCK_PACKAGE2});
-        receiver.onReceive(mContext, externalIntent);
+        // Call onExternalApplicationsAvailable and verify update permission to netd.
+        onExternalApplicationsAvailable(new String[] { MOCK_PACKAGE1 , MOCK_PACKAGE2});
         mNetdMonitor.expectNetworkPerm(PERMISSION_SYSTEM, new UserHandle[]{MOCK_USER1},
                 MOCK_APPID1);
         mNetdMonitor.expectNetworkPerm(PERMISSION_NETWORK, new UserHandle[]{MOCK_USER1},
@@ -1687,22 +1710,18 @@ public class PermissionMonitorTest {
             throws Exception {
         // Initial the permission state. MOCK_PACKAGE1 and MOCK_PACKAGE2 are installed on external
         // storage and shared on MOCK_UID11. There has no permission for MOCK_UID11.
-        doReturn(List.of(
+        final List<PackageInfo> pkgs = List.of(
                 buildPackageInfo(MOCK_PACKAGE1, MOCK_UID11),
-                buildPackageInfo(MOCK_PACKAGE2, MOCK_UID11)))
-                .when(mPackageManager).getInstalledPackagesAsUser(eq(GET_PERMISSIONS), anyInt());
-        startMonitoring();
+                buildPackageInfo(MOCK_PACKAGE2, MOCK_UID11));
+        initialize();
+        onUserAddedWithInstalledPackageList(MOCK_USER1, pkgs);
         mNetdMonitor.expectNoNetworkPerm(new UserHandle[]{MOCK_USER1}, MOCK_APPID1);
         mBpfMapMonitor.expectTrafficPerm(PERMISSION_NONE, MOCK_APPID1);
 
-        final BroadcastReceiver receiver = expectBroadcastReceiver(
-                Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);
-        // Verify receiving EXTERNAL_APPLICATIONS_AVAILABLE intent and update permission to netd.
-        final Intent externalIntent = new Intent(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);
-        externalIntent.putExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST, new String[] {MOCK_PACKAGE1});
+        // Call onExternalApplicationsAvailable and verify update permission to netd.
         buildAndMockPackageInfoWithPermissions(MOCK_PACKAGE1, MOCK_UID11, CHANGE_NETWORK_STATE);
         buildAndMockPackageInfoWithPermissions(MOCK_PACKAGE2, MOCK_UID11, UPDATE_DEVICE_STATS);
-        receiver.onReceive(mContext, externalIntent);
+        onExternalApplicationsAvailable(new String[] {MOCK_PACKAGE1});
         mNetdMonitor.expectNetworkPerm(PERMISSION_NETWORK, new UserHandle[]{MOCK_USER1},
                 MOCK_APPID1);
         mBpfMapMonitor.expectTrafficPerm(PERMISSION_UPDATE_DEVICE_STATS, MOCK_APPID1);
@@ -1715,25 +1734,21 @@ public class PermissionMonitorTest {
         // Initial the permission state. MOCK_PACKAGE1 is installed on external storage and
         // MOCK_PACKAGE2 is installed on device. These two packages are shared on MOCK_UID11.
         // MOCK_UID11 has NETWORK and INTERNET permissions.
-        doReturn(List.of(
+        final List<PackageInfo> pkgs = List.of(
                 buildPackageInfo(MOCK_PACKAGE1, MOCK_UID11),
-                buildPackageInfo(MOCK_PACKAGE2, MOCK_UID11, CHANGE_NETWORK_STATE, INTERNET)))
-                .when(mPackageManager).getInstalledPackagesAsUser(eq(GET_PERMISSIONS), anyInt());
-        startMonitoring();
+                buildPackageInfo(MOCK_PACKAGE2, MOCK_UID11, CHANGE_NETWORK_STATE, INTERNET));
+        initialize();
+        onUserAddedWithInstalledPackageList(MOCK_USER1, pkgs);
         mNetdMonitor.expectNetworkPerm(PERMISSION_NETWORK, new UserHandle[]{MOCK_USER1},
                 MOCK_APPID1);
         mBpfMapMonitor.expectTrafficPerm(PERMISSION_INTERNET, MOCK_APPID1);
 
-        final BroadcastReceiver receiver = expectBroadcastReceiver(
-                Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);
-        // Verify receiving EXTERNAL_APPLICATIONS_AVAILABLE intent and update permission to netd.
-        final Intent externalIntent = new Intent(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);
-        externalIntent.putExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST, new String[] {MOCK_PACKAGE1});
+        // Call onExternalApplicationsAvailable and verify update permission to netd.
         buildAndMockPackageInfoWithPermissions(MOCK_PACKAGE1, MOCK_UID11,
                 CONNECTIVITY_USE_RESTRICTED_NETWORKS, UPDATE_DEVICE_STATS);
         buildAndMockPackageInfoWithPermissions(MOCK_PACKAGE2, MOCK_UID11, CHANGE_NETWORK_STATE,
                 INTERNET);
-        receiver.onReceive(mContext, externalIntent);
+        onExternalApplicationsAvailable(new String[] {MOCK_PACKAGE1});
         mNetdMonitor.expectNetworkPerm(PERMISSION_SYSTEM, new UserHandle[]{MOCK_USER1},
                 MOCK_APPID1);
         mBpfMapMonitor.expectTrafficPerm(PERMISSION_TRAFFIC_ALL, MOCK_APPID1);
@@ -1784,7 +1799,25 @@ public class PermissionMonitorTest {
                 mProcessShim.toSdkSandboxUid(MOCK_UID11)));
     }
 
-    private void prepareMultiUserPackages() {
+    private void addUserAndVerifyAppIdsPermissions(UserHandle user, List<PackageInfo> pkgs,
+            int appId1Perm, int appId2Perm, int appId3Perm) {
+        onUserAddedWithInstalledPackageList(user, pkgs);
+        mBpfMapMonitor.expectTrafficPerm(appId1Perm, MOCK_APPID1);
+        mBpfMapMonitor.expectTrafficPerm(appId2Perm, MOCK_APPID2);
+        mBpfMapMonitor.expectTrafficPerm(appId3Perm, MOCK_APPID3);
+    }
+
+    private void removeUserAndVerifyAppIdsPermissions(UserHandle user, int appId1Perm,
+            int appId2Perm, int appId3Perm) {
+        onUserRemoved(user);
+        mBpfMapMonitor.expectTrafficPerm(appId1Perm, MOCK_APPID1);
+        mBpfMapMonitor.expectTrafficPerm(appId2Perm, MOCK_APPID2);
+        mBpfMapMonitor.expectTrafficPerm(appId3Perm, MOCK_APPID3);
+    }
+
+    @Test
+    @EnableCompatChanges(RESTRICT_LOCAL_NETWORK)
+    public void testAppIdsTrafficPermission_UserAddedRemoved() {
         // MOCK_USER1 has installed 3 packages
         // mockApp1 has no permission and share MOCK_APPID1.
         // mockApp2 has INTERNET permission and share MOCK_APPID2.
@@ -1806,45 +1839,16 @@ public class PermissionMonitorTest {
         final List<PackageInfo> pkgs3 = List.of(
                 buildPackageInfo("mockApp6", MOCK_UID32, UPDATE_DEVICE_STATS));
 
-        doReturn(pkgs1).when(mPackageManager).getInstalledPackagesAsUser(eq(GET_PERMISSIONS),
-                eq(MOCK_USER_ID1));
-        doReturn(pkgs2).when(mPackageManager).getInstalledPackagesAsUser(eq(GET_PERMISSIONS),
-                eq(MOCK_USER_ID2));
-        doReturn(pkgs3).when(mPackageManager).getInstalledPackagesAsUser(eq(GET_PERMISSIONS),
-                eq(MOCK_USER_ID3));
-    }
-
-    private void addUserAndVerifyAppIdsPermissions(UserHandle user, int appId1Perm,
-            int appId2Perm, int appId3Perm) {
-        onUserAdded(user);
-        mBpfMapMonitor.expectTrafficPerm(appId1Perm, MOCK_APPID1);
-        mBpfMapMonitor.expectTrafficPerm(appId2Perm, MOCK_APPID2);
-        mBpfMapMonitor.expectTrafficPerm(appId3Perm, MOCK_APPID3);
-    }
-
-    private void removeUserAndVerifyAppIdsPermissions(UserHandle user, int appId1Perm,
-            int appId2Perm, int appId3Perm) {
-        onUserRemoved(user);
-        mBpfMapMonitor.expectTrafficPerm(appId1Perm, MOCK_APPID1);
-        mBpfMapMonitor.expectTrafficPerm(appId2Perm, MOCK_APPID2);
-        mBpfMapMonitor.expectTrafficPerm(appId3Perm, MOCK_APPID3);
-    }
-
-    @Test
-    @EnableCompatChanges(RESTRICT_LOCAL_NETWORK)
-    public void testAppIdsTrafficPermission_UserAddedRemoved() {
-        prepareMultiUserPackages();
-
         // Add MOCK_USER1 and verify the permissions with each appIds.
-        addUserAndVerifyAppIdsPermissions(MOCK_USER1, PERMISSION_NONE, PERMISSION_INTERNET,
+        addUserAndVerifyAppIdsPermissions(MOCK_USER1, pkgs1, PERMISSION_NONE, PERMISSION_INTERNET,
                 PERMISSION_UPDATE_DEVICE_STATS);
 
         // Add MOCK_USER2 and verify the permissions upgrade on MOCK_APPID1 & MOCK_APPID3.
-        addUserAndVerifyAppIdsPermissions(MOCK_USER2, PERMISSION_UPDATE_DEVICE_STATS,
+        addUserAndVerifyAppIdsPermissions(MOCK_USER2, pkgs2, PERMISSION_UPDATE_DEVICE_STATS,
                 PERMISSION_INTERNET, PERMISSION_TRAFFIC_ALL);
 
         // Add MOCK_USER3 and verify the permissions upgrade on MOCK_APPID2.
-        addUserAndVerifyAppIdsPermissions(MOCK_USER3, PERMISSION_UPDATE_DEVICE_STATS,
+        addUserAndVerifyAppIdsPermissions(MOCK_USER3, pkgs3, PERMISSION_UPDATE_DEVICE_STATS,
                 PERMISSION_TRAFFIC_ALL, PERMISSION_TRAFFIC_ALL);
 
         // Remove MOCK_USER2 and verify the permissions downgrade on MOCK_APPID1 & MOCK_APPID3.
@@ -1856,7 +1860,7 @@ public class PermissionMonitorTest {
                 PERMISSION_UPDATE_DEVICE_STATS, PERMISSION_UNINSTALLED);
 
         // Add MOCK_USER2 back and verify the permissions upgrade on MOCK_APPID1 & MOCK_APPID3.
-        addUserAndVerifyAppIdsPermissions(MOCK_USER2, PERMISSION_UPDATE_DEVICE_STATS,
+        addUserAndVerifyAppIdsPermissions(MOCK_USER2, pkgs2, PERMISSION_UPDATE_DEVICE_STATS,
                 PERMISSION_UPDATE_DEVICE_STATS, PERMISSION_INTERNET);
 
         // Remove MOCK_USER3 and verify the permissions downgrade on MOCK_APPID2.
@@ -1868,8 +1872,8 @@ public class PermissionMonitorTest {
     @EnableCompatChanges(RESTRICT_LOCAL_NETWORK)
     public void testAppIdsTrafficPermission_Multiuser_PackageAdded() throws Exception {
         // Add two users with empty package list.
-        onUserAdded(MOCK_USER1);
-        onUserAdded(MOCK_USER2);
+        onUserAddedWithInstalledPackageList(MOCK_USER1, List.of());
+        onUserAddedWithInstalledPackageList(MOCK_USER2, List.of());
 
         final int[] netdPermissions = {PERMISSION_NONE, PERMISSION_INTERNET,
                 PERMISSION_UPDATE_DEVICE_STATS, PERMISSION_TRAFFIC_ALL};
@@ -1939,8 +1943,8 @@ public class PermissionMonitorTest {
     @EnableCompatChanges(RESTRICT_LOCAL_NETWORK)
     public void testAppIdsTrafficPermission_Multiuser_PackageRemoved() throws Exception {
         // Add two users with empty package list.
-        onUserAdded(MOCK_USER1);
-        onUserAdded(MOCK_USER2);
+        onUserAddedWithInstalledPackageList(MOCK_USER1, List.of());
+        onUserAddedWithInstalledPackageList(MOCK_USER2, List.of());
 
         int appId = MOCK_APPID1;
         // Verify that the permission combination is expected when same appId package is removed on
diff --git a/tests/unit/java/com/android/server/connectivity/QuicConnectionCloserTest.kt b/tests/unit/java/com/android/server/connectivity/QuicConnectionCloserTest.kt
new file mode 100644
index 0000000000..9e1c090f2c
--- /dev/null
+++ b/tests/unit/java/com/android/server/connectivity/QuicConnectionCloserTest.kt
@@ -0,0 +1,232 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.connectivity
+
+import android.net.InetAddresses
+import android.net.LinkAddress
+import android.net.LinkProperties
+import android.net.Network
+import android.net.TEST_IFACE
+import android.os.Build
+import android.os.Handler
+import android.os.Looper
+import android.os.ParcelFileDescriptor
+import android.system.OsConstants.SOL_SOCKET
+import android.util.SparseArray
+import com.android.net.module.util.SkDestroyListener
+import com.android.net.module.util.netlink.InetDiagMessage
+import com.android.net.module.util.netlink.StructInetDiagSockId
+import com.android.net.module.util.netlink.StructNlMsgHdr
+import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
+import com.android.testutils.DevSdkIgnoreRunner
+import com.android.testutils.visibleOnHandlerThread
+import java.net.InetSocketAddress
+import java.util.function.Consumer
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.ArgumentCaptor
+import org.mockito.InOrder
+import org.mockito.Mockito.any
+import org.mockito.Mockito.anyLong
+import org.mockito.Mockito.doReturn
+import org.mockito.Mockito.eq
+import org.mockito.Mockito.inOrder
+import org.mockito.Mockito.mock
+import org.mockito.Mockito.never
+import org.mockito.Mockito.verify
+
+private const val TEST_UID = 1234
+private const val TEST_NETID = 789
+private const val TEST_SOCKET_COOKIE = 12321L
+
+// TODO: Use OsConstants.SO_MARK once this API is available
+private const val SO_MARK = 36
+
+private val TEST_SRC_ADDRESS = InetAddresses.parseNumericAddress("2001:db8:1:2::2")
+private val TEST_SRC_SOCKET_ADDRESS = InetSocketAddress(
+        TEST_SRC_ADDRESS,
+        1234
+)
+private val TEST_DST_SOCKET_ADDRESS = InetSocketAddress(
+        InetAddresses.parseNumericAddress("2001:db8:1:2::3"),
+        443
+)
+private val TEST_LP = LinkProperties().apply {
+    interfaceName = TEST_IFACE
+    addLinkAddress(LinkAddress(TEST_SRC_ADDRESS, 64))
+}
+private val TEST_NETWORK = Network(TEST_NETID)
+private val TEST_PAYLOAD = byteArrayOf(0, 1, 2, 3, 4, 5)
+
+@RunWith(DevSdkIgnoreRunner::class)
+@IgnoreUpTo(Build.VERSION_CODES.R)
+class QuicConnectionCloserTest {
+    private val pfd = mock(ParcelFileDescriptor::class.java)
+    private val skDestroyListener = mock(SkDestroyListener::class.java)
+    private val handler by lazy { Handler(Looper.getMainLooper()) }
+
+    private val mDeps = mock(QuicConnectionCloser.Dependencies::class.java).also {
+        doReturn(TEST_NETID).`when`(it).getsockoptInt(any(), eq(SOL_SOCKET), eq(SO_MARK))
+        doReturn(TEST_SOCKET_COOKIE).`when`(it).getSocketCookie(any())
+        doReturn(TEST_SRC_SOCKET_ADDRESS).`when`(it).getsockname(any())
+        doReturn(TEST_DST_SOCKET_ADDRESS).`when`(it).getpeername(any())
+        doReturn(skDestroyListener).`when`(it).makeSkDestroyListener(any(), any())
+    }
+
+    private val nai = mock(NetworkAgentInfo::class.java).also {
+        it.linkProperties = TEST_LP
+        doReturn(TEST_NETWORK).`when`(it).network()
+    }
+
+    private val networkForNetId = SparseArray<NetworkAgentInfo>().apply {
+        put(TEST_NETID, nai)
+    }
+
+    private val mQuicConnectionCloser = QuicConnectionCloser(networkForNetId, handler, mDeps)
+
+    private fun InOrder.expectDestroyUdpSocket() = verify(mDeps).destroyUdpSocket(
+            TEST_SRC_SOCKET_ADDRESS,
+            TEST_DST_SOCKET_ADDRESS,
+            TEST_SOCKET_COOKIE
+    )
+
+    private fun InOrder.assertNoDestroyUdpSocket() = verify(mDeps, never()).destroyUdpSocket(
+            any(),
+            any(),
+            anyLong()
+    )
+
+    private fun InOrder.expectSendQuicConnectionClosePayload() =
+            verify(mDeps).sendQuicConnectionClosePayload(
+                    TEST_NETWORK,
+                    TEST_SRC_SOCKET_ADDRESS,
+                    TEST_DST_SOCKET_ADDRESS,
+                    TEST_PAYLOAD
+            )
+
+    private fun InOrder.assertNoSendQuicConnectionClosePayload() =
+            verify(mDeps, never()).sendQuicConnectionClosePayload(
+                    any(),
+                    any(),
+                    any(),
+                    any()
+            )
+
+    @Test
+    fun testCloseQuicConnectionByUids() {
+        mQuicConnectionCloser.registerQuicConnectionClosePayload(TEST_UID, pfd, TEST_PAYLOAD)
+        visibleOnHandlerThread(handler) {
+            mQuicConnectionCloser.closeQuicConnectionByUids(setOf(TEST_UID))
+        }
+
+        val inOrder = inOrder(mDeps)
+        inOrder.expectDestroyUdpSocket()
+        inOrder.expectSendQuicConnectionClosePayload()
+    }
+
+    @Test
+    fun testCloseQuicConnectionByUids_unregisterQuicConnectionCloseInfo() {
+        mQuicConnectionCloser.registerQuicConnectionClosePayload(TEST_UID, pfd, TEST_PAYLOAD)
+        mQuicConnectionCloser.unregisterQuicConnectionClosePayload(pfd)
+        visibleOnHandlerThread(handler) {
+            mQuicConnectionCloser.closeQuicConnectionByUids(setOf(TEST_UID))
+        }
+
+        val inOrder = inOrder(mDeps)
+        inOrder.assertNoDestroyUdpSocket()
+        inOrder.assertNoSendQuicConnectionClosePayload()
+    }
+
+    @Test
+    fun testCloseQuicConnectionByUids_networkDisconnected() {
+        mQuicConnectionCloser.registerQuicConnectionClosePayload(TEST_UID, pfd, TEST_PAYLOAD)
+        // closeQuicConnectionByUids determines that the network is disconnected by
+        // checking if it's absent from the networkForNetId set.
+        synchronized (networkForNetId) {
+            networkForNetId.clear()
+        }
+        visibleOnHandlerThread(handler) {
+            mQuicConnectionCloser.closeQuicConnectionByUids(setOf(TEST_UID))
+        }
+
+        val inOrder = inOrder(mDeps)
+        inOrder.assertNoDestroyUdpSocket()
+        inOrder.assertNoSendQuicConnectionClosePayload()
+    }
+
+    @Test
+    fun testCloseQuicConnectionByUids_networkAddressChange() {
+        mQuicConnectionCloser.registerQuicConnectionClosePayload(TEST_UID, pfd, TEST_PAYLOAD)
+        // Update address to different address from TEST_SRC_SOCKET_ADDRESS
+        nai.linkProperties = LinkProperties().apply {
+            interfaceName = TEST_IFACE
+            addLinkAddress(LinkAddress(InetAddresses.parseNumericAddress("2001:db8:1:3::2"), 64))
+        }
+        visibleOnHandlerThread(handler) {
+            mQuicConnectionCloser.closeQuicConnectionByUids(setOf(TEST_UID))
+        }
+
+        val inOrder = inOrder(mDeps)
+        inOrder.assertNoDestroyUdpSocket()
+        inOrder.assertNoSendQuicConnectionClosePayload()
+    }
+
+    private fun getSkDestroyListenerCallback(): Consumer<InetDiagMessage> {
+        val captor = ArgumentCaptor.forClass(Consumer::class.java)
+                as ArgumentCaptor<Consumer<InetDiagMessage>>
+        verify(mDeps).makeSkDestroyListener(captor.capture(), any())
+        return captor.value
+    }
+
+    @Test
+    fun testHandleUdpSocketDestroy() {
+        mQuicConnectionCloser.registerQuicConnectionClosePayload(TEST_UID, pfd, TEST_PAYLOAD)
+
+        val inetDiagMessage = InetDiagMessage(StructNlMsgHdr())
+        inetDiagMessage.inetDiagMsg.id = StructInetDiagSockId(
+                TEST_SRC_SOCKET_ADDRESS,
+                TEST_DST_SOCKET_ADDRESS,
+                0 /* ifindex */,
+                TEST_SOCKET_COOKIE
+        )
+        getSkDestroyListenerCallback().accept(inetDiagMessage)
+
+        val inOrder = inOrder(mDeps)
+        // DestroyUdpSocket is not called since the socket is already closed
+        inOrder.assertNoDestroyUdpSocket()
+        inOrder.expectSendQuicConnectionClosePayload()
+    }
+
+    @Test
+    fun testHandleUdpSocketDestroy_unregisterBeforeSocketClose() {
+        mQuicConnectionCloser.registerQuicConnectionClosePayload(TEST_UID, pfd, TEST_PAYLOAD)
+        mQuicConnectionCloser.unregisterQuicConnectionClosePayload(pfd)
+
+        val inetDiagMessage = InetDiagMessage(StructNlMsgHdr())
+        inetDiagMessage.inetDiagMsg.id = StructInetDiagSockId(
+                TEST_SRC_SOCKET_ADDRESS,
+                TEST_DST_SOCKET_ADDRESS,
+                0 /* ifindex */,
+                TEST_SOCKET_COOKIE
+        )
+        getSkDestroyListenerCallback().accept(inetDiagMessage)
+
+        val inOrder = inOrder(mDeps)
+        inOrder.assertNoDestroyUdpSocket()
+        inOrder.assertNoSendQuicConnectionClosePayload()
+    }
+}
diff --git a/tests/unit/java/com/android/server/connectivity/SatelliteAccessControllerTest.kt b/tests/unit/java/com/android/server/connectivity/SatelliteAccessControllerTest.kt
index 788532565f..d570d41f92 100644
--- a/tests/unit/java/com/android/server/connectivity/SatelliteAccessControllerTest.kt
+++ b/tests/unit/java/com/android/server/connectivity/SatelliteAccessControllerTest.kt
@@ -16,38 +16,45 @@
 package com.android.server.connectivity
 
 import android.Manifest
+import android.annotation.SuppressLint
 import android.app.role.OnRoleHoldersChangedListener
 import android.app.role.RoleManager
-import android.content.BroadcastReceiver
 import android.content.Context
-import android.content.Intent
-import android.content.IntentFilter
 import android.content.pm.ApplicationInfo
+import android.content.pm.PackageInfo
 import android.content.pm.PackageManager
 import android.os.Build
+import android.os.Bundle
 import android.os.Handler
 import android.os.Looper
 import android.os.UserHandle
 import android.os.UserManager
-import android.util.ArraySet
+import android.util.ArrayMap
+import com.android.server.connectivity.ConnectivityFlags.CONSTRAINED_DATA_SATELLITE_OPTIN
+import com.android.server.connectivity.SatelliteAccessController.PER_USER_RANGE
+import com.android.server.connectivity.SatelliteAccessController.PROPERTY_SATELLITE_DATA_OPTIMIZED
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
 import com.android.testutils.DevSdkIgnoreRunner
+import com.android.testutils.com.android.testutils.SetFeatureFlagsRule
+import com.android.testutils.com.android.testutils.SetFeatureFlagsRule.FeatureFlag
+import java.util.concurrent.CompletableFuture
 import java.util.concurrent.Executor
-import java.util.function.Consumer
+import java.util.function.BiConsumer
 import org.junit.Before
+import org.junit.Rule
 import org.junit.Test
 import org.junit.runner.RunWith
 import org.mockito.ArgumentCaptor
 import org.mockito.ArgumentMatchers.any
 import org.mockito.ArgumentMatchers.anyInt
 import org.mockito.ArgumentMatchers.eq
-import org.mockito.ArgumentMatchers.isNull
 import org.mockito.Mockito.doReturn
+import org.mockito.Mockito.inOrder
 import org.mockito.Mockito.mock
 import org.mockito.Mockito.never
-import org.mockito.Mockito.timeout
 import org.mockito.Mockito.times
 import org.mockito.Mockito.verify
+import org.mockito.Mockito.`when`
 
 private const val PRIMARY_USER = 0
 private const val SECONDARY_USER = 10
@@ -62,32 +69,37 @@ private const val SMS_APP2 = "sms_app_2"
 private const val SMS_APP_ID1 = 100
 private const val SMS_APP_ID2 = 101
 
-// UID for app1 and app2 on primary user
-// These app could become default sms app for user1
-private val PRIMARY_USER_SMS_APP_UID1 = UserHandle.getUid(PRIMARY_USER, SMS_APP_ID1)
-private val PRIMARY_USER_SMS_APP_UID2 = UserHandle.getUid(PRIMARY_USER, SMS_APP_ID2)
+private fun Int.toUid(userId: Int) = UserHandle.getUid(userId, this)
+private fun Int.getUserId() = this / PER_USER_RANGE
 
-// UID for app1 and app2 on secondary user
-// These app could become default sms app for user2
-private val SECONDARY_USER_SMS_APP_UID1 = UserHandle.getUid(SECONDARY_USER, SMS_APP_ID1)
-private val SECONDARY_USER_SMS_APP_UID2 = UserHandle.getUid(SECONDARY_USER, SMS_APP_ID2)
+private const val TEST_PACKAGE1 = "com.android.package1"
+private const val TEST_PACKAGE2 = "com.android.package2"
+private const val TEST_UID1 = 2001
+private const val TEST_UID2 = 2002 + SECONDARY_USER * PER_USER_RANGE // Under 2nd user.
 
+@SuppressLint("VisibleForTests", "MissingPermission")
 @RunWith(DevSdkIgnoreRunner::class)
 @IgnoreUpTo(Build.VERSION_CODES.TIRAMISU)
 class SatelliteAccessControllerTest {
     private val context = mock(Context::class.java)
-    private val primaryUserContext = mock(Context::class.java)
-    private val secondaryUserContext = mock(Context::class.java)
-    private val mPackageManagerPrimaryUser = mock(PackageManager::class.java)
-    private val mPackageManagerSecondaryUser = mock(PackageManager::class.java)
-    private val mDeps = mock(SatelliteAccessController.Dependencies::class.java)
-    private val mCallback = mock(Consumer::class.java) as Consumer<Set<Int>>
+    private val deps = mock(SatelliteAccessController.Dependencies::class.java)
+    private val callback = mock(BiConsumer::class.java) as BiConsumer<Set<Int>, Set<Int>>
     private val userManager = mock(UserManager::class.java)
-    private val mHandler = Handler(Looper.getMainLooper())
-    private var mSatelliteAccessController =
-        SatelliteAccessController(context, mDeps, mCallback, mHandler)
-    private lateinit var mRoleHolderChangedListener: OnRoleHoldersChangedListener
-    private lateinit var mUserRemovedReceiver: BroadcastReceiver
+    private val handler = Handler(Looper.getMainLooper())
+    private lateinit var satelliteAccessController: SatelliteAccessController
+    private lateinit var roleHolderChangedListener: OnRoleHoldersChangedListener
+    private val mockedPackageManagerForUser = ArrayMap<Int, PackageManager>()
+
+    private val featureFlags = HashSet<String>()
+
+    // This will set feature flags from @FeatureFlag annotations
+    // into the map before setUp() runs.
+    @get:Rule
+    val setFeatureFlagsRule = SetFeatureFlagsRule(
+            { name, enabled ->
+                if (enabled == true) featureFlags.add(name) else featureFlags.remove(name) },
+            { name -> featureFlags.contains(name) }
+    )
 
     private fun <T> mockService(name: String, clazz: Class<T>, service: T) {
         doReturn(name).`when`(context).getSystemServiceName(clazz)
@@ -98,237 +110,466 @@ class SatelliteAccessControllerTest {
         }
     }
 
+    private fun mockPackageManagerForUser(userId: Int): PackageManager =
+            mockedPackageManagerForUser.getOrPut(userId) {
+                val userHandle = UserHandle.of(userId)
+                val contextAsUser = mock(Context::class.java)
+                val packageManager = mock(PackageManager::class.java)
+                doReturn(contextAsUser).`when`(context).createContextAsUser(userHandle, 0)
+                doReturn(packageManager).`when`(contextAsUser).packageManager
+                packageManager
+            }
+
+    private fun getMockedPackageManagerForUser(userId: Int) = mockedPackageManagerForUser[userId]!!
+
     @Before
-    @Throws(PackageManager.NameNotFoundException::class)
     fun setup() {
         doReturn(emptyList<UserHandle>()).`when`(userManager).getUserHandles(true)
         mockService(Context.USER_SERVICE, UserManager::class.java, userManager)
+        doReturn(featureFlags.contains(CONSTRAINED_DATA_SATELLITE_OPTIN))
+                .`when`(deps).supportConstrainedDataSatelliteOptIn(any())
+        satelliteAccessController = SatelliteAccessController(context, deps, callback, handler)
 
-        doReturn(primaryUserContext).`when`(context).createContextAsUser(PRIMARY_USER_HANDLE, 0)
-        doReturn(mPackageManagerPrimaryUser).`when`(primaryUserContext).packageManager
-
-        doReturn(secondaryUserContext).`when`(context).createContextAsUser(SECONDARY_USER_HANDLE, 0)
-        doReturn(mPackageManagerSecondaryUser).`when`(secondaryUserContext).packageManager
+        mockPackageManagerForUser(PRIMARY_USER)
+        mockPackageManagerForUser(SECONDARY_USER)
 
         for (app in listOf(SMS_APP1, SMS_APP2)) {
             doReturn(PackageManager.PERMISSION_GRANTED)
-                .`when`(mPackageManagerPrimaryUser)
+                .`when`(getMockedPackageManagerForUser(PRIMARY_USER))
                 .checkPermission(Manifest.permission.SATELLITE_COMMUNICATION, app)
             doReturn(PackageManager.PERMISSION_GRANTED)
-                .`when`(mPackageManagerSecondaryUser)
+                .`when`(getMockedPackageManagerForUser(SECONDARY_USER))
                 .checkPermission(Manifest.permission.SATELLITE_COMMUNICATION, app)
         }
 
-        // Initialise message application primary user package1
-        val applicationInfo1 = ApplicationInfo()
-        applicationInfo1.uid = PRIMARY_USER_SMS_APP_UID1
-        doReturn(applicationInfo1)
-            .`when`(mPackageManagerPrimaryUser)
-            .getApplicationInfo(eq(SMS_APP1), anyInt())
-
-        // Initialise message application primary user package2
-        val applicationInfo2 = ApplicationInfo()
-        applicationInfo2.uid = PRIMARY_USER_SMS_APP_UID2
-        doReturn(applicationInfo2)
-            .`when`(mPackageManagerPrimaryUser)
-            .getApplicationInfo(eq(SMS_APP2), anyInt())
-
-        // Initialise message application secondary user package1
-        val applicationInfo3 = ApplicationInfo()
-        applicationInfo3.uid = SECONDARY_USER_SMS_APP_UID1
-        doReturn(applicationInfo3)
-            .`when`(mPackageManagerSecondaryUser)
-            .getApplicationInfo(eq(SMS_APP1), anyInt())
-
-        // Initialise message application secondary user package2
-        val applicationInfo4 = ApplicationInfo()
-        applicationInfo4.uid = SECONDARY_USER_SMS_APP_UID2
-        doReturn(applicationInfo4)
-            .`when`(mPackageManagerSecondaryUser)
-            .getApplicationInfo(eq(SMS_APP2), anyInt())
+        for ((appName, appId) in listOf(
+            SMS_APP1 to SMS_APP_ID1,
+            SMS_APP2 to SMS_APP_ID2
+        )) {
+            val primaryUid = appId.toUid(PRIMARY_USER)
+            val primaryAppInfo = ApplicationInfo().apply { uid = primaryUid }
+            doReturn(primaryAppInfo)
+                    .`when`(getMockedPackageManagerForUser(PRIMARY_USER))
+                    .getApplicationInfo(eq(appName), anyInt())
+            val secondaryUid = appId.toUid(SECONDARY_USER)
+            val secondaryAppInfo = ApplicationInfo().apply { uid = secondaryUid }
+            doReturn(secondaryAppInfo)
+                    .`when`(getMockedPackageManagerForUser(SECONDARY_USER))
+                    .getApplicationInfo(eq(appName), anyInt())
+        }
     }
 
     @Test
-    fun test_onRoleHoldersChanged_SatelliteFallbackUid_Changed_SingleUser() {
+    fun testRoleHoldersChanged_satelliteRoleSmsUidChanged_singleUser() {
         startSatelliteAccessController()
-        doReturn(listOf<String>()).`when`(mDeps).getRoleHoldersAsUser(
+        doReturn(listOf<String>()).`when`(deps).getRoleHoldersAsUser(
             RoleManager.ROLE_SMS,
             PRIMARY_USER_HANDLE
         )
-        mRoleHolderChangedListener.onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
-        verify(mCallback, never()).accept(any())
+        onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
+        verify(callback, never()).accept(any(), any())
 
         // check DEFAULT_MESSAGING_APP1 is available as satellite network fallback uid
         doReturn(listOf(SMS_APP1))
-            .`when`(mDeps).getRoleHoldersAsUser(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
-        mRoleHolderChangedListener.onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
-        verify(mCallback).accept(setOf(PRIMARY_USER_SMS_APP_UID1))
+            .`when`(deps).getRoleHoldersAsUser(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
+        onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
+        verify(callback).accept(setOf(SMS_APP_ID1.toUid(PRIMARY_USER)), emptySet())
 
         // check SMS_APP2 is available as satellite network Fallback uid
-        doReturn(listOf(SMS_APP2)).`when`(mDeps).getRoleHoldersAsUser(
+        doReturn(listOf(SMS_APP2)).`when`(deps).getRoleHoldersAsUser(
             RoleManager.ROLE_SMS,
             PRIMARY_USER_HANDLE
         )
-        mRoleHolderChangedListener.onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
-        verify(mCallback).accept(setOf(PRIMARY_USER_SMS_APP_UID2))
+        onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
+        verify(callback).accept(setOf(SMS_APP_ID2.toUid(PRIMARY_USER)), emptySet())
 
         // check no uid is available as satellite network fallback uid
-        doReturn(listOf<String>()).`when`(mDeps).getRoleHoldersAsUser(
+        doReturn(listOf<String>()).`when`(deps).getRoleHoldersAsUser(
             RoleManager.ROLE_SMS,
             PRIMARY_USER_HANDLE
         )
-        mRoleHolderChangedListener.onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
-        verify(mCallback).accept(ArraySet())
+        onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
+        verify(callback).accept(emptySet(), emptySet())
     }
 
     @Test
-    fun test_onRoleHoldersChanged_NoSatelliteCommunicationPermission() {
+    fun testRoleHoldersChanged_noSatelliteCommunicationPermission() {
         startSatelliteAccessController()
-        doReturn(listOf<Any>()).`when`(mDeps).getRoleHoldersAsUser(
+        doReturn(listOf<Any>()).`when`(deps).getRoleHoldersAsUser(
             RoleManager.ROLE_SMS,
             PRIMARY_USER_HANDLE
         )
-        mRoleHolderChangedListener.onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
-        verify(mCallback, never()).accept(any())
+        onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
+        verify(callback, never()).accept(any(), any())
 
-        // check DEFAULT_MESSAGING_APP1 is not available as satellite network fallback uid
+        // Check DEFAULT_MESSAGING_APP1 is not available as satellite network fallback uid
         // since satellite communication permission not available.
         doReturn(PackageManager.PERMISSION_DENIED)
-            .`when`(mPackageManagerPrimaryUser)
+            .`when`(getMockedPackageManagerForUser(PRIMARY_USER))
             .checkPermission(Manifest.permission.SATELLITE_COMMUNICATION, SMS_APP1)
         doReturn(listOf(SMS_APP1))
-            .`when`(mDeps).getRoleHoldersAsUser(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
-        mRoleHolderChangedListener.onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
-        verify(mCallback, never()).accept(any())
+            .`when`(deps).getRoleHoldersAsUser(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
+        onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
+        verify(callback, never()).accept(any(), any())
     }
 
     @Test
-    fun test_onRoleHoldersChanged_RoleSms_NotAvailable() {
+    fun testRoleHoldersChanged_roleSms_notAvailable() {
         startSatelliteAccessController()
         doReturn(listOf(SMS_APP1))
-            .`when`(mDeps).getRoleHoldersAsUser(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
-        mRoleHolderChangedListener.onRoleHoldersChanged(
-            RoleManager.ROLE_BROWSER,
-            PRIMARY_USER_HANDLE
-        )
-        verify(mCallback, never()).accept(any())
+            .`when`(deps).getRoleHoldersAsUser(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
+        onRoleHoldersChanged(RoleManager.ROLE_BROWSER, PRIMARY_USER_HANDLE)
+        verify(callback, never()).accept(any(), any())
     }
 
     @Test
-    fun test_onRoleHoldersChanged_SatelliteNetworkFallbackUid_Changed_multiUser() {
+    fun testRoleHoldersChanged_satelliteRoleSmsUidChanged_multiUser() {
         startSatelliteAccessController()
-        doReturn(listOf<String>()).`when`(mDeps).getRoleHoldersAsUser(
+        doReturn(listOf<String>()).`when`(deps).getRoleHoldersAsUser(
             RoleManager.ROLE_SMS,
             PRIMARY_USER_HANDLE
         )
-        mRoleHolderChangedListener.onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
-        verify(mCallback, never()).accept(any())
+        onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
+        verify(callback, never()).accept(any(), any())
 
         // check SMS_APP1 is available as satellite network fallback uid at primary user
         doReturn(listOf(SMS_APP1))
-            .`when`(mDeps).getRoleHoldersAsUser(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
-        mRoleHolderChangedListener.onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
-        verify(mCallback).accept(setOf(PRIMARY_USER_SMS_APP_UID1))
+            .`when`(deps).getRoleHoldersAsUser(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
+        onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
+        verify(callback).accept(setOf(SMS_APP_ID1.toUid(PRIMARY_USER)), emptySet())
 
         // check SMS_APP2 is available as satellite network fallback uid at primary user
-        doReturn(listOf(SMS_APP2)).`when`(mDeps).getRoleHoldersAsUser(
+        doReturn(listOf(SMS_APP2)).`when`(deps).getRoleHoldersAsUser(
             RoleManager.ROLE_SMS,
             PRIMARY_USER_HANDLE
         )
-        mRoleHolderChangedListener.onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
-        verify(mCallback).accept(setOf(PRIMARY_USER_SMS_APP_UID2))
+        onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
+        verify(callback).accept(setOf(SMS_APP_ID2.toUid(PRIMARY_USER)), emptySet())
 
         // check SMS_APP1 is available as satellite network fallback uid at secondary user
-        doReturn(listOf(SMS_APP1)).`when`(mDeps).getRoleHoldersAsUser(
+        doReturn(listOf(SMS_APP1)).`when`(deps).getRoleHoldersAsUser(
             RoleManager.ROLE_SMS,
             SECONDARY_USER_HANDLE
         )
-        mRoleHolderChangedListener.onRoleHoldersChanged(RoleManager.ROLE_SMS, SECONDARY_USER_HANDLE)
-        verify(mCallback).accept(setOf(PRIMARY_USER_SMS_APP_UID2, SECONDARY_USER_SMS_APP_UID1))
+        onRoleHoldersChanged(RoleManager.ROLE_SMS, SECONDARY_USER_HANDLE)
+        verify(callback).accept(
+            setOf(SMS_APP_ID2.toUid(PRIMARY_USER), SMS_APP_ID1.toUid(SECONDARY_USER)),
+            emptySet()
+        )
 
         // check no uid is available as satellite network fallback uid at primary user
-        doReturn(listOf<String>()).`when`(mDeps).getRoleHoldersAsUser(
-            RoleManager.ROLE_SMS,
-            PRIMARY_USER_HANDLE
-        )
-        mRoleHolderChangedListener.onRoleHoldersChanged(
+        doReturn(listOf<String>()).`when`(deps).getRoleHoldersAsUser(
             RoleManager.ROLE_SMS,
             PRIMARY_USER_HANDLE
         )
-        verify(mCallback).accept(setOf(SECONDARY_USER_SMS_APP_UID1))
+        onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
+        verify(callback).accept(setOf(SMS_APP_ID1.toUid(SECONDARY_USER)), emptySet())
 
         // check SMS_APP2 is available as satellite network fallback uid at secondary user
         doReturn(listOf(SMS_APP2))
-            .`when`(mDeps).getRoleHoldersAsUser(RoleManager.ROLE_SMS, SECONDARY_USER_HANDLE)
-        mRoleHolderChangedListener.onRoleHoldersChanged(RoleManager.ROLE_SMS, SECONDARY_USER_HANDLE)
-        verify(mCallback).accept(setOf(SECONDARY_USER_SMS_APP_UID2))
+            .`when`(deps).getRoleHoldersAsUser(RoleManager.ROLE_SMS, SECONDARY_USER_HANDLE)
+        onRoleHoldersChanged(RoleManager.ROLE_SMS, SECONDARY_USER_HANDLE)
+        verify(callback).accept(setOf(SMS_APP_ID2.toUid(SECONDARY_USER)), emptySet())
 
         // check no uid is available as satellite network fallback uid at secondary user
-        doReturn(listOf<String>()).`when`(mDeps).getRoleHoldersAsUser(
+        doReturn(listOf<String>()).`when`(deps).getRoleHoldersAsUser(
             RoleManager.ROLE_SMS,
             SECONDARY_USER_HANDLE
         )
-        mRoleHolderChangedListener.onRoleHoldersChanged(RoleManager.ROLE_SMS, SECONDARY_USER_HANDLE)
-        verify(mCallback).accept(ArraySet())
+        onRoleHoldersChanged(RoleManager.ROLE_SMS, SECONDARY_USER_HANDLE)
+        verify(callback).accept(emptySet(), emptySet())
     }
 
     @Test
-    fun test_SatelliteFallbackUidCallback_OnUserRemoval() {
+    fun testSatelliteFallbackUidCallback_onUserRemoval() {
         startSatelliteAccessController()
         // check SMS_APP2 is available as satellite network fallback uid at primary user
-        doReturn(listOf(SMS_APP2)).`when`(mDeps).getRoleHoldersAsUser(
+        doReturn(listOf(SMS_APP2)).`when`(deps).getRoleHoldersAsUser(
             RoleManager.ROLE_SMS,
             PRIMARY_USER_HANDLE
         )
-        mRoleHolderChangedListener.onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
-        verify(mCallback).accept(setOf(PRIMARY_USER_SMS_APP_UID2))
+        onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
+        verify(callback).accept(setOf(SMS_APP_ID2.toUid(PRIMARY_USER)), emptySet())
 
         // check SMS_APP1 is available as satellite network fallback uid at secondary user
-        doReturn(listOf(SMS_APP1)).`when`(mDeps).getRoleHoldersAsUser(
+        doReturn(listOf(SMS_APP1)).`when`(deps).getRoleHoldersAsUser(
             RoleManager.ROLE_SMS,
             SECONDARY_USER_HANDLE
         )
-        mRoleHolderChangedListener.onRoleHoldersChanged(RoleManager.ROLE_SMS, SECONDARY_USER_HANDLE)
-        verify(mCallback).accept(setOf(PRIMARY_USER_SMS_APP_UID2, SECONDARY_USER_SMS_APP_UID1))
+        onRoleHoldersChanged(RoleManager.ROLE_SMS, SECONDARY_USER_HANDLE)
+        verify(callback).accept(
+            setOf(SMS_APP_ID2.toUid(PRIMARY_USER), SMS_APP_ID1.toUid(SECONDARY_USER)),
+            emptySet()
+        )
+        onUserRemoved(SECONDARY_USER_HANDLE)
+        verify(callback, times(2)).accept(
+            setOf(SMS_APP_ID2.toUid(PRIMARY_USER)),
+            emptySet()
+        )
+    }
 
-        val userRemovalIntent = Intent(Intent.ACTION_USER_REMOVED)
-        userRemovalIntent.putExtra(Intent.EXTRA_USER, SECONDARY_USER_HANDLE)
-        mUserRemovedReceiver.onReceive(context, userRemovalIntent)
-        verify(mCallback, times(2)).accept(setOf(PRIMARY_USER_SMS_APP_UID2))
+    private fun <T : Any> processOnHandlerThread(function: () -> T): T {
+        val future = CompletableFuture<T>()
+        handler.post { future.complete(function()) }
+        return future.get()
     }
 
-    @Test
-    fun testOnStartUpCallbackSatelliteFallbackUidWithExistingUsers() {
-        doReturn(
-            listOf(PRIMARY_USER_HANDLE)
-        ).`when`(userManager).getUserHandles(true)
-        doReturn(listOf(SMS_APP1))
-            .`when`(mDeps).getRoleHoldersAsUser(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
-        // At start up, SatelliteAccessController must call CS callback with existing users'
-        // default messaging apps uids.
-        startSatelliteAccessController()
-        verify(mCallback, timeout(500)).accept(setOf(PRIMARY_USER_SMS_APP_UID1))
+    private fun onRoleHoldersChanged(roleName: String, userHandle: UserHandle) =
+        processOnHandlerThread {
+            roleHolderChangedListener.onRoleHoldersChanged(roleName, userHandle)
+        }
+
+    private fun onUserAddedWithInstalledPackageList(
+            userHandle: UserHandle,
+            apps: List<PackageInfo>
+    ) = processOnHandlerThread {
+        satelliteAccessController.onUserAddedWithInstalledPackageList(userHandle, apps)
     }
 
+    private fun onUserRemoved(userHandle: UserHandle) = processOnHandlerThread {
+        satelliteAccessController.onUserRemoved(userHandle)
+    }
+
+    private fun onPackageAdded(packageName: String, uid: Int) =
+            processOnHandlerThread { satelliteAccessController.onPackageAdded(packageName, uid) }
+
+    private fun onPackageRemoved(packageName: String, uid: Int) =
+            processOnHandlerThread { satelliteAccessController.onPackageRemoved(packageName, uid) }
+
+    private fun onExternalApplicationsAvailable(pkgList: Array<String>) =
+            processOnHandlerThread {
+                satelliteAccessController.onExternalApplicationsAvailable(pkgList)
+            }
+
     private fun startSatelliteAccessController() {
-        mSatelliteAccessController.start()
+        satelliteAccessController.start()
         // Get registered listener using captor
         val listenerCaptor = ArgumentCaptor.forClass(OnRoleHoldersChangedListener::class.java)
-        verify(mDeps).addOnRoleHoldersChangedListenerAsUser(
+        verify(deps).addOnRoleHoldersChangedListenerAsUser(
             any(Executor::class.java),
             listenerCaptor.capture(),
             any(UserHandle::class.java)
         )
-        mRoleHolderChangedListener = listenerCaptor.value
-
-        // Get registered receiver using captor
-        val userRemovedReceiverCaptor = ArgumentCaptor.forClass(BroadcastReceiver::class.java)
-        verify(context).registerReceiver(
-            userRemovedReceiverCaptor.capture(),
-            any(IntentFilter::class.java),
-            isNull(),
-            any(Handler::class.java)
-        )
-         mUserRemovedReceiver = userRemovedReceiverCaptor.value
+        roleHolderChangedListener = listenerCaptor.value
+    }
+
+    private fun makePackageInfo(packageName: String, uid: Int) = PackageInfo().apply {
+        this.packageName = packageName
+        applicationInfo = ApplicationInfo().apply { this.uid = uid }
+    }
+
+    private fun mockGetPackagesForUid(uid: Int, pkgs: Array<String>?) {
+        val pm = mockPackageManagerForUser(uid.getUserId())
+        `when`(pm.getPackagesForUid(uid)).thenReturn(pkgs)
+    }
+
+    private fun mockIsSatelliteDataOptimizedAppForUser(
+            userId: Int,
+            packageName: String,
+            isOptimized: Boolean
+    ) {
+        val appInfo = ApplicationInfo()
+        if (isOptimized) {
+            appInfo.metaData = Bundle()
+            appInfo.metaData.putString(PROPERTY_SATELLITE_DATA_OPTIMIZED, packageName)
+        }
+        val pm = mockPackageManagerForUser(userId)
+        doReturn(appInfo).`when`(pm).getApplicationInfo(packageName, PackageManager.GET_META_DATA)
+    }
+
+    @FeatureFlag(name = CONSTRAINED_DATA_SATELLITE_OPTIN)
+    @Test
+    fun testSatelliteOptInUids_onPackageAdded() {
+        mockIsSatelliteDataOptimizedAppForUser(TEST_UID1.getUserId(), TEST_PACKAGE1, true)
+        onPackageAdded(TEST_PACKAGE1, TEST_UID1)
+        verify(callback).accept(emptySet(), setOf(TEST_UID1))
+    }
+
+    @FeatureFlag(name = CONSTRAINED_DATA_SATELLITE_OPTIN)
+    @Test
+    fun testSatelliteOptInUids_invalidMetaData() {
+        val appInfoWithBoolean = ApplicationInfo()
+        appInfoWithBoolean.metaData = Bundle()
+        appInfoWithBoolean.metaData.putBoolean(PROPERTY_SATELLITE_DATA_OPTIMIZED, true)
+        val pm = mockPackageManagerForUser(TEST_UID1.getUserId())
+        doReturn(appInfoWithBoolean).`when`(pm)
+                .getApplicationInfo(TEST_PACKAGE1, PackageManager.GET_META_DATA)
+        onPackageAdded(TEST_PACKAGE1, TEST_UID1)
+        verify(callback, never()).accept(any(), any())
+
+        val appInfoWithWrongPackage = ApplicationInfo()
+        appInfoWithWrongPackage.metaData = Bundle()
+        appInfoWithWrongPackage.metaData
+                .putString(PROPERTY_SATELLITE_DATA_OPTIMIZED, "wrong package")
+        doReturn(appInfoWithWrongPackage).`when`(pm)
+                .getApplicationInfo(TEST_PACKAGE1, PackageManager.GET_META_DATA)
+
+        onPackageAdded(TEST_PACKAGE1, TEST_UID1)
+        verify(callback, never()).accept(any(), any())
+    }
+
+    @FeatureFlag(name = CONSTRAINED_DATA_SATELLITE_OPTIN)
+    @Test
+    fun testSatelliteOptInUids_onPackageAdded_ignoresIfNotSatelliteOptimized() {
+        mockIsSatelliteDataOptimizedAppForUser(TEST_UID1.getUserId(), TEST_PACKAGE1, false)
+        onPackageAdded(TEST_PACKAGE1, TEST_UID1)
+        verify(callback, never()).accept(any(), any())
+    }
+
+    @FeatureFlag(name = CONSTRAINED_DATA_SATELLITE_OPTIN)
+    @Test
+    fun testSatelliteOptInUids_onPackageRemoved_noOtherShareUid() {
+        mockIsSatelliteDataOptimizedAppForUser(TEST_UID1.getUserId(), TEST_PACKAGE1, true)
+        mockGetPackagesForUid(TEST_UID1, arrayOf(TEST_PACKAGE1))
+
+        onPackageAdded(TEST_PACKAGE1, TEST_UID1)
+        verify(callback).accept(emptySet(), setOf(TEST_UID1))
+        onPackageRemoved(TEST_PACKAGE1, TEST_UID1)
+        verify(callback).accept(emptySet(), emptySet())
+    }
+
+    @FeatureFlag(name = CONSTRAINED_DATA_SATELLITE_OPTIN)
+    @Test
+    fun testSatelliteOptInUids_onPackageRemoved_otherShareUid() {
+        mockIsSatelliteDataOptimizedAppForUser(TEST_UID1.getUserId(), TEST_PACKAGE1, true)
+        mockIsSatelliteDataOptimizedAppForUser(TEST_UID1.getUserId(), TEST_PACKAGE2, true)
+        mockGetPackagesForUid(TEST_UID1, arrayOf(TEST_PACKAGE1, TEST_PACKAGE2))
+
+        // Verify uid is not removed if there is still another package shares the same uid.
+        val inOrder = inOrder(callback)
+        onPackageAdded(TEST_PACKAGE1, TEST_UID1)
+        inOrder.verify(callback).accept(emptySet(), setOf(TEST_UID1))
+        onPackageRemoved(TEST_PACKAGE1, TEST_UID1)
+        inOrder.verifyNoMoreInteractions()
+
+        // Verify uid is removed if there is no other package with shared uid.
+        mockGetPackagesForUid(TEST_UID1, null)
+        onPackageRemoved(TEST_PACKAGE2, TEST_UID1)
+        inOrder.verify(callback).accept(emptySet(), emptySet())
+    }
+
+    @FeatureFlag(name = CONSTRAINED_DATA_SATELLITE_OPTIN)
+    @Test
+    fun testSatelliteOptInUids_onUserAddedRemoved() {
+        mockIsSatelliteDataOptimizedAppForUser(TEST_UID1.getUserId(), TEST_PACKAGE1, true)
+        mockIsSatelliteDataOptimizedAppForUser(TEST_UID2.getUserId(), TEST_PACKAGE2, true)
+        val packageInfo1 = makePackageInfo(TEST_PACKAGE1, TEST_UID1)
+        val packageInfo2 = makePackageInfo(TEST_PACKAGE2, TEST_UID2)
+
+        val inOrder = inOrder(callback)
+        onUserAddedWithInstalledPackageList(PRIMARY_USER_HANDLE, listOf(packageInfo1))
+        onUserAddedWithInstalledPackageList(SECONDARY_USER_HANDLE, listOf(packageInfo2))
+        inOrder.verify(callback).accept(emptySet(), setOf(TEST_UID1))
+        inOrder.verify(callback).accept(emptySet(), setOf(TEST_UID1, TEST_UID2))
+
+        onUserRemoved(SECONDARY_USER_HANDLE)
+        // Verify that the app associated with the non-removed user is not removed.
+        inOrder.verify(callback).accept(emptySet(), setOf(TEST_UID1))
+
+        onUserRemoved(PRIMARY_USER_HANDLE)
+        // Verify everything is removed.
+        inOrder.verify(callback).accept(emptySet(), emptySet())
+        inOrder.verifyNoMoreInteractions()
+    }
+
+    @FeatureFlag(name = CONSTRAINED_DATA_SATELLITE_OPTIN, enabled = false)
+    @Test
+    fun testSatelliteOptInUids_featureDisabled() {
+        mockIsSatelliteDataOptimizedAppForUser(TEST_UID1.getUserId(), TEST_PACKAGE1, true)
+        val packageInfo1 = makePackageInfo(TEST_PACKAGE1, TEST_UID1)
+
+        // Verify nothing changes and nothing crashes.
+        onUserAddedWithInstalledPackageList(PRIMARY_USER_HANDLE, listOf(packageInfo1))
+        onPackageAdded(TEST_PACKAGE1, TEST_UID1)
+        onPackageRemoved(TEST_PACKAGE1, TEST_UID1)
+        onExternalApplicationsAvailable(arrayOf(SMS_APP1, SMS_APP2))
+        onUserRemoved(PRIMARY_USER_HANDLE)
+        verify(callback, never()).accept(any(), any())
+    }
+
+    @FeatureFlag(name = CONSTRAINED_DATA_SATELLITE_OPTIN)
+    @Test
+    fun testSatelliteOptInUids_withRoleSmsUids() {
+        startSatelliteAccessController()
+        // Set SMS_APP1 under primary user as a role-sms Uid.
+        doReturn(listOf(SMS_APP1))
+                .`when`(deps).getRoleHoldersAsUser(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
+        onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
+        verify(callback).accept(setOf(SMS_APP_ID1.toUid(PRIMARY_USER)), emptySet())
+
+        // Mock another opt-in uid, verify they both reported via the callback.
+        mockIsSatelliteDataOptimizedAppForUser(TEST_UID1.getUserId(), TEST_PACKAGE1, true)
+        onPackageAdded(TEST_PACKAGE1, TEST_UID1)
+        verify(callback).accept(setOf(SMS_APP_ID1.toUid(PRIMARY_USER)), setOf(TEST_UID1))
+    }
+
+    @FeatureFlag(name = CONSTRAINED_DATA_SATELLITE_OPTIN)
+    @Test
+    fun testSatelliteOptInUids_onUserAddedWithRoleSmsUids() {
+        mockIsSatelliteDataOptimizedAppForUser(TEST_UID1.getUserId(), TEST_PACKAGE1, true)
+        val packageInfo1 = makePackageInfo(TEST_PACKAGE1, TEST_UID1)
+        doReturn(listOf(SMS_APP1))
+                .`when`(deps).getRoleHoldersAsUser(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
+
+        val inOrder = inOrder(callback)
+        onUserAddedWithInstalledPackageList(PRIMARY_USER_HANDLE, listOf(packageInfo1))
+        // Verify the callback only fired once after both lists are ready.
+        inOrder.verify(callback, never())
+                .accept(setOf(SMS_APP_ID1.toUid(PRIMARY_USER)), emptySet())
+        inOrder.verify(callback).accept(setOf(SMS_APP_ID1.toUid(PRIMARY_USER)), setOf(TEST_UID1))
+        inOrder.verifyNoMoreInteractions()
+    }
+
+    @FeatureFlag(name = CONSTRAINED_DATA_SATELLITE_OPTIN)
+    @Test
+    fun testSatelliteOptInUids_withRoleSmsUids_overlappedUid() {
+        startSatelliteAccessController()
+        val smsUid = SMS_APP_ID1.toUid(PRIMARY_USER)
+
+        val inOrder = inOrder(callback)
+        // Mock opt-in uids, verify they both reported via the callback.
+        // However, one opt-in uid is a messaging app and will surprise us later.
+        mockIsSatelliteDataOptimizedAppForUser(TEST_UID1.getUserId(), TEST_PACKAGE1, true)
+        mockIsSatelliteDataOptimizedAppForUser(TEST_UID1.getUserId(), SMS_APP1, true)
+        onPackageAdded(TEST_PACKAGE1, TEST_UID1)
+        inOrder.verify(callback).accept(emptySet(), setOf(TEST_UID1))
+        onPackageAdded(SMS_APP1, smsUid)
+        inOrder.verify(callback).accept(emptySet(), setOf(TEST_UID1, smsUid))
+
+        // Set SMS_APP1 as a role-sms Uid.
+        // Verify the role-sms Uid is excluded from the opt-in Uid list.
+        doReturn(listOf(SMS_APP1))
+                .`when`(deps).getRoleHoldersAsUser(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
+        onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
+        inOrder.verify(callback).accept(setOf(smsUid), setOf(TEST_UID1))
+
+        // Unset SMS_APP1 as the role-sms Uid.
+        // Verify the role-sms Uid is included to the opt-in Uid list again.
+        doReturn(emptyList<String>())
+                .`when`(deps).getRoleHoldersAsUser(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
+        onRoleHoldersChanged(RoleManager.ROLE_SMS, PRIMARY_USER_HANDLE)
+        inOrder.verify(callback).accept(emptySet(), setOf(TEST_UID1, smsUid))
+    }
+
+    @FeatureFlag(name = CONSTRAINED_DATA_SATELLITE_OPTIN)
+    @Test
+    fun testSatelliteOptInUids_onExternalApplicationsAvailable() {
+        // Mock the sms apps as general opt-in apps without setting role-sms.
+        mockIsSatelliteDataOptimizedAppForUser(PRIMARY_USER, SMS_APP1, true)
+        mockIsSatelliteDataOptimizedAppForUser(SECONDARY_USER, SMS_APP1, true)
+        mockIsSatelliteDataOptimizedAppForUser(PRIMARY_USER, SMS_APP2, true)
+        mockIsSatelliteDataOptimizedAppForUser(SECONDARY_USER, SMS_APP2, true)
+
+        val inOrder = inOrder(callback)
+        onUserAddedWithInstalledPackageList(PRIMARY_USER_HANDLE, emptyList())
+        onUserAddedWithInstalledPackageList(SECONDARY_USER_HANDLE, emptyList())
+        onExternalApplicationsAvailable(arrayOf(SMS_APP1, SMS_APP2))
+        inOrder.verify(callback).accept(emptySet(), setOf(
+                SMS_APP_ID1.toUid(PRIMARY_USER),
+                SMS_APP_ID1.toUid(SECONDARY_USER),
+                SMS_APP_ID2.toUid(PRIMARY_USER),
+                SMS_APP_ID2.toUid(SECONDARY_USER)
+        ))
+        inOrder.verifyNoMoreInteractions()
     }
 }
diff --git a/tests/unit/java/com/android/server/connectivity/mdns/ConnectivityMonitorWithConnectivityManagerTests.java b/tests/unit/java/com/android/server/connectivity/mdns/ConnectivityMonitorWithConnectivityManagerTests.java
index bb59e0d4bf..96951e7bf0 100644
--- a/tests/unit/java/com/android/server/connectivity/mdns/ConnectivityMonitorWithConnectivityManagerTests.java
+++ b/tests/unit/java/com/android/server/connectivity/mdns/ConnectivityMonitorWithConnectivityManagerTests.java
@@ -16,8 +16,10 @@
 
 package com.android.server.connectivity.mdns;
 
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
+import static android.net.InetAddresses.parseNumericAddress;
+import static android.net.RouteInfo.RTN_UNICAST;
 
+import static org.junit.Assert.assertEquals;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.inOrder;
@@ -28,8 +30,12 @@ import static org.mockito.Mockito.verify;
 import android.content.Context;
 import android.net.ConnectivityManager;
 import android.net.ConnectivityManager.NetworkCallback;
+import android.net.IpPrefix;
+import android.net.LinkProperties;
 import android.net.Network;
 import android.net.NetworkRequest;
+import android.net.RouteInfo;
+import android.os.Build;
 
 import com.android.net.module.util.SharedLog;
 import com.android.testutils.DevSdkIgnoreRule;
@@ -43,9 +49,12 @@ import org.mockito.InOrder;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 
+import java.net.NetworkInterface;
+import java.util.List;
+
 /** Tests for {@link ConnectivityMonitor}. */
 @RunWith(DevSdkIgnoreRunner.class)
-@DevSdkIgnoreRule.IgnoreUpTo(SC_V2)
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 public class ConnectivityMonitorWithConnectivityManagerTests {
     @Mock private Context mContext;
     @Mock private ConnectivityMonitor.Listener mockListener;
@@ -106,18 +115,11 @@ public class ConnectivityMonitorWithConnectivityManagerTests {
     @Test
     public void testIntentFired_shouldNotifyListener() {
         InOrder inOrder = inOrder(mockListener);
-        monitor.startWatchingConnectivityChanges();
-
-        final ArgumentCaptor<NetworkCallback> callbackCaptor =
-                ArgumentCaptor.forClass(NetworkCallback.class);
-        verify(mConnectivityManager, times(1)).registerNetworkCallback(
-                any(NetworkRequest.class), callbackCaptor.capture());
-
-        final NetworkCallback callback = callbackCaptor.getValue();
+        final NetworkCallback callback = setupCallback();
         final Network testNetwork = mock(Network.class);
 
         // Simulate network available.
-        callback.onAvailable(testNetwork);
+        callback.onLinkPropertiesChanged(testNetwork, new LinkProperties());
         inOrder.verify(mockListener).onConnectivityChanged();
 
         // Simulate network lost.
@@ -129,6 +131,107 @@ public class ConnectivityMonitorWithConnectivityManagerTests {
         inOrder.verify(mockListener).onConnectivityChanged();
     }
 
+    private NetworkCallback setupCallback() {
+        monitor.startWatchingConnectivityChanges();
+        final ArgumentCaptor<NetworkCallback> callbackCaptor =
+                ArgumentCaptor.forClass(NetworkCallback.class);
+        verify(mConnectivityManager, times(1)).registerNetworkCallback(
+                any(NetworkRequest.class), callbackCaptor.capture());
+
+        return callbackCaptor.getValue();
+    }
+
+    @Test
+    public void testGuessNetworkOfRemoteHost_ipv4Address() {
+        final NetworkCallback callback = setupCallback();
+
+        final Network testNetwork1 = mock(Network.class);
+        final Network testNetwork2 = mock(Network.class);
+        final int ifIndex1 = 1;
+        final NetworkInterfaceWrapper iface1 = getTestInterface("iface1", ifIndex1);
+        final NetworkInterfaceWrapper iface2 = getTestInterface("iface2", 2);
+
+        final LinkProperties lp1 = new LinkProperties();
+        lp1.setInterfaceName("iface1");
+        lp1.addRoute(new RouteInfo(
+                new IpPrefix("192.0.1.123/24"), null, lp1.getInterfaceName(), RTN_UNICAST));
+        lp1.addRoute(new RouteInfo(
+                new IpPrefix("0.0.0.0/0"), parseNumericAddress("192.0.1.1"),
+                lp1.getInterfaceName(), RTN_UNICAST));
+        final LinkProperties lp2 = new LinkProperties();
+        lp2.setInterfaceName("iface2");
+        lp2.addRoute(new RouteInfo(
+                new IpPrefix("192.0.2.123/24"), null, lp2.getInterfaceName(), RTN_UNICAST));
+        lp2.addRoute(new RouteInfo(
+                new IpPrefix("0.0.0.0/0"), parseNumericAddress("192.0.2.1"),
+                lp2.getInterfaceName(), RTN_UNICAST));
+
+        callback.onLinkPropertiesChanged(testNetwork1, lp1);
+        callback.onLinkPropertiesChanged(testNetwork2, lp2);
+
+        assertEquals(new SocketKey(testNetwork1, ifIndex1), monitor.guessNetworkOfRemoteHost(
+                List.of(iface1, iface2), parseNumericAddress("192.0.1.124")));
+    }
+
+    @Test
+    public void testGuessNetworkOfRemoteHost_ipv4LinkLocalAddress() {
+        final NetworkCallback callback = setupCallback();
+
+        final Network testNetwork = mock(Network.class);
+        final int ifIndex = 1;
+        final NetworkInterfaceWrapper iface = getTestInterface("iface1", ifIndex);
+
+        final LinkProperties lp = new LinkProperties();
+        lp.setInterfaceName("iface1");
+        lp.addRoute(new RouteInfo(
+                new IpPrefix("0.0.0.0/0"), parseNumericAddress("192.0.1.1"), lp.getInterfaceName(),
+                RTN_UNICAST));
+        lp.addRoute(new RouteInfo(
+                new IpPrefix("169.254.0.0/16"), null, lp.getInterfaceName(), RTN_UNICAST));
+
+        callback.onLinkPropertiesChanged(testNetwork, lp);
+
+        assertEquals(new SocketKey(testNetwork, ifIndex), monitor.guessNetworkOfRemoteHost(
+                List.of(iface), parseNumericAddress("169.254.1.2")));
+    }
+
+    @Test
+    public void testGuessNetworkOfRemoteHost_inet6LinkLocalAddress() throws Exception {
+        final NetworkCallback callback = setupCallback();
+
+        final Network testNetwork1 = mock(Network.class);
+        final Network testNetwork2 = mock(Network.class);
+        final NetworkInterfaceWrapper loIface = new NetworkInterfaceWrapper(
+                NetworkInterface.getByName("lo"));
+        final NetworkInterfaceWrapper wrongIface = getTestInterface(
+                "wrongiface", loIface.getIndex() + 1);
+
+        final LinkProperties lp1 = new LinkProperties();
+        lp1.setInterfaceName("wrongiface");
+        lp1.addRoute(new RouteInfo(
+                new IpPrefix("fe80::123/64"), null, lp1.getInterfaceName(), RTN_UNICAST));
+        lp1.addRoute(new RouteInfo(
+                new IpPrefix("::/0"), parseNumericAddress("fe80::111"), lp1.getInterfaceName(),
+                RTN_UNICAST));
+        final LinkProperties lp2 = new LinkProperties();
+        // Use an interface that is known to exist so the link-local address scope can be parsed
+        lp2.setInterfaceName("lo");
+
+        callback.onLinkPropertiesChanged(testNetwork1, lp1);
+        callback.onLinkPropertiesChanged(testNetwork2, lp2);
+
+        assertEquals(new SocketKey(testNetwork2, loIface.getIndex()),
+                monitor.guessNetworkOfRemoteHost(List.of(wrongIface, loIface),
+                        parseNumericAddress("fe80::124%lo")));
+    }
+
+    private NetworkInterfaceWrapper getTestInterface(String name, int index) {
+        NetworkInterface iface = mock(NetworkInterface.class);
+        doReturn(name).when(iface).getName();
+        doReturn(index).when(iface).getIndex();
+        return new NetworkInterfaceWrapper(iface);
+    }
+
     private void verifyNetworkCallbackRegistered(int time) {
         verify(mConnectivityManager, times(time)).registerNetworkCallback(
                 any(NetworkRequest.class), any(NetworkCallback.class));
diff --git a/tests/unit/java/com/android/server/connectivity/mdns/MdnsAdvertiserTest.kt b/tests/unit/java/com/android/server/connectivity/mdns/MdnsAdvertiserTest.kt
index 087617ad62..e08ce84109 100644
--- a/tests/unit/java/com/android/server/connectivity/mdns/MdnsAdvertiserTest.kt
+++ b/tests/unit/java/com/android/server/connectivity/mdns/MdnsAdvertiserTest.kt
@@ -576,14 +576,14 @@ class MdnsAdvertiserTest {
     }
 
     @Test
-    fun testAddService_NoSubtypeForGoogleCastOffload() {
+    fun testAddService_NoSubtypeForOffloadWhenSkipAnnouncements() {
         val advertiser =
             MdnsAdvertiser(thread.looper, socketProvider, cb, mockDeps, sharedlog, flags, context)
         postSync {
             advertiser.addOrUpdateService(
                 SERVICE_ID_1,
                 GOOGLECAST_SERVICE,
-                DEFAULT_ADVERTISING_OPTION,
+                MdnsAdvertisingOptions.newBuilder().setSkipSubtypeAnnouncements(true).build(),
                 TEST_CLIENT_UID_1
             )
         }
diff --git a/tests/unit/java/com/android/server/connectivity/mdns/MdnsDiscoveryManagerTests.java b/tests/unit/java/com/android/server/connectivity/mdns/MdnsDiscoveryManagerTests.java
index 758b8222f0..6cf5e84fb2 100644
--- a/tests/unit/java/com/android/server/connectivity/mdns/MdnsDiscoveryManagerTests.java
+++ b/tests/unit/java/com/android/server/connectivity/mdns/MdnsDiscoveryManagerTests.java
@@ -16,8 +16,6 @@
 
 package com.android.server.connectivity.mdns;
 
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 import static org.mockito.ArgumentMatchers.any;
@@ -31,6 +29,7 @@ import static org.mockito.Mockito.when;
 
 import android.annotation.NonNull;
 import android.net.Network;
+import android.os.Build;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.text.TextUtils;
@@ -61,7 +60,7 @@ import java.util.concurrent.ScheduledExecutorService;
 /** Tests for {@link MdnsDiscoveryManager}. */
 @DevSdkIgnoreRunner.MonitorThreadLeak
 @RunWith(DevSdkIgnoreRunner.class)
-@DevSdkIgnoreRule.IgnoreUpTo(SC_V2)
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 public class MdnsDiscoveryManagerTests {
     private static final long DEFAULT_TIMEOUT = 2000L;
     private static final String SERVICE_TYPE_1 = "_googlecast._tcp.local";
diff --git a/tests/unit/java/com/android/server/connectivity/mdns/MdnsInterfaceAdvertiserTest.kt b/tests/unit/java/com/android/server/connectivity/mdns/MdnsInterfaceAdvertiserTest.kt
index 629ac6714a..49467f7be1 100644
--- a/tests/unit/java/com/android/server/connectivity/mdns/MdnsInterfaceAdvertiserTest.kt
+++ b/tests/unit/java/com/android/server/connectivity/mdns/MdnsInterfaceAdvertiserTest.kt
@@ -50,11 +50,11 @@ import org.mockito.Mockito.argThat
 import org.mockito.Mockito.doAnswer
 import org.mockito.Mockito.doReturn
 import org.mockito.Mockito.eq
+import org.mockito.Mockito.inOrder
 import org.mockito.Mockito.mock
 import org.mockito.Mockito.never
 import org.mockito.Mockito.times
 import org.mockito.Mockito.verify
-import org.mockito.Mockito.inOrder
 
 private const val LOG_TAG = "testlogtag"
 private const val TIMEOUT_MS = 10_000L
@@ -107,7 +107,8 @@ class MdnsInterfaceAdvertiserTest {
     private val announceCbCaptor = ArgumentCaptor.forClass(PacketRepeaterCallback::class.java)
             as ArgumentCaptor<PacketRepeaterCallback<BaseAnnouncementInfo>>
     private val packetHandlerCaptor = ArgumentCaptor.forClass(
-            MulticastPacketReader.PacketHandler::class.java)
+            MulticastPacketReader.PacketHandler::class.java
+    )
 
     private val probeCb get() = probeCbCaptor.value
     private val announceCb get() = announceCbCaptor.value
@@ -131,14 +132,19 @@ class MdnsInterfaceAdvertiserTest {
     fun setUp() {
         doReturn(repository).`when`(deps).makeRecordRepository(any(), eq(TEST_HOSTNAME), any())
         doReturn(replySender).`when`(deps).makeReplySender(
-                anyString(), any(), any(), any(), any(), any())
+            anyString(),
+            any(),
+            any(),
+            any(),
+            any(),
+            any()
+        )
         doReturn(announcer).`when`(deps).makeMdnsAnnouncer(anyString(), any(), any(), any(), any())
         doReturn(prober).`when`(deps).makeMdnsProber(anyString(), any(), any(), any(), any())
 
         val knownServices = mutableSetOf<Int>()
         doAnswer { inv ->
             knownServices.add(inv.getArgument(0))
-
             -1
         }.`when`(repository).addService(anyInt(), any(), any())
         doAnswer { inv ->
@@ -169,8 +175,11 @@ class MdnsInterfaceAdvertiserTest {
     fun testAddRemoveService() {
         val testAnnouncementInfo = addServiceAndFinishProbing(TEST_SERVICE_ID_1, TEST_SERVICE_1)
 
-        verify(announcer).startSending(TEST_SERVICE_ID_1, testAnnouncementInfo,
-                0L /* initialDelayMs */)
+        verify(announcer).startSending(
+            TEST_SERVICE_ID_1,
+            testAnnouncementInfo,
+            0L /* initialDelayMs */
+        )
 
         thread.waitForIdle(TIMEOUT_MS)
         verify(cb).onServiceProbingSucceeded(advertiser, TEST_SERVICE_ID_1)
@@ -243,7 +252,9 @@ class MdnsInterfaceAdvertiserTest {
         inOrder.verify(prober).stop(TEST_SERVICE_ID_1)
         inOrder.verify(announcer).stop(TEST_SERVICE_ID_1)
         inOrder.verify(announcer).stop(TEST_SERVICE_ID_2)
-        inOrder.verify(announcer).startSending(TEST_SERVICE_ID_2, announcementInfo, 0L /* initialDelayMs */)
+        inOrder.verify(
+            announcer
+        ).startSending(TEST_SERVICE_ID_2, announcementInfo, 0L /* initialDelayMs */)
     }
 
     @Test
@@ -300,8 +311,14 @@ class MdnsInterfaceAdvertiserTest {
     fun testReplyToQuery() {
         addServiceAndFinishProbing(TEST_SERVICE_ID_1, TEST_SERVICE_1)
 
-        val testReply = MdnsReplyInfo(emptyList(), emptyList(), 0, InetSocketAddress(0),
-                InetSocketAddress(0), emptyList())
+        val testReply = MdnsReplyInfo(
+            emptyList(),
+            emptyList(),
+            0,
+            InetSocketAddress(0),
+            InetSocketAddress(0),
+            emptyList()
+        )
         doReturn(testReply).`when`(repository).getReply(any(), any())
 
         // Query obtained with:
@@ -319,8 +336,12 @@ class MdnsInterfaceAdvertiserTest {
         verify(repository).getReply(packetCaptor.capture(), srcCaptor.capture())
 
         assertEquals(src, srcCaptor.value)
-        assertNotSame(src, srcCaptor.value, "src will be reused by the packetHandler, references " +
-                "to it should not be used outside of handlePacket.")
+        assertNotSame(
+            src,
+            srcCaptor.value,
+            "src will be reused by the packetHandler, references " +
+            "to it should not be used outside of handlePacket."
+        )
 
         packetCaptor.value.let {
             assertEquals(1, it.questions.size)
@@ -339,24 +360,45 @@ class MdnsInterfaceAdvertiserTest {
     fun testReplyToQuery_TruncatedBitSet() {
         addServiceAndFinishProbing(TEST_SERVICE_ID_1, TEST_SERVICE_1)
         val src = InetSocketAddress(parseNumericAddress("2001:db8::456"), MdnsConstants.MDNS_PORT)
-        val testReply = MdnsReplyInfo(emptyList(), emptyList(), 400L, InetSocketAddress(0), src,
-                emptyList())
-        val knownAnswersReply = MdnsReplyInfo(emptyList(), emptyList(), 400L, InetSocketAddress(0),
-                src, emptyList())
-        val knownAnswersReply2 = MdnsReplyInfo(emptyList(), emptyList(), 0L, InetSocketAddress(0),
-                src, emptyList())
+        val testReply = MdnsReplyInfo(
+            emptyList(),
+            emptyList(),
+            400L,
+            InetSocketAddress(0),
+            src,
+            emptyList()
+        )
+        val knownAnswersReply = MdnsReplyInfo(
+            emptyList(),
+            emptyList(),
+            400L,
+            InetSocketAddress(0),
+            src,
+            emptyList()
+        )
+        val knownAnswersReply2 = MdnsReplyInfo(
+            emptyList(),
+            emptyList(),
+            0L,
+            InetSocketAddress(0),
+            src,
+            emptyList()
+        )
         doReturn(testReply).`when`(repository).getReply(
                 argThat { pkg -> pkg.questions.size != 0 && pkg.answers.size == 0 &&
                         (pkg.flags and MdnsConstants.FLAG_TRUNCATED) != 0},
-                eq(src))
+                eq(src)
+        )
         doReturn(knownAnswersReply).`when`(repository).getReply(
                 argThat { pkg -> pkg.questions.size == 0 && pkg.answers.size != 0 &&
                         (pkg.flags and MdnsConstants.FLAG_TRUNCATED) != 0},
-                eq(src))
+                eq(src)
+        )
         doReturn(knownAnswersReply2).`when`(repository).getReply(
                 argThat { pkg -> pkg.questions.size == 0 && pkg.answers.size != 0 &&
                         (pkg.flags and MdnsConstants.FLAG_TRUNCATED) == 0},
-                eq(src))
+                eq(src)
+        )
 
         // Query obtained with:
         // scapy.raw(scapy.DNS(
@@ -452,8 +494,10 @@ class MdnsInterfaceAdvertiserTest {
         //    qd = None,
         //    an = scapy.DNSRR(type='TXT', rrname='_testservice._tcp.local'))
         // ).hex().upper()
-        val query = HexDump.hexStringToByteArray("0000010000000001000000000C5F7465737473657276696" +
-                "365045F746370056C6F63616C0000100001000000000000")
+        val query = HexDump.hexStringToByteArray(
+            "0000010000000001000000000C5F7465737473657276696" +
+                "365045F746370056C6F63616C0000100001000000000000"
+        )
         val src = InetSocketAddress(parseNumericAddress("2001:db8::456"), MdnsConstants.MDNS_PORT)
         packetHandler.handlePacket(query, query.size, src)
 
@@ -488,7 +532,9 @@ class MdnsInterfaceAdvertiserTest {
     fun testRenameServiceForConflict() {
         val mockProbingInfo = mock(ProbingInfo::class.java)
         doReturn(mockProbingInfo).`when`(repository).renameServiceForConflict(
-                TEST_SERVICE_ID_1, TEST_SERVICE_1)
+            TEST_SERVICE_ID_1,
+            TEST_SERVICE_1
+        )
 
         advertiser.renameServiceForConflict(TEST_SERVICE_ID_1, TEST_SERVICE_1)
 
@@ -499,13 +545,34 @@ class MdnsInterfaceAdvertiserTest {
     fun testReplaceExitingService() {
         doReturn(TEST_SERVICE_ID_DUPLICATE).`when`(repository)
                 .addService(eq(TEST_SERVICE_ID_DUPLICATE), any(), any())
-        advertiser.addService(TEST_SERVICE_ID_DUPLICATE, TEST_SERVICE_1_SUBTYPE,
-                MdnsAdvertisingOptions.getDefaultOptions())
+        advertiser.addService(
+            TEST_SERVICE_ID_DUPLICATE,
+            TEST_SERVICE_1_SUBTYPE,
+            MdnsAdvertisingOptions.getDefaultOptions()
+        )
         verify(repository).addService(eq(TEST_SERVICE_ID_DUPLICATE), any(), any())
         verify(announcer).stop(TEST_SERVICE_ID_DUPLICATE)
         verify(prober).startProbing(any())
     }
 
+    @Test
+    fun testOffloadOnlyWillSkipProbing() {
+        val testProbingInfo = mock(ProbingInfo::class.java)
+        doReturn(TEST_SERVICE_ID_1).`when`(repository)
+            .addService(eq(TEST_SERVICE_ID_1), any(), any())
+        doReturn(TEST_SERVICE_ID_1).`when`(testProbingInfo).serviceId
+        doReturn(testProbingInfo).`when`(repository).setServiceProbing(TEST_SERVICE_ID_1)
+        advertiser.addService(
+            TEST_SERVICE_ID_1,
+            TEST_SERVICE_1_SUBTYPE,
+            MdnsAdvertisingOptions.newBuilder().setOffloadOnly(true).build()
+        )
+        verify(repository).addService(eq(TEST_SERVICE_ID_1), any(), any())
+        thread.waitForIdle(TIMEOUT_MS)
+        verify(prober, never()).startProbing(any())
+        verify(cb).onServiceProbingSucceeded(advertiser, TEST_SERVICE_ID_1)
+    }
+
     @Test
     fun testUpdateExistingService() {
         doReturn(TEST_SERVICE_ID_DUPLICATE).`when`(repository)
@@ -517,14 +584,20 @@ class MdnsInterfaceAdvertiserTest {
         verify(prober, never()).startProbing(any())
     }
 
-    private fun addServiceAndStartProbing(serviceId: Int, serviceInfo: NsdServiceInfo):
-            ProbingInfo {
+    private fun addServiceAndStartProbing(
+        serviceId: Int,
+        serviceInfo: NsdServiceInfo
+    ): ProbingInfo {
         val testProbingInfo = mock(ProbingInfo::class.java)
         doReturn(serviceId).`when`(testProbingInfo).serviceId
         doReturn(testProbingInfo).`when`(repository).setServiceProbing(serviceId)
 
         advertiser.addService(serviceId, serviceInfo, MdnsAdvertisingOptions.getDefaultOptions())
-        verify(repository).addService(serviceId, serviceInfo, null /* ttl */)
+        verify(repository).addService(
+            serviceId,
+            serviceInfo,
+            MdnsAdvertisingOptions.newBuilder().build()
+        )
         verify(prober).startProbing(testProbingInfo)
 
         return testProbingInfo
diff --git a/tests/unit/java/com/android/server/connectivity/mdns/MdnsPacketReaderTests.java b/tests/unit/java/com/android/server/connectivity/mdns/MdnsPacketReaderTests.java
index 0168b61009..ee141d30ca 100644
--- a/tests/unit/java/com/android/server/connectivity/mdns/MdnsPacketReaderTests.java
+++ b/tests/unit/java/com/android/server/connectivity/mdns/MdnsPacketReaderTests.java
@@ -16,12 +16,12 @@
 
 package com.android.server.connectivity.mdns;
 
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.fail;
 
+import android.os.Build;
+
 import com.android.net.module.util.HexDump;
 import com.android.testutils.DevSdkIgnoreRule;
 import com.android.testutils.DevSdkIgnoreRunner;
@@ -34,7 +34,7 @@ import java.net.DatagramPacket;
 import java.util.Locale;
 
 @RunWith(DevSdkIgnoreRunner.class)
-@DevSdkIgnoreRule.IgnoreUpTo(SC_V2)
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 public class MdnsPacketReaderTests {
 
     @Test
diff --git a/tests/unit/java/com/android/server/connectivity/mdns/MdnsRecordRepositoryTest.kt b/tests/unit/java/com/android/server/connectivity/mdns/MdnsRecordRepositoryTest.kt
index 9674da36a0..7e37a9b1c0 100644
--- a/tests/unit/java/com/android/server/connectivity/mdns/MdnsRecordRepositoryTest.kt
+++ b/tests/unit/java/com/android/server/connectivity/mdns/MdnsRecordRepositoryTest.kt
@@ -21,6 +21,7 @@ import android.net.LinkAddress
 import android.net.nsd.NsdServiceInfo
 import android.os.Build
 import android.os.HandlerThread
+import android.system.OsConstants
 import com.android.net.module.util.HexDump.hexStringToByteArray
 import com.android.server.connectivity.mdns.MdnsAnnouncer.AnnouncementInfo
 import com.android.server.connectivity.mdns.MdnsInterfaceAdvertiser.CONFLICT_HOST
@@ -39,8 +40,8 @@ import com.android.testutils.DevSdkIgnoreRunner
 import com.google.common.truth.Truth.assertThat
 import java.net.InetSocketAddress
 import java.net.NetworkInterface
-import java.util.Collections
 import java.time.Duration
+import java.util.Collections
 import kotlin.test.assertContentEquals
 import kotlin.test.assertEquals
 import kotlin.test.assertFailsWith
@@ -63,6 +64,7 @@ private const val TEST_SERVICE_CUSTOM_HOST_ID_1 = 48
 private const val TEST_PORT = 12345
 private const val TEST_SUBTYPE = "_subtype"
 private const val TEST_SUBTYPE2 = "_subtype2"
+
 // RFC6762 10. Resource Record TTL Values and Cache Coherency
 // The recommended TTL value for Multicast DNS resource records with a host name as the resource
 // record's name (e.g., A, AAAA, HINFO) or a host name contained within the resource record's rdata
@@ -74,7 +76,20 @@ private val TEST_HOSTNAME = arrayOf("Android_000102030405060708090A0B0C0D0E0F",
 private val TEST_ADDRESSES = listOf(
         LinkAddress(parseNumericAddress("192.0.2.111"), 24),
         LinkAddress(parseNumericAddress("2001:db8::111"), 64),
-        LinkAddress(parseNumericAddress("2001:db8::222"), 64))
+        LinkAddress(parseNumericAddress("2001:db8::222"), 64)
+)
+private val TEST_TEMPORARY_IPV6_ADDRESS = LinkAddress(
+    parseNumericAddress("2001:db8::333"),
+    64,
+    OsConstants.IFA_F_TEMPORARY /* flags */,
+    0 /* lifetime */
+)
+
+private val GOOGLECAST_SERVICE = NsdServiceInfo().apply {
+    serviceType = "_googlecast._tcp"
+    serviceName = "MyTestService"
+    port = TEST_PORT
+}
 
 private val TEST_SERVICE_1 = NsdServiceInfo().apply {
     serviceType = "_testservice._tcp"
@@ -127,14 +142,18 @@ private val TEST_PUBLIC_KEY = hexStringToByteArray(
                 "221d2879dac26ee5b460e9007c992e19" +
                 "02d897c391b03764d448f7d0c772fdb0" +
                 "3b1d9d6d52ff8886769e8e2362513565" +
-                "270962d3")
+                "270962d3"
+)
 
 private val TEST_PUBLIC_KEY_2 = hexStringToByteArray(
         "0201030dc141d0637960b98cbc12cfca" +
                 "221d2879dac26ee5b460e9007c992e19" +
                 "02d897c391b03764d448f7d0c772fdb0" +
                 "3b1d9d6d52ff8886769e8e2362513565" +
-                "270962d4")
+                "270962d4"
+)
+
+private val DEFAULT_OPTION = MdnsAdvertisingOptions.newBuilder().build()
 
 @RunWith(DevSdkIgnoreRunner::class)
 @DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
@@ -184,9 +203,14 @@ class MdnsRecordRepositoryTest {
     @Test
     fun testAddServiceAndProbe() {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
+        val option = MdnsAdvertisingOptions.newBuilder()
+            .setTtl(Duration.ofSeconds(50))
+            .build()
         assertEquals(0, repository.servicesCount)
-        assertEquals(-1,
-                repository.addService(TEST_SERVICE_ID_1, TEST_SERVICE_1, Duration.ofSeconds(50)))
+        assertEquals(
+            -1,
+            repository.addService(TEST_SERVICE_ID_1, TEST_SERVICE_1, option)
+        )
         assertEquals(1, repository.servicesCount)
 
         val probingInfo = repository.setServiceProbing(TEST_SERVICE_ID_1)
@@ -206,12 +230,16 @@ class MdnsRecordRepositoryTest {
         assertEquals(MdnsAnyRecord(expectedName, false /* unicast */), packet.questions[0])
 
         assertEquals(1, packet.authorityRecords.size)
-        assertEquals(MdnsServiceRecord(expectedName,
-                0L /* receiptTimeMillis */,
-                false /* cacheFlush */,
-                50_000L /* ttlMillis */,
-                0 /* servicePriority */, 0 /* serviceWeight */,
-                TEST_PORT, TEST_HOSTNAME), packet.authorityRecords[0])
+        assertEquals(MdnsServiceRecord(
+            expectedName,
+            0L /* receiptTimeMillis */,
+            false /* cacheFlush */,
+            50_000L /* ttlMillis */,
+            0 /* servicePriority */,
+            0 /* serviceWeight */,
+            TEST_PORT,
+            TEST_HOSTNAME
+        ), packet.authorityRecords[0])
 
         assertContentEquals(intArrayOf(TEST_SERVICE_ID_1), repository.clearServices())
     }
@@ -221,10 +249,10 @@ class MdnsRecordRepositoryTest {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
         repository.initWithService(TEST_SERVICE_ID_1, TEST_SERVICE_1)
         assertFailsWith(NameConflictException::class) {
-            repository.addService(TEST_SERVICE_ID_2, TEST_SERVICE_1, null /* ttl */)
+            repository.addService(TEST_SERVICE_ID_2, TEST_SERVICE_1, DEFAULT_OPTION)
         }
         assertFailsWith(NameConflictException::class) {
-            repository.addService(TEST_SERVICE_ID_3, TEST_SERVICE_3, null /* ttl */)
+            repository.addService(TEST_SERVICE_ID_3, TEST_SERVICE_3, DEFAULT_OPTION)
         }
     }
 
@@ -241,8 +269,13 @@ class MdnsRecordRepositoryTest {
 
         val queriedName = arrayOf(TEST_SUBTYPE, "_sub", "_testservice", "_tcp", "local")
         val questions = listOf(MdnsPointerRecord(queriedName, false /* isUnicast */))
-        val query = MdnsPacket(0 /* flags */, questions, emptyList() /* answers */,
-                emptyList() /* authorityRecords */, emptyList() /* additionalRecords */)
+        val query = MdnsPacket(
+            0 /* flags */,
+            questions,
+            emptyList() /* answers */,
+            emptyList() /* authorityRecords */,
+            emptyList() /* additionalRecords */
+        )
         val src = InetSocketAddress(parseNumericAddress("192.0.2.123"), 5353)
         val reply = repository.getReply(query, src)
 
@@ -258,16 +291,54 @@ class MdnsRecordRepositoryTest {
                         0L /* receiptTimeMillis */,
                         false /* cacheFlush */,
                         longTtl,
-                        serviceName),
+                        serviceName
+                ),
         ), reply.answers)
     }
 
+    @Test
+    fun testGetReplyReturnsNullForOffloadOnlyService() {
+        val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
+        repository.initWithService(
+            TEST_SERVICE_ID_1,
+            TEST_SERVICE_1,
+            option = MdnsAdvertisingOptions.newBuilder().setOffloadOnly(true).build()
+        )
+
+        val queriedName = arrayOf(TEST_SUBTYPE, "_sub", "_testservice", "_tcp", "local")
+        val questions = listOf(MdnsPointerRecord(queriedName, false /* isUnicast */))
+        val query = MdnsPacket(
+            0 /* flags */,
+            questions,
+            emptyList() /* answers */,
+            emptyList() /* authorityRecords */,
+            emptyList() /* additionalRecords */
+        )
+        val src = InetSocketAddress(parseNumericAddress("192.0.2.123"), 5353)
+        val reply = repository.getReply(query, src)
+
+        assertNull(reply)
+    }
+
+    @Test
+    fun testExitServiceReturnNullForOffloadOnlyService() {
+        val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
+        repository.initWithService(
+            TEST_SERVICE_ID_1,
+            TEST_SERVICE_1,
+            option = MdnsAdvertisingOptions.newBuilder().setOffloadOnly(true).build()
+        )
+        repository.onAdvertisementSent(TEST_SERVICE_ID_1, 2 /* sentPacketCount */)
+        val reply = repository.exitService(TEST_SERVICE_ID_1)
+        assertNull(reply)
+    }
+
     @Test
     fun testInvalidReuseOfServiceId() {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
-        repository.addService(TEST_SERVICE_ID_1, TEST_SERVICE_1, null /* ttl */)
+        repository.addService(TEST_SERVICE_ID_1, TEST_SERVICE_1, DEFAULT_OPTION)
         assertFailsWith(IllegalArgumentException::class) {
-            repository.addService(TEST_SERVICE_ID_1, TEST_SERVICE_2, null /* ttl */)
+            repository.addService(TEST_SERVICE_ID_1, TEST_SERVICE_2, DEFAULT_OPTION)
         }
     }
 
@@ -276,7 +347,7 @@ class MdnsRecordRepositoryTest {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
         assertFalse(repository.hasActiveService(TEST_SERVICE_ID_1))
 
-        repository.addService(TEST_SERVICE_ID_1, TEST_SERVICE_1, null /* ttl */)
+        repository.addService(TEST_SERVICE_ID_1, TEST_SERVICE_1, DEFAULT_OPTION)
         assertTrue(repository.hasActiveService(TEST_SERVICE_ID_1))
 
         val probingInfo = repository.setServiceProbing(TEST_SERVICE_ID_1)
@@ -311,7 +382,8 @@ class MdnsRecordRepositoryTest {
                         0L /* receiptTimeMillis */,
                         false /* cacheFlush */,
                         0L /* ttlMillis */,
-                        arrayOf("MyTestService", "_testservice", "_tcp", "local"))
+                        arrayOf("MyTestService", "_testservice", "_tcp", "local")
+                )
         ), packet.answers)
 
         repository.removeService(TEST_SERVICE_ID_1)
@@ -321,8 +393,11 @@ class MdnsRecordRepositoryTest {
     @Test
     fun testExitAnnouncements_WithSubtypes() {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
-        repository.initWithService(TEST_SERVICE_ID_1, TEST_SERVICE_1,
-                setOf(TEST_SUBTYPE, TEST_SUBTYPE2))
+        repository.initWithService(
+            TEST_SERVICE_ID_1,
+            TEST_SERVICE_1,
+            setOf(TEST_SUBTYPE, TEST_SUBTYPE2)
+        )
         repository.onAdvertisementSent(TEST_SERVICE_ID_1, 2 /* sentPacketCount */)
 
         val exitAnnouncement = repository.exitService(TEST_SERVICE_ID_1)
@@ -342,24 +417,280 @@ class MdnsRecordRepositoryTest {
                         0L /* receiptTimeMillis */,
                         false /* cacheFlush */,
                         0L /* ttlMillis */,
-                        arrayOf("MyTestService", "_testservice", "_tcp", "local")),
+                        arrayOf("MyTestService", "_testservice", "_tcp", "local")
+                ),
                 MdnsPointerRecord(
                         arrayOf("_subtype", "_sub", "_testservice", "_tcp", "local"),
                         0L /* receiptTimeMillis */,
                         false /* cacheFlush */,
                         0L /* ttlMillis */,
-                        arrayOf("MyTestService", "_testservice", "_tcp", "local")),
+                        arrayOf("MyTestService", "_testservice", "_tcp", "local")
+                ),
                 MdnsPointerRecord(
                         arrayOf("_subtype2", "_sub", "_testservice", "_tcp", "local"),
                         0L /* receiptTimeMillis */,
                         false /* cacheFlush */,
                         0L /* ttlMillis */,
-                        arrayOf("MyTestService", "_testservice", "_tcp", "local")))
+                        arrayOf("MyTestService", "_testservice", "_tcp", "local")
+                )
+        )
 
         repository.removeService(TEST_SERVICE_ID_1)
         assertEquals(0, repository.servicesCount)
     }
 
+    @Test
+    fun testAnnouncementsWithOutSubtypes() {
+        val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
+        val option = MdnsAdvertisingOptions.newBuilder().setSkipSubtypeAnnouncements(true).build()
+        val announcementInfo = repository.initWithService(
+            TEST_SERVICE_ID_1,
+            GOOGLECAST_SERVICE,
+            setOf(TEST_SUBTYPE, TEST_SUBTYPE2),
+            option = option
+        )
+        repository.onAdvertisementSent(TEST_SERVICE_ID_1, 2 /* sentPacketCount */)
+        val packet = announcementInfo.getPacket(0)
+
+        assertEquals(0, packet.transactionId)
+        assertEquals(0x8400 /* response, authoritative */, packet.flags)
+        assertEquals(0, packet.questions.size)
+        assertEquals(0, packet.authorityRecords.size)
+
+        val serviceType = arrayOf("_googlecast", "_tcp", "local")
+        val serviceName = arrayOf("MyTestService", "_googlecast", "_tcp", "local")
+        val v4AddrRev = getReverseDnsAddress(TEST_ADDRESSES[0].address)
+        val v6Addr1Rev = getReverseDnsAddress(TEST_ADDRESSES[1].address)
+        val v6Addr2Rev = getReverseDnsAddress(TEST_ADDRESSES[2].address)
+
+        assertThat(packet.answers).containsExactly(
+            // Reverse address and address records for the hostname
+            MdnsPointerRecord(
+                v4AddrRev,
+                0L /* receiptTimeMillis */,
+                true /* cacheFlush */,
+                120000L /* ttlMillis */,
+                TEST_HOSTNAME
+            ),
+            MdnsInetAddressRecord(
+                TEST_HOSTNAME,
+                0L /* receiptTimeMillis */,
+                true /* cacheFlush */,
+                120000L /* ttlMillis */,
+                TEST_ADDRESSES[0].address
+            ),
+            MdnsPointerRecord(
+                v6Addr1Rev,
+                0L /* receiptTimeMillis */,
+                true /* cacheFlush */,
+                120000L /* ttlMillis */,
+                TEST_HOSTNAME
+            ),
+            MdnsInetAddressRecord(
+                TEST_HOSTNAME,
+                0L /* receiptTimeMillis */,
+                true /* cacheFlush */,
+                120000L /* ttlMillis */,
+                TEST_ADDRESSES[1].address
+            ),
+            MdnsPointerRecord(
+                v6Addr2Rev,
+                0L /* receiptTimeMillis */,
+                true /* cacheFlush */,
+                120000L /* ttlMillis */,
+                TEST_HOSTNAME
+            ),
+            MdnsInetAddressRecord(
+                TEST_HOSTNAME,
+                0L /* receiptTimeMillis */,
+                true /* cacheFlush */,
+                120000L /* ttlMillis */,
+                TEST_ADDRESSES[2].address
+            ),
+            // Service registration records (RFC6763)
+            MdnsPointerRecord(
+                serviceType,
+                0L /* receiptTimeMillis */,
+                // Not a unique name owned by the announcer, so cacheFlush=false
+                false /* cacheFlush */,
+                4500000L /* ttlMillis */,
+                serviceName
+            ),
+            MdnsServiceRecord(
+                serviceName,
+                0L /* receiptTimeMillis */,
+                true /* cacheFlush */,
+                120000L /* ttlMillis */,
+                0 /* servicePriority */,
+                0 /* serviceWeight */,
+                TEST_PORT /* servicePort */,
+                TEST_HOSTNAME
+            ),
+            MdnsTextRecord(
+                serviceName,
+                0L /* receiptTimeMillis */,
+                true /* cacheFlush */,
+                4500000L /* ttlMillis */,
+                emptyList() /* entries */
+            ),
+            // Service type enumeration record (RFC6763 9.)
+            MdnsPointerRecord(
+                arrayOf("_services", "_dns-sd", "_udp", "local"),
+                0L /* receiptTimeMillis */,
+                false /* cacheFlush */,
+                4500000L /* ttlMillis */,
+                serviceType
+            ))
+
+        assertContentEquals(listOf(
+            MdnsNsecRecord(
+                v4AddrRev,
+                0L /* receiptTimeMillis */,
+                true /* cacheFlush */,
+                120000L /* ttlMillis */,
+                v4AddrRev,
+                intArrayOf(TYPE_PTR)
+            ),
+            MdnsNsecRecord(
+                TEST_HOSTNAME,
+                0L /* receiptTimeMillis */,
+                true /* cacheFlush */,
+                120000L /* ttlMillis */,
+                TEST_HOSTNAME,
+                intArrayOf(TYPE_A, TYPE_AAAA)
+            ),
+            MdnsNsecRecord(
+                v6Addr1Rev,
+                0L /* receiptTimeMillis */,
+                true /* cacheFlush */,
+                120000L /* ttlMillis */,
+                v6Addr1Rev,
+                intArrayOf(TYPE_PTR)
+            ),
+            MdnsNsecRecord(
+                v6Addr2Rev,
+                0L /* receiptTimeMillis */,
+                true /* cacheFlush */,
+                120000L /* ttlMillis */,
+                v6Addr2Rev,
+                intArrayOf(TYPE_PTR)
+            ),
+            MdnsNsecRecord(
+                serviceName,
+                0L /* receiptTimeMillis */,
+                true /* cacheFlush */,
+                4500000L /* ttlMillis */,
+                serviceName,
+                intArrayOf(TYPE_TXT, TYPE_SRV)
+            )
+        ), packet.additionalRecords)
+    }
+
+    @Test
+    fun testExitAnnouncementsWithOutSubtypes() {
+        val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
+        val option = MdnsAdvertisingOptions.newBuilder().setSkipSubtypeAnnouncements(true).build()
+        repository.initWithService(
+            TEST_SERVICE_ID_1,
+            TEST_SERVICE_1,
+            setOf(TEST_SUBTYPE, TEST_SUBTYPE2),
+            option = option
+        )
+        repository.onAdvertisementSent(TEST_SERVICE_ID_1, 2 /* sentPacketCount */)
+
+        val exitAnnouncement = repository.exitService(TEST_SERVICE_ID_1)
+        assertNotNull(exitAnnouncement)
+        assertEquals(1, repository.servicesCount)
+        val packet = exitAnnouncement.getPacket(0)
+
+        assertEquals(0, packet.transactionId)
+        assertEquals(0x8400 /* response, authoritative */, packet.flags)
+        assertEquals(0, packet.questions.size)
+        assertEquals(0, packet.authorityRecords.size)
+        assertEquals(0, packet.additionalRecords.size)
+
+        assertThat(packet.answers).containsExactly(
+            MdnsPointerRecord(
+                arrayOf("_testservice", "_tcp", "local"),
+                0L /* receiptTimeMillis */,
+                false /* cacheFlush */,
+                0L /* ttlMillis */,
+                arrayOf("MyTestService", "_testservice", "_tcp", "local")
+            ),
+        )
+    }
+
+    @Test
+    fun testGetOffloadPacketWithoutSubtype() {
+        val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
+        val ipAddress = TEST_ADDRESSES.toMutableList()
+        ipAddress.add(TEST_TEMPORARY_IPV6_ADDRESS)
+        val option = MdnsAdvertisingOptions.newBuilder().setSkipSubtypeAnnouncements(true).build()
+        repository.initWithService(
+            TEST_SERVICE_ID_1,
+            GOOGLECAST_SERVICE,
+            setOf(TEST_SUBTYPE, TEST_SUBTYPE2),
+            addresses = ipAddress,
+            option = option
+        )
+        val serviceName = arrayOf("MyTestService", "_googlecast", "_tcp", "local")
+        val serviceType = arrayOf("_googlecast", "_tcp", "local")
+        val offloadPacket = repository.getOffloadPacket(TEST_SERVICE_ID_1)
+        assertEquals(0, offloadPacket.transactionId)
+        assertEquals(0x8400, offloadPacket.flags)
+        assertEquals(0, offloadPacket.questions.size)
+        assertEquals(0, offloadPacket.additionalRecords.size)
+        assertEquals(0, offloadPacket.authorityRecords.size)
+        assertContentEquals(listOf(
+            MdnsPointerRecord(
+                serviceType,
+                0L /* receiptTimeMillis */,
+                // Not a unique name owned by the announcer, so cacheFlush=false
+                false /* cacheFlush */,
+                4500000L /* ttlMillis */,
+                serviceName
+            ),
+            MdnsServiceRecord(
+                serviceName,
+                0L /* receiptTimeMillis */,
+                true /* cacheFlush */,
+                120000L /* ttlMillis */,
+                0 /* servicePriority */,
+                0 /* serviceWeight */,
+                TEST_PORT /* servicePort */,
+                TEST_HOSTNAME
+            ),
+            MdnsTextRecord(
+                serviceName,
+                0L /* receiptTimeMillis */,
+                true /* cacheFlush */,
+                4500000L /* ttlMillis */,
+                emptyList() /* entries */
+            ),
+            MdnsInetAddressRecord(
+                TEST_HOSTNAME,
+                0L /* receiptTimeMillis */,
+                true /* cacheFlush */,
+                120000L /* ttlMillis */,
+                TEST_ADDRESSES[0].address
+            ),
+            MdnsInetAddressRecord(
+                TEST_HOSTNAME,
+                0L /* receiptTimeMillis */,
+                true /* cacheFlush */,
+                120000L /* ttlMillis */,
+                TEST_ADDRESSES[1].address
+            ),
+            MdnsInetAddressRecord(
+                TEST_HOSTNAME,
+                0L /* receiptTimeMillis */,
+                true /* cacheFlush */,
+                120000L /* ttlMillis */,
+                TEST_ADDRESSES[2].address
+            ),
+        ), offloadPacket.answers)
+    }
+
     @Test
     fun testExitingServiceReAdded() {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
@@ -367,8 +698,10 @@ class MdnsRecordRepositoryTest {
         repository.onAdvertisementSent(TEST_SERVICE_ID_1, 2 /* sentPacketCount */)
         repository.exitService(TEST_SERVICE_ID_1)
 
-        assertEquals(TEST_SERVICE_ID_1,
-                repository.addService(TEST_SERVICE_ID_2, TEST_SERVICE_1, null /* ttl */))
+        assertEquals(
+            TEST_SERVICE_ID_1,
+            repository.addService(TEST_SERVICE_ID_2, TEST_SERVICE_1, DEFAULT_OPTION)
+        )
         assertEquals(1, repository.servicesCount)
 
         repository.removeService(TEST_SERVICE_ID_2)
@@ -378,8 +711,11 @@ class MdnsRecordRepositoryTest {
     @Test
     fun testOnProbingSucceeded() {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
-        val announcementInfo = repository.initWithService(TEST_SERVICE_ID_1, TEST_SERVICE_1,
-                setOf(TEST_SUBTYPE, TEST_SUBTYPE2))
+        val announcementInfo = repository.initWithService(
+            TEST_SERVICE_ID_1,
+            TEST_SERVICE_1,
+            setOf(TEST_SUBTYPE, TEST_SUBTYPE2)
+        )
         repository.onAdvertisementSent(TEST_SERVICE_ID_1, 2 /* sentPacketCount */)
         val packet = announcementInfo.getPacket(0)
 
@@ -398,36 +734,48 @@ class MdnsRecordRepositoryTest {
 
         assertThat(packet.answers).containsExactly(
                 // Reverse address and address records for the hostname
-                MdnsPointerRecord(v4AddrRev,
-                        0L /* receiptTimeMillis */,
-                        true /* cacheFlush */,
-                        120000L /* ttlMillis */,
-                        TEST_HOSTNAME),
-                MdnsInetAddressRecord(TEST_HOSTNAME,
-                        0L /* receiptTimeMillis */,
-                        true /* cacheFlush */,
-                        120000L /* ttlMillis */,
-                        TEST_ADDRESSES[0].address),
-                MdnsPointerRecord(v6Addr1Rev,
-                        0L /* receiptTimeMillis */,
-                        true /* cacheFlush */,
-                        120000L /* ttlMillis */,
-                        TEST_HOSTNAME),
-                MdnsInetAddressRecord(TEST_HOSTNAME,
-                        0L /* receiptTimeMillis */,
-                        true /* cacheFlush */,
-                        120000L /* ttlMillis */,
-                        TEST_ADDRESSES[1].address),
-                MdnsPointerRecord(v6Addr2Rev,
-                        0L /* receiptTimeMillis */,
-                        true /* cacheFlush */,
-                        120000L /* ttlMillis */,
-                        TEST_HOSTNAME),
-                MdnsInetAddressRecord(TEST_HOSTNAME,
-                        0L /* receiptTimeMillis */,
-                        true /* cacheFlush */,
-                        120000L /* ttlMillis */,
-                        TEST_ADDRESSES[2].address),
+                MdnsPointerRecord(
+                    v4AddrRev,
+                    0L /* receiptTimeMillis */,
+                    true /* cacheFlush */,
+                    120000L /* ttlMillis */,
+                    TEST_HOSTNAME
+                ),
+                MdnsInetAddressRecord(
+                    TEST_HOSTNAME,
+                    0L /* receiptTimeMillis */,
+                    true /* cacheFlush */,
+                    120000L /* ttlMillis */,
+                    TEST_ADDRESSES[0].address
+                ),
+                MdnsPointerRecord(
+                    v6Addr1Rev,
+                    0L /* receiptTimeMillis */,
+                    true /* cacheFlush */,
+                    120000L /* ttlMillis */,
+                    TEST_HOSTNAME
+                ),
+                MdnsInetAddressRecord(
+                    TEST_HOSTNAME,
+                    0L /* receiptTimeMillis */,
+                    true /* cacheFlush */,
+                    120000L /* ttlMillis */,
+                    TEST_ADDRESSES[1].address
+                ),
+                MdnsPointerRecord(
+                    v6Addr2Rev,
+                    0L /* receiptTimeMillis */,
+                    true /* cacheFlush */,
+                    120000L /* ttlMillis */,
+                    TEST_HOSTNAME
+                ),
+                MdnsInetAddressRecord(
+                    TEST_HOSTNAME,
+                    0L /* receiptTimeMillis */,
+                    true /* cacheFlush */,
+                    120000L /* ttlMillis */,
+                    TEST_ADDRESSES[2].address
+                ),
                 // Service registration records (RFC6763)
                 MdnsPointerRecord(
                         serviceType,
@@ -435,21 +783,24 @@ class MdnsRecordRepositoryTest {
                         // Not a unique name owned by the announcer, so cacheFlush=false
                         false /* cacheFlush */,
                         4500000L /* ttlMillis */,
-                        serviceName),
+                        serviceName
+                ),
                 MdnsPointerRecord(
                         serviceSubtype,
                         0L /* receiptTimeMillis */,
                         // Not a unique name owned by the announcer, so cacheFlush=false
                         false /* cacheFlush */,
                         4500000L /* ttlMillis */,
-                        serviceName),
+                        serviceName
+                ),
                 MdnsPointerRecord(
                         serviceSubtype2,
                         0L /* receiptTimeMillis */,
                         // Not a unique name owned by the announcer, so cacheFlush=false
                         false /* cacheFlush */,
                         4500000L /* ttlMillis */,
-                        serviceName),
+                        serviceName
+                ),
                 MdnsServiceRecord(
                         serviceName,
                         0L /* receiptTimeMillis */,
@@ -458,59 +809,78 @@ class MdnsRecordRepositoryTest {
                         0 /* servicePriority */,
                         0 /* serviceWeight */,
                         TEST_PORT /* servicePort */,
-                        TEST_HOSTNAME),
+                        TEST_HOSTNAME
+                ),
                 MdnsTextRecord(
                         serviceName,
                         0L /* receiptTimeMillis */,
                         true /* cacheFlush */,
                         4500000L /* ttlMillis */,
-                        emptyList() /* entries */),
+                        emptyList() /* entries */
+                ),
                 // Service type enumeration record (RFC6763 9.)
                 MdnsPointerRecord(
                         arrayOf("_services", "_dns-sd", "_udp", "local"),
                         0L /* receiptTimeMillis */,
                         false /* cacheFlush */,
                         4500000L /* ttlMillis */,
-                        serviceType))
+                        serviceType
+                ))
 
         assertContentEquals(listOf(
-                MdnsNsecRecord(v4AddrRev,
-                        0L /* receiptTimeMillis */,
-                        true /* cacheFlush */,
-                        120000L /* ttlMillis */,
-                        v4AddrRev,
-                        intArrayOf(TYPE_PTR)),
-                MdnsNsecRecord(TEST_HOSTNAME,
-                        0L /* receiptTimeMillis */,
-                        true /* cacheFlush */,
-                        120000L /* ttlMillis */,
-                        TEST_HOSTNAME,
-                        intArrayOf(TYPE_A, TYPE_AAAA)),
-                MdnsNsecRecord(v6Addr1Rev,
-                        0L /* receiptTimeMillis */,
-                        true /* cacheFlush */,
-                        120000L /* ttlMillis */,
-                        v6Addr1Rev,
-                        intArrayOf(TYPE_PTR)),
-                MdnsNsecRecord(v6Addr2Rev,
-                        0L /* receiptTimeMillis */,
-                        true /* cacheFlush */,
-                        120000L /* ttlMillis */,
-                        v6Addr2Rev,
-                        intArrayOf(TYPE_PTR)),
-                MdnsNsecRecord(serviceName,
-                        0L /* receiptTimeMillis */,
-                        true /* cacheFlush */,
-                        4500000L /* ttlMillis */,
-                        serviceName,
-                        intArrayOf(TYPE_TXT, TYPE_SRV))
+                MdnsNsecRecord(
+                    v4AddrRev,
+                    0L /* receiptTimeMillis */,
+                    true /* cacheFlush */,
+                    120000L /* ttlMillis */,
+                    v4AddrRev,
+                    intArrayOf(TYPE_PTR)
+                ),
+                MdnsNsecRecord(
+                    TEST_HOSTNAME,
+                    0L /* receiptTimeMillis */,
+                    true /* cacheFlush */,
+                    120000L /* ttlMillis */,
+                    TEST_HOSTNAME,
+                    intArrayOf(TYPE_A, TYPE_AAAA)
+                ),
+                MdnsNsecRecord(
+                    v6Addr1Rev,
+                    0L /* receiptTimeMillis */,
+                    true /* cacheFlush */,
+                    120000L /* ttlMillis */,
+                    v6Addr1Rev,
+                    intArrayOf(TYPE_PTR)
+                ),
+                MdnsNsecRecord(
+                    v6Addr2Rev,
+                    0L /* receiptTimeMillis */,
+                    true /* cacheFlush */,
+                    120000L /* ttlMillis */,
+                    v6Addr2Rev,
+                    intArrayOf(TYPE_PTR)
+                ),
+                MdnsNsecRecord(
+                    serviceName,
+                    0L /* receiptTimeMillis */,
+                    true /* cacheFlush */,
+                    4500000L /* ttlMillis */,
+                    serviceName,
+                    intArrayOf(TYPE_TXT, TYPE_SRV)
+                )
         ), packet.additionalRecords)
     }
 
     @Test
     fun testGetOffloadPacket() {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
-        repository.initWithService(TEST_SERVICE_ID_1, TEST_SERVICE_1)
+        val ipAddress = TEST_ADDRESSES.toMutableList()
+        ipAddress.add(TEST_TEMPORARY_IPV6_ADDRESS)
+        repository.initWithService(
+            TEST_SERVICE_ID_1,
+            TEST_SERVICE_1,
+            addresses = ipAddress
+        )
         val serviceName = arrayOf("MyTestService", "_testservice", "_tcp", "local")
         val serviceType = arrayOf("_testservice", "_tcp", "local")
         val offloadPacket = repository.getOffloadPacket(TEST_SERVICE_ID_1)
@@ -526,7 +896,8 @@ class MdnsRecordRepositoryTest {
                 // Not a unique name owned by the announcer, so cacheFlush=false
                 false /* cacheFlush */,
                 4500000L /* ttlMillis */,
-                serviceName),
+                serviceName
+            ),
             MdnsServiceRecord(
                 serviceName,
                 0L /* receiptTimeMillis */,
@@ -535,28 +906,36 @@ class MdnsRecordRepositoryTest {
                 0 /* servicePriority */,
                 0 /* serviceWeight */,
                 TEST_PORT /* servicePort */,
-                TEST_HOSTNAME),
+                TEST_HOSTNAME
+            ),
             MdnsTextRecord(
                 serviceName,
                 0L /* receiptTimeMillis */,
                 true /* cacheFlush */,
                 4500000L /* ttlMillis */,
-                emptyList() /* entries */),
-            MdnsInetAddressRecord(TEST_HOSTNAME,
+                emptyList() /* entries */
+            ),
+            MdnsInetAddressRecord(
+                TEST_HOSTNAME,
                 0L /* receiptTimeMillis */,
                 true /* cacheFlush */,
                 120000L /* ttlMillis */,
-                TEST_ADDRESSES[0].address),
-            MdnsInetAddressRecord(TEST_HOSTNAME,
+                TEST_ADDRESSES[0].address
+            ),
+            MdnsInetAddressRecord(
+                TEST_HOSTNAME,
                 0L /* receiptTimeMillis */,
                 true /* cacheFlush */,
                 120000L /* ttlMillis */,
-                TEST_ADDRESSES[1].address),
-            MdnsInetAddressRecord(TEST_HOSTNAME,
+                TEST_ADDRESSES[1].address
+            ),
+            MdnsInetAddressRecord(
+                TEST_HOSTNAME,
                 0L /* receiptTimeMillis */,
                 true /* cacheFlush */,
                 120000L /* ttlMillis */,
-                TEST_ADDRESSES[2].address),
+                TEST_ADDRESSES[2].address
+            ),
         ), offloadPacket.answers)
     }
 
@@ -574,10 +953,15 @@ class MdnsRecordRepositoryTest {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
         repository.initWithService(TEST_SERVICE_ID_1, TEST_SERVICE_1)
         val questionsCaseInSensitive = listOf(
-                MdnsPointerRecord(arrayOf("_TESTSERVICE", "_TCP", "local"), false /* isUnicast */))
-        val queryCaseInsensitive = MdnsPacket(0 /* flags */, questionsCaseInSensitive,
-            emptyList() /* answers */, emptyList() /* authorityRecords */,
-            emptyList() /* additionalRecords */)
+                MdnsPointerRecord(arrayOf("_TESTSERVICE", "_TCP", "local"), false /* isUnicast */)
+        )
+        val queryCaseInsensitive = MdnsPacket(
+            0 /* flags */,
+            questionsCaseInSensitive,
+            emptyList() /* answers */,
+            emptyList() /* authorityRecords */,
+            emptyList() /* additionalRecords */
+        )
         val src = InetSocketAddress(parseNumericAddress("192.0.2.123"), 5353)
         val replyCaseInsensitive = repository.getReply(queryCaseInsensitive, src)
         assertNotNull(replyCaseInsensitive)
@@ -590,8 +974,13 @@ class MdnsRecordRepositoryTest {
      */
     private fun makeQuery(vararg queries: Pair<Int, Array<String>>): MdnsPacket {
         val questions = queries.map { (type, name) -> makeQuestionRecord(name, type) }
-        return MdnsPacket(0 /* flags */, questions, emptyList() /* answers */,
-                emptyList() /* authorityRecords */, emptyList() /* additionalRecords */)
+        return MdnsPacket(
+            0 /* flags */,
+            questions,
+            emptyList() /* answers */,
+                emptyList() /* authorityRecords */,
+            emptyList() /* additionalRecords */
+        )
     }
 
     private fun makeQuestionRecord(name: Array<String>, type: Int): MdnsRecord {
@@ -616,32 +1005,69 @@ class MdnsRecordRepositoryTest {
         val reply = repository.getReply(query, src)
 
         assertNotNull(reply)
-        assertEquals(listOf(
+        assertEquals(
+            listOf(
                 MdnsPointerRecord(
-                    arrayOf("_testservice", "_tcp", "local"), 0L, false, LONG_TTL, serviceName)),
-            reply.answers)
+                    arrayOf("_testservice", "_tcp", "local"),
+                    0L,
+                    false,
+                    LONG_TTL,
+                    serviceName
+                )
+            ),
+            reply.answers
+        )
         assertEquals(listOf(
                 MdnsTextRecord(serviceName, 0L, true, LONG_TTL, emptyList()),
                 MdnsServiceRecord(serviceName, 0L, true, SHORT_TTL, 0, 0, TEST_PORT, TEST_HOSTNAME),
                 MdnsInetAddressRecord(
-                    TEST_HOSTNAME, 0L, true, SHORT_TTL, TEST_ADDRESSES[0].address),
+                    TEST_HOSTNAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_ADDRESSES[0].address
+                ),
                 MdnsInetAddressRecord(
-                    TEST_HOSTNAME, 0L, true, SHORT_TTL, TEST_ADDRESSES[1].address),
+                    TEST_HOSTNAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_ADDRESSES[1].address
+                ),
                 MdnsInetAddressRecord(
-                    TEST_HOSTNAME, 0L, true, SHORT_TTL, TEST_ADDRESSES[2].address),
-                MdnsNsecRecord(serviceName, 0L, true, LONG_TTL, serviceName /* nextDomain */,
-                        intArrayOf(TYPE_TXT, TYPE_SRV)),
-                MdnsNsecRecord(TEST_HOSTNAME, 0L, true, SHORT_TTL, TEST_HOSTNAME /* nextDomain */,
-                        intArrayOf(TYPE_A, TYPE_AAAA)),
+                    TEST_HOSTNAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_ADDRESSES[2].address
+                ),
+                MdnsNsecRecord(
+                    serviceName,
+                    0L,
+                    true,
+                    LONG_TTL,
+                    serviceName /* nextDomain */,
+                    intArrayOf(TYPE_TXT, TYPE_SRV)
+                ),
+                MdnsNsecRecord(
+                    TEST_HOSTNAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_HOSTNAME /* nextDomain */,
+                    intArrayOf(TYPE_A, TYPE_AAAA)
+                ),
             ), reply.additionalAnswers)
     }
 
-
     @Test
     fun testGetReply_ptrQuestionForServiceWithCustomHost_customHostUsedInAdditionalAnswers() {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
-        repository.initWithService(TEST_SERVICE_CUSTOM_HOST_ID_1, TEST_SERVICE_CUSTOM_HOST_1,
-                setOf(TEST_SUBTYPE, TEST_SUBTYPE2))
+        repository.initWithService(
+            TEST_SERVICE_CUSTOM_HOST_ID_1,
+            TEST_SERVICE_CUSTOM_HOST_1,
+            setOf(TEST_SUBTYPE, TEST_SUBTYPE2)
+        )
         val src = InetSocketAddress(parseNumericAddress("fe80::1234"), 5353)
         val serviceName = arrayOf("TestService", "_testservice", "_tcp", "local")
 
@@ -649,23 +1075,53 @@ class MdnsRecordRepositoryTest {
         val reply = repository.getReply(query, src)
 
         assertNotNull(reply)
-        assertEquals(listOf(
+        assertEquals(
+            listOf(
                 MdnsPointerRecord(
-                        arrayOf("_testservice", "_tcp", "local"),
-                        0L, false, LONG_TTL, serviceName)),
-                reply.answers)
+                    arrayOf("_testservice", "_tcp", "local"),
+                    0L,
+                    false,
+                    LONG_TTL,
+                    serviceName
+                )
+            ),
+            reply.answers
+        )
         assertEquals(listOf(
                 MdnsTextRecord(serviceName, 0L, true, LONG_TTL, listOf()),
-                MdnsServiceRecord(serviceName, 0L, true, SHORT_TTL,
-                        0, 0, TEST_PORT, TEST_CUSTOM_HOST_1_NAME),
+                MdnsServiceRecord(
+                    serviceName,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    0,
+                    0,
+                    TEST_PORT,
+                    TEST_CUSTOM_HOST_1_NAME
+                ),
                 MdnsInetAddressRecord(
-                        TEST_CUSTOM_HOST_1_NAME, 0L, true, SHORT_TTL,
-                        parseNumericAddress("2001:db8::1")),
-                MdnsNsecRecord(serviceName, 0L, true, LONG_TTL, serviceName /* nextDomain */,
-                        intArrayOf(TYPE_TXT, TYPE_SRV)),
-                MdnsNsecRecord(TEST_CUSTOM_HOST_1_NAME, 0L, true, SHORT_TTL,
-                        TEST_CUSTOM_HOST_1_NAME /* nextDomain */,
-                        intArrayOf(TYPE_AAAA)),
+                    TEST_CUSTOM_HOST_1_NAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    parseNumericAddress("2001:db8::1")
+                ),
+                MdnsNsecRecord(
+                    serviceName,
+                    0L,
+                    true,
+                    LONG_TTL,
+                    serviceName /* nextDomain */,
+                    intArrayOf(TYPE_TXT, TYPE_SRV)
+                ),
+                MdnsNsecRecord(
+                    TEST_CUSTOM_HOST_1_NAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_CUSTOM_HOST_1_NAME /* nextDomain */,
+                    intArrayOf(TYPE_AAAA)
+                ),
         ), reply.additionalAnswers)
     }
 
@@ -696,29 +1152,67 @@ class MdnsRecordRepositoryTest {
         val reply = repository.getReply(query, src)
 
         assertNotNull(reply)
-        assertEquals(listOf(
+        assertEquals(
+            listOf(
                 MdnsPointerRecord(
-                        arrayOf("_testservice", "_tcp", "local"),
-                        0L, false, LONG_TTL, serviceName)),
-                reply.answers)
+                    arrayOf("_testservice", "_tcp", "local"),
+                    0L,
+                    false,
+                    LONG_TTL,
+                    serviceName
+                )
+            ),
+            reply.answers
+        )
         assertEquals(listOf(
                 MdnsTextRecord(serviceName, 0L, true, LONG_TTL, listOf()),
-                MdnsServiceRecord(serviceName, 0L, true, SHORT_TTL,
-                        0, 0, TEST_PORT, TEST_CUSTOM_HOST_1_NAME),
+                MdnsServiceRecord(
+                    serviceName,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    0,
+                    0,
+                    TEST_PORT,
+                    TEST_CUSTOM_HOST_1_NAME
+                ),
                 MdnsInetAddressRecord(
-                        TEST_CUSTOM_HOST_1_NAME, 0L, true, SHORT_TTL,
-                        parseNumericAddress("2001:db8::1")),
+                    TEST_CUSTOM_HOST_1_NAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    parseNumericAddress("2001:db8::1")
+                ),
                 MdnsInetAddressRecord(
-                        TEST_CUSTOM_HOST_1_NAME, 0L, true, SHORT_TTL,
-                        parseNumericAddress("192.0.2.1")),
+                    TEST_CUSTOM_HOST_1_NAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    parseNumericAddress("192.0.2.1")
+                ),
                 MdnsInetAddressRecord(
-                        TEST_CUSTOM_HOST_1_NAME, 0L, true, SHORT_TTL,
-                        parseNumericAddress("2001:db8::3")),
-                MdnsNsecRecord(serviceName, 0L, true, LONG_TTL, serviceName /* nextDomain */,
-                        intArrayOf(TYPE_TXT, TYPE_SRV)),
-                MdnsNsecRecord(TEST_CUSTOM_HOST_1_NAME, 0L, true, SHORT_TTL,
-                        TEST_CUSTOM_HOST_1_NAME /* nextDomain */,
-                        intArrayOf(TYPE_A, TYPE_AAAA)),
+                    TEST_CUSTOM_HOST_1_NAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    parseNumericAddress("2001:db8::3")
+                ),
+                MdnsNsecRecord(
+                    serviceName,
+                    0L,
+                    true,
+                    LONG_TTL,
+                    serviceName /* nextDomain */,
+                    intArrayOf(TYPE_TXT, TYPE_SRV)
+                ),
+                MdnsNsecRecord(
+                    TEST_CUSTOM_HOST_1_NAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_CUSTOM_HOST_1_NAME /* nextDomain */,
+                    intArrayOf(TYPE_A, TYPE_AAAA)
+                ),
         ), reply.additionalAnswers)
     }
 
@@ -730,28 +1224,63 @@ class MdnsRecordRepositoryTest {
         val serviceName = arrayOf("MyTestService", "_testservice", "_tcp", "local")
 
         val query = makeQuery(
-                TYPE_PTR to arrayOf(TEST_SUBTYPE, "_sub", "_testservice", "_tcp", "local"))
+                TYPE_PTR to arrayOf(TEST_SUBTYPE, "_sub", "_testservice", "_tcp", "local")
+        )
         val reply = repository.getReply(query, src)
 
         assertNotNull(reply)
-        assertEquals(listOf(
+        assertEquals(
+            listOf(
                 MdnsPointerRecord(
-                    arrayOf(TEST_SUBTYPE, "_sub", "_testservice", "_tcp", "local"), 0L, false,
-                    LONG_TTL, serviceName)),
-            reply.answers)
+                    arrayOf(TEST_SUBTYPE, "_sub", "_testservice", "_tcp", "local"),
+                    0L,
+                    false,
+                    LONG_TTL,
+                    serviceName
+                )
+            ),
+            reply.answers
+        )
         assertEquals(listOf(
                 MdnsTextRecord(serviceName, 0L, true, LONG_TTL, emptyList()),
                 MdnsServiceRecord(serviceName, 0L, true, SHORT_TTL, 0, 0, TEST_PORT, TEST_HOSTNAME),
                 MdnsInetAddressRecord(
-                    TEST_HOSTNAME, 0L, true, SHORT_TTL, TEST_ADDRESSES[0].address),
+                    TEST_HOSTNAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_ADDRESSES[0].address
+                ),
                 MdnsInetAddressRecord(
-                    TEST_HOSTNAME, 0L, true, SHORT_TTL, TEST_ADDRESSES[1].address),
+                    TEST_HOSTNAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_ADDRESSES[1].address
+                ),
                 MdnsInetAddressRecord(
-                    TEST_HOSTNAME, 0L, true, SHORT_TTL, TEST_ADDRESSES[2].address),
-                MdnsNsecRecord(serviceName, 0L, true, LONG_TTL, serviceName /* nextDomain */,
-                        intArrayOf(TYPE_TXT, TYPE_SRV)),
-                MdnsNsecRecord(TEST_HOSTNAME, 0L, true, SHORT_TTL, TEST_HOSTNAME /* nextDomain */,
-                        intArrayOf(TYPE_A, TYPE_AAAA)),
+                    TEST_HOSTNAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_ADDRESSES[2].address
+                ),
+                MdnsNsecRecord(
+                    serviceName,
+                    0L,
+                    true,
+                    LONG_TTL,
+                    serviceName /* nextDomain */,
+                    intArrayOf(TYPE_TXT, TYPE_SRV)
+                ),
+                MdnsNsecRecord(
+                    TEST_HOSTNAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_HOSTNAME /* nextDomain */,
+                    intArrayOf(TYPE_A, TYPE_AAAA)
+                ),
             ), reply.additionalAnswers)
     }
 
@@ -764,27 +1293,63 @@ class MdnsRecordRepositoryTest {
 
         val query = makeQuery(
                 TYPE_PTR to arrayOf("_testservice", "_tcp", "local"),
-                TYPE_PTR to arrayOf("_testservice", "_tcp", "local"))
+                TYPE_PTR to arrayOf("_testservice", "_tcp", "local")
+        )
         val reply = repository.getReply(query, src)
 
         assertNotNull(reply)
-        assertEquals(listOf(
+        assertEquals(
+            listOf(
                 MdnsPointerRecord(
-                    arrayOf("_testservice", "_tcp", "local"), 0L, false, LONG_TTL, serviceName)),
-            reply.answers)
+                    arrayOf("_testservice", "_tcp", "local"),
+                    0L,
+                    false,
+                    LONG_TTL,
+                    serviceName
+                )
+            ),
+            reply.answers
+        )
         assertEquals(listOf(
                 MdnsTextRecord(serviceName, 0L, true, LONG_TTL, emptyList()),
                 MdnsServiceRecord(serviceName, 0L, true, SHORT_TTL, 0, 0, TEST_PORT, TEST_HOSTNAME),
                 MdnsInetAddressRecord(
-                    TEST_HOSTNAME, 0L, true, SHORT_TTL, TEST_ADDRESSES[0].address),
+                    TEST_HOSTNAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_ADDRESSES[0].address
+                ),
                 MdnsInetAddressRecord(
-                    TEST_HOSTNAME, 0L, true, SHORT_TTL, TEST_ADDRESSES[1].address),
+                    TEST_HOSTNAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_ADDRESSES[1].address
+                ),
                 MdnsInetAddressRecord(
-                    TEST_HOSTNAME, 0L, true, SHORT_TTL, TEST_ADDRESSES[2].address),
-                MdnsNsecRecord(serviceName, 0L, true, LONG_TTL, serviceName /* nextDomain */,
-                        intArrayOf(TYPE_TXT, TYPE_SRV)),
-                MdnsNsecRecord(TEST_HOSTNAME, 0L, true, SHORT_TTL, TEST_HOSTNAME /* nextDomain */,
-                        intArrayOf(TYPE_A, TYPE_AAAA)),
+                    TEST_HOSTNAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_ADDRESSES[2].address
+                ),
+                MdnsNsecRecord(
+                    serviceName,
+                    0L,
+                    true,
+                    LONG_TTL,
+                    serviceName /* nextDomain */,
+                    intArrayOf(TYPE_TXT, TYPE_SRV)
+                ),
+                MdnsNsecRecord(
+                    TEST_HOSTNAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_HOSTNAME /* nextDomain */,
+                    intArrayOf(TYPE_A, TYPE_AAAA)
+                ),
             ), reply.additionalAnswers)
     }
 
@@ -797,30 +1362,70 @@ class MdnsRecordRepositoryTest {
 
         val query = makeQuery(
                 TYPE_PTR to arrayOf("_testservice", "_tcp", "local"),
-                TYPE_PTR to arrayOf(TEST_SUBTYPE, "_sub", "_testservice", "_tcp", "local"))
+                TYPE_PTR to arrayOf(TEST_SUBTYPE, "_sub", "_testservice", "_tcp", "local")
+        )
         val reply = repository.getReply(query, src)
 
         assertNotNull(reply)
-        assertEquals(listOf(
+        assertEquals(
+            listOf(
                 MdnsPointerRecord(
-                    arrayOf("_testservice", "_tcp", "local"), 0L, false, LONG_TTL, serviceName),
+                    arrayOf("_testservice", "_tcp", "local"),
+                    0L,
+                    false,
+                    LONG_TTL,
+                    serviceName
+                ),
                 MdnsPointerRecord(
                     arrayOf(TEST_SUBTYPE, "_sub", "_testservice", "_tcp", "local"),
-                    0L, false, LONG_TTL, serviceName)),
-            reply.answers)
+                    0L,
+                    false,
+                    LONG_TTL,
+                    serviceName
+                )
+            ),
+            reply.answers
+        )
         assertEquals(listOf(
                 MdnsTextRecord(serviceName, 0L, true, LONG_TTL, emptyList()),
                 MdnsServiceRecord(serviceName, 0L, true, SHORT_TTL, 0, 0, TEST_PORT, TEST_HOSTNAME),
                 MdnsInetAddressRecord(
-                    TEST_HOSTNAME, 0L, true, SHORT_TTL, TEST_ADDRESSES[0].address),
+                    TEST_HOSTNAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_ADDRESSES[0].address
+                ),
                 MdnsInetAddressRecord(
-                    TEST_HOSTNAME, 0L, true, SHORT_TTL, TEST_ADDRESSES[1].address),
+                    TEST_HOSTNAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_ADDRESSES[1].address
+                ),
                 MdnsInetAddressRecord(
-                    TEST_HOSTNAME, 0L, true, SHORT_TTL, TEST_ADDRESSES[2].address),
-                MdnsNsecRecord(serviceName, 0L, true, LONG_TTL, serviceName /* nextDomain */,
-                        intArrayOf(TYPE_TXT, TYPE_SRV)),
-                MdnsNsecRecord(TEST_HOSTNAME, 0L, true, SHORT_TTL, TEST_HOSTNAME /* nextDomain */,
-                        intArrayOf(TYPE_A, TYPE_AAAA)),
+                    TEST_HOSTNAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_ADDRESSES[2].address
+                ),
+                MdnsNsecRecord(
+                    serviceName,
+                    0L,
+                    true,
+                    LONG_TTL,
+                    serviceName /* nextDomain */,
+                    intArrayOf(TYPE_TXT, TYPE_SRV)
+                ),
+                MdnsNsecRecord(
+                    TEST_HOSTNAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_HOSTNAME /* nextDomain */,
+                    intArrayOf(TYPE_A, TYPE_AAAA)
+                ),
             ), reply.additionalAnswers)
     }
 
@@ -835,8 +1440,10 @@ class MdnsRecordRepositoryTest {
         val reply = repository.getReply(query, src)
 
         assertNotNull(reply)
-        assertEquals(listOf(MdnsTextRecord(serviceName, 0L, true, LONG_TTL, emptyList())),
-                reply.answers)
+        assertEquals(
+            listOf(MdnsTextRecord(serviceName, 0L, true, LONG_TTL, emptyList())),
+            reply.answers
+        )
         // No NSEC records because the reply doesn't include the SRV record
         assertTrue(reply.additionalAnswers.isEmpty())
     }
@@ -845,8 +1452,11 @@ class MdnsRecordRepositoryTest {
     fun testGetReply_AAAAQuestionButNoIpv6Address_returnsNsecRecord() {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
         repository.initWithService(
-                TEST_SERVICE_ID_1, TEST_SERVICE_1, setOf(TEST_SUBTYPE),
-                listOf(LinkAddress(parseNumericAddress("192.0.2.111"), 24)))
+            TEST_SERVICE_ID_1,
+            TEST_SERVICE_1,
+            setOf(TEST_SUBTYPE),
+            listOf(LinkAddress(parseNumericAddress("192.0.2.111"), 24))
+        )
         val src = InetSocketAddress(parseNumericAddress("192.0.2.123"), 5353)
 
         val query = makeQuery(TYPE_AAAA to TEST_HOSTNAME)
@@ -854,40 +1464,69 @@ class MdnsRecordRepositoryTest {
 
         assertNotNull(reply)
         assertTrue(reply.answers.isEmpty())
-        assertEquals(listOf(
-                MdnsNsecRecord(TEST_HOSTNAME, 0L, true, LONG_TTL, TEST_HOSTNAME /* nextDomain */,
-                        intArrayOf(TYPE_AAAA))),
-            reply.additionalAnswers)
+        assertEquals(
+            listOf(
+                MdnsNsecRecord(
+                    TEST_HOSTNAME,
+                    0L,
+                    true,
+                    LONG_TTL,
+                    TEST_HOSTNAME /* nextDomain */,
+                    intArrayOf(TYPE_AAAA)
+                )
+            ),
+            reply.additionalAnswers
+        )
     }
 
     @Test
     fun testGetReply_AAAAQuestionForCustomHost_returnsAAAARecords() {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
         repository.initWithService(
-                TEST_CUSTOM_HOST_ID_1, TEST_CUSTOM_HOST_1, subtypes = setOf(),
-                listOf(LinkAddress(parseNumericAddress("192.0.2.111"), 24)))
-        repository.addService(TEST_CUSTOM_HOST_ID_2, TEST_CUSTOM_HOST_2, null /* ttl */)
+            TEST_CUSTOM_HOST_ID_1,
+            TEST_CUSTOM_HOST_1,
+            subtypes = setOf(),
+            listOf(LinkAddress(parseNumericAddress("192.0.2.111"), 24))
+        )
+        repository.addService(TEST_CUSTOM_HOST_ID_2, TEST_CUSTOM_HOST_2, DEFAULT_OPTION)
         val src = InetSocketAddress(parseNumericAddress("fe80::123"), 5353)
 
         val query = makeQuery(TYPE_AAAA to TEST_CUSTOM_HOST_1_NAME)
         val reply = repository.getReply(query, src)
 
         assertNotNull(reply)
-        assertEquals(listOf(
-                MdnsInetAddressRecord(TEST_CUSTOM_HOST_1_NAME,
-                        0, false, LONG_TTL, parseNumericAddress("2001:db8::1")),
-                MdnsInetAddressRecord(TEST_CUSTOM_HOST_1_NAME,
-                        0, false, LONG_TTL, parseNumericAddress("2001:db8::2"))),
-                reply.answers)
         assertEquals(
-                listOf(MdnsNsecRecord(TEST_CUSTOM_HOST_1_NAME,
-                        0L, true, SHORT_TTL,
-                        TEST_CUSTOM_HOST_1_NAME /* nextDomain */,
-                        intArrayOf(TYPE_AAAA))),
-                reply.additionalAnswers)
+            listOf(
+                MdnsInetAddressRecord(
+                    TEST_CUSTOM_HOST_1_NAME,
+                    0,
+                    false,
+                    LONG_TTL,
+                    parseNumericAddress("2001:db8::1")
+                ),
+                MdnsInetAddressRecord(
+                    TEST_CUSTOM_HOST_1_NAME,
+                    0,
+                    false,
+                    LONG_TTL,
+                    parseNumericAddress("2001:db8::2")
+                )
+            ),
+            reply.answers
+        )
+        assertEquals(
+                listOf(MdnsNsecRecord(
+                    TEST_CUSTOM_HOST_1_NAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_CUSTOM_HOST_1_NAME /* nextDomain */,
+                    intArrayOf(TYPE_AAAA)
+                )),
+                reply.additionalAnswers
+        )
     }
 
-
     @Test
     fun testGetReply_AAAAQuestionForCustomHostInMultipleRegistrations_returnsAAAARecords() {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
@@ -910,20 +1549,43 @@ class MdnsRecordRepositoryTest {
         val reply = repository.getReply(query, src)
 
         assertNotNull(reply)
-        assertEquals(listOf(
-                MdnsInetAddressRecord(TEST_CUSTOM_HOST_1_NAME,
-                        0, false, LONG_TTL, parseNumericAddress("2001:db8::1")),
-                MdnsInetAddressRecord(TEST_CUSTOM_HOST_1_NAME,
-                        0, false, LONG_TTL, parseNumericAddress("2001:db8::2")),
-                MdnsInetAddressRecord(TEST_CUSTOM_HOST_1_NAME,
-                        0, false, LONG_TTL, parseNumericAddress("2001:db8::3"))),
-                reply.answers)
         assertEquals(
-                listOf(MdnsNsecRecord(TEST_CUSTOM_HOST_1_NAME,
-                        0L, true, SHORT_TTL,
-                        TEST_CUSTOM_HOST_1_NAME /* nextDomain */,
-                        intArrayOf(TYPE_AAAA))),
-                reply.additionalAnswers)
+            listOf(
+                MdnsInetAddressRecord(
+                    TEST_CUSTOM_HOST_1_NAME,
+                    0,
+                    false,
+                    LONG_TTL,
+                    parseNumericAddress("2001:db8::1")
+                ),
+                MdnsInetAddressRecord(
+                    TEST_CUSTOM_HOST_1_NAME,
+                    0,
+                    false,
+                    LONG_TTL,
+                    parseNumericAddress("2001:db8::2")
+                ),
+                MdnsInetAddressRecord(
+                    TEST_CUSTOM_HOST_1_NAME,
+                    0,
+                    false,
+                    LONG_TTL,
+                    parseNumericAddress("2001:db8::3")
+                )
+            ),
+            reply.answers
+        )
+        assertEquals(
+                listOf(MdnsNsecRecord(
+                    TEST_CUSTOM_HOST_1_NAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_CUSTOM_HOST_1_NAME /* nextDomain */,
+                    intArrayOf(TYPE_AAAA)
+                )),
+                reply.additionalAnswers
+        )
     }
 
     @Test
@@ -950,24 +1612,46 @@ class MdnsRecordRepositoryTest {
         val reply1 = repository.getReply(query1, src)
 
         assertNotNull(reply1)
-        assertEquals(listOf(MdnsKeyRecord(serviceName1,
-                0, false, LONG_TTL, TEST_PUBLIC_KEY)),
-                reply1.answers)
-        assertEquals(listOf(),
-                reply1.additionalAnswers)
+        assertEquals(
+            listOf(MdnsKeyRecord(
+                serviceName1,
+                0,
+                false,
+                LONG_TTL,
+                TEST_PUBLIC_KEY
+            )),
+            reply1.answers
+        )
+        assertEquals(
+            listOf(),
+            reply1.additionalAnswers
+        )
 
         val query2 = makeQuery(TYPE_KEY to serviceName2)
         val reply2 = repository.getReply(query2, src)
 
         assertNotNull(reply2)
-        assertEquals(listOf(MdnsKeyRecord(serviceName2,
-                0, false, LONG_TTL, TEST_PUBLIC_KEY)),
-                reply2.answers)
-        assertEquals(listOf(MdnsNsecRecord(serviceName2,
-                0L, true, SHORT_TTL,
+        assertEquals(
+            listOf(MdnsKeyRecord(
+                serviceName2,
+                0,
+                false,
+                LONG_TTL,
+                TEST_PUBLIC_KEY
+            )),
+            reply2.answers
+        )
+        assertEquals(
+            listOf(MdnsNsecRecord(
+                serviceName2,
+                0L,
+                true,
+                SHORT_TTL,
                 serviceName2 /* nextDomain */,
-                intArrayOf(TYPE_KEY))),
-                reply2.additionalAnswers)
+                intArrayOf(TYPE_KEY)
+            )),
+            reply2.additionalAnswers
+        )
     }
 
     @Test
@@ -994,23 +1678,46 @@ class MdnsRecordRepositoryTest {
         val reply1 = repository.getReply(query1, src)
 
         assertNotNull(reply1)
-        assertEquals(listOf(MdnsKeyRecord(hostname1,
-                0, false, LONG_TTL, TEST_PUBLIC_KEY)),
-                reply1.answers)
-        assertEquals(listOf(),
-                reply1.additionalAnswers)
+        assertEquals(
+            listOf(MdnsKeyRecord(
+                hostname1,
+                0,
+                false,
+                LONG_TTL,
+                TEST_PUBLIC_KEY
+            )),
+            reply1.answers
+        )
+        assertEquals(
+            listOf(),
+            reply1.additionalAnswers
+        )
 
         val query2 = makeQuery(TYPE_KEY to hostname2)
         val reply2 = repository.getReply(query2, src)
 
         assertNotNull(reply2)
-        assertEquals(listOf(MdnsKeyRecord(hostname2,
-                0, false, LONG_TTL, TEST_PUBLIC_KEY)),
-                reply2.answers)
-        assertEquals(listOf(MdnsNsecRecord(hostname2, 0L, true, SHORT_TTL,
+        assertEquals(
+            listOf(MdnsKeyRecord(
+                hostname2,
+                0,
+                false,
+                LONG_TTL,
+                TEST_PUBLIC_KEY
+            )),
+            reply2.answers
+        )
+        assertEquals(
+            listOf(MdnsNsecRecord(
+                hostname2,
+                0L,
+                true,
+                SHORT_TTL,
                 hostname2 /* nextDomain */,
-                intArrayOf(TYPE_KEY))),
-                reply2.additionalAnswers)
+                intArrayOf(TYPE_KEY)
+            )),
+            reply2.additionalAnswers
+        )
     }
 
     @Test
@@ -1083,10 +1790,16 @@ class MdnsRecordRepositoryTest {
     fun testGetReply_customHostRemoved_noAnswerToAAAAQuestion() {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
         repository.initWithService(
-                TEST_CUSTOM_HOST_ID_1, TEST_CUSTOM_HOST_1, subtypes = setOf(),
-                listOf(LinkAddress(parseNumericAddress("192.0.2.111"), 24)))
+            TEST_CUSTOM_HOST_ID_1,
+            TEST_CUSTOM_HOST_1,
+            subtypes = setOf(),
+            listOf(LinkAddress(parseNumericAddress("192.0.2.111"), 24))
+        )
         repository.addService(
-                TEST_SERVICE_CUSTOM_HOST_ID_1, TEST_SERVICE_CUSTOM_HOST_1, null /* ttl */)
+            TEST_SERVICE_CUSTOM_HOST_ID_1,
+            TEST_SERVICE_CUSTOM_HOST_1,
+            DEFAULT_OPTION
+        )
         repository.removeService(TEST_CUSTOM_HOST_ID_1)
         repository.removeService(TEST_SERVICE_CUSTOM_HOST_ID_1)
 
@@ -1107,16 +1820,33 @@ class MdnsRecordRepositoryTest {
 
         val query = makeQuery(
                 TYPE_PTR to arrayOf("_testservice", "_tcp", "local"),
-                TYPE_SRV to serviceName)
+                TYPE_SRV to serviceName
+        )
         val reply = repository.getReply(query, src)
 
         assertNotNull(reply)
-        assertEquals(listOf(
+        assertEquals(
+            listOf(
                 MdnsPointerRecord(
-                    arrayOf("_testservice", "_tcp", "local"), 0L, false, LONG_TTL, serviceName),
+                    arrayOf("_testservice", "_tcp", "local"),
+                    0L,
+                    false,
+                    LONG_TTL,
+                    serviceName
+                ),
                 MdnsServiceRecord(
-                    serviceName, 0L, true, SHORT_TTL, 0, 0, TEST_PORT, TEST_HOSTNAME)),
-            reply.answers)
+                    serviceName,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    0,
+                    0,
+                    TEST_PORT,
+                    TEST_HOSTNAME
+                )
+            ),
+            reply.answers
+        )
         assertFalse(reply.additionalAnswers.any { it -> it is MdnsServiceRecord })
     }
 
@@ -1132,26 +1862,60 @@ class MdnsRecordRepositoryTest {
                 TYPE_TXT to serviceName,
                 TYPE_SRV to serviceName,
                 TYPE_A to TEST_HOSTNAME,
-                TYPE_AAAA to TEST_HOSTNAME)
+                TYPE_AAAA to TEST_HOSTNAME
+        )
         val reply = repository.getReply(query, src)
 
         assertNotNull(reply)
-        assertEquals(listOf(
+        assertEquals(
+            listOf(
                 MdnsServiceRecord(serviceName, 0L, true, SHORT_TTL, 0, 0, TEST_PORT, TEST_HOSTNAME),
                 MdnsTextRecord(serviceName, 0L, true, LONG_TTL, emptyList()),
                 MdnsInetAddressRecord(
-                        TEST_HOSTNAME, 0L, true, SHORT_TTL, TEST_ADDRESSES[0].address),
+                    TEST_HOSTNAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_ADDRESSES[0].address
+                ),
                 MdnsInetAddressRecord(
-                        TEST_HOSTNAME, 0L, true, SHORT_TTL, TEST_ADDRESSES[1].address),
+                    TEST_HOSTNAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_ADDRESSES[1].address
+                ),
                 MdnsInetAddressRecord(
-                        TEST_HOSTNAME, 0L, true, SHORT_TTL, TEST_ADDRESSES[2].address)),
-            reply.answers)
-        assertEquals(listOf(
-                MdnsNsecRecord(serviceName, 0L, true, LONG_TTL, serviceName /* nextDomain */,
-                        intArrayOf(TYPE_TXT, TYPE_SRV)),
-                MdnsNsecRecord(TEST_HOSTNAME, 0L, true, SHORT_TTL, TEST_HOSTNAME /* nextDomain */,
-                        intArrayOf(TYPE_A, TYPE_AAAA))),
-            reply.additionalAnswers)
+                    TEST_HOSTNAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_ADDRESSES[2].address
+                )
+            ),
+            reply.answers
+        )
+        assertEquals(
+            listOf(
+                MdnsNsecRecord(
+                    serviceName,
+                    0L,
+                    true,
+                    LONG_TTL,
+                    serviceName /* nextDomain */,
+                    intArrayOf(TYPE_TXT, TYPE_SRV)
+                ),
+                MdnsNsecRecord(
+                    TEST_HOSTNAME,
+                    0L,
+                    true,
+                    SHORT_TTL,
+                    TEST_HOSTNAME /* nextDomain */,
+                    intArrayOf(TYPE_A, TYPE_AAAA)
+                )
+            ),
+            reply.additionalAnswers
+        )
     }
 
     @Test
@@ -1218,7 +1982,6 @@ class MdnsRecordRepositoryTest {
         assertNull(secondReply)
     }
 
-
     @Test
     fun testGetReply_twoIpv6QueriesInOneSecond_theSecondReplyIsThrottled() {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
@@ -1281,39 +2044,49 @@ class MdnsRecordRepositoryTest {
     @Test
     fun testGetConflictingServices() {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
-        repository.addService(TEST_SERVICE_ID_1, TEST_SERVICE_1, null /* ttl */)
-        repository.addService(TEST_SERVICE_ID_2, TEST_SERVICE_2, null /* ttl */)
+        repository.addService(TEST_SERVICE_ID_1, TEST_SERVICE_1, DEFAULT_OPTION)
+        repository.addService(TEST_SERVICE_ID_2, TEST_SERVICE_2, DEFAULT_OPTION)
 
         val packet = MdnsPacket(
                 0 /* flags */,
                 emptyList() /* questions */,
                 listOf(
                     MdnsServiceRecord(
-                            arrayOf("MyTestService", "_testservice", "_tcp", "local"),
-                            0L /* receiptTimeMillis */, true /* cacheFlush */, 0L /* ttlMillis */,
-                            0 /* servicePriority */, 0 /* serviceWeight */,
-                            TEST_SERVICE_1.port + 1,
-                            TEST_HOSTNAME),
+                        arrayOf("MyTestService", "_testservice", "_tcp", "local"),
+                        0L /* receiptTimeMillis */,
+                        true /* cacheFlush */,
+                        0L /* ttlMillis */,
+                        0 /* servicePriority */,
+                        0 /* serviceWeight */,
+                        TEST_SERVICE_1.port + 1,
+                        TEST_HOSTNAME
+                    ),
                     MdnsTextRecord(
-                            arrayOf("MyOtherTestService", "_testservice", "_tcp", "local"),
-                            0L /* receiptTimeMillis */, true /* cacheFlush */, 0L /* ttlMillis */,
-                            listOf(TextEntry.fromString("somedifferent=entry"))),
+                        arrayOf("MyOtherTestService", "_testservice", "_tcp", "local"),
+                        0L /* receiptTimeMillis */,
+                        true /* cacheFlush */,
+                        0L /* ttlMillis */,
+                        listOf(TextEntry.fromString("somedifferent=entry"))
+                    ),
                 ) /* answers */,
                 emptyList() /* authorityRecords */,
-                emptyList() /* additionalRecords */)
+                emptyList() /* additionalRecords */
+        )
 
         assertEquals(
                 mapOf(
                         TEST_SERVICE_ID_1 to CONFLICT_SERVICE,
-                        TEST_SERVICE_ID_2 to CONFLICT_SERVICE),
-                repository.getConflictingServices(packet))
+                        TEST_SERVICE_ID_2 to CONFLICT_SERVICE
+                ),
+                repository.getConflictingServices(packet)
+        )
     }
 
     @Test
     fun testGetConflictingServicesCaseInsensitive() {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
-        repository.addService(TEST_SERVICE_ID_1, TEST_SERVICE_1, null /* ttl */)
-        repository.addService(TEST_SERVICE_ID_2, TEST_SERVICE_2, null /* ttl */)
+        repository.addService(TEST_SERVICE_ID_1, TEST_SERVICE_1, DEFAULT_OPTION)
+        repository.addService(TEST_SERVICE_ID_2, TEST_SERVICE_2, DEFAULT_OPTION)
 
         val packet = MdnsPacket(
             0 /* flags */,
@@ -1321,73 +2094,110 @@ class MdnsRecordRepositoryTest {
             listOf(
                 MdnsServiceRecord(
                     arrayOf("MYTESTSERVICE", "_TESTSERVICE", "_tcp", "local"),
-                    0L /* receiptTimeMillis */, true /* cacheFlush */, 0L /* ttlMillis */,
-                    0 /* servicePriority */, 0 /* serviceWeight */,
+                    0L /* receiptTimeMillis */,
+                    true /* cacheFlush */,
+                    0L /* ttlMillis */,
+                    0 /* servicePriority */,
+                    0 /* serviceWeight */,
                     TEST_SERVICE_1.port + 1,
-                    TEST_HOSTNAME),
+                    TEST_HOSTNAME
+                ),
                 MdnsTextRecord(
                     arrayOf("MYOTHERTESTSERVICE", "_TESTSERVICE", "_tcp", "local"),
-                    0L /* receiptTimeMillis */, true /* cacheFlush */, 0L /* ttlMillis */,
-                    listOf(TextEntry.fromString("somedifferent=entry"))),
+                    0L /* receiptTimeMillis */,
+                    true /* cacheFlush */,
+                    0L /* ttlMillis */,
+                    listOf(TextEntry.fromString("somedifferent=entry"))
+                ),
             ) /* answers */,
             emptyList() /* authorityRecords */,
-            emptyList() /* additionalRecords */)
+            emptyList() /* additionalRecords */
+        )
 
         assertEquals(
-                mapOf(TEST_SERVICE_ID_1 to CONFLICT_SERVICE,
-                        TEST_SERVICE_ID_2 to CONFLICT_SERVICE),
-                repository.getConflictingServices(packet))
+                mapOf(
+                    TEST_SERVICE_ID_1 to CONFLICT_SERVICE,
+                    TEST_SERVICE_ID_2 to CONFLICT_SERVICE
+                ),
+                repository.getConflictingServices(packet)
+        )
     }
 
     @Test
     fun testGetConflictingServices_customHosts_differentAddresses() {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
-        repository.addService(TEST_CUSTOM_HOST_ID_1, TEST_CUSTOM_HOST_1, null /* ttl */)
-        repository.addService(TEST_CUSTOM_HOST_ID_2, TEST_CUSTOM_HOST_2, null /* ttl */)
+        repository.addService(TEST_CUSTOM_HOST_ID_1, TEST_CUSTOM_HOST_1, DEFAULT_OPTION)
+        repository.addService(TEST_CUSTOM_HOST_ID_2, TEST_CUSTOM_HOST_2, DEFAULT_OPTION)
 
         val packet = MdnsPacket(
                 0, /* flags */
                 emptyList(), /* questions */
                 listOf(
-                        MdnsInetAddressRecord(arrayOf("TestHost", "local"),
-                                0L /* receiptTimeMillis */, true /* cacheFlush */,
-                                0L /* ttlMillis */, parseNumericAddress("2001:db8::5")),
-                        MdnsInetAddressRecord(arrayOf("TestHost", "local"),
-                                0L /* receiptTimeMillis */, true /* cacheFlush */,
-                                0L /* ttlMillis */, parseNumericAddress("2001:db8::6")),
+                        MdnsInetAddressRecord(
+                            arrayOf("TestHost", "local"),
+                            0L /* receiptTimeMillis */,
+                            true /* cacheFlush */,
+                            0L /* ttlMillis */,
+                            parseNumericAddress("2001:db8::5")
+                        ),
+                        MdnsInetAddressRecord(
+                            arrayOf("TestHost", "local"),
+                            0L /* receiptTimeMillis */,
+                            true /* cacheFlush */,
+                            0L /* ttlMillis */,
+                            parseNumericAddress("2001:db8::6")
+                        ),
                 ) /* answers */,
                 emptyList() /* authorityRecords */,
-                emptyList() /* additionalRecords */)
+                emptyList() /* additionalRecords */
+        )
 
-        assertEquals(mapOf(TEST_CUSTOM_HOST_ID_1 to CONFLICT_HOST),
-                repository.getConflictingServices(packet))
+        assertEquals(
+            mapOf(TEST_CUSTOM_HOST_ID_1 to CONFLICT_HOST),
+                repository.getConflictingServices(packet)
+        )
     }
 
     @Test
     fun testGetConflictingServices_customHosts_moreAddressesThanUs_conflict() {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
-        repository.addService(TEST_CUSTOM_HOST_ID_1, TEST_CUSTOM_HOST_1, null /* ttl */)
-        repository.addService(TEST_CUSTOM_HOST_ID_2, TEST_CUSTOM_HOST_2, null /* ttl */)
+        repository.addService(TEST_CUSTOM_HOST_ID_1, TEST_CUSTOM_HOST_1, DEFAULT_OPTION)
+        repository.addService(TEST_CUSTOM_HOST_ID_2, TEST_CUSTOM_HOST_2, DEFAULT_OPTION)
 
         val packet = MdnsPacket(
                 0, /* flags */
                 emptyList(), /* questions */
                 listOf(
-                        MdnsInetAddressRecord(arrayOf("TestHost", "local"),
-                                0L /* receiptTimeMillis */, true /* cacheFlush */,
-                                0L /* ttlMillis */, parseNumericAddress("2001:db8::1")),
-                        MdnsInetAddressRecord(arrayOf("TestHost", "local"),
-                                0L /* receiptTimeMillis */, true /* cacheFlush */,
-                                0L /* ttlMillis */, parseNumericAddress("2001:db8::2")),
-                        MdnsInetAddressRecord(arrayOf("TestHost", "local"),
-                                0L /* receiptTimeMillis */, true /* cacheFlush */,
-                                0L /* ttlMillis */, parseNumericAddress("2001:db8::3")),
+                        MdnsInetAddressRecord(
+                            arrayOf("TestHost", "local"),
+                            0L /* receiptTimeMillis */,
+                            true /* cacheFlush */,
+                            0L /* ttlMillis */,
+                            parseNumericAddress("2001:db8::1")
+                        ),
+                        MdnsInetAddressRecord(
+                            arrayOf("TestHost", "local"),
+                            0L /* receiptTimeMillis */,
+                            true /* cacheFlush */,
+                            0L /* ttlMillis */,
+                            parseNumericAddress("2001:db8::2")
+                        ),
+                        MdnsInetAddressRecord(
+                            arrayOf("TestHost", "local"),
+                            0L /* receiptTimeMillis */,
+                            true /* cacheFlush */,
+                            0L /* ttlMillis */,
+                            parseNumericAddress("2001:db8::3")
+                        ),
                 ) /* answers */,
                 emptyList() /* authorityRecords */,
-                emptyList() /* additionalRecords */)
+                emptyList() /* additionalRecords */
+        )
 
-        assertEquals(mapOf(TEST_CUSTOM_HOST_ID_1 to CONFLICT_HOST),
-                repository.getConflictingServices(packet))
+        assertEquals(
+            mapOf(TEST_CUSTOM_HOST_ID_1 to CONFLICT_HOST),
+            repository.getConflictingServices(packet)
+        )
     }
 
     @Test
@@ -1400,35 +2210,50 @@ class MdnsRecordRepositoryTest {
                 0, /* flags */
                 emptyList(), /* questions */
                 listOf(
-                        MdnsInetAddressRecord(arrayOf("TestHost", "local"),
-                                0L /* receiptTimeMillis */, true /* cacheFlush */,
-                                0L /* ttlMillis */, parseNumericAddress("2001:db8::2")),
+                        MdnsInetAddressRecord(
+                            arrayOf("TestHost", "local"),
+                            0L /* receiptTimeMillis */,
+                            true /* cacheFlush */,
+                            0L /* ttlMillis */,
+                            parseNumericAddress("2001:db8::2")
+                        ),
                 ) /* answers */,
                 emptyList() /* authorityRecords */,
-                emptyList() /* additionalRecords */)
+                emptyList() /* additionalRecords */
+        )
 
-        assertEquals(emptyMap(),
-                repository.getConflictingServices(packet))
+        assertEquals(
+            emptyMap(),
+            repository.getConflictingServices(packet)
+        )
     }
 
     @Test
     fun testGetConflictingServices_customHostsReplyHasSameNameRecord_conflictDuringProbing() {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
-        repository.addService(TEST_CUSTOM_HOST_ID_1, TEST_CUSTOM_HOST_1, null /* ttl */)
+        repository.addService(TEST_CUSTOM_HOST_ID_1, TEST_CUSTOM_HOST_1, DEFAULT_OPTION)
         repository.addServiceAndFinishProbing(TEST_CUSTOM_HOST_ID_2, TEST_CUSTOM_HOST_2)
 
         val packet = MdnsPacket(
             0, /* flags */
             emptyList(), /* questions */
-            listOf(MdnsKeyRecord(arrayOf("TestHost", "local"),
-                    0L /* receiptTimeMillis */, true /* cacheFlush */,
-                    0L /* ttlMillis */, TEST_PUBLIC_KEY),
+            listOf(
+                MdnsKeyRecord(
+                    arrayOf("TestHost", "local"),
+                    0L /* receiptTimeMillis */,
+                    true /* cacheFlush */,
+                    0L /* ttlMillis */,
+                    TEST_PUBLIC_KEY
+                ),
             ) /* answers */,
             emptyList() /* authorityRecords */,
-            emptyList() /* additionalRecords */)
+            emptyList() /* additionalRecords */
+        )
 
-        assertEquals(mapOf(TEST_CUSTOM_HOST_ID_1 to CONFLICT_HOST),
-            repository.getConflictingServices(packet))
+        assertEquals(
+            mapOf(TEST_CUSTOM_HOST_ID_1 to CONFLICT_HOST),
+            repository.getConflictingServices(packet)
+        )
     }
 
     @Test
@@ -1441,21 +2266,31 @@ class MdnsRecordRepositoryTest {
                 0, /* flags */
                 emptyList(), /* questions */
                 listOf(
-                        MdnsInetAddressRecord(arrayOf("TestHost", "local"),
-                                0L /* receiptTimeMillis */, true /* cacheFlush */,
-                                0L /* ttlMillis */, parseNumericAddress("2001:db8::1")),
-                        MdnsInetAddressRecord(arrayOf("TestHost", "local"),
-                                0L /* receiptTimeMillis */, true /* cacheFlush */,
-                                0L /* ttlMillis */, parseNumericAddress("2001:db8::2")),
+                        MdnsInetAddressRecord(
+                            arrayOf("TestHost", "local"),
+                            0L /* receiptTimeMillis */,
+                            true /* cacheFlush */,
+                            0L /* ttlMillis */,
+                            parseNumericAddress("2001:db8::1")
+                        ),
+                        MdnsInetAddressRecord(
+                            arrayOf("TestHost", "local"),
+                            0L /* receiptTimeMillis */,
+                            true /* cacheFlush */,
+                            0L /* ttlMillis */,
+                            parseNumericAddress("2001:db8::2")
+                        ),
                 ) /* answers */,
                 emptyList() /* authorityRecords */,
-                emptyList() /* additionalRecords */)
+                emptyList() /* additionalRecords */
+        )
 
-        assertEquals(emptyMap(),
-                repository.getConflictingServices(packet))
+        assertEquals(
+            emptyMap(),
+            repository.getConflictingServices(packet)
+        )
     }
 
-
     @Test
     fun testGetConflictingServices_customHostsCaseInsensitiveReplyHasIdenticalHosts_noConflict() {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
@@ -1466,18 +2301,29 @@ class MdnsRecordRepositoryTest {
                 0, /* flags */
                 emptyList(), /* questions */
                 listOf(
-                        MdnsInetAddressRecord(arrayOf("TESTHOST", "local"),
-                                0L /* receiptTimeMillis */, true /* cacheFlush */,
-                                0L /* ttlMillis */, parseNumericAddress("2001:db8::1")),
-                        MdnsInetAddressRecord(arrayOf("testhost", "local"),
-                                0L /* receiptTimeMillis */, true /* cacheFlush */,
-                                0L /* ttlMillis */, parseNumericAddress("2001:db8::2")),
+                        MdnsInetAddressRecord(
+                            arrayOf("TESTHOST", "local"),
+                            0L /* receiptTimeMillis */,
+                            true /* cacheFlush */,
+                            0L /* ttlMillis */,
+                            parseNumericAddress("2001:db8::1")
+                        ),
+                        MdnsInetAddressRecord(
+                            arrayOf("testhost", "local"),
+                            0L /* receiptTimeMillis */,
+                            true /* cacheFlush */,
+                            0L /* ttlMillis */,
+                            parseNumericAddress("2001:db8::2")
+                        ),
                 ) /* answers */,
                 emptyList() /* authorityRecords */,
-                emptyList() /* additionalRecords */)
+                emptyList() /* additionalRecords */
+        )
 
-        assertEquals(emptyMap(),
-                repository.getConflictingServices(packet))
+        assertEquals(
+            emptyMap(),
+            repository.getConflictingServices(packet)
+        )
     }
 
     @Test
@@ -1489,7 +2335,7 @@ class MdnsRecordRepositoryTest {
             serviceName = "MyTestService"
             port = TEST_PORT
             publicKey = TEST_PUBLIC_KEY
-        }, null /* ttl */)
+        }, DEFAULT_OPTION)
 
         val otherTtlMillis = 1234L
         val packet = MdnsPacket(
@@ -1497,16 +2343,21 @@ class MdnsRecordRepositoryTest {
                 emptyList() /* questions */,
                 listOf(
                         MdnsKeyRecord(
-                                arrayOf("MyTestService", "_testservice", "_tcp", "local"),
-                                0L /* receiptTimeMillis */, true /* cacheFlush */,
-                                otherTtlMillis,
-                                TEST_PUBLIC_KEY)
+                            arrayOf("MyTestService", "_testservice", "_tcp", "local"),
+                            0L /* receiptTimeMillis */,
+                            true /* cacheFlush */,
+                            otherTtlMillis,
+                            TEST_PUBLIC_KEY
+                        )
                 ) /* answers */,
                 emptyList() /* authorityRecords */,
-                emptyList() /* additionalRecords */)
+                emptyList() /* additionalRecords */
+        )
 
-        assertEquals(emptyMap(),
-                repository.getConflictingServices(packet))
+        assertEquals(
+            emptyMap(),
+            repository.getConflictingServices(packet)
+        )
     }
 
     @Test
@@ -1518,7 +2369,7 @@ class MdnsRecordRepositoryTest {
             serviceName = "MyTestService"
             port = TEST_PORT
             publicKey = TEST_PUBLIC_KEY
-        }, null /* null */)
+        }, DEFAULT_OPTION)
 
         val otherTtlMillis = 1234L
         val packet = MdnsPacket(
@@ -1526,16 +2377,21 @@ class MdnsRecordRepositoryTest {
                 emptyList() /* questions */,
                 listOf(
                         MdnsKeyRecord(
-                                arrayOf("MyTestService", "_testservice", "_tcp", "local"),
-                                0L /* receiptTimeMillis */, true /* cacheFlush */,
-                                otherTtlMillis,
-                                TEST_PUBLIC_KEY_2)
+                            arrayOf("MyTestService", "_testservice", "_tcp", "local"),
+                            0L /* receiptTimeMillis */,
+                            true /* cacheFlush */,
+                            otherTtlMillis,
+                            TEST_PUBLIC_KEY_2
+                        )
                 ) /* answers */,
                 emptyList() /* authorityRecords */,
-                emptyList() /* additionalRecords */)
+                emptyList() /* additionalRecords */
+        )
 
-        assertEquals(mapOf(TEST_SERVICE_ID_1 to CONFLICT_SERVICE),
-                repository.getConflictingServices(packet))
+        assertEquals(
+            mapOf(TEST_SERVICE_ID_1 to CONFLICT_SERVICE),
+            repository.getConflictingServices(packet)
+        )
     }
 
     @Test
@@ -1557,16 +2413,21 @@ class MdnsRecordRepositoryTest {
                 emptyList() /* questions */,
                 listOf(
                         MdnsKeyRecord(
-                                arrayOf("MyHost", "local"),
-                                0L /* receiptTimeMillis */, true /* cacheFlush */,
-                                otherTtlMillis,
-                                TEST_PUBLIC_KEY)
+                            arrayOf("MyHost", "local"),
+                            0L /* receiptTimeMillis */,
+                            true /* cacheFlush */,
+                            otherTtlMillis,
+                            TEST_PUBLIC_KEY
+                        )
                 ) /* answers */,
                 emptyList() /* authorityRecords */,
-                emptyList() /* additionalRecords */)
+                emptyList() /* additionalRecords */
+        )
 
-        assertEquals(emptyMap(),
-                repository.getConflictingServices(packet))
+        assertEquals(
+            emptyMap(),
+            repository.getConflictingServices(packet)
+        )
     }
 
     @Test
@@ -1576,24 +2437,29 @@ class MdnsRecordRepositoryTest {
         repository.addService(TEST_SERVICE_ID_1, NsdServiceInfo().apply {
             hostname = "MyHost"
             publicKey = TEST_PUBLIC_KEY
-        }, null /* ttl */)
+        }, DEFAULT_OPTION)
 
         val otherTtlMillis = 1234L
         val packet = MdnsPacket(
             0 /* flags */,
             emptyList() /* questions */,
-            listOf(MdnsInetAddressRecord(arrayOf("MyHost", "local"),
+            listOf(
+                MdnsInetAddressRecord(
+                    arrayOf("MyHost", "local"),
                     0L /* receiptTimeMillis */,
                     true /* cacheFlush */,
                     otherTtlMillis,
-                    parseNumericAddress("192.168.2.111"))
+                    parseNumericAddress("192.168.2.111")
+                )
             ) /* answers */,
             emptyList() /* authorityRecords */,
             emptyList() /* additionalRecords */
         )
 
-        assertEquals(mapOf(TEST_SERVICE_ID_1 to CONFLICT_HOST),
-            repository.getConflictingServices(packet))
+        assertEquals(
+            mapOf(TEST_SERVICE_ID_1 to CONFLICT_HOST),
+            repository.getConflictingServices(packet)
+        )
     }
 
     @Test
@@ -1606,7 +2472,7 @@ class MdnsRecordRepositoryTest {
                     parseNumericAddress("2001:db8::1"),
                     parseNumericAddress("2001:db8::2"))
             publicKey = TEST_PUBLIC_KEY
-        }, null /* ttl */)
+        }, DEFAULT_OPTION)
 
         val otherTtlMillis = 1234L
         val packet = MdnsPacket(
@@ -1614,16 +2480,21 @@ class MdnsRecordRepositoryTest {
                 emptyList() /* questions */,
                 listOf(
                         MdnsKeyRecord(
-                                arrayOf("MyHost", "local"),
-                                0L /* receiptTimeMillis */, true /* cacheFlush */,
-                                otherTtlMillis,
-                                TEST_PUBLIC_KEY_2)
+                            arrayOf("MyHost", "local"),
+                            0L /* receiptTimeMillis */,
+                            true /* cacheFlush */,
+                            otherTtlMillis,
+                            TEST_PUBLIC_KEY_2
+                        )
                 ) /* answers */,
                 emptyList() /* authorityRecords */,
-                emptyList() /* additionalRecords */)
+                emptyList() /* additionalRecords */
+        )
 
-        assertEquals(mapOf(TEST_SERVICE_ID_1 to CONFLICT_HOST),
-                repository.getConflictingServices(packet))
+        assertEquals(
+            mapOf(TEST_SERVICE_ID_1 to CONFLICT_HOST),
+            repository.getConflictingServices(packet)
+        )
     }
 
     @Test
@@ -1643,7 +2514,7 @@ class MdnsRecordRepositoryTest {
             port = TEST_PORT
             hostname = "MyHost"
             publicKey = TEST_PUBLIC_KEY
-        }, null /* ttl */)
+        }, DEFAULT_OPTION)
 
         // Although there's a KEY RR in the second registration being probed, it shouldn't conflict
         // with an address record which is from a probed registration in the repository.
@@ -1654,12 +2525,15 @@ class MdnsRecordRepositoryTest {
             listOf(
                 MdnsInetAddressRecord(
                     arrayOf("MyHost", "local"),
-                    0L /* receiptTimeMillis */, true /* cacheFlush */,
+                    0L /* receiptTimeMillis */,
+                    true /* cacheFlush */,
                     otherTtlMillis,
-                    parseNumericAddress("2001:db8::1"))
+                    parseNumericAddress("2001:db8::1")
+                )
             ) /* answers */,
             emptyList() /* authorityRecords */,
-            emptyList() /* additionalRecords */)
+            emptyList() /* additionalRecords */
+        )
 
         assertEquals(mapOf(), repository.getConflictingServices(packet))
     }
@@ -1667,8 +2541,8 @@ class MdnsRecordRepositoryTest {
     @Test
     fun testGetConflictingServices_IdenticalService() {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
-        repository.addService(TEST_SERVICE_ID_1, TEST_SERVICE_1, null /* ttl */)
-        repository.addService(TEST_SERVICE_ID_2, TEST_SERVICE_2, null /* ttl */)
+        repository.addService(TEST_SERVICE_ID_1, TEST_SERVICE_1, DEFAULT_OPTION)
+        repository.addService(TEST_SERVICE_ID_2, TEST_SERVICE_2, DEFAULT_OPTION)
 
         val otherTtlMillis = 1234L
         val packet = MdnsPacket(
@@ -1676,18 +2550,26 @@ class MdnsRecordRepositoryTest {
                 emptyList() /* questions */,
                 listOf(
                         MdnsServiceRecord(
-                                arrayOf("MyTestService", "_testservice", "_tcp", "local"),
-                                0L /* receiptTimeMillis */, true /* cacheFlush */,
-                                otherTtlMillis, 0 /* servicePriority */, 0 /* serviceWeight */,
-                                TEST_SERVICE_1.port,
-                                arrayOf("ANDROID_000102030405060708090A0B0C0D0E0F", "local")),
+                            arrayOf("MyTestService", "_testservice", "_tcp", "local"),
+                            0L /* receiptTimeMillis */,
+                            true /* cacheFlush */,
+                            otherTtlMillis,
+                            0 /* servicePriority */,
+                            0 /* serviceWeight */,
+                            TEST_SERVICE_1.port,
+                            arrayOf("ANDROID_000102030405060708090A0B0C0D0E0F", "local")
+                        ),
                         MdnsTextRecord(
-                                arrayOf("MyOtherTestService", "_testservice", "_tcp", "local"),
-                                0L /* receiptTimeMillis */, true /* cacheFlush */,
-                                otherTtlMillis, emptyList()),
+                            arrayOf("MyOtherTestService", "_testservice", "_tcp", "local"),
+                            0L /* receiptTimeMillis */,
+                            true /* cacheFlush */,
+                            otherTtlMillis,
+                            emptyList()
+                        ),
                 ) /* answers */,
                 emptyList() /* authorityRecords */,
-                emptyList() /* additionalRecords */)
+                emptyList() /* additionalRecords */
+        )
 
         // Above records are identical to the actual registrations: no conflict
         assertEquals(emptyMap(), repository.getConflictingServices(packet))
@@ -1696,8 +2578,8 @@ class MdnsRecordRepositoryTest {
     @Test
     fun testGetConflictingServicesCaseInsensitive_IdenticalService() {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
-        repository.addService(TEST_SERVICE_ID_1, TEST_SERVICE_1, null /* ttl */)
-        repository.addService(TEST_SERVICE_ID_2, TEST_SERVICE_2, null /* ttl */)
+        repository.addService(TEST_SERVICE_ID_1, TEST_SERVICE_1, DEFAULT_OPTION)
+        repository.addService(TEST_SERVICE_ID_2, TEST_SERVICE_2, DEFAULT_OPTION)
 
         val otherTtlMillis = 1234L
         val packet = MdnsPacket(
@@ -1705,18 +2587,26 @@ class MdnsRecordRepositoryTest {
                 emptyList() /* questions */,
                 listOf(
                         MdnsServiceRecord(
-                                arrayOf("MYTESTSERVICE", "_TESTSERVICE", "_tcp", "local"),
-                                0L /* receiptTimeMillis */, true /* cacheFlush */,
-                                otherTtlMillis, 0 /* servicePriority */, 0 /* serviceWeight */,
-                                TEST_SERVICE_1.port,
-                                TEST_HOSTNAME),
+                            arrayOf("MYTESTSERVICE", "_TESTSERVICE", "_tcp", "local"),
+                            0L /* receiptTimeMillis */,
+                            true /* cacheFlush */,
+                            otherTtlMillis,
+                            0 /* servicePriority */,
+                            0 /* serviceWeight */,
+                            TEST_SERVICE_1.port,
+                            TEST_HOSTNAME
+                        ),
                         MdnsTextRecord(
-                                arrayOf("MyOtherTestService", "_TESTSERVICE", "_tcp", "local"),
-                                0L /* receiptTimeMillis */, true /* cacheFlush */,
-                                otherTtlMillis, emptyList()),
+                            arrayOf("MyOtherTestService", "_TESTSERVICE", "_tcp", "local"),
+                            0L /* receiptTimeMillis */,
+                            true /* cacheFlush */,
+                            otherTtlMillis,
+                            emptyList()
+                        ),
                 ) /* answers */,
                 emptyList() /* authorityRecords */,
-                emptyList() /* additionalRecords */)
+                emptyList() /* additionalRecords */
+        )
 
         // Above records are identical to the actual registrations: no conflict
         assertEquals(emptyMap(), repository.getConflictingServices(packet))
@@ -1751,13 +2641,21 @@ class MdnsRecordRepositoryTest {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
         repository.initWithService(TEST_SERVICE_ID_1, TEST_SERVICE_1)
         // Verify that there is no packet replied.
-        assertEquals(MdnsConstants.NO_PACKET,
-                repository.getServiceRepliedRequestsCount(TEST_SERVICE_ID_1))
+        assertEquals(
+            MdnsConstants.NO_PACKET,
+            repository.getServiceRepliedRequestsCount(TEST_SERVICE_ID_1)
+        )
 
         val questions = listOf(
-                MdnsPointerRecord(arrayOf("_testservice", "_tcp", "local"), false /* isUnicast */))
-        val query = MdnsPacket(0 /* flags */, questions, emptyList() /* answers */,
-                emptyList() /* authorityRecords */, emptyList() /* additionalRecords */)
+                MdnsPointerRecord(arrayOf("_testservice", "_tcp", "local"), false /* isUnicast */)
+        )
+        val query = MdnsPacket(
+            0 /* flags */,
+            questions,
+            emptyList() /* answers */,
+            emptyList() /* authorityRecords */,
+            emptyList() /* additionalRecords */
+        )
         val src = InetSocketAddress(parseNumericAddress("192.0.2.123"), 5353)
 
         // Reply to the question and verify there is one packet replied.
@@ -1766,18 +2664,26 @@ class MdnsRecordRepositoryTest {
         assertEquals(1, repository.getServiceRepliedRequestsCount(TEST_SERVICE_ID_1))
 
         // No package replied for unknown service.
-        assertEquals(MdnsConstants.NO_PACKET,
-                repository.getServiceRepliedRequestsCount(TEST_SERVICE_ID_2))
+        assertEquals(
+            MdnsConstants.NO_PACKET,
+            repository.getServiceRepliedRequestsCount(TEST_SERVICE_ID_2)
+        )
     }
 
     @Test
     fun testIncludeInetAddressRecordsInProbing() {
-        val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME,
-            makeFlags(includeInetAddressesInProbing = true))
+        val repository = MdnsRecordRepository(
+            thread.looper,
+            deps,
+            TEST_HOSTNAME,
+            makeFlags(includeInetAddressesInProbing = true)
+        )
         repository.updateAddresses(TEST_ADDRESSES)
         assertEquals(0, repository.servicesCount)
-        assertEquals(-1,
-                repository.addService(TEST_SERVICE_ID_1, TEST_SERVICE_1, null /* ttl */))
+        assertEquals(
+            -1,
+            repository.addService(TEST_SERVICE_ID_1, TEST_SERVICE_1, DEFAULT_OPTION)
+        )
         assertEquals(1, repository.servicesCount)
 
         val probingInfo = repository.setServiceProbing(TEST_SERVICE_ID_1)
@@ -1808,25 +2714,29 @@ class MdnsRecordRepositoryTest {
                 0 /* servicePriority */,
                 0 /* serviceWeight */,
                 TEST_PORT,
-                TEST_HOSTNAME),
+                TEST_HOSTNAME
+            ),
             MdnsInetAddressRecord(
                 TEST_HOSTNAME,
                 0L /* receiptTimeMillis */,
                 false /* cacheFlush */,
                 SHORT_TTL /* ttlMillis */,
-                TEST_ADDRESSES[0].address),
+                TEST_ADDRESSES[0].address
+            ),
             MdnsInetAddressRecord(
                 TEST_HOSTNAME,
                 0L /* receiptTimeMillis */,
                 false /* cacheFlush */,
                 SHORT_TTL /* ttlMillis */,
-                TEST_ADDRESSES[1].address),
+                TEST_ADDRESSES[1].address
+            ),
             MdnsInetAddressRecord(
                 TEST_HOSTNAME,
                 0L /* receiptTimeMillis */,
                 false /* cacheFlush */,
                 SHORT_TTL /* ttlMillis */,
-                TEST_ADDRESSES[2].address)
+                TEST_ADDRESSES[2].address
+            )
         ), packet.authorityRecords)
 
         assertContentEquals(intArrayOf(TEST_SERVICE_ID_1), repository.clearServices())
@@ -1838,11 +2748,20 @@ class MdnsRecordRepositoryTest {
             replyAnswers: List<MdnsRecord>,
             additionalAnswers: List<MdnsRecord>
     ) {
-        val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME,
-            makeFlags(isKnownAnswerSuppressionEnabled = true))
+        val repository = MdnsRecordRepository(
+            thread.looper,
+            deps,
+            TEST_HOSTNAME,
+            makeFlags(isKnownAnswerSuppressionEnabled = true)
+        )
         repository.initWithService(TEST_SERVICE_ID_1, TEST_SERVICE_1)
-        val query = MdnsPacket(0 /* flags */, questions, knownAnswers,
-                emptyList() /* authorityRecords */, emptyList() /* additionalRecords */)
+        val query = MdnsPacket(
+            0 /* flags */,
+            questions,
+            knownAnswers,
+            emptyList() /* authorityRecords */,
+            emptyList() /* additionalRecords */
+        )
         val src = InetSocketAddress(parseNumericAddress("192.0.2.123"), 5353)
         val reply = repository.getReply(query, src)
 
@@ -1869,9 +2788,14 @@ class MdnsRecordRepositoryTest {
                 0L /* receiptTimeMillis */,
                 false /* cacheFlush */,
                 LONG_TTL,
-                arrayOf("MyTestService", "_testservice", "_tcp", "local")))
-        doGetReplyWithAnswersTest(questions, knownAnswers, emptyList() /* replyAnswers */,
-                emptyList() /* additionalAnswers */)
+                arrayOf("MyTestService", "_testservice", "_tcp", "local")
+        ))
+        doGetReplyWithAnswersTest(
+            questions,
+            knownAnswers,
+            emptyList() /* replyAnswers */,
+            emptyList() /* additionalAnswers */
+        )
     }
 
     @Test
@@ -1884,20 +2808,23 @@ class MdnsRecordRepositoryTest {
                 0L /* receiptTimeMillis */,
                 false /* cacheFlush */,
                 (LONG_TTL / 2 - 1000L),
-                arrayOf("MyTestService", "_testservice", "_tcp", "local")))
+                arrayOf("MyTestService", "_testservice", "_tcp", "local")
+        ))
         val replyAnswers = listOf(MdnsPointerRecord(
                 queriedName,
                 0L /* receiptTimeMillis */,
                 false /* cacheFlush */,
                 LONG_TTL,
-                serviceName))
+                serviceName
+        ))
         val additionalAnswers = listOf(
                 MdnsTextRecord(
                         serviceName,
                         0L /* receiptTimeMillis */,
                         true /* cacheFlush */,
                         LONG_TTL,
-                        emptyList() /* entries */),
+                        emptyList() /* entries */
+                ),
                 MdnsServiceRecord(
                         serviceName,
                         0L /* receiptTimeMillis */,
@@ -1906,39 +2833,46 @@ class MdnsRecordRepositoryTest {
                         0 /* servicePriority */,
                         0 /* serviceWeight */,
                         TEST_PORT,
-                        TEST_HOSTNAME),
+                        TEST_HOSTNAME
+                ),
                 MdnsInetAddressRecord(
                         TEST_HOSTNAME,
                         0L /* receiptTimeMillis */,
                         true /* cacheFlush */,
                         SHORT_TTL,
-                        TEST_ADDRESSES[0].address),
+                        TEST_ADDRESSES[0].address
+                ),
                 MdnsInetAddressRecord(
                         TEST_HOSTNAME,
                         0L /* receiptTimeMillis */,
                         true /* cacheFlush */,
                         SHORT_TTL,
-                        TEST_ADDRESSES[1].address),
+                        TEST_ADDRESSES[1].address
+                ),
                 MdnsInetAddressRecord(
                         TEST_HOSTNAME,
                         0L /* receiptTimeMillis */,
                         true /* cacheFlush */,
                         SHORT_TTL,
-                        TEST_ADDRESSES[2].address),
+                        TEST_ADDRESSES[2].address
+                ),
                 MdnsNsecRecord(
                         serviceName,
                         0L /* receiptTimeMillis */,
                         true /* cacheFlush */,
                         LONG_TTL,
                         serviceName /* nextDomain */,
-                        intArrayOf(MdnsRecord.TYPE_TXT, MdnsRecord.TYPE_SRV)),
+                        intArrayOf(MdnsRecord.TYPE_TXT, MdnsRecord.TYPE_SRV)
+                ),
                 MdnsNsecRecord(
                         TEST_HOSTNAME,
                         0L /* receiptTimeMillis */,
                         true /* cacheFlush */,
                         SHORT_TTL,
                         TEST_HOSTNAME /* nextDomain */,
-                        intArrayOf(MdnsRecord.TYPE_A, MdnsRecord.TYPE_AAAA)))
+                        intArrayOf(MdnsRecord.TYPE_A, MdnsRecord.TYPE_AAAA)
+                )
+        )
         doGetReplyWithAnswersTest(questions, knownAnswers, replyAnswers, additionalAnswers)
     }
 
@@ -1952,20 +2886,23 @@ class MdnsRecordRepositoryTest {
                 0L /* receiptTimeMillis */,
                 false /* cacheFlush */,
                 LONG_TTL,
-                arrayOf("MyOtherTestService", "_testservice", "_tcp", "local")))
+                arrayOf("MyOtherTestService", "_testservice", "_tcp", "local")
+        ))
         val replyAnswers = listOf(MdnsPointerRecord(
                 queriedName,
                 0L /* receiptTimeMillis */,
                 false /* cacheFlush */,
                 LONG_TTL,
-                serviceName))
+                serviceName
+        ))
         val additionalAnswers = listOf(
                 MdnsTextRecord(
                         serviceName,
                         0L /* receiptTimeMillis */,
                         true /* cacheFlush */,
                         LONG_TTL,
-                        emptyList() /* entries */),
+                        emptyList() /* entries */
+                ),
                 MdnsServiceRecord(
                         serviceName,
                         0L /* receiptTimeMillis */,
@@ -1974,39 +2911,46 @@ class MdnsRecordRepositoryTest {
                         0 /* servicePriority */,
                         0 /* serviceWeight */,
                         TEST_PORT,
-                        TEST_HOSTNAME),
+                        TEST_HOSTNAME
+                ),
                 MdnsInetAddressRecord(
                         TEST_HOSTNAME,
                         0L /* receiptTimeMillis */,
                         true /* cacheFlush */,
                         SHORT_TTL,
-                        TEST_ADDRESSES[0].address),
+                        TEST_ADDRESSES[0].address
+                ),
                 MdnsInetAddressRecord(
                         TEST_HOSTNAME,
                         0L /* receiptTimeMillis */,
                         true /* cacheFlush */,
                         SHORT_TTL,
-                        TEST_ADDRESSES[1].address),
+                        TEST_ADDRESSES[1].address
+                ),
                 MdnsInetAddressRecord(
                         TEST_HOSTNAME,
                         0L /* receiptTimeMillis */,
                         true /* cacheFlush */,
                         SHORT_TTL,
-                        TEST_ADDRESSES[2].address),
+                        TEST_ADDRESSES[2].address
+                ),
                 MdnsNsecRecord(
                         serviceName,
                         0L /* receiptTimeMillis */,
                         true /* cacheFlush */,
                         LONG_TTL,
                         serviceName /* nextDomain */,
-                        intArrayOf(MdnsRecord.TYPE_TXT, MdnsRecord.TYPE_SRV)),
+                        intArrayOf(MdnsRecord.TYPE_TXT, MdnsRecord.TYPE_SRV)
+                ),
                 MdnsNsecRecord(
                         TEST_HOSTNAME,
                         0L /* receiptTimeMillis */,
                         true /* cacheFlush */,
                         SHORT_TTL,
                         TEST_HOSTNAME /* nextDomain */,
-                        intArrayOf(MdnsRecord.TYPE_A, MdnsRecord.TYPE_AAAA)))
+                        intArrayOf(MdnsRecord.TYPE_A, MdnsRecord.TYPE_AAAA)
+                )
+        )
         doGetReplyWithAnswersTest(questions, knownAnswers, replyAnswers, additionalAnswers)
     }
 
@@ -2016,13 +2960,15 @@ class MdnsRecordRepositoryTest {
         val serviceName = arrayOf("MyTestService", "_testservice", "_tcp", "local")
         val questions = listOf(
                 MdnsPointerRecord(queriedName, false /* isUnicast */),
-                MdnsServiceRecord(serviceName, false /* isUnicast */))
+                MdnsServiceRecord(serviceName, false /* isUnicast */)
+        )
         val knownAnswers = listOf(MdnsPointerRecord(
                 queriedName,
                 0L /* receiptTimeMillis */,
                 false /* cacheFlush */,
                 LONG_TTL - 1000L,
-                serviceName))
+                serviceName
+        ))
         val replyAnswers = listOf(MdnsServiceRecord(
                 serviceName,
                 0L /* receiptTimeMillis */,
@@ -2031,33 +2977,39 @@ class MdnsRecordRepositoryTest {
                 0 /* servicePriority */,
                 0 /* serviceWeight */,
                 TEST_PORT,
-                TEST_HOSTNAME))
+                TEST_HOSTNAME
+        ))
         val additionalAnswers = listOf(
                 MdnsInetAddressRecord(
                         TEST_HOSTNAME,
                         0L /* receiptTimeMillis */,
                         true /* cacheFlush */,
                         SHORT_TTL,
-                        TEST_ADDRESSES[0].address),
+                        TEST_ADDRESSES[0].address
+                ),
                 MdnsInetAddressRecord(
                         TEST_HOSTNAME,
                         0L /* receiptTimeMillis */,
                         true /* cacheFlush */,
                         SHORT_TTL,
-                        TEST_ADDRESSES[1].address),
+                        TEST_ADDRESSES[1].address
+                ),
                 MdnsInetAddressRecord(
                         TEST_HOSTNAME,
                         0L /* receiptTimeMillis */,
                         true /* cacheFlush */,
                         SHORT_TTL,
-                        TEST_ADDRESSES[2].address),
+                        TEST_ADDRESSES[2].address
+                ),
                 MdnsNsecRecord(
                         TEST_HOSTNAME,
                         0L /* receiptTimeMillis */,
                         true /* cacheFlush */,
                         SHORT_TTL,
                         TEST_HOSTNAME /* nextDomain */,
-                        intArrayOf(MdnsRecord.TYPE_A, MdnsRecord.TYPE_AAAA)))
+                        intArrayOf(MdnsRecord.TYPE_A, MdnsRecord.TYPE_AAAA)
+                )
+        )
         doGetReplyWithAnswersTest(questions, knownAnswers, replyAnswers, additionalAnswers)
     }
 
@@ -2067,7 +3019,8 @@ class MdnsRecordRepositoryTest {
         val serviceName = arrayOf("MyTestService", "_testservice", "_tcp", "local")
         val questions = listOf(
                 MdnsPointerRecord(queriedName, false /* isUnicast */),
-                MdnsServiceRecord(serviceName, false /* isUnicast */))
+                MdnsServiceRecord(serviceName, false /* isUnicast */)
+        )
         val knownAnswers = listOf(
             MdnsPointerRecord(
                 queriedName,
@@ -2087,8 +3040,12 @@ class MdnsRecordRepositoryTest {
                 TEST_HOSTNAME
             )
         )
-        doGetReplyWithAnswersTest(questions, knownAnswers, emptyList() /* replyAnswers */,
-                emptyList() /* additionalAnswers */)
+        doGetReplyWithAnswersTest(
+            questions,
+            knownAnswers,
+            emptyList() /* replyAnswers */,
+            emptyList() /* additionalAnswers */
+        )
     }
 
     @Test
@@ -2099,9 +3056,15 @@ class MdnsRecordRepositoryTest {
         // Ask for 2 services, only the first one is known and requests unicast reply
         val questions = listOf(
             MdnsPointerRecord(arrayOf("_testservice", "_tcp", "local"), true /* isUnicast */),
-            MdnsPointerRecord(arrayOf("_otherservice", "_tcp", "local"), true /* isUnicast */))
-        val query = MdnsPacket(0 /* flags */, questions, emptyList() /* answers */,
-                emptyList() /* authorityRecords */, emptyList() /* additionalRecords */)
+            MdnsPointerRecord(arrayOf("_otherservice", "_tcp", "local"), true /* isUnicast */)
+        )
+        val query = MdnsPacket(
+            0 /* flags */,
+            questions,
+            emptyList() /* answers */,
+            emptyList() /* authorityRecords */,
+            emptyList() /* additionalRecords */
+        )
         val src = InetSocketAddress(parseNumericAddress("2001:db8::123"), 5353)
 
         // Reply to the question and verify it is sent to the source.
@@ -2123,9 +3086,15 @@ class MdnsRecordRepositoryTest {
         // Ask for 2 services, both are known and only the first one requests unicast reply
         val questions = listOf(
             MdnsPointerRecord(arrayOf("_testservice", "_tcp", "local"), true /* isUnicast */),
-            MdnsPointerRecord(arrayOf("_otherservice", "_tcp", "local"), false /* isUnicast */))
-        val query = MdnsPacket(0 /* flags */, questions, emptyList() /* answers */,
-                emptyList() /* authorityRecords */, emptyList() /* additionalRecords */)
+            MdnsPointerRecord(arrayOf("_otherservice", "_tcp", "local"), false /* isUnicast */)
+        )
+        val query = MdnsPacket(
+            0 /* flags */,
+            questions,
+            emptyList() /* answers */,
+            emptyList() /* authorityRecords */,
+            emptyList() /* additionalRecords */
+        )
         val src = InetSocketAddress(parseNumericAddress("2001:db8::123"), 5353)
 
         // Reply to the question and verify it is sent multicast.
@@ -2142,9 +3111,15 @@ class MdnsRecordRepositoryTest {
         // Ask for 2 services, the first one requests a unicast reply but is unknown
         val questions = listOf(
             MdnsPointerRecord(arrayOf("_otherservice", "_tcp", "local"), true /* isUnicast */),
-            MdnsPointerRecord(arrayOf("_testservice", "_tcp", "local"), false /* isUnicast */))
-        val query = MdnsPacket(0 /* flags */, questions, emptyList() /* answers */,
-                emptyList() /* authorityRecords */, emptyList() /* additionalRecords */)
+            MdnsPointerRecord(arrayOf("_testservice", "_tcp", "local"), false /* isUnicast */)
+        )
+        val query = MdnsPacket(
+            0 /* flags */,
+            questions,
+            emptyList() /* answers */,
+            emptyList() /* authorityRecords */,
+            emptyList() /* additionalRecords */
+        )
         val src = InetSocketAddress(parseNumericAddress("2001:db8::123"), 5353)
 
         // Reply to the question and verify it is sent multicast.
@@ -2155,15 +3130,25 @@ class MdnsRecordRepositoryTest {
 
     @Test
     fun testReplyMulticastWhenUnicastFeatureDisabled() {
-        val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME,
-            makeFlags(unicastReplyEnabled = false))
+        val repository = MdnsRecordRepository(
+            thread.looper,
+            deps,
+            TEST_HOSTNAME,
+            makeFlags(unicastReplyEnabled = false)
+        )
         repository.initWithService(TEST_SERVICE_ID_1, TEST_SERVICE_1)
 
         // The service is known and requests unicast reply, but the feature is disabled
         val questions = listOf(
-            MdnsPointerRecord(arrayOf("_testservice", "_tcp", "local"), true /* isUnicast */))
-        val query = MdnsPacket(0 /* flags */, questions, emptyList() /* answers */,
-                emptyList() /* authorityRecords */, emptyList() /* additionalRecords */)
+            MdnsPointerRecord(arrayOf("_testservice", "_tcp", "local"), true /* isUnicast */)
+        )
+        val query = MdnsPacket(
+            0 /* flags */,
+            questions,
+            emptyList() /* answers */,
+            emptyList() /* authorityRecords */,
+            emptyList() /* additionalRecords */
+        )
         val src = InetSocketAddress(parseNumericAddress("2001:db8::123"), 5353)
 
         // Reply to the question and verify it is sent multicast.
@@ -2174,18 +3159,27 @@ class MdnsRecordRepositoryTest {
 
     @Test
     fun testGetReply_OnlyKnownAnswers() {
-        val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME,
-                makeFlags(isKnownAnswerSuppressionEnabled = true))
+        val repository = MdnsRecordRepository(
+            thread.looper,
+            deps,
+            TEST_HOSTNAME,
+            makeFlags(isKnownAnswerSuppressionEnabled = true)
+        )
         repository.initWithService(TEST_SERVICE_ID_1, TEST_SERVICE_1)
         val knownAnswers = listOf(MdnsPointerRecord(
                 arrayOf("_testservice", "_tcp", "local"),
                 0L /* receiptTimeMillis */,
                 false /* cacheFlush */,
                 LONG_TTL - 1000L,
-                arrayOf("MyTestService", "_testservice", "_tcp", "local")))
-        val query = MdnsPacket(MdnsConstants.FLAG_TRUNCATED /* flags */, emptyList(),
-                knownAnswers, emptyList() /* authorityRecords */,
-                emptyList() /* additionalRecords */)
+                arrayOf("MyTestService", "_testservice", "_tcp", "local")
+        ))
+        val query = MdnsPacket(
+            MdnsConstants.FLAG_TRUNCATED /* flags */,
+            emptyList(),
+            knownAnswers,
+            emptyList() /* authorityRecords */,
+            emptyList() /* additionalRecords */
+        )
         val src = InetSocketAddress(parseNumericAddress("192.0.2.123"), 5353)
         val reply = repository.getReply(query, src)
         assertNotNull(reply)
@@ -2237,10 +3231,16 @@ class MdnsRecordRepositoryTest {
     @Test
     fun testRestartProbingForHostname() {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
-        repository.initWithService(TEST_CUSTOM_HOST_ID_1, TEST_CUSTOM_HOST_1,
-                setOf(TEST_SUBTYPE, TEST_SUBTYPE2))
-        repository.addService(TEST_SERVICE_CUSTOM_HOST_ID_1,
-                TEST_SERVICE_CUSTOM_HOST_NO_ADDRESSES, null)
+        repository.initWithService(
+            TEST_CUSTOM_HOST_ID_1,
+            TEST_CUSTOM_HOST_1,
+            setOf(TEST_SUBTYPE, TEST_SUBTYPE2)
+        )
+        repository.addService(
+            TEST_SERVICE_CUSTOM_HOST_ID_1,
+            TEST_SERVICE_CUSTOM_HOST_NO_ADDRESSES,
+            DEFAULT_OPTION
+        )
         repository.setServiceProbing(TEST_SERVICE_CUSTOM_HOST_ID_1)
         repository.removeService(TEST_CUSTOM_HOST_ID_1)
 
@@ -2266,16 +3266,23 @@ class MdnsRecordRepositoryTest {
                         0 /* servicePriority */,
                         0 /* serviceWeight */,
                         TEST_PORT,
-                        TEST_CUSTOM_HOST_1_NAME))
+                        TEST_CUSTOM_HOST_1_NAME
+                )
+        )
     }
 
     @Test
     fun testRestartAnnouncingForHostname() {
         val repository = MdnsRecordRepository(thread.looper, deps, TEST_HOSTNAME, makeFlags())
-        repository.initWithService(TEST_CUSTOM_HOST_ID_1, TEST_CUSTOM_HOST_1,
-                setOf(TEST_SUBTYPE, TEST_SUBTYPE2))
-        repository.addServiceAndFinishProbing(TEST_SERVICE_CUSTOM_HOST_ID_1,
-                TEST_SERVICE_CUSTOM_HOST_NO_ADDRESSES)
+        repository.initWithService(
+            TEST_CUSTOM_HOST_ID_1,
+            TEST_CUSTOM_HOST_1,
+            setOf(TEST_SUBTYPE, TEST_SUBTYPE2)
+        )
+        repository.addServiceAndFinishProbing(
+            TEST_SERVICE_CUSTOM_HOST_ID_1,
+            TEST_SERVICE_CUSTOM_HOST_NO_ADDRESSES
+        )
         repository.removeService(TEST_CUSTOM_HOST_ID_1)
 
         val announcementInfos = repository.restartAnnouncingForHostname("TestHost")
@@ -2300,7 +3307,8 @@ class MdnsRecordRepositoryTest {
                         // Not a unique name owned by the announcer, so cacheFlush=false
                         false /* cacheFlush */,
                         4500000L /* ttlMillis */,
-                        serviceName),
+                        serviceName
+                ),
                 MdnsServiceRecord(
                         serviceName,
                         0L /* receiptTimeMillis */,
@@ -2309,50 +3317,65 @@ class MdnsRecordRepositoryTest {
                         0 /* servicePriority */,
                         0 /* serviceWeight */,
                         TEST_PORT /* servicePort */,
-                        TEST_CUSTOM_HOST_1_NAME),
+                        TEST_CUSTOM_HOST_1_NAME
+                ),
                 MdnsTextRecord(
                         serviceName,
                         0L /* receiptTimeMillis */,
                         true /* cacheFlush */,
                         4500000L /* ttlMillis */,
-                        emptyList() /* entries */),
+                        emptyList() /* entries */
+                ),
                 MdnsPointerRecord(
                         arrayOf("_services", "_dns-sd", "_udp", "local"),
                         0L /* receiptTimeMillis */,
                         false /* cacheFlush */,
                         4500000L /* ttlMillis */,
-                        serviceType))
+                        serviceType
+                )
+        )
         assertThat(packet.additionalRecords).containsExactly(
-                MdnsNsecRecord(v4AddrRev,
-                        0L /* receiptTimeMillis */,
-                        true /* cacheFlush */,
-                        120000L /* ttlMillis */,
-                        v4AddrRev,
-                        intArrayOf(TYPE_PTR)),
-                MdnsNsecRecord(TEST_HOSTNAME,
-                        0L /* receiptTimeMillis */,
-                        true /* cacheFlush */,
-                        120000L /* ttlMillis */,
-                        TEST_HOSTNAME,
-                        intArrayOf(TYPE_A, TYPE_AAAA)),
-                MdnsNsecRecord(v6Addr1Rev,
-                        0L /* receiptTimeMillis */,
-                        true /* cacheFlush */,
-                        120000L /* ttlMillis */,
-                        v6Addr1Rev,
-                        intArrayOf(TYPE_PTR)),
-                MdnsNsecRecord(v6Addr2Rev,
-                        0L /* receiptTimeMillis */,
-                        true /* cacheFlush */,
-                        120000L /* ttlMillis */,
-                        v6Addr2Rev,
-                        intArrayOf(TYPE_PTR)),
-                MdnsNsecRecord(serviceName,
-                        0L /* receiptTimeMillis */,
-                        true /* cacheFlush */,
-                        4500000L /* ttlMillis */,
-                        serviceName,
-                        intArrayOf(TYPE_TXT, TYPE_SRV)))
+                MdnsNsecRecord(
+                    v4AddrRev,
+                    0L /* receiptTimeMillis */,
+                    true /* cacheFlush */,
+                    120000L /* ttlMillis */,
+                    v4AddrRev,
+                    intArrayOf(TYPE_PTR)
+                ),
+                MdnsNsecRecord(
+                    TEST_HOSTNAME,
+                    0L /* receiptTimeMillis */,
+                    true /* cacheFlush */,
+                    120000L /* ttlMillis */,
+                    TEST_HOSTNAME,
+                    intArrayOf(TYPE_A, TYPE_AAAA)
+                ),
+                MdnsNsecRecord(
+                    v6Addr1Rev,
+                    0L /* receiptTimeMillis */,
+                    true /* cacheFlush */,
+                    120000L /* ttlMillis */,
+                    v6Addr1Rev,
+                    intArrayOf(TYPE_PTR)
+                ),
+                MdnsNsecRecord(
+                    v6Addr2Rev,
+                    0L /* receiptTimeMillis */,
+                    true /* cacheFlush */,
+                    120000L /* ttlMillis */,
+                    v6Addr2Rev,
+                    intArrayOf(TYPE_PTR)
+                ),
+                MdnsNsecRecord(
+                    serviceName,
+                    0L /* receiptTimeMillis */,
+                    true /* cacheFlush */,
+                    4500000L /* ttlMillis */,
+                    serviceName,
+                    intArrayOf(TYPE_TXT, TYPE_SRV)
+                )
+        )
     }
 }
 
@@ -2360,18 +3383,20 @@ private fun MdnsRecordRepository.initWithService(
     serviceId: Int,
     serviceInfo: NsdServiceInfo,
     subtypes: Set<String> = setOf(),
-    addresses: List<LinkAddress> = TEST_ADDRESSES
+    addresses: List<LinkAddress> = TEST_ADDRESSES,
+    option: MdnsAdvertisingOptions = DEFAULT_OPTION
 ): AnnouncementInfo {
     updateAddresses(addresses)
     serviceInfo.setSubtypes(subtypes)
-    return addServiceAndFinishProbing(serviceId, serviceInfo)
+    return addServiceAndFinishProbing(serviceId, serviceInfo, option)
 }
 
 private fun MdnsRecordRepository.addServiceAndFinishProbing(
     serviceId: Int,
-    serviceInfo: NsdServiceInfo
+    serviceInfo: NsdServiceInfo,
+    option: MdnsAdvertisingOptions = DEFAULT_OPTION
 ): AnnouncementInfo {
-    addService(serviceId, serviceInfo, null /* ttl */)
+    addService(serviceId, serviceInfo, option)
     val probingInfo = setServiceProbing(serviceId)
     assertNotNull(probingInfo)
     return onProbingSucceeded(probingInfo)
diff --git a/tests/unit/java/com/android/server/connectivity/mdns/MdnsRecordTests.java b/tests/unit/java/com/android/server/connectivity/mdns/MdnsRecordTests.java
index 784c50282f..789a9bd3ab 100644
--- a/tests/unit/java/com/android/server/connectivity/mdns/MdnsRecordTests.java
+++ b/tests/unit/java/com/android/server/connectivity/mdns/MdnsRecordTests.java
@@ -17,7 +17,6 @@
 package com.android.server.connectivity.mdns;
 
 import static com.android.server.connectivity.mdns.MdnsConstants.QCLASS_INTERNET;
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
 
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
@@ -30,6 +29,7 @@ import static org.junit.Assert.assertTrue;
 
 import static java.util.Collections.emptyList;
 
+import android.os.Build;
 import android.util.Log;
 
 import com.android.net.module.util.HexDump;
@@ -51,7 +51,7 @@ import java.util.List;
 // The record test data does not use compressed names (label pointers), since that would require
 // additional data to populate the label dictionary accordingly.
 @RunWith(DevSdkIgnoreRunner.class)
-@DevSdkIgnoreRule.IgnoreUpTo(SC_V2)
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 public class MdnsRecordTests {
     private static final String TAG = "MdnsRecordTests";
     private static final int MAX_PACKET_SIZE = 4096;
@@ -352,14 +352,6 @@ public class MdnsRecordTests {
 
         MdnsTextRecord record = new MdnsTextRecord(name, reader);
 
-        List<String> strings = record.getStrings();
-        assertNotNull(strings);
-        assertEquals(3, strings.size());
-
-        assertEquals("a=hello there", strings.get(0));
-        assertEquals("b=1234567890", strings.get(1));
-        assertEquals("xyz=!@#$", strings.get(2));
-
         List<TextEntry> entries = record.getEntries();
         assertNotNull(entries);
         assertEquals(3, entries.size());
diff --git a/tests/unit/java/com/android/server/connectivity/mdns/MdnsReplySenderTest.kt b/tests/unit/java/com/android/server/connectivity/mdns/MdnsReplySenderTest.kt
index 9bd0530108..53e5e28eb2 100644
--- a/tests/unit/java/com/android/server/connectivity/mdns/MdnsReplySenderTest.kt
+++ b/tests/unit/java/com/android/server/connectivity/mdns/MdnsReplySenderTest.kt
@@ -28,11 +28,13 @@ import com.android.server.connectivity.mdns.MdnsConstants.IPV6_SOCKET_ADDR
 import com.android.server.connectivity.mdns.MdnsReplySender.getReplyDestination
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
 import com.android.testutils.DevSdkIgnoreRunner
+import java.io.IOException
 import java.net.DatagramPacket
 import java.net.InetSocketAddress
 import java.util.concurrent.CompletableFuture
 import java.util.concurrent.TimeUnit
 import kotlin.test.assertEquals
+import kotlin.test.assertFailsWith
 import org.junit.After
 import org.junit.Before
 import org.junit.Test
@@ -41,9 +43,12 @@ import org.mockito.ArgumentCaptor
 import org.mockito.Mockito.any
 import org.mockito.Mockito.anyLong
 import org.mockito.Mockito.argThat
+import org.mockito.Mockito.doCallRealMethod
 import org.mockito.Mockito.doReturn
+import org.mockito.Mockito.doThrow
 import org.mockito.Mockito.eq
 import org.mockito.Mockito.mock
+import org.mockito.Mockito.never
 import org.mockito.Mockito.timeout
 import org.mockito.Mockito.times
 import org.mockito.Mockito.verify
@@ -107,6 +112,23 @@ class MdnsReplySenderTest {
             MdnsNsecRecord(otherHostname, 0L /* receiptTimeMillis */, true /* cacheFlush */,
                     SHORT_TTL, otherHostname /* nextDomain */,
                     intArrayOf(MdnsRecord.TYPE_A, MdnsRecord.TYPE_AAAA)))
+    private val manyServiceNames = (1..30).map {
+        arrayOf("MyTestService", "_testservice", "_tcp", "local")
+    }
+    private val manyAnswers = manyServiceNames.map {
+        MdnsPointerRecord(it, 0L /* receiptTimeMillis */, false /* cacheFlush */, LONG_TTL, it)
+    }
+    private val manyAdditionalAnswers = manyServiceNames.flatMap {
+        listOf(
+            MdnsTextRecord(it, 0L /* receiptTimeMillis */, true /* cacheFlush */, LONG_TTL,
+                    emptyList()),
+            MdnsServiceRecord(it, 0L /* receiptTimeMillis */, true /* cacheFlush */, SHORT_TTL,
+                    0 /* servicePriority */, 0 /* serviceWeight */, TEST_PORT, it),
+            MdnsNsecRecord(it, 0L /* receiptTimeMillis */, true /* cacheFlush */, LONG_TTL,
+                    it /* nextDomain */,
+                    intArrayOf(MdnsRecord.TYPE_TXT, MdnsRecord.TYPE_SRV))
+        )
+    }
     private val thread = HandlerThread(MdnsReplySenderTest::class.simpleName)
     private val socket = mock(MdnsInterfaceSocket::class.java)
     private val buffer = ByteArray(1500)
@@ -119,6 +141,7 @@ class MdnsReplySenderTest {
         thread.start()
         doReturn(true).`when`(socket).hasJoinedIpv4()
         doReturn(true).`when`(socket).hasJoinedIpv6()
+        doCallRealMethod().`when`(deps).createRawDnsPacket(any(), any())
     }
 
     @After
@@ -162,6 +185,47 @@ class MdnsReplySenderTest {
         verify(socket).send(argThat{ it.socketAddress.equals(IPV4_SOCKET_ADDR) })
     }
 
+    @Test
+    fun testSendNow_CreateRawDnsPacketThrowsGeneralIOException_PacketIsNotSent() {
+        val replySender = createSender(enableKAS = false)
+        val packet = MdnsPacket(0x8400,
+                emptyList() /* questions */,
+                answers,
+                emptyList() /* authorityRecords */,
+                additionalAnswers)
+        doThrow(IOException()).`when`(deps).createRawDnsPacket(any(), any())
+        val future = CompletableFuture<Unit>()
+        handler.post {
+            assertFailsWith<IOException> {
+                replySender.sendNow(packet, IPV4_SOCKET_ADDR)
+            }
+            future.complete(null)
+        }
+        future.get(DEFAULT_TIMEOUT_MS, TimeUnit.MILLISECONDS)
+        verify(socket, never()).send(any())
+    }
+
+    @Test
+    fun testSendNow_PacketIsTooLarge_AdditionalRecordsAreTruncated() {
+        val replySender = createSender(enableKAS = false)
+        // The datagram is 2059 bytes which exceeds the 1500 byte limit.
+        val packet = MdnsPacket(0x8400,
+                emptyList() /* questions */,
+                manyAnswers,
+                emptyList() /* authorityRecords */,
+                manyAdditionalAnswers)
+        sendNow(replySender, packet, IPV4_SOCKET_ADDR)
+        verify(socket).send(argThat{
+            val packet = MdnsPacket.parse(MdnsPacketReader(it))
+
+            packet.questions.isEmpty() &&
+            packet.answers.equals(manyAnswers) &&
+            packet.authorityRecords.isEmpty() &&
+            packet.additionalRecords.isEmpty() &&
+            it.socketAddress.equals(IPV4_SOCKET_ADDR)
+        })
+    }
+
     private fun verifyMessageQueued(
             sender: MdnsReplySender,
             replies: List<MdnsReplyInfo>
diff --git a/tests/unit/java/com/android/server/connectivity/mdns/MdnsResponseDecoderTests.java b/tests/unit/java/com/android/server/connectivity/mdns/MdnsResponseDecoderTests.java
index a22e8c6b0c..0c288bcad9 100644
--- a/tests/unit/java/com/android/server/connectivity/mdns/MdnsResponseDecoderTests.java
+++ b/tests/unit/java/com/android/server/connectivity/mdns/MdnsResponseDecoderTests.java
@@ -19,7 +19,6 @@ package com.android.server.connectivity.mdns;
 import static android.net.InetAddresses.parseNumericAddress;
 
 import static com.android.server.connectivity.mdns.util.MdnsUtils.Clock;
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
 
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
@@ -32,16 +31,17 @@ import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.mock;
 
 import android.net.Network;
+import android.os.Build;
 import android.util.ArraySet;
 
 import com.android.net.module.util.HexDump;
 import com.android.server.connectivity.mdns.MdnsResponseTests.MdnsInet4AddressRecord;
 import com.android.server.connectivity.mdns.MdnsResponseTests.MdnsInet6AddressRecord;
+import com.android.server.connectivity.mdns.MdnsServiceInfo.TextEntry;
 import com.android.testutils.DevSdkIgnoreRule;
 import com.android.testutils.DevSdkIgnoreRunner;
 
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -57,7 +57,7 @@ import java.util.List;
 import java.util.stream.Collectors;
 
 @RunWith(DevSdkIgnoreRunner.class)
-@DevSdkIgnoreRule.IgnoreUpTo(SC_V2)
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 public class MdnsResponseDecoderTests {
     private static final byte[] data = HexDump.hexStringToByteArray(
             "0000840000000004"
@@ -165,6 +165,10 @@ public class MdnsResponseDecoderTests {
     // for the records changed.
     private static final byte[] DATAIN_IPV4_2 = HexDump.hexStringToByteArray(
             "0974657374686f73743100000180010000007800040a010204");
+    // MDNS record for name "testhost1" with an IPv4 address of 10.1.2.5. Does not set the cache
+    // flush bit.
+    private static final byte[] DATAIN_IPV4_NOCACHEFLUSH = HexDump.hexStringToByteArray(
+            "0974657374686f73743100000100010000007800040a010205");
     // MDNS record w/name "testhost1" & IPv6 address of aabb:ccdd:1122:3344:a0b0:c0d0:1020:3040.
     // Also set cache flush bit for the records changed.
     private static final byte[] DATAIN_IPV6_1 = HexDump.hexStringToByteArray(
@@ -173,6 +177,10 @@ public class MdnsResponseDecoderTests {
     // Also set cache flush bit for the records changed.
     private static final byte[] DATAIN_IPV6_2 = HexDump.hexStringToByteArray(
             "0974657374686f73743100001c8001000000780010aabbccdd11223344a0b0c0d010203030");
+    // MDNS record for name "testhost1" & IPv6 address of aabb:ccdd:1122:3344:a0b0:c0d0:1020:3050.
+    // Does not set the cache flush bit.
+    private static final byte[] DATAIN_IPV6_NOCACHEFLUSH = HexDump.hexStringToByteArray(
+            "0974657374686f73743100001c0001000000780010aabbccdd11223344a0b0c0d010203050");
     // MDNS record w/name "test" & PTR to foo.bar.quxx
     private static final byte[] DATAIN_PTR_1 = HexDump.hexStringToByteArray(
             "047465737400000C000100001194000E03666F6F03626172047175787800");
@@ -205,6 +213,7 @@ public class MdnsResponseDecoderTests {
     private static final String MATTER_SERVICE_NAME = "_matter";
     private static final String[] MATTER_SERVICE_TYPE =
             new String[] {MATTER_SERVICE_NAME, "_tcp", "local"};
+    private final MdnsFeatureFlags defaultFlags = MdnsFeatureFlags.newBuilder().build();
 
     private ArraySet<MdnsResponse> responses;
 
@@ -259,15 +268,16 @@ public class MdnsResponseDecoderTests {
         assertEquals(0, serviceWeight);
 
         MdnsTextRecord textRecord = response.getTextRecord();
-        List<String> textStrings = textRecord.getStrings();
-        assertEquals(7, textStrings.size());
-        assertEquals("id=970bf547b753fc63c2d2a36bb896aba8", textStrings.get(0));
-        assertEquals("ve=02", textStrings.get(1));
-        assertEquals("md=Chromecast", textStrings.get(2));
-        assertEquals("ic=/setup/icon.png", textStrings.get(3));
-        assertEquals("fn=Johnny's Chromecast", textStrings.get(4));
-        assertEquals("ca=5", textStrings.get(5));
-        assertEquals("st=0", textStrings.get(6));
+        List<TextEntry> textEntries = textRecord.getEntries();
+        assertEquals(List.of(
+                new TextEntry("id", "970bf547b753fc63c2d2a36bb896aba8"),
+                new TextEntry("ve", "02"),
+                new TextEntry("md", "Chromecast"),
+                new TextEntry("ic", "/setup/icon.png"),
+                new TextEntry("fn", "Johnny's Chromecast"),
+                new TextEntry("ca", "5"),
+                new TextEntry("st", "0")
+        ), textEntries);
     }
 
     private void verifyResponse(ArraySet<MdnsResponse> responseArraySet) {
@@ -340,13 +350,13 @@ public class MdnsResponseDecoderTests {
                 new InetSocketAddress(MdnsConstants.getMdnsIPv6Address(), MdnsConstants.MDNS_PORT));
 
         final MdnsPacket parsedPacket = MdnsResponseDecoder.parseResponse(
-                data6, data6.length, MdnsFeatureFlags.newBuilder().build());
+                data6, data6.length, defaultFlags);
         assertNotNull(parsedPacket);
 
         final Network network = mock(Network.class);
         responses = new ArraySet<>(decoder.augmentResponses(parsedPacket,
                 /* existingResponses= */ Collections.emptyList(),
-                /* interfaceIndex= */ 10, network /* expireOnExit= */).first);
+                /* interfaceIndex= */ 10, network /* expireOnExit= */, defaultFlags).first);
 
         assertEquals(responses.size(), 1);
         assertEquals(responses.valueAt(0).getInterfaceIndex(), 10);
@@ -356,7 +366,6 @@ public class MdnsResponseDecoderTests {
     @Test
     public void decode_singleHostname_multipleSrvRecords_flagEnabled_multipleCompleteResponses()
             throws Exception {
-        //MdnsScannerConfigsFlagsImpl.allowMultipleSrvRecordsPerHost.override(true);
         MdnsResponseDecoder decoder = new MdnsResponseDecoder(mClock, MATTER_SERVICE_TYPE);
         assertNotNull(matterDuplicateHostname);
 
@@ -381,24 +390,6 @@ public class MdnsResponseDecoderTests {
                         parseNumericAddress("2605:a601:a846:5700:3e61:5ff:fe0c:89f8"))));
     }
 
-    @Test
-    @Ignore("MdnsConfigs is not configurable currently.")
-    public void decode_singleHostname_multipleSrvRecords_flagDisabled_singleCompleteResponse()
-            throws Exception {
-        //MdnsScannerConfigsFlagsImpl.allowMultipleSrvRecordsPerHost.override(false);
-        MdnsResponseDecoder decoder = new MdnsResponseDecoder(mClock, MATTER_SERVICE_TYPE);
-        assertNotNull(matterDuplicateHostname);
-
-        responses = decode(decoder, matterDuplicateHostname);
-
-        // This should emit only two records:
-        assertEquals(2, responses.size());
-
-        // But only the first is complete:
-        assertTrue(responses.valueAt(0).isComplete());
-        assertFalse(responses.valueAt(1).isComplete());
-    }
-
     @Test
     public void testDecodeWithIpv4AddressChange() throws IOException {
         MdnsResponse response = makeMdnsResponse(0, DATAIN_SERVICE_NAME_1, List.of(
@@ -487,6 +478,96 @@ public class MdnsResponseDecoderTests {
                 updatedResponses.valueAt(0).getInet6AddressRecords().get(0).getInet6Address());
     }
 
+    @Test
+    public void testDecodeWithAddressesAddedAndRemoved_AddIpv4Address() throws IOException {
+        MdnsResponse response = makeMdnsResponse(0, DATAIN_SERVICE_NAME_1, List.of(
+                new PacketAndRecordClass(DATAIN_PTR_1,
+                        MdnsPointerRecord.class),
+                new PacketAndRecordClass(DATAIN_SERVICE_1,
+                        MdnsServiceRecord.class),
+                new PacketAndRecordClass(DATAIN_IPV6_1,
+                        MdnsInet6AddressRecord.class),
+                new PacketAndRecordClass(DATAIN_IPV4_1,
+                        MdnsInet4AddressRecord.class)));
+        // Now update the response replacing IPv6 addresses, and adding an IPv4 address
+        final MdnsResponseDecoder decoder = new MdnsResponseDecoder(mClock, null);
+        final byte[] removedAddrResponse = makeResponsePacket(List.of(
+                DATAIN_PTR_1, DATAIN_SERVICE_1, DATAIN_IPV6_2, DATAIN_IPV4_NOCACHEFLUSH));
+        final ArraySet<MdnsResponse> updatedResponses = decode(
+                decoder, removedAddrResponse, List.of(response));
+        assertEquals(1, updatedResponses.size());
+        assertEquals(1, updatedResponses.valueAt(0).getInet6AddressRecords().size());
+        assertEquals(parseNumericAddress("aabb:ccdd:1122:3344:a0b0:c0d0:1020:3030"),
+                updatedResponses.valueAt(0).getInet6AddressRecords().get(0).getInet6Address());
+        assertEquals(2, updatedResponses.valueAt(0).getInet4AddressRecords().size());
+        assertEquals(parseNumericAddress("10.1.2.3"),
+                updatedResponses.valueAt(0).getInet4AddressRecords().get(0).getInet4Address());
+        assertEquals(parseNumericAddress("10.1.2.5"),
+                updatedResponses.valueAt(0).getInet4AddressRecords().get(1).getInet4Address());
+    }
+
+    @Test
+    public void testDecodeWithAddressesReplaced_PerAddressTypeCacheFlushDisabled()
+            throws IOException {
+        final MdnsFeatureFlags flags = MdnsFeatureFlags.newBuilder()
+                .setIsCacheFlushPerAddressTypeEnabled(false)
+                .build();
+        MdnsResponse response = makeMdnsResponse(0, DATAIN_SERVICE_NAME_1, List.of(
+                new PacketAndRecordClass(DATAIN_PTR_1,
+                        MdnsPointerRecord.class),
+                new PacketAndRecordClass(DATAIN_SERVICE_1,
+                        MdnsServiceRecord.class),
+                new PacketAndRecordClass(DATAIN_IPV6_1,
+                        MdnsInet6AddressRecord.class),
+                new PacketAndRecordClass(DATAIN_IPV4_1,
+                        MdnsInet4AddressRecord.class)));
+        // Update the response replacing addresses with an IPv6 address (per-type flush disabled)
+        final MdnsResponseDecoder decoder = new MdnsResponseDecoder(mClock, null);
+        final byte[] removedAddrResponse = makeResponsePacket(List.of(
+                DATAIN_PTR_1, DATAIN_SERVICE_1, DATAIN_IPV6_2));
+        final MdnsPacket parsedPacket = MdnsResponseDecoder.parseResponse(
+                removedAddrResponse, removedAddrResponse.length, flags);
+        assertNotNull(parsedPacket);
+
+        final ArraySet<MdnsResponse> updatedResponses = new ArraySet<>(decoder.augmentResponses(
+                parsedPacket, List.of(response), MdnsSocket.INTERFACE_INDEX_UNSPECIFIED,
+                mock(Network.class), flags).first);
+
+        assertEquals(1, updatedResponses.size());
+        assertEquals(1, updatedResponses.valueAt(0).getInet6AddressRecords().size());
+        assertEquals(parseNumericAddress("aabb:ccdd:1122:3344:a0b0:c0d0:1020:3030"),
+                updatedResponses.valueAt(0).getInet6AddressRecords().get(0).getInet6Address());
+        assertEquals(0, updatedResponses.valueAt(0).getInet4AddressRecords().size());
+    }
+
+    @Test
+    public void testDecodeWithAddressesAdded_AddIpv6Address() throws IOException {
+        MdnsResponse response = makeMdnsResponse(0, DATAIN_SERVICE_NAME_1, List.of(
+                new PacketAndRecordClass(DATAIN_PTR_1,
+                        MdnsPointerRecord.class),
+                new PacketAndRecordClass(DATAIN_SERVICE_1,
+                        MdnsServiceRecord.class),
+                new PacketAndRecordClass(DATAIN_IPV6_1,
+                        MdnsInet6AddressRecord.class),
+                new PacketAndRecordClass(DATAIN_IPV4_1,
+                        MdnsInet4AddressRecord.class)));
+        // Now update the response adding an IPv6 address
+        final MdnsResponseDecoder decoder = new MdnsResponseDecoder(mClock, null);
+        final byte[] removedAddrResponse = makeResponsePacket(List.of(
+                DATAIN_PTR_1, DATAIN_SERVICE_1, DATAIN_IPV6_NOCACHEFLUSH));
+        final ArraySet<MdnsResponse> updatedResponses = decode(
+                decoder, removedAddrResponse, List.of(response));
+        assertEquals(1, updatedResponses.size());
+        assertEquals(2, updatedResponses.valueAt(0).getInet6AddressRecords().size());
+        assertEquals(parseNumericAddress("aabb:ccdd:1122:3344:a0b0:c0d0:1020:3040"),
+                updatedResponses.valueAt(0).getInet6AddressRecords().get(0).getInet6Address());
+        assertEquals(parseNumericAddress("aabb:ccdd:1122:3344:a0b0:c0d0:1020:3050"),
+                updatedResponses.valueAt(0).getInet6AddressRecords().get(1).getInet6Address());
+        assertEquals(1, updatedResponses.valueAt(0).getInet4AddressRecords().size());
+        assertEquals(parseNumericAddress("10.1.2.3"),
+                updatedResponses.valueAt(0).getInet4AddressRecords().get(0).getInet4Address());
+    }
+
     @Test
     public void testDecodeWithChangeOnText() throws IOException {
         MdnsResponse response = makeMdnsResponse(0, DATAIN_SERVICE_NAME_1, List.of(
@@ -502,9 +583,9 @@ public class MdnsResponseDecoderTests {
                 decoder, makeResponsePacket(DATAIN_TEXT_2), List.of(response));
         assertEquals(1, updatedResponses.size());
         assertEquals(List.of(
-                new MdnsServiceInfo.TextEntry("a", "hello there"),
-                new MdnsServiceInfo.TextEntry("b", "1234567890"),
-                new MdnsServiceInfo.TextEntry("xyz", "!@#$")),
+                new TextEntry("a", "hello there"),
+                new TextEntry("b", "1234567890"),
+                new TextEntry("xyz", "!@#$")),
                 updatedResponses.valueAt(0).getTextRecord().getEntries());
     }
 
@@ -570,6 +651,26 @@ public class MdnsResponseDecoderTests {
         assertEquals(0, changes.size());
     }
 
+    @Test
+    public void testDecodeWithNoChange_AddressRecordWithNoCacheFlush() throws IOException {
+        MdnsResponse response = makeMdnsResponse(0, DATAIN_SERVICE_NAME_1, List.of(
+                new PacketAndRecordClass(DATAIN_PTR_1,
+                        MdnsPointerRecord.class),
+                new PacketAndRecordClass(DATAIN_SERVICE_1,
+                        MdnsServiceRecord.class),
+                new PacketAndRecordClass(DATAIN_IPV6_1,
+                        MdnsInet6AddressRecord.class),
+                new PacketAndRecordClass(DATAIN_IPV4_NOCACHEFLUSH,
+                        MdnsInet4AddressRecord.class)));
+        // Now update the response adding an already existing IPv4 address
+        final MdnsResponseDecoder decoder = new MdnsResponseDecoder(mClock, null);
+        final byte[] removedAddrResponse = makeResponsePacket(List.of(
+                DATAIN_PTR_1, DATAIN_SERVICE_1, DATAIN_IPV4_NOCACHEFLUSH));
+        final ArraySet<MdnsResponse> updatedResponses = decode(
+                decoder, removedAddrResponse, List.of(response));
+        assertEquals(0, updatedResponses.size());
+    }
+
     private static MdnsResponse makeMdnsResponse(long time, String[] serviceName,
             List<PacketAndRecordClass> responseList) throws IOException {
         final MdnsResponse response = new MdnsResponse(
@@ -640,11 +741,11 @@ public class MdnsResponseDecoderTests {
     private ArraySet<MdnsResponse> decode(MdnsResponseDecoder decoder, byte[] data,
             Collection<MdnsResponse> existingResponses) throws MdnsPacket.ParseException {
         final MdnsPacket parsedPacket = MdnsResponseDecoder.parseResponse(
-                data, data.length, MdnsFeatureFlags.newBuilder().build());
+                data, data.length, defaultFlags);
         assertNotNull(parsedPacket);
 
         return new ArraySet<>(decoder.augmentResponses(parsedPacket,
                 existingResponses,
-                MdnsSocket.INTERFACE_INDEX_UNSPECIFIED, mock(Network.class)).first);
+                MdnsSocket.INTERFACE_INDEX_UNSPECIFIED, mock(Network.class), defaultFlags).first);
     }
 }
\ No newline at end of file
diff --git a/tests/unit/java/com/android/server/connectivity/mdns/MdnsResponseTests.java b/tests/unit/java/com/android/server/connectivity/mdns/MdnsResponseTests.java
index 3e189f12fc..0b5fe91e61 100644
--- a/tests/unit/java/com/android/server/connectivity/mdns/MdnsResponseTests.java
+++ b/tests/unit/java/com/android/server/connectivity/mdns/MdnsResponseTests.java
@@ -18,8 +18,6 @@ package com.android.server.connectivity.mdns;
 
 import static android.net.InetAddresses.parseNumericAddress;
 
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -30,6 +28,7 @@ import static org.mockito.Mockito.mock;
 import static java.util.Collections.emptyList;
 
 import android.net.Network;
+import android.os.Build;
 
 import com.android.net.module.util.HexDump;
 import com.android.testutils.DevSdkIgnoreRule;
@@ -45,7 +44,7 @@ import java.util.List;
 // The record test data does not use compressed names (label pointers), since that would require
 // additional data to populate the label dictionary accordingly.
 @RunWith(DevSdkIgnoreRunner.class)
-@DevSdkIgnoreRule.IgnoreUpTo(SC_V2)
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 public class MdnsResponseTests {
     private static final String TAG = "MdnsResponseTests";
     // MDNS response packet for name "test" with an IPv4 address of 10.1.2.3
diff --git a/tests/unit/java/com/android/server/connectivity/mdns/MdnsServiceCacheTest.kt b/tests/unit/java/com/android/server/connectivity/mdns/MdnsServiceCacheTest.kt
index 2ebe87a9f9..40065c1a6d 100644
--- a/tests/unit/java/com/android/server/connectivity/mdns/MdnsServiceCacheTest.kt
+++ b/tests/unit/java/com/android/server/connectivity/mdns/MdnsServiceCacheTest.kt
@@ -20,8 +20,11 @@ import android.os.Build
 import android.os.Handler
 import android.os.HandlerThread
 import com.android.net.module.util.ArrayTrackRecord
+import com.android.net.module.util.CollectionUtils
+import com.android.server.connectivity.mdns.MdnsResponse.EXPIRATION_NEVER
 import com.android.server.connectivity.mdns.MdnsServiceCache.CacheKey
 import com.android.server.connectivity.mdns.MdnsServiceCache.CachedService
+import com.android.server.connectivity.mdns.MdnsServiceCache.NEVER_SENT_QUERY
 import com.android.server.connectivity.mdns.MdnsServiceCacheTest.ExpiredRecord.ExpiredEvent.ServiceRecordExpired
 import com.android.server.connectivity.mdns.util.MdnsUtils
 import com.android.testutils.DevSdkIgnoreRule
@@ -109,10 +112,13 @@ class MdnsServiceCacheTest {
         thread.join()
     }
 
-    private fun makeFlags(isExpiredServicesRemovalEnabled: Boolean = false) =
-            MdnsFeatureFlags.Builder()
-                    .setIsExpiredServicesRemovalEnabled(isExpiredServicesRemovalEnabled)
-                    .build()
+    private fun makeFlags(
+            isExpiredServicesRemovalEnabled: Boolean = false,
+            isOptimizedExpiredServiceRemovalEnabled: Boolean = false
+    ) = MdnsFeatureFlags.Builder()
+            .setIsExpiredServicesRemovalEnabled(isExpiredServicesRemovalEnabled)
+            .setIsOptimizedExpiredServiceRemovalEnabled(isOptimizedExpiredServiceRemovalEnabled)
+            .build()
 
     private fun <T> runningOnHandlerAndReturn(functor: (() -> T)): T {
         val future = CompletableFuture<T>()
@@ -137,15 +143,19 @@ class MdnsServiceCacheTest {
     private fun getService(
             serviceCache: MdnsServiceCache,
             serviceName: String,
-            cacheKey: CacheKey
+            cacheKey: CacheKey,
+            excludeExpiredService: Boolean = true,
     ): MdnsResponse? = runningOnHandlerAndReturn {
-        serviceCache.getCachedService(serviceName, cacheKey)
+        serviceCache.getCachedService(serviceName, cacheKey, excludeExpiredService)
     }
 
     private fun getServices(
             serviceCache: MdnsServiceCache,
-            cacheKey: CacheKey
-    ): List<MdnsResponse> = runningOnHandlerAndReturn { serviceCache.getCachedServices(cacheKey) }
+            cacheKey: CacheKey,
+            excludeExpiredService: Boolean = true,
+    ): List<MdnsResponse> = runningOnHandlerAndReturn {
+        serviceCache.getCachedServices(cacheKey, excludeExpiredService)
+    }
 
     private fun registerServiceExpiredCallback(
             serviceCache: MdnsServiceCache,
@@ -160,6 +170,37 @@ class MdnsServiceCacheTest {
             cacheKey: CacheKey
     ): Unit = runningOnHandlerAndReturn { serviceCache.removeServices(cacheKey) }
 
+    private fun getFirstQueryTimeAfterLastUpdate(
+            serviceCache: MdnsServiceCache,
+            serviceName: String,
+            cacheKey: CacheKey
+    ): Long = runningOnHandlerAndReturn {
+        serviceCache.getFirstQueryTimeAfterLastUpdate(serviceName, cacheKey)
+    }
+
+    private fun updateFirstQueryTimeForCachedServices(
+            serviceCache: MdnsServiceCache,
+            serviceName: String?,
+            subtypes: List<String>,
+            cacheKey: CacheKey,
+            currentTime: Long
+    ): Unit = runningOnHandlerAndReturn {
+        serviceCache.updateFirstQueryTimeForCachedServices(
+                serviceName,
+                subtypes,
+                cacheKey,
+                currentTime
+        )
+    }
+
+    private fun removeExpiredServicesAndNotifyListeners(
+            serviceCache: MdnsServiceCache,
+            cacheKey: CacheKey,
+            currentTime: Long
+    ): Unit = runningOnHandlerAndReturn {
+        serviceCache.removeExpiredServicesAndNotifyListeners(cacheKey, currentTime)
+    }
+
     @Test
     fun testAddAndRemoveService() {
         val serviceCache = MdnsServiceCache(thread.looper, makeFlags(), clock)
@@ -326,63 +367,275 @@ class MdnsServiceCacheTest {
         assertEquals(service4, services[3])
     }
 
+    private fun verifyGetServices(
+            serviceCache: MdnsServiceCache,
+            cacheKey: CacheKey,
+            excludeExpiredService: Boolean,
+            vararg serviceInstanceNames: String
+    ) {
+        val responses = getServices(serviceCache, cacheKey, excludeExpiredService)
+        assertEquals(serviceInstanceNames.size, responses.size)
+        for (serviceInstanceName: String in serviceInstanceNames) {
+            assertTrue(responses.stream().anyMatch { response ->
+                response.serviceInstanceName == serviceInstanceName
+            })
+        }
+    }
+
     @Test
     fun testRemoveServices() {
         val serviceCache = MdnsServiceCache(thread.looper, makeFlags(), clock)
         addOrUpdateService(serviceCache, cacheKey1, createResponse(SERVICE_NAME_1, SERVICE_TYPE_1))
         addOrUpdateService(serviceCache, cacheKey1, createResponse(SERVICE_NAME_2, SERVICE_TYPE_1))
         addOrUpdateService(serviceCache, cacheKey2, createResponse(SERVICE_NAME_1, SERVICE_TYPE_2))
-        val responses1 = getServices(serviceCache, cacheKey1)
-        assertEquals(2, responses1.size)
-        assertTrue(responses1.stream().anyMatch { response ->
-            response.serviceInstanceName == SERVICE_NAME_1
-        })
-        assertTrue(responses1.any { response ->
-            response.serviceInstanceName == SERVICE_NAME_2
-        })
-        val responses2 = getServices(serviceCache, cacheKey2)
-        assertEquals(1, responses2.size)
-        assertTrue(responses2.stream().anyMatch { response ->
-            response.serviceInstanceName == SERVICE_NAME_1
-        })
+        verifyGetServices(
+                serviceCache,
+                cacheKey1,
+                excludeExpiredService = true,
+                SERVICE_NAME_1,
+                SERVICE_NAME_2
+        )
+        verifyGetServices(serviceCache, cacheKey2, excludeExpiredService = true, SERVICE_NAME_1)
 
         removeServices(serviceCache, cacheKey1)
-        val responses3 = getServices(serviceCache, cacheKey1)
-        assertEquals(0, responses3.size)
-        val responses4 = getServices(serviceCache, cacheKey2)
-        assertEquals(1, responses4.size)
+        verifyGetServices(serviceCache, cacheKey1, excludeExpiredService = true)
+        verifyGetServices(serviceCache, cacheKey2, excludeExpiredService = true, SERVICE_NAME_1)
 
         removeServices(serviceCache, cacheKey2)
-        val responses5 = getServices(serviceCache, cacheKey2)
-        assertEquals(0, responses5.size)
+        verifyGetServices(serviceCache, cacheKey2, excludeExpiredService = true)
+    }
+
+    @Test
+    fun testFirstQueryTime_AddService() {
+        val serviceCache = MdnsServiceCache(thread.looper, makeFlags(), clock)
+        addOrUpdateService(serviceCache, cacheKey1, createResponse(SERVICE_NAME_1, SERVICE_TYPE_1))
+        addOrUpdateService(serviceCache, cacheKey1, createResponse(SERVICE_NAME_2, SERVICE_TYPE_1))
+
+        // Verify the first query time
+        assertEquals(
+                NEVER_SENT_QUERY,
+                getFirstQueryTimeAfterLastUpdate(serviceCache, SERVICE_NAME_1, cacheKey1)
+        )
+        assertEquals(
+                NEVER_SENT_QUERY,
+                getFirstQueryTimeAfterLastUpdate(serviceCache, SERVICE_NAME_2, cacheKey1)
+        )
+    }
+
+    @Test
+    fun testFirstQueryTime_UpdateServices() {
+        val serviceCache = MdnsServiceCache(thread.looper, makeFlags(), clock)
+        var currentTime = 12345L
+        addOrUpdateService(serviceCache, cacheKey1, createResponse(SERVICE_NAME_1, SERVICE_TYPE_1))
+        addOrUpdateService(serviceCache, cacheKey1, createResponse(SERVICE_NAME_2, SERVICE_TYPE_1))
+
+        // Update the first query time for all services and verify the update.
+        updateFirstQueryTimeForCachedServices(
+                serviceCache,
+                serviceName = null,
+                subtypes = emptyList(),
+                cacheKey1,
+                currentTime
+        )
+        assertEquals(
+                currentTime,
+                getFirstQueryTimeAfterLastUpdate(serviceCache, SERVICE_NAME_1, cacheKey1)
+        )
+        assertEquals(
+                currentTime,
+                getFirstQueryTimeAfterLastUpdate(serviceCache, SERVICE_NAME_2, cacheKey1)
+        )
+    }
+
+    @Test
+    fun testFirstQueryTime_UpdateServices_WithSubtypes() {
+        val serviceCache = MdnsServiceCache(thread.looper, makeFlags(), clock)
+        var currentTime = 12345L
+        val subType = "subtype"
+        addOrUpdateService(serviceCache, cacheKey1, createResponse(SERVICE_NAME_1, SERVICE_TYPE_1))
+        addOrUpdateService(
+                serviceCache,
+                cacheKey1,
+                createResponse(SERVICE_NAME_2, SERVICE_TYPE_1, subType = subType)
+        )
+
+        // Update the first query time for the service with a subtype and verify the update.
+        updateFirstQueryTimeForCachedServices(
+                serviceCache,
+                serviceName = null,
+                subtypes = listOf(subType),
+                cacheKey1,
+                currentTime
+        )
+
+        assertEquals(
+                NEVER_SENT_QUERY,
+                getFirstQueryTimeAfterLastUpdate(serviceCache, SERVICE_NAME_1, cacheKey1)
+        )
+        assertEquals(
+                currentTime,
+                getFirstQueryTimeAfterLastUpdate(serviceCache, SERVICE_NAME_2, cacheKey1)
+        )
+    }
+
+    @Test
+    fun testFirstQueryTime_UpdateSpecificService() {
+        val serviceCache = MdnsServiceCache(thread.looper, makeFlags(), clock)
+        var currentTime = 12345L
+        addOrUpdateService(serviceCache, cacheKey1, createResponse(SERVICE_NAME_1, SERVICE_TYPE_1))
+        addOrUpdateService(serviceCache, cacheKey1, createResponse(SERVICE_NAME_2, SERVICE_TYPE_1))
+
+        // Update the first query time for service 1 only and verify the update.
+        updateFirstQueryTimeForCachedServices(
+                serviceCache,
+                SERVICE_NAME_1,
+                subtypes = emptyList(),
+                cacheKey1,
+                currentTime
+        )
+        assertEquals(
+                currentTime,
+                getFirstQueryTimeAfterLastUpdate(serviceCache, SERVICE_NAME_1, cacheKey1)
+        )
+        assertEquals(
+                NEVER_SENT_QUERY,
+                getFirstQueryTimeAfterLastUpdate(serviceCache, SERVICE_NAME_2, cacheKey1)
+        )
+    }
+
+    @Test
+    fun testRemoveExpiredServiceAfterQuerySent() {
+        val serviceCache = MdnsServiceCache(
+                thread.looper,
+                makeFlags(
+                        isExpiredServicesRemovalEnabled = true,
+                        isOptimizedExpiredServiceRemovalEnabled = true
+                ),
+                clock
+        )
+        var currentTime = TEST_ELAPSED_REALTIME_MS
+
+        // Add a service, then advance the time to expire the service.
+        doReturn(currentTime).`when`(clock).elapsedRealtime()
+        addOrUpdateService(serviceCache, cacheKey1, createResponse(SERVICE_NAME_1, SERVICE_TYPE_1))
+        currentTime += DEFAULT_TTL_TIME_MS
+        doReturn(currentTime).`when`(clock).elapsedRealtime()
+        // No service because the service has been marked as expired
+        assertNull(getService(serviceCache, SERVICE_NAME_1, cacheKey1))
+        // Can still get the service if expired services are included.
+        assertNotNull(getService(
+                serviceCache,
+                SERVICE_NAME_1,
+                cacheKey1,
+                excludeExpiredService = false
+        ))
+
+        // Attempt to remove the expired service, but it should not be removed due to no query being
+        // sent.
+        removeExpiredServicesAndNotifyListeners(serviceCache, cacheKey1, currentTime)
+        assertNotNull(getService(
+                serviceCache,
+                SERVICE_NAME_1,
+                cacheKey1,
+                excludeExpiredService = false
+        ))
+
+        // Update the first query time and attempt to remove the expired service again after 2 sec
+        // later. It should now be removed.
+        updateFirstQueryTimeForCachedServices(
+                serviceCache,
+                SERVICE_NAME_1,
+                subtypes = emptyList(),
+                cacheKey1,
+                currentTime
+        )
+        currentTime += MdnsServiceTypeClient.REMOVE_SERVICE_AFTER_QUERY_SENT_TIME
+        doReturn(currentTime).`when`(clock).elapsedRealtime()
+        removeExpiredServicesAndNotifyListeners(serviceCache, cacheKey1, currentTime)
+        assertNull(getService(
+                serviceCache,
+                SERVICE_NAME_1,
+                cacheKey1,
+                excludeExpiredService = false
+        ))
+    }
+
+    @Test
+    fun testGetNextExpirationTime() {
+        val serviceCache = MdnsServiceCache(
+                thread.looper,
+                makeFlags(
+                        isExpiredServicesRemovalEnabled = true,
+                        isOptimizedExpiredServiceRemovalEnabled = true
+                ),
+                clock
+        )
+        var currentTime = TEST_ELAPSED_REALTIME_MS
+        assertEquals(EXPIRATION_NEVER, serviceCache.currentExpiredTime)
+
+        doReturn(currentTime).`when`(clock).elapsedRealtime()
+        addOrUpdateService(
+                serviceCache,
+                cacheKey1,
+                createResponse(SERVICE_NAME_1, SERVICE_TYPE_1, ttlTime = 30000L)
+        )
+        addOrUpdateService(
+                serviceCache,
+                cacheKey1,
+                createResponse(SERVICE_NAME_2, SERVICE_TYPE_1, ttlTime = 60000L)
+        )
+        assertEquals(TEST_ELAPSED_REALTIME_MS + 30000L, serviceCache.currentExpiredTime)
+
+        currentTime += 45000L
+        doReturn(currentTime).`when`(clock).elapsedRealtime()
+        removeExpiredServicesAndNotifyListeners(serviceCache, cacheKey1, currentTime)
+        assertEquals(TEST_ELAPSED_REALTIME_MS + 60000L, serviceCache.currentExpiredTime)
+
+        currentTime += 100000L
+        doReturn(currentTime).`when`(clock).elapsedRealtime()
+        removeExpiredServicesAndNotifyListeners(serviceCache, cacheKey1, currentTime)
+        assertEquals(EXPIRATION_NEVER, serviceCache.currentExpiredTime)
     }
 
     private fun createResponse(
             serviceInstanceName: String,
             serviceType: String,
-            ttlTime: Long = 120000L
+            ttlTime: Long = DEFAULT_TTL_TIME_MS,
+            subType: String? = null
     ): MdnsResponse {
-        val serviceName = "$serviceInstanceName.$serviceType".split(".").toTypedArray()
+        val serviceTypeArray = if (subType != null) {
+            MdnsUtils.constructFullSubtype(
+                    serviceType.split(".").toTypedArray(),
+                    "_$subType"
+            )
+        } else {
+            serviceType.split(".").toTypedArray()
+        }
+        val serviceNameArray = CollectionUtils.prependArray(
+                String::class.java,
+                serviceTypeArray,
+                serviceInstanceName
+        )
         val response = MdnsResponse(
                 0 /* now */,
-            "$serviceInstanceName.$serviceType".split(".").toTypedArray(),
+                serviceNameArray,
                 socketKey.interfaceIndex,
-            socketKey.network
+                socketKey.network
         )
 
         // Set PTR record
         val pointerRecord = MdnsPointerRecord(
-                serviceType.split(".").toTypedArray(),
+                serviceTypeArray,
                 TEST_ELAPSED_REALTIME_MS /* receiptTimeMillis */,
                 false /* cacheFlush */,
                 ttlTime /* ttlMillis */,
-                serviceName
+                serviceNameArray
         )
         response.addPointerRecord(pointerRecord)
 
         // Set SRV record.
         val serviceRecord = MdnsServiceRecord(
-                serviceName,
+                serviceNameArray,
                 TEST_ELAPSED_REALTIME_MS /* receiptTimeMillis */,
                 false /* cacheFlush */,
                 ttlTime /* ttlMillis */,
diff --git a/tests/unit/java/com/android/server/connectivity/mdns/MdnsServiceInfoTest.java b/tests/unit/java/com/android/server/connectivity/mdns/MdnsServiceInfoTest.java
index 4ce8ba6360..23553829d4 100644
--- a/tests/unit/java/com/android/server/connectivity/mdns/MdnsServiceInfoTest.java
+++ b/tests/unit/java/com/android/server/connectivity/mdns/MdnsServiceInfoTest.java
@@ -17,7 +17,6 @@
 package com.android.server.connectivity.mdns;
 
 import static com.android.server.connectivity.mdns.MdnsSocket.INTERFACE_INDEX_UNSPECIFIED;
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
 
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
@@ -26,6 +25,7 @@ import static org.junit.Assert.assertTrue;
 import static org.mockito.Mockito.mock;
 
 import android.net.Network;
+import android.os.Build;
 import android.os.Parcel;
 
 import com.android.server.connectivity.mdns.MdnsServiceInfo.TextEntry;
@@ -37,13 +37,12 @@ import org.junit.runner.RunWith;
 
 import java.time.Instant;
 import java.util.List;
-import java.util.Map;
 
 @RunWith(DevSdkIgnoreRunner.class)
-@DevSdkIgnoreRule.IgnoreUpTo(SC_V2)
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 public class MdnsServiceInfoTest {
     @Test
-    public void constructor_createWithOnlyTextStrings_correctAttributes() {
+    public void constructor_createWithTextEntries_correctAttributes() {
         MdnsServiceInfo info =
                 new MdnsServiceInfo(
                         "my-mdns-service",
@@ -53,26 +52,6 @@ public class MdnsServiceInfoTest {
                         12345,
                         "192.168.1.1",
                         "2001::1",
-                        List.of("vn=Google Inc.", "mn=Google Nest Hub Max"),
-                        /* textEntries= */ null,
-                        INTERFACE_INDEX_UNSPECIFIED);
-
-        assertTrue(info.getAttributeByKey("vn").equals("Google Inc."));
-        assertTrue(info.getAttributeByKey("mn").equals("Google Nest Hub Max"));
-    }
-
-    @Test
-    public void constructor_createWithOnlyTextEntries_correctAttributes() {
-        MdnsServiceInfo info =
-                new MdnsServiceInfo(
-                        "my-mdns-service",
-                        new String[] {"_googlecast", "_tcp"},
-                        List.of(),
-                        new String[] {"my-host", "local"},
-                        12345,
-                        "192.168.1.1",
-                        "2001::1",
-                        /* textStrings= */ null,
                         List.of(MdnsServiceInfo.TextEntry.fromString("vn=Google Inc."),
                                 MdnsServiceInfo.TextEntry.fromString("mn=Google Nest Hub Max")),
                         INTERFACE_INDEX_UNSPECIFIED);
@@ -81,48 +60,6 @@ public class MdnsServiceInfoTest {
         assertTrue(info.getAttributeByKey("mn").equals("Google Nest Hub Max"));
     }
 
-    @Test
-    public void constructor_createWithBothTextStringsAndTextEntries_acceptsOnlyTextEntries() {
-        MdnsServiceInfo info =
-                new MdnsServiceInfo(
-                        "my-mdns-service",
-                        new String[] {"_googlecast", "_tcp"},
-                        List.of(),
-                        new String[] {"my-host", "local"},
-                        12345,
-                        "192.168.1.1",
-                        "2001::1",
-                        List.of("vn=Alphabet Inc.", "mn=Google Nest Hub Max", "id=12345"),
-                        List.of(
-                                MdnsServiceInfo.TextEntry.fromString("vn=Google Inc."),
-                                MdnsServiceInfo.TextEntry.fromString("mn=Google Nest Hub Max")),
-                        INTERFACE_INDEX_UNSPECIFIED);
-
-        assertEquals(Map.of("vn", "Google Inc.", "mn", "Google Nest Hub Max"),
-                info.getAttributes());
-    }
-
-    @Test
-    public void constructor_createWithDuplicateKeys_acceptsTheFirstOne() {
-        MdnsServiceInfo info =
-                new MdnsServiceInfo(
-                        "my-mdns-service",
-                        new String[] {"_googlecast", "_tcp"},
-                        List.of(),
-                        new String[] {"my-host", "local"},
-                        12345,
-                        "192.168.1.1",
-                        "2001::1",
-                        List.of("vn=Alphabet Inc.", "mn=Google Nest Hub Max", "id=12345"),
-                        List.of(MdnsServiceInfo.TextEntry.fromString("vn=Google Inc."),
-                                MdnsServiceInfo.TextEntry.fromString("mn=Google Nest Hub Max"),
-                                MdnsServiceInfo.TextEntry.fromString("mn=Google WiFi Router")),
-                        INTERFACE_INDEX_UNSPECIFIED);
-
-        assertEquals(Map.of("vn", "Google Inc.", "mn", "Google Nest Hub Max"),
-                info.getAttributes());
-    }
-
     @Test
     public void constructor_createWithUppercaseKeys_correctAttributes() {
         MdnsServiceInfo info =
@@ -134,8 +71,7 @@ public class MdnsServiceInfoTest {
                         12345,
                         "192.168.1.1",
                         "2001::1",
-                        List.of("KEY=Value"),
-                        /* textEntries= */ null,
+                        List.of(MdnsServiceInfo.TextEntry.fromString("KEY=Value")),
                         INTERFACE_INDEX_UNSPECIFIED);
 
         assertEquals("Value", info.getAttributeByKey("key"));
@@ -155,7 +91,6 @@ public class MdnsServiceInfoTest {
                         12345,
                         "192.168.1.1",
                         "2001::1",
-                        List.of(),
                         /* textEntries= */ null,
                         INTERFACE_INDEX_UNSPECIFIED);
 
@@ -173,7 +108,6 @@ public class MdnsServiceInfoTest {
                         12345,
                         "192.168.1.1",
                         "2001::1",
-                        List.of(),
                         /* textEntries= */ null,
                         /* interfaceIndex= */ 20);
 
@@ -191,7 +125,6 @@ public class MdnsServiceInfoTest {
                         12345,
                         "192.168.1.1",
                         "2001::1",
-                        List.of(),
                         /* textEntries= */ null,
                         /* interfaceIndex= */ 20);
 
@@ -207,7 +140,6 @@ public class MdnsServiceInfoTest {
                         12345,
                         List.of("192.168.1.1"),
                         List.of("2001::1"),
-                        List.of(),
                         /* textEntries= */ null,
                         /* interfaceIndex= */ 20,
                         network,
@@ -228,7 +160,6 @@ public class MdnsServiceInfoTest {
                         12345,
                         List.of("192.168.1.1", "192.168.1.2"),
                         List.of("2001::1", "2001::2"),
-                        List.of("vn=Alphabet Inc.", "mn=Google Nest Hub Max", "id=12345"),
                         List.of(
                                 MdnsServiceInfo.TextEntry.fromString("vn=Google Inc."),
                                 MdnsServiceInfo.TextEntry.fromString("mn=Google Nest Hub Max"),
diff --git a/tests/unit/java/com/android/server/connectivity/mdns/MdnsServiceTypeClientTests.java b/tests/unit/java/com/android/server/connectivity/mdns/MdnsServiceTypeClientTests.java
index b9c0d2f7ca..27ea3fcb14 100644
--- a/tests/unit/java/com/android/server/connectivity/mdns/MdnsServiceTypeClientTests.java
+++ b/tests/unit/java/com/android/server/connectivity/mdns/MdnsServiceTypeClientTests.java
@@ -22,8 +22,10 @@ import static com.android.server.connectivity.mdns.MdnsQueryScheduler.TIME_BETWE
 import static com.android.server.connectivity.mdns.MdnsSearchOptions.ACTIVE_QUERY_MODE;
 import static com.android.server.connectivity.mdns.MdnsSearchOptions.AGGRESSIVE_QUERY_MODE;
 import static com.android.server.connectivity.mdns.MdnsSearchOptions.PASSIVE_QUERY_MODE;
+import static com.android.server.connectivity.mdns.MdnsServiceTypeClient.EVENT_QUERY_RESULT;
+import static com.android.server.connectivity.mdns.MdnsServiceTypeClient.EVENT_REMOVE_EXPIRED_SERVICES;
 import static com.android.server.connectivity.mdns.MdnsServiceTypeClient.EVENT_START_QUERYTASK;
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
+import static com.android.server.connectivity.mdns.MdnsServiceTypeClient.REMOVE_SERVICE_AFTER_QUERY_SENT_TIME;
 
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
@@ -42,6 +44,7 @@ import static org.mockito.Mockito.doCallRealMethod;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.inOrder;
 import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.timeout;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
@@ -53,6 +56,7 @@ import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.net.InetAddresses;
 import android.net.Network;
+import android.os.Build;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Message;
@@ -97,7 +101,7 @@ import java.util.stream.Stream;
 /** Tests for {@link MdnsServiceTypeClient}. */
 @DevSdkIgnoreRunner.MonitorThreadLeak
 @RunWith(DevSdkIgnoreRunner.class)
-@DevSdkIgnoreRule.IgnoreUpTo(SC_V2)
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 public class MdnsServiceTypeClientTests {
     private static final int INTERFACE_INDEX = 999;
     private static final long DEFAULT_TIMEOUT = 2000L;
@@ -253,10 +257,14 @@ public class MdnsServiceTypeClientTests {
         }).when(mockDeps).createScheduler(any(Handler.class));
 
         doAnswer(inv -> {
-            message = (Message) inv.getArguments()[0];
-            latestDelayMs = (long) inv.getArguments()[1];
+            final int what = (int) inv.getArguments()[0];
+            if (what == EVENT_START_QUERYTASK) {
+                final Object obj = inv.getArguments()[3];
+                message = realHandler.obtainMessage(what, obj);
+            }
+            latestDelayMs = (long) inv.getArguments()[4];
             return null;
-        }).when(mockScheduler).sendDelayedMessage(any(), anyLong());
+        }).when(mockScheduler).sendDelayedMessage(anyInt(), anyInt(), anyInt(), any(), anyLong());
 
         client = makeMdnsServiceTypeClient(featureFlags);
     }
@@ -302,6 +310,11 @@ public class MdnsServiceTypeClientTests {
         delayMessage = null;
     }
 
+    private void dispatchRealtimeSchedulerMessage() {
+        runOnHandler(() -> realHandler.dispatchMessage(message));
+        message = null;
+    }
+
     @Test
     public void sendQueries_activeScanMode() {
         MdnsSearchOptions searchOptions = MdnsSearchOptions.newBuilder()
@@ -2191,6 +2204,124 @@ public class MdnsServiceTypeClientTests {
         verify(mockScheduler).close();
     }
 
+    private void verifyQuerySentAndRemoveExpiredServices(int count) {
+        currentThreadExecutor.getAndClearLastScheduledRunnable().run();
+        verify(mockDeps, times(count)).sendMessage(
+                any(Handler.class), argThat(message -> message.what == EVENT_QUERY_RESULT));
+        verify(mockScheduler, times(count)).sendDelayedMessage(
+                eq(EVENT_REMOVE_EXPIRED_SERVICES), eq(0), eq(0), any(), anyLong());
+        verify(mockScheduler, times(count)).sendDelayedMessage(
+                eq(EVENT_START_QUERYTASK), eq(0), eq(0), any(), anyLong());
+    }
+
+    @Test
+    public void testExpireServiceRemovedAfterQuerySent() throws IOException {
+        final String requestedInstance = "instance1";
+        final String ipV4Address = "192.0.2.0";
+        final MdnsFeatureFlags flags = MdnsFeatureFlags.newBuilder()
+                .setIsExpiredServicesRemovalEnabled(true)
+                .setIsOptimizedExpiredServiceRemovalEnabled(true)
+                .setIsAccurateDelayCallbackEnabled(true)
+                .build();
+        serviceCache = new MdnsServiceCache(thread.getLooper(), flags, mockDecoderClock);
+        client = makeMdnsServiceTypeClient(flags);
+        startSendAndReceive(mockListenerOne,
+                MdnsSearchOptions.newBuilder().setQueryMode(AGGRESSIVE_QUERY_MODE).build());
+
+        // Sent a query
+        verifyQuerySentAndRemoveExpiredServices(1 /* count */);
+
+        // Receive a response
+        processResponse(
+                createResponse(requestedInstance, ipV4Address, 5353, SERVICE_TYPE_LABELS,
+                        Collections.emptyMap() /* textAttributes */, TEST_TTL),
+                socketKey);
+        verify(mockListenerOne).onServiceNameDiscovered(
+                matchServiceName(requestedInstance), eq(false) /* isServiceFromCache */);
+        verify(mockListenerOne).onServiceFound(
+                matchServiceName(requestedInstance), eq(false) /* isServiceFromCache */);
+
+        // Advance the time so that the service's TTL is not expired and send a query again. Attempt
+        // to remove expired services for which there should be no callback.
+        doReturn(TEST_ELAPSED_REALTIME + TEST_TTL - 1).when(mockDecoderClock).elapsedRealtime();
+        dispatchRealtimeSchedulerMessage();
+        verifyQuerySentAndRemoveExpiredServices(2 /* count */);
+        runOnHandler(() -> realHandler.dispatchMessage(
+                realHandler.obtainMessage(EVENT_REMOVE_EXPIRED_SERVICES)));
+        verify(mockListenerOne, never()).onServiceRemoved(any());
+        verify(mockListenerOne, never()).onServiceNameRemoved(any());
+
+        // Advance the time so that the service's TTL is expired, and send a query again. Attempt to
+        // remove expired services for which there should be a callback.
+        doReturn(TEST_ELAPSED_REALTIME + TEST_TTL + REMOVE_SERVICE_AFTER_QUERY_SENT_TIME)
+                .when(mockDecoderClock).elapsedRealtime();
+        dispatchRealtimeSchedulerMessage();
+        verifyQuerySentAndRemoveExpiredServices(3 /* count */);
+        runOnHandler(() -> realHandler.dispatchMessage(
+                realHandler.obtainMessage(EVENT_REMOVE_EXPIRED_SERVICES)));
+        verify(mockListenerOne, timeout(TEST_TIMEOUT_MS).times(1))
+                .onServiceRemoved(matchServiceName(requestedInstance));
+        verify(mockListenerOne, timeout(TEST_TIMEOUT_MS).times(1))
+                .onServiceNameRemoved(matchServiceName(requestedInstance));
+    }
+
+    @Test
+    public void testNoLostCallbackIfServiceHasNotNotified() throws IOException {
+        final String requestedInstance = "instance1";
+        final String ipV4Address = "192.0.2.0";
+        final MdnsFeatureFlags flags = MdnsFeatureFlags.newBuilder()
+                .setIsExpiredServicesRemovalEnabled(true)
+                .setIsOptimizedExpiredServiceRemovalEnabled(true)
+                .setIsAccurateDelayCallbackEnabled(true)
+                .build();
+        long currentTime = TEST_ELAPSED_REALTIME;
+        serviceCache = new MdnsServiceCache(thread.getLooper(), flags, mockDecoderClock);
+        client = makeMdnsServiceTypeClient(flags);
+        doReturn(currentTime).when(mockDecoderClock).elapsedRealtime();
+        startSendAndReceive(mockListenerOne,
+                MdnsSearchOptions.newBuilder().setQueryMode(AGGRESSIVE_QUERY_MODE).build());
+
+        // Sent a query
+        verifyQuerySentAndRemoveExpiredServices(1 /* count */);
+
+        // Receive a response
+        processResponse(
+                createResponse(requestedInstance, ipV4Address, 5353, SERVICE_TYPE_LABELS,
+                        Collections.emptyMap() /* textAttributes */, TEST_TTL),
+                socketKey);
+        verify(mockListenerOne).onServiceNameDiscovered(
+                matchServiceName(requestedInstance), eq(false) /* isServiceFromCache */);
+        verify(mockListenerOne).onServiceFound(
+                matchServiceName(requestedInstance), eq(false) /* isServiceFromCache */);
+
+        // Advance the time so that the service's TTL is expired, and send a query again
+        currentTime += TEST_TTL + 1;
+        doReturn(currentTime).when(mockDecoderClock).elapsedRealtime();
+        dispatchRealtimeSchedulerMessage();
+        verifyQuerySentAndRemoveExpiredServices(2 /* count */);
+
+        // A new listener was added, but it should not receive any callback because the existing
+        // service is expired.
+        startSendAndReceive(mockListenerTwo,
+                MdnsSearchOptions.newBuilder().setQueryMode(AGGRESSIVE_QUERY_MODE).build());
+        verifyQuerySentAndRemoveExpiredServices(3 /* count */);
+        verify(mockListenerTwo, never()).onServiceNameDiscovered(any(), anyBoolean());
+        verify(mockListenerTwo, never()).onServiceFound(any(), anyBoolean());
+
+        // Advance the time and attempt to remove expired services. Only the listener, which was
+        // previously notified, should receive a callback.
+        currentTime += REMOVE_SERVICE_AFTER_QUERY_SENT_TIME;
+        doReturn(currentTime).when(mockDecoderClock).elapsedRealtime();
+        runOnHandler(() -> realHandler.dispatchMessage(
+                realHandler.obtainMessage(EVENT_REMOVE_EXPIRED_SERVICES)));
+        verify(mockListenerOne, timeout(TEST_TIMEOUT_MS).times(1))
+                .onServiceRemoved(matchServiceName(requestedInstance));
+        verify(mockListenerOne, timeout(TEST_TIMEOUT_MS).times(1))
+                .onServiceNameRemoved(matchServiceName(requestedInstance));
+        verify(mockListenerTwo, never()).onServiceRemoved(any());
+        verify(mockListenerTwo, never()).onServiceNameRemoved(any());
+    }
+
     private static MdnsServiceInfo matchServiceName(String name) {
         return argThat(info -> info.getServiceInstanceName().equals(name));
     }
@@ -2213,8 +2344,7 @@ public class MdnsServiceTypeClientTests {
             boolean multipleSocketDiscovery, int scheduledCount, int sendMessageCount,
             boolean useAccurateDelayCallback) {
         if (useAccurateDelayCallback && message != null && realHandler != null) {
-            runOnHandler(() -> realHandler.dispatchMessage(message));
-            message = null;
+            dispatchRealtimeSchedulerMessage();
         } else {
             // Dispatch the message
             if (delayMessage != null && realHandler != null) {
@@ -2246,7 +2376,8 @@ public class MdnsServiceTypeClientTests {
                 .sendMessage(any(Handler.class), any(Message.class));
         // Verify the task has been scheduled.
         if (useAccurateDelayCallback) {
-            verify(mockScheduler, times(scheduledCount)).sendDelayedMessage(any(), anyLong());
+            verify(mockScheduler, times(scheduledCount)).sendDelayedMessage(
+                    anyInt(), anyInt(), anyInt(), any(), anyLong());
         } else {
             verify(mockDeps, times(scheduledCount))
                     .sendMessageDelayed(any(Handler.class), any(Message.class), anyLong());
diff --git a/tests/unit/java/com/android/server/connectivity/mdns/MdnsSocketClientTests.java b/tests/unit/java/com/android/server/connectivity/mdns/MdnsSocketClientTests.java
index ab70e385dd..3d48302265 100644
--- a/tests/unit/java/com/android/server/connectivity/mdns/MdnsSocketClientTests.java
+++ b/tests/unit/java/com/android/server/connectivity/mdns/MdnsSocketClientTests.java
@@ -17,7 +17,6 @@
 package com.android.server.connectivity.mdns;
 
 import static com.android.testutils.Cleanup.testAndCleanup;
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
 
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
@@ -27,9 +26,11 @@ import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.argThat;
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.doNothing;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.inOrder;
 import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.timeout;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
@@ -42,6 +43,7 @@ import android.net.ConnectivityManager;
 import android.net.InetAddresses;
 import android.net.wifi.WifiManager;
 import android.net.wifi.WifiManager.MulticastLock;
+import android.os.Build;
 import android.text.format.DateUtils;
 import android.util.Log;
 
@@ -73,7 +75,7 @@ import java.util.concurrent.atomic.AtomicBoolean;
 
 /** Tests for {@link MdnsSocketClient} */
 @RunWith(DevSdkIgnoreRunner.class)
-@DevSdkIgnoreRule.IgnoreUpTo(SC_V2)
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 public class MdnsSocketClientTests {
     private static final long TIMEOUT = 500;
     private final byte[] buf = new byte[10];
@@ -102,15 +104,7 @@ public class MdnsSocketClientTests {
         when(mockWifiManager.createMulticastLock(ArgumentMatchers.anyString()))
                 .thenReturn(mockMulticastLock);
 
-        mdnsClient = new MdnsSocketClient(mContext, mockMulticastLock, sharedLog, flags) {
-                    @Override
-                    MdnsSocket createMdnsSocket(int port, SharedLog sharedLog) throws IOException {
-                        if (port == MdnsConstants.MDNS_PORT) {
-                            return mockMulticastSocket;
-                        }
-                        return mockUnicastSocket;
-                    }
-                };
+        mdnsClient = makeTestSocketClient(flags);
         mdnsClient.setCallback(mockCallback);
 
         doAnswer(
@@ -217,6 +211,18 @@ public class MdnsSocketClientTests {
                 .receive(any(DatagramPacket.class));
     }
 
+    private MdnsSocketClient makeTestSocketClient(MdnsFeatureFlags flags) {
+        return new MdnsSocketClient(mContext, mockMulticastLock, sharedLog, flags) {
+            @Override
+            MdnsSocket createMdnsSocket(int port, SharedLog sharedLog) throws IOException {
+                if (port == MdnsConstants.MDNS_PORT) {
+                    return mockMulticastSocket;
+                }
+                return mockUnicastSocket;
+            }
+        };
+    }
+
     @After
     public void tearDown() {
         mdnsClient.stopDiscovery();
@@ -620,6 +626,26 @@ public class MdnsSocketClientTests {
         }, () -> Log.setWtfHandler(originalHandler));
     }
 
+    @Test
+    public void testSetThreadStatsTag() throws IOException {
+        final MdnsFeatureFlags flags = MdnsFeatureFlags.newBuilder()
+                .setMdnsSocketThreadStatsTag(42).build();
+
+        final MdnsSocketClient socketClient = spy(makeTestSocketClient(flags));
+
+
+        doNothing().when(socketClient).setThreadStatsTag(anyInt());
+        doNothing().when(socketClient).clearThreadStatsTag();
+        final InOrder inOrder = inOrder(socketClient);
+        socketClient.startDiscovery();
+
+        testAndCleanup(() -> {
+            inOrder.verify(socketClient).setThreadStatsTag(42);
+            inOrder.verify(socketClient).createMdnsSocket(anyInt(), any());
+            inOrder.verify(socketClient).clearThreadStatsTag();
+        }, socketClient::stopDiscovery);
+    }
+
     private DatagramPacket getTestDatagramPacket() {
         return new DatagramPacket(buf, 0, 5,
                 new InetSocketAddress(MdnsConstants.getMdnsIPv4Address(), 5353 /* port */));
diff --git a/tests/unit/java/com/android/server/connectivity/mdns/MdnsSocketProviderTest.java b/tests/unit/java/com/android/server/connectivity/mdns/MdnsSocketProviderTest.java
index f763bae09a..6bcc4ed442 100644
--- a/tests/unit/java/com/android/server/connectivity/mdns/MdnsSocketProviderTest.java
+++ b/tests/unit/java/com/android/server/connectivity/mdns/MdnsSocketProviderTest.java
@@ -18,6 +18,7 @@ package com.android.server.connectivity.mdns;
 
 import static android.net.NetworkCapabilities.TRANSPORT_BLUETOOTH;
 import static android.net.NetworkCapabilities.TRANSPORT_CELLULAR;
+import static android.net.NetworkCapabilities.TRANSPORT_THREAD;
 import static android.net.NetworkCapabilities.TRANSPORT_VPN;
 import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
 
@@ -596,6 +597,17 @@ public class MdnsSocketProviderTest {
         testCallback.expectedNoCallback();
     }
 
+    @Test
+    public void testNoSocketCreatedForThread() {
+        startMonitoringSockets();
+
+        final TestSocketCallback testCallback = new TestSocketCallback();
+        runOnHandler(() -> mSocketProvider.requestSocket(TEST_NETWORK, testCallback));
+
+        postNetworkAvailable(TRANSPORT_THREAD);
+        testCallback.expectedNoCallback();
+    }
+
     @Test
     public void testNoSocketCreatedForNonMulticastInterface() throws Exception {
         doReturn(false).when(mTestNetworkIfaceWrapper).supportsMulticast();
diff --git a/tests/unit/java/com/android/server/connectivity/mdns/MdnsSocketTests.java b/tests/unit/java/com/android/server/connectivity/mdns/MdnsSocketTests.java
index 58096844cc..71779afe29 100644
--- a/tests/unit/java/com/android/server/connectivity/mdns/MdnsSocketTests.java
+++ b/tests/unit/java/com/android/server/connectivity/mdns/MdnsSocketTests.java
@@ -16,11 +16,11 @@
 
 package com.android.server.connectivity.mdns;
 
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
-
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.os.Build;
+
 import com.android.net.module.util.SharedLog;
 import com.android.testutils.DevSdkIgnoreRule;
 import com.android.testutils.DevSdkIgnoreRunner;
@@ -45,7 +45,7 @@ import java.util.Collections;
 
 /** Tests for {@link MdnsSocket}. */
 @RunWith(DevSdkIgnoreRunner.class)
-@DevSdkIgnoreRule.IgnoreUpTo(SC_V2)
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 public class MdnsSocketTests {
 
     @Mock private NetworkInterfaceWrapper mockNetworkInterfaceWrapper;
diff --git a/tests/unit/java/com/android/server/connectivity/mdns/MulticastNetworkInterfaceProviderTests.java b/tests/unit/java/com/android/server/connectivity/mdns/MulticastNetworkInterfaceProviderTests.java
index af233c9be9..86fbf6b517 100644
--- a/tests/unit/java/com/android/server/connectivity/mdns/MulticastNetworkInterfaceProviderTests.java
+++ b/tests/unit/java/com/android/server/connectivity/mdns/MulticastNetworkInterfaceProviderTests.java
@@ -16,8 +16,6 @@
 
 package com.android.server.connectivity.mdns;
 
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -27,6 +25,7 @@ import static org.mockito.Mockito.when;
 
 import android.annotation.NonNull;
 import android.content.Context;
+import android.os.Build;
 
 import androidx.test.InstrumentationRegistry;
 
@@ -53,7 +52,7 @@ import java.util.List;
 
 /** Tests for {@link MulticastNetworkInterfaceProvider}. */
 @RunWith(DevSdkIgnoreRunner.class)
-@DevSdkIgnoreRule.IgnoreUpTo(SC_V2)
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 public class MulticastNetworkInterfaceProviderTests {
 
     @Mock private NetworkInterfaceWrapper loopbackInterface;
@@ -193,7 +192,8 @@ public class MulticastNetworkInterfaceProviderTests {
 
     @Test
     public void testStartWatchingConnectivityChanges() {
-        ConnectivityMonitor mockMonitor = mock(ConnectivityMonitor.class);
+        ConnectivityMonitorWithConnectivityManager mockMonitor =
+                mock(ConnectivityMonitorWithConnectivityManager.class);
         provider.connectivityMonitor = mockMonitor;
 
         InOrder inOrder = inOrder(mockMonitor);
diff --git a/tests/unit/java/com/android/server/connectivity/mdns/util/MdnsUtilsTest.kt b/tests/unit/java/com/android/server/connectivity/mdns/util/MdnsUtilsTest.kt
index efae244e48..0e4bd47858 100644
--- a/tests/unit/java/com/android/server/connectivity/mdns/util/MdnsUtilsTest.kt
+++ b/tests/unit/java/com/android/server/connectivity/mdns/util/MdnsUtilsTest.kt
@@ -18,6 +18,7 @@ package com.android.server.connectivity.mdns.util
 
 import android.net.InetAddresses
 import android.os.Build
+import com.android.net.module.util.CollectionUtils
 import com.android.server.connectivity.mdns.MdnsConstants
 import com.android.server.connectivity.mdns.MdnsConstants.FLAG_TRUNCATED
 import com.android.server.connectivity.mdns.MdnsConstants.IPV4_SOCKET_ADDR
@@ -32,17 +33,18 @@ import com.android.server.connectivity.mdns.MdnsServiceInfo
 import com.android.server.connectivity.mdns.MdnsServiceRecord
 import com.android.server.connectivity.mdns.MdnsTextRecord
 import com.android.server.connectivity.mdns.util.MdnsUtils.createQueryDatagramPackets
+import com.android.server.connectivity.mdns.util.MdnsUtils.responseMatchesInstanceNameAndSubtypes
 import com.android.server.connectivity.mdns.util.MdnsUtils.truncateServiceName
 import com.android.testutils.DevSdkIgnoreRule
 import com.android.testutils.DevSdkIgnoreRunner
+import java.net.DatagramPacket
+import kotlin.test.assertContentEquals
 import org.junit.Assert.assertArrayEquals
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertFalse
 import org.junit.Assert.assertTrue
 import org.junit.Test
 import org.junit.runner.RunWith
-import java.net.DatagramPacket
-import kotlin.test.assertContentEquals
 
 @RunWith(DevSdkIgnoreRunner::class)
 @DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
@@ -178,8 +180,13 @@ class MdnsUtilsTest {
         val interfaceIndex = 99
         val response = MdnsResponse(0 /* now */, serviceName, interfaceIndex, null /* network */)
         // Set PTR record
-        response.addPointerRecord(MdnsPointerRecord(serviceType.split(".").toTypedArray(),
-                testElapsedRealtime, false /* cacheFlush */, ttlTime, serviceName))
+        response.addPointerRecord(MdnsPointerRecord(
+                serviceType.split(".").toTypedArray(),
+                testElapsedRealtime,
+                false /* cacheFlush */,
+                ttlTime,
+                serviceName
+        ))
         // Set SRV record.
         response.serviceRecord = MdnsServiceRecord(serviceName, testElapsedRealtime,
                 false /* cacheFlush */, ttlTime, 0 /* servicePriority */, 0 /* serviceWeight */,
@@ -189,16 +196,27 @@ class MdnsUtilsTest {
                 testElapsedRealtime, true /* cacheFlush */, 0L /* ttlMillis */,
                 listOf(MdnsServiceInfo.TextEntry.fromString("somedifferent=entry")))
         // Set InetAddress record.
-        response.addInet4AddressRecord(MdnsInetAddressRecord(hostName.split(".").toTypedArray(),
-                testElapsedRealtime, true /* cacheFlush */,
-                0L /* ttlMillis */, InetAddresses.parseNumericAddress(v4Address)))
-        response.addInet6AddressRecord(MdnsInetAddressRecord(hostName.split(".").toTypedArray(),
-                testElapsedRealtime, true /* cacheFlush */,
-                0L /* ttlMillis */, InetAddresses.parseNumericAddress(v6Address)))
+        response.addInet4AddressRecord(MdnsInetAddressRecord(
+                hostName.split(".").toTypedArray(),
+                testElapsedRealtime,
+                true /* cacheFlush */,
+                0L /* ttlMillis */,
+                InetAddresses.parseNumericAddress(v4Address)
+        ))
+        response.addInet6AddressRecord(MdnsInetAddressRecord(
+                hostName.split(".").toTypedArray(),
+                testElapsedRealtime,
+                true /* cacheFlush */,
+                0L /* ttlMillis */,
+                InetAddresses.parseNumericAddress(v6Address)
+        ))
 
         // Convert a MdnsResponse to a MdnsServiceInfo
         val serviceInfo = MdnsUtils.buildMdnsServiceInfoFromResponse(
-                response, serviceType.split(".").toTypedArray(), testElapsedRealtime)
+                response,
+                serviceType.split(".").toTypedArray(),
+                testElapsedRealtime
+        )
 
         assertEquals(serviceInstanceName, serviceInfo.serviceInstanceName)
         assertArrayEquals(serviceType.split(".").toTypedArray(), serviceInfo.serviceType)
@@ -210,7 +228,112 @@ class MdnsUtilsTest {
         assertEquals(v6Address, serviceInfo.ipv6Addresses[0])
         assertEquals(interfaceIndex, serviceInfo.interfaceIndex)
         assertEquals(null, serviceInfo.network)
-        assertEquals(mapOf("somedifferent" to "entry"),
-                serviceInfo.attributes)
+        assertEquals(mapOf("somedifferent" to "entry"), serviceInfo.attributes)
+    }
+
+    private fun createResponse(
+            serviceInstanceName: String,
+            serviceType: String,
+            subType: String? = null
+    ): MdnsResponse {
+        val serviceTypeArray = if (subType != null) {
+            MdnsUtils.constructFullSubtype(
+                serviceType.split(".").toTypedArray(),
+                "_$subType"
+            )
+        } else {
+            serviceType.split(".").toTypedArray()
+        }
+        val serviceNameArray = CollectionUtils.prependArray(
+                String::class.java,
+                serviceTypeArray,
+                serviceInstanceName
+        )
+        val response =
+            MdnsResponse(0 /* now */, serviceNameArray, 99 /* interfaceIndex */, null /* network */)
+        response.addPointerRecord(MdnsPointerRecord(
+                serviceTypeArray,
+                120000L /* receiptTimeMillis */,
+                false /* cacheFlush */,
+                0L /* ttlTime */,
+                serviceNameArray
+        ))
+        return response
+    }
+
+    @Test
+    fun testResponseMatchesInstanceNameAndSubtypes() {
+        val serviceInstanceName = "MyTestService"
+        val serviceType = "_testservice._tcp.local"
+        val subType = "subtype"
+        val response = createResponse(serviceInstanceName, serviceType)
+        val responseWithSubType = createResponse(serviceInstanceName, serviceType, subType)
+
+        // No instance name and subtypes
+        assertTrue(responseMatchesInstanceNameAndSubtypes(
+                response,
+                null /* instanceName */,
+                emptyList() /* subTypes */
+        ))
+        assertTrue(responseMatchesInstanceNameAndSubtypes(
+                responseWithSubType,
+                null /* instanceName */,
+                emptyList() /* subTypes */
+        ))
+        // Has instance name but no subtypes
+        assertTrue(responseMatchesInstanceNameAndSubtypes(
+                response,
+                serviceInstanceName,
+                emptyList() /* subTypes */
+        ))
+        assertTrue(responseMatchesInstanceNameAndSubtypes(
+                responseWithSubType,
+                serviceInstanceName,
+                emptyList() /* subTypes */
+        ))
+        // Has subtypes but no instance name
+        assertFalse(responseMatchesInstanceNameAndSubtypes(
+                response,
+                null /* instanceName */,
+                listOf(subType)
+        ))
+        assertTrue(responseMatchesInstanceNameAndSubtypes(
+                responseWithSubType,
+                null /* instanceName */,
+                listOf(subType)
+        ))
+        // Has both instance name and subtypes
+        assertFalse(responseMatchesInstanceNameAndSubtypes(
+                response,
+                serviceInstanceName,
+                listOf(subType)
+        ))
+        assertTrue(responseMatchesInstanceNameAndSubtypes(
+                responseWithSubType,
+                serviceInstanceName,
+                listOf(subType)
+        ))
+        // Has other instance name
+        assertFalse(responseMatchesInstanceNameAndSubtypes(
+                response,
+                "OtherTestService",
+                emptyList() /* subTypes */
+        ))
+        assertFalse(responseMatchesInstanceNameAndSubtypes(
+                responseWithSubType,
+                "OtherTestService",
+                emptyList() /* subTypes */
+        ))
+        // Has other subtypes
+        assertFalse(responseMatchesInstanceNameAndSubtypes(
+                response,
+                null /* instanceName */,
+                listOf("othersubtype")
+        ))
+        assertFalse(responseMatchesInstanceNameAndSubtypes(
+                responseWithSubType,
+                null /* instanceName */,
+                listOf("othersubtype")
+        ))
     }
 }
diff --git a/tests/unit/java/com/android/server/connectivityservice/CSActiveNetworkInfoTest.kt b/tests/unit/java/com/android/server/connectivityservice/CSActiveNetworkInfoTest.kt
index 360a298949..1516938cb2 100644
--- a/tests/unit/java/com/android/server/connectivityservice/CSActiveNetworkInfoTest.kt
+++ b/tests/unit/java/com/android/server/connectivityservice/CSActiveNetworkInfoTest.kt
@@ -18,9 +18,7 @@ package com.android.server
 
 import android.net.INetd.PERMISSION_INTERNET
 import android.net.INetd.PERMISSION_NONE
-import android.net.NetworkCapabilities
 import android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET
-import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_VCN_MANAGED
 import android.net.NetworkCapabilities.TRANSPORT_WIFI
 import android.net.NetworkInfo.DetailedState.BLOCKED
 import android.net.NetworkInfo.DetailedState.CONNECTED
@@ -37,12 +35,6 @@ import org.mockito.ArgumentMatchers.anyBoolean
 import org.mockito.ArgumentMatchers.anyInt
 import org.mockito.Mockito.doReturn
 
-private fun nc() = NetworkCapabilities.Builder()
-        .addTransportType(TRANSPORT_WIFI)
-        .addCapability(NET_CAPABILITY_INTERNET)
-        .addCapability(NET_CAPABILITY_NOT_VCN_MANAGED)
-        .build()
-
 @RunWith(DevSdkIgnoreRunner::class)
 @SmallTest
 @IgnoreUpTo(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
@@ -56,7 +48,7 @@ class CSActiveNetworkInfoTest : CSTest() {
         deps.setChangeIdEnabled(changeEnabled, NETWORK_BLOCKED_WITHOUT_INTERNET_PERMISSION)
         doReturn(permissions).`when`(bpfNetMaps).getNetPermForUid(anyInt())
 
-        val agent = Agent(nc = nc())
+        val agent = Agent(nc = nc(TRANSPORT_WIFI, NET_CAPABILITY_INTERNET))
         agent.connect()
 
         val networkInfo = cm.activeNetworkInfo
diff --git a/tests/unit/java/com/android/server/connectivityservice/CSBlockedReasonsTest.kt b/tests/unit/java/com/android/server/connectivityservice/CSBlockedReasonsTest.kt
index 985d403fe3..c33dc69cb2 100644
--- a/tests/unit/java/com/android/server/connectivityservice/CSBlockedReasonsTest.kt
+++ b/tests/unit/java/com/android/server/connectivityservice/CSBlockedReasonsTest.kt
@@ -43,8 +43,8 @@ import android.os.Build
 import android.os.Process
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
 import com.android.testutils.DevSdkIgnoreRunner
-import com.android.testutils.RecorderCallback.CallbackEntry.BlockedStatusInt
 import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.BlockedStatusInt
 import org.junit.Test
 import org.junit.runner.RunWith
 import org.mockito.ArgumentMatchers.anyBoolean
diff --git a/tests/unit/java/com/android/server/connectivityservice/CSCaptivePortalAppTest.kt b/tests/unit/java/com/android/server/connectivityservice/CSCaptivePortalAppTest.kt
index 0bad60daa7..b66fcc9dac 100644
--- a/tests/unit/java/com/android/server/connectivityservice/CSCaptivePortalAppTest.kt
+++ b/tests/unit/java/com/android/server/connectivityservice/CSCaptivePortalAppTest.kt
@@ -23,22 +23,11 @@ import android.content.pm.PackageManager.PERMISSION_GRANTED
 import android.net.CaptivePortal
 import android.net.ConnectivityManager.ACTION_CAPTIVE_PORTAL_SIGN_IN
 import android.net.ConnectivityManager.EXTRA_CAPTIVE_PORTAL
-import android.net.IpPrefix
-import android.net.LinkAddress
-import android.net.LinkProperties
-import android.net.NetworkCapabilities
 import android.net.NetworkCapabilities.NET_CAPABILITY_CAPTIVE_PORTAL
 import android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET
-import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED
-import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_ROAMING
-import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_SUSPENDED
-import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_VCN_MANAGED
 import android.net.NetworkCapabilities.TRANSPORT_WIFI
 import android.net.NetworkRequest
-import android.net.NetworkScore
-import android.net.NetworkScore.KEEP_CONNECTED_FOR_TEST
 import android.net.NetworkStack
-import android.net.RouteInfo
 import android.os.Build
 import android.os.Bundle
 import androidx.test.filters.SmallTest
@@ -52,30 +41,6 @@ import org.mockito.ArgumentMatchers.anyInt
 import org.mockito.Mockito.never
 import org.mockito.Mockito.verify
 
-// This allows keeping all the networks connected without having to file individual requests
-// for them.
-private fun keepScore() = FromS(
-        NetworkScore.Builder().setKeepConnectedReason(KEEP_CONNECTED_FOR_TEST).build()
-)
-
-private fun nc(transport: Int, vararg caps: Int) = NetworkCapabilities.Builder().apply {
-    addTransportType(transport)
-    caps.forEach {
-        addCapability(it)
-    }
-    // Useful capabilities for everybody
-    addCapability(NET_CAPABILITY_NOT_RESTRICTED)
-    addCapability(NET_CAPABILITY_NOT_SUSPENDED)
-    addCapability(NET_CAPABILITY_NOT_ROAMING)
-    addCapability(NET_CAPABILITY_NOT_VCN_MANAGED)
-}.build()
-
-private fun lp(iface: String) = LinkProperties().apply {
-    interfaceName = iface
-    addLinkAddress(LinkAddress(LOCAL_IPV4_ADDRESS, 32))
-    addRoute(RouteInfo(IpPrefix("0.0.0.0/0"), null, null))
-}
-
 @DevSdkIgnoreRunner.MonitorThreadLeak
 @RunWith(DevSdkIgnoreRunner::class)
 @SmallTest
@@ -91,7 +56,7 @@ class CSCaptivePortalAppTest : CSTest() {
         val captivePortalRequest = NetworkRequest.Builder()
                 .addCapability(NET_CAPABILITY_CAPTIVE_PORTAL).build()
         cm.registerNetworkCallback(captivePortalRequest, captivePortalCallback)
-        val wifiAgent = createWifiAgent()
+        val wifiAgent = Agent(WIFI_IFACE, TRANSPORT_WIFI, NET_CAPABILITY_INTERNET)
         wifiAgent.connectWithCaptivePortal(TEST_REDIRECT_URL)
         captivePortalCallback.expectAvailableCallbacksUnvalidated(wifiAgent)
         val signInIntent = startCaptivePortalApp(wifiAgent)
@@ -106,14 +71,6 @@ class CSCaptivePortalAppTest : CSTest() {
         verify(wifiAgent.networkMonitor, never()).forceReevaluation(anyInt())
     }
 
-    private fun createWifiAgent(): CSAgentWrapper {
-        return Agent(
-            score = keepScore(),
-            lp = lp(WIFI_IFACE),
-                nc = nc(TRANSPORT_WIFI, NET_CAPABILITY_INTERNET)
-        )
-    }
-
     private fun startCaptivePortalApp(networkAgent: CSAgentWrapper): Intent {
         val network = networkAgent.network
         cm.startCaptivePortalApp(network)
diff --git a/tests/unit/java/com/android/server/connectivityservice/CSDeclaredMethodsForCallbacksTest.kt b/tests/unit/java/com/android/server/connectivityservice/CSDeclaredMethodsForCallbacksTest.kt
index b179aac770..f1c2143a54 100644
--- a/tests/unit/java/com/android/server/connectivityservice/CSDeclaredMethodsForCallbacksTest.kt
+++ b/tests/unit/java/com/android/server/connectivityservice/CSDeclaredMethodsForCallbacksTest.kt
@@ -35,8 +35,8 @@ import com.android.server.defaultLp
 import com.android.server.defaultNc
 import com.android.testutils.DevSdkIgnoreRule
 import com.android.testutils.DevSdkIgnoreRunner
-import com.android.testutils.RecorderCallback.CallbackEntry
 import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event
 import com.android.testutils.tryTest
 import java.lang.reflect.Modifier
 import java.util.concurrent.atomic.AtomicInteger
@@ -127,11 +127,11 @@ class CSDeclaredMethodsForCallbacksTest : CSTest() {
         waitForIdle()
 
         // Only callbacks for the corresponding flags are called
-        requestCb.expect<CallbackEntry.LinkPropertiesChanged>()
-        requestCb.expect<CallbackEntry.Lost>()
+        requestCb.expect<Event.LinkPropertiesChanged>()
+        requestCb.expect<Event.Lost>()
         requestCb.assertNoCallback(timeoutMs = 0L)
 
-        listenCb.expect<CallbackEntry.CapabilitiesChanged>()
+        listenCb.expect<Event.CapabilitiesChanged>()
         listenCb.assertNoCallback(timeoutMs = 0L)
     }
 
diff --git a/tests/unit/java/com/android/server/connectivityservice/CSDefaultNetworkRematchMetricsTest.kt b/tests/unit/java/com/android/server/connectivityservice/CSDefaultNetworkRematchMetricsTest.kt
new file mode 100644
index 0000000000..d95fdf42f2
--- /dev/null
+++ b/tests/unit/java/com/android/server/connectivityservice/CSDefaultNetworkRematchMetricsTest.kt
@@ -0,0 +1,205 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server
+
+import android.net.INetd
+import android.net.Network
+import android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET
+import android.net.NetworkCapabilities.TRANSPORT_CELLULAR
+import android.net.NetworkCapabilities.TRANSPORT_WIFI
+import android.net.UidRange
+import android.os.Build
+import com.android.server.ConnectivityService.PREFERENCE_ORDER_SATELLITE_FALLBACK
+import com.android.server.ConnectivityStatsLog.DEFAULT_NETWORK_REMATCH__REMATCH_REASON__RMR_NETWORK_DISCONNECTED
+import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
+import com.android.testutils.DevSdkIgnoreRunner
+import com.android.testutils.postAndWait
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.ArgumentMatchers.argThat
+import org.mockito.ArgumentMatchers.eq
+import org.mockito.InOrder
+import org.mockito.Mockito.atLeastOnce
+import org.mockito.Mockito.inOrder
+import org.mockito.Mockito.verify
+
+private const val DEFAULT_REQUEST_ID = 1
+private const val TEST_UID = 1234
+private const val TEST_UID2 = 5678
+
+// Timestamp constants. They need to be chosen to prevent a difference between
+// any two of them from being equal to a difference between another two
+// (or more) of them. This ensures that wrong duration calculations won't pass
+// the tests accidentally.
+private const val t0 = 0L
+private const val t1 = 11L
+private const val t2 = 23L
+private const val t3 = 38L
+private const val t4 = 56L
+
+@IgnoreUpTo(Build.VERSION_CODES.TIRAMISU)
+@RunWith(DevSdkIgnoreRunner::class)
+class CSDefaultNetworkRematchMetricsTest : CSTest() {
+    companion object {
+        private val NO_SERVICE_NETWORK = Network(INetd.UNREACHABLE_NET_ID)
+    }
+
+    @Test
+    fun testRematchWritesStats() {
+        val inOrder = inOrder(defaultNetworkRematchMetrics)
+
+        // 1. Connect a cellular network. It becomes the default.
+        deps.elapsedRealtime = t1
+        val naiCell = Agent(nc = nc(TRANSPORT_CELLULAR, NET_CAPABILITY_INTERNET))
+        naiCell.connect(true)
+        expectAddEvent(inOrder, DEFAULT_REQUEST_ID, null, naiCell.network, t1 - t0)
+        inOrder.verify(defaultNetworkRematchMetrics, atLeastOnce()).writeStatsAndClear()
+
+        // 2. Connect a WiFi network. It has a higher score and will cause a rematch.
+        deps.elapsedRealtime = t2
+        val naiWifi = Agent(nc = nc(TRANSPORT_WIFI, NET_CAPABILITY_INTERNET))
+        naiWifi.connect(true)
+
+        // 3. Verify: The rematch should trigger writing the stats.
+        expectAddEvent(inOrder, DEFAULT_REQUEST_ID, naiCell.network, naiWifi.network, t2 - t1)
+        inOrder.verify(defaultNetworkRematchMetrics, atLeastOnce()).writeStatsAndClear()
+        inOrder.verifyNoMoreInteractions()
+    }
+
+    @Test
+    fun testDisconnectWritesStats() {
+        val inOrder = inOrder(defaultNetworkRematchMetrics)
+
+        // 1. Connect a cellular network. It becomes the default.
+        deps.elapsedRealtime = t1
+        val naiCell = Agent(nc = nc(TRANSPORT_CELLULAR, NET_CAPABILITY_INTERNET))
+        naiCell.connect(true)
+        expectAddEvent(inOrder, DEFAULT_REQUEST_ID, null, naiCell.network, t1 - t0)
+        inOrder.verify(defaultNetworkRematchMetrics).writeStatsAndClear()
+        inOrder.verifyNoMoreInteractions()
+
+        // 2. Disconnect the cellular network.
+        deps.elapsedRealtime = t2
+        naiCell.disconnect()
+        waitForIdle()
+
+        // 3. Verify: Disconnecting the default network should trigger writing the stats.
+        expectAddEvent(inOrder, DEFAULT_REQUEST_ID, naiCell.network, null, t2 - t1)
+        inOrder.verify(defaultNetworkRematchMetrics).writeStatsAndClear(
+                DEFAULT_NETWORK_REMATCH__REMATCH_REASON__RMR_NETWORK_DISCONNECTED
+        )
+        // Caused by rematch.
+        inOrder.verify(defaultNetworkRematchMetrics).writeStatsAndClear()
+        inOrder.verifyNoMoreInteractions()
+    }
+
+    private fun expectAddEvent(
+            inOrder: InOrder,
+            requestId: Int,
+            oldNetwork: Network?,
+            newNetwork: Network?,
+            satisfiedDurationMs: Long
+    ) {
+        inOrder.verify(defaultNetworkRematchMetrics).addEvent(
+                argThat { it.mRequests.firstOrNull()?.requestId == requestId },
+                argThat { it?.network == oldNetwork },
+                argThat { it?.network == newNetwork },
+                eq(satisfiedDurationMs)
+        )
+    }
+
+    private fun expectAddSatelliteEvent(
+            inOrder: InOrder,
+            expectedUid: Int,
+            oldNetwork: Network?,
+            newNetwork: Network?,
+            expectedSatisfiedDuration: Long
+    ) {
+        inOrder.verify(defaultNetworkRematchMetrics).addEvent(
+                argThat {
+                    it.preferenceOrderForNetd == PREFERENCE_ORDER_SATELLITE_FALLBACK &&
+                            it.uids.contains(UidRange(expectedUid, expectedUid))
+                },
+                argThat { it?.network == oldNetwork },
+                argThat { it?.network == newNetwork },
+                eq(expectedSatisfiedDuration)
+        )
+    }
+
+    private fun updateSatelliteNetworkFallbackUids(messagingUids: Set<Int>, optinUids: Set<Int>) {
+        csHandler.postAndWait {
+            deps.satelliteNetworkFallbackUidUpdate!!.accept(messagingUids, optinUids)
+        }
+    }
+
+    @Test
+    fun testReplaceSatelliteRequestWritesStats() {
+        val inOrder = inOrder(defaultNetworkRematchMetrics)
+
+        // Trigger CS to add the SATELLITE_FALLBACK multilayer network request.
+        // Only an opt-in UID multilayer request is created since there is no
+        // role-sms UID.
+        // The satellite request is created and immediately satisfied by NO_SERVICE_NETWORK
+        // if it rematches when no network is available.
+        deps.elapsedRealtime = t1
+        updateSatelliteNetworkFallbackUids(setOf(), setOf(TEST_UID))
+        // The request created and rematched immediately so it satisfied by null with no time.
+        expectAddSatelliteEvent(inOrder, TEST_UID, null, NO_SERVICE_NETWORK, 0)
+
+        // Connect a cellular network. Expect an event indicating the NO_SERVICE_NETWORK
+        // was satisfied for the duration t2 - t1.
+        deps.elapsedRealtime = t2
+        val naiCell = Agent(nc = nc(TRANSPORT_CELLULAR, NET_CAPABILITY_INTERNET))
+        naiCell.connect(true)
+        expectAddEvent(inOrder, DEFAULT_REQUEST_ID, null, naiCell.network, t2 - t0)
+        expectAddSatelliteEvent(inOrder, TEST_UID, NO_SERVICE_NETWORK, naiCell.network, t2 - t1)
+        verify(defaultNetworkRematchMetrics, atLeastOnce()).writeStatsAndClear()
+
+        // Make a UID list update to trigger the multilayer requests replacement:
+        //  1. Remove opt-in UID request for TEST_UID.
+        //  2. Create opt-in UID request for TEST_UID + TEST_UID2.
+        deps.elapsedRealtime = t3
+        updateSatelliteNetworkFallbackUids(setOf(), setOf(TEST_UID, TEST_UID2))
+        // The removed request reports nothing.
+        // TODO: Consider reports another event when the request is being removed.
+        //  Uncomment expectAddSatelliteEvent(inOrder, TEST_UID, naiCell.network, null, t3 - t2)
+        //  Or alternatively copy the satisfiedTime from the removed requests.
+        // The just created request satisfied by cell immediately.
+        expectAddSatelliteEvent(inOrder, TEST_UID, null, naiCell.network, 0)
+        inOrder.verify(defaultNetworkRematchMetrics, atLeastOnce()).writeStatsAndClear()
+        inOrder.verifyNoMoreInteractions()
+
+        deps.elapsedRealtime = t4
+        naiCell.disconnect()
+        // Wait for idle is needed to keep this test stable after disconnection because
+        // networkCallback<LOST> fired before addEvent.
+        waitForIdle()
+        // Verify: Disconnecting the default network should trigger writing the stats.
+        // The device reports cell satisfied for t4 - t3, with a transition null -> no service.
+        // This is because the original request is removed when updating the uid list and the
+        // duration is only calculated for the newly created request at t3.
+        expectAddEvent(inOrder, DEFAULT_REQUEST_ID, naiCell.network, null, t4 - t2)
+        expectAddSatelliteEvent(inOrder, TEST_UID, naiCell.network, null, t4 - t3)
+        inOrder.verify(defaultNetworkRematchMetrics).writeStatsAndClear(
+                DEFAULT_NETWORK_REMATCH__REMATCH_REASON__RMR_NETWORK_DISCONNECTED
+        )
+        // Caused by rematch.
+        expectAddSatelliteEvent(inOrder, TEST_UID, null, NO_SERVICE_NETWORK, 0)
+        inOrder.verify(defaultNetworkRematchMetrics).writeStatsAndClear()
+        inOrder.verifyNoMoreInteractions()
+    }
+}
diff --git a/tests/unit/java/com/android/server/connectivityservice/CSDestroySocketTest.kt b/tests/unit/java/com/android/server/connectivityservice/CSDestroySocketTest.kt
index bc5be7865c..aeeced6579 100644
--- a/tests/unit/java/com/android/server/connectivityservice/CSDestroySocketTest.kt
+++ b/tests/unit/java/com/android/server/connectivityservice/CSDestroySocketTest.kt
@@ -24,38 +24,105 @@ import android.net.ConnectivityManager.BLOCKED_REASON_NONE
 import android.net.ConnectivityManager.FIREWALL_CHAIN_BACKGROUND
 import android.net.ConnectivityManager.FIREWALL_RULE_ALLOW
 import android.net.ConnectivityManager.FIREWALL_RULE_DENY
+import android.net.INetd
+import android.net.LinkAddress
 import android.net.LinkProperties
 import android.net.NetworkCapabilities
+import android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET
+import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_SUSPENDED
+import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_VCN_MANAGED
+import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_VPN
+import android.net.NetworkCapabilities.TRANSPORT_BLUETOOTH
+import android.net.NetworkCapabilities.TRANSPORT_CELLULAR
+import android.net.NetworkCapabilities.TRANSPORT_ETHERNET
+import android.net.NetworkCapabilities.TRANSPORT_TEST
+import android.net.NetworkCapabilities.TRANSPORT_VPN
+import android.net.NetworkCapabilities.TRANSPORT_WIFI
+import android.net.NetworkRequest
+import android.net.VpnManager
+import android.net.VpnTransportInfo
 import android.os.Build
+import android.util.Range
 import com.android.net.module.util.BaseNetdUnsolicitedEventListener
+import com.android.net.module.util.netlink.NetlinkConstants
+import com.android.net.module.util.netlink.RtNetlinkAddressMessage
+import com.android.net.module.util.netlink.StructIfaddrMsg
+import com.android.net.module.util.netlink.StructNlMsgHdr
+import com.android.server.NetIdManager.MAX_NET_ID
+import com.android.server.NetIdManager.MIN_NET_ID
 import com.android.server.connectivity.ConnectivityFlags.DELAY_DESTROY_SOCKETS
 import com.android.testutils.DevSdkIgnoreRule
 import com.android.testutils.DevSdkIgnoreRunner
+import com.android.testutils.TestableNetworkAgent.Event.OnNetworkDestroyed
+import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.CapabilitiesChanged
+import com.android.testutils.TestableNetworkCallback.Event.LinkPropertiesChanged
+import com.android.testutils.TestableNetworkCallback.Event.Lost
+import java.net.Inet6Address
+import java.net.InetAddress
+import junit.framework.Assert.assertFalse
+import junit.framework.Assert.assertTrue
+import kotlin.test.assertEquals
+import kotlin.test.assertNotNull
 import org.junit.Test
 import org.junit.runner.RunWith
 import org.mockito.ArgumentCaptor
 import org.mockito.Mockito.any
+import org.mockito.Mockito.anyInt
+import org.mockito.Mockito.doNothing
 import org.mockito.Mockito.doReturn
 import org.mockito.Mockito.inOrder
 import org.mockito.Mockito.never
+import org.mockito.Mockito.timeout
+import org.mockito.Mockito.times
 import org.mockito.Mockito.verify
 
 private const val TIMESTAMP = 1234L
 private const val TEST_UID = 1234
 private const val TEST_UID2 = 5678
+private val TEST_UID_RANGE1 = Range(10000, 20000)
+private val TEST_UID_RANGE2 = Range(21000, 30000)
+private val TEST_UID_RANGE3 = Range(31000, 40000)
 private const val TEST_CELL_IFACE = "test_rmnet"
 
-private fun cellNc() = NetworkCapabilities.Builder()
-        .addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR)
-        .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
-        .addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_SUSPENDED)
-        .addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VCN_MANAGED)
-        .build()
+private fun cellNc() = makeNc(TRANSPORT_CELLULAR)
 
-private fun cellLp() = LinkProperties().also{
-    it.interfaceName = TEST_CELL_IFACE
+private fun makeNc(transportType: Int) = nc(transportType, NET_CAPABILITY_INTERNET)
+
+private fun cellLp() = makeLp(TEST_CELL_IFACE)
+
+private fun vpnNc(uidRanges: Set<Range<Int>>) = NetworkCapabilities.Builder()
+    .addTransportType(TRANSPORT_VPN)
+    .setTransportInfo(
+        VpnTransportInfo(
+            VpnManager.TYPE_VPN_PLATFORM,
+            null /* sessionId */,
+            false /* bypassable */,
+            false /* longLivedTcpConnectionsExpensive */
+        )
+    )
+    .removeCapability(NET_CAPABILITY_NOT_VPN)
+    .addCapability(NET_CAPABILITY_INTERNET)
+    .addCapability(NET_CAPABILITY_NOT_SUSPENDED)
+    .addCapability(NET_CAPABILITY_NOT_VCN_MANAGED)
+    .setUids(uidRanges)
+    .build()
+
+private fun makeLp(interfaceName: String) = LinkProperties().also{
+    it.interfaceName = interfaceName
 }
 
+private fun makeRequest(nc: NetworkCapabilities) = NetworkRequest.Builder()
+    .clearCapabilities()
+    .setCapabilities(nc)
+    .build()
+
+private fun makeVpnRequest(uidRanges: Set<Range<Int>>) = NetworkRequest.Builder()
+    .clearCapabilities()
+    .addTransportType(TRANSPORT_VPN)
+    .setUids(uidRanges)
+    .build()
+
 @RunWith(DevSdkIgnoreRunner::class)
 @DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
 class CSDestroySocketTest : CSTest() {
@@ -155,7 +222,6 @@ class CSDestroySocketTest : CSTest() {
     @Test
     fun testReplaceFirewallChain() {
         val netdEventListener = getRegisteredNetdUnsolicitedEventListener()
-        val inOrder = inOrder(destroySocketsWrapper)
 
         val cellAgent = Agent(nc = cellNc(), lp = cellLp())
         cellAgent.connect()
@@ -193,8 +259,8 @@ class CSDestroySocketTest : CSTest() {
                 .`when`(bpfNetMaps).getUidNetworkingBlockedReasons(TEST_UID2)
         cm.replaceFirewallChain(FIREWALL_CHAIN_BACKGROUND, intArrayOf(TEST_UID2))
         waitForIdle()
-        inOrder.verify(destroySocketsWrapper, never())
-                .destroyLiveTcpSocketsByOwnerUids(setOf(TEST_UID))
+        verify(destroySocketsWrapper, never()).destroyLiveTcpSocketsByOwnerUids(setOf(TEST_UID))
+        verify(quicConnectionCloser, never()).closeQuicConnectionByUids(setOf(TEST_UID))
 
         netdEventListener.onInterfaceClassActivityChanged(
                 true, // isActive
@@ -203,8 +269,8 @@ class CSDestroySocketTest : CSTest() {
                 TEST_UID
         )
         waitForIdle()
-        inOrder.verify(destroySocketsWrapper)
-                .destroyLiveTcpSocketsByOwnerUids(setOf(TEST_UID))
+        verify(destroySocketsWrapper).destroyLiveTcpSocketsByOwnerUids(setOf(TEST_UID))
+        verify(quicConnectionCloser).closeQuicConnectionByUids(setOf(TEST_UID))
 
         cellAgent.disconnect()
     }
@@ -277,8 +343,10 @@ class CSDestroySocketTest : CSTest() {
 
         if (expectDestroySockets) {
             verify(destroySocketsWrapper).destroyLiveTcpSocketsByOwnerUids(setOf(TEST_UID))
+            verify(quicConnectionCloser).closeQuicConnectionByUids(setOf(TEST_UID))
         } else {
             verify(destroySocketsWrapper, never()).destroyLiveTcpSocketsByOwnerUids(setOf(TEST_UID))
+            verify(quicConnectionCloser, never()).closeQuicConnectionByUids(setOf(TEST_UID))
         }
     }
 
@@ -335,4 +403,469 @@ class CSDestroySocketTest : CSTest() {
                 expectDestroySockets = false
         )
     }
+
+    private fun InetAddress.toLinkAddress() =
+        LinkAddress(this, if (this is Inet6Address) 64 else 24)
+
+    private fun prepareNetworkAgent(
+        interfaceName: String,
+        addresses: List<LinkAddress>,
+        nc: NetworkCapabilities
+    ): Pair<CSAgentWrapper, TestableNetworkCallback> {
+        val callback = TestableNetworkCallback()
+        cm.registerNetworkCallback(makeRequest(nc), callback)
+        val linkProperties = makeLp(interfaceName)
+        for (linkAddress in addresses) {
+            linkProperties.addLinkAddress(linkAddress)
+        }
+        val agent = Agent(nc = nc, lp = linkProperties)
+        agent.connect()
+        return agent to callback
+    }
+
+    @Test
+    fun testIpToNetworksMap() {
+        val addressV6_1 = InetAddress.getByName("2001:DB8:0100::1111")
+        val addressV6_2 = InetAddress.getByName("2001:DB8:0200::2222")
+        val addressV6_3 = InetAddress.getByName("2001:DB8:0333::3333")
+        val addressV6LinkLocal = InetAddress.getByName("FE80::1234")
+        val addressV4_1 = InetAddress.getByName("192.0.2.10")
+        val addressV4_2 = InetAddress.getByName("192.0.2.11")
+        // Creates 3 NetworkAgent with various IP addresses(some are used for only one network
+        // agent some are used for multiple network agents.)
+
+        val (cellAgent, cellCallback) = prepareNetworkAgent(
+            "rmnet1",
+            arrayListOf(addressV6_1.toLinkAddress(), addressV4_1.toLinkAddress()),
+            makeNc(transportType = TRANSPORT_CELLULAR)
+        )
+
+        val (wlanAgent, wlanCallback) = prepareNetworkAgent(
+            "wlan1",
+            arrayListOf(addressV6_2.toLinkAddress(), addressV4_1.toLinkAddress()),
+            makeNc(transportType = TRANSPORT_WIFI)
+        )
+        val (ethAgent, ethCallback) = prepareNetworkAgent(
+            "eth2",
+            arrayListOf(addressV6_2.toLinkAddress(), addressV4_2.toLinkAddress()),
+            makeNc(transportType = TRANSPORT_ETHERNET)
+        )
+        val ipToNetworksMap = assertNotNull(service.mIpToNetworksMap)
+        fun InetAddress.getNetworks() = ipToNetworksMap[this]!!.map{ it.network }.toSet()
+
+        // Verify mIpToNetworksMap properly stores network agents based on IP addresses.
+        assertEquals(setOf(cellAgent.network), addressV6_1.getNetworks())
+        assertEquals(
+            setOf(wlanAgent.network, ethAgent.network),
+            addressV6_2.getNetworks()
+        )
+        assertEquals(
+            setOf(wlanAgent.network, cellAgent.network),
+            addressV4_1.getNetworks()
+        )
+        assertEquals(setOf(ethAgent.network), addressV4_2.getNetworks())
+
+        // Disconnect network agent#2 & #3.
+        wlanAgent.disconnect()
+        ethAgent.disconnect()
+        // Update only interface name without IP address change for network agent #1.
+        val linkProperties = makeLp("ipsec1")
+        linkProperties.addLinkAddress(addressV4_1.toLinkAddress())
+        linkProperties.addLinkAddress(addressV6_1.toLinkAddress())
+        cellAgent.sendLinkProperties(linkProperties)
+        cellCallback.eventuallyExpect<LinkPropertiesChanged> {
+            it.network == cellAgent.network && it.lp.interfaceName == "ipsec1"
+        }
+
+        // Verify mIpToNetworksMap for the LinkPropertiesChanged
+        assertFalse(ipToNetworksMap.containsKey(addressV6_2))
+        assertFalse(ipToNetworksMap.containsKey(addressV4_2))
+        assertEquals(setOf(cellAgent.network), addressV6_1.getNetworks())
+        assertEquals(setOf(cellAgent.network), addressV4_1.getNetworks())
+
+        // Change IP addresses for network agent #1.
+        val linkProperties2 = makeLp("rmnet1")
+        linkProperties2.addLinkAddress(addressV4_2.toLinkAddress())
+        linkProperties2.addLinkAddress(addressV6_1.toLinkAddress())
+        linkProperties2.addLinkAddress(addressV6_3.toLinkAddress())
+        cellAgent.sendLinkProperties(linkProperties2)
+        // Add network agent#4
+        val (agent4, callback4) = prepareNetworkAgent(
+            "bt1",
+            arrayListOf(addressV6LinkLocal.toLinkAddress(), addressV4_2.toLinkAddress()),
+            makeNc(transportType = TRANSPORT_BLUETOOTH)
+        )
+        assertEquals(3, ipToNetworksMap.size)
+        assertEquals(setOf(cellAgent.network), addressV6_1.getNetworks())
+        assertEquals(
+            setOf(cellAgent.network, agent4.network),
+            addressV4_2.getNetworks()
+        )
+        assertEquals(setOf(cellAgent.network), addressV6_3.getNetworks())
+        assertFalse(ipToNetworksMap.containsKey(addressV4_1))
+        // This map doesn't handle IPv6 link local addresses.
+        assertFalse(ipToNetworksMap.containsKey(addressV6LinkLocal))
+
+        // Disconnect all remaining network agents.
+        cellAgent.disconnect()
+        agent4.disconnect()
+        agent4.eventuallyExpect<OnNetworkDestroyed>()
+        // Verify mIpToNetworksMap is empty.
+        assertTrue(ipToNetworksMap.isEmpty())
+    }
+
+    @Test
+    fun testDestroySocketForRemovedIpAddressFromSingleNetwork() {
+        val addressV6_1 = InetAddress.getByName("2001:DB8:0100::1111")
+        val addressV6_2 = InetAddress.getByName("2001:DB8:0200::2222")
+        // add a test network.
+        val (agent1, callback1) = prepareNetworkAgent(
+            "wlan2",
+            arrayListOf(addressV6_1.toLinkAddress()),
+            makeNc(transportType = TRANSPORT_WIFI)
+        )
+
+        // IP address changed
+        val linkProperties2 = makeLp("wlan2")
+        linkProperties2.addLinkAddress(addressV6_2.toLinkAddress())
+        agent1.sendLinkProperties(linkProperties2)
+        callback1.eventuallyExpect<LinkPropertiesChanged> {
+            it.network == agent1.network && !it.lp.addresses.contains(addressV6_1)
+        }
+        // verify destroy sockets on the removed IP address
+        verify(destroySocketsWrapper).destroyLiveTcpSocketsByLocalAddress(
+            addressV6_1,
+            setOf(Range.create(MIN_NET_ID, MAX_NET_ID)),
+            null
+        )
+
+        // network disconnect
+        agent1.disconnect()
+        agent1.eventuallyExpect<OnNetworkDestroyed>()
+        // verify destroy sockets on the removed IP address
+        verify(destroySocketsWrapper).destroyLiveTcpSocketsByLocalAddress(
+            addressV6_2,
+            setOf(Range.create(MIN_NET_ID, MAX_NET_ID)),
+            null
+        )
+        verify(destroySocketsWrapper, never()).destroyLiveTcpSocketsByLocalAddress(any(), anyInt())
+    }
+
+    @Test
+    fun testDestroySocketForRemovedIpAddressFromMultipleNonVpnNetworks() {
+        val addressV6_1 = InetAddress.getByName("2001:DB8:0100::1111")
+        val addressV6_2 = InetAddress.getByName("2001:DB8:0200::2222")
+        val addressV6LinkLocal = InetAddress.getByName("FE80::1234")
+        val addressV4_1 = InetAddress.getByName("192.0.2.10")
+
+        // add 4 test networks(non VPN). 3 have a same IP address, and 1 network has different one.
+        val (cellAgent, cellCallback) = prepareNetworkAgent(
+            "rmnet1",
+            arrayListOf(addressV6_1.toLinkAddress(), addressV4_1.toLinkAddress()),
+            makeNc(transportType = TRANSPORT_CELLULAR)
+        )
+
+        val (wlanAgent, wlanCallback) = prepareNetworkAgent(
+            "wlan0",
+            arrayListOf(),
+            makeNc(transportType = TRANSPORT_WIFI)
+        )
+
+        val (testAgent, testCallback) = prepareNetworkAgent(
+            "test2",
+            arrayListOf(addressV6_2.toLinkAddress()),
+            makeNc(transportType = TRANSPORT_TEST)
+        )
+
+        val (ethAgent, ethCallback) = prepareNetworkAgent(
+            "eth1",
+            arrayListOf(addressV6_1.toLinkAddress()),
+            makeNc(transportType = TRANSPORT_ETHERNET)
+        )
+
+        // Add IP addresses on network#2
+        val linkProperties = makeLp("wlan0")
+        linkProperties.addLinkAddress(addressV6LinkLocal.toLinkAddress())
+        linkProperties.addLinkAddress(addressV6_1.toLinkAddress())
+        wlanAgent.sendLinkProperties(linkProperties)
+
+        // Remove IP addresses network#1
+        val linkProperties1 = makeLp("rmnet1")
+        cellAgent.sendLinkProperties(linkProperties1)
+        cellCallback.eventuallyExpect<LinkPropertiesChanged> {
+            it.network == cellAgent.network && it.lp.addresses.size == 0
+        }
+
+        // verify destroy sockets on the removed IP address and exempt netId lists.
+        verify(destroySocketsWrapper).destroyLiveTcpSocketsByLocalAddress(
+            addressV6_1,
+            setOf(
+                Range.create(MIN_NET_ID, wlanAgent.network.netId - 1),
+                Range.create(wlanAgent.network.netId + 1, ethAgent.network.netId - 1),
+                Range.create(ethAgent.network.netId + 1, MAX_NET_ID)
+            ),
+            null
+        )
+        // verify destroy sockets on the removed IP address
+        verify(destroySocketsWrapper).destroyLiveTcpSocketsByLocalAddress(
+            addressV4_1,
+            setOf(Range.create(MIN_NET_ID, MAX_NET_ID)),
+            null
+        )
+
+        // Remove IP addresses from network#2
+        val linkProperties2 = makeLp("wlan3")
+        wlanAgent.sendLinkProperties(linkProperties2)
+        wlanCallback.eventuallyExpect<LinkPropertiesChanged> {
+            it.network == wlanAgent.network && it.lp.interfaceName == "wlan3"
+        }
+        // verify destroy sockets on the removed IP address and exempt netId lists.
+        verify(destroySocketsWrapper).destroyLiveTcpSocketsByLocalAddress(
+            addressV6_1,
+            setOf(
+                Range.create(MIN_NET_ID, ethAgent.network.netId - 1),
+                Range.create(ethAgent.network.netId + 1, MAX_NET_ID)
+            ),
+            null
+        )
+        // verify not to destroy sockets on the link local address at NetworkAgent update.
+        verify(destroySocketsWrapper, never()).destroyLiveTcpSocketsByLocalAddress(
+            addressV6LinkLocal,
+            setOf(Range.create(MIN_NET_ID, MAX_NET_ID)),
+            null
+        )
+
+        // disconnect all test networks
+        cellAgent.disconnect()
+        wlanAgent.disconnect()
+        testAgent.disconnect()
+        ethAgent.disconnect()
+        ethAgent.eventuallyExpect<OnNetworkDestroyed>()
+
+        // verify destroy sockets on the removed IP address
+        verify(destroySocketsWrapper).destroyLiveTcpSocketsByLocalAddress(
+            addressV6_2,
+            setOf(Range.create(MIN_NET_ID, MAX_NET_ID)),
+            null
+        )
+        verify(destroySocketsWrapper).destroyLiveTcpSocketsByLocalAddress(
+            addressV6_1,
+            setOf(Range.create(MIN_NET_ID, MAX_NET_ID)),
+            null
+        )
+        verify(destroySocketsWrapper, never()).destroyLiveTcpSocketsByLocalAddress(any(), anyInt())
+    }
+
+    @Test
+    fun testDestroySocketForRemovedIpAddressFromMultipleVpnNetworks() {
+        val addressV6_1 = InetAddress.getByName("2001:DB8:0100::1111")
+        val addressV6_2 = InetAddress.getByName("2001:DB8:0200::2222")
+        val addressV6_3 = InetAddress.getByName("2001:DB8:0333::3333")
+        val addressV6LinkLocal = InetAddress.getByName("FE80::1234")
+        val addressV4_1 = InetAddress.getByName("192.0.2.10")
+        // add 3 VPN test networks and 1 non-VPN network.
+
+        val (vpnAgent1, vpnCallback1) = prepareNetworkAgent(
+            "ipsec1",
+            arrayListOf(addressV6_1.toLinkAddress(), addressV4_1.toLinkAddress()),
+            vpnNc(setOf(TEST_UID_RANGE1))
+        )
+
+        val (vpnAgent2, vpnCallback2) = prepareNetworkAgent(
+            "ipsec2",
+            arrayListOf(addressV6LinkLocal.toLinkAddress(), addressV6_1.toLinkAddress()),
+            vpnNc(setOf(TEST_UID_RANGE2))
+        )
+        val (vpnAgent3, vpnCallback3) = prepareNetworkAgent(
+            "ipsec3",
+            arrayListOf(addressV6_1.toLinkAddress()),
+            vpnNc(setOf(TEST_UID_RANGE3))
+        )
+        val (testAgent, testCallback) = prepareNetworkAgent(
+            "test4",
+            arrayListOf(addressV6_2.toLinkAddress(), addressV4_1.toLinkAddress()),
+            makeNc(TRANSPORT_TEST)
+        )
+        // Remove IP addresses network#1
+        val linkProperties1 = makeLp("ipsec21")
+        vpnAgent1.sendLinkProperties(linkProperties1)
+        vpnCallback1.eventuallyExpect<LinkPropertiesChanged> {
+            it.network == vpnAgent1.network && it.lp.interfaceName == "ipsec21"
+        }
+        // verify destroy sockets on the removed IP address(TEST_IPV6_ADDRESS1) and VPN's uid range.
+        verify(destroySocketsWrapper).destroyLiveTcpSocketsByLocalAddress(
+            addressV6_1,
+            setOf(Range.create(MIN_NET_ID, MAX_NET_ID)),
+            vpnAgent1.nc.uids
+        )
+        // verify destroy sockets on the removed IP address(TEST_IPV4_ADDRESS1). network#1 and
+        // network#4 use TEST_IPV4_ADDRESS1, however network#4 is not VPN network, so we destroy
+        // sockets only based on the removed IP address.
+        verify(destroySocketsWrapper).destroyLiveTcpSocketsByLocalAddress(
+            addressV4_1,
+            setOf(Range.create(MIN_NET_ID, MAX_NET_ID)),
+            null
+        )
+
+        // Change IP addresses network#2
+        val linkProperties2 = makeLp("ipsec2")
+        linkProperties2.addLinkAddress(addressV6_3.toLinkAddress())
+        vpnAgent2.sendLinkProperties(linkProperties2)
+        vpnCallback2.eventuallyExpect<LinkPropertiesChanged> { it.network == vpnAgent2.network &&
+                it.lp.interfaceName == "ipsec2" && it.lp.addresses.contains(addressV6_3)
+        }
+        // verify destroy sockets on the removed IP address(TEST_IPV6_ADDRESS1) and VPN's uid range.
+        verify(destroySocketsWrapper).destroyLiveTcpSocketsByLocalAddress(
+            addressV6_1,
+            setOf(Range.create(MIN_NET_ID, MAX_NET_ID)),
+            vpnAgent2.nc.uids
+        )
+        // verify not to destroy sockets on the link local address at NetworkAgent update.
+        verify(destroySocketsWrapper, never()).destroyLiveTcpSocketsByLocalAddress(
+            addressV6LinkLocal,
+            setOf(Range.create(MIN_NET_ID, MAX_NET_ID)),
+            null
+        )
+
+        // disconnect all test networks
+        vpnAgent1.disconnect()
+        vpnAgent2.disconnect()
+        vpnAgent3.disconnect()
+        testAgent.disconnect()
+        testAgent.eventuallyExpect<OnNetworkDestroyed>()
+
+        // verify destroy sockets on the removed IP address.
+        verify(destroySocketsWrapper).destroyLiveTcpSocketsByLocalAddress(
+            addressV6_3,
+            setOf(Range.create(MIN_NET_ID, MAX_NET_ID)),
+            null
+        )
+        verify(destroySocketsWrapper).destroyLiveTcpSocketsByLocalAddress(
+            addressV6_2,
+            setOf(Range.create(MIN_NET_ID, MAX_NET_ID)),
+            null
+        )
+        verify(destroySocketsWrapper, times(2)).destroyLiveTcpSocketsByLocalAddress(
+            addressV4_1,
+            setOf(Range.create(MIN_NET_ID, MAX_NET_ID)),
+            null
+        )
+        verify(destroySocketsWrapper, never()).destroyLiveTcpSocketsByLocalAddress(any(), anyInt())
+    }
+
+    @Test
+    fun testDestroySocketWithNetlinkMessageForLinkLocalAddress() {
+        val addressV6LinkLocal = InetAddress.getByName("FE80::1234")
+        val testInterfaceId = 10
+        val nlMsgLinkLocalAddressRemoved = RtNetlinkAddressMessage(
+            StructNlMsgHdr(
+                30 /* payload length */,
+                NetlinkConstants.RTM_DELADDR,
+                0 /* flages */,
+                0 /* seq */
+            ),
+            StructIfaddrMsg(
+                10 /* family */,
+                64 /* prefix length */,
+                0 /* flags */,
+                0 /* scope */,
+                testInterfaceId /* interfaceId */
+            ),
+            addressV6LinkLocal,
+            null,
+            0 /* flags */
+        )
+        csHandler.post{deps.netlinkMessageUpdate?.accept(nlMsgLinkLocalAddressRemoved)}
+
+        // verify destroy a socket on link local address with corresponding interface ID.
+        verify(destroySocketsWrapper, timeout(100)).destroyLiveTcpSocketsByLocalAddress(
+            addressV6LinkLocal,
+            testInterfaceId
+        )
+    }
+
+    @Test
+    fun testDestroySocketWithNetlinkMessageForOemNetwork() {
+        val addressV4 = InetAddress.getByName("203.0.113.10")
+        val nlMsgAddressRemoved = RtNetlinkAddressMessage(
+            StructNlMsgHdr(
+                30 /* payload length */,
+                NetlinkConstants.RTM_DELADDR,
+                0 /* flags */,
+                0 /* seq */
+            ),
+            StructIfaddrMsg(
+                10 /* family */,
+                64 /* prefix length */,
+                0 /* flags */,
+                0 /* scope */,
+                5 /* interfaceId */
+            ),
+            addressV4,
+            null,
+            0 /* flags */
+        )
+        csHandler.post{deps.netlinkMessageUpdate?.accept(nlMsgAddressRemoved)}
+
+        // verify destroy non platform socket(netId < MIN_NET_ID) with the RTM_DELADDR message
+        verify(destroySocketsWrapper, timeout(100)).destroyLiveTcpSocketsByLocalAddress(
+            addressV4,
+            setOf(Range.create(0, MIN_NET_ID - 1)),
+            null /* uidRanges */
+        )
+    }
+
+    @Test
+    fun testDestroySocketsLackingPermissionForPermissionUpdate() {
+        val inOrder = inOrder(destroySocketsWrapper)
+        val addressV6_1 = InetAddress.getByName("2001:DB8:0100::1111")
+        val addressV4_1 = InetAddress.getByName("192.0.2.10")
+
+        doNothing().`when`(netd).networkSetPermissionForNetwork(anyInt(), anyInt())
+
+        val ncRestricted =
+            cellNc().removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED)
+        val ncNotRestricted =
+            cellNc().addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED)
+
+        val (agent, callback) = prepareNetworkAgent(
+            "rmnet1",
+            arrayListOf(addressV6_1.toLinkAddress(), addressV4_1.toLinkAddress()),
+            ncRestricted
+        )
+
+        agent.sendNetworkCapabilities(ncNotRestricted)
+        callback.eventuallyExpect<CapabilitiesChanged> {
+            it.network == agent.network &&
+                    it.caps.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED)
+        }
+        inOrder.verify(destroySocketsWrapper, never())
+            .destroyLiveTcpSocketsLackingPermission(anyInt(), anyInt())
+        agent.sendNetworkCapabilities(ncRestricted)
+        callback.eventuallyExpect<Lost>()
+        inOrder.verify(destroySocketsWrapper, times(2))
+            .destroyLiveTcpSocketsLackingPermission(
+                agent.network.netId,
+                INetd.PERMISSION_SYSTEM
+            )
+    }
+
+    @Test
+    fun testDestroySocketsLackingPermissionForDelayedTeardown() {
+        val addressV6_1 = InetAddress.getByName("2001:DB8:0100::1111")
+        doNothing().`when`(netd).networkSetPermissionForNetwork(anyInt(), anyInt())
+        val (agent, callback) = prepareNetworkAgent(
+            "rmnet1",
+            arrayListOf(addressV6_1.toLinkAddress()),
+            makeNc(TRANSPORT_CELLULAR)
+        )
+        agent.sendTeardownDelayMs(1)
+        agent.disconnect()
+        agent.eventuallyExpect<OnNetworkDestroyed>()
+
+        verify(destroySocketsWrapper, times(2)).destroyLiveTcpSocketsLackingPermission(
+            agent.network.netId,
+            INetd.PERMISSION_SYSTEM
+        )
+    }
 }
diff --git a/tests/unit/java/com/android/server/connectivityservice/CSDestroyedNetworkTests.kt b/tests/unit/java/com/android/server/connectivityservice/CSDestroyedNetworkTests.kt
index b82453140c..3b511b150e 100644
--- a/tests/unit/java/com/android/server/connectivityservice/CSDestroyedNetworkTests.kt
+++ b/tests/unit/java/com/android/server/connectivityservice/CSDestroyedNetworkTests.kt
@@ -23,8 +23,8 @@ import android.os.Build
 import androidx.test.filters.SmallTest
 import com.android.testutils.DevSdkIgnoreRule
 import com.android.testutils.DevSdkIgnoreRunner
-import com.android.testutils.RecorderCallback.CallbackEntry.Lost
 import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.Lost
 import org.junit.Test
 import org.junit.runner.RunWith
 import org.mockito.ArgumentMatchers.anyInt
diff --git a/tests/unit/java/com/android/server/connectivityservice/CSEnforceMeteredApnPolicy.kt b/tests/unit/java/com/android/server/connectivityservice/CSEnforceMeteredApnPolicy.kt
new file mode 100644
index 0000000000..776d5c649a
--- /dev/null
+++ b/tests/unit/java/com/android/server/connectivityservice/CSEnforceMeteredApnPolicy.kt
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server
+
+import android.net.INetd.PERMISSION_INTERNET
+import android.net.INetd.PERMISSION_NONE
+import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_SUSPENDED
+import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_VCN_MANAGED
+import android.net.NetworkCapabilities.TRANSPORT_CELLULAR
+import android.net.NetworkProvider
+import android.net.NetworkRequest
+import android.net.NetworkScore
+import android.net.connectivity.ConnectivityCompatChanges.NETWORK_BLOCKED_WITHOUT_INTERNET_PERMISSION
+import android.os.Build
+import android.os.Process
+import androidx.test.filters.SmallTest
+import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
+import com.android.testutils.DevSdkIgnoreRunner
+import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkOfferCallback
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
+import org.mockito.Mockito.doReturn
+
+private const val TIMEOUT_MS = 5_000L
+private const val NO_CB_TIMEOUT_MS = 200L
+
+private fun cellNc() = nc(
+    TRANSPORT_CELLULAR,
+    NET_CAPABILITY_NOT_SUSPENDED,
+    NET_CAPABILITY_NOT_VCN_MANAGED
+)
+
+private fun cellRequest() = NetworkRequest.Builder()
+        .addTransportType(TRANSPORT_CELLULAR)
+        .build()
+
+@RunWith(DevSdkIgnoreRunner::class)
+@SmallTest
+@IgnoreUpTo(Build.VERSION_CODES.R)
+class CSEnforceMeteredApnPolicy : CSTest() {
+    @Parameterized.Parameter(0) lateinit var params: TestParams
+
+    data class TestParams(
+            val changeEnabled: Boolean,
+            val hasInternetPermission: Boolean,
+            val expectRequestMeteredNetwork: Boolean
+    )
+
+    companion object {
+        @JvmStatic
+        @Parameterized.Parameters
+        fun arguments() = listOf(
+                // For backwards compatibility, if the change is disabled and the uid does not have
+                // the internet permission, the uid can request metered network even if the uid is
+                // restricted from using metered networks.
+                TestParams(
+                        changeEnabled = false,
+                        hasInternetPermission = false,
+                        expectRequestMeteredNetwork = true
+                ),
+                // If the uid has the internet permission and the uid is restricted from using
+                // metered network, the uid cannot request metered network even if the change is
+                // disabled.
+                TestParams(
+                        changeEnabled = false,
+                        hasInternetPermission = true,
+                        expectRequestMeteredNetwork = false
+                ),
+                // If the change is enabled and the uid is restricted from using metered network,
+                // the uid cannot request metered network regardless of the internet permission.
+                TestParams(
+                        changeEnabled = true,
+                        hasInternetPermission = false,
+                        expectRequestMeteredNetwork = false
+                ),
+                TestParams(
+                        changeEnabled = true,
+                        hasInternetPermission = true,
+                        expectRequestMeteredNetwork = false
+                )
+        )
+    }
+
+    @Test
+    fun testEnforceMeteredApnPolicy() {
+        deps.setBuildSdk(VERSION_V)
+        deps.setChangeIdEnabled(params.changeEnabled, NETWORK_BLOCKED_WITHOUT_INTERNET_PERMISSION)
+        doReturn(true).`when`(bpfNetMaps).isUidRestrictedOnMeteredNetworks(Process.myUid())
+        doReturn(if (params.hasInternetPermission) PERMISSION_INTERNET else PERMISSION_NONE )
+                .`when`(bpfNetMaps).getNetPermForUid(Process.myUid())
+
+        val provider = NetworkProvider(context, csHandlerThread.looper, "Cell provider")
+        cm.registerNetworkProvider(provider)
+        val offerCb = TestableNetworkOfferCallback(TIMEOUT_MS, NO_CB_TIMEOUT_MS)
+        provider.registerNetworkOffer(
+                NetworkScore.Builder().build(),
+                cellNc(),
+                Runnable::run,
+                offerCb
+        )
+        val cb = TestableNetworkCallback()
+        cm.requestNetwork(cellRequest(), cb)
+
+        if (params.expectRequestMeteredNetwork) {
+            offerCb.expectOnNetworkNeeded(cellNc())
+        } else {
+            offerCb.assertNoCallback()
+        }
+
+        cm.unregisterNetworkCallback(cb)
+        provider.unregisterNetworkOffer(offerCb)
+    }
+}
diff --git a/tests/unit/java/com/android/server/connectivityservice/CSIngressDiscardRuleTests.kt b/tests/unit/java/com/android/server/connectivityservice/CSIngressDiscardRuleTests.kt
index 77b06b2239..2ef035e9b7 100644
--- a/tests/unit/java/com/android/server/connectivityservice/CSIngressDiscardRuleTests.kt
+++ b/tests/unit/java/com/android/server/connectivityservice/CSIngressDiscardRuleTests.kt
@@ -35,8 +35,8 @@ import androidx.test.filters.SmallTest
 import com.android.server.connectivity.ConnectivityFlags
 import com.android.testutils.DevSdkIgnoreRule
 import com.android.testutils.DevSdkIgnoreRunner
-import com.android.testutils.RecorderCallback.CallbackEntry.LinkPropertiesChanged
 import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.LinkPropertiesChanged
 import org.junit.Test
 import org.junit.runner.RunWith
 import org.mockito.InOrder
diff --git a/tests/unit/java/com/android/server/connectivityservice/CSInterfaceTrackerTest.kt b/tests/unit/java/com/android/server/connectivityservice/CSInterfaceTrackerTest.kt
new file mode 100644
index 0000000000..08236e006f
--- /dev/null
+++ b/tests/unit/java/com/android/server/connectivityservice/CSInterfaceTrackerTest.kt
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License")
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.connectivityservice
+
+import android.net.IpPrefix
+import android.net.LinkAddress
+import android.net.LinkProperties
+import android.net.NetworkCapabilities
+import android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET
+import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_VCN_MANAGED
+import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_VPN
+import android.net.NetworkCapabilities.TRANSPORT_VPN
+import android.net.NetworkCapabilities.TRANSPORT_WIFI
+import android.net.NetworkRequest
+import android.os.Build
+import androidx.test.filters.SmallTest
+import com.android.server.CSTest
+import com.android.testutils.DevSdkIgnoreRule
+import com.android.testutils.DevSdkIgnoreRunner
+import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.Lost
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.Mockito.inOrder
+
+private const val WIFI_IFNAME = "wlan0"
+
+private val wifiNc = NetworkCapabilities.Builder()
+    .addTransportType(TRANSPORT_WIFI)
+    .addCapability(NET_CAPABILITY_INTERNET)
+    .addCapability(NET_CAPABILITY_NOT_VCN_MANAGED)
+    .build()
+
+private fun lp(iface: String, vararg linkAddresses: LinkAddress) = LinkProperties().apply {
+    interfaceName = iface
+    for (linkAddress in linkAddresses) {
+        addLinkAddress(linkAddress)
+    }
+}
+
+private fun nr(transport: Int) = NetworkRequest.Builder()
+    .clearCapabilities()
+    .addTransportType(transport).apply {
+        if (transport != TRANSPORT_VPN) {
+            addCapability(NET_CAPABILITY_NOT_VPN)
+        }
+    }.build()
+
+@DevSdkIgnoreRunner.MonitorThreadLeak
+@RunWith(DevSdkIgnoreRunner::class)
+@SmallTest
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.VANILLA_ICE_CREAM)
+class CSInterfaceTrackerTest : CSTest() {
+    private val LOCAL_IPV6_IP_ADDRESS_PREFIX = IpPrefix("fe80::1cf1:35ff:fe8c:db87/64")
+    private val LOCAL_IPV6_LINK_ADDRESS = LinkAddress(
+        LOCAL_IPV6_IP_ADDRESS_PREFIX.getAddress(),
+        LOCAL_IPV6_IP_ADDRESS_PREFIX.getPrefixLength()
+    )
+
+    @Test
+    fun testDisconnectingNetwork_InterfaceRemoved() {
+        val nr = nr(NetworkCapabilities.TRANSPORT_WIFI)
+        val cb = TestableNetworkCallback()
+        val interfaceTrackerInorder = inOrder(interfaceTracker)
+        cm.requestNetwork(nr, cb)
+
+        // Connecting to network with IPv6 local address in LinkProperties
+        val wifiLp = lp(WIFI_IFNAME, LOCAL_IPV6_LINK_ADDRESS)
+        val wifiAgent = Agent(nc = wifiNc, lp = wifiLp)
+        wifiAgent.connect()
+        cb.expectAvailableCallbacks(wifiAgent.network, validated = false)
+        interfaceTrackerInorder.verify(interfaceTracker).addInterface(WIFI_IFNAME)
+
+        wifiAgent.disconnect()
+        cb.expect<Lost>(timeoutMs = 500) { it.network == wifiAgent.network }
+        // onLost is fired before the network is destroyed.
+        waitForIdle()
+
+        interfaceTrackerInorder.verify(interfaceTracker).removeInterface(WIFI_IFNAME)
+    }
+}
diff --git a/tests/unit/java/com/android/server/connectivityservice/CSKeepConnectedTest.kt b/tests/unit/java/com/android/server/connectivityservice/CSKeepConnectedTest.kt
index c0965b4ff7..d99099450d 100644
--- a/tests/unit/java/com/android/server/connectivityservice/CSKeepConnectedTest.kt
+++ b/tests/unit/java/com/android/server/connectivityservice/CSKeepConnectedTest.kt
@@ -28,8 +28,8 @@ import android.os.Build
 import androidx.test.filters.SmallTest
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
 import com.android.testutils.DevSdkIgnoreRunner
-import com.android.testutils.RecorderCallback.CallbackEntry.Lost
 import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.Lost
 import org.junit.Test
 import org.junit.runner.RunWith
 
diff --git a/tests/unit/java/com/android/server/connectivityservice/CSL2capProviderTest.kt b/tests/unit/java/com/android/server/connectivityservice/CSL2capProviderTest.kt
index ee5b4eede5..98e7ff44ae 100644
--- a/tests/unit/java/com/android/server/connectivityservice/CSL2capProviderTest.kt
+++ b/tests/unit/java/com/android/server/connectivityservice/CSL2capProviderTest.kt
@@ -45,10 +45,10 @@ import com.android.server.net.L2capNetwork.L2capIpClient
 import com.android.server.net.L2capPacketForwarder
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
 import com.android.testutils.DevSdkIgnoreRunner
-import com.android.testutils.RecorderCallback.CallbackEntry.Lost
-import com.android.testutils.RecorderCallback.CallbackEntry.Reserved
-import com.android.testutils.RecorderCallback.CallbackEntry.Unavailable
 import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.Lost
+import com.android.testutils.TestableNetworkCallback.Event.Reserved
+import com.android.testutils.TestableNetworkCallback.Event.Unavailable
 import com.android.testutils.anyNetwork
 import com.android.testutils.waitForIdle
 import java.io.IOException
@@ -67,7 +67,6 @@ import org.mockito.ArgumentMatchers.isNull
 import org.mockito.Mockito.doAnswer
 import org.mockito.Mockito.doReturn
 import org.mockito.Mockito.doThrow
-import org.mockito.Mockito.mock
 import org.mockito.Mockito.verify
 
 private const val PSM = 0x85
diff --git a/tests/unit/java/com/android/server/connectivityservice/CSLocalAgentCreationTests.kt b/tests/unit/java/com/android/server/connectivityservice/CSLocalAgentCreationTests.kt
index 6dc9d2d537..7d5ed312fb 100644
--- a/tests/unit/java/com/android/server/connectivityservice/CSLocalAgentCreationTests.kt
+++ b/tests/unit/java/com/android/server/connectivityservice/CSLocalAgentCreationTests.kt
@@ -28,8 +28,8 @@ import android.os.Build
 import androidx.test.filters.SmallTest
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
 import com.android.testutils.DevSdkIgnoreRunner
-import com.android.testutils.RecorderCallback.CallbackEntry.Available
 import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.Available
 import kotlin.test.assertFailsWith
 import org.junit.Assert.assertEquals
 import org.junit.Test
diff --git a/tests/unit/java/com/android/server/connectivityservice/CSLocalAgentTests.kt b/tests/unit/java/com/android/server/connectivityservice/CSLocalAgentTests.kt
index 9468d548d4..152751d401 100644
--- a/tests/unit/java/com/android/server/connectivityservice/CSLocalAgentTests.kt
+++ b/tests/unit/java/com/android/server/connectivityservice/CSLocalAgentTests.kt
@@ -16,9 +16,6 @@
 
 package com.android.server
 
-import android.net.IpPrefix
-import android.net.LinkAddress
-import android.net.LinkProperties
 import android.net.LocalNetworkConfig
 import android.net.MulticastRoutingConfig
 import android.net.MulticastRoutingConfig.CONFIG_FORWARD_NONE
@@ -26,26 +23,20 @@ import android.net.NetworkCapabilities
 import android.net.NetworkCapabilities.NET_CAPABILITY_DUN
 import android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET
 import android.net.NetworkCapabilities.NET_CAPABILITY_LOCAL_NETWORK
-import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED
-import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_ROAMING
-import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_SUSPENDED
-import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_VCN_MANAGED
 import android.net.NetworkCapabilities.TRANSPORT_CELLULAR
 import android.net.NetworkCapabilities.TRANSPORT_THREAD
 import android.net.NetworkCapabilities.TRANSPORT_WIFI
 import android.net.NetworkRequest
 import android.net.NetworkScore
-import android.net.NetworkScore.KEEP_CONNECTED_FOR_TEST
 import android.net.NetworkScore.KEEP_CONNECTED_LOCAL_NETWORK
-import android.net.RouteInfo
 import android.net.connectivity.ConnectivityCompatChanges.ENABLE_MATCH_LOCAL_NETWORK
 import android.net.connectivity.ConnectivityCompatChanges.ENABLE_MATCH_NON_THREAD_LOCAL_NETWORKS
 import android.os.Build
 import com.android.testutils.DevSdkIgnoreRule
 import com.android.testutils.DevSdkIgnoreRunner
-import com.android.testutils.RecorderCallback.CallbackEntry.LocalInfoChanged
-import com.android.testutils.RecorderCallback.CallbackEntry.Lost
 import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.LocalInfoChanged
+import com.android.testutils.TestableNetworkCallback.Event.Lost
 import kotlin.test.assertFailsWith
 import org.junit.Test
 import org.junit.runner.RunWith
@@ -61,29 +52,7 @@ private const val TIMEOUT_MS = 200L
 private const val MEDIUM_TIMEOUT_MS = 1_000L
 private const val LONG_TIMEOUT_MS = 5_000
 
-private fun nc(transport: Int, vararg caps: Int) = NetworkCapabilities.Builder().apply {
-    addTransportType(transport)
-    caps.forEach {
-        addCapability(it)
-    }
-    // Useful capabilities for everybody
-    addCapability(NET_CAPABILITY_NOT_RESTRICTED)
-    addCapability(NET_CAPABILITY_NOT_SUSPENDED)
-    addCapability(NET_CAPABILITY_NOT_ROAMING)
-    addCapability(NET_CAPABILITY_NOT_VCN_MANAGED)
-}.build()
-
-private fun lp(iface: String) = LinkProperties().apply {
-    interfaceName = iface
-    addLinkAddress(LinkAddress(LOCAL_IPV4_ADDRESS, 32))
-    addRoute(RouteInfo(IpPrefix("0.0.0.0/0"), null, null))
-}
-
-// This allows keeping all the networks connected without having to file individual requests
-// for them.
-private fun keepScore() = FromS(
-        NetworkScore.Builder().setKeepConnectedReason(KEEP_CONNECTED_FOR_TEST).build()
-)
+private fun lp(iface: String) = defaultLp().apply { interfaceName = iface }
 
 @DevSdkIgnoreRunner.MonitorThreadLeak
 @RunWith(DevSdkIgnoreRunner::class)
@@ -235,19 +204,11 @@ class CSLocalAgentTests : CSTest() {
     }
 
     private fun createWifiAgent(name: String): CSAgentWrapper {
-        return Agent(
-                score = keepScore(),
-                lp = lp(name),
-                nc = nc(TRANSPORT_WIFI, NET_CAPABILITY_INTERNET)
-        )
+        return Agent(name, TRANSPORT_WIFI, NET_CAPABILITY_INTERNET)
     }
 
     private fun createCellAgent(name: String): CSAgentWrapper {
-        return Agent(
-                score = keepScore(),
-                lp = lp(name),
-                nc = nc(TRANSPORT_CELLULAR, NET_CAPABILITY_INTERNET)
-        )
+        return Agent(name, TRANSPORT_CELLULAR, NET_CAPABILITY_INTERNET)
     }
 
     private fun sendLocalNetworkConfig(
diff --git a/tests/unit/java/com/android/server/connectivityservice/CSLocalNetworkProtectionTest.kt b/tests/unit/java/com/android/server/connectivityservice/CSLocalNetworkProtectionTest.kt
index 84c98359de..4f1c1aabb8 100644
--- a/tests/unit/java/com/android/server/connectivityservice/CSLocalNetworkProtectionTest.kt
+++ b/tests/unit/java/com/android/server/connectivityservice/CSLocalNetworkProtectionTest.kt
@@ -31,9 +31,9 @@ import android.os.Build
 import androidx.test.filters.SmallTest
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
 import com.android.testutils.DevSdkIgnoreRunner
-import com.android.testutils.RecorderCallback.CallbackEntry.LinkPropertiesChanged
-import com.android.testutils.RecorderCallback.CallbackEntry.Lost
 import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.LinkPropertiesChanged
+import com.android.testutils.TestableNetworkCallback.Event.Lost
 import org.junit.Test
 import org.junit.runner.RunWith
 import org.mockito.ArgumentMatchers.eq
diff --git a/tests/unit/java/com/android/server/connectivityservice/CSNetworkActivityTest.kt b/tests/unit/java/com/android/server/connectivityservice/CSNetworkActivityTest.kt
index ccbd6b3370..99fdfa5248 100644
--- a/tests/unit/java/com/android/server/connectivityservice/CSNetworkActivityTest.kt
+++ b/tests/unit/java/com/android/server/connectivityservice/CSNetworkActivityTest.kt
@@ -40,8 +40,8 @@ import com.android.net.module.util.BaseNetdUnsolicitedEventListener
 import com.android.server.CSTest.CSContext
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
 import com.android.testutils.DevSdkIgnoreRunner
-import com.android.testutils.RecorderCallback.CallbackEntry.Lost
 import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.Lost
 import java.time.Duration
 import kotlin.test.assertNotNull
 import org.junit.Assert.assertFalse
diff --git a/tests/unit/java/com/android/server/connectivityservice/CSNetworkAgentTest.kt b/tests/unit/java/com/android/server/connectivityservice/CSNetworkAgentTest.kt
index 547a4cccf2..c07d0e2bc2 100644
--- a/tests/unit/java/com/android/server/connectivityservice/CSNetworkAgentTest.kt
+++ b/tests/unit/java/com/android/server/connectivityservice/CSNetworkAgentTest.kt
@@ -16,16 +16,27 @@
 
 package com.android.server
 
+import android.net.ConnectivitySettingsManager
+import android.net.InetAddresses
+import android.net.IpPrefix
+import android.net.LinkAddress
+import android.net.LinkProperties
 import android.net.NativeNetworkConfig
+import android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET
 import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_VPN
+import android.net.NetworkCapabilities.NET_CAPABILITY_TRUSTED
 import android.net.NetworkCapabilities.TRANSPORT_VPN
 import android.net.NetworkCapabilities.TRANSPORT_WIFI
+import android.net.ResolverParamsParcel
+import android.net.RouteInfo
 import android.net.VpnManager
 import android.net.VpnTransportInfo
 import android.net.netd.aidl.NativeUidRangeConfig
 import android.os.Build
 import android.os.Process
 import android.util.Range
+import com.android.server.connectivity.ConnectivityFlags.EARLY_LINK_PROPERTIES_UPDATE_FOR_VPN
+import com.android.server.connectivity.ConnectivityFlags.QUEUE_NETWORK_AGENT_EVENTS_IN_SYSTEM_SERVER
 import com.android.testutils.ConnectivityModuleTest
 import com.android.testutils.DevSdkIgnoreRule
 import com.android.testutils.DevSdkIgnoreRunner
@@ -33,13 +44,20 @@ import org.junit.Test
 import org.junit.runner.RunWith
 import org.mockito.ArgumentMatchers.anyInt
 import org.mockito.ArgumentMatchers.argThat
+import org.mockito.ArgumentMatchers.eq
 import org.mockito.Mockito.inOrder
 import org.mockito.Mockito.never
+import org.mockito.Mockito.times
+
+private const val DNS_ADDR = "8.8.8.8"
+private const val IPV4_ADDR = "192.168.2.1"
+private const val ROUTE_PREFIX = "0.0.0.0/0"
 
 @DevSdkIgnoreRunner.MonitorThreadLeak
 @RunWith(DevSdkIgnoreRunner::class)
 @DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S)
 class CSNetworkAgentTest : CSTest() {
+
     @Test fun testVpnUidAgent() = testUidAgent(
         TRANSPORT_VPN,
         expectAddUidRanges = true
@@ -89,4 +107,105 @@ class CSNetworkAgentTest : CSTest() {
         // The old method should never be called in any case
         netdInOrder.verify(netd, never()).networkAddUidRanges(anyInt(), any())
     }
+
+    // Test the early link properties update for the VPN network when the flag
+    // QUEUE_NETWORK_AGENT_EVENTS_IN_SYSTEM_SERVER is disabled. That flag is enabled by default in
+    // the CSTest.
+    @ConnectivityModuleTest
+    @FeatureFlags(flags = [Flag(QUEUE_NETWORK_AGENT_EVENTS_IN_SYSTEM_SERVER, false)])
+    @Test
+    fun testEarlyLinkPropertiesUpdateForVPN() =
+            testEarlyLinkPropertiesUpdate(TRANSPORT_VPN, expectEarlyLinkPropertiesUpdate = true)
+
+    // Test the early link properties update for the non-VPN network when the flag
+    // QUEUE_NETWORK_AGENT_EVENTS_IN_SYSTEM_SERVER is disabled. That flag is enabled by default in
+    // the CSTest.
+    @ConnectivityModuleTest
+    @FeatureFlags(flags = [Flag(QUEUE_NETWORK_AGENT_EVENTS_IN_SYSTEM_SERVER, false)])
+    @Test
+    fun testEarlyLinkPropertiesUpdateForNonVPN() =
+            testEarlyLinkPropertiesUpdate(TRANSPORT_WIFI, expectEarlyLinkPropertiesUpdate = false)
+
+    // Test the early link properties update for the VPN network when both flags
+    // QUEUE_NETWORK_AGENT_EVENTS_IN_SYSTEM_SERVER and EARLY_LINK_PROPERTIES_UPDATE_FOR_VPN are
+    // disabled. These flags are enabled by default in the CSTest.
+    @ConnectivityModuleTest
+    @FeatureFlags(
+        flags = [Flag(QUEUE_NETWORK_AGENT_EVENTS_IN_SYSTEM_SERVER, false),
+            Flag(EARLY_LINK_PROPERTIES_UPDATE_FOR_VPN, false)]
+    )
+    @Test
+    fun testEarlyLinkPropertiesUpdateDisabledForVPN() =
+            testEarlyLinkPropertiesUpdate(TRANSPORT_VPN, expectEarlyLinkPropertiesUpdate = false)
+
+    private fun testEarlyLinkPropertiesUpdate(
+            transport: Int,
+            expectEarlyLinkPropertiesUpdate: Boolean
+    ) {
+        val netdInOrder = inOrder(netd)
+        val resolverInOrder = inOrder(dnsResolver)
+
+        val nc = defaultNc()
+                .addTransportType(transport)
+                .addCapability(NET_CAPABILITY_TRUSTED)
+                .addCapability(NET_CAPABILITY_INTERNET)
+        if (TRANSPORT_VPN == transport) {
+            nc.removeCapability(NET_CAPABILITY_NOT_VPN)
+            nc.setTransportInfo(
+                    VpnTransportInfo(
+                            VpnManager.TYPE_VPN_SERVICE,
+                            "MySession12345",
+                            true /* bypassable */,
+                            false /* longLivedTcpConnectionsExpensive */
+                    )
+            )
+        }
+        val linkAddress = LinkAddress(InetAddresses.parseNumericAddress(IPV4_ADDR), 32)
+        val lp = LinkProperties().apply {
+            addLinkAddress(linkAddress)
+            addRoute(RouteInfo(IpPrefix(ROUTE_PREFIX), null, null))
+            addDnsServer(InetAddresses.parseNumericAddress(DNS_ADDR))
+        }
+        ConnectivitySettingsManager.setPrivateDnsMode(
+                context,
+                ConnectivitySettingsManager.PRIVATE_DNS_MODE_OPPORTUNISTIC
+        )
+        val agent = Agent(nc = nc, lp = lp)
+        agent.connect()
+
+        netdInOrder.verify(netd).networkCreate(argThat { it.netId == agent.network.netId })
+        netdInOrder.verify(netd).networkAddRouteParcel(
+                eq(agent.network.netId),
+                argThat { it.destination == ROUTE_PREFIX }
+        )
+        netdInOrder.verify(netd).networkAddRouteParcel(
+                eq(agent.network.netId),
+                argThat { it.destination == linkAddress.toString() }
+        )
+
+        if (expectEarlyLinkPropertiesUpdate) {
+            // Update the DNS without the TLS servers because the private DNS hasn't been set.
+            resolverInOrder.verify(dnsResolver).setResolverConfiguration(
+                    argThat { it: ResolverParamsParcel ->
+                        it.netId == agent.network.netId &&
+                        it.servers.any { server -> server == DNS_ADDR } &&
+                        it.tlsServers.isEmpty() }
+            )
+            // The private DNS has been set. Update the DNS again with the TLS servers.
+            resolverInOrder.verify(dnsResolver).setResolverConfiguration(
+                    argThat {
+                        it.netId == agent.network.netId &&
+                        it.servers.any { server -> server == DNS_ADDR } &&
+                        it.tlsServers.any { server -> server == DNS_ADDR }}
+            )
+        } else {
+            // Update the DNS with the TLS servers because the private DNS has been set.
+            resolverInOrder.verify(dnsResolver, times(2)).setResolverConfiguration(
+                    argThat {
+                        it.netId == agent.network.netId &&
+                        it.servers.any { server -> server == DNS_ADDR } &&
+                        it.tlsServers.any { server -> server == DNS_ADDR }}
+            )
+        }
+    }
 }
diff --git a/tests/unit/java/com/android/server/connectivityservice/CSNetworkRequestInfoTest.kt b/tests/unit/java/com/android/server/connectivityservice/CSNetworkRequestInfoTest.kt
new file mode 100644
index 0000000000..d8b5138f2c
--- /dev/null
+++ b/tests/unit/java/com/android/server/connectivityservice/CSNetworkRequestInfoTest.kt
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server
+
+import android.net.ConnectivityManager
+import android.net.NetworkCapabilities
+import android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET
+import android.net.NetworkRequest
+import android.os.Build
+import com.android.server.connectivity.NetworkAgentInfo
+import com.android.testutils.DevSdkIgnoreRule
+import com.android.testutils.DevSdkIgnoreRunner
+import java.util.Collections
+import kotlin.test.assertEquals
+import org.junit.Test
+import org.junit.runner.RunWith
+
+private const val TEST_UID = 1234
+
+@RunWith(DevSdkIgnoreRunner::class)
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.TIRAMISU)
+class CSNetworkRequestInfoTest : CSTest() {
+    /**
+     * Helper function to create a NetworkRequestInfo for internal system usage.
+     * This simplifies NRI creation within the test.
+     */
+    private fun createNri(request: NetworkRequest): ConnectivityService.NetworkRequestInfo {
+        // This uses the internal constructor to create an NRI as the system would.
+        return service.NetworkRequestInfo(
+                TEST_UID,
+                Collections.singletonList(request),
+                0 // preferenceOrder
+        )
+    }
+
+    @Test
+    fun testGetSatisfiedTime() {
+        // Setup: Create a basic NetworkRequestInfo and mock a network.
+        val t0 = 50L
+        deps.elapsedRealtime = t0
+        val capabilities = NetworkCapabilities.Builder()
+                .addCapability(NET_CAPABILITY_INTERNET)
+                .build()
+        val request = NetworkRequest(
+                capabilities,
+                ConnectivityManager.TYPE_NONE,
+                1 /* requestId */,
+                NetworkRequest.Type.REQUEST
+        )
+        val nri = createNri(request)
+        val nai = mock<NetworkAgentInfo>()
+
+        // Initially, satisfiedTime should be the created time, which is the "null" start
+        // to satisfying the request.
+        assertEquals(t0, nri.satisfiedTime)
+
+        // When a network satisfies the request at t=100, verify the satisfiedTime updates.
+        val t1 = 100L
+        deps.elapsedRealtime = t1
+        nri.setSatisfier(nai, request)
+        assertEquals(t1, nri.satisfiedTime)
+
+        // When the request becomes unsatisfied at t=250, verify the satisfiedTime updates.
+        val t2 = 250L
+        deps.elapsedRealtime = t2
+        nri.setSatisfier(null, null)
+        assertEquals(t2, nri.satisfiedTime)
+    }
+
+    @Test
+    fun testCopyConstructorPreservesSatisfiedTime() {
+        val capabilities = NetworkCapabilities.Builder()
+                .addCapability(NET_CAPABILITY_INTERNET)
+                .build()
+        val request = NetworkRequest(
+                capabilities,
+                ConnectivityManager.TYPE_NONE,
+                1 /* requestId */,
+                NetworkRequest.Type.REQUEST
+        )
+        val t1 = 100L
+        deps.elapsedRealtime = t1
+        val originalNri = createNri(request)
+
+        // Change time, and verify it is not used by copy constructor.
+        val t2 = 12345L
+        deps.elapsedRealtime = t2
+        val newNri = service.NetworkRequestInfo(originalNri, Collections.singletonList(request))
+        assertEquals(t1, newNri.satisfiedTime)
+    }
+}
diff --git a/tests/unit/java/com/android/server/connectivityservice/CSNetworkReservationTest.kt b/tests/unit/java/com/android/server/connectivityservice/CSNetworkReservationTest.kt
index e698930e3a..662ec18395 100644
--- a/tests/unit/java/com/android/server/connectivityservice/CSNetworkReservationTest.kt
+++ b/tests/unit/java/com/android/server/connectivityservice/CSNetworkReservationTest.kt
@@ -32,11 +32,11 @@ import android.net.NetworkScore
 import android.os.Build
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
 import com.android.testutils.DevSdkIgnoreRunner
-import com.android.testutils.RecorderCallback.CallbackEntry.Reserved
-import com.android.testutils.RecorderCallback.CallbackEntry.Unavailable
 import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.Reserved
+import com.android.testutils.TestableNetworkCallback.Event.Unavailable
 import com.android.testutils.TestableNetworkOfferCallback
-import com.android.testutils.TestableNetworkOfferCallback.CallbackEntry.OnNetworkNeeded
+import com.android.testutils.TestableNetworkOfferCallback.Event.Needed
 import kotlin.test.assertEquals
 import kotlin.test.assertNull
 import org.junit.Before
@@ -118,7 +118,7 @@ class CSNetworkReservationTest : CSTest() {
     }
 
     fun TestableNetworkOfferCallback.expectNoCallbackWhere(
-            predicate: (TestableNetworkOfferCallback.CallbackEntry) -> Boolean
+            predicate: (TestableNetworkOfferCallback.Event) -> Boolean
     ) {
         val event = history.poll(NO_CB_TIMEOUT_MS) { predicate(it) }
         assertNull(event)
@@ -134,7 +134,7 @@ class CSNetworkReservationTest : CSTest() {
 
         // validate the offer does not receive onNetworkNeeded for reservation request
         offerCb.expectNoCallbackWhere {
-            it is OnNetworkNeeded && it.request.type == NetworkRequest.Type.RESERVATION
+            it is Needed && it.request.type == NetworkRequest.Type.RESERVATION
         }
     }
 
diff --git a/tests/unit/java/com/android/server/connectivityservice/CSPreferenceTest.kt b/tests/unit/java/com/android/server/connectivityservice/CSPreferenceTest.kt
new file mode 100644
index 0000000000..c8cd64e902
--- /dev/null
+++ b/tests/unit/java/com/android/server/connectivityservice/CSPreferenceTest.kt
@@ -0,0 +1,388 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server
+
+import android.Manifest.permission.NETWORK_SETTINGS
+import android.annotation.SuppressLint
+import android.content.pm.ApplicationInfo
+import android.net.ConnectivityManager
+import android.net.ConnectivityManager.NetworkCallback
+import android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET
+import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_BANDWIDTH_CONSTRAINED
+import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED
+import android.net.NetworkCapabilities.TRANSPORT_SATELLITE
+import android.net.NetworkCapabilities.TRANSPORT_TEST
+import android.net.NetworkCapabilities.TRANSPORT_WIFI
+import android.net.NetworkProvider
+import android.net.NetworkScore
+import android.net.OemNetworkPreferences
+import android.net.OemNetworkPreferences.OEM_NETWORK_PREFERENCE_TEST
+import android.os.Build
+import android.os.ConditionVariable
+import android.os.Handler
+import android.os.Looper
+import android.os.Process
+import android.os.UserHandle
+import androidx.test.filters.SmallTest
+import com.android.testutils.DevSdkIgnoreRule
+import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
+import com.android.testutils.DevSdkIgnoreRunner
+import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.Lost
+import com.android.testutils.TestableNetworkOfferCallback
+import com.android.testutils.TestableNetworkOfferCallback.Event.Needed
+import com.android.testutils.TestableNetworkOfferCallback.Event.Unneeded
+import com.android.testutils.postAndWait
+import com.android.testutils.runAsShell
+import kotlin.test.assertEquals
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.Mockito.any
+import org.mockito.Mockito.doAnswer
+import org.mockito.Mockito.eq
+
+const val UID1 = 184
+const val UID2 = 10184
+const val UID3 = 10193
+const val SMSUID = 124
+
+private const val DEFAULT_TIMEOUT_MS = 5000L
+private const val DEFAULT_NO_CALLBACK_TIMEOUT_MS = 200L
+
+private fun satelliteNc(restricted: Boolean) = nc(
+    TRANSPORT_SATELLITE,
+    NET_CAPABILITY_INTERNET,
+).apply {
+    removeCapability(NET_CAPABILITY_NOT_BANDWIDTH_CONSTRAINED)
+    if (restricted) removeCapability(NET_CAPABILITY_NOT_RESTRICTED)
+}
+
+@SuppressLint("VisibleForTests", "MissingPermission")
+@DevSdkIgnoreRunner.MonitorThreadLeak
+@RunWith(DevSdkIgnoreRunner::class)
+@SmallTest
+@IgnoreUpTo(Build.VERSION_CODES.R)
+class CSPreferenceTest : CSTest() {
+    @get:Rule
+    val ignoreRule = DevSdkIgnoreRule()
+
+    val handler = Handler(Looper.getMainLooper())
+
+    @Test
+    fun testBasicOemPreference() {
+        val myAppId = UserHandle.getAppId(Process.myUid())
+        doAnswer { invocation ->
+            val handle = invocation.getArgument<UserHandle>(2)
+            ApplicationInfo().apply { uid = handle.getUid(myAppId) }
+        }.`when`(packageManager).getApplicationInfoAsUser(
+            eq(context.packageName),
+            eq(0), // flags
+            any<UserHandle>()
+        )
+
+        val wifiAgent = Agent(nc(TRANSPORT_WIFI, NET_CAPABILITY_INTERNET))
+        wifiAgent.connect()
+        val testAgent = Agent(TRANSPORT_TEST)
+        testAgent.connect()
+
+        val cb = TestableNetworkCallback()
+        cm.registerDefaultNetworkCallback(cb)
+        cb.expectAvailableCallbacks(wifiAgent.network, validated = false)
+
+        val pr = OemNetworkPreferences.Builder()
+            .addNetworkPreference(context.packageName, OEM_NETWORK_PREFERENCE_TEST)
+            .build()
+        val cv = ConditionVariable()
+        cm.setOemNetworkPreference(pr, Runnable::run) { cv.open() }
+        cv.block()
+
+        cb.expectAvailableCallbacks(testAgent.network, validated = false)
+
+        cv.close()
+        cm.setOemNetworkPreference(
+            OemNetworkPreferences.Builder().build(),
+            Runnable::run
+        ) {
+            cv.open()
+        }
+        cv.block()
+
+        cb.expectAvailableCallbacks(wifiAgent.network, validated = false)
+    }
+
+    private fun ConnectivityManager.registerDefaultNetworkCallbackForUid(
+        uid: Int,
+        cb: NetworkCallback
+    ) = runAsShell(NETWORK_SETTINGS) {
+        registerDefaultNetworkCallbackForUid(uid, cb, handler)
+    }
+
+    private fun defaultCallbacksForUids(vararg uids: Int) = uids.map { uid ->
+        val cb = TestableNetworkCallback()
+        cm.registerDefaultNetworkCallbackForUid(uid, cb)
+        uid to cb
+    }.toMap()
+
+    private fun <K, V> Map<K, V>.eachValue(what: (V) -> Unit) = forEach { what(it.value) }
+
+    private fun updateSatellitePreference(roleUids: Set<Int>, optinUids: Set<Int>) =
+        csHandler.postAndWait {
+            deps.satelliteNetworkFallbackUidUpdate.accept(roleUids, optinUids)
+        }
+
+    fun doTestSatellitePreference_PreferenceInstalledFirst(satelliteRestricted: Boolean) {
+        // Connect some wifi agent and file callbacks.
+        val wifiAgent = Agent(nc(TRANSPORT_WIFI, NET_CAPABILITY_INTERNET))
+        wifiAgent.connect()
+
+        val callbacks = defaultCallbacksForUids(UID1, UID2, UID3, SMSUID)
+        callbacks.eachValue { it.expectAvailableCallbacks(wifiAgent.network, validated = false) }
+
+        // Now file the preference and make sure no callbacks are sent.
+        updateSatellitePreference(setOf(SMSUID), setOf(UID1, UID2))
+        callbacks.eachValue { it.assertNoCallback() }
+
+        // Connect the satellite agent. Because there is a default network, no callbacks are
+        // sent yet.
+        val satelliteAgent = Agent(
+            nc = satelliteNc(satelliteRestricted),
+            score = keepConnectedScore()
+        )
+        satelliteAgent.connect()
+        callbacks.eachValue { it.assertNoCallback() }
+
+        // Disconnect wifi. The two opted-in UIDs fall back to satellite iff unrestricted. The SMS
+        // UID falls back to the satellite in any case.
+        wifiAgent.disconnect()
+        callbacks.eachValue { it.expect<Lost>(wifiAgent.network) }
+        if (satelliteRestricted) {
+            callbacks[UID1]!!.assertNoCallback()
+            callbacks[UID2]!!.assertNoCallback()
+        } else {
+            callbacks[UID1]!!.expectAvailableCallbacks(satelliteAgent.network, validated = false)
+            callbacks[UID2]!!.expectAvailableCallbacks(satelliteAgent.network, validated = false)
+        }
+        callbacks[UID3]!!.assertNoCallback()
+        callbacks[SMSUID]!!.expectAvailableCallbacks(satelliteAgent.network, validated = false)
+
+        // Disconnect satellite
+        satelliteAgent.disconnect()
+        if (satelliteRestricted) {
+            callbacks[UID1]!!.assertNoCallback()
+            callbacks[UID2]!!.assertNoCallback()
+        } else {
+            callbacks[UID1]!!.expect<Lost>(satelliteAgent.network)
+            callbacks[UID2]!!.expect<Lost>(satelliteAgent.network)
+        }
+        callbacks[UID3]!!.assertNoCallback()
+        callbacks[SMSUID]!!.expect<Lost>(satelliteAgent.network)
+
+        callbacks.eachValue { cm.unregisterNetworkCallback(it) }
+    }
+
+    @Test @IgnoreUpTo(Build.VERSION_CODES.VANILLA_ICE_CREAM)
+    fun testOptInSatellitePreference_PreferenceInstalledFirst_UnrestrictedSatellite() =
+        doTestSatellitePreference_PreferenceInstalledFirst(satelliteRestricted = false)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.VANILLA_ICE_CREAM)
+    fun testOptInSatellitePreference_PreferenceInstalledFirst_RestrictedSatellite() =
+        doTestSatellitePreference_PreferenceInstalledFirst(satelliteRestricted = true)
+
+    fun doTestSatellitePreference_NetworkConnectedFirst(satelliteRestricted: Boolean) {
+        // Connect some wifi agent and a satellite agent.
+        val wifiAgent = Agent(nc(TRANSPORT_WIFI, NET_CAPABILITY_INTERNET))
+        wifiAgent.connect()
+
+        val firstSatelliteAgent = Agent(
+            nc = satelliteNc(satelliteRestricted),
+            score = keepConnectedScore()
+        )
+        firstSatelliteAgent.connect()
+
+        // File callbacks. They all have wifi as their default network.
+        val callbacks = defaultCallbacksForUids(UID1, UID2, UID3, SMSUID)
+        callbacks.eachValue { it.expectAvailableCallbacks(wifiAgent.network, validated = false) }
+
+        // Now file the preference and make sure no callbacks are sent because there
+        // is a wifi agent.
+        updateSatellitePreference(setOf(SMSUID), setOf(UID1, UID2))
+        callbacks.eachValue { it.assertNoCallback() }
+
+        // Disconnect satellite. No callbacks are sent since everyone is on wifi.
+        firstSatelliteAgent.disconnect()
+        callbacks.eachValue { it.assertNoCallback() }
+
+        // Remove all settings
+        updateSatellitePreference(emptySet(), emptySet())
+
+        // Connect a new satellite agent. No callback is sent yet, wifi is still connected
+        val satelliteAgent = Agent(
+            nc = satelliteNc(satelliteRestricted),
+            score = keepConnectedScore()
+        )
+        satelliteAgent.connect()
+        callbacks.eachValue { it.assertNoCallback() }
+
+        // Disconnect wifi, everyone loses their default network
+        wifiAgent.disconnect()
+        callbacks.eachValue { it.expect<Lost>(wifiAgent.network) }
+        callbacks.eachValue { it.assertNoCallback() }
+
+        // Install the preference again. If satellite is unrestricted, then the opted-in
+        // UIDs go on it.
+        updateSatellitePreference(setOf(SMSUID), setOf(UID1, UID2))
+        if (satelliteRestricted) {
+            callbacks[UID1]!!.assertNoCallback()
+            callbacks[UID2]!!.assertNoCallback()
+        } else {
+            callbacks[UID1]!!.expectAvailableCallbacks(satelliteAgent.network, validated = false)
+            callbacks[UID2]!!.expectAvailableCallbacks(satelliteAgent.network, validated = false)
+        }
+        callbacks[UID3]!!.assertNoCallback()
+        callbacks[SMSUID]!!.expectAvailableCallbacks(satelliteAgent.network, validated = false)
+
+        // Disconnect satellite
+        satelliteAgent.disconnect()
+        if (satelliteRestricted) {
+            callbacks[UID1]!!.assertNoCallback()
+            callbacks[UID2]!!.assertNoCallback()
+        } else {
+            callbacks[UID1]!!.expect<Lost>(satelliteAgent.network)
+            callbacks[UID2]!!.expect<Lost>(satelliteAgent.network)
+        }
+        callbacks[UID3]!!.assertNoCallback()
+        callbacks[SMSUID]!!.expect<Lost>(satelliteAgent.network)
+
+        callbacks.eachValue { cm.unregisterNetworkCallback(it) }
+    }
+
+    @Test @IgnoreUpTo(Build.VERSION_CODES.VANILLA_ICE_CREAM)
+    fun testOptInSatellitePreference_NetworkConnectedFirst_UnrestrictedSatellite() =
+        doTestSatellitePreference_NetworkConnectedFirst(satelliteRestricted = false)
+    @Test @IgnoreUpTo(Build.VERSION_CODES.VANILLA_ICE_CREAM)
+    fun testOptInSatellitePreference_NetworkConnectedFirst_RestrictedSatellite() =
+        doTestSatellitePreference_NetworkConnectedFirst(satelliteRestricted = true)
+
+    private val Needed.isRestricted
+        get() = !request.hasCapability(NET_CAPABILITY_NOT_RESTRICTED)
+    private val Unneeded.isRestricted
+        get() = !request.hasCapability(NET_CAPABILITY_NOT_RESTRICTED)
+
+    /**
+     * This test ensures that the network offers for the satellite provider (normally telephony)
+     * are correctly updated.
+     *
+     * Generally, as long as there is a general internet-providing default network, the satellite
+     * network is not requested.
+     * When there is no general default network, satellite should be requested if and only if
+     * there are UIDs that can use it. If there is an apps with the SMS role, it will request a
+     * network without NOT_RESTRICTED capability (this app is allowed to use a restricted network).
+     * If there are any opted-in apps, they will request a network with NOT_RESTRICTED.
+     */
+    @Test @IgnoreUpTo(Build.VERSION_CODES.VANILLA_ICE_CREAM)
+    fun testSatelliteRequest() {
+        val provider = NetworkProvider(context, csHandlerThread.looper, "Test provider")
+        cm.registerNetworkProvider(provider)
+
+        val satelliteCallback = TestableNetworkOfferCallback()
+        provider.registerNetworkOffer(
+            NetworkScore.Builder().build(),
+            satelliteNc(restricted = false),
+            Runnable::run,
+            satelliteCallback
+        )
+        val restrictedSatelliteCallback = TestableNetworkOfferCallback()
+        provider.registerNetworkOffer(
+            NetworkScore.Builder().build(),
+            satelliteNc(restricted = true),
+            Runnable::run,
+            restrictedSatelliteCallback
+        )
+        satelliteCallback.assertNoCallback()
+
+        updateSatellitePreference(emptySet(), setOf(UID1))
+        satelliteCallback.expect<Needed>()
+        satelliteCallback.assertNoCallback()
+        restrictedSatelliteCallback.assertNoCallback()
+
+        updateSatellitePreference(emptySet(), emptySet())
+        satelliteCallback.expect<Unneeded>()
+        satelliteCallback.assertNoCallback()
+        restrictedSatelliteCallback.assertNoCallback()
+
+        updateSatellitePreference(setOf(SMSUID), emptySet())
+        satelliteCallback.expect<Needed> { it.isRestricted }
+        restrictedSatelliteCallback.expect<Needed> { it.isRestricted }
+        satelliteCallback.assertNoCallback()
+        restrictedSatelliteCallback.assertNoCallback()
+
+        updateSatellitePreference(setOf(SMSUID), setOf(UID1))
+        // TODO : ideally ConnectivityService would not send unneeded then needed. This is
+        // happening because updating the preferences removes the requests, which causes a
+        // rematch (where the requests are not registered), then adds the requests again, which
+        // causes another rematch.
+        satelliteCallback.expect<Unneeded> { it.isRestricted }
+        restrictedSatelliteCallback.expect<Unneeded> { it.isRestricted }
+
+        val mark1 = satelliteCallback.mark
+        satelliteCallback.eventuallyExpect<Needed>(from = mark1) { !it.isRestricted }
+        satelliteCallback.eventuallyExpect<Needed>(from = mark1) { it.isRestricted }
+        assertEquals(2, satelliteCallback.mark - mark1)
+        restrictedSatelliteCallback.expect<Needed> { it.isRestricted }
+        satelliteCallback.assertNoCallback()
+        restrictedSatelliteCallback.assertNoCallback()
+
+        updateSatellitePreference(emptySet(), setOf(UID1))
+        val mark2 = satelliteCallback.mark
+        satelliteCallback.eventuallyExpect<Unneeded>(from = mark2) { it.isRestricted }
+        satelliteCallback.eventuallyExpect<Unneeded>(from = mark2) { !it.isRestricted }
+        assertEquals(2, satelliteCallback.mark - mark2)
+        satelliteCallback.expect<Needed> { !it.isRestricted }
+        restrictedSatelliteCallback.expect<Unneeded> { it.isRestricted }
+        satelliteCallback.assertNoCallback()
+        restrictedSatelliteCallback.assertNoCallback()
+
+        updateSatellitePreference(setOf(SMSUID), setOf(UID1))
+        restrictedSatelliteCallback.expect<Needed> { it.isRestricted }
+        satelliteCallback.expect<Unneeded> { !it.isRestricted }
+        val mark3 = satelliteCallback.mark
+        satelliteCallback.eventuallyExpect<Needed>(from = mark3) { it.isRestricted }
+        satelliteCallback.eventuallyExpect<Needed>(from = mark3) { !it.isRestricted }
+        assertEquals(2, satelliteCallback.mark - mark3)
+        satelliteCallback.assertNoCallback()
+        restrictedSatelliteCallback.assertNoCallback()
+
+        val wifiAgent = Agent(nc(TRANSPORT_WIFI, NET_CAPABILITY_INTERNET))
+        wifiAgent.connect()
+        val mark4 = satelliteCallback.mark
+        satelliteCallback.eventuallyExpect<Unneeded>(from = mark4) { it.isRestricted }
+        satelliteCallback.eventuallyExpect<Unneeded>(from = mark4) { !it.isRestricted }
+        assertEquals(2, satelliteCallback.mark - mark4)
+        restrictedSatelliteCallback.expect<Unneeded> { it.isRestricted }
+        satelliteCallback.assertNoCallback()
+        restrictedSatelliteCallback.assertNoCallback()
+
+        wifiAgent.disconnect()
+        val mark5 = satelliteCallback.mark
+        satelliteCallback.eventuallyExpect<Needed>(from = mark5) { it.isRestricted }
+        satelliteCallback.eventuallyExpect<Needed>(from = mark5) { !it.isRestricted }
+        assertEquals(2, satelliteCallback.mark - mark5)
+        restrictedSatelliteCallback.expect<Needed> { it.isRestricted }
+        satelliteCallback.assertNoCallback()
+        restrictedSatelliteCallback.assertNoCallback()
+    }
+}
diff --git a/tests/unit/java/com/android/server/connectivityservice/CSQueuedCallbacksTest.kt b/tests/unit/java/com/android/server/connectivityservice/CSQueuedCallbacksTest.kt
index 6d1858e964..4f15b1a6a7 100644
--- a/tests/unit/java/com/android/server/connectivityservice/CSQueuedCallbacksTest.kt
+++ b/tests/unit/java/com/android/server/connectivityservice/CSQueuedCallbacksTest.kt
@@ -55,14 +55,14 @@ import com.android.server.defaultLp
 import com.android.server.defaultNc
 import com.android.testutils.DevSdkIgnoreRule
 import com.android.testutils.DevSdkIgnoreRunner
-import com.android.testutils.RecorderCallback.CallbackEntry.BlockedStatus
-import com.android.testutils.RecorderCallback.CallbackEntry.CapabilitiesChanged
-import com.android.testutils.RecorderCallback.CallbackEntry.LinkPropertiesChanged
-import com.android.testutils.RecorderCallback.CallbackEntry.LocalInfoChanged
-import com.android.testutils.RecorderCallback.CallbackEntry.Lost
-import com.android.testutils.RecorderCallback.CallbackEntry.Resumed
-import com.android.testutils.RecorderCallback.CallbackEntry.Suspended
 import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.BlockedStatus
+import com.android.testutils.TestableNetworkCallback.Event.CapabilitiesChanged
+import com.android.testutils.TestableNetworkCallback.Event.LinkPropertiesChanged
+import com.android.testutils.TestableNetworkCallback.Event.LocalInfoChanged
+import com.android.testutils.TestableNetworkCallback.Event.Lost
+import com.android.testutils.TestableNetworkCallback.Event.Resumed
+import com.android.testutils.TestableNetworkCallback.Event.Suspended
 import com.android.testutils.visibleOnHandlerThread
 import com.android.testutils.waitForIdleSerialExecutor
 import java.util.Collections
diff --git a/tests/unit/java/com/android/server/connectivityservice/CSSatelliteNetworkTest.kt b/tests/unit/java/com/android/server/connectivityservice/CSSatelliteNetworkTest.kt
index 58420c0db2..31f70fdb8e 100644
--- a/tests/unit/java/com/android/server/connectivityservice/CSSatelliteNetworkTest.kt
+++ b/tests/unit/java/com/android/server/connectivityservice/CSSatelliteNetworkTest.kt
@@ -16,10 +16,9 @@
 
 package com.android.server
 
-import android.net.IpPrefix
+import android.Manifest.permission.NETWORK_SETTINGS
+import android.annotation.SuppressLint
 import android.net.INetd
-import android.net.LinkAddress
-import android.net.LinkProperties
 import android.net.NativeNetworkConfig
 import android.net.NativeNetworkType
 import android.net.NetworkCapabilities
@@ -29,15 +28,18 @@ import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED
 import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_ROAMING
 import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_SUSPENDED
 import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_VCN_MANAGED
-import android.net.NetworkScore
+import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_VPN
 import android.net.NetworkCapabilities.TRANSPORT_SATELLITE
-import android.net.NetworkScore.KEEP_CONNECTED_FOR_TEST
-import android.net.RouteInfo
+import android.net.NetworkCapabilities.TRANSPORT_WIFI
+import android.net.NetworkRequest
 import android.net.UidRange
 import android.net.UidRangeParcel
 import android.net.VpnManager
 import android.net.netd.aidl.NativeUidRangeConfig
 import android.os.Build
+import android.os.Handler
+import android.os.Looper
+import android.os.Process
 import android.os.UserHandle
 import android.util.ArraySet
 import com.android.net.module.util.CollectionUtils
@@ -46,7 +48,12 @@ import com.android.testutils.DevSdkIgnoreRule
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
 import com.android.testutils.DevSdkIgnoreRunner
 import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.Losing
+import com.android.testutils.TestableNetworkCallback.Event.Lost
+import com.android.testutils.runAsShell
 import com.android.testutils.visibleOnHandlerThread
+import kotlin.test.assertEquals
+import kotlin.test.assertTrue
 import org.junit.Assert
 import org.junit.Rule
 import org.junit.Test
@@ -55,14 +62,13 @@ import org.mockito.ArgumentMatchers.any
 import org.mockito.Mockito.inOrder
 import org.mockito.Mockito.never
 import org.mockito.Mockito.verify
-import kotlin.test.assertEquals
-import kotlin.test.assertTrue
 
 private const val SECONDARY_USER = 10
 private val SECONDARY_USER_HANDLE = UserHandle(SECONDARY_USER)
 private const val TEST_PACKAGE_UID = 123
 private const val TEST_PACKAGE_UID2 = 321
 
+@SuppressLint("VisibleForTests", "MissingPermission")
 @DevSdkIgnoreRunner.MonitorThreadLeak
 @RunWith(DevSdkIgnoreRunner::class)
 @IgnoreUpTo(Build.VERSION_CODES.TIRAMISU)
@@ -77,7 +83,10 @@ class CSSatelliteNetworkTest : CSTest() {
     @Test
     fun testCreateMultiLayerNrisFromSatelliteNetworkPreferredUids() {
         // Verify that empty uid set should not create any NRI for it.
-        val nrisNoUid = service.createMultiLayerNrisFromSatelliteNetworkFallbackUids(emptySet())
+        val nrisNoUid = service.createMultiLayerNrisFromSatelliteNetworkFallbackUids(
+            emptySet(),
+            emptySet()
+        )
         Assert.assertEquals(0, nrisNoUid.size.toLong())
         val uid1 = PRIMARY_USER_HANDLE.getUid(TEST_PACKAGE_UID)
         val uid2 = PRIMARY_USER_HANDLE.getUid(TEST_PACKAGE_UID2)
@@ -98,16 +107,17 @@ class CSSatelliteNetworkTest : CSTest() {
         satelliteAgent.connect()
 
         val satelliteNetId = satelliteAgent.network.netId
-        val permission = if (restricted) {INetd.PERMISSION_SYSTEM} else {INetd.PERMISSION_NONE}
+        val permission = if (restricted) INetd.PERMISSION_SYSTEM else INetd.PERMISSION_NONE
         netdInOrder.verify(netd).networkCreate(
-            nativeNetworkConfigPhysical(satelliteNetId, permission))
+            nativeNetworkConfigPhysical(satelliteNetId, permission)
+        )
 
         val uid1 = PRIMARY_USER_HANDLE.getUid(TEST_PACKAGE_UID)
         val uid2 = PRIMARY_USER_HANDLE.getUid(TEST_PACKAGE_UID2)
         val uid3 = SECONDARY_USER_HANDLE.getUid(TEST_PACKAGE_UID)
 
         // Initial satellite network fallback uids status.
-        updateSatelliteNetworkFallbackUids(setOf())
+        updateSatelliteNetworkFallbackUids(emptySet(), emptySet())
         netdInOrder.verify(netd, never()).networkAddUidRangesParcel(any())
         netdInOrder.verify(netd, never()).networkRemoveUidRangesParcel(any())
 
@@ -115,10 +125,11 @@ class CSSatelliteNetworkTest : CSTest() {
         var uids = mutableSetOf(uid1, uid2, uid3)
         val uidRanges1 = toUidRangeStableParcels(uidRangesForUids(uids))
         val config1 = NativeUidRangeConfig(
-            satelliteNetId, uidRanges1,
+            satelliteNetId,
+            uidRanges1,
             PREFERENCE_ORDER_SATELLITE_FALLBACK
         )
-        updateSatelliteNetworkFallbackUids(uids)
+        updateSatelliteNetworkFallbackUids(uids, emptySet())
         netdInOrder.verify(netd).networkAddUidRangesParcel(config1)
         netdInOrder.verify(netd, never()).networkRemoveUidRangesParcel(any())
 
@@ -126,10 +137,11 @@ class CSSatelliteNetworkTest : CSTest() {
         uids = mutableSetOf(uid1)
         val uidRanges2: Array<UidRangeParcel?> = toUidRangeStableParcels(uidRangesForUids(uids))
         val config2 = NativeUidRangeConfig(
-            satelliteNetId, uidRanges2,
+            satelliteNetId,
+            uidRanges2,
             PREFERENCE_ORDER_SATELLITE_FALLBACK
         )
-        updateSatelliteNetworkFallbackUids(uids)
+        updateSatelliteNetworkFallbackUids(uids, emptySet())
         netdInOrder.verify(netd).networkRemoveUidRangesParcel(config1)
         netdInOrder.verify(netd).networkAddUidRangesParcel(config2)
     }
@@ -163,8 +175,10 @@ class CSSatelliteNetworkTest : CSTest() {
         doTestSatelliteNeverBecomeDefaultNetwork(restricted = false)
     }
 
-    private fun doTestUnregisterAfterReplacementSatisfier(destroyBeforeRequest: Boolean = false,
-                                                          destroyAfterRequest: Boolean = false) {
+    private fun doTestUnregisterAfterReplacementSatisfier(
+        destroyBeforeRequest: Boolean = false,
+        destroyAfterRequest: Boolean = false
+    ) {
         val satelliteAgent = createSatelliteAgent("satellite0")
         satelliteAgent.connect()
 
@@ -173,7 +187,7 @@ class CSSatelliteNetworkTest : CSTest() {
         }
 
         val uids = setOf(TEST_PACKAGE_UID)
-        updateSatelliteNetworkFallbackUids(uids)
+        updateSatelliteNetworkFallbackUids(uids, emptySet())
 
         if (destroyBeforeRequest) {
             verify(netd, never()).networkAddUidRangesParcel(any())
@@ -191,7 +205,7 @@ class CSSatelliteNetworkTest : CSTest() {
             satelliteAgent.unregisterAfterReplacement(timeoutMs = 5000)
         }
 
-        updateSatelliteNetworkFallbackUids(setOf())
+        updateSatelliteNetworkFallbackUids(setOf(), emptySet())
         if (destroyBeforeRequest || destroyAfterRequest) {
             // If the network is already destroyed, networkRemoveUidRangesParcel should not be
             // called.
@@ -222,9 +236,74 @@ class CSSatelliteNetworkTest : CSTest() {
         doTestUnregisterAfterReplacementSatisfier()
     }
 
+    @SuppressLint("MissingPermission")
+    @Test @IgnoreUpTo(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+    fun testFallbackNetworkCallbacks() {
+        val handler = Handler(Looper.getMainLooper())
+        val myUid = Process.myUid()
+        val otherUid = Process.myUid() + 1
+        val defaultCb = TestableNetworkCallback().also { cm.registerDefaultNetworkCallback(it) }
+        val otherUidCb = TestableNetworkCallback().also {
+            runAsShell(NETWORK_SETTINGS) {
+                cm.registerDefaultNetworkCallbackForUid(otherUid, it, handler)
+            }
+        }
+        val allNetworksCb = TestableNetworkCallback().also {
+            cm.registerNetworkCallback(NetworkRequest.Builder().clearCapabilities().build(), it)
+        }
+
+        updateSatelliteNetworkFallbackUids(setOf(myUid), emptySet())
+        defaultCb.assertNoCallback()
+
+        val satelliteAgent = createSatelliteAgent(
+            "satellite0",
+            restricted = false,
+            keepConnected = false
+        ).apply { connect() }
+        val satelliteNetwork = satelliteAgent.network
+
+        allNetworksCb.expectAvailableCallbacks(satelliteNetwork, validated = false)
+        defaultCb.expectAvailableCallbacks(satelliteNetwork, validated = false)
+        otherUidCb.assertNoCallback()
+
+        val wifiAgent = Agent(
+            lp = defaultLp().apply { interfaceName = "wlan0" },
+                nc = ncForTransport(TRANSPORT_WIFI)
+        ).apply { connect() }
+        val wifiNetwork = wifiAgent.network
+
+        allNetworksCb.expectAvailableCallbacks(wifiNetwork, validated = false)
+        defaultCb.expectAvailableCallbacks(wifiNetwork, validated = false)
+        otherUidCb.expectAvailableCallbacks(wifiNetwork, validated = false)
+        allNetworksCb.expect<Losing>(satelliteNetwork)
+        allNetworksCb.expect<Lost>(satelliteNetwork)
+
+        wifiAgent.disconnect()
+        allNetworksCb.expect<Lost>(wifiNetwork)
+        defaultCb.expect<Lost>(wifiNetwork)
+        otherUidCb.expect<Lost>(wifiNetwork)
+
+        val satelliteAgent2 = createSatelliteAgent(
+            "satellite0",
+            restricted = false,
+            keepConnected = false
+        )
+        satelliteAgent2.connect()
+        val satelliteNetwork2 = satelliteAgent2.network
+
+        allNetworksCb.expectAvailableCallbacks(satelliteNetwork2, validated = false)
+        defaultCb.expectAvailableCallbacks(satelliteNetwork2, validated = false)
+
+        updateSatelliteNetworkFallbackUids(emptySet(), emptySet())
+
+        allNetworksCb.expect<Lost>(satelliteNetwork2)
+        defaultCb.expect<Lost>(satelliteNetwork2)
+        otherUidCb.assertNoCallback()
+    }
+
     private fun assertCreateMultiLayerNrisFromSatelliteNetworkPreferredUids(uids: Set<Int>) {
-        val nris: Set<ConnectivityService.NetworkRequestInfo> =
-            service.createMultiLayerNrisFromSatelliteNetworkFallbackUids(uids)
+        val nris =
+            service.createMultiLayerNrisFromSatelliteNetworkFallbackUids(uids, emptySet())
         val nri = nris.iterator().next()
         // Verify that one NRI is created with multilayer requests. Because one NRI can contain
         // multiple uid ranges, so it only need create one NRI here.
@@ -234,18 +313,30 @@ class CSSatelliteNetworkTest : CSTest() {
         assertEquals(PREFERENCE_ORDER_SATELLITE_FALLBACK, nri.mPreferenceOrder)
     }
 
-    private fun updateSatelliteNetworkFallbackUids(uids: Set<Int>) {
+    private fun updateSatelliteNetworkFallbackUids(messagingUids: Set<Int>, optinUids: Set<Int>) {
         visibleOnHandlerThread(csHandler) {
-            deps.satelliteNetworkFallbackUidUpdate!!.accept(uids)
+            deps.satelliteNetworkFallbackUidUpdate!!.accept(messagingUids, optinUids)
         }
     }
 
     private fun nativeNetworkConfigPhysical(netId: Int, permission: Int) =
-        NativeNetworkConfig(netId, NativeNetworkType.PHYSICAL, permission,
-            false /* secure */, VpnManager.TYPE_VPN_NONE, false /* excludeLocalRoutes */)
+        NativeNetworkConfig(
+            netId,
+            NativeNetworkType.PHYSICAL,
+            permission,
+            false /* secure */,
+            VpnManager.TYPE_VPN_NONE,
+            false /* excludeLocalRoutes */
+        )
 
-    private fun createSatelliteAgent(name: String, restricted: Boolean = true): CSAgentWrapper {
-        return Agent(score = keepScore(), lp = lp(name),
+    private fun createSatelliteAgent(
+        name: String,
+        restricted: Boolean = true,
+        keepConnected: Boolean = true
+    ): CSAgentWrapper {
+        return Agent(
+            score = if (keepConnected) keepScore() else defaultScore(),
+            lp = defaultLp().apply { interfaceName = name },
             nc = satelliteNc(restricted)
         )
     }
@@ -270,29 +361,23 @@ class CSSatelliteNetworkTest : CSTest() {
         return uidRangesForUids(*CollectionUtils.toIntArray(uids))
     }
 
-    private fun satelliteNc(restricted: Boolean) =
-            NetworkCapabilities.Builder().apply {
-                addTransportType(TRANSPORT_SATELLITE)
-
-                addCapability(NET_CAPABILITY_INTERNET)
-                addCapability(NET_CAPABILITY_NOT_SUSPENDED)
-                addCapability(NET_CAPABILITY_NOT_ROAMING)
-                addCapability(NET_CAPABILITY_NOT_VCN_MANAGED)
-                if (restricted) {
-                    removeCapability(NET_CAPABILITY_NOT_RESTRICTED)
-                }
-                removeCapability(NET_CAPABILITY_NOT_BANDWIDTH_CONSTRAINED)
-            }.build()
-
-    private fun lp(iface: String) = LinkProperties().apply {
-        interfaceName = iface
-        addLinkAddress(LinkAddress(LOCAL_IPV4_ADDRESS, 32))
-        addRoute(RouteInfo(IpPrefix("0.0.0.0/0"), null, null))
+    private fun ncForTransport(transport: Int) =
+        NetworkCapabilities.Builder().apply {
+            addTransportType(transport)
+            addCapability(NET_CAPABILITY_INTERNET)
+            addCapability(NET_CAPABILITY_NOT_SUSPENDED)
+            addCapability(NET_CAPABILITY_NOT_ROAMING)
+            addCapability(NET_CAPABILITY_NOT_VCN_MANAGED)
+            addCapability(NET_CAPABILITY_NOT_VPN)
+        }.build()
+
+    private fun satelliteNc(restricted: Boolean): NetworkCapabilities {
+        val nc = ncForTransport(TRANSPORT_SATELLITE)
+        if (restricted) {
+            nc.removeCapability(NET_CAPABILITY_NOT_RESTRICTED)
+        } else {
+            nc.removeCapability(NET_CAPABILITY_NOT_BANDWIDTH_CONSTRAINED)
+        }
+        return nc
     }
-
-    // This allows keeping all the networks connected without having to file individual requests
-    // for them.
-    private fun keepScore() = FromS(
-        NetworkScore.Builder().setKeepConnectedReason(KEEP_CONNECTED_FOR_TEST).build()
-    )
 }
diff --git a/tests/unit/java/com/android/server/connectivityservice/CSShellCommandsTest.kt b/tests/unit/java/com/android/server/connectivityservice/CSShellCommandsTest.kt
new file mode 100644
index 0000000000..3467fff894
--- /dev/null
+++ b/tests/unit/java/com/android/server/connectivityservice/CSShellCommandsTest.kt
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server
+
+import android.annotation.SuppressLint
+import android.net.INetd
+import android.net.NativeNetworkConfig
+import android.net.NativeNetworkType
+import android.net.NetworkCapabilities
+import android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET
+import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_BANDWIDTH_CONSTRAINED
+import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_ROAMING
+import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_SUSPENDED
+import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_VCN_MANAGED
+import android.net.NetworkCapabilities.NET_CAPABILITY_NOT_VPN
+import android.net.NetworkCapabilities.TRANSPORT_SATELLITE
+import android.net.NetworkCapabilities.TRANSPORT_WIFI
+import android.net.NetworkRequest
+import android.net.UidRangeParcel
+import android.net.VpnManager
+import android.net.netd.aidl.NativeUidRangeConfig
+import android.os.Build
+import android.os.ParcelFileDescriptor
+import android.os.Process
+import androidx.test.filters.SmallTest
+import com.android.server.ConnectivityService.PREFERENCE_ORDER_DEBUG_FALLBACK
+import com.android.testutils.DevSdkIgnoreRule
+import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
+import com.android.testutils.DevSdkIgnoreRunner
+import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.Losing
+import com.android.testutils.TestableNetworkCallback.Event.Lost
+import java.io.File
+import org.junit.Assume.assumeTrue
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.Mockito.inOrder
+
+@DevSdkIgnoreRunner.MonitorThreadLeak
+@RunWith(DevSdkIgnoreRunner::class)
+@SmallTest
+@IgnoreUpTo(Build.VERSION_CODES.R)
+class CSShellCommandsTest : CSTest() {
+
+    @get:Rule
+    val ignoreRule = DevSdkIgnoreRule()
+
+    fun handleShellCommand(args: String) {
+        val pfd = ParcelFileDescriptor.open(File("/dev/null"), ParcelFileDescriptor.MODE_READ_WRITE)
+        service.handleShellCommand(pfd, pfd, pfd, args.split(" ").toTypedArray())
+    }
+
+    fun ncForTransport(transport: Int, otherCaps: IntArray = intArrayOf()): NetworkCapabilities {
+        return NetworkCapabilities.Builder().apply {
+            addTransportType(transport)
+            addCapability(NET_CAPABILITY_INTERNET)
+            addCapability(NET_CAPABILITY_NOT_ROAMING)
+            addCapability(NET_CAPABILITY_NOT_SUSPENDED)
+            addCapability(NET_CAPABILITY_NOT_VCN_MANAGED)
+            addCapability(NET_CAPABILITY_NOT_VPN)
+            removeCapability(NET_CAPABILITY_NOT_BANDWIDTH_CONSTRAINED)
+            for (i in otherCaps) addCapability(i)
+        }.build()
+    }
+
+    private fun nativeNetworkConfigPhysical(netId: Int) =
+        NativeNetworkConfig(
+            netId,
+            NativeNetworkType.PHYSICAL,
+            INetd.PERMISSION_NONE,
+            false, // secure
+            VpnManager.TYPE_VPN_NONE,
+            false // excludeLocalRoutes
+        )
+
+    private fun uidRangeConfig(netId: Int, uid: Int) = NativeUidRangeConfig(
+        netId,
+        arrayOf(UidRangeParcel(uid, uid)),
+        PREFERENCE_ORDER_DEBUG_FALLBACK
+    )
+
+    private fun createSatelliteNetwork() = Agent(
+        lp = defaultLp().apply{ interfaceName = "satellite0" },
+        nc = ncForTransport(TRANSPORT_SATELLITE),
+        score = defaultScore() // Do not keep connected if there are no requests.
+    ).apply { connect() }.network
+
+    @SuppressLint("MissingPermission")
+    @Test @IgnoreUpTo(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+    fun testDebugFallbackNetwork() {
+        assumeTrue(Build.isDebuggable())
+
+        val myUid = Process.myUid()
+        val inOrder = inOrder(netd)
+        val cb = TestableNetworkCallback()
+        cm.registerNetworkCallback(NetworkRequest.Builder().clearCapabilities().build(), cb)
+
+        val defaultCb = TestableNetworkCallback()
+        cm.registerDefaultNetworkCallback(defaultCb)
+
+        // Set myUid to default to satellite.
+        handleShellCommand(
+            "set-debug-fallback-network-for-uid $myUid $TRANSPORT_SATELLITE"
+        )
+
+        // When satellite connects, it becomes the default network for myUid.
+        val satelliteNetwork = createSatelliteNetwork()
+        val satelliteNetId = satelliteNetwork.netId
+        cb.expectAvailableCallbacks(satelliteNetwork, validated = false)
+        defaultCb.expectAvailableCallbacks(satelliteNetwork, validated = false)
+
+        inOrder.verify(netd).networkCreate(nativeNetworkConfigPhysical(satelliteNetId))
+        inOrder.verify(netd).networkAddUidRangesParcel(uidRangeConfig(satelliteNetId, myUid))
+
+        // When wifi connects, satellite is no longer myUid's default and gets torn down.
+        val wifiAgent = Agent(ncForTransport(
+            TRANSPORT_WIFI,
+            intArrayOf(NET_CAPABILITY_NOT_BANDWIDTH_CONSTRAINED)
+        ))
+        wifiAgent.connect()
+        cb.expectAvailableCallbacks(wifiAgent.network, validated = false)
+        defaultCb.expectAvailableCallbacks(wifiAgent.network, validated = false)
+
+        cb.expect<Losing>(satelliteNetwork)
+        cb.expect<Lost>(satelliteNetwork)
+        inOrder.verify(netd).networkRemoveUidRangesParcel(uidRangeConfig(satelliteNetId, myUid))
+        waitForIdle() // Network teardown is not guaranteed to have happened when onLost fires.
+        inOrder.verify(netd).networkDestroy(satelliteNetId)
+
+        // When wifi disconnects, satellite becomes the default again.
+        wifiAgent.disconnect()
+        cb.expect<Lost>(wifiAgent.network)
+        defaultCb.expect<Lost>(wifiAgent.network)
+
+        val satelliteNetwork2 = createSatelliteNetwork()
+        val satelliteNetId2 = satelliteNetwork2.netId
+        cb.expectAvailableCallbacks(satelliteNetwork2, validated = false)
+        defaultCb.expectAvailableCallbacks(satelliteNetwork2, validated = false)
+
+        inOrder.verify(netd).networkCreate(nativeNetworkConfigPhysical(satelliteNetId2))
+        inOrder.verify(netd).networkAddUidRangesParcel(uidRangeConfig(satelliteNetId2, myUid))
+
+        // Set myUid to no longer default to satellite, and expect satellite to disconnect.
+        // It cannot be the system default network because it's bandwidth constrained.
+        handleShellCommand("clear-debug-fallback-network-for-uid ${Process.myUid()}")
+        cb.expect<Lost>(satelliteNetwork2)
+        defaultCb.expect<Lost>(satelliteNetwork2)
+
+        inOrder.verify(netd).networkRemoveUidRangesParcel(uidRangeConfig(satelliteNetId2, myUid))
+        waitForIdle() // Network teardown is not guaranteed to have happened when onLost fires.
+        inOrder.verify(netd).networkDestroy(satelliteNetId2)
+    }
+}
diff --git a/tests/unit/java/com/android/server/connectivityservice/base/CSAgentWrapper.kt b/tests/unit/java/com/android/server/connectivityservice/base/CSAgentWrapper.kt
index a77daa810e..a285dd1103 100644
--- a/tests/unit/java/com/android/server/connectivityservice/base/CSAgentWrapper.kt
+++ b/tests/unit/java/com/android/server/connectivityservice/base/CSAgentWrapper.kt
@@ -22,6 +22,7 @@ import android.net.INetworkMonitor
 import android.net.INetworkMonitor.NETWORK_VALIDATION_PROBE_DNS
 import android.net.INetworkMonitor.NETWORK_VALIDATION_PROBE_HTTP
 import android.net.INetworkMonitorCallbacks
+import android.net.KeepalivePacketData
 import android.net.LinkProperties
 import android.net.LocalNetworkConfig
 import android.net.Network
@@ -35,13 +36,36 @@ import android.net.NetworkProvider
 import android.net.NetworkRequest
 import android.net.NetworkScore
 import android.net.NetworkTestResultParcelable
+import android.net.QosFilter
+import android.net.Uri
 import android.net.networkstack.NetworkStackClientBase
 import android.os.HandlerThread
-import com.android.testutils.RecorderCallback.CallbackEntry.Available
-import com.android.testutils.RecorderCallback.CallbackEntry.Lost
+import android.os.Looper
+import com.android.net.module.util.ArrayTrackRecord
+import com.android.testutils.TestableNetworkAgent.Event
+import com.android.testutils.TestableNetworkAgent.Event.OnAddKeepalivePacketFilter
+import com.android.testutils.TestableNetworkAgent.Event.OnAutomaticReconnectDisabled
+import com.android.testutils.TestableNetworkAgent.Event.OnBandwidthUpdateRequested
+import com.android.testutils.TestableNetworkAgent.Event.OnDscpPolicyStatusUpdated
+import com.android.testutils.TestableNetworkAgent.Event.OnNetworkCreated
+import com.android.testutils.TestableNetworkAgent.Event.OnNetworkDestroyed
+import com.android.testutils.TestableNetworkAgent.Event.OnNetworkUnwanted
+import com.android.testutils.TestableNetworkAgent.Event.OnRegisterQosCallback
+import com.android.testutils.TestableNetworkAgent.Event.OnRemoveKeepalivePacketFilter
+import com.android.testutils.TestableNetworkAgent.Event.OnSaveAcceptUnvalidated
+import com.android.testutils.TestableNetworkAgent.Event.OnSignalStrengthThresholdsUpdated
+import com.android.testutils.TestableNetworkAgent.Event.OnStartSocketKeepalive
+import com.android.testutils.TestableNetworkAgent.Event.OnStopSocketKeepalive
+import com.android.testutils.TestableNetworkAgent.Event.OnUnregisterQosCallback
+import com.android.testutils.TestableNetworkAgent.Event.OnValidationStatus
 import com.android.testutils.TestableNetworkCallback
+import com.android.testutils.TestableNetworkCallback.Event.Available
+import com.android.testutils.TestableNetworkCallback.Event.Lost
+import java.time.Duration
 import java.util.concurrent.atomic.AtomicInteger
 import kotlin.test.assertEquals
+import kotlin.test.assertNotNull
+import kotlin.test.assertTrue
 import kotlin.test.fail
 import org.mockito.ArgumentCaptor
 import org.mockito.ArgumentMatchers.any
@@ -87,9 +111,104 @@ class CSAgentWrapper(
     private var nmValidationResult = NO_PROBE_RESULT
     private var nmProbesCompleted = NO_PROBE_RESULT
     private var nmProbesSucceeded = NO_PROBE_RESULT
+    val history = ArrayTrackRecord<Event>().newReadHead()
+    val DEFAULT_TIMEOUT_MS = 5000L
 
     override val network: Network get() = agent.network!!
 
+    inner class TestAgent : NetworkAgent {
+        constructor(
+            context: Context,
+            looper: Looper,
+            tag: String,
+            nc: NetworkCapabilities,
+            lp: LinkProperties,
+            lnc: LocalNetworkConfig?,
+            score: NetworkScore,
+            nac: NetworkAgentConfig,
+            provider: NetworkProvider?
+        ) :
+                super(context, looper, tag, nc, lp, lnc, score, nac, provider) {
+        }
+
+        constructor(
+            context: Context,
+            looper: Looper,
+            tag: String,
+            nc: NetworkCapabilities,
+            lp: LinkProperties,
+            score: Int,
+            nac: NetworkAgentConfig,
+            provider: NetworkProvider?
+        ) :
+                super(context, looper, tag, nc, lp, score, nac, provider) {
+        }
+
+        override fun onBandwidthUpdateRequested() {
+            history.add(OnBandwidthUpdateRequested)
+        }
+
+        override fun onNetworkUnwanted() {
+            history.add(OnNetworkUnwanted)
+        }
+
+        override fun onAddKeepalivePacketFilter(slot: Int, packet: KeepalivePacketData) {
+            history.add(OnAddKeepalivePacketFilter(slot, packet))
+        }
+
+        override fun onRemoveKeepalivePacketFilter(slot: Int) {
+            history.add(OnRemoveKeepalivePacketFilter(slot))
+        }
+
+        override fun onStartSocketKeepalive(
+            slot: Int,
+            interval: Duration,
+            packet: KeepalivePacketData
+        ) {
+            history.add(OnStartSocketKeepalive(slot, interval.seconds.toInt(), packet))
+        }
+
+        override fun onStopSocketKeepalive(slot: Int) {
+            history.add(OnStopSocketKeepalive(slot))
+        }
+
+        override fun onSaveAcceptUnvalidated(accept: Boolean) {
+            history.add(OnSaveAcceptUnvalidated(accept))
+        }
+
+        override fun onAutomaticReconnectDisabled() {
+            history.add(OnAutomaticReconnectDisabled)
+        }
+
+        override fun onSignalStrengthThresholdsUpdated(thresholds: IntArray) {
+            history.add(OnSignalStrengthThresholdsUpdated(thresholds))
+        }
+
+        override fun onQosCallbackRegistered(qosCallbackId: Int, filter: QosFilter) {
+            history.add(OnRegisterQosCallback(qosCallbackId, filter))
+        }
+
+        override fun onQosCallbackUnregistered(qosCallbackId: Int) {
+            history.add(OnUnregisterQosCallback(qosCallbackId))
+        }
+
+        override fun onValidationStatus(status: Int, uri: Uri?) {
+            history.add(OnValidationStatus(status, uri))
+        }
+
+        override fun onNetworkCreated() {
+            history.add(OnNetworkCreated)
+        }
+
+        override fun onNetworkDestroyed() {
+            history.add(OnNetworkDestroyed)
+        }
+
+        override fun onDscpPolicyStatusUpdated(policyId: Int, status: Int) {
+            history.add(OnDscpPolicyStatusUpdated(policyId, status))
+        }
+    }
+
     init {
         // Capture network monitor callbacks and simulate network monitor
         val validateAnswer = Answer {
@@ -108,12 +227,13 @@ class CSAgentWrapper(
         )
 
         // Create the actual agent. NetworkAgent is abstract, so make an anonymous subclass.
-        if (deps.isAtLeastS()) {
-            agent = object : NetworkAgent(context, csHandlerThread.looper, TAG,
-                    nc, lp, lnc?.value, score.value, nac, provider) {}
+        agent = if (deps.isAtLeastS()) {
+            TestAgent(
+                context, csHandlerThread.looper, TAG, nc, lp, lnc?.value,
+                score.value, nac, provider)
         } else {
-            agent = object : NetworkAgent(context, csHandlerThread.looper, TAG,
-                    nc, lp, 50 /* score */, nac, provider) {}
+            TestAgent(
+                context, csHandlerThread.looper, TAG, nc, lp, 50 /* score */, nac, provider)
         }
         agent.register()
         assertEquals(agent.network!!.netId, nmNetworkCaptor.value.netId)
@@ -191,6 +311,7 @@ class CSAgentWrapper(
             agent.unregister()
             cb.assertNoCallback()
         }
+        mgr.unregisterNetworkCallback(cb)
     }
 
     fun setTeardownDelayMillis(delayMillis: Int) = agent.setTeardownDelayMillis(delayMillis)
@@ -199,6 +320,7 @@ class CSAgentWrapper(
     fun sendLocalNetworkConfig(lnc: LocalNetworkConfig) = agent.sendLocalNetworkConfig(lnc)
     fun sendNetworkCapabilities(nc: NetworkCapabilities) = agent.sendNetworkCapabilities(nc)
     fun sendLinkProperties(lp: LinkProperties) = agent.sendLinkProperties(lp)
+    fun sendTeardownDelayMs(delayMs: Int) = agent.setTeardownDelayMillis(delayMs)
 
     fun connectWithCaptivePortal(redirectUrl: String) {
         setCaptivePortal(redirectUrl)
@@ -224,4 +346,16 @@ class CSAgentWrapper(
             probesSucceeded = NO_PROBE_RESULT
         )
     }
+
+    inline fun <reified T : Event> expect(test: (T) -> Boolean = { true }): T {
+        val foundCallback = history.poll(DEFAULT_TIMEOUT_MS)
+        assertTrue(foundCallback is T, "Expected ${T::class} but found $foundCallback")
+        assertTrue(test(foundCallback), "Unexpected callback : $foundCallback")
+        return foundCallback
+    }
+
+    inline fun <reified T : Event> eventuallyExpect() =
+        history.poll(DEFAULT_TIMEOUT_MS) { it is T }.also {
+            assertNotNull(it, "Callback ${T::class} not received")
+        } as T
 }
diff --git a/tests/unit/java/com/android/server/connectivityservice/base/CSTest.kt b/tests/unit/java/com/android/server/connectivityservice/base/CSTest.kt
index 0fe61eca44..1a97e3a9c0 100644
--- a/tests/unit/java/com/android/server/connectivityservice/base/CSTest.kt
+++ b/tests/unit/java/com/android/server/connectivityservice/base/CSTest.kt
@@ -16,6 +16,7 @@
 
 package com.android.server
 
+import android.annotation.SuppressLint
 import android.app.AlarmManager
 import android.app.AppOpsManager
 import android.bluetooth.BluetoothManager
@@ -27,6 +28,7 @@ import android.content.pm.PackageManager.PERMISSION_GRANTED
 import android.content.pm.UserInfo
 import android.content.res.Resources
 import android.net.ConnectivityManager
+import android.net.IDnsResolver
 import android.net.INetd
 import android.net.INetd.PERMISSION_INTERNET
 import android.net.InetAddresses
@@ -44,6 +46,7 @@ import android.net.NetworkCapabilities.TRANSPORT_WIFI
 import android.net.NetworkPolicyManager
 import android.net.NetworkProvider
 import android.net.NetworkScore
+import android.net.NetworkScore.KEEP_CONNECTED_FOR_TEST
 import android.net.PacProxyManager
 import android.net.connectivity.ConnectivityCompatChanges.ENABLE_MATCH_LOCAL_NETWORK
 import android.net.networkstack.NetworkStackClientBase
@@ -58,11 +61,17 @@ import android.permission.PermissionManager.PermissionResult
 import android.telephony.SubscriptionManager
 import android.telephony.TelephonyManager
 import android.testing.TestableContext
+import android.util.Range
+import android.util.SparseArray
 import androidx.test.platform.app.InstrumentationRegistry
 import com.android.internal.app.IBatteryStats
 import com.android.internal.util.test.BroadcastInterceptingContext
+import com.android.metrics.DefaultNetworkRematchMetrics
+import com.android.metrics.SatelliteCoarseUsageMetricsCollector
 import com.android.modules.utils.build.SdkLevel
 import com.android.net.module.util.ArrayTrackRecord
+import com.android.net.module.util.SharedLog
+import com.android.net.module.util.netlink.NetlinkMessage
 import com.android.networkstack.apishim.common.UnsupportedApiLevelException
 import com.android.server.connectivity.AutomaticOnOffKeepaliveTracker
 import com.android.server.connectivity.CarrierPrivilegeAuthenticator
@@ -72,12 +81,15 @@ import com.android.server.connectivity.InterfaceTracker
 import com.android.server.connectivity.MulticastRoutingCoordinatorService
 import com.android.server.connectivity.MultinetworkPolicyTracker
 import com.android.server.connectivity.MultinetworkPolicyTrackerTestDependencies
+import com.android.server.connectivity.NetworkAgentInfo
 import com.android.server.connectivity.NetworkRequestStateStatsMetrics
 import com.android.server.connectivity.PermissionMonitor
 import com.android.server.connectivity.ProxyTracker
+import com.android.server.connectivity.QuicConnectionCloser
 import com.android.server.connectivity.SatelliteAccessController
 import com.android.testutils.visibleOnHandlerThread
 import com.android.testutils.waitForIdle
+import java.net.InetAddress
 import java.util.concurrent.Executors
 import java.util.concurrent.LinkedBlockingQueue
 import java.util.concurrent.TimeUnit
@@ -135,6 +147,7 @@ private fun NetworkCapabilities.getLegacyType() =
  */
 // TODO (b/272685721) : make ConnectivityServiceTest smaller and faster by moving the setup
 // parts into this class and moving the individual tests to multiple separate classes.
+@SuppressLint("VisibleForTests", "MissingPermission")
 open class CSTest {
     @get:Rule
     val testNameRule = TestName()
@@ -171,6 +184,9 @@ open class CSTest {
         it[ConnectivityFlags.USE_DECLARED_METHODS_FOR_CALLBACKS] = true
         it[ConnectivityFlags.QUEUE_CALLBACKS_FOR_FROZEN_APPS] = true
         it[ConnectivityFlags.QUEUE_NETWORK_AGENT_EVENTS_IN_SYSTEM_SERVER] = true
+        it[ConnectivityFlags.CLOSE_QUIC_CONNECTION] = true
+        it[ConnectivityFlags.EARLY_LINK_PROPERTIES_UPDATE_FOR_VPN] = true
+        it[ConnectivityFlags.CONSTRAINED_DATA_SATELLITE_METRICS] = true
     }
     fun setFeatureEnabled(flag: String, enabled: Boolean) = enabledFeatures.set(flag, enabled)
 
@@ -219,7 +235,11 @@ open class CSTest {
 
     val multicastRoutingCoordinatorService = mock<MulticastRoutingCoordinatorService>()
     val satelliteAccessController = mock<SatelliteAccessController>()
+    val satelliteCoarseUsageMetricsCollector = mock<SatelliteCoarseUsageMetricsCollector>()
+    val defaultNetworkRematchMetrics = mock<DefaultNetworkRematchMetrics>()
+    val quicConnectionCloser = mock<QuicConnectionCloser>()
     val destroySocketsWrapper = mock<DestroySocketsWrapper>()
+    val dnsResolver = mock<IDnsResolver>()
 
     val deps = CSDeps()
     val permDeps = PermDeps()
@@ -259,7 +279,7 @@ open class CSTest {
 
         alarmHandlerThread = HandlerThread("TestAlarmManager").also { it.start() }
         alarmManager = makeMockAlarmManager(alarmHandlerThread)
-        service = makeConnectivityService(context, netd, deps, permDeps).also {
+        service = makeConnectivityService(context, netd, deps, permDeps, dnsResolver).also {
             it.systemReadyInternal()
         }
         cm = ConnectivityManager(context, service)
@@ -277,8 +297,22 @@ open class CSTest {
     }
 
     // Class to be mocked and used to verify destroy sockets methods call
+    // TODO: Move to use TestableCallback-style object with a TrackRecord inside to check.
     open inner class DestroySocketsWrapper {
         open fun destroyLiveTcpSocketsByOwnerUids(ownerUids: Set<Int>) {}
+        open fun destroyLiveTcpSocketsByLocalAddress(
+            address: InetAddress,
+            netIdRange: Set<Range<Int>>?,
+            uidRanges: Set<Range<Int>>?
+        ) {}
+        open fun destroyLiveTcpSocketsByLocalAddress(
+            address: InetAddress?,
+            interfaceId: Int
+        ) {}
+        open fun destroyLiveTcpSocketsLackingPermission(
+            netId: Int,
+            permission: Int
+        ) {}
     }
 
     inner class CSDeps : ConnectivityService.Dependencies() {
@@ -288,6 +322,8 @@ open class CSTest {
             netd: INetd,
             interfaceTracker: InterfaceTracker
         ) = this@CSTest.bpfNetMaps
+
+        override fun getInterfaceTracker(context: Context?) = this@CSTest.interfaceTracker
         override fun getClatCoordinator(netd: INetd?) = this@CSTest.clatCoordinator
         override fun getNetworkStack() = this@CSTest.networkStack
 
@@ -303,17 +339,24 @@ open class CSTest {
                 listener: BiConsumer<Int, Int>,
                 handler: Handler
         ) = if (SdkLevel.isAtLeastT()) mock<CarrierPrivilegeAuthenticator>() else null
-
-        var satelliteNetworkFallbackUidUpdate: Consumer<Set<Int>>? = null
+        var satelliteNetworkFallbackUidUpdate = BiConsumer<Set<Int>, Set<Int>> {_, _ -> }
         override fun makeSatelliteAccessController(
             context: Context,
-            updateSatelliteNetworkFallackUid: Consumer<Set<Int>>?,
+            updateSatelliteNetworkFallackUid: BiConsumer<Set<Int>, Set<Int>>,
             csHandlerThread: Handler
         ): SatelliteAccessController? {
             satelliteNetworkFallbackUidUpdate = updateSatelliteNetworkFallackUid
             return satelliteAccessController
         }
 
+        override fun makeSatelliteCoarseUsageMetricsCollector(
+                context: Context
+        ) = satelliteCoarseUsageMetricsCollector
+
+        override fun makeDefaultNetworkRematchMetrics(): DefaultNetworkRematchMetrics? {
+            return defaultNetworkRematchMetrics
+        }
+
         private inner class AOOKTDeps(c: Context) : AutomaticOnOffKeepaliveTracker.Dependencies(c) {
             override fun isTetheringFeatureNotChickenedOut(name: String): Boolean {
                 return isFeatureEnabled(context, name)
@@ -404,16 +447,79 @@ open class CSTest {
         override fun getCallingUid() =
                 if (callingUid == CALLING_UID_UNMOCKED) super.getCallingUid() else callingUid
 
+        private var mockedElapsedTime = 0L
+
+        override fun getElapsedRealtime() = mockedElapsedTime
+
+        fun setElapsedRealtime(time: Long) {
+            visibleOnHandlerThread(csHandler) { mockedElapsedTime = time }
+        }
+
         override fun destroyLiveTcpSocketsByOwnerUids(ownerUids: Set<Int>) {
             // Call mocked destroyLiveTcpSocketsByOwnerUids so that test can verify this method call
             destroySocketsWrapper.destroyLiveTcpSocketsByOwnerUids(ownerUids)
         }
 
         override fun makeL2capNetworkProvider(context: Context) = null
+
+        override fun makeQuicConnectionCloser(
+                networkForNetId: SparseArray<NetworkAgentInfo>,
+                handler: Handler
+        ): QuicConnectionCloser = quicConnectionCloser
+
+        override fun flagConnectivityServiceDestroySocket() = true
+
+        override fun destroyLiveTcpSocketsByLocalAddress(
+            address: InetAddress,
+            netIdRange: Set<Range<Int>>?,
+            uidRanges: Set<Range<Int>>?
+        ) {
+            // Call mocked destroyLiveTcpSocketsByLocalAddress so that test can verify this method
+            // call
+            destroySocketsWrapper.destroyLiveTcpSocketsByLocalAddress(
+                address,
+                netIdRange,
+                uidRanges
+            )
+        }
+
+        override fun destroyLiveTcpSocketsByLocalAddress(
+            address: InetAddress,
+            interfaceId: Int
+        ) {
+            // Call mocked destroyLiveTcpSocketsByLocalAddress so that test can verify this method
+            // call
+            destroySocketsWrapper.destroyLiveTcpSocketsByLocalAddress(
+                address,
+                interfaceId
+            )
+        }
+
+        override fun destroyLiveTcpSocketsLackingPermission(
+            netId: Int,
+            permission: Int
+        ) {
+            destroySocketsWrapper.destroyLiveTcpSocketsLackingPermission(
+                netId,
+                permission
+            )
+        }
+
+        var netlinkMessageUpdate = Consumer<NetlinkMessage> {_ -> }
+        override fun makeAddressUpdateMonitor(
+            h: Handler,
+            log: SharedLog,
+            tag: String,
+            consumer: Consumer<NetlinkMessage>
+        ): ConnectivityService.AddressUpdateMonitor {
+            netlinkMessageUpdate = consumer
+            return ConnectivityService.AddressUpdateMonitor(h, log, tag, consumer)
+        }
     }
 
     inner class PermDeps : PermissionMonitor.Dependencies() {
         override fun shouldEnforceLocalNetRestrictions(uid: Int) = false
+        override fun isFeatureNotChickenedOut(context: Context?, name: String?) = true
     }
 
     inner class CSContext(base: Context) : BroadcastInterceptingContext(base) {
@@ -585,4 +691,15 @@ open class CSTest {
                 .build()
         return Agent(nc = nc, lp = lp)
     }
+    fun Agent(interfaceName: String, transport: Int, vararg caps: Int) = Agent(
+        nc = nc(transport, *caps),
+        lp = defaultLp().apply { this.interfaceName = interfaceName },
+        score = keepScore()
+    )
+
+    // This allows keeping all the networks connected without having to file individual requests
+    // for them.
+    fun keepScore() = FromS(
+        NetworkScore.Builder().setKeepConnectedReason(KEEP_CONNECTED_FOR_TEST).build()
+    )
 }
diff --git a/tests/unit/java/com/android/server/connectivityservice/base/CSTestHelpers.kt b/tests/unit/java/com/android/server/connectivityservice/base/CSTestHelpers.kt
index f28f063bb8..69ff193594 100644
--- a/tests/unit/java/com/android/server/connectivityservice/base/CSTestHelpers.kt
+++ b/tests/unit/java/com/android/server/connectivityservice/base/CSTestHelpers.kt
@@ -78,11 +78,19 @@ internal fun emptyAgentConfig(legacyType: Int) = NetworkAgentConfig.Builder()
 
 internal fun defaultNc() = NetworkCapabilities.Builder()
         // Add sensible defaults for agents that don't want to care
+        .addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED)
         .addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_SUSPENDED)
         .addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_ROAMING)
         .addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VCN_MANAGED)
         .build()
 
+internal fun nc(transport: Int, vararg caps: Int) = defaultNc().apply {
+    addTransportType(transport)
+    caps.forEach {
+        addCapability(it)
+    }
+}
+
 internal fun defaultScore() = FromS(NetworkScore.Builder().build())
 
 internal fun keepConnectedScore() = FromS(NetworkScore.Builder()
@@ -215,11 +223,12 @@ internal fun makeConnectivityService(
         context: Context,
         netd: INetd,
         deps: Dependencies,
-        mPermDeps: PermissionMonitor.Dependencies
+        mPermDeps: PermissionMonitor.Dependencies,
+        resolver: IDnsResolver
 ) =
         ConnectivityService(
                 context,
-                mock<IDnsResolver>(),
+                resolver,
                 mock<IpConnectivityLog>(),
                 netd,
                 deps,
diff --git a/tests/unit/java/com/android/server/ethernet/EthernetNetworkFactoryTest.java b/tests/unit/java/com/android/server/ethernet/EthernetNetworkFactoryTest.java
index 70d4ad8ce4..74b02367c0 100644
--- a/tests/unit/java/com/android/server/ethernet/EthernetNetworkFactoryTest.java
+++ b/tests/unit/java/com/android/server/ethernet/EthernetNetworkFactoryTest.java
@@ -40,6 +40,7 @@ import android.net.EthernetNetworkSpecifier;
 import android.net.IpConfiguration;
 import android.net.LinkAddress;
 import android.net.LinkProperties;
+import android.net.MacAddress;
 import android.net.Network;
 import android.net.NetworkAgentConfig;
 import android.net.NetworkCapabilities;
@@ -75,10 +76,11 @@ import java.util.Objects;
 @DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 public class EthernetNetworkFactoryTest {
     private static final int TIMEOUT_MS = 2_000;
-    private static final String TEST_IFACE = "test123";
+    private static final String HW_ADDR = "01:02:03:04:05:06";
+    private static final EthernetPort TEST_IFACE =
+            new EthernetPort("test123", MacAddress.fromString(HW_ADDR), 42);
     private static final String IP_ADDR = "192.0.2.2/25";
     private static final LinkAddress LINK_ADDR = new LinkAddress(IP_ADDR);
-    private static final String HW_ADDR = "01:02:03:04:05:06";
     private TestLooper mLooper;
     private Handler mHandler;
     private EthernetNetworkFactory mNetFactory = null;
@@ -222,17 +224,17 @@ public class EthernetNetworkFactoryTest {
 
     // creates an interface with provisioning in progress (since updating the interface link state
     // automatically starts the provisioning process)
-    private void createInterfaceUndergoingProvisioning(String iface) {
+    private void createInterfaceUndergoingProvisioning(EthernetPort port) {
         // Default to the ethernet transport type.
-        createInterfaceUndergoingProvisioning(iface, NetworkCapabilities.TRANSPORT_ETHERNET);
+        createInterfaceUndergoingProvisioning(port, NetworkCapabilities.TRANSPORT_ETHERNET);
     }
 
     private void createInterfaceUndergoingProvisioning(
-            @NonNull final String iface, final int transportType) {
+            EthernetPort port, final int transportType) {
         final IpConfiguration ipConfig = createDefaultIpConfig();
-        mNetFactory.addInterface(iface, HW_ADDR, ipConfig,
+        mNetFactory.addInterface(port, ipConfig,
                 createInterfaceCapsBuilder(transportType).build());
-        assertTrue(mNetFactory.updateInterfaceLinkState(iface, true));
+        assertTrue(mNetFactory.updateInterfaceLinkState(port, true));
 
         ArgumentCaptor<NetworkOfferCallback> captor = ArgumentCaptor.forClass(
                 NetworkOfferCallback.class);
@@ -248,9 +250,9 @@ public class EthernetNetworkFactoryTest {
     }
 
     // creates a provisioned interface
-    private void createAndVerifyProvisionedInterface(String iface) throws Exception {
+    private void createAndVerifyProvisionedInterface(EthernetPort port) throws Exception {
         // Default to the ethernet transport type.
-        createAndVerifyProvisionedInterface(iface, NetworkCapabilities.TRANSPORT_ETHERNET,
+        createAndVerifyProvisionedInterface(port, NetworkCapabilities.TRANSPORT_ETHERNET,
                 ConnectivityManager.TYPE_ETHERNET);
     }
 
@@ -262,9 +264,9 @@ public class EthernetNetworkFactoryTest {
     }
 
     private void createAndVerifyProvisionedInterface(
-            @NonNull final String iface, final int transportType, final int expectedLegacyType)
+            EthernetPort port, final int transportType, final int expectedLegacyType)
             throws Exception {
-        createInterfaceUndergoingProvisioning(iface, transportType);
+        createInterfaceUndergoingProvisioning(port, transportType);
         triggerOnProvisioningSuccess();
         // provisioning succeeded, verify that the network agent is created, registered, marked
         // as connected and legacy type are correctly set.
@@ -272,26 +274,13 @@ public class EthernetNetworkFactoryTest {
                 NetworkCapabilities.class);
         verify(mDeps).makeEthernetNetworkAgent(any(), any(), ncCaptor.capture(), any(),
                 argThat(x -> x.getLegacyType() == expectedLegacyType), any(), any());
-        assertEquals(
-                new EthernetNetworkSpecifier(iface), ncCaptor.getValue().getNetworkSpecifier());
+        assertEquals(new EthernetNetworkSpecifier(port.getInterfaceName()),
+                ncCaptor.getValue().getNetworkSpecifier());
         verifyNetworkAgentRegistersAndConnects();
         clearInvocations(mDeps);
         clearInvocations(mNetworkAgent);
     }
 
-    // creates an unprovisioned interface
-    private void createUnprovisionedInterface(String iface) throws Exception {
-        // To create an unprovisioned interface, provision and then "stop" it, i.e. stop its
-        // NetworkAgent and IpClient. One way this can be done is by provisioning an interface and
-        // then calling onNetworkUnwanted.
-        mNetFactory.addInterface(iface, HW_ADDR, createDefaultIpConfig(),
-                createInterfaceCapsBuilder(NetworkCapabilities.TRANSPORT_ETHERNET).build());
-        assertTrue(mNetFactory.updateInterfaceLinkState(iface, true));
-
-        clearInvocations(mIpClient);
-        clearInvocations(mNetworkAgent);
-    }
-
     @Test
     public void testUpdateInterfaceLinkStateForActiveProvisioningInterface() throws Exception {
         initEthernetNetworkFactory();
@@ -318,7 +307,8 @@ public class EthernetNetworkFactoryTest {
     @Test
     public void testProvisioningLoss() throws Exception {
         initEthernetNetworkFactory();
-        when(mDeps.getNetworkInterfaceByName(TEST_IFACE)).thenReturn(mInterfaceParams);
+        when(mDeps.getNetworkInterfaceByName(TEST_IFACE.getInterfaceName()))
+                .thenReturn(mInterfaceParams);
         createAndVerifyProvisionedInterface(TEST_IFACE);
 
         triggerOnProvisioningFailure();
@@ -331,7 +321,7 @@ public class EthernetNetworkFactoryTest {
     public void testProvisioningLossForDisappearedInterface() throws Exception {
         initEthernetNetworkFactory();
         // mocked method returns null by default, but just to be explicit in the test:
-        when(mDeps.getNetworkInterfaceByName(eq(TEST_IFACE))).thenReturn(null);
+        when(mDeps.getNetworkInterfaceByName(eq(TEST_IFACE.getInterfaceName()))).thenReturn(null);
 
         createAndVerifyProvisionedInterface(TEST_IFACE);
         triggerOnProvisioningFailure();
@@ -362,7 +352,8 @@ public class EthernetNetworkFactoryTest {
     public void testNetworkUnwantedWithStaleNetworkAgent() throws Exception {
         initEthernetNetworkFactory();
         // ensures provisioning is restarted after provisioning loss
-        when(mDeps.getNetworkInterfaceByName(TEST_IFACE)).thenReturn(mInterfaceParams);
+        when(mDeps.getNetworkInterfaceByName(TEST_IFACE.getInterfaceName()))
+                .thenReturn(mInterfaceParams);
         createAndVerifyProvisionedInterface(TEST_IFACE);
 
         EthernetNetworkAgent.Callbacks oldCbs = mNetworkAgent.getCallbacks();
@@ -438,7 +429,8 @@ public class EthernetNetworkFactoryTest {
     @Test
     public void testIgnoreOnIpLayerStoppedCallbackForStaleCallback() throws Exception {
         initEthernetNetworkFactory();
-        when(mDeps.getNetworkInterfaceByName(TEST_IFACE)).thenReturn(mInterfaceParams);
+        when(mDeps.getNetworkInterfaceByName(TEST_IFACE.getInterfaceName()))
+                .thenReturn(mInterfaceParams);
         final IpClientCallbacks staleIpClientCallbacks = getStaleIpClientCallbacks();
 
         staleIpClientCallbacks.onProvisioningFailure(new LinkProperties());
@@ -500,7 +492,7 @@ public class EthernetNetworkFactoryTest {
         final NetworkCapabilities capabilities = createDefaultFilterCaps();
         final IpConfiguration ipConfiguration = createStaticIpConfig();
 
-        mNetFactory.updateInterface(TEST_IFACE, ipConfiguration, capabilities);
+        mNetFactory.updateInterface(TEST_IFACE.getInterfaceName(), ipConfiguration, capabilities);
         triggerOnProvisioningSuccess();
 
         verify(mDeps).makeEthernetNetworkAgent(any(), any(),
@@ -515,7 +507,7 @@ public class EthernetNetworkFactoryTest {
         final NetworkCapabilities capabilities = createDefaultFilterCaps();
         final IpConfiguration ipConfiguration = createStaticIpConfig();
 
-        mNetFactory.updateInterface(TEST_IFACE, ipConfiguration, capabilities);
+        mNetFactory.updateInterface(TEST_IFACE.getInterfaceName(), ipConfiguration, capabilities);
 
         verifyNoStopOrStart();
     }
@@ -526,7 +518,8 @@ public class EthernetNetworkFactoryTest {
         createAndVerifyProvisionedInterface(TEST_IFACE);
 
         final IpConfiguration initialIpConfig = createStaticIpConfig();
-        mNetFactory.updateInterface(TEST_IFACE, initialIpConfig, null /*capabilities*/);
+        mNetFactory.updateInterface(TEST_IFACE.getInterfaceName(), initialIpConfig,
+                null /*capabilities*/);
 
         triggerOnProvisioningSuccess();
         verifyRestart(initialIpConfig);
@@ -538,7 +531,8 @@ public class EthernetNetworkFactoryTest {
 
 
         // verify that sending a null ipConfig does not update the current ipConfig.
-        mNetFactory.updateInterface(TEST_IFACE, null /*ipConfig*/, null /*capabilities*/);
+        mNetFactory.updateInterface(TEST_IFACE.getInterfaceName(), null /*ipConfig*/,
+                null /*capabilities*/);
         triggerOnProvisioningSuccess();
         verifyRestart(initialIpConfig);
     }
@@ -560,7 +554,7 @@ public class EthernetNetworkFactoryTest {
         initEthernetNetworkFactory();
         createAndVerifyProvisionedInterface(TEST_IFACE);
 
-        final String result = mNetFactory.getHwAddress(TEST_IFACE);
+        final String result = mNetFactory.getHwAddress(TEST_IFACE.getInterfaceName());
         assertEquals(HW_ADDR, result);
     }
 
@@ -568,7 +562,7 @@ public class EthernetNetworkFactoryTest {
     public void testGetMacAddressForNonExistingInterface() {
         initEthernetNetworkFactory();
 
-        final String result = mNetFactory.getHwAddress(TEST_IFACE);
+        final String result = mNetFactory.getHwAddress(TEST_IFACE.getInterfaceName());
         // No interface exists due to not calling createAndVerifyProvisionedInterface(...).
         assertNull(result);
     }
diff --git a/tests/unit/java/com/android/server/ethernet/EthernetPortTest.java b/tests/unit/java/com/android/server/ethernet/EthernetPortTest.java
new file mode 100644
index 0000000000..594b4c13b5
--- /dev/null
+++ b/tests/unit/java/com/android/server/ethernet/EthernetPortTest.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ethernet;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertThrows;
+
+import android.net.MacAddress;
+import android.os.Build;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo;
+import com.android.testutils.DevSdkIgnoreRunner;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@SmallTest
+@RunWith(DevSdkIgnoreRunner.class)
+@IgnoreUpTo(Build.VERSION_CODES.S_V2)
+public class EthernetPortTest {
+    private final String mTestInterfaceName = "eth0";
+    private final MacAddress mTestMacAddress = MacAddress.fromString("0A:1B:2C:3D:4E:5F");
+    private final int mTestInterfaceIndex = 1;
+
+    @Test
+    public void testMakeEthernetPort() {
+        EthernetPort port = new EthernetPort(
+                mTestInterfaceName, mTestMacAddress, mTestInterfaceIndex);
+        assertEquals(mTestInterfaceName, port.getInterfaceName());
+        assertEquals(mTestMacAddress, port.getMacAddress());
+        assertEquals(mTestInterfaceIndex, port.getInterfaceIndex());
+    }
+
+    @Test
+    public void testMakeEthernetPortWithEmptyInterfaceName() {
+        assertThrows("Ethernet port should have valid interface name, MAC address and "
+                + "interface index.",
+                IllegalArgumentException.class,
+                () -> new EthernetPort("", mTestMacAddress, mTestInterfaceIndex));
+    }
+
+    @Test
+    public void testMakeEthernetPortWithNullInterfaceName() {
+        assertThrows("Ethernet port should have valid interface name, MAC address and "
+                + "interface index.",
+                IllegalArgumentException.class,
+                () -> new EthernetPort(null, mTestMacAddress, mTestInterfaceIndex));
+    }
+
+    @Test
+    public void testMakeEthernetPortWithNullMacAddress() {
+        assertThrows("Ethernet port should have valid interface name, MAC address and "
+                + "interface index.",
+                IllegalArgumentException.class,
+                () -> new EthernetPort(mTestInterfaceName, null, mTestInterfaceIndex));
+    }
+
+    @Test
+    public void testMakeEthernetPortWithInvalidInterfaceIndex() {
+        assertThrows("Ethernet port should have valid interface name, MAC address and "
+                + "interface index.",
+                IllegalArgumentException.class,
+                () -> new EthernetPort(mTestInterfaceName, mTestMacAddress, 0));
+    }
+
+    @Test
+    public void testHashCodeConsistency() {
+        EthernetPort port = new EthernetPort(
+                mTestInterfaceName, mTestMacAddress, mTestInterfaceIndex);
+        int hash1 = port.hashCode();
+        int hash2 = port.hashCode();
+        assertEquals(hash1, hash2);
+    }
+
+    @Test
+    public void testHashCodeOfDifferentConfig() {
+        EthernetPort port1 = new EthernetPort(
+                mTestInterfaceName, mTestMacAddress, mTestInterfaceIndex);
+        EthernetPort port2 = new EthernetPort(
+                "eth1", MacAddress.fromString("DE:AD:BE:EF:00:01"), 2);
+        int hash1 = port1.hashCode();
+        int hash2 = port2.hashCode();
+        assertNotEquals(hash1, hash2);
+    }
+
+    @Test
+    public void testHashCodeOfTheSameConfig() {
+        EthernetPort port1 = new EthernetPort(
+                mTestInterfaceName, mTestMacAddress, mTestInterfaceIndex);
+        EthernetPort port2 = new EthernetPort(
+                mTestInterfaceName, mTestMacAddress, mTestInterfaceIndex);
+        int hash1 = port1.hashCode();
+        int hash2 = port2.hashCode();
+        assertEquals(hash1, hash2);
+    }
+
+    @Test
+    public void testToString() {
+        EthernetPort port = new EthernetPort(
+                mTestInterfaceName, mTestMacAddress, mTestInterfaceIndex);
+        String expect = "EthernetPort(eth0, ifindex=1, MAC=0a:1b:2c:3d:4e:5f)";
+        assertEquals(expect, port.toString());
+    }
+}
diff --git a/tests/unit/java/com/android/server/ethernet/EthernetTrackerTest.java b/tests/unit/java/com/android/server/ethernet/EthernetTrackerTest.java
index 97ca8adcc5..7b6985e522 100644
--- a/tests/unit/java/com/android/server/ethernet/EthernetTrackerTest.java
+++ b/tests/unit/java/com/android/server/ethernet/EthernetTrackerTest.java
@@ -21,11 +21,10 @@ import static android.net.TestNetworkManager.TEST_TAP_PREFIX;
 import static com.android.server.ethernet.EthernetTracker.DEFAULT_CAPABILITIES;
 import static com.google.common.truth.Truth.assertThat;
 
-import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.ArgumentMatchers.eq;
@@ -36,8 +35,6 @@ import android.content.Context;
 import android.net.INetd;
 import android.net.InetAddresses;
 import android.net.IpConfiguration;
-import android.net.IpConfiguration.IpAssignment;
-import android.net.IpConfiguration.ProxySettings;
 import android.net.LinkAddress;
 import android.net.NetworkCapabilities;
 import android.net.StaticIpConfiguration;
@@ -81,9 +78,9 @@ public class EthernetTrackerTest {
     public void setUp() throws RemoteException {
         MockitoAnnotations.initMocks(this);
         initMockResources();
-        doReturn(false).when(mFactory).updateInterfaceLinkState(anyString(), anyBoolean());
+        doReturn(false).when(mFactory).updateInterfaceLinkState(any(), anyBoolean());
         doReturn(new String[0]).when(mNetd).interfaceGetList();
-        doReturn(new String[0]).when(mFactory).getAvailableInterfaces(anyBoolean());
+        doReturn(new String[0]).when(mFactory).getInterfacesSorted(anyBoolean());
         mHandlerThread = new HandlerThread(THREAD_NAME);
         mHandlerThread.start();
         tracker = new EthernetTracker(mContext, mHandlerThread.getThreadHandler(), mFactory, mNetd,
@@ -105,83 +102,72 @@ public class EthernetTrackerTest {
         HandlerUtils.waitForIdle(mHandlerThread, TIMEOUT_MS);
     }
 
-    /**
-     * Test: Creation of various valid static IP configurations
-     */
     @Test
-    public void createStaticIpConfiguration() {
-        // Empty gives default StaticIPConfiguration object
-        assertStaticConfiguration(new StaticIpConfiguration(), "");
-
-        // Setting only the IP address properly cascades and assumes defaults
-        assertStaticConfiguration(new StaticIpConfiguration.Builder()
-                .setIpAddress(new LinkAddress("192.0.2.10/24")).build(), "ip=192.0.2.10/24");
-
-        final ArrayList<InetAddress> dnsAddresses = new ArrayList<>();
-        dnsAddresses.add(InetAddresses.parseNumericAddress("4.4.4.4"));
-        dnsAddresses.add(InetAddresses.parseNumericAddress("8.8.8.8"));
-        // Setting other fields properly cascades them
-        assertStaticConfiguration(new StaticIpConfiguration.Builder()
+    public void testIpConfigurationParsing() {
+        EthernetConfigParser p = new EthernetConfigParser("eth0;*;;", true /*isAtLeastB*/);
+        assertThat(p.mIpConfig).isNull();
+
+        p = new EthernetConfigParser("eth0;*;ip=192.0.2.10/24", true /*isAtLeastB*/);
+        StaticIpConfiguration s = new StaticIpConfiguration.Builder()
+                .setIpAddress(new LinkAddress("192.0.2.10/24"))
+                .build();
+        assertThat(p.mIpConfig)
+                .isEqualTo(new IpConfiguration.Builder().setStaticIpConfiguration(s).build());
+
+        p = new EthernetConfigParser(
+                "eth0;*;ip=192.0.2.10/24 dns=4.4.4.4,8.8.8.8   gateway=192.0.2.1  domains=android ",
+                true /*isAtLeastB*/);
+        ArrayList<InetAddress> dns = new ArrayList<>();
+        dns.add(InetAddresses.parseNumericAddress("4.4.4.4"));
+        dns.add(InetAddresses.parseNumericAddress("8.8.8.8"));
+        s = new StaticIpConfiguration.Builder()
                 .setIpAddress(new LinkAddress("192.0.2.10/24"))
-                .setDnsServers(dnsAddresses)
+                .setDnsServers(dns)
                 .setGateway(InetAddresses.parseNumericAddress("192.0.2.1"))
-                .setDomains("android").build(),
-                "ip=192.0.2.10/24 dns=4.4.4.4,8.8.8.8 gateway=192.0.2.1 domains=android");
+                .setDomains("android")
+                .build();
+        assertThat(p.mIpConfig)
+                .isEqualTo(new IpConfiguration.Builder().setStaticIpConfiguration(s).build());
 
         // Verify order doesn't matter
-        assertStaticConfiguration(new StaticIpConfiguration.Builder()
-                .setIpAddress(new LinkAddress("192.0.2.10/24"))
-                .setDnsServers(dnsAddresses)
-                .setGateway(InetAddresses.parseNumericAddress("192.0.2.1"))
-                .setDomains("android").build(),
-                "domains=android ip=192.0.2.10/24 gateway=192.0.2.1 dns=4.4.4.4,8.8.8.8 ");
+        p = new EthernetConfigParser(
+                "eth0;; domains=android ip=192.0.2.10/24 gateway=192.0.2.1 dns=4.4.4.4,8.8.8.8   ;",
+                false /*isAtLeastB*/);
+        assertThat(p.mIpConfig)
+                .isEqualTo(new IpConfiguration.Builder().setStaticIpConfiguration(s).build());
     }
 
-    /**
-     * Test: Attempt creation of various bad static IP configurations
-     */
     @Test
-    public void createStaticIpConfiguration_Bad() {
-        assertStaticConfigurationFails("ip=192.0.2.1/24 gateway= blah=20.20.20.20");  // Unknown key
-        assertStaticConfigurationFails("ip=192.0.2.1");  // mask is missing
-        assertStaticConfigurationFails("ip=a.b.c");  // not a valid ip address
-        assertStaticConfigurationFails("dns=4.4.4.4,1.2.3.A");  // not valid ip address in dns
-        assertStaticConfigurationFails("=");  // Key and value is empty
-        assertStaticConfigurationFails("ip=");  // Value is empty
-        assertStaticConfigurationFails("ip=192.0.2.1/24 gateway=");  // Gateway is empty
+    public void testIpConfigurationParsing_withInvalidInputs() {
+        assertThrows(IllegalArgumentException.class, () -> { // unknown key
+            new EthernetConfigParser("eth0;;ip=192.0.2.1/24 blah=20.20.20.20", true /*isAtLeastB*/);
+        });
+
+        assertThrows(IllegalArgumentException.class, () -> { // mask missing
+            new EthernetConfigParser("eth0;;ip=192.0.2.1", true /*isAtLeastB*/);
+        });
+
+        assertThrows(IllegalArgumentException.class, () -> { // invalid ip address
+            new EthernetConfigParser("eth0;;ip=x.y.z", true /*isAtLeastB*/);
+        });
+
+        assertThrows(IllegalArgumentException.class, () -> { // invalid dns ip
+            new EthernetConfigParser("eth0;;dns=4.4.4.4,1.2.3.A", true /*isAtLeastB*/);
+        });
+
+        assertThrows(IllegalArgumentException.class, () -> { // empty key / value
+            new EthernetConfigParser("eth0;;=", true /*isAtLeastB*/);
+        });
+
+        assertThrows(IllegalArgumentException.class, () -> { // empty value
+            new EthernetConfigParser("eth0;;ip=", true /*isAtLeastB*/);
+        });
+
+        assertThrows(IllegalArgumentException.class, () -> { // empty gateway
+            new EthernetConfigParser("eth0;;ip=192.0.2.1/24 gateway=", true /*isAtLeastB*/);
+        });
     }
 
-    private void assertStaticConfigurationFails(String config) {
-        try {
-            EthernetTracker.parseStaticIpConfiguration(config);
-            fail("Expected to fail: " + config);
-        } catch (IllegalArgumentException e) {
-            // expected
-        }
-    }
-
-    private void assertStaticConfiguration(StaticIpConfiguration expectedStaticIpConfig,
-                String configAsString) {
-        final IpConfiguration expectedIpConfiguration = new IpConfiguration();
-        expectedIpConfiguration.setIpAssignment(IpAssignment.STATIC);
-        expectedIpConfiguration.setProxySettings(ProxySettings.NONE);
-        expectedIpConfiguration.setStaticIpConfiguration(expectedStaticIpConfig);
-
-        assertEquals(expectedIpConfiguration,
-                EthernetTracker.parseStaticIpConfiguration(configAsString));
-    }
-
-    private NetworkCapabilities.Builder makeEthernetCapabilitiesBuilder(boolean clearDefaults) {
-        final NetworkCapabilities.Builder builder =
-                clearDefaults
-                        ? NetworkCapabilities.Builder.withoutDefaultCapabilities()
-                        : new NetworkCapabilities.Builder();
-        return builder.addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_ROAMING)
-                .addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_CONGESTED)
-                .addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_SUSPENDED);
-    }
-
-
     @Test
     public void testNetworkCapabilityParsing() {
         final NetworkCapabilities baseNc = NetworkCapabilities.Builder.withoutDefaultCapabilities()
@@ -253,16 +239,6 @@ public class EthernetTrackerTest {
         assertThat(p.mIface).isEqualTo("eth0");
     }
 
-    @Test
-    public void testIpConfigParsing() {
-        // Note that EthernetConfigParser doesn't actually parse the IpConfig (yet).
-        final EthernetConfigParser p = new EthernetConfigParser(
-                "eth0;1,2,3;ip=192.168.0.10/24 gateway=192.168.0.1 dns=4.4.4.4,8.8.8.8;1",
-                false /*isAtLeastB*/);
-        assertThat(p.mIpConfig)
-                .isEqualTo("ip=192.168.0.10/24 gateway=192.168.0.1 dns=4.4.4.4,8.8.8.8");
-    }
-
     @Test
     public void testCreateEthernetConfigParserThrowsNpeWithNullInput() {
         assertThrows(NullPointerException.class, () -> new EthernetConfigParser(null, false));
@@ -284,37 +260,4 @@ public class EthernetTrackerTest {
         verify(mFactory).updateInterface(
                 eq(TEST_IFACE), eq(ipConfig), eq(capabilities));
     }
-
-    @Test
-    public void testIsValidTestInterfaceIsFalseWhenTestInterfacesAreNotIncluded() {
-        final String validIfaceName = TEST_TAP_PREFIX + "123";
-        tracker.setIncludeTestInterfaces(false);
-        waitForIdle();
-
-        final boolean isValidTestInterface = tracker.isValidTestInterface(validIfaceName);
-
-        assertFalse(isValidTestInterface);
-    }
-
-    @Test
-    public void testIsValidTestInterfaceIsFalseWhenTestInterfaceNameIsInvalid() {
-        final String invalidIfaceName = "123" + TEST_TAP_PREFIX;
-        tracker.setIncludeTestInterfaces(true);
-        waitForIdle();
-
-        final boolean isValidTestInterface = tracker.isValidTestInterface(invalidIfaceName);
-
-        assertFalse(isValidTestInterface);
-    }
-
-    @Test
-    public void testIsValidTestInterfaceIsTrueWhenTestInterfacesIncludedAndValidName() {
-        final String validIfaceName = TEST_TAP_PREFIX + "123";
-        tracker.setIncludeTestInterfaces(true);
-        waitForIdle();
-
-        final boolean isValidTestInterface = tracker.isValidTestInterface(validIfaceName);
-
-        assertTrue(isValidTestInterface);
-    }
 }
diff --git a/tests/unit/java/com/android/server/net/L2capPacketForwarderTest.kt b/tests/unit/java/com/android/server/net/L2capPacketForwarderTest.kt
index e261732b53..8076bad9a3 100644
--- a/tests/unit/java/com/android/server/net/L2capPacketForwarderTest.kt
+++ b/tests/unit/java/com/android/server/net/L2capPacketForwarderTest.kt
@@ -24,6 +24,7 @@ import android.os.ParcelFileDescriptor
 import android.system.Os
 import android.system.OsConstants.AF_UNIX
 import android.system.OsConstants.SHUT_RD
+import android.system.OsConstants.SHUT_RDWR
 import android.system.OsConstants.SHUT_WR
 import android.system.OsConstants.SOCK_SEQPACKET
 import android.system.OsConstants.SOL_SOCKET
@@ -31,7 +32,7 @@ import android.system.OsConstants.SO_RCVTIMEO
 import android.system.OsConstants.SO_SNDTIMEO
 import android.system.StructTimeval
 import com.android.server.net.L2capPacketForwarder.BluetoothSocketWrapper
-import com.android.server.net.L2capPacketForwarder.FdWrapper
+import com.android.server.net.L2capPacketForwarder.TunWrapper
 import com.android.testutils.ConnectivityModuleTest
 import com.android.testutils.DevSdkIgnoreRule
 import com.android.testutils.DevSdkIgnoreRunner
@@ -180,9 +181,19 @@ class L2capPacketForwarderTest {
             }
         }).`when`(bluetoothSocket).close()
 
+        // TunWrapper does not shutdown fd as tun is not a connected socket, i.e. closing interrupts
+        // blocking operations.
+        val parcelFd = ParcelFileDescriptor(tunFds[0])
+        val tunWrapper = object : TunWrapper(parcelFd) {
+            override fun close() {
+                Os.shutdown(parcelFd.fileDescriptor, SHUT_RDWR)
+                parcelFd.close()
+            }
+        }
+
         forwarder = L2capPacketForwarder(
                 handler,
-                FdWrapper(ParcelFileDescriptor(tunFds[0])),
+                tunWrapper,
                 BluetoothSocketWrapper(bluetoothSocket),
                 false /* compressHeaders */,
                 callback
diff --git a/tests/unit/java/com/android/server/net/NetworkStatsFactoryTest.java b/tests/unit/java/com/android/server/net/NetworkStatsFactoryTest.java
index 89acf69c4f..5099d19914 100644
--- a/tests/unit/java/com/android/server/net/NetworkStatsFactoryTest.java
+++ b/tests/unit/java/com/android/server/net/NetworkStatsFactoryTest.java
@@ -33,7 +33,6 @@ import static android.net.NetworkStats.UID_ALL;
 import static com.android.server.net.NetworkStatsFactory.CONFIG_PER_UID_TAG_THROTTLING;
 import static com.android.server.net.NetworkStatsFactory.CONFIG_PER_UID_TAG_THROTTLING_THRESHOLD;
 import static com.android.server.net.NetworkStatsFactory.kernelToTag;
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
@@ -48,6 +47,7 @@ import android.content.Context;
 import android.net.NetworkStats;
 import android.net.TrafficStats;
 import android.net.UnderlyingNetworkInfo;
+import android.os.Build;
 import android.os.SystemClock;
 
 import androidx.test.InstrumentationRegistry;
@@ -80,7 +80,7 @@ import java.util.HashMap;
 /** Tests for {@link NetworkStatsFactory}. */
 @RunWith(DevSdkIgnoreRunner.class)
 @SmallTest
-@DevSdkIgnoreRule.IgnoreUpTo(SC_V2)
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 public class NetworkStatsFactoryTest extends NetworkStatsBaseTest {
     private static final String CLAT_PREFIX = "v4-";
     private static final int TEST_TAGS_PER_UID_THRESHOLD = 10;
diff --git a/tests/unit/java/com/android/server/net/NetworkStatsObserversTest.java b/tests/unit/java/com/android/server/net/NetworkStatsObserversTest.java
index a534c22410..617c4ec9d0 100644
--- a/tests/unit/java/com/android/server/net/NetworkStatsObserversTest.java
+++ b/tests/unit/java/com/android/server/net/NetworkStatsObserversTest.java
@@ -17,6 +17,7 @@
 package com.android.server.net;
 
 import static android.net.ConnectivityManager.TYPE_MOBILE;
+import static android.net.NetworkCapabilities.TRANSPORT_CELLULAR;
 import static android.net.NetworkIdentity.OEM_NONE;
 import static android.net.NetworkStats.DEFAULT_NETWORK_NO;
 import static android.net.NetworkStats.DEFAULT_NETWORK_YES;
@@ -30,8 +31,6 @@ import static android.net.NetworkTemplate.MATCH_WIFI;
 import static android.net.TrafficStats.MB_IN_BYTES;
 import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
 
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.assertTrue;
@@ -45,6 +44,7 @@ import android.net.NetworkIdentitySet;
 import android.net.NetworkStats;
 import android.net.NetworkStatsAccess;
 import android.net.NetworkTemplate;
+import android.os.Build;
 import android.os.HandlerThread;
 import android.os.IBinder;
 import android.os.Looper;
@@ -55,6 +55,7 @@ import android.util.ArrayMap;
 
 import androidx.test.filters.SmallTest;
 
+import com.android.net.module.util.BitUtils;
 import com.android.testutils.DevSdkIgnoreRule;
 import com.android.testutils.DevSdkIgnoreRunner;
 import com.android.testutils.HandlerUtils;
@@ -76,7 +77,7 @@ import java.util.Set;
  */
 @RunWith(DevSdkIgnoreRunner.class)
 @SmallTest
-@DevSdkIgnoreRule.IgnoreUpTo(SC_V2) // TODO: Use to Build.VERSION_CODES.SC_V2 when available
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 public class NetworkStatsObserversTest {
     private static final String TEST_IFACE = "test0";
     private static final String TEST_IFACE2 = "test1";
@@ -301,7 +302,8 @@ public class NetworkStatsObserversTest {
         identSet.add(new NetworkIdentity(
                 TYPE_MOBILE, TelephonyManager.NETWORK_TYPE_UNKNOWN,
                 IMSI_1, null /* networkId */, false /* roaming */, true /* metered */,
-                true /* defaultNetwork */, OEM_NONE, SUBID_1));
+                true /* defaultNetwork */, OEM_NONE, SUBID_1,
+                BitUtils.packBits(new int[] { TRANSPORT_CELLULAR })));
         return identSet;
     }
 
diff --git a/tests/unit/java/com/android/server/net/NetworkStatsServiceTest.java b/tests/unit/java/com/android/server/net/NetworkStatsServiceTest.java
index 66af56ba56..955701e8ec 100644
--- a/tests/unit/java/com/android/server/net/NetworkStatsServiceTest.java
+++ b/tests/unit/java/com/android/server/net/NetworkStatsServiceTest.java
@@ -27,6 +27,8 @@ import static android.content.pm.PackageManager.PERMISSION_GRANTED;
 import static android.net.ConnectivityManager.TYPE_MOBILE;
 import static android.net.ConnectivityManager.TYPE_TEST;
 import static android.net.ConnectivityManager.TYPE_WIFI;
+import static android.net.NetworkCapabilities.TRANSPORT_CELLULAR;
+import static android.net.NetworkCapabilities.TRANSPORT_SATELLITE;
 import static android.net.NetworkIdentity.OEM_PAID;
 import static android.net.NetworkIdentity.OEM_PRIVATE;
 import static android.net.NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK;
@@ -79,7 +81,6 @@ import static com.android.server.net.NetworkStatsService.NETSTATS_IMPORT_FALLBAC
 import static com.android.server.net.NetworkStatsService.NETSTATS_IMPORT_SUCCESSES_COUNTER_NAME;
 import static com.android.server.net.NetworkStatsService.TRAFFICSTATS_CLIENT_RATE_LIMIT_CACHE_ENABLED_FLAG;
 import static com.android.server.net.NetworkStatsService.TRAFFICSTATS_SERVICE_RATE_LIMIT_CACHE_ENABLED_FLAG;
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -224,7 +225,7 @@ import java.util.function.Consumer;
 @RunWith(DevSdkIgnoreRunner.class)
 @SmallTest
 // NetworkStatsService is not updatable before T, so tests do not need to be backwards compatible
-@DevSdkIgnoreRule.IgnoreUpTo(SC_V2)
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 public class NetworkStatsServiceTest extends NetworkStatsBaseTest {
     @Rule
     public final DevSdkIgnoreRule ignoreRule = new DevSdkIgnoreRule();
@@ -604,7 +605,7 @@ public class NetworkStatsServiceTest extends NetworkStatsBaseTest {
 
         @Override
         public boolean isDebuggable() {
-            return mIsDebuggable == Boolean.TRUE;
+            return Objects.equals(mIsDebuggable, Boolean.TRUE);
         }
 
         @Override
@@ -1139,7 +1140,7 @@ public class NetworkStatsServiceTest extends NetworkStatsBaseTest {
         // Pretend that 5g mobile network comes online
         final NetworkStateSnapshot[] mobileStates =
                 new NetworkStateSnapshot[] {buildMobileState(IMSI_1), buildStateOfTransport(
-                        NetworkCapabilities.TRANSPORT_CELLULAR, TYPE_MOBILE,
+                        TRANSPORT_CELLULAR, TYPE_MOBILE,
                         TEST_IFACE2, IMSI_1, null /* wifiNetworkKey */,
                         true /* isTemporarilyNotMetered */, false /* isRoaming */)};
         setMobileRatTypeAndWaitForIdle(TelephonyManager.NETWORK_TYPE_NR);
@@ -1414,7 +1415,7 @@ public class NetworkStatsServiceTest extends NetworkStatsBaseTest {
         mockNetworkStatsUidDetail(buildEmptyStats());
 
         final NetworkStateSnapshot mobileState = buildStateOfTransport(
-                NetworkCapabilities.TRANSPORT_CELLULAR, TYPE_MOBILE,
+                TRANSPORT_CELLULAR, TYPE_MOBILE,
                 TEST_IFACE2, IMSI_1, null /* wifiNetworkKey */,
                 false /* isTemporarilyNotMetered */, false /* isRoaming */);
 
@@ -1473,7 +1474,7 @@ public class NetworkStatsServiceTest extends NetworkStatsBaseTest {
         final String[] mobileIfaces = {TEST_IFACE2};
         mockNetworkStatsUidDetail(buildEmptyStats(), emptyTetherStats, mobileIfaces);
         final NetworkStats mobileStats = mService.getUidStatsForTransport(
-                NetworkCapabilities.TRANSPORT_CELLULAR);
+                TRANSPORT_CELLULAR);
 
         assertEquals(2, mobileStats.size());
         // Verify the operation count stats that caused by incrementOperationCount only appears
@@ -1492,7 +1493,7 @@ public class NetworkStatsServiceTest extends NetworkStatsBaseTest {
         mockNetworkStatsUidDetail(buildEmptyStats());
 
         final NetworkStateSnapshot mobileState = buildStateOfTransport(
-                NetworkCapabilities.TRANSPORT_CELLULAR, TYPE_MOBILE,
+                TRANSPORT_CELLULAR, TYPE_MOBILE,
                 TEST_IFACE2, IMSI_1, null /* wifiNetworkKey */,
                 false /* isTemporarilyNotMetered */, false /* isRoaming */);
 
@@ -1523,7 +1524,7 @@ public class NetworkStatsServiceTest extends NetworkStatsBaseTest {
         // with getUidStatsForTransport(TRANSPORT_CELLULAR) return stats of both cellular
         // and satellite
         final NetworkStats mobileStats = mService.getUidStatsForTransport(
-                NetworkCapabilities.TRANSPORT_CELLULAR);
+                TRANSPORT_CELLULAR);
 
         // The iface field of the returned stats should be null because getUidStatsForTransport
         // clears the interface field before it returns the result.
@@ -1532,10 +1533,82 @@ public class NetworkStatsServiceTest extends NetworkStatsBaseTest {
 
         // getUidStatsForTransport(TRANSPORT_SATELLITE) is not supported
         assertThrows(IllegalArgumentException.class,
-                () -> mService.getUidStatsForTransport(NetworkCapabilities.TRANSPORT_SATELLITE));
+                () -> mService.getUidStatsForTransport(TRANSPORT_SATELLITE));
 
     }
 
+    // This test demonstrates that a network identity with legacy type TYPE_MOBILE
+    // can represent different underlying physical transports (e.g., satellite or cellular).
+    // NetworkTemplate, using MATCH_MOBILE, can then differentiate these further
+    // by applying a transportTypes filter.
+    @Test
+    public void testGetSatelliteStats() throws Exception {
+        mockDefaultSettings();
+        final NetworkTemplate templateSatellite =
+                new NetworkTemplate.Builder()
+                        .setMeteredness(METERED_YES)
+                        .setSubscriberIds(Set.of(IMSI_1))
+                        .setTransportType(TRANSPORT_SATELLITE)
+                        .build();
+
+        final NetworkTemplate templateCellularOnly =
+                new NetworkTemplate.Builder()
+                        .setMeteredness(METERED_YES)
+                        .setSubscriberIds(Set.of(IMSI_1))
+                        .setTransportType(TRANSPORT_CELLULAR)
+                        .build();
+
+        // Initial state: Assert all relevant templates are empty
+        assertUidTotal(sTemplateImsi1, UID_RED, 0L, 0L, 0L, 0L, 0);
+        assertUidTotal(templateSatellite, UID_RED, 0L, 0L, 0L, 0L, 0);
+        assertUidTotal(templateCellularOnly, UID_RED, 0L, 0L, 0L, 0L, 0);
+
+        // 1. Bring up SATELLITE mobile network for IMSI_1
+        NetworkStateSnapshot satelliteState = buildSatelliteMobileState(IMSI_1);
+
+        mService.notifyNetworkStatus(NETWORKS_MOBILE, new NetworkStateSnapshot[]{satelliteState},
+                getActiveIface(satelliteState), new UnderlyingNetworkInfo[0]);
+        setMobileRatTypeAndWaitForIdle(TelephonyManager.NETWORK_TYPE_LTE);
+
+        // Record 100 bytes of data on the satellite network for UID_RED
+        incrementCurrentTime(HOUR_IN_MILLIS);
+        mockNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1)
+                .insertEntry(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, METERED_YES, ROAMING_NO,
+                        DEFAULT_NETWORK_YES, 100L, 10L, 100L, 10L, 0L));
+        forcePollAndWaitForIdle();
+
+        // Verify data attribution for SATELLITE
+        // sTemplateImsi1 (general mobile) should count satellite data.
+        assertUidTotal(sTemplateImsi1, UID_RED, 100L, 10L, 100L, 10L, 0);
+        // sTemplateMobileSatelliteImsi1 (satellite specific) should count satellite data.
+        assertUidTotal(templateSatellite, UID_RED, 100L, 10L, 100L, 10L, 0);
+        // templateCellularOnly (cellular specific) should NOT count satellite data.
+        assertUidTotal(templateCellularOnly, UID_RED, 0L, 0L, 0L, 0L, 0);
+
+        // 2. Switch to CELLULAR mobile network for IMSI_1 on the same interface
+        NetworkStateSnapshot cellularState = buildMobileState(IMSI_1);
+
+        mService.notifyNetworkStatus(NETWORKS_MOBILE, new NetworkStateSnapshot[]{cellularState},
+                getActiveIface(cellularState), new UnderlyingNetworkInfo[0]);
+        // Mocking UID details to reflect total traffic on the interface since boot/last poll.
+        // Previous satellite data (100B) + new cellular data (200B) = 300B total on iface.
+        incrementCurrentTime(HOUR_IN_MILLIS);
+        mockNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1)
+                .insertEntry(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, METERED_YES, ROAMING_NO,
+                        DEFAULT_NETWORK_YES, 300L, 30L, 300L, 30L, 0L)); // 100sat + 200cell
+        forcePollAndWaitForIdle();
+
+        // Verify data attribution after CELLULAR usage
+        // sTemplateImsi1 (general mobile) should count cumulative data (satellite + cellular).
+        // (100 previous + 200 new = 300 total)
+        assertUidTotal(sTemplateImsi1, UID_RED, 300L, 30L, 300L, 30L, 0);
+        // sTemplateMobileSatelliteImsi1 should still only have the satellite data.
+        assertUidTotal(templateSatellite, UID_RED, 100L, 10L, 100L, 10L, 0);
+        // templateCellularOnly should now have the new cellular data (200B).
+        // (Current total on iface 300B - previous total on iface before this poll 100B = 200B)
+        assertUidTotal(templateCellularOnly, UID_RED, 200L, 20L, 200L, 20L, 0);
+    }
+
     @Test
     public void testForegroundBackground() throws Exception {
         // pretend that network comes online
@@ -1641,7 +1714,7 @@ public class NetworkStatsServiceTest extends NetworkStatsBaseTest {
         mockDefaultSettings();
         NetworkStateSnapshot[] states =
             new NetworkStateSnapshot[] {buildStateOfTransport(
-                    NetworkCapabilities.TRANSPORT_CELLULAR, TYPE_MOBILE,
+                    TRANSPORT_CELLULAR, TYPE_MOBILE,
                     TEST_IFACE,  IMSI_1, null /* wifiNetworkKey */,
                     false /* isTemporarilyNotMetered */, true /* isRoaming */)};
         mockNetworkStatsSummary(buildEmptyStats());
@@ -2821,13 +2894,13 @@ public class NetworkStatsServiceTest extends NetworkStatsBaseTest {
     }
 
     private static NetworkStateSnapshot buildMobileState(String subscriberId) {
-        return buildStateOfTransport(NetworkCapabilities.TRANSPORT_CELLULAR, TYPE_MOBILE,
+        return buildStateOfTransport(TRANSPORT_CELLULAR, TYPE_MOBILE,
                 TEST_IFACE, subscriberId, null /* wifiNetworkKey */,
                 false /* isTemporarilyNotMetered */, false /* isRoaming */);
     }
 
     private static NetworkStateSnapshot buildSatelliteMobileState(String subscriberId) {
-        return buildStateOfTransport(NetworkCapabilities.TRANSPORT_SATELLITE, TYPE_MOBILE,
+        return buildStateOfTransport(TRANSPORT_SATELLITE, TYPE_MOBILE,
                 TEST_IFACE, subscriberId, null /* wifiNetworkKey */,
                 false /* isTemporarilyNotMetered */, false /* isRoaming */);
     }
@@ -2871,7 +2944,7 @@ public class NetworkStatsServiceTest extends NetworkStatsBaseTest {
         for (int nc : oemNetCapabilities) {
             capabilities.setCapability(nc, true);
         }
-        capabilities.addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR);
+        capabilities.addTransportType(TRANSPORT_CELLULAR);
         return new NetworkStateSnapshot(MOBILE_NETWORK, capabilities, prop, subscriberId,
                 TYPE_MOBILE);
     }
@@ -2884,7 +2957,7 @@ public class NetworkStatsServiceTest extends NetworkStatsBaseTest {
         capabilities.setCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED, true);
         capabilities.setCapability(NetworkCapabilities.NET_CAPABILITY_NOT_ROAMING, true);
         capabilities.setCapability(NetworkCapabilities.NET_CAPABILITY_IMS, true);
-        capabilities.addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR);
+        capabilities.addTransportType(TRANSPORT_CELLULAR);
         capabilities.setNetworkSpecifier(new TelephonyNetworkSpecifier(subId));
         return new NetworkStateSnapshot(
                 MOBILE_NETWORK, capabilities, prop, subscriberId, TYPE_MOBILE);
diff --git a/tests/unit/java/com/android/server/net/NetworkStatsSubscriptionsMonitorTest.java b/tests/unit/java/com/android/server/net/NetworkStatsSubscriptionsMonitorTest.java
index 622f2be4be..9c432ae3fe 100644
--- a/tests/unit/java/com/android/server/net/NetworkStatsSubscriptionsMonitorTest.java
+++ b/tests/unit/java/com/android/server/net/NetworkStatsSubscriptionsMonitorTest.java
@@ -19,8 +19,6 @@ package com.android.server.net;
 import static android.telephony.TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_NONE;
 import static android.telephony.TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_NR_NSA;
 
-import static com.android.testutils.DevSdkIgnoreRuleKt.SC_V2;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.fail;
@@ -39,6 +37,7 @@ import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.app.usage.NetworkStatsManager;
 import android.content.Context;
+import android.os.Build;
 import android.os.Looper;
 import android.os.Parcel;
 import android.telephony.SubscriptionManager;
@@ -64,7 +63,7 @@ import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 
 @RunWith(DevSdkIgnoreRunner.class)
-@DevSdkIgnoreRule.IgnoreUpTo(SC_V2)
+@DevSdkIgnoreRule.IgnoreUpTo(Build.VERSION_CODES.S_V2)
 public final class NetworkStatsSubscriptionsMonitorTest {
     private static final int TEST_SUBID1 = 3;
     private static final int TEST_SUBID2 = 5;
diff --git a/tests/unit/java/com/android/server/net/PersistentIntTest.kt b/tests/unit/java/com/android/server/net/PersistentIntTest.kt
index 92683525ed..5f07e5b6df 100644
--- a/tests/unit/java/com/android/server/net/PersistentIntTest.kt
+++ b/tests/unit/java/com/android/server/net/PersistentIntTest.kt
@@ -16,10 +16,10 @@
 
 package com.android.server.net
 
+import android.os.Build
 import android.util.SystemConfigFileCommitEventLogger
 import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo
 import com.android.testutils.DevSdkIgnoreRunner
-import com.android.testutils.SC_V2
 import com.android.testutils.assertThrows
 import org.junit.After
 import org.junit.Before
@@ -37,7 +37,7 @@ import java.util.Random
 import kotlin.test.assertEquals
 
 @RunWith(DevSdkIgnoreRunner::class)
-@IgnoreUpTo(SC_V2)
+@IgnoreUpTo(Build.VERSION_CODES.S_V2)
 class PersistentIntTest {
     val tempFilesCreated = mutableSetOf<Path>()
     lateinit var tempDir: Path
diff --git a/thread/tests/unit/src/com/android/server/thread/ThreadNetworkControllerServiceTest.java b/thread/tests/unit/src/com/android/server/thread/ThreadNetworkControllerServiceTest.java
index a73390c670..51f20e15d6 100644
--- a/thread/tests/unit/src/com/android/server/thread/ThreadNetworkControllerServiceTest.java
+++ b/thread/tests/unit/src/com/android/server/thread/ThreadNetworkControllerServiceTest.java
@@ -652,6 +652,43 @@ public final class ThreadNetworkControllerServiceTest {
         assertThat(failure.getErrorCode()).isEqualTo(ERROR_FAILED_PRECONDITION);
     }
 
+    @Test
+    public void setEnabled_success_threadNetworkEnabled() throws Exception {
+        mService.initialize();
+
+        CompletableFuture<Void> setEnabledFuture = new CompletableFuture<>();
+        mService.setEnabled(true, newOperationReceiver(setEnabledFuture));
+        mTestLooper.dispatchAll();
+
+        assertThat(mFakeOtDaemon.getEnabledState()).isEqualTo(STATE_ENABLED);
+    }
+
+    @Test
+    public void setDisabled_success_threadNetworkDisabled() throws Exception {
+        mService.initialize();
+
+        CompletableFuture<Void> setEnabledFuture = new CompletableFuture<>();
+        mService.setEnabled(false, newOperationReceiver(setEnabledFuture));
+        mTestLooper.dispatchAll();
+
+        assertThat(mFakeOtDaemon.getEnabledState()).isEqualTo(STATE_DISABLED);
+    }
+
+    @Test
+    public void setEnabled_otDaemonRemoteFailure_returnsInternalError() throws Exception {
+        mService.initialize();
+        CompletableFuture<Void> setEnabledFuture = new CompletableFuture<>();
+        mFakeOtDaemon.setSetEnabledException(
+                new RemoteException("ot-daemon setThreadEnabled() throws"));
+
+        mService.setEnabled(true, newOperationReceiver(setEnabledFuture));
+        mTestLooper.dispatchAll();
+
+        var thrown = assertThrows(ExecutionException.class, () -> setEnabledFuture.get());
+        ThreadNetworkException failure = (ThreadNetworkException) thrown.getCause();
+        assertThat(failure.getErrorCode()).isEqualTo(ERROR_INTERNAL_ERROR);
+    }
+
     private AtomicReference<BroadcastReceiver> captureBroadcastReceiver(String action) {
         AtomicReference<BroadcastReceiver> receiverRef = new AtomicReference<>();
 
diff --git a/thread/tests/utils/src/android/net/thread/utils/TapTestNetworkTracker.java b/thread/tests/utils/src/android/net/thread/utils/TapTestNetworkTracker.java
index 62c278534d..c117975fc7 100644
--- a/thread/tests/utils/src/android/net/thread/utils/TapTestNetworkTracker.java
+++ b/thread/tests/utils/src/android/net/thread/utils/TapTestNetworkTracker.java
@@ -17,7 +17,7 @@ package android.net.thread.utils;
 
 import static android.Manifest.permission.MANAGE_TEST_NETWORKS;
 
-import static com.android.testutils.RecorderCallback.CallbackEntry.LINK_PROPERTIES_CHANGED;
+import static com.android.testutils.TestableNetworkCallback.Event.LINK_PROPERTIES_CHANGED;
 import static com.android.testutils.TestPermissionUtil.runAsShell;
 
 import android.content.Context;
```

