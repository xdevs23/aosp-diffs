```diff
diff --git a/OWNERS b/OWNERS
index d80db9d..ee742aa 100644
--- a/OWNERS
+++ b/OWNERS
@@ -1,9 +1,20 @@
 # Bug component: 20868
 # Owners for Telephony
+breadley@google.com
+fionaxu@google.com
+jackyu@google.com
+rgreenwalt@google.com
+tgunn@google.com
+huiwang@google.com
+jayachandranc@google.com
+amruthr@google.com
+sasindran@google.com
+schie@google.com
+hyeinyu@google.com
+joonhunshin@google.com
 seheele@google.com
 vithalangarkar@google.com
 mkoon@google.com
-schie@google.com
 younsung@google.com
 hwangoo@google.com
 sewookseo@google.com
diff --git a/TEST_MAPPING b/TEST_MAPPING
index 60b77c8..e664771 100644
--- a/TEST_MAPPING
+++ b/TEST_MAPPING
@@ -1,8 +1,10 @@
 {
   "presubmit": [
     {
-      "name": "QualifiedNetworksServiceTests",
-      "keywords": ["internal"]
+      "name": "CtsTelephonyModuleTests"
+    },
+    {
+      "name": "TelephonyModuleTests"
     }
   ]
 }
diff --git a/apex/Android.bp b/apex/Android.bp
index 5749621..65a549d 100644
--- a/apex/Android.bp
+++ b/apex/Android.bp
@@ -18,25 +18,76 @@ package {
 }
 
 apex_key {
-    name: "com.android.telephonymodules.key",
-    public_key: "com.android.telephonymodules.avbpubkey",
-    private_key: "com.android.telephonymodules.pem",
+    name: "com.android.telephony2.key",
+    public_key: "com.android.telephony2.avbpubkey",
+    private_key: "com.android.telephony2.pem",
 }
 
 android_app_certificate {
-    name: "com.android.telephonymodules.certificate",
-    certificate: "com.android.telephonymodules",
+    name: "com.android.telephony2.certificate",
+    certificate: "com.android.telephony2",
 }
 
 apex {
-    name: "com.android.telephonymodules",
+    // This apex will be enabled using release_telephony_module flag
+    enabled: select(release_flag("RELEASE_TELEPHONY_MODULE"), {
+        true: true,
+        false: false,
+    }),
+
+    name: "com.android.telephony2",
     manifest: "manifest.json",
-    file_contexts: ":com.android.telephonymodules-file_contexts",
-    key: "com.android.telephonymodules.key",
-    certificate: ":com.android.telephonymodules.certificate",
-    updatable: false,
-    system_ext_specific: true,
-    apps: [
-        "QualifiedNetworksService",
+    file_contexts: ":com.android.telephony2-file_contexts",
+    key: "com.android.telephony2.key",
+    certificate: ":com.android.telephony2.certificate",
+    defaults: ["b-launched-apex-module"],
+    bootclasspath_fragments: ["com.android.telephony-bootclasspath-fragment"],
+}
+
+// Encapsulate the contributions made by the com.android.telephony2 to the bootclasspath.
+bootclasspath_fragment {
+    // This fragment will be enabled using release_telephony_module flag
+    enabled: select(release_flag("RELEASE_TELEPHONY_MODULE"), {
+        true: true,
+        false: false,
+    }),
+
+    name: "com.android.telephony-bootclasspath-fragment",
+    contents: ["framework-telephony"],
+    apex_available: ["com.android.telephony2"],
+    hidden_api: {
+        split_packages: ["*"], // TODO(b/409547011) be more specific
+    },
+
+    // The bootclasspath_fragments that provide APIs on which this depends.
+    fragments: [
+
+        // Needed to access core java APIs.
+        {
+            apex: "com.android.art",
+            module: "art-bootclasspath-fragment",
+        },
+    ],
+
+    // Additional stubs libraries that this fragment's contents use which are
+    // not provided by another bootclasspath_fragment.
+    additional_stubs: [
+        // Needed to access platform APIs.
+        "android-non-updatable",
+    ],
+}
+
+sdk {
+    // This sdk will be enabled using release_telephony_module flag
+    enabled: select(release_flag("RELEASE_TELEPHONY_MODULE"), {
+        true: true,
+        false: false,
+    }),
+
+    name: "telephony-module-sdk",
+    apexes: [
+        // Adds exportable dependencies of the APEX to the sdk,
+        // e.g. *classpath_fragments.
+        "com.android.telephony2",
     ],
 }
diff --git a/apex/com.android.telephony2.avbpubkey b/apex/com.android.telephony2.avbpubkey
new file mode 100644
index 0000000..0af5097
Binary files /dev/null and b/apex/com.android.telephony2.avbpubkey differ
diff --git a/apex/com.android.telephony2.pem b/apex/com.android.telephony2.pem
new file mode 100644
index 0000000..cc35665
--- /dev/null
+++ b/apex/com.android.telephony2.pem
@@ -0,0 +1,52 @@
+-----BEGIN PRIVATE KEY-----
+MIIJQwIBADANBgkqhkiG9w0BAQEFAASCCS0wggkpAgEAAoICAQCyscZ1dWzXulZe
+1DQq9x2JtZ15K8mOxLNgcIPaOenCUKYQUhGHlKx0ng6IXXKDk8+D66rWBHbNDf1n
+yF1ktoVbCUHSdSKtklYTTqgqdY5AK1sjj1FasvgkSUxkATAcxM+YA1cBuF4TIpGi
+11QvdQ/R74B0Ea8hF5UNEVirx9ikN3nPESYYunniRfG5SLKDKgmLdFuy2nFQiSgu
+u9WgMxA0iPEUBOcL6cM8JTrU78RuoXouctXISGnuNoy+U1jmvQnydhxG2kcVPwUX
+tPBoMsnCnAx4qOLXPK0oYL4Vf8HMVGZovZdiPsomWAtEmKgwc7Wk6v4ZEi/aos0R
+9HI/nYe+7Q8wnMEl9X4D1LQrbhNNVnA8n5eZCb72OW+kwP0Zuvk7mTU6wRi/lko7
+S/WxXZBsX3sAfkf0xH8achdqCwqbxCos7pgJIZBsWPCxVnuDpDlZn1elDKi88pWw
+/g2C9h4T6R9pdB0luyuaLwB7kLie+HAGFUmnJe8MA3FUy1XP32T73uQEX06T9Iga
+UwSB8V+f8T2A11xsRMWJmuWEbx0ZN7fsMR/wQr0oivKNkShUgaMBug0cNQDrq71s
+hkzk65ys9jnuHZ+1pwalF7QNy4wDPPOlOGgiieWIK7892pLUUoBsDxkcOeQxFDBa
+Jzo/15b4Uw1TGzvAULf/CPtwPRV3gQIDAQABAoICABEUtjQ3F8LdQHFLFnt+6Jdn
+wVg6S8d2XPEcgDYFcCdPXzhTJ/LOTtfM3fXB/Pa/08e36LoRbiu2qSDZAbhlTAUC
+MwUDhl+SC+FHlQKN/x16J3mUMwIY9mg9i2xJwsgVNgTBWPlEntV0afhnXdg1d+Ao
+5R3zLMrcfrZjkJbHARndZarZ6ErX1FvBNNRxswKfq47lffhwMgGxQqKI+OgZyXRE
+HMs9lrpIS429v0xoaN3sWIoFFxNQfLO1CioNPIO90SwYhyZsqfvJbNqxxIMpS6jr
+ErQb7KcHWUPxT2otrqAx9yIO8WAGQXt90gHqF7Wd8eCER+qslt9uzWxocd1L2RRJ
+hYA9FHcakOJFD9tvfKK0VekpkwR1stQiZ/JAHpQBfqKzADGYhpWa7R3catCiPClx
+jGmsFo7yr7Myq4LnP08wF1e7+VjzxXfrTnMRmA6NilcJCz2DkX0hhcKiy1c1HhPX
++JeXOBIWkKEr16cu3NY2SsrdOsPc/suUPVY8olfAX9ZajRMWdWhDkTHRV5V7pE/4
+bEShgmEf+yKB6+LwNeYNiVadtA0xiZhtQsG2DT5KY72DO141CiZ93XrYPA5Z4x1w
+QgaCL8GBi/+dymEUhxeVr9B652mZL8foA62M1q60mshka6UFswMe+DtFlF7E0utY
+TTe92Th+Ryw7Gk+XdB9LAoIBAQDlp3Hx7YCPhjr2XL2jVZjBSu/gSjAbmpjVUg9J
+DLrKFNuH7b1dX1iQURv14In5L8cBbeb/npVcw7dcxZfIRAbJek2KQl6SqQshzfix
+CiHZrfxMLjCHb7cC6tl+31/WjbJkCOyfULSPfQirJ7y+aHNa827gKk68frSYYinC
+bbShI+XzDkSIeLYoVckGZlNCe1c2nqajVBeW6pt2AvAEXFBOYeNqs8kEuluuZ9MV
++OFk5wKOLVyvOqMNz4PfDOSt5ER6M8JhqrJ36u8hQrQKAKsQiw7By41T/BY62RNW
+sP9IT4CiI6MXUdZZ1GXfjV+78UYIzBKK15h3f6FkyYhdXxxzAoIBAQDHMbsWmbEV
+oKA69REDj6m2sPojjsr0/uC44xlwoY6l60tC9IzJaO77PKksVObIPW7tJYHs/Ps8
+D7zO4UFSZeCLBYh/5RXtOVO9MwLbDYrWF9siElK2V7RuG9PbiVkmFzzXZJlSbppg
+rNepSU66SJt1O/n1FNbWkBc3sfSfvKFqSGlfXSFNI+4lD0KLotPkVNJ/Efen3VCO
+tI7tBtU5qQLMtuYj39ORLiOlBOAqrsrDPQMdstw2tMrFnFAYREnM/r6IBP7LVP81
+LTHFu00sYRsMVV/RUPtuSlUo6/yaOdVlV2TzTTvIR1VQZtr4wkENgA19/NeUIcbQ
+bWiPwrlbxTM7AoIBAQDOjfFVWHl2HZPwu+8w9i8DQ2RHBlMIsN7flwP6fwGN+n6N
+Xo4gaj5c5ybP2loejxNdvLy0kqzil4HXZj0jOdQk6OTPAuzO2k4R5JDWozdY8zzm
+Q/EQD7G6ZQKkM0Ke1ilqAgDZNhyApkPitUX0uDtwxVynMEZLEWdbW4cVwdhhysjq
++J05ZeDonGfHYsdmF0uU69MTOfJRocebt/6q3WC5bx+9e+DEaN1HG0jnDUekmoZY
+3IHtdT7skAWa25zerl3Mz7r4XzBP3TWhY75M9NbndTsboPoHXMedvFrBcUbage8/
+ZfAtbETv3LKYBC7j+pk0FmBjEpCmglvmK8GDwaTzAoIBAGqYa1Tx1DkNpxFF2d/8
+/kYcuQ9UN7oZtypZpWCHpC2YF8Nx2PFjbRgXYzStDn8zmOvhOYEX9F400cYn9uvg
+RuQ+hshiUHSNTAmghbOxsI1XYNX/1jFsB8swqxP9kS54Gv/s/ruFIqn/dL1L1IyN
+lFuNR/rmNv3FSBdu7Miaigq1S2ZUESEVzDgazXKqJRg4aBjGBbDYF2b2qtGe6XYc
+wrnIWqnx+mbjuQFy9X8B4NHQEZ3P/FZuM2DCgH4r9Q51eIKTocIv7w6G6+6zh93q
+7S2RdmAuJQ7lSmNGvfvOXSsJNKWavBY2TipjkGS0l1lhIFc+eiL0XE9nbSAZhVXd
+1scCggEBAMDYwsPxXW4pgnMrCZfyZ0a07sVzdi2Ejp1/8AB5tWW1WL3ermNjgH5c
+6Wec2Wfio99V7J0FjLuKRitZhrxLd5J8D5HMdNd7LSHOVWmev1YeraEkyv23TkkA
+WwNUeXSm76ygn5o11d8PnrmSv2Jh8cwviR8eJlEgBSdhs6zA71uzRYPugtuir3KJ
+zOsS13PAk3HGMkCoOTHEOBZSmGv1cVKB+e11v/4O9vfa2b7PG2/lAOfYNwgA/jHB
+grwOXTfU6hR6UosVCdPS6Eyx6YtK8bb2BDgHqYrpLllK0dxpjTv57YYu6gaFdQyN
+KDkcZIz9rMvkNOZsU+P1FpZMBxbFzRg=
+-----END PRIVATE KEY-----
diff --git a/apex/com.android.telephony2.pk8 b/apex/com.android.telephony2.pk8
new file mode 100644
index 0000000..1d5345c
Binary files /dev/null and b/apex/com.android.telephony2.pk8 differ
diff --git a/apex/com.android.telephony2.x509.pem b/apex/com.android.telephony2.x509.pem
new file mode 100644
index 0000000..99fad0b
--- /dev/null
+++ b/apex/com.android.telephony2.x509.pem
@@ -0,0 +1,34 @@
+-----BEGIN CERTIFICATE-----
+MIIF+TCCA+GgAwIBAgIUI60mPrIdm/t+h+kWmgyjrTOIxGwwDQYJKoZIhvcNAQEL
+BQAwgaMxCzAJBgNVBAYTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRYwFAYDVQQH
+DA1Nb3VudGFpbiBWaWV3MRAwDgYDVQQKDAdBbmRyb2lkMRAwDgYDVQQLDAdBbmRy
+b2lkMSIwIAYJKoZIhvcNAQkBFhNhbmRyb2lkQGFuZHJvaWQuY29tMR8wHQYDVQQD
+DBZjb20uYW5kcm9pZC50ZWxlcGhvbnkyMCAXDTI1MDUxNDAwMDE0NloYDzQ3NjMw
+NDEwMDAwMTQ2WjCBozELMAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWEx
+FjAUBgNVBAcMDU1vdW50YWluIFZpZXcxEDAOBgNVBAoMB0FuZHJvaWQxEDAOBgNV
+BAsMB0FuZHJvaWQxIjAgBgkqhkiG9w0BCQEWE2FuZHJvaWRAYW5kcm9pZC5jb20x
+HzAdBgNVBAMMFmNvbS5hbmRyb2lkLnRlbGVwaG9ueTIwggIiMA0GCSqGSIb3DQEB
+AQUAA4ICDwAwggIKAoICAQDRv42h9xGW9/Sdoz9T1KlVMhSzOC+hSX8oIBG3ZOnZ
+i4iIHLG/m+sox8Ctl5cpF2pFE2e2HZxdprsly7nPDgzxThGQ/n1u5BFdY6fDtTuq
+SOehNd2KR+23GXLVQGy8jmXiXDgZRdy9SaJphDrLE5e+MF+ujl2wspvie6XgmLL9
+uwprJleZ2x39Peb3bEI4NsIkeyV2AEYvG3MOpOPRttwjrFQdRsJaCyiJ81RpYlai
+F0Ph62+316kMMDhBf5WTT7ZNHBQNIX/8bpl82F5t1hz5L9Qxi6eSMNTBtblHcvv7
+LMTVbB5CcdR2Zd2gt25ksueXM/N2BEuVPwo3KfDmiTQDCZAWw7DacnusGGM1vIFO
+C+M/XrNw7eEtg7pVaXzS2GPCpYhCaXrB6bdvCWH4khm7OSv2IV0mwJWMo8kMnj1O
+6wgfrWt41OrhiBwPJPz9/TM2AOGw/uscmAyM3VOKEd088il3sp3OSeQUsXF4Y8qh
+FPZnqby45Hd1WH7dZne1LpZj4a4cGUApt9fDLCUJgLAcmJvqqkoW5vDMgpBvMfVm
+WkG6Ir+/ydIIZ12RODGkpAw3V2EKCkPo+UHoY9DcqSfmXK+ggol7UGAqrL15me3u
+Ov4xceIjJMrqpeD5kcEayncx4+Ci1lThCoAmYm1XEzmgU3K/uXW7vWMHCH+5xHYG
+ewIDAQABoyEwHzAdBgNVHQ4EFgQUhTpxzxpGPeMk/yBZEE64duX52YgwDQYJKoZI
+hvcNAQELBQADggIBAHBa3odqHKXJf9NQrILZM5F1/Uu5nHB+zirovl7bXQ9Fzz3l
+hH3eikdgKXSaQS54dgJagurGsXT2hDM8h6LA7Qn7BKTjWzMqM9ZYr5h/BVN2lhRw
+Nwd1HwEu1FF3TAAQ/eAjyf0i9Hmo0WXyrNnOHJXpQpVdwy2xts2QLeC6KExe5XK2
+WIZ7vKilyIpanx9Y6S/AgegdoZykHD2RagzlYUvVSNN1jDi9vOVQqoVyB4ntOuCH
+odXXYVoZXi2Oui8zvNt+mj0dqY3hLB7LgJ9aLtL18DrgPa+SoF5+vfZLjO8pfIAt
+KNifYNGEwuNMHHBkgxs+NW03WZfzOsdSJB7y1drHo6iXVsA07GIZ6k/OdsyVgpsI
+l/Qepo73SUr0dCdXKGai2mjfXeFwgh+Bs/167ZQbMgt6caapG+LRHCLJyJIIg5Pr
+9pqVLOyDu5HxV1a4idRLlmY1d2Ic1eimpzCQ0+hra1drYsitTFMvI5IRr9Ok9pI0
+DLRX9ctzGpATi+0SJ5PHYuxlkQFZuVKu9z71iYjSB7xM8v7iLJPZIOosfiFJOqzz
+XnTKqoRROAvm8xFlbQDVAyvO41UmGW8tYr8sTh0uiMdTGPjPEzWxEEBimXsFsljJ
+W9Xi+CQLOJZOwl3ogOe3naDWSWRu+XlIS5WzCbPpxFj+rqvr1bf0YEQitVuB
+-----END CERTIFICATE-----
diff --git a/apex/com.android.telephonymodules.avbpubkey b/apex/com.android.telephonymodules.avbpubkey
deleted file mode 100644
index a297634..0000000
Binary files a/apex/com.android.telephonymodules.avbpubkey and /dev/null differ
diff --git a/apex/com.android.telephonymodules.pem b/apex/com.android.telephonymodules.pem
deleted file mode 100644
index 10e1429..0000000
--- a/apex/com.android.telephonymodules.pem
+++ /dev/null
@@ -1,52 +0,0 @@
------BEGIN PRIVATE KEY-----
-MIIJQwIBADANBgkqhkiG9w0BAQEFAASCCS0wggkpAgEAAoICAQCmmxsmwBp6Nzbi
-cLD8z4XRW1gxTlN2uQGIoZdUDkqDEG9iuJl86x6g1feO/VSE9UxMJ0bC8Qczv8LB
-x3qFaGbmc4Qe0Jd0PkZLoCJaLnowM2nCD/fFGcr8vIkPaDZ0QjanB+llvLjhSQjh
-KAYBjdauKGPNyevEgL8zaz84RuDfqdfwVfuXRHU7DjN/g2Oq6dK3Azo4rBcf8U4O
-Mkpfb7h7NZ0lwOMsEqoBbcxyr/+/FDiuiOEEvqGnHZSDixRFFdDYosrapIwvvy5t
-MrM8CW4J3oYU6Wlekf7GM7astJvailMG5SoEFcR29ZF9BvwLTDueDT1leD8XTgdy
-BdsLTcvQgvR2NNsxJGaj/H96PLxHs9G1Q2yQndB6vcBQZvjyB6j1KwDZdBD8MRZP
-9LLJVzl+jfC6Gi5xoTUyyf0JAcuGr7/k0HnQfDrrAijqFGNr3odhCDjM2A8aY9BA
-afydWLRjPx/AJbnGxl7W7P4L+xjZmZivtm81B7PiUIQfrzDbwZJoBCKOIvnsZcdJ
-IMA80svraOPQbOUgdtnzRu3sOFgFdXAnBqHXRmSJZF2hQzLIPhQzTtBbShtj4Sef
-V4R8oAry4N6eFQ0NAyJCZfCpmgqthRgXO0WsRWbQhAt1tgMp+0SFOpqxeGYHbuo7
-OPbVqgL+sKefq8ogvO9NxL0h7GhjSQIDAQABAoICAAE4ybsP5VnQWhkQx8GA4Zu6
-kmPhLcxE+NGIUthpVutNZW25ShngDQxTqWI9ch9b/6xezN5s31dGMJ7UcE32aSvH
-PNivga7W7pPLJ7lW1itQkzXawV/LC8Gs/cnUwzJ40lcJADGQb+AqFZQ2I44jHMgP
-8IRvtsiNA6n0P0VRwsAtKhHfhY3zUPNHDEJjA6n7F0IjlkuYWn6P2dlRjdlTk8wm
-hWGjn57g/6ltRVaxevwLIUvJYfITllKoDUDmNha4HV0bW4a9NnB6s9PV73nRHWMZ
-5EyWtiC9DBvmwPAVDoAMq+V07IkVYkiXjjK3KIXKMDU9Zl3+QuMwPa58w8GaV1Rr
-+y2/08wbQsjEWxkUFzk5K38v6/wiTFkuqUxAsw7I5BGI+v7LaDCwYlM3kiSkLUvp
-APxQyYIhaEWzsDNOTzsYf7YXwDyf71T8cAkgtdVwBSOCLC5QmDClmbOEtiHjt5rK
-eFD4z1TeD9p/R4V7e1ywl91ZIeHz4QyA9GT0J6+ukq3tT6tYWmOJxKirRM+uUriY
-BXCt9DsaeASOaFNwWGGmmikZmN4E667EQLZLE3nfwZXzvLpIphfBrEJ1gf8l5H4S
-XClytOPPD0PBIP3JldkKL2rwIeSTonVO1OPkwVICDakx73snvAYouvxEWoMmAueu
-AW0HpR5fVXe4B+XSm9ghAoIBAQDYF6+8u9mBU85/jcSG3bLolAaQ0NjKp+oc72cn
-7NxDLzYF8PU9H8+A0uvyfeIzaGpgvHWDLPAMFOyL/Bp14DVfl9hMmE5u/9lmdk3e
-4c+MPCIqg4hwylpaFYlJK14u2C0Ciiuz0qhLZIhDp5ypxuHFHxT63PjrGqDHlcNx
-RFcMvrw9V4siESHNoiSa5aPG1qsY9pPltX4ddDsS4OS8B7Juu3BSPCpYZ3y5qXmY
-ysKdvTytwAghlTTlk8rchPkxOgyiPF5uHEAszkmWcb4ZAICiRIKb/sAWnMVMYX6X
-sp0ojFgufT/9xool6Uav1x4RI4faWYS3pi4F2byMMRfy5x0pAoIBAQDFX9CnGmJT
-TWjSThdZbcK5adWfrKqOykxP3YpfCjquHcXG1dIGFJxNt6bpDBwInl10TO6ffR9a
-/KmZvH2fJCktGuJByomd7pxIqTAEyk3EtEsmlC8EhyKOCb/DdWEQ9l+cEchPYsv6
-XFkcPqjXS548tdLthDUuX+0tGuJw2X8s4Lh/kVY3cmdOeCJ/Vu3uYdIgXtkdLAIe
-NbO3NaiEmUxPcfWeYGuYMUgXLIHLa3Gx8C+mOlNbdP1fTkAQfmX/OEAjvoOiO7HE
-HM9BN3UmjVZ7HhWgodN3iuPY8sAczXJ1SMnbwC7Zza+eBBX6XF7VXZkbW95UAMjc
-ll8WQ0dKk7khAoIBABA4Humkk9vAJZSvWFvjEgWg7qk587uqRMktMuntPk8QoRZr
-Eo0m8RUzP6Bw0GSZZrqiCpPw8IeHnoWXQ4krbfYh2ItPNzvfmjq1kHy1KDXXYZ0d
-SEVm+sceLLLAPY54jVBOfJ8/pYAbKJsjXn/jvJhmD9YQdeJ3mi/Azu2Weo4rVsen
-5XqGHKppjCPQLq3C+Q6jm1A3giLF0ZVGKgTu8vaavQB/IZKHGfZ5gPX16gua444L
-BtE2eMTuheBtXqLSP5aBv3i2SB7U0PMo0GLiBcWoLMF2qoZH+AsWmkDamC8t8YRz
-xDTRDRdxXeve0pPovc6mv25lW7j2sc839Bs4O5kCggEBAIAaeCp9DWRT0bztwmng
-u4nsDyLbxrd2xaDwgWa+FOf9mug6z13y8p/emw6XNXrCjpV1eUs6wqcjZlDJ7h7k
-MXV9BWz+L+O5guYGKYxyYZdSDZS0iO+/ZcYavcP241FHFzcMs54S2aFdXtjeMmfK
-RKHSwVw3euzmheHImT/1an2OPTFO+05ximt7vag4m6UlCGTKKtCsR5Oj90jqIr4t
-YUIPDQQGQM8+7TNdR8Dns5tx8PtKz9+ERw8ckqgh4cGMmNSaSoV5iR9oM3x4qiij
-g4XVOORRJBdqpgehRt9q2OcWny1pxv7GaT1+GWWtnj+NyFnhfqO2/qdtUbn5YMQe
-rQECggEBAJ5M5Dcxf0mO67PpHQna7ij1nvqEffGjafrK2sArD24CBN3DcQjXXVem
-NwLqhJp8aF+1CSnZUdht2f99LK7J1JJUVLhBS7DqO+vXY7Z1H/piMhzcgMHrMRfz
-FDjqkz6o7U3t8DcDvvnIBrb2SAaEe9P8NVoGvnRGY8qEBWUBWWp7a8EI6bwqCyEK
-AJCbfmnW0CYODkimLZrxSX/cw73V+rkIppGokwlCOzECaQv5rMoN5rJFAsr8bKUi
-KP2jekPneG4IICleAWw1aKFO+6SmzuqhPsnIaD92P6z44RP08C4E+apU3uDi7LI/
-QMfxc0Ti2vHgsAxG/eXHuTPh4uVPMr4=
------END PRIVATE KEY-----
diff --git a/apex/com.android.telephonymodules.pk8 b/apex/com.android.telephonymodules.pk8
deleted file mode 100644
index a069bce..0000000
Binary files a/apex/com.android.telephonymodules.pk8 and /dev/null differ
diff --git a/apex/com.android.telephonymodules.x509.pem b/apex/com.android.telephonymodules.x509.pem
deleted file mode 100644
index 0ede0c3..0000000
--- a/apex/com.android.telephonymodules.x509.pem
+++ /dev/null
@@ -1,34 +0,0 @@
------BEGIN CERTIFICATE-----
-MIIF3TCCA8UCFHa+mCrq+7E64OyHEE/OrgFeOvw+MA0GCSqGSIb3DQEBCwUAMIGp
-MQswCQYDVQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91
-bnRhaW4gVmlldzEQMA4GA1UECgwHQW5kcm9pZDEQMA4GA1UECwwHQW5kcm9pZDEi
-MCAGCSqGSIb3DQEJARYTYW5kcm9pZEBhbmRyb2lkLmNvbTElMCMGA1UEAwwcY29t
-LmFuZHJvaWQudGVsZXBob255bW9kdWxlczAgFw0yMjExMTQwNDExNTJaGA80NzYw
-MTAxMDA0MTE1MlowgakxCzAJBgNVBAYTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlh
-MRYwFAYDVQQHDA1Nb3VudGFpbiBWaWV3MRAwDgYDVQQKDAdBbmRyb2lkMRAwDgYD
-VQQLDAdBbmRyb2lkMSIwIAYJKoZIhvcNAQkBFhNhbmRyb2lkQGFuZHJvaWQuY29t
-MSUwIwYDVQQDDBxjb20uYW5kcm9pZC50ZWxlcGhvbnltb2R1bGVzMIICIjANBgkq
-hkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAqdi9XrMZHp108lwRFtnRHr9DQSEF/stM
-wA0ITS2hvDaxNneupwBd1n1YDe7bjTE/tPHapDJfqciIHQHbgNcQ4UTM9I4g9Gf0
-GGfD6WuBD+xQfqSwjWHhEvTAFDskWEBisYuzbh+81/AjBVz3vbN6kTWz87w+Os2i
-fDH0VU6IbohMFkyND9/kzEImZzHQo8EzdMO6aqp9T2TpWz5ZdgPa4lu1OB+6s0WA
-L3FEUJRYCjOKd1uUIdyEu5a65ul15tQntkVcTS7tA9EgC+VDlQ1P7+HvZKNhNL3C
-9YhFTTRc5VMiaENfh1a+MkJoG2HNZK06RuuMklZ+/7/KmRto8FHEt2+VvFenAxtZ
-XcL3T8jm+zn2Q0oY1zn9TA2ceJ4UHma+5Qr9vXXN+ARFGyZfwFck6L/XDtHiZeYH
-Hw4ECt2y4dXMPOsgJT/PdFzTc6z/eXNR8w22+4tU7rMjHjZYoysmhzqVU31Pb113
-kCrgyveDN88T0rDSnlBqfwoU0lXHUQzzgldvwI0MBwemPoqi6NobCSZPqeAACjQz
-YHCvoztx5n4AEsy3iQOy5oFLFh2W0QYqGxB0zcUkc6+mjQBSd4JC6gDUWYYyAkT2
-9HvyQ5yVEKV5tvuUHesIo8ss5GvAUTvH9ihUg4KeTO7mKpOP+LSr7YRRLUPpH6IQ
-O2S75AJByKcCAwEAATANBgkqhkiG9w0BAQsFAAOCAgEABycVuF7h5mOIGk8Dote7
-OI58d9ohlLydshNcgXR0PXUK0CD83KQByS2H2pwho6XT5cG17yKgYamnR1W8hL5h
-BjkC8e3ztx5qtHujQr9OT87GCtQ4n+HXSKe0KORmMj0mawtuotpyVgaEXSFrqqk5
-2ApdQDHmOP+TIM42Z4Oi/WNyEtBWishFvh0CCQcUJNliKnL6CcJQXn9veaJ5Tb99
-RgV4Qp5u+coB//RRdQHKEuU/oiSMHbQJpTo/qSImBP2KjAYwvRk+KfMguFNtcN1g
-snCd1pi7jRSDYZnMEbsp6+ulSCrlvL3NWXo5fI8Uv79X1l1ilOdggx6mLf39ieUd
-dY4zwcnepjxMUvfHUA/vtDFYorOxEHoV7AhqbHkESjOvYIwYqEhiFJ65ugMbOzhA
-kk+KqV1NDWAAc221X8uDxpi5b0odmszY2s5zT5HXhHjmh4OBglujq+/PsK4uvZ6y
-3DF5cGd78TyhrP4Q8sa/NrEofGlly7AITusY/b9WaF8BPpWglAjiPp4Ew9jwd2z/
-SjD9qmxp/FORrpMjkkyeujmPzhpgT1hHjk4T0uIng3bR0dUhE5q8s4SDrIixGnno
-McBdqmxR88e+mC34zR6D7sNNfSztYB7qutoreRF4EXFQUOQeLaJJKoI3iVvmxdSL
-sMwH7OEAqFLlGLTY9wmK5Eo=
------END CERTIFICATE-----
diff --git a/apex/manifest.json b/apex/manifest.json
index 220c940..c35fe7d 100644
--- a/apex/manifest.json
+++ b/apex/manifest.json
@@ -1,4 +1,7 @@
 {
-  "name": "com.android.telephonymodules",
-  "version": 0
+    "name": "com.android.telephony2",
+
+    // Placeholder module version to be replaced during build.
+    // Do not change!
+    "version": 0
 }
diff --git a/framework/Android.bp b/framework/Android.bp
new file mode 100644
index 0000000..e54b123
--- /dev/null
+++ b/framework/Android.bp
@@ -0,0 +1,37 @@
+// Copyright (C) 2025 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package {
+    default_team: "trendy_team_fwk_telephony",
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+filegroup {
+    name: "framework-telephony-module-sources",
+    srcs: ["java/**/*.java"],
+    visibility: [
+        "//visibility:private",
+    ],
+}
+
+java_sdk_library {
+    name: "framework-telephony",
+    srcs: [":framework-telephony-module-sources"],
+    defaults: ["framework-module-defaults"],
+    permitted_packages: ["android.telephony"],
+    apex_available: [
+        "com.android.telephony2",
+    ],
+    min_sdk_version: "36",
+}
diff --git a/framework/api/current.txt b/framework/api/current.txt
new file mode 100644
index 0000000..d802177
--- /dev/null
+++ b/framework/api/current.txt
@@ -0,0 +1 @@
+// Signature format: 2.0
diff --git a/framework/api/module-lib-current.txt b/framework/api/module-lib-current.txt
new file mode 100644
index 0000000..d802177
--- /dev/null
+++ b/framework/api/module-lib-current.txt
@@ -0,0 +1 @@
+// Signature format: 2.0
diff --git a/framework/api/module-lib-removed.txt b/framework/api/module-lib-removed.txt
new file mode 100644
index 0000000..d802177
--- /dev/null
+++ b/framework/api/module-lib-removed.txt
@@ -0,0 +1 @@
+// Signature format: 2.0
diff --git a/framework/api/removed.txt b/framework/api/removed.txt
new file mode 100644
index 0000000..d802177
--- /dev/null
+++ b/framework/api/removed.txt
@@ -0,0 +1 @@
+// Signature format: 2.0
diff --git a/framework/api/system-current.txt b/framework/api/system-current.txt
new file mode 100644
index 0000000..d802177
--- /dev/null
+++ b/framework/api/system-current.txt
@@ -0,0 +1 @@
+// Signature format: 2.0
diff --git a/framework/api/system-removed.txt b/framework/api/system-removed.txt
new file mode 100644
index 0000000..d802177
--- /dev/null
+++ b/framework/api/system-removed.txt
@@ -0,0 +1 @@
+// Signature format: 2.0
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/IThresholdListener.java b/framework/java/android/telephony/PhoneNumberManager.java
similarity index 54%
rename from services/QualifiedNetworksService/src/com/android/telephony/qns/IThresholdListener.java
rename to framework/java/android/telephony/PhoneNumberManager.java
index 0b1f5d6..6300d61 100644
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/IThresholdListener.java
+++ b/framework/java/android/telephony/PhoneNumberManager.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2021 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,22 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-package com.android.telephony.qns;
+package android.telephony;
 
 /**
- * interface for Wi-Fi or Cellular ThresholdListener
+ * PhoneNumberManager.
+ *
+ * @hide
  */
-public interface IThresholdListener {
-    /**
-     * Called when the Wi-Fi threshold changes.
-     * @param thresholds
-     */
-    void onWifiThresholdChanged(Threshold[] thresholds);
-
-    /**
-     * Called when the cellular threshold chages.
-     * @param thresholds
-     */
-    void onCellularThresholdChanged(Threshold[] thresholds);
+public class PhoneNumberManager {
+    /** @hide **/
+    public void dummy() {}
 }
diff --git a/libs/TelephonyStatsLib/Android.bp b/libs/TelephonyStatsLib/Android.bp
index 10a1159..173dfbe 100644
--- a/libs/TelephonyStatsLib/Android.bp
+++ b/libs/TelephonyStatsLib/Android.bp
@@ -24,7 +24,7 @@ java_library {
     ],
     apex_available: [
         "//apex_available:platform",
-        "com.android.telephonymodules",
+        "com.android.telephony2",
     ],
 }
 
diff --git a/services/QualifiedNetworksService/Android.bp b/services/QualifiedNetworksService/Android.bp
deleted file mode 100644
index 0e78894..0000000
--- a/services/QualifiedNetworksService/Android.bp
+++ /dev/null
@@ -1,114 +0,0 @@
-// Copyright (C) 2021 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package {
-    default_team: "trendy_team_fwk_telephony",
-    default_applicable_licenses: ["Android-Apache-2.0"],
-}
-
-genrule {
-    name: "statslog-qns-java-gen",
-    tools: ["stats-log-api-gen"],
-    cmd: "$(location stats-log-api-gen) --java $(out) --module qns --javaPackage com.android.telephony.qns.stats --javaClass QnsStatsLog --worksource",
-    out: ["com/android/telephony/qns/stats/QnsStatsLog.java"],
-}
-
-android_app {
-    name: "QualifiedNetworksService",
-    system_ext_specific: true,
-    platform_apis: true,
-    manifest: "AndroidManifest.xml",
-    srcs: [
-        "src/**/*.java",
-        "src/**/I*.aidl",
-        ":statslog-qns-java-gen",
-    ],
-
-    static_libs: [
-        "androidx.appcompat_appcompat",
-        "androidx.browser_browser",
-        "TelephonyStatsLib",
-    ],
-
-    libs: [
-        "telephony-common",
-        "ims-common",
-        "framework-annotations-lib",
-        "framework-connectivity.stubs.module_lib",
-        "framework-wifi.stubs.module_lib",
-    ],
-
-    plugins: ["auto_value_plugin"],
-
-    required: [
-        "privapp-permissions_com.android.telephony.qns",
-    ],
-
-    apex_available: [
-        "//apex_available:platform",
-        "com.android.telephonymodules",
-    ],
-
-    owner: "google",
-    privileged: true,
-    certificate: "platform",
-}
-
-prebuilt_etc {
-    name: "privapp-permissions_com.android.telephony.qns",
-    sub_dir: "permissions",
-    src: "privapp-permissions_com.android.telephony.qns.xml",
-    filename_from_src: true,
-    system_ext_specific: true,
-}
-
-android_test {
-    name: "QualifiedNetworksServiceTests",
-    manifest: "tests/AndroidManifest.xml",
-    srcs: [
-        "src/**/*.java",
-        "src/**/I*.aidl",
-        "tests/**/*.java",
-        ":statslog-qns-java-gen",
-    ],
-    libs: [
-        "android.test.runner.stubs.system",
-        "telephony-common",
-        "ims-common",
-        "android.test.mock.stubs.system",
-        "android.test.base.stubs.system",
-    ],
-    static_libs: [
-        "androidx.appcompat_appcompat",
-        "androidx.browser_browser",
-        "androidx.test.ext.truth",
-        "androidx.test.ext.junit",
-        "androidx.test.rules",
-        "androidx.test.core",
-        "frameworks-base-testutils",
-        "mockito-target-extended-minus-junit4",
-        "platform-test-annotations",
-        "truth",
-        "testables",
-        "TelephonyStatsLib",
-    ],
-    jni_libs: [
-        "libdexmakerjvmtiagent",
-        "libstaticjvmtiagent",
-    ],
-    platform_apis: true,
-    certificate: "platform",
-    instrumentation_for: "QualifiedNetworksService",
-    test_suites: ["device-tests"],
-}
diff --git a/services/QualifiedNetworksService/AndroidManifest.xml b/services/QualifiedNetworksService/AndroidManifest.xml
deleted file mode 100644
index 5abdbf9..0000000
--- a/services/QualifiedNetworksService/AndroidManifest.xml
+++ /dev/null
@@ -1,69 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- -->
-
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    coreApp="true"
-    package="com.android.telephony.qns">
-  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
-  <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
-  <uses-permission android:name="android.permission.INTERNET" />
-  <uses-permission android:name="android.permission.MODIFY_PHONE_STATE" />
-  <uses-permission android:name="android.permission.NETWORK_SIGNAL_STRENGTH_WAKEUP" />
-  <uses-permission android:name="android.permission.READ_PHONE_STATE" />
-  <uses-permission android:name="android.permission.READ_PRECISE_PHONE_STATE" />
-  <uses-permission android:name="android.permission.READ_PRIVILEGED_PHONE_STATE" />
-  <uses-permission android:name="android.permission.REGISTER_STATS_PULL_ATOM" />
-  <uses-permission android:name="android.permission.USE_EXACT_ALARM"/>
-  <application
-      android:directBootAware="true"
-      android:defaultToDeviceProtectedStorage="true">
-    <service android:name=".QualifiedNetworksServiceImpl"
-         android:exported="true"
-         android:permission="android.permission.BIND_TELEPHONY_DATA_SERVICE"
-         android:enabled="true" >
-         <intent-filter>
-               <action android:name="android.telephony.data.QualifiedNetworksService" />
-         </intent-filter>
-    </service>
-    <activity
-      android:name=".wfc.WfcActivationActivity"
-      android:configChanges="orientation"
-      android:exported="false"
-      android:permission="android.permission.MODIFY_PHONE_STATE"
-      android:screenOrientation="nosensor"
-      android:theme="@android:style/Theme.Translucent.NoTitleBar"
-      android:windowFullscreen="false"
-      android:windowSoftInputMode="adjustResize">
-      <intent-filter>
-        <action android:name="android.intent.action.MAIN" />
-        <category android:name="android.intent.category.DEFAULT" />
-      </intent-filter>
-    </activity>
-
-    <activity-alias
-      android:name=".WfcActivationActivity"
-      android:exported="true"
-      android:label="@string/wifi_calling_activation_activity_label"
-      android:permission="android.permission.MODIFY_PHONE_STATE"
-      android:targetActivity=".wfc.WfcActivationActivity">
-      <intent-filter>
-        <action android:name="android.intent.action.MAIN" />
-        <category android:name="android.intent.category.DEFAULT" />
-      </intent-filter>
-    </activity-alias>
-  </application>
-</manifest>
diff --git a/services/QualifiedNetworksService/OWNERS b/services/QualifiedNetworksService/OWNERS
deleted file mode 100644
index 30bdf49..0000000
--- a/services/QualifiedNetworksService/OWNERS
+++ /dev/null
@@ -1,8 +0,0 @@
-set noparent
-
-# for QualifiedNetworksService
-sewookseo@google.com
-sangyun@google.com
-seheele@google.com
-nagendranb@google.com
-mdungriyal@google.com
diff --git a/services/QualifiedNetworksService/README.md b/services/QualifiedNetworksService/README.md
deleted file mode 100644
index 6eb2577..0000000
--- a/services/QualifiedNetworksService/README.md
+++ /dev/null
@@ -1,5 +0,0 @@
-QualifiedNetworksService for Android
-====================================
-
-### Introduction
-QualifiedNetworksService derives the qualified access networks for data networks based on network conditions and various carrier requirements, and reports it to telephony framework.
\ No newline at end of file
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10001_Tracfone-TMO-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_10001_Tracfone-TMO-US.xml
deleted file mode 100644
index dde5c3e..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10001_Tracfone-TMO-US.xml
+++ /dev/null
@@ -1,60 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-100"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-95"/>
-        <item value="-105"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10002_O2Prepaid-GB.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_10002_O2Prepaid-GB.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10002_O2Prepaid-GB.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10003_O2prepaid-DE.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_10003_O2prepaid-DE.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10003_O2prepaid-DE.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10008_Tracfone-VZW-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_10008_Tracfone-VZW-US.xml
deleted file mode 100644
index 235a321..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10008_Tracfone-VZW-US.xml
+++ /dev/null
@@ -1,99 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="3">
-        <item value="65535"/>
-        <item value="65535"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="3">
-        <item value="65535"/>
-        <item value="65535"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-75"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.cbs_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.cbs_rat_preference_int" value="3"/>
-    <boolean name="qns.roam_transport_type_selection_without_signal_strength_bool" value="true"/>
-    <boolean name="qns.allow_ims_over_iwlan_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="120000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="120000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.non_ims_wlan_hysteresis_timer_ms_int_array" num="2">
-        <item value="120000"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <boolean name="qns.ho_guarding_by_preference_bool" value="true"/>
-    <int name="qns.ims_network_enable_hysteresis_timer_int" value="1"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="3"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.support_service_barring_check_bool" value="true"/>
-    <int-array name="qns.waiting_time_for_preferred_transport_when_power_on_int_array" num="2">
-        <item value="45000"/>
-        <item value="0"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10009_C Spire-US-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_10009_C Spire-US-US.xml
deleted file mode 100644
index 550c8c3..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10009_C Spire-US-US.xml	
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10012_Red Pocket-ATT-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_10012_Red Pocket-ATT-US.xml
deleted file mode 100644
index f1c9954..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10012_Red Pocket-ATT-US.xml	
+++ /dev/null
@@ -1,91 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rssnr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rssnr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_sssinr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_sssinr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-73"/>
-        <item value="-93"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_utran_ecno_int_array" num="2">
-        <item value="-11"/>
-        <item value="-15"/>
-    </int-array>
-    <int-array name="qns.video_geran_rssi_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.xcap_rat_preference_int" value="3"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="1">
-        <item value="1"/>
-    </int-array>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="3">
-        <item value="LTE"/>
-        <item value="NR"/>
-        <item value="3G"/>
-    </string-array>
-    <boolean name="qns.prefer_current_transport_type_in_voice_call_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="1"/>
-        <item value="2"/>
-    </int-array>
-    <int name="qns.media_threshold_rtp_packet_loss_time_millis" value="12000"/>
-    <int name="qns.wifi_rssi_thresholdbackhaul_timer_int" value="0"/>
-    <int name="qns.sip_dialog_session_policy_int" value="1"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10013_FirstNet Pacific-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_10013_FirstNet Pacific-US.xml
deleted file mode 100644
index f1c9954..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10013_FirstNet Pacific-US.xml	
+++ /dev/null
@@ -1,91 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rssnr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rssnr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_sssinr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_sssinr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-73"/>
-        <item value="-93"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_utran_ecno_int_array" num="2">
-        <item value="-11"/>
-        <item value="-15"/>
-    </int-array>
-    <int-array name="qns.video_geran_rssi_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.xcap_rat_preference_int" value="3"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="1">
-        <item value="1"/>
-    </int-array>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="3">
-        <item value="LTE"/>
-        <item value="NR"/>
-        <item value="3G"/>
-    </string-array>
-    <boolean name="qns.prefer_current_transport_type_in_voice_call_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="1"/>
-        <item value="2"/>
-    </int-array>
-    <int name="qns.media_threshold_rtp_packet_loss_time_millis" value="12000"/>
-    <int name="qns.wifi_rssi_thresholdbackhaul_timer_int" value="0"/>
-    <int name="qns.sip_dialog_session_policy_int" value="1"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10021_AT&T_5G-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_10021_AT&T_5G-US.xml
deleted file mode 100644
index f1c9954..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10021_AT&T_5G-US.xml
+++ /dev/null
@@ -1,91 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rssnr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rssnr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_sssinr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_sssinr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-73"/>
-        <item value="-93"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_utran_ecno_int_array" num="2">
-        <item value="-11"/>
-        <item value="-15"/>
-    </int-array>
-    <int-array name="qns.video_geran_rssi_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.xcap_rat_preference_int" value="3"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="1">
-        <item value="1"/>
-    </int-array>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="3">
-        <item value="LTE"/>
-        <item value="NR"/>
-        <item value="3G"/>
-    </string-array>
-    <boolean name="qns.prefer_current_transport_type_in_voice_call_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="1"/>
-        <item value="2"/>
-    </int-array>
-    <int name="qns.media_threshold_rtp_packet_loss_time_millis" value="12000"/>
-    <int name="qns.wifi_rssi_thresholdbackhaul_timer_int" value="0"/>
-    <int name="qns.sip_dialog_session_policy_int" value="1"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10023_Consumer Cellular TMO-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_10023_Consumer Cellular TMO-US.xml
deleted file mode 100644
index dde5c3e..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10023_Consumer Cellular TMO-US.xml	
+++ /dev/null
@@ -1,60 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-100"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-95"/>
-        <item value="-105"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10024_Cellcom Core-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_10024_Cellcom Core-US.xml
deleted file mode 100644
index dc61386..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10024_Cellcom Core-US.xml	
+++ /dev/null
@@ -1,20 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-74"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-74"/>
-        <item value="-80"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10025_Roger5g-CA.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_10025_Roger5g-CA.xml
deleted file mode 100644
index 0633e46..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10025_Roger5g-CA.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="4">
-        <item value="LTE" />
-        <item value="NR" />
-        <item value="3G" />
-        <item value="2G" />
-    </string-array>
-    <int name="qns.xcap_rat_preference_int" value="2"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="2">
-        <item value="1"/>
-        <item value="1"/>
-    </int-array>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-78"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-78"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10028_AT&T_5G_SA-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_10028_AT&T_5G_SA-US.xml
deleted file mode 100644
index f1c9954..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10028_AT&T_5G_SA-US.xml
+++ /dev/null
@@ -1,91 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rssnr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rssnr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_sssinr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_sssinr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-73"/>
-        <item value="-93"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_utran_ecno_int_array" num="2">
-        <item value="-11"/>
-        <item value="-15"/>
-    </int-array>
-    <int-array name="qns.video_geran_rssi_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.xcap_rat_preference_int" value="3"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="1">
-        <item value="1"/>
-    </int-array>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="3">
-        <item value="LTE"/>
-        <item value="NR"/>
-        <item value="3G"/>
-    </string-array>
-    <boolean name="qns.prefer_current_transport_type_in_voice_call_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="1"/>
-        <item value="2"/>
-    </int-array>
-    <int name="qns.media_threshold_rtp_packet_loss_time_millis" value="12000"/>
-    <int name="qns.wifi_rssi_thresholdbackhaul_timer_int" value="0"/>
-    <int name="qns.sip_dialog_session_policy_int" value="1"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10029_Cricket 5G-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_10029_Cricket 5G-US.xml
deleted file mode 100644
index f1c9954..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_10029_Cricket 5G-US.xml	
+++ /dev/null
@@ -1,91 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rssnr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rssnr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_sssinr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_sssinr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-73"/>
-        <item value="-93"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_utran_ecno_int_array" num="2">
-        <item value="-11"/>
-        <item value="-15"/>
-    </int-array>
-    <int-array name="qns.video_geran_rssi_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.xcap_rat_preference_int" value="3"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="1">
-        <item value="1"/>
-    </int-array>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="3">
-        <item value="LTE"/>
-        <item value="NR"/>
-        <item value="3G"/>
-    </string-array>
-    <boolean name="qns.prefer_current_transport_type_in_voice_call_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="1"/>
-        <item value="2"/>
-    </int-array>
-    <int name="qns.media_threshold_rtp_packet_loss_time_millis" value="12000"/>
-    <int name="qns.wifi_rssi_thresholdbackhaul_timer_int" value="0"/>
-    <int name="qns.sip_dialog_session_policy_int" value="1"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1187_AT&T-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1187_AT&T-US.xml
deleted file mode 100644
index f1c9954..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1187_AT&T-US.xml
+++ /dev/null
@@ -1,91 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rssnr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rssnr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_sssinr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_sssinr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-73"/>
-        <item value="-93"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_utran_ecno_int_array" num="2">
-        <item value="-11"/>
-        <item value="-15"/>
-    </int-array>
-    <int-array name="qns.video_geran_rssi_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.xcap_rat_preference_int" value="3"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="1">
-        <item value="1"/>
-    </int-array>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="3">
-        <item value="LTE"/>
-        <item value="NR"/>
-        <item value="3G"/>
-    </string-array>
-    <boolean name="qns.prefer_current_transport_type_in_voice_call_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="1"/>
-        <item value="2"/>
-    </int-array>
-    <int name="qns.media_threshold_rtp_packet_loss_time_millis" value="12000"/>
-    <int name="qns.wifi_rssi_thresholdbackhaul_timer_int" value="0"/>
-    <int name="qns.sip_dialog_session_policy_int" value="1"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1344_H3-AT.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1344_H3-AT.xml
deleted file mode 100644
index 7a6caa0..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1344_H3-AT.xml
+++ /dev/null
@@ -1,78 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <string-array name="qns.condition_rove_in_idle_wifi_pref_home_string_array" num="1">
-        <item value="Condition:WIFI_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_idle_wifi_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_wifi_pref_home_string_array" num="1">
-        <item value="Condition:WIFI_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_wifi_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_BAD"/>
-    </string-array>
-    <boolean name="qns.override_cell_pref_to_ims_pref_home" value="true" />
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-108"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-108"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-97"/>
-        <item value="-107"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-90"/>
-        <item value="-100"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-74"/>
-        <item value="-85"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-108"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="-108"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="-97"/>
-        <item value="-107"/>
-    </int-array>
-    <int-array name="qns.video_geran_rssi_int_array" num="2">
-        <item value="-90"/>
-        <item value="-100"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-74"/>
-        <item value="-85"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-108"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="-108"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.voice_utran_rscp_int_array" num="2">
-        <item value="-97"/>
-        <item value="-107"/>
-    </int-array>
-    <int-array name="qns.voice_geran_rssi_int_array" num="2">
-        <item value="-90"/>
-        <item value="-100"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-74"/>
-        <item value="-85"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1345_Telstra-AU.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1345_Telstra-AU.xml
deleted file mode 100644
index 2413d82..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1345_Telstra-AU.xml
+++ /dev/null
@@ -1,41 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-110"/>
-        <item value="-118"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rsrq_int_array" num="2">
-        <item value="-14"/>
-        <item value="-16"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-106"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-110"/>
-        <item value="-118"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrq_int_array" num="2">
-        <item value="-14"/>
-        <item value="-16"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="-106"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-110"/>
-        <item value="-118"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrq_int_array" num="2">
-        <item value="-14"/>
-        <item value="-16"/>
-    </int-array>
-    <int-array name="qns.voice_utran_rscp_int_array" num="2">
-        <item value="-106"/>
-        <item value="-110"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1403_Roger-CA.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1403_Roger-CA.xml
deleted file mode 100644
index 0633e46..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1403_Roger-CA.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="4">
-        <item value="LTE" />
-        <item value="NR" />
-        <item value="3G" />
-        <item value="2G" />
-    </string-array>
-    <int name="qns.xcap_rat_preference_int" value="2"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="2">
-        <item value="1"/>
-        <item value="1"/>
-    </int-array>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-78"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-78"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1404_Telus-CA.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1404_Telus-CA.xml
deleted file mode 100644
index f7fd607..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1404_Telus-CA.xml
+++ /dev/null
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="3">
-        <item value="LTE" />
-        <item value="NR" />
-        <item value="3G" />
-    </string-array>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-106"/>
-        <item value="-116"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-100"/>
-        <item value="-105"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-106"/>
-        <item value="-116"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="-100"/>
-        <item value="-105"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-106"/>
-        <item value="-116"/>
-    </int-array>
-    <int-array name="qns.voice_utran_rscp_int_array" num="2">
-        <item value="-100"/>
-        <item value="-105"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1413_Sunrise-CH.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1413_Sunrise-CH.xml
deleted file mode 100644
index fdd0dcd..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1413_Sunrise-CH.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1453_Eplus-DE.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1453_Eplus-DE.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1453_Eplus-DE.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1454_O2-DE.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1454_O2-DE.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1454_O2-DE.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1463_TDC-DK.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1463_TDC-DK.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1463_TDC-DK.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1464_Telenor-DK.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1464_Telenor-DK.xml
deleted file mode 100644
index be4c547..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1464_Telenor-DK.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.xcap_rat_preference_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1466_Three-DK.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1466_Three-DK.xml
deleted file mode 100644
index be4c547..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1466_Three-DK.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.xcap_rat_preference_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1487_Bouygues-FR.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1487_Bouygues-FR.xml
deleted file mode 100644
index 5ead087..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1487_Bouygues-FR.xml
+++ /dev/null
@@ -1,41 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="4">
-        <item value="LTE"/>
-        <item value="NR"/>
-        <item value="3G"/>
-        <item value="2G"/>
-    </string-array>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-110"/>
-        <item value="-120"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-100"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-60"/>
-        <item value="-70"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-79"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-110"/>
-        <item value="-120"/>
-    </int-array>
-    <int-array name="qns.voice_utran_rscp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-100"/>
-    </int-array>
-    <int-array name="qns.voice_geran_rssi_int_array" num="2">
-        <item value="-60"/>
-        <item value="-70"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-79"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1492_O2Postpaid-GB.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1492_O2Postpaid-GB.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1492_O2Postpaid-GB.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_14_A1-AT.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_14_A1-AT.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_14_A1-AT.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1505_H3G-GB.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1505_H3G-GB.xml
deleted file mode 100644
index 8b84400..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1505_H3G-GB.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <boolean name="qns.in_call_ho_decision_wlan_to_wwan_without_vops_condition_bool" value="true"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1573_Windtre_IT.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1573_Windtre_IT.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1573_Windtre_IT.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1575_VeryMobile-IT.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1575_VeryMobile-IT.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1575_VeryMobile-IT.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1595_Swisscom-LI.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1595_Swisscom-LI.xml
deleted file mode 100644
index db16b95..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1595_Swisscom-LI.xml
+++ /dev/null
@@ -1,128 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="120000"/>
-        <item value="120000"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="120000"/>
-        <item value="120000"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="3">
-        <item value="-105"/>
-        <item value="-122"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="3">
-        <item value="-105"/>
-        <item value="-114"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="3">
-        <item value="-92"/>
-        <item value="-100"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-60"/>
-        <item value="-78"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="3">
-        <item value="-105"/>
-        <item value="-122"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-55"/>
-        <item value="-75"/>
-    </int-array>
-    <string-array name="qns.rove_in_threshold_gap_with_guard_timer_string_array" num="3">
-        <item value="eutran:rsrp:-2"/>
-        <item value="utran:rscp:-2"/>
-        <item value="geran:rssi:-2"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_idle_wifi_pref_home_guarding_none_string_array"
-                  num="3">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,UTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,GERAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_idle_wifi_pref_home_guarding_wifi_string_array"
-                  num="3">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,UTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,GERAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_wifi_pref_home_guarding_none_string_array"
-                  num="3">
-        <item value="Condition:EUTRAN_GOOD"/>
-        <item value="Condition:UTRAN_GOOD"/>
-        <item value="Condition:GERAN_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_wifi_pref_home_guarding_cell_string_array"
-                  num="3">
-        <item value="Condition:IWLAN_BAD,EUTRAN_GOOD"/>
-        <item value="Condition:IWLAN_BAD,UTRAN_GOOD"/>
-        <item value="Condition:IWLAN_BAD,GERAN_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_voice_wifi_pref_home_guarding_none_string_array"
-                  num="1">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_voice_wifi_pref_home_guarding_wifi_string_array"
-                  num="1">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_voice_wifi_pref_home_guarding_none_string_array"
-                  num="1">
-        <item value="Condition:EUTRAN_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_voice_wifi_pref_home_guarding_cell_string_array"
-                  num="1">
-        <item value="Condition:IWLAN_BAD,EUTRAN_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_idle_cell_pref_home_guarding_none_string_array"
-                  num="3">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,UTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,GERAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_idle_cell_pref_home_guarding_wifi_string_array"
-                  num="3">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,UTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,GERAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_cell_pref_home_guarding_none_string_array"
-                  num="3">
-        <item value="Condition:EUTRAN_GOOD"/>
-        <item value="Condition:UTRAN_GOOD"/>
-        <item value="Condition:GERAN_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_cell_pref_home_guarding_cell_string_array"
-                  num="3">
-        <item value="Condition:IWLAN_BAD,EUTRAN_GOOD"/>
-        <item value="Condition:IWLAN_BAD,UTRAN_GOOD"/>
-        <item value="Condition:IWLAN_BAD,GERAN_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_voice_cell_pref_home_guarding_none_string_array"
-                  num="1">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_voice_cell_pref_home_guarding_wifi_string_array"
-                  num="1">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_voice_cell_pref_home_guarding_none_string_array"
-                  num="1">
-        <item value="Condition:EUTRAN_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_voice_cells_pref_home_guarding_cell_string_array"
-                  num="1">
-        <item value="Condition:IWLAN_BAD,EUTRAN_GOOD"/>
-    </string-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_15_Vodafone-AU.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_15_Vodafone-AU.xml
deleted file mode 100644
index 7f3dbb4..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_15_Vodafone-AU.xml
+++ /dev/null
@@ -1,54 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <boolean name="qns.block_iwlan_in_international_roaming_without_wwan_bool" value="true"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-104"/>
-        <item value="-113"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-105"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-99"/>
-        <item value="-102"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-74"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-104"/>
-        <item value="-113"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="-105"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.video_geran_rssi_int_array" num="2">
-        <item value="-99"/>
-        <item value="-102"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-74"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-104"/>
-        <item value="-113"/>
-    </int-array>
-    <int-array name="qns.voice_utran_rscp_int_array" num="2">
-        <item value="-105"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.voice_geran_rssi_int_array" num="2">
-        <item value="-99"/>
-        <item value="-102"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-74"/>
-        <item value="-80"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1644_KPN-NL.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1644_KPN-NL.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1644_KPN-NL.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1690_Telia-SE.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1690_Telia-SE.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1690_Telia-SE.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1691_H3-SE.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1691_H3-SE.xml
deleted file mode 100644
index be4c547..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1691_H3-SE.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.xcap_rat_preference_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1695_Telenor-SE.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1695_Telenor-SE.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1695_Telenor-SE.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1696_Tele2-SE.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1696_Tele2-SE.xml
deleted file mode 100644
index fdd0dcd..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1696_Tele2-SE.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_16_Swisscom.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_16_Swisscom.xml
deleted file mode 100644
index db16b95..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_16_Swisscom.xml
+++ /dev/null
@@ -1,128 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="120000"/>
-        <item value="120000"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="120000"/>
-        <item value="120000"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="3">
-        <item value="-105"/>
-        <item value="-122"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="3">
-        <item value="-105"/>
-        <item value="-114"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="3">
-        <item value="-92"/>
-        <item value="-100"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-60"/>
-        <item value="-78"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="3">
-        <item value="-105"/>
-        <item value="-122"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-55"/>
-        <item value="-75"/>
-    </int-array>
-    <string-array name="qns.rove_in_threshold_gap_with_guard_timer_string_array" num="3">
-        <item value="eutran:rsrp:-2"/>
-        <item value="utran:rscp:-2"/>
-        <item value="geran:rssi:-2"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_idle_wifi_pref_home_guarding_none_string_array"
-                  num="3">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,UTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,GERAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_idle_wifi_pref_home_guarding_wifi_string_array"
-                  num="3">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,UTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,GERAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_wifi_pref_home_guarding_none_string_array"
-                  num="3">
-        <item value="Condition:EUTRAN_GOOD"/>
-        <item value="Condition:UTRAN_GOOD"/>
-        <item value="Condition:GERAN_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_wifi_pref_home_guarding_cell_string_array"
-                  num="3">
-        <item value="Condition:IWLAN_BAD,EUTRAN_GOOD"/>
-        <item value="Condition:IWLAN_BAD,UTRAN_GOOD"/>
-        <item value="Condition:IWLAN_BAD,GERAN_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_voice_wifi_pref_home_guarding_none_string_array"
-                  num="1">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_voice_wifi_pref_home_guarding_wifi_string_array"
-                  num="1">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_voice_wifi_pref_home_guarding_none_string_array"
-                  num="1">
-        <item value="Condition:EUTRAN_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_voice_wifi_pref_home_guarding_cell_string_array"
-                  num="1">
-        <item value="Condition:IWLAN_BAD,EUTRAN_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_idle_cell_pref_home_guarding_none_string_array"
-                  num="3">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,UTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,GERAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_idle_cell_pref_home_guarding_wifi_string_array"
-                  num="3">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,UTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,GERAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_cell_pref_home_guarding_none_string_array"
-                  num="3">
-        <item value="Condition:EUTRAN_GOOD"/>
-        <item value="Condition:UTRAN_GOOD"/>
-        <item value="Condition:GERAN_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_cell_pref_home_guarding_cell_string_array"
-                  num="3">
-        <item value="Condition:IWLAN_BAD,EUTRAN_GOOD"/>
-        <item value="Condition:IWLAN_BAD,UTRAN_GOOD"/>
-        <item value="Condition:IWLAN_BAD,GERAN_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_voice_cell_pref_home_guarding_none_string_array"
-                  num="1">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_voice_cell_pref_home_guarding_wifi_string_array"
-                  num="1">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_voice_cell_pref_home_guarding_none_string_array"
-                  num="1">
-        <item value="Condition:EUTRAN_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_voice_cells_pref_home_guarding_cell_string_array"
-                  num="1">
-        <item value="Condition:IWLAN_BAD,EUTRAN_GOOD"/>
-    </string-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1707_Starhub-SG.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1707_Starhub-SG.xml
deleted file mode 100644
index fed6d17..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1707_Starhub-SG.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1779_Cricket Wireless-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1779_Cricket Wireless-US.xml
deleted file mode 100644
index f1c9954..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1779_Cricket Wireless-US.xml	
+++ /dev/null
@@ -1,91 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rssnr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rssnr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_sssinr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_sssinr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-73"/>
-        <item value="-93"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_utran_ecno_int_array" num="2">
-        <item value="-11"/>
-        <item value="-15"/>
-    </int-array>
-    <int-array name="qns.video_geran_rssi_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.xcap_rat_preference_int" value="3"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="1">
-        <item value="1"/>
-    </int-array>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="3">
-        <item value="LTE"/>
-        <item value="NR"/>
-        <item value="3G"/>
-    </string-array>
-    <boolean name="qns.prefer_current_transport_type_in_voice_call_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="1"/>
-        <item value="2"/>
-    </int-array>
-    <int name="qns.media_threshold_rtp_packet_loss_time_millis" value="12000"/>
-    <int name="qns.wifi_rssi_thresholdbackhaul_timer_int" value="0"/>
-    <int name="qns.sip_dialog_session_policy_int" value="1"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1836_C Spire-US-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1836_C Spire-US-US.xml
deleted file mode 100644
index 550c8c3..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1836_C Spire-US-US.xml	
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1839_Verizon_Wireless-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1839_Verizon_Wireless-US.xml
deleted file mode 100644
index 235a321..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1839_Verizon_Wireless-US.xml
+++ /dev/null
@@ -1,99 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="3">
-        <item value="65535"/>
-        <item value="65535"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="3">
-        <item value="65535"/>
-        <item value="65535"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-75"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.cbs_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.cbs_rat_preference_int" value="3"/>
-    <boolean name="qns.roam_transport_type_selection_without_signal_strength_bool" value="true"/>
-    <boolean name="qns.allow_ims_over_iwlan_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="120000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="120000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.non_ims_wlan_hysteresis_timer_ms_int_array" num="2">
-        <item value="120000"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <boolean name="qns.ho_guarding_by_preference_bool" value="true"/>
-    <int name="qns.ims_network_enable_hysteresis_timer_int" value="1"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="3"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.support_service_barring_check_bool" value="true"/>
-    <int-array name="qns.waiting_time_for_preferred_transport_when_power_on_int_array" num="2">
-        <item value="45000"/>
-        <item value="0"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1849_Bluegrass Cellular LLC-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1849_Bluegrass Cellular LLC-US.xml
deleted file mode 100644
index 235a321..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1849_Bluegrass Cellular LLC-US.xml	
+++ /dev/null
@@ -1,99 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="3">
-        <item value="65535"/>
-        <item value="65535"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="3">
-        <item value="65535"/>
-        <item value="65535"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-75"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.cbs_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.cbs_rat_preference_int" value="3"/>
-    <boolean name="qns.roam_transport_type_selection_without_signal_strength_bool" value="true"/>
-    <boolean name="qns.allow_ims_over_iwlan_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="120000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="120000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.non_ims_wlan_hysteresis_timer_ms_int_array" num="2">
-        <item value="120000"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <boolean name="qns.ho_guarding_by_preference_bool" value="true"/>
-    <int name="qns.ims_network_enable_hysteresis_timer_int" value="1"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="3"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.support_service_barring_check_bool" value="true"/>
-    <int-array name="qns.waiting_time_for_preferred_transport_when_power_on_int_array" num="2">
-        <item value="45000"/>
-        <item value="0"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1881_FET-TW.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1881_FET-TW.xml
deleted file mode 100644
index fdd0dcd..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1881_FET-TW.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1884_CHT-TW.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1884_CHT-TW.xml
deleted file mode 100644
index fdd0dcd..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1884_CHT-TW.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1888_TaiwanMobile-TW.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1888_TaiwanMobile-TW.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1888_TaiwanMobile-TW.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1895_Freedommobile-CA.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1895_Freedommobile-CA.xml
deleted file mode 100644
index 9cced41..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1895_Freedommobile-CA.xml
+++ /dev/null
@@ -1,7 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.xcap_rat_preference_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1900_OneCall-NO.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1900_OneCall-NO.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1900_OneCall-NO.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1903_H3-IE.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1903_H3-IE.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1903_H3-IE.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1949_MetroPCS-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1949_MetroPCS-US.xml
deleted file mode 100644
index dde5c3e..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1949_MetroPCS-US.xml
+++ /dev/null
@@ -1,60 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-100"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-95"/>
-        <item value="-105"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1951_boost-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1951_boost-US.xml
deleted file mode 100644
index dde5c3e..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1951_boost-US.xml
+++ /dev/null
@@ -1,60 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-100"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-95"/>
-        <item value="-105"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1952_U.S. Cellular-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1952_U.S. Cellular-US.xml
deleted file mode 100644
index 550c8c3..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1952_U.S. Cellular-US.xml	
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1961_Airtel.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1961_Airtel.xml
deleted file mode 100644
index 84f8a30..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1961_Airtel.xml
+++ /dev/null
@@ -1,10 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2" />
-    <boolean name="qns.support_wfc_during_airplane_mode_bool" value="false"/>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="1">
-        <item value="LTE" />
-    </string-array>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1962_Fido-CA.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1962_Fido-CA.xml
deleted file mode 100644
index 0633e46..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1962_Fido-CA.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="4">
-        <item value="LTE" />
-        <item value="NR" />
-        <item value="3G" />
-        <item value="2G" />
-    </string-array>
-    <int name="qns.xcap_rat_preference_int" value="2"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="2">
-        <item value="1"/>
-        <item value="1"/>
-    </int-array>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-78"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-78"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_19_Vodafone-IE.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_19_Vodafone-IE.xml
deleted file mode 100644
index a6c8061..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_19_Vodafone-IE.xml
+++ /dev/null
@@ -1,7 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <boolean name="qns.block_iwlan_in_international_roaming_without_wwan_bool" value="true"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1_T-Mobile-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_1_T-Mobile-US.xml
deleted file mode 100644
index dde5c3e..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_1_T-Mobile-US.xml
+++ /dev/null
@@ -1,60 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-100"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-95"/>
-        <item value="-105"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2008_Videtron-CA.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2008_Videtron-CA.xml
deleted file mode 100644
index 960f33f..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2008_Videtron-CA.xml
+++ /dev/null
@@ -1,42 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-114"/>
-        <item value="-120"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-103"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-74"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-114"/>
-        <item value="-120"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="-103"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-74"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-114"/>
-        <item value="-120"/>
-    </int-array>
-    <int-array name="qns.voice_utran_rscp_int_array" num="2">
-        <item value="-103"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-74"/>
-        <item value="-80"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2018_Reliance-Jio.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2018_Reliance-Jio.xml
deleted file mode 100644
index 13133ef..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2018_Reliance-Jio.xml
+++ /dev/null
@@ -1,11 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2" />
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="1">
-        <item value="LTE" />
-    </string-array>
-    <boolean name="qns.roam_transport_type_selection_without_signal_strength_bool" value="true" />
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <string name="qns_wlan_rtt_backhaul_check_on_icmp_ping_string">www.google.com,5,200,32,100,600000,1800000</string>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2020_Koodo-CA.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2020_Koodo-CA.xml
deleted file mode 100644
index cb0f9ae..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2020_Koodo-CA.xml
+++ /dev/null
@@ -1,36 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="3">
-        <item value="LTE" />
-        <item value="NR" />
-        <item value="3G" />
-    </string-array>
-    <int name="qns.xcap_rat_preference_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-106"/>
-        <item value="-116"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-100"/>
-        <item value="-105"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-106"/>
-        <item value="-116"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="-100"/>
-        <item value="-105"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-106"/>
-        <item value="-116"/>
-    </int-array>
-    <int-array name="qns.voice_utran_rscp_int_array" num="2">
-        <item value="-100"/>
-        <item value="-105"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2021_Virgin-CA.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2021_Virgin-CA.xml
deleted file mode 100644
index 9cced41..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2021_Virgin-CA.xml
+++ /dev/null
@@ -1,7 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.xcap_rat_preference_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2024_Locus Telecom-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2024_Locus Telecom-US.xml
deleted file mode 100644
index f1c9954..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2024_Locus Telecom-US.xml	
+++ /dev/null
@@ -1,91 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rssnr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rssnr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_sssinr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_sssinr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-73"/>
-        <item value="-93"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_utran_ecno_int_array" num="2">
-        <item value="-11"/>
-        <item value="-15"/>
-    </int-array>
-    <int-array name="qns.video_geran_rssi_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.xcap_rat_preference_int" value="3"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="1">
-        <item value="1"/>
-    </int-array>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="3">
-        <item value="LTE"/>
-        <item value="NR"/>
-        <item value="3G"/>
-    </string-array>
-    <boolean name="qns.prefer_current_transport_type_in_voice_call_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="1"/>
-        <item value="2"/>
-    </int-array>
-    <int name="qns.media_threshold_rtp_packet_loss_time_millis" value="12000"/>
-    <int name="qns.wifi_rssi_thresholdbackhaul_timer_int" value="0"/>
-    <int name="qns.sip_dialog_session_policy_int" value="1"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2025_Telrite Pure Talk-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2025_Telrite Pure Talk-US.xml
deleted file mode 100644
index f1c9954..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2025_Telrite Pure Talk-US.xml	
+++ /dev/null
@@ -1,91 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rssnr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rssnr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_sssinr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_sssinr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-73"/>
-        <item value="-93"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_utran_ecno_int_array" num="2">
-        <item value="-11"/>
-        <item value="-15"/>
-    </int-array>
-    <int-array name="qns.video_geran_rssi_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.xcap_rat_preference_int" value="3"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="1">
-        <item value="1"/>
-    </int-array>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="3">
-        <item value="LTE"/>
-        <item value="NR"/>
-        <item value="3G"/>
-    </string-array>
-    <boolean name="qns.prefer_current_transport_type_in_voice_call_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="1"/>
-        <item value="2"/>
-    </int-array>
-    <int name="qns.media_threshold_rtp_packet_loss_time_millis" value="12000"/>
-    <int name="qns.wifi_rssi_thresholdbackhaul_timer_int" value="0"/>
-    <int name="qns.sip_dialog_session_policy_int" value="1"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2027_Airvoice-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2027_Airvoice-US.xml
deleted file mode 100644
index f1c9954..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2027_Airvoice-US.xml
+++ /dev/null
@@ -1,91 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rssnr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rssnr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_sssinr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_sssinr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-73"/>
-        <item value="-93"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_utran_ecno_int_array" num="2">
-        <item value="-11"/>
-        <item value="-15"/>
-    </int-array>
-    <int-array name="qns.video_geran_rssi_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.xcap_rat_preference_int" value="3"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="1">
-        <item value="1"/>
-    </int-array>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="3">
-        <item value="LTE"/>
-        <item value="NR"/>
-        <item value="3G"/>
-    </string-array>
-    <boolean name="qns.prefer_current_transport_type_in_voice_call_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="1"/>
-        <item value="2"/>
-    </int-array>
-    <int name="qns.media_threshold_rtp_packet_loss_time_millis" value="12000"/>
-    <int name="qns.wifi_rssi_thresholdbackhaul_timer_int" value="0"/>
-    <int name="qns.sip_dialog_session_policy_int" value="1"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2028_Ztar-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2028_Ztar-US.xml
deleted file mode 100644
index f1c9954..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2028_Ztar-US.xml
+++ /dev/null
@@ -1,91 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rssnr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rssnr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_sssinr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_sssinr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-73"/>
-        <item value="-93"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_utran_ecno_int_array" num="2">
-        <item value="-11"/>
-        <item value="-15"/>
-    </int-array>
-    <int-array name="qns.video_geran_rssi_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.xcap_rat_preference_int" value="3"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="1">
-        <item value="1"/>
-    </int-array>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="3">
-        <item value="LTE"/>
-        <item value="NR"/>
-        <item value="3G"/>
-    </string-array>
-    <boolean name="qns.prefer_current_transport_type_in_voice_call_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="1"/>
-        <item value="2"/>
-    </int-array>
-    <int name="qns.media_threshold_rtp_packet_loss_time_millis" value="12000"/>
-    <int name="qns.wifi_rssi_thresholdbackhaul_timer_int" value="0"/>
-    <int name="qns.sip_dialog_session_policy_int" value="1"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2047_IDMobile-GB.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2047_IDMobile-GB.xml
deleted file mode 100644
index 8b84400..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2047_IDMobile-GB.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <boolean name="qns.in_call_ho_decision_wlan_to_wwan_without_vops_condition_bool" value="true"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2063_Family Mobile (Walmart)-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2063_Family Mobile (Walmart)-US.xml
deleted file mode 100644
index dde5c3e..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2063_Family Mobile (Walmart)-US.xml	
+++ /dev/null
@@ -1,60 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-100"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-95"/>
-        <item value="-105"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2064_GoSmart-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2064_GoSmart-US.xml
deleted file mode 100644
index dde5c3e..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2064_GoSmart-US.xml
+++ /dev/null
@@ -1,60 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-100"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-95"/>
-        <item value="-105"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2067_Lycamobile-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2067_Lycamobile-US.xml
deleted file mode 100644
index dde5c3e..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2067_Lycamobile-US.xml
+++ /dev/null
@@ -1,60 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-100"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-95"/>
-        <item value="-105"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2069_Ultra-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2069_Ultra-US.xml
deleted file mode 100644
index dde5c3e..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2069_Ultra-US.xml
+++ /dev/null
@@ -1,60 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-100"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-95"/>
-        <item value="-105"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2073_US Mobile-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2073_US Mobile-US.xml
deleted file mode 100644
index dde5c3e..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2073_US Mobile-US.xml	
+++ /dev/null
@@ -1,60 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-100"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-95"/>
-        <item value="-105"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2075_Republic Wireless-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2075_Republic Wireless-US.xml
deleted file mode 100644
index dde5c3e..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2075_Republic Wireless-US.xml	
+++ /dev/null
@@ -1,60 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-100"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-95"/>
-        <item value="-105"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2078_Simple Mobile-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2078_Simple Mobile-US.xml
deleted file mode 100644
index dde5c3e..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2078_Simple Mobile-US.xml	
+++ /dev/null
@@ -1,60 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-100"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-95"/>
-        <item value="-105"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2080_Ting-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2080_Ting-US.xml
deleted file mode 100644
index dde5c3e..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2080_Ting-US.xml
+++ /dev/null
@@ -1,60 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-100"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-95"/>
-        <item value="-105"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2081_Twilio M2M-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2081_Twilio M2M-US.xml
deleted file mode 100644
index dde5c3e..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2081_Twilio M2M-US.xml	
+++ /dev/null
@@ -1,60 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-100"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-95"/>
-        <item value="-105"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2083_Ultra-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2083_Ultra-US.xml
deleted file mode 100644
index dde5c3e..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2083_Ultra-US.xml
+++ /dev/null
@@ -1,60 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-100"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-95"/>
-        <item value="-105"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2090_Tbaytel_ca.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2090_Tbaytel_ca.xml
deleted file mode 100644
index 0633e46..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2090_Tbaytel_ca.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="4">
-        <item value="LTE" />
-        <item value="NR" />
-        <item value="3G" />
-        <item value="2G" />
-    </string-array>
-    <int name="qns.xcap_rat_preference_int" value="2"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="2">
-        <item value="1"/>
-        <item value="1"/>
-    </int-array>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-78"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-78"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2092_Congstar-DE.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2092_Congstar-DE.xml
deleted file mode 100644
index b204cef..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2092_Congstar-DE.xml
+++ /dev/null
@@ -1,104 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.xcap_rat_preference_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <boolean name="qns.override_cell_pref_to_ims_pref_home" value="true"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="1">
-        <item value="LTE"/>
-    </string-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-99"/>
-        <item value="-103"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-89"/>
-        <item value="-106"/>
-    </int-array>
-    <int-array name="qns.voice_utran_rscp_int_array" num="2">
-        <item value="-89"/>
-        <item value="-105"/>
-    </int-array>
-    <int-array name="qns.voice_geran_rssi_int_array" num="2">
-        <item value="-89"/>
-        <item value="-102"/>
-    </int-array>
-    <string-array name="qns.condition_rove_in_idle_wifi_pref_home_string_array" num="1">
-        <item value="Condition:WIFI_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_voice_wifi_pref_home_string_array" num="1">
-        <item value="Condition:WIFI_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_video_wifi_pref_home_string_array" num="1">
-        <item value="Condition:WIFI_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_idle_cell_pref_home_string_array" num="3">
-        <item value="Condition:WIFI_GOOD,EUTRAN_BAD"/>
-        <item value="Condition:UTRAN_AVAILABLE"/>
-        <item value="Condition:GERAN_AVAILABLE"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_voice_cell_pref_home_string_array" num="3">
-        <item value="Condition:WIFI_GOOD,EUTRAN_BAD"/>
-        <item value="Condition:WIFI_GOOD,UTRAN_AVAILABLE"/>
-        <item value="Condition:WIFI_GOOD,GERAN_AVAILABLE"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_video_cell_pref_home_string_array" num="3">
-        <item value="Condition:WIFI_GOOD,EUTRAN_BAD"/>
-        <item value="Condition:WIFI_GOOD,UTRAN_AVAILABLE"/>
-        <item value="Condition:WIFI_GOOD,GERAN_AVAILABLE"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_wifi_pref_home_string_array" num="1">
-        <item value="Condition:WIFI_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_voice_wifi_pref_home_string_array" num="1">
-        <item value="Condition:WIFI_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_video_wifi_pref_home_string_array" num="1">
-        <item value="Condition:WIFI_BAD,EUTRAN_TOLERABLE"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_cell_pref_home_string_array" num="1">
-        <item value="Condition:EUTRAN_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_voice_cell_pref_home_string_array" num="1">
-        <item value="Condition:WIFI_BAD,EUTRAN_TOLERABLE"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_video_cell_pref_home_string_array" num="1">
-        <item value="Condition:WIFI_BAD,EUTRAN_TOLERABLE"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_idle_wifi_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_voice_wifi_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_video_wifi_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_idle_cell_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_GOOD,CELLULAR_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_voice_cell_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_GOOD,CELLULAR_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_video_cell_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_GOOD,CELLULAR_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_wifi_pref_roam_string_array" num="1">
-        <item value="Condition:EUTRAN_TOLERABLE"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_voice_wifi_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_BAD,EUTRAN_TOLERABLE"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_video_wifi_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_BAD,EUTRAN_TOLERABLE"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_cell_pref_roam_string_array" num="1">
-        <item value="Condition:CELLULAR_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_voice_cell_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_BAD,EUTRAN_TOLERABLE"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_video_cell_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_BAD,EUTRAN_TOLERABLE"/>
-    </string-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_20_Vodafone-NL.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_20_Vodafone-NL.xml
deleted file mode 100644
index fcd42ec..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_20_Vodafone-NL.xml
+++ /dev/null
@@ -1,42 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.xcap_rat_preference_int" value="2"/>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="5000"/>
-        <item value="5000"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="5000"/>
-        <item value="5000"/>
-    </int-array>
-    <boolean name="qns.block_iwlan_in_international_roaming_without_wwan_bool" value="true"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-104"/>
-        <item value="-118"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-105"/>
-        <item value="-112"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-94"/>
-        <item value="-102"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-104"/>
-        <item value="-118"/>
-    </int-array>
-    <int-array name="qns.voice_utran_rscp_int_array" num="2">
-        <item value="-105"/>
-        <item value="-112"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-94"/>
-        <item value="-102"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2101_BTC-GB.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2101_BTC-GB.xml
deleted file mode 100644
index a32a97c..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2101_BTC-GB.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2102_BTB-GB.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2102_BTB-GB.xml
deleted file mode 100644
index a32a97c..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2102_BTB-GB.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2119_FirstNet-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2119_FirstNet-US.xml
deleted file mode 100644
index f1c9954..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2119_FirstNet-US.xml
+++ /dev/null
@@ -1,91 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rssnr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rssnr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_sssinr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_sssinr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-73"/>
-        <item value="-93"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_utran_ecno_int_array" num="2">
-        <item value="-11"/>
-        <item value="-15"/>
-    </int-array>
-    <int-array name="qns.video_geran_rssi_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.xcap_rat_preference_int" value="3"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="1">
-        <item value="1"/>
-    </int-array>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="3">
-        <item value="LTE"/>
-        <item value="NR"/>
-        <item value="3G"/>
-    </string-array>
-    <boolean name="qns.prefer_current_transport_type_in_voice_call_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="1"/>
-        <item value="2"/>
-    </int-array>
-    <int name="qns.media_threshold_rtp_packet_loss_time_millis" value="12000"/>
-    <int name="qns.wifi_rssi_thresholdbackhaul_timer_int" value="0"/>
-    <int name="qns.sip_dialog_session_policy_int" value="1"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2120_FirstNet Lab-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2120_FirstNet Lab-US.xml
deleted file mode 100644
index f1c9954..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2120_FirstNet Lab-US.xml	
+++ /dev/null
@@ -1,91 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rssnr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rssnr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_sssinr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_sssinr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-73"/>
-        <item value="-93"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_utran_ecno_int_array" num="2">
-        <item value="-11"/>
-        <item value="-15"/>
-    </int-array>
-    <int-array name="qns.video_geran_rssi_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.xcap_rat_preference_int" value="3"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="1">
-        <item value="1"/>
-    </int-array>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="3">
-        <item value="LTE"/>
-        <item value="NR"/>
-        <item value="3G"/>
-    </string-array>
-    <boolean name="qns.prefer_current_transport_type_in_voice_call_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="1"/>
-        <item value="2"/>
-    </int-array>
-    <int name="qns.media_threshold_rtp_packet_loss_time_millis" value="12000"/>
-    <int name="qns.wifi_rssi_thresholdbackhaul_timer_int" value="0"/>
-    <int name="qns.sip_dialog_session_policy_int" value="1"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2126_Spectrum Mobile-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2126_Spectrum Mobile-US.xml
deleted file mode 100644
index 235a321..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2126_Spectrum Mobile-US.xml	
+++ /dev/null
@@ -1,99 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="3">
-        <item value="65535"/>
-        <item value="65535"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="3">
-        <item value="65535"/>
-        <item value="65535"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-75"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.cbs_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.cbs_rat_preference_int" value="3"/>
-    <boolean name="qns.roam_transport_type_selection_without_signal_strength_bool" value="true"/>
-    <boolean name="qns.allow_ims_over_iwlan_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="120000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="120000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.non_ims_wlan_hysteresis_timer_ms_int_array" num="2">
-        <item value="120000"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <boolean name="qns.ho_guarding_by_preference_bool" value="true"/>
-    <int name="qns.ims_network_enable_hysteresis_timer_int" value="1"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="3"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.support_service_barring_check_bool" value="true"/>
-    <int-array name="qns.waiting_time_for_preferred_transport_when_power_on_int_array" num="2">
-        <item value="45000"/>
-        <item value="0"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2137_Gamma-GB.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2137_Gamma-GB.xml
deleted file mode 100644
index 8b84400..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2137_Gamma-GB.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <boolean name="qns.in_call_ho_decision_wlan_to_wwan_without_vops_condition_bool" value="true"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2140_Smarty-GB.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2140_Smarty-GB.xml
deleted file mode 100644
index 8b84400..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2140_Smarty-GB.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <boolean name="qns.in_call_ho_decision_wlan_to_wwan_without_vops_condition_bool" value="true"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2146_Visible-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2146_Visible-US.xml
deleted file mode 100644
index 235a321..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2146_Visible-US.xml
+++ /dev/null
@@ -1,99 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="3">
-        <item value="65535"/>
-        <item value="65535"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="3">
-        <item value="65535"/>
-        <item value="65535"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-75"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.cbs_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.cbs_rat_preference_int" value="3"/>
-    <boolean name="qns.roam_transport_type_selection_without_signal_strength_bool" value="true"/>
-    <boolean name="qns.allow_ims_over_iwlan_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="120000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="120000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.non_ims_wlan_hysteresis_timer_ms_int_array" num="2">
-        <item value="120000"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <boolean name="qns.ho_guarding_by_preference_bool" value="true"/>
-    <int name="qns.ims_network_enable_hysteresis_timer_int" value="1"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="3"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.support_service_barring_check_bool" value="true"/>
-    <int-array name="qns.waiting_time_for_preferred_transport_when_power_on_int_array" num="2">
-        <item value="45000"/>
-        <item value="0"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2256_TelAlaska.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2256_TelAlaska.xml
deleted file mode 100644
index a963b95..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2256_TelAlaska.xml
+++ /dev/null
@@ -1,103 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.ims_transport_type_int" value="2"/>
-    <boolean name="qns.support_vops_notavailable_priority_iwlan_bool" value="false"/>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.cbs_transport_type_int" value="2"/>
-    <boolean name="qns.allow_ims_over_iwlan_cellular_limited_case_bool" value="true"/>
-    <int name="qns.ims_network_enable_hysteresis_timer_int" value="1"/>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="120000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="120000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="3"/>
-        <item value="1"/>
-    </int-array>
-    <int-array name="qns.waiting_time_for_preferred_transport_when_power_on_int_array" num="2">
-        <item value="45000"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="3">
-        <item value="65535"/>
-        <item value="65535"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="3">
-        <item value="-100"/>
-        <item value="-112"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrq_int_array" num="3">
-        <item value="-11"/>
-        <item value="-15"/>
-        <item value="-18"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="3">
-        <item value="65535"/>
-        <item value="65535"/>
-        <item value="-115"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-75"/>
-    </int-array>
-    <boolean name="qns.roam_transport_type_selection_without_signal_strength_bool" value="true"/>
-    <boolean name="qns.prefer_current_transport_type_in_voice_call_bool" value="false"/>
-    <string-array name="qns.rove_in_threshold_gap_with_guard_timer_string_array" num="1">
-        <item value="eutran:rsrp:-2"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_cell_pref_roam_guarding_none_string_array"
-                  num="1">
-        <item value="Condition:EUTRAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_cell_pref_roam_guarding_cell_string_array"
-                  num="1">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-    </string-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2274_SFR-FR.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2274_SFR-FR.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2274_SFR-FR.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2282_Kena-IT.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2282_Kena-IT.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2282_Kena-IT.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2287_Halebop-SE.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2287_Halebop-SE.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2287_Halebop-SE.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2366_Swisscom.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2366_Swisscom.xml
deleted file mode 100644
index db16b95..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2366_Swisscom.xml
+++ /dev/null
@@ -1,128 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="120000"/>
-        <item value="120000"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="120000"/>
-        <item value="120000"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="3">
-        <item value="-105"/>
-        <item value="-122"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="3">
-        <item value="-105"/>
-        <item value="-114"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="3">
-        <item value="-92"/>
-        <item value="-100"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-60"/>
-        <item value="-78"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="3">
-        <item value="-105"/>
-        <item value="-122"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-55"/>
-        <item value="-75"/>
-    </int-array>
-    <string-array name="qns.rove_in_threshold_gap_with_guard_timer_string_array" num="3">
-        <item value="eutran:rsrp:-2"/>
-        <item value="utran:rscp:-2"/>
-        <item value="geran:rssi:-2"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_idle_wifi_pref_home_guarding_none_string_array"
-                  num="3">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,UTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,GERAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_idle_wifi_pref_home_guarding_wifi_string_array"
-                  num="3">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,UTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,GERAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_wifi_pref_home_guarding_none_string_array"
-                  num="3">
-        <item value="Condition:EUTRAN_GOOD"/>
-        <item value="Condition:UTRAN_GOOD"/>
-        <item value="Condition:GERAN_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_wifi_pref_home_guarding_cell_string_array"
-                  num="3">
-        <item value="Condition:IWLAN_BAD,EUTRAN_GOOD"/>
-        <item value="Condition:IWLAN_BAD,UTRAN_GOOD"/>
-        <item value="Condition:IWLAN_BAD,GERAN_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_voice_wifi_pref_home_guarding_none_string_array"
-                  num="1">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_voice_wifi_pref_home_guarding_wifi_string_array"
-                  num="1">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_voice_wifi_pref_home_guarding_none_string_array"
-                  num="1">
-        <item value="Condition:EUTRAN_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_voice_wifi_pref_home_guarding_cell_string_array"
-                  num="1">
-        <item value="Condition:IWLAN_BAD,EUTRAN_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_idle_cell_pref_home_guarding_none_string_array"
-                  num="3">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,UTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,GERAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_idle_cell_pref_home_guarding_wifi_string_array"
-                  num="3">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,UTRAN_BAD"/>
-        <item value="Condition:IWLAN_GOOD,GERAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_cell_pref_home_guarding_none_string_array"
-                  num="3">
-        <item value="Condition:EUTRAN_GOOD"/>
-        <item value="Condition:UTRAN_GOOD"/>
-        <item value="Condition:GERAN_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_cell_pref_home_guarding_cell_string_array"
-                  num="3">
-        <item value="Condition:IWLAN_BAD,EUTRAN_GOOD"/>
-        <item value="Condition:IWLAN_BAD,UTRAN_GOOD"/>
-        <item value="Condition:IWLAN_BAD,GERAN_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_voice_cell_pref_home_guarding_none_string_array"
-                  num="1">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_voice_cell_pref_home_guarding_wifi_string_array"
-                  num="1">
-        <item value="Condition:IWLAN_GOOD,EUTRAN_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_voice_cell_pref_home_guarding_none_string_array"
-                  num="1">
-        <item value="Condition:EUTRAN_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_voice_cells_pref_home_guarding_cell_string_array"
-                  num="1">
-        <item value="Condition:IWLAN_BAD,EUTRAN_GOOD"/>
-    </string-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2386_Tmobile-NL.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2386_Tmobile-NL.xml
deleted file mode 100644
index f870823..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2386_Tmobile-NL.xml
+++ /dev/null
@@ -1,45 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="5000"/>
-        <item value="5000"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="5000"/>
-        <item value="5000"/>
-    </int-array>
-    <string-array name="qns.condition_rove_in_idle_wifi_pref_home_string_array" num="1">
-        <item value="Condition:WIFI_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_idle_wifi_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_wifi_pref_home_string_array" num="1">
-        <item value="Condition:WIFI_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_wifi_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_BAD"/>
-    </string-array>
-    <boolean name="qns.override_cell_pref_to_ims_pref_home" value="true"/>
-    <int name="qns.xcap_rat_preference_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-99"/>
-        <item value="-103"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-89"/>
-        <item value="-106"/>
-    </int-array>
-    <int-array name="qns.voice_utran_rscp_int_array" num="2">
-        <item value="-89"/>
-        <item value="-105"/>
-    </int-array>
-    <int-array name="qns.voice_geran_rssi_int_array" num="2">
-        <item value="-89"/>
-        <item value="-102"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2398_Vodafone-CZ.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2398_Vodafone-CZ.xml
deleted file mode 100644
index 073866a..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2398_Vodafone-CZ.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <boolean name="qns.block_iwlan_in_international_roaming_without_wwan_bool" value="true"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2417_Fizz-CA.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2417_Fizz-CA.xml
deleted file mode 100644
index 960f33f..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2417_Fizz-CA.xml
+++ /dev/null
@@ -1,42 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-114"/>
-        <item value="-120"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-103"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-74"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-114"/>
-        <item value="-120"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="-103"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-74"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-114"/>
-        <item value="-120"/>
-    </int-array>
-    <int-array name="qns.voice_utran_rscp_int_array" num="2">
-        <item value="-103"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-74"/>
-        <item value="-80"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2418_Talkmobile-GB.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2418_Talkmobile-GB.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2418_Talkmobile-GB.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2433_Assurance Wireless-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2433_Assurance Wireless-US.xml
deleted file mode 100644
index dde5c3e..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2433_Assurance Wireless-US.xml	
+++ /dev/null
@@ -1,60 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="-109"/>
-        <item value="-114"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-100"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-95"/>
-        <item value="-105"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int-array name="qns.video_wifi_rssi_int_array" num="2">
-        <item value="-70"/>
-        <item value="-80"/>
-    </int-array>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="10000"/>
-        <item value="10000"/>
-        <item value="10000"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2455_Homobile_IT.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2455_Homobile_IT.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2455_Homobile_IT.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2460_Shaw-CA.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2460_Shaw-CA.xml
deleted file mode 100644
index 9cced41..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2460_Shaw-CA.xml
+++ /dev/null
@@ -1,7 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.xcap_rat_preference_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2467_ESN-GB.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2467_ESN-GB.xml
deleted file mode 100644
index 2ed7d8e..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2467_ESN-GB.xml
+++ /dev/null
@@ -1,7 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int name="qns.xcap_rat_preference_int" value="2"/>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2504_Liberty Mobile-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2504_Liberty Mobile-US.xml
deleted file mode 100644
index f1c9954..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2504_Liberty Mobile-US.xml	
+++ /dev/null
@@ -1,91 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rssnr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rssnr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_sssinr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_sssinr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-73"/>
-        <item value="-93"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_utran_ecno_int_array" num="2">
-        <item value="-11"/>
-        <item value="-15"/>
-    </int-array>
-    <int-array name="qns.video_geran_rssi_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.xcap_rat_preference_int" value="3"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="1">
-        <item value="1"/>
-    </int-array>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="3">
-        <item value="LTE"/>
-        <item value="NR"/>
-        <item value="3G"/>
-    </string-array>
-    <boolean name="qns.prefer_current_transport_type_in_voice_call_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="1"/>
-        <item value="2"/>
-    </int-array>
-    <int name="qns.media_threshold_rtp_packet_loss_time_millis" value="12000"/>
-    <int name="qns.wifi_rssi_thresholdbackhaul_timer_int" value="0"/>
-    <int name="qns.sip_dialog_session_policy_int" value="1"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2525_Boost Mobile-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2525_Boost Mobile-US.xml
deleted file mode 100644
index f1c9954..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2525_Boost Mobile-US.xml	
+++ /dev/null
@@ -1,91 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rssnr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rssnr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_sssinr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_sssinr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-73"/>
-        <item value="-93"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_utran_ecno_int_array" num="2">
-        <item value="-11"/>
-        <item value="-15"/>
-    </int-array>
-    <int-array name="qns.video_geran_rssi_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.xcap_rat_preference_int" value="3"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="1">
-        <item value="1"/>
-    </int-array>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="3">
-        <item value="LTE"/>
-        <item value="NR"/>
-        <item value="3G"/>
-    </string-array>
-    <boolean name="qns.prefer_current_transport_type_in_voice_call_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="1"/>
-        <item value="2"/>
-    </int-array>
-    <int name="qns.media_threshold_rtp_packet_loss_time_millis" value="12000"/>
-    <int name="qns.wifi_rssi_thresholdbackhaul_timer_int" value="0"/>
-    <int name="qns.sip_dialog_session_policy_int" value="1"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2526_Ting-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2526_Ting-US.xml
deleted file mode 100644
index f1c9954..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2526_Ting-US.xml
+++ /dev/null
@@ -1,91 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rssnr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rssnr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_sssinr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_sssinr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-73"/>
-        <item value="-93"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_utran_ecno_int_array" num="2">
-        <item value="-11"/>
-        <item value="-15"/>
-    </int-array>
-    <int-array name="qns.video_geran_rssi_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.xcap_rat_preference_int" value="3"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="1">
-        <item value="1"/>
-    </int-array>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="3">
-        <item value="LTE"/>
-        <item value="NR"/>
-        <item value="3G"/>
-    </string-array>
-    <boolean name="qns.prefer_current_transport_type_in_voice_call_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="1"/>
-        <item value="2"/>
-    </int-array>
-    <int name="qns.media_threshold_rtp_packet_loss_time_millis" value="12000"/>
-    <int name="qns.wifi_rssi_thresholdbackhaul_timer_int" value="0"/>
-    <int name="qns.sip_dialog_session_policy_int" value="1"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2527_Republic-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2527_Republic-US.xml
deleted file mode 100644
index f1c9954..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2527_Republic-US.xml
+++ /dev/null
@@ -1,91 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rssnr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rssnr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_sssinr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_sssinr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-73"/>
-        <item value="-93"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_utran_ecno_int_array" num="2">
-        <item value="-11"/>
-        <item value="-15"/>
-    </int-array>
-    <int-array name="qns.video_geran_rssi_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.xcap_rat_preference_int" value="3"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="1">
-        <item value="1"/>
-    </int-array>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="3">
-        <item value="LTE"/>
-        <item value="NR"/>
-        <item value="3G"/>
-    </string-array>
-    <boolean name="qns.prefer_current_transport_type_in_voice_call_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="1"/>
-        <item value="2"/>
-    </int-array>
-    <int name="qns.media_threshold_rtp_packet_loss_time_millis" value="12000"/>
-    <int name="qns.wifi_rssi_thresholdbackhaul_timer_int" value="0"/>
-    <int name="qns.sip_dialog_session_policy_int" value="1"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2534_Boost Infinite-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2534_Boost Infinite-US.xml
deleted file mode 100644
index f1c9954..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2534_Boost Infinite-US.xml	
+++ /dev/null
@@ -1,91 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rssnr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rssnr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_sssinr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_sssinr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-73"/>
-        <item value="-93"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_utran_ecno_int_array" num="2">
-        <item value="-11"/>
-        <item value="-15"/>
-    </int-array>
-    <int-array name="qns.video_geran_rssi_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.xcap_rat_preference_int" value="3"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="1">
-        <item value="1"/>
-    </int-array>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="3">
-        <item value="LTE"/>
-        <item value="NR"/>
-        <item value="3G"/>
-    </string-array>
-    <boolean name="qns.prefer_current_transport_type_in_voice_call_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="1"/>
-        <item value="2"/>
-    </int-array>
-    <int name="qns.media_threshold_rtp_packet_loss_time_millis" value="12000"/>
-    <int name="qns.wifi_rssi_thresholdbackhaul_timer_int" value="0"/>
-    <int name="qns.sip_dialog_session_policy_int" value="1"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2538_Universal DISH-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2538_Universal DISH-US.xml
deleted file mode 100644
index f1c9954..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2538_Universal DISH-US.xml	
+++ /dev/null
@@ -1,91 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rssnr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rssnr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_sssinr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_sssinr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-73"/>
-        <item value="-93"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_utran_ecno_int_array" num="2">
-        <item value="-11"/>
-        <item value="-15"/>
-    </int-array>
-    <int-array name="qns.video_geran_rssi_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.xcap_rat_preference_int" value="3"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="1">
-        <item value="1"/>
-    </int-array>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="3">
-        <item value="LTE"/>
-        <item value="NR"/>
-        <item value="3G"/>
-    </string-array>
-    <boolean name="qns.prefer_current_transport_type_in_voice_call_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="1"/>
-        <item value="2"/>
-    </int-array>
-    <int name="qns.media_threshold_rtp_packet_loss_time_millis" value="12000"/>
-    <int name="qns.wifi_rssi_thresholdbackhaul_timer_int" value="0"/>
-    <int name="qns.sip_dialog_session_policy_int" value="1"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2539_Project Genesis-US.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2539_Project Genesis-US.xml
deleted file mode 100644
index f1c9954..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2539_Project Genesis-US.xml	
+++ /dev/null
@@ -1,91 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_eutran_rssnr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rssnr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_ssrsrp_int_array" num="2">
-        <item value="-90"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_ngran_ssrsrp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_ngran_sssinr_int_array" num="2">
-        <item value="2"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.voice_ngran_sssinr_int_array" num="2">
-        <item value="65535"/>
-        <item value="-3"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-73"/>
-        <item value="-93"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int-array name="qns.idle_utran_ecno_int_array" num="2">
-        <item value="-11"/>
-        <item value="-15"/>
-    </int-array>
-    <int-array name="qns.video_geran_rssi_int_array" num="2">
-        <item value="65535"/>
-        <item value="65535"/>
-    </int-array>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.xcap_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.xcap_rat_preference_int" value="3"/>
-    <int-array name="qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array" num="1">
-        <item value="1"/>
-    </int-array>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="3">
-        <item value="LTE"/>
-        <item value="NR"/>
-        <item value="3G"/>
-    </string-array>
-    <boolean name="qns.prefer_current_transport_type_in_voice_call_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="0"/>
-        <item value="0"/>
-    </int-array>
-    <boolean name="qns.allow_video_over_iwlan_with_cellular_limited_case_bool" value="true"/>
-    <int-array name="qns.in_call_rovein_allowed_and_fallback_reason_int_array" num="2">
-        <item value="1"/>
-        <item value="2"/>
-    </int-array>
-    <int name="qns.media_threshold_rtp_packet_loss_time_millis" value="12000"/>
-    <int name="qns.wifi_rssi_thresholdbackhaul_timer_int" value="0"/>
-    <int name="qns.sip_dialog_session_policy_int" value="1"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_25_Vodafone-DE.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_25_Vodafone-DE.xml
deleted file mode 100644
index f4fea1a..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_25_Vodafone-DE.xml
+++ /dev/null
@@ -1,16 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <boolean name="qns.block_iwlan_in_international_roaming_without_wwan_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="5000"/>
-        <item value="5000"/>
-    </int-array>
-    <int-array name="qns.ims_wwan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="5000"/>
-        <item value="5000"/>
-    </int-array>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_26_Vodafone-ES.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_26_Vodafone-ES.xml
deleted file mode 100644
index 431b491..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_26_Vodafone-ES.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <boolean name="qns.block_iwlan_in_international_roaming_without_wwan_bool" value="true"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_27_SFR-FR.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_27_SFR-FR.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_27_SFR-FR.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_28_Vodafone-GB.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_28_Vodafone-GB.xml
deleted file mode 100644
index 8a2010e..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_28_Vodafone-GB.xml
+++ /dev/null
@@ -1,52 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <boolean name="qns.block_iwlan_in_international_roaming_without_wwan_bool" value="true"/>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="5000"/>
-        <item value="5000"/>
-    </int-array>
-    <int-array name="qns.ims_wlan_hysteresis_timer_ms_int_array" num="3">
-        <item value="5000"/>
-        <item value="5000"/>
-        <item value="5000"/>
-    </int-array>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-110"/>
-        <item value="-116"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-105"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-99"/>
-        <item value="-102"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-110"/>
-        <item value="-116"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="-105"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.video_geran_rssi_int_array" num="2">
-        <item value="-99"/>
-        <item value="-102"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-110"/>
-        <item value="-116"/>
-    </int-array>
-    <int-array name="qns.voice_utran_rscp_int_array" num="2">
-        <item value="-105"/>
-        <item value="-110"/>
-    </int-array>
-    <int-array name="qns.voice_geran_rssi_int_array" num="2">
-        <item value="-99"/>
-        <item value="-102"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_29_Vodafone-IT.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_29_Vodafone-IT.xml
deleted file mode 100644
index 431b491..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_29_Vodafone-IT.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <boolean name="qns.block_iwlan_in_international_roaming_without_wwan_bool" value="true"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2_EE-GB.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_2_EE-GB.xml
deleted file mode 100644
index 2ed7d8e..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_2_EE-GB.xml
+++ /dev/null
@@ -1,7 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int name="qns.xcap_rat_preference_int" value="2"/>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_30_Optus-AU.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_30_Optus-AU.xml
deleted file mode 100644
index 86e5286..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_30_Optus-AU.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int-array name="qns.idle_eutran_rsrp_int_array" num="2">
-        <item value="-104"/>
-        <item value="-113"/>
-    </int-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-99"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.video_eutran_rsrp_int_array" num="2">
-        <item value="-104"/>
-        <item value="-113"/>
-    </int-array>
-    <int-array name="qns.video_utran_rscp_int_array" num="2">
-        <item value="-99"/>
-        <item value="-108"/>
-    </int-array>
-    <int-array name="qns.voice_eutran_rsrp_int_array" num="2">
-        <item value="-104"/>
-        <item value="-113"/>
-    </int-array>
-    <int-array name="qns.voice_utran_rscp_int_array" num="2">
-        <item value="-99"/>
-        <item value="-108"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_31_Singtel-SG.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_31_Singtel-SG.xml
deleted file mode 100644
index fdd0dcd..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_31_Singtel-SG.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_32_Orange-FR.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_32_Orange-FR.xml
deleted file mode 100644
index 808f614..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_32_Orange-FR.xml
+++ /dev/null
@@ -1,21 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-75"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_without_cellular_int_array" num="2">
-        <item value="-85"/>
-        <item value="-90"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-75"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_without_cellular_int_array" num="2">
-        <item value="-85"/>
-        <item value="-90"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_33_Tim-IT.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_33_Tim-IT.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_33_Tim-IT.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_34_Movistar-ES.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_34_Movistar-ES.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_34_Movistar-ES.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_3_Telekom.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_3_Telekom.xml
deleted file mode 100644
index b204cef..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_3_Telekom.xml
+++ /dev/null
@@ -1,104 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.xcap_rat_preference_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <boolean name="qns.override_cell_pref_to_ims_pref_home" value="true"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <string-array name="qns.ims_cellular_allowed_rat_string_array" num="1">
-        <item value="LTE"/>
-    </string-array>
-    <int-array name="qns.idle_utran_rscp_int_array" num="2">
-        <item value="-99"/>
-        <item value="-103"/>
-    </int-array>
-    <int-array name="qns.idle_geran_rssi_int_array" num="2">
-        <item value="-89"/>
-        <item value="-106"/>
-    </int-array>
-    <int-array name="qns.voice_utran_rscp_int_array" num="2">
-        <item value="-89"/>
-        <item value="-105"/>
-    </int-array>
-    <int-array name="qns.voice_geran_rssi_int_array" num="2">
-        <item value="-89"/>
-        <item value="-102"/>
-    </int-array>
-    <string-array name="qns.condition_rove_in_idle_wifi_pref_home_string_array" num="1">
-        <item value="Condition:WIFI_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_voice_wifi_pref_home_string_array" num="1">
-        <item value="Condition:WIFI_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_video_wifi_pref_home_string_array" num="1">
-        <item value="Condition:WIFI_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_idle_cell_pref_home_string_array" num="3">
-        <item value="Condition:WIFI_GOOD,EUTRAN_BAD"/>
-        <item value="Condition:UTRAN_AVAILABLE"/>
-        <item value="Condition:GERAN_AVAILABLE"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_voice_cell_pref_home_string_array" num="3">
-        <item value="Condition:WIFI_GOOD,EUTRAN_BAD"/>
-        <item value="Condition:WIFI_GOOD,UTRAN_AVAILABLE"/>
-        <item value="Condition:WIFI_GOOD,GERAN_AVAILABLE"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_video_cell_pref_home_string_array" num="3">
-        <item value="Condition:WIFI_GOOD,EUTRAN_BAD"/>
-        <item value="Condition:WIFI_GOOD,UTRAN_AVAILABLE"/>
-        <item value="Condition:WIFI_GOOD,GERAN_AVAILABLE"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_wifi_pref_home_string_array" num="1">
-        <item value="Condition:WIFI_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_voice_wifi_pref_home_string_array" num="1">
-        <item value="Condition:WIFI_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_video_wifi_pref_home_string_array" num="1">
-        <item value="Condition:WIFI_BAD,EUTRAN_TOLERABLE"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_cell_pref_home_string_array" num="1">
-        <item value="Condition:EUTRAN_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_voice_cell_pref_home_string_array" num="1">
-        <item value="Condition:WIFI_BAD,EUTRAN_TOLERABLE"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_video_cell_pref_home_string_array" num="1">
-        <item value="Condition:WIFI_BAD,EUTRAN_TOLERABLE"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_idle_wifi_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_voice_wifi_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_video_wifi_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_idle_cell_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_GOOD,CELLULAR_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_voice_cell_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_GOOD,CELLULAR_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_in_video_cell_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_GOOD,CELLULAR_BAD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_wifi_pref_roam_string_array" num="1">
-        <item value="Condition:EUTRAN_TOLERABLE"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_voice_wifi_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_BAD,EUTRAN_TOLERABLE"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_video_wifi_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_BAD,EUTRAN_TOLERABLE"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_idle_cell_pref_roam_string_array" num="1">
-        <item value="Condition:CELLULAR_GOOD"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_voice_cell_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_BAD,EUTRAN_TOLERABLE"/>
-    </string-array>
-    <string-array name="qns.condition_rove_out_video_cell_pref_roam_string_array" num="1">
-        <item value="Condition:WIFI_BAD,EUTRAN_TOLERABLE"/>
-    </string-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_4_Tmobile-AT.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_4_Tmobile-AT.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_4_Tmobile-AT.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_576_Bell-CA.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_576_Bell-CA.xml
deleted file mode 100644
index 9cced41..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_576_Bell-CA.xml
+++ /dev/null
@@ -1,7 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.sos_transport_type_int" value="2"/>
-    <int name="qns.xcap_rat_preference_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="2"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_656_Telia-DK.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_656_Telia-DK.xml
deleted file mode 100644
index be4c547..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_656_Telia-DK.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.xcap_rat_preference_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_678_Orange-ES.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_678_Orange-ES.xml
deleted file mode 100644
index 5f8b6cf..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_678_Orange-ES.xml
+++ /dev/null
@@ -1,21 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int-array name="qns.idle_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-75"/>
-    </int-array>
-    <int-array name="qns.idle_wifi_rssi_without_cellular_int_array" num="2">
-        <item value="-85"/>
-        <item value="-90"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_int_array" num="2">
-        <item value="-65"/>
-        <item value="-75"/>
-    </int-array>
-    <int-array name="qns.voice_wifi_rssi_without_cellular_int_array" num="2">
-        <item value="-85"/>
-        <item value="-90"/>
-    </int-array>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_717_Virgin-GB.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_717_Virgin-GB.xml
deleted file mode 100644
index b11ece8..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_717_Virgin-GB.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_transport_type_int" value="2"/>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_792_H3G-IE.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_792_H3G-IE.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_792_H3G-IE.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_958_Telenor-NO.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_958_Telenor-NO.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_958_Telenor-NO.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/assets/carrier_config_carrierid_959_Telia-NO.xml b/services/QualifiedNetworksService/assets/carrier_config_carrierid_959_Telia-NO.xml
deleted file mode 100644
index cc4c410..0000000
--- a/services/QualifiedNetworksService/assets/carrier_config_carrierid_959_Telia-NO.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<carrier_config>
-    <int name="qns.mms_rat_preference_int" value="3"/>
-    <int name="qns.mms_transport_type_int" value="2"/>
-</carrier_config>
diff --git a/services/QualifiedNetworksService/res/layout/activity_wfc_activation.xml b/services/QualifiedNetworksService/res/layout/activity_wfc_activation.xml
deleted file mode 100644
index 205e037..0000000
--- a/services/QualifiedNetworksService/res/layout/activity_wfc_activation.xml
+++ /dev/null
@@ -1,24 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-    Copyright (C) 2022 Google Inc.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-         http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<!-- Layout of WfcActivationCanadaActivity -->
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              android:layout_width="match_parent"
-              android:layout_height="match_parent"
-              android:orientation="vertical" >
-
-</LinearLayout>
diff --git a/services/QualifiedNetworksService/res/values/strings.xml b/services/QualifiedNetworksService/res/values/strings.xml
deleted file mode 100644
index c49f1a5..0000000
--- a/services/QualifiedNetworksService/res/values/strings.xml
+++ /dev/null
@@ -1,37 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2022 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <!-- Strings for Wi-Fi calling activation activity -->
-  <!-- Default title showed on the top of a fullscreen view, indicating that the app is for managing the user's Wi-Fi calling activation. [CHAR LIMIT=40] -->
-  <string name="wifi_calling_activation_activity_label">Carrier Setup</string>
-  <!-- Text used in progress dialog which is showed when app is loading web content. [CHAR LIMIT=30] -->
-  <string name="progress_text">This will take a few moments</string>
-  <!-- Title of error message dialog shown when the user tries to turn on Wi-Fi calling without Wi-Fi connection [CHAR LIMIT=40] -->
-  <string name="connect_to_wifi_or_web_portal_title">Wi-Fi not connected</string>
-  <!-- Error message shown when the user tries to turn on Wi-Fi calling without Wi-Fi connection [CHAR LIMIT=NONE] -->
-  <string name="connect_to_wifi_or_web_portal_message">Turn on Wi-Fi and connect to a network to use Wi-Fi calling.<xliff:g id="newline">\n</xliff:g><xliff:g id="newline">\n</xliff:g>You can set up Wi-Fi calling or update your emergency address using the mobile network.</string>
-  <!-- Button to exit current app and go to turing on Wi-Fi [CHAR LIMIT=NONE] -->
-  <string name="button_turn_on_wifi">Turn on Wi-Fi</string>
-  <!-- Button to continue Wi-Fi calling setup [CHAR LIMIT=NONE] -->
-  <string name="button_setup_web_portal">Continue Setup</string>
-
-  <!-- Do not translate. The component used to load web content on webview [CHAR LIMIT=NONE] -->
-  <string name="webview_component" translatable="false">com.android.imsserviceentitlement/.WfcQnsActivationActivity</string>
-  <!-- Do not translate. The QNS package name [CHAR LIMIT=NONE] -->
-  <string name="qns_package" translatable="false">com.android.telephony.qns</string>
-  <!-- Do not translate. The package used to bind custom tabs service[CHAR LIMIT=NONE] -->
-  <string name="custom_tabs_service_package_name" translatable="false" >com.android.chrome"</string>
-</resources>
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/AccessNetworkEvaluator.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/AccessNetworkEvaluator.java
deleted file mode 100644
index 44e5972..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/AccessNetworkEvaluator.java
+++ /dev/null
@@ -1,2210 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import android.content.Context;
-import android.net.NetworkCapabilities;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Looper;
-import android.os.Message;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.AccessNetworkConstants.AccessNetworkType;
-import android.telephony.TelephonyManager;
-import android.telephony.data.ApnSetting;
-import android.telephony.ims.ImsReasonInfo;
-import android.telephony.ims.ProvisioningManager;
-import android.util.Log;
-
-import com.android.internal.annotations.VisibleForTesting;
-import com.android.telephony.qns.AccessNetworkSelectionPolicy.GuardingPreCondition;
-import com.android.telephony.qns.AccessNetworkSelectionPolicy.PreCondition;
-import com.android.telephony.qns.IwlanNetworkStatusTracker.IwlanAvailabilityInfo;
-import com.android.telephony.qns.QualifiedNetworksServiceImpl.QualifiedNetworksInfo;
-
-import java.io.PrintWriter;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.concurrent.Executor;
-
-/**
- * AccessNetworkEvaluator evaluates prioritized AccessNetwork list base on Cellular/Wi-Fi network
- * status and configurations from carrier/user.
- */
-class AccessNetworkEvaluator {
-    private static final boolean DBG = true;
-    private static final int EVENT_BASE = 10000;
-    private static final int EVENT_IWLAN_NETWORK_STATUS_CHANGED = EVENT_BASE;
-    private static final int EVENT_QNS_TELEPHONY_INFO_CHANGED = EVENT_BASE + 1;
-    private static final int EVENT_RESTRICT_INFO_CHANGED = EVENT_BASE + 4;
-    private static final int EVENT_SET_CALL_TYPE = EVENT_BASE + 5;
-    private static final int EVENT_DATA_CONNECTION_STATE_CHANGED = EVENT_BASE + 6;
-    private static final int EVENT_PROVISIONING_INFO_CHANGED = EVENT_BASE + 8;
-    private static final int EVENT_IMS_REGISTRATION_STATE_CHANGED = EVENT_BASE + 10;
-    private static final int EVENT_WIFI_RTT_STATUS_CHANGED = EVENT_BASE + 11;
-    private static final int EVENT_SIP_DIALOG_SESSION_STATE_CHANGED = EVENT_BASE + 12;
-    private static final int EVENT_IMS_CALL_DISCONNECT_CAUSE_CHANGED = EVENT_BASE + 13;
-    private static final int EVALUATE_SPECIFIC_REASON_NONE = 0;
-    private static final int EVALUATE_SPECIFIC_REASON_IWLAN_DISABLE = 1;
-    private static final int EVALUATE_SPECIFIC_REASON_DATA_DISCONNECTED = 2;
-    private static final int EVALUATE_SPECIFIC_REASON_DATA_FAILED = 3;
-    private static final int EVALUATE_SPECIFIC_REASON_DATA_CONNECTED = 4;
-
-    protected final int mSlotIndex;
-    protected final Context mContext;
-    private final String mLogTag;
-    private final int mNetCapability;
-    @VisibleForTesting
-    protected final Handler mHandler;
-    private final HandlerThread mHandlerThread;
-    private final RestrictManager mRestrictManager;
-    protected QnsCarrierConfigManager mConfigManager;
-    protected QnsComponents mQnsComponents;
-    protected QualityMonitor mWifiQualityMonitor;
-    protected QualityMonitor mCellularQualityMonitor;
-    protected CellularNetworkStatusTracker mCellularNetworkStatusTracker;
-    protected IwlanNetworkStatusTracker mIwlanNetworkStatusTracker;
-    protected DataConnectionStatusTracker mDataConnectionStatusTracker;
-    protected QnsEventDispatcher mQnsEventDispatcher;
-    protected QnsCallStatusTracker mCallStatusTracker;
-    protected QnsProvisioningListener mQnsProvisioningListener;
-    protected QnsImsManager mQnsImsManager;
-    protected WifiBackhaulMonitor mWifiBackhaulMonitor;
-    protected QnsTelephonyListener mQnsTelephonyListener;
-    // for metric
-    protected QnsMetrics mQnsMetrics;
-
-    protected int mCellularAccessNetworkType = AccessNetworkType.UNKNOWN;
-    protected boolean mCellularAvailable = false;
-    protected boolean mIwlanAvailable = false;
-    private boolean mIsCrossWfc = false;
-
-    protected QnsRegistrantList mQualifiedNetworksChangedRegistrants = new QnsRegistrantList();
-    // pre-conditions
-    private int mCallType;
-    private int mCoverage;
-    private int mLatestAvailableCellularAccessNetwork = AccessNetworkType.UNKNOWN;
-    private List<AccessNetworkSelectionPolicy> mAccessNetworkSelectionPolicies = new ArrayList<>();
-    private List<Integer> mLastQualifiedAccessNetworkTypes;
-    private boolean mIsNotifiedLastQualifiedAccessNetworkTypes = false;
-    private boolean mWfcPlatformEnabled = false;
-    private boolean mSettingWfcEnabled = false;
-    private int mSettingWfcMode = QnsConstants.CELL_PREF;
-    private boolean mSettingWfcRoamingEnabled = false;
-    private int mSettingWfcRoamingMode = QnsConstants.WIFI_PREF;
-    private boolean mAllowIwlanForWfcActivation = false;
-    private Map<PreCondition, List<AccessNetworkSelectionPolicy>> mAnspPolicyMap = null;
-    private ThresholdListener mThresholdListener;
-    private boolean mInitialized = false;
-    private boolean mIsRttCheckSuccess = false;
-    private QnsProvisioningListener.QnsProvisioningInfo mLastProvisioningInfo =
-            new QnsProvisioningListener.QnsProvisioningInfo();
-    private boolean mSipDialogSessionState = false;
-    private int mCachedTransportTypeForEmergencyInitialConnect =
-            AccessNetworkConstants.TRANSPORT_TYPE_INVALID;
-    private int mLastEvaluateSpecificReason = EVALUATE_SPECIFIC_REASON_NONE;
-
-    AccessNetworkEvaluator(QnsComponents qnsComponents, int netCapability, int slotIndex) {
-        mNetCapability = netCapability;
-        mQnsComponents = qnsComponents;
-        mSlotIndex = slotIndex;
-        mContext = mQnsComponents.getContext();
-        mLogTag =
-                QnsConstants.QNS_TAG
-                        + "_"
-                        + AccessNetworkEvaluator.class.getSimpleName()
-                        + "_"
-                        + mSlotIndex
-                        + "_"
-                        + QnsUtils.getNameOfNetCapability(netCapability);
-        // load configurations & sort by purpose.
-
-        log("created AccessNetworkEvaluator");
-
-        // make handler to handle events for evaluate available AccessNetworks.
-        mHandlerThread =
-                new HandlerThread(AccessNetworkEvaluator.class.getSimpleName() + mNetCapability);
-        mHandlerThread.start();
-        mHandler = new EvaluatorEventHandler(mHandlerThread.getLooper());
-        Executor executor = new QnsUtils.QnsExecutor(mHandler);
-
-        mConfigManager = mQnsComponents.getQnsCarrierConfigManager(mSlotIndex);
-        mCallStatusTracker = mQnsComponents.getQnsCallStatusTracker(mSlotIndex);
-        mQnsProvisioningListener = mQnsComponents.getQnsProvisioningListener(mSlotIndex);
-        mIwlanNetworkStatusTracker = mQnsComponents.getIwlanNetworkStatusTracker();
-        mDataConnectionStatusTracker =
-                new DataConnectionStatusTracker(
-                        mQnsComponents.getQnsTelephonyListener(mSlotIndex),
-                        mHandlerThread.getLooper(),
-                        mSlotIndex,
-                        mNetCapability);
-        mQnsImsManager = mQnsComponents.getQnsImsManager(mSlotIndex);
-        mWifiBackhaulMonitor = mQnsComponents.getWifiBackhaulMonitor(mSlotIndex);
-        mQnsTelephonyListener = mQnsComponents.getQnsTelephonyListener(mSlotIndex);
-        mQnsMetrics = mQnsComponents.getQnsMetrics();
-
-        // Pre-Conditions
-        mCellularNetworkStatusTracker = mQnsComponents.getCellularNetworkStatusTracker(mSlotIndex);
-        mQnsEventDispatcher = mQnsComponents.getQnsEventDispatcher(mSlotIndex);
-        mThresholdListener = new ThresholdListener(executor);
-
-        // Post-Conditions
-        mWifiQualityMonitor = mQnsComponents.getWifiQualityMonitor();
-        mCellularQualityMonitor = mQnsComponents.getCellularQualityMonitor(mSlotIndex);
-
-        // Evaluates
-        mRestrictManager =
-                new RestrictManager(
-                        mQnsComponents,
-                        mHandler.getLooper(),
-                        mNetCapability,
-                        mDataConnectionStatusTracker,
-                        mSlotIndex);
-
-        mHandler.post(() -> buildAccessNetworkSelectionPolicy(false));
-        initLastNotifiedQualifiedNetwork();
-        initSettings();
-        registerListeners();
-    }
-
-    @VisibleForTesting
-    AccessNetworkEvaluator(
-            QnsComponents qnsComponents,
-            int netCapability,
-            RestrictManager restrictManager,
-            DataConnectionStatusTracker dataConnectionStatusTracker,
-            int slotIndex) {
-        mQnsComponents = qnsComponents;
-        mSlotIndex = slotIndex;
-        mLogTag =
-                QnsConstants.QNS_TAG
-                        + "_"
-                        + AccessNetworkEvaluator.class.getSimpleName()
-                        + "_"
-                        + mSlotIndex
-                        + "_"
-                        + QnsUtils.getNameOfNetCapability(netCapability);
-        // load configurations & sort by purpose.
-        mNetCapability = netCapability;
-        mContext = mQnsComponents.getContext();
-        mRestrictManager = restrictManager;
-        mConfigManager = mQnsComponents.getQnsCarrierConfigManager(mSlotIndex);
-        mWifiQualityMonitor = mQnsComponents.getWifiQualityMonitor();
-        mCellularQualityMonitor = mQnsComponents.getCellularQualityMonitor(mSlotIndex);
-        mCellularNetworkStatusTracker = mQnsComponents.getCellularNetworkStatusTracker(mSlotIndex);
-        mIwlanNetworkStatusTracker = mQnsComponents.getIwlanNetworkStatusTracker();
-        mDataConnectionStatusTracker = dataConnectionStatusTracker;
-        mQnsEventDispatcher = mQnsComponents.getQnsEventDispatcher(mSlotIndex);
-        mCallStatusTracker = mQnsComponents.getQnsCallStatusTracker(mSlotIndex);
-        mQnsProvisioningListener = mQnsComponents.getQnsProvisioningListener(mSlotIndex);
-        mQnsImsManager = mQnsComponents.getQnsImsManager(mSlotIndex);
-        mWifiBackhaulMonitor = mQnsComponents.getWifiBackhaulMonitor(mSlotIndex);
-        mQnsTelephonyListener = mQnsComponents.getQnsTelephonyListener(mSlotIndex);
-        mQnsMetrics = mQnsComponents.getQnsMetrics();
-        mHandlerThread =
-                new HandlerThread(AccessNetworkEvaluator.class.getSimpleName() + mNetCapability);
-        mHandlerThread.start();
-        mHandler = new EvaluatorEventHandler(mHandlerThread.getLooper());
-        mHandler.post(() -> buildAccessNetworkSelectionPolicy(false));
-        initLastNotifiedQualifiedNetwork();
-        initSettings();
-        registerListeners();
-    }
-
-    void rebuild() {
-        log("rebuild");
-        initSettings();
-        mLastProvisioningInfo.clear();
-        mConfigManager.setQnsProvisioningInfo(mLastProvisioningInfo);
-        mHandler.post(() -> buildAccessNetworkSelectionPolicy(true));
-        mRestrictManager.clearRestrictions();
-        if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS) {
-            if (mWifiBackhaulMonitor.isRttCheckEnabled()) {
-                mWifiBackhaulMonitor.registerForRttStatusChange(
-                        mHandler, EVENT_WIFI_RTT_STATUS_CHANGED);
-            } else {
-                mWifiBackhaulMonitor.clearAll();
-            }
-        }
-        reportQualifiedNetwork(getInitialAccessNetworkTypes());
-        initLastNotifiedQualifiedNetwork();
-        unregisterThresholdToQualityMonitor();
-
-        if (isAllowed(AccessNetworkConstants.TRANSPORT_TYPE_WLAN)
-                && evaluateAvailability(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        isAllowed(AccessNetworkConstants.TRANSPORT_TYPE_WWAN))) {
-            mHandler.post(this::evaluate);
-        }
-        mLastEvaluateSpecificReason = EVALUATE_SPECIFIC_REASON_NONE;
-    }
-
-    void close() {
-        log("close");
-        mHandler.post(this::onClose);
-        mHandlerThread.quitSafely();
-    }
-
-    private void onClose() {
-        notifyForQualifiedNetworksChanged(getInitialAccessNetworkTypes());
-        initLastNotifiedQualifiedNetwork();
-        unregisterListeners();
-        mQualifiedNetworksChangedRegistrants.removeAll();
-        mDataConnectionStatusTracker.close();
-        mRestrictManager.close();
-    }
-
-    void registerForQualifiedNetworksChanged(Handler h, int what) {
-        mInitialized = true;
-        mQualifiedNetworksChangedRegistrants.addUnique(h, what, null);
-        if (isNotifiedQualifiedAccessNetworkTypes()) {
-            if (DBG) {
-                log(
-                        "registerForQualifiedNetworksChanged, report:"
-                                + QnsUtils.getStringAccessNetworkTypes(
-                                        mLastQualifiedAccessNetworkTypes));
-            }
-            notifyForQualifiedNetworksChanged(mLastQualifiedAccessNetworkTypes);
-        }
-        mHandler.post(this::evaluate);
-    }
-
-    void unregisterForQualifiedNetworksChanged(Handler h) {
-        mQualifiedNetworksChangedRegistrants.remove(h);
-    }
-
-    private List<Integer> getInitialAccessNetworkTypes() {
-        // The framework treats empty lists as WWAN.
-        return List.of();
-    }
-
-    protected int getLastQualifiedTransportType() {
-        if (mLastQualifiedAccessNetworkTypes.size() > 0
-                && mLastQualifiedAccessNetworkTypes.get(0) == AccessNetworkType.IWLAN) {
-            return AccessNetworkConstants.TRANSPORT_TYPE_WLAN;
-        }
-        // otherwise, returns WWAN. (includes an empty list)
-        return AccessNetworkConstants.TRANSPORT_TYPE_WWAN;
-    }
-
-    protected boolean isNotifiedQualifiedAccessNetworkTypes() {
-        return mIsNotifiedLastQualifiedAccessNetworkTypes;
-    }
-
-    protected void initLastNotifiedQualifiedNetwork() {
-        mIsNotifiedLastQualifiedAccessNetworkTypes = false;
-        mLastQualifiedAccessNetworkTypes = getInitialAccessNetworkTypes();
-        log(
-                "initLastNotifiedQualifiedNetwork mLastQualifiedAccessNetworkTypes:"
-                        + QnsUtils.getStringAccessNetworkTypes(mLastQualifiedAccessNetworkTypes));
-    }
-
-    protected boolean equalsLastNotifiedQualifiedNetwork(List<Integer> accessNetworkTypes) {
-        return mLastQualifiedAccessNetworkTypes.equals(accessNetworkTypes);
-    }
-
-    protected void updateLastNotifiedQualifiedNetwork(List<Integer> accessNetworkTypes) {
-        mLastQualifiedAccessNetworkTypes = accessNetworkTypes;
-        mRestrictManager.updateLastNotifiedTransportType(getLastQualifiedTransportType());
-        log(
-                "updateLastNotifiedQualifiedNetwork mLastQualifiedAccessNetworkTypes:"
-                        + QnsUtils.getStringAccessNetworkTypes(mLastQualifiedAccessNetworkTypes));
-    }
-
-    protected void notifyForQualifiedNetworksChanged(List<Integer> accessNetworkTypes) {
-        mIsNotifiedLastQualifiedAccessNetworkTypes = true;
-        QualifiedNetworksInfo info = new QualifiedNetworksInfo(mNetCapability, accessNetworkTypes);
-        QnsAsyncResult ar = new QnsAsyncResult(null, info, null);
-        mQualifiedNetworksChangedRegistrants.notifyRegistrants(ar);
-
-        // metrics
-        sendMetricsForQualifiedNetworks(info);
-    }
-
-    private void initSettings() {
-        mWfcPlatformEnabled = QnsUtils.isWfcEnabledByPlatform(mQnsImsManager);
-        mSettingWfcEnabled = QnsUtils.isWfcEnabled(mQnsImsManager, mQnsProvisioningListener, false);
-        mSettingWfcMode = QnsUtils.getWfcMode(mQnsImsManager, false);
-        mSettingWfcRoamingEnabled =
-                QnsUtils.isWfcEnabled(mQnsImsManager, mQnsProvisioningListener, true);
-        mSettingWfcRoamingMode = QnsUtils.getWfcMode(mQnsImsManager, true);
-        mAllowIwlanForWfcActivation = false;
-        mSipDialogSessionState = false;
-        mCachedTransportTypeForEmergencyInitialConnect =
-                AccessNetworkConstants.TRANSPORT_TYPE_INVALID;
-        log(
-                "WfcSettings. mWfcPlatformEnabled:"
-                        + mWfcPlatformEnabled
-                        + " WfcEnabled:"
-                        + mSettingWfcEnabled
-                        + " WfcMode:"
-                        + QnsConstants.preferenceToString(mSettingWfcMode)
-                        + " WfcRoamingEnabled:"
-                        + mSettingWfcRoamingEnabled
-                        + " WfcRoamingMode:"
-                        + QnsConstants.preferenceToString(mSettingWfcRoamingMode));
-    }
-
-    protected void registerListeners() {
-        log("registerListeners");
-        mWifiQualityMonitor.registerThresholdChange(
-                mThresholdListener, mNetCapability, null, mSlotIndex);
-        mCellularQualityMonitor.registerThresholdChange(
-                mThresholdListener, mNetCapability, null, mSlotIndex);
-        mIwlanNetworkStatusTracker.registerIwlanNetworksChanged(
-                mSlotIndex, mHandler, EVENT_IWLAN_NETWORK_STATUS_CHANGED);
-        mDataConnectionStatusTracker.registerDataConnectionStatusChanged(
-                mHandler, EVENT_DATA_CONNECTION_STATE_CHANGED);
-        mQnsImsManager.registerImsRegistrationStatusChanged(
-                mHandler, EVENT_IMS_REGISTRATION_STATE_CHANGED);
-        mQnsImsManager.registerSipDialogSessionStateChanged(
-                mHandler, EVENT_SIP_DIALOG_SESSION_STATE_CHANGED);
-        mCellularNetworkStatusTracker.registerQnsTelephonyInfoChanged(
-                mNetCapability, mHandler, EVENT_QNS_TELEPHONY_INFO_CHANGED);
-        if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS
-                || mNetCapability == NetworkCapabilities.NET_CAPABILITY_EIMS) {
-            mCallStatusTracker.registerCallTypeChangedListener(
-                    mNetCapability, mHandler, EVENT_SET_CALL_TYPE, null);
-        }
-
-        if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS) {
-            if (mWifiBackhaulMonitor.isRttCheckEnabled()) {
-                mWifiBackhaulMonitor.registerForRttStatusChange(
-                        mHandler, EVENT_WIFI_RTT_STATUS_CHANGED);
-            }
-        }
-        mQnsProvisioningListener.registerProvisioningItemInfoChanged(
-                mHandler, EVENT_PROVISIONING_INFO_CHANGED, null, true);
-        if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS) {
-            mQnsTelephonyListener.registerImsCallDropDisconnectCauseListener(
-                    mHandler, EVENT_IMS_CALL_DISCONNECT_CAUSE_CHANGED, null);
-        }
-        List<Integer> events = new ArrayList<>();
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_ENABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_DISABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_ONLY);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_CELLULAR_PREFERRED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_PREFERRED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_ENABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_DISABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_ONLY);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_MODE_TO_CELLULAR_PREFERRED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_PREFERRED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_PLATFORM_ENABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_PLATFORM_DISABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_SIM_ABSENT);
-        events.add(QnsEventDispatcher.QNS_EVENT_TRY_WFC_ACTIVATION);
-        events.add(QnsEventDispatcher.QNS_EVENT_CANCEL_TRY_WFC_ACTIVATION);
-        mQnsEventDispatcher.registerEvent(events, mHandler);
-        mRestrictManager.registerRestrictInfoChanged(mHandler, EVENT_RESTRICT_INFO_CHANGED);
-    }
-
-    protected void unregisterListeners() {
-        log("unregisterListeners");
-        mWifiQualityMonitor.unregisterThresholdChange(mNetCapability, mSlotIndex);
-        mCellularQualityMonitor.unregisterThresholdChange(mNetCapability, mSlotIndex);
-        mDataConnectionStatusTracker.unRegisterDataConnectionStatusChanged(mHandler);
-        mQnsImsManager.unregisterImsRegistrationStatusChanged(mHandler);
-        mQnsImsManager.unregisterSipDialogSessionStateChanged(mHandler);
-        mCellularNetworkStatusTracker.unregisterQnsTelephonyInfoChanged(mNetCapability, mHandler);
-        mIwlanNetworkStatusTracker.unregisterIwlanNetworksChanged(mSlotIndex, mHandler);
-        if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS
-                || mNetCapability == NetworkCapabilities.NET_CAPABILITY_EIMS) {
-            mCallStatusTracker.unregisterCallTypeChangedListener(mNetCapability, mHandler);
-            if (mWifiBackhaulMonitor.isRttCheckEnabled()) {
-                mWifiBackhaulMonitor.unRegisterForRttStatusChange(mHandler);
-            }
-        }
-        if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS) {
-            mQnsTelephonyListener.unregisterImsCallDropDisconnectCauseListener(mHandler);
-        }
-        mQnsProvisioningListener.unregisterProvisioningItemInfoChanged(mHandler);
-        mQnsEventDispatcher.unregisterEvent(mHandler);
-        mRestrictManager.unRegisterRestrictInfoChanged(mHandler);
-    }
-
-    private boolean isIwlanAvailableWithoutRestrict() {
-        return (mIwlanAvailable
-                && !mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-    }
-
-    private boolean isCellularAvailableWithoutRestrict() {
-        return (mCellularAvailable
-                && !mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-    }
-
-    protected void log(String s) {
-        Log.d(mLogTag, s);
-    }
-
-    protected void onQnsTelephonyInfoChanged(QnsTelephonyListener.QnsTelephonyInfo info) {
-        boolean needEvaluate = false;
-
-        if (info instanceof QnsTelephonyListener.QnsTelephonyInfoIms) {
-            QnsTelephonyListener.QnsTelephonyInfoIms infoIms =
-                    (QnsTelephonyListener.QnsTelephonyInfoIms) info;
-            boolean checkVoPs = false;
-            boolean volteRoamingSupported = true;
-            int cellularAccessNetworkType =
-                    QnsUtils.getCellularAccessNetworkType(
-                            infoIms.getDataRegState(), infoIms.getDataNetworkType());
-
-            int coverage = getCoverage(infoIms);
-            if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS
-                    && infoIms.isCellularAvailable()) {
-                checkVoPs = vopsCheckRequired(cellularAccessNetworkType, coverage, mCallType);
-                volteRoamingSupported = mConfigManager.isVolteRoamingSupported(coverage);
-            }
-            boolean checkBarring = mConfigManager.isServiceBarringCheckSupported();
-            if (DBG) {
-                log(
-                        "checkVoPs:"
-                                + checkVoPs
-                                + ", checkBarring:"
-                                + checkBarring
-                                + ", volteRoamingSupported:"
-                                + volteRoamingSupported);
-            }
-            boolean cellAvailable =
-                    infoIms.isCellularAvailable(
-                            mNetCapability, checkVoPs, checkBarring, volteRoamingSupported);
-            if (mCellularAvailable != cellAvailable) {
-                mCellularAvailable = cellAvailable;
-                needEvaluate = true;
-                log("onQnsTelephonyInfoChanged cellularAvailableIms:" + mCellularAvailable);
-            }
-        } else if (mCellularAvailable != info.isCellularAvailable()) {
-            mCellularAvailable = info.isCellularAvailable();
-            needEvaluate = true;
-            log("onQnsTelephonyInfoChanged cellularAvailable:" + mCellularAvailable);
-        }
-        if (mCellularAccessNetworkType
-                != QnsUtils.getCellularAccessNetworkType(
-                        info.getDataRegState(), info.getDataNetworkType())) {
-            mCellularAccessNetworkType =
-                    QnsUtils.getCellularAccessNetworkType(
-                            info.getDataRegState(), info.getDataNetworkType());
-            mRestrictManager.setCellularAccessNetwork(mCellularAccessNetworkType);
-            if (mCellularAccessNetworkType != AccessNetworkType.UNKNOWN) {
-                mLatestAvailableCellularAccessNetwork = mCellularAccessNetworkType;
-            }
-
-            needEvaluate = true;
-            log(
-                    "onQnsTelephonyInfoChanged cellularAccessNetworkType:"
-                            + mCellularAccessNetworkType);
-        }
-        int coverage = getCoverage(info);
-        if (mCoverage != coverage) {
-            mCoverage = coverage;
-            needEvaluate = true;
-            mRestrictManager.setCellularCoverage(mCoverage);
-            log("onQnsTelephonyInfoChanged Coverage:" + mCoverage);
-        }
-
-        if (needEvaluate) {
-            evaluate();
-        }
-    }
-
-    @VisibleForTesting
-    int getCoverage(QnsTelephonyListener.QnsTelephonyInfo info) {
-        if (DBG) {
-            log("getCoverage roaming=" + info.isCoverage());
-        }
-        if (info.isCoverage()) {
-            return QnsConstants.COVERAGE_ROAM;
-        } else {
-            return QnsConstants.COVERAGE_HOME;
-        }
-    }
-
-    protected void onIwlanNetworkStatusChanged(IwlanAvailabilityInfo info) {
-        if (info != null) {
-            if (mIwlanAvailable != info.getIwlanAvailable()) {
-                mIwlanAvailable = info.getIwlanAvailable();
-            }
-            mIsCrossWfc = info.isCrossWfc();
-            log("onIwlanNetworkStatusChanged IwlanAvailable:" + mIwlanAvailable);
-            if (info.getNotifyIwlanDisabled()) {
-                evaluate(EVALUATE_SPECIFIC_REASON_IWLAN_DISABLE);
-            } else {
-                evaluate();
-            }
-        }
-    }
-
-    private void onWfcEnabledChanged(boolean enabled, boolean roaming) {
-        StringBuilder sb = new StringBuilder("onWfcEnabledChanged");
-        sb.append(" enabled:").append(enabled);
-        sb.append(" coverage:")
-                .append(
-                        QnsConstants.coverageToString(
-                                roaming ? QnsConstants.COVERAGE_ROAM : QnsConstants.COVERAGE_HOME));
-
-        boolean needEvaluate = false;
-        if (!roaming && mSettingWfcEnabled != enabled) {
-            if (mCoverage == QnsConstants.COVERAGE_HOME) {
-                needEvaluate = true;
-            }
-            mSettingWfcEnabled = enabled;
-            sb.append(" mSettingWfcEnabled:").append(mSettingWfcEnabled);
-        } else if (roaming && mSettingWfcRoamingEnabled != enabled) {
-            if (mCoverage == QnsConstants.COVERAGE_ROAM) {
-                needEvaluate = true;
-            }
-            mSettingWfcRoamingEnabled = enabled;
-            sb.append(" mSettingWfcRoamingEnabled:").append(mSettingWfcRoamingEnabled);
-        }
-
-        if (needEvaluate) {
-            sb.append(" evaluate.");
-            log(sb.toString());
-            if (enabled) {
-                evaluate();
-            } else {
-                evaluate(EVALUATE_SPECIFIC_REASON_IWLAN_DISABLE);
-            }
-        } else {
-            log(sb.toString());
-        }
-    }
-
-    private void onWfcModeChanged(int mode, boolean roaming) {
-        StringBuilder sb = new StringBuilder("onWfcModeChanged");
-        sb.append(" mode:").append(QnsConstants.preferenceToString(mode));
-        sb.append(" coverage:")
-                .append(
-                        QnsConstants.coverageToString(
-                                roaming ? QnsConstants.COVERAGE_ROAM : QnsConstants.COVERAGE_HOME));
-
-        boolean needEvaluate = false;
-        if (!roaming && mSettingWfcMode != mode) {
-            if (mCoverage == QnsConstants.COVERAGE_HOME) {
-                needEvaluate = true;
-            }
-            mSettingWfcMode = mode;
-            sb.append(" mSettingWfcMode:").append(QnsConstants.preferenceToString(mSettingWfcMode));
-        } else if (roaming && mSettingWfcRoamingMode != mode) {
-            if (mCoverage == QnsConstants.COVERAGE_ROAM) {
-                needEvaluate = true;
-            }
-            mSettingWfcRoamingMode = mode;
-            sb.append(" mSettingWfcRoamingMode:");
-            sb.append(QnsConstants.preferenceToString(mSettingWfcRoamingMode));
-        }
-
-        if (needEvaluate) {
-            sb.append(" evaluate.");
-            log(sb.toString());
-            evaluate();
-        } else {
-            log(sb.toString());
-        }
-    }
-
-    private void onWfcPlatformChanged(boolean bWfcPlatformEnabled) {
-        StringBuilder sb = new StringBuilder("onWfcPlatformChanged");
-        sb.append(" bWfcPlatformEnabled:").append(bWfcPlatformEnabled);
-        if (mWfcPlatformEnabled == bWfcPlatformEnabled) {
-            sb.append(" no changes");
-            log(sb.toString());
-        } else {
-            mWfcPlatformEnabled = bWfcPlatformEnabled;
-            if (bWfcPlatformEnabled) {
-                sb.append(" evaluate.");
-                log(sb.toString());
-                evaluate();
-            } else {
-                sb.append(" report cellular as qualified network directly.");
-                log(sb.toString());
-                reportQualifiedNetwork(new ArrayList<>(List.of(mCellularAccessNetworkType)));
-            }
-        }
-    }
-
-    private void onSimAbsent() {
-        log("onSimAbsent");
-
-        // report default qualified access network.
-        reportQualifiedNetwork(getInitialAccessNetworkTypes());
-    }
-
-    private void onRestrictInfoChanged() {
-        // TODO
-        log("onRestrictInfoChanged");
-        evaluate();
-    }
-
-    @VisibleForTesting
-    void onTryWfcConnectionStateChanged(boolean isEnabled) {
-        log("onTryWfcConnectionStateChanged enabled:" + isEnabled);
-        int timeout = mConfigManager.getVowifiRegistrationTimerForVowifiActivation();
-
-        if (mAllowIwlanForWfcActivation == isEnabled) {
-            return;
-        }
-        if (isEnabled) {
-            mHandler.sendEmptyMessageDelayed(
-                    QnsEventDispatcher.QNS_EVENT_CANCEL_TRY_WFC_ACTIVATION,
-                    timeout + /* milliseconds */ 3000);
-        } else {
-            mHandler.removeMessages(QnsEventDispatcher.QNS_EVENT_CANCEL_TRY_WFC_ACTIVATION);
-        }
-        mAllowIwlanForWfcActivation = isEnabled;
-        evaluate();
-    }
-
-    @VisibleForTesting
-    void onSetCallType(@QnsConstants.QnsCallType int callType) {
-        if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS
-                && callType == QnsConstants.CALL_TYPE_EMERGENCY) {
-            if (!mDataConnectionStatusTracker.isActiveState()) return;
-        }
-
-        // metrics
-        sendMetricsForCallTypeChanged(mCallType, callType);
-
-        mCallType = callType;
-        mRestrictManager.setQnsCallType(mCallType);
-        log("onSetCallType CallType:" + mCallType);
-
-        // call type from service manager API
-
-        // TODO
-        evaluate();
-    }
-
-    void onEmergencyPreferredTransportTypeChanged(
-            @AccessNetworkConstants.TransportType int transport) {
-        if (mNetCapability != NetworkCapabilities.NET_CAPABILITY_EIMS) {
-            return;
-        }
-        mHandler.post(() -> {
-                    log(
-                            "onEmergencyPreferredTransportTypeChanged transport:"
-                                    + QnsConstants.transportTypeToString(transport));
-                    if (mDataConnectionStatusTracker.isInactiveState()
-                            || (mDataConnectionStatusTracker.isActiveState()
-                                    && mCallType == QnsConstants.CALL_TYPE_IDLE)) {
-                        // If data network state is inactive OR active but call is not active yet,
-                        // QNS will follow domain selection's decision.
-                        enforceNotifyQualifiedNetworksWithTransportType(transport);
-                    } else {
-                        log(
-                                "cache transportType for emergency: "
-                                        + QnsConstants.transportTypeToString(transport));
-                        mCachedTransportTypeForEmergencyInitialConnect = transport;
-                    }
-                }
-        );
-    }
-
-    private void enforceNotifyQualifiedNetworksWithTransportType(
-            @AccessNetworkConstants.TransportType int transportType) {
-        List<Integer> accessNetworkTypes = new ArrayList<>();
-        if (transportType == AccessNetworkConstants.TRANSPORT_TYPE_WLAN) {
-            accessNetworkTypes.add(AccessNetworkType.IWLAN);
-        } else if (mCellularAccessNetworkType != AccessNetworkType.UNKNOWN) {
-            accessNetworkTypes.add(mCellularAccessNetworkType);
-        }
-        updateLastNotifiedQualifiedNetwork(accessNetworkTypes);
-        notifyForQualifiedNetworksChanged(accessNetworkTypes);
-    }
-
-    @VisibleForTesting
-    void onDataConnectionStateChanged(
-            DataConnectionStatusTracker.DataConnectionChangedInfo info) {
-        log("onDataConnectionStateChanged info:" + info);
-        boolean needEvaluate = false;
-        int evaluateSpecificReason = EVALUATE_SPECIFIC_REASON_NONE;
-        switch (info.getEvent()) {
-            case DataConnectionStatusTracker.EVENT_DATA_CONNECTION_DISCONNECTED:
-                evaluateSpecificReason = EVALUATE_SPECIFIC_REASON_DATA_DISCONNECTED;
-                if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_EIMS) {
-                    // If FWK guided emergency's transport type during data connected state, notify
-                    // the transport type when the data connection is disconnected.
-                    notifyCachedTransportTypeForEmergency();
-                    // When cellular is not available, CellularQualityMonitor will stop listening to
-                    // TelephonyCallback. Thresholds for Emergency apn may not be reset as ANE for
-                    // emergency only evaluates while data is connected. CellularQualityMonitor will
-                    // not listen to TelephonyCallback again until the set of threshold values
-                    // changed. Resetting thresholds for emergency after the emergency connection
-                    // disconnects.
-                    unregisterThresholdToQualityMonitor();
-                } else {
-                    needEvaluate = true;
-                    initLastNotifiedQualifiedNetwork();
-                }
-                break;
-            case DataConnectionStatusTracker.EVENT_DATA_CONNECTION_CONNECTED:
-                evaluateSpecificReason = EVALUATE_SPECIFIC_REASON_DATA_CONNECTED;
-                mHandler.post(() -> onDataConnectionConnected(info.getTransportType()));
-                break;
-            case DataConnectionStatusTracker.EVENT_DATA_CONNECTION_FAILED:
-                evaluateSpecificReason = EVALUATE_SPECIFIC_REASON_DATA_FAILED;
-                if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_EIMS) {
-                    // If FWK guided emergency's transport type during data connecting state, notify
-                    // the transport type when the data connection is failed.
-                    notifyCachedTransportTypeForEmergency();
-                    // When cellular is not available, CellularQualityMonitor will stop listening to
-                    // TelephonyCallback. Thresholds for Emergency apn may not be reset as ANE for
-                    // emergency only evaluates while data is connected. CellularQualityMonitor will
-                    // not listen to TelephonyCallback again until the set of threshold values
-                    // changed. Resetting thresholds for emergency after the emergency connection
-                    // disconnects.
-                    unregisterThresholdToQualityMonitor();
-                } else {
-                    needEvaluate = true;
-                }
-                break;
-        }
-
-        // metrics
-        sendMetricsForDataConnectionChanged(info);
-
-        if (needEvaluate) {
-            evaluate(evaluateSpecificReason);
-        }
-    }
-
-    private void notifyCachedTransportTypeForEmergency() {
-        if (mCachedTransportTypeForEmergencyInitialConnect
-                != AccessNetworkConstants.TRANSPORT_TYPE_INVALID) {
-            enforceNotifyQualifiedNetworksWithTransportType(
-                    mCachedTransportTypeForEmergencyInitialConnect);
-            mCachedTransportTypeForEmergencyInitialConnect =
-                    AccessNetworkConstants.TRANSPORT_TYPE_INVALID;
-        }
-    }
-
-    private void onDataConnectionConnected(int transportType) {
-        int otherTransportType;
-        if (DBG) {
-            log("onDataConnectionConnected :" + QnsConstants.transportTypeToString(transportType));
-        }
-        if (transportType == AccessNetworkConstants.TRANSPORT_TYPE_INVALID) {
-            log("Error: onDataConnectionConnected invalid transport type.");
-            return;
-        } else {
-            otherTransportType =
-                    transportType == AccessNetworkConstants.TRANSPORT_TYPE_WLAN
-                            ? AccessNetworkConstants.TRANSPORT_TYPE_WWAN
-                            : AccessNetworkConstants.TRANSPORT_TYPE_WLAN;
-        }
-        if (!mRestrictManager.isRestricted(otherTransportType)) {
-            evaluate();
-        } // else case : evaluate() will process when restrictions released.
-    }
-
-    protected void onProvisioningInfoChanged(QnsProvisioningListener.QnsProvisioningInfo info) {
-        boolean needBuildAnsp = false;
-        boolean needEvaluate = false;
-
-        log("onProvisioningInfoChanged info:" + info);
-
-        if (!info.equalsIntegerItem(
-                mLastProvisioningInfo, ProvisioningManager.KEY_LTE_THRESHOLD_1)) {
-            log(
-                    "onProvisioningInfoChanged, KEY_LTE_THRESHOLD_1("
-                            + ProvisioningManager.KEY_LTE_THRESHOLD_1
-                            + ") is provisioned to "
-                            + info.getIntegerItem(ProvisioningManager.KEY_LTE_THRESHOLD_1));
-            mConfigManager.setQnsProvisioningInfo(info);
-            needBuildAnsp = true;
-            needEvaluate = true;
-        }
-        if (!info.equalsIntegerItem(
-                mLastProvisioningInfo, ProvisioningManager.KEY_LTE_THRESHOLD_2)) {
-            log(
-                    "onProvisioningInfoChanged, KEY_LTE_THRESHOLD_2("
-                            + ProvisioningManager.KEY_LTE_THRESHOLD_2
-                            + ") is provisioned to "
-                            + info.getIntegerItem(ProvisioningManager.KEY_LTE_THRESHOLD_2));
-            mConfigManager.setQnsProvisioningInfo(info);
-            needBuildAnsp = true;
-            needEvaluate = true;
-        }
-        if (!info.equalsIntegerItem(
-                mLastProvisioningInfo, ProvisioningManager.KEY_LTE_THRESHOLD_3)) {
-            log(
-                    "onProvisioningInfoChanged, KEY_LTE_THRESHOLD_3("
-                            + ProvisioningManager.KEY_LTE_THRESHOLD_3
-                            + ") is provisioned to "
-                            + info.getIntegerItem(ProvisioningManager.KEY_LTE_THRESHOLD_3));
-            mConfigManager.setQnsProvisioningInfo(info);
-            needBuildAnsp = true;
-            needEvaluate = true;
-        }
-        if (!info.equalsIntegerItem(
-                mLastProvisioningInfo, ProvisioningManager.KEY_WIFI_THRESHOLD_A)) {
-            log(
-                    "onProvisioningInfoChanged, KEY_WIFI_THRESHOLD_A("
-                            + ProvisioningManager.KEY_WIFI_THRESHOLD_A
-                            + ") is provisioned to "
-                            + info.getIntegerItem(ProvisioningManager.KEY_WIFI_THRESHOLD_A));
-            mConfigManager.setQnsProvisioningInfo(info);
-            needBuildAnsp = true;
-            needEvaluate = true;
-        }
-        if (!info.equalsIntegerItem(
-                mLastProvisioningInfo, ProvisioningManager.KEY_WIFI_THRESHOLD_B)) {
-            log(
-                    "onProvisioningInfoChanged, KEY_WIFI_THRESHOLD_B("
-                            + ProvisioningManager.KEY_WIFI_THRESHOLD_B
-                            + ") is provisioned to "
-                            + info.getIntegerItem(ProvisioningManager.KEY_WIFI_THRESHOLD_B));
-            mConfigManager.setQnsProvisioningInfo(info);
-            needBuildAnsp = true;
-            needEvaluate = true;
-        }
-
-        if (!info.equalsIntegerItem(
-                mLastProvisioningInfo, ProvisioningManager.KEY_LTE_EPDG_TIMER_SEC)) {
-            log(
-                    "onProvisioningInfoChanged, KEY_LTE_EPDG_TIMER_SEC("
-                            + ProvisioningManager.KEY_LTE_EPDG_TIMER_SEC
-                            + ") is provisioned to "
-                            + info.getIntegerItem(ProvisioningManager.KEY_LTE_EPDG_TIMER_SEC));
-            mConfigManager.setQnsProvisioningInfo(info);
-            needEvaluate = true;
-        }
-        if (!info.equalsIntegerItem(
-                mLastProvisioningInfo, ProvisioningManager.KEY_WIFI_EPDG_TIMER_SEC)) {
-            log(
-                    "onProvisioningInfoChanged, KEY_WIFI_EPDG_TIMER_SEC("
-                            + ProvisioningManager.KEY_WIFI_EPDG_TIMER_SEC
-                            + ") is provisioned to "
-                            + info.getIntegerItem(ProvisioningManager.KEY_WIFI_EPDG_TIMER_SEC));
-            mConfigManager.setQnsProvisioningInfo(info);
-            needEvaluate = true;
-        }
-
-        mLastProvisioningInfo = info;
-
-        if (needBuildAnsp) {
-            buildAccessNetworkSelectionPolicy(true);
-        }
-        if (needEvaluate) {
-            evaluate();
-        }
-
-        /* TODO to be checked
-        ProvisioningManager.KEY_VOLTE_PROVISIONING_STATUS
-        ProvisioningManager.KEY_VOICE_OVER_WIFI_ENTITLEMENT_ID
-        */
-    }
-
-    private void onImsRegStateChanged(QnsImsManager.ImsRegistrationState imsRegEvent) {
-        if (mConfigManager.getRatPreference(mNetCapability)
-                != QnsConstants.RAT_PREFERENCE_WIFI_WHEN_WFC_AVAILABLE) {
-            return;
-        }
-        int transportType = imsRegEvent.getTransportType();
-        int event = imsRegEvent.getEvent();
-        if (event == QnsConstants.IMS_REGISTRATION_CHANGED_REGISTERED
-                || event == QnsConstants.IMS_REGISTRATION_CHANGED_UNREGISTERED) {
-            log(
-                    "onImsRegStateChanged, "
-                            + QnsConstants.transportTypeToString(transportType)
-                            + ","
-                            + QnsConstants.imsRegistrationEventToString(event));
-            evaluate();
-        }
-    }
-
-    protected void onSipDialogSessionStateChanged(boolean isActive) {
-        if (mConfigManager.getSipDialogSessionPolicy()
-                == QnsConstants.SIP_DIALOG_SESSION_POLICY_NONE) {
-            mSipDialogSessionState = false;
-            return;
-        }
-        if (mSipDialogSessionState != isActive) {
-            mSipDialogSessionState = isActive;
-            log("onSipDialogSessionStateChanged isActive:" + isActive);
-            evaluate();
-        }
-    }
-
-    protected void onImsCallDisconnectCauseChanged(ImsReasonInfo imsReasonInfo) {
-        if (imsReasonInfo == null) {
-            return;
-        }
-        if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS
-                && imsReasonInfo.getCode() == ImsReasonInfo.CODE_MEDIA_NO_DATA) {
-            log(
-                    "onImsCallDisconnectCauseChanged: iwlanAvailable="
-                            + mIwlanAvailable
-                            + " cellularAvailable="
-                            + mCellularAvailable
-                            + " imsReasonInfo="
-                            + imsReasonInfo);
-            if (mIwlanAvailable && mCellularAvailable) {
-                // metrics
-                sendMetricsForImsCallDropStats();
-            }
-        }
-    }
-
-    protected void onCellularQualityChanged(Threshold[] ths) {
-        if (ths == null || ths.length == 0) {
-            log("onCellularQualityChanged: E threshold is null");
-            return;
-        }
-        log("onCellularQualityChanged Threshold:" + Arrays.toString(ths));
-        // TODO
-        evaluate();
-    }
-
-    protected void onWiFiQualityChanged(Threshold[] ths) {
-        if (ths == null || ths.length == 0) {
-            log("onCellularQualityChanged: E threshold is null");
-            return;
-        }
-        log("onWiFiQualityChanged Threshold:" + Arrays.toString(ths));
-        // TODO
-        evaluate();
-    }
-
-    private void onRttStatusChanged(boolean result) {
-        log("onRttStatusChanged status: " + result);
-        if (result != mIsRttCheckSuccess) {
-            mIsRttCheckSuccess = result;
-            if (mIsRttCheckSuccess) {
-                evaluate();
-            }
-        }
-    }
-
-    protected boolean isWfcEnabled() {
-
-        validateWfcSettingsAndUpdate();
-
-        if (mAllowIwlanForWfcActivation) {
-            return true;
-        }
-        if (!mWfcPlatformEnabled) {
-            log("isWfcPlatformEnabled:false");
-            return false;
-        }
-        if (mCoverage == QnsConstants.COVERAGE_HOME && mSettingWfcEnabled) {
-            return true;
-        }
-        if ((mCoverage == QnsConstants.COVERAGE_ROAM
-                        || mIwlanNetworkStatusTracker.isInternationalRoaming(mSlotIndex))
-                && mSettingWfcRoamingEnabled) {
-            return true;
-        }
-
-        if (mConfigManager.allowImsOverIwlanCellularLimitedCase()
-                && !isAccessNetworkAllowed(mCellularAccessNetworkType, mNetCapability)
-                && mCallType == QnsConstants.CALL_TYPE_IDLE
-                && mIwlanAvailable) {
-            log("isWfcEnabled:true for idle, allow wfc");
-            return true;
-        }
-
-        if (mConfigManager.allowVideoOverIWLANWithCellularLimitedCase()
-                && mCallType == QnsConstants.CALL_TYPE_VIDEO
-                && mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS) {
-            log("isWfcEnabled:true for video");
-            return true;
-        }
-
-        return false;
-    }
-
-    private void validateWfcSettingsAndUpdate() {
-        boolean roaming = (mCoverage == QnsConstants.COVERAGE_ROAM);
-        boolean wfcSetting =
-                QnsUtils.isWfcEnabled(mQnsImsManager, mQnsProvisioningListener, roaming);
-        if (roaming && mSettingWfcRoamingEnabled != wfcSetting) {
-            log("validateWfcSettingsAndUpdate, found wfc roaming setting mismatch");
-            if (wfcSetting) {
-                mWfcPlatformEnabled = true;
-                mSettingWfcRoamingEnabled = true;
-            } else {
-                mWfcPlatformEnabled = QnsUtils.isWfcEnabledByPlatform(mQnsImsManager);
-                mSettingWfcRoamingEnabled = false;
-            }
-            mSettingWfcRoamingMode = QnsUtils.getWfcMode(mQnsImsManager, true);
-        } else if (!roaming && mSettingWfcEnabled != wfcSetting) {
-            log("validateWfcSettingsAndUpdate, found wfc setting mismatch");
-            if (wfcSetting) {
-                mWfcPlatformEnabled = true;
-                mSettingWfcEnabled = true;
-            } else {
-                mWfcPlatformEnabled = QnsUtils.isWfcEnabledByPlatform(mQnsImsManager);
-                mSettingWfcEnabled = false;
-            }
-            mSettingWfcMode = QnsUtils.getWfcMode(mQnsImsManager, false);
-        }
-    }
-
-    private boolean isAccessNetworkAllowed(int accessNetwork, int netCapability) {
-        switch (netCapability) {
-            case NetworkCapabilities.NET_CAPABILITY_EIMS:
-            case NetworkCapabilities.NET_CAPABILITY_IMS:
-            case NetworkCapabilities.NET_CAPABILITY_XCAP:
-                return mConfigManager.isAccessNetworkAllowed(accessNetwork, netCapability);
-            default:
-                if (accessNetwork == AccessNetworkType.UNKNOWN) {
-                    return false;
-                }
-        }
-        return true;
-    }
-
-    private boolean isAllowed(int transportType) {
-        StringBuilder sb = new StringBuilder();
-        sb.append(" evaluate isAllowed for transportType:")
-                .append(QnsConstants.transportTypeToString(transportType));
-
-        if (transportType == AccessNetworkConstants.TRANSPORT_TYPE_WLAN) {
-            boolean isWfcEnabled = isWfcEnabled();
-            sb.append(" isWfcEnabled:").append(isWfcEnabled);
-            if (!isWfcEnabled) {
-                log(sb.toString());
-                return false;
-            }
-
-            if (mQnsEventDispatcher.isAirplaneModeToggleOn()) {
-                boolean isWfcAllowInAirplaneMode = mConfigManager.allowWFCOnAirplaneModeOn();
-                sb.append(" isWfcAllowInAirplaneMode:").append(isWfcAllowInAirplaneMode);
-                if (!isWfcAllowInAirplaneMode) {
-                    log(sb.toString());
-                    return false;
-                }
-            }
-
-            if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS
-                    && (mQnsEventDispatcher.isAirplaneModeToggleOn()
-                            || !mQnsComponents
-                                    .getQnsTelephonyListener(mSlotIndex)
-                                    .getLastQnsTelephonyInfo()
-                                    .isCellularAvailable())
-                    && mIwlanNetworkStatusTracker.isInternationalRoaming(mSlotIndex)) {
-                boolean isBlockIwlan = mConfigManager.blockIwlanInInternationalRoamWithoutWwan();
-                sb.append(" isBlockIwlanInInternationalRoamWithoutWwan:").append(isBlockIwlan);
-                if (isBlockIwlan) {
-                    log(sb.toString());
-                    return false;
-                }
-            }
-        }
-
-        if (transportType == AccessNetworkConstants.TRANSPORT_TYPE_WWAN) {
-            if (mQnsEventDispatcher.isAirplaneModeToggleOn()) {
-                sb.append(" AirplaneModeOn");
-                log(sb.toString());
-                return false;
-            }
-
-            if (getPreferredMode() == QnsConstants.WIFI_ONLY) {
-                sb.append(" isWiFiOnly:false");
-                log(sb.toString());
-                return false;
-            }
-        }
-
-        if (mConfigManager.getRatPreference(mNetCapability)
-                != QnsConstants.RAT_PREFERENCE_DEFAULT) {
-            switch (mConfigManager.getRatPreference(mNetCapability)) {
-                case QnsConstants.RAT_PREFERENCE_WIFI_ONLY:
-                    if (transportType == AccessNetworkConstants.TRANSPORT_TYPE_WWAN) {
-                        sb.append(" isAllowRatPrefWiFiOnly:false");
-                        log(sb.toString());
-                        return false;
-                    }
-                    sb.append(" isAllowRatPrefWiFiOnly:true");
-                    break;
-                case QnsConstants.RAT_PREFERENCE_WIFI_WHEN_WFC_AVAILABLE:
-                    if ((transportType == AccessNetworkConstants.TRANSPORT_TYPE_WWAN
-                                    && mQnsImsManager.isImsRegistered(
-                                            AccessNetworkConstants.TRANSPORT_TYPE_WLAN))
-                            || (transportType == AccessNetworkConstants.TRANSPORT_TYPE_WLAN
-                                    && !mQnsImsManager.isImsRegistered(
-                                            AccessNetworkConstants.TRANSPORT_TYPE_WLAN))) {
-                        sb.append(" isAllowRatPrefWfcAvail:false");
-                        log(sb.toString());
-                        return false;
-                    }
-                    sb.append(" isAllowRatPrefWfcAvail:true");
-                    break;
-                case QnsConstants.RAT_PREFERENCE_WIFI_WHEN_NO_CELLULAR:
-                    if (transportType == AccessNetworkConstants.TRANSPORT_TYPE_WLAN
-                            && mCellularAvailable) {
-                        sb.append(" isAllowRatPrefNoCell:false");
-                        log(sb.toString());
-                        return false;
-                    }
-                    sb.append(" isAllowRatPrefNoCell:true");
-                    break;
-                case QnsConstants.RAT_PREFERENCE_WIFI_WHEN_HOME_IS_NOT_AVAILABLE:
-                    if (transportType == AccessNetworkConstants.TRANSPORT_TYPE_WWAN
-                            && (!mCellularAvailable || mCoverage != QnsConstants.COVERAGE_HOME)) {
-                        sb.append(" isAllowRatPrefNotHome:false");
-                        log(sb.toString());
-                        return false;
-                    }
-                    sb.append(" isAllowRatPrefNotHome:true");
-                    break;
-            }
-        }
-
-        log(sb.toString());
-        return true;
-    }
-
-    private boolean evaluateAvailability(int transportType, boolean isAllowedForOtherType) {
-        boolean isAvailable =
-                (transportType == AccessNetworkConstants.TRANSPORT_TYPE_WLAN)
-                        ? mIwlanAvailable
-                        : mCellularAvailable;
-        boolean isOtherTypeAvailable =
-                isAllowedForOtherType
-                        && ((transportType != AccessNetworkConstants.TRANSPORT_TYPE_WLAN)
-                                ? mIwlanAvailable
-                                : mCellularAvailable);
-        boolean isRestricted = mRestrictManager.isRestricted(transportType);
-        boolean isAllowedOnSingleTransport =
-                mRestrictManager.isAllowedOnSingleTransport(transportType);
-
-        StringBuilder sb = new StringBuilder();
-        sb.append(" evaluate Available for transportType:")
-                .append(QnsConstants.transportTypeToString(transportType));
-
-        sb.append(" isAvailable:").append(isAvailable);
-        if (!isAvailable) {
-            log(sb.toString());
-            return false;
-        } else if (transportType == AccessNetworkConstants.TRANSPORT_TYPE_WLAN
-                && mIsCrossWfc
-                && !isCrossWfcAllowed(mCellularAvailable)) {
-            sb.append(" CrossWfc is not allowed. mCellularAvailable:").append(mCellularAvailable);
-            log(sb.toString());
-            return false;
-        }
-
-        if (isRestricted) {
-            PreCondition cond = getMatchingPreCondition();
-            if (cond instanceof GuardingPreCondition
-                    && ((GuardingPreCondition) cond).getGuarding() != QnsConstants.GUARDING_NONE) {
-                isRestricted = mRestrictManager.isRestrictedExceptGuarding(transportType);
-                sb.append(" isRestrictedExceptGuarding:").append(isRestricted);
-            } else {
-                sb.append(" isRestricted:").append(isRestricted);
-            }
-        } else {
-            sb.append(" isRestricted:").append(isRestricted);
-        }
-        if (!isRestricted) {
-            log(sb.toString());
-            return true;
-        }
-
-        sb.append(" hasIgnorableRestriction:").append(isAllowedOnSingleTransport);
-        if (!isAllowedOnSingleTransport) {
-            log(sb.toString());
-            return false;
-        }
-
-        sb.append(" isOtherTypeAvailable:").append(isOtherTypeAvailable);
-        log(sb.toString());
-        return !isOtherTypeAvailable;
-    }
-
-    protected void evaluate() {
-        evaluate(EVALUATE_SPECIFIC_REASON_NONE);
-    }
-
-    protected synchronized void evaluate(int specificReason) {
-        if (!mInitialized) {
-            if (DBG) log("ANE is not initialized yet.");
-            return;
-        }
-        mLastEvaluateSpecificReason = specificReason;
-        log("evaluate reason:" + evaluateSpecificReasonToString(specificReason));
-        if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_EIMS) {
-            if (!mDataConnectionStatusTracker.isActiveState()) {
-                log("QNS only handles HO of EMERGENCY data connection");
-                return;
-            }
-        }
-
-        if (mDataConnectionStatusTracker.isActiveState()) {
-            /* Check handover policy */
-            if (isHandoverPolicyCheckAvailable()) {
-                if (!moveTransportTypeAllowed()) {
-                    log("Handover is not allowed. Skip this evaluation.");
-                    return;
-                }
-            } else {
-                if (specificReason == EVALUATE_SPECIFIC_REASON_IWLAN_DISABLE
-                        && !mCellularAvailable) {
-                    log("Allow evaluation without handover policy check");
-                } else {
-                    log("Handover policy check is not available. Skip this evaluation.");
-                    return;
-                }
-            }
-        }
-
-        /* Check network Availability */
-        boolean isAllowedForIwlan = isAllowed(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        boolean isAllowedForCellular = isAllowed(AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        boolean availabilityIwlan =
-                isAllowedForIwlan
-                        && evaluateAvailability(
-                                AccessNetworkConstants.TRANSPORT_TYPE_WLAN, isAllowedForCellular);
-        boolean availabilityCellular =
-                isAllowedForCellular
-                        && evaluateAvailability(
-                                AccessNetworkConstants.TRANSPORT_TYPE_WWAN, isAllowedForIwlan);
-        log(" availability Iwlan:" + availabilityIwlan + " Cellular:" + availabilityCellular);
-
-        if (mWifiBackhaulMonitor.isRttCheckEnabled()
-                && mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS) {
-            mWifiBackhaulMonitor.setCellularAvailable(
-                    availabilityCellular
-                            && isAccessNetworkAllowed(mCellularAccessNetworkType, mNetCapability));
-        }
-        // QualifiedNetworksService checks AccessNetworkSelectionPolicy only in the case both
-        // networks(cellular and iwlan) are available. If only one network is available, no
-        // evaluation is run. Available network of accessNetworkType will be reported immediately.
-        if (availabilityIwlan && availabilityCellular) {
-            updateAccessNetworkSelectionPolicy();
-            List<Integer> accessNetworkTypes =
-                    evaluateAccessNetworkSelectionPolicy(availabilityIwlan, availabilityCellular);
-            reportSatisfiedAccessNetworkTypesByState(accessNetworkTypes, true);
-            reevaluateLastNotifiedSecondAccessNetwork();
-        } else if (availabilityIwlan) {
-            updateAccessNetworkSelectionPolicy();
-            if (!mIsCrossWfc && hasWifiThresholdWithoutCellularCondition()) {
-                List<Integer> accessNetworkTypes =
-                        evaluateAccessNetworkSelectionPolicy(
-                                availabilityIwlan, availabilityCellular);
-                reportSatisfiedAccessNetworkTypesByState(accessNetworkTypes, true);
-            } else {
-                reportSatisfiedAccessNetworkTypesByState(List.of(AccessNetworkType.IWLAN), false);
-            }
-        } else if (availabilityCellular) {
-            reportSatisfiedAccessNetworkTypesByState(
-                    new ArrayList<>(List.of(mCellularAccessNetworkType)), false);
-        } else {
-            // TODO Is it better to report to cellular when there is nothing?
-            log("evaluate nothing without an available network.");
-            if (specificReason == EVALUATE_SPECIFIC_REASON_IWLAN_DISABLE) {
-                reportQualifiedNetwork(getInitialAccessNetworkTypes());
-            }
-        }
-    }
-
-    @VisibleForTesting
-    boolean vopsCheckRequired(int cellularAccessNetworkType, int coverage, int callType) {
-        boolean checkVoPs = false;
-        if (mConfigManager.isMmtelCapabilityRequired(coverage)
-                && (cellularAccessNetworkType == AccessNetworkType.EUTRAN
-                        || cellularAccessNetworkType == AccessNetworkType.NGRAN)) {
-            if (mDataConnectionStatusTracker.isInactiveState()) {
-                checkVoPs = true;
-            } else if (mDataConnectionStatusTracker.getLastTransportType()
-                    == AccessNetworkConstants.TRANSPORT_TYPE_WLAN) {
-                if (callType == QnsConstants.CALL_TYPE_IDLE
-                        || !mConfigManager.isInCallHoDecisionWlanToWwanWithoutVopsCondition()) {
-                    checkVoPs = true;
-                }
-            } else if (mDataConnectionStatusTracker.getLastTransportType()
-                    == AccessNetworkConstants.TRANSPORT_TYPE_WWAN) {
-                // If there is an on-going call and UE is moving into an area which does not support
-                // VoPS, don't consider VoPS condition and let AccessNetworkEvaluator decide a
-                // preferred RAT.
-                if (callType == QnsConstants.CALL_TYPE_IDLE) {
-                    checkVoPs = true;
-                }
-            }
-        }
-        return checkVoPs;
-    }
-
-    private boolean hasWifiThresholdWithoutCellularCondition() {
-        if (mAccessNetworkSelectionPolicies == null || mAccessNetworkSelectionPolicies.isEmpty()) {
-            return false;
-        }
-        for (AccessNetworkSelectionPolicy policy : mAccessNetworkSelectionPolicies) {
-            if (policy.hasWifiThresholdWithoutCellularCondition()) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    protected synchronized void reportSatisfiedAccessNetworkTypesByState(
-            List<Integer> satisfiedAccessNetworkTypes, boolean needMonitor) {
-        if (needMonitor) {
-            if (mDataConnectionStatusTracker.isInactiveState()) {
-                if (satisfiedAccessNetworkTypes.size() > 0) {
-                    reportQualifiedNetwork(satisfiedAccessNetworkTypes);
-                    updateAccessNetworkSelectionPolicy();
-                }
-                updateQualityMonitor();
-            } else if (!mDataConnectionStatusTracker.isConnectionInProgress()) {
-                if (isHandoverNeeded(satisfiedAccessNetworkTypes)) {
-                    reportQualifiedNetwork(satisfiedAccessNetworkTypes);
-                    unregisterThresholdToQualityMonitor();
-                } else if (isFallbackCase(satisfiedAccessNetworkTypes)) {
-                    reportQualifiedNetwork(satisfiedAccessNetworkTypes);
-                    updateAccessNetworkSelectionPolicy();
-                    updateQualityMonitor();
-                } else {
-                    updateQualityMonitor();
-                }
-            }
-        } else {
-            if (mDataConnectionStatusTracker.isInactiveState()) {
-                reportQualifiedNetwork(satisfiedAccessNetworkTypes);
-            } else if (!mDataConnectionStatusTracker.isConnectionInProgress()) {
-                if (isHandoverNeeded(satisfiedAccessNetworkTypes)) {
-                    reportQualifiedNetwork(satisfiedAccessNetworkTypes);
-                } else if (isFallbackCase(satisfiedAccessNetworkTypes)) {
-                    reportQualifiedNetwork(satisfiedAccessNetworkTypes);
-                }
-            }
-            unregisterThresholdToQualityMonitor();
-        }
-    }
-
-    protected int getTargetTransportType(List<Integer> accessNetworkTypes) {
-        if (accessNetworkTypes == null || accessNetworkTypes.size() == 0) {
-            return AccessNetworkConstants.TRANSPORT_TYPE_INVALID;
-        }
-        if (accessNetworkTypes.get(0) == AccessNetworkType.IWLAN) {
-            return AccessNetworkConstants.TRANSPORT_TYPE_WLAN;
-        }
-        return AccessNetworkConstants.TRANSPORT_TYPE_WWAN;
-    }
-
-    @VisibleForTesting
-    boolean isHandoverPolicyCheckAvailable() {
-        if (mDataConnectionStatusTracker.isActiveState()) {
-            int srcTransportType = mDataConnectionStatusTracker.getLastTransportType();
-            boolean targetNetworkAvailable =
-                    srcTransportType == AccessNetworkConstants.TRANSPORT_TYPE_WLAN
-                            ? mCellularAvailable
-                            : mIwlanAvailable;
-            if (srcTransportType == getLastQualifiedTransportType() && targetNetworkAvailable) {
-                log(" handover policy check is available for this evaluation.");
-                return true;
-            }
-        }
-        log("handover policy check is not available for this evaluation.");
-        return false;
-    }
-
-    @VisibleForTesting
-    boolean moveTransportTypeAllowed() {
-        int srcAccessNetwork =
-                mDataConnectionStatusTracker.getLastTransportType()
-                                == AccessNetworkConstants.TRANSPORT_TYPE_WLAN
-                        ? AccessNetworkType.IWLAN
-                        : mLatestAvailableCellularAccessNetwork;
-        int dstAccessNetwork =
-                srcAccessNetwork == AccessNetworkType.IWLAN
-                        ? mCellularAccessNetworkType
-                        : AccessNetworkType.IWLAN;
-        if (mConfigManager.isHandoverAllowedByPolicy(
-                mNetCapability, srcAccessNetwork, dstAccessNetwork, mCoverage)) {
-            return true;
-        } else {
-            if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS
-                    && mCallStatusTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_IMS)) {
-                // Telephony will make new connection with preferred AccessNetwork
-                log("handover is not allowed. but need to move to target Transport.");
-                return true;
-            }
-            if (dstAccessNetwork == AccessNetworkType.IWLAN && useDifferentApnOverIwlan()) {
-                // Telephony will make new connection when change transport type
-                log(
-                        "handover is not allowed. but need to move to target Transport using"
-                                + " different apn over IWLAN.");
-                return true;
-            }
-            if (dstAccessNetwork != AccessNetworkType.IWLAN
-                    && mCellularAvailable
-                    && mConfigManager.getRatPreference(mNetCapability)
-                            == QnsConstants.RAT_PREFERENCE_WIFI_WHEN_NO_CELLULAR) {
-                // Telephony will make new connection when change transport type
-                log(
-                        "handover is not allowed. but need to move to target Transport for the"
-                                + " RAT_PREFERENCE_WIFI_WHEN_NO_CELLULAR.");
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private boolean useDifferentApnOverIwlan() {
-        // supports MMS, XCAP and CBS
-        if (mNetCapability != NetworkCapabilities.NET_CAPABILITY_MMS
-                && mNetCapability != NetworkCapabilities.NET_CAPABILITY_XCAP
-                && mNetCapability != NetworkCapabilities.NET_CAPABILITY_CBS) {
-            return false;
-        }
-
-        ApnSetting apnSetting =
-                mDataConnectionStatusTracker.getLastApnSetting(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        if (apnSetting != null
-                && (apnSetting.getApnTypeBitmask() & ApnSetting.TYPE_DEFAULT) != 0
-                && (apnSetting.getNetworkTypeBitmask()
-                                & (1 << (TelephonyManager.NETWORK_TYPE_IWLAN - 1)))
-                        == 0) {
-            log("useDifferentApnOverIwlan true");
-            return true;
-        }
-        log("useDifferentApnOverIwlan false");
-        return false;
-    }
-
-    protected boolean isHandoverNeeded(List<Integer> accessNetworkTypes) {
-        if (mDataConnectionStatusTracker.isInactiveState()
-                || mDataConnectionStatusTracker.isHandoverState()) {
-            return false;
-        }
-
-        int targetTransportType = getTargetTransportType(accessNetworkTypes);
-        if (targetTransportType == AccessNetworkConstants.TRANSPORT_TYPE_INVALID) {
-            return false;
-        }
-
-        // Handover case
-        int sourceTransportType = mDataConnectionStatusTracker.getLastTransportType();
-        return sourceTransportType != targetTransportType;
-    }
-
-    protected boolean isFallbackCase(List<Integer> accessNetworkTypes) {
-        if (mDataConnectionStatusTracker.isInactiveState()) {
-            return false;
-        }
-
-        int targetTransportType = getTargetTransportType(accessNetworkTypes);
-        if (targetTransportType == AccessNetworkConstants.TRANSPORT_TYPE_INVALID) {
-            return false;
-        }
-        if (targetTransportType != mDataConnectionStatusTracker.getLastTransportType()) {
-            return false;
-        }
-
-        if (getLastQualifiedTransportType() == targetTransportType) {
-            return false;
-        }
-
-        log("isFallbackcase:true");
-        return true;
-    }
-
-    protected void reportQualifiedNetwork(List<Integer> accessNetworkTypes) {
-        if (accessNetworkTypes.contains(AccessNetworkType.UNKNOWN)) {
-            log(
-                    "reportQualifiedNetwork, remove UNKNOWN access network."
-                            + QnsUtils.getStringAccessNetworkTypes(accessNetworkTypes));
-            accessNetworkTypes.remove(AccessNetworkType.UNKNOWN);
-        }
-        List<Integer> supportAccessNetworkTypes = new ArrayList<>();
-        if (mConfigManager.allowImsOverIwlanCellularLimitedCase()) {
-            for (Integer accessNetwork : accessNetworkTypes) {
-                if (accessNetwork == AccessNetworkType.IWLAN
-                        || isAccessNetworkAllowed(accessNetwork, mNetCapability)) {
-                    supportAccessNetworkTypes.add(accessNetwork);
-                }
-            }
-            if (!accessNetworkTypes.isEmpty() && supportAccessNetworkTypes.isEmpty()) {
-                log("supportAccessNetworkTypes is empty");
-                return;
-            }
-        } else {
-            supportAccessNetworkTypes.addAll(accessNetworkTypes);
-        }
-
-        log(
-                "reportQualifiedNetwork supportAccessNetworkTypes:"
-                        + QnsUtils.getStringAccessNetworkTypes(supportAccessNetworkTypes));
-
-        if (equalsLastNotifiedQualifiedNetwork(supportAccessNetworkTypes)) {
-            return;
-        } else {
-            if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS
-                    && mWifiBackhaulMonitor.isRttCheckEnabled()) {
-                if (supportAccessNetworkTypes.contains(AccessNetworkType.IWLAN)) {
-                    if (!isRttSuccess()) {
-                        mWifiBackhaulMonitor.requestRttCheck();
-                        return;
-                    }
-                } else {
-                    mIsRttCheckSuccess = false;
-                }
-            }
-        }
-
-        updateLastNotifiedQualifiedNetwork(supportAccessNetworkTypes);
-        notifyForQualifiedNetworksChanged(supportAccessNetworkTypes);
-    }
-
-    private List<Threshold> findUnmatchedThresholds() {
-        List<Threshold> unmatchedThresholds = new ArrayList<>();
-        if (mAccessNetworkSelectionPolicies == null
-                || mAccessNetworkSelectionPolicies.size() == 0) {
-            return unmatchedThresholds;
-        }
-
-        List<Integer> excludeThresholdGroup = new ArrayList<>();
-        boolean bIwlanRegistrable = isIwlanAvailableWithoutRestrict();
-        boolean bCellularRegistrable = isCellularAvailableWithoutRestrict();
-        for (AccessNetworkSelectionPolicy policy : mAccessNetworkSelectionPolicies) {
-            List<Threshold> policyUnmatchedThresholds =
-                    policy.findUnmatchedThresholds(mWifiQualityMonitor, mCellularQualityMonitor);
-            if (policyUnmatchedThresholds == null || policyUnmatchedThresholds.size() == 0) {
-                continue;
-            }
-            for (Threshold threshold : policyUnmatchedThresholds) {
-                if (bIwlanRegistrable && threshold.getAccessNetwork() == AccessNetworkType.IWLAN) {
-                    unmatchedThresholds.add(threshold);
-                }
-                if (bCellularRegistrable
-                        && threshold.getAccessNetwork() != AccessNetworkType.IWLAN) {
-                    if (threshold.getAccessNetwork() == mCellularAccessNetworkType) {
-                        unmatchedThresholds.add(threshold);
-                    } else if (threshold.getGroupId() >= 0) {
-                        // If the current cellular access network and the access network of
-                        // cellular threshold are different, it is not necessary to monitor the
-                        // entire threshold of this group.
-                        excludeThresholdGroup.add(threshold.getGroupId());
-                    }
-                }
-            }
-        }
-        for (int excludeGid : excludeThresholdGroup) {
-            unmatchedThresholds.removeIf(threshold -> threshold.getGroupId() == excludeGid);
-        }
-        return unmatchedThresholds;
-    }
-
-    private void updateQualityMonitor() {
-        List<Threshold> unmatchedThresholds = findUnmatchedThresholds();
-        if (unmatchedThresholds.size() == 0) {
-            log("updateQualityMonitor empty unmatchedThresholds.");
-            unregisterThresholdToQualityMonitor();
-            return;
-        }
-
-        log("updateQualityMonitor");
-
-        LinkedHashSet<Integer> unmatchedGroupIdSet = new LinkedHashSet<>();
-        HashMap<Integer, Integer> unmatchedMonitorTypeMap = new HashMap<>();
-        LinkedHashSet<Integer> unmatchedMonitorTypeSet = new LinkedHashSet<>();
-        for (Threshold th : unmatchedThresholds) {
-            if (th.getGroupId() < 0) {
-                continue;
-            }
-            unmatchedGroupIdSet.add(th.getGroupId());
-            int key = th.getAccessNetwork() << 16 | th.getMeasurementType();
-            unmatchedMonitorTypeMap.put(key, unmatchedMonitorTypeMap.getOrDefault(key, 0) + 1);
-        }
-
-        List<Map.Entry<Integer, Integer>> list_entries =
-                new ArrayList<>(unmatchedMonitorTypeMap.entrySet());
-        list_entries.sort(Entry.comparingByValue());
-        for (Entry<Integer, Integer> entry : list_entries) {
-            unmatchedMonitorTypeSet.add(entry.getKey());
-        }
-
-        LinkedHashSet<Integer> reducedGroupIdSet = new LinkedHashSet<>();
-        for (int type : unmatchedMonitorTypeSet) {
-            reducedGroupIdSet.clear();
-            boolean skipReduce = false;
-            for (Threshold th : unmatchedThresholds) {
-                if (type == (th.getAccessNetwork() << 16 | th.getMeasurementType())) {
-                    if (th.getGroupId() < 0) {
-                        skipReduce = true;
-                        break;
-                    }
-                } else {
-                    reducedGroupIdSet.add(th.getGroupId());
-                }
-            }
-            if (skipReduce) {
-                continue;
-            }
-
-            if (reducedGroupIdSet.containsAll(unmatchedGroupIdSet)) {
-                unmatchedThresholds.removeIf(
-                        threshold ->
-                                type
-                                        == (threshold.getAccessNetwork() << 16
-                                                | threshold.getMeasurementType()));
-            }
-        }
-
-        registerThresholdsToQualityMonitor(unmatchedThresholds);
-    }
-
-    private void unregisterThresholdToQualityMonitor() {
-        mWifiQualityMonitor.updateThresholdsForNetCapability(mNetCapability, mSlotIndex, null);
-        mCellularQualityMonitor.updateThresholdsForNetCapability(mNetCapability, mSlotIndex, null);
-    }
-
-    private void registerThresholdsToQualityMonitor(List<Threshold> thresholds) {
-        if (thresholds == null) {
-            thresholds = new ArrayList<>();
-        }
-
-        List<Threshold> monitorWiFiThresholds = new ArrayList<>();
-        List<Threshold> monitorCellThresholds = new ArrayList<>();
-        for (Threshold th : thresholds) {
-            if (th.getAccessNetwork() == AccessNetworkType.IWLAN) {
-                monitorWiFiThresholds.add(th);
-            } else {
-                monitorCellThresholds.add(th);
-            }
-        }
-
-        for (Threshold th : monitorWiFiThresholds) {
-            log("  monitorWiFiThresholds th:" + th.toShortString());
-        }
-        for (Threshold th : monitorCellThresholds) {
-            log("  monitorCellThresholds th:" + th.toShortString());
-        }
-
-        // refresh threshold to be monitored.
-        mWifiQualityMonitor.updateThresholdsForNetCapability(
-                mNetCapability, mSlotIndex, monitorWiFiThresholds.toArray(new Threshold[0]));
-        mCellularQualityMonitor.updateThresholdsForNetCapability(
-                mNetCapability, mSlotIndex, monitorCellThresholds.toArray(new Threshold[0]));
-    }
-
-    protected void updateThrottleStatus(
-            boolean isThrottle, long throttleTimeMillis, int transportType) {
-        mRestrictManager.notifyThrottling(isThrottle, throttleTimeMillis, transportType);
-    }
-
-    protected int getPreferredMode() {
-        if (mAllowIwlanForWfcActivation) {
-            return QnsConstants.WIFI_PREF;
-        }
-        if (mCoverage == QnsConstants.COVERAGE_ROAM) {
-            return mSettingWfcRoamingMode;
-        }
-        return mSettingWfcMode;
-    }
-
-    private int getPreferredAccessNetwork() {
-        switch (getPreferredMode()) {
-            case QnsConstants.CELL_PREF:
-                return mCellularAccessNetworkType;
-            case QnsConstants.WIFI_PREF:
-            case QnsConstants.WIFI_ONLY:
-                return AccessNetworkType.IWLAN;
-        }
-        return mCellularAccessNetworkType;
-    }
-
-    private boolean isRttSuccess() {
-        return !isAccessNetworkAllowed(
-                        mCellularAccessNetworkType, NetworkCapabilities.NET_CAPABILITY_IMS)
-                || mIsRttCheckSuccess;
-    }
-
-    private List<Integer> evaluateAccessNetworkSelectionPolicy(
-            boolean availabilityIwlan, boolean availabilityCellular) {
-        log("evaluateAccessNetworkSelectionPolicy");
-
-        if (mAccessNetworkSelectionPolicies == null || mAccessNetworkSelectionPolicies.isEmpty()) {
-            return new ArrayList<>();
-        }
-        List<Integer> accessNetworkTypes = new ArrayList<>();
-        for (AccessNetworkSelectionPolicy policy : mAccessNetworkSelectionPolicies) {
-            if (policy.satisfiedByThreshold(
-                    mWifiQualityMonitor,
-                    mCellularQualityMonitor,
-                    availabilityIwlan,
-                    availabilityCellular,
-                    mCellularAccessNetworkType)) {
-                log(
-                        "  satisfiedByThreshold TargetTransportType:"
-                                + QnsConstants.transportTypeToString(
-                                        policy.getTargetTransportType()));
-                if (policy.getTargetTransportType() == AccessNetworkConstants.TRANSPORT_TYPE_WLAN) {
-                    if (!accessNetworkTypes.contains(AccessNetworkType.IWLAN)) {
-                        accessNetworkTypes.add(AccessNetworkType.IWLAN);
-                    }
-
-                } else {
-                    if (!accessNetworkTypes.contains(mCellularAccessNetworkType)) {
-                        if (availabilityCellular) {
-                            accessNetworkTypes.add(mCellularAccessNetworkType);
-                        } else {
-                            accessNetworkTypes.add(AccessNetworkType.UNKNOWN);
-                        }
-                    }
-                    if ((mCallType == QnsConstants.CALL_TYPE_VOICE
-                                    || mCallType == QnsConstants.CALL_TYPE_EMERGENCY)
-                            && policy.satisfiedWithWifiLowSignalStrength()) {
-                        int reason = mConfigManager.getQnsIwlanHoRestrictReason();
-                        if (reason == QnsConstants.FALLBACK_REASON_RTP_OR_WIFI
-                                || reason == QnsConstants.FALLBACK_REASON_WIFI_ONLY) {
-                            log("WWAN decision with Wi-Fi low signalStrength in Voice call");
-                            mRestrictManager.increaseCounterToRestrictIwlanInCall();
-                        }
-                    }
-                }
-            }
-        }
-
-        // If the evaluator has not yet reported a Qualified Networks, report preferred.
-        if (!isNotifiedQualifiedAccessNetworkTypes()) {
-            if (accessNetworkTypes.size() == 0) {
-                accessNetworkTypes.add(getPreferredAccessNetwork());
-                log(
-                        "  no candidate access network, use preferred:"
-                                + QnsUtils.getStringAccessNetworkTypes(accessNetworkTypes));
-            } else if (accessNetworkTypes.size() > 1) {
-                accessNetworkTypes.remove(Integer.valueOf(getPreferredAccessNetwork()));
-                accessNetworkTypes.add(0, getPreferredAccessNetwork());
-                log(
-                        "  two more candidate access network, use preferred:"
-                                + QnsUtils.getStringAccessNetworkTypes(accessNetworkTypes));
-            }
-        }
-
-        // TODO. need to be improved handling the second access network
-        // Add a second access network, if the preferred access network does not exist in list.
-        if (availabilityIwlan
-                && availabilityCellular
-                && mConfigManager.isOverrideImsPreferenceSupported()) {
-            if (!accessNetworkTypes.isEmpty()
-                    && accessNetworkTypes.get(0) != AccessNetworkType.IWLAN
-                    && getPreferredMode() == QnsConstants.CELL_PREF
-                    && isAccessNetworkAllowed(accessNetworkTypes.get(0), mNetCapability)) {
-                if (!accessNetworkTypes.contains(AccessNetworkType.IWLAN)) {
-                    accessNetworkTypes.add(AccessNetworkType.IWLAN);
-                    log(
-                            "  add a second accessNetworkTypes : "
-                                    + QnsUtils.getStringAccessNetworkTypes(accessNetworkTypes));
-                }
-            } else if (accessNetworkTypes.isEmpty()
-                    && !mLastQualifiedAccessNetworkTypes.isEmpty()
-                    && mLastQualifiedAccessNetworkTypes.get(0) != AccessNetworkType.IWLAN
-                    && getPreferredMode() == QnsConstants.CELL_PREF
-                    && isAccessNetworkAllowed(
-                            mLastQualifiedAccessNetworkTypes.get(0), mNetCapability)) {
-                if (!mLastQualifiedAccessNetworkTypes.contains(AccessNetworkType.IWLAN)) {
-                    accessNetworkTypes.addAll(mLastQualifiedAccessNetworkTypes);
-                    accessNetworkTypes.add(AccessNetworkType.IWLAN);
-                    log(
-                            "  add a second accessNetworkTypes in existing "
-                                    + "mLastQualifiedAccessNetworkTypes : "
-                                    + QnsUtils.getStringAccessNetworkTypes(accessNetworkTypes));
-                }
-            }
-        }
-
-        log("  accessNetworkTypes:" + QnsUtils.getStringAccessNetworkTypes(accessNetworkTypes));
-        return accessNetworkTypes;
-    }
-
-    // TODO. need to be improved handling the second access network
-    // A qualified conditions are required for the second access network.
-    // What threshold conditions are qualified for the second access network? (like rove in)
-    // What are the threshold conditions for exiting the second access network? (like a rove out)
-    private void reevaluateLastNotifiedSecondAccessNetwork() {
-        if (mConfigManager.isOverrideImsPreferenceSupported()
-                && mLastQualifiedAccessNetworkTypes.size() > 1
-                && mLastQualifiedAccessNetworkTypes.get(1) == AccessNetworkType.IWLAN) {
-            if (!isAccessNetworkAllowed(mCellularAccessNetworkType, mNetCapability)
-                    || getPreferredMode() != QnsConstants.CELL_PREF) {
-                log("reevaluateLastNotifiedSecondAccessNetwork, Removed a second access network");
-                reportQualifiedNetwork(
-                        new ArrayList<>(List.of(mLastQualifiedAccessNetworkTypes.get(0))));
-            }
-        }
-    }
-
-    private Map<PreCondition, List<AccessNetworkSelectionPolicy>> buildAccessNetworkSelectionPolicy(
-            boolean bForceUpdate) {
-        if (mAnspPolicyMap == null || bForceUpdate) {
-            log("Building list of AccessNetworkSelectionPolicy.");
-            mAnspPolicyMap =
-                    AccessNetworkSelectionPolicyBuilder.build(mConfigManager, mNetCapability);
-
-            if (DBG) {
-                mAnspPolicyMap
-                        .values()
-                        .forEach(
-                                list ->
-                                        list.stream()
-                                                .map(policy -> " retriMap ANSP=" + policy)
-                                                .forEach(this::log));
-            }
-        }
-        return mAnspPolicyMap;
-    }
-
-    private void updateAccessNetworkSelectionPolicy() {
-        Map<PreCondition, List<AccessNetworkSelectionPolicy>> map =
-                buildAccessNetworkSelectionPolicy(false);
-        if (map == null) {
-            map = new HashMap<>();
-        }
-
-        log("Create a list of AccessNetworkSelectionPolicy that match the preconditions.");
-
-        PreCondition preCondition = getMatchingPreCondition();
-        List<AccessNetworkSelectionPolicy> matchedPolicies = new ArrayList<>();
-        List<AccessNetworkSelectionPolicy> list = map.get(preCondition);
-        if (list != null) {
-            for (AccessNetworkSelectionPolicy policy : list) {
-                if (policy.satisfyPrecondition(preCondition)
-                        && !mDataConnectionStatusTracker.isConnectionInProgress()
-                        && (!isNotifiedQualifiedAccessNetworkTypes()
-                                || getLastQualifiedTransportType()
-                                        != policy.getTargetTransportType())) {
-                    matchedPolicies.add(policy);
-                }
-            }
-        }
-
-        if (mAccessNetworkSelectionPolicies.equals(matchedPolicies)) {
-            for (AccessNetworkSelectionPolicy policy : matchedPolicies) {
-                log("  Matched ANSP=" + policy);
-            }
-        }
-
-        for (AccessNetworkSelectionPolicy policy : matchedPolicies) {
-            log("  Found new ANSP=" + policy);
-        }
-
-        mAccessNetworkSelectionPolicies = matchedPolicies;
-    }
-
-    private PreCondition getMatchingPreCondition() {
-        int callType = mCallType;
-        if ((mNetCapability == NetworkCapabilities.NET_CAPABILITY_EIMS
-                        || mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS)
-                && mCallType == QnsConstants.CALL_TYPE_EMERGENCY) {
-            callType = QnsConstants.CALL_TYPE_VOICE;
-        }
-        int sipDialogPolicy = mConfigManager.getSipDialogSessionPolicy();
-        if (callType == QnsConstants.CALL_TYPE_IDLE && mSipDialogSessionState) {
-            if (sipDialogPolicy > QnsConstants.SIP_DIALOG_SESSION_POLICY_NONE) {
-                log("apply sipDialogPolicy:"
-                        + QnsConstants.qnsSipDialogSessionPolicyToString(sipDialogPolicy));
-            }
-            switch (sipDialogPolicy) {
-                case QnsConstants.SIP_DIALOG_SESSION_POLICY_FOLLOW_VOICE_CALL:
-                    callType = QnsConstants.CALL_TYPE_VOICE;
-                    break;
-                case QnsConstants.SIP_DIALOG_SESSION_POLICY_FOLLOW_VIDEO_CALL:
-                    callType = QnsConstants.CALL_TYPE_VIDEO;
-                    break;
-                case QnsConstants.SIP_DIALOG_SESSION_POLICY_NONE:
-                    // fall-through
-                default:
-                    // do-nothing
-                    break;
-            }
-        }
-
-        if (mConfigManager.hasThresholdGapWithGuardTimer()) {
-            @QnsConstants.QnsGuarding int guarding = QnsConstants.GUARDING_NONE;
-            int source = getLastQualifiedTransportType();
-            if (source != AccessNetworkConstants.TRANSPORT_TYPE_WLAN
-                    && mRestrictManager.hasRestrictionType(
-                            AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                            RestrictManager.RESTRICT_TYPE_GUARDING)) {
-                guarding = QnsConstants.GUARDING_WIFI;
-            } else if (source != AccessNetworkConstants.TRANSPORT_TYPE_WWAN
-                    && mRestrictManager.hasRestrictionType(
-                            AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                            RestrictManager.RESTRICT_TYPE_GUARDING)) {
-                guarding = QnsConstants.GUARDING_CELLULAR;
-            }
-            return new GuardingPreCondition(callType, getPreferredMode(), mCoverage, guarding);
-        }
-        return new PreCondition(callType, getPreferredMode(), mCoverage);
-    }
-
-    private String evaluateSpecificReasonToString(int specificReason) {
-        if (specificReason == EVALUATE_SPECIFIC_REASON_NONE) {
-            return "EVALUATE_SPECIFIC_REASON_NONE";
-        } else if (specificReason == EVALUATE_SPECIFIC_REASON_IWLAN_DISABLE) {
-            return "EVALUATE_SPECIFIC_REASON_IWLAN_DISABLE";
-        } else if (specificReason == EVALUATE_SPECIFIC_REASON_DATA_DISCONNECTED) {
-            return "EVALUATE_SPECIFIC_REASON_DATA_DISCONNECTED";
-        } else if (specificReason == EVALUATE_SPECIFIC_REASON_DATA_FAILED) {
-            return "EVALUATE_SPECIFIC_REASON_DATA_FAILED";
-        } else if (specificReason == EVALUATE_SPECIFIC_REASON_DATA_CONNECTED) {
-            return "EVALUATE_SPECIFIC_REASON_DATA_CONNECTED";
-        }
-        return "UNKNOWN";
-    }
-
-    private boolean isCrossWfcAllowed(boolean cellularAvailable) {
-        if (mConfigManager.getRatPreference(mNetCapability)
-                == QnsConstants.RAT_PREFERENCE_WIFI_WHEN_WFC_AVAILABLE) {
-            // Should follow RAT_PREFERENCE_WIFI_WHEN_WFC_AVAILABLE and do not block CST when IMS
-            // connected to CST
-            return true;
-        }
-        return !cellularAvailable;
-    }
-
-    private class EvaluatorEventHandler extends Handler {
-        EvaluatorEventHandler(Looper l) {
-            super(l);
-        }
-
-        @Override
-        public void handleMessage(Message message) {
-            log("handleMessage msg=" + message.what);
-            QnsAsyncResult ar = (QnsAsyncResult) message.obj;
-            switch (message.what) {
-                case EVENT_IWLAN_NETWORK_STATUS_CHANGED:
-                    onIwlanNetworkStatusChanged((IwlanAvailabilityInfo) ar.mResult);
-                    break;
-                case EVENT_QNS_TELEPHONY_INFO_CHANGED:
-                    onQnsTelephonyInfoChanged((QnsTelephonyListener.QnsTelephonyInfo) ar.mResult);
-                    break;
-                case EVENT_RESTRICT_INFO_CHANGED:
-                    onRestrictInfoChanged();
-                    break;
-                case EVENT_SET_CALL_TYPE:
-                    onSetCallType((int) ar.mResult);
-                    break;
-                case EVENT_DATA_CONNECTION_STATE_CHANGED:
-                    onDataConnectionStateChanged(
-                            (DataConnectionStatusTracker.DataConnectionChangedInfo) ar.mResult);
-                    break;
-                case EVENT_PROVISIONING_INFO_CHANGED:
-                    onProvisioningInfoChanged(
-                            (QnsProvisioningListener.QnsProvisioningInfo) ar.mResult);
-                    break;
-                case EVENT_IMS_REGISTRATION_STATE_CHANGED:
-                    onImsRegStateChanged((QnsImsManager.ImsRegistrationState) ar.mResult);
-                    break;
-                case EVENT_SIP_DIALOG_SESSION_STATE_CHANGED:
-                    onSipDialogSessionStateChanged((boolean) ar.mResult);
-                    break;
-                case EVENT_IMS_CALL_DISCONNECT_CAUSE_CHANGED:
-                    onImsCallDisconnectCauseChanged((ImsReasonInfo) ar.mResult);
-                    break;
-                case QnsEventDispatcher.QNS_EVENT_WFC_ENABLED:
-                    onWfcEnabledChanged(true, false);
-                    break;
-                case QnsEventDispatcher.QNS_EVENT_WFC_DISABLED:
-                    onWfcEnabledChanged(false, false);
-                    break;
-                case QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_ONLY:
-                    onWfcModeChanged(QnsConstants.WIFI_ONLY, false);
-                    break;
-                case QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_CELLULAR_PREFERRED:
-                    onWfcModeChanged(QnsConstants.CELL_PREF, false);
-                    break;
-                case QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_PREFERRED:
-                    onWfcModeChanged(QnsConstants.WIFI_PREF, false);
-                    break;
-                case QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_ENABLED:
-                    onWfcEnabledChanged(true, true);
-                    break;
-                case QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_DISABLED:
-                    onWfcEnabledChanged(false, true);
-                    break;
-                case QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_ONLY:
-                    onWfcModeChanged(QnsConstants.WIFI_ONLY, true);
-                    break;
-                case QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_MODE_TO_CELLULAR_PREFERRED:
-                    onWfcModeChanged(QnsConstants.CELL_PREF, true);
-                    break;
-                case QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_PREFERRED:
-                    onWfcModeChanged(QnsConstants.WIFI_PREF, true);
-                    break;
-                case QnsEventDispatcher.QNS_EVENT_WFC_PLATFORM_ENABLED:
-                    onWfcPlatformChanged(true);
-                    break;
-                case QnsEventDispatcher.QNS_EVENT_WFC_PLATFORM_DISABLED:
-                    onWfcPlatformChanged(false);
-                    break;
-                case QnsEventDispatcher.QNS_EVENT_SIM_ABSENT:
-                    onSimAbsent();
-                    break;
-                case EVENT_WIFI_RTT_STATUS_CHANGED:
-                    onRttStatusChanged((boolean) ar.mResult);
-                    break;
-                case QnsEventDispatcher.QNS_EVENT_TRY_WFC_ACTIVATION:
-                    onTryWfcConnectionStateChanged(true);
-                    break;
-                case QnsEventDispatcher.QNS_EVENT_CANCEL_TRY_WFC_ACTIVATION:
-                    onTryWfcConnectionStateChanged(false);
-                    break;
-                default:
-                    log("never reach here msg=" + message.what);
-            }
-        }
-    }
-
-    private class ThresholdListener extends ThresholdCallback
-            implements ThresholdCallback.WifiThresholdListener,
-                    ThresholdCallback.CellularThresholdListener {
-
-        ThresholdListener(Executor executor) {
-            this.init(executor);
-        }
-
-        @Override
-        public void onWifiThresholdChanged(Threshold[] thresholds) {
-            onWiFiQualityChanged(thresholds);
-        }
-
-        @Override
-        public void onCellularThresholdChanged(Threshold[] thresholds) {
-            onCellularQualityChanged(thresholds);
-        }
-    }
-
-    /**
-     * Dumps the state of {@link QualityMonitor}
-     *
-     * @param pw {@link PrintWriter} to write the state of the object.
-     * @param prefix String to append at start of dumped log.
-     */
-    void dump(PrintWriter pw, String prefix) {
-        pw.println(prefix + "------------------------------");
-        pw.println(
-                prefix
-                        + "ANE["
-                        + QnsUtils.getNameOfNetCapability(mNetCapability)
-                        + "_"
-                        + mSlotIndex
-                        + "]:");
-        pw.println(prefix + "mInitialized=" + mInitialized);
-        pw.println(
-                prefix
-                        + "mQualifiedNetworksChangedRegistrant size="
-                        + mQualifiedNetworksChangedRegistrants.size());
-        pw.println(
-                prefix
-                        + "mCellularAccessNetworkType="
-                        + QnsConstants.accessNetworkTypeToString(mCellularAccessNetworkType)
-                        + ", mLatestAvailableCellularAccessNetwork="
-                        + QnsConstants.accessNetworkTypeToString(
-                                mLatestAvailableCellularAccessNetwork)
-                        + ", mIsNotifiedLastQualifiedAccessNetworkTypes="
-                        + mIsNotifiedLastQualifiedAccessNetworkTypes);
-        pw.print(prefix + "mLastQualifiedAccessNetworkTypes=");
-        mLastQualifiedAccessNetworkTypes.forEach(
-                accessNetwork ->
-                        pw.print(QnsConstants.accessNetworkTypeToString(accessNetwork) + "|"));
-        pw.println(
-                ", mIsNotifiedLastQualifiedAccessNetworkTypes="
-                        + mIsNotifiedLastQualifiedAccessNetworkTypes);
-        pw.println(
-                prefix
-                        + "mCellularAvailable="
-                        + mCellularAvailable
-                        + ", mIwlanAvailable="
-                        + mIwlanAvailable
-                        + ", mIsCrossWfc="
-                        + QnsConstants.callTypeToString(mCallType)
-                        + ", mCoverage"
-                        + QnsConstants.coverageToString(mCoverage));
-        pw.println(
-                prefix
-                        + "mWfcPlatformEnabled="
-                        + mWfcPlatformEnabled
-                        + ", mSettingWfcEnabled="
-                        + mSettingWfcEnabled
-                        + ", mSettingWfcMode="
-                        + QnsConstants.preferenceToString(mSettingWfcMode)
-                        + ", mSettingWfcRoamingEnabled="
-                        + mSettingWfcRoamingEnabled
-                        + ", mSettingWfcRoamingMode="
-                        + QnsConstants.preferenceToString(mSettingWfcRoamingMode)
-                        + ", mAllowIwlanForWfcActivation="
-                        + mAllowIwlanForWfcActivation);
-        pw.println(prefix + "mLastProvisioningInfo=" + mLastProvisioningInfo);
-        pw.println(prefix + "mAccessNetworkSelectionPolicies=" + mAccessNetworkSelectionPolicies);
-        pw.println(prefix + "mAnspPolicyMap=" + mAnspPolicyMap);
-        pw.println(prefix + "mCachedTransportTypeForEmergencyInitialConnect"
-                + mCachedTransportTypeForEmergencyInitialConnect);
-        mRestrictManager.dump(pw, prefix + "  ");
-    }
-
-    @VisibleForTesting
-    boolean getSipDialogSessionState() {
-        return mSipDialogSessionState;
-    }
-
-    private void sendMetricsForQualifiedNetworks(QualifiedNetworksInfo info) {
-        if (!mCellularAvailable
-                || !mIwlanAvailable
-                || mCellularAccessNetworkType == AccessNetworkType.UNKNOWN
-                || mLastEvaluateSpecificReason == EVALUATE_SPECIFIC_REASON_DATA_DISCONNECTED) {
-            // b/268557926, decided to cut off if WWAN and WLAN are not in contention.
-            return;
-        }
-        mQnsMetrics.reportAtomForQualifiedNetworks(
-                info,
-                mSlotIndex,
-                mDataConnectionStatusTracker.getLastTransportType(),
-                mCoverage,
-                mSettingWfcEnabled,
-                mSettingWfcRoamingEnabled,
-                mSettingWfcMode,
-                mSettingWfcRoamingMode,
-                mCellularAccessNetworkType,
-                mIwlanAvailable,
-                mIsCrossWfc,
-                mRestrictManager,
-                mCellularQualityMonitor,
-                mWifiQualityMonitor,
-                mCallType);
-    }
-
-    private void sendMetricsForCallTypeChanged(int oldCallType, int newCallType) {
-        int transportTypeOfCall = mDataConnectionStatusTracker.getLastTransportType();
-        mQnsMetrics.reportAtomForCallTypeChanged(mNetCapability, mSlotIndex,
-                oldCallType, newCallType, mRestrictManager, transportTypeOfCall);
-    }
-
-    private void sendMetricsForDataConnectionChanged(
-            DataConnectionStatusTracker.DataConnectionChangedInfo info) {
-        mQnsMetrics.reportAtomForDataConnectionChanged(
-                mNetCapability, mSlotIndex, info, mConfigManager.getCarrierId());
-    }
-
-    private void sendMetricsForImsCallDropStats() {
-        int transportTypeOfCall = mDataConnectionStatusTracker.getLastTransportType();
-        mQnsMetrics.reportAtomForImsCallDropStats(mNetCapability, mSlotIndex, mRestrictManager,
-                mCellularQualityMonitor, mWifiQualityMonitor, transportTypeOfCall,
-                mCellularAccessNetworkType);
-    }
-
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/AccessNetworkSelectionPolicy.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/AccessNetworkSelectionPolicy.java
deleted file mode 100644
index 5f06699..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/AccessNetworkSelectionPolicy.java
+++ /dev/null
@@ -1,295 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import android.telephony.AccessNetworkConstants;
-import android.util.Log;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Objects;
-import java.util.concurrent.atomic.AtomicInteger;
-
-class AccessNetworkSelectionPolicy {
-    private static final AtomicInteger sAid = new AtomicInteger();
-
-    private final int mPolicyId;
-    private final int mNetCapability;
-    private final int mTargetTransportType; // AccessNetworkConstants WWAN or WLAN
-    private final PreCondition mPreCondition;
-    private final PostCondition mPostCondition;
-    private final String mLogTag;
-    private ThresholdGroup mLastMatchedThresholdGroup;
-
-    AccessNetworkSelectionPolicy(
-            int netCapability,
-            int targetTransportType,
-            PreCondition preCondition,
-            List<ThresholdGroup> thgroups) {
-        mPolicyId = sAid.getAndIncrement();
-        mLogTag =
-                QnsConstants.QNS_TAG
-                        + "_"
-                        + AccessNetworkSelectionPolicy.class.getSimpleName()
-                        + "_"
-                        + mPolicyId
-                        + "_"
-                        + QnsUtils.getNameOfNetCapability(netCapability);
-        mNetCapability = netCapability;
-        mTargetTransportType = targetTransportType;
-        mPreCondition = preCondition;
-        mPostCondition = new PostCondition(thgroups);
-    }
-
-    @Override
-    public String toString() {
-        return "[AnsPolicy"
-                + mPolicyId
-                + ":"
-                + QnsUtils.getNameOfNetCapability(mNetCapability)
-                + "]"
-                + QnsConstants.transportTypeToString(mTargetTransportType)
-                + ","
-                + mPreCondition.toString()
-                + mPostCondition.toString();
-    }
-
-    int getTargetTransportType() {
-        return mTargetTransportType;
-    }
-
-    boolean satisfyPrecondition(PreCondition preCondition) {
-        return mPreCondition.satisfied(preCondition);
-    }
-
-    boolean satisfiedByThreshold(
-            QualityMonitor wifiMonitor,
-            QualityMonitor cellMonitor,
-            boolean iwlanAvailable,
-            boolean cellAvailable,
-            int cellularAccessNetworkType) {
-        if (wifiMonitor == null || cellMonitor == null) {
-            return false;
-        }
-        return mPostCondition.satisfiedByThreshold(
-                wifiMonitor, cellMonitor, iwlanAvailable, cellAvailable, cellularAccessNetworkType);
-    }
-
-    List<Threshold> findUnmatchedThresholds(
-            QualityMonitor wifiMonitor, QualityMonitor cellMonitor) {
-        if (wifiMonitor == null || cellMonitor == null) {
-            return null;
-        }
-        return mPostCondition.findUnmatchedThresholds(wifiMonitor, cellMonitor);
-    }
-
-    protected void log(String s) {
-        Log.d(mLogTag, s);
-    }
-
-    boolean hasWifiThresholdWithoutCellularCondition() {
-        return mPostCondition.hasWifiThresholdWithoutCellularCondition();
-    }
-
-    boolean satisfiedWithWifiLowSignalStrength() {
-        List<Threshold> thList =
-                mLastMatchedThresholdGroup.getThresholds(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN);
-        if (thList != null) {
-            for (Threshold th : thList) {
-                if (th.getMatchType() == QnsConstants.THRESHOLD_EQUAL_OR_SMALLER) {
-                    log("satisfiedWithWifiLowSignalStrength");
-                    return true;
-                }
-            }
-        }
-        return false;
-    }
-
-    PreCondition getPreCondition() {
-        return mPreCondition;
-    }
-
-    protected static class PreCondition {
-        @QnsConstants.QnsCallType private final int mCallType;
-        @QnsConstants.WfcModePreference private final int mPreference;
-        @QnsConstants.CellularCoverage private final int mCoverage;
-
-        protected PreCondition(
-                @QnsConstants.QnsCallType int callType,
-                @QnsConstants.WfcModePreference int preference,
-                @QnsConstants.CellularCoverage int coverage) {
-            mCallType = callType;
-            mCoverage = coverage;
-            mPreference = preference;
-        }
-
-        boolean satisfied(PreCondition preCondition) {
-            return (mCallType == preCondition.mCallType)
-                    && (mCoverage == preCondition.mCoverage)
-                    && (mPreference == preCondition.mPreference);
-        }
-
-        int getCallType() {
-            return mCallType;
-        }
-
-        int getPreference() {
-            return mPreference;
-        }
-
-        int getCoverage() {
-            return mCoverage;
-        }
-
-        @Override
-        public String toString() {
-            return QnsConstants.callTypeToString(mCallType)
-                    + ","
-                    + QnsConstants.preferenceToString(mPreference)
-                    + ","
-                    + QnsConstants.coverageToString(mCoverage)
-                    + ",";
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) return true;
-            if (!(o instanceof PreCondition)) return false;
-            PreCondition that = (PreCondition) o;
-            return mCallType == that.mCallType
-                    && mPreference == that.mPreference
-                    && mCoverage == that.mCoverage;
-        }
-
-        @Override
-        public int hashCode() {
-            return Objects.hash(mCallType, mPreference, mCoverage);
-        }
-    }
-
-    protected static class GuardingPreCondition extends PreCondition {
-        @QnsConstants.QnsGuarding private final int mGuarding;
-
-        protected GuardingPreCondition(
-                @QnsConstants.QnsCallType int callType,
-                @QnsConstants.WfcModePreference int preference,
-                @QnsConstants.CellularCoverage int coverage,
-                @QnsConstants.QnsGuarding int guarding) {
-            super(callType, preference, coverage);
-            mGuarding = guarding;
-        }
-
-        boolean satisfied(PreCondition preCondition) {
-            if (preCondition instanceof GuardingPreCondition) {
-                return super.satisfied(preCondition)
-                        && mGuarding == ((GuardingPreCondition) preCondition).mGuarding;
-            }
-            return super.satisfied(preCondition);
-        }
-
-        int getGuarding() {
-            return mGuarding;
-        }
-
-        @Override
-        public String toString() {
-            return QnsConstants.guardingToString(mGuarding) + "," + super.toString();
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) return true;
-            if (!(o instanceof GuardingPreCondition)) return false;
-            if (!super.equals(o)) return false;
-            GuardingPreCondition that = (GuardingPreCondition) o;
-            return mGuarding == that.mGuarding;
-        }
-
-        @Override
-        public int hashCode() {
-            return Objects.hash(super.hashCode(), mGuarding);
-        }
-    }
-
-    protected class PostCondition {
-        private final List<ThresholdGroup> mThresholdGroups;
-
-        protected PostCondition(List<ThresholdGroup> thGroups) {
-            mThresholdGroups = thGroups;
-        }
-
-        protected boolean satisfiedByThreshold(
-                QualityMonitor wifiMonitor,
-                QualityMonitor cellMonitor,
-                boolean iwlanAvailable,
-                boolean cellAvailable,
-                int cellularAccessNetworkType) {
-            // if one of thresholdgroup satisfies, return true;
-            if (mThresholdGroups != null) {
-                for (ThresholdGroup thgroup : mThresholdGroups) {
-                    if (thgroup.satisfiedByThreshold(
-                            wifiMonitor,
-                            cellMonitor,
-                            iwlanAvailable,
-                            cellAvailable,
-                            cellularAccessNetworkType)) {
-                        mLastMatchedThresholdGroup = thgroup;
-                        return true;
-                    }
-                }
-            }
-            return false;
-        }
-
-        protected List<Threshold> findUnmatchedThresholds(
-                QualityMonitor wifiMonitor, QualityMonitor cellMonitor) {
-            List<Threshold> unmatchedThresholds = new ArrayList<>();
-            if (mThresholdGroups != null) {
-                for (ThresholdGroup thgroup : mThresholdGroups) {
-                    unmatchedThresholds.addAll(
-                            thgroup.findUnmatchedThresholds(wifiMonitor, cellMonitor));
-                }
-            }
-            return unmatchedThresholds;
-        }
-
-        boolean hasWifiThresholdWithoutCellularCondition() {
-            if (mThresholdGroups == null) {
-                return false;
-            }
-            for (ThresholdGroup thresholdGroup : mThresholdGroups) {
-                if (thresholdGroup.hasWifiThresholdWithoutCellularCondition()) {
-                    return true;
-                }
-            }
-            return false;
-        }
-
-        @Override
-        public String toString() {
-            StringBuilder sb = new StringBuilder();
-            if (mThresholdGroups != null && mThresholdGroups.size() > 0) {
-                for (ThresholdGroup thgroup : mThresholdGroups) {
-                    sb.append(thgroup.toShortString()).append(",");
-                }
-                sb.deleteCharAt(sb.lastIndexOf(","));
-            }
-            return sb.toString();
-        }
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/AccessNetworkSelectionPolicyBuilder.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/AccessNetworkSelectionPolicyBuilder.java
deleted file mode 100644
index 7b32183..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/AccessNetworkSelectionPolicyBuilder.java
+++ /dev/null
@@ -1,793 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import android.telephony.AccessNetworkConstants;
-import android.telephony.AccessNetworkConstants.AccessNetworkType;
-import android.telephony.SignalThresholdInfo;
-import android.util.Log;
-
-import com.android.telephony.qns.AccessNetworkSelectionPolicy.PreCondition;
-import com.android.telephony.qns.QnsCarrierConfigManager.QnsConfigArray;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.StringTokenizer;
-import java.util.stream.Collectors;
-
-class AccessNetworkSelectionPolicyBuilder {
-
-    static final int WLAN = AccessNetworkConstants.TRANSPORT_TYPE_WLAN;
-    static final int WWAN = AccessNetworkConstants.TRANSPORT_TYPE_WWAN;
-    static final int ROVE_IN = QnsConstants.ROVE_IN;
-    static final int ROVE_OUT = QnsConstants.ROVE_OUT;
-    static final int IDLE = QnsConstants.CALL_TYPE_IDLE;
-    static final int VOICE = QnsConstants.CALL_TYPE_VOICE;
-    static final int VIDEO = QnsConstants.CALL_TYPE_VIDEO;
-    static final int WIFI_PREF = QnsConstants.WIFI_PREF;
-    static final int CELL_PREF = QnsConstants.CELL_PREF;
-    static final int HOME = QnsConstants.COVERAGE_HOME;
-    static final int ROAM = QnsConstants.COVERAGE_ROAM;
-    static final int IWLAN = AccessNetworkConstants.AccessNetworkType.IWLAN;
-    static final int GUARDING_NONE = QnsConstants.GUARDING_NONE;
-    static final int GUARDING_CELL = QnsConstants.GUARDING_CELLULAR;
-    static final int GUARDING_WIFI = QnsConstants.GUARDING_WIFI;
-
-    static final HashMap<AnspKey, String[]> sPolicyMap;
-
-    static {
-        // Default policy map
-        sPolicyMap = new HashMap<>();
-        sPolicyMap.put(new AnspKey(ROVE_IN, WIFI_PREF), new String[] {"Condition:WIFI_GOOD"});
-        sPolicyMap.put(new AnspKey(ROVE_OUT, WIFI_PREF), new String[] {"Condition:WIFI_BAD"});
-        sPolicyMap.put(
-                new AnspKey(ROVE_IN, CELL_PREF), new String[] {"Condition:WIFI_GOOD,CELLULAR_BAD"});
-        sPolicyMap.put(
-                new AnspKey(ROVE_OUT, CELL_PREF),
-                new String[] {"Condition:CELLULAR_GOOD", "Condition:WIFI_BAD,CELLULAR_TOLERABLE"});
-    }
-
-    protected String[] getPolicyInMap(
-            @QnsConstants.RoveDirection int direction, PreCondition preCondition) {
-        return sPolicyMap.get(new AnspKey(direction, preCondition.getPreference()));
-    }
-
-    protected String[] getPolicyInInternal(
-            @QnsConstants.RoveDirection int direction, PreCondition preCondition) {
-        return mConfig.getPolicy(direction, preCondition);
-    }
-
-    protected String[] getPolicy(
-            @QnsConstants.RoveDirection int direction, PreCondition preCondition) {
-        String[] internalPolicies = getPolicyInInternal(direction, preCondition);
-        if (internalPolicies != null) {
-            return internalPolicies;
-        }
-
-        if (mConfig.isTransportTypeSelWithoutSSInRoamSupported()
-                && preCondition.getCoverage() == QnsConstants.COVERAGE_ROAM) {
-            if (mConfig.allowImsOverIwlanCellularLimitedCase()) {
-                List<Integer> supportedAccessNetworks = getSupportAccessNetworkTypes();
-                List<String> policyImsOverIwlan = new ArrayList<>();
-                for (int accessNetwork : supportedAccessNetworks) {
-                    if (accessNetwork == IWLAN) {
-                        continue;
-                    }
-                    if (mConfig.isAccessNetworkAllowed(accessNetwork, mNetCapability)) {
-                        if (preCondition.getPreference() == QnsConstants.CELL_PREF
-                                && direction == QnsConstants.ROVE_OUT) {
-                            String name =
-                                    QnsConstants.accessNetworkTypeToString(accessNetwork)
-                                            + "_AVAILABLE";
-                            policyImsOverIwlan.add("Condition:WIFI_AVAILABLE," + name);
-                        } else if (preCondition.getPreference() == QnsConstants.WIFI_PREF
-                                && direction == QnsConstants.ROVE_IN) {
-                            String name =
-                                    QnsConstants.accessNetworkTypeToString(accessNetwork)
-                                            + "_AVAILABLE";
-                            policyImsOverIwlan.add("Condition:WIFI_AVAILABLE," + name);
-                        }
-                    } else {
-                        if (preCondition.getPreference() == QnsConstants.CELL_PREF
-                                && direction == QnsConstants.ROVE_IN) {
-                            String name =
-                                    QnsConstants.accessNetworkTypeToString(accessNetwork)
-                                            + "_AVAILABLE";
-                            policyImsOverIwlan.add("Condition:WIFI_AVAILABLE," + name);
-                        } else if (preCondition.getPreference() == QnsConstants.WIFI_PREF
-                                && direction == QnsConstants.ROVE_IN) {
-                            String name =
-                                    QnsConstants.accessNetworkTypeToString(accessNetwork)
-                                            + "_AVAILABLE";
-                            policyImsOverIwlan.add("Condition:WIFI_AVAILABLE," + name);
-                        }
-                    }
-                }
-                return policyImsOverIwlan.toArray(String[]::new);
-            } else {
-                if (preCondition.getPreference() == QnsConstants.CELL_PREF
-                        && direction == QnsConstants.ROVE_OUT) {
-                    return new String[] {"Condition:WIFI_AVAILABLE"};
-                } else if (preCondition.getPreference() == QnsConstants.WIFI_PREF
-                        && direction == QnsConstants.ROVE_IN) {
-                    return new String[] {"Condition:WIFI_AVAILABLE"};
-                } else {
-                    return new String[] {"Condition:"};
-                }
-            }
-        }
-        if (mConfig.isCurrentTransportTypeInVoiceCallSupported()
-                && direction == QnsConstants.ROVE_OUT
-                && preCondition.getCallType() == QnsConstants.CALL_TYPE_VOICE
-                && preCondition.getPreference() == QnsConstants.CELL_PREF) {
-            return new String[] {"Condition:WIFI_BAD"};
-        }
-        if (mConfig.isChooseWfcPreferredTransportInBothBadCondition(preCondition.getPreference())) {
-            if (direction == QnsConstants.ROVE_OUT
-                    && preCondition.getPreference() == QnsConstants.CELL_PREF) {
-                return new String[] {"Condition:WIFI_BAD", "Condition:CELLULAR_GOOD"};
-            } else if (direction == QnsConstants.ROVE_IN
-                    && preCondition.getPreference() == QnsConstants.WIFI_PREF) {
-                return new String[] {"Condition:WIFI_GOOD", "Condition:CELLULAR_BAD"};
-            }
-        }
-
-        return getPolicyInMap(direction, preCondition);
-    }
-
-    protected List<Integer> getSupportAccessNetworkTypes() {
-        return List.of(
-                AccessNetworkType.NGRAN,
-                AccessNetworkType.EUTRAN,
-                AccessNetworkType.UTRAN,
-                AccessNetworkType.GERAN,
-                AccessNetworkType.IWLAN);
-    }
-
-    public static synchronized Map<PreCondition, List<AccessNetworkSelectionPolicy>> build(
-            QnsCarrierConfigManager configManager, int netCapability) {
-        AccessNetworkSelectionPolicyBuilder builder;
-        if (configManager.isOverrideImsPreferenceSupported()) {
-            builder = new AnspImsPreferModePolicyBuilder(configManager, netCapability);
-        } else {
-            builder = new AccessNetworkSelectionPolicyBuilder(configManager, netCapability);
-        }
-        return builder.buildAnsp();
-    }
-
-    protected void log(String log) {
-        Log.d(mLogTag, log);
-    }
-
-    protected String mLogTag = "QnsAnspBuilder";
-    protected final QnsCarrierConfigManager mConfig;
-    protected final int mNetCapability;
-
-    AccessNetworkSelectionPolicyBuilder(QnsCarrierConfigManager configManager, int netCapability) {
-        mConfig = configManager;
-        mNetCapability = netCapability;
-    }
-
-    protected Map<PreCondition, List<AccessNetworkSelectionPolicy>> buildAnsp() {
-        List<Integer> directionList = List.of(ROVE_IN, ROVE_OUT);
-        List<Integer> callTypeList = List.of(IDLE, VOICE, VIDEO);
-        List<Integer> preferenceList = List.of(WIFI_PREF, CELL_PREF);
-        List<Integer> coverageList = List.of(HOME, ROAM);
-        List<Integer> guardingList = List.of(GUARDING_NONE, GUARDING_CELL, GUARDING_WIFI);
-
-        Map<PreCondition, List<AccessNetworkSelectionPolicy>> allPolicies = new HashMap<>();
-        boolean enabledGuardingPreCondition = mConfig.hasThresholdGapWithGuardTimer();
-        for (int coverage : coverageList) {
-            for (int preference : preferenceList) {
-                for (int callType : callTypeList) {
-                    for (int direction : directionList) {
-                        if (enabledGuardingPreCondition) {
-                            for (int guarding : guardingList) {
-                                if (direction == ROVE_IN && guarding == GUARDING_CELL) {
-                                    continue;
-                                }
-                                if (direction == ROVE_OUT && guarding == GUARDING_WIFI) {
-                                    continue;
-                                }
-                                PreCondition preCondition =
-                                        new AccessNetworkSelectionPolicy.GuardingPreCondition(
-                                                callType, preference, coverage, guarding);
-                                AccessNetworkSelectionPolicy ansp =
-                                        buildAccessNetworkSelectionPolicy(direction, preCondition);
-                                allPolicies.computeIfAbsent(
-                                        ansp.getPreCondition(), k -> new ArrayList<>());
-                                allPolicies.get(ansp.getPreCondition()).add(ansp);
-                            }
-                        } else {
-                            PreCondition preCondition =
-                                    new PreCondition(callType, preference, coverage);
-                            AccessNetworkSelectionPolicy ansp =
-                                    buildAccessNetworkSelectionPolicy(direction, preCondition);
-                            allPolicies.computeIfAbsent(
-                                    ansp.getPreCondition(), k -> new ArrayList<>());
-                            allPolicies.get(ansp.getPreCondition()).add(ansp);
-                        }
-                    }
-                }
-            }
-        }
-        return allPolicies;
-    }
-
-    protected AccessNetworkSelectionPolicy buildAccessNetworkSelectionPolicy(
-            @QnsConstants.RoveDirection int direction, PreCondition preCondition) {
-        int transportType = direction == ROVE_IN ? WLAN : WWAN;
-        return new AccessNetworkSelectionPolicy(
-                mNetCapability,
-                transportType,
-                preCondition,
-                makeThresholdGroups(direction, preCondition));
-    }
-
-    protected List<ThresholdGroup> makeThresholdGroups(
-            @QnsConstants.RoveDirection int direction, PreCondition preCondition) {
-        String[] policy = getPolicy(direction, preCondition);
-        List<ThresholdGroup> thresholdGroups = new ArrayList<>();
-        if (policy == null) {
-            return thresholdGroups;
-        }
-
-        for (String condition : policy) {
-            List<AnspItem> anspItems = parseCondition(condition, preCondition);
-            addThresholdGroup(thresholdGroups, anspItems, direction, preCondition);
-        }
-
-        List<Threshold> wifiWithoutThs = makeThresholdsWifiWithoutCellular(direction, preCondition);
-        if (!wifiWithoutThs.isEmpty()) {
-            addThresholdGroup(thresholdGroups, wifiWithoutThs);
-        }
-
-        return thresholdGroups;
-    }
-
-    protected List<AnspItem> parseCondition(String condition, PreCondition preCondition) {
-        List<AnspItem> anspItems = AnspItem.parseToPrimitives(condition);
-        List<Integer> supportedAccessNetworkTypes = getSupportAccessNetworkTypes();
-        List<AnspItem> wifiAnspItems = new ArrayList<>();
-        List<AnspItem> cellAnspItems = new ArrayList<>();
-        List<AnspItem> wifiAvailableAnspItems = new ArrayList<>();
-        List<AnspItem> cellAvailableAnspItems = new ArrayList<>();
-        for (int supportedAccessNetwork : supportedAccessNetworkTypes) {
-            boolean bHasThreshold = false;
-            boolean bAddAvailable = false;
-            for (AnspItem anspItem : anspItems) {
-                if (supportedAccessNetwork != anspItem.getAccessNetwork()) {
-                    continue;
-                }
-                if (hasThreshold(anspItem, preCondition)) {
-                    bHasThreshold = true;
-                    if (supportedAccessNetwork == IWLAN) {
-                        wifiAnspItems.add(anspItem);
-                    } else {
-                        cellAnspItems.add(anspItem);
-                    }
-                } else {
-                    bAddAvailable = true;
-                }
-            }
-
-            if (!bHasThreshold && bAddAvailable) {
-                String itemName =
-                        QnsConstants.accessNetworkTypeToString(supportedAccessNetwork)
-                                + "_AVAILABLE";
-                if (supportedAccessNetwork == IWLAN) {
-                    wifiAvailableAnspItems.add(AnspItem.find(itemName));
-                } else {
-                    cellAvailableAnspItems.add(AnspItem.find(itemName));
-                }
-            }
-        }
-        if (!wifiAnspItems.isEmpty() && !cellAvailableAnspItems.isEmpty()) {
-            cellAnspItems.addAll(cellAvailableAnspItems);
-        }
-        if (!cellAnspItems.isEmpty() && !wifiAvailableAnspItems.isEmpty()) {
-            wifiAnspItems.addAll(wifiAvailableAnspItems);
-        }
-
-        wifiAnspItems.addAll(cellAnspItems);
-        return wifiAnspItems;
-    }
-
-    protected void addThresholdGroup(
-            List<ThresholdGroup> thresholdGroups, List<Threshold> thresholds) {
-        for (ThresholdGroup thresholdGroup : thresholdGroups) {
-            if (thresholdGroup.identicalThreshold(thresholds)) {
-                return;
-            }
-        }
-        thresholdGroups.add(new ThresholdGroup(thresholds));
-    }
-
-    protected void addThresholdGroup(
-            List<ThresholdGroup> thresholdGroups,
-            List<AnspItem> anspItems,
-            @QnsConstants.RoveDirection int direction,
-            PreCondition preCondition) {
-        if (anspItems == null || anspItems.isEmpty()) {
-            return;
-        }
-
-        List<AnspItem> wifiAnspItems = new ArrayList<>();
-        List<AnspItem> cellAnspItems = new ArrayList<>();
-        List<Integer> supportedAccessNetworkTypes = getSupportAccessNetworkTypes();
-        for (AnspItem anspItem : anspItems) {
-            if (anspItem.getAccessNetwork() == IWLAN) {
-                wifiAnspItems.add(anspItem);
-            } else {
-                cellAnspItems.add(anspItem);
-            }
-        }
-
-        if (direction == QnsConstants.ROVE_IN) {
-            if (!wifiAnspItems.isEmpty() && !cellAnspItems.isEmpty()) {
-                for (AnspItem wifi : wifiAnspItems) {
-                    for (AnspItem cell : cellAnspItems) {
-                        Threshold wifiTh = makeThreshold(wifi, direction, preCondition);
-                        Threshold cellTh = makeThreshold(cell, direction, preCondition);
-                        addThresholdGroup(thresholdGroups, List.of(wifiTh, cellTh));
-                    }
-                }
-            } else {
-                for (AnspItem cell : cellAnspItems) {
-                    Threshold cellTh = makeThreshold(cell, direction, preCondition);
-                    addThresholdGroup(thresholdGroups, List.of(cellTh));
-                }
-                for (AnspItem wifi : wifiAnspItems) {
-                    Threshold wifiTh = makeThreshold(wifi, direction, preCondition);
-                    addThresholdGroup(thresholdGroups, List.of(wifiTh));
-                }
-            }
-        } else { // ROVE_OUT
-            for (int supportedAccessNetwork : supportedAccessNetworkTypes) {
-                if (supportedAccessNetwork == IWLAN) {
-                    continue;
-                }
-                List<Threshold> thresholdList = new ArrayList<>();
-                for (AnspItem wifi : wifiAnspItems) {
-                    Threshold wifiTh = makeThreshold(wifi, direction, preCondition);
-                    thresholdList.add(wifiTh);
-                }
-                if (!cellAnspItems.isEmpty()) {
-                    boolean isAddedThreshold = false;
-                    for (AnspItem cell : cellAnspItems) {
-                        if (cell.getAccessNetwork() == supportedAccessNetwork) {
-                            Threshold cellTh = makeThreshold(cell, direction, preCondition);
-                            thresholdList.add(cellTh);
-                            isAddedThreshold = true;
-                        }
-                    }
-                    if (!isAddedThreshold) {
-                        continue;
-                    }
-                }
-                if (!thresholdList.isEmpty()) {
-                    addThresholdGroup(thresholdGroups, thresholdList);
-                }
-            }
-        }
-    }
-
-    private Threshold makeThreshold(
-            AnspItem anspItem,
-            @QnsConstants.RoveDirection int direction,
-            PreCondition preCondition) {
-        int adjustThreshold = 0;
-        if (preCondition instanceof AccessNetworkSelectionPolicy.GuardingPreCondition) {
-            AccessNetworkSelectionPolicy.GuardingPreCondition guardingPreCondition =
-                    (AccessNetworkSelectionPolicy.GuardingPreCondition) preCondition;
-            if (direction == ROVE_IN && guardingPreCondition.getGuarding() == GUARDING_WIFI) {
-                adjustThreshold =
-                        mConfig.getThresholdGapWithGuardTimer(
-                                anspItem.getAccessNetwork(), anspItem.getMeasurementType());
-            }
-        }
-        return new Threshold(
-                anspItem.getAccessNetwork(),
-                anspItem.getMeasurementType(),
-                getThreshold(anspItem, preCondition) + adjustThreshold,
-                anspItem.getMatchType(),
-                getBackHaulTimer(anspItem.getAccessNetwork()));
-    }
-
-    protected boolean hasThreshold(AnspItem anspItem, PreCondition preCondition) {
-        return getThreshold(anspItem, preCondition) != QnsConfigArray.INVALID;
-    }
-
-    protected int getThreshold(AnspItem anspItem, PreCondition preCondition) {
-        if (anspItem.getMeasurementType() == AVAILABILITY) {
-            if (anspItem.getQualityType() == AVAIL || anspItem.getQualityType() == UNAVAIL) {
-                return anspItem.getQualityType();
-            }
-            return QnsConfigArray.INVALID;
-        }
-        QnsConfigArray thresholds =
-                mConfig.getThresholdByPref(
-                        anspItem.getAccessNetwork(),
-                        preCondition.getCallType(),
-                        anspItem.getMeasurementType(),
-                        preCondition.getPreference());
-        if (thresholds == null) {
-            return QnsConfigArray.INVALID;
-        }
-        switch (anspItem.getQualityType()) {
-            case GOOD:
-                return thresholds.mGood;
-            case BAD:
-                return thresholds.mBad;
-            case TOLERABLE:
-                if (thresholds.mWorst != QnsConfigArray.INVALID) {
-                    return thresholds.mWorst;
-                }
-                return thresholds.mBad;
-        }
-        return QnsConfigArray.INVALID;
-    }
-
-    protected Threshold makeUnavailableThreshold(
-            @AccessNetworkConstants.RadioAccessNetworkType int accessNetwork) {
-        int backHaulTimer = getBackHaulTimer(accessNetwork);
-        return new Threshold(
-                accessNetwork,
-                QnsConstants.SIGNAL_MEASUREMENT_AVAILABILITY,
-                UNAVAIL,
-                QnsConstants.THRESHOLD_MATCH_TYPE_EQUAL_TO,
-                backHaulTimer);
-    }
-
-    protected List<Threshold> makeThresholdsWifiWithoutCellular(
-            @QnsConstants.RoveDirection int direction, PreCondition preCondition) {
-        List<Threshold> thresholds = new ArrayList<>();
-        int backHaulTimer = getBackHaulTimer(AccessNetworkConstants.AccessNetworkType.IWLAN);
-
-        QnsConfigArray threshold =
-                mConfig.getWifiRssiThresholdWithoutCellular(preCondition.getCallType());
-        if (threshold == null) {
-            return thresholds;
-        }
-        if (threshold.mGood != QnsConfigArray.INVALID && direction == QnsConstants.ROVE_IN) {
-            thresholds.add(
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.IWLAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                            threshold.mGood,
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            backHaulTimer));
-        }
-        if (threshold.mBad != QnsConfigArray.INVALID && direction == QnsConstants.ROVE_OUT) {
-            thresholds.add(
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.IWLAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                            threshold.mBad,
-                            QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                            backHaulTimer));
-        }
-        if (!thresholds.isEmpty()) {
-            for (int an : getSupportAccessNetworkTypes()) {
-                if (an == IWLAN) {
-                    continue;
-                }
-                thresholds.add(makeUnavailableThreshold(an));
-            }
-        }
-        return thresholds;
-    }
-
-    private int getBackHaulTimer(int accessNetwork) {
-        if (accessNetwork == AccessNetworkConstants.AccessNetworkType.IWLAN) {
-            return mConfig.getWIFIRssiBackHaulTimer();
-        }
-        return mConfig.getCellularSSBackHaulTimer();
-    }
-
-    static final int AVAILABILITY = QnsConstants.SIGNAL_MEASUREMENT_AVAILABILITY;
-    static final int EQUAL = QnsConstants.THRESHOLD_MATCH_TYPE_EQUAL_TO;
-    static final int LARGER = QnsConstants.THRESHOLD_EQUAL_OR_LARGER;
-    static final int SMALLER = QnsConstants.THRESHOLD_EQUAL_OR_SMALLER;
-    static final int NGRAN = AccessNetworkConstants.AccessNetworkType.NGRAN;
-    static final int EUTRAN = AccessNetworkConstants.AccessNetworkType.EUTRAN;
-    static final int UTRAN = AccessNetworkConstants.AccessNetworkType.UTRAN;
-    static final int GERAN = AccessNetworkConstants.AccessNetworkType.GERAN;
-    static final int RSSI = SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI;
-    static final int SSRSRP = SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSRSRP;
-    static final int SSRSRQ = SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSRSRQ;
-    static final int SSSINR = SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSSINR;
-    static final int RSRP = SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP;
-    static final int RSRQ = SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRQ;
-    static final int RSSNR = SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR;
-    static final int RSCP = SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSCP;
-    static final int ECNO = SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_ECNO;
-    static final int AVAIL = QnsConstants.SIGNAL_AVAILABLE;
-    static final int UNAVAIL = QnsConstants.SIGNAL_UNAVAILABLE;
-    static final int GOOD = QnsConstants.POLICY_GOOD;
-    static final int BAD = QnsConstants.POLICY_BAD;
-    static final int TOLERABLE = QnsConstants.POLICY_TOLERABLE;
-
-    enum AnspItem {
-        IWLAN_AVAILABLE("IWLAN_AVAILABLE", IWLAN, AVAILABILITY, EQUAL, AVAIL),
-        IWLAN_UNAVAILABLE("IWLAN_UNAVAILABLE", IWLAN, AVAILABILITY, EQUAL, UNAVAIL),
-        IWLAN_RSSI_GOOD("IWLAN_RSSI_GOOD", IWLAN, RSSI, LARGER, GOOD),
-        IWLAN_RSSI_BAD("IWLAN_RSSI_BAD", IWLAN, RSSI, SMALLER, BAD),
-
-        NGRAN_AVAILABLE("NGRAN_AVAILABLE", NGRAN, AVAILABILITY, EQUAL, AVAIL),
-        NGRAN_UNAVAILABLE("NGRAN_UNAVAILABLE", NGRAN, AVAILABILITY, EQUAL, UNAVAIL),
-        NGRAN_SSRSRP_GOOD("NGRAN_SSRSRP_GOOD", NGRAN, SSRSRP, LARGER, GOOD),
-        NGRAN_SSRSRP_BAD("NGRAN_SSRSRP_BAD", NGRAN, SSRSRP, SMALLER, BAD),
-        NGRAN_SSRSRP_TOLERABLE("NGRAN_SSRSRP_TOLERABLE", NGRAN, SSRSRP, LARGER, TOLERABLE),
-        NGRAN_SSRSRQ_GOOD("NGRAN_SSRSRQ_GOOD", NGRAN, SSRSRQ, LARGER, GOOD),
-        NGRAN_SSRSRQ_BAD("NGRAN_SSRSRQ_BAD", NGRAN, SSRSRQ, SMALLER, BAD),
-        NGRAN_SSRSRQ_TOLERABLE("NGRAN_SSRSRQ_TOLERABLE", NGRAN, SSRSRQ, LARGER, TOLERABLE),
-        NGRAN_SSSINR_GOOD("NGRAN_SSSINR_GOOD", NGRAN, SSSINR, LARGER, GOOD),
-        NGRAN_SSSINR_BAD("NGRAN_SSSINR_BAD", NGRAN, SSSINR, SMALLER, BAD),
-        NGRAN_SSSINR_TOLERABLE("NGRAN_SSSINR_TOLERABLE", NGRAN, SSSINR, LARGER, TOLERABLE),
-
-        EUTRAN_AVAILABLE("EUTRAN_AVAILABLE", EUTRAN, AVAILABILITY, EQUAL, AVAIL),
-        EUTRAN_UNAVAILABLE("EUTRAN_UNAVAILABLE", EUTRAN, AVAILABILITY, EQUAL, UNAVAIL),
-        EUTRAN_RSRP_GOOD("EUTRAN_RSRP_GOOD", EUTRAN, RSRP, LARGER, GOOD),
-        EUTRAN_RSRP_BAD("EUTRAN_RSRP_BAD", EUTRAN, RSRP, SMALLER, BAD),
-        EUTRAN_RSRP_TOLERABLE("EUTRAN_RSRP_TOLERABLE", EUTRAN, RSRP, LARGER, TOLERABLE),
-        EUTRAN_RSRQ_GOOD("EUTRAN_RSRQ_GOOD", EUTRAN, RSRQ, LARGER, GOOD),
-        EUTRAN_RSRQ_BAD("EUTRAN_RSRQ_BAD", EUTRAN, RSRQ, SMALLER, BAD),
-        EUTRAN_RSRQ_TOLERABLE("EUTRAN_RSRQ_TOLERABLE", EUTRAN, RSRQ, LARGER, TOLERABLE),
-        EUTRAN_RSSNR_GOOD("EUTRAN_RSSNR_GOOD", EUTRAN, RSSNR, LARGER, GOOD),
-        EUTRAN_RSSNR_BAD("EUTRAN_RSSNR_BAD", EUTRAN, RSSNR, SMALLER, BAD),
-        EUTRAN_RSSNR_TOLERABLE("EUTRAN_RSSNR_TOLERABLE", EUTRAN, RSSNR, LARGER, TOLERABLE),
-
-        UTRAN_AVAILABLE("UTRAN_AVAILABLE", UTRAN, AVAILABILITY, EQUAL, AVAIL),
-        UTRAN_UNAVAILABLE("UTRAN_UNAVAILABLE", UTRAN, AVAILABILITY, EQUAL, UNAVAIL),
-        UTRAN_RSCP_GOOD("UTRAN_RSCP_GOOD", UTRAN, RSCP, LARGER, GOOD),
-        UTRAN_RSCP_BAD("UTRAN_RSCP_BAD", UTRAN, RSCP, SMALLER, BAD),
-        UTRAN_RSCP_TOLERABLE("UTRAN_RSCP_TOLERABLE", UTRAN, RSCP, LARGER, TOLERABLE),
-        UTRAN_ECNO_GOOD("UTRAN_ECNO_GOOD", UTRAN, ECNO, LARGER, GOOD),
-        UTRAN_ECNO_BAD("UTRAN_ECNO_BAD", UTRAN, ECNO, SMALLER, BAD),
-        UTRAN_ECNO_TOLERABLE("UTRAN_ECNO_TOLERABLE", UTRAN, ECNO, LARGER, TOLERABLE),
-
-        GERAN_AVAILABLE("GERAN_AVAILABLE", GERAN, AVAILABILITY, EQUAL, AVAIL),
-        GERAN_UNAVAILABLE("GERAN_UNAVAILABLE", GERAN, AVAILABILITY, EQUAL, UNAVAIL),
-        GERAN_RSSI_GOOD("GERAN_RSSI_GOOD", GERAN, RSSI, LARGER, GOOD),
-        GERAN_RSSI_BAD("GERAN_RSSI_BAD", GERAN, RSSI, SMALLER, BAD),
-        GERAN_RSSI_TOLERABLE("GERAN_RSSI_TOLERABLE", GERAN, RSSI, LARGER, TOLERABLE),
-
-        IWLAN_GOOD("IWLAN_GOOD", new AnspItem[] {IWLAN_RSSI_GOOD}),
-        IWLAN_BAD("IWLAN_BAD", new AnspItem[] {IWLAN_RSSI_BAD}),
-        WIFI_AVAILABLE("WIFI_AVAILABLE", new AnspItem[] {IWLAN_AVAILABLE}),
-        WIFI_UNAVAILABLE("WIFI_UNAVAILABLE", new AnspItem[] {IWLAN_UNAVAILABLE}),
-        WIFI_GOOD("WIFI_GOOD", new AnspItem[] {IWLAN_GOOD}),
-        WIFI_BAD("WIFI_BAD", new AnspItem[] {IWLAN_BAD}),
-
-        NGRAN_GOOD(
-                "NGRAN_GOOD",
-                new AnspItem[] {NGRAN_SSRSRP_GOOD, NGRAN_SSRSRQ_GOOD, NGRAN_SSSINR_GOOD}),
-        NGRAN_BAD(
-                "NGRAN_BAD", new AnspItem[] {NGRAN_SSRSRP_BAD, NGRAN_SSRSRQ_BAD, NGRAN_SSSINR_BAD}),
-        NGRAN_TOLERABLE(
-                "NGRAN_TOLERABLE",
-                new AnspItem[] {
-                    NGRAN_SSRSRP_TOLERABLE, NGRAN_SSRSRQ_TOLERABLE, NGRAN_SSSINR_TOLERABLE
-                }),
-
-        EUTRAN_GOOD(
-                "EUTRAN_GOOD",
-                new AnspItem[] {EUTRAN_RSRP_GOOD, EUTRAN_RSRQ_GOOD, EUTRAN_RSSNR_GOOD}),
-        EUTRAN_BAD(
-                "EUTRAN_BAD", new AnspItem[] {EUTRAN_RSRP_BAD, EUTRAN_RSRQ_BAD, EUTRAN_RSSNR_BAD}),
-        EUTRAN_TOLERABLE(
-                "EUTRAN_TOLERABLE",
-                new AnspItem[] {
-                    EUTRAN_RSRP_TOLERABLE, EUTRAN_RSRQ_TOLERABLE, EUTRAN_RSSNR_TOLERABLE
-                }),
-
-        UTRAN_GOOD("UTRAN_GOOD", new AnspItem[] {UTRAN_RSCP_GOOD, UTRAN_ECNO_GOOD}),
-        UTRAN_BAD("UTRAN_BAD", new AnspItem[] {UTRAN_RSCP_BAD, UTRAN_ECNO_BAD}),
-        UTRAN_TOLERABLE(
-                "UTRAN_TOLERABLE", new AnspItem[] {UTRAN_RSCP_TOLERABLE, UTRAN_ECNO_TOLERABLE}),
-
-        GERAN_GOOD("GERAN_GOOD", new AnspItem[] {GERAN_RSSI_GOOD}),
-        GERAN_BAD("GERAN_BAD", new AnspItem[] {GERAN_RSSI_BAD}),
-        GERAN_TOLERABLE("GERAN_TOLERABLE", new AnspItem[] {GERAN_RSSI_TOLERABLE}),
-
-        CELLULAR_AVAILABLE(
-                "CELLULAR_AVAILABLE",
-                new AnspItem[] {
-                    NGRAN_AVAILABLE, EUTRAN_AVAILABLE, UTRAN_AVAILABLE, GERAN_AVAILABLE
-                }),
-        CELLULAR_UNAVAILABLE(
-                "CELLULAR_UNAVAILABLE",
-                new AnspItem[] {
-                    NGRAN_UNAVAILABLE, EUTRAN_UNAVAILABLE, UTRAN_UNAVAILABLE, GERAN_UNAVAILABLE
-                }),
-        CELLULAR_GOOD(
-                "CELLULAR_GOOD", new AnspItem[] {NGRAN_GOOD, EUTRAN_GOOD, UTRAN_GOOD, GERAN_GOOD}),
-        CELLULAR_BAD("CELLULAR_BAD", new AnspItem[] {NGRAN_BAD, EUTRAN_BAD, UTRAN_BAD, GERAN_BAD}),
-        CELLULAR_TOLERABLE(
-                "CELLULAR_TOLERABLE",
-                new AnspItem[] {
-                    NGRAN_TOLERABLE, EUTRAN_TOLERABLE, UTRAN_TOLERABLE, GERAN_TOLERABLE
-                }),
-        ;
-        private static final Map<String, AnspItem> sAnspItemMap;
-
-        static {
-            sAnspItemMap =
-                    Collections.unmodifiableMap(
-                            Arrays.stream(values())
-                                    .collect(
-                                            Collectors.toMap(
-                                                    AnspItem::getName,
-                                                    anspItem -> anspItem,
-                                                    (a, b) -> b)));
-        }
-
-        private final String mName;
-        private final int mAccessNetwork;
-        private final int mMeasurementType;
-        private final int mMatchType;
-        private final int mQualityType;
-        private final AnspItem[] mAnspItems;
-
-        AnspItem(String name, AnspItem[] items) {
-            mName = name;
-            mAnspItems = items;
-            mAccessNetwork = -1;
-            mMeasurementType = -1;
-            mMatchType = -1;
-            mQualityType = -1;
-        }
-
-        AnspItem(
-                String name,
-                int accessNetwork,
-                int measurementType,
-                int matchType,
-                int qualityType) {
-            mName = name;
-            mAnspItems = null;
-            mAccessNetwork = accessNetwork;
-            mMeasurementType = measurementType;
-            mMatchType = matchType;
-            mQualityType = qualityType;
-        }
-
-        private String getName() {
-            return mName;
-        }
-
-        static AnspItem find(String item) {
-            return sAnspItemMap.get(item);
-        }
-
-        static List<AnspItem> parseToPrimitives(String condition) {
-            List<AnspItem> primitives = new ArrayList<>();
-            if (condition == null) {
-                return primitives;
-            }
-
-            if (condition.startsWith("Condition:")) {
-                StringTokenizer st = new StringTokenizer(condition, ":,");
-                st.nextToken();
-                while (st.hasMoreTokens()) {
-                    String token = st.nextToken();
-                    AnspItem anspItem = AnspItem.find(token);
-                    primitives.addAll(anspItem.toPrimitives());
-                }
-            }
-            return primitives;
-        }
-
-        private Collection<AnspItem> toPrimitives() {
-            if (isPrimitive()) {
-                return List.of(this);
-            }
-            List<AnspItem> primitives = new ArrayList<>();
-            for (AnspItem item : mAnspItems) {
-                primitives.addAll(item.toPrimitives());
-            }
-            return primitives;
-        }
-
-        boolean isPrimitive() {
-            return mAnspItems == null;
-        }
-
-        int getAccessNetwork() {
-            return mAccessNetwork;
-        }
-
-        int getMeasurementType() {
-            return mMeasurementType;
-        }
-
-        int getMatchType() {
-            return mMatchType;
-        }
-
-        int getQualityType() {
-            return mQualityType;
-        }
-    }
-
-    /**
-     * The class AnspKey is the AccessNetworkSelectionPolicy inner class that is used to store or
-     * load policies in a hashmap.
-     */
-    static class AnspKey {
-        private static final int INVALID = 0xFFFF;
-        int mKey1;
-        int mKey2;
-        int mKey3;
-        int mKey4;
-
-        AnspKey(int k1, int k2) {
-            this.mKey1 = k1;
-            this.mKey2 = k2;
-            this.mKey3 = INVALID;
-            this.mKey4 = INVALID;
-        }
-
-        AnspKey(int k1, int k2, int k3) {
-            this.mKey1 = k1;
-            this.mKey2 = k2;
-            this.mKey3 = k3;
-            this.mKey4 = INVALID;
-        }
-
-        AnspKey(int k1, int k2, int k3, int k4) {
-            this.mKey1 = k1;
-            this.mKey2 = k2;
-            this.mKey3 = k3;
-            this.mKey4 = k4;
-        }
-
-        @Override
-        public String toString() {
-            return "MultiKey{"
-                    + "mKey1="
-                    + mKey1
-                    + ", mKey2="
-                    + mKey2
-                    + ", mKey3="
-                    + mKey3
-                    + ", mKey4="
-                    + mKey4
-                    + '}';
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) return true;
-            if (!(o instanceof AnspKey)) return false;
-            AnspKey ak = (AnspKey) o;
-            return mKey1 == ak.mKey1 && mKey2 == ak.mKey2 && mKey3 == ak.mKey3 && mKey4 == ak.mKey4;
-        }
-
-        @Override
-        public int hashCode() {
-            return Objects.hash(mKey1, mKey2, mKey3, mKey4);
-        }
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/AnspImsPreferModePolicyBuilder.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/AnspImsPreferModePolicyBuilder.java
deleted file mode 100644
index 01c3062..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/AnspImsPreferModePolicyBuilder.java
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import android.telephony.AccessNetworkConstants;
-
-import java.util.HashMap;
-import java.util.List;
-
-class AnspImsPreferModePolicyBuilder extends AccessNetworkSelectionPolicyBuilder {
-
-    static final HashMap<AnspKey, String[]> sImsPreferModePolicyMap;
-    AnspImsPreferModePolicyBuilder(
-            QnsCarrierConfigManager configManager, int netCapability) {
-        super(configManager, netCapability);
-        mLogTag = "QnsAnspImsPrefBuilder";
-    }
-
-    static {
-        sImsPreferModePolicyMap = new HashMap<>();
-        sImsPreferModePolicyMap.put(
-                new AnspKey(ROVE_IN, IDLE, WIFI_PREF), new String[] {"Condition:WIFI_AVAILABLE"});
-        sImsPreferModePolicyMap.put(
-                new AnspKey(ROVE_OUT, IDLE, WIFI_PREF),
-                new String[] {"Condition:EUTRAN_TOLERABLE"});
-        sImsPreferModePolicyMap.put(
-                new AnspKey(ROVE_IN, VOICE, WIFI_PREF), new String[] {"Condition:WIFI_GOOD"});
-        sImsPreferModePolicyMap.put(
-                new AnspKey(ROVE_OUT, VOICE, WIFI_PREF),
-                new String[] {"Condition:WIFI_BAD,EUTRAN_TOLERABLE"});
-        sImsPreferModePolicyMap.put(
-                new AnspKey(ROVE_IN, VIDEO, WIFI_PREF), new String[] {"Condition:WIFI_GOOD"});
-        sImsPreferModePolicyMap.put(
-                new AnspKey(ROVE_OUT, VIDEO, WIFI_PREF),
-                new String[] {"Condition:WIFI_BAD,EUTRAN_TOLERABLE"});
-        sImsPreferModePolicyMap.put(
-                new AnspKey(ROVE_IN, IDLE, CELL_PREF, ROAM),
-                new String[] {"Condition:WIFI_GOOD,CELLULAR_BAD"});
-        sImsPreferModePolicyMap.put(
-                new AnspKey(ROVE_OUT, IDLE, CELL_PREF, ROAM),
-                new String[] {"Condition:CELLULAR_GOOD"});
-        sImsPreferModePolicyMap.put(
-                new AnspKey(ROVE_IN, VOICE, CELL_PREF, ROAM),
-                new String[] {"Condition:WIFI_GOOD,CELLULAR_BAD"});
-        sImsPreferModePolicyMap.put(
-                new AnspKey(ROVE_OUT, VOICE, CELL_PREF, ROAM),
-                new String[] {"Condition:WIFI_BAD,EUTRAN_TOLERABLE"});
-        sImsPreferModePolicyMap.put(
-                new AnspKey(ROVE_IN, VIDEO, CELL_PREF, ROAM),
-                new String[] {"Condition:WIFI_GOOD,CELLULAR_BAD"});
-        sImsPreferModePolicyMap.put(
-                new AnspKey(ROVE_OUT, VIDEO, CELL_PREF, ROAM),
-                new String[] {"Condition:WIFI_BAD,EUTRAN_TOLERABLE"});
-        // Overridden rules to ims preference from cellular preference
-        sImsPreferModePolicyMap.put(
-                new AnspKey(ROVE_IN, IDLE, CELL_PREF, HOME),
-                new String[] {
-                    "Condition:WIFI_GOOD,EUTRAN_BAD",
-                    "Condition:WIFI_GOOD,UTRAN_AVAILABLE",
-                    "Condition:WIFI_GOOD,GERAN_AVAILABLE"
-                });
-        sImsPreferModePolicyMap.put(
-                new AnspKey(ROVE_OUT, IDLE, CELL_PREF, HOME),
-                new String[] {
-                    "Condition:EUTRAN_GOOD",
-                    "Condition:WIFI_BAD,EUTRAN_TOLERABLE",
-                    "Condition:WIFI_BAD,UTRAN_GOOD",
-                    "Condition:WIFI_BAD,GERAN_GOOD"
-                });
-        sImsPreferModePolicyMap.put(
-                new AnspKey(ROVE_IN, VOICE, CELL_PREF, HOME),
-                new String[] {
-                    "Condition:WIFI_GOOD,EUTRAN_BAD",
-                    "Condition:WIFI_GOOD,UTRAN_AVAILABLE",
-                    "Condition:WIFI_GOOD,GERAN_AVAILABLE"
-                });
-        sImsPreferModePolicyMap.put(
-                new AnspKey(ROVE_OUT, VOICE, CELL_PREF, HOME),
-                new String[] {
-                    "Condition:EUTRAN_GOOD",
-                    "Condition:WIFI_BAD,EUTRAN_TOLERABLE",
-                    "Condition:WIFI_BAD,UTRAN_GOOD",
-                    "Condition:WIFI_BAD,GERAN_GOOD"
-                });
-        sImsPreferModePolicyMap.put(
-                new AnspKey(ROVE_IN, VIDEO, CELL_PREF, HOME),
-                new String[] {
-                    "Condition:WIFI_GOOD,EUTRAN_BAD",
-                    "Condition:WIFI_GOOD,UTRAN_AVAILABLE",
-                    "Condition:WIFI_GOOD,GERAN_AVAILABLE"
-                });
-        sImsPreferModePolicyMap.put(
-                new AnspKey(ROVE_OUT, VIDEO, CELL_PREF, HOME),
-                new String[] {
-                    "Condition:EUTRAN_GOOD",
-                    "Condition:WIFI_BAD,EUTRAN_TOLERABLE",
-                    "Condition:WIFI_BAD,UTRAN_GOOD",
-                    "Condition:WIFI_BAD,GERAN_GOOD"
-                });
-    }
-
-    @Override
-    protected String[] getPolicyInMap(
-            @QnsConstants.RoveDirection int direction,
-            AccessNetworkSelectionPolicy.PreCondition preCondition) {
-        if (preCondition.getPreference() == WIFI_PREF) {
-            return sImsPreferModePolicyMap.get(
-                    new AnspKey(
-                            direction, preCondition.getCallType(), preCondition.getPreference()));
-        }
-        return sImsPreferModePolicyMap.get(
-                new AnspKey(
-                        direction,
-                        preCondition.getCallType(),
-                        preCondition.getPreference(),
-                        preCondition.getCoverage()));
-    }
-
-    @Override
-    protected List<Integer> getSupportAccessNetworkTypes() {
-        return List.of(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                AccessNetworkConstants.AccessNetworkType.UTRAN,
-                AccessNetworkConstants.AccessNetworkType.GERAN,
-                AccessNetworkConstants.AccessNetworkType.IWLAN);
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/CellularNetworkStatusTracker.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/CellularNetworkStatusTracker.java
deleted file mode 100644
index 9cd7d9f..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/CellularNetworkStatusTracker.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.telephony.qns;
-
-import android.os.Handler;
-import android.util.Log;
-
-/**
- * monitor cellular network status like attach or detach. The CellularNetworkStatusTracker is used
- * as data to evaluate cellular availability and coverage. Availability : Whether the data
- * registration state is in-service. Coverage : Whether the data registration state is Home or Roam.
- */
-class CellularNetworkStatusTracker {
-
-    private final String mLogTag;
-    private final int mSlotIndex;
-    private final QnsTelephonyListener mQnsTelephonyListener;
-
-    /**
-     * Constructor to instantiate CellularNetworkStatusTracker
-     *
-     * @param listener QnsTelephonyListener instance
-     * @param slotIndex slot index
-     */
-    CellularNetworkStatusTracker(QnsTelephonyListener listener, int slotIndex) {
-        mSlotIndex = slotIndex;
-        mLogTag =
-                QnsConstants.QNS_TAG
-                        + "_"
-                        + CellularNetworkStatusTracker.class.getSimpleName()
-                        + "_"
-                        + mSlotIndex;
-        mQnsTelephonyListener = listener;
-    }
-
-    protected void log(String s) {
-        Log.d(mLogTag, s);
-    }
-
-    /**
-     * Register for QnsTelephonyInfoChanged
-     *
-     * @param netCapability Network Capability
-     * @param h Handler
-     * @param what Event
-     */
-    void registerQnsTelephonyInfoChanged(int netCapability, Handler h, int what) {
-        mQnsTelephonyListener.registerQnsTelephonyInfoChanged(netCapability, h, what, null, true);
-    }
-
-    /**
-     * Unregister for QnsTelephonyInfoChanged
-     *
-     * @param netCapability Network Capability
-     * @param h Handler
-     */
-    void unregisterQnsTelephonyInfoChanged(int netCapability, Handler h) {
-        mQnsTelephonyListener.unregisterQnsTelephonyInfoChanged(netCapability, h);
-    }
-
-    boolean isAirplaneModeEnabled() {
-        return mQnsTelephonyListener.isAirplaneModeEnabled();
-    }
-
-    boolean isSupportVoPS() {
-        return mQnsTelephonyListener.isSupportVoPS();
-    }
-
-    boolean isVoiceBarring() {
-        return mQnsTelephonyListener.isVoiceBarring();
-    }
-
-    public void close() {}
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/CellularQualityMonitor.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/CellularQualityMonitor.java
deleted file mode 100644
index c9edc08..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/CellularQualityMonitor.java
+++ /dev/null
@@ -1,590 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.telephony.qns;
-
-import static android.telephony.CellInfo.UNAVAILABLE;
-
-import android.annotation.NonNull;
-import android.content.Context;
-import android.net.NetworkCapabilities;
-import android.os.Binder;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Looper;
-import android.os.Message;
-import android.telephony.AccessNetworkConstants.AccessNetworkType;
-import android.telephony.CellSignalStrength;
-import android.telephony.CellSignalStrengthGsm;
-import android.telephony.CellSignalStrengthLte;
-import android.telephony.CellSignalStrengthNr;
-import android.telephony.CellSignalStrengthWcdma;
-import android.telephony.SignalStrength;
-import android.telephony.SignalStrengthUpdateRequest;
-import android.telephony.SignalThresholdInfo;
-import android.telephony.TelephonyCallback;
-import android.telephony.TelephonyManager;
-import android.util.Log;
-import android.util.SparseArray;
-
-import com.android.internal.annotations.VisibleForTesting;
-
-import java.io.PrintWriter;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.Executor;
-
-/**
- * This class manages cellular threshold information registered from AccessNetworkEvaluator. It
- * extends QualityMonitor class to implement and notify the signal changes in Cellular RAT.
- */
-class CellularQualityMonitor extends QualityMonitor {
-
-    private static final int MAX_THRESHOLD_COUNT =
-            SignalThresholdInfo.MAXIMUM_NUMBER_OF_THRESHOLDS_ALLOWED;
-    private final String mTag;
-    private TelephonyManager mTelephonyManager;
-    private QnsCarrierConfigManager mConfigManager;
-    private int mSubId;
-    private final int mSlotIndex;
-    private boolean mIsQnsListenerRegistered;
-    private final List<SignalThresholdInfo> mSignalThresholdInfoList;
-    private final HandlerThread mHandlerThread;
-
-    /**
-     * thresholdMatrix stores the thresholds according to measurement type and netCapability. For
-     * ex: LTE_RSRP: {TYPE_IMS: [-112, -110, -90], TYPE_XCAP: [-100, -99]} LTE_RSSNR:{TYPE_IMS:
-     * [-10, -15], TYPE_EMERGENCY: [-15]}
-     */
-    private final ConcurrentHashMap<String, SparseArray<List<Integer>>> mThresholdMatrix =
-            new ConcurrentHashMap<>();
-
-    private final HashMap<String, int[]> mThresholdsRegistered = new HashMap<>();
-    private HashMap<String, Integer> mThresholdWaitTimer = new HashMap<>();
-    private SignalStrengthUpdateRequest mSSUpdateRequest;
-    private final CellularSignalStrengthListener mSignalStrengthListener;
-    private final QnsTelephonyListener mQnsTelephonyListener;
-    @VisibleForTesting final Handler mHandler;
-    /**
-     * Constructor to instantiate CellularQualityMonitor
-     *
-     * @param context application context
-     * @param listener QnsTelephonyListener instance
-     * @param slotIndex slot index
-     */
-    CellularQualityMonitor(Context context,
-            QnsCarrierConfigManager configMgr,
-            QnsTelephonyListener listener,
-            int slotIndex) {
-        super(QualityMonitor.class.getSimpleName() + "-C-" + slotIndex);
-        mContext = context;
-        mSlotIndex = slotIndex;
-        mQnsTelephonyListener = listener;
-
-        mTag = CellularQualityMonitor.class.getSimpleName() + "-" + mSlotIndex;
-        mSubId = QnsUtils.getSubId(mContext, mSlotIndex);
-        mIsQnsListenerRegistered = false;
-        mSignalThresholdInfoList = new ArrayList<>();
-        mHandlerThread = new HandlerThread(mTag);
-        mHandlerThread.start();
-        mHandler = new CellularEventsHandler(mHandlerThread.getLooper());
-        mTelephonyManager = mContext.getSystemService(TelephonyManager.class);
-        mQnsTelephonyListener.registerSubscriptionIdListener(
-                mHandler, EVENT_SUBSCRIPTION_ID_CHANGED, null);
-        if (mTelephonyManager != null) {
-            mTelephonyManager = mTelephonyManager.createForSubscriptionId(mSubId);
-        } else {
-            Log.e(mTag, "Failed to get Telephony Service");
-        }
-        mConfigManager = configMgr;
-        mSignalStrengthListener = new CellularSignalStrengthListener(mContext.getMainExecutor());
-        mSignalStrengthListener.setSignalStrengthListener(this::onSignalStrengthsChanged);
-    }
-
-    /** Listener for change of signal strength. */
-    private interface OnSignalStrengthListener {
-        /** Notify the cellular signal strength changed. */
-        void onSignalStrengthsChanged(SignalStrength signalStrength);
-    }
-
-    /** {@link TelephonyCallback} to listen to Cellular Service State Changed. */
-    private class CellularSignalStrengthListener extends TelephonyCallback
-            implements TelephonyCallback.SignalStrengthsListener {
-        private OnSignalStrengthListener mSignalStrengthListener;
-        private Executor mExecutor;
-
-        CellularSignalStrengthListener(Executor executor) {
-            super();
-            mExecutor = executor;
-        }
-
-        void setSignalStrengthListener(OnSignalStrengthListener listener) {
-            mSignalStrengthListener = listener;
-        }
-
-        /** Register a TelephonyCallback for this listener. */
-        void register() {
-            long identity = Binder.clearCallingIdentity();
-            try {
-                mTelephonyManager.registerTelephonyCallback(mExecutor, this);
-            } finally {
-                Binder.restoreCallingIdentity(identity);
-            }
-        }
-
-        /** Unregister a TelephonyCallback for this listener. */
-        void unregister() {
-            mTelephonyManager.unregisterTelephonyCallback(this);
-        }
-
-        @Override
-        public void onSignalStrengthsChanged(@NonNull SignalStrength signalStrength) {
-            if (mSignalStrengthListener != null) {
-                Log.d(mTag, "Signal Strength Changed : " + signalStrength);
-                mSignalStrengthListener.onSignalStrengthsChanged(signalStrength);
-            }
-        }
-    }
-
-    private void onSignalStrengthsChanged(SignalStrength signalStrength) {
-        List<CellSignalStrength> ss = signalStrength.getCellSignalStrengths();
-        if (!ss.isEmpty()) {
-            for (CellSignalStrength cs : ss) {
-                checkAndNotifySignalStrength(cs);
-            }
-        }
-    }
-
-    private void checkAndNotifySignalStrength(CellSignalStrength cellSignalStrength) {
-        Log.d(mTag, "CellSignalStrength Changed: " + cellSignalStrength);
-
-        int signalStrength;
-        for (Map.Entry<String, List<Threshold>> entry : mThresholdsList.entrySet()) {
-            // check if key is in waiting list of backhaul
-            if (mWaitingThresholds.getOrDefault(entry.getKey(), false)) {
-                Log.d(mTag, "Backhaul timer already running for the threshold");
-                continue;
-            }
-            List<Threshold> matchedThresholds = new ArrayList<>();
-            Threshold threshold;
-            for (Threshold th : entry.getValue()) {
-                signalStrength =
-                        getSignalStrength(
-                                th.getAccessNetwork(), th.getMeasurementType(), cellSignalStrength);
-                if (signalStrength != UNAVAILABLE && th.isMatching(signalStrength)) {
-                    threshold = th.copy();
-                    threshold.setThreshold(signalStrength);
-                    matchedThresholds.add(threshold);
-                }
-            }
-            if (matchedThresholds.size() > 0) {
-                notifyThresholdChange(entry.getKey(), matchedThresholds.toArray(new Threshold[0]));
-            }
-        }
-    }
-
-    @Override
-    synchronized int getCurrentQuality(int accessNetwork, int measurementType) {
-        SignalStrength ss = mTelephonyManager.getSignalStrength();
-        int quality = SignalStrength.INVALID; // Int Max Value
-        if (ss != null) {
-            List<CellSignalStrength> cellSignalStrengthList = ss.getCellSignalStrengths();
-            for (CellSignalStrength cs : cellSignalStrengthList) {
-                quality = getSignalStrength(accessNetwork, measurementType, cs);
-                if (quality != UNAVAILABLE) {
-                    return quality;
-                }
-            }
-        }
-        return quality;
-    }
-
-    @Override
-    synchronized void registerThresholdChange(
-            ThresholdCallback thresholdCallback,
-            int netCapability,
-            Threshold[] ths,
-            int slotIndex) {
-        Log.d(mTag, "registerThresholdChange for netCapability= " + netCapability);
-        super.registerThresholdChange(thresholdCallback, netCapability, ths, slotIndex);
-        updateThresholdsForNetCapability(netCapability, slotIndex, ths);
-    }
-
-    @Override
-    synchronized void unregisterThresholdChange(int netCapability, int slotIndex) {
-        Log.d(mTag, "unregisterThresholdChange for netCapability= " + netCapability);
-        super.unregisterThresholdChange(netCapability, slotIndex);
-        updateThresholdsMatrix(netCapability, null);
-        if (updateRegisteredThresholdsArray()) {
-            createSignalThresholdsInfoList();
-            listenRequests();
-        }
-    }
-
-    @Override
-    synchronized void updateThresholdsForNetCapability(
-            int netCapability, int slotIndex, Threshold[] ths) {
-        Log.d(mTag, "updateThresholdsForNetCapability for netCapability= " + netCapability);
-        super.updateThresholdsForNetCapability(netCapability, slotIndex, ths);
-        if (ths != null && ths.length > 0 && !validateThresholdList(ths)) {
-            throw new IllegalStateException("Thresholds are not in valid range.");
-        }
-        updateThresholdsMatrix(netCapability, ths);
-        if (updateRegisteredThresholdsArray()) {
-            createSignalThresholdsInfoList();
-            listenRequests();
-        }
-    }
-
-    @Override
-    protected void notifyThresholdChange(String key, Threshold[] ths) {
-        IThresholdListener listener = mThresholdCallbackMap.get(key);
-        Log.d(mTag, "Notify Threshold Change to listener = " + listener);
-        if (listener != null) {
-            listener.onCellularThresholdChanged(ths);
-        }
-    }
-
-    private void createSignalThresholdsInfoList() {
-        mSignalThresholdInfoList.clear();
-        for (Map.Entry<String, int[]> entry : mThresholdsRegistered.entrySet()) {
-            if (entry.getValue().length == 0) continue;
-            int networkType = Integer.parseInt(entry.getKey().split("_")[0]);
-            int measurementType = Integer.parseInt(entry.getKey().split("_")[1]);
-            SignalThresholdInfo.Builder builder =
-                    new SignalThresholdInfo.Builder()
-                            .setRadioAccessNetworkType(networkType)
-                            .setSignalMeasurementType(measurementType)
-                            .setThresholds(entry.getValue());
-            int backhaulTime = mThresholdWaitTimer.getOrDefault(entry.getKey(), -1);
-            if (backhaulTime > 0) {
-                builder.setHysteresisMs(backhaulTime);
-            }
-            int hysteresisDb = mConfigManager.getWwanHysteresisDbLevel(networkType,
-                    measurementType);
-            builder.setHysteresisDb(hysteresisDb);
-            mSignalThresholdInfoList.add(builder.build());
-            Log.d(mTag, "Updated SignalThresholdInfo List: " + mSignalThresholdInfoList);
-        }
-    }
-
-    private boolean updateRegisteredThresholdsArray() {
-        boolean isUpdated = false;
-        for (Map.Entry<String, SparseArray<List<Integer>>> entry : mThresholdMatrix.entrySet()) {
-            SparseArray<List<Integer>> netCapabilityThresholds =
-                    mThresholdMatrix.getOrDefault(entry.getKey(), new SparseArray<>());
-            Set<Integer> thresholdsSet = new HashSet<>(); // to store unique thresholds
-            int count = 0;
-            for (int i = 0;
-                    (i < netCapabilityThresholds.size() && count <= MAX_THRESHOLD_COUNT);
-                    i++) {
-                List<Integer> thresholdsList =
-                        netCapabilityThresholds.get(
-                                netCapabilityThresholds.keyAt(i), new ArrayList<>());
-                for (int t : thresholdsList) {
-                    if (thresholdsSet.add(t)) {
-                        count++;
-                    }
-                    if (count >= MAX_THRESHOLD_COUNT) {
-                        break;
-                    }
-                }
-            }
-            int[] newThresholds = new int[thresholdsSet.size()];
-            count = 0;
-            for (int i : thresholdsSet) {
-                newThresholds[count++] = i;
-            }
-            Arrays.sort(newThresholds);
-            int[] oldThresholds = mThresholdsRegistered.get(entry.getKey());
-            Log.d(
-                    mTag,
-                    "For measurement type= "
-                            + entry.getKey()
-                            + " old Threshold= "
-                            + Arrays.toString(oldThresholds)
-                            + " new Threshold= "
-                            + Arrays.toString(newThresholds));
-            if (!Arrays.equals(newThresholds, oldThresholds)) {
-                mThresholdsRegistered.put(entry.getKey(), newThresholds);
-                isUpdated = true;
-            }
-        }
-        return isUpdated;
-    }
-
-    private void updateThresholdsMatrix(int netCapability, Threshold[] ths) {
-
-        Log.d(mTag, "Current threshold matrix: " + mThresholdMatrix);
-        // clear old threshold for the netCapability in given netCapability from threshold matrix.
-        for (Map.Entry<String, SparseArray<List<Integer>>> entry : mThresholdMatrix.entrySet()) {
-            SparseArray<List<Integer>> netCapabilityThresholds =
-                    mThresholdMatrix.get(entry.getKey());
-            if (netCapabilityThresholds != null) {
-                netCapabilityThresholds.remove(netCapability);
-            }
-        }
-        if (ths == null || ths.length == 0) {
-            return;
-        }
-
-        // store new thresholds in threshold matrix
-        for (Threshold th : ths) {
-            String key = th.getAccessNetwork() + "_" + th.getMeasurementType();
-            SparseArray<List<Integer>> netCapabilityThresholds =
-                    mThresholdMatrix.getOrDefault(key, new SparseArray<>());
-            List<Integer> thresholdsList =
-                    netCapabilityThresholds.get(netCapability, new ArrayList<>());
-            thresholdsList.add(th.getThreshold());
-            netCapabilityThresholds.put(netCapability, thresholdsList);
-            mThresholdMatrix.put(key, netCapabilityThresholds);
-            mThresholdWaitTimer.put(key, th.getWaitTime());
-        }
-        Log.d(mTag, "updated thresholds matrix: " + mThresholdMatrix);
-    }
-
-    /** This methods stops listening for the thresholds. */
-    private synchronized void clearOldRequests() {
-        if (mSSUpdateRequest != null) {
-            Log.d(mTag, "Clearing request: " + mSSUpdateRequest);
-            mTelephonyManager.clearSignalStrengthUpdateRequest(mSSUpdateRequest);
-            mSSUpdateRequest = null;
-        }
-        mSignalStrengthListener.unregister();
-    }
-
-    /** This methods starts listening for the thresholds. */
-    private void listenRequests() {
-        clearOldRequests();
-        if (mSignalThresholdInfoList.size() > 0) {
-            mSSUpdateRequest =
-                    new SignalStrengthUpdateRequest.Builder()
-                            .setSignalThresholdInfos(mSignalThresholdInfoList)
-                            .setReportingRequestedWhileIdle(true)
-                            .build();
-            mTelephonyManager.setSignalStrengthUpdateRequest(mSSUpdateRequest);
-            Log.d(mTag, "Listening to request: " + mSSUpdateRequest);
-            mSignalStrengthListener.register();
-            if (!mIsQnsListenerRegistered) {
-                mQnsTelephonyListener.registerQnsTelephonyInfoChanged(
-                        NetworkCapabilities.NET_CAPABILITY_IMS,
-                        mHandler,
-                        EVENT_CELLULAR_QNS_TELEPHONY_INFO_CHANGED,
-                        null,
-                        false);
-                mIsQnsListenerRegistered = true;
-            }
-        } else {
-            Log.d(mTag, "No requests are pending to listen");
-            mQnsTelephonyListener.unregisterQnsTelephonyInfoChanged(
-                    NetworkCapabilities.NET_CAPABILITY_IMS, mHandler);
-            mIsQnsListenerRegistered = false;
-        }
-    }
-
-    private int getSignalStrength(int accessNetwork, int measurementType, CellSignalStrength css) {
-        int signalStrength = UNAVAILABLE;
-        switch (measurementType) {
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI:
-                if (accessNetwork == AccessNetworkType.GERAN
-                        && css instanceof CellSignalStrengthGsm) {
-                    signalStrength = ((CellSignalStrengthGsm) css).getRssi();
-                }
-                break;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSCP:
-                if (accessNetwork == AccessNetworkType.UTRAN
-                        && css instanceof CellSignalStrengthWcdma) {
-                    signalStrength = ((CellSignalStrengthWcdma) css).getDbm();
-                }
-                break;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP:
-                if (accessNetwork == AccessNetworkType.EUTRAN
-                        && css instanceof CellSignalStrengthLte) {
-                    signalStrength = ((CellSignalStrengthLte) css).getRsrp();
-                }
-                break;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRQ:
-                if (accessNetwork == AccessNetworkType.EUTRAN
-                        && css instanceof CellSignalStrengthLte) {
-                    signalStrength = ((CellSignalStrengthLte) css).getRsrq();
-                }
-                break;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR:
-                if (accessNetwork == AccessNetworkType.EUTRAN
-                        && css instanceof CellSignalStrengthLte) {
-                    signalStrength = ((CellSignalStrengthLte) css).getRssnr();
-                }
-                break;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSRSRP:
-                if (accessNetwork == AccessNetworkType.NGRAN
-                        && css instanceof CellSignalStrengthNr) {
-                    signalStrength = ((CellSignalStrengthNr) css).getSsRsrp();
-                }
-                break;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSRSRQ:
-                if (accessNetwork == AccessNetworkType.NGRAN
-                        && css instanceof CellSignalStrengthNr) {
-                    signalStrength = ((CellSignalStrengthNr) css).getSsRsrq();
-                }
-                break;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSSINR:
-                if (accessNetwork == AccessNetworkType.NGRAN
-                        && css instanceof CellSignalStrengthNr) {
-                    signalStrength = ((CellSignalStrengthNr) css).getSsSinr();
-                }
-                break;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_ECNO:
-                if (accessNetwork == AccessNetworkType.UTRAN
-                        && css instanceof CellSignalStrengthWcdma) {
-                    signalStrength = ((CellSignalStrengthWcdma) css).getEcNo();
-                }
-                break;
-            default:
-                Log.d(mTag, "measurement type = " + measurementType + " not handled.");
-                break;
-        }
-        return signalStrength;
-    }
-
-    private boolean validateThresholdList(Threshold[] ths) {
-        for (Threshold threshold : ths) {
-            if (!isValidThreshold(threshold.getMeasurementType(), threshold.getThreshold())) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /** Return true if signal measurement type is valid and the threshold value is in range. */
-    private static boolean isValidThreshold(int type, int threshold) {
-        switch (type) {
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI:
-                return threshold >= SignalThresholdInfo.SIGNAL_RSSI_MIN_VALUE
-                        && threshold <= SignalThresholdInfo.SIGNAL_RSSI_MAX_VALUE;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSCP:
-                return threshold >= SignalThresholdInfo.SIGNAL_RSCP_MIN_VALUE
-                        && threshold <= SignalThresholdInfo.SIGNAL_RSCP_MAX_VALUE;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP:
-                return threshold >= SignalThresholdInfo.SIGNAL_RSRP_MIN_VALUE
-                        && threshold <= SignalThresholdInfo.SIGNAL_RSRP_MAX_VALUE;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRQ:
-                return threshold >= SignalThresholdInfo.SIGNAL_RSRQ_MIN_VALUE
-                        && threshold <= SignalThresholdInfo.SIGNAL_RSRQ_MAX_VALUE;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR:
-                return threshold >= SignalThresholdInfo.SIGNAL_RSSNR_MIN_VALUE
-                        && threshold <= SignalThresholdInfo.SIGNAL_RSSNR_MAX_VALUE;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSRSRP:
-                return threshold >= SignalThresholdInfo.SIGNAL_SSRSRP_MIN_VALUE
-                        && threshold <= SignalThresholdInfo.SIGNAL_SSRSRP_MAX_VALUE;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSRSRQ:
-                return threshold >= SignalThresholdInfo.SIGNAL_SSRSRQ_MIN_VALUE
-                        && threshold <= SignalThresholdInfo.SIGNAL_SSRSRQ_MAX_VALUE;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSSINR:
-                return threshold >= SignalThresholdInfo.SIGNAL_SSSINR_MIN_VALUE
-                        && threshold <= SignalThresholdInfo.SIGNAL_SSSINR_MAX_VALUE;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_ECNO:
-                return threshold >= SignalThresholdInfo.SIGNAL_ECNO_MIN_VALUE
-                        && threshold <= SignalThresholdInfo.SIGNAL_ECNO_MAX_VALUE;
-
-            default:
-                return false;
-        }
-    }
-
-    @VisibleForTesting
-    List<SignalThresholdInfo> getSignalThresholdInfo() {
-        return mSignalThresholdInfoList;
-    }
-
-    private class CellularEventsHandler extends Handler {
-        CellularEventsHandler(Looper looper) {
-            super(looper);
-        }
-
-        @Override
-        public void handleMessage(@NonNull Message msg) {
-            Log.d(mTag, "handleMessage what = " + msg.what);
-            QnsAsyncResult ar;
-            switch (msg.what) {
-                case EVENT_CELLULAR_QNS_TELEPHONY_INFO_CHANGED:
-                    ar = (QnsAsyncResult) msg.obj;
-                    if (ar.mException == null
-                            && ar.mResult instanceof QnsTelephonyListener.QnsTelephonyInfo) {
-                        QnsTelephonyListener.QnsTelephonyInfo info =
-                                (QnsTelephonyListener.QnsTelephonyInfo) ar.mResult;
-                        onQnsTelephonyInfoChanged(info);
-                    }
-                    break;
-                case EVENT_SUBSCRIPTION_ID_CHANGED:
-                    ar = (QnsAsyncResult) msg.obj;
-                    int newSubId = (int) ar.mResult;
-                    clearOldRequests();
-                    mSubId = newSubId;
-                    mTelephonyManager =
-                            mContext.getSystemService(TelephonyManager.class)
-                                    .createForSubscriptionId(mSubId);
-                    break;
-                default:
-                    Log.d(mTag, "Not Handled !");
-            }
-        }
-
-        QnsTelephonyListener.QnsTelephonyInfo mLastQnsTelephonyInfo = null;
-
-        private void onQnsTelephonyInfoChanged(QnsTelephonyListener.QnsTelephonyInfo info) {
-            if (mLastQnsTelephonyInfo == null
-                    || mLastQnsTelephonyInfo.getDataNetworkType() != info.getDataNetworkType()
-                    || mLastQnsTelephonyInfo.getDataRegState() != info.getDataRegState()
-                    || mLastQnsTelephonyInfo.isCellularAvailable() != info.isCellularAvailable()) {
-                if (!info.isCellularAvailable()) {
-                    clearOldRequests();
-                }
-                mLastQnsTelephonyInfo = info;
-            }
-        }
-    }
-
-    @VisibleForTesting
-    @Override
-    public void close() {
-        mQnsTelephonyListener.unregisterSubscriptionIdChanged(mHandler);
-        clearOldRequests();
-        mSignalThresholdInfoList.clear();
-        mIsQnsListenerRegistered = false;
-        if (mHandlerThread != null) {
-            mHandlerThread.quit();
-        }
-    }
-
-    @Override
-    void dump(PrintWriter pw, String prefix) {
-        pw.println(prefix + "------------------------------");
-        pw.println(prefix + "CellularQualityMonitor[" + mSlotIndex + "]:");
-        pw.println(prefix + "mSubId=" + mSubId);
-        super.dump(pw, prefix);
-        pw.println(prefix + "mIsQnsListenerRegistered=" + mIsQnsListenerRegistered);
-        pw.println(prefix + "mSignalThresholdInfoList=" + mSignalThresholdInfoList);
-        pw.println(prefix + "mSSUpdateRequest=" + mSSUpdateRequest);
-        pw.println(prefix + "mThresholdMatrix=" + mThresholdMatrix);
-        pw.println(prefix + "mThresholdsRegistered=" + mThresholdsRegistered);
-        pw.println(prefix + "mThresholdWaitTimer=" + mThresholdWaitTimer);
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/DataConnectionStatusTracker.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/DataConnectionStatusTracker.java
deleted file mode 100644
index 976766c..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/DataConnectionStatusTracker.java
+++ /dev/null
@@ -1,377 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import android.annotation.IntDef;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.PreciseDataConnectionState;
-import android.telephony.TelephonyManager;
-import android.telephony.data.ApnSetting;
-import android.util.Log;
-import android.util.SparseArray;
-
-import com.android.internal.annotations.VisibleForTesting;
-
-class DataConnectionStatusTracker {
-    private static final int EVENT_DATA_CONNECTION_STATE_CHANGED = 11001;
-    protected final int mSlotIndex;
-    private final String mLogTag;
-    private final int mNetCapability;
-    @VisibleForTesting protected final Handler mHandler;
-    private DataConnectionChangedInfo mLastUpdatedDcChangedInfo;
-    private final QnsTelephonyListener mQnsTelephonyListener;
-    static final int STATE_INACTIVE = 0;
-    static final int STATE_CONNECTING = 1;
-    static final int STATE_CONNECTED = 2;
-    static final int STATE_HANDOVER = 3;
-
-    @IntDef(
-            value = {
-                STATE_INACTIVE,
-                STATE_CONNECTING,
-                STATE_CONNECTED,
-                STATE_HANDOVER,
-            })
-    @interface DataConnectionState {}
-
-    static final int EVENT_DATA_CONNECTION_DISCONNECTED = 0;
-    static final int EVENT_DATA_CONNECTION_STARTED = 1;
-    static final int EVENT_DATA_CONNECTION_CONNECTED = 2;
-    static final int EVENT_DATA_CONNECTION_FAILED = 3;
-    static final int EVENT_DATA_CONNECTION_HANDOVER_STARTED = 4;
-    static final int EVENT_DATA_CONNECTION_HANDOVER_SUCCESS = 5;
-    static final int EVENT_DATA_CONNECTION_HANDOVER_FAILED = 6;
-
-    @IntDef(
-            value = {
-                EVENT_DATA_CONNECTION_DISCONNECTED,
-                EVENT_DATA_CONNECTION_STARTED,
-                EVENT_DATA_CONNECTION_CONNECTED,
-                EVENT_DATA_CONNECTION_FAILED,
-                EVENT_DATA_CONNECTION_HANDOVER_STARTED,
-                EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                EVENT_DATA_CONNECTION_HANDOVER_FAILED,
-            })
-    @interface DataConnectionChangedEvent {}
-
-    private final QnsRegistrantList mDataConnectionStatusRegistrants;
-    private int mState = STATE_INACTIVE;
-    private int mDataConnectionFailCause;
-    private int mTransportType = AccessNetworkConstants.TRANSPORT_TYPE_INVALID;
-    private SparseArray<ApnSetting> mLastApnSettings = new SparseArray<>();
-
-    /**
-     * Constructor to instantiate CellularQualityMonitor
-     *
-     * @param qnsTelephonyListener QnsTelephonyListener instance
-     * @param looper looper to bind class' handler.
-     * @param slotIndex slot index
-     * @param netCapability integer value of network capability
-     */
-    DataConnectionStatusTracker(
-            QnsTelephonyListener qnsTelephonyListener,
-            Looper looper,
-            int slotIndex,
-            int netCapability) {
-        mLogTag =
-                QnsConstants.QNS_TAG
-                        + "_"
-                        + DataConnectionStatusTracker.class.getSimpleName()
-                        + "_"
-                        + slotIndex
-                        + "_"
-                        + QnsUtils.getNameOfNetCapability(netCapability);
-
-        mSlotIndex = slotIndex;
-        mNetCapability = netCapability;
-
-        mHandler = new DataConnectionStatusTrackerHandler(looper);
-        mDataConnectionStatusRegistrants = new QnsRegistrantList();
-        mQnsTelephonyListener = qnsTelephonyListener;
-        mQnsTelephonyListener.registerPreciseDataConnectionStateChanged(
-                mNetCapability, mHandler, EVENT_DATA_CONNECTION_STATE_CHANGED, null, true);
-    }
-
-    protected void log(String s) {
-        Log.d(mLogTag, s);
-    }
-
-    boolean isInactiveState() {
-        return mState == STATE_INACTIVE;
-    }
-
-    boolean isActiveState() {
-        return mState == STATE_CONNECTED || mState == STATE_HANDOVER;
-    }
-
-    boolean isHandoverState() {
-        return mState == STATE_HANDOVER;
-    }
-
-    boolean isConnectionInProgress() {
-        return mState == STATE_CONNECTING || mState == STATE_HANDOVER;
-    }
-
-    int getLastTransportType() {
-        return mTransportType;
-    }
-
-    int getLastFailCause() {
-        return mDataConnectionFailCause;
-    }
-
-    /** Returns Latest APN setting for the transport type */
-    ApnSetting getLastApnSetting(int transportType) {
-        try {
-            return mLastApnSettings.get(transportType);
-        } catch (Exception e) {
-            return null;
-        }
-    }
-
-    void registerDataConnectionStatusChanged(Handler h, int what) {
-        if (h != null) {
-            mDataConnectionStatusRegistrants.addUnique(h, what, null);
-        }
-        if (mLastUpdatedDcChangedInfo != null) {
-            QnsRegistrant r = new QnsRegistrant(h, what, null);
-            r.notifyResult(mLastUpdatedDcChangedInfo);
-        }
-    }
-
-    void unRegisterDataConnectionStatusChanged(Handler h) {
-        if (h != null) {
-            mDataConnectionStatusRegistrants.remove(h);
-        }
-    }
-
-    private void onDataConnectionStateChanged(PreciseDataConnectionState status) {
-        int transportType = status.getTransportType();
-        int state = status.getState();
-        mDataConnectionFailCause = status.getLastCauseCode();
-        log(
-                "onDataConnectionChanged transportType:"
-                        + QnsConstants.transportTypeToString(transportType)
-                        + " state:"
-                        + QnsConstants.dataStateToString(status.getState())
-                        + " cause:"
-                        + status.getLastCauseCode());
-
-        switch (state) {
-            case TelephonyManager.DATA_DISCONNECTED:
-                if (mState == STATE_CONNECTED || mState == STATE_HANDOVER) {
-                    mState = STATE_INACTIVE;
-                    mTransportType = AccessNetworkConstants.TRANSPORT_TYPE_INVALID;
-                    log("Connection Disconnected");
-                    notifyDataConnectionStatusChangedEvent(EVENT_DATA_CONNECTION_DISCONNECTED);
-                } else {
-                    if (mState == STATE_CONNECTING) {
-                        // Initial connect Failed.
-                        mState = STATE_INACTIVE;
-                        mTransportType = AccessNetworkConstants.TRANSPORT_TYPE_INVALID;
-                        log("Initial connect failed");
-                        notifyDataConnectionFailed(transportType);
-                    }
-                }
-                break;
-
-            case TelephonyManager.DATA_CONNECTING:
-                if (mState == STATE_INACTIVE) {
-                    mState = STATE_CONNECTING;
-                    log(
-                            "Initial Connect inited transport: "
-                                    + QnsConstants.transportTypeToString(transportType));
-                    notifyDataConnectionStarted(transportType);
-                }
-                break;
-
-            case TelephonyManager.DATA_CONNECTED:
-                if (mState == STATE_CONNECTING || mState == STATE_INACTIVE) {
-                    mState = STATE_CONNECTED;
-                    mTransportType = transportType;
-                    log(
-                            "Data Connected Transport: "
-                                    + QnsConstants.transportTypeToString(mTransportType));
-                    notifyDataConnectionStatusChangedEvent(EVENT_DATA_CONNECTION_CONNECTED);
-                } else if (mState == STATE_HANDOVER && mTransportType != transportType) {
-                    mState = STATE_CONNECTED;
-                    mTransportType = transportType;
-                    log(
-                            "Handover completed to: "
-                                    + QnsConstants.transportTypeToString(mTransportType));
-                    notifyDataConnectionStatusChangedEvent(EVENT_DATA_CONNECTION_HANDOVER_SUCCESS);
-                } else if (mState == STATE_HANDOVER && mTransportType == transportType) {
-                    mState = STATE_CONNECTED;
-                    log(
-                            "Handover failed and return to: "
-                                    + QnsConstants.transportTypeToString(mTransportType));
-                    notifyDataConnectionStatusChangedEvent(EVENT_DATA_CONNECTION_HANDOVER_FAILED);
-                }
-                break;
-
-            case TelephonyManager.DATA_SUSPENDED:
-                if (mState == STATE_HANDOVER && mTransportType != transportType) {
-                    mState = STATE_CONNECTED;
-                    mTransportType = transportType;
-                    log(
-                            "QNS assumes Handover completed to: "
-                                    + QnsConstants.transportTypeToString(mTransportType));
-                    notifyDataConnectionStatusChangedEvent(EVENT_DATA_CONNECTION_HANDOVER_SUCCESS);
-                }
-                break;
-
-            case TelephonyManager.DATA_HANDOVER_IN_PROGRESS:
-                if (mState == STATE_CONNECTED && mTransportType == transportType) {
-                    mState = STATE_HANDOVER;
-                    log(
-                            "Handover initiated from "
-                                    + QnsConstants.transportTypeToString(transportType));
-                    notifyDataConnectionStatusChangedEvent(EVENT_DATA_CONNECTION_HANDOVER_STARTED);
-                } else {
-                    log(
-                            "Ignore STATE_HANDOVER since request is not for Src TransportType: "
-                                    + QnsConstants.transportTypeToString(mTransportType));
-                }
-                break;
-
-            default:
-                break;
-        }
-        mLastApnSettings.put(mTransportType, status.getApnSetting());
-    }
-
-    private void notifyDataConnectionStarted(int transportType) {
-        DataConnectionChangedInfo info =
-                new DataConnectionChangedInfo(EVENT_DATA_CONNECTION_STARTED, mState, transportType);
-        mLastUpdatedDcChangedInfo = info;
-        mDataConnectionStatusRegistrants.notifyResult(info);
-    }
-
-    private void notifyDataConnectionFailed(int transportType) {
-        DataConnectionChangedInfo info =
-                new DataConnectionChangedInfo(EVENT_DATA_CONNECTION_FAILED, mState, transportType);
-        mLastUpdatedDcChangedInfo = info;
-        mDataConnectionStatusRegistrants.notifyResult(info);
-    }
-
-    private void notifyDataConnectionStatusChangedEvent(int event) {
-        DataConnectionChangedInfo info =
-                new DataConnectionChangedInfo(event, mState, mTransportType);
-        mLastUpdatedDcChangedInfo = info;
-        mDataConnectionStatusRegistrants.notifyResult(info);
-    }
-
-    void close() {
-        mQnsTelephonyListener.unregisterPreciseDataConnectionStateChanged(mNetCapability, mHandler);
-        mDataConnectionStatusRegistrants.removeAll();
-    }
-
-    static String stateToString(int state) {
-        switch (state) {
-            case STATE_INACTIVE:
-                return "STATE_INCATIVE";
-            case STATE_CONNECTING:
-                return "STATE_CONNCTING";
-            case STATE_CONNECTED:
-                return "STATE_CONNECTED";
-            case STATE_HANDOVER:
-                return "STATE_HANDOVER";
-        }
-        return "INVALID";
-    }
-
-    static String eventToString(int event) {
-        switch (event) {
-            case EVENT_DATA_CONNECTION_DISCONNECTED:
-                return "EVENT_DATA_CONNECTION_DISCONNECTED";
-            case EVENT_DATA_CONNECTION_STARTED:
-                return "EVENT_DATA_CONNECTION_STARTED";
-            case EVENT_DATA_CONNECTION_CONNECTED:
-                return "EVENT_DATA_CONNECTION_CONNECTED";
-            case EVENT_DATA_CONNECTION_FAILED:
-                return "EVENT_DATA_CONNECTION_FAILED";
-            case EVENT_DATA_CONNECTION_HANDOVER_STARTED:
-                return "EVENT_DATA_CONNECTION_HANDOVER_STARTED";
-            case EVENT_DATA_CONNECTION_HANDOVER_SUCCESS:
-                return "EVENT_DATA_CONNECTION_HANDOVER_SUCCESS";
-            case EVENT_DATA_CONNECTION_HANDOVER_FAILED:
-                return "EVENT_DATA_CONNECTION_HANDOVER_FAILED";
-        }
-        return "INVALID";
-    }
-
-    static class DataConnectionChangedInfo {
-        private final int mEvent;
-        private final int mState;
-        private final int mCurrentTransportType;
-
-        @Override
-        public String toString() {
-            return "DataConnectionChangedInfo{"
-                    + "mEvent="
-                    + eventToString(mEvent)
-                    + ", mState="
-                    + stateToString(mState)
-                    + ", mCurrentTransportType="
-                    + QnsConstants.transportTypeToString(mCurrentTransportType)
-                    + '}';
-        }
-
-        DataConnectionChangedInfo(
-                @DataConnectionChangedEvent int event,
-                @DataConnectionState int state,
-                @AccessNetworkConstants.TransportType int transportType) {
-            mEvent = event;
-            mState = state;
-            mCurrentTransportType = transportType;
-        }
-
-        int getState() {
-            return mState;
-        }
-
-        int getEvent() {
-            return mEvent;
-        }
-
-        int getTransportType() {
-            return mCurrentTransportType;
-        }
-    }
-
-    class DataConnectionStatusTrackerHandler extends Handler {
-        DataConnectionStatusTrackerHandler(Looper l) {
-            super(l);
-        }
-
-        @Override
-        public void handleMessage(Message message) {
-            log("handleMessage msg=" + message.what);
-            QnsAsyncResult ar = (QnsAsyncResult) message.obj;
-            switch (message.what) {
-                case EVENT_DATA_CONNECTION_STATE_CHANGED:
-                    onDataConnectionStateChanged((PreciseDataConnectionState) ar.mResult);
-                    break;
-                default:
-                    log("never reach here msg=" + message.what);
-            }
-        }
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/IwlanNetworkStatusTracker.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/IwlanNetworkStatusTracker.java
deleted file mode 100644
index cef9690..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/IwlanNetworkStatusTracker.java
+++ /dev/null
@@ -1,668 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import android.annotation.NonNull;
-import android.content.Context;
-import android.location.Country;
-import android.location.CountryDetector;
-import android.net.ConnectivityManager;
-import android.net.LinkAddress;
-import android.net.LinkProperties;
-import android.net.Network;
-import android.net.NetworkCapabilities;
-import android.net.NetworkSpecifier;
-import android.net.TelephonyNetworkSpecifier;
-import android.net.TransportInfo;
-import android.net.vcn.VcnTransportInfo;
-import android.net.vcn.VcnUtils;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Looper;
-import android.os.Message;
-import android.telephony.TelephonyManager;
-import android.text.TextUtils;
-import android.util.Log;
-import android.util.SparseArray;
-
-import com.android.internal.annotations.VisibleForTesting;
-
-import java.io.PrintWriter;
-import java.net.Inet4Address;
-import java.net.Inet6Address;
-import java.net.InetAddress;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-
-/**
- * IwlanNetworkStatusTracker monitors if there is a network available for IWLAN and informs it to
- * registrants.
- */
-class IwlanNetworkStatusTracker {
-    private static final Boolean DBG = true;
-    private static final String sLogTag = IwlanNetworkStatusTracker.class.getSimpleName();
-    private static final int EVENT_BASE = 1000;
-    private static final int EVENT_IWLAN_SERVICE_STATE_CHANGED = EVENT_BASE;
-    private final Map<Integer, QnsRegistrantList> mIwlanNetworkListenersArray =
-            new ConcurrentHashMap<>();
-    private static final String LAST_KNOWN_COUNTRY_CODE_KEY = "last_known_country_code";
-    private static final int INVALID_SUB_ID = -1;
-    private final SparseArray<QnsCarrierConfigManager> mQnsConfigManagers = new SparseArray<>();
-    private final SparseArray<QnsEventDispatcher> mQnsEventDispatchers = new SparseArray<>();
-    private final SparseArray<QnsImsManager> mQnsImsManagers = new SparseArray<>();
-    private final SparseArray<QnsTelephonyListener> mQnsTelephonyListeners = new SparseArray<>();
-    private final Context mContext;
-    private DefaultNetworkCallback mDefaultNetworkCallback;
-    private final HandlerThread mHandlerThread;
-    private final ConnectivityManager mConnectivityManager;
-    private final TelephonyManager mTelephonyManager;
-    private Handler mNetCbHandler;
-    private String mLastKnownCountryCode;
-    private boolean mWifiAvailable = false;
-    private boolean mWifiToggleOn = false;
-    private Map<Integer, Boolean> mIwlanRegistered = new ConcurrentHashMap<>();
-
-    // The current active data subscription. May not be the default data subscription.
-    private int mConnectedDataSub = INVALID_SUB_ID;
-    @VisibleForTesting SparseArray<IwlanEventHandler> mHandlerSparseArray = new SparseArray<>();
-    @VisibleForTesting SparseArray<IwlanAvailabilityInfo> mLastIwlanAvailabilityInfo =
-            new SparseArray<>();
-    private CountryDetector mCountryDetector;
-
-    enum LinkProtocolType {
-        UNKNOWN,
-        IPV4,
-        IPV6,
-        IPV4V6;
-    }
-
-    private static LinkProtocolType sLinkProtocolType = LinkProtocolType.UNKNOWN;
-
-    class IwlanEventHandler extends Handler {
-        private final int mSlotIndex;
-
-        IwlanEventHandler(int slotId, Looper l) {
-            super(l);
-            mSlotIndex = slotId;
-            List<Integer> events = new ArrayList<>();
-            events.add(QnsEventDispatcher.QNS_EVENT_CROSS_SIM_CALLING_ENABLED);
-            events.add(QnsEventDispatcher.QNS_EVENT_CROSS_SIM_CALLING_DISABLED);
-            events.add(QnsEventDispatcher.QNS_EVENT_WIFI_DISABLING);
-            events.add(QnsEventDispatcher.QNS_EVENT_WIFI_ENABLED);
-            mQnsEventDispatchers.get(mSlotIndex).registerEvent(events, this);
-            mQnsTelephonyListeners
-                    .get(mSlotIndex)
-                    .registerIwlanServiceStateListener(
-                            this, EVENT_IWLAN_SERVICE_STATE_CHANGED, null);
-        }
-
-        @Override
-        public void handleMessage(Message message) {
-            Log.d(sLogTag, "handleMessage msg=" + message.what);
-            switch (message.what) {
-                case QnsEventDispatcher.QNS_EVENT_CROSS_SIM_CALLING_ENABLED:
-                    onCrossSimEnabledEvent(true, mSlotIndex);
-                    break;
-                case QnsEventDispatcher.QNS_EVENT_CROSS_SIM_CALLING_DISABLED:
-                    onCrossSimEnabledEvent(false, mSlotIndex);
-                    break;
-                case QnsEventDispatcher.QNS_EVENT_WIFI_ENABLED:
-                    onWifiEnabled();
-                    break;
-                case QnsEventDispatcher.QNS_EVENT_WIFI_DISABLING:
-                    onWifiDisabling();
-                    break;
-                case EVENT_IWLAN_SERVICE_STATE_CHANGED:
-                    QnsAsyncResult ar = (QnsAsyncResult) message.obj;
-                    boolean isRegistered = (boolean) ar.mResult;
-                    onIwlanServiceStateChanged(mSlotIndex, isRegistered);
-                    break;
-                default:
-                    Log.d(sLogTag, "Unknown message received!");
-                    break;
-            }
-        }
-    }
-
-    IwlanNetworkStatusTracker(@NonNull Context context) {
-        mContext = context;
-        mHandlerThread = new HandlerThread(IwlanNetworkStatusTracker.class.getSimpleName());
-        mHandlerThread.start();
-        Looper looper = mHandlerThread.getLooper();
-        mNetCbHandler = new Handler(looper);
-        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
-        mTelephonyManager = mContext.getSystemService(TelephonyManager.class);
-        mLastIwlanAvailabilityInfo.clear();
-        registerDefaultNetworkCb();
-        Log.d(sLogTag, "Registered with Connectivity Service");
-        startCountryDetector();
-    }
-
-    void initBySlotIndex(
-            @NonNull QnsCarrierConfigManager configManager,
-            @NonNull QnsEventDispatcher dispatcher,
-            @NonNull QnsImsManager imsManager,
-            @NonNull QnsTelephonyListener telephonyListener,
-            int slotId) {
-        mQnsConfigManagers.put(slotId, configManager);
-        mQnsEventDispatchers.put(slotId, dispatcher);
-        mQnsImsManagers.put(slotId, imsManager);
-        mQnsTelephonyListeners.put(slotId, telephonyListener);
-        mHandlerSparseArray.put(slotId, new IwlanEventHandler(slotId, mHandlerThread.getLooper()));
-    }
-
-    void closeBySlotIndex(int slotId) {
-        IwlanEventHandler handler = mHandlerSparseArray.get(slotId);
-        mQnsEventDispatchers.get(slotId).unregisterEvent(handler);
-        mQnsTelephonyListeners.get(slotId).unregisterIwlanServiceStateChanged(handler);
-        mIwlanNetworkListenersArray.remove(slotId);
-        mQnsConfigManagers.remove(slotId);
-        mQnsEventDispatchers.remove(slotId);
-        mQnsImsManagers.remove(slotId);
-        mQnsTelephonyListeners.remove(slotId);
-        mHandlerSparseArray.remove(slotId);
-    }
-
-    @VisibleForTesting
-    void onCrossSimEnabledEvent(boolean enabled, int slotId) {
-        Log.d(sLogTag, "onCrossSimEnabledEvent enabled:" + enabled + " slotIndex:" + slotId);
-        if (enabled) {
-            int activeDataSub = INVALID_SUB_ID;
-            NetworkSpecifier specifier;
-            final Network activeNetwork = mConnectivityManager.getActiveNetwork();
-            if (activeNetwork != null) {
-                final NetworkCapabilities nc =
-                        mConnectivityManager.getNetworkCapabilities(activeNetwork);
-                if (nc != null && nc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
-                    specifier = nc.getNetworkSpecifier();
-                    TransportInfo transportInfo = nc.getTransportInfo();
-                    if (transportInfo instanceof VcnTransportInfo) {
-                        activeDataSub = VcnUtils.getSubIdFromVcnCaps(mConnectivityManager, nc);
-                    } else if (specifier instanceof TelephonyNetworkSpecifier) {
-                        activeDataSub = ((TelephonyNetworkSpecifier) specifier).getSubscriptionId();
-                    }
-                    if (activeDataSub != INVALID_SUB_ID && activeDataSub != mConnectedDataSub) {
-                        mConnectedDataSub = activeDataSub;
-                    }
-                }
-            }
-            notifyIwlanNetworkStatus();
-        } else {
-            notifyIwlanNetworkStatus(true);
-        }
-    }
-
-    @VisibleForTesting
-    void onWifiEnabled() {
-        mWifiToggleOn = true;
-        if (!mWifiAvailable) {
-            for (Integer slotId : mIwlanNetworkListenersArray.keySet()) {
-                if (!isCrossSimCallingCondition(slotId)
-                        && mIwlanRegistered.containsKey(slotId)
-                        && mIwlanRegistered.get(slotId)) {
-                    mWifiAvailable = true;
-                    notifyIwlanNetworkStatus(slotId, false);
-                }
-            }
-        }
-    }
-
-    @VisibleForTesting
-    void onWifiDisabling() {
-        mWifiToggleOn = false;
-        if (mWifiAvailable) {
-            mWifiAvailable = false;
-            notifyIwlanNetworkStatus(true);
-        }
-    }
-
-    @VisibleForTesting
-    void onIwlanServiceStateChanged(int slotId, boolean isRegistered) {
-        mIwlanRegistered.put(slotId, isRegistered);
-        notifyIwlanNetworkStatus(slotId, false);
-    }
-
-    private void notifyIwlanNetworkStatusToRegister(int slotId, QnsRegistrant r) {
-        if (DBG) {
-            Log.d(sLogTag, "notifyIwlanNetworkStatusToRegister");
-        }
-        IwlanAvailabilityInfo info = mLastIwlanAvailabilityInfo.get(slotId);
-        if (info == null) {
-            info = makeIwlanAvailabilityInfo(slotId);
-            mLastIwlanAvailabilityInfo.put(slotId, info);
-        }
-        r.notifyResult(info);
-    }
-
-    private void registerDefaultNetworkCb() {
-        if (mDefaultNetworkCallback == null) {
-            mDefaultNetworkCallback = new DefaultNetworkCallback();
-            mConnectivityManager.registerDefaultNetworkCallback(
-                    mDefaultNetworkCallback, mNetCbHandler);
-        }
-    }
-
-    private void unregisterDefaultNetworkCb() {
-        if (mDefaultNetworkCallback != null) {
-            mConnectivityManager.unregisterNetworkCallback(mDefaultNetworkCallback);
-            mDefaultNetworkCallback = null;
-        }
-    }
-
-    protected void close() {
-        mNetCbHandler.post(this::onClose);
-        mHandlerThread.quitSafely();
-    }
-
-    private void onClose() {
-        unregisterDefaultNetworkCb();
-        mLastIwlanAvailabilityInfo.clear();
-        mIwlanNetworkListenersArray.clear();
-        mIwlanRegistered.clear();
-        mCountryDetector.unregisterCountryDetectorCallback(this::updateCountryCode);
-        Log.d(sLogTag, "closed IwlanNetworkStatusTracker");
-    }
-
-    public void registerIwlanNetworksChanged(int slotId, Handler h, int what) {
-        if (h != null && mHandlerThread.isAlive()) {
-            QnsRegistrant r = new QnsRegistrant(h, what, null);
-            if (mIwlanNetworkListenersArray.get(slotId) == null) {
-                mIwlanNetworkListenersArray.put(slotId, new QnsRegistrantList());
-            }
-            mIwlanNetworkListenersArray.get(slotId).add(r);
-            IwlanEventHandler handler = mHandlerSparseArray.get(slotId);
-            if (handler != null) {
-                IwlanAvailabilityInfo lastInfo = mLastIwlanAvailabilityInfo.get(slotId);
-                IwlanAvailabilityInfo newInfo = makeIwlanAvailabilityInfo(slotId);
-                if (lastInfo == null || !lastInfo.equals(newInfo)) {
-                    // if the LastIwlanAvailabilityInfo is no more valid, notify to all registrants.
-                    handler.post(() -> notifyIwlanNetworkStatus());
-                } else {
-                    // if the LastIwlanAvailabilityInfo is valid, notify to only this registrant.
-                    handler.post(() -> notifyIwlanNetworkStatusToRegister(slotId, r));
-                }
-            }
-        }
-    }
-
-    void unregisterIwlanNetworksChanged(int slotId, Handler h) {
-        if (mIwlanNetworkListenersArray.get(slotId) != null) {
-            mIwlanNetworkListenersArray.get(slotId).remove(h);
-        }
-    }
-
-    private IwlanAvailabilityInfo makeIwlanAvailabilityInfo(int slotId) {
-        boolean iwlanEnable = false;
-        boolean isCrossWfc = false;
-        boolean isRegistered = false;
-        boolean isBlockIpv6OnlyWifi = false;
-        if (mQnsConfigManagers.contains(slotId)) {
-            isBlockIpv6OnlyWifi = mQnsConfigManagers.get(slotId).blockIpv6OnlyWifi();
-        }
-        LinkProtocolType linkProtocolType = sLinkProtocolType;
-
-        if (mIwlanRegistered.containsKey(slotId)) {
-            isRegistered = mIwlanRegistered.get(slotId);
-        }
-
-        if (mWifiAvailable) {
-            boolean blockWifi =
-                    isBlockIpv6OnlyWifi
-                            && ((linkProtocolType == LinkProtocolType.UNKNOWN)
-                                    || (linkProtocolType == LinkProtocolType.IPV6));
-            iwlanEnable = !blockWifi && isRegistered;
-        } else if (isCrossSimCallingCondition(slotId) && isRegistered) {
-            iwlanEnable = true;
-            isCrossWfc = true;
-        }
-        if (DBG) {
-            if (QnsUtils.isCrossSimCallingEnabled(mQnsImsManagers.get(slotId))) {
-                Log.d(
-                        sLogTag,
-                        "makeIwlanAvailabilityInfo(slot:"
-                                + slotId
-                                + ") "
-                                + "mWifiAvailable:"
-                                + mWifiAvailable
-                                + " mConnectedDataSub:"
-                                + mConnectedDataSub
-                                + " isRegistered:"
-                                + isRegistered
-                                + " subId:"
-                                + QnsUtils.getSubId(mContext, slotId)
-                                + " isDDS:"
-                                + QnsUtils.isDefaultDataSubs(slotId)
-                                + " iwlanEnable:"
-                                + iwlanEnable
-                                + " isCrossWfc:"
-                                + isCrossWfc);
-            } else {
-                Log.d(
-                        sLogTag,
-                        "makeIwlanAvailabilityInfo(slot:"
-                                + slotId
-                                + ")"
-                                + " mWifiAvailable:"
-                                + mWifiAvailable
-                                + " isRegistered:"
-                                + isRegistered
-                                + " iwlanEnable:"
-                                + iwlanEnable
-                                + "  isCrossWfc:"
-                                + isCrossWfc
-                                + " isBlockIpv6OnlyWifi:"
-                                + isBlockIpv6OnlyWifi
-                                + " linkProtocolType:"
-                                + linkProtocolType);
-            }
-        }
-        return new IwlanAvailabilityInfo(iwlanEnable, isCrossWfc);
-    }
-
-    private boolean isCrossSimCallingCondition(int slotId) {
-        return QnsUtils.isCrossSimCallingEnabled(mQnsImsManagers.get(slotId))
-                && QnsUtils.getSubId(mContext, slotId) != mConnectedDataSub
-                && mConnectedDataSub != INVALID_SUB_ID;
-    }
-
-    private void notifyIwlanNetworkStatus() {
-        notifyIwlanNetworkStatus(false);
-    }
-
-    private void notifyIwlanNetworkStatus(boolean notifyIwlanDisabled) {
-        for (Integer slotId : mIwlanNetworkListenersArray.keySet()) {
-            notifyIwlanNetworkStatus(slotId, notifyIwlanDisabled);
-        }
-    }
-
-    private void notifyIwlanNetworkStatus(int slotId, boolean notifyIwlanDisabled) {
-        Log.d(sLogTag, "notifyIwlanNetworkStatus for slot: " + slotId);
-        IwlanAvailabilityInfo info = makeIwlanAvailabilityInfo(slotId);
-        if (!info.getIwlanAvailable() && notifyIwlanDisabled) {
-            Log.d(sLogTag, "setNotifyIwlanDisabled for slot: " + slotId);
-            info.setNotifyIwlanDisabled();
-        }
-        if (!info.equals(mLastIwlanAvailabilityInfo.get(slotId))) {
-            Log.d(sLogTag, "notify updated info for slot: " + slotId);
-            if (mIwlanNetworkListenersArray.get(slotId) != null) {
-                mIwlanNetworkListenersArray.get(slotId).notifyResult(info);
-            }
-            mLastIwlanAvailabilityInfo.put(slotId, info);
-        }
-    }
-
-    class IwlanAvailabilityInfo {
-        private boolean mIwlanAvailable = false;
-        private boolean mIsCrossWfc = false;
-        private boolean mNotifyIwlanDisabled = false;
-
-        IwlanAvailabilityInfo(boolean iwlanAvailable, boolean crossWfc) {
-            mIwlanAvailable = iwlanAvailable;
-            mIsCrossWfc = crossWfc;
-        }
-
-        @VisibleForTesting
-        void setNotifyIwlanDisabled() {
-            mNotifyIwlanDisabled = true;
-        }
-
-        boolean getIwlanAvailable() {
-            return mIwlanAvailable;
-        }
-
-        boolean isCrossWfc() {
-            return mIsCrossWfc;
-        }
-
-        @VisibleForTesting
-        boolean getNotifyIwlanDisabled() {
-            return mNotifyIwlanDisabled;
-        }
-
-        boolean equals(IwlanAvailabilityInfo info) {
-            if (info == null) {
-                Log.d(sLogTag, " equals info is null");
-                return false;
-            }
-            Log.d(
-                    sLogTag,
-                    "equals() IwlanAvailable: "
-                            + mIwlanAvailable
-                            + "/"
-                            + info.mIwlanAvailable
-                            + " IsCrossWfc: "
-                            + mIsCrossWfc
-                            + "/"
-                            + info.mIsCrossWfc
-                            + " NotifyIwlanDisabled: "
-                            + mNotifyIwlanDisabled
-                            + "/"
-                            + info.mNotifyIwlanDisabled);
-            return (mIwlanAvailable == info.mIwlanAvailable)
-                    && (mIsCrossWfc == info.mIsCrossWfc)
-                    && (mNotifyIwlanDisabled == info.mNotifyIwlanDisabled);
-        }
-    }
-
-    final class DefaultNetworkCallback extends ConnectivityManager.NetworkCallback {
-        /** Called when the framework connects and has declared a new network ready for use. */
-        @Override
-        public void onAvailable(Network network) {
-            Log.d(sLogTag, "onAvailable: " + network);
-            if (mConnectivityManager != null) {
-                NetworkCapabilities nc = mConnectivityManager.getNetworkCapabilities(network);
-                if (nc != null) {
-                    if (nc.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)) {
-                        mWifiToggleOn = true;
-                        mWifiAvailable = true;
-                        mConnectedDataSub = INVALID_SUB_ID;
-                        notifyIwlanNetworkStatus();
-                    } else if (nc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
-                        NetworkSpecifier specifier = nc.getNetworkSpecifier();
-                        TransportInfo transportInfo = nc.getTransportInfo();
-                        if (transportInfo instanceof VcnTransportInfo) {
-                            mConnectedDataSub =
-                                    VcnUtils.getSubIdFromVcnCaps(mConnectivityManager, nc);
-                        } else if (specifier instanceof TelephonyNetworkSpecifier) {
-                            mConnectedDataSub =
-                                    ((TelephonyNetworkSpecifier) specifier).getSubscriptionId();
-                        }
-                        mWifiAvailable = false;
-                        notifyIwlanNetworkStatus();
-                    }
-                }
-            }
-        }
-
-        /**
-         * Called when the network is about to be lost, typically because there are no outstanding
-         * requests left for it. This may be paired with a {@link
-         * android.net.ConnectivityManager.NetworkCallback#onAvailable} call with the new
-         * replacement network for graceful handover. This method is not guaranteed to be called
-         * before {@link android.net.ConnectivityManager.NetworkCallback#onLost} is called, for
-         * example in case a network is suddenly disconnected.
-         */
-        @Override
-        public void onLosing(Network network, int maxMsToLive) {
-            Log.d(sLogTag, "onLosing: maxMsToLive: " + maxMsToLive + " network: " + network);
-        }
-
-        /**
-         * Called when a network disconnects or otherwise no longer satisfies this request or *
-         * callback.
-         */
-        @Override
-        public void onLost(Network network) {
-            Log.d(sLogTag, "onLost: " + network);
-            if (mWifiAvailable) {
-                mWifiAvailable = false;
-            }
-            if (mConnectedDataSub != INVALID_SUB_ID) {
-                mConnectedDataSub = INVALID_SUB_ID;
-            }
-            sLinkProtocolType = LinkProtocolType.UNKNOWN;
-            notifyIwlanNetworkStatus();
-        }
-
-        /** Called when the network corresponding to this request changes {@link LinkProperties}. */
-        @Override
-        public void onLinkPropertiesChanged(Network network, LinkProperties linkProperties) {
-            Log.d(sLogTag, "onLinkPropertiesChanged: " + linkProperties);
-            if (mWifiAvailable) {
-                LinkProtocolType prevType = sLinkProtocolType;
-
-                checkWifiLinkProtocolType(linkProperties);
-                if (prevType != LinkProtocolType.IPV6
-                        && sLinkProtocolType == LinkProtocolType.IPV6) {
-                    notifyIwlanNetworkStatus(true);
-                } else if (prevType != sLinkProtocolType) {
-                    notifyIwlanNetworkStatus();
-                }
-            }
-        }
-
-        /** Called when access to the specified network is blocked or unblocked. */
-        @Override
-        public void onBlockedStatusChanged(Network network, boolean blocked) {
-            Log.d(sLogTag, "onBlockedStatusChanged: " + " BLOCKED:" + blocked);
-        }
-
-        @Override
-        public void onCapabilitiesChanged(
-                Network network, NetworkCapabilities networkCapabilities) {
-            // onCapabilitiesChanged is guaranteed to be called immediately after onAvailable per
-            // API
-            Log.d(sLogTag, "onCapabilitiesChanged: " + network);
-            NetworkCapabilities nc = networkCapabilities;
-            if (nc != null) {
-                if (nc.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)) {
-                    if (!mWifiAvailable && mWifiToggleOn) {
-                        mWifiAvailable = true;
-                        mConnectedDataSub = INVALID_SUB_ID;
-                        notifyIwlanNetworkStatus();
-                    } else {
-                        Log.d(sLogTag, "OnCapability : Wifi Available already true");
-                    }
-                } else if (nc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
-                    int activeDataSub = INVALID_SUB_ID;
-                    mWifiAvailable = false;
-                    NetworkSpecifier specifier = nc.getNetworkSpecifier();
-                    TransportInfo transportInfo = nc.getTransportInfo();
-                    if (transportInfo instanceof VcnTransportInfo) {
-                        activeDataSub = VcnUtils.getSubIdFromVcnCaps(mConnectivityManager, nc);
-                    } else if (specifier instanceof TelephonyNetworkSpecifier) {
-                        activeDataSub = ((TelephonyNetworkSpecifier) specifier).getSubscriptionId();
-                    }
-                    if (activeDataSub != INVALID_SUB_ID && activeDataSub != mConnectedDataSub) {
-                        mConnectedDataSub = activeDataSub;
-                        notifyIwlanNetworkStatus();
-                    }
-                }
-            }
-        }
-    }
-
-    private void checkWifiLinkProtocolType(@NonNull LinkProperties linkProperties) {
-        boolean hasIpv4 = false;
-        boolean hasIpv6 = false;
-        for (LinkAddress linkAddress : linkProperties.getLinkAddresses()) {
-            InetAddress inetAddress = linkAddress.getAddress();
-            if (inetAddress instanceof Inet4Address) {
-                hasIpv4 = true;
-            } else if (inetAddress instanceof Inet6Address) {
-                hasIpv6 = true;
-            }
-        }
-        if (hasIpv4 && hasIpv6) {
-            sLinkProtocolType = LinkProtocolType.IPV4V6;
-        } else if (hasIpv4) {
-            sLinkProtocolType = LinkProtocolType.IPV4;
-        } else if (hasIpv6) {
-            sLinkProtocolType = LinkProtocolType.IPV6;
-        }
-    }
-
-    /**
-     * This method returns if current country code is outside the home country.
-     *
-     * @return True if it is international roaming, otherwise false.
-     */
-    boolean isInternationalRoaming(int slotId) {
-        boolean isInternationalRoaming = false;
-        String simCountry = mTelephonyManager.createForSubscriptionId(slotId).getSimCountryIso();
-        if (!TextUtils.isEmpty(simCountry) && !TextUtils.isEmpty(mLastKnownCountryCode)) {
-            Log.d(
-                    sLogTag,
-                    "SIM country = " + simCountry + ", current country = " + mLastKnownCountryCode);
-            isInternationalRoaming = !simCountry.equalsIgnoreCase(mLastKnownCountryCode);
-        }
-        return isInternationalRoaming;
-    }
-
-    /**
-     * This method is to add country listener in order to receive country code from the detector.
-     */
-    private void startCountryDetector() {
-        mCountryDetector = mContext.getSystemService(CountryDetector.class);
-        if (mCountryDetector != null) {
-            mCountryDetector.registerCountryDetectorCallback(
-                    new QnsUtils.QnsExecutor(mNetCbHandler), this::updateCountryCode);
-        }
-    }
-
-    /** This method is to update the last known country code if it is changed. */
-    private void updateCountryCode(Country country) {
-        if (country == null) {
-            return;
-        }
-        if (country.getSource() == Country.COUNTRY_SOURCE_NETWORK
-                || country.getSource() == Country.COUNTRY_SOURCE_LOCATION) {
-            String newCountryCode = country.getCountryCode();
-            if (!TextUtils.isEmpty(newCountryCode)
-                    && (TextUtils.isEmpty(mLastKnownCountryCode)
-                            || !mLastKnownCountryCode.equalsIgnoreCase(newCountryCode))) {
-                mLastKnownCountryCode = newCountryCode;
-                Log.d(sLogTag, "Update the last known country code = " + mLastKnownCountryCode);
-            }
-        }
-    }
-
-    /**
-     * Dumps the state of {@link QualityMonitor}
-     *
-     * @param pw {@link PrintWriter} to write the state of the object.
-     * @param prefix String to append at start of dumped log.
-     */
-    void dump(PrintWriter pw, String prefix) {
-        pw.println(prefix + "------------------------------");
-        pw.println(prefix + "IwlanNetworkStatusTracker:");
-        pw.println(
-                prefix
-                        + "mWifiAvailable="
-                        + mWifiAvailable
-                        + ", mWifiToggleOn="
-                        + mWifiToggleOn
-                        + ", mConnectedDataSub="
-                        + mConnectedDataSub
-                        + ", mIwlanRegistered="
-                        + mIwlanRegistered);
-        pw.println(prefix + "sLinkProtocolType=" + sLinkProtocolType);
-        pw.println(prefix + "mLastKnownCountryCode=" + mLastKnownCountryCode);
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsCallStatusTracker.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsCallStatusTracker.java
deleted file mode 100644
index eb2f231..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsCallStatusTracker.java
+++ /dev/null
@@ -1,1020 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static com.android.telephony.qns.QnsConstants.INVALID_ID;
-
-import android.annotation.NonNull;
-import android.net.NetworkCapabilities;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Looper;
-import android.os.Message;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.Annotation;
-import android.telephony.CallQuality;
-import android.telephony.CallState;
-import android.telephony.PreciseCallState;
-import android.telephony.PreciseDataConnectionState;
-import android.telephony.TelephonyManager;
-import android.telephony.ims.ImsCallProfile;
-import android.telephony.ims.MediaQualityStatus;
-import android.util.Log;
-import android.util.SparseArray;
-
-import com.android.internal.annotations.VisibleForTesting;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.function.Consumer;
-
-/**
- * Tracking IMS Call status and update call type changed event to ANE.
- */
-public class QnsCallStatusTracker {
-    private final String mLogTag;
-    private QnsTelephonyListener mTelephonyListener;
-    private QnsCarrierConfigManager mConfigManager;
-    private List<CallState> mCallStates = new ArrayList<>();
-    private QnsRegistrant mCallTypeChangedEventListener;
-    private QnsRegistrant mEmergencyCallTypeChangedEventListener;
-    private final QnsTimer mQnsTimer;
-    private int mLastNormalCallType = QnsConstants.CALL_TYPE_IDLE;
-    private int mLastEmergencyCallType = QnsConstants.CALL_TYPE_IDLE;
-    private boolean mEmergencyOverIms;
-    private ActiveCallTracker mActiveCallTracker;
-    private Consumer<List<CallState>> mCallStatesConsumer =
-            callStateList -> updateCallState(callStateList);
-    private Consumer<Integer> mSrvccStateConsumer = state -> onSrvccStateChangedInternal(state);
-    private Consumer<MediaQualityStatus> mMediaQualityStatusConsumer =
-            status -> mActiveCallTracker.onMediaQualityStatusChanged(status);
-
-    static class CallQualityBlock {
-        int mUpLinkLevel;
-        int mDownLinkLevel;
-        long mCreatedElapsedTime;
-        long mDurationMillis;
-        CallQualityBlock(int uplinkLevel, int downLinkLevel, long createdElapsedTime) {
-            mUpLinkLevel = uplinkLevel;
-            mDownLinkLevel = downLinkLevel;
-            mCreatedElapsedTime = createdElapsedTime;
-        }
-
-        long getUpLinkQualityVolume() {
-            if (mDurationMillis > 0) {
-                return mUpLinkLevel * mDurationMillis;
-            } else {
-                long now = QnsUtils.getSystemElapsedRealTime();
-                return (now - mCreatedElapsedTime) * mUpLinkLevel;
-            }
-        }
-
-        long getDownLinkQualityVolume() {
-            if (mDurationMillis > 0) {
-                return mDownLinkLevel * mDurationMillis;
-            } else {
-                long now = QnsUtils.getSystemElapsedRealTime();
-                return (now - mCreatedElapsedTime) * mDownLinkLevel;
-            }
-        }
-    }
-
-    class ActiveCallTracker {
-        private static final int EVENT_DATA_CONNECTION_STATUS_CHANGED = 3300;
-
-        @QnsConstants.QnsCallType
-        private int mCallType = QnsConstants.CALL_TYPE_IDLE;
-        @Annotation.NetCapability
-        private int mNetCapability = QnsConstants.INVALID_VALUE;
-        private QnsRegistrantList mLowMediaQualityListeners = new QnsRegistrantList();
-        private int mAccessNetwork = AccessNetworkConstants.AccessNetworkType.UNKNOWN;
-        private int mTransportType = AccessNetworkConstants.TRANSPORT_TYPE_INVALID;
-        private SparseArray<CallQuality> mCallQualities = new SparseArray();
-        private TransportQuality mCurrentQuality;
-        /** A list of TransportQuality for each Transport type */
-        private SparseArray<List<TransportQuality>> mTransportQualityArray = new SparseArray<>();
-        private boolean mWwanAvailable = false;
-        private boolean mWlanAvailable = false;
-
-        private boolean mMediaThresholdBreached = false;
-        private HandlerThread mHandlerThread;
-        private ActiveCallTrackerHandler mActiveCallHandler;
-        private MediaLowQualityHandler mLowQualityHandler;
-        private String mLogTag;
-
-        private class ActiveCallTrackerHandler extends Handler {
-            ActiveCallTrackerHandler(Looper l) {
-                super(l);
-            }
-
-            @Override
-            public void handleMessage(Message message) {
-                QnsAsyncResult ar;
-                int transportType;
-                Log.d(mLogTag, "handleMessage : " + message.what);
-                switch (message.what) {
-                    case EVENT_DATA_CONNECTION_STATUS_CHANGED:
-                        ar = (QnsAsyncResult) message.obj;
-                        onDataConnectionStatusChanged(
-                                (PreciseDataConnectionState) ar.mResult);
-                        break;
-
-                    default:
-                        Log.d(mLogTag, "unHandleMessage : " + message.what);
-                        break;
-                }
-
-            }
-        }
-
-        /** Tracking low quality status */
-        private class MediaLowQualityHandler extends Handler {
-            private static final int EVENT_MEDIA_QUALITY_CHANGED = 3401;
-            private static final int EVENT_PACKET_LOSS_TIMER_EXPIRED = 3402;
-            private static final int EVENT_HYSTERESIS_FOR_NORMAL_QUALITY = 3403;
-            private static final int EVENT_POLLING_CHECK_LOW_QUALITY = 3404;
-
-            private static final int STATE_NORMAL_QUALITY = 0;
-            private static final int STATE_SUSPECT_LOW_QUALITY = 1;
-            private static final int STATE_LOW_QUALITY = 2;
-
-            private static final int HYSTERESIS_TIME_NORMAL_QUALITY_MILLIS = 3000;
-            private static final int LOW_QUALITY_CHECK_INTERVAL_MILLIS = 15000;
-            private static final int LOW_QUALITY_CHECK_AFTER_HO_MILLIS = 3000;
-            private static final int LOW_QUALITY_REPORTED_TIME_INITIAL_VALUE = -1;
-
-            private int mState = STATE_NORMAL_QUALITY;
-            private int mPacketLossTimerId = INVALID_ID;
-            private int mHysteresisTimerId = INVALID_ID;
-            private int mPollingCheckTimerId = INVALID_ID;
-            private MediaQualityStatus mMediaQualityStatus;
-            private String mTag;
-
-            MediaLowQualityHandler(Looper l) {
-                super(l);
-                mTag = mLogTag + "_LQH";
-            }
-
-            @Override
-            public void handleMessage(Message message) {
-                Log.d(mTag, "handleMessage : " + message.what);
-                switch (message.what) {
-                    case EVENT_MEDIA_QUALITY_CHANGED:
-                        MediaQualityStatus status = (MediaQualityStatus) message.obj;
-                        onMediaQualityChanged(status);
-                        break;
-
-                    case EVENT_PACKET_LOSS_TIMER_EXPIRED:
-                        onPacketLossTimerExpired(message.arg1);
-                        break;
-
-                    case EVENT_HYSTERESIS_FOR_NORMAL_QUALITY:
-                        exitLowQualityState();
-                        break;
-
-                    case EVENT_POLLING_CHECK_LOW_QUALITY:
-                        checkLowQuality();
-                        break;
-
-                    default:
-                        Log.d(mLogTag, "unHandleMessage : " + message.what);
-                        break;
-                }
-            }
-
-            private void onMediaQualityChanged(MediaQualityStatus status) {
-                Log.d(mTag, "onMediaQualityChanged " + status);
-                int reason = thresholdBreached(status);
-                boolean needNotify = false;
-                if (reason == 0) {
-                    // Threshold not breached.
-                    mMediaQualityStatus = status;
-                    if (mState == STATE_NORMAL_QUALITY) {
-                        Log.d(mTag, "keeps normal quality.");
-                        mMediaQualityStatus = status;
-                        return;
-                    } else {
-                        // check normal quality is stable or not.
-                        mHysteresisTimerId = mQnsTimer.registerTimer(
-                                Message.obtain(this, EVENT_HYSTERESIS_FOR_NORMAL_QUALITY),
-                                HYSTERESIS_TIME_NORMAL_QUALITY_MILLIS);
-                    }
-                } else {
-                    // Threshold breached.
-                    mQnsTimer.unregisterTimer(mHysteresisTimerId);
-                    mHysteresisTimerId = INVALID_ID;
-                    switch (mState) {
-                        case STATE_NORMAL_QUALITY:
-                        case STATE_SUSPECT_LOW_QUALITY:
-                            if (reason == (1 << QnsConstants.RTP_LOW_QUALITY_REASON_PACKET_LOSS)) {
-                                int delayMillis = (mConfigManager.getRTPMetricsData()).mPktLossTime;
-                                if (delayMillis > 0) {
-                                    if (mState == STATE_NORMAL_QUALITY) {
-                                        enterSuspectLowQualityState(delayMillis);
-                                    }
-                                } else if (delayMillis == 0) {
-                                    needNotify = true;
-                                }
-                            } else {
-                                mQnsTimer.unregisterTimer(mPacketLossTimerId);
-                                mPacketLossTimerId = INVALID_ID;
-                                enterLowQualityState(status);
-                                needNotify = true;
-                            }
-                            break;
-
-                        case STATE_LOW_QUALITY:
-                            if (mMediaQualityStatus.getTransportType() == status.getTransportType()
-                                    && thresholdBreached(mMediaQualityStatus)
-                                    != thresholdBreached(status)) {
-                                needNotify = true;
-                            }
-                            break;
-                    }
-                    mMediaQualityStatus = status;
-                }
-                if (needNotify) {
-                    enterLowQualityState(status);
-                    notifyLowMediaQuality(reason);
-                }
-
-            }
-
-            @VisibleForTesting
-            void enterLowQualityState(MediaQualityStatus status) {
-                Log.d(mTag, "enterLowQualityState " + status);
-                mState = STATE_LOW_QUALITY;
-                mPollingCheckTimerId = mQnsTimer.registerTimer(
-                        Message.obtain(this, EVENT_POLLING_CHECK_LOW_QUALITY),
-                        LOW_QUALITY_CHECK_INTERVAL_MILLIS);
-            }
-
-            void enterSuspectLowQualityState(int delayMillis) {
-                Log.d(mTag, "enterSuspectLowQualityState.");
-                mQnsTimer.unregisterTimer(mPacketLossTimerId);
-                Log.d(mTag, "Packet loss timer start. " + delayMillis);
-                Message msg = this.obtainMessage(
-                        EVENT_PACKET_LOSS_TIMER_EXPIRED, mTransportType, 0);
-                mPacketLossTimerId = mQnsTimer.registerTimer(msg, delayMillis);
-                mState = STATE_SUSPECT_LOW_QUALITY;
-            }
-
-            void exitLowQualityState() {
-                mState = STATE_NORMAL_QUALITY;
-                this.removeCallbacksAndMessages(null);
-                mQnsTimer.unregisterTimer(mPacketLossTimerId);
-                mQnsTimer.unregisterTimer(mHysteresisTimerId);
-                mQnsTimer.unregisterTimer(mPollingCheckTimerId);
-                mPacketLossTimerId = INVALID_ID;
-                mHysteresisTimerId = INVALID_ID;
-                mPollingCheckTimerId = INVALID_ID;
-                notifyLowMediaQuality(0);
-            }
-
-            void checkLowQuality() {
-                if (mState == STATE_NORMAL_QUALITY) {
-                    Log.w(mTag, "checkLowQuality on unexpected state(normal state).");
-                } else {
-                    Log.d(mTag, "checkLowQuality");
-                    int reason = thresholdBreached(mMediaQualityStatus);
-                    if (reason > 0) {
-                        notifyLowMediaQuality(thresholdBreached(mMediaQualityStatus));
-                    } else if (mHysteresisTimerId != INVALID_ID) {
-                        // hysteresis time to be normal state is running. let's check after that.
-                        mPollingCheckTimerId = mQnsTimer.registerTimer(
-                                Message.obtain(this, EVENT_POLLING_CHECK_LOW_QUALITY),
-                                HYSTERESIS_TIME_NORMAL_QUALITY_MILLIS);
-                    } else {
-                        Log.w(mTag, "Unexpected case.");
-                    }
-                }
-            }
-
-            void updateForHandover(int transportType) {
-                // restart timers that they need to be restarted on new transport type.
-                if (mState == STATE_SUSPECT_LOW_QUALITY) {
-                    mQnsTimer.unregisterTimer(mPacketLossTimerId);
-                    Message msg = this.obtainMessage(
-                            EVENT_PACKET_LOSS_TIMER_EXPIRED, transportType, 0);
-                    mPacketLossTimerId = mQnsTimer.registerTimer(msg,
-                            (mConfigManager.getRTPMetricsData()).mPktLossTime);
-                }
-                if (mHysteresisTimerId != INVALID_ID) {
-                    mQnsTimer.unregisterTimer(mHysteresisTimerId);
-                    mHysteresisTimerId = mQnsTimer.registerTimer(
-                            Message.obtain(this, EVENT_HYSTERESIS_FOR_NORMAL_QUALITY),
-                            HYSTERESIS_TIME_NORMAL_QUALITY_MILLIS);
-                }
-                if (mState == STATE_LOW_QUALITY) {
-                    mQnsTimer.unregisterTimer(mPollingCheckTimerId);
-                    mPollingCheckTimerId = mQnsTimer.registerTimer(
-                            Message.obtain(this, EVENT_POLLING_CHECK_LOW_QUALITY),
-                            LOW_QUALITY_CHECK_AFTER_HO_MILLIS);
-                }
-            }
-
-            private void onPacketLossTimerExpired(int transportType) {
-                if (mTransportType != transportType) {
-                    Log.d(mTag, "onPacketLossTimerExpired transport type mismatched.");
-                    if (mState == STATE_SUSPECT_LOW_QUALITY) {
-                        mState = STATE_NORMAL_QUALITY;
-                    }
-                    return;
-                }
-                if (thresholdBreached(mMediaQualityStatus)
-                        == (1 << QnsConstants.RTP_LOW_QUALITY_REASON_PACKET_LOSS)) {
-                    enterLowQualityState(mMediaQualityStatus);
-                    notifyLowMediaQuality(1 << QnsConstants.RTP_LOW_QUALITY_REASON_PACKET_LOSS);
-                }
-            }
-
-            private void notifyLowMediaQuality(int reason) {
-                long now = QnsUtils.getSystemElapsedRealTime();
-                TransportQuality tq = getLastTransportQuality(mTransportType);
-                if (tq != null) {
-                    if (reason > 0) {
-                        tq.mLowRtpQualityReportedTime = now;
-                    } else {
-                        tq.mLowRtpQualityReportedTime = LOW_QUALITY_REPORTED_TIME_INITIAL_VALUE;
-                    }
-                }
-                Log.d(mTag, "notifyLowMediaQuality reason:" + reason + " transport type:"
-                        + QnsConstants.transportTypeToString(mTransportType));
-                mLowMediaQualityListeners.notifyResult(reason);
-            }
-        }
-
-        class TransportQuality {
-            int mTransportType = AccessNetworkConstants.TRANSPORT_TYPE_INVALID;
-            long mLowRtpQualityReportedTime =
-                    MediaLowQualityHandler.LOW_QUALITY_REPORTED_TIME_INITIAL_VALUE;
-            List<CallQualityBlock> mCallQualityBlockList;
-
-            TransportQuality(int transportType) {
-                mTransportType = transportType;
-                mCallQualityBlockList = new ArrayList<>();
-            }
-
-            boolean isLowRtpQualityReported() {
-                return mLowRtpQualityReportedTime
-                        != MediaLowQualityHandler.LOW_QUALITY_REPORTED_TIME_INITIAL_VALUE;
-            }
-
-            CallQualityBlock getLastCallQualityBlock() {
-                int length = mCallQualityBlockList.size();
-                if (length > 0) {
-                    return mCallQualityBlockList.get(length - 1);
-                } else {
-                    return null;
-                }
-            }
-        }
-
-        ActiveCallTracker(int slotIndex, Looper looper) {
-            mLogTag = ActiveCallTracker.class.getSimpleName() + "_" + slotIndex;
-            if (looper == null) {
-                mHandlerThread = new HandlerThread(ActiveCallTracker.class.getSimpleName());
-                mHandlerThread.start();
-                mActiveCallHandler = new ActiveCallTrackerHandler(mHandlerThread.getLooper());
-                mLowQualityHandler = new MediaLowQualityHandler(mHandlerThread.getLooper());
-            } else {
-                mActiveCallHandler = new ActiveCallTrackerHandler(looper);
-                mLowQualityHandler = new MediaLowQualityHandler(looper);
-            }
-            mTelephonyListener.addMediaQualityStatusCallback(mMediaQualityStatusConsumer);
-            mTransportQualityArray.put(
-                    AccessNetworkConstants.TRANSPORT_TYPE_WLAN, new ArrayList<>());
-            mTransportQualityArray.put(
-                    AccessNetworkConstants.TRANSPORT_TYPE_WWAN, new ArrayList<>());
-        }
-
-        void close() {
-            mTelephonyListener.removeMediaQualityStatusCallback(mMediaQualityStatusConsumer);
-            if (mNetCapability != QnsConstants.INVALID_VALUE) {
-                mTelephonyListener.unregisterPreciseDataConnectionStateChanged(
-                        mNetCapability, mActiveCallHandler);
-                mNetCapability = QnsConstants.INVALID_VALUE;
-            }
-            if (mHandlerThread != null) {
-                mHandlerThread.quitSafely();
-            }
-        }
-
-        @VisibleForTesting
-        void onDataConnectionStatusChanged(PreciseDataConnectionState state) {
-            if (state == null) {
-                Log.d(mLogTag, "onDataConnectionStatusChanged with null info");
-                return;
-            }
-            if (state.getState() == TelephonyManager.DATA_CONNECTED) {
-                int transportType = state.getTransportType();
-                if (transportType == AccessNetworkConstants.TRANSPORT_TYPE_INVALID) {
-                    Log.w(mLogTag, "Unexpected transport type on connected DataNetwork.");
-                    return;
-                }
-                if (mTransportType == AccessNetworkConstants.TRANSPORT_TYPE_INVALID) {
-                    Log.d(mLogTag, "Call started with "
-                            + QnsConstants.transportTypeToString(transportType));
-                    mTransportType = transportType;
-                    startTrackingTransportQuality(transportType);
-                } else if (mTransportType != transportType) {
-                    Log.d(mLogTag, "Call Handed over to "
-                            + QnsConstants.transportTypeToString(transportType));
-                    mTransportType = transportType;
-                    onHandoverCompleted(transportType);
-                }
-            }
-        }
-
-        private void onHandoverCompleted(
-                @AccessNetworkConstants.TransportType int dstTransportType) {
-            long now = QnsUtils.getSystemElapsedRealTime();
-            // complete to update TransportQuality for prev transport type
-            CallQualityBlock last = null;
-            int prevTransportType = QnsUtils.getOtherTransportType(dstTransportType);
-            TransportQuality prev = getLastTransportQuality(prevTransportType);
-            if (prev != null) {
-                last = prev.getLastCallQualityBlock();
-            }
-            // add a new TransportQuality for new transport type
-            mTransportQualityArray.get(dstTransportType)
-                    .add(new TransportQuality(dstTransportType));
-            TransportQuality current = getLastTransportQuality(dstTransportType);
-            if (last != null) {
-                last.mDurationMillis = now - last.mCreatedElapsedTime;
-                current.mCallQualityBlockList
-                        .add(new CallQualityBlock(last.mUpLinkLevel, last.mDownLinkLevel, now));
-            }
-            mLowQualityHandler.updateForHandover(dstTransportType);
-        }
-
-        private void startTrackingTransportQuality(int transportType) {
-            mTransportQualityArray.get(AccessNetworkConstants.TRANSPORT_TYPE_WLAN).clear();
-            mTransportQualityArray.get(AccessNetworkConstants.TRANSPORT_TYPE_WWAN).clear();
-            mTransportQualityArray.get(transportType)
-                    .add(new TransportQuality(transportType));
-        }
-
-        void callStarted(@QnsConstants.QnsCallType int callType, int netCapability) {
-            if (mCallType != QnsConstants.CALL_TYPE_IDLE) {
-                if (mCallType != callType) {
-                    callTypeUpdated(callType);
-                } else {
-                    Log.w(mLogTag, "call type:" + callType + " already started.");
-                }
-            }
-            Log.d(mLogTag, "callStarted callType: " + callType + " netCapa:"
-                    + QnsUtils.getNameOfNetCapability(netCapability));
-            mCallType = callType;
-            mNetCapability = netCapability;
-            //Transport type will be updated when EVENT_DATA_CONNECTION_STATUS_CHANGED occurs.
-            PreciseDataConnectionState dataState =
-                    mTelephonyListener.getLastPreciseDataConnectionState(netCapability);
-            if (dataState != null && dataState.getTransportType()
-                    != AccessNetworkConstants.TRANSPORT_TYPE_INVALID) {
-                mTransportType = dataState.getTransportType();
-                startTrackingTransportQuality(mTransportType);
-            }
-            mTelephonyListener.registerPreciseDataConnectionStateChanged(mNetCapability,
-                    mActiveCallHandler, EVENT_DATA_CONNECTION_STATUS_CHANGED, null, true);
-        }
-
-        private void callTypeUpdated(@QnsConstants.QnsCallType int callType) {
-            Log.d(mLogTag, "callTypeUpdated from " + mCallType + " to " + callType);
-            mCallType = callType;
-        }
-
-        void callEnded() {
-            mLowQualityHandler.exitLowQualityState();
-            long now = QnsUtils.getSystemElapsedRealTime();
-            // complete to update TransportQuality for prev transport type
-            CallQualityBlock last = null;
-            TransportQuality prev = getLastTransportQuality(mTransportType);
-            if (prev != null) {
-                last = prev.getLastCallQualityBlock();
-            }
-            if (last != null) {
-                last.mDurationMillis = now - last.mCreatedElapsedTime;
-            }
-            long upLinkQualityOverWwan = mActiveCallTracker
-                    .getUpLinkQualityLevelDuringCall(AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-            long upLinkQualityOverWlan = mActiveCallTracker
-                    .getUpLinkQualityLevelDuringCall(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-            long downLinkQualityOverWwan = mActiveCallTracker
-                    .getDownLinkQualityLevelDuringCall(AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-            long downLinkQualityOverWlan = mActiveCallTracker
-                    .getDownLinkQualityLevelDuringCall(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-            StringBuilder sb = new StringBuilder();
-            sb.append("CallQuality [WWAN:");
-            if (upLinkQualityOverWwan == QnsConstants.INVALID_VALUE
-                    || downLinkQualityOverWwan == QnsConstants.INVALID_VALUE) {
-                sb.append("Not available] ");
-            } else {
-                sb.append("upLinkQualityOverWwan = ").append(upLinkQualityOverWwan)
-                        .append(", downLinkQualityOverWwan = ").append(downLinkQualityOverWwan)
-                        .append("] ");
-            }
-            sb.append("[WLAN:");
-            if (upLinkQualityOverWlan == QnsConstants.INVALID_VALUE
-                    || downLinkQualityOverWlan == QnsConstants.INVALID_VALUE) {
-                sb.append("Not available] ");
-            } else {
-                sb.append("upLinkQualityOverWlan = ").append(upLinkQualityOverWwan)
-                        .append(", downLinkQualityOverWlan = ").append(downLinkQualityOverWwan)
-                        .append("] ");
-            }
-            Log.d(mLogTag, "callEnded callType: " + mCallType + " netCapa:"
-                    + QnsUtils.getNameOfNetCapability(mNetCapability) + " " + sb.toString());
-            mCallType = QnsConstants.CALL_TYPE_IDLE;
-            mTelephonyListener.unregisterPreciseDataConnectionStateChanged(
-                    mNetCapability, mActiveCallHandler);
-            mNetCapability = QnsConstants.INVALID_VALUE;
-            mAccessNetwork = AccessNetworkConstants.AccessNetworkType.UNKNOWN;
-            mTransportType = AccessNetworkConstants.TRANSPORT_TYPE_INVALID;
-        }
-
-        void onMediaQualityStatusChanged(MediaQualityStatus status) {
-            if (status == null) {
-                Log.e(mLogTag, "null MediaQualityStatus received.");
-                return;
-            }
-            Message msg = mLowQualityHandler
-                    .obtainMessage(MediaLowQualityHandler.EVENT_MEDIA_QUALITY_CHANGED, status);
-            mLowQualityHandler.sendMessage(msg);
-        }
-
-        int getTransportType() {
-            return this.mTransportType;
-        }
-
-        int getCallType() {
-            return this.mCallType;
-        }
-
-        int getNetCapability() {
-            return this.mNetCapability;
-        }
-
-        @VisibleForTesting
-        TransportQuality getLastTransportQuality(int transportType) {
-            if (transportType == AccessNetworkConstants.TRANSPORT_TYPE_INVALID) {
-                Log.w(mLogTag, "getLastTransportQuality with invalid transport type.");
-                return null;
-            }
-            int size = mTransportQualityArray.get(transportType).size();
-            if (size > 0) {
-                return mTransportQualityArray.get(transportType).get(size - 1);
-            } else {
-                return null;
-            }
-        }
-
-        @VisibleForTesting
-        List<TransportQuality> getTransportQualityList(int transportType) {
-            return mTransportQualityArray.get(transportType);
-        }
-
-        long getUpLinkQualityLevelDuringCall(int transportType) {
-            List<TransportQuality> tqList = getTransportQualityList(transportType);
-            long sumUplinkQualityLevelVolume = 0;
-            long totalDuration = 0;
-            for (int i = 0; i < tqList.size(); i++) {
-                List<CallQualityBlock> callQualityBlockList = tqList.get(i).mCallQualityBlockList;
-                for (int j = 0; j < callQualityBlockList.size(); j++) {
-                    CallQualityBlock cq = callQualityBlockList.get(j);
-                    sumUplinkQualityLevelVolume += cq.getUpLinkQualityVolume();
-                    long durationMillis = cq.mDurationMillis;
-                    if (i == tqList.size() - 1 && j == callQualityBlockList.size() - 1) {
-                        if (durationMillis == 0) {
-                            durationMillis = QnsUtils.getSystemElapsedRealTime()
-                                    - cq.mCreatedElapsedTime;
-                        }
-                    }
-                    if (durationMillis > 0) {
-                        totalDuration += durationMillis;
-                    } else {
-                        return -1;
-                    }
-                }
-            }
-            if (totalDuration <= 0) {
-                return QnsConstants.INVALID_VALUE;
-            }
-            long qualityLevel = sumUplinkQualityLevelVolume / totalDuration;
-            Log.d(mLogTag, "getUplinkQualityLevel for [" + QnsConstants
-                    .transportTypeToString(transportType) + "] totalQualityVolume: "
-                    + sumUplinkQualityLevelVolume + ", totalDuration: " + totalDuration
-                    + " level:" + qualityLevel);
-            return qualityLevel;
-        }
-
-        long getDownLinkQualityLevelDuringCall(int transportType) {
-            List<TransportQuality> tqList = getTransportQualityList(transportType);
-            long sumDownLinkQualityLevelVolume = 0;
-            long totalDuration = 0;
-            for (int i = 0; i < tqList.size(); i++) {
-                List<CallQualityBlock> callQualityBlockList = tqList.get(i).mCallQualityBlockList;
-                for (int j = 0; j < callQualityBlockList.size(); j++) {
-                    CallQualityBlock cq = callQualityBlockList.get(j);
-                    sumDownLinkQualityLevelVolume += cq.getDownLinkQualityVolume();
-                    long durationMillis = cq.mDurationMillis;
-                    if (i == tqList.size() - 1 && j == callQualityBlockList.size() - 1) {
-                        if (durationMillis == 0) {
-                            durationMillis = QnsUtils.getSystemElapsedRealTime()
-                                    - cq.mCreatedElapsedTime;
-                        }
-                    }
-                    if (durationMillis > 0) {
-                        totalDuration += durationMillis;
-                    } else {
-                        return QnsConstants.INVALID_VALUE;
-                    }
-                }
-            }
-            if (totalDuration <= 0) {
-                return QnsConstants.INVALID_VALUE;
-            }
-            long qualityLevel = sumDownLinkQualityLevelVolume / totalDuration;
-            Log.d(mLogTag, "getDownLinkQualityLevel for [" + QnsConstants
-                    .transportTypeToString(transportType) + "] totalQualityVolume: "
-                    + sumDownLinkQualityLevelVolume + ", totalDuration: " + totalDuration
-                    + " level:" + qualityLevel);
-            return qualityLevel;
-        }
-
-        void updateCallQuality(CallState state) {
-            if (state == null) {
-                Log.w(mLogTag, "updateCallQuality Null CallState.");
-                return;
-            }
-            CallQuality cq = state.getCallQuality();
-            if (cq == null || isDummyCallQuality(cq)) {
-                return;
-            }
-            mActiveCallHandler.post(() -> onUpdateCallQuality(cq));
-        }
-
-        private void onUpdateCallQuality(CallQuality cq) {
-            TransportQuality transportQuality = getLastTransportQuality(mTransportType);
-            if (transportQuality != null) {
-                long now = QnsUtils.getSystemElapsedRealTime();
-                CallQualityBlock prev = transportQuality.getLastCallQualityBlock();
-                if (prev != null) {
-                    prev.mDurationMillis = now - prev.mCreatedElapsedTime;
-                }
-                transportQuality.mCallQualityBlockList.add(
-                        new CallQualityBlock(
-                                cq.getUplinkCallQualityLevel(), cq.getDownlinkCallQualityLevel(),
-                                now));
-            }
-        }
-
-        private boolean isDummyCallQuality(CallQuality cq) {
-            return (cq.getNumRtpPacketsTransmitted() == 0
-                    && cq.getNumRtpPacketsReceived() == 0
-                    && cq.getUplinkCallQualityLevel() == 0
-                    && cq.getDownlinkCallQualityLevel() == 0);
-        }
-        /**
-         * Register an event for low media quality report.
-         *
-         * @param h the Handler to get event.
-         * @param what the event.
-         * @param userObj user object.
-         */
-        void registerLowMediaQualityListener(
-                Handler h, int what, Object userObj) {
-            Log.d(mLogTag, "registerLowMediaQualityListener");
-            if (h != null) {
-                QnsRegistrant r = new QnsRegistrant(h, what, userObj);
-                mLowMediaQualityListeners.add(r);
-            }
-        }
-
-        /**
-         * Unregister an event for low media quality report.
-         *
-         * @param h the handler to get event.
-         */
-        void unregisterLowMediaQualityListener(Handler h) {
-            if (h != null) {
-                mLowMediaQualityListeners.remove(h);
-            }
-        }
-
-        @VisibleForTesting
-        int thresholdBreached(MediaQualityStatus status) {
-            int breachedReason = 0;
-            QnsCarrierConfigManager.RtpMetricsConfig rtpConfig = mConfigManager.getRTPMetricsData();
-            if (status.getRtpPacketLossRate() > 0
-                    && status.getRtpPacketLossRate() >= rtpConfig.mPktLossRate) {
-                breachedReason |= 1 << QnsConstants.RTP_LOW_QUALITY_REASON_PACKET_LOSS;
-            }
-            if (status.getRtpJitterMillis() > 0
-                    && status.getRtpJitterMillis() >= rtpConfig.mJitter) {
-                breachedReason |= 1 << QnsConstants.RTP_LOW_QUALITY_REASON_JITTER;
-            }
-            if (status.getRtpInactivityMillis() > 0
-                    && status.getRtpInactivityMillis() >= rtpConfig.mNoRtpInterval) {
-                breachedReason |= 1 << QnsConstants.RTP_LOW_QUALITY_REASON_NO_RTP;
-            }
-            return breachedReason;
-        }
-
-        boolean worseThanBefore(MediaQualityStatus before, MediaQualityStatus now) {
-            return thresholdBreached(now) > thresholdBreached(before);
-        }
-    }
-
-    QnsCallStatusTracker(QnsTelephonyListener telephonyListener,
-            QnsCarrierConfigManager configManager, QnsTimer qnsTimer, int slotIndex) {
-        this(telephonyListener, configManager, qnsTimer, slotIndex, null);
-    }
-
-    /** Only for test */
-    @VisibleForTesting
-    QnsCallStatusTracker(QnsTelephonyListener telephonyListener,
-            QnsCarrierConfigManager configManager, QnsTimer qnsTimer, int slotIndex,
-            Looper looper) {
-        mLogTag = QnsCallStatusTracker.class.getSimpleName() + "_" + slotIndex;
-        mTelephonyListener = telephonyListener;
-        mConfigManager = configManager;
-        mQnsTimer = qnsTimer;
-        mActiveCallTracker = new ActiveCallTracker(slotIndex, looper);
-        mTelephonyListener.addCallStatesChangedCallback(mCallStatesConsumer);
-        mTelephonyListener.addSrvccStateChangedCallback(mSrvccStateConsumer);
-    }
-
-    void close() {
-        mTelephonyListener.removeCallStatesChangedCallback(mCallStatesConsumer);
-        mTelephonyListener.removeSrvccStateChangedCallback(mSrvccStateConsumer);
-        if (mActiveCallTracker != null) {
-            mActiveCallTracker.close();
-        }
-    }
-
-    void updateCallState(List<CallState> callStateList) {
-        List<CallState> imsCallStateList = new ArrayList<>();
-        StringBuilder sb = new StringBuilder("");
-
-        if (callStateList.size() > 0) {
-            for (CallState cs : callStateList) {
-                if (cs.getImsCallServiceType() != ImsCallProfile.SERVICE_TYPE_NONE
-                        || cs.getImsCallType() != ImsCallProfile.CALL_TYPE_NONE) {
-                    if (cs.getCallState() != PreciseCallState.PRECISE_CALL_STATE_DISCONNECTED) {
-                        imsCallStateList.add(cs);
-                        sb.append("{" + cs + "}");
-                    }
-                }
-            }
-        }
-        int ongoingCallNum = imsCallStateList.size();
-        mCallStates = imsCallStateList;
-        Log.d(mLogTag, "updateCallState callNum:(" + ongoingCallNum + "): [" + sb + "]");
-        if (imsCallStateList.size() == 0) {
-            if (mLastNormalCallType != QnsConstants.CALL_TYPE_IDLE) {
-                mLastNormalCallType = QnsConstants.CALL_TYPE_IDLE;
-                notifyCallType(NetworkCapabilities.NET_CAPABILITY_IMS, mLastNormalCallType);
-            }
-            if (mLastEmergencyCallType != QnsConstants.CALL_TYPE_IDLE) {
-                mLastEmergencyCallType = QnsConstants.CALL_TYPE_IDLE;
-                if (mEmergencyOverIms) {
-                    mEmergencyOverIms = false;
-                    notifyCallType(NetworkCapabilities.NET_CAPABILITY_IMS, mLastEmergencyCallType);
-                } else {
-                    notifyCallType(NetworkCapabilities.NET_CAPABILITY_EIMS, mLastEmergencyCallType);
-                }
-            }
-        } else {
-            //1. Notify Call Type IDLE, if the call was removed from the call list.
-            if (mLastNormalCallType != QnsConstants.CALL_TYPE_IDLE
-                    && !hasVideoCall() && !hasVoiceCall()) {
-                mLastNormalCallType = QnsConstants.CALL_TYPE_IDLE;
-                notifyCallType(NetworkCapabilities.NET_CAPABILITY_IMS, mLastNormalCallType);
-
-            }
-            if (mLastEmergencyCallType != QnsConstants.CALL_TYPE_IDLE && !hasEmergencyCall()) {
-                mLastEmergencyCallType = QnsConstants.CALL_TYPE_IDLE;
-                if (mEmergencyOverIms) {
-                    mEmergencyOverIms = false;
-                    notifyCallType(NetworkCapabilities.NET_CAPABILITY_IMS, mLastEmergencyCallType);
-                } else {
-                    notifyCallType(NetworkCapabilities.NET_CAPABILITY_EIMS, mLastEmergencyCallType);
-                }
-            }
-            //2. Notify a new ongoing call type
-            if (hasEmergencyCall()) {
-                if (mLastEmergencyCallType != QnsConstants.CALL_TYPE_EMERGENCY) {
-                    mLastEmergencyCallType = QnsConstants.CALL_TYPE_EMERGENCY;
-                    if (!isDataNetworkConnected(NetworkCapabilities.NET_CAPABILITY_EIMS)
-                            && isDataNetworkConnected(NetworkCapabilities.NET_CAPABILITY_IMS)) {
-                        notifyCallType(NetworkCapabilities.NET_CAPABILITY_IMS,
-                                mLastEmergencyCallType);
-                        mEmergencyOverIms = true;
-                    } else {
-                        notifyCallType(NetworkCapabilities.NET_CAPABILITY_EIMS,
-                                mLastEmergencyCallType);
-                    }
-                }
-            } else if (hasVideoCall()) {
-                if (mLastNormalCallType != QnsConstants.CALL_TYPE_VIDEO) {
-                    mLastNormalCallType = QnsConstants.CALL_TYPE_VIDEO;
-                    notifyCallType(NetworkCapabilities.NET_CAPABILITY_IMS, mLastNormalCallType);
-                }
-            } else if (hasVoiceCall()) {
-                if (mLastNormalCallType != QnsConstants.CALL_TYPE_VOICE) {
-                    mLastNormalCallType = QnsConstants.CALL_TYPE_VOICE;
-                    notifyCallType(NetworkCapabilities.NET_CAPABILITY_IMS, mLastNormalCallType);
-                }
-            }
-            if (mActiveCallTracker.getCallType() != QnsConstants.CALL_TYPE_IDLE) {
-                mActiveCallTracker.updateCallQuality(getActiveCall());
-            }
-        }
-    }
-
-    private void notifyCallType(int netCapability, int callType) {
-        Log.d(mLogTag, "notifyCallType for " + QnsUtils.getNameOfNetCapability(netCapability)
-                + ", callType:" + callType);
-        if (netCapability == NetworkCapabilities.NET_CAPABILITY_IMS
-                && mCallTypeChangedEventListener != null) {
-            mCallTypeChangedEventListener.notifyResult(callType);
-        } else if (netCapability == NetworkCapabilities.NET_CAPABILITY_EIMS
-                && mEmergencyCallTypeChangedEventListener != null) {
-            mEmergencyCallTypeChangedEventListener.notifyResult(callType);
-        }
-        if (callType == QnsConstants.CALL_TYPE_IDLE) {
-            mActiveCallTracker.callEnded();
-        } else {
-            mActiveCallTracker.callStarted(callType, netCapability);
-        }
-        mQnsTimer.updateCallState(callType);
-    }
-
-    boolean isCallIdle() {
-        return mCallStates.size() == 0;
-    }
-
-    boolean isCallIdle(int netCapability) {
-        int callNum = mCallStates.size();
-        if (callNum == 0) {
-            return true;
-        }
-        if (netCapability == NetworkCapabilities.NET_CAPABILITY_IMS) {
-            return (mLastNormalCallType == QnsConstants.CALL_TYPE_IDLE)
-                    && (mLastEmergencyCallType != QnsConstants.CALL_TYPE_IDLE
-                    && !mEmergencyOverIms);
-        } else if (netCapability == NetworkCapabilities.NET_CAPABILITY_EIMS) {
-            return mLastEmergencyCallType == QnsConstants.CALL_TYPE_IDLE || mEmergencyOverIms;
-        }
-        return false;
-    }
-
-    boolean hasEmergencyCall() {
-        for (CallState cs : mCallStates) {
-            if (cs.getImsCallServiceType() == ImsCallProfile.SERVICE_TYPE_EMERGENCY
-                    && cs.getCallState() == PreciseCallState.PRECISE_CALL_STATE_ACTIVE) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    CallState getActiveCall() {
-        for (CallState cs : mCallStates) {
-            if (cs.getCallState() == PreciseCallState.PRECISE_CALL_STATE_ACTIVE) {
-                return cs;
-            }
-        }
-        return null;
-    }
-
-    boolean hasVideoCall() {
-        for (CallState cs : mCallStates) {
-            if (cs.getImsCallServiceType() == ImsCallProfile.SERVICE_TYPE_NORMAL
-                    && cs.getImsCallType() == ImsCallProfile.CALL_TYPE_VT
-                    && (cs.getCallState() == PreciseCallState.PRECISE_CALL_STATE_DISCONNECTING
-                            || cs.getCallState() == PreciseCallState.PRECISE_CALL_STATE_HOLDING
-                            || cs.getCallState() == PreciseCallState.PRECISE_CALL_STATE_ACTIVE)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    boolean hasVoiceCall() {
-        for (CallState cs : mCallStates) {
-            if (cs.getImsCallServiceType() == ImsCallProfile.SERVICE_TYPE_NORMAL
-                    && cs.getImsCallType() == ImsCallProfile.CALL_TYPE_VOICE) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * register call type changed event.
-     *
-     * @param netCapability Network Capability of caller
-     * @param h Handler want to receive event.
-     * @param what event Id to receive
-     * @param userObj user object
-     */
-    void registerCallTypeChangedListener(
-            int netCapability, @NonNull Handler h, int what, Object userObj) {
-        if (netCapability != NetworkCapabilities.NET_CAPABILITY_IMS
-                && netCapability != NetworkCapabilities.NET_CAPABILITY_EIMS) {
-            Log.d(mLogTag, "registerCallTypeChangedListener : wrong netCapability");
-            return;
-        }
-        if (h != null) {
-            QnsRegistrant r = new QnsRegistrant(h, what, userObj);
-            if (netCapability == NetworkCapabilities.NET_CAPABILITY_IMS) {
-                mCallTypeChangedEventListener = r;
-            } else if (netCapability == NetworkCapabilities.NET_CAPABILITY_EIMS) {
-                mEmergencyCallTypeChangedEventListener = r;
-            }
-        } else {
-            Log.d(mLogTag, "registerCallTypeChangedListener : Handler is Null");
-        }
-    }
-
-    /**
-     * Unregister call type changed event.
-     *
-     * @param netCapability Network Capability of caller
-     * @param h Handler want to receive event.
-     */
-    void unregisterCallTypeChangedListener(int netCapability, @NonNull Handler h) {
-        if (netCapability != NetworkCapabilities.NET_CAPABILITY_IMS
-                && netCapability != NetworkCapabilities.NET_CAPABILITY_EIMS) {
-            Log.d(mLogTag, "unregisterCallTypeChangedListener : wrong netCapability");
-            return;
-        }
-        if (h != null) {
-            if (netCapability == NetworkCapabilities.NET_CAPABILITY_IMS) {
-                mCallTypeChangedEventListener = null;
-            } else if (netCapability == NetworkCapabilities.NET_CAPABILITY_EIMS) {
-                mEmergencyCallTypeChangedEventListener = null;
-            }
-        } else {
-            Log.d(mLogTag, "unregisterCallTypeChangedListener : Handler is Null");
-        }
-    }
-
-    ActiveCallTracker getActiveCallTracker() {
-        return mActiveCallTracker;
-    }
-
-    @VisibleForTesting
-    void onSrvccStateChangedInternal(int srvccState) {
-        if (srvccState == TelephonyManager.SRVCC_STATE_HANDOVER_COMPLETED) {
-            mCallStates.clear();
-            if (mLastNormalCallType != QnsConstants.CALL_TYPE_IDLE) {
-                mLastNormalCallType = QnsConstants.CALL_TYPE_IDLE;
-                if (mCallTypeChangedEventListener != null) {
-                    mCallTypeChangedEventListener.notifyResult(mLastNormalCallType);
-                }
-            }
-            if (mLastEmergencyCallType != QnsConstants.CALL_TYPE_IDLE) {
-                mLastEmergencyCallType = QnsConstants.CALL_TYPE_IDLE;
-                if (mEmergencyOverIms) {
-                    mEmergencyOverIms = false;
-                    if (mCallTypeChangedEventListener != null) {
-                        mCallTypeChangedEventListener.notifyResult(mLastEmergencyCallType);
-                    }
-                } else {
-                    if (mEmergencyCallTypeChangedEventListener != null) {
-                        mEmergencyCallTypeChangedEventListener.notifyResult(mLastEmergencyCallType);
-                    }
-                }
-            }
-        }
-    }
-
-
-    private boolean isDataNetworkConnected(int netCapability) {
-        PreciseDataConnectionState preciseDataStatus =
-                mTelephonyListener.getLastPreciseDataConnectionState(netCapability);
-
-        if (preciseDataStatus == null) return false;
-        int state = preciseDataStatus.getState();
-        return (state == TelephonyManager.DATA_CONNECTED
-                || state == TelephonyManager.DATA_HANDOVER_IN_PROGRESS
-                || state == TelephonyManager.DATA_SUSPENDED);
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsCarrierAnspSupportConfig.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsCarrierAnspSupportConfig.java
deleted file mode 100644
index d798d8e..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsCarrierAnspSupportConfig.java
+++ /dev/null
@@ -1,1189 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static com.android.telephony.qns.QnsConstants.MIN_THRESHOLD_GAP;
-import static com.android.telephony.qns.QnsConstants.POLICY_BAD;
-import static com.android.telephony.qns.QnsConstants.POLICY_GOOD;
-
-import android.net.wifi.WifiInfo;
-import android.os.PersistableBundle;
-import android.telephony.SignalThresholdInfo;
-import android.util.Log;
-
-import java.util.Arrays;
-import java.util.HashMap;
-
-/**
- * This class supports loading QnsConfigArray of Thresholds & Policies (Good, Bad ,Worst) values in
- * case of cellular & (Good,Bad) in case of Wi-Fi Thresholds defined .
- */
-class QnsCarrierAnspSupportConfig {
-    /**
-     * List of 3 customized eutran(4g) RSRP thresholds to be considered for rove-in & rove-out in
-     * 4G(VoLTE registered) & in idle state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_RSRP}
-     *
-     * <p>3 threshold integers must be within the boundaries Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_RSRP_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_RSRP_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:{@link QnsConstants#KEY_DEFAULT_THRESHOLD_RSRP_GOOD}"
-     *   <LI>"Bad: {@link QnsConstants#KEY_DEFAULT_THRESHOLD_RSRP_BAD}"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_IDLE_EUTRAN_RSRP_INT_ARRAY = "qns.idle_eutran_rsrp_int_array";
-
-    /**
-     * List of 3 customized eutran(4g) RSRP thresholds to be considered for rove-in & rove-out in 4G
-     * (VoLTE) & in voice call state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_RSRP}
-     *
-     * <p>3 threshold integers must be within the boundaries: Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_RSRP_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_RSRP_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:{@link QnsConstants#KEY_DEFAULT_THRESHOLD_RSRP_GOOD}"
-     *   <LI>"Bad: {@link QnsConstants#KEY_DEFAULT_THRESHOLD_RSRP_BAD}"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_VOICE_EUTRAN_RSRP_INT_ARRAY = "qns.voice_eutran_rsrp_int_array";
-
-    /**
-     * List of 3 customized eutran(4g) RSRP thresholds to be considered for rove-in & rove-out in 4G
-     * (VoLTE) & in video call state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_RSRP}
-     *
-     * <p>3 threshold integers must be within the boundaries: Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_RSRP_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_RSRP_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:65535"
-     *   <LI>"Bad:65535"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_VIDEO_EUTRAN_RSRP_INT_ARRAY = "qns.video_eutran_rsrp_int_array";
-
-    /**
-     * List of 3 customized eutran(4g) RSRQ thresholds to be considered for rove-in & rove-out in
-     * 4G(VoLTE registered) & in idle state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_RSRQ}
-     *
-     * <p>3 threshold integers must be within the boundaries Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_RSRQ_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_RSRQ_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:65535"
-     *   <LI>"Bad:65535"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_IDLE_EUTRAN_RSRQ_INT_ARRAY = "qns.idle_eutran_rsrq_int_array";
-
-    /**
-     * List of 3 customized eutran(4g) RSRQ thresholds to be considered for rove-in & rove-out in
-     * 4G(VoLTE) & in Voice Call state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_RSRQ}
-     *
-     * <p>3 threshold integers must be within the boundaries Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_RSRQ_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_RSRQ_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:65535"
-     *   <LI>"Bad:65535"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_VOICE_EUTRAN_RSRQ_INT_ARRAY = "qns.voice_eutran_rsrq_int_array";
-
-    /**
-     * List of 3 customized eutran(4g) RSRQ thresholds to be considered for rove-in & rove-out in
-     * 4G(VoLTE) & in Video Call state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_RSRQ}
-     *
-     * <p>3 threshold integers must be within the boundaries Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_RSRQ_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_RSRQ_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:65535"
-     *   <LI>"Bad:65535"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_VIDEO_EUTRAN_RSRQ_INT_ARRAY = "qns.video_eutran_rsrq_int_array";
-
-    /**
-     * List of 3 customized eutran(4g) RSSNR thresholds to be considered for rove-in & rove-out in
-     * 4G(VoLTE registered) & in idle state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_RSSNR}
-     *
-     * <p>3 threshold integers must be within the boundaries Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_RSSNR_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_RSSNR_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:65535"
-     *   <LI>"Bad:65535"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_IDLE_EUTRAN_RSSNR_INT_ARRAY = "qns.idle_eutran_rssnr_int_array";
-
-    /**
-     * List of 3 customized eutran(4g) RSSNR thresholds to be considered for rove-in & rove-out in
-     * 4G(VoLTE registered) & in Voice Call state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_RSSNR}
-     *
-     * <p>3 threshold integers must be within the boundaries Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_RSSNR_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_RSSNR_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:65535"
-     *   <LI>"Bad:65535"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_VOICE_EUTRAN_RSSNR_INT_ARRAY = "qns.voice_eutran_rssnr_int_array";
-
-    /**
-     * List of 3 customized eutran(4g) RSSNR thresholds to be considered for rove-in & rove-out in
-     * 4G(VoLTE registered) & in Video Call state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_RSSNR}
-     *
-     * <p>3 threshold integers must be within the boundaries Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_RSSNR_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_RSSNR_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:65535"
-     *   <LI>"Bad:65535"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_VIDEO_EUTRAN_RSSNR_INT_ARRAY = "qns.video_eutran_rssnr_int_array";
-
-    /**
-     * List of 3 customized ngran(5g) SSRSRP thresholds to be considered for rove-in & rove-out in
-     * 5g(VoNR registered) & in idle state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_SSRSRP}
-     *
-     * <p>3 threshold integers must be within the boundaries Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_SSRSRP_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_SSRSRP_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:{@link QnsConstants#KEY_DEFAULT_THRESHOLD_SSRSRP_GOOD}"
-     *   <LI>"Bad: {@link QnsConstants#KEY_DEFAULT_THRESHOLD_SSRSRP_BAD}"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_IDLE_NGRAN_SSRSRP_INT_ARRAY = "qns.idle_ngran_ssrsrp_int_array";
-
-    /**
-     * List of 3 customized ngran(5g) SSRSRP thresholds to be considered for rove-in & rove-out in
-     * 5g(VoNR) & in voice call state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_SSRSRP}
-     *
-     * <p>3 threshold integers must be within the boundaries: Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_SSRSRP_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_SSRSRP_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:{@link QnsConstants#KEY_DEFAULT_THRESHOLD_SSRSRP_GOOD}"
-     *   <LI>"Bad: {@link QnsConstants#KEY_DEFAULT_THRESHOLD_SSRSRP_BAD}"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_VOICE_NGRAN_SSRSRP_INT_ARRAY = "qns.voice_ngran_ssrsrp_int_array";
-
-    /**
-     * List of 3 customized ngran(5g) SSRSRP thresholds to be considered for rove-in & rove-out in
-     * 5G (VoNR) & in video call state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_SSRSRP}
-     *
-     * <p>3 threshold integers must be within the boundaries: Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_SSRSRP_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_SSRSRP_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:65535"
-     *   <LI>"Bad:65535"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_VIDEO_NGRAN_SSRSRP_INT_ARRAY = "qns.video_ngran_ssrsrp_int_array";
-
-    /**
-     * List of 3 customized ngran(5g) SSRSRQ thresholds to be considered for rove-in & rove-out in
-     * 5G (VoNR) & in idle state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_SSRSRQ}
-     *
-     * <p>3 threshold integers must be within the boundaries: Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_SSRSRQ_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_SSRSRQ_MAX_VALUE}
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply. {@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:65535"
-     *   <LI>"Bad:65535"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_IDLE_NGRAN_SSRSRQ_INT_ARRAY = "qns.idle_ngran_ssrsrq_int_array";
-
-    /**
-     * List of 3 customized ngran(5g) SSRSRQ thresholds to be considered for rove-in & rove-out in
-     * 5G (VoNR) & in voice call state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_SSRSRQ}
-     *
-     * <p>3 threshold integers must be within the boundaries: Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_SSRSRQ_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_SSRSRQ_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:65535"
-     *   <LI>"Bad:65535"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_VOICE_NGRAN_SSRSRQ_INT_ARRAY = "qns.voice_ngran_ssrsrq_int_array";
-
-    /**
-     * List of 3 customized ngran(5g) SSRSRQ thresholds to be considered for rove-in & rove-out in
-     * 5G (VoNR) & in video call state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_SSRSRQ}
-     *
-     * <p>3 threshold integers must be within the boundaries: Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_SSRSRQ_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_SSRSRQ_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:65535"
-     *   <LI>"Bad:65535"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_VIDEO_NGRAN_SSRSRQ_INT_ARRAY = "qns.video_ngran_ssrsrq_int_array";
-
-    /**
-     * List of 3 customized ngran(5g) SSSINR thresholds to be considered for rove-in & rove-out in
-     * 5G (VoNR) & in idle state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_SSSINR}
-     *
-     * <p>3 threshold integers must be within the boundaries: Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_SSSINR_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_SSSINR_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:65535"
-     *   <LI>"Bad:65535"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_IDLE_NGRAN_SSSINR_INT_ARRAY = "qns.idle_ngran_sssinr_int_array";
-
-    /**
-     * List of 3 customized ngran(5g) SSSINR thresholds to be considered for rove-in & rove-out in
-     * 5G (VoNR) & in voice call state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_SSSINR}
-     *
-     * <p>3 threshold integers must be within the boundaries: Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_SSSINR_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_SSSINR_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:65535"
-     *   <LI>"Bad:65535"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_VOICE_NGRAN_SSSINR_INT_ARRAY = "qns.voice_ngran_sssinr_int_array";
-
-    /**
-     * List of 3 customized ngran(5g) SSSINR thresholds to be considered for rove-in & rove-out in
-     * 5G (VoNR) & in video call state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_SSSINR}
-     *
-     * <p>3 threshold integers must be within the boundaries: Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_SSSINR_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_SSSINR_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:65535"
-     *   <LI>"Bad:65535"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_VIDEO_NGRAN_SSSINR_INT_ARRAY = "qns.video_ngran_sssinr_int_array";
-
-    /**
-     * List of 3 customized utran(3g) RSCP thresholds to be considered for rove-in & rove-out in 3g
-     * (IMS registered) & in idle state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_RSCP}
-     *
-     * <p>3 threshold integers must be within the boundaries: Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_RSCP_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_RSCP_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:{@link QnsConstants#KEY_DEFAULT_THRESHOLD_RSCP_GOOD}"
-     *   <LI>"Bad: {@link QnsConstants#KEY_DEFAULT_THRESHOLD_RSCP_BAD}"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_IDLE_UTRAN_RSCP_INT_ARRAY = "qns.idle_utran_rscp_int_array";
-
-    /**
-     * List of 3 customized utran(3g) RSCP thresholds to be considered for rove-in & rove-out in 3g
-     * (IMS registered) & in voice call(SRVCC) state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_RSCP}
-     *
-     * <p>3 threshold integers must be within the boundaries: Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_RSCP_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_RSCP_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:65535"
-     *   <LI>"Bad:65535"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_VOICE_UTRAN_RSCP_INT_ARRAY = "qns.voice_utran_rscp_int_array";
-
-    /**
-     * List of 3 customized utran(3g) RSCP thresholds to be considered for rove-in & rove-out in 3g
-     * (IMS registered) & in video call(SRVCC) state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_RSCP}
-     *
-     * <p>3 threshold integers must be within the boundaries: Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_RSCP_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_RSCP_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:65535"
-     *   <LI>"Bad:65535"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_VIDEO_UTRAN_RSCP_INT_ARRAY = "qns.video_utran_rscp_int_array";
-
-    /**
-     * List of 3 customized utran(3G) Ec/No threshold values which are considered for rove-in and
-     * rove-out in idle state.
-     *
-     * <p>3 threshold integers must be within the boundaries: Note: When a value is set to "65535",
-     * it means an invalid threshold value. {@link SignalThresholdInfo#SIGNAL_ECNO_MIN_VALUE} {@link
-     * SignalThresholdInfo#SIGNAL_ECNO_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:65535"
-     *   <LI>"Bad:65535"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value will be applied.
-     */
-    static final String KEY_IDLE_UTRAN_ECNO_INT_ARRAY = "qns.idle_utran_ecno_int_array";
-
-    /**
-     * List of 3 customized geran(2g) RSSI thresholds to be considered for rove-in & rove-out in 2g
-     * (IMS registered) & in idle state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_RSSI}
-     *
-     * <p>3 threshold integers must be within the boundaries: Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_RSSI_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_RSSI_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:65535"
-     *   <LI>"Bad:65535"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_IDLE_GERAN_RSSI_INT_ARRAY = "qns.idle_geran_rssi_int_array";
-
-    /**
-     * List of 3 customized geran(2g) RSSI thresholds to be considered for rove-in & rove-out in 2g
-     * (IMS registered) & in voice call state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_RSSI}
-     *
-     * <p>3 threshold integers must be within the boundaries: Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_RSSI_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_RSSI_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:{@link QnsConstants#KEY_DEFAULT_THRESHOLD_GERAN_RSSI_GOOD}"
-     *   <LI>"Bad: {@link QnsConstants#KEY_DEFAULT_THRESHOLD_GERAN_RSSI_BAD}"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_VOICE_GERAN_RSSI_INT_ARRAY = "qns.voice_geran_rssi_int_array";
-
-    /**
-     * List of 3 customized geran(2g) RSSI thresholds to be considered for rove-in & rove-out in 2g
-     * (IMS registered) & in video call state.
-     *
-     * <p>Reference: {@link SignalThresholdInfo#SIGNAL_MEASUREMENT_TYPE_RSSI}
-     *
-     * <p>3 threshold integers must be within the boundaries: Note: In case of "worst" criteria is
-     * not relevant the same is set @ "65535" {@link SignalThresholdInfo#SIGNAL_RSSI_MIN_VALUE}
-     * {@link SignalThresholdInfo#SIGNAL_RSSI_MAX_VALUE}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:65535"
-     *   <LI>"Bad:65535"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_VIDEO_GERAN_RSSI_INT_ARRAY = "qns.video_geran_rssi_int_array";
-
-    /**
-     * List of 2 customized wifi RSSI thresholds to be considered for rove-in & rove-out in wifi
-     * (IMS registered) & in idle state.
-     *
-     * <p>2 threshold integers must be within the boundaries: {@link WifiInfo#MIN_RSSI} {@link
-     * WifiInfo#MIN_RSSI}
-     *
-     * <p>{@code 2 values defined by default(Good, Bad)}
-     *
-     * <UL>
-     *   <LI>"Good:{@link QnsConstants#KEY_DEFAULT_THRESHOLD_WIFI_RSSI_GOOD}"
-     *   <LI>"Bad:{@link QnsConstants#KEY_DEFAULT_THRESHOLD_WIFI_RSSI_BAD}"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_IDLE_WIFI_RSSI_INT_ARRAY = "qns.idle_wifi_rssi_int_array";
-
-    /**
-     * List of 2 customized wifi RSSI thresholds to be considered for rove-in & rove-out in wifi
-     * (IMS registered) & in voice call state.
-     *
-     * <p>2 threshold integers must be within the boundaries: {@link WifiInfo#MIN_RSSI} {@link
-     * WifiInfo#MIN_RSSI}
-     *
-     * <p>{@code 2 values defined by default(Good, Bad)}
-     *
-     * <UL>
-     *   <LI>"Good:{@link QnsConstants#KEY_DEFAULT_THRESHOLD_WIFI_RSSI_GOOD}"
-     *   <LI>"Bad:{@link QnsConstants#KEY_DEFAULT_THRESHOLD_WIFI_RSSI_BAD}"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_VOICE_WIFI_RSSI_INT_ARRAY = "qns.voice_wifi_rssi_int_array";
-
-    /**
-     * List of 2 customized wifi RSSI thresholds to be considered for rove-in & rove-out in wifi
-     * (IMS registered) & in video call state.
-     *
-     * <p>2 threshold integers must be within the boundaries: {@link WifiInfo#MIN_RSSI} {@link
-     * WifiInfo#MIN_RSSI}
-     *
-     * <p>{@code 2 values defined by default(Good, Bad)}
-     *
-     * <UL>
-     *   <LI>"Good:{@link QnsConstants#KEY_DEFAULT_THRESHOLD_WIFI_RSSI_GOOD}"
-     *   <LI>"Bad:{@link QnsConstants#KEY_DEFAULT_THRESHOLD_WIFI_RSSI_BAD}"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_VIDEO_WIFI_RSSI_INT_ARRAY = "qns.video_wifi_rssi_int_array";
-
-    /**
-     * List of 2 customized wifi RSSI thresholds to be considered for rove-in & rove-out in wifi
-     * (IMS registered) & in idle state to be considered during Overriding with Wifi Pref settings.
-     *
-     * <p>2 threshold integers must be within the boundaries: {@link WifiInfo#MIN_RSSI} {@link
-     * WifiInfo#MIN_RSSI}
-     *
-     * <p>{@code 2 values defined by default(Good, Bad)}
-     *
-     * <UL>
-     *   <LI>"Good:{@link QnsConstants#KEY_DEFAULT_THRESHOLD_WIFI_RSSI_GOOD}"
-     *   <LI>"Bad:{@link QnsConstants#KEY_DEFAULT_THRESHOLD_WIFI_RSSI_BAD}"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_OVERRIDE_WIFI_PREF_IDLE_WIFI_RSSI_INT_ARRAY =
-            "qns.override_wifi_pref_idle_wifi_rssi_int_array";
-
-    /**
-     * List of 2 customized wifi RSSI thresholds to be considered for rove-in & rove-out in wifi
-     * (IMS registered) & in voice call state to be considered during Overriding with Wifi Pref
-     * settings.
-     *
-     * <p>2 threshold integers must be within the boundaries: {@link WifiInfo#MIN_RSSI} {@link
-     * WifiInfo#MIN_RSSI}
-     *
-     * <p>{@code 2 values defined by default(Good, Bad)}
-     *
-     * <UL>
-     *   <LI>"Good:{@link QnsConstants#KEY_DEFAULT_THRESHOLD_WIFI_RSSI_GOOD}"
-     *   <LI>"Bad:{@link QnsConstants#KEY_DEFAULT_THRESHOLD_WIFI_RSSI_BAD}"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_OVERRIDE_WIFI_PREF_VOICE_WIFI_RSSI_INT_ARRAY =
-            "qns.override_wifi_pref_voice_wifi_rssi_int_array";
-
-    /**
-     * List of 2 customized wifi RSSI thresholds to be considered for rove-in & rove-out in wifi
-     * (IMS registered) & in video call state to be considered during Overriding with Wifi Pref
-     * settings.
-     *
-     * <p>2 threshold integers must be within the boundaries: {@link WifiInfo#MIN_RSSI} {@link
-     * WifiInfo#MIN_RSSI}
-     *
-     * <p>{@code 2 values defined by default(Good, Bad)}
-     *
-     * <UL>
-     *   <LI>"Good:{@link QnsConstants#KEY_DEFAULT_THRESHOLD_WIFI_RSSI_GOOD}"
-     *   <LI>"Bad:{@link QnsConstants#KEY_DEFAULT_THRESHOLD_WIFI_RSSI_BAD}"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_OVERRIDE_WIFI_PREF_VIDEO_WIFI_RSSI_INT_ARRAY =
-            "qns.override_wifi_pref_video_wifi_rssi_int_array";
-
-    /**
-     * List of 2 customized wifi RSSI thresholds to be considered for rove-in & rove-out in wifi
-     * (IMS registered) & in idle state. Without cellular coverage, it sets the wifi rove-in &
-     * rove-out threshold of the UE.
-     *
-     * <p>2 threshold integers must be within the boundaries: {@link WifiInfo#MIN_RSSI} {@link
-     * WifiInfo#MIN_RSSI}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:65535"
-     *   <LI>"Bad:65535"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_IDLE_WIFI_RSSI_WITHOUT_CELLULAR_INT_ARRAY =
-            "qns.idle_wifi_rssi_without_cellular_int_array";
-
-    /**
-     * List of 2 customized wifi RSSI thresholds to be considered for rove-in & rove-out in wifi
-     * (IMS registered) & in voice call state. Without cellular coverage, it sets the wifi rove-in &
-     * rove-out threshold of the UE.
-     *
-     * <p>2 threshold integers must be within the boundaries: {@link WifiInfo#MIN_RSSI} {@link
-     * WifiInfo#MIN_RSSI}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:65535"
-     *   <LI>"Bad:65535"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_VOICE_WIFI_RSSI_WITHOUT_CELLULAR_INT_ARRAY =
-            "qns.voice_wifi_rssi_without_cellular_int_array";
-
-    /**
-     * List of 2 customized wifi RSSI thresholds to be considered for rove-in & rove-out in wifi
-     * (IMS registered) & in video call state. Without cellular coverage, it sets the wifi rove-in &
-     * rove-out threshold of the UE.
-     *
-     * <p>2 threshold integers must be within the boundaries: {@link WifiInfo#MIN_RSSI} {@link
-     * WifiInfo#MIN_RSSI}
-     *
-     * <p>{@code 3 values defined by default(Good, Bad, Worst)}
-     *
-     * <UL>
-     *   <LI>"Good:65535"
-     *   <LI>"Bad:65535"
-     *   <LI>"Worst:65535"
-     * </UL>
-     *
-     * <p>This key is considered invalid if the format is violated. If the key not configured, a
-     * default value set will apply.
-     */
-    static final String KEY_VIDEO_WIFI_RSSI_WITHOUT_CELLULAR_INT_ARRAY =
-            "qns.video_wifi_rssi_without_cellular_int_array";
-
-    // Internal Policy Rule/keys Updates
-    static final String KEY_CONDITION_ROVE_IN_IDLE_WIFI_PREF_HOME_STRING_ARRAY =
-            "qns.condition_rove_in_idle_wifi_pref_home_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VOICE_WIFI_PREF_HOME_STRING_ARRAY =
-            "qns.condition_rove_in_voice_wifi_pref_home_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VIDEO_WIFI_PREF_HOME_STRING_ARRAY =
-            "qns.condition_rove_in_video_wifi_pref_home_string_array";
-    static final String KEY_CONDITION_ROVE_IN_IDLE_CELL_PREF_HOME_STRING_ARRAY =
-            "qns.condition_rove_in_idle_cell_pref_home_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VOICE_CELL_PREF_HOME_STRING_ARRAY =
-            "qns.condition_rove_in_voice_cell_pref_home_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VIDEO_CELL_PREF_HOME_STRING_ARRAY =
-            "qns.condition_rove_in_video_cell_pref_home_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_IDLE_WIFI_PREF_HOME_STRING_ARRAY =
-            "qns.condition_rove_out_idle_wifi_pref_home_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VOICE_WIFI_PREF_HOME_STRING_ARRAY =
-            "qns.condition_rove_out_voice_wifi_pref_home_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VIDEO_WIFI_PREF_HOME_STRING_ARRAY =
-            "qns.condition_rove_out_video_wifi_pref_home_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_IDLE_CELL_PREF_HOME_STRING_ARRAY =
-            "qns.condition_rove_out_idle_cell_pref_home_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VOICE_CELL_PREF_HOME_STRING_ARRAY =
-            "qns.condition_rove_out_voice_cell_pref_home_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VIDEO_CELL_PREF_HOME_STRING_ARRAY =
-            "qns.condition_rove_out_video_cell_pref_home_string_array";
-    static final String KEY_CONDITION_ROVE_IN_IDLE_WIFI_PREF_ROAM_STRING_ARRAY =
-            "qns.condition_rove_in_idle_wifi_pref_roam_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VOICE_WIFI_PREF_ROAM_STRING_ARRAY =
-            "qns.condition_rove_in_voice_wifi_pref_roam_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VIDEO_WIFI_PREF_ROAM_STRING_ARRAY =
-            "qns.condition_rove_in_video_wifi_pref_roam_string_array";
-    static final String KEY_CONDITION_ROVE_IN_IDLE_CELL_PREF_ROAM_STRING_ARRAY =
-            "qns.condition_rove_in_idle_cell_pref_roam_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VOICE_CELL_PREF_ROAM_STRING_ARRAY =
-            "qns.condition_rove_in_voice_cell_pref_roam_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VIDEO_CELL_PREF_ROAM_STRING_ARRAY =
-            "qns.condition_rove_in_video_cell_pref_roam_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_IDLE_WIFI_PREF_ROAM_STRING_ARRAY =
-            "qns.condition_rove_out_idle_wifi_pref_roam_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VOICE_WIFI_PREF_ROAM_STRING_ARRAY =
-            "qns.condition_rove_out_voice_wifi_pref_roam_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VIDEO_WIFI_PREF_ROAM_STRING_ARRAY =
-            "qns.condition_rove_out_video_wifi_pref_roam_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_IDLE_CELL_PREF_ROAM_STRING_ARRAY =
-            "qns.condition_rove_out_idle_cell_pref_roam_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VOICE_CELL_PREF_ROAM_STRING_ARRAY =
-            "qns.condition_rove_out_voice_cell_pref_roam_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VIDEO_CELL_PREF_ROAM_STRING_ARRAY =
-            "qns.condition_rove_out_video_cell_pref_roam_string_array";
-
-    /**
-     * Define keys for extended policy rules. Different handover criteria based on whether
-     * hysteresis timer is running or not.
-     */
-    static final String KEY_CONDITION_ROVE_IN_IDLE_WIFI_PREF_HOME_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_in_idle_wifi_pref_home_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_IN_IDLE_WIFI_PREF_HOME_GUARDING_WIFI_STRING_ARRAY =
-            "qns.condition_rove_in_idle_wifi_pref_home_guarding_wifi_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VOICE_WIFI_PREF_HOME_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_in_voice_wifi_pref_home_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VOICE_WIFI_PREF_HOME_GUARDING_WIFI_STRING_ARRAY =
-            "qns.condition_rove_in_voice_wifi_pref_home_guarding_wifi_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VIDEO_WIFI_PREF_HOME_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_in_video_wifi_pref_home_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VIDEO_WIFI_PREF_HOME_GUARDING_WIFI_STRING_ARRAY =
-            "qns.condition_rove_in_video_wifi_pref_home_guarding_wifi_string_array";
-    static final String KEY_CONDITION_ROVE_IN_IDLE_CELL_PREF_HOME_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_in_idle_cell_pref_home_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_IN_IDLE_CELL_PREF_HOME_GUARDING_WIFI_STRING_ARRAY =
-            "qns.condition_rove_in_idle_cell_pref_home_guarding_wifi_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VOICE_CELL_PREF_HOME_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_in_voice_cell_pref_home_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VOICE_CELL_PREF_HOME_GUARDING_WIFI_STRING_ARRAY =
-            "qns.condition_rove_in_voice_cell_pref_home_guarding_wifi_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VIDEO_CELL_PREF_HOME_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_in_video_cell_pref_home_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VIDEO_CELL_PREF_HOME_GUARDING_WIFI_STRING_ARRAY =
-            "qns.condition_rove_in_video_cell_pref_home_guarding_wifi_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_IDLE_WIFI_PREF_HOME_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_out_idle_wifi_pref_home_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_IDLE_WIFI_PREF_HOME_GUARDING_CELL_STRING_ARRAY =
-            "qns.condition_rove_out_idle_wifi_pref_home_guarding_cell_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VOICE_WIFI_PREF_HOME_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_out_voice_wifi_pref_home_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VOICE_WIFI_PREF_HOME_GUARDING_CELL_STRING_ARRAY =
-            "qns.condition_rove_out_voice_wifi_pref_home_guarding_cell_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VIDEO_WIFI_PREF_HOME_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_out_video_wifi_pref_home_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VIDEO_WIFI_PREF_HOME_GUARDING_CELL_STRING_ARRAY =
-            "qns.condition_rove_out_video_wifi_pref_home_guarding_cell_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_IDLE_CELL_PREF_HOME_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_out_idle_cell_pref_home_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_IDLE_CELL_PREF_HOME_GUARDING_CELL_STRING_ARRAY =
-            "qns.condition_rove_out_idle_cell_pref_home_guarding_cell_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VOICE_CELL_PREF_HOME_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_out_voice_cell_pref_home_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VOICE_CELL_PREF_HOME_GUARDING_CELL_STRING_ARRAY =
-            "qns.condition_rove_out_voice_cell_pref_home_guarding_cell_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VIDEO_CELL_PREF_HOME_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_out_video_cell_pref_home_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VIDEO_CELL_PREF_HOME_GUARDING_CELL_STRING_ARRAY =
-            "qns.condition_rove_out_video_cell_pref_home_guarding_cell_string_array";
-    static final String KEY_CONDITION_ROVE_IN_IDLE_WIFI_PREF_ROAM_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_in_idle_wifi_pref_roam_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_IN_IDLE_WIFI_PREF_ROAM_GUARDING_WIFI_STRING_ARRAY =
-            "qns.condition_rove_in_idle_wifi_pref_roam_guarding_wifi_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VOICE_WIFI_PREF_ROAM_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_in_voice_wifi_pref_roam_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VOICE_WIFI_PREF_ROAM_GUARDING_WIFI_STRING_ARRAY =
-            "qns.condition_rove_in_voice_wifi_pref_roam_guarding_wifi_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VIDEO_WIFI_PREF_ROAM_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_in_video_wifi_pref_roam_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VIDEO_WIFI_PREF_ROAM_GUARDING_WIFI_STRING_ARRAY =
-            "qns.condition_rove_in_video_wifi_pref_roam_guarding_wifi_string_array";
-    static final String KEY_CONDITION_ROVE_IN_IDLE_CELL_PREF_ROAM_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_in_idle_cell_pref_roam_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_IN_IDLE_CELL_PREF_ROAM_GUARDING_WIFI_STRING_ARRAY =
-            "qns.condition_rove_in_idle_cell_pref_roam_guarding_wifi_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VOICE_CELL_PREF_ROAM_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_in_voice_cell_pref_roam_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VOICE_CELL_PREF_ROAM_GUARDING_WIFI_STRING_ARRAY =
-            "qns.condition_rove_in_voice_cell_pref_roam_guarding_wifi_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VIDEO_CELL_PREF_ROAM_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_in_video_cell_pref_roam_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_IN_VIDEO_CELL_PREF_ROAM_GUARDING_WIFI_STRING_ARRAY =
-            "qns.condition_rove_in_video_cell_pref_roam_guarding_wifi_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_IDLE_WIFI_PREF_ROAM_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_out_idle_wifi_pref_roam_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_IDLE_WIFI_PREF_ROAM_GUARDING_CELL_STRING_ARRAY =
-            "qns.condition_rove_out_idle_wifi_pref_roam_guarding_cell_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VOICE_WIFI_PREF_ROAM_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_out_voice_wifi_pref_roam_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VOICE_WIFI_PREF_ROAM_GUARDING_CELL_STRING_ARRAY =
-            "qns.condition_rove_out_voice_wifi_pref_roam_guarding_cell_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VIDEO_WIFI_PREF_ROAM_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_out_video_wifi_pref_roam_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VIDEO_WIFI_PREF_ROAM_GUARDING_CELL_STRING_ARRAY =
-            "qns.condition_rove_out_video_wifi_pref_roam_guarding_cell_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_IDLE_CELL_PREF_ROAM_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_out_idle_cell_pref_roam_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_IDLE_CELL_PREF_ROAM_GUARDING_CELL_STRING_ARRAY =
-            "qns.condition_rove_out_idle_cell_pref_roam_guarding_cell_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VOICE_CELL_PREF_ROAM_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_out_voice_cell_pref_roam_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VOICE_CELL_PREF_ROAM_GUARDING_CELL_STRING_ARRAY =
-            "qns.condition_rove_out_voice_cell_pref_roam_guarding_cell_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VIDEO_CELL_PREF_ROAM_GUARDING_NONE_STRING_ARRAY =
-            "qns.condition_rove_out_video_cell_pref_roam_guarding_none_string_array";
-    static final String KEY_CONDITION_ROVE_OUT_VIDEO_CELL_PREF_ROAM_GUARDING_CELL_STRING_ARRAY =
-            "qns.condition_rove_out_video_cell_pref_roam_guarding_cell_string_array";
-
-    private final HashMap<String, int[]> mQnsRatThresholdMap = new HashMap<>();
-
-    private final HashMap<String, String[]> mQnsPolicyMap = new HashMap<>();
-    private final String mLogTag;
-
-    static final String[] THRESHOLD_KEYS =
-            new String[] {
-                KEY_IDLE_EUTRAN_RSRP_INT_ARRAY,
-                KEY_VOICE_EUTRAN_RSRP_INT_ARRAY,
-                KEY_VIDEO_EUTRAN_RSRP_INT_ARRAY,
-                KEY_IDLE_EUTRAN_RSRQ_INT_ARRAY,
-                KEY_VOICE_EUTRAN_RSRQ_INT_ARRAY,
-                KEY_VIDEO_EUTRAN_RSRQ_INT_ARRAY,
-                KEY_IDLE_EUTRAN_RSSNR_INT_ARRAY,
-                KEY_VOICE_EUTRAN_RSSNR_INT_ARRAY,
-                KEY_VIDEO_EUTRAN_RSSNR_INT_ARRAY,
-                KEY_IDLE_NGRAN_SSRSRP_INT_ARRAY,
-                KEY_VOICE_NGRAN_SSRSRP_INT_ARRAY,
-                KEY_VIDEO_NGRAN_SSRSRP_INT_ARRAY,
-                KEY_IDLE_NGRAN_SSRSRQ_INT_ARRAY,
-                KEY_VOICE_NGRAN_SSRSRQ_INT_ARRAY,
-                KEY_VIDEO_NGRAN_SSRSRQ_INT_ARRAY,
-                KEY_IDLE_NGRAN_SSSINR_INT_ARRAY,
-                KEY_VOICE_NGRAN_SSSINR_INT_ARRAY,
-                KEY_VIDEO_NGRAN_SSSINR_INT_ARRAY,
-                KEY_IDLE_UTRAN_RSCP_INT_ARRAY,
-                KEY_VOICE_UTRAN_RSCP_INT_ARRAY,
-                KEY_VIDEO_UTRAN_RSCP_INT_ARRAY,
-                KEY_IDLE_UTRAN_ECNO_INT_ARRAY,
-                KEY_IDLE_GERAN_RSSI_INT_ARRAY,
-                KEY_VOICE_GERAN_RSSI_INT_ARRAY,
-                KEY_VIDEO_GERAN_RSSI_INT_ARRAY,
-                KEY_IDLE_WIFI_RSSI_INT_ARRAY,
-                KEY_VOICE_WIFI_RSSI_INT_ARRAY,
-                KEY_VIDEO_WIFI_RSSI_INT_ARRAY,
-                KEY_OVERRIDE_WIFI_PREF_IDLE_WIFI_RSSI_INT_ARRAY,
-                KEY_OVERRIDE_WIFI_PREF_VOICE_WIFI_RSSI_INT_ARRAY,
-                KEY_OVERRIDE_WIFI_PREF_VIDEO_WIFI_RSSI_INT_ARRAY,
-                KEY_IDLE_WIFI_RSSI_WITHOUT_CELLULAR_INT_ARRAY,
-                KEY_VOICE_WIFI_RSSI_WITHOUT_CELLULAR_INT_ARRAY,
-                KEY_VIDEO_WIFI_RSSI_WITHOUT_CELLULAR_INT_ARRAY
-            };
-
-    /**
-     * Constructor to Slot & Context whose Access Network selection policy related support configs
-     * needs to be loaded, along with Other QNS Configurations on which the related Carrier Config
-     * ID to be loaded.
-     *
-     * @param slotIndex Constructor for initialising QnsCarrierAnspSupportConfig to current SlotID
-     */
-    QnsCarrierAnspSupportConfig(int slotIndex) {
-        mLogTag =
-                QnsConstants.QNS_TAG
-                        + "_"
-                        + QnsCarrierAnspSupportConfig.class.getSimpleName()
-                        + "_"
-                        + slotIndex;
-    }
-
-    /**
-     * This method loads the Threshold Array & Policy Array rules for building Access Network
-     * Selection policies
-     *
-     * @param bundleCarrier : Carrier config Manager (pb config) persistent bundle
-     * @param bundleAsset : asset config (xml) persistent bundle
-     */
-    void loadQnsAnspSupportArray(PersistableBundle bundleCarrier, PersistableBundle bundleAsset) {
-        updateAnspThresholdArrayList(bundleCarrier, bundleAsset);
-        updateAnspPolicyArrayList(bundleCarrier, bundleAsset);
-    }
-
-    private void updateAnspThresholdArrayList(
-            PersistableBundle bundleCarrier, PersistableBundle bundleAsset) {
-
-        for (String key : THRESHOLD_KEYS) {
-            int[] anspThresholdArray = QnsUtils.getConfig(bundleCarrier, bundleAsset, key);
-            if (anspThresholdArray != null && anspThresholdArray.length > 1) {
-                anspThresholdArray = validateAndAdjustThresholdArray(anspThresholdArray, key);
-            }
-            mQnsRatThresholdMap.put(key, anspThresholdArray);
-        }
-    }
-
-    private int[] validateAndAdjustThresholdArray(int[] thresholds, String thresholdKey) {
-        if (thresholds[POLICY_GOOD] != QnsCarrierConfigManager.QnsConfigArray.INVALID
-                && thresholds[POLICY_BAD] != QnsCarrierConfigManager.QnsConfigArray.INVALID
-                && thresholds[POLICY_GOOD] - thresholds[POLICY_BAD] < MIN_THRESHOLD_GAP) {
-            if (thresholds[POLICY_GOOD] - thresholds[POLICY_BAD] < 0) {
-                Log.d(mLogTag, "invalid Thresholds for " + thresholdKey + " use default.");
-                return QnsUtils.getConfig(null, null, thresholdKey);
-            } else if (thresholds[POLICY_GOOD] - thresholds[POLICY_BAD] < MIN_THRESHOLD_GAP) {
-                int currentGap = thresholds[POLICY_GOOD] - thresholds[POLICY_BAD];
-                int[] adjust = thresholds.clone();
-                for (int i = currentGap; i < MIN_THRESHOLD_GAP; i++) {
-                    if ((i - currentGap) % 2 == 0) {
-                        adjust[POLICY_GOOD]++;
-                    } else {
-                        adjust[POLICY_BAD]--;
-                    }
-                }
-                Log.d(
-                        mLogTag,
-                        "Thresholds("
-                                + thresholdKey
-                                + ") gap is too small adjust:"
-                                + "["
-                                + thresholds[POLICY_GOOD]
-                                + "] > ["
-                                + adjust[POLICY_GOOD]
-                                + "]"
-                                + "["
-                                + thresholds[POLICY_BAD]
-                                + "] > ["
-                                + adjust[POLICY_BAD]
-                                + "]");
-                return adjust;
-            }
-        }
-        return thresholds;
-    }
-
-    private void updateAnspPolicyArrayList(
-            PersistableBundle bundleCarrier, PersistableBundle bundleAsset) {
-
-        String[] policyKeys =
-                new String[] {
-                    KEY_CONDITION_ROVE_IN_IDLE_WIFI_PREF_HOME_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VOICE_WIFI_PREF_HOME_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VIDEO_WIFI_PREF_HOME_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_IDLE_CELL_PREF_HOME_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VOICE_CELL_PREF_HOME_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VIDEO_CELL_PREF_HOME_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_IDLE_WIFI_PREF_HOME_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VOICE_WIFI_PREF_HOME_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VIDEO_WIFI_PREF_HOME_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_IDLE_CELL_PREF_HOME_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VOICE_CELL_PREF_HOME_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VIDEO_CELL_PREF_HOME_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_IDLE_WIFI_PREF_ROAM_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VOICE_WIFI_PREF_ROAM_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VIDEO_WIFI_PREF_ROAM_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_IDLE_CELL_PREF_ROAM_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VOICE_CELL_PREF_ROAM_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VIDEO_CELL_PREF_ROAM_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_IDLE_WIFI_PREF_ROAM_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VOICE_WIFI_PREF_ROAM_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VIDEO_WIFI_PREF_ROAM_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_IDLE_CELL_PREF_ROAM_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VOICE_CELL_PREF_ROAM_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VIDEO_CELL_PREF_ROAM_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_IDLE_WIFI_PREF_HOME_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_IDLE_WIFI_PREF_HOME_GUARDING_WIFI_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VOICE_WIFI_PREF_HOME_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VOICE_WIFI_PREF_HOME_GUARDING_WIFI_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VIDEO_WIFI_PREF_HOME_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VIDEO_WIFI_PREF_HOME_GUARDING_WIFI_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_IDLE_CELL_PREF_HOME_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_IDLE_CELL_PREF_HOME_GUARDING_WIFI_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VOICE_CELL_PREF_HOME_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VOICE_CELL_PREF_HOME_GUARDING_WIFI_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VIDEO_CELL_PREF_HOME_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VIDEO_CELL_PREF_HOME_GUARDING_WIFI_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_IDLE_WIFI_PREF_HOME_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_IDLE_WIFI_PREF_HOME_GUARDING_CELL_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VOICE_WIFI_PREF_HOME_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VOICE_WIFI_PREF_HOME_GUARDING_CELL_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VIDEO_WIFI_PREF_HOME_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VIDEO_WIFI_PREF_HOME_GUARDING_CELL_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_IDLE_CELL_PREF_HOME_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_IDLE_CELL_PREF_HOME_GUARDING_CELL_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VOICE_CELL_PREF_HOME_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VOICE_CELL_PREF_HOME_GUARDING_CELL_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VIDEO_CELL_PREF_HOME_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VIDEO_CELL_PREF_HOME_GUARDING_CELL_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_IDLE_WIFI_PREF_ROAM_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_IDLE_WIFI_PREF_ROAM_GUARDING_WIFI_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VOICE_WIFI_PREF_ROAM_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VOICE_WIFI_PREF_ROAM_GUARDING_WIFI_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VIDEO_WIFI_PREF_ROAM_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VIDEO_WIFI_PREF_ROAM_GUARDING_WIFI_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_IDLE_CELL_PREF_ROAM_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_IDLE_CELL_PREF_ROAM_GUARDING_WIFI_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VOICE_CELL_PREF_ROAM_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VOICE_CELL_PREF_ROAM_GUARDING_WIFI_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VIDEO_CELL_PREF_ROAM_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_IN_VIDEO_CELL_PREF_ROAM_GUARDING_WIFI_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_IDLE_WIFI_PREF_ROAM_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_IDLE_WIFI_PREF_ROAM_GUARDING_CELL_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VOICE_WIFI_PREF_ROAM_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VOICE_WIFI_PREF_ROAM_GUARDING_CELL_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VIDEO_WIFI_PREF_ROAM_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VIDEO_WIFI_PREF_ROAM_GUARDING_CELL_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_IDLE_CELL_PREF_ROAM_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_IDLE_CELL_PREF_ROAM_GUARDING_CELL_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VOICE_CELL_PREF_ROAM_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VOICE_CELL_PREF_ROAM_GUARDING_CELL_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VIDEO_CELL_PREF_ROAM_GUARDING_NONE_STRING_ARRAY,
-                    KEY_CONDITION_ROVE_OUT_VIDEO_CELL_PREF_ROAM_GUARDING_CELL_STRING_ARRAY,
-                };
-        for (String key : policyKeys) {
-            String[] anspPolicyArray = QnsUtils.getConfig(bundleCarrier, bundleAsset, key);
-            mQnsPolicyMap.put(key, anspPolicyArray);
-        }
-    }
-
-    int[] getAnspCarrierThreshold(String key) {
-        return mQnsRatThresholdMap.get(key);
-    }
-
-    String[] getAnspCarrierPolicy(String key) {
-        return mQnsPolicyMap.get(key);
-    }
-
-    /**
-     * Check if Threshold config was Updated.
-     *
-     * @param configBundle : Carrier config Manager (pb config) persistent bundle
-     * @param assetBundle : asset config (xml) persistent bundle
-     * @return true/false
-     */
-    synchronized boolean checkQnsAnspConfigChange(
-            PersistableBundle configBundle, PersistableBundle assetBundle) {
-        return isThresholdConfigChanged(configBundle, assetBundle);
-    }
-
-    private boolean isThresholdConfigChanged(
-            PersistableBundle configChangeBundle, PersistableBundle assetBundle) {
-        HashMap<String, int[]> qnsRatThresUpdatedMap = new HashMap<>();
-
-        for (String key : THRESHOLD_KEYS) {
-            int[] anspThresholdArray = QnsUtils.getConfig(configChangeBundle, assetBundle, key);
-            qnsRatThresUpdatedMap.put(key, anspThresholdArray);
-        }
-
-        for (String k : mQnsRatThresholdMap.keySet()) {
-            if (!Arrays.equals(mQnsRatThresholdMap.get(k), qnsRatThresUpdatedMap.get(k))) {
-                mQnsRatThresholdMap.putAll(qnsRatThresUpdatedMap);
-                return true;
-            }
-        }
-
-        return false;
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsCarrierConfigManager.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsCarrierConfigManager.java
deleted file mode 100644
index 496907e..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsCarrierConfigManager.java
+++ /dev/null
@@ -1,2807 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static android.telephony.AccessNetworkConstants.TRANSPORT_TYPE_WLAN;
-import static android.telephony.AccessNetworkConstants.TRANSPORT_TYPE_WWAN;
-import static android.telephony.SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_ECNO;
-import static android.telephony.SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSCP;
-import static android.telephony.SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP;
-import static android.telephony.SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRQ;
-import static android.telephony.SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI;
-import static android.telephony.SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR;
-import static android.telephony.SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSRSRP;
-import static android.telephony.SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSRSRQ;
-import static android.telephony.SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSSINR;
-import static android.telephony.SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_UNKNOWN;
-import static android.telephony.TelephonyManager.UNKNOWN_CARRIER_ID;
-
-import static com.android.telephony.qns.QnsConstants.FALLBACK_REASON_INVALID;
-import static com.android.telephony.qns.QnsConstants.MAX_COUNT_INVALID;
-import static com.android.telephony.qns.wfc.WfcCarrierConfigManager.KEY_QNS_VOWIFI_REGISTATION_TIMER_FOR_VOWIFI_ACTIVATION_INT;
-
-import android.annotation.IntDef;
-import android.annotation.NonNull;
-import android.content.Context;
-import android.net.NetworkCapabilities;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Looper;
-import android.os.Message;
-import android.os.PersistableBundle;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.Annotation.NetCapability;
-import android.telephony.CarrierConfigManager;
-import android.telephony.SignalThresholdInfo;
-import android.telephony.SubscriptionManager;
-import android.telephony.TelephonyManager;
-import android.telephony.ims.ImsMmTelManager;
-import android.telephony.ims.ProvisioningManager;
-import android.text.TextUtils;
-import android.util.ArraySet;
-import android.util.Log;
-
-import com.android.internal.annotations.VisibleForTesting;
-
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Set;
-import java.util.stream.Collectors;
-
-/**
- * This class supports loading Ansp(Access Network Selection Policy , Thresholds , Handover Polices
- * & Other Supporting Carrier configurations , to support ANE to decide on the HO decision
- * management & listing related Access Network to pass to Telephony
- */
-class QnsCarrierConfigManager {
-    /**
-     * Boolean indicating the WFC services in QNS Side is enabled, when airplane mode is On
-     *
-     * <p>{@code true}: QNS is enabled for WFC services in airplane mode on. {@code false}: QNS is
-     * disabled for WFC services in airplane mode on. The default value for this key is {@code true}
-     */
-    static final String KEY_QNS_SUPPORT_WFC_DURING_AIRPLANE_MODE_BOOL =
-            "qns.support_wfc_during_airplane_mode_bool";
-
-    /**
-     * Boolean indicating if in-call handover decision from WLAN to WWAN should consider VoPS
-     * status.
-     *
-     * <p>{@code true}: In-call handover decision from WLAN to WWAN won't consider VoPS status, for
-     * example, UE can perform handover from WLAN to LTE even if LTE network does not support VoPS.
-     * {@code false}: In-call handover decision from WLAN to WWAN will consider VoPS status, for
-     * example, UE should not perform handover from WLAN to LTE if LTE network does not support
-     * VoPS.
-     * The default value for this key is {@code false}
-     */
-    static final String KEY_IN_CALL_HO_DECISION_WLAN_TO_WWAN_WITHOUT_VOPS_CONDITION_BOOL =
-            "qns.in_call_ho_decision_wlan_to_wwan_without_vops_condition_bool";
-
-    /**
-     * Boolean indicating Iwlan TransportType priority is enabled , when VOPS(Voice Over PS Session)
-     * flag from NW is false .
-     *
-     * <p>{@code true}: Iwlan TransportType selection priority is enabled, when VOPS(Voice Over PS
-     * Session) is false. {@code false}: Iwlan TransportType selection priority is disabled, when
-     * VOPS (Voice Over PS Session) is false. The default value for this key is {@code true}
-     */
-    static final String KEY_QNS_VOPS_NOTAVAILABLE_PRIORITY_IWLAN_BOOL =
-            "qns.support_vops_notavailable_priority_iwlan_bool";
-
-    /**
-     * Boolean indicating when disabled , supporting of Guard Timer applied to both TransportType
-     * WWAN (Cellular) & WLAN ( Wifi)
-     *
-     * <p>{@code false}: Whe Disabled , Guard timer (To avoid Ping Pong) is executed for both the
-     * direction ( ie Cellular to Wifi & Wifi to Cellular) {@code true}: when enabled , Guard timer
-     * (To avoid Ping Pong) is executed only based on the preference set. The default value for this
-     * key is {@code false}
-     */
-    static final String KEY_QNS_HO_GUARDING_BY_PREFERENCE_BOOL =
-            "qns.ho_guarding_by_preference_bool";
-    /**
-     * Boolean indicating the Service Barring check is disabled, when making HO decision from
-     * transport type WWAN (Cellular) to Transport type WLAN Wifi
-     *
-     * <p>{@code false}: Service Barring check is disabled , when making HO decision from transport
-     * type WWAN (Cellular) to Transport type WLAN Wifi {@code true}: Service Barring check is
-     * enabled , when making HO decision from transport type WWAN (Cellular) to Transport type WLAN
-     * Wifi The default value for this key is {@code false}
-     */
-    static final String KEY_QNS_SUPPORT_SERVICE_BARRING_CHECK_BOOL =
-            "qns.support_service_barring_check_bool";
-
-    /**
-     * Boolean indicating the transport type selection without Signal Strength is disabled, during
-     * roaming condition
-     *
-     * <p>{@code false}: when disabled , transport type selection is based on RAT existence & signal
-     * quality during roaming.. {@code true}: when enabled , transport type selection is based on
-     * RAT availability during roaming. (not depends on Signal Strength) The default value for this
-     * key is {@code false}
-     */
-    static final String KEY_ROAM_TRANSPORT_TYPE_SELECTION_WITHOUT_SIGNAL_STRENGTH_BOOL =
-            "qns.roam_transport_type_selection_without_signal_strength_bool";
-
-    /**
-     * Boolean indicating the preference to select/continue call in current Transport Type is
-     * disabled.
-     *
-     * <p>{@code false}: When disabled , preference to select/continue call in current Transport
-     * Type is not allowed {@code true}: When enabled , preference to select/continue call in
-     * current Transport Type is allowed The default value for this key is {@code false}
-     */
-    static final String KEY_PREFER_CURRENT_TRANSPORT_TYPE_IN_VOICE_CALL_BOOL =
-            "qns.prefer_current_transport_type_in_voice_call_bool";
-
-    /**
-     * Boolean to override IMS Mode Preference from cellular preference.
-     *
-     * <p>{@code false}: When disabled , no ims override preference. {@code true}: When enabled ,
-     * load ims mode preference instead of cellular mode preference at home network. The default
-     * value for this key is {@code false}
-     */
-    static final String KEY_POLICY_OVERRIDE_CELL_PREF_TO_IMS_PREF_HOME_BOOL =
-            "qns.override_cell_pref_to_ims_pref_home";
-
-    /**
-     * Boolean indicating allowing video call over wifi is disabled , when cellular limited case
-     * meets.(ie no LTE home network is available, or if an LTE home network is available but VoPS
-     * is disabled or has 100% SSAC voice barring)
-     *
-     * <p>{@code false}: When disabled , preference to allow video call on meeting cellular limited
-     * case conditions over Wifi is not allowed. {@code true}: When enabled , preference to move
-     * video call on meeting cellular limited case conditions over Wifi is allowed. The default
-     * value for this key is {@code false}
-     */
-    static final String KEY_QNS_ALLOW_VIDEO_OVER_IWLAN_WITH_CELLULAR_LIMITED_CASE_BOOL =
-            "qns.allow_video_over_iwlan_with_cellular_limited_case_bool";
-
-    /**
-     * Boolean indicating cellular2WiFi-hysteresis Scenario rove out policies of WIth WIfi Bad
-     * criteria check with Guard TImer conditions is disabled.
-     *
-     * <p>{@code false}: When disabled , cellular2WiFi-hysteresis Scenario rove out policies during
-     * guard timer conditions(Running/Expired state) is not available {@code true}: When enabled ,
-     * cellular2WiFi-hysteresis Scenario rove out policies during guard timer
-     * conditions(Running/Expired state) is available The default value for this key is {@code
-     * false}
-     */
-    static final String KEY_QNS_ROVE_OUT_POLICY_WITH_WIFI_BAD_GUARDTIMER_CONDITIONS_BOOL =
-            "qns.rove_out_policy_with_wifi_bad_guardtimer_conditions_bool";
-
-    /**
-     * Boolean indicating enabling of Wi-Fi call when in a call state idle with a cellular network
-     * that does not support ims pdn.
-     *
-     * <p>{@code false}: When disabled , There is no action to enable Wi-Fi Calling. {@code true}:
-     * When enabled , Enable Wi-Fi calling, if the call state is idle and the cellular network the
-     * UE is staying on does not allow ims pdn. The default value for this key is {@code false}
-     */
-    static final String KEY_QNS_ALLOW_IMS_OVER_IWLAN_CELLULAR_LIMITED_CASE_BOOL =
-            "qns.allow_ims_over_iwlan_cellular_limited_case_bool";
-
-    /**
-     * Boolean indicating if to block IWLAN when UE is in no WWAN coverage and the last stored
-     * country code is outside the home country.
-     * By default this value is {@code false}.
-     */
-    static final String KEY_BLOCK_IWLAN_IN_INTERNATIONAL_ROAMING_WITHOUT_WWAN_BOOL =
-            "qns.block_iwlan_in_international_roaming_without_wwan_bool";
-
-    /**
-     * Boolean indicating if to block IWLAN when UE is connected to IPv6 only WiFi AP. The setting
-     * may only apply on Android T. For Android U onwards, we may support a carrier config at IWLAN
-     * if we still encounter any issues for IPv6 WFC. By default this value is {@code true}.
-     */
-    static final String KEY_BLOCK_IPV6_ONLY_WIFI_BOOL = "qns.block_ipv6_only_wifi_bool";
-
-    /**
-     * Specifies the Rat Preference for the XCAP network capability. Boolean indicating adding the
-     * IMS Registration condition to the Wi-Fi Rove in condition.
-     *
-     * <ul>
-     *   <li>{@code QnsConstants#RAT_PREFERENCE_DEFAULT}: Default, Follow the system preference.
-     *   <li>{@code QnsConstants#RAT_PREFERENCE_WIFI_ONLY}: If set , choose Wi-Fi always
-     *   <li>{@code QnsConstants#RAT_PREFERENCE_WIFI_WHEN_WFC_AVAILABLE}: If set , choose Wi-Fi when
-     *       the Wi-Fi Calling is available.(when IMS is registered through the Wi-Fi)
-     *   <li>{@code QnsConstants#RAT_PREFERENCE_WIFI_WHEN_NO_CELLULAR}: If set , choose Wi-Fi when
-     *       no cellular
-     *   <li>{@code QnsConstants#RAT_PREFERENCE_WIFI_WHEN_HOME_IS_NOT_AVAILABLE}: If set , choose
-     *       Wi-Fi when cellular is available at home network.
-     * </ul>
-     */
-    static final String KEY_QNS_XCAP_RAT_PREFERENCE_INT = "qns.xcap_rat_preference_int";
-
-    /**
-     * Specifies the Rat Preference for the SOS network capability. Boolean indicating adding the
-     * IMS Registration condition to the Wi-Fi Rove in condition.
-     *
-     * <ul>
-     *   <li>{@code QnsConstants#RAT_PREFERENCE_DEFAULT}: Default, Follow the system preference.
-     *   <li>{@code QnsConstants#RAT_PREFERENCE_WIFI_ONLY}: If set , choose Wi-Fi always
-     *   <li>{@code QnsConstants#RAT_PREFERENCE_WIFI_WHEN_WFC_AVAILABLE}: If set , choose Wi-Fi when
-     *       the Wi-Fi Calling is available.(when IMS is registered through the Wi-Fi)
-     *   <li>{@code QnsConstants#RAT_PREFERENCE_WIFI_WHEN_NO_CELLULAR}: If set , choose Wi-Fi when
-     *       no cellular
-     *   <li>{@code QnsConstants#RAT_PREFERENCE_WIFI_WHEN_HOME_IS_NOT_AVAILABLE}: If set , choose
-     *       Wi-Fi when cellular is available at home network.
-     * </ul>
-     */
-    static final String KEY_QNS_SOS_RAT_PREFERENCE_INT = "qns.sos_rat_preference_int";
-
-    /**
-     * Specifies the Rat Preference for the MMS network capability. Boolean indicating adding the
-     * IMS Registration condition to the Wi-Fi Rove in condition.
-     *
-     * <p>{@code QnsConstants#RAT_PREFERENCE_DEFAULT}: Default value , Follow the system preference.
-     * {@code QnsConstants#RAT_PREFERENCE_WIFI_ONLY}: If set , choose Wi-Fi always {@code
-     * QnsConstants#RAT_PREFERENCE_WIFI_WHEN_WFC_AVAILABLE}: If set , choose Wi-Fi when the Wi-Fi
-     * Calling is available.(when IMS is registered through the Wi-Fi) {@code
-     * QnsConstants#RAT_PREFERENCE_WIFI_WHEN_NO_CELLULAR}: If set , choose Wi-Fi when no cellular
-     * {@code QnsConstants#RAT_PREFERENCE_WIFI_WHEN_HOME_IS_NOT_AVAILABLE}: If set , choose Wi-Fi
-     * when cellular is available at home network. The default value for this key is {@code
-     * QnsConstants#RAT_PREFERENCE_DEFAULT}
-     */
-    static final String KEY_QNS_MMS_RAT_PREFERENCE_INT = "qns.mms_rat_preference_int";
-
-    /**
-     * Specifies the Rat Preference for the CBS network capability. Boolean indicating adding the
-     * IMS Registration condition to the Wi-Fi Rove in condition.
-     *
-     * <p>{@code QnsConstants#RAT_PREFERENCE_DEFAULT}: Default value , Follow the system preference.
-     * {@code QnsConstants#RAT_PREFERENCE_WIFI_ONLY}: If set , choose Wi-Fi always {@code
-     * QnsConstants#RAT_PREFERENCE_WIFI_WHEN_WFC_AVAILABLE}: If set , choose Wi-Fi when the Wi-Fi
-     * Calling is available.(when IMS is registered through the Wi-Fi) {@code
-     * QnsConstants#RAT_PREFERENCE_WIFI_WHEN_NO_CELLULAR}: If set , choose Wi-Fi when no cellular
-     * {@code QnsConstants#RAT_PREFERENCE_WIFI_WHEN_HOME_IS_NOT_AVAILABLE}: If set , choose Wi-Fi
-     * when cellular is available at home network. The default value for this key is {@code
-     * QnsConstants#RAT_PREFERENCE_DEFAULT}
-     */
-    static final String KEY_QNS_CBS_RAT_PREFERENCE_INT = "qns.cbs_rat_preference_int";
-
-    /**
-     * Specifies the interval at which the Wifi Backhaul timer in milli seconds, for threshold Wifi
-     * rssi signal strength fluctuation in case, on meeting the criteria in Rove In Scenario (Moving
-     * to Cellular to Wifi) {@link QnsConstants}. The values are set as below:
-     *
-     * <ul>
-     *   <li>0: {@link QnsConstants#DEFAULT_WIFI_BACKHAUL_TIMER}
-     *   <li>1: {@link QnsConstants#KEY_DEFAULT_VALUE}
-     * </ul>
-     *
-     * &As per operator Requirements.
-     *
-     * <p>{@code QnsConstants#DEFAULT_WIFI_BACKHAUL_TIMER}: If set , specifies interval of 3secs
-     * running the backhaul check(To avoid Wifi Fluctuation) on meeting the criteria in Rove in case
-     * {@code QnsConstants#KEY_DEFAULT_VALUE}: If set , this feature to be disabled <As per Operator
-     * requirement configurable>: If this value set , specifies interval in milli seconds running
-     * the backhaul check. The default value for this key is {@link
-     * QnsConstants#DEFAULT_WIFI_BACKHAUL_TIMER}
-     */
-    static final String KEY_QNS_WIFI_RSSI_THRESHOLDBACKHAUL_TIMER_MS_INT =
-            "qns.wifi_rssi_thresholdbackhaul_timer_int";
-
-    /**
-     * Specifies the interval at which the Cellular Backhaul timer in milli seconds for cellular
-     * signal strengths fluctuation in case, on meeting the criteria in Rove out Scenario (Moving to
-     * Wifi from Cellular) The values are set as below:
-     *
-     * <ul>
-     *   <li>0: {@link QnsConstants#KEY_DEFAULT_VALUE}
-     * </ul>
-     *
-     * &As per operator Requirements.
-     *
-     * <p>{@code QnsConstants#KEY_DEFAULT_VALUE}: If set , this feature to be disabled <As per
-     * Operator requirement configurable>: If this value set , specifies interval in milli seconds
-     * running the backhaul check over Cellular in Rove Out The default value for this key is {@link
-     * QnsConstants#KEY_DEFAULT_VALUE}
-     */
-    static final String KEY_QNS_CELLULAR_SS_THRESHOLDBACKHAUL_TIMER_MS_INT =
-            "qns.cellular_ss_thresholdbackhaul_timer_int";
-
-    /**
-     * Specifies the Transport type UE supports with QNS services for IMS network capability. {@link
-     * QnsConstants}. The values are set as below:
-     *
-     * <ul>
-     *   <li>0: {@link QnsConstants#TRANSPORT_TYPE_ALLOWED_WWAN}
-     *   <li>1: {@link QnsConstants#TRANSPORT_TYPE_ALLOWED_IWLAN}
-     *   <li>2: {@link QnsConstants#TRANSPORT_TYPE_ALLOWED_BOTH}
-     * </ul>
-     *
-     * {@code QnsConstants#TRANSPORT_TYPE_ALLOWED_WWAN}: If set , Transport type UE supports is
-     * cellular for IMS network capability. {@code QnsConstants#TRANSPORT_TYPE_ALLOWED_IWLAN}: If
-     * this value set , Transport type UE supports is Wifi for IMS network capability. {@code
-     * QnsConstants#TRANSPORT_TYPE_ALLOWED_BOTH}: If this value set , Transport type UE supports is
-     * both Cellular & Wifi for IMS network capability The default value for this key is {@link
-     * QnsConstants#TRANSPORT_TYPE_ALLOWED_BOTH}
-     */
-    static final String KEY_QNS_IMS_TRANSPORT_TYPE_INT = "qns.ims_transport_type_int";
-
-    /**
-     * Specifies the Transport type UE supports with QNS services for SOS network capability. {@link
-     * QnsConstants}. The values are set as below:
-     *
-     * <ul>
-     *   <li>0: {@link QnsConstants#TRANSPORT_TYPE_ALLOWED_WWAN}
-     *   <li>1: {@link QnsConstants#TRANSPORT_TYPE_ALLOWED_IWLAN}
-     *   <li>2: {@link QnsConstants#TRANSPORT_TYPE_ALLOWED_BOTH}
-     * </ul>
-     *
-     * {@code QnsConstants#TRANSPORT_TYPE_ALLOWED_WWAN}: If set , Transport type UE supports is
-     * cellular for SOS network capability. {@code QnsConstants#TRANSPORT_TYPE_ALLOWED_IWLAN}: If
-     * this value set , Transport type UE supports is Wifi for SOS network capability. {@code
-     * QnsConstants#TRANSPORT_TYPE_ALLOWED_BOTH}: If this value set , Transport type UE supports is
-     * both Cellular & Wifi for SOS network capability. The default value for this key is {@link
-     * QnsConstants#TRANSPORT_TYPE_ALLOWED_WWAN}
-     */
-    static final String KEY_QNS_SOS_TRANSPORT_TYPE_INT = "qns.sos_transport_type_int";
-
-    /**
-     * Specifies the Transport type UE supports with QNS services for MMS network capability. {@link
-     * QnsConstants}. The values are set as below:
-     *
-     * <ul>
-     *   <li>0: {@link QnsConstants#TRANSPORT_TYPE_ALLOWED_WWAN}
-     *   <li>1: {@link QnsConstants#TRANSPORT_TYPE_ALLOWED_IWLAN}
-     *   <li>2: {@link QnsConstants#TRANSPORT_TYPE_ALLOWED_BOTH}
-     * </ul>
-     *
-     * {@code QnsConstants#TRANSPORT_TYPE_ALLOWED_WWAN}: If set , Transport type UE supports is
-     * cellular for MMS network capability. {@code QnsConstants#TRANSPORT_TYPE_ALLOWED_IWLAN}: If
-     * this value set , Transport type UE supports is Wifi for MMS network capability. {@code
-     * QnsConstants#TRANSPORT_TYPE_ALLOWED_BOTH}: If this value set , Transport type UE supports is
-     * both Cellular & Wifi for MMS network capability. The default value for this key is {@link
-     * QnsConstants#TRANSPORT_TYPE_ALLOWED_WWAN}
-     */
-    static final String KEY_QNS_MMS_TRANSPORT_TYPE_INT = "qns.mms_transport_type_int";
-
-    /**
-     * Specifies the Transport type UE supports with QNS services for CBS network capability. {@link
-     * QnsConstants}. The values are set as below:
-     *
-     * <ul>
-     *   <li>0: {@link QnsConstants#TRANSPORT_TYPE_ALLOWED_WWAN}
-     *   <li>1: {@link QnsConstants#TRANSPORT_TYPE_ALLOWED_IWLAN}
-     *   <li>2: {@link QnsConstants#TRANSPORT_TYPE_ALLOWED_BOTH}
-     * </ul>
-     *
-     * {@code QnsConstants#TRANSPORT_TYPE_ALLOWED_WWAN}: If set , Transport type UE supports is
-     * cellular for CBS network capability. {@code QnsConstants#TRANSPORT_TYPE_ALLOWED_IWLAN}: If
-     * this value set , Transport type UE supports is Wifi for CBS network capability. {@code
-     * QnsConstants#TRANSPORT_TYPE_ALLOWED_BOTH}: If this value set , Transport type UE supports is
-     * both Cellular & Wifi for CBS network capability. The default value for this key is {@link
-     * QnsConstants#TRANSPORT_TYPE_ALLOWED_WWAN}
-     */
-    static final String KEY_QNS_CBS_TRANSPORT_TYPE_INT = "qns.cbs_transport_type_int";
-
-    /**
-     * For IMS PDN, specify a list of the hysteresis timer(millisecond) for handover from WLAN and
-     * WWAN to avoid ping-pong effect.
-     *
-     * <ul>
-     *   <li>Index 0: The hysteresis timer for handover from WLAN and WWAN in idle state.
-     *   <li>Index 1: The hysteresis timer for handover from WLAN and WWAN in voice call state.
-     *   <li>Index 2: The hysteresis timer for handover from WLAN and WWAN in video call state.
-     * </ul>
-     *
-     * <p>The default values are {@link QnsConstants#KEY_DEFAULT_HYST_TIMER}
-     */
-    static final String KEY_IMS_WWAN_HYSTERESIS_TIMER_MS_INT_ARRAY =
-            "qns.ims_wwan_hysteresis_timer_ms_int_array";
-
-    /**
-     * For IMS PDN, specify a list of the hysteresis timer(millisecond) for handover from WWAN and
-     * WLAN to avoid ping-pong effect.
-     *
-     * <ul>
-     *   <li>Index 0: The hysteresis timer for handover from WWAN and WLAN in idle state.
-     *   <li>Index 1: The hysteresis timer for handover from WWAN and WLAN in voice call state.
-     *   <li>Index 2: The hysteresis timer for handover from WWAN and WLAN in video call state.
-     * </ul>
-     *
-     * <p>The default values are {@link QnsConstants#KEY_DEFAULT_HYST_TIMER}
-     */
-    static final String KEY_IMS_WLAN_HYSTERESIS_TIMER_MS_INT_ARRAY =
-            "qns.ims_wlan_hysteresis_timer_ms_int_array";
-
-    /**
-     * Location(HOME/ROAM) of using handover hysteresis timer
-     * <li>0: {@link QnsConstants#COVERAGE_HOME}
-     * <li>1: {@link QnsConstants#COVERAGE_ROAM}
-     * <li>2: {@link QnsConstants#COVERAGE_BOTH} The default value for this key is {@link
-     * QnsConstants#COVERAGE_BOTH}
-     */
-    static final String KEY_QNS_IMS_NETWORK_ENABLE_HO_HYSTERESIS_TIMER_INT =
-            "qns.ims_network_enable_hysteresis_timer_int";
-
-    /**
-     * For MMS, XCAP and CBS PDNs, specify a list of the hysteresis timer(millisecond) for handover
-     * from WLAN and WWAN to avoid ping-pong effect.
-     *
-     * <ul>
-     *   <li>Index 0: The hysteresis timer for handover from WLAN to WWAN in idle state.
-     *   <li>Index 1: The hysteresis timer for handover from WLAN to WWAN in call state.
-     * </ul>
-     *
-     * <p>The default values are {@link QnsConstants#KEY_DEFAULT_VALUE}
-     */
-    static final String KEY_NON_IMS_WWAN_HYSTERESIS_TIMER_MS_INT_ARRAY =
-            "qns.non_ims_wwan_hysteresis_timer_ms_int_array";
-
-    /**
-     * For MMS, XCAP and CBS PDNs, specify a list of the hysteresis timer(millisecond) for handover
-     * from WWAN and WLAN to avoid ping-pong effect.
-     *
-     * <ul>
-     *   <li>Index 0: The hysteresis timer for handover from WWAN and WLAN in idle state.
-     *   <li>Index 1: The hysteresis timer for handover from WWAN and WLAN in call state.
-     * </ul>
-     *
-     * <p>The default values are {@link QnsConstants#KEY_DEFAULT_VALUE}
-     */
-    static final String KEY_NON_IMS_WLAN_HYSTERESIS_TIMER_MS_INT_ARRAY =
-            "qns.non_ims_wlan_hysteresis_timer_ms_int_array";
-
-    /**
-     * This item is the minimum handover guarding timer value when there is no guarding time for
-     * handover.
-     * Note:
-     * If this value is set to less than or equal to 0, minimum guarding action is disabled.
-     * if this value is set to greater than or equal to
-     * {@code QnsConstants#CONFIG_DEFAULT_MIN_HANDOVER_GUARDING_TIMER_LIMIT},
-     * {@code QnsConstants#CONFIG_DEFAULT_MIN_HANDOVER_GUARDING_TIMER_LIMIT} value is set.
-     * If no value set at asset or paris , QnsConstants#CONFIG_DEFAULT_MIN_HANDOVER_GUARDING_TIMER
-     * value at code is set.
-     *
-     * <p>{@code QnsConstants#CONFIG_DEFAULT_MIN_HANDOVER_GUARDING_TIMER} : default value of timer.
-     * {@code QnsConstants#CONFIG_DEFAULT_MIN_HANDOVER_GUARDING_TIMER_LIMIT} : maximum allowable
-     * value.
-     */
-    static final String KEY_MINIMUM_HANDOVER_GUARDING_TIMER_MS_INT =
-            "qns.minimum_handover_guarding_timer_ms_int";
-
-    /**
-     * This indicates time duration for packet loss rate sustained.
-     *
-     * <p/> The default value for this key is {@code
-     * QnsConstants#KEY_DEFAULT_PACKET_LOSS_TIME_MILLIS}
-     */
-    static final String KEY_QNS_MEDIA_THRESHOLD_RTP_PACKET_LOSS_TIME_MILLIS_INT =
-            "qns.media_threshold_rtp_packet_loss_time_millis";
-
-    /**
-     * Specify a list of the waiting time(millisecond) for the preferred transport type when power
-     * up.
-     *
-     * <ul>
-     *   <li>Index 0: The waiting time for WWAN in cellular preferred mode.
-     *   <li>Index 1: The waiting time for WLAN in WiFi preferred mode.
-     * </ul>
-     *
-     * <p>The default values are all {@link QnsConstants#KEY_DEFAULT_VALUE}
-     *
-     * <p>For example, if set 45000ms in the index 0 of this list, WLAN will be restricted 45000ms
-     * in cellular preferred mode when power up, and the timer will be canceled if IMS PDN is
-     * connected on WWAN within 45000ms.
-     */
-    static final String KEY_WAITING_TIME_FOR_PREFERRED_TRANSPORT_WHEN_POWER_ON_INT_ARRAY =
-            "qns.waiting_time_for_preferred_transport_when_power_on_int_array";
-
-    /**
-     * Specifies the number of count allowed IWLAN on HO to cellular during call due to fallback
-     * reason such as Wifi bad or RTP Low Quality Criteria
-     *
-     * <p>The Possible values are set as below: <rovein_count_allowed,rove_outfallback_reason
-     *
-     * <ul>
-     *   <li><-1,-1></-1,-1>:{@link QnsConstants#MAX_COUNT_INVALID,QnsConstants#MAX_COUNT_INVALID}
-     * </ul>
-     *
-     * & As per operator Requirements (Ex: 3,1 or 1,2)
-     *
-     * <p>The default value for this key is {@link QnsConstants#MAX_COUNT_INVALID,
-     * QnsConstants#FALLBACK_REASON_INVALID}
-     */
-    static final String KEY_QNS_IN_CALL_ROVEIN_ALLOWED_COUNT_AND_FALLBACK_REASON_INT_ARRAY =
-            "qns.in_call_rovein_allowed_and_fallback_reason_int_array";
-
-    /**
-     * Specifies the number of count allowed IWLAN on HO to cellular during call due to fallback
-     * reason such as Wifi bad or RTP Low Quality Criteria
-     *
-     * <p>The Possible values are set as below:
-     *
-     * <ul>
-     *   <li>Index 0: The waiting time for WLAN //If set to 0 , feature is disabled for WLAN-WWAN
-     *   <li>Index 1: The waiting time for WWAN //If set to 0 , feature is disabled for WWAN-WLAN
-     * </ul>
-     *
-     * The default value for this key is {@link
-     * QnsConstants#KEY_DEFAULT_IWLAN_AVOID_TIME_LOW_RTP_QUALITY_MILLIS,
-     * QnsConstants#KEY_DEFAULT_VALUE}
-     */
-    static final String KEY_QNS_HO_RESTRICT_TIME_WITH_LOW_RTP_QUALITY_MILLIS_INT_ARRAY =
-            "qns.ho_restrict_time_with_low_rtp_quality_int_array";
-
-    /**
-     * Specify if choosing the transport type based on WFC preference mode when both WWAN and WLAN
-     * are not able to meet service requirements.
-     *
-     * <p>The possible values are set as below:
-     *
-     * <ul>
-     *   <li>1: {@link ImsMmTelManager#WIFI_MODE_CELLULAR_PREFERRED}
-     *   <li>2: {@link ImsMmTelManager#WIFI_MODE_WIFI_PREFERRED}
-     * </ul>
-     *
-     * {@code ImsMmTelManager#WIFI_MODE_CELLULAR_PREFERRED}: Only apply the design when WFC
-     * preference mode is cellular preferred. Choose WWAN when cellular preferred and both WWAN and
-     * WLAN are in bad condition. {@code ImsMmTelManager#WIFI_MODE_WIFI_PREFERRED}: Only apply the
-     * design when WFC preference mode is WiFi preferred. Choose WLAN when WiFi preferred and both
-     * WWAN and WLAN are in bad condition.
-     *
-     * <p>If set to {ImsMmTelManager#WIFI_MODE_CELLULAR_PREFERRED,
-     * ImsMmTelManager#WIFI_MODE_WIFI_PREFERRED}, the design will apply on both cellular and WiFi
-     * preference mode.
-     *
-     * <p>The default value for this key is empty. An empty array indicates staying on the current
-     * transport when both WWAN and WLAN are not able to meet service requirements.
-     */
-    static final String KEY_CHOOSE_WFC_PREFERRED_TRANSPORT_IN_BOTH_BAD_CONDITION_INT_ARRAY =
-            "qns.choose_wfc_preferred_transport_in_both_bad_condition_int_array";
-
-    /**
-     * String indicating parameters for RTT(round trip time) check using ICMP PING on IWLAN.
-     *
-     * <p>We recommend to use a server on IWLAN path for RTT check. A server which is not reached
-     * via IWLAN connection may give inadequate result.
-     *
-     * <p>format:<server_address>,<ping_count>,<intra_ping_interval>,<packet_size>,<rtt_criteria>,
-     * <rtt_check_Interval>,<hyst_fallback_timer> For Ex:
-     * "epdg.epc.mnc001.mcc001.pub.3gppnetwork.org,5,100,32,100,1800000,600000"
-     *
-     * <p>The default value for this key is null indicating not enabled by default for round trip
-     * time check.
-     */
-    static final String KEY_QNS_WLAN_RTT_BACKHAUL_CHECK_ON_ICMP_PING_STRING =
-            "qns.wlan_rtt_backhaul_check_on_icmp_ping_string";
-
-    /**
-     * List of Array items indicating network capabilities with fallback support based on retry
-     * count or retry timer or either of them with fallback guard timer to be set
-     *
-     * <p><string-array name="qns.fallback_on_initial_connection_failure_string_array" num="2" <item
-     * value="<network_capability>:<retry_count>:<retry_timer>:<fallback_guard_timer>
-     * :<max_fallback_count>"/> Note: All Timer Values to be in millis Example: <item
-     * value="ims:3:60000:10000:2"/> <item value="mms:1:10000:60000:2"/>
-     *
-     * <p>The default value for this key is null indicating not enabled by default for fallback in
-     * case of initial connection failure
-     */
-    static final String KEY_QNS_FALLBACK_ON_INITIAL_CONNECTION_FAILURE_STRING_ARRAY =
-            "qns.fallback_on_initial_connection_failure_string_array";
-
-    /**
-     * List of Array items indicating the Access Network Allowed For IMS network capability. The
-     * values are set as below: "LTE" "NR" "3G" "2G" The default value for this key is {@Code
-     * "LTE","NR"}
-     */
-    static final String KEY_IMS_CELLULAR_ALLOWED_RAT_STRING_ARRAY =
-            "qns.ims_cellular_allowed_rat_string_array";
-
-    /**
-     * List of Array items indicating the Access Network Allowed For IMS network capability. The
-     * values are set as below: Format "<accessNetwork>:<meas_type>:<gap>" "eutran:rsrp:-2"
-     * "ngran:ssrsrp:2" Note: Similar format followed across different accessNetwork & Measurement
-     * Types. The default value for this key is "".
-     */
-    static final String KEY_QNS_ROVEIN_THRESHOLD_GAP_WITH_GUARD_TIMER_STRING_ARRAY =
-            "qns.rove_in_threshold_gap_with_guard_timer_string_array";
-
-    /**
-     * List of Array items indicating IMS unregistered cause & time(millis) for fallback (to WWAN).
-     *
-     * <p><string-array name="qns.fallback_wwan_ims_unregistration_reason_string_array" num="2">
-     * <!-- fallback WWAN with ImsReason 321~378,1503 during 60sec at cellular prefer mode -->
-     * <item value="cause=321~378|1503, time=60000, preference=cell"/>
-     * <!-- fallback WWAN with ImsReason 240,243,323~350 during 90sec -->
-     * <item value="cause=240|243|323~350, time=90000"/> </string-array>
-     *
-     * <p>The default value for this key is "".
-     */
-    static final String KEY_QNS_FALLBACK_WWAN_IMS_UNREGISTRATION_REASON_STRING_ARRAY =
-            "qns.fallback_wwan_ims_unregistration_reason_string_array";
-
-    /**
-     * List of Array items indicating IMS HO registration fail cause & time(millis) for fallback (to
-     * WWAN).
-     *
-     * <p><string-array name="qns.fallback_wwan_ims_ho_reigster_fail_reason_string_array" num="2">
-     * <!-- fallback WWAN with ImsReason 321~378,1503 during 60sec at cellular prefer mode -->
-     * <item value="cause=321~378|1503, time=60000, preference=cell"/>
-     * <!-- fallback WWAN with ImsReason 240,243,323~350 during 90sec -->
-     * <item value="cause=240|243|323~350, time=90000"/> </string-array>
-     *
-     * <p>The default value for this key is "".
-     */
-    static final String KEY_QNS_FALLBACK_WWAN_IMS_HO_REGISTER_FAIL_REASON_STRING_ARRAY =
-            "qns.fallback_wwan_ims_ho_register_fail_reason_string_array";
-
-    /**
-     * Specifies override the call precondition policy of AccessNetworkSelectionPolicy when the
-     * Sip Dialog Session is active.
-     * This Sip Dialog Session policy is applied when there is no calling in the subscription, and
-     * when the device is in a calling state, the calling policy is used first.
-     *
-     * <p> If the Sip Dialog Session is active, the AccessNetworkSelectionPolicy is applied as one
-     * of three policies: none, follow policy as voice call or as video call.
-     * <li>0: {@code QnsConstants#SIP_DIALOG_SESSION_POLICY_NONE} not Applied. The default value
-     * for this key.
-     * <li>1: {@code QnsConstants#SIP_DIALOG_SESSION_POLICY_FOLLOW_VOICE_CALL} apply voice call
-     * policy.
-     * <li>2: {@code QnsConstants#SIP_DIALOG_SESSION_POLICY_FOLLOW_VIDEO_CALL}  apply video call
-     * policy.
-     */
-    static final String KEY_SIP_DIALOG_SESSION_POLICY_INT = "qns.sip_dialog_session_policy_int";
-
-    /**
-     * List of Array items indicating hysteresis db levels based on access network and measurement
-     * type , whose value to be used at api
-     * {@link SignalThresholdInfo#Builder().setHysteresisDb(int)}
-     * The values are set as Format "<accessNetwork>:<meas_type>:<hysteresisDb>"
-     * Ex: "eutran:rsrp:2","ngran:ssrsrp:1"
-     *
-     * The default value or if value set is less than zero,
-     * for this key is {@link QnsConstants#KEY_DEFAULT_VALUE}
-     *
-     */
-    public static final String KEY_QNS_CELLULAR_SIGNAL_STRENGTH_HYSTERESIS_DB_STRING_ARRAY =
-            "qns.cellular_signal_strength_hysteresis_db_string_array";
-
-    private static final Map<Integer, String> sAccessNetworkMap = Map.of(
-            AccessNetworkConstants.AccessNetworkType.EUTRAN, "eutran",
-            AccessNetworkConstants.AccessNetworkType.UTRAN, "utran",
-            AccessNetworkConstants.AccessNetworkType.NGRAN, "ngran",
-            AccessNetworkConstants.AccessNetworkType.GERAN, "geran",
-            AccessNetworkConstants.AccessNetworkType.IWLAN, "wifi"
-    );
-
-    private static final Map<Integer, String> sMeasTypeMap = Map.of(
-            SIGNAL_MEASUREMENT_TYPE_RSRP, "rsrp",
-            SIGNAL_MEASUREMENT_TYPE_RSRQ, "rsrq",
-            SIGNAL_MEASUREMENT_TYPE_RSSNR, "rssnr",
-            SIGNAL_MEASUREMENT_TYPE_SSRSRP, "ssrsrp",
-            SIGNAL_MEASUREMENT_TYPE_SSRSRQ, "ssrsrq",
-            SIGNAL_MEASUREMENT_TYPE_SSSINR, "sssinr",
-            SIGNAL_MEASUREMENT_TYPE_RSCP, "rscp",
-            SIGNAL_MEASUREMENT_TYPE_RSSI, "rssi",
-            SIGNAL_MEASUREMENT_TYPE_ECNO, "ecno"
-    );
-
-    private static final Map<Integer, String> sCallTypeMap = Map.of(
-            QnsConstants.CALL_TYPE_IDLE, "idle",
-            QnsConstants.CALL_TYPE_VOICE, "voice",
-            QnsConstants.CALL_TYPE_VIDEO, "video"
-    );
-
-    private final String mLogTag;
-    private final int mSlotIndex;
-    private final Context mContext;
-    private boolean mIsConfigLoaded = false;
-    protected int mSubId;
-    protected int mCurrCarrierId;
-    private final QnsEventDispatcher mQnsEventDispatcher;
-    private final QnsCarrierAnspSupportConfig mAnspConfigMgr;
-    @VisibleForTesting final Handler mHandler;
-
-    private boolean mIsWfcInAirplaneModeOnSupport;
-    private boolean mIsInCallHoDecisionWlanToWwanWithoutVopsConditionSupported;
-    private boolean mIsHoGuardOnPreferenceSupport;
-    private boolean mIsServiceBarringCheckSupport;
-    private boolean mIsVideoOverIWLANWithCellularCheckSupport;
-    private boolean mIsRoveOutWifiBadGuardTimerConditionsSupported;
-    private boolean mIsAllowImsOverIwlanCellularLimitedCase;
-    private boolean mIsBlockIwlanInInternationalRoamWithoutWwan;
-    private boolean mIsBlockIpv6OnlyWifi;
-    private boolean mIsVolteRoamingSupported;
-    private final boolean[] mAnspSupportConfigArray = new boolean[3];
-
-    private int mWifiThresBackHaulTimer;
-    private int mCellularThresBackHaulTimer;
-    private int mQnsImsTransportType;
-    private int mQnsSosTransportType;
-    private int mQnsMmsTransportType;
-    private int[] mQnsXcapSupportedAccessNetworkTypes;
-    private int mQnsCbsTransportType;
-    private int mXcapRatPreference;
-    private int mSosRatPreference;
-    private int mMmsRatPreference;
-    private int mCbsRatPreference;
-    private int mNetworkEnableHysteresisTimer;
-    private int mMinimumHandoverGuardingTimer;
-    private int mVowifiRegistrationTimerForVowifiActivation;
-    private int mSipDialogSessionPolicy;
-
-    private int[] mWwanHysteresisTimer;
-    private int[] mWlanHysteresisTimer;
-    private int[] mNonImsWwanHysteresisTimer;
-    private int[] mNonImsWlanHysteresisTimer;
-    private int[] mRTPMetricsData = new int[4];
-    private int[] mWaitingTimerForPreferredTransport;
-    private int[] mAllowMaxIwlanHoCountOnReason;
-    private int[] mHoRestrictTimeOnRtpQuality;
-    private int[] mIsMmtelCapabilityRequired;
-    private int[] mIsWfcPreferredTransportRequired;
-
-    private String mWlanRttBackhaulCheckConfigsOnPing;
-    private String[] mImsAllowedRats;
-    private String[] mRoveInGuardTimerConditionThresholdGaps;
-    private String[] mFallbackOnInitialConnectionFailure;
-    private String[] mAccessNetworkMeasurementHysteresisDb;
-
-    @NonNull
-    private final List<FallbackRule> mFallbackWwanRuleWithImsUnregistered = new ArrayList<>();
-
-    @NonNull
-    private final List<FallbackRule> mFallbackWwanRuleWithImsHoRegisterFail = new ArrayList<>();
-
-    /** Rules for handover between IWLAN and cellular network. */
-    @NonNull private List<HandoverRule> mHandoverRuleList = new ArrayList<>();
-
-    protected QnsRegistrantList mQnsCarrierConfigLoadedRegistrants = new QnsRegistrantList();
-    protected QnsRegistrantList mQnsCarrierConfigChangedRegistrants = new QnsRegistrantList();
-
-    protected QnsProvisioningListener.QnsProvisioningInfo mQnsProvisioningInfo =
-            new QnsProvisioningListener.QnsProvisioningInfo();
-
-    void setQnsProvisioningInfo(QnsProvisioningListener.QnsProvisioningInfo info) {
-        mQnsProvisioningInfo = info;
-    }
-
-    private QnsConfigArray applyProvisioningInfo(
-            QnsConfigArray thresholds, int accessNetwork, int measurementType, int callType) {
-
-        if (mQnsProvisioningInfo.hasItem(ProvisioningManager.KEY_LTE_THRESHOLD_1)
-                && thresholds.mBad != QnsConfigArray.INVALID
-                && accessNetwork == AccessNetworkConstants.AccessNetworkType.EUTRAN
-                && measurementType == SIGNAL_MEASUREMENT_TYPE_RSRP) {
-            int bad = mQnsProvisioningInfo.getIntegerItem(ProvisioningManager.KEY_LTE_THRESHOLD_1);
-            Log.d(mLogTag, "provisioning bad THLTE1 old:" + thresholds.mBad + " new:" + bad);
-            thresholds.mBad = bad;
-        }
-        if (mQnsProvisioningInfo.hasItem(ProvisioningManager.KEY_LTE_THRESHOLD_2)
-                && thresholds.mWorst != QnsConfigArray.INVALID
-                && accessNetwork == AccessNetworkConstants.AccessNetworkType.EUTRAN
-                && measurementType == SIGNAL_MEASUREMENT_TYPE_RSRP) {
-            int worst =
-                    mQnsProvisioningInfo.getIntegerItem(ProvisioningManager.KEY_LTE_THRESHOLD_2);
-            Log.d(mLogTag, "provisioning worst THLTE2 old:" + thresholds.mWorst + " new:" + worst);
-            thresholds.mWorst = worst;
-        }
-        if (mQnsProvisioningInfo.hasItem(ProvisioningManager.KEY_LTE_THRESHOLD_3)
-                && thresholds.mGood != QnsConfigArray.INVALID
-                && accessNetwork == AccessNetworkConstants.AccessNetworkType.EUTRAN
-                && measurementType == SIGNAL_MEASUREMENT_TYPE_RSRP) {
-            int good = mQnsProvisioningInfo.getIntegerItem(ProvisioningManager.KEY_LTE_THRESHOLD_3);
-            Log.d(mLogTag, "provisioning good THLTE3 old:" + thresholds.mGood + " new:" + good);
-            thresholds.mGood = good;
-        }
-        if (mQnsProvisioningInfo.hasItem(ProvisioningManager.KEY_WIFI_THRESHOLD_A)
-                && thresholds.mGood != QnsConfigArray.INVALID
-                && accessNetwork == AccessNetworkConstants.AccessNetworkType.IWLAN
-                && measurementType == SIGNAL_MEASUREMENT_TYPE_RSSI) {
-            int good =
-                    mQnsProvisioningInfo.getIntegerItem(ProvisioningManager.KEY_WIFI_THRESHOLD_A);
-            Log.d(mLogTag, "provisioning good VOWT_A old:" + thresholds.mGood + " new:" + good);
-            thresholds.mGood = good;
-        }
-        if (mQnsProvisioningInfo.hasItem(ProvisioningManager.KEY_WIFI_THRESHOLD_B)
-                && thresholds.mBad != QnsConfigArray.INVALID
-                && accessNetwork == AccessNetworkConstants.AccessNetworkType.IWLAN
-                && measurementType == SIGNAL_MEASUREMENT_TYPE_RSSI) {
-            int bad = mQnsProvisioningInfo.getIntegerItem(ProvisioningManager.KEY_WIFI_THRESHOLD_B);
-            Log.d(mLogTag, "provisioning bad VOWT_B old:" + thresholds.mBad + " new:" + bad);
-            thresholds.mBad = bad;
-            // TODO : make video threshold gap config, and move in getThreshold...()
-            if (getCarrierId() == 1839 && callType == QnsConstants.CALL_TYPE_VIDEO) {
-                thresholds.mBad = bad + 5;
-            }
-        }
-
-        return thresholds;
-    }
-
-    static class FallbackRule {
-        /** Key : IMS registration fail reason, value : fallback time in millis */
-        final Set<Integer> mReasons;
-
-        final int mBackoffTimeMillis;
-        final int mPreferenceMode;
-
-        FallbackRule(Set<Integer> reasons, int backoffTimeMillis, int preferenceMode) {
-            mReasons = reasons;
-            mBackoffTimeMillis = backoffTimeMillis;
-            mPreferenceMode = preferenceMode;
-        }
-
-        int getFallBackTime(int reason) {
-            if (mReasons.contains(reason)) {
-                return mBackoffTimeMillis;
-            } else {
-                return 0;
-            }
-        }
-
-        @Override
-        public String toString() {
-            StringBuilder builder = new StringBuilder();
-            builder.append("FallbackRule time:").append(mBackoffTimeMillis);
-            if (mPreferenceMode == -1) {
-                builder.append(" ");
-            } else if (mPreferenceMode == QnsConstants.CELL_PREF) {
-                builder.append(" " + "CELL_PREF_MODE");
-            } else if (mPreferenceMode == QnsConstants.WIFI_PREF) {
-                builder.append(" " + "WIFI_PREF_MODE");
-            }
-            builder.append(" reasons:");
-            for (Integer i : mReasons) {
-                builder.append(i).append(" ");
-            }
-            return builder.toString();
-        }
-    }
-
-    static class HandoverRule {
-        @Retention(RetentionPolicy.SOURCE)
-        @IntDef(
-                prefix = {"RULE_TYPE_"},
-                value = {
-                    RULE_TYPE_ALLOWED,
-                    RULE_TYPE_DISALLOWED,
-                })
-        @interface HandoverRuleType {}
-
-        /** Indicating this rule is for allowing handover. */
-        static final int RULE_TYPE_ALLOWED = 1;
-
-        /** Indicating this rule is for disallowing handover. */
-        static final int RULE_TYPE_DISALLOWED = 2;
-
-        private static final String RULE_TAG_SOURCE_ACCESS_NETWORKS = "source";
-
-        private static final String RULE_TAG_TARGET_ACCESS_NETWORKS = "target";
-
-        private static final String RULE_TAG_TYPE = "type";
-
-        private static final String RULE_TAG_CAPABILITIES = "capabilities";
-
-        private static final String RULE_TAG_ROAMING = "roaming";
-
-        /** Handover rule type. */
-        @HandoverRuleType final int mHandoverRuleType;
-
-        /** The applicable source access networks for handover. */
-        @NonNull @AccessNetworkConstants.RadioAccessNetworkType
-        final Set<Integer> mSourceAccessNetworks;
-
-        /** The applicable target access networks for handover. */
-        @NonNull @AccessNetworkConstants.RadioAccessNetworkType
-        final Set<Integer> mTargetAccessNetworks;
-
-        /**
-         * The network capabilities to any of which this handover rule applies. If is empty, then
-         * capability is ignored as a rule matcher.
-         */
-        @NonNull @NetCapability final Set<Integer> mNetworkCapabilities;
-
-        /** {@code true} indicates this policy is only applicable when the device is roaming. */
-        final boolean mIsOnlyForRoaming;
-
-        /**
-         * Constructor
-         *
-         * @param ruleString The rule in string format.
-         * @see CarrierConfigManager#KEY_IWLAN_HANDOVER_POLICY_STRING_ARRAY
-         */
-        HandoverRule(@NonNull String ruleString) {
-            if (TextUtils.isEmpty(ruleString)) {
-                throw new IllegalArgumentException("illegal rule " + ruleString);
-            }
-
-            Set<Integer> source = null, target = null, capabilities = Collections.emptySet();
-            int type = 0;
-            boolean roaming = false;
-
-            ruleString = ruleString.trim().toLowerCase(Locale.ROOT);
-            String[] expressions = ruleString.split("\\s*,\\s*");
-            for (String expression : expressions) {
-                String[] tokens = expression.trim().split("\\s*=\\s*");
-                if (tokens.length != 2) {
-                    throw new IllegalArgumentException(
-                            "illegal rule " + ruleString + ", tokens=" + Arrays.toString(tokens));
-                }
-                String key = tokens[0].trim();
-                String value = tokens[1].trim();
-                try {
-                    switch (key) {
-                        case RULE_TAG_SOURCE_ACCESS_NETWORKS:
-                            source =
-                                    Arrays.stream(value.split("\\s*\\|\\s*"))
-                                            .map(String::trim)
-                                            .map(QnsConstants::accessNetworkTypeFromString)
-                                            .collect(Collectors.toSet());
-                            break;
-                        case RULE_TAG_TARGET_ACCESS_NETWORKS:
-                            target =
-                                    Arrays.stream(value.split("\\s*\\|\\s*"))
-                                            .map(String::trim)
-                                            .map(QnsConstants::accessNetworkTypeFromString)
-                                            .collect(Collectors.toSet());
-                            break;
-                        case RULE_TAG_TYPE:
-                            if (value.toLowerCase(Locale.ROOT).equals("allowed")) {
-                                type = RULE_TYPE_ALLOWED;
-                            } else if (value.toLowerCase(Locale.ROOT).equals("disallowed")) {
-                                type = RULE_TYPE_DISALLOWED;
-                            } else {
-                                throw new IllegalArgumentException("unexpected rule type " + value);
-                            }
-                            break;
-                        case RULE_TAG_CAPABILITIES:
-                            capabilities = QnsUtils.getNetworkCapabilitiesFromString(value);
-                            break;
-                        case RULE_TAG_ROAMING:
-                            roaming = Boolean.parseBoolean(value);
-                            break;
-                        default:
-                            throw new IllegalArgumentException("unexpected key " + key);
-                    }
-                } catch (Exception e) {
-                    e.printStackTrace();
-                    throw new IllegalArgumentException(
-                            "illegal rule \"" + ruleString + "\", e=" + e);
-                }
-            }
-
-            if (source == null || target == null || source.isEmpty() || target.isEmpty()) {
-                throw new IllegalArgumentException(
-                        "Need to specify both source and target. " + "\"" + ruleString + "\"");
-            }
-
-            if (source.contains(AccessNetworkConstants.AccessNetworkType.UNKNOWN)
-                    && type != RULE_TYPE_DISALLOWED) {
-                throw new IllegalArgumentException("Unknown access network can be only specified in"
-                        + " the disallowed rule. \"" + ruleString + "\"");
-            }
-
-            if (target.contains(AccessNetworkConstants.AccessNetworkType.UNKNOWN)) {
-                throw new IllegalArgumentException(
-                        "Target access networks contains unknown. " + "\"" + ruleString + "\"");
-            }
-
-            if (type == 0) {
-                throw new IllegalArgumentException(
-                        "Rule type is not specified correctly. " + "\"" + ruleString + "\"");
-            }
-
-            if (capabilities != null && capabilities.contains(-1)) {
-                throw new IllegalArgumentException(
-                        "Network capabilities contains unknown. " + "\"" + ruleString + "\"");
-            }
-
-            if (!source.contains(AccessNetworkConstants.AccessNetworkType.IWLAN)
-                    && !target.contains(AccessNetworkConstants.AccessNetworkType.IWLAN)) {
-                throw new IllegalArgumentException(
-                        "IWLAN must be specified in either source or "
-                                + "target access networks.\""
-                                + ruleString
-                                + "\"");
-            }
-
-            mSourceAccessNetworks = source;
-            mTargetAccessNetworks = target;
-            this.mHandoverRuleType = type;
-            mNetworkCapabilities = capabilities;
-            mIsOnlyForRoaming = roaming;
-        }
-
-        @Override
-        public String toString() {
-            return "[HandoverRule: type="
-                    + (mHandoverRuleType == RULE_TYPE_ALLOWED ? "allowed" : "disallowed")
-                    + ", source="
-                    + mSourceAccessNetworks.stream()
-                            .map(QnsConstants::accessNetworkTypeToString)
-                            .collect(Collectors.joining("|"))
-                    + ", target="
-                    + mTargetAccessNetworks.stream()
-                            .map(QnsConstants::accessNetworkTypeToString)
-                            .collect(Collectors.joining("|"))
-                    + ", isRoaming="
-                    + mIsOnlyForRoaming
-                    + ", capabilities="
-                    + QnsUtils.networkCapabilitiesToString(mNetworkCapabilities)
-                    + "]";
-        }
-    }
-
-    private class QnsCarrierConfigChangeHandler extends Handler {
-        QnsCarrierConfigChangeHandler(Looper looper) {
-            super(looper);
-        }
-
-        @Override
-        public void handleMessage(Message message) {
-            switch (message.what) {
-                case QnsEventDispatcher.QNS_EVENT_CARRIER_CONFIG_CHANGED:
-                    Log.d(mLogTag, "Event received QNS_EVENT_CARRIER_CONFIG_CHANGED");
-                    if (SubscriptionManager.isValidSubscriptionId(getSubId())) {
-                        int newCarrierID = getCarrierId();
-                        Log.d(
-                                mLogTag,
-                                "Carrier Id: current=" + mCurrCarrierId + ", new=" + newCarrierID);
-                        if (newCarrierID != 0 && newCarrierID != UNKNOWN_CARRIER_ID) {
-                            if (mCurrCarrierId != newCarrierID) {
-                                mCurrCarrierId = newCarrierID;
-                                loadQnsConfigurations();
-                                mIsConfigLoaded = true;
-                                notifyLoadQnsConfigurationsCompleted();
-                            } else {
-                                if (isQnsConfigChanged()) {
-                                    Log.d(mLogTag, "Qns Carrier config updated found");
-                                    notifyQnsConfigurationsChanged();
-                                }
-                            }
-                        }
-                    }
-                    break;
-                default:
-                    break;
-            }
-        }
-    }
-
-    /**
-     * Constructor to Initial Slot and Context whose carrier config ID needs to be loaded along with
-     * initialising the Action Intent on which Carrier Config ID to be loaded.
-     */
-    QnsCarrierConfigManager(Context context, QnsEventDispatcher dispatcher, int slotIndex) {
-        mSlotIndex = slotIndex;
-        mContext = context;
-        mLogTag =
-                QnsConstants.QNS_TAG
-                        + "_"
-                        + QnsCarrierConfigManager.class.getSimpleName()
-                        + "_"
-                        + mSlotIndex;
-        mQnsEventDispatcher = dispatcher;
-        mAnspConfigMgr = new QnsCarrierAnspSupportConfig(slotIndex);
-
-        HandlerThread handlerThread = new HandlerThread(mLogTag);
-        handlerThread.start();
-        mHandler =
-                new QnsCarrierConfigManager.QnsCarrierConfigChangeHandler(
-                        handlerThread.getLooper());
-
-        List<Integer> events = new ArrayList<>();
-        events.add(QnsEventDispatcher.QNS_EVENT_CARRIER_CONFIG_CHANGED);
-        mQnsEventDispatcher.registerEvent(events, mHandler);
-
-        // sending empty message when new object created; as actual event will not be received in
-        // case QNS restarts.
-        // This EVENT will not be processed in bootup case since carrier id will be invalid until
-        // actual event received from QnsEventDispatcher.
-        mHandler.sendEmptyMessage(QnsEventDispatcher.QNS_EVENT_CARRIER_CONFIG_CHANGED);
-
-        // To do : Update based on xml version Changes handling
-        // To do : Operator Update on Threshold changes handling
-    }
-
-    /** Below API clears the current Access Network selection Policies */
-    void close() {
-        if (mHandler != null) mQnsEventDispatcher.unregisterEvent(mHandler);
-    }
-
-    synchronized PersistableBundle readFromCarrierConfigManager(Context context) {
-        PersistableBundle carrierConfigBundle;
-        CarrierConfigManager carrierConfigManager =
-                context.getSystemService(CarrierConfigManager.class);
-
-        if (carrierConfigManager == null) {
-            throw new IllegalStateException("Carrier config manager is null.");
-        }
-        carrierConfigBundle = carrierConfigManager.getConfigForSubId(getSubId());
-
-        return carrierConfigBundle;
-    }
-
-    synchronized PersistableBundle readFromAssets(Context context) {
-        PersistableBundle assetBundle;
-
-        assetBundle = QnsUtils.readQnsDefaultConfigFromAssets(context, mCurrCarrierId);
-
-        if (assetBundle == null) {
-            throw new IllegalStateException("Carrier config manager is null.");
-        }
-
-        return assetBundle;
-    }
-
-    /** Below API is used for Loading the carrier configurations based on Current Carrier ID */
-    void loadQnsConfigurations() {
-
-        PersistableBundle carrierConfigBundle = readFromCarrierConfigManager(mContext);
-        Log.d(mLogTag, "CarrierConfig Bundle for Slot: " + mSlotIndex + carrierConfigBundle);
-
-        PersistableBundle assetConfigBundle = readFromAssets(mContext);
-        Log.d(mLogTag, "AssetConfig Bundle for Slot: " + mSlotIndex + assetConfigBundle);
-
-        // load configurations supporting ANE
-        loadQnsAneSupportConfigurations(carrierConfigBundle, assetConfigBundle);
-
-        // load qns Ansp (Access Network Selection Policy) carrier Support Configurations
-        // for building Internal ANSP Policies
-        loadAnspCarrierSupportConfigs(carrierConfigBundle, assetConfigBundle);
-
-        mAnspConfigMgr.loadQnsAnspSupportArray(carrierConfigBundle, assetConfigBundle);
-
-        // Load configs using Carrier Config Manager Keys
-        loadDirectFromCarrierConfigManagerKey(carrierConfigBundle);
-
-        loadWfcConfigurations(carrierConfigBundle, assetConfigBundle);
-
-        loadMediaThreshold(carrierConfigBundle, assetConfigBundle);
-    }
-
-    /**
-     * Below API takes care of loading the configuration based on the carrier config Manager
-     * available for given carrier config manager keys.
-     */
-    void loadDirectFromCarrierConfigManagerKey(PersistableBundle bundleCarrier) {
-        loadHandoverRules(
-                bundleCarrier, null, CarrierConfigManager.KEY_IWLAN_HANDOVER_POLICY_STRING_ARRAY);
-        loadCarrierConfig(bundleCarrier);
-    }
-
-    /**
-     * Below API takes care of validating the configs (Threshold & HO rules) Updates after loading
-     * Qns configurations, for the current operator in use, in case of config update scenario
-     *
-     * @return : true/false
-     */
-    synchronized boolean isQnsConfigChanged() {
-        PersistableBundle carrierConfigBundle = readFromCarrierConfigManager(mContext);
-        Log.d(
-                mLogTag,
-                "Check carrier config for Qns item changefor_slot: "
-                        + mSlotIndex
-                        + "_"
-                        + carrierConfigBundle);
-        PersistableBundle assetConfigBundle = readFromAssets(mContext);
-        Log.d(
-                mLogTag,
-                "Check Asset config for Qns item changefor_slot: "
-                        + mSlotIndex
-                        + "_"
-                        + assetConfigBundle);
-
-        boolean isThresholdConfigChanged =
-                checkThresholdConfigChange(carrierConfigBundle, assetConfigBundle);
-        boolean isHandoverRulesChanged =
-                checkHandoverRuleConfigChange(
-                        carrierConfigBundle,
-                        null,
-                        CarrierConfigManager.KEY_IWLAN_HANDOVER_POLICY_STRING_ARRAY);
-        Log.d(
-                mLogTag,
-                "Threshold config changed = "
-                        + isThresholdConfigChanged
-                        + ", IMS handover rule changed = "
-                        + isHandoverRulesChanged);
-
-        return (isThresholdConfigChanged || isHandoverRulesChanged);
-    }
-
-    /**
-     * Below API takes to check if current HO rules as any difference with existing HO rules Updated
-     * based on Event Carrier config change event received after initial loading @Param
-     * PersistableBundle : configBundle
-     *
-     * @return true/false
-     */
-    synchronized boolean checkHandoverRuleConfigChange(
-            PersistableBundle carrierConfigBundle,
-            PersistableBundle assetConfigBundle,
-            String key) {
-        List<HandoverRule> handoverUpdateRuleList =
-                updateHandoverRules(carrierConfigBundle, assetConfigBundle, key);
-
-        Log.d(mLogTag, "New rule:" + handoverUpdateRuleList.toString());
-        Log.d(mLogTag, "Existing rule:" + mHandoverRuleList.toString());
-
-        if (mHandoverRuleList.toString().equals(handoverUpdateRuleList.toString())
-                || handoverUpdateRuleList.isEmpty()
-                || mHandoverRuleList.isEmpty()) {
-            handoverUpdateRuleList.clear();
-            return false;
-        } else {
-            mHandoverRuleList = new ArrayList<>(handoverUpdateRuleList);
-            Log.d(mLogTag, "New rule Updated:" + mHandoverRuleList);
-            handoverUpdateRuleList.clear();
-            return true;
-        }
-    }
-
-    /**
-     * Below API takes to check if ANSP threshold configs was Updated based on Event Carrier config
-     * change event received after initial Qns configuration loading is completed
-     */
-    synchronized boolean checkThresholdConfigChange(
-            PersistableBundle carrierConfigBundle, PersistableBundle assetConfigBundle) {
-
-        return mAnspConfigMgr.checkQnsAnspConfigChange(carrierConfigBundle, assetConfigBundle);
-    }
-
-    /**
-     * Below API takes care of loading the configuration based on the Bundle data built based on
-     * asset folder xml file . (Except reading Key item of threshold & ANSP
-     */
-    void loadQnsAneSupportConfigurations(
-            PersistableBundle bundleCarrier, PersistableBundle bundleAsset) {
-
-        mIsWfcInAirplaneModeOnSupport =
-                getConfig(
-                        bundleCarrier, bundleAsset, KEY_QNS_SUPPORT_WFC_DURING_AIRPLANE_MODE_BOOL);
-        mIsInCallHoDecisionWlanToWwanWithoutVopsConditionSupported =
-                getConfig(
-                        bundleCarrier,
-                        bundleAsset,
-                        KEY_IN_CALL_HO_DECISION_WLAN_TO_WWAN_WITHOUT_VOPS_CONDITION_BOOL);
-        mIsHoGuardOnPreferenceSupport =
-                getConfig(bundleCarrier, bundleAsset, KEY_QNS_HO_GUARDING_BY_PREFERENCE_BOOL);
-        mIsServiceBarringCheckSupport =
-                getConfig(bundleCarrier, bundleAsset, KEY_QNS_SUPPORT_SERVICE_BARRING_CHECK_BOOL);
-        mIsVideoOverIWLANWithCellularCheckSupport =
-                getConfig(
-                        bundleCarrier,
-                        bundleAsset,
-                        KEY_QNS_ALLOW_VIDEO_OVER_IWLAN_WITH_CELLULAR_LIMITED_CASE_BOOL);
-        mIsRoveOutWifiBadGuardTimerConditionsSupported =
-                getConfig(
-                        bundleCarrier,
-                        bundleAsset,
-                        KEY_QNS_ROVE_OUT_POLICY_WITH_WIFI_BAD_GUARDTIMER_CONDITIONS_BOOL);
-        mIsAllowImsOverIwlanCellularLimitedCase =
-                getConfig(
-                        bundleCarrier,
-                        bundleAsset,
-                        KEY_QNS_ALLOW_IMS_OVER_IWLAN_CELLULAR_LIMITED_CASE_BOOL);
-        mIsBlockIwlanInInternationalRoamWithoutWwan =
-                getConfig(
-                        bundleCarrier,
-                        bundleAsset,
-                        KEY_BLOCK_IWLAN_IN_INTERNATIONAL_ROAMING_WITHOUT_WWAN_BOOL);
-        mIsBlockIpv6OnlyWifi = getConfig(bundleCarrier, bundleAsset, KEY_BLOCK_IPV6_ONLY_WIFI_BOOL);
-
-        mWifiThresBackHaulTimer =
-                getConfig(
-                        bundleCarrier,
-                        bundleAsset,
-                        KEY_QNS_WIFI_RSSI_THRESHOLDBACKHAUL_TIMER_MS_INT);
-        mCellularThresBackHaulTimer =
-                getConfig(
-                        bundleCarrier,
-                        bundleAsset,
-                        KEY_QNS_CELLULAR_SS_THRESHOLDBACKHAUL_TIMER_MS_INT);
-        mQnsImsTransportType =
-                getConfig(bundleCarrier, bundleAsset, KEY_QNS_IMS_TRANSPORT_TYPE_INT);
-        mQnsSosTransportType =
-                getConfig(bundleCarrier, bundleAsset, KEY_QNS_SOS_TRANSPORT_TYPE_INT);
-        mQnsMmsTransportType =
-                getConfig(bundleCarrier, bundleAsset, KEY_QNS_MMS_TRANSPORT_TYPE_INT);
-        mQnsXcapSupportedAccessNetworkTypes =
-                getConfig(
-                        bundleCarrier,
-                        bundleAsset,
-                        CarrierConfigManager.ImsSs.KEY_XCAP_OVER_UT_SUPPORTED_RATS_INT_ARRAY);
-        mQnsCbsTransportType =
-                getConfig(bundleCarrier, bundleAsset, KEY_QNS_CBS_TRANSPORT_TYPE_INT);
-        mQnsCbsTransportType =
-                getConfig(bundleCarrier, bundleAsset, KEY_QNS_CBS_TRANSPORT_TYPE_INT);
-        mXcapRatPreference = getConfig(bundleCarrier, bundleAsset, KEY_QNS_XCAP_RAT_PREFERENCE_INT);
-        mSosRatPreference = getConfig(bundleCarrier, bundleAsset, KEY_QNS_SOS_RAT_PREFERENCE_INT);
-        mMmsRatPreference = getConfig(bundleCarrier, bundleAsset, KEY_QNS_MMS_RAT_PREFERENCE_INT);
-        mCbsRatPreference = getConfig(bundleCarrier, bundleAsset, KEY_QNS_CBS_RAT_PREFERENCE_INT);
-        mNetworkEnableHysteresisTimer =
-                getConfig(
-                        bundleCarrier,
-                        bundleAsset,
-                        KEY_QNS_IMS_NETWORK_ENABLE_HO_HYSTERESIS_TIMER_INT);
-
-        mWwanHysteresisTimer =
-                getConfig(bundleCarrier, bundleAsset, KEY_IMS_WWAN_HYSTERESIS_TIMER_MS_INT_ARRAY);
-        mWlanHysteresisTimer =
-                getConfig(bundleCarrier, bundleAsset, KEY_IMS_WLAN_HYSTERESIS_TIMER_MS_INT_ARRAY);
-        mNonImsWwanHysteresisTimer =
-                getConfig(
-                        bundleCarrier, bundleAsset, KEY_NON_IMS_WWAN_HYSTERESIS_TIMER_MS_INT_ARRAY);
-        mNonImsWlanHysteresisTimer =
-                getConfig(
-                        bundleCarrier, bundleAsset, KEY_NON_IMS_WLAN_HYSTERESIS_TIMER_MS_INT_ARRAY);
-        mMinimumHandoverGuardingTimer =
-                getConfig(bundleCarrier, bundleAsset, KEY_MINIMUM_HANDOVER_GUARDING_TIMER_MS_INT);
-        mWaitingTimerForPreferredTransport =
-                getConfig(
-                        bundleCarrier,
-                        bundleAsset,
-                        KEY_WAITING_TIME_FOR_PREFERRED_TRANSPORT_WHEN_POWER_ON_INT_ARRAY);
-        mAllowMaxIwlanHoCountOnReason =
-                getConfig(
-                        bundleCarrier,
-                        bundleAsset,
-                        KEY_QNS_IN_CALL_ROVEIN_ALLOWED_COUNT_AND_FALLBACK_REASON_INT_ARRAY);
-        mHoRestrictTimeOnRtpQuality =
-                getConfig(
-                        bundleCarrier,
-                        bundleAsset,
-                        KEY_QNS_HO_RESTRICT_TIME_WITH_LOW_RTP_QUALITY_MILLIS_INT_ARRAY);
-        mWlanRttBackhaulCheckConfigsOnPing =
-                getConfig(
-                        bundleCarrier,
-                        bundleAsset,
-                        KEY_QNS_WLAN_RTT_BACKHAUL_CHECK_ON_ICMP_PING_STRING);
-
-        mFallbackOnInitialConnectionFailure =
-                getConfig(
-                        bundleCarrier,
-                        bundleAsset,
-                        KEY_QNS_FALLBACK_ON_INITIAL_CONNECTION_FAILURE_STRING_ARRAY);
-        mImsAllowedRats =
-                getConfig(bundleCarrier, bundleAsset, KEY_IMS_CELLULAR_ALLOWED_RAT_STRING_ARRAY);
-        mRoveInGuardTimerConditionThresholdGaps =
-                getConfig(
-                        bundleCarrier,
-                        bundleAsset,
-                        KEY_QNS_ROVEIN_THRESHOLD_GAP_WITH_GUARD_TIMER_STRING_ARRAY);
-        mSipDialogSessionPolicy =
-                getConfig(bundleCarrier, bundleAsset, KEY_SIP_DIALOG_SESSION_POLICY_INT);
-        mAccessNetworkMeasurementHysteresisDb =
-                getConfig(
-                        bundleCarrier,
-                        bundleAsset,
-                        KEY_QNS_CELLULAR_SIGNAL_STRENGTH_HYSTERESIS_DB_STRING_ARRAY);
-
-        loadFallbackPolicyWithImsRegiFail(bundleCarrier, bundleAsset);
-    }
-
-    @VisibleForTesting
-    void loadWfcConfigurations(PersistableBundle bundleCarrier, PersistableBundle bundleAsset) {
-
-        mVowifiRegistrationTimerForVowifiActivation =
-                getConfig(
-                        bundleCarrier,
-                        bundleAsset,
-                        KEY_QNS_VOWIFI_REGISTATION_TIMER_FOR_VOWIFI_ACTIVATION_INT);
-    }
-
-    @VisibleForTesting
-    void loadFallbackPolicyWithImsRegiFail(PersistableBundle carrier, PersistableBundle asset) {
-        synchronized (this) {
-            mFallbackWwanRuleWithImsUnregistered.clear();
-            String[] fallbackRulesStrings =
-                    getConfig(
-                            carrier,
-                            asset,
-                            KEY_QNS_FALLBACK_WWAN_IMS_UNREGISTRATION_REASON_STRING_ARRAY);
-            if (fallbackRulesStrings != null) {
-                Log.d(mLogTag, "loadFallbackPolicyWithImsRegiFail" + fallbackRulesStrings.length);
-                for (String ruleString : fallbackRulesStrings) {
-                    Log.d(mLogTag, " ruleString1:" + ruleString);
-                    FallbackRule rule = parseFallbackRule(ruleString);
-                    if (rule != null) {
-                        mFallbackWwanRuleWithImsUnregistered.add(rule);
-                    }
-                }
-            } else {
-                Log.d(mLogTag, "Config FallbackWwanRuleWithImsUnregistered is null");
-            }
-            mFallbackWwanRuleWithImsHoRegisterFail.clear();
-            fallbackRulesStrings =
-                    getConfig(
-                            carrier,
-                            asset,
-                            KEY_QNS_FALLBACK_WWAN_IMS_HO_REGISTER_FAIL_REASON_STRING_ARRAY);
-            if (fallbackRulesStrings != null) {
-                Log.d(mLogTag, "loadFallbackPolicyWithImsRegiFail2:" + fallbackRulesStrings.length);
-                for (String ruleString : fallbackRulesStrings) {
-                    Log.d(mLogTag, " ruleString2:" + ruleString);
-                    FallbackRule rule = parseFallbackRule(ruleString);
-                    if (rule != null) {
-                        mFallbackWwanRuleWithImsHoRegisterFail.add(rule);
-                    }
-                }
-            } else {
-                Log.d(mLogTag, "Config mFallbackWwanRuleWithImsHoRegisterFail is null");
-            }
-        }
-    }
-
-    private FallbackRule parseFallbackRule(String ruleString) {
-        if (TextUtils.isEmpty(ruleString)) {
-            throw new IllegalArgumentException("illegal rule " + ruleString);
-        }
-        Set<Integer> reasons = new ArraySet<>();
-        int time = 0;
-        int preferenceMode = -1;
-        ruleString = ruleString.trim().toLowerCase(Locale.ROOT);
-        String[] expressions = ruleString.split("\\s*,\\s*");
-        for (String expression : expressions) {
-            String[] tokens = expression.trim().split("\\s*=\\s*");
-            if (tokens.length != 2) {
-                throw new IllegalArgumentException(
-                        "illegal rule " + ruleString + ", tokens=" + Arrays.toString(tokens));
-            }
-            String key = tokens[0].trim();
-            String value = tokens[1].trim();
-
-            try {
-                switch (key) {
-                    case "cause":
-                        String[] cause = value.trim().split("\\s*\\|\\s*");
-                        for (String c : cause) {
-                            if (!c.contains("~")) {
-                                reasons.add(Integer.parseInt(c));
-                            } else {
-                                String[] tok = c.trim().split("\\s*~\\s*");
-                                int start = Integer.parseInt(tok[0]);
-                                int end = Integer.parseInt(tok[1]);
-                                for (int i = start; i <= end; i++) {
-                                    reasons.add(i);
-                                }
-                            }
-                        }
-                        break;
-                    case "time":
-                        time = Integer.parseInt(value);
-                        break;
-                    case "preference":
-                        if (value.equals("cell")) {
-                            preferenceMode = QnsConstants.CELL_PREF;
-                        } else if (value.equals("wifi")) {
-                            preferenceMode = QnsConstants.WIFI_PREF;
-                        }
-                        break;
-
-                    default:
-                        throw new IllegalArgumentException("unexpected key " + key);
-                }
-
-            } catch (Exception e) {
-                e.printStackTrace();
-                throw new IllegalArgumentException("illegal rule \"" + ruleString + "\", e=" + e);
-            }
-        }
-        if (reasons.size() > 0) {
-            return new FallbackRule(reasons, time, preferenceMode);
-        } else {
-            return null;
-        }
-    }
-
-    private synchronized <T> T getConfig(
-            PersistableBundle bundleCarrier, PersistableBundle bundleAsset, String configKey) {
-        return QnsUtils.getConfig(bundleCarrier, bundleAsset, configKey);
-    }
-
-    /** Load handover rules from carrier config. */
-    @VisibleForTesting
-    void loadHandoverRules(
-            PersistableBundle bundleCarrier, PersistableBundle bundleAsset, String key) {
-        synchronized (this) {
-            mHandoverRuleList.clear();
-            String[] handoverRulesStrings = getConfig(bundleCarrier, bundleAsset, key);
-            if (handoverRulesStrings != null) {
-                for (String ruleString : handoverRulesStrings) {
-                    Log.d(mLogTag, "loadHandoverRules: " + ruleString);
-                    try {
-                        mHandoverRuleList.add(new HandoverRule(ruleString));
-                    } catch (IllegalArgumentException e) {
-                        Log.d(mLogTag, "loadHandoverRules: " + e.getMessage());
-                    }
-                }
-            }
-        }
-    }
-
-    void loadMediaThreshold(PersistableBundle bundleCarrier, PersistableBundle assetConfigBundle) {
-        //read Jitter
-        mRTPMetricsData[0] = getConfig(
-                bundleCarrier, null,
-                CarrierConfigManager.ImsVoice.KEY_VOICE_RTP_JITTER_THRESHOLD_MILLIS_INT);
-        //read Packet Loss Rate
-        mRTPMetricsData[1] = getConfig(
-                bundleCarrier, null,
-                CarrierConfigManager.ImsVoice.KEY_VOICE_RTP_PACKET_LOSS_RATE_THRESHOLD_INT);
-        //read Inactivity Time
-        long inactivityTime = getConfig(
-                bundleCarrier, null,
-                CarrierConfigManager.ImsVoice.KEY_VOICE_RTP_INACTIVITY_TIME_THRESHOLD_MILLIS_LONG);
-        mRTPMetricsData[3] = (int) inactivityTime;
-        //read Packet Loss Duration
-        mRTPMetricsData[2] = getConfig(
-                bundleCarrier, assetConfigBundle,
-                KEY_QNS_MEDIA_THRESHOLD_RTP_PACKET_LOSS_TIME_MILLIS_INT);
-    }
-
-    /** Updated handover rules from carrier config. */
-    @VisibleForTesting
-    List<HandoverRule> updateHandoverRules(
-            PersistableBundle bundleCarrier, PersistableBundle bundleAsset, String key) {
-        List<HandoverRule> readNewHandoverRuleList = new ArrayList<>();
-        synchronized (this) {
-            String[] handoverRulesStrings = getConfig(bundleCarrier, bundleAsset, key);
-            if (handoverRulesStrings != null) {
-                for (String ruleString : handoverRulesStrings) {
-                    Log.d(mLogTag, "UpdateHandoverRules: " + ruleString);
-                    try {
-                        Log.d(mLogTag, "Rule Updated");
-                        readNewHandoverRuleList.add(new HandoverRule(ruleString));
-                    } catch (IllegalArgumentException e) {
-                        Log.d(mLogTag, "UpdateHandoverRules: " + e.getMessage());
-                    }
-                }
-            }
-        }
-        return readNewHandoverRuleList;
-    }
-
-    /** Load carrier config. */
-    @VisibleForTesting
-    void loadCarrierConfig(PersistableBundle bundleCarrier) {
-        mIsMmtelCapabilityRequired =
-                getConfig(
-                        bundleCarrier,
-                        null,
-                        CarrierConfigManager.Ims.KEY_IMS_PDN_ENABLED_IN_NO_VOPS_SUPPORT_INT_ARRAY);
-        mIsVolteRoamingSupported =
-                getConfig(
-                        bundleCarrier,
-                        null,
-                        CarrierConfigManager.ImsVoice.KEY_CARRIER_VOLTE_ROAMING_AVAILABLE_BOOL);
-    }
-
-    /**
-     * To read the current Carrier ID based on the Slot ID and Context info
-     *
-     * @return : Current Carrier ID
-     */
-    int getCarrierId() {
-        TelephonyManager tm = mContext.getSystemService(TelephonyManager.class);
-        if (tm != null) {
-            tm = tm.createForSubscriptionId(QnsUtils.getSubId(mContext, mSlotIndex));
-            return tm.getSimCarrierId();
-        }
-        return 0;
-    }
-
-    /**
-     * To read the current Subscription ID based on the Slot ID and Context info Output : Current
-     * Carrier ID
-     */
-    int getSubId() {
-        mSubId = QnsUtils.getSubId(mContext, mSlotIndex);
-        return mSubId;
-    }
-
-    /** Notify all the registrants of the Slot loaded after carrier config loading is Completed */
-    protected void notifyLoadQnsConfigurationsCompleted() {
-        if (mQnsCarrierConfigLoadedRegistrants != null) {
-            mQnsCarrierConfigLoadedRegistrants.notifyRegistrants();
-        } else {
-            Log.d(mLogTag, "notifyLoadQnsConfigurationsCompleted. no Registrant.");
-        }
-    }
-
-    /** Notify all the registrants of the Slot loaded after carrier config loading is Completed */
-    protected void notifyQnsConfigurationsChanged() {
-
-        if (mQnsCarrierConfigChangedRegistrants != null) {
-            mQnsCarrierConfigChangedRegistrants.notifyRegistrants();
-        } else {
-            Log.d(mLogTag, "notifyQnsConfigurationsChanged. no Registrant.");
-        }
-    }
-
-    /**
-     * API exposed for other classes to register for notification with handlers on Carrier
-     * Configuration Loaded
-     *
-     * @param h    Handler to receive event
-     * @param what Event on which to be handled
-     */
-    void registerForConfigurationLoaded(Handler h, int what) {
-        mQnsCarrierConfigLoadedRegistrants.addUnique(h, what, null);
-        if (mIsConfigLoaded) {
-            // notify the handler if config is already loaded.
-            h.sendEmptyMessage(what);
-        }
-    }
-
-    /**
-     * API exposed for other classes to register for notification with handlers on Carrier
-     * Configuration changed
-     *
-     * @param h    Handler to receive event
-     * @param what Event on which to be handled
-     */
-    void registerForConfigurationChanged(Handler h, int what) {
-        mQnsCarrierConfigChangedRegistrants.addUnique(h, what, null);
-    }
-
-    /**
-     * API exposed for other classes to unregister for notification of QNS Configuration loaded with
-     * handlers
-     *
-     * @param h Handler to Unregister receiving event Output : Void
-     */
-    void unregisterForConfigurationLoaded(Handler h) {
-        mQnsCarrierConfigLoadedRegistrants.remove(h);
-    }
-
-    /**
-     * API exposed for other classes to unregister for notification of QNS Configuration changed
-     * with handlers
-     *
-     * @param h Handler to Unregister receiving event Output : Void
-     */
-    void unregisterForConfigurationChanged(Handler h) {
-        mQnsCarrierConfigChangedRegistrants.remove(h);
-    }
-
-    /**
-     * This method returns if WFC is supported in Airplane Mode On
-     *
-     * @return : boolean (True/False)
-     */
-    boolean allowWFCOnAirplaneModeOn() {
-
-        return mIsWfcInAirplaneModeOnSupport;
-    }
-
-    /**
-     * This method returns if in-call handover decision from WLAN to WWAN should not consider VoPS
-     * status.
-     *
-     * @return True if in-call handover decision from WLAN to WWAN should not consider VoPS status,
-     * otherwise false.
-     */
-    boolean isInCallHoDecisionWlanToWwanWithoutVopsCondition() {
-        return mIsInCallHoDecisionWlanToWwanWithoutVopsConditionSupported;
-    }
-
-    /**
-     * This method returns VOPS/VONR bit is required for WWAN availability.
-     *
-     * @return : boolean (True/False)
-     */
-    boolean isMmtelCapabilityRequired(int coverage) {
-        if (mIsMmtelCapabilityRequired == null || mIsMmtelCapabilityRequired.length == 0) {
-            return true;
-        }
-        for (int i : mIsMmtelCapabilityRequired) {
-            if ((i == CarrierConfigManager.Ims.NETWORK_TYPE_HOME
-                            && coverage == QnsConstants.COVERAGE_HOME)
-                    || (i == CarrierConfigManager.Ims.NETWORK_TYPE_ROAMING
-                            && coverage == QnsConstants.COVERAGE_ROAM)) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * This method returns if VoLTE roaming is supported by a carrier.
-     *
-     * @return True if VoLTE roaming is supported or UE is in home network, otherwise false.
-     */
-    boolean isVolteRoamingSupported(@QnsConstants.CellularCoverage int coverage) {
-        if (coverage == QnsConstants.COVERAGE_ROAM) {
-            return mIsVolteRoamingSupported;
-        }
-        return true;
-    }
-
-    /**
-     * This method returns Video call over WFC with wfc off & LTE preconditions met
-     *
-     * @return : boolean (True/False)
-     */
-    boolean allowVideoOverIWLANWithCellularLimitedCase() {
-        return mIsVideoOverIWLANWithCellularCheckSupport;
-    }
-
-    /**
-     * This method returns if handover is allowed by policy
-     *
-     * @return True if handover is allowed by policy, otherwise false.
-     */
-    boolean isHandoverAllowedByPolicy(
-            int netCapability, int srcAn, int destAn, @QnsConstants.CellularCoverage int coverage) {
-        Log.d(
-                mLogTag,
-                "isHandoverAllowedByPolicy netCapability: "
-                        + QnsUtils.getNameOfNetCapability(netCapability)
-                        + " srcAccessNetwork:"
-                        + QnsConstants.accessNetworkTypeToString(srcAn)
-                        + " destAccessNetwork:"
-                        + QnsConstants.accessNetworkTypeToString(destAn)
-                        + "  "
-                        + QnsConstants.coverageToString(coverage));
-        // check Telephony handover policy.
-        // Matching the rules by the configured order. Bail out if find first matching rule.
-        for (HandoverRule rule : mHandoverRuleList) {
-            if (rule.mIsOnlyForRoaming && coverage != QnsConstants.COVERAGE_ROAM) continue;
-
-            if (rule.mSourceAccessNetworks.contains(srcAn)
-                    && rule.mTargetAccessNetworks.contains(destAn)) {
-                // if no capability rule specified, data network capability is considered matched.
-                // otherwise, any capabilities overlap is also considered matched.
-                if (rule.mNetworkCapabilities.isEmpty()
-                        || rule.mNetworkCapabilities.contains(netCapability)) {
-                    if (rule.mHandoverRuleType == HandoverRule.RULE_TYPE_DISALLOWED) {
-                        Log.d(mLogTag, "isHandoverAllowedByPolicy:Not allowed by policy " + rule);
-                        return false;
-                    } else {
-                        Log.d(mLogTag, "isHandoverAllowedByPolicy: allowed by policy " + rule);
-                        return true;
-                    }
-                }
-            }
-        }
-
-        Log.d(mLogTag, "isHandoverAllowedByPolicy: Did not find matching rule. ");
-        // Disallow handover for non-IMS network capability anyway if no rule is found.
-        if (netCapability != NetworkCapabilities.NET_CAPABILITY_IMS) return false;
-
-        // Allow handover for IMS network capability anyway if no rule is found.
-        return true;
-    }
-
-    /**
-     * This method returns if Service Barring Check for HO decision is Supported
-     *
-     * @return : boolean (True/False)
-     */
-    boolean isServiceBarringCheckSupported() {
-
-        return mIsServiceBarringCheckSupport;
-    }
-
-    /**
-     * This method returns if the Guard timer (Ping Pong) hysteresis is preference specific
-     *
-     * @return : Based on Carrier Config Settings based on operator requirement possible values:
-     * True / False
-     */
-    boolean isGuardTimerHysteresisOnPrefSupported() {
-
-        return mIsHoGuardOnPreferenceSupport;
-    }
-
-    /**
-     * This method returns if the network(HOME or ROAM) requires handover guard timer.
-     *
-     * @return : Based on Carrier Config Settings based on operator requirement possible values:
-     * True / False
-     */
-    boolean isHysteresisTimerEnabled(int coverage) {
-        if (mNetworkEnableHysteresisTimer == QnsConstants.COVERAGE_BOTH
-                || mNetworkEnableHysteresisTimer == coverage) {
-            return true;
-        }
-        return false;
-    }
-
-    /**
-     * Get carrier config for the KEY_ROAM_TRANSPORT_TYPE_SELECTION_WITHOUT_SIGNAL_STRENGTH_BOOL if
-     * true, It ignores all thresholds needed to only refer to availability.
-     *
-     * @return true for key value is true. False for otherwise.
-     */
-    boolean isTransportTypeSelWithoutSSInRoamSupported() {
-
-        return mAnspSupportConfigArray[0];
-    }
-
-    /*
-     * get carrierconfig for KEY_PREFER_CURRENT_TRANSPORT_TYPE_IN_VOICE_CALL
-     * true: Prefer current transport type during voice call.
-     *
-     * @return true for key value is true. False for otherwise.
-     */
-    boolean isCurrentTransportTypeInVoiceCallSupported() {
-
-        return mAnspSupportConfigArray[1];
-    }
-
-    /**
-     * Get carrierconfig for KEY_POLICY_OVERRIDE_CELL_PREF_TO_IMS_PREF_HOME_BOOL
-     * true: Use IMS Preferred when WFC Mode is Cellular Preferred at Home Network.
-     *
-     * @return true for key value is true. False for otherwise.
-     */
-    boolean isOverrideImsPreferenceSupported() {
-        return mAnspSupportConfigArray[2];
-    }
-
-    /**
-     * The method is to return if choose WFC prferred transport in both WWAN and WLAN are bad
-     * conditions. It is controlled by
-     * KEY_CHOOSE_WFC_PREFERRED_TRANSPORT_IN_BOTH_BAD_CONDITION_INT_ARRAY.
-     *
-     * @return : boolean (True/False)
-     */
-    boolean isChooseWfcPreferredTransportInBothBadCondition(int wfcMode) {
-        if (mIsWfcPreferredTransportRequired == null
-                || mIsWfcPreferredTransportRequired.length == 0) {
-            return false;
-        }
-        for (int i : mIsWfcPreferredTransportRequired) {
-            if (wfcMode == i) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * This method returns whether the rove out(to Cellular) policy includes a Wi-Fi bad condition
-     * at handover guarding time.
-     *
-     * @return : Based on Carrier Config Settings based on operator requirement possible values:
-     * True / False
-     */
-    boolean isRoveOutWithWiFiLowQualityAtGuardingTime() {
-
-        return mIsRoveOutWifiBadGuardTimerConditionsSupported;
-    }
-
-    /**
-     * This method returns the waiting time for the preferred transport type at power up.
-     *
-     * @return : A timer in millisecond
-     */
-    int getWaitingTimerForPreferredTransportOnPowerOn(int transportType) {
-        switch (transportType) {
-            case TRANSPORT_TYPE_WWAN:
-                return mWaitingTimerForPreferredTransport[0];
-            case TRANSPORT_TYPE_WLAN:
-                return mWaitingTimerForPreferredTransport[1];
-            default:
-                Log.d(mLogTag, "Invalid transport type, return the default timer.");
-                return QnsConstants.KEY_DEFAULT_VALUE;
-        }
-    }
-
-    /**
-     * This method returns the Transport type Preference on Power On.
-     *
-     * @return : Based on Carrier Config Settings Possible values (3000msec:Default or operator
-     * customisation.
-     */
-    int getWIFIRssiBackHaulTimer() {
-        return mWifiThresBackHaulTimer;
-    }
-
-    /**
-     * This method returns Cellular SS Backhaul Timer.
-     *
-     * @return : Based on Carrier Config Settings based on operator requirement possible values ( 0
-     * : Invalid or 320ms)
-     */
-    int getCellularSSBackHaulTimer() {
-
-        return mCellularThresBackHaulTimer;
-    }
-
-    /**
-     * This method returns IWLAN HO Avoid time due to Low RTP Quality Backhaul Timer.
-     *
-     * @return : Based on Carrier Config Settings based on operator requirement possible values ( 0
-     * : or operator requirement)
-     */
-    int getHoRestrictedTimeOnLowRTPQuality(
-            @AccessNetworkConstants.RadioAccessNetworkType int accessNetwork) {
-
-        if (accessNetwork == TRANSPORT_TYPE_WLAN) {
-            return mHoRestrictTimeOnRtpQuality[0];
-        } else if (accessNetwork == TRANSPORT_TYPE_WWAN) {
-            return mHoRestrictTimeOnRtpQuality[1];
-        } else {
-            return QnsConstants.KEY_DEFAULT_VALUE;
-        }
-    }
-
-    /**
-     * This method returns QNS preferred transport type for network capabilities / Services
-     *
-     * @return : Based on Carrier Config Settings based on operator requirement possible values:
-     * TRANSPORT_TYPE_ALLOWED_WWAN = 0 TRANSPORT_TYPE_ALLOWED_IWLAN = 1
-     * TRANSPORT_TYPE_ALLOWED_BOTH = 2
-     */
-    int getQnsSupportedTransportType(int netCapability) {
-        if (netCapability == NetworkCapabilities.NET_CAPABILITY_IMS) {
-            return mQnsImsTransportType;
-        } else if (netCapability == NetworkCapabilities.NET_CAPABILITY_EIMS) {
-            return mQnsSosTransportType;
-        } else if (netCapability == NetworkCapabilities.NET_CAPABILITY_MMS) {
-            return mQnsMmsTransportType;
-        } else if (netCapability == NetworkCapabilities.NET_CAPABILITY_XCAP) {
-            HashSet<Integer> supportedTransportType = new HashSet<>();
-            if (mQnsXcapSupportedAccessNetworkTypes != null) {
-                Arrays.stream(mQnsXcapSupportedAccessNetworkTypes)
-                        .forEach(accessNetwork -> supportedTransportType.add(
-                                QnsUtils.getTransportTypeFromAccessNetwork(accessNetwork)));
-            }
-            if (supportedTransportType.contains(AccessNetworkConstants.TRANSPORT_TYPE_WLAN)) {
-                if (supportedTransportType.contains(AccessNetworkConstants.TRANSPORT_TYPE_WWAN)) {
-                    return QnsConstants.TRANSPORT_TYPE_ALLOWED_BOTH;
-                }
-                return QnsConstants.TRANSPORT_TYPE_ALLOWED_IWLAN;
-            }
-            return QnsConstants.TRANSPORT_TYPE_ALLOWED_WWAN;
-        } else if (netCapability == NetworkCapabilities.NET_CAPABILITY_CBS) {
-            return mQnsCbsTransportType;
-        }
-        return QnsConstants.INVALID_ID;
-    }
-
-    /**
-     * This method returns the hysteresis timer when handover from WLAN to WWAN.
-     *
-     * @return : the hysteresis timer
-     */
-    int getWwanHysteresisTimer(int netCapability, @QnsConstants.QnsCallType int callType) {
-        if (mQnsProvisioningInfo.hasItem(ProvisioningManager.KEY_LTE_EPDG_TIMER_SEC)) {
-            return mQnsProvisioningInfo.getIntegerItem(ProvisioningManager.KEY_LTE_EPDG_TIMER_SEC);
-        }
-        switch (netCapability) {
-            case NetworkCapabilities.NET_CAPABILITY_IMS:
-            case NetworkCapabilities.NET_CAPABILITY_EIMS:
-                if (callType == QnsConstants.CALL_TYPE_IDLE) {
-                    return mWwanHysteresisTimer[0];
-                } else if (callType == QnsConstants.CALL_TYPE_VOICE) {
-                    return mWwanHysteresisTimer[1];
-                } else if (callType == QnsConstants.CALL_TYPE_VIDEO) {
-                    return mWwanHysteresisTimer[2];
-                } else {
-                    return QnsConstants.KEY_DEFAULT_VALUE;
-                }
-            case NetworkCapabilities.NET_CAPABILITY_MMS:
-            case NetworkCapabilities.NET_CAPABILITY_XCAP:
-            case NetworkCapabilities.NET_CAPABILITY_CBS:
-                if (callType == QnsConstants.CALL_TYPE_IDLE) {
-                    return mNonImsWwanHysteresisTimer[0];
-                } else {
-                    return mNonImsWwanHysteresisTimer[1];
-                }
-            default:
-                return QnsConstants.KEY_DEFAULT_VALUE;
-        }
-    }
-
-    /**
-     * This method returns the hysteresis timer when handover from WWAN to WLAN.
-     *
-     * @return : the hysteresis timer
-     */
-    int getWlanHysteresisTimer(int netCapability, @QnsConstants.QnsCallType int callType) {
-        if (mQnsProvisioningInfo.hasItem(ProvisioningManager.KEY_WIFI_EPDG_TIMER_SEC)) {
-            return mQnsProvisioningInfo.getIntegerItem(ProvisioningManager.KEY_WIFI_EPDG_TIMER_SEC);
-        }
-        switch (netCapability) {
-            case NetworkCapabilities.NET_CAPABILITY_IMS:
-            case NetworkCapabilities.NET_CAPABILITY_EIMS:
-                if (callType == QnsConstants.CALL_TYPE_IDLE) {
-                    return mWlanHysteresisTimer[0];
-                } else if (callType == QnsConstants.CALL_TYPE_VOICE) {
-                    return mWlanHysteresisTimer[1];
-                } else if (callType == QnsConstants.CALL_TYPE_VIDEO) {
-                    return mWlanHysteresisTimer[2];
-                } else {
-                    return QnsConstants.KEY_DEFAULT_VALUE;
-                }
-            case NetworkCapabilities.NET_CAPABILITY_MMS:
-            case NetworkCapabilities.NET_CAPABILITY_XCAP:
-            case NetworkCapabilities.NET_CAPABILITY_CBS:
-                if (callType == QnsConstants.CALL_TYPE_IDLE) {
-                    return mNonImsWlanHysteresisTimer[0];
-                } else {
-                    return mNonImsWlanHysteresisTimer[1];
-                }
-            default:
-                return QnsConstants.KEY_DEFAULT_VALUE;
-        }
-    }
-
-    /**
-     * This method returns the timer millis for the minimum guarding timer.
-     *
-     * @return the minimum guarding timer in millis. applies when handover guarding is disabled or
-     * there is no guarding time.
-     */
-    int getMinimumHandoverGuardingTimer() {
-        int timer = mMinimumHandoverGuardingTimer;
-        if (timer <= 0) {
-            return 0;
-        }
-        if (timer >= QnsConstants.CONFIG_DEFAULT_MIN_HANDOVER_GUARDING_TIMER_LIMIT) {
-            timer = QnsConstants.CONFIG_DEFAULT_MIN_HANDOVER_GUARDING_TIMER_LIMIT;
-        }
-        return timer;
-    }
-
-    /**
-     * This method returns the Threshold gap offset based on which threshold to be registered during
-     * Guard timer Running / Expired conditions from Evaluator
-     *
-     * @return : Based on Carrier Config Settings & operator requirement Default Value : 0 gap
-     * offset (Means different threshold for Guard timer conditions not enabled)
-     */
-    int getThresholdGapWithGuardTimer(
-            @AccessNetworkConstants.RadioAccessNetworkType int accessNetwork, int measType) {
-
-        return getValueForMeasurementType(
-                accessNetwork, measType, mRoveInGuardTimerConditionThresholdGaps);
-
-    }
-
-    /**
-     *  This method returns hysteresis Dbm level for ran and measurement type configured.
-     *
-     * @return : Based on Carrier Config Settings & operator requirement Default Value.
-     * Note: If configured value set is less than zero or not set,
-     * {@link QnsConstants#KEY_DEFAULT_VALUE}
-     */
-    public int getWwanHysteresisDbLevel(
-            @AccessNetworkConstants.RadioAccessNetworkType int accessNetwork, int measType) {
-
-        int hysteresisDb = getValueForMeasurementType(
-                accessNetwork, measType, mAccessNetworkMeasurementHysteresisDb);
-        return hysteresisDb >= 0 ? hysteresisDb : QnsConstants.KEY_DEFAULT_VALUE;
-    }
-
-    private int getValueForMeasurementType(
-            @AccessNetworkConstants.RadioAccessNetworkType int accessNetwork, int measType,
-            String [] measurementValues) {
-
-        if (measurementValues == null) {
-            return QnsConstants.KEY_DEFAULT_VALUE;
-        }
-
-        for (String check_offset : measurementValues) {
-            if (check_offset == null || check_offset.isEmpty()) continue;
-            String[] value = check_offset.split(":");
-            String access_network = sAccessNetworkMap.get(accessNetwork);
-            String measurement_Type = sMeasTypeMap.get(measType);
-            try {
-                if (value.length == 3 && value[0].equalsIgnoreCase(access_network)
-                        && value[1].equalsIgnoreCase(measurement_Type)) {
-                    return Integer.parseInt(value[2]);
-                }
-            } catch (Exception e) {
-                e.printStackTrace();
-            }
-        }
-        return QnsConstants.KEY_DEFAULT_VALUE;
-    }
-
-    boolean hasThresholdGapWithGuardTimer() {
-        if (mRoveInGuardTimerConditionThresholdGaps == null) {
-            return false;
-        }
-        return true;
-    }
-
-    /**
-     * This method returns Access Network Selection Policy based on network capability
-     *
-     * @param targetTransportType : WWAN/WLAN
-     * @return : Target transport mapped to string
-     */
-    static String transportNetworkToString(int targetTransportType) {
-        switch (targetTransportType) {
-            case TRANSPORT_TYPE_WWAN:
-                return "CELLULAR";
-            case TRANSPORT_TYPE_WLAN:
-                return "WIFI";
-        }
-        return "";
-    }
-
-    /**
-     * Finds and returns a threshold config that meets the given parameter condition.
-     *
-     * @param accessNetwork   (EUTRAN/UTRAN/NGRAN/GERAN/IWLAN)
-     * @param callType        (IDLE/VOICE/VIDEO)
-     * @param measurementType (RSRP/RSRQ/RSSNR/SSRSP/SSRSQ/RSCP/RSSI)
-     * @return QnsConfigArray for good, bad and worst thresholds. If the value does not exist or is
-     * not supported, it is filled with invalid (0x0000FFFF). Note, for the wifi case, the worst
-     * in thresholds will be invalid. INVALID VALUE, if not found item or exceptions.
-     */
-    QnsConfigArray getThreshold(
-            @AccessNetworkConstants.RadioAccessNetworkType int accessNetwork,
-            int callType,
-            int measurementType) {
-        int[] thresholdList = new int[] {0x0000FFFF, 0x0000FFFF, 0x0000FFFF};
-        if (accessNetwork == AccessNetworkConstants.AccessNetworkType.UNKNOWN
-                || measurementType == SIGNAL_MEASUREMENT_TYPE_UNKNOWN) {
-            return null;
-        }
-
-        String access_network = sAccessNetworkMap.get(accessNetwork);
-        String measurement_Type = sMeasTypeMap.get(measurementType);
-        String call_Type = sCallTypeMap.get(callType);
-
-        if (access_network != null && measurement_Type != null && call_Type != null) {
-            String key =
-                    "qns."
-                            + call_Type
-                            + "_"
-                            + access_network
-                            + "_"
-                            + measurement_Type
-                            + "_"
-                            + "int_array";
-
-            thresholdList = mAnspConfigMgr.getAnspCarrierThreshold(key);
-
-            if (thresholdList != null && thresholdList.length > 1) {
-                if (AccessNetworkConstants.AccessNetworkType.IWLAN == accessNetwork
-                        || thresholdList.length == 2) {
-                    return new QnsConfigArray(thresholdList[0], thresholdList[1]);
-                } else {
-                    return new QnsConfigArray(thresholdList[0], thresholdList[1], thresholdList[2]);
-                }
-            } else {
-                thresholdList = new int[] {0x0000FFFF, 0x0000FFFF, 0x0000FFFF};
-            }
-        }
-        return new QnsConfigArray(thresholdList[0], thresholdList[1], thresholdList[2]);
-    }
-
-    QnsConfigArray getThresholdByPref(
-            int accessNetwork, int callType, int measurementType, int preference) {
-        if (accessNetwork == AccessNetworkConstants.AccessNetworkType.UNKNOWN
-                || measurementType == SIGNAL_MEASUREMENT_TYPE_UNKNOWN) {
-            return null;
-        }
-
-        int[] thresholdList = null;
-        String access_network = sAccessNetworkMap.get(accessNetwork);
-        String measurement_Type = sMeasTypeMap.get(measurementType);
-        String call_Type = sCallTypeMap.get(callType);
-
-        if (access_network == null || measurement_Type == null || call_Type == null) {
-            return new QnsConfigArray(0x0000FFFF, 0x0000FFFF, 0x0000FFFF);
-        }
-
-        if (accessNetwork == AccessNetworkConstants.AccessNetworkType.IWLAN
-                && preference == QnsConstants.WIFI_PREF) {
-            String overrideKey =
-                    "qns.override_wifi_pref_"
-                            + call_Type
-                            + "_"
-                            + access_network
-                            + "_"
-                            + measurement_Type
-                            + "_int_array";
-            thresholdList = mAnspConfigMgr.getAnspCarrierThreshold(overrideKey);
-        }
-
-        if (thresholdList == null || thresholdList.length < 2) {
-            String key =
-                    "qns."
-                            + call_Type
-                            + "_"
-                            + access_network
-                            + "_"
-                            + measurement_Type
-                            + "_int_array";
-            thresholdList = mAnspConfigMgr.getAnspCarrierThreshold(key);
-        }
-        if (thresholdList == null || thresholdList.length < 2) {
-            return new QnsConfigArray(0x0000FFFF, 0x0000FFFF, 0x0000FFFF);
-        }
-
-        if (AccessNetworkConstants.AccessNetworkType.IWLAN == accessNetwork
-                || thresholdList.length == 2) {
-            QnsConfigArray qnsConfigArray = new QnsConfigArray(thresholdList[0], thresholdList[1]);
-            return applyProvisioningInfo(qnsConfigArray, accessNetwork, measurementType, callType);
-        }
-
-        QnsConfigArray qnsConfigArray =
-                new QnsConfigArray(thresholdList[0], thresholdList[1], thresholdList[2]);
-        return applyProvisioningInfo(qnsConfigArray, accessNetwork, measurementType, callType);
-    }
-
-    QnsConfigArray getWifiRssiThresholdWithoutCellular(int callType) {
-        int[] thresholdList;
-        String call_Type = sCallTypeMap.get(callType);
-
-        if (call_Type == null) {
-            return new QnsConfigArray(0x0000FFFF, 0x0000FFFF, 0x0000FFFF);
-        }
-
-        String key = "qns." + call_Type + "_wifi_rssi_without_cellular_int_array";
-        thresholdList = mAnspConfigMgr.getAnspCarrierThreshold(key);
-
-        if (thresholdList == null || thresholdList.length < 2) {
-            return new QnsConfigArray(0x0000FFFF, 0x0000FFFF, 0x0000FFFF);
-        }
-
-        return new QnsConfigArray(thresholdList[0], thresholdList[1]);
-    }
-
-    /**
-     * Finds and returns a policy config that meets the given parameter condition.
-     *
-     * @param direction    (ROVE_IN / ROVE_OUT)
-     * @param preCondition (Types of CALL, PREFERENCE, COVERAGE and so on)
-     * @return QnsConfigArray for good, bad and worst policy. If the value does not exist or is not
-     * supported, it is filled with invalid. (0x0000FFFF). Note, for the wifi case, the worst in
-     * thresholds will be invalid. null, if not found item or exceptions.
-     */
-    String[] getPolicy(
-            @QnsConstants.RoveDirection int direction,
-            AccessNetworkSelectionPolicy.PreCondition preCondition) {
-
-        String key =
-                "qns.condition_"
-                        + QnsConstants.directionToString(direction).toLowerCase()
-                        + "_"
-                        + QnsConstants.callTypeToString(preCondition.getCallType()).toLowerCase()
-                        + "_"
-                        + QnsConstants.preferenceToString(preCondition.getPreference())
-                                .toLowerCase()
-                        + "_"
-                        + QnsConstants.coverageToString(preCondition.getCoverage()).toLowerCase()
-                        + "_";
-
-        if (preCondition instanceof AccessNetworkSelectionPolicy.GuardingPreCondition) {
-            AccessNetworkSelectionPolicy.GuardingPreCondition guardingCondition =
-                    (AccessNetworkSelectionPolicy.GuardingPreCondition) preCondition;
-            String guardingKey =
-                    key
-                            + QnsConstants.guardingToString(guardingCondition.getGuarding())
-                                    .toLowerCase()
-                            + "_string_array";
-            String[] guardingPolicy = mAnspConfigMgr.getAnspCarrierPolicy(guardingKey);
-            if (guardingPolicy != null) {
-                return guardingPolicy;
-            }
-        }
-        key = key + "string_array";
-        return mAnspConfigMgr.getAnspCarrierPolicy(key);
-    }
-
-    /**
-     * This method returns RTP Metrics data of Carrier for HO decision making
-     *
-     * @return config of RTP metrics. refer {@link RtpMetricsConfig}
-     */
-    @VisibleForTesting
-    RtpMetricsConfig getRTPMetricsData() {
-
-        return new RtpMetricsConfig(
-                mRTPMetricsData[0], mRTPMetricsData[1], mRTPMetricsData[2], mRTPMetricsData[3]);
-    }
-
-    /**
-     * This retrieves fallback timer to WWAN with the reason of IMS unregistered.
-     *
-     * @return fallback time in millis.
-     */
-    @VisibleForTesting
-    int getFallbackTimeImsUnregistered(int reason, int preferMode) {
-        Log.d(
-                mLogTag,
-                "getFallbackTimeImsUnregistered reason:" + reason + " prefMode:" + preferMode);
-        for (FallbackRule rule : mFallbackWwanRuleWithImsUnregistered) {
-            Log.d(mLogTag, rule.toString());
-            if (preferMode != QnsConstants.WIFI_ONLY
-                    && (rule.mPreferenceMode == -1 || rule.mPreferenceMode == preferMode)) {
-                int time = rule.getFallBackTime(reason);
-                if (time > 0) {
-                    Log.d(mLogTag, "getFallbackTimeImsUnregistered fallbackTime:" + time);
-                    return time;
-                }
-            }
-        }
-        Log.d(mLogTag, "getFallbackTimeImsUnregistered fallbackTime:" + 0);
-        return 0;
-    }
-
-    /**
-     * This retrieves fallback timer to WWAN with the reason of IMS HO register fail.
-     *
-     * @return fallback time in millis.
-     */
-    @VisibleForTesting
-    int getFallbackTimeImsHoRegisterFailed(int reason, int preferMode) {
-        Log.d(
-                mLogTag,
-                "getFallbackTimeImsHoRegisterFailed reason:" + reason + " prefMode:" + preferMode);
-        for (FallbackRule rule : mFallbackWwanRuleWithImsHoRegisterFail) {
-            if (preferMode != QnsConstants.WIFI_ONLY
-                    && (rule.mPreferenceMode == -1 || rule.mPreferenceMode == preferMode)) {
-                Log.d(mLogTag, rule.toString());
-                int time = rule.getFallBackTime(reason);
-                Log.d(mLogTag, "getFallbackTimeImsHoRegisterFailed fallback time: " + time);
-                if (time > 0) return time;
-            }
-        }
-        Log.d(mLogTag, "getFallbackTimeImsHoRegisterFailed fallback time: " + 0);
-        return 0;
-    }
-
-    /**
-     * This method returns Access Network Selection Policy Support configurations with boolean array
-     * list type
-     *
-     */
-    void loadAnspCarrierSupportConfigs(
-            PersistableBundle bundleCarrier, PersistableBundle bundleAsset) {
-        int i = 0;
-        String[] anspConfigs = {
-            KEY_ROAM_TRANSPORT_TYPE_SELECTION_WITHOUT_SIGNAL_STRENGTH_BOOL,
-            KEY_PREFER_CURRENT_TRANSPORT_TYPE_IN_VOICE_CALL_BOOL,
-            KEY_POLICY_OVERRIDE_CELL_PREF_TO_IMS_PREF_HOME_BOOL
-        };
-
-        for (String key : anspConfigs) {
-            mAnspSupportConfigArray[i] = getConfig(bundleCarrier, bundleAsset, key);
-            i += 1;
-        }
-
-        mIsWfcPreferredTransportRequired =
-                getConfig(
-                        bundleCarrier,
-                        bundleAsset,
-                        KEY_CHOOSE_WFC_PREFERRED_TRANSPORT_IN_BOTH_BAD_CONDITION_INT_ARRAY);
-    }
-
-    /**
-     * This method gives the network capabilities supported based on
-     * KEY_QNS_<NetworkCapability></NetworkCapability>_TRANSPORT_TYPE_INT
-     *
-     * @return : Supported network capabilities
-     */
-    List<Integer> getQnsSupportedNetCapabilities() {
-        List<Integer> netCapabilities = new ArrayList<>();
-        if (mQnsImsTransportType == QnsConstants.TRANSPORT_TYPE_ALLOWED_IWLAN
-                || mQnsImsTransportType == QnsConstants.TRANSPORT_TYPE_ALLOWED_BOTH) {
-            netCapabilities.add(NetworkCapabilities.NET_CAPABILITY_IMS);
-        }
-        if (mQnsSosTransportType == QnsConstants.TRANSPORT_TYPE_ALLOWED_IWLAN
-                || mQnsSosTransportType == QnsConstants.TRANSPORT_TYPE_ALLOWED_BOTH) {
-            netCapabilities.add(NetworkCapabilities.NET_CAPABILITY_EIMS);
-        }
-        if (mQnsMmsTransportType == QnsConstants.TRANSPORT_TYPE_ALLOWED_IWLAN
-                || mQnsMmsTransportType == QnsConstants.TRANSPORT_TYPE_ALLOWED_BOTH) {
-            netCapabilities.add(NetworkCapabilities.NET_CAPABILITY_MMS);
-        }
-        if (mQnsXcapSupportedAccessNetworkTypes != null
-                && Arrays.stream(mQnsXcapSupportedAccessNetworkTypes)
-                        .anyMatch(accessNetwork -> QnsUtils.getTransportTypeFromAccessNetwork(
-                                accessNetwork) == AccessNetworkConstants.TRANSPORT_TYPE_WLAN)) {
-            netCapabilities.add(NetworkCapabilities.NET_CAPABILITY_XCAP);
-        }
-        if (mQnsCbsTransportType == QnsConstants.TRANSPORT_TYPE_ALLOWED_IWLAN
-                || mQnsCbsTransportType == QnsConstants.TRANSPORT_TYPE_ALLOWED_BOTH) {
-            netCapabilities.add(NetworkCapabilities.NET_CAPABILITY_CBS);
-        }
-        return netCapabilities;
-    }
-
-    private static final Map<Integer, String> sRatStringMatcher = Map.of(
-            AccessNetworkConstants.AccessNetworkType.EUTRAN, "LTE",
-            AccessNetworkConstants.AccessNetworkType.NGRAN, "NR",
-            AccessNetworkConstants.AccessNetworkType.UTRAN, "3G",
-            AccessNetworkConstants.AccessNetworkType.GERAN, "2G"
-    );
-
-    /**
-     * This method returns Allowed cellular RAT for IMS
-     *
-     * @param accessNetwork : (EUTRAN, NGRAN, UTRAN, GERAN)
-     * @param netCapability : (ims, sos, mms, xcap, cbs)
-     * @return : True or False based on configuration
-     */
-    boolean isAccessNetworkAllowed(int accessNetwork, int netCapability) {
-
-        switch (netCapability) {
-            case NetworkCapabilities.NET_CAPABILITY_EIMS:
-            case NetworkCapabilities.NET_CAPABILITY_IMS:
-                // cases to be enhanced for different key items when added
-                String ratName = sRatStringMatcher.get(accessNetwork);
-                if (mImsAllowedRats != null
-                        && ratName != null
-                        && Arrays.stream(mImsAllowedRats)
-                                .anyMatch(ratType -> TextUtils.equals(ratType, ratName))) {
-                    return true;
-                }
-                break;
-            case NetworkCapabilities.NET_CAPABILITY_XCAP:
-                return mQnsXcapSupportedAccessNetworkTypes != null
-                        && Arrays.stream(mQnsXcapSupportedAccessNetworkTypes)
-                                .anyMatch(xcapAccessNetwork -> accessNetwork == xcapAccessNetwork);
-            default:
-                return false;
-        }
-        return false;
-    }
-
-    /**
-     * This method returns max HO Back to IWLAN count value with Fallback reason to Rove Out
-     *
-     * @return : int array (Ex: -1,-1 or 1,2 or 3,1 etc... )
-     */
-    int getQnsMaxIwlanHoCountDuringCall() {
-
-        if (mAllowMaxIwlanHoCountOnReason[0] <= 0) {
-            mAllowMaxIwlanHoCountOnReason[0] = MAX_COUNT_INVALID;
-        }
-
-        return mAllowMaxIwlanHoCountOnReason[0];
-    }
-
-    /**
-     * This method returns Supported Fallback reason to Rove Out from IWLAN
-     *
-     * @return : int array (Ex: -1,-1 or 1,2 or 3,1 etc... )
-     */
-    int getQnsIwlanHoRestrictReason() {
-        if (mAllowMaxIwlanHoCountOnReason[1] <= 0) {
-            mAllowMaxIwlanHoCountOnReason[1] = FALLBACK_REASON_INVALID;
-        }
-        return mAllowMaxIwlanHoCountOnReason[1];
-    }
-
-    /**
-     * This method returns to allow enabled Wi-Fi calling based on exceptional cellular state, even
-     * when Wi-Fi calling is disabled.
-     *
-     * <p>Enable Wi-Fi calling If the call state is idle and the cellular network the UE is staying
-     * on does not allow ims pdn.
-     *
-     * @return : Based on Carrier Config Settings based on operator requirement possible values:
-     * True / False
-     */
-    boolean allowImsOverIwlanCellularLimitedCase() {
-        return mIsAllowImsOverIwlanCellularLimitedCase;
-    }
-
-    /**
-     * This method returns if Iwlan is not allowed when UE is in no WWAN coverage and the last
-     * stored country code is outside the home country.
-     *
-     * @return True if need to block Iwlan, otherwise false.
-     */
-    boolean blockIwlanInInternationalRoamWithoutWwan() {
-        return mIsBlockIwlanInInternationalRoamWithoutWwan;
-    }
-
-    /**
-     * This method returns if IPv6 only WiFi is allowed
-     *
-     * @return True if need to block IPv6 only WiFi, otherwise false.
-     */
-    boolean blockIpv6OnlyWifi() {
-        return mIsBlockIpv6OnlyWifi;
-    }
-
-    /**
-     * This method returns the wait timer in milliseconds that VoWiFi registration in VoWiFi
-     * activation process
-     */
-    int getVowifiRegistrationTimerForVowifiActivation() {
-        return mVowifiRegistrationTimerForVowifiActivation;
-    }
-
-    /**
-     * This method returns whether the IMS Registration state option is added when reporting a
-     * qualified Wi-Fi network for network capabilities other than ims.
-     *
-     * @return : Based on Carrier Config Settings based on operator requirement possible values:
-     * True / False
-     */
-    int getRatPreference(int netCapability) {
-        switch (netCapability) {
-            case NetworkCapabilities.NET_CAPABILITY_XCAP:
-                return mXcapRatPreference;
-            case NetworkCapabilities.NET_CAPABILITY_EIMS:
-                return mSosRatPreference;
-            case NetworkCapabilities.NET_CAPABILITY_MMS:
-                return mMmsRatPreference;
-            case NetworkCapabilities.NET_CAPABILITY_CBS:
-                return mCbsRatPreference;
-        }
-        return QnsConstants.RAT_PREFERENCE_DEFAULT;
-    }
-
-    /**
-     * This method returns the rtt check server address config as per operator requirement
-     *
-     * @return Based on carrier config settings of operator. By default, to be made empty to
-     * disable the feature.
-     */
-    String getWlanRttServerAddressConfig() {
-        String[] ping_address = getWlanRttPingConfigs();
-
-        if (ping_address != null && ping_address[0] != null && !ping_address[0].isEmpty()) {
-            return ping_address[0];
-        } else {
-            return null;
-        }
-    }
-
-    /**
-     * This method returns No of Pings, Intra Ping Interval, Size of the packet, RTT criteria RTT
-     * retry timer
-     *
-     * @return : Based on carrier config settings as per operator requirement
-     */
-    int[] getWlanRttOtherConfigs() {
-        int[] pingConfigs = new int[5];
-        String[] rtt_ping_config = getWlanRttPingConfigs();
-
-        if (rtt_ping_config != null && !rtt_ping_config[0].isEmpty()) {
-            for (int i = 1; i < 6; i++) {
-                if (rtt_ping_config[i] != null) {
-                    pingConfigs[i - 1] = Integer.parseInt(rtt_ping_config[i]);
-                }
-            }
-        }
-        return pingConfigs;
-    }
-
-    /**
-     * This method returns fallback Hysteresis timer on RTT Failure.
-     *
-     * @return : Based on carrier config settings as per operator requirement
-     */
-    int getWlanRttFallbackHystTimer() {
-        String[] rtt_hyst_fallback_timer = getWlanRttPingConfigs();
-
-        if (rtt_hyst_fallback_timer != null
-                && !rtt_hyst_fallback_timer[0].isEmpty()
-                && rtt_hyst_fallback_timer[6] != null) {
-            return Integer.parseInt(rtt_hyst_fallback_timer[6]);
-        } else {
-            return 0;
-        }
-    }
-
-    private String[] getWlanRttPingConfigs() {
-        if (mWlanRttBackhaulCheckConfigsOnPing == null) return null;
-
-        return mWlanRttBackhaulCheckConfigsOnPing.split(",");
-    }
-
-    /**
-     * If fallback for Initial connection failure for the network capability is met is supported ,
-     * this method provides information about the failure retry count or retry timer or both if
-     * supported until fallback to other transport.
-     *
-     * @param netCapability : (ims,sos,mms,xcap,cbs)
-     * @return :
-     * <NetworkCapability_SupportForFallback>:<retry_count>:<retry_timer>:<max_fallback_count>
-     */
-    int[] getInitialDataConnectionFallbackConfig(int netCapability) {
-
-        int[] fallbackConfigOnDataFail = new int[4];
-        String[] fallback_config = getFallbackConfigForNetCapability(netCapability);
-
-        if (fallback_config != null
-                && fallback_config[0] != null
-                && fallback_config[0].length() > 0) {
-            // netCapability Availability Status
-            fallbackConfigOnDataFail[0] = 1;
-
-            // Retry Count :  && fallback_config[1].length() > 0
-            if (fallback_config.length > 1
-                    && fallback_config[1] != null
-                    && !fallback_config[1].isEmpty()) {
-                fallbackConfigOnDataFail[1] = Integer.parseInt(fallback_config[1]);
-            }
-
-            // Retry timer
-            if (fallback_config.length > 2
-                    && fallback_config[2] != null
-                    && !fallback_config[2].isEmpty()) {
-                fallbackConfigOnDataFail[2] = Integer.parseInt(fallback_config[2]);
-            }
-
-            // Max fallback count
-            if (fallback_config.length > 4
-                    && fallback_config[4] != null
-                    && !fallback_config[4].isEmpty()) {
-                fallbackConfigOnDataFail[3] = Integer.parseInt(fallback_config[4]);
-            }
-        }
-        return fallbackConfigOnDataFail;
-    }
-
-    /**
-     * This method returns the fall back timer to be starting the restriction , for no. of retries
-     * when met with the pdn fail fallback causes
-     *
-     * @param netCapability : (ims,sos,mms,xcap,cbs)
-     * @return : Fallback Guard timer to be set on starting the fallback restrict @ RestrictManager
-     */
-    int getFallbackGuardTimerOnInitialConnectionFail(int netCapability) {
-        String[] fallback_guard_timer = getFallbackConfigForNetCapability(netCapability);
-
-        if (fallback_guard_timer != null
-                && fallback_guard_timer[0] != null
-                && fallback_guard_timer[0].length() > 0
-                && ((fallback_guard_timer.length > 1
-                                && fallback_guard_timer[1] != null
-                                && !fallback_guard_timer[1].isEmpty())
-                        || (fallback_guard_timer.length > 2
-                                && fallback_guard_timer[2] != null
-                                && !fallback_guard_timer[2].isEmpty()))
-                && (fallback_guard_timer.length > 3
-                        && fallback_guard_timer[3] != null
-                        && !fallback_guard_timer[3].isEmpty())) {
-            return Integer.parseInt(fallback_guard_timer[3]);
-        } else {
-            return 0;
-        }
-    }
-
-    /**
-     * To support find the right Initial Pdn connection failure fallback config based on network
-     * capability
-     */
-    private String[] getFallbackConfigForNetCapability(int netCapability) {
-        if (mFallbackOnInitialConnectionFailure != null
-                && mFallbackOnInitialConnectionFailure.length > 0) {
-            String netCapabilityName = QnsUtils.getNameOfNetCapability(netCapability);
-            for (String config : mFallbackOnInitialConnectionFailure) {
-                Log.d(mLogTag, "Fallback On Initial Failure enabled for " + config);
-                if (config.contains(netCapabilityName)) {
-                    return config.split(":");
-                }
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Get the Sip Dialog Session policy when the Sip Dialog State is active. This Sip Dialog
-     * Session policy is applied when there is no calling in the subscription, and when the device
-     * is in a calling state, the calling policy is used first.
-     *
-     * @return 0: {@code QnsConstants#SIP_DIALOG_SESSION_POLICY_NONE} not Applied. The default value
-     * for this key. 1: {@code QnsConstants#SIP_DIALOG_SESSION_POLICY_FOLLOW_VOICE_CALL} apply voice
-     * call policy. 2: {@code QnsConstants#SIP_DIALOG_SESSION_POLICY_FOLLOW_VIDEO_CALL}  apply video
-     * call policy.
-     */
-    @QnsConstants.QnsSipDialogSessionPolicy int getSipDialogSessionPolicy() {
-        return mSipDialogSessionPolicy;
-    }
-
-    static class QnsConfigArray {
-
-        /*
-         * static invalid
-         */
-        static final int INVALID = 0x0000FFFF;
-        /*
-         * Thresholds, A signal value of good strength to enter.
-         */
-        int mGood = INVALID;
-        /*
-         * Thresholds, A signal value of bad strength to leave.
-         */
-        int mBad = INVALID;
-        /*
-         * Thresholds, A signal value of worst strength to enter.
-         * The worst strength is only applicable for cellular.
-         */
-        int mWorst = INVALID;
-
-        QnsConfigArray(int good, int bad, int worst) {
-            set(good, bad, worst);
-        }
-
-        QnsConfigArray(int good, int bad) {
-            set(good, bad, INVALID);
-        }
-
-        void set(int good, int bad, int worst) {
-            mGood = good;
-            mBad = bad;
-            mWorst = worst;
-        }
-
-        @Override
-        public String toString() {
-            return "QnsConfigArray{"
-                    + "Good="
-                    + mGood
-                    + ", Bad="
-                    + mBad
-                    + ", Worst="
-                    + mWorst
-                    + '}';
-        }
-    }
-
-    @VisibleForTesting
-    static class RtpMetricsConfig {
-        /** Maximum jitter */
-        final int mJitter;
-
-        /** RTP packet loss rate in percentage */
-        final int mPktLossRate;
-
-        /** Time interval(milliseconds) of RTP packet loss rate */
-        final int mPktLossTime;
-
-        /** No RTP interval in milliseconds */
-        final int mNoRtpInterval;
-
-        RtpMetricsConfig(int jitter, int pktLossRate, int pktLossTime, int noRtpInterval) {
-            this.mJitter = jitter;
-            this.mPktLossRate = pktLossRate;
-            this.mPktLossTime = pktLossTime;
-            this.mNoRtpInterval = noRtpInterval;
-        }
-
-        @Override
-        public String toString() {
-            return "RtpMetricsConfig{"
-                    + "mJitter="
-                    + mJitter
-                    + ", mPktLossRate="
-                    + mPktLossRate
-                    + ", mPktLossTime="
-                    + mPktLossTime
-                    + ", mNoRtpInterval="
-                    + mNoRtpInterval
-                    + '}';
-        }
-    }
-
-    @VisibleForTesting
-    QnsCarrierAnspSupportConfig getQnsCarrierAnspSupportConfig() {
-        return mAnspConfigMgr;
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsComponents.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsComponents.java
deleted file mode 100644
index 0471ea8..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsComponents.java
+++ /dev/null
@@ -1,320 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import android.content.Context;
-import android.util.Log;
-import android.util.SparseArray;
-
-import com.android.internal.annotations.VisibleForTesting;
-
-import java.io.PrintWriter;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * QnsComponents stores all the components used in QNS. It maintains the lifecycle of QNS classes.
- * All QNS components are initialed at construction of this class.
- */
-class QnsComponents {
-
-    private final String mLogTag = QnsComponents.class.getSimpleName();
-    private final Context mContext;
-    private final SparseArray<CellularNetworkStatusTracker> mCellularNetworkStatusTrackers;
-    private final SparseArray<CellularQualityMonitor> mCellularQualityMonitors;
-    private final SparseArray<QnsImsManager> mQnsImsManagers;
-    private final SparseArray<QnsCarrierConfigManager> mQnsCarrierConfigManagers;
-    private final SparseArray<QnsEventDispatcher> mQnsEventDispatchers;
-    private final SparseArray<QnsProvisioningListener> mQnsProvisioningListeners;
-    private final SparseArray<QnsTelephonyListener> mQnsTelephonyListeners;
-    private final SparseArray<QnsCallStatusTracker> mQnsCallStatusTracker;
-    private final SparseArray<WifiBackhaulMonitor> mWifiBackhaulMonitors;
-    private final List<Integer> mSlotIds;
-    private IwlanNetworkStatusTracker mIwlanNetworkStatusTracker;
-    private QnsTimer mQnsTimer;
-    private WifiQualityMonitor mWifiQualityMonitor;
-    private QnsMetrics mQnsMetrics;
-
-    /** Constructor to instantiate QnsComponents class. */
-    QnsComponents(Context context) {
-        mContext = context;
-        mCellularNetworkStatusTrackers = new SparseArray<>();
-        mCellularQualityMonitors = new SparseArray<>();
-        mQnsImsManagers = new SparseArray<>();
-        mQnsCarrierConfigManagers = new SparseArray<>();
-        mQnsEventDispatchers = new SparseArray<>();
-        mQnsProvisioningListeners = new SparseArray<>();
-        mQnsTelephonyListeners = new SparseArray<>();
-        mQnsCallStatusTracker = new SparseArray<>();
-        mWifiBackhaulMonitors = new SparseArray<>();
-        mSlotIds = new ArrayList<>();
-    }
-
-    /** It initialises all the QNS components for given slotId */
-    synchronized void createQnsComponents(int slotId) {
-        mSlotIds.add(slotId);
-        mQnsTelephonyListeners.put(slotId, new QnsTelephonyListener(mContext, slotId));
-        mQnsImsManagers.put(slotId, new QnsImsManager(mContext, slotId));
-        mCellularNetworkStatusTrackers.put(
-                slotId,
-                new CellularNetworkStatusTracker(mQnsTelephonyListeners.get(slotId), slotId));
-        mQnsProvisioningListeners.put(
-                slotId, new QnsProvisioningListener(mContext, mQnsImsManagers.get(slotId), slotId));
-        mQnsEventDispatchers.put(
-                slotId,
-                new QnsEventDispatcher(
-                        mContext,
-                        mQnsProvisioningListeners.get(slotId),
-                        mQnsImsManagers.get(slotId),
-                        slotId));
-        mQnsCarrierConfigManagers.put(
-                slotId,
-                new QnsCarrierConfigManager(mContext, mQnsEventDispatchers.get(slotId), slotId));
-        mCellularQualityMonitors.put(
-                slotId,
-                new CellularQualityMonitor(mContext,
-                        mQnsCarrierConfigManagers.get(slotId),
-                        mQnsTelephonyListeners.get(slotId),
-                        slotId));
-        if (mQnsTimer == null) {
-            mQnsTimer = new QnsTimer(mContext);
-        }
-        mQnsCallStatusTracker.put(
-                slotId,
-                new QnsCallStatusTracker(
-                        mQnsTelephonyListeners.get(slotId),
-                        mQnsCarrierConfigManagers.get(slotId),
-                        mQnsTimer,
-                        slotId));
-        mWifiBackhaulMonitors.put(
-                slotId,
-                new WifiBackhaulMonitor(
-                        mContext,
-                        mQnsCarrierConfigManagers.get(slotId),
-                        mQnsImsManagers.get(slotId),
-                        mQnsTimer,
-                        slotId));
-        if (mWifiQualityMonitor == null) {
-            mWifiQualityMonitor = new WifiQualityMonitor(mContext, mQnsTimer);
-        }
-        if (mIwlanNetworkStatusTracker == null) {
-            mIwlanNetworkStatusTracker = new IwlanNetworkStatusTracker(mContext);
-        }
-        mIwlanNetworkStatusTracker.initBySlotIndex(
-                mQnsCarrierConfigManagers.get(slotId),
-                mQnsEventDispatchers.get(slotId),
-                mQnsImsManagers.get(slotId),
-                mQnsTelephonyListeners.get(slotId),
-                slotId);
-        if (mQnsMetrics == null) {
-            mQnsMetrics = new QnsMetrics(mContext);
-        }
-
-        Log.d(mLogTag, "QnsComponents created for slot " + slotId);
-    }
-
-    @VisibleForTesting
-    QnsComponents(
-            Context context,
-            CellularNetworkStatusTracker cellularNetworkStatusTracker,
-            CellularQualityMonitor cellularQualityMonitor,
-            IwlanNetworkStatusTracker iwlanNetworkStatusTracker,
-            QnsImsManager qnsImsManager,
-            QnsCarrierConfigManager qnsCarrierConfigManager,
-            QnsEventDispatcher qnsEventDispatcher,
-            QnsProvisioningListener qnsProvisioningListener,
-            QnsTelephonyListener qnsTelephonyListener,
-            QnsCallStatusTracker qnsCallStatusTracker,
-            QnsTimer qnsTimer,
-            WifiBackhaulMonitor wifiBackhaulMonitor,
-            WifiQualityMonitor wifiQualityMonitor,
-            QnsMetrics qnsMetrics,
-            int slotId) {
-        this(context);
-        mSlotIds.add(slotId);
-        mQnsTelephonyListeners.put(slotId, qnsTelephonyListener);
-        mQnsImsManagers.put(slotId, qnsImsManager);
-        mCellularNetworkStatusTrackers.put(slotId, cellularNetworkStatusTracker);
-        mCellularQualityMonitors.put(slotId, cellularQualityMonitor);
-        mQnsCallStatusTracker.put(slotId, qnsCallStatusTracker);
-
-        mQnsProvisioningListeners.put(slotId, qnsProvisioningListener);
-        mQnsEventDispatchers.put(slotId, qnsEventDispatcher);
-        mQnsCarrierConfigManagers.put(slotId, qnsCarrierConfigManager);
-        mWifiBackhaulMonitors.put(slotId, wifiBackhaulMonitor);
-
-        mWifiQualityMonitor = wifiQualityMonitor;
-        mQnsTimer = qnsTimer;
-        mIwlanNetworkStatusTracker = iwlanNetworkStatusTracker;
-        mIwlanNetworkStatusTracker.initBySlotIndex(
-                qnsCarrierConfigManager,
-                qnsEventDispatcher,
-                qnsImsManager,
-                qnsTelephonyListener,
-                slotId);
-        mQnsMetrics = qnsMetrics;
-    }
-
-    /** Returns instance of CellularNetworkStatusTracker for given slotId. */
-    CellularNetworkStatusTracker getCellularNetworkStatusTracker(int slotId) {
-        return mCellularNetworkStatusTrackers.get(slotId);
-    }
-
-    /** Returns instance of CellularQualityMonitor for given slotId. */
-    CellularQualityMonitor getCellularQualityMonitor(int slotId) {
-        return mCellularQualityMonitors.get(slotId);
-    }
-
-    /** Returns instance of QnsCallStatusTracker for given slotId. */
-    QnsCallStatusTracker getQnsCallStatusTracker(int slotId) {
-        return mQnsCallStatusTracker.get(slotId);
-    }
-
-    /** Returns instance of QnsImsManager for given slotId. */
-    QnsImsManager getQnsImsManager(int slotId) {
-        return mQnsImsManagers.get(slotId);
-    }
-
-    /** Returns instance of QnsCarrierConfigManager for given slotId. */
-    QnsCarrierConfigManager getQnsCarrierConfigManager(int slotId) {
-        return mQnsCarrierConfigManagers.get(slotId);
-    }
-
-    /** Returns instance of QnsEventDispatcher for given slotId. */
-    QnsEventDispatcher getQnsEventDispatcher(int slotId) {
-        return mQnsEventDispatchers.get(slotId);
-    }
-
-    /** Returns instance of QnsProvisioningListener for given slotId. */
-    QnsProvisioningListener getQnsProvisioningListener(int slotId) {
-        return mQnsProvisioningListeners.get(slotId);
-    }
-
-    /** Returns instance of QnsTelephonyListener for given slotId. */
-    QnsTelephonyListener getQnsTelephonyListener(int slotId) {
-        return mQnsTelephonyListeners.get(slotId);
-    }
-
-    /** Returns instance of WifiBackhaulMonitor for given slotId. */
-    WifiBackhaulMonitor getWifiBackhaulMonitor(int slotId) {
-        return mWifiBackhaulMonitors.get(slotId);
-    }
-
-    /** Returns instance of IwlanNetworkStatusTracker. */
-    IwlanNetworkStatusTracker getIwlanNetworkStatusTracker() {
-        return mIwlanNetworkStatusTracker;
-    }
-
-    /** Returns instance of WifiQualityMonitor. */
-    WifiQualityMonitor getWifiQualityMonitor() {
-        return mWifiQualityMonitor;
-    }
-
-    /** Returns instance of QnsTimer. */
-    QnsTimer getQnsTimer() {
-        return mQnsTimer;
-    }
-
-    /** Returns instance of WifiQualityMonitor. */
-    QnsMetrics getQnsMetrics() {
-        return mQnsMetrics;
-    }
-
-    /** Returns context. */
-    Context getContext() {
-        return mContext;
-    }
-
-    /** It closes all the components of QNS of given slotId. */
-    synchronized void closeComponents(int slotId) {
-        if (!mSlotIds.contains(slotId)) return;
-        mIwlanNetworkStatusTracker.closeBySlotIndex(slotId);
-        if (mSlotIds.size() == 1) {
-            mIwlanNetworkStatusTracker.close();
-            mWifiQualityMonitor.close();
-            mQnsMetrics.close();
-            mIwlanNetworkStatusTracker = null;
-            mWifiQualityMonitor = null;
-            mQnsMetrics = null;
-        }
-
-        WifiBackhaulMonitor wifiBackhaulMonitor = mWifiBackhaulMonitors.get(slotId);
-        if (wifiBackhaulMonitor != null) {
-            mWifiBackhaulMonitors.remove(slotId);
-            wifiBackhaulMonitor.close();
-        }
-        QnsCallStatusTracker qnsCallStatusTracker = mQnsCallStatusTracker.get(slotId);
-        if (qnsCallStatusTracker != null) {
-            mQnsCallStatusTracker.remove(slotId);
-            qnsCallStatusTracker.close();
-        }
-        if (mSlotIds.size() == 1) {
-            mQnsTimer.close();
-            mQnsTimer = null;
-        }
-        CellularQualityMonitor cellularQualityMonitor = mCellularQualityMonitors.get(slotId);
-        if (cellularQualityMonitor != null) {
-            mCellularQualityMonitors.remove(slotId);
-            cellularQualityMonitor.close();
-        }
-        QnsCarrierConfigManager qnsCarrierConfigManager = mQnsCarrierConfigManagers.get(slotId);
-        if (qnsCarrierConfigManager != null) {
-            mQnsCarrierConfigManagers.remove(slotId);
-            qnsCarrierConfigManager.close();
-        }
-        QnsEventDispatcher qnsEventDispatcher = mQnsEventDispatchers.get(slotId);
-        if (qnsEventDispatcher != null) {
-            mQnsEventDispatchers.remove(slotId);
-            qnsEventDispatcher.close();
-        }
-        QnsProvisioningListener qnsProvisioningListener = mQnsProvisioningListeners.get(slotId);
-        if (qnsProvisioningListener != null) {
-            mQnsProvisioningListeners.remove(slotId);
-            qnsProvisioningListener.close();
-        }
-        CellularNetworkStatusTracker cellularTracker = mCellularNetworkStatusTrackers.get(slotId);
-        if (cellularTracker != null) {
-            mCellularNetworkStatusTrackers.remove(slotId);
-            cellularTracker.close();
-        }
-        QnsImsManager qnsImsManager = mQnsImsManagers.get(slotId);
-        if (qnsImsManager != null) {
-            mQnsImsManagers.remove(slotId);
-            qnsImsManager.close();
-        }
-        QnsTelephonyListener qnsTelephonyListener = mQnsTelephonyListeners.get(slotId);
-        if (qnsTelephonyListener != null) {
-            mQnsTelephonyListeners.remove(slotId);
-            qnsTelephonyListener.close();
-        }
-
-        mSlotIds.remove(Integer.valueOf(slotId));
-        Log.d(mLogTag, "QnsComponents closed for slot " + slotId);
-    }
-
-    void dump(PrintWriter pw) {
-        if (mIwlanNetworkStatusTracker != null) {
-            mIwlanNetworkStatusTracker.dump(pw, "  ");
-        }
-        if (mIwlanNetworkStatusTracker != null) {
-            mWifiQualityMonitor.dump(pw, "  ");
-        }
-        if (mIwlanNetworkStatusTracker != null) {
-            mQnsTimer.dump(pw, " ");
-        }
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsConstants.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsConstants.java
deleted file mode 100644
index c60cf3e..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsConstants.java
+++ /dev/null
@@ -1,454 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import android.annotation.IntDef;
-import android.annotation.NonNull;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.AccessNetworkConstants.AccessNetworkType;
-import android.telephony.Annotation;
-import android.telephony.TelephonyManager;
-import android.telephony.ims.ImsMmTelManager;
-
-/** This class is a collection of constants */
-class QnsConstants {
-
-    static final String QNS_TAG = "QNS";
-
-    static final int INVALID_VALUE = -1;
-    static final int INVALID_ID = -1;
-    static final int KEY_DEFAULT_VALUE = 0;
-
-    static final int KEY_DEFAULT_HYST_TIMER = 30000;
-    static final int CONFIG_DEFAULT_MIN_HANDOVER_GUARDING_TIMER = 3000;
-    static final int CONFIG_DEFAULT_MIN_HANDOVER_GUARDING_TIMER_LIMIT = 5000;
-
-    static final int KEY_DEFAULT_PACKET_LOSS_TIME_MILLIS = 3000;
-    static final int KEY_DEFAULT_IWLAN_AVOID_TIME_LOW_RTP_QUALITY_MILLIS = 60000;
-    static final int KEY_DEFAULT_WWAN_AVOID_TIME_LOW_RTP_QUALITY_MILLIS = 60000;
-
-    static final int KEY_DEFAULT_THRESHOLD_SSRSRP_GOOD = -110;
-    static final int KEY_DEFAULT_THRESHOLD_SSRSRP_BAD = -115;
-    static final int KEY_DEFAULT_THRESHOLD_RSRP_GOOD = -115;
-    static final int KEY_DEFAULT_THRESHOLD_RSRP_BAD = -120;
-    static final int KEY_DEFAULT_THRESHOLD_RSCP_GOOD = -105;
-    static final int KEY_DEFAULT_THRESHOLD_RSCP_BAD = -115;
-    static final int KEY_DEFAULT_THRESHOLD_GERAN_RSSI_GOOD = -100;
-    static final int KEY_DEFAULT_THRESHOLD_GERAN_RSSI_BAD = -105;
-    static final int KEY_DEFAULT_THRESHOLD_WIFI_RSSI_GOOD = -75;
-    static final int KEY_DEFAULT_THRESHOLD_WIFI_RSSI_BAD = -80;
-
-    static final int CALL_TYPE_IDLE = 0;
-    static final int CALL_TYPE_VOICE = 1;
-    static final int CALL_TYPE_VIDEO = 2;
-    static final int CALL_TYPE_EMERGENCY = 3;
-
-    @IntDef(
-            value = {
-                CALL_TYPE_IDLE,
-                CALL_TYPE_VOICE,
-                CALL_TYPE_VIDEO,
-                CALL_TYPE_EMERGENCY,
-            })
-    @interface QnsCallType {}
-
-    static final int COVERAGE_HOME = 0;
-    static final int COVERAGE_ROAM = 1;
-    static final int COVERAGE_BOTH = 2;
-
-    @IntDef(value = {COVERAGE_HOME, COVERAGE_ROAM, COVERAGE_BOTH})
-    @interface CellularCoverage {}
-
-    // These(RTP_LOW_QUALITY_) constants are used to @code worseThanBefore(),
-    // be caution before change.
-    static final int RTP_LOW_QUALITY_REASON_JITTER = 1;
-    static final int RTP_LOW_QUALITY_REASON_PACKET_LOSS = 2;
-    static final int RTP_LOW_QUALITY_REASON_NO_RTP = 3;
-
-    @IntDef(
-            value = {
-                RTP_LOW_QUALITY_REASON_JITTER,
-                RTP_LOW_QUALITY_REASON_PACKET_LOSS,
-                RTP_LOW_QUALITY_REASON_NO_RTP,
-            })
-    @interface RtpLowQualityReason {}
-
-    static final int FALLBACK_REASON_INVALID = -1;
-    static final int FALLBACK_REASON_RTP_ONLY = 0;
-    static final int FALLBACK_REASON_WIFI_ONLY = 1;
-    static final int FALLBACK_REASON_RTP_OR_WIFI = 2;
-
-    @IntDef(
-            value = {
-                FALLBACK_REASON_INVALID,
-                FALLBACK_REASON_RTP_ONLY,
-                FALLBACK_REASON_WIFI_ONLY,
-                FALLBACK_REASON_RTP_OR_WIFI,
-            })
-    @interface QnsFallbackReason {}
-
-    static final int MAX_COUNT_INVALID = -1;
-
-    static final int MIN_THRESHOLD_GAP = 3;
-
-    static final int WIFI_ONLY = ImsMmTelManager.WIFI_MODE_WIFI_ONLY;
-    static final int WIFI_PREF = ImsMmTelManager.WIFI_MODE_WIFI_PREFERRED;
-    static final int CELL_PREF = ImsMmTelManager.WIFI_MODE_CELLULAR_PREFERRED;
-
-    @IntDef(
-            value = {
-                WIFI_ONLY, WIFI_PREF, CELL_PREF,
-            })
-    @interface WfcModePreference {}
-
-    static final int ROVE_OUT = 0;
-    static final int ROVE_IN = 1;
-
-    @IntDef(
-            value = {
-                ROVE_OUT, ROVE_IN,
-            })
-    @interface RoveDirection {}
-
-    static final int POLICY_GOOD = 0;
-    static final int POLICY_BAD = 1;
-    static final int POLICY_TOLERABLE = 2;
-
-    @IntDef(
-            value = {
-                POLICY_GOOD,
-                POLICY_BAD,
-                POLICY_TOLERABLE,
-            })
-    @interface QnsQualityType {}
-
-    static final int GUARDING_NONE = 0;
-    static final int GUARDING_CELLULAR = 1;
-    static final int GUARDING_WIFI = 2;
-
-    @IntDef(
-            value = {
-                GUARDING_NONE,
-                GUARDING_WIFI,
-                GUARDING_CELLULAR,
-            })
-    @interface QnsGuarding {}
-
-    static final int IMS_REGISTRATION_CHANGED_UNREGISTERED = 0;
-    static final int IMS_REGISTRATION_CHANGED_ACCESS_NETWORK_CHANGE_FAILED = 1;
-    static final int IMS_REGISTRATION_CHANGED_REGISTERED = 2;
-
-    @IntDef(
-            value = {
-                IMS_REGISTRATION_CHANGED_UNREGISTERED,
-                IMS_REGISTRATION_CHANGED_ACCESS_NETWORK_CHANGE_FAILED,
-                IMS_REGISTRATION_CHANGED_REGISTERED,
-            })
-    @interface QnsImsRegiEvent {}
-
-    static final int SIP_DIALOG_SESSION_POLICY_NONE = 0;
-    static final int SIP_DIALOG_SESSION_POLICY_FOLLOW_VOICE_CALL = 1;
-    static final int SIP_DIALOG_SESSION_POLICY_FOLLOW_VIDEO_CALL = 2;
-
-    @IntDef(
-            value = {
-                    SIP_DIALOG_SESSION_POLICY_NONE,
-                    SIP_DIALOG_SESSION_POLICY_FOLLOW_VOICE_CALL,
-                    SIP_DIALOG_SESSION_POLICY_FOLLOW_VIDEO_CALL,
-            })
-    @interface QnsSipDialogSessionPolicy {}
-
-    static final int THRESHOLD_MATCH_TYPE_EQUAL_TO = 0;
-    static final int THRESHOLD_EQUAL_OR_LARGER = 1;
-    static final int THRESHOLD_EQUAL_OR_SMALLER = 2;
-
-    static final int SIGNAL_MEASUREMENT_AVAILABILITY = 1 << 7;
-
-    static final int SIGNAL_UNAVAILABLE = 0;
-    static final int SIGNAL_AVAILABLE = 1;
-
-    static final int DEFAULT_WIFI_BACKHAUL_TIMER = 3000;
-
-    static final int TRANSPORT_TYPE_ALLOWED_WWAN = 0;
-    static final int TRANSPORT_TYPE_ALLOWED_IWLAN = 1;
-    static final int TRANSPORT_TYPE_ALLOWED_BOTH = 2;
-
-    /** Type of Rat Preference. Default value , Follow the system preference. */
-    static final int RAT_PREFERENCE_DEFAULT = 0;
-    /** Type of Rat Preference. choose Wi-Fi always */
-    static final int RAT_PREFERENCE_WIFI_ONLY = 1;
-    /**
-     * Type of Rat Preference. choose Wi-Fi when the Wi-Fi Calling is available.(when IMS is
-     * registered through the Wi-Fi)
-     */
-    static final int RAT_PREFERENCE_WIFI_WHEN_WFC_AVAILABLE = 2;
-    /** Type of Rat Preference. choose Wi-Fi when no cellular */
-    static final int RAT_PREFERENCE_WIFI_WHEN_NO_CELLULAR = 3;
-    /** Type of Rat Preference. choose Wi-Fi when cellular is available at home network. */
-    static final int RAT_PREFERENCE_WIFI_WHEN_HOME_IS_NOT_AVAILABLE = 4;
-
-    @IntDef(
-            value = {
-                RAT_PREFERENCE_DEFAULT,
-                RAT_PREFERENCE_WIFI_ONLY,
-                RAT_PREFERENCE_WIFI_WHEN_WFC_AVAILABLE,
-                RAT_PREFERENCE_WIFI_WHEN_NO_CELLULAR,
-                RAT_PREFERENCE_WIFI_WHEN_HOME_IS_NOT_AVAILABLE,
-            })
-    @interface RatPreference {}
-
-    static String callTypeToString(@QnsConstants.QnsCallType int callType) {
-        switch (callType) {
-            case CALL_TYPE_IDLE:
-                return "IDLE";
-            case CALL_TYPE_VOICE:
-                return "VOICE";
-            case CALL_TYPE_VIDEO:
-                return "VIDEO";
-            case CALL_TYPE_EMERGENCY:
-                return "SOS";
-        }
-        return "";
-    }
-
-    static String coverageToString(@QnsConstants.CellularCoverage int coverage) {
-        switch (coverage) {
-            case COVERAGE_HOME:
-                return "HOME";
-            case COVERAGE_ROAM:
-                return "ROAM";
-        }
-        return "";
-    }
-
-    static String preferenceToString(@QnsConstants.WfcModePreference int preference) {
-        switch (preference) {
-            case WIFI_ONLY:
-                return "WIFI_ONLY";
-            case WIFI_PREF:
-                return "WIFI_PREF";
-            case CELL_PREF:
-                return "CELL_PREF";
-        }
-        return "";
-    }
-
-    static String directionToString(@QnsConstants.RoveDirection int direction) {
-        if (direction == ROVE_IN) {
-            return "ROVE_IN";
-        }
-        return "ROVE_OUT";
-    }
-
-    static String guardingToString(@QnsConstants.QnsGuarding int guarding) {
-        switch (guarding) {
-            case GUARDING_NONE:
-                return "GUARDING_NONE";
-            case GUARDING_CELLULAR:
-                return "GUARDING_CELL";
-            case GUARDING_WIFI:
-                return "GUARDING_WIFI";
-        }
-        return "";
-    }
-
-    /**
-     * This method coverts call state value from int to string
-     *
-     * @param state int value of call state.
-     * @return returns the string value for the given int call state in parameter.
-     */
-    static String callStateToString(@Annotation.CallState int state) {
-        switch (state) {
-            case TelephonyManager.CALL_STATE_IDLE:
-                return "CALL_STATE_IDLE";
-            case TelephonyManager.CALL_STATE_RINGING:
-                return "CALL_STATE_RINGING";
-            case TelephonyManager.CALL_STATE_OFFHOOK:
-                return "CALL_STATE_OFFHOOK";
-            default:
-                return "CALL_STATE_UNKNOWN_" + state;
-        }
-    }
-
-    static String imsRegistrationEventToString(@QnsConstants.QnsImsRegiEvent int event) {
-        switch (event) {
-            case IMS_REGISTRATION_CHANGED_UNREGISTERED:
-                return "IMS_REGISTRATION_CHANGED_UNREGISTERED";
-            case IMS_REGISTRATION_CHANGED_ACCESS_NETWORK_CHANGE_FAILED:
-                return "IMS_REGISTRATION_CHANGED_ACCESS_NETWORK_CHANGE_FAILED";
-            case IMS_REGISTRATION_CHANGED_REGISTERED:
-                return "IMS_REGISTRATION_CHANGED_REGISTERED";
-        }
-        return "";
-    }
-
-    /**
-     * This method converts AccessNetworkType from int to string.
-     *
-     * @param type int value of AccessNetworkType
-     * @return String value of the access network type.
-     */
-    static String accessNetworkTypeToString(int type) {
-        switch (type) {
-            case AccessNetworkType.UNKNOWN:
-                return "UNKNOWN";
-            case AccessNetworkType.GERAN:
-                return "GERAN";
-            case AccessNetworkType.UTRAN:
-                return "UTRAN";
-            case AccessNetworkType.EUTRAN:
-                return "EUTRAN";
-            case AccessNetworkType.CDMA2000:
-                return "CDMA2000";
-            case AccessNetworkType.IWLAN:
-                return "IWLAN";
-            case AccessNetworkType.NGRAN:
-                return "NGRAN";
-            default:
-                return Integer.toString(type);
-        }
-    }
-
-    /**
-     * This method coverts AccessNetworkType from string to int.
-     *
-     * @param str String value of AccessNetworkType
-     * @return Integer value of AccessNetworkType.
-     */
-    static int accessNetworkTypeFromString(@NonNull String str) {
-        switch (str.toUpperCase()) {
-            case "GERAN":
-                return AccessNetworkType.GERAN;
-            case "UTRAN":
-                return AccessNetworkType.UTRAN;
-            case "EUTRAN":
-                return AccessNetworkType.EUTRAN;
-            case "CDMA2000":
-                return AccessNetworkType.CDMA2000;
-            case "IWLAN":
-                return AccessNetworkType.IWLAN;
-            case "NGRAN":
-                return AccessNetworkType.NGRAN;
-            default:
-                return AccessNetworkType.UNKNOWN;
-        }
-    }
-
-    /**
-     * This method coverts TransportType from int to string.
-     *
-     * @param transportType Integer value of TransportType
-     * @return String value of TransportType.
-     */
-    static String transportTypeToString(int transportType) {
-        switch (transportType) {
-            case AccessNetworkConstants.TRANSPORT_TYPE_WWAN:
-                return "WWAN";
-            case AccessNetworkConstants.TRANSPORT_TYPE_WLAN:
-                return "WLAN";
-            case AccessNetworkConstants.TRANSPORT_TYPE_INVALID:
-                return "INVALID";
-            default:
-                return Integer.toString(transportType);
-        }
-    }
-
-    /**
-     * Convert data state to string
-     *
-     * @return The data state in string format.
-     */
-    static String dataStateToString(@Annotation.DataState int state) {
-        switch (state) {
-            case TelephonyManager.DATA_DISCONNECTED:
-                return "DISCONNECTED";
-            case TelephonyManager.DATA_CONNECTING:
-                return "CONNECTING";
-            case TelephonyManager.DATA_CONNECTED:
-                return "CONNECTED";
-            case TelephonyManager.DATA_SUSPENDED:
-                return "SUSPENDED";
-            case TelephonyManager.DATA_DISCONNECTING:
-                return "DISCONNECTING";
-            case TelephonyManager.DATA_HANDOVER_IN_PROGRESS:
-                return "HANDOVERINPROGRESS";
-            case TelephonyManager.DATA_UNKNOWN:
-                return "UNKNOWN";
-        }
-        // This is the error case. The well-defined value for UNKNOWN is -1.
-        return "UNKNOWN(" + state + ")";
-    }
-
-    /**
-     * This method converts Network Type to AccessNetworkType.
-     *
-     * @param networkType integer value of network type
-     * @return integer value of AccessNetworkType.
-     */
-    static int networkTypeToAccessNetworkType(int networkType) {
-        switch (networkType) {
-            case TelephonyManager.NETWORK_TYPE_GPRS:
-            case TelephonyManager.NETWORK_TYPE_EDGE:
-            case TelephonyManager.NETWORK_TYPE_GSM:
-                return AccessNetworkType.GERAN;
-            case TelephonyManager.NETWORK_TYPE_UMTS:
-            case TelephonyManager.NETWORK_TYPE_HSDPA:
-            case TelephonyManager.NETWORK_TYPE_HSUPA:
-            case TelephonyManager.NETWORK_TYPE_HSPAP:
-            case TelephonyManager.NETWORK_TYPE_HSPA:
-            case TelephonyManager.NETWORK_TYPE_TD_SCDMA:
-                return AccessNetworkType.UTRAN;
-            case TelephonyManager.NETWORK_TYPE_1xRTT:
-            case TelephonyManager.NETWORK_TYPE_CDMA:
-            case TelephonyManager.NETWORK_TYPE_EVDO_0:
-            case TelephonyManager.NETWORK_TYPE_EVDO_A:
-            case TelephonyManager.NETWORK_TYPE_EVDO_B:
-            case TelephonyManager.NETWORK_TYPE_EHRPD:
-                return AccessNetworkType.CDMA2000;
-            case TelephonyManager.NETWORK_TYPE_LTE:
-            case TelephonyManager.NETWORK_TYPE_LTE_CA:
-                return AccessNetworkType.EUTRAN;
-            case TelephonyManager.NETWORK_TYPE_NR:
-                return AccessNetworkType.NGRAN;
-            case TelephonyManager.NETWORK_TYPE_IWLAN:
-                return AccessNetworkType.IWLAN;
-            default:
-                return AccessNetworkType.UNKNOWN;
-        }
-    }
-
-    /**
-     * This method converts QnsSipDialogSessionPolicy to string.
-     *
-     * @param policy int value of QnsSipDialogSessionPolicy.
-     * @return String value of QnsSipDialogSessionPolicy.
-     */
-    static String qnsSipDialogSessionPolicyToString(
-            @QnsConstants.QnsSipDialogSessionPolicy int policy) {
-        switch (policy) {
-            case SIP_DIALOG_SESSION_POLICY_NONE:
-                return "POLICY_NONE";
-            case SIP_DIALOG_SESSION_POLICY_FOLLOW_VOICE_CALL:
-                return "POLICY_VOICE";
-            case SIP_DIALOG_SESSION_POLICY_FOLLOW_VIDEO_CALL:
-                return "POLICY_VIDEO";
-            default:
-                return "NONE";
-        }
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsEventDispatcher.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsEventDispatcher.java
deleted file mode 100644
index 6447fc9..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsEventDispatcher.java
+++ /dev/null
@@ -1,833 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static android.telephony.SubscriptionManager.EXTRA_SLOT_INDEX;
-import static android.telephony.ims.ImsMmTelManager.WIFI_MODE_CELLULAR_PREFERRED;
-import static android.telephony.ims.ImsMmTelManager.WIFI_MODE_WIFI_ONLY;
-import static android.telephony.ims.ImsMmTelManager.WIFI_MODE_WIFI_PREFERRED;
-
-import static com.android.telephony.qns.wfc.WfcActivationHelper.ACTION_TRY_WFC_CONNECTION;
-import static com.android.telephony.qns.wfc.WfcActivationHelper.EXTRA_SUB_ID;
-import static com.android.telephony.qns.wfc.WfcActivationHelper.EXTRA_TRY_STATUS;
-import static com.android.telephony.qns.wfc.WfcActivationHelper.STATUS_START;
-
-import android.annotation.IntDef;
-import android.content.BroadcastReceiver;
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.database.ContentObserver;
-import android.net.Uri;
-import android.net.wifi.WifiManager;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Looper;
-import android.os.Message;
-import android.provider.Settings;
-import android.telephony.CarrierConfigManager;
-import android.telephony.SubscriptionManager;
-import android.telephony.TelephonyManager;
-import android.telephony.ims.ProvisioningManager;
-import android.util.Log;
-import android.util.SparseArray;
-
-import com.android.internal.annotations.VisibleForTesting;
-import com.android.internal.telephony.TelephonyIntents;
-
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-/** QnsEventDispatcher Delivers Broadcasted Intent & change on setting to registered Handlers. */
-class QnsEventDispatcher {
-
-    @IntDef(
-            prefix = {"QNS_EVENT_"},
-            value = {
-                QNS_EVENT_BASE,
-                QNS_EVENT_CARRIER_CONFIG_CHANGED,
-                QNS_EVENT_CARRIER_CONFIG_UNKNOWN_CARRIER,
-                QNS_EVENT_WIFI_DISABLING,
-                QNS_EVENT_WIFI_AP_CHANGED,
-                QNS_EVENT_APM_DISABLED,
-                QNS_EVENT_APM_ENABLED,
-                QNS_EVENT_WFC_ENABLED,
-                QNS_EVENT_WFC_DISABLED,
-                QNS_EVENT_WFC_MODE_TO_WIFI_ONLY,
-                QNS_EVENT_WFC_MODE_TO_CELLULAR_PREFERRED,
-                QNS_EVENT_WFC_MODE_TO_WIFI_PREFERRED,
-                QNS_EVENT_WFC_ROAMING_ENABLED,
-                QNS_EVENT_WFC_ROAMING_DISABLED,
-                QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_ONLY,
-                QNS_EVENT_WFC_ROAMING_MODE_TO_CELLULAR_PREFERRED,
-                QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_PREFERRED,
-                QNS_EVENT_CROSS_SIM_CALLING_ENABLED,
-                QNS_EVENT_CROSS_SIM_CALLING_DISABLED,
-                QNS_EVENT_EMERGENCY_CALLBACK_MODE_ON,
-                QNS_EVENT_EMERGENCY_CALLBACK_MODE_OFF,
-                QNS_EVENT_WFC_PLATFORM_ENABLED,
-                QNS_EVENT_WFC_PLATFORM_DISABLED,
-                QNS_EVENT_SIM_ABSENT,
-                QNS_EVENT_SIM_LOADED,
-                QNS_EVENT_WIFI_ENABLED,
-            })
-    @interface QnsEventType {}
-
-    static final int QNS_EVENT_BASE = 0;
-    static final int QNS_EVENT_CARRIER_CONFIG_CHANGED = QNS_EVENT_BASE + 1;
-    static final int QNS_EVENT_CARRIER_CONFIG_UNKNOWN_CARRIER = QNS_EVENT_BASE + 2;
-    static final int QNS_EVENT_WIFI_DISABLING = QNS_EVENT_BASE + 3;
-    static final int QNS_EVENT_WIFI_AP_CHANGED = QNS_EVENT_BASE + 4;
-    static final int QNS_EVENT_APM_DISABLED = QNS_EVENT_BASE + 5;
-    static final int QNS_EVENT_APM_ENABLED = QNS_EVENT_BASE + 6;
-    static final int QNS_EVENT_WFC_ENABLED = QNS_EVENT_BASE + 7;
-    static final int QNS_EVENT_WFC_DISABLED = QNS_EVENT_BASE + 8;
-    static final int QNS_EVENT_WFC_MODE_TO_WIFI_ONLY = QNS_EVENT_BASE + 9;
-    static final int QNS_EVENT_WFC_MODE_TO_CELLULAR_PREFERRED = QNS_EVENT_BASE + 10;
-    static final int QNS_EVENT_WFC_MODE_TO_WIFI_PREFERRED = QNS_EVENT_BASE + 11;
-    static final int QNS_EVENT_WFC_ROAMING_ENABLED = QNS_EVENT_BASE + 12;
-    static final int QNS_EVENT_WFC_ROAMING_DISABLED = QNS_EVENT_BASE + 13;
-    static final int QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_ONLY = QNS_EVENT_BASE + 14;
-    static final int QNS_EVENT_WFC_ROAMING_MODE_TO_CELLULAR_PREFERRED = QNS_EVENT_BASE + 15;
-    static final int QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_PREFERRED = QNS_EVENT_BASE + 16;
-    static final int QNS_EVENT_CROSS_SIM_CALLING_ENABLED = QNS_EVENT_BASE + 17;
-    static final int QNS_EVENT_CROSS_SIM_CALLING_DISABLED = QNS_EVENT_BASE + 18;
-    static final int QNS_EVENT_EMERGENCY_CALLBACK_MODE_ON = QNS_EVENT_BASE + 19;
-    static final int QNS_EVENT_EMERGENCY_CALLBACK_MODE_OFF = QNS_EVENT_BASE + 20;
-    static final int QNS_EVENT_WFC_PLATFORM_ENABLED = QNS_EVENT_BASE + 21;
-    static final int QNS_EVENT_WFC_PLATFORM_DISABLED = QNS_EVENT_BASE + 22;
-    static final int QNS_EVENT_SIM_ABSENT = QNS_EVENT_BASE + 23;
-    static final int QNS_EVENT_SIM_LOADED = QNS_EVENT_BASE + 24;
-    static final int QNS_EVENT_WIFI_ENABLED = QNS_EVENT_BASE + 25;
-    static final int QNS_EVENT_TRY_WFC_ACTIVATION = QNS_EVENT_BASE + 100;
-    static final int QNS_EVENT_CANCEL_TRY_WFC_ACTIVATION = QNS_EVENT_BASE + 101;
-    private static final int EVENT_PROVISIONING_INFO_CHANGED = QNS_EVENT_BASE + 200;
-    private static Boolean sIsAirplaneModeOn;
-    private static int sWiFiState = WifiManager.WIFI_STATE_UNKNOWN;
-    private final String mLogTag;
-    private final Context mContext;
-    private final int mSlotIndex;
-    SparseArray<Set<Handler>> mEventHandlers = new SparseArray<>();
-    private int mSubId;
-    private Uri mCrossSimCallingUri;
-    private Uri mWfcEnabledUri;
-    private Uri mWfcModeUri;
-    private Uri mWfcRoamingEnabledUri;
-    private Uri mWfcRoamingModeUri;
-    @VisibleForTesting UserSettingObserver mUserSettingObserver;
-    private HandlerThread mUserSettingHandlerThread;
-    boolean mLastWfcEnabledByPlatform = false;
-    boolean mLastCrossSimCallingEnabled = false;
-    boolean mLastWfcEnabled = false;
-    int mLastWfcMode = WIFI_MODE_CELLULAR_PREFERRED;
-    boolean mLastWfcRoamingEnabled = false;
-    int mLastWfcModeRoaming = WIFI_MODE_WIFI_PREFERRED;
-    protected final QnsProvisioningListener mQnsProvisioningListener;
-    protected final QnsImsManager mQnsImsManager;
-    private QnsProvisioningListener.QnsProvisioningInfo mLastProvisioningInfo;
-    @VisibleForTesting final QnsEventDispatcherHandler mQnsEventDispatcherHandler;
-
-    @VisibleForTesting
-    final BroadcastReceiver mIntentReceiver =
-            new BroadcastReceiver() {
-                @Override
-                public void onReceive(Context context, Intent intent) {
-                    String action = intent.getAction();
-                    int event;
-                    Log.d(mLogTag, "onReceive: " + action);
-                    switch (action) {
-                        case CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED:
-                            int slotId =
-                                    intent.getIntExtra(
-                                            CarrierConfigManager.EXTRA_SLOT_INDEX,
-                                            SubscriptionManager.INVALID_SIM_SLOT_INDEX);
-                            int carrierId =
-                                    intent.getIntExtra(
-                                            TelephonyManager.EXTRA_CARRIER_ID,
-                                            TelephonyManager.UNKNOWN_CARRIER_ID);
-
-                            onCarrierConfigChanged(context, slotId, carrierId);
-                            break;
-
-                        case TelephonyManager.ACTION_SIM_CARD_STATE_CHANGED:
-                        case TelephonyManager.ACTION_SIM_APPLICATION_STATE_CHANGED:
-                            slotId =
-                                    intent.getIntExtra(
-                                            CarrierConfigManager.EXTRA_SLOT_INDEX,
-                                            SubscriptionManager.INVALID_SIM_SLOT_INDEX);
-                            int simState =
-                                    intent.getIntExtra(
-                                            TelephonyManager.EXTRA_SIM_STATE,
-                                            TelephonyManager.SIM_STATE_UNKNOWN);
-                            onSimStateChanged(slotId, simState);
-                            break;
-
-                        case Intent.ACTION_AIRPLANE_MODE_CHANGED:
-                            Boolean isAirplaneModeOn = intent.getBooleanExtra("state", false);
-                            if (sIsAirplaneModeOn != null
-                                    && sIsAirplaneModeOn.equals(isAirplaneModeOn)) {
-                                // no change in apm state
-                                break;
-                            }
-                            sIsAirplaneModeOn = isAirplaneModeOn;
-                            event =
-                                    sIsAirplaneModeOn
-                                            ? QNS_EVENT_APM_ENABLED
-                                            : QNS_EVENT_APM_DISABLED;
-                            updateHandlers(event);
-                            break;
-
-                        case WifiManager.WIFI_STATE_CHANGED_ACTION:
-                            int wifiState =
-                                    intent.getIntExtra(
-                                            WifiManager.EXTRA_WIFI_STATE,
-                                            WifiManager.WIFI_STATE_UNKNOWN);
-                            if (wifiState != sWiFiState) {
-                                sWiFiState = wifiState;
-                                if (wifiState == WifiManager.WIFI_STATE_DISABLING) {
-                                    event = QNS_EVENT_WIFI_DISABLING;
-                                } else if (wifiState == WifiManager.WIFI_STATE_ENABLED) {
-                                    event = QNS_EVENT_WIFI_ENABLED;
-                                } else {
-                                    break;
-                                }
-                                updateHandlers(event);
-                            }
-                            break;
-
-                        case TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED:
-                            boolean emergencyMode =
-                                    intent.getBooleanExtra(
-                                            TelephonyManager.EXTRA_PHONE_IN_ECM_STATE, false);
-                            event =
-                                    emergencyMode
-                                            ? QNS_EVENT_EMERGENCY_CALLBACK_MODE_ON
-                                            : QNS_EVENT_EMERGENCY_CALLBACK_MODE_OFF;
-                            int slotIndex = intent.getIntExtra(EXTRA_SLOT_INDEX, 0);
-                            // getInstance(mContext, slotIndex).
-                            if (mSlotIndex == slotIndex) {
-                                updateHandlers(event);
-                            }
-                            break;
-                    }
-                }
-            };
-
-    final BroadcastReceiver mWfcActivationIntentReceiver =
-            new BroadcastReceiver() {
-                @Override
-                public void onReceive(Context context, Intent intent) {
-                    String action = intent.getAction();
-                    int event;
-                    Log.d(mLogTag, "mWfcActivationIntentReceiver onReceive: " + action);
-                    switch (action) {
-                        case ACTION_TRY_WFC_CONNECTION:
-                            int subId = intent.getIntExtra(EXTRA_SUB_ID, -1);
-                            if (subId != mSubId) {
-                                Log.d(mLogTag, "Intent subId: " + subId + ", mSubId: " + mSubId);
-                                break;
-                            }
-                            int request = intent.getIntExtra(EXTRA_TRY_STATUS, 0);
-                            event =
-                                    request == STATUS_START
-                                            ? QNS_EVENT_TRY_WFC_ACTIVATION
-                                            : QNS_EVENT_CANCEL_TRY_WFC_ACTIVATION;
-                            updateHandlers(event);
-                            break;
-                    }
-                }
-            };
-
-    /** QnsEventDispatcher constructor */
-    QnsEventDispatcher(
-            Context context,
-            QnsProvisioningListener provisioningListener,
-            QnsImsManager imsManager,
-            int slotIndex) {
-        mContext = context;
-        mSlotIndex = slotIndex;
-        mLogTag = QnsEventDispatcher.class.getSimpleName() + "[" + mSlotIndex + "]";
-        mSubId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
-        mQnsProvisioningListener = provisioningListener;
-        mQnsImsManager = imsManager;
-        final ContentResolver cr = mContext.getContentResolver();
-        int airplaneMode = Settings.Global.getInt(cr, Settings.Global.AIRPLANE_MODE_ON, 0);
-        sIsAirplaneModeOn = (airplaneMode == 1);
-        IntentFilter intentFilter = new IntentFilter();
-        intentFilter.addAction(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
-        intentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
-        intentFilter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);
-        intentFilter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
-        intentFilter.addAction(TelephonyManager.ACTION_SIM_CARD_STATE_CHANGED);
-        intentFilter.addAction(TelephonyManager.ACTION_SIM_APPLICATION_STATE_CHANGED);
-        mContext.registerReceiver(mIntentReceiver, intentFilter);
-
-        IntentFilter wfcIntentFilter = new IntentFilter();
-        wfcIntentFilter.addAction(ACTION_TRY_WFC_CONNECTION);
-        mContext.registerReceiver(
-                mWfcActivationIntentReceiver, wfcIntentFilter, Context.RECEIVER_NOT_EXPORTED);
-
-        HandlerThread handlerThread = new HandlerThread(mLogTag);
-        handlerThread.start();
-        mQnsEventDispatcherHandler = new QnsEventDispatcherHandler(handlerThread.getLooper());
-        mQnsEventDispatcherHandler.post(() -> loadAndNotifyWfcSettings(mContext, mSlotIndex));
-
-        mLastProvisioningInfo = new QnsProvisioningListener.QnsProvisioningInfo();
-        mQnsProvisioningListener.registerProvisioningItemInfoChanged(
-                mQnsEventDispatcherHandler, EVENT_PROVISIONING_INFO_CHANGED, null, true);
-    }
-
-    private synchronized void loadAndNotifyWfcSettings(Context context, int slotIndex) {
-        int subId = QnsUtils.getSubId(context, slotIndex);
-        Log.d(mLogTag, "loadAndNotifyWfcSettings for sub:" + subId);
-        if (subId != mSubId) {
-            unregisterContentObserver();
-            mSubId = subId;
-            registerContentObserver();
-        }
-        notifyWfcEnabledByPlatform();
-        notifyCurrentSetting(mCrossSimCallingUri, true);
-        notifyCurrentSetting(mWfcEnabledUri, true);
-        notifyCurrentSetting(mWfcModeUri, true);
-        notifyCurrentSetting(mWfcRoamingEnabledUri, true);
-        notifyCurrentSetting(mWfcRoamingModeUri, true);
-    }
-
-    private synchronized void onCarrierConfigChanged(Context context, int slotId, int carrierId) {
-        if (slotId != mSlotIndex) {
-            return;
-        }
-
-        Log.d(mLogTag, "onCarrierConfigChanged");
-        loadAndNotifyWfcSettings(context, slotId);
-
-        int event;
-        if (carrierId != TelephonyManager.UNKNOWN_CARRIER_ID) {
-            event = QNS_EVENT_CARRIER_CONFIG_CHANGED;
-        } else {
-            event = QNS_EVENT_CARRIER_CONFIG_UNKNOWN_CARRIER;
-        }
-
-        updateHandlers(event);
-    }
-
-    synchronized void registerEvent(List<Integer> events, Handler handler) {
-        for (@QnsEventType int event : events) {
-            if (mEventHandlers.contains(event)) {
-                mEventHandlers.get(event).add(handler);
-            } else {
-                Set<Handler> handlers = new HashSet<>();
-                handlers.add(handler);
-                mEventHandlers.append(event, handlers);
-            }
-        }
-        notifyImmediately(events, handler);
-    }
-
-    private void onSimStateChanged(int slotId, int simState) {
-        if (slotId != mSlotIndex) {
-            return;
-        }
-        if (simState == TelephonyManager.SIM_STATE_ABSENT) {
-            updateHandlers(QNS_EVENT_SIM_ABSENT);
-        } else if (simState == TelephonyManager.SIM_STATE_LOADED) {
-            updateHandlers(QNS_EVENT_SIM_LOADED);
-        }
-    }
-
-    private synchronized void notifyImmediately(List<Integer> events, Handler handler) {
-        boolean bWfcPlatformSetting = false;
-        boolean bWfcSetting = false;
-        boolean bWfcModeSetting = false;
-        boolean bWfcRoamingSetting = false;
-        boolean bWfcRoamingModeSetting = false;
-        boolean bCrossSimSetting = false;
-        for (@QnsEventType int event : events) {
-            switch (event) {
-                case QNS_EVENT_WFC_PLATFORM_ENABLED:
-                case QNS_EVENT_WFC_PLATFORM_DISABLED:
-                    bWfcPlatformSetting = true;
-                    break;
-                case QNS_EVENT_WFC_ENABLED:
-                case QNS_EVENT_WFC_DISABLED:
-                    bWfcSetting = true;
-                    break;
-                case QNS_EVENT_WFC_ROAMING_ENABLED:
-                case QNS_EVENT_WFC_ROAMING_DISABLED:
-                    bWfcRoamingSetting = true;
-                    break;
-                case QNS_EVENT_WFC_MODE_TO_WIFI_ONLY:
-                case QNS_EVENT_WFC_MODE_TO_CELLULAR_PREFERRED:
-                case QNS_EVENT_WFC_MODE_TO_WIFI_PREFERRED:
-                    bWfcModeSetting = true;
-                    break;
-                case QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_ONLY:
-                case QNS_EVENT_WFC_ROAMING_MODE_TO_CELLULAR_PREFERRED:
-                case QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_PREFERRED:
-                    bWfcRoamingModeSetting = true;
-                    break;
-                case QnsEventDispatcher.QNS_EVENT_CROSS_SIM_CALLING_ENABLED:
-                case QnsEventDispatcher.QNS_EVENT_CROSS_SIM_CALLING_DISABLED:
-                    bCrossSimSetting = true;
-                    break;
-            }
-        }
-
-        if (bWfcPlatformSetting) {
-            if (mLastWfcEnabledByPlatform) {
-                updateHandler(handler, QNS_EVENT_WFC_PLATFORM_ENABLED);
-            } else {
-                updateHandler(handler, QNS_EVENT_WFC_PLATFORM_DISABLED);
-            }
-            // checks again whether setting is changed.
-            notifyWfcEnabledByPlatform();
-        }
-        if (bWfcSetting) {
-            if (mLastWfcEnabled) {
-                updateHandler(handler, QNS_EVENT_WFC_ENABLED);
-            } else {
-                updateHandler(handler, QNS_EVENT_WFC_DISABLED);
-            }
-            // checks again whether setting is changed.
-            notifyCurrentSetting(mWfcEnabledUri, false);
-        }
-        if (bWfcModeSetting) {
-            switch (mLastWfcMode) {
-                case WIFI_MODE_WIFI_ONLY:
-                    updateHandler(handler, QNS_EVENT_WFC_MODE_TO_WIFI_ONLY);
-                    break;
-                case WIFI_MODE_CELLULAR_PREFERRED:
-                    updateHandler(handler, QNS_EVENT_WFC_MODE_TO_CELLULAR_PREFERRED);
-                    break;
-                case WIFI_MODE_WIFI_PREFERRED:
-                    updateHandler(handler, QNS_EVENT_WFC_MODE_TO_WIFI_PREFERRED);
-                    break;
-            }
-            // checks again whether setting is changed.
-            notifyCurrentSetting(mWfcModeUri, false);
-        }
-        if (bWfcRoamingSetting) {
-            if (mLastWfcRoamingEnabled) {
-                updateHandler(handler, QNS_EVENT_WFC_ROAMING_ENABLED);
-            } else {
-                updateHandler(handler, QNS_EVENT_WFC_ROAMING_DISABLED);
-            }
-            // checks again whether setting is changed.
-            notifyCurrentSetting(mWfcRoamingEnabledUri, false);
-        }
-        if (bWfcRoamingModeSetting) {
-            switch (mLastWfcModeRoaming) {
-                case WIFI_MODE_WIFI_ONLY:
-                    updateHandler(handler, QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_ONLY);
-                    break;
-                case WIFI_MODE_CELLULAR_PREFERRED:
-                    updateHandler(handler, QNS_EVENT_WFC_ROAMING_MODE_TO_CELLULAR_PREFERRED);
-                    break;
-                case WIFI_MODE_WIFI_PREFERRED:
-                    updateHandler(handler, QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_PREFERRED);
-                    break;
-            }
-            // checks again whether setting is changed.
-            notifyCurrentSetting(mWfcRoamingModeUri, false);
-        }
-        if (bCrossSimSetting) {
-            if (mLastCrossSimCallingEnabled) {
-                updateHandler(handler, QNS_EVENT_CROSS_SIM_CALLING_ENABLED);
-            } else {
-                updateHandler(handler, QNS_EVENT_CROSS_SIM_CALLING_DISABLED);
-            }
-            // checks again whether setting is changed.
-            notifyCurrentSetting(mCrossSimCallingUri, false);
-        }
-    }
-
-    synchronized void unregisterEvent(Handler handler) {
-        for (int i = 0; i < mEventHandlers.size(); i++) {
-            Set<Handler> handlers = mEventHandlers.valueAt(i);
-            handlers.remove(handler);
-            if (handlers.isEmpty()) {
-                mEventHandlers.delete(mEventHandlers.keyAt(i));
-                i--;
-            }
-        }
-        if (mEventHandlers.size() == 0) {
-            close();
-        }
-    }
-
-    public void close() {
-        try {
-            mContext.unregisterReceiver(mIntentReceiver);
-        } catch (IllegalArgumentException ignored) {
-        }
-        if (mUserSettingObserver != null) {
-            mContext.getContentResolver().unregisterContentObserver(mUserSettingObserver);
-        }
-        if (mUserSettingHandlerThread != null) {
-            mUserSettingHandlerThread.quit();
-        }
-        if (mQnsProvisioningListener != null) {
-            mQnsProvisioningListener.unregisterProvisioningItemInfoChanged(
-                    mQnsEventDispatcherHandler);
-        }
-    }
-
-    private synchronized void unregisterContentObserver() {
-        if (mUserSettingObserver != null) {
-            mContext.getContentResolver().unregisterContentObserver(mUserSettingObserver);
-        }
-        mCrossSimCallingUri = null;
-        mWfcEnabledUri = null;
-        mWfcModeUri = null;
-        mWfcRoamingEnabledUri = null;
-        mWfcRoamingModeUri = null;
-    }
-
-    private void registerContentObserver() {
-        // Register for content observer
-        if (mUserSettingObserver == null) {
-            Log.d(mLogTag, "create mUserSettingObserver");
-            mUserSettingHandlerThread = new HandlerThread(QnsEventDispatcher.class.getSimpleName());
-            mUserSettingHandlerThread.start();
-            Looper looper = mUserSettingHandlerThread.getLooper();
-            Handler handler = new Handler(looper);
-            mUserSettingObserver = new UserSettingObserver(handler);
-
-            // init
-            mLastWfcEnabledByPlatform = QnsUtils.isWfcEnabledByPlatform(mQnsImsManager);
-            mLastCrossSimCallingEnabled = QnsUtils.isCrossSimCallingEnabled(mQnsImsManager);
-            mLastWfcEnabled =
-                    QnsUtils.isWfcEnabled(mQnsImsManager, mQnsProvisioningListener, false);
-            mLastWfcMode = QnsUtils.getWfcMode(mQnsImsManager, false);
-            mLastWfcRoamingEnabled =
-                    QnsUtils.isWfcEnabled(mQnsImsManager, mQnsProvisioningListener, true);
-            mLastWfcModeRoaming = QnsUtils.getWfcMode(mQnsImsManager, true);
-        }
-
-        if (mSubId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
-            return;
-        }
-
-        StringBuilder sb = new StringBuilder("registerContentObserver");
-        sb.append(" subId:").append(mSubId);
-        ContentResolver resolver = mContext.getContentResolver();
-
-        // Update current Cross Sim Calling setting
-        Uri crossSimCallingUri = getUri(SubscriptionManager.CROSS_SIM_ENABLED_CONTENT_URI, mSubId);
-        if (!crossSimCallingUri.equals(mCrossSimCallingUri)) {
-            mCrossSimCallingUri = crossSimCallingUri;
-            sb.append(" crossSimCallingUri/").append(mSubId);
-            resolver.registerContentObserver(mCrossSimCallingUri, true, mUserSettingObserver);
-        }
-
-        // Update current Wi-Fi Calling setting
-        Uri wfcEnabledUri = getUri(SubscriptionManager.WFC_ENABLED_CONTENT_URI, mSubId);
-        if (!wfcEnabledUri.equals(mWfcEnabledUri)) {
-            mWfcEnabledUri = wfcEnabledUri;
-            sb.append(" wfcEnabledUri/").append(mSubId);
-            resolver.registerContentObserver(mWfcEnabledUri, true, mUserSettingObserver);
-        }
-
-        // Update current Wi-Fi Calling Mode setting
-        Uri wfcModeUri = getUri(SubscriptionManager.WFC_MODE_CONTENT_URI, mSubId);
-        if (!wfcModeUri.equals(mWfcModeUri)) {
-            mWfcModeUri = wfcModeUri;
-            sb.append(" wfcModeUri/").append(mSubId);
-            resolver.registerContentObserver(mWfcModeUri, true, mUserSettingObserver);
-        }
-
-        // Update current Wi-Fi Calling setting for roaming
-        Uri wfcRoamEnabledUri = getUri(SubscriptionManager.WFC_ROAMING_ENABLED_CONTENT_URI, mSubId);
-        if (!wfcRoamEnabledUri.equals(mWfcRoamingEnabledUri)) {
-            mWfcRoamingEnabledUri = wfcRoamEnabledUri;
-            sb.append(" wfcRoamEnabledUri/").append(mSubId);
-            resolver.registerContentObserver(mWfcRoamingEnabledUri, true, mUserSettingObserver);
-        }
-
-        // Update current Wi-Fi Calling Mode setting for roaming
-        Uri wfcRoamingModeUri = getUri(SubscriptionManager.WFC_ROAMING_MODE_CONTENT_URI, mSubId);
-        if (!wfcRoamingModeUri.equals(mWfcRoamingModeUri)) {
-            mWfcRoamingModeUri = wfcRoamingModeUri;
-            sb.append(" wfcRoamingModeUri/").append(mSubId);
-            resolver.registerContentObserver(mWfcRoamingModeUri, true, mUserSettingObserver);
-        }
-
-        Log.d(mLogTag, sb.toString());
-    }
-
-    private Uri getUri(Uri uri, int subId) {
-        return Uri.withAppendedPath(uri, String.valueOf(subId));
-    }
-
-    void notifyCurrentSetting(Uri uri, boolean bForceUpdate) {
-        if (uri == null) {
-            return;
-        }
-        try {
-            String uriString = uri.getPath();
-            int subIndex = Integer.parseInt(uriString.substring(uriString.lastIndexOf('/') + 1));
-            int slotIndex = SubscriptionManager.getSlotIndex(subIndex);
-            int event = QNS_EVENT_BASE;
-
-            if (slotIndex == SubscriptionManager.INVALID_SIM_SLOT_INDEX) {
-                Log.e(mLogTag, "Invalid slot index: " + slotIndex);
-                return;
-            }
-
-            StringBuilder sb = new StringBuilder("notifyCurrentSetting");
-            sb.append(", bForceUpdate:").append(bForceUpdate);
-
-            Log.d(mLogTag, "CrossSimCallingUri:" + mCrossSimCallingUri);
-            Log.d(mLogTag, "mWfcEnabledUri:" + mWfcEnabledUri);
-            Log.d(mLogTag, "mWfcModeUri:" + mWfcModeUri);
-            Log.d(mLogTag, "mWfcRoamingEnabledUri:" + mWfcRoamingEnabledUri);
-            Log.d(mLogTag, "mWfcRoamingModeUri:" + mWfcRoamingModeUri);
-
-            if (uri.equals(mCrossSimCallingUri)) {
-                boolean isCrossSimCallingEnabled =
-                        QnsUtils.isCrossSimCallingEnabled(mQnsImsManager);
-                if (mLastCrossSimCallingEnabled != isCrossSimCallingEnabled || bForceUpdate) {
-                    if (isCrossSimCallingEnabled) {
-                        event = QNS_EVENT_CROSS_SIM_CALLING_ENABLED;
-                    } else {
-                        event = QNS_EVENT_CROSS_SIM_CALLING_DISABLED;
-                    }
-                    mLastCrossSimCallingEnabled = isCrossSimCallingEnabled;
-                    sb.append(", isCrossSimCallingEnabled:").append(isCrossSimCallingEnabled);
-                    Log.d(mLogTag, sb.toString());
-                    updateHandlers(event);
-                }
-            } else if (uri.equals(mWfcEnabledUri)) {
-                boolean isWfcEnabled =
-                        QnsUtils.isWfcEnabled(mQnsImsManager, mQnsProvisioningListener, false);
-                if (mLastWfcEnabled != isWfcEnabled || bForceUpdate) {
-                    if (isWfcEnabled) {
-                        event = QNS_EVENT_WFC_ENABLED;
-                    } else {
-                        event = QNS_EVENT_WFC_DISABLED;
-                    }
-                    mLastWfcEnabled = isWfcEnabled;
-                    sb.append(", isWfcEnabled:").append(isWfcEnabled);
-                    Log.d(mLogTag, sb.toString());
-                    updateHandlers(event);
-                }
-            } else if (uri.equals(mWfcModeUri)) {
-                int wfcMode = QnsUtils.getWfcMode(mQnsImsManager, false);
-                if (mLastWfcMode != wfcMode || bForceUpdate) {
-                    switch (wfcMode) {
-                        case WIFI_MODE_WIFI_ONLY:
-                            event = QNS_EVENT_WFC_MODE_TO_WIFI_ONLY;
-                            break;
-                        case WIFI_MODE_CELLULAR_PREFERRED:
-                            event = QNS_EVENT_WFC_MODE_TO_CELLULAR_PREFERRED;
-                            break;
-                        case WIFI_MODE_WIFI_PREFERRED:
-                            event = QNS_EVENT_WFC_MODE_TO_WIFI_PREFERRED;
-                            break;
-                    }
-                    mLastWfcMode = wfcMode;
-                    sb.append(", wfcMode:").append(wfcMode);
-                    Log.d(mLogTag, sb.toString());
-                    updateHandlers(event);
-                }
-            } else if (uri.equals(mWfcRoamingEnabledUri)) {
-                boolean isWfcRoamingEnabled =
-                        QnsUtils.isWfcEnabled(mQnsImsManager, mQnsProvisioningListener, true);
-                if (mLastWfcRoamingEnabled != isWfcRoamingEnabled || bForceUpdate) {
-                    if (isWfcRoamingEnabled) {
-                        event = QNS_EVENT_WFC_ROAMING_ENABLED;
-                    } else {
-                        event = QNS_EVENT_WFC_ROAMING_DISABLED;
-                    }
-                    mLastWfcRoamingEnabled = isWfcRoamingEnabled;
-                    sb.append(", isWfcRoamingEnabled:").append(isWfcRoamingEnabled);
-                    Log.d(mLogTag, sb.toString());
-                    updateHandlers(event);
-                }
-            } else if (uri.equals(mWfcRoamingModeUri)) {
-                int wfcModeRoaming = QnsUtils.getWfcMode(mQnsImsManager, true);
-                if (mLastWfcModeRoaming != wfcModeRoaming || bForceUpdate) {
-                    switch (wfcModeRoaming) {
-                        case WIFI_MODE_WIFI_ONLY:
-                            event = QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_ONLY;
-                            break;
-                        case WIFI_MODE_CELLULAR_PREFERRED:
-                            event = QNS_EVENT_WFC_ROAMING_MODE_TO_CELLULAR_PREFERRED;
-                            break;
-                        case WIFI_MODE_WIFI_PREFERRED:
-                            event = QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_PREFERRED;
-                            break;
-                    }
-                    mLastWfcModeRoaming = wfcModeRoaming;
-                    sb.append(", wfcModeRoaming:").append(wfcModeRoaming);
-                    Log.d(mLogTag, sb.toString());
-                    updateHandlers(event);
-                }
-            } else {
-                Log.e(mLogTag, "Unknown Uri : " + uri);
-            }
-        } catch (Exception e) {
-            Log.e(mLogTag, "notifyCurrentSetting got exception:" + e);
-            e.printStackTrace();
-        }
-    }
-
-    void notifyWfcEnabledByPlatform() {
-        boolean isWfcEnabledByPlatform = QnsUtils.isWfcEnabledByPlatform(mQnsImsManager);
-        if (mLastWfcEnabledByPlatform != isWfcEnabledByPlatform) {
-            mLastWfcEnabledByPlatform = isWfcEnabledByPlatform;
-            Log.d(mLogTag, "notifyWfcEnabledByPlatform:" + isWfcEnabledByPlatform);
-            if (isWfcEnabledByPlatform) {
-                updateHandlers(QNS_EVENT_WFC_PLATFORM_ENABLED);
-            } else {
-                updateHandlers(QNS_EVENT_WFC_PLATFORM_DISABLED);
-            }
-        }
-    }
-
-    private synchronized void updateHandler(Handler handler, int event) {
-        try {
-            if (mEventHandlers.get(event).contains(handler)) {
-                Log.d(mLogTag, "Updating handler for the event: " + event);
-                handler.obtainMessage(event).sendToTarget();
-            }
-        } catch (Exception e) {
-            Log.e(mLogTag, "updateHandler got exception e:" + e);
-        }
-    }
-
-    private synchronized void updateHandlers(int event) {
-        if (mEventHandlers.contains(event)) {
-            Log.d(mLogTag, "Updating handlers for the event: " + event);
-            for (Handler handler : mEventHandlers.get(event)) {
-                handler.obtainMessage(event).sendToTarget();
-            }
-        }
-    }
-
-    @VisibleForTesting
-    class UserSettingObserver extends ContentObserver {
-        UserSettingObserver(Handler h) {
-            super(h);
-        }
-
-        @Override
-        public void onChange(boolean selfChange, Uri uri) {
-            Log.d(mLogTag, "onUserSettingChanged");
-            onUserSettingChanged(uri);
-        }
-    }
-
-    private synchronized void onUserSettingChanged(Uri uri) {
-        if (mCrossSimCallingUri.equals(uri)) {
-            notifyCurrentSetting(uri, false);
-        } else if (mWfcEnabledUri.equals(uri)) {
-            // checks platform changes first.
-            notifyWfcEnabledByPlatform();
-
-            notifyCurrentSetting(uri, false);
-        } else if (mWfcModeUri.equals(uri)) {
-            notifyCurrentSetting(uri, false);
-        } else if (mWfcRoamingEnabledUri.equals(uri)) {
-            // checks platform changes first.
-            notifyWfcEnabledByPlatform();
-
-            notifyCurrentSetting(uri, false);
-        } else if (mWfcRoamingModeUri.equals(uri)) {
-            notifyCurrentSetting(uri, false);
-        }
-    }
-
-    private class QnsEventDispatcherHandler extends Handler {
-        /**
-         * Use the provided {@link Looper} instead of the default one.
-         *
-         * @param looper The looper, must not be null.
-         */
-        QnsEventDispatcherHandler(Looper looper) {
-            super(looper);
-        }
-
-        @Override
-        public void handleMessage(Message message) {
-            Log.d(mLogTag, "handleMessage msg=" + message.what);
-            QnsAsyncResult ar = (QnsAsyncResult) message.obj;
-            switch (message.what) {
-                case EVENT_PROVISIONING_INFO_CHANGED:
-                    onProvisioningInfoChanged(
-                            (QnsProvisioningListener.QnsProvisioningInfo) ar.mResult);
-                    break;
-                default:
-                    break;
-            }
-        }
-    }
-
-    private synchronized void onProvisioningInfoChanged(
-            QnsProvisioningListener.QnsProvisioningInfo info) {
-
-        Log.d(mLogTag, "onProvisioningInfoChanged info:" + info);
-
-        if (!info.equalsIntegerItem(
-                mLastProvisioningInfo,
-                ProvisioningManager.KEY_VOICE_OVER_WIFI_ROAMING_ENABLED_OVERRIDE)) {
-            Log.d(
-                    mLogTag,
-                    "onProvisioningInfoChanged, KEY_VOICE_OVER_WIFI_ROAMING_ENABLED_OVERRIDE("
-                            + ProvisioningManager.KEY_VOICE_OVER_WIFI_ROAMING_ENABLED_OVERRIDE
-                            + ") is provisioned to "
-                            + info.getIntegerItem(
-                                    ProvisioningManager
-                                            .KEY_VOICE_OVER_WIFI_ROAMING_ENABLED_OVERRIDE));
-            // checks platform changes first.
-            notifyWfcEnabledByPlatform();
-            notifyCurrentSetting(mWfcRoamingEnabledUri, false);
-        }
-        if (!info.equalsIntegerItem(
-                mLastProvisioningInfo, ProvisioningManager.KEY_VOICE_OVER_WIFI_MODE_OVERRIDE)) {
-            Log.d(
-                    mLogTag,
-                    "onProvisioningInfoChanged, KEY_VOICE_OVER_WIFI_MODE_OVERRIDE("
-                            + ProvisioningManager.KEY_VOICE_OVER_WIFI_MODE_OVERRIDE
-                            + ") is provisioned to "
-                            + info.getIntegerItem(
-                                    ProvisioningManager.KEY_VOICE_OVER_WIFI_MODE_OVERRIDE));
-            notifyCurrentSetting(mWfcModeUri, false);
-        }
-        if (!info.equalsIntegerItem(
-                mLastProvisioningInfo, ProvisioningManager.KEY_VOICE_OVER_WIFI_ENABLED_OVERRIDE)) {
-            Log.d(
-                    mLogTag,
-                    "onProvisioningInfoChanged, KEY_VOICE_OVER_WIFI_ENABLED_OVERRIDE("
-                            + ProvisioningManager.KEY_VOICE_OVER_WIFI_ENABLED_OVERRIDE
-                            + ") is provisioned to "
-                            + info.getIntegerItem(
-                                    ProvisioningManager.KEY_VOICE_OVER_WIFI_ENABLED_OVERRIDE));
-            // checks platform changes first.
-            notifyWfcEnabledByPlatform();
-            notifyCurrentSetting(mWfcEnabledUri, false);
-        }
-
-        mLastProvisioningInfo = info;
-    }
-
-    boolean isAirplaneModeToggleOn() {
-        return sIsAirplaneModeOn;
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsImsManager.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsImsManager.java
deleted file mode 100644
index 6a7c0c6..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsImsManager.java
+++ /dev/null
@@ -1,1111 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.telephony.qns;
-
-import static android.telephony.ims.feature.MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE;
-import static android.telephony.ims.stub.ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN;
-import static android.telephony.ims.stub.ImsRegistrationImplBase.REGISTRATION_TECH_LTE;
-
-import android.content.Context;
-import android.content.pm.PackageManager;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.PersistableBundle;
-import android.os.SystemProperties;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.CarrierConfigManager;
-import android.telephony.SubscriptionManager;
-import android.telephony.TelephonyManager;
-import android.telephony.ims.ImsException;
-import android.telephony.ims.ImsManager;
-import android.telephony.ims.ImsMmTelManager;
-import android.telephony.ims.ImsRcsManager;
-import android.telephony.ims.ImsReasonInfo;
-import android.telephony.ims.ImsRegistrationAttributes;
-import android.telephony.ims.ImsStateCallback;
-import android.telephony.ims.ProvisioningManager;
-import android.telephony.ims.RegistrationManager;
-import android.telephony.ims.SipDelegateManager;
-import android.telephony.ims.SipDialogState;
-import android.telephony.ims.SipDialogStateCallback;
-import android.telephony.ims.feature.ImsFeature;
-import android.util.Log;
-
-import androidx.annotation.NonNull;
-
-import com.android.internal.annotations.VisibleForTesting;
-
-import java.util.List;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.Consumer;
-
-/**
- * QnsImsManager is helper class to get wi-fi calling related items from ImsManager
- *
- * @hide
- */
-class QnsImsManager {
-
-    static final String PROP_DBG_WFC_AVAIL_OVERRIDE = "persist.dbg.wfc_avail_ovr";
-
-    private static final int SYS_PROP_NOT_SET = -1;
-
-    private final String mLogTag;
-    private final Context mContext;
-    private final int mSlotId;
-    private final Executor mExecutor;
-    private final Handler mHandler;
-    private final HandlerThread mHandlerThread;
-    private int mSubId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
-    private final SubscriptionManager mSubscriptionManager;
-    private boolean mQnsImsManagerInitialized;
-    private CarrierConfigManager mConfigManager;
-    private ImsManager mImsManager;
-    private ImsMmTelManager mImsMmTelManager;
-    private ImsRcsManager mImsRcsManager;
-    private SipDelegateManager mSipDelegateManager;
-    QnsImsStateCallback mMmTelStateCallback;
-    QnsImsStateCallback mRcsStateCallback;
-    QnsImsRegistrationCallback mMmtelImsRegistrationCallback;
-    QnsImsRegistrationCallback mRcsImsRegistrationCallback;
-    QnsSipDialogStateCallback mRcsSipDialogSessionStateCallback;
-
-    final QnsRegistrantList mMmTelImsStateListener;
-    final QnsRegistrantList mRcsImsStateListener;
-    final QnsRegistrantList mMmTelImsRegistrationListener;
-    final QnsRegistrantList mRcsImsRegistrationListener;
-    final QnsRegistrantList mRcsSipDialogSessionStateListener;
-
-    @VisibleForTesting
-    final SubscriptionManager.OnSubscriptionsChangedListener mSubscriptionsChangeListener;
-
-    /** QnsImsManager default constructor */
-    QnsImsManager(Context context, int slotId) {
-        mSlotId = slotId;
-        mLogTag = QnsImsManager.class.getSimpleName() + "_" + mSlotId;
-        mContext = context;
-        mExecutor = new QnsImsManagerExecutor();
-
-        mHandlerThread = new HandlerThread(mLogTag);
-        mHandlerThread.start();
-        mHandler = new Handler(mHandlerThread.getLooper());
-
-        mMmTelImsStateListener = new QnsRegistrantList();
-        mRcsImsStateListener = new QnsRegistrantList();
-        mMmTelImsRegistrationListener = new QnsRegistrantList();
-        mRcsImsRegistrationListener = new QnsRegistrantList();
-        mRcsSipDialogSessionStateListener = new QnsRegistrantList();
-
-        initQnsImsManager();
-
-        mSubscriptionManager = mContext.getSystemService(SubscriptionManager.class);
-        mSubscriptionsChangeListener = new QnsSubscriptionsChangedListener();
-        if (mSubscriptionManager != null) {
-            mSubscriptionManager.addOnSubscriptionsChangedListener(
-                    new QnsUtils.QnsExecutor(mHandler), mSubscriptionsChangeListener);
-        }
-    }
-
-    class QnsSubscriptionsChangedListener
-            extends SubscriptionManager.OnSubscriptionsChangedListener {
-
-        /**
-         * Callback invoked when there is any change to any SubscriptionInfo.
-         */
-        @Override
-        public void onSubscriptionsChanged() {
-            int newSubId = QnsUtils.getSubId(mContext, mSlotId);
-            if (newSubId != mSubId) {
-                mSubId = newSubId;
-                if (mSubId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
-                    clearQnsImsManager();
-                } else {
-                    clearQnsImsManager();
-                    initQnsImsManager();
-                }
-            }
-        }
-    }
-
-    @VisibleForTesting
-    protected synchronized void initQnsImsManager() {
-        if (mQnsImsManagerInitialized) {
-            return;
-        }
-        log("initQnsImsManager.");
-
-        if (mConfigManager == null) {
-            mConfigManager = mContext.getSystemService(CarrierConfigManager.class);
-            if (mConfigManager == null) {
-                loge("initQnsImsManager: couldn't initialize. failed to get CarrierConfigManager.");
-                clearQnsImsManager();
-                return;
-            }
-        }
-
-        if (mImsManager == null) {
-            mImsManager = mContext.getSystemService(ImsManager.class);
-            if (mImsManager == null) {
-                loge("initQnsImsManager: couldn't initialize. failed to get ImsManager.");
-                clearQnsImsManager();
-                return;
-            }
-        }
-
-        int subId = getSubId();
-        if (!SubscriptionManager.isValidSubscriptionId(subId)) {
-            return;
-        }
-
-        mImsMmTelManager = mImsManager.getImsMmTelManager(subId);
-        if (mImsMmTelManager == null) {
-            loge("initQnsImsManager: couldn't initialize. failed to get ImsMmTelManager.");
-            clearQnsImsManager();
-            return;
-        }
-
-        mImsRcsManager = mImsManager.getImsRcsManager(subId);
-        if (mImsRcsManager == null) {
-            loge("initQnsImsManager: couldn't initialize. failed to get ImsRcsManager.");
-            clearQnsImsManager();
-            return;
-        }
-
-        mSipDelegateManager = mImsManager.getSipDelegateManager(subId);
-        if (mSipDelegateManager == null) {
-            loge("initQnsImsManager: couldn't initialize. failed to get mSipDelegateManager.");
-            clearQnsImsManager();
-            return;
-        }
-
-        mQnsImsManagerInitialized = true;
-
-        startTrackingImsState(ImsFeature.FEATURE_MMTEL);
-        startTrackingImsState(ImsFeature.FEATURE_RCS);
-        startTrackingImsRegistration(ImsFeature.FEATURE_MMTEL);
-        startTrackingImsRegistration(ImsFeature.FEATURE_RCS);
-        startTrackingSipDialogSessionState(ImsFeature.FEATURE_RCS);
-    }
-
-    @VisibleForTesting
-    protected synchronized void startTrackingImsState(int feature) {
-        if (feature == ImsFeature.FEATURE_MMTEL
-                && mImsMmTelManager != null
-                && mMmTelStateCallback == null) {
-            try {
-                QnsImsStateCallback imsStateCallback = new QnsImsStateCallback(feature);
-                mImsMmTelManager.registerImsStateCallback(mExecutor, imsStateCallback);
-                log("startTrackingImsState: registered ImsFeature.MMTEL State Callback.");
-                mMmTelStateCallback = imsStateCallback;
-            } catch (ImsException e) {
-                loge("startTrackingImsState: couldn't register MMTEL state callback, " + e);
-            }
-        }
-
-        if (feature == ImsFeature.FEATURE_RCS
-                && mImsRcsManager != null
-                && mRcsStateCallback == null) {
-            try {
-                QnsImsStateCallback rcsStateCallback = new QnsImsStateCallback(feature);
-                mImsRcsManager.registerImsStateCallback(mExecutor, rcsStateCallback);
-                log("startTrackingImsState: registered ImsFeature.RCS State Callback.");
-                mRcsStateCallback = rcsStateCallback;
-            } catch (ImsException e) {
-                loge("startTrackingImsState: couldn't register RCS state callback, " + e);
-            }
-        }
-    }
-
-    @VisibleForTesting
-    protected synchronized void startTrackingImsRegistration(int feature) {
-        if (feature == ImsFeature.FEATURE_MMTEL
-                && mImsMmTelManager != null
-                && mMmtelImsRegistrationCallback == null) {
-            try {
-                QnsImsRegistrationCallback imsRegistrationCallback =
-                        new QnsImsRegistrationCallback(feature);
-                mImsMmTelManager.registerImsRegistrationCallback(
-                        mExecutor, imsRegistrationCallback);
-                log("startTrackingImsRegistration: registered MMTEL registration callback");
-                mMmtelImsRegistrationCallback = imsRegistrationCallback;
-            } catch (ImsException e) {
-                loge("registerImsRegistrationCallback: couldn't register MMTEL callback, " + e);
-            }
-        }
-
-        if (feature == ImsFeature.FEATURE_RCS
-                && mImsRcsManager != null
-                && mRcsImsRegistrationCallback == null) {
-            try {
-                QnsImsRegistrationCallback rcsRegistrationCallback =
-                        new QnsImsRegistrationCallback(feature);
-                mImsRcsManager.registerImsRegistrationCallback(mExecutor, rcsRegistrationCallback);
-                log("startTrackingImsRegistration: registered RCS registration callback");
-                mRcsImsRegistrationCallback = rcsRegistrationCallback;
-            } catch (ImsException e) {
-                loge("startTrackingImsRegistration: couldn't register RCS callback, " + e);
-            }
-        }
-    }
-
-    @VisibleForTesting
-    protected synchronized void startTrackingSipDialogSessionState(int feature) {
-        if (feature == ImsFeature.FEATURE_RCS
-                && mImsRcsManager != null
-                && mRcsStateCallback != null
-                && mRcsStateCallback.isImsAvailable()
-                && mRcsSipDialogSessionStateCallback == null) {
-            try {
-                QnsSipDialogStateCallback rcsSipDialogStateCallback =
-                        new QnsSipDialogStateCallback();
-                mSipDelegateManager.registerSipDialogStateCallback(
-                        mExecutor, rcsSipDialogStateCallback);
-                log("startTrackingSipDialogSessionState: registered SipDialogState callback.");
-                mRcsSipDialogSessionStateCallback = rcsSipDialogStateCallback;
-            } catch (ImsException e) {
-                loge("startTrackingSipDialogSessionState: couldn't register callback, " + e);
-            } catch (UnsupportedOperationException e) {
-                loge("registerSipDialogStateCallback: couldn't register callback, " + e);
-            }
-        }
-    }
-
-    protected synchronized void stopTrackingImsState(int feature) {
-        if (feature == ImsFeature.FEATURE_MMTEL
-                && mImsMmTelManager != null
-                && mMmTelStateCallback != null) {
-            try {
-                mImsMmTelManager.unregisterImsStateCallback(mMmTelStateCallback);
-            } catch (Exception e) {
-                // do-nothing
-            }
-        }
-        if (feature == ImsFeature.FEATURE_RCS
-                && mImsRcsManager != null
-                && mRcsStateCallback != null) {
-            try {
-                mImsRcsManager.unregisterImsStateCallback(mRcsStateCallback);
-            } catch (Exception e) {
-                // do-nothing
-            }
-        }
-    }
-
-    protected synchronized void stopTrackingImsRegistration(int feature) {
-        if (feature == ImsFeature.FEATURE_MMTEL
-                && mImsMmTelManager != null
-                && mMmtelImsRegistrationCallback != null) {
-            try {
-                mImsMmTelManager.unregisterImsRegistrationCallback(mMmtelImsRegistrationCallback);
-            } catch (Exception e) {
-                // do-nothing
-            }
-        }
-        if (feature == ImsFeature.FEATURE_RCS
-                && mImsRcsManager != null
-                && mRcsImsRegistrationCallback != null) {
-            try {
-                mImsRcsManager.unregisterImsRegistrationCallback(mRcsImsRegistrationCallback);
-            } catch (Exception e) {
-                // do-nothing
-            }
-        }
-    }
-
-    protected synchronized void stopTrackingSipDialogSessionState(int feature) {
-        if (feature == ImsFeature.FEATURE_RCS
-                && mSipDelegateManager != null
-                && mRcsSipDialogSessionStateCallback != null) {
-            try {
-                mSipDelegateManager.unregisterSipDialogStateCallback(
-                        mRcsSipDialogSessionStateCallback);
-            } catch (Exception e) {
-                // do-nothing
-            }
-        }
-    }
-
-    @VisibleForTesting
-    protected synchronized void clearQnsImsManager() {
-        log("clearQnsImsManager");
-
-        stopTrackingImsState(ImsFeature.FEATURE_MMTEL);
-        stopTrackingImsState(ImsFeature.FEATURE_RCS);
-        stopTrackingImsRegistration(ImsFeature.FEATURE_MMTEL);
-        stopTrackingImsRegistration(ImsFeature.FEATURE_RCS);
-        stopTrackingSipDialogSessionState(ImsFeature.FEATURE_RCS);
-
-        mImsManager = null;
-        mImsMmTelManager = null;
-        mImsRcsManager = null;
-        mSipDelegateManager = null;
-        mMmTelStateCallback = null;
-        mMmtelImsRegistrationCallback = null;
-        mRcsStateCallback = null;
-        mRcsImsRegistrationCallback = null;
-        mRcsSipDialogSessionStateCallback = null;
-        mQnsImsManagerInitialized = false;
-    }
-
-    @VisibleForTesting
-    protected synchronized void close() {
-        if (mSubscriptionManager != null) {
-            mSubscriptionManager.removeOnSubscriptionsChangedListener(mSubscriptionsChangeListener);
-        }
-        mHandlerThread.quitSafely();
-        clearQnsImsManager();
-
-        mMmTelImsStateListener.removeAll();
-        mRcsImsStateListener.removeAll();
-        mMmTelImsRegistrationListener.removeAll();
-        mRcsImsRegistrationListener.removeAll();
-        mRcsSipDialogSessionStateListener.removeAll();
-    }
-
-    int getSlotIndex() {
-        return mSlotId;
-    }
-
-    private synchronized ImsMmTelManager getImsMmTelManagerOrThrowExceptionIfNotReady()
-            throws ImsException {
-        initQnsImsManager();
-        if (mImsManager == null || mImsMmTelManager == null || mMmTelStateCallback == null) {
-            throw new ImsException(
-                    "IMS service is down.", ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
-        }
-        return mImsMmTelManager;
-    }
-
-    /**
-     * Get the boolean config from carrier config manager.
-     *
-     * @param key config key defined in CarrierConfigManager
-     * @return boolean value of corresponding key.
-     */
-    private boolean getBooleanCarrierConfig(String key) {
-        PersistableBundle b = null;
-        if (mConfigManager != null) {
-            // If an invalid subId is used, this bundle will contain default values.
-            b = mConfigManager.getConfigForSubId(getSubId());
-        }
-        if (b != null) {
-            return b.getBoolean(key);
-        } else {
-            // Return static default defined in CarrierConfigManager.
-            return CarrierConfigManager.getDefaultConfig().getBoolean(key);
-        }
-    }
-
-    /**
-     * Get the int config from carrier config manager.
-     *
-     * @param key config key defined in CarrierConfigManager
-     * @return integer value of corresponding key.
-     */
-    private int getIntCarrierConfig(String key) {
-        PersistableBundle b = null;
-        if (mConfigManager != null) {
-            // If an invalid subId is used, this bundle will contain default values.
-            b = mConfigManager.getConfigForSubId(getSubId());
-        }
-        if (b != null) {
-            return b.getInt(key);
-        } else {
-            // Return static default defined in CarrierConfigManager.
-            return CarrierConfigManager.getDefaultConfig().getInt(key);
-        }
-    }
-
-    private boolean isCrossSimCallingEnabledByUser() {
-        boolean crossSimCallingEnabled;
-        try {
-            ImsMmTelManager mmTelManager = getImsMmTelManagerOrThrowExceptionIfNotReady();
-            crossSimCallingEnabled = mmTelManager.isCrossSimCallingEnabled();
-        } catch (Exception e) {
-            crossSimCallingEnabled = false;
-        }
-        log("isCrossSimCallingEnabledByUser:" + crossSimCallingEnabled);
-        return crossSimCallingEnabled;
-    }
-
-    private boolean isGbaValid() {
-        if (getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_IMS_GBA_REQUIRED_BOOL)) {
-            TelephonyManager tm = mContext.getSystemService(TelephonyManager.class);
-            if (tm == null) {
-                loge("isGbaValid: TelephonyManager is null, returning false.");
-                return false;
-            }
-            tm = tm.createForSubscriptionId(getSubId());
-            String efIst = tm.getIsimIst();
-            if (efIst == null) {
-                loge("isGbaValid - ISF is NULL");
-                return true;
-            }
-            boolean result = efIst.length() > 1 && (0x02 & (byte) efIst.charAt(1)) != 0;
-            log("isGbaValid - GBA capable=" + result + ", ISF=" + efIst);
-            return result;
-        }
-        return true;
-    }
-
-    private boolean isCrossSimEnabledByPlatform() {
-        if (isWfcEnabledByPlatform()) {
-            return getBooleanCarrierConfig(
-                    CarrierConfigManager.KEY_CARRIER_CROSS_SIM_IMS_AVAILABLE_BOOL);
-        }
-        return false;
-    }
-
-    private boolean isVolteProvisionedOnDevice() {
-        if (isMmTelProvisioningRequired(REGISTRATION_TECH_LTE)) {
-            return isVolteProvisioned();
-        }
-
-        return true;
-    }
-
-    private boolean isVolteProvisioned() {
-        return getImsProvisionedBoolNoException(REGISTRATION_TECH_LTE);
-    }
-
-    private boolean isWfcProvisioned() {
-        return getImsProvisionedBoolNoException(REGISTRATION_TECH_IWLAN);
-    }
-
-    private boolean isMmTelProvisioningRequired(int tech) {
-        if (!SubscriptionManager.isValidSubscriptionId(getSubId())) {
-            return false;
-        }
-
-        boolean required = false;
-        try {
-            ProvisioningManager p = ProvisioningManager.createForSubscriptionId(getSubId());
-            required = p.isProvisioningRequiredForCapability(CAPABILITY_TYPE_VOICE, tech);
-        } catch (RuntimeException e) {
-            loge("isMmTelProvisioningRequired, tech:" + tech + ". e:" + e);
-        }
-
-        log("isMmTelProvisioningRequired " + required + " for tech:" + tech);
-        return required;
-    }
-
-    private boolean getImsProvisionedBoolNoException(int tech) {
-        if (!SubscriptionManager.isValidSubscriptionId(getSubId())) {
-            return false;
-        }
-
-        boolean status = false;
-        try {
-            ProvisioningManager p = ProvisioningManager.createForSubscriptionId(getSubId());
-            status = p.getProvisioningStatusForCapability(CAPABILITY_TYPE_VOICE, tech);
-        } catch (RuntimeException e) {
-            loge("getImsProvisionedBoolNoException, tech:" + tech + ". e:" + e);
-        }
-
-        log("getImsProvisionedBoolNoException " + status + " for tech:" + tech);
-        return status;
-    }
-
-    private int getSubId() {
-        return QnsUtils.getSubId(mContext, mSlotId);
-    }
-
-    private static class QnsImsManagerExecutor implements Executor {
-        private Executor mExecutor;
-
-        @Override
-        public void execute(Runnable runnable) {
-            startExecutorIfNeeded();
-            mExecutor.execute(runnable);
-        }
-
-        private synchronized void startExecutorIfNeeded() {
-            if (mExecutor != null) return;
-            mExecutor = Executors.newSingleThreadExecutor();
-        }
-    }
-
-    private class QnsImsStateCallback extends ImsStateCallback {
-        int mImsFeature;
-        boolean mImsAvailable;
-
-        public boolean isImsAvailable() {
-            return mImsAvailable;
-        }
-
-        QnsImsStateCallback(int imsFeature) {
-            mImsFeature = imsFeature;
-        }
-
-        @Override
-        public void onUnavailable(int reason) {
-            changeImsState(false);
-        }
-
-        @Override
-        public void onAvailable() {
-            changeImsState(true);
-        }
-
-        @Override
-        public void onError() {
-            changeImsState(false);
-        }
-
-        private void changeImsState(boolean imsAvailable) {
-            if (mImsAvailable != imsAvailable) {
-                mImsAvailable = imsAvailable;
-                onImsStateChanged(mImsFeature, imsAvailable);
-            }
-        }
-    }
-
-    /** class for the IMS State. */
-    static class ImsState {
-        private final boolean mImsAvailable;
-
-        ImsState(boolean imsAvailable) {
-            mImsAvailable = imsAvailable;
-        }
-
-        boolean isImsAvailable() {
-            return mImsAvailable;
-        }
-    }
-
-    private void onImsStateChanged(int imsFeature, boolean imsAvailable) {
-        if (imsFeature == ImsFeature.FEATURE_MMTEL) {
-            log("onImsStateChanged ImsFeature.MMTEL:" + imsAvailable);
-        }
-        if (imsFeature == ImsFeature.FEATURE_RCS) {
-            log("onImsStateChanged ImsFeature.RCS:" + imsAvailable);
-        }
-
-        if (imsAvailable) {
-            startTrackingImsRegistration(imsFeature);
-            if (imsFeature == ImsFeature.FEATURE_RCS) {
-                startTrackingSipDialogSessionState(imsFeature);
-            }
-        }
-
-        ImsState imsState = new ImsState(imsAvailable);
-        notifyImsStateChanged(imsFeature, imsState);
-    }
-
-    /**
-     * Registers to monitor Ims State
-     *
-     * @param h Handler to get an event
-     * @param what message id.
-     */
-    void registerImsStateChanged(Handler h, int what) {
-        QnsRegistrant r = new QnsRegistrant(h, what, null);
-        mMmTelImsStateListener.add(r);
-    }
-
-    /**
-     * Unregisters ims state for given handler.
-     *
-     * @param h Handler
-     */
-    void unregisterImsStateChanged(Handler h) {
-        mMmTelImsStateListener.remove(h);
-    }
-
-    /**
-     * Registers to monitor Rcs State
-     *
-     * @param h Handler to get an event
-     * @param what message id.
-     */
-    void registerRcsStateChanged(Handler h, int what) {
-        QnsRegistrant r = new QnsRegistrant(h, what, null);
-        mRcsImsStateListener.add(r);
-    }
-
-    /**
-     * Unregisters rcs state for given handler.
-     *
-     * @param h Handler
-     */
-    void unregisterRcsStateChanged(Handler h) {
-        mRcsImsStateListener.remove(h);
-    }
-
-    protected void notifyImsStateChanged(int imsFeature, ImsState imsState) {
-        if (imsFeature == ImsFeature.FEATURE_MMTEL) {
-            mMmTelImsStateListener.notifyResult(imsState);
-        } else if (imsFeature == ImsFeature.FEATURE_RCS) {
-            mRcsImsStateListener.notifyResult(imsState);
-        }
-    }
-
-    private static class StateConsumer extends Semaphore implements Consumer<Integer> {
-        private static final long TIMEOUT_MILLIS = 2000;
-
-        StateConsumer() {
-            super(0);
-            mValue = new AtomicInteger();
-        }
-
-        private final AtomicInteger mValue;
-
-        int getOrTimeOut() throws InterruptedException {
-            if (tryAcquire(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) {
-                return mValue.get();
-            }
-            return ImsFeature.STATE_UNAVAILABLE;
-        }
-
-        public void accept(Integer value) {
-            if (value != null) {
-                mValue.set(value);
-            }
-            release();
-        }
-    }
-
-    private class QnsImsRegistrationCallback extends RegistrationManager.RegistrationCallback {
-        int mImsFeature;
-        ImsRegistrationState mImsRegistrationState;
-
-        QnsImsRegistrationCallback(int imsFeature) {
-            mImsFeature = imsFeature;
-            mImsRegistrationState = null;
-        }
-
-        @Override
-        public void onRegistered(ImsRegistrationAttributes attribute) {
-            int transportType = attribute.getTransportType();
-            log("on IMS registered on :" + QnsConstants.transportTypeToString(transportType));
-            mImsRegistrationState =
-                    new ImsRegistrationState(
-                            QnsConstants.IMS_REGISTRATION_CHANGED_REGISTERED, transportType, null);
-            notifyImsRegistrationChangedEvent(
-                    mImsFeature, new ImsRegistrationState(mImsRegistrationState));
-        }
-
-        @Override
-        public void onTechnologyChangeFailed(int transportType, ImsReasonInfo reason) {
-            log(
-                    "onTechnologyChangeFailed["
-                            + QnsConstants.transportTypeToString(transportType)
-                            + "] "
-                            + reason.toString());
-            mImsRegistrationState =
-                    new ImsRegistrationState(
-                            QnsConstants.IMS_REGISTRATION_CHANGED_ACCESS_NETWORK_CHANGE_FAILED,
-                            transportType,
-                            reason);
-            notifyImsRegistrationChangedEvent(
-                    mImsFeature, new ImsRegistrationState(mImsRegistrationState));
-        }
-
-        @Override
-        public void onUnregistered(ImsReasonInfo reason) {
-            log("onUnregistered " + reason.toString());
-            mImsRegistrationState =
-                    new ImsRegistrationState(
-                            QnsConstants.IMS_REGISTRATION_CHANGED_UNREGISTERED,
-                            AccessNetworkConstants.TRANSPORT_TYPE_INVALID,
-                            reason);
-            notifyImsRegistrationChangedEvent(
-                    mImsFeature, new ImsRegistrationState(mImsRegistrationState));
-        }
-    }
-
-    private class QnsSipDialogStateCallback extends SipDialogStateCallback {
-        boolean mIsActive;
-
-        public boolean isActive() {
-            return mIsActive;
-        }
-
-        @Override
-        public void onActiveSipDialogsChanged(@NonNull List<SipDialogState> dialogs) {
-            for (SipDialogState state : dialogs) {
-                if (state.getState() == SipDialogState.STATE_CONFIRMED) {
-                    if (!mIsActive) {
-                        mIsActive = true;
-                        notifySipDialogSessionStateChanged(mIsActive);
-                    }
-                    return;
-                }
-            }
-            if (mIsActive) {
-                mIsActive = false;
-                notifySipDialogSessionStateChanged(mIsActive);
-            }
-        }
-
-        @Override
-        public void onError() {
-            mIsActive = false;
-            notifySipDialogSessionStateChanged(mIsActive);
-            // TODO do nothing?
-        }
-    }
-
-    /** State class for the IMS Registration. */
-    static class ImsRegistrationState {
-        @QnsConstants.QnsImsRegiEvent private final int mEvent;
-        private final int mTransportType;
-        private final ImsReasonInfo mReasonInfo;
-
-        ImsRegistrationState(int event, int transportType, ImsReasonInfo reason) {
-            mEvent = event;
-            mTransportType = transportType;
-            mReasonInfo = reason;
-        }
-
-        ImsRegistrationState(ImsRegistrationState state) {
-            mEvent = state.mEvent;
-            mTransportType = state.mTransportType;
-            mReasonInfo = state.mReasonInfo;
-        }
-
-        int getEvent() {
-            return mEvent;
-        }
-
-        int getTransportType() {
-            return mTransportType;
-        }
-
-        ImsReasonInfo getReasonInfo() {
-            return mReasonInfo;
-        }
-
-        @Override
-        public String toString() {
-            String reason = getReasonInfo() == null ? "null" : mReasonInfo.toString();
-            String event = Integer.toString(mEvent);
-            switch (mEvent) {
-                case QnsConstants.IMS_REGISTRATION_CHANGED_REGISTERED:
-                    event = "IMS_REGISTERED";
-                    break;
-                case QnsConstants.IMS_REGISTRATION_CHANGED_UNREGISTERED:
-                    event = "IMS_UNREGISTERED";
-                    break;
-                case QnsConstants.IMS_REGISTRATION_CHANGED_ACCESS_NETWORK_CHANGE_FAILED:
-                    event = "IMS_ACCESS_NETWORK_CHANGE_FAILED";
-                    break;
-            }
-            return "ImsRegistrationState["
-                    + QnsConstants.transportTypeToString(mTransportType)
-                    + "] "
-                    + "Event:"
-                    + event
-                    + " reason:"
-                    + reason;
-        }
-    }
-
-    /**
-     * Get the status of whether the IMS is registered or not for given transport type
-     *
-     * @param transportType Transport Type
-     * @return true when ims is registered.
-     */
-    boolean isImsRegistered(int transportType) {
-        if (mMmtelImsRegistrationCallback == null) {
-            return false;
-        }
-        ImsRegistrationState state = mMmtelImsRegistrationCallback.mImsRegistrationState;
-        return state != null
-                && state.getTransportType() == transportType
-                && state.getEvent() == QnsConstants.IMS_REGISTRATION_CHANGED_REGISTERED;
-    }
-
-    /**
-     * Get the status of whether the Rcs is registered or not for given transport type
-     *
-     * @param transportType Transport Type
-     * @return true when ims is registered.
-     */
-    boolean isRcsRegistered(int transportType) {
-        if (mRcsImsRegistrationCallback == null) {
-            return false;
-        }
-        ImsRegistrationState state = mRcsImsRegistrationCallback.mImsRegistrationState;
-        return state != null
-                && state.getTransportType() == transportType
-                && state.getEvent() == QnsConstants.IMS_REGISTRATION_CHANGED_REGISTERED;
-    }
-
-    /**
-     * Registers to monitor Ims registration status
-     *
-     * @param h Handler to get an event
-     * @param what message id.
-     */
-    void registerImsRegistrationStatusChanged(Handler h, int what) {
-        QnsRegistrant r = new QnsRegistrant(h, what, null);
-        mMmTelImsRegistrationListener.add(r);
-    }
-
-    /**
-     * Unregisters ims registration status for given handler.
-     *
-     * @param h Handler
-     */
-    void unregisterImsRegistrationStatusChanged(Handler h) {
-        mMmTelImsRegistrationListener.remove(h);
-    }
-
-    /**
-     * Registers to monitor Ims registration status
-     *
-     * @param h Handler to get an event
-     * @param what message id.
-     */
-    void registerRcsRegistrationStatusChanged(Handler h, int what) {
-        QnsRegistrant r = new QnsRegistrant(h, what, null);
-        mRcsImsRegistrationListener.add(r);
-    }
-
-    /**
-     * Unregisters ims registration status for given handler.
-     *
-     * @param h Handler
-     */
-    void unregisterRcsRegistrationStatusChanged(Handler h) {
-        mRcsImsRegistrationListener.remove(h);
-    }
-
-    @VisibleForTesting
-    protected void notifyImsRegistrationChangedEvent(int imsFeature, ImsRegistrationState state) {
-        if (imsFeature == ImsFeature.FEATURE_MMTEL) {
-            mMmTelImsRegistrationListener.notifyResult(state);
-        } else if (imsFeature == ImsFeature.FEATURE_RCS) {
-            mRcsImsRegistrationListener.notifyResult(state);
-        }
-    }
-
-    /**
-     * Get the active status of SipDialogState
-     *
-     * @return true when one of Sip Dialogs is active.
-     */
-    boolean isSipDialogSessionActive() {
-        return mRcsSipDialogSessionStateCallback != null
-                && mRcsSipDialogSessionStateCallback.isActive();
-    }
-
-    /**
-     * Registers to monitor SipDialogSession State
-     *
-     * @param h Handler to get an event
-     * @param what message id.
-     */
-    void registerSipDialogSessionStateChanged(Handler h, int what) {
-        QnsRegistrant r = new QnsRegistrant(h, what, null);
-        mRcsSipDialogSessionStateListener.add(r);
-    }
-
-    /**
-     * Unregisters SipDialogState status for given handler.
-     *
-     * @param h Handler
-     */
-    void unregisterSipDialogSessionStateChanged(Handler h) {
-        mRcsSipDialogSessionStateListener.remove(h);
-    }
-
-    @VisibleForTesting
-    protected void notifySipDialogSessionStateChanged(boolean isActive) {
-        mRcsSipDialogSessionStateListener.notifyResult(isActive);
-    }
-
-    private static boolean isImsSupportedOnDevice(Context context) {
-        return context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_TELEPHONY_IMS);
-    }
-
-    /**
-     * Get the status of the MmTel Feature corresponding to this subscription.
-     *
-     * <p>This function is a blocking function and there may be a timeout of up to 2 seconds.
-     *
-     * @return MmTel Feature Status. Returns one of the following: {@link
-     *     ImsFeature#STATE_UNAVAILABLE}, {@link ImsFeature#STATE_INITIALIZING}, {@link
-     *     ImsFeature#STATE_READY}.
-     * @throws ImsException if the IMS service associated with this subscription is not available or
-     *     the IMS service is not available.
-     * @throws InterruptedException if the thread to get value is timed out. (max 2000ms)
-     */
-    int getImsServiceState() throws ImsException, InterruptedException {
-        if (!isImsSupportedOnDevice(mContext)) {
-            throw new ImsException(
-                    "IMS not supported on device.",
-                    ImsReasonInfo.CODE_LOCAL_IMS_NOT_SUPPORTED_ON_DEVICE);
-        }
-        ImsMmTelManager mmTelManager = getImsMmTelManagerOrThrowExceptionIfNotReady();
-        final StateConsumer stateConsumer = new StateConsumer();
-        mmTelManager.getFeatureState(mExecutor, stateConsumer);
-        int state = stateConsumer.getOrTimeOut(); // ImsFeature.STATE_READY
-        log("getImsServiceState state:" + state);
-        return state;
-    }
-
-    /**
-     * Returns whether wi-fi calling feature is enabled by platform.
-     *
-     * <p>This function is a blocking function and there may be a timeout of up to 2 seconds.
-     *
-     * @return true, if wi-fi calling feature is enabled by platform.
-     */
-    boolean isWfcEnabledByPlatform() {
-        // We first read the per slot value. If it doesn't exist, we read the general value.
-        // If still doesn't exist, we use the hardcoded default value.
-        if (SystemProperties.getInt(PROP_DBG_WFC_AVAIL_OVERRIDE + mSlotId, SYS_PROP_NOT_SET) == 1
-                || SystemProperties.getInt(PROP_DBG_WFC_AVAIL_OVERRIDE, SYS_PROP_NOT_SET) == 1) {
-            return true;
-        }
-
-        return mContext.getResources()
-                        .getBoolean(com.android.internal.R.bool.config_device_wfc_ims_available)
-                && getBooleanCarrierConfig(CarrierConfigManager.KEY_CARRIER_WFC_IMS_AVAILABLE_BOOL)
-                && isGbaValid();
-    }
-
-    /**
-     * Returns whether wi-fi calling setting is enabled by user.
-     *
-     * @return true, if wi-fi calling setting is enabled by user.
-     */
-    boolean isWfcEnabledByUser() {
-        boolean wfcEnabled;
-        try {
-            ImsMmTelManager mmTelManager = getImsMmTelManagerOrThrowExceptionIfNotReady();
-            wfcEnabled = mmTelManager.isVoWiFiSettingEnabled();
-        } catch (Exception e) {
-            wfcEnabled =
-                    getBooleanCarrierConfig(
-                            CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ENABLED_BOOL);
-        }
-        log("isWfcEnabledByUser:" + wfcEnabled);
-        return wfcEnabled;
-    }
-
-    /**
-     * Returns whether wi-fi calling roaming setting is enabled by user.
-     *
-     * @return true, if wi-fi calling roaming setting is enabled by user.
-     */
-    boolean isWfcRoamingEnabledByUser() {
-        boolean wfcRoamingEnabled;
-        try {
-            ImsMmTelManager mmTelManager = getImsMmTelManagerOrThrowExceptionIfNotReady();
-            wfcRoamingEnabled = mmTelManager.isVoWiFiRoamingSettingEnabled();
-        } catch (Exception e) {
-            wfcRoamingEnabled =
-                    getBooleanCarrierConfig(
-                            CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ROAMING_ENABLED_BOOL);
-        }
-        log("isWfcRoamingEnabledByUser:" + wfcRoamingEnabled);
-        return wfcRoamingEnabled;
-    }
-
-    /**
-     * Returns whether cross sim wi-fi calling is enabled.
-     *
-     * @return true, if cross sim wi-fi calling is enabled.
-     */
-    boolean isCrossSimCallingEnabled() {
-        boolean userEnabled = isCrossSimCallingEnabledByUser();
-        boolean platformEnabled = isCrossSimEnabledByPlatform();
-        boolean isProvisioned = isWfcProvisionedOnDevice();
-
-        log(
-                "isCrossSimCallingEnabled: platformEnabled = "
-                        + platformEnabled
-                        + ", provisioned = "
-                        + isProvisioned
-                        + ", userEnabled = "
-                        + userEnabled);
-        return userEnabled && platformEnabled && isProvisioned;
-    }
-
-    /**
-     * Returns Voice over Wi-Fi mode preference
-     *
-     * @param roaming false:mode pref for home, true:mode pref for roaming
-     * @return voice over Wi-Fi mode preference, which can be one of the following: {@link
-     *     ImsMmTelManager#WIFI_MODE_WIFI_ONLY}, {@link
-     *     ImsMmTelManager#WIFI_MODE_CELLULAR_PREFERRED}, {@link
-     *     ImsMmTelManager#WIFI_MODE_WIFI_PREFERRED}
-     */
-    int getWfcMode(boolean roaming) {
-        if (!roaming) {
-            int wfcMode;
-            try {
-                ImsMmTelManager mmTelManager = getImsMmTelManagerOrThrowExceptionIfNotReady();
-                wfcMode = mmTelManager.getVoWiFiModeSetting();
-            } catch (Exception e) {
-                wfcMode =
-                        getIntCarrierConfig(
-                                CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_MODE_INT);
-            }
-            log("getWfcMode:" + wfcMode);
-            return wfcMode;
-        } else {
-            int wfcRoamingMode;
-            try {
-                ImsMmTelManager mmTelManager = getImsMmTelManagerOrThrowExceptionIfNotReady();
-                wfcRoamingMode = mmTelManager.getVoWiFiRoamingModeSetting();
-            } catch (Exception e) {
-                wfcRoamingMode =
-                        getIntCarrierConfig(
-                                CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ROAMING_MODE_INT);
-            }
-            log("getWfcMode(roaming):" + wfcRoamingMode);
-            return wfcRoamingMode;
-        }
-    }
-
-    /**
-     * Indicates whether VoWifi is provisioned on slot.
-     *
-     * <p>When CarrierConfig KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL is true, and VoLTE is
-     * not provisioned on device, this method returns false.
-     */
-    boolean isWfcProvisionedOnDevice() {
-        if (getBooleanCarrierConfig(
-                CarrierConfigManager.KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL)) {
-            if (!isVolteProvisionedOnDevice()) {
-                return false;
-            }
-        }
-
-        if (isMmTelProvisioningRequired(REGISTRATION_TECH_IWLAN)) {
-            return isWfcProvisioned();
-        }
-
-        return true;
-    }
-
-    protected void log(String s) {
-        Log.d(mLogTag, s);
-    }
-
-    protected void loge(String s) {
-        Log.e(mLogTag, s);
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsMetrics.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsMetrics.java
deleted file mode 100644
index d936d0b..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsMetrics.java
+++ /dev/null
@@ -1,1026 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import android.content.Context;
-import android.net.NetworkCapabilities;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Message;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.AccessNetworkConstants.AccessNetworkType;
-import android.telephony.SignalThresholdInfo;
-import android.telephony.qns.QnsProtoEnums;
-import android.util.Log;
-
-import com.android.internal.annotations.VisibleForTesting;
-import com.android.internal.util.State;
-import com.android.internal.util.StateMachine;
-import com.android.telephony.qns.DataConnectionStatusTracker.DataConnectionChangedInfo;
-import com.android.telephony.qns.QualifiedNetworksServiceImpl.QualifiedNetworksInfo;
-import com.android.telephony.qns.atoms.AtomsQnsFallbackRestrictionChangedInfo;
-import com.android.telephony.qns.atoms.AtomsQnsHandoverPingPongInfo;
-import com.android.telephony.qns.atoms.AtomsQnsHandoverTimeMillisInfo;
-import com.android.telephony.qns.atoms.AtomsQnsImsCallDropStats;
-import com.android.telephony.qns.atoms.AtomsQnsRatPreferenceMismatchInfo;
-import com.android.telephony.qns.atoms.AtomsQualifiedRatListChangedInfo;
-import com.android.telephony.statslib.StatsLib;
-
-import java.util.HashMap;
-import java.util.List;
-import java.util.concurrent.ConcurrentHashMap;
-
-/** QnsStats class */
-class QnsMetrics {
-
-    private StatsLib mStats;
-    private final String mLogTag;
-    private final Handler mHandler;
-    private final HandlerThread mHandlerThread;
-
-    // For HandoverTIme.
-    private final ConcurrentHashMap<Integer, HandoverTimeStateMachine> mHandoverTimeMap;
-    private final ConcurrentHashMap<Integer, PingPongTime> mPingPongTime;
-    private final ConcurrentHashMap<Integer, RatMismatchTime> mRatMismatchTime;
-    private final ConcurrentHashMap<Integer, RtpCallDrop> mRtpCallDrop;
-
-    /** Constructor */
-    QnsMetrics(Context context) {
-        mStats = new StatsLib(context);
-        mLogTag = QnsMetrics.class.getSimpleName();
-
-        mHandoverTimeMap = new ConcurrentHashMap<>();
-        mPingPongTime = new ConcurrentHashMap<>();
-        mRatMismatchTime = new ConcurrentHashMap<>();
-        mRtpCallDrop = new ConcurrentHashMap<>();
-
-        mHandlerThread = new HandlerThread(QnsMetrics.class.getSimpleName());
-        mHandlerThread.start();
-        mHandler = new Handler(mHandlerThread.getLooper());
-    }
-
-    @VisibleForTesting
-    QnsMetrics(StatsLib statsLib) {
-        mStats = statsLib;
-        mLogTag = QnsMetrics.class.getSimpleName();
-
-        mHandoverTimeMap = new ConcurrentHashMap<>();
-        mPingPongTime = new ConcurrentHashMap<>();
-        mRatMismatchTime = new ConcurrentHashMap<>();
-        mRtpCallDrop = new ConcurrentHashMap<>();
-
-        mHandlerThread = new HandlerThread(QnsMetrics.class.getSimpleName());
-        mHandlerThread.start();
-        mHandler = new Handler(mHandlerThread.getLooper());
-    }
-
-    @VisibleForTesting
-    Handler getHandler() {
-        return mHandler;
-    }
-
-    /** close */
-    public void close() {
-        mStats = null;
-        mHandlerThread.quitSafely();
-    }
-
-    /**
-     * Report atoms when the qualified access network is reported.
-     *
-     * @param info QualifiedNetworksInfo
-     * @param slotId slot index
-     * @param dataConnectionCurrentTransportType transportType currently stayed in.
-     * @param coverage coverage home or roam.
-     * @param settingWfcEnabled setting for wfc
-     * @param settingWfcRoamingEnabled roaming setting for wfc
-     * @param settingWfcMode setting for wfc mode
-     * @param settingWfcRoamingMode roaming setting for wfc mode
-     * @param cellularAccessNetworkType cellular rat
-     * @param iwlanAvailable iwlan available
-     * @param isCrossWfc cross sim wfc enabled
-     * @param restrictManager restriction manager
-     * @param cellularQualityMonitor cellular quality monitor
-     * @param wifiQualityMonitor wifi quality monitor
-     * @param callType call type
-     */
-    public void reportAtomForQualifiedNetworks(
-            QualifiedNetworksInfo info,
-            int slotId,
-            int dataConnectionCurrentTransportType,
-            int coverage,
-            boolean settingWfcEnabled,
-            boolean settingWfcRoamingEnabled,
-            int settingWfcMode,
-            int settingWfcRoamingMode,
-            int cellularAccessNetworkType,
-            boolean iwlanAvailable,
-            boolean isCrossWfc,
-            RestrictManager restrictManager,
-            QualityMonitor cellularQualityMonitor,
-            QualityMonitor wifiQualityMonitor,
-            int callType) {
-        mHandler.post(() -> procQualifiedNetworksForHandoverTime(info, slotId));
-        mHandler.post(() ->
-                procQualifiedRatListChanged(
-                        info,
-                        slotId,
-                        dataConnectionCurrentTransportType,
-                        coverage,
-                        settingWfcEnabled,
-                        settingWfcRoamingEnabled,
-                        settingWfcMode,
-                        settingWfcRoamingMode,
-                        cellularAccessNetworkType,
-                        iwlanAvailable,
-                        isCrossWfc,
-                        restrictManager,
-                        cellularQualityMonitor,
-                        wifiQualityMonitor,
-                        callType));
-    }
-
-    /**
-     * Report atom when data connection is changed
-     *
-     * @param netCapability Network Capability
-     * @param slotId slot Index
-     * @param info DataConnectionChangedInfo
-     * @param carrierId carrier id.
-     */
-    public void reportAtomForDataConnectionChanged(
-            int netCapability, int slotId, DataConnectionChangedInfo info, int carrierId) {
-        mHandler.post(() -> procDataConnectionChangedForHandoverTime(netCapability, slotId, info));
-        mHandler.post(() -> procDataConnectionChangedForHandoverPingPong(
-                netCapability, slotId, info, carrierId));
-        mHandler.post(() -> procDataConnectionChangedForRatMismatch(
-                netCapability, slotId, info, carrierId));
-    }
-
-    /**
-     * Report atom when a restriction is set.
-     *
-     * @param netCapability Network Capability
-     * @param slotId slot Index
-     * @param wlanRestrictions list of restrictions on wlan
-     * @param wwanRestrictions list of restrictions on wwan
-     * @param carrierId carrier id.
-     */
-    public void reportAtomForRestrictions(
-            int netCapability,
-            int slotId,
-            List<Integer> wlanRestrictions,
-            List<Integer> wwanRestrictions,
-            int carrierId) {
-        mHandler.post(() -> procRestrictionsForFallback(
-                netCapability, slotId, wlanRestrictions, wwanRestrictions, carrierId));
-    }
-
-    /**
-     * Report atom when call type change
-     *
-     * @param netCapability Network Capability
-     * @param slotId slot Index
-     * @param oldCallType previous call type
-     * @param newCallType new call type
-     * @param restrictManager restriction manager
-     * @param transportTypeOfCall transport type in call
-     */
-    public void reportAtomForCallTypeChanged(
-            int netCapability,
-            int slotId,
-            int oldCallType,
-            int newCallType,
-            RestrictManager restrictManager,
-            int transportTypeOfCall) {
-        mHandler.post(() -> procCallTypeChangedForImsCallDrop(netCapability, slotId,
-                oldCallType, newCallType, restrictManager, transportTypeOfCall));
-    }
-
-    /**
-     * Report atom when ims call is dropped
-     *
-     * @param netCapability Network Capability
-     * @param slotId slot Index
-     * @param restrictManager restriction manager
-     * @param cellularQualityMonitor cellular quality monitor
-     * @param wifiQualityMonitor wifi quality monitor
-     * @param transportTypeOfCall transport type in call
-     * @param cellularAccessNetworkType cellular access network
-     */
-    public void reportAtomForImsCallDropStats(
-            int netCapability,
-            int slotId,
-            RestrictManager restrictManager,
-            QualityMonitor cellularQualityMonitor,
-            QualityMonitor wifiQualityMonitor,
-            int transportTypeOfCall,
-            int cellularAccessNetworkType) {
-        mHandler.post(() -> procCallDroppedForImsCallDrop(netCapability, slotId, restrictManager,
-                cellularQualityMonitor, wifiQualityMonitor, transportTypeOfCall,
-                cellularAccessNetworkType));
-    }
-
-    private void procQualifiedRatListChanged(
-            QualifiedNetworksInfo info,
-            int slotId,
-            int dataConnectedTransportType,
-            int coverage,
-            boolean settingWfcEnabled,
-            boolean settingWfcRoamingEnabled,
-            int settingWfcMode,
-            int settingWfcRoamingMode,
-            int cellularAccessNetworkType,
-            boolean iwlanAvailable,
-            boolean isCrossWfc,
-            RestrictManager restrictManager,
-            QualityMonitor cellularQualityMonitor,
-            QualityMonitor wifiQualityMonitor,
-            int callType) {
-        int netCapability = info.getNetCapability();
-        int firstQualifiedRat = getQualifiedAccessNetwork(info, 0);
-        int secondQualifiedRat = getQualifiedAccessNetwork(info, 1);
-        boolean wfcEnabled = getWfcEnabled(coverage, settingWfcEnabled, settingWfcRoamingEnabled);
-        int wfcMode = getWfcMode(coverage, settingWfcMode, settingWfcRoamingMode);
-        int iwlanNetworkType = getIwlanNetworkType(iwlanAvailable, isCrossWfc);
-        int restrictionsOnWwan = getRestrictionsBitmask(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN, restrictManager);
-        int restrictionsOnWlan = getRestrictionsBitmask(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN, restrictManager);
-        int signalStrength = getSignalStrength(cellularQualityMonitor, cellularAccessNetworkType);
-        int signalQuality = getSignalQuality(cellularQualityMonitor, cellularAccessNetworkType);
-        int signalNoise = getSignalNoise(cellularQualityMonitor, cellularAccessNetworkType);
-        int iwlanSignalStrength = getSignalStrength(wifiQualityMonitor, AccessNetworkType.IWLAN);
-        int updateReason = 0;
-        int imsCallQuality = 0;
-
-        writeQualifiedRatListChangedInfo(
-                netCapability,
-                slotId,
-                firstQualifiedRat,
-                secondQualifiedRat,
-                dataConnectedTransportType,
-                wfcEnabled,
-                wfcMode,
-                cellularAccessNetworkType,
-                iwlanNetworkType,
-                restrictionsOnWwan,
-                restrictionsOnWlan,
-                signalStrength,
-                signalQuality,
-                signalNoise,
-                iwlanSignalStrength,
-                updateReason,
-                callType,
-                imsCallQuality);
-    }
-
-
-    private void procQualifiedNetworksForHandoverTime(QualifiedNetworksInfo info, int slotId) {
-        if (info.getNetCapability() != NetworkCapabilities.NET_CAPABILITY_IMS) {
-            return;
-        }
-
-        HandoverTimeStateMachine handoverTimeStateMachine = mHandoverTimeMap.get(slotId);
-        if (handoverTimeStateMachine == null) {
-            handoverTimeStateMachine =
-                    new HandoverTimeStateMachine(info.getNetCapability(), slotId, mHandler);
-            mHandoverTimeMap.put(slotId, handoverTimeStateMachine);
-        }
-
-        handoverTimeStateMachine.sendQualifiedRatChanged(info);
-    }
-
-    private void procDataConnectionChangedForHandoverTime(
-            int netCapability, int slotId, DataConnectionChangedInfo info) {
-        if (netCapability != NetworkCapabilities.NET_CAPABILITY_IMS) {
-            return;
-        }
-
-        HandoverTimeStateMachine handoverTimeStateMachine = mHandoverTimeMap.get(slotId);
-        if (handoverTimeStateMachine == null) {
-            handoverTimeStateMachine =
-                    new HandoverTimeStateMachine(netCapability, slotId, mHandler);
-            mHandoverTimeMap.put(slotId, handoverTimeStateMachine);
-        }
-
-        handoverTimeStateMachine.sendDataStateChanged(info);
-    }
-
-    private void procDataConnectionChangedForHandoverPingPong(int netCapability, int slotId,
-            DataConnectionChangedInfo info, int carrierId) {
-        if (netCapability != NetworkCapabilities.NET_CAPABILITY_IMS) {
-            return;
-        }
-
-        PingPongTime pingPongTime = mPingPongTime.get(slotId);
-        if (pingPongTime == null) {
-            pingPongTime = new PingPongTime();
-            mPingPongTime.put(slotId, pingPongTime);
-        }
-
-        boolean bActiveState;
-        switch (info.getState()) {
-            case DataConnectionStatusTracker.STATE_INACTIVE:
-            case DataConnectionStatusTracker.STATE_CONNECTING:
-                bActiveState = false;
-                break;
-            case DataConnectionStatusTracker.STATE_CONNECTED:
-            case DataConnectionStatusTracker.STATE_HANDOVER:
-            default:
-                bActiveState = true;
-                break;
-        }
-        switch (info.getEvent()) {
-            case DataConnectionStatusTracker.EVENT_DATA_CONNECTION_CONNECTED:
-                pingPongTime.mSuccessTime = QnsUtils.getSystemElapsedRealTime();
-                pingPongTime.mHandoverCount = 0;
-                break;
-            case DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_STARTED:
-                pingPongTime.mStartTime = QnsUtils.getSystemElapsedRealTime();
-                break;
-            case DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_SUCCESS:
-                pingPongTime.mHandoverCount++;
-                pingPongTime.mSuccessTime = QnsUtils.getSystemElapsedRealTime();
-                break;
-        }
-
-        if (pingPongTime.mStartTime != 0L && pingPongTime.mSuccessTime != 0L) {
-            long pingPongTimeLimit = AtomsQnsHandoverPingPongInfo.PING_PONG_TIME_IN_MILLIS;
-            long elapsed =
-                    (pingPongTime.mSuccessTime > pingPongTime.mStartTime)
-                            ? (pingPongTime.mSuccessTime - pingPongTime.mStartTime)
-                            : (pingPongTime.mStartTime - pingPongTime.mSuccessTime);
-            if (pingPongTime.mHandoverCount > 0) {
-                log("HandoverPingPong elapsed:" + elapsed
-                        + " ping-pong count:" + (pingPongTime.mHandoverCount / 2));
-            }
-            if (elapsed > pingPongTimeLimit || !bActiveState) {
-                if (pingPongTime.mHandoverCount > 1) {
-                    int pingpongCount = pingPongTime.mHandoverCount / 2;
-                    writeQnsHandoverPingPong(slotId, pingpongCount, carrierId);
-                }
-                pingPongTime.mHandoverCount = 0;
-                pingPongTime.mStartTime = 0L;
-                pingPongTime.mSuccessTime = 0L;
-                procDataConnectionChangedForHandoverPingPong(
-                        netCapability, slotId, info, carrierId);
-            }
-        }
-        if (!bActiveState) {
-            pingPongTime.mHandoverCount = 0;
-            pingPongTime.mStartTime = 0L;
-            pingPongTime.mSuccessTime = 0L;
-        }
-    }
-
-    private void procRestrictionsForFallback(int netCapability, int slotId,
-            List<Integer> wlanRestrictions, List<Integer> wwanRestrictions, int carrierId) {
-        if (netCapability != NetworkCapabilities.NET_CAPABILITY_IMS
-                || wlanRestrictions == null
-                || wwanRestrictions == null) {
-            return;
-        }
-
-        boolean bRestrictionOnWlanByRtpThresholdBreached =
-                wlanRestrictions.contains(RestrictManager.RESTRICT_TYPE_RTP_LOW_QUALITY);
-        boolean bRestrictionOnWwanByRtpThresholdBreached =
-                wwanRestrictions.contains(RestrictManager.RESTRICT_TYPE_RTP_LOW_QUALITY);
-        boolean bRestrictionOnWlanByImsRegistrationFailed =
-                wlanRestrictions.contains(
-                        RestrictManager.RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL);
-        boolean bRestrictionOnWlanByWifiBackhaulProblem =
-                wlanRestrictions.contains(
-                        RestrictManager.RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL);
-
-        // all false will not write atom because this atom is used for count metric.
-        if (bRestrictionOnWlanByRtpThresholdBreached
-                || bRestrictionOnWwanByRtpThresholdBreached
-                || bRestrictionOnWlanByImsRegistrationFailed
-                || bRestrictionOnWlanByWifiBackhaulProblem) {
-            writeQnsFallbackRestrictionChangedInfo(
-                    bRestrictionOnWlanByRtpThresholdBreached,
-                    bRestrictionOnWwanByRtpThresholdBreached,
-                    bRestrictionOnWlanByImsRegistrationFailed,
-                    bRestrictionOnWlanByWifiBackhaulProblem,
-                    carrierId,
-                    slotId);
-        }
-    }
-
-    private void procDataConnectionChangedForRatMismatch(
-            int netCapability, int slotId, DataConnectionChangedInfo info, int carrierId) {
-
-        RatMismatchTime mismatchTime = mRatMismatchTime.get(slotId);
-        if (mismatchTime == null) {
-            mismatchTime = new RatMismatchTime();
-            mRatMismatchTime.put(slotId, mismatchTime);
-        }
-
-        switch (info.getEvent()) {
-            case DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_STARTED:
-                if (mismatchTime.mCount == 0) {
-                    mismatchTime.mStartTime = QnsUtils.getSystemElapsedRealTime();
-                }
-                break;
-            case DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_FAILED:
-                mismatchTime.mCount++;
-                break;
-            default:
-                if (mismatchTime.mCount > 0) {
-                    long duration = QnsUtils.getSystemElapsedRealTime() - mismatchTime.mStartTime;
-                    int count = mismatchTime.mCount;
-
-                    writeQnsRatPreferenceMismatchInfo(
-                            netCapability, count, (int) duration, carrierId, slotId);
-                    mismatchTime.mCount = 0;
-                    mismatchTime.mStartTime = 0L;
-                }
-                break;
-        }
-    }
-
-    private void writeQualifiedRatListChangedInfo(
-            int netCapability,
-            int slotId,
-            int firstQualifiedRat,
-            int secondQualifiedRat,
-            int currentTransportType,
-            boolean wfcEnabled,
-            int wfcMode,
-            int cellularNetworkType,
-            int iwlanNetworkType,
-            int restrictionsOnWwan,
-            int restrictionsOnWlan,
-            int signalStrength,
-            int signalQuality,
-            int signalNoise,
-            int iwlanSignalStrength,
-            int updateReason,
-            int imsCallType,
-            int imsCallQuality) {
-        AtomsQualifiedRatListChangedInfo atoms =
-                new AtomsQualifiedRatListChangedInfo(
-                        netCapability,
-                        firstQualifiedRat,
-                        secondQualifiedRat,
-                        currentTransportType,
-                        wfcEnabled,
-                        wfcMode,
-                        cellularNetworkType,
-                        iwlanNetworkType,
-                        restrictionsOnWwan,
-                        restrictionsOnWlan,
-                        signalStrength,
-                        signalQuality,
-                        signalNoise,
-                        iwlanSignalStrength,
-                        updateReason,
-                        imsCallType,
-                        imsCallQuality,
-                        slotId);
-        mStats.write(atoms);
-    }
-
-
-    private void writeQnsHandoverTimeMillisInfo(long handoverTime, int slotIndex) {
-        AtomsQnsHandoverTimeMillisInfo atoms =
-                new AtomsQnsHandoverTimeMillisInfo((int) handoverTime, slotIndex);
-        mStats.append(atoms);
-    }
-
-    private void writeQnsHandoverPingPong(int slotId, int pingPongCount, int carrierId) {
-        AtomsQnsHandoverPingPongInfo atoms =
-                new AtomsQnsHandoverPingPongInfo(pingPongCount, carrierId, slotId);
-        mStats.append(atoms);
-    }
-
-    private void writeQnsFallbackRestrictionChangedInfo(
-            boolean bRestrictionOnWlanByRtpThresholdBreached,
-            boolean bRestrictionOnWwanByRtpThresholdBreached,
-            boolean bRestrictionOnWlanByImsRegistrationFailed,
-            boolean bRestrictionOnWlanByWifiBackhaulProblem,
-            int carrierId,
-            int slotId) {
-        AtomsQnsFallbackRestrictionChangedInfo atom =
-                new AtomsQnsFallbackRestrictionChangedInfo(
-                        bRestrictionOnWlanByRtpThresholdBreached,
-                        bRestrictionOnWwanByRtpThresholdBreached,
-                        bRestrictionOnWlanByImsRegistrationFailed,
-                        bRestrictionOnWlanByWifiBackhaulProblem,
-                        carrierId,
-                        slotId);
-        mStats.write(atom);
-    }
-
-    private void writeQnsRatPreferenceMismatchInfo(int netCapability, int handoverFailCount,
-            int durationMismatch, int carrierId, int slotId) {
-        AtomsQnsRatPreferenceMismatchInfo atoms = new AtomsQnsRatPreferenceMismatchInfo(
-                netCapability, handoverFailCount, durationMismatch, carrierId, slotId);
-        mStats.append(atoms);
-    }
-
-    class HandoverTimeStateMachine extends StateMachine {
-
-        private static final int EVENT_DATA_STATE_CHANGED = 0;
-        private static final int EVENT_QUALIFIED_RAT_CHANGED = 1;
-
-        private final IdleState mIdleState;
-        private final ConnectedState mConnectedState;
-        private final HandoverRequestedState mHandoverRequestedState;
-        private final HandoverInProgressState mHandoverInProgressState;
-
-        private final int mNetCapability;
-        private final int mSlotId;
-        int mDataTransportType;
-        long mHandoverRequestedTime;
-
-        HandoverTimeStateMachine(int netCapability, int slotId, Handler handler) {
-            super(mLogTag + "_" + HandoverTimeStateMachine.class.getSimpleName() + "_" + slotId
-                    + "_" + QnsUtils.getNameOfNetCapability(netCapability), handler);
-
-            mIdleState = new IdleState();
-            mConnectedState = new ConnectedState();
-            mHandoverRequestedState = new HandoverRequestedState();
-            mHandoverInProgressState = new HandoverInProgressState();
-
-            mNetCapability = netCapability;
-            mSlotId = slotId;
-            mDataTransportType = AccessNetworkConstants.TRANSPORT_TYPE_INVALID;
-            mHandoverRequestedTime = 0L;
-
-            addState(mIdleState);
-            addState(mConnectedState);
-            addState(mHandoverRequestedState);
-            addState(mHandoverInProgressState);
-            setInitialState(mIdleState);
-            start();
-        }
-
-        public void sendDataStateChanged(DataConnectionChangedInfo info) {
-            sendMessage(EVENT_DATA_STATE_CHANGED, info);
-        }
-
-        public void sendQualifiedRatChanged(QualifiedNetworksInfo info) {
-            sendMessage(EVENT_QUALIFIED_RAT_CHANGED, info);
-        }
-
-        private final class IdleState extends State {
-            @Override
-            public void enter() {
-                log("IdleState");
-                mDataTransportType = AccessNetworkConstants.TRANSPORT_TYPE_INVALID;
-                mHandoverRequestedTime = 0L;
-            }
-
-            @Override
-            public boolean processMessage(Message msg) {
-                log("IdleState processMessage=" + msg.what);
-                switch (msg.what) {
-                    case EVENT_DATA_STATE_CHANGED:
-                        DataConnectionChangedInfo dataInfo = (DataConnectionChangedInfo) msg.obj;
-                        switch (dataInfo.getState()) {
-                            case DataConnectionStatusTracker.STATE_CONNECTED:
-                                mDataTransportType = dataInfo.getTransportType();
-                                transitionTo(mConnectedState);
-                                return HANDLED;
-                            case DataConnectionStatusTracker.STATE_HANDOVER:
-                                mDataTransportType = dataInfo.getTransportType();
-                                transitionTo(mConnectedState);
-                                break;
-                        }
-                        break;
-                    case EVENT_QUALIFIED_RAT_CHANGED:
-                        break;
-                }
-                return super.processMessage(msg);
-            }
-
-            @Override
-            public void exit() {
-                super.exit();
-            }
-        }
-
-        private final class ConnectedState extends State {
-            @Override
-            public void enter() {
-                log("ConnectedState");
-                mHandoverRequestedTime = 0L;
-            }
-
-            @Override
-            public boolean processMessage(Message msg) {
-                log("ConnectedState processMessage=" + msg.what);
-                switch (msg.what) {
-                    case EVENT_DATA_STATE_CHANGED:
-                        DataConnectionChangedInfo dataInfo = (DataConnectionChangedInfo) msg.obj;
-                        switch (dataInfo.getState()) {
-                            case DataConnectionStatusTracker.STATE_INACTIVE:
-                            case DataConnectionStatusTracker.STATE_CONNECTING:
-                                transitionTo(mIdleState);
-                                break;
-                            case DataConnectionStatusTracker.STATE_CONNECTED:
-                            case DataConnectionStatusTracker.STATE_HANDOVER:
-                                mDataTransportType = dataInfo.getTransportType();
-                                return HANDLED;
-                        }
-                        break;
-                    case EVENT_QUALIFIED_RAT_CHANGED:
-                        QualifiedNetworksInfo qualifiedInfo = (QualifiedNetworksInfo) msg.obj;
-                        // handover trigger
-                        if (mNetCapability == qualifiedInfo.getNetCapability()
-                                && qualifiedInfo.getAccessNetworkTypes().stream().anyMatch(
-                                        accessNetwork -> QnsUtils.getTransportTypeFromAccessNetwork(
-                                                accessNetwork) != mDataTransportType)) {
-                            mHandoverRequestedTime = QnsUtils.getSystemElapsedRealTime();
-                            transitionTo(mHandoverRequestedState);
-                            return HANDLED;
-                        }
-                        break;
-                }
-
-                return super.processMessage(msg);
-            }
-
-            @Override
-            public void exit() {
-                super.exit();
-            }
-        }
-
-        private final class HandoverRequestedState extends State {
-            @Override
-            public void enter() {
-                log("HandoverRequestedState");
-            }
-
-            @Override
-            public boolean processMessage(Message msg) {
-                log("HandoverRequestedState processMessage=" + msg.what);
-                switch (msg.what) {
-                    case EVENT_DATA_STATE_CHANGED:
-                        DataConnectionChangedInfo dataInfo = (DataConnectionChangedInfo) msg.obj;
-                        switch (dataInfo.getState()) {
-                            case DataConnectionStatusTracker.STATE_INACTIVE:
-                            case DataConnectionStatusTracker.STATE_CONNECTING:
-                                transitionTo(mIdleState);
-                                break;
-                            case DataConnectionStatusTracker.STATE_CONNECTED:
-                                if (dataInfo.getTransportType() != mDataTransportType) {
-                                    // back to connected state, already reached to target transport.
-                                    mDataTransportType = dataInfo.getTransportType();
-                                    transitionTo(mConnectedState);
-                                }
-                                break;
-                            case DataConnectionStatusTracker.STATE_HANDOVER:
-                                if (dataInfo.getTransportType() != mDataTransportType) {
-                                    // back to connected state, already reached to target transport.
-                                    mDataTransportType = dataInfo.getTransportType();
-                                    transitionTo(mConnectedState);
-                                }
-                                transitionTo(mHandoverInProgressState);
-                                break;
-                        }
-                        break;
-                    case EVENT_QUALIFIED_RAT_CHANGED:
-                        QualifiedNetworksInfo qualifiedInfo = (QualifiedNetworksInfo) msg.obj;
-                        if (mNetCapability != qualifiedInfo.getNetCapability()) {
-                            break;
-                        }
-                        if (qualifiedInfo.getAccessNetworkTypes().stream().noneMatch(
-                                accessNetwork -> QnsUtils.getTransportTypeFromAccessNetwork(
-                                        accessNetwork) != mDataTransportType)) {
-                            // back to connected state. no handover target transport.
-                            transitionTo(mConnectedState);
-                            return HANDLED;
-                        }
-                        break;
-                }
-                return super.processMessage(msg);
-            }
-
-            @Override
-            public void exit() {
-                super.exit();
-            }
-        }
-
-        private final class HandoverInProgressState extends State {
-            @Override
-            public void enter() {
-                log("HandoverInProgressState");
-            }
-
-            @Override
-            public boolean processMessage(Message msg) {
-                log("HandoverInProgressState processMessage=" + msg.what);
-                switch (msg.what) {
-                    case EVENT_DATA_STATE_CHANGED:
-                        DataConnectionChangedInfo dataInfo = (DataConnectionChangedInfo) msg.obj;
-                        switch (dataInfo.getState()) {
-                            case DataConnectionStatusTracker.STATE_INACTIVE:
-                            case DataConnectionStatusTracker.STATE_CONNECTING:
-                                transitionTo(mIdleState);
-                                break;
-                            case DataConnectionStatusTracker.STATE_CONNECTED:
-                                if (dataInfo.getTransportType() != mDataTransportType) {
-                                    if (mHandoverRequestedTime == 0L) {
-                                        break;
-                                    }
-                                    // handover done.
-                                    long handoverTime = QnsUtils.getSystemElapsedRealTime()
-                                            - mHandoverRequestedTime;
-                                    writeQnsHandoverTimeMillisInfo(handoverTime, mSlotId);
-                                    mDataTransportType = dataInfo.getTransportType();
-                                    mHandoverRequestedTime = 0L;
-                                    transitionTo(mConnectedState);
-                                } else {
-                                    // handover didn't have done yet.
-                                    transitionTo(mHandoverRequestedState);
-                                }
-                                break;
-                            case DataConnectionStatusTracker.STATE_HANDOVER:
-                                if (dataInfo.getTransportType() != mDataTransportType) {
-                                    // back to connected state, already reached to target transport.
-                                    mDataTransportType = dataInfo.getTransportType();
-                                    transitionTo(mConnectedState);
-                                }
-                                break;
-                        }
-                        break;
-                    case EVENT_QUALIFIED_RAT_CHANGED:
-                        QualifiedNetworksInfo qualifiedInfo = (QualifiedNetworksInfo) msg.obj;
-                        if (mNetCapability == qualifiedInfo.getNetCapability()
-                                && qualifiedInfo.getAccessNetworkTypes().stream().noneMatch(
-                                        accessNetwork -> QnsUtils.getTransportTypeFromAccessNetwork(
-                                                accessNetwork) != mDataTransportType)) {
-                            // back to connected state. no handover request
-                            transitionTo(mConnectedState);
-                            return HANDLED;
-                        }
-                        break;
-                }
-                return super.processMessage(msg);
-            }
-
-            @Override
-            public void exit() {
-                super.exit();
-            }
-        }
-    }
-
-    private static class PingPongTime {
-        int mHandoverCount = 0;
-        long mStartTime = 0L;
-        long mSuccessTime = 0L;
-    }
-
-    private static class RatMismatchTime {
-        int mCount = 0;
-        long mStartTime = 0L;
-    }
-
-    private static class RtpCallDrop {
-        boolean mRtpThresholdBreached;
-        int mRestrictionsOnOtherTransportType;
-    }
-
-
-    private void procCallTypeChangedForImsCallDrop(
-            int netCapability,
-            int slotId,
-            int oldCallType,
-            int newCallType,
-            RestrictManager restrictManager,
-            int transportTypeOfCall) {
-        if (netCapability != NetworkCapabilities.NET_CAPABILITY_IMS) {
-            return;
-        }
-
-        RtpCallDrop rtpCallDrop = mRtpCallDrop.get(slotId);
-        if (rtpCallDrop == null) {
-            rtpCallDrop = new RtpCallDrop();
-            mRtpCallDrop.put(slotId, rtpCallDrop);
-        }
-
-        // call ended
-        if (newCallType == QnsConstants.CALL_TYPE_IDLE
-                && oldCallType != QnsConstants.CALL_TYPE_IDLE) {
-            rtpCallDrop.mRtpThresholdBreached =
-                    restrictManager.hasRestrictionType(
-                            transportTypeOfCall, RestrictManager.RESTRICT_TYPE_RTP_LOW_QUALITY);
-            int otherTransportType =
-                    transportTypeOfCall == AccessNetworkConstants.TRANSPORT_TYPE_WLAN
-                            ? AccessNetworkConstants.TRANSPORT_TYPE_WWAN
-                            : AccessNetworkConstants.TRANSPORT_TYPE_WLAN;
-            rtpCallDrop.mRestrictionsOnOtherTransportType =
-                    getRestrictionsBitmask(otherTransportType, restrictManager);
-        } else {
-            rtpCallDrop.mRtpThresholdBreached = false;
-            rtpCallDrop.mRestrictionsOnOtherTransportType = 0;
-        }
-    }
-
-    private void procCallDroppedForImsCallDrop(
-            int netCapability,
-            int slotId,
-            RestrictManager restrictManager,
-            QualityMonitor cellularQualityMonitor,
-            QualityMonitor wifiQualityMonitor,
-            int transportTypeOfCall,
-            int cellularAccessNetworkType) {
-        if (netCapability != NetworkCapabilities.NET_CAPABILITY_IMS) {
-            return;
-        }
-
-        RtpCallDrop rtpCallDrop = mRtpCallDrop.get(slotId);
-        if (rtpCallDrop == null) {
-            rtpCallDrop = new RtpCallDrop();
-            mRtpCallDrop.put(slotId, rtpCallDrop);
-        }
-
-        if (!rtpCallDrop.mRtpThresholdBreached
-                || rtpCallDrop.mRestrictionsOnOtherTransportType == 0) {
-            rtpCallDrop.mRtpThresholdBreached = restrictManager.hasRestrictionType(
-                            transportTypeOfCall, RestrictManager.RESTRICT_TYPE_RTP_LOW_QUALITY);
-            int otherTransportType =
-                    transportTypeOfCall == AccessNetworkConstants.TRANSPORT_TYPE_WLAN
-                            ? AccessNetworkConstants.TRANSPORT_TYPE_WWAN
-                            : AccessNetworkConstants.TRANSPORT_TYPE_WLAN;
-            rtpCallDrop.mRestrictionsOnOtherTransportType =
-                    getRestrictionsBitmask(otherTransportType, restrictManager);
-        }
-
-        int signalStrength = getSignalStrength(cellularQualityMonitor, cellularAccessNetworkType);
-        int signalQuality = getSignalQuality(cellularQualityMonitor, cellularAccessNetworkType);
-        int signalNoise = getSignalNoise(cellularQualityMonitor, cellularAccessNetworkType);
-        int iwlanSignalStrength = getSignalStrength(wifiQualityMonitor, AccessNetworkType.IWLAN);
-
-        writeQnsImsCallDropStats(
-                transportTypeOfCall,
-                rtpCallDrop.mRtpThresholdBreached,
-                rtpCallDrop.mRestrictionsOnOtherTransportType,
-                signalStrength,
-                signalQuality,
-                signalNoise,
-                iwlanSignalStrength,
-                cellularAccessNetworkType,
-                slotId);
-    }
-
-    private void writeQnsImsCallDropStats(
-            int transportTypeCallDropped,
-            boolean rtpThresholdBreached,
-            int restrictionsOnOtherTransportType,
-            int signalStrength,
-            int signalQuality,
-            int signalNoise,
-            int iwlanSignalStrength,
-            int cellularNetworkType,
-            int slotId) {
-        AtomsQnsImsCallDropStats atoms =
-                new AtomsQnsImsCallDropStats(
-                        transportTypeCallDropped,
-                        rtpThresholdBreached,
-                        restrictionsOnOtherTransportType,
-                        signalStrength,
-                        signalQuality,
-                        signalNoise,
-                        iwlanSignalStrength,
-                        slotId,
-                        cellularNetworkType);
-        mStats.write(atoms);
-    }
-
-    private int getQualifiedAccessNetwork(QualifiedNetworksInfo info, int index) {
-        List<Integer> types = info.getAccessNetworkTypes();
-        if (types == null || index >= types.size()) {
-            return QnsProtoEnums.EMPTY;
-        }
-        return types.get(index);
-    }
-
-    private boolean getWfcEnabled(int coverage, boolean wfcEnabled, boolean wfcRoamingEnabled) {
-        return coverage == QnsConstants.COVERAGE_HOME ? wfcEnabled : wfcRoamingEnabled;
-    }
-
-    private int getWfcMode(int coverage, int wfcMode, int wfcRoamingMode) {
-        return coverage == QnsConstants.COVERAGE_HOME ? wfcMode : wfcRoamingMode;
-    }
-
-    private int getIwlanNetworkType(boolean iwlanAvailable, boolean isCrossWfc) {
-        if (!iwlanAvailable) {
-            return QnsProtoEnums.IWLAN_NETWORK_TYPE_NONE;
-        } else if (isCrossWfc) {
-            return QnsProtoEnums.IWLAN_NETWORK_TYPE_CST;
-        }
-        return QnsProtoEnums.IWLAN_NETWORK_TYPE_WIFI;
-    }
-
-    static final HashMap<Integer, Integer> sAtomRestrictionsMap;
-
-    static {
-        sAtomRestrictionsMap = new HashMap<>();
-        sAtomRestrictionsMap.put(
-                RestrictManager.RESTRICT_TYPE_GUARDING, QnsProtoEnums.RESTRICT_TYPE_GUARDING);
-        sAtomRestrictionsMap.put(
-                RestrictManager.RESTRICT_TYPE_THROTTLING, QnsProtoEnums.RESTRICT_TYPE_THROTTLING);
-        sAtomRestrictionsMap.put(
-                RestrictManager.RESTRICT_TYPE_HO_NOT_ALLOWED,
-                QnsProtoEnums.RESTRICT_TYPE_HO_NOT_ALLOWED);
-        sAtomRestrictionsMap.put(
-                RestrictManager.RESTRICT_TYPE_NON_PREFERRED_TRANSPORT,
-                QnsProtoEnums.RESTRICT_TYPE_NON_PREFERRED_TRANSPORT);
-        sAtomRestrictionsMap.put(
-                RestrictManager.RESTRICT_TYPE_RTP_LOW_QUALITY,
-                QnsProtoEnums.RESTRICT_TYPE_RTP_LOW_QUALITY);
-        sAtomRestrictionsMap.put(
-                RestrictManager.RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL,
-                QnsProtoEnums.RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL);
-        sAtomRestrictionsMap.put(
-                RestrictManager.RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL,
-                QnsProtoEnums.RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL);
-        sAtomRestrictionsMap.put(
-                RestrictManager.RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL,
-                QnsProtoEnums.RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL);
-        sAtomRestrictionsMap.put(
-                RestrictManager.RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL,
-                QnsProtoEnums.RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-        sAtomRestrictionsMap.put(
-                RestrictManager.RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL,
-                QnsProtoEnums.RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL);
-    }
-
-    private int getRestrictionsBitmask(int transportType, RestrictManager restrictManager) {
-        int restrictions = QnsProtoEnums.RESTRICT_TYPE_NONE;
-        for (int restrictionType : sAtomRestrictionsMap.keySet()) {
-            if (restrictManager.hasRestrictionType(transportType, restrictionType)) {
-                restrictions |= sAtomRestrictionsMap.get(restrictionType);
-            }
-        }
-        return restrictions;
-    }
-
-    private int getSignalStrength(QualityMonitor qm, int accessNetworkType) {
-        switch (accessNetworkType) {
-            case AccessNetworkType.GERAN:
-            case AccessNetworkType.IWLAN:
-                return qm.getCurrentQuality(
-                        accessNetworkType, SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI);
-            case AccessNetworkType.UTRAN:
-                return qm.getCurrentQuality(
-                        accessNetworkType, SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSCP);
-            case AccessNetworkType.EUTRAN:
-                return qm.getCurrentQuality(
-                        accessNetworkType, SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP);
-            case AccessNetworkType.NGRAN:
-                return qm.getCurrentQuality(
-                        accessNetworkType, SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSRSRP);
-        }
-        return 0;
-    }
-
-    private int getSignalQuality(QualityMonitor qm, int accessNetworkType) {
-        switch (accessNetworkType) {
-            case AccessNetworkType.EUTRAN:
-                return qm.getCurrentQuality(
-                        accessNetworkType, SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRQ);
-            case AccessNetworkType.NGRAN:
-                return qm.getCurrentQuality(
-                        accessNetworkType, SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSRSRQ);
-        }
-        return 0;
-    }
-
-    private int getSignalNoise(QualityMonitor qm, int accessNetworkType) {
-        switch (accessNetworkType) {
-            case AccessNetworkType.EUTRAN:
-                return qm.getCurrentQuality(
-                        accessNetworkType, SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR);
-            case AccessNetworkType.NGRAN:
-                return qm.getCurrentQuality(
-                        accessNetworkType, SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSSINR);
-        }
-        return 0;
-    }
-
-    protected void log(String s) {
-        Log.d(mLogTag, s);
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsProvisioningListener.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsProvisioningListener.java
deleted file mode 100644
index b10011c..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsProvisioningListener.java
+++ /dev/null
@@ -1,487 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import android.annotation.NonNull;
-import android.content.Context;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Looper;
-import android.os.Message;
-import android.telephony.SubscriptionManager;
-import android.telephony.ims.ProvisioningManager;
-import android.text.TextUtils;
-import android.util.Log;
-
-import com.android.internal.annotations.VisibleForTesting;
-
-import java.util.concurrent.ConcurrentHashMap;
-
-class QnsProvisioningListener {
-
-    private static final long REG_CALLBACK_DELAY = 2000L; // 3sec
-    private static final int REG_CALLBACK_RETRY = 10; // 10 times
-    private static final int EVENT_BASE = 11000;
-    private static final int EVENT_REGISTER_PROVISIONING_CALLBACK = EVENT_BASE + 1;
-    private static final int EVENT_CALLBACK_REGISTERED = EVENT_BASE + 3;
-    private static final int EVENT_NOTIFY_PROVISION_INFO_CHANGED = EVENT_BASE + 4;
-    private static final int EVENT_IMS_STATE_CHANGED = EVENT_BASE + 5;
-    private final String mLogTag;
-    private final Context mContext;
-    private final int mSlotIndex;
-    private final QnsProvisioningInfo mProvisioningInfo;
-    private final QnsImsManager mQnsImsManager;
-    @VisibleForTesting QnsProvisioningHandler mQnsProvisioningHandler;
-
-    private final QnsProvisioningCallback mQnsProvisioningCallback;
-    private final QnsRegistrantList mRegistrantList;
-    private ProvisioningManager mProvisioningManager;
-    private boolean mIsProvisioningCallbackRegistered;
-
-    QnsProvisioningListener(Context context, QnsImsManager imsManager, int slotIndex) {
-        mSlotIndex = slotIndex;
-        mLogTag = QnsProvisioningListener.class.getSimpleName() + "_" + mSlotIndex;
-        mContext = context;
-        mQnsImsManager = imsManager;
-        mProvisioningInfo = new QnsProvisioningInfo();
-        mQnsProvisioningCallback = new QnsProvisioningCallback();
-        mIsProvisioningCallbackRegistered = false;
-        mRegistrantList = new QnsRegistrantList();
-
-        HandlerThread handlerThread = new HandlerThread(mLogTag);
-        handlerThread.start();
-        mQnsProvisioningHandler = new QnsProvisioningHandler(handlerThread.getLooper());
-
-        registerProvisioningCallback();
-        mQnsImsManager.registerImsStateChanged(mQnsProvisioningHandler, EVENT_IMS_STATE_CHANGED);
-    }
-
-    void close() {
-        mQnsImsManager.unregisterImsStateChanged(mQnsProvisioningHandler);
-        mRegistrantList.removeAll();
-        mProvisioningInfo.clear();
-        unregisterProvisioningCallback();
-    }
-
-    private void registerProvisioningCallback() {
-        // checks if the callback is already registered
-        if (mIsProvisioningCallbackRegistered) {
-            log("registerProvisioningCallback: already registered.");
-            return;
-        }
-
-        // checks for validation subscription id.
-        int subId = QnsUtils.getSubId(mContext, mSlotIndex);
-        if (!SubscriptionManager.isValidSubscriptionId(subId)) {
-            log("registerProvisioningCallback failed Invalid Subscription Id");
-            return;
-        }
-
-        log("on registering provisioning callback");
-
-        try {
-            // checks ImsException for ims not supported or unavailable.
-            if (mQnsImsManager.getImsServiceState() != 2) { // STATE_READY
-                throw new Exception();
-            }
-
-            // create provisioning manager.
-            if (mProvisioningManager == null) {
-                mProvisioningManager = ProvisioningManager.createForSubscriptionId(subId);
-            }
-
-            // Register provisioning changed callback
-            mProvisioningManager.registerProvisioningChangedCallback(
-                    mContext.getMainExecutor(), mQnsProvisioningCallback);
-
-            // Set the provisioning callback is registered.
-            mIsProvisioningCallbackRegistered = true;
-
-            log("registered provisioning callback");
-
-            mQnsProvisioningHandler.sendProvisioningCallbackRegistered();
-        } catch (Exception e) {
-            loge("registerProvisioningCallback error: " + e);
-
-            // Unregister the callback
-            unregisterProvisioningCallback();
-
-            // Retry registering provisioning callback.
-            if (!mIsProvisioningCallbackRegistered) {
-                mQnsProvisioningHandler.sendRegisterProvisioningCallback();
-            }
-        }
-    }
-
-    private void unregisterProvisioningCallback() {
-        log("unregisterProvisioningCallback");
-
-        if (mProvisioningManager != null) {
-            try {
-                mProvisioningManager.unregisterProvisioningChangedCallback(
-                        mQnsProvisioningCallback);
-            } catch (Exception e) {
-                loge("unregisterProvisioningCallback error:" + e);
-            }
-        }
-        if (mIsProvisioningCallbackRegistered) {
-            mIsProvisioningCallbackRegistered = false;
-        }
-        if (mProvisioningManager != null) {
-            mProvisioningManager = null;
-        }
-    }
-
-    /**
-     * Register an event for Provisioning value changed.
-     *
-     * @param h the Handler to get event.
-     * @param what the event.
-     * @param userObj user object.
-     * @param notifyImmediately set true if you want to notify immediately.
-     */
-    void registerProvisioningItemInfoChanged(
-            Handler h, int what, Object userObj, boolean notifyImmediately) {
-        if (h != null) {
-            QnsRegistrant r = new QnsRegistrant(h, what, userObj);
-            mRegistrantList.add(r);
-            if (notifyImmediately) {
-                r.notifyRegistrant(
-                        new QnsAsyncResult(null, new QnsProvisioningInfo(mProvisioningInfo), null));
-            }
-        }
-    }
-
-    /**
-     * Unregister an event for Provisioning value changed.
-     *
-     * @param h the handler to get event.
-     */
-    void unregisterProvisioningItemInfoChanged(Handler h) {
-        if (h != null) {
-            mRegistrantList.remove(h);
-        }
-    }
-
-    boolean getLastProvisioningWfcRoamingEnabledInfo() {
-        try {
-            return mProvisioningInfo.getIntegerItem(
-                            ProvisioningManager.KEY_VOICE_OVER_WIFI_ROAMING_ENABLED_OVERRIDE)
-                    != 0;
-        } catch (Exception e) {
-            return false;
-        }
-    }
-
-    private void notifyProvisioningItemInfoChanged(@NonNull QnsProvisioningInfo info) {
-        log("notify ProvisioningItemInfo:" + info);
-        mRegistrantList.notifyRegistrants(new QnsAsyncResult(null, info, null));
-    }
-
-    private void loadDefaultItems() {
-        synchronized (mProvisioningInfo) {
-            loadIntegerItem(ProvisioningManager.KEY_VOLTE_PROVISIONING_STATUS);
-            loadIntegerItem(ProvisioningManager.KEY_VOICE_OVER_WIFI_ROAMING_ENABLED_OVERRIDE);
-            loadIntegerItem(ProvisioningManager.KEY_VOICE_OVER_WIFI_MODE_OVERRIDE);
-            loadIntegerItem(ProvisioningManager.KEY_VOICE_OVER_WIFI_ENABLED_OVERRIDE);
-            loadIntegerItem(ProvisioningManager.KEY_LTE_THRESHOLD_1);
-            loadIntegerItem(ProvisioningManager.KEY_LTE_THRESHOLD_2);
-            loadIntegerItem(ProvisioningManager.KEY_LTE_THRESHOLD_3);
-            loadIntegerItem(ProvisioningManager.KEY_1X_THRESHOLD);
-            loadIntegerItem(ProvisioningManager.KEY_WIFI_THRESHOLD_A);
-            loadIntegerItem(ProvisioningManager.KEY_WIFI_THRESHOLD_B);
-            loadIntegerItem(ProvisioningManager.KEY_LTE_EPDG_TIMER_SEC);
-            loadIntegerItem(ProvisioningManager.KEY_WIFI_EPDG_TIMER_SEC);
-            loadIntegerItem(ProvisioningManager.KEY_1X_EPDG_TIMER_SEC);
-            loadStringItem(ProvisioningManager.KEY_VOICE_OVER_WIFI_ENTITLEMENT_ID);
-            if (mProvisioningInfo.isUpdated()) {
-                mQnsProvisioningHandler.sendNotifyProvisioningInfoChanged();
-            }
-        }
-    }
-
-    private void loadIntegerItem(int item) {
-        try {
-            int value = mProvisioningManager.getProvisioningIntValue(item);
-            log("loadIntegerItem item:" + item + " value:" + value);
-            mProvisioningInfo.setIntegerItem(item, value);
-        } catch (Exception e) {
-            loge("got exception e:" + e);
-        }
-    }
-
-    private void loadStringItem(int item) {
-        try {
-            String value = mProvisioningManager.getProvisioningStringValue(item);
-            log("loadStringItem item:" + item + " value:" + value);
-            mProvisioningInfo.setStringItem(item, value);
-        } catch (Exception e) {
-            loge("got exception e:" + e);
-        }
-    }
-
-    protected void log(String s) {
-        Log.d(mLogTag, s);
-    }
-
-    protected void loge(String s) {
-        Log.e(mLogTag, s);
-    }
-
-    static class QnsProvisioningInfo {
-
-        private final ConcurrentHashMap<Integer, Integer> mIntegerItems;
-        private final ConcurrentHashMap<Integer, String> mStringItems;
-        private boolean mUpdated;
-
-        QnsProvisioningInfo() {
-            mIntegerItems = new ConcurrentHashMap<>();
-            mStringItems = new ConcurrentHashMap<>();
-            mUpdated = false;
-        }
-
-        QnsProvisioningInfo(QnsProvisioningInfo info) {
-            mIntegerItems = new ConcurrentHashMap<>();
-            mStringItems = new ConcurrentHashMap<>();
-            mIntegerItems.putAll(info.mIntegerItems);
-            mStringItems.putAll(info.mStringItems);
-            mUpdated = info.mUpdated;
-        }
-
-        @Override
-        public String toString() {
-            return "QnsProvisioningInfo{"
-                    + "mIntegerItems="
-                    + mIntegerItems
-                    + ", mStringItems="
-                    + mStringItems
-                    + ", mUpdated="
-                    + mUpdated
-                    + '}';
-        }
-
-        boolean hasItem(int item) {
-            return mIntegerItems.get(item) != null || mStringItems.get(item) != null;
-        }
-
-        private void setIntegerItem(int item, int value) {
-            if (value == ProvisioningManager.PROVISIONING_RESULT_UNKNOWN
-                    || (!isValueZeroValidItem(item)
-                            && value == ProvisioningManager.PROVISIONING_VALUE_DISABLED)) {
-                if (mIntegerItems.remove(item) != null) {
-                    markUpdated(true);
-                }
-                return;
-            }
-            if (getIntegerItem(item) != null && getIntegerItem(item) == value) {
-                return;
-            }
-            mIntegerItems.put(item, value);
-            markUpdated(true);
-        }
-
-        Integer getIntegerItem(int item) {
-            return mIntegerItems.get(item);
-        }
-
-        private boolean isValueZeroValidItem(int key) {
-            switch (key) {
-                case ProvisioningManager.KEY_VOLTE_PROVISIONING_STATUS:
-                case ProvisioningManager.KEY_VOICE_OVER_WIFI_ROAMING_ENABLED_OVERRIDE:
-                case ProvisioningManager.KEY_VOICE_OVER_WIFI_MODE_OVERRIDE:
-                case ProvisioningManager.KEY_VOICE_OVER_WIFI_ENABLED_OVERRIDE:
-                case ProvisioningManager.KEY_VOICE_OVER_WIFI_ENTITLEMENT_ID:
-                    return true;
-                case ProvisioningManager.KEY_LTE_THRESHOLD_1:
-                case ProvisioningManager.KEY_LTE_THRESHOLD_2:
-                case ProvisioningManager.KEY_LTE_THRESHOLD_3:
-                case ProvisioningManager.KEY_1X_THRESHOLD:
-                case ProvisioningManager.KEY_WIFI_THRESHOLD_A:
-                case ProvisioningManager.KEY_WIFI_THRESHOLD_B:
-                case ProvisioningManager.KEY_LTE_EPDG_TIMER_SEC:
-                case ProvisioningManager.KEY_WIFI_EPDG_TIMER_SEC:
-                case ProvisioningManager.KEY_1X_EPDG_TIMER_SEC:
-                    return false;
-            }
-            return true;
-        }
-
-        private void setStringItem(int item, String value) {
-            if (ProvisioningManager.STRING_QUERY_RESULT_ERROR_GENERIC.equals(value)
-                    || ProvisioningManager.STRING_QUERY_RESULT_ERROR_NOT_READY.equals(value)) {
-                if (mStringItems.remove(item) != null) {
-                    markUpdated(true);
-                }
-                return;
-            }
-            if (TextUtils.equals(value, getStringItem(item))) {
-                return;
-            }
-            mStringItems.put(item, value);
-            markUpdated(true);
-        }
-
-        String getStringItem(int item) {
-            return mStringItems.get(item);
-        }
-
-        void clear() {
-            mIntegerItems.clear();
-            mStringItems.clear();
-            markUpdated(false);
-        }
-
-        void markUpdated(boolean bUpdated) {
-            mUpdated = bUpdated;
-        }
-
-        boolean isUpdated() {
-            return mUpdated;
-        }
-
-        boolean equalsIntegerItem(QnsProvisioningInfo info, int key) {
-            Integer my = getIntegerItem(key);
-            Integer other = info.getIntegerItem(key);
-            if (my == null && other == null) {
-                return true;
-            } else if (my != null && other != null) {
-                int myvalue = my;
-                int othervalue = other;
-                return myvalue == othervalue;
-            }
-            return false;
-        }
-    }
-
-    private class QnsProvisioningCallback extends ProvisioningManager.Callback {
-        /** Constructor */
-        QnsProvisioningCallback() {}
-
-        /**
-         * Called when a provisioning item has changed.
-         *
-         * @param item the IMS provisioning key constant, as defined by the OEM.
-         * @param value the new integer value of the IMS provisioning key.
-         */
-        @Override
-        public void onProvisioningIntChanged(int item, int value) {
-            synchronized (mProvisioningInfo) {
-                mProvisioningInfo.setIntegerItem(item, value);
-                if (mProvisioningInfo.isUpdated()) {
-                    mQnsProvisioningHandler.sendNotifyProvisioningInfoChanged();
-                }
-            }
-        }
-
-        /**
-         * Called when a provisioning item has changed.
-         *
-         * @param item the IMS provisioning key constant, as defined by the OEM.
-         * @param value the new String value of the IMS configuration constant.
-         */
-        @Override
-        public void onProvisioningStringChanged(int item, String value) {
-            synchronized (mProvisioningInfo) {
-                mProvisioningInfo.setStringItem(item, value);
-                if (mProvisioningInfo.isUpdated()) {
-                    mQnsProvisioningHandler.sendNotifyProvisioningInfoChanged();
-                }
-            }
-        }
-    }
-
-    @VisibleForTesting
-    class QnsProvisioningHandler extends Handler {
-        private int mRetryRegisterProvisioningCallbackCount;
-
-        QnsProvisioningHandler(Looper looper) {
-            super(looper);
-            mRetryRegisterProvisioningCallbackCount = REG_CALLBACK_RETRY;
-        }
-
-        void resetRetryRegisterProvisioningCallbackCount() {
-            mRetryRegisterProvisioningCallbackCount = REG_CALLBACK_RETRY;
-        }
-
-        @Override
-        public void handleMessage(Message message) {
-            log("message what:" + message.what);
-            QnsAsyncResult ar = (QnsAsyncResult) message.obj;
-            switch (message.what) {
-                case EVENT_IMS_STATE_CHANGED:
-                    if (ar != null) {
-                        QnsImsManager.ImsState state = (QnsImsManager.ImsState) ar.mResult;
-                        if (state.isImsAvailable()) {
-                            log("ImsState is changed to available");
-                            unregisterProvisioningCallback();
-                            resetRetryRegisterProvisioningCallbackCount();
-                            registerProvisioningCallback();
-                        } else {
-                            log("ImsState is changed to unavailable");
-                            clearLastProvisioningInfo();
-                        }
-                    }
-                    break;
-                case EVENT_REGISTER_PROVISIONING_CALLBACK:
-                    registerProvisioningCallback();
-                    break;
-                case EVENT_CALLBACK_REGISTERED:
-                    loadDefaultItems();
-                    break;
-                case EVENT_NOTIFY_PROVISION_INFO_CHANGED:
-                    synchronized (mProvisioningInfo) {
-                        if (mProvisioningInfo.isUpdated()) {
-                            notifyProvisioningItemInfoChanged(
-                                    new QnsProvisioningInfo(mProvisioningInfo));
-                            mProvisioningInfo.markUpdated(false);
-                        }
-                    }
-                    break;
-                default:
-                    break;
-            }
-        }
-
-        void sendRegisterProvisioningCallback() {
-            mRetryRegisterProvisioningCallbackCount--;
-            if (mRetryRegisterProvisioningCallbackCount > 0) {
-                removeMessages(EVENT_REGISTER_PROVISIONING_CALLBACK);
-                Message msg = obtainMessage(EVENT_REGISTER_PROVISIONING_CALLBACK);
-                sendMessageDelayed(msg, REG_CALLBACK_DELAY);
-            }
-        }
-
-        void sendProvisioningCallbackRegistered() {
-            removeMessages(EVENT_REGISTER_PROVISIONING_CALLBACK);
-            resetRetryRegisterProvisioningCallbackCount();
-            Message msg = obtainMessage(EVENT_CALLBACK_REGISTERED);
-            sendMessage(msg);
-        }
-
-        void sendNotifyProvisioningInfoChanged() {
-            removeMessages(EVENT_NOTIFY_PROVISION_INFO_CHANGED);
-            Message msg = obtainMessage(EVENT_NOTIFY_PROVISION_INFO_CHANGED);
-            sendMessageDelayed(msg, 100);
-        }
-    }
-
-    private void clearLastProvisioningInfo() {
-        synchronized (mProvisioningInfo) {
-            mProvisioningInfo.clear();
-        }
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsRegistrant.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsRegistrant.java
deleted file mode 100644
index 4bd919b..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsRegistrant.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import android.os.Handler;
-import android.os.Message;
-
-import java.lang.ref.WeakReference;
-
-/** @hide */
-class QnsRegistrant {
-    protected WeakReference<Handler> mRefH;
-    protected int mWhat;
-    protected Object mUserObj;
-
-    QnsRegistrant(Handler h, int what, Object obj) {
-        mRefH = new WeakReference<>(h);
-        mWhat = what;
-        mUserObj = obj;
-    }
-
-    /** Clear registrant. */
-    void clear() {
-        mRefH = null;
-        mUserObj = null;
-    }
-
-    /**
-     * notify result
-     *
-     * @param result Object to notify
-     */
-    void notifyResult(Object result) {
-        internalNotifyRegistrant(result, null);
-    }
-
-    /**
-     * notify registrant
-     *
-     * @param ar QnsAsyncResult to notify
-     */
-    void notifyRegistrant(QnsAsyncResult ar) {
-        internalNotifyRegistrant(ar.mResult, ar.mException);
-    }
-
-    protected void internalNotifyRegistrant(Object result, Throwable exception) {
-        Handler h = getHandler();
-
-        if (h == null) {
-            clear();
-        } else {
-            Message msg = Message.obtain();
-
-            msg.what = mWhat;
-            msg.obj = new QnsAsyncResult(mUserObj, result, exception);
-            h.sendMessage(msg);
-        }
-    }
-
-    /**
-     * get a handler.
-     *
-     * @return Handler
-     */
-    Handler getHandler() {
-        if (mRefH == null) {
-            return null;
-        }
-
-        return mRefH.get();
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsRegistrantList.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsRegistrantList.java
deleted file mode 100644
index c4cb79f..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsRegistrantList.java
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import android.os.Handler;
-
-import java.util.ArrayList;
-
-/** @hide */
-class QnsRegistrantList {
-    protected final ArrayList<QnsRegistrant> mRegistrants;
-
-    /** constructor */
-    QnsRegistrantList() {
-        mRegistrants = new ArrayList<>();
-    }
-
-    /**
-     * Add each element for the registrant.
-     *
-     * @param h handler
-     * @param what message to be delivered
-     * @param obj object
-     */
-    synchronized void add(Handler h, int what, Object obj) {
-        add(new QnsRegistrant(h, what, obj));
-    }
-
-    /**
-     * Add each element for the registrant. does not allow duplicated handler
-     *
-     * @param h handler
-     * @param what message to be delivered
-     * @param obj object
-     */
-    synchronized void addUnique(Handler h, int what, Object obj) {
-        // if the handler is already in the registrant list, remove it
-        remove(h);
-        add(new QnsRegistrant(h, what, obj));
-    }
-
-    /**
-     * Add the registrant.
-     *
-     * @param r registrant.
-     */
-    synchronized void add(QnsRegistrant r) {
-        removeCleared();
-        mRegistrants.add(r);
-    }
-
-    /** Remove cleared registrant in list */
-    synchronized void removeCleared() {
-        for (int i = mRegistrants.size() - 1; i >= 0; i--) {
-            QnsRegistrant r = mRegistrants.get(i);
-
-            if (r.mRefH == null) {
-                mRegistrants.remove(i);
-            }
-        }
-    }
-
-    /** Remove all registrant */
-    synchronized void removeAll() {
-        mRegistrants.clear();
-    }
-
-    /**
-     * Returns size of Registrant.
-     *
-     * @return size
-     */
-    synchronized int size() {
-        return mRegistrants.size();
-    }
-
-    /**
-     * Returns Object from the list
-     *
-     * @param index index
-     * @return Object
-     */
-    synchronized Object get(int index) {
-        return mRegistrants.get(index);
-    }
-
-    private synchronized void internalNotifyRegistrants(Object result, Throwable exception) {
-        for (QnsRegistrant registrant : mRegistrants) {
-            registrant.internalNotifyRegistrant(result, exception);
-        }
-    }
-
-    /** notify registrant */
-    void notifyRegistrants() {
-        internalNotifyRegistrants(null, null);
-    }
-
-    /**
-     * notify registrant with given object
-     *
-     * @param result object
-     */
-    void notifyResult(Object result) {
-        internalNotifyRegistrants(result, null);
-    }
-
-    /**
-     * notify registrant
-     *
-     * @param ar QnsAsyncResult to be notified
-     */
-    void notifyRegistrants(QnsAsyncResult ar) {
-        internalNotifyRegistrants(ar.mResult, ar.mException);
-    }
-
-    /**
-     * remove handler in list
-     *
-     * @param h handler
-     */
-    synchronized void remove(Handler h) {
-        for (QnsRegistrant r : mRegistrants) {
-            Handler rh;
-
-            rh = r.getHandler();
-
-            /* Clean up both the requested registrant and
-             * any now-collected registrants
-             */
-            if (rh == null || rh == h) {
-                r.clear();
-            }
-        }
-
-        removeCleared();
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsTelephonyListener.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsTelephonyListener.java
deleted file mode 100644
index 9e59736..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsTelephonyListener.java
+++ /dev/null
@@ -1,1267 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static android.telephony.BarringInfo.BARRING_SERVICE_TYPE_EMERGENCY;
-import static android.telephony.BarringInfo.BARRING_SERVICE_TYPE_MMTEL_VOICE;
-
-import android.annotation.NonNull;
-import android.content.Context;
-import android.net.NetworkCapabilities;
-import android.os.Binder;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.Annotation;
-import android.telephony.BarringInfo;
-import android.telephony.CallState;
-import android.telephony.NetworkRegistrationInfo;
-import android.telephony.NrVopsSupportInfo;
-import android.telephony.PreciseDataConnectionState;
-import android.telephony.ServiceState;
-import android.telephony.SubscriptionManager;
-import android.telephony.TelephonyCallback;
-import android.telephony.TelephonyManager;
-import android.telephony.VopsSupportInfo;
-import android.telephony.ims.ImsReasonInfo;
-import android.telephony.ims.MediaQualityStatus;
-import android.util.Log;
-
-import com.android.internal.annotations.VisibleForTesting;
-
-import java.io.PrintWriter;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Objects;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.Executor;
-import java.util.function.Consumer;
-
-/*
- * QnsTelephonyListener
- * Tracks Cellular ServiceState per each slot.
- */
-class QnsTelephonyListener {
-
-    private static final Archiving<PreciseDataConnectionState>
-            sArchivingPreciseDataConnectionState = new Archiving<>();
-    private final String mLogTag;
-    private final int mSlotIndex;
-    private final Context mContext;
-    private final SubscriptionManager mSubscriptionManager;
-    private final Handler mHandler;
-    private final HandlerThread mHandlerThread;
-    QnsRegistrantList mCallStateListener = new QnsRegistrantList();
-    QnsRegistrantList mSrvccStateListener = new QnsRegistrantList();
-    QnsRegistrantList mSubscriptionIdListener = new QnsRegistrantList();
-    QnsRegistrantList mIwlanServiceStateListener = new QnsRegistrantList();
-    QnsRegistrantList mImsCallDropDisconnectCauseListener = new QnsRegistrantList();
-    List<Consumer<List<CallState>>> mCallStatesConsumerList = new ArrayList<>();
-    List<Consumer<Integer>> mSrvccStateConsumerList = new ArrayList<>();
-    List<Consumer<MediaQualityStatus>> mMediaQualityConsumerList = new ArrayList<>();
-    protected ConcurrentHashMap<Integer, QnsRegistrantList> mQnsTelephonyInfoRegistrantMap =
-            new ConcurrentHashMap<>();
-    protected ConcurrentHashMap<Integer, QnsRegistrantList> mNetCapabilityRegistrantMap =
-            new ConcurrentHashMap<>();
-    protected QnsTelephonyInfo mLastQnsTelephonyInfo = new QnsTelephonyInfo();
-    protected QnsTelephonyInfoIms mLastQnsTelephonyInfoIms = new QnsTelephonyInfoIms();
-    protected ServiceState mLastServiceState = new ServiceState();
-    protected HashMap<Integer, PreciseDataConnectionState> mLastPreciseDataConnectionState =
-            new HashMap<>();
-    private int mSubId;
-    @VisibleForTesting TelephonyListener mTelephonyListener;
-    private int mCoverage;
-    @Annotation.CallState private int mCallState;
-
-    @VisibleForTesting
-    final SubscriptionManager.OnSubscriptionsChangedListener mSubscriptionsChangeListener =
-            new SubscriptionManager.OnSubscriptionsChangedListener() {
-                @Override
-                public void onSubscriptionsChanged() {
-                    int newSubId = QnsUtils.getSubId(mContext, mSlotIndex);
-                    if ((mSubId != newSubId)
-                            && (newSubId != SubscriptionManager.INVALID_SUBSCRIPTION_ID)) {
-                        stopTelephonyListener(mSubId); // old
-                        mSubId = newSubId;
-                        onSubscriptionIdChanged(newSubId);
-                        startTelephonyListener(newSubId); // new
-                    }
-                }
-            };
-
-    /** Default constructor. */
-    QnsTelephonyListener(@NonNull Context context, int slotIndex) {
-        mLogTag = QnsTelephonyListener.class.getSimpleName() + "_" + slotIndex;
-        mSlotIndex = slotIndex;
-        mContext = context;
-
-        mSubscriptionManager = mContext.getSystemService(SubscriptionManager.class);
-        mHandlerThread = new HandlerThread(QnsTelephonyListener.class.getSimpleName());
-        mHandlerThread.start();
-        mHandler = new Handler(mHandlerThread.getLooper());
-
-        mSubId = QnsUtils.getSubId(mContext, mSlotIndex);
-        startTelephonyListener(mSubId);
-
-        if (mSubscriptionManager != null) {
-            mSubscriptionManager.addOnSubscriptionsChangedListener(
-                    new QnsUtils.QnsExecutor(mHandler), mSubscriptionsChangeListener);
-        }
-    }
-
-    private static int registrationStateToServiceState(int registrationState) {
-        switch (registrationState) {
-            case NetworkRegistrationInfo.REGISTRATION_STATE_HOME:
-            case NetworkRegistrationInfo.REGISTRATION_STATE_ROAMING:
-                return ServiceState.STATE_IN_SERVICE;
-            default:
-                return ServiceState.STATE_OUT_OF_SERVICE;
-        }
-    }
-
-    protected void notifyQnsTelephonyInfo(QnsTelephonyInfo info) {
-        QnsAsyncResult ar;
-        for (Integer netCapability : mQnsTelephonyInfoRegistrantMap.keySet()) {
-            if (netCapability == NetworkCapabilities.NET_CAPABILITY_IMS
-                    || netCapability == NetworkCapabilities.NET_CAPABILITY_EIMS) {
-                ar = new QnsAsyncResult(null, mLastQnsTelephonyInfoIms, null);
-            } else {
-                ar = new QnsAsyncResult(null, info, null);
-            }
-            mQnsTelephonyInfoRegistrantMap.get(netCapability).notifyRegistrants(ar);
-        }
-    }
-
-    protected void notifyQnsTelephonyInfoIms(QnsTelephonyInfoIms info) {
-        QnsAsyncResult ar = new QnsAsyncResult(null, info, null);
-        QnsRegistrantList imsRegList =
-                mQnsTelephonyInfoRegistrantMap.get(NetworkCapabilities.NET_CAPABILITY_IMS);
-        QnsRegistrantList sosRegList =
-                mQnsTelephonyInfoRegistrantMap.get(NetworkCapabilities.NET_CAPABILITY_EIMS);
-        if (imsRegList != null) {
-            imsRegList.notifyRegistrants(ar);
-        }
-        if (sosRegList != null) {
-            sosRegList.notifyRegistrants(ar);
-        }
-    }
-
-    protected void notifyIwlanServiceStateInfo(boolean isInService) {
-        mIwlanServiceStateListener.notifyResult(isInService);
-    }
-
-    protected void notifyPreciseDataConnectionStateChanged(
-            PreciseDataConnectionState connectionState) {
-        List<Integer> netCapabilities =
-                QnsUtils.getNetCapabilitiesFromApnTypeBitmask(
-                        connectionState.getApnSetting().getApnTypeBitmask());
-        QnsAsyncResult ar = new QnsAsyncResult(null, connectionState, null);
-        for (int netCapability : netCapabilities) {
-            PreciseDataConnectionState lastState = getLastPreciseDataConnectionState(netCapability);
-            if (lastState == null || !lastState.equals(connectionState)) {
-                mLastPreciseDataConnectionState.put(netCapability, connectionState);
-                sArchivingPreciseDataConnectionState.put(
-                        mSubId, connectionState.getTransportType(), netCapability, connectionState);
-                QnsRegistrantList netCapabilityRegistrantList =
-                        mNetCapabilityRegistrantMap.get(netCapability);
-                if (netCapabilityRegistrantList != null) {
-                    netCapabilityRegistrantList.notifyRegistrants(ar);
-                }
-            } else {
-                log(
-                        "onPreciseDataConnectionStateChanged state received for netCapability is"
-                                + " same:"
-                                + netCapability);
-            }
-        }
-    }
-
-    /** Get a last QnsTelephonyInfo notified previously. */
-    QnsTelephonyInfo getLastQnsTelephonyInfo() {
-        return mLastQnsTelephonyInfo;
-    }
-
-    /** Get a last of the precise data connection state per netCapability. */
-    PreciseDataConnectionState getLastPreciseDataConnectionState(int netCapability) {
-        return mLastPreciseDataConnectionState.get(netCapability);
-    }
-
-    /**
-     * Register an event for QnsTelephonyInfo changed.
-     *
-     * @param netCapability Network Capability to be notified.
-     * @param h the Handler to get event.
-     * @param what the event.
-     * @param userObj user object.
-     * @param notifyImmediately set true if want to notify immediately.
-     */
-    void registerQnsTelephonyInfoChanged(
-            int netCapability, Handler h, int what, Object userObj, boolean notifyImmediately) {
-        if (h != null) {
-            QnsRegistrant r = new QnsRegistrant(h, what, userObj);
-            QnsRegistrantList netCapabilityRegistrantList =
-                    mQnsTelephonyInfoRegistrantMap.get(netCapability);
-            if (netCapabilityRegistrantList == null) {
-                netCapabilityRegistrantList = new QnsRegistrantList();
-                mQnsTelephonyInfoRegistrantMap.put(netCapability, netCapabilityRegistrantList);
-            }
-            netCapabilityRegistrantList.add(r);
-
-            if (notifyImmediately) {
-                r.notifyRegistrant(new QnsAsyncResult(null, getLastQnsTelephonyInfo(), null));
-            }
-        }
-    }
-
-    /**
-     * Register an event for Precise Data Connection State Changed.
-     *
-     * @param netCapability Network Capability to be notified.
-     * @param h the handler to get event.
-     * @param what the event.
-     */
-    void registerPreciseDataConnectionStateChanged(
-            int netCapability, Handler h, int what, Object userObj, boolean notifyImmediately) {
-        if (h != null) {
-            QnsRegistrant r = new QnsRegistrant(h, what, userObj);
-            QnsRegistrantList netCapabilityRegistrantList =
-                    mNetCapabilityRegistrantMap.get(netCapability);
-            if (netCapabilityRegistrantList == null) {
-                netCapabilityRegistrantList = new QnsRegistrantList();
-                mNetCapabilityRegistrantMap.put(netCapability, netCapabilityRegistrantList);
-            }
-            netCapabilityRegistrantList.add(r);
-
-            PreciseDataConnectionState pdcs = getLastPreciseDataConnectionState(netCapability);
-            if (notifyImmediately && pdcs != null) {
-                r.notifyRegistrant(new QnsAsyncResult(null, pdcs, null));
-            }
-        }
-    }
-
-    /**
-     * Register an event for CallState changed.
-     *
-     * @param h the Handler to get event.
-     * @param what the event.
-     * @param userObj user object.
-     * @param notifyImmediately set true if want to notify immediately.
-     */
-    void registerCallStateListener(Handler h, int what, Object userObj, boolean notifyImmediately) {
-        log("registerCallStateListener");
-        if (h != null) {
-            QnsRegistrant r = new QnsRegistrant(h, what, userObj);
-            mCallStateListener.add(r);
-
-            if (notifyImmediately) {
-                r.notifyRegistrant(new QnsAsyncResult(null, mCallState, null));
-            }
-        }
-    }
-
-    /**
-     * Register an event for SRVCC state changed.
-     *
-     * @param h the Handler to get event.
-     * @param what the event.
-     * @param userObj user object.
-     */
-    void registerSrvccStateListener(Handler h, int what, Object userObj) {
-        log("registerSrvccStateListener");
-        if (h != null) {
-            QnsRegistrant r = new QnsRegistrant(h, what, userObj);
-            mSrvccStateListener.add(r);
-        }
-    }
-
-    /**
-     * Register an event for subscription Id changed.
-     *
-     * @param h the Handler to get event.
-     * @param what the event.
-     * @param userObj user object.
-     */
-    void registerSubscriptionIdListener(Handler h, int what, Object userObj) {
-        log("registerSubscriptionIdListener");
-        if (h != null) {
-            QnsRegistrant r = new QnsRegistrant(h, what, userObj);
-            mSubscriptionIdListener.add(r);
-        }
-    }
-
-    /**
-     * Register an event for iwlan service state changed.
-     *
-     * @param h the Handler to get event.
-     * @param what the event.
-     * @param userObj user object.
-     */
-    void registerIwlanServiceStateListener(Handler h, int what, Object userObj) {
-        log("registerIwlanServiceStateListener");
-        if (h != null) {
-            QnsRegistrant r = new QnsRegistrant(h, what, userObj);
-            mIwlanServiceStateListener.add(r);
-
-            NetworkRegistrationInfo lastIwlanNrs =
-                    mLastServiceState.getNetworkRegistrationInfo(
-                            NetworkRegistrationInfo.DOMAIN_PS,
-                            AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-            if (lastIwlanNrs != null) {
-                r.notifyRegistrant(
-                        new QnsAsyncResult(null, lastIwlanNrs.isNetworkRegistered(), null));
-            }
-        }
-    }
-
-    /**
-     * Register an event for ImsCallDropDisconnectCause changed.
-     *
-     * @param h the Handler to get event.
-     * @param what the event.
-     * @param userObj user object.
-     */
-    void registerImsCallDropDisconnectCauseListener(Handler h, int what, Object userObj) {
-        log("registerImsCallDropDisconnectCauseListener");
-        if (h != null) {
-            QnsRegistrant r = new QnsRegistrant(h, what, userObj);
-            mImsCallDropDisconnectCauseListener.add(r);
-        }
-    }
-
-    /**
-     * Unregister an event for QnsTelephonyInfo changed.
-     *
-     * @param netCapability Network Capability to be notified.
-     * @param h the handler to get event.
-     */
-    void unregisterQnsTelephonyInfoChanged(int netCapability, Handler h) {
-        if (h != null) {
-            QnsRegistrantList netCapabilityRegistrantList =
-                    mQnsTelephonyInfoRegistrantMap.get(netCapability);
-            if (netCapabilityRegistrantList != null) {
-                netCapabilityRegistrantList.remove(h);
-            }
-        }
-    }
-
-    /**
-     * Unregister an event for Precise Data Connectio State Changed.
-     *
-     * @param netCapability Network Capability to be notified.
-     * @param h the handler to get event.
-     */
-    void unregisterPreciseDataConnectionStateChanged(int netCapability, Handler h) {
-        if (h != null) {
-            QnsRegistrantList netCapabilityRegistrantList =
-                    mNetCapabilityRegistrantMap.get(netCapability);
-            if (netCapabilityRegistrantList != null) {
-                netCapabilityRegistrantList.remove(h);
-            }
-        }
-    }
-
-    /**
-     * Unregister an event for CallState changed.
-     *
-     * @param h the handler to get event.
-     */
-    void unregisterCallStateChanged(Handler h) {
-        log("unregisterCallStateChanged");
-        if (h != null) {
-            mCallStateListener.remove(h);
-        }
-    }
-
-    /**
-     * Unregister an event for SRVCC state changed.
-     *
-     * @param h the handler to get event.
-     */
-    void unregisterSrvccStateChanged(Handler h) {
-        log("unregisterSrvccStateChanged");
-        if (h != null) {
-            mSrvccStateListener.remove(h);
-        }
-    }
-
-    /**
-     * Unregister an event for subscription Id changed.
-     *
-     * @param h the handler to get event.
-     */
-    void unregisterSubscriptionIdChanged(Handler h) {
-        log("unregisterSubscriptionIdChanged");
-        if (h != null) {
-            mSubscriptionIdListener.remove(h);
-        }
-    }
-
-    /**
-     * Unregister an event for iwlan service state changed.
-     *
-     * @param h the handler to get event.
-     */
-    void unregisterIwlanServiceStateChanged(Handler h) {
-        log("unregisterIwlanServiceStateChanged");
-        if (h != null) {
-            mIwlanServiceStateListener.remove(h);
-        }
-    }
-
-    /**
-     * Unregister an event for ImsCallDropDisconnectCause state changed.
-     *
-     * @param h the handler to get event.
-     */
-    void unregisterImsCallDropDisconnectCauseListener(Handler h) {
-        log("unregisterImsCallDropDisconnectCauseListener");
-        if (h != null) {
-            mImsCallDropDisconnectCauseListener.remove(h);
-        }
-    }
-
-    private void createTelephonyListener() {
-        if (mTelephonyListener == null) {
-            mTelephonyListener = new TelephonyListener(mContext.getMainExecutor());
-            mTelephonyListener.setServiceStateListener(
-                    (ServiceState serviceState) -> {
-                        onServiceStateChanged(serviceState);
-                    });
-            mTelephonyListener.setPreciseDataConnectionStateListener(
-                    (PreciseDataConnectionState connectionState) -> {
-                        onPreciseDataConnectionStateChanged(connectionState);
-                    });
-            mTelephonyListener.setBarringInfoListener(
-                    (BarringInfo barringInfo) -> {
-                        onBarringInfoChanged(barringInfo);
-                    });
-            mTelephonyListener.setCallStateListener(
-                    (int callState) -> {
-                        onCallStateChanged(callState);
-                    });
-            mTelephonyListener.setSrvccStateListener(
-                    (int srvccState) -> {
-                        onSrvccStateChanged(srvccState);
-                    });
-            mTelephonyListener.setImsCallDisconnectCauseListener(
-                    (ImsReasonInfo imsReasonInfo) -> {
-                        onImsCallDisconnectCauseChanged(imsReasonInfo);
-                    });
-        }
-    }
-
-    protected void stopTelephonyListener(int subId) {
-        if (mTelephonyListener == null) {
-            return;
-        }
-        mTelephonyListener.unregister(subId);
-        cleanupQnsTelephonyListenerSettings();
-    }
-
-    protected void startTelephonyListener(int subId) {
-        if (subId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
-            return;
-        }
-        if (mTelephonyListener == null) {
-            createTelephonyListener();
-        }
-        mTelephonyListener.register(mContext, subId);
-    }
-
-    private void cleanupQnsTelephonyListenerSettings() {
-        log("cleanupQnsTelephonyListenerSettings");
-        mLastQnsTelephonyInfo = new QnsTelephonyInfo();
-        mLastQnsTelephonyInfoIms = new QnsTelephonyInfoIms();
-        mLastServiceState = new ServiceState();
-        mLastPreciseDataConnectionState = new HashMap<>();
-        // mCoverage, keep previous state.
-        mCallState = QnsConstants.CALL_TYPE_IDLE;
-    }
-
-    protected void onServiceStateChanged(ServiceState serviceState) {
-        QnsTelephonyInfo newInfo = new QnsTelephonyInfo(mLastQnsTelephonyInfo);
-
-        NetworkRegistrationInfo newIwlanNrs =
-                serviceState.getNetworkRegistrationInfo(
-                        NetworkRegistrationInfo.DOMAIN_PS,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        NetworkRegistrationInfo oldIwlanNrs =
-                mLastServiceState.getNetworkRegistrationInfo(
-                        NetworkRegistrationInfo.DOMAIN_PS,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        if (newIwlanNrs != null
-                && (oldIwlanNrs == null
-                        || newIwlanNrs.isNetworkRegistered()
-                                != oldIwlanNrs.isNetworkRegistered())) {
-            log("Iwlan is in service: " + newIwlanNrs.isNetworkRegistered());
-            notifyIwlanServiceStateInfo(newIwlanNrs.isNetworkRegistered());
-        }
-
-        NetworkRegistrationInfo newWwanNrs =
-                serviceState.getNetworkRegistrationInfo(
-                        NetworkRegistrationInfo.DOMAIN_PS,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        NetworkRegistrationInfo oldWwanNrs =
-                mLastServiceState.getNetworkRegistrationInfo(
-                        NetworkRegistrationInfo.DOMAIN_PS,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        NetworkRegistrationInfo newWwanCsNrs =
-                serviceState.getNetworkRegistrationInfo(
-                        NetworkRegistrationInfo.DOMAIN_CS,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        // Event for voice registration state changed
-        if (newWwanCsNrs != null) {
-            newInfo.setVoiceNetworkType(newWwanCsNrs.getAccessNetworkTechnology());
-        }
-
-        // Event for cellular data tech changed
-        if (newWwanNrs != null) {
-            newInfo.setDataNetworkType(newWwanNrs.getAccessNetworkTechnology());
-            newInfo.setDataRegState(
-                    registrationStateToServiceState(newWwanNrs.getNetworkRegistrationState()));
-
-            // Event for cellular data roaming registration state changed.
-            // Refer roaming state which is not overridden by configs.
-            if (!newWwanNrs.isNetworkRoaming()) {
-                mCoverage = QnsConstants.COVERAGE_HOME;
-            } else {
-                mCoverage = QnsConstants.COVERAGE_ROAM;
-            }
-            newInfo.setRegisteredPlmn(newWwanNrs.getRegisteredPlmn());
-            newInfo.setCoverage(mCoverage == QnsConstants.COVERAGE_ROAM);
-        } else {
-            newInfo.setRegisteredPlmn(null);
-        }
-
-        // Event for cellular ps attach state changed.
-        boolean hasAirplaneModeOnChanged =
-                mLastServiceState.getState() != ServiceState.STATE_POWER_OFF
-                        && serviceState.getState() == ServiceState.STATE_POWER_OFF;
-        if ((oldWwanNrs == null || !oldWwanNrs.isNetworkRegistered() || hasAirplaneModeOnChanged)
-                && (newWwanNrs != null && newWwanNrs.isNetworkRegistered())) {
-            newInfo.setCellularAvailable(true);
-        }
-        if ((oldWwanNrs != null && oldWwanNrs.isNetworkRegistered())
-                && (newWwanNrs == null || !newWwanNrs.isNetworkRegistered())) {
-            newInfo.setCellularAvailable(false);
-        }
-
-        // Event for VOPS changed
-        boolean vopsSupport = isSupportVoPS(newWwanNrs);
-        boolean vopsEmergencySupport = isSupportEmergencyService(newWwanNrs);
-        boolean vopsSupportChanged = vopsSupport != mLastQnsTelephonyInfoIms.getVopsSupport();
-        boolean vopsEmergencySupportChanged =
-                vopsEmergencySupport != mLastQnsTelephonyInfoIms.getVopsEmergencySupport();
-
-        if (!newInfo.equals(mLastQnsTelephonyInfo)) {
-            StringBuilder sb = new StringBuilder();
-            if (newInfo.getVoiceNetworkType() != mLastQnsTelephonyInfo.getVoiceNetworkType()) {
-                sb.append(" voiceTech:").append(newInfo.getVoiceNetworkType());
-            }
-            if (newInfo.getDataNetworkType() != mLastQnsTelephonyInfo.getDataNetworkType()) {
-                sb.append(" dataTech:").append(newInfo.getDataNetworkType());
-            }
-            if (newInfo.getDataRegState() != mLastQnsTelephonyInfo.getDataRegState()) {
-                sb.append(" dataRegState:").append(newInfo.getDataRegState());
-            }
-            if (newInfo.isCoverage() != mLastQnsTelephonyInfo.isCoverage()) {
-                sb.append(" coverage:").append(newInfo.isCoverage() ? "ROAM" : "HOME");
-            }
-            if (newInfo.isCellularAvailable() != mLastQnsTelephonyInfo.isCellularAvailable()) {
-                sb.append(" cellAvailable:").append(newInfo.isCellularAvailable());
-            }
-            if (vopsSupportChanged) {
-                sb.append(" VOPS support:").append(vopsSupport);
-            }
-            if (vopsSupportChanged) {
-                sb.append(" VOPS emergency support:").append(vopsEmergencySupport);
-            }
-
-            log("onCellularServiceStateChanged QnsTelephonyInfo:" + sb);
-
-            mLastQnsTelephonyInfo = newInfo;
-            mLastQnsTelephonyInfoIms =
-                    new QnsTelephonyInfoIms(
-                            newInfo,
-                            vopsSupport,
-                            vopsEmergencySupport,
-                            mLastQnsTelephonyInfoIms.getVoiceBarring(),
-                            mLastQnsTelephonyInfoIms.getEmergencyBarring());
-            mLastServiceState = serviceState;
-            notifyQnsTelephonyInfo(newInfo);
-        } else {
-            if (vopsSupportChanged || vopsEmergencySupportChanged) {
-                log("onCellularServiceStateChanged VoPS enabled" + vopsSupport);
-                log("onCellularServiceStateChanged VoPS EMC support" + vopsEmergencySupport);
-                mLastQnsTelephonyInfoIms.setVopsSupport(vopsSupport);
-                mLastQnsTelephonyInfoIms.setVopsEmergencySupport(vopsEmergencySupport);
-                notifyQnsTelephonyInfoIms(mLastQnsTelephonyInfoIms);
-            }
-        }
-        mLastServiceState = serviceState;
-    }
-
-    boolean isAirplaneModeEnabled() {
-        return mLastServiceState.getState() == ServiceState.STATE_POWER_OFF;
-    }
-
-    boolean isSupportVoPS() {
-        try {
-            NetworkRegistrationInfo networkRegInfo =
-                    mLastServiceState.getNetworkRegistrationInfo(
-                            NetworkRegistrationInfo.DOMAIN_PS,
-                            AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-            return isSupportVoPS(networkRegInfo);
-        } catch (NullPointerException e) {
-            return false;
-        }
-    }
-
-    private boolean isSupportVoPS(NetworkRegistrationInfo nri) {
-        try {
-            VopsSupportInfo vopsInfo = nri.getDataSpecificInfo().getVopsSupportInfo();
-            if (vopsInfo instanceof NrVopsSupportInfo) {
-                NrVopsSupportInfo nrVopsInfo = (NrVopsSupportInfo) vopsInfo;
-                return nrVopsInfo.getVopsSupport()
-                        == NrVopsSupportInfo.NR_STATUS_VOPS_3GPP_SUPPORTED;
-            } else {
-                return vopsInfo.isVopsSupported();
-            }
-        } catch (NullPointerException e) {
-            return false;
-        }
-    }
-
-    boolean isSupportEmergencyService() {
-        return mLastQnsTelephonyInfoIms.getVopsEmergencySupport();
-    }
-
-    private boolean isSupportEmergencyService(NetworkRegistrationInfo networkRegInfo) {
-        try {
-            VopsSupportInfo vopsInfo = networkRegInfo.getDataSpecificInfo().getVopsSupportInfo();
-            if (vopsInfo instanceof NrVopsSupportInfo) {
-                NrVopsSupportInfo nrVopsInfo = (NrVopsSupportInfo) vopsInfo;
-                return nrVopsInfo.isEmergencyServiceSupported();
-            } else {
-                return vopsInfo.isEmergencyServiceSupported();
-            }
-        } catch (NullPointerException e) {
-            return false;
-        }
-    }
-
-    protected void onPreciseDataConnectionStateChanged(PreciseDataConnectionState connectionState) {
-        if (!validatePreciseDataConnectionStateChanged(connectionState)) {
-            log("invalid onPreciseDataConnectionStateChanged:" + connectionState);
-            return;
-        }
-        log("onPreciseDataConnectionStateChanged state:" + connectionState);
-        notifyPreciseDataConnectionStateChanged(connectionState);
-    }
-
-    private boolean validatePreciseDataConnectionStateChanged(PreciseDataConnectionState newState) {
-        try {
-            if (newState.getState() == TelephonyManager.DATA_CONNECTED
-                    || newState.getState() == TelephonyManager.DATA_HANDOVER_IN_PROGRESS) {
-                List<Integer> netCapabilities =
-                        QnsUtils.getNetCapabilitiesFromApnTypeBitmask(
-                                newState.getApnSetting().getApnTypeBitmask());
-                for (int netCapability : netCapabilities) {
-                    PreciseDataConnectionState lastState =
-                            getLastPreciseDataConnectionState(netCapability);
-                    PreciseDataConnectionState archiveState =
-                            sArchivingPreciseDataConnectionState.get(
-                                    mSubId, newState.getTransportType(), netCapability);
-                    if (archiveState.equals(newState) && lastState == null) {
-                        return false;
-                    }
-                }
-            }
-        } catch (Exception e) {
-            log("got Exception in validatePreciseDataConnectionStateChanged:" + e);
-        }
-        return true;
-    }
-
-    boolean isVoiceBarring() {
-        return mLastQnsTelephonyInfoIms.getVoiceBarring();
-    }
-
-    boolean isEmergencyBarring() {
-        return mLastQnsTelephonyInfoIms.getEmergencyBarring();
-    }
-
-    protected void onBarringInfoChanged(BarringInfo barringInfo) {
-        boolean voiceBarringByFactor =
-                barringInfo
-                                .getBarringServiceInfo(BARRING_SERVICE_TYPE_MMTEL_VOICE)
-                                .getConditionalBarringFactor()
-                        == 100;
-        boolean emergencyBarringByFactor =
-                barringInfo
-                                .getBarringServiceInfo(BARRING_SERVICE_TYPE_EMERGENCY)
-                                .getConditionalBarringFactor()
-                        == 100;
-        log(
-                "onBarringInfoChanged voiceBarringByFactor:"
-                        + voiceBarringByFactor
-                        + " emergencyBarringFactor"
-                        + emergencyBarringByFactor);
-        boolean changed = false;
-        if (mLastQnsTelephonyInfoIms.getVoiceBarring() != voiceBarringByFactor) {
-            log(" onBarringInfoChanged voiceBarring changed:" + voiceBarringByFactor);
-            mLastQnsTelephonyInfoIms.setVoiceBarring(voiceBarringByFactor);
-            changed = true;
-        }
-        if (mLastQnsTelephonyInfoIms.getEmergencyBarring() != emergencyBarringByFactor) {
-            log(" onBarringInfoChanged emergencyBarring changed:" + emergencyBarringByFactor);
-            mLastQnsTelephonyInfoIms.setEmergencyBarring(emergencyBarringByFactor);
-            changed = true;
-        }
-        if (changed) {
-            notifyQnsTelephonyInfoIms(mLastQnsTelephonyInfoIms);
-        }
-    }
-
-    protected void onCallStateChanged(int callState) {
-        mCallState = callState;
-        mCallStateListener.notifyResult(callState);
-    }
-
-    protected void onSrvccStateChanged(int srvccState) {
-        mSrvccStateListener.notifyResult(srvccState);
-    }
-
-    protected void onSubscriptionIdChanged(int subId) {
-        mSubscriptionIdListener.notifyResult(subId);
-    }
-
-    protected void onImsCallDisconnectCauseChanged(ImsReasonInfo imsReasonInfo) {
-        mImsCallDropDisconnectCauseListener.notifyResult(imsReasonInfo);
-    }
-
-    protected void log(String s) {
-        Log.d(mLogTag, s);
-    }
-
-    void close() {
-        mSubscriptionManager.removeOnSubscriptionsChangedListener(mSubscriptionsChangeListener);
-        mHandlerThread.quitSafely();
-        if (mTelephonyListener != null) {
-            mTelephonyListener.unregister(mSubId);
-        }
-        mNetCapabilityRegistrantMap.clear();
-        mQnsTelephonyInfoRegistrantMap.clear();
-        mLastPreciseDataConnectionState.clear();
-        mIwlanServiceStateListener.removeAll();
-    }
-
-    /** Listener for change of service state. */
-    protected interface OnServiceStateListener {
-        /** Notify the cellular service state changed. */
-        void onServiceStateChanged(ServiceState serviceState);
-    }
-
-    /** Listener for change of precise data connection state. */
-    protected interface OnPreciseDataConnectionStateListener {
-        /** Notify the PreciseDataConnectionState changed. */
-        void onPreciseDataConnectionStateChanged(PreciseDataConnectionState connectionState);
-    }
-
-    protected interface OnBarringInfoListener {
-        /** Notify the Barring info changed. */
-        void onBarringInfoChanged(BarringInfo barringInfo);
-    }
-
-    protected interface OnCallStateListener {
-        /** Notify the Call state changed. */
-        void onCallStateChanged(@Annotation.CallState int state);
-    }
-
-    protected interface OnSrvccStateChangedCallback {
-        /** Notify the Call state changed. */
-        void onSrvccStateChanged(@Annotation.SrvccState int state);
-    }
-
-    protected interface OnCallStatesChangedCallback {
-        /** Notify the Call state changed. */
-        void onCallStatesChanged(List<CallState> callStateList);
-    }
-
-    protected interface OnImsCallDisconnectCauseListener {
-        /** Notify the call disconnected cause changed. */
-        void onImsCallDisconnectCauseChanged(@NonNull ImsReasonInfo imsReasonInfo);
-    }
-
-    protected static class Archiving<V> {
-        protected HashMap<String, V> mArchiving = new HashMap<>();
-
-        Archiving() {}
-
-        private String getKey(int subId, int transportType, int netCapability) {
-            return subId + "_" + transportType + "_" + netCapability;
-        }
-
-        void put(int subId, int transportType, int netCapability, V v) {
-            mArchiving.put(getKey(subId, transportType, netCapability), v);
-        }
-
-        V get(int subId, int transportType, int netCapability) {
-            return mArchiving.get(getKey(subId, transportType, netCapability));
-        }
-    }
-
-    class QnsTelephonyInfoIms extends QnsTelephonyInfo {
-        private boolean mVopsSupport;
-        private boolean mVopsEmergencySupport;
-        private boolean mVoiceBarring;
-        private boolean mEmergencyBarring;
-
-        QnsTelephonyInfoIms() {
-            super();
-            mVoiceBarring = false;
-            mVopsSupport = false;
-            mEmergencyBarring = false;
-            mVopsEmergencySupport = false;
-        }
-
-        QnsTelephonyInfoIms(
-                QnsTelephonyInfo info,
-                boolean vopsSupport,
-                boolean vopsEmergencySupport,
-                boolean voiceBarring,
-                boolean emergencyBarring) {
-            super(info);
-            mVopsSupport = vopsSupport;
-            mVopsEmergencySupport = vopsEmergencySupport;
-            mVoiceBarring = voiceBarring;
-            mEmergencyBarring = emergencyBarring;
-        }
-
-        boolean getVopsSupport() {
-            return mVopsSupport;
-        }
-
-        void setVopsSupport(boolean support) {
-            mVopsSupport = support;
-        }
-
-        boolean getVopsEmergencySupport() {
-            return mVopsEmergencySupport;
-        }
-
-        void setVopsEmergencySupport(boolean support) {
-            mVopsEmergencySupport = support;
-        }
-
-        boolean getVoiceBarring() {
-            return mVoiceBarring;
-        }
-
-        void setVoiceBarring(boolean barring) {
-            mVoiceBarring = barring;
-        }
-
-        boolean getEmergencyBarring() {
-            return mEmergencyBarring;
-        }
-
-        void setEmergencyBarring(boolean barring) {
-            mEmergencyBarring = barring;
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            boolean equal = super.equals(o);
-            if (equal) {
-                if (!(o instanceof QnsTelephonyInfoIms)) return false;
-                equal =
-                        (this.mVoiceBarring == ((QnsTelephonyInfoIms) o).getVoiceBarring())
-                                && (this.mVopsSupport == ((QnsTelephonyInfoIms) o).getVopsSupport())
-                                && (this.mVopsEmergencySupport
-                                        == ((QnsTelephonyInfoIms) o).getVopsEmergencySupport())
-                                && (this.mEmergencyBarring
-                                        == ((QnsTelephonyInfoIms) o).getEmergencyBarring());
-            }
-            return equal;
-        }
-
-        @Override
-        public String toString() {
-            return "QnsTelephonyInfoIms{"
-                    + "mVopsSupport="
-                    + mVopsSupport
-                    + ", mVopsEmergencySupport="
-                    + mVopsEmergencySupport
-                    + ", mVoiceBarring="
-                    + mVoiceBarring
-                    + ", mEmergencyBarring="
-                    + mEmergencyBarring
-                    + ", mVoiceNetworkType="
-                    + getVoiceNetworkType()
-                    + ", mDataRegState="
-                    + getDataRegState()
-                    + ", mDataNetworkType="
-                    + getDataNetworkType()
-                    + ", mCoverage="
-                    + mCoverage
-                    + ", mRegisteredPlmn='"
-                    + getRegisteredPlmn()
-                    + "'"
-                    + ", mCellularAvailable="
-                    + isCellularAvailable()
-                    + '}';
-        }
-
-        boolean isCellularAvailable(
-                int netCapability,
-                boolean checkVops,
-                boolean checkBarring,
-                boolean volteRoamingSupported) {
-            if (netCapability == NetworkCapabilities.NET_CAPABILITY_IMS) {
-                return super.isCellularAvailable()
-                        && (!checkVops || mVopsSupport)
-                        && (!checkBarring || !mVoiceBarring)
-                        && volteRoamingSupported;
-            } else if (netCapability == NetworkCapabilities.NET_CAPABILITY_EIMS) {
-                return super.isCellularAvailable()
-                        && (!checkVops || mVopsEmergencySupport)
-                        && (!checkBarring && !mEmergencyBarring);
-            }
-            return false;
-        }
-    }
-
-    class QnsTelephonyInfo {
-        private int mVoiceNetworkType;
-        private int mDataRegState;
-        private int mDataNetworkType;
-        private boolean mCoverage;
-        private String mRegisteredPlmn;
-        private boolean mCellularAvailable;
-
-        QnsTelephonyInfo() {
-            mVoiceNetworkType = TelephonyManager.NETWORK_TYPE_UNKNOWN;
-            mDataRegState = ServiceState.STATE_OUT_OF_SERVICE;
-            mDataNetworkType = TelephonyManager.NETWORK_TYPE_UNKNOWN;
-            mCoverage = false; // home
-            mCellularAvailable = false; // not available
-            mRegisteredPlmn = "";
-        }
-
-        QnsTelephonyInfo(QnsTelephonyInfo info) {
-            mVoiceNetworkType = info.mVoiceNetworkType;
-            mDataRegState = info.mDataRegState;
-            mDataNetworkType = info.mDataNetworkType;
-            mCoverage = info.mCoverage;
-            mCellularAvailable = info.mCellularAvailable;
-            mRegisteredPlmn = info.mRegisteredPlmn;
-        }
-
-        int getVoiceNetworkType() {
-            return mVoiceNetworkType;
-        }
-
-        void setVoiceNetworkType(int voiceNetworkType) {
-            mVoiceNetworkType = voiceNetworkType;
-        }
-
-        int getDataRegState() {
-            return mDataRegState;
-        }
-
-        void setDataRegState(int dataRegState) {
-            mDataRegState = dataRegState;
-        }
-
-        int getDataNetworkType() {
-            return mDataNetworkType;
-        }
-
-        void setDataNetworkType(int dataNetworkType) {
-            mDataNetworkType = dataNetworkType;
-        }
-
-        String getRegisteredPlmn() {
-            return mRegisteredPlmn;
-        }
-
-        void setRegisteredPlmn(String plmn) {
-            if (plmn == null) {
-                mRegisteredPlmn = "";
-            } else {
-                mRegisteredPlmn = plmn;
-            }
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) return true;
-            if (!(o instanceof QnsTelephonyInfo)) return false;
-            QnsTelephonyInfo that = (QnsTelephonyInfo) o;
-            return mVoiceNetworkType == that.mVoiceNetworkType
-                    && mDataRegState == that.mDataRegState
-                    && mDataNetworkType == that.mDataNetworkType
-                    && mCoverage == that.mCoverage
-                    && mRegisteredPlmn.equals(that.mRegisteredPlmn)
-                    && mCellularAvailable == that.mCellularAvailable;
-        }
-
-        @Override
-        public int hashCode() {
-            return Objects.hash(
-                    mVoiceNetworkType,
-                    mDataRegState,
-                    mDataNetworkType,
-                    mCoverage,
-                    mCellularAvailable);
-        }
-
-        @Override
-        public String toString() {
-            return "QnsTelephonyInfo{"
-                    + "mVoiceNetworkType="
-                    + mVoiceNetworkType
-                    + ", mDataRegState="
-                    + mDataRegState
-                    + ", mDataNetworkType="
-                    + mDataNetworkType
-                    + ", mCoverage="
-                    + mCoverage
-                    + ", mRegisteredPlmn='"
-                    + mRegisteredPlmn
-                    + "'"
-                    + ", mCellularAvailable="
-                    + mCellularAvailable
-                    + '}';
-        }
-
-        boolean isCoverage() {
-            return mCoverage;
-        }
-
-        void setCoverage(boolean coverage) {
-            mCoverage = coverage;
-        }
-
-        boolean isCellularAvailable() {
-            return mCellularAvailable;
-        }
-
-        void setCellularAvailable(boolean cellularAvailable) {
-            mCellularAvailable = cellularAvailable;
-        }
-    }
-
-    /** {@link TelephonyCallback} to listen to Cellular Service State Changed. */
-    protected class TelephonyListener extends TelephonyCallback
-            implements TelephonyCallback.ServiceStateListener,
-                    TelephonyCallback.PreciseDataConnectionStateListener,
-                    TelephonyCallback.BarringInfoListener,
-                    TelephonyCallback.CallStateListener,
-                    TelephonyCallback.SrvccStateListener,
-                    TelephonyCallback.CallAttributesListener,
-                    TelephonyCallback.MediaQualityStatusChangedListener,
-                    TelephonyCallback.ImsCallDisconnectCauseListener {
-        private final Executor mExecutor;
-        private OnServiceStateListener mServiceStateListener;
-        private OnPreciseDataConnectionStateListener mPreciseDataConnectionStateListener;
-        private OnBarringInfoListener mBarringInfoListener;
-        private OnCallStateListener mCallStateListener;
-        private OnSrvccStateChangedCallback mSrvccStateCallback;
-        private OnSrvccStateChangedCallback mSrvccStateListener;
-        private OnCallStatesChangedCallback mCallStatesCallback;
-        private OnImsCallDisconnectCauseListener mImsCallDisconnectCauseListener;
-        private TelephonyManager mTelephonyManager;
-
-        TelephonyListener(Executor executor) {
-            super();
-            mExecutor = executor;
-        }
-
-        void setServiceStateListener(OnServiceStateListener listener) {
-            mServiceStateListener = listener;
-        }
-
-        void setPreciseDataConnectionStateListener(OnPreciseDataConnectionStateListener listener) {
-            mPreciseDataConnectionStateListener = listener;
-        }
-
-        void setBarringInfoListener(OnBarringInfoListener listener) {
-            mBarringInfoListener = listener;
-        }
-
-        void setCallStateListener(OnCallStateListener listener) {
-            mCallStateListener = listener;
-        }
-
-        void setSrvccStateCallback(OnSrvccStateChangedCallback callback) {
-            mSrvccStateCallback = callback;
-        }
-
-        void setSrvccStateListener(OnSrvccStateChangedCallback listener) {
-            mSrvccStateListener = listener;
-        }
-
-        void setCallStatesCallback(OnCallStatesChangedCallback listener) {
-            mCallStatesCallback = listener;
-        }
-
-        void setImsCallDisconnectCauseListener(OnImsCallDisconnectCauseListener listener) {
-            mImsCallDisconnectCauseListener = listener;
-        }
-
-        /**
-         * Register a TelephonyCallback for this listener.
-         *
-         * @param context the Context
-         * @param subId the subscription id.
-         */
-        void register(Context context, int subId) {
-            log("register TelephonyCallback for sub:" + subId);
-            long identity = Binder.clearCallingIdentity();
-            try {
-                mTelephonyManager =
-                        context.getSystemService(TelephonyManager.class)
-                                .createForSubscriptionId(subId);
-                mTelephonyManager.registerTelephonyCallback(
-                        TelephonyManager.INCLUDE_LOCATION_DATA_NONE, mExecutor, this);
-            } catch (NullPointerException e) {
-                log("got NullPointerException e:" + e);
-            } finally {
-                Binder.restoreCallingIdentity(identity);
-            }
-        }
-
-        /**
-         * Unregister a TelephonyCallback for this listener.
-         *
-         * @param subId the subscription id.
-         */
-        void unregister(int subId) {
-            log("unregister TelephonyCallback for sub:" + subId);
-            mTelephonyManager.unregisterTelephonyCallback(this);
-        }
-
-        @Override
-        public void onServiceStateChanged(ServiceState serviceState) {
-            if (mServiceStateListener != null) {
-                mServiceStateListener.onServiceStateChanged(serviceState);
-            }
-        }
-
-        @Override
-        public void onPreciseDataConnectionStateChanged(
-                PreciseDataConnectionState connectionState) {
-            if (mPreciseDataConnectionStateListener != null) {
-                mPreciseDataConnectionStateListener.onPreciseDataConnectionStateChanged(
-                        connectionState);
-            }
-        }
-
-        @Override
-        public void onBarringInfoChanged(BarringInfo barringInfo) {
-            if (mBarringInfoListener != null) {
-                mBarringInfoListener.onBarringInfoChanged(barringInfo);
-            }
-        }
-
-        @Override
-        public void onCallStateChanged(@Annotation.CallState int state) {
-            if (mCallStateListener != null) {
-                mCallStateListener.onCallStateChanged(state);
-            }
-        }
-
-        @Override
-        public void onSrvccStateChanged(@Annotation.SrvccState int state) {
-            if (mSrvccStateListener != null) {
-                mSrvccStateListener.onSrvccStateChanged(state);
-            }
-            for (Consumer<Integer> consumer : mSrvccStateConsumerList) {
-                consumer.accept(state);
-            }
-        }
-
-        @Override
-        public void onCallStatesChanged(List<CallState> callStateList) {
-            for (Consumer<List<CallState>> consumer : mCallStatesConsumerList) {
-                consumer.accept(callStateList);
-            }
-            if (mCallStatesCallback != null) {
-                mCallStatesCallback.onCallStatesChanged(callStateList);
-            }
-        }
-
-        @Override
-        public void onMediaQualityStatusChanged(MediaQualityStatus status) {
-            for (Consumer<MediaQualityStatus> consumer : mMediaQualityConsumerList) {
-                consumer.accept(status);
-            }
-        }
-
-        @Override
-        public void onImsCallDisconnectCauseChanged(@NonNull ImsReasonInfo imsReasonInfo) {
-            if (mImsCallDisconnectCauseListener != null) {
-                mImsCallDisconnectCauseListener.onImsCallDisconnectCauseChanged(imsReasonInfo);
-            }
-        }
-    }
-
-    void addCallStatesChangedCallback(Consumer<List<CallState>> consumer) {
-        mCallStatesConsumerList.add(consumer);
-    }
-
-    void removeCallStatesChangedCallback(Consumer<List<CallState>> consumer) {
-        mCallStatesConsumerList.remove(consumer);
-    }
-
-    void addSrvccStateChangedCallback(Consumer<Integer> consumer) {
-        mSrvccStateConsumerList.add(consumer);
-    }
-
-    void removeSrvccStateChangedCallback(Consumer<Integer> consumer) {
-        mSrvccStateConsumerList.remove(consumer);
-    }
-
-    void addMediaQualityStatusCallback(Consumer<MediaQualityStatus> consumer) {
-        mMediaQualityConsumerList.add(consumer);
-    }
-
-    void removeMediaQualityStatusCallback(Consumer<MediaQualityStatus> consumer) {
-        mMediaQualityConsumerList.remove(consumer);
-    }
-
-    /**
-     * Dumps the state of {@link QualityMonitor}
-     *
-     * @param pw {@link PrintWriter} to write the state of the object.
-     * @param prefix String to append at start of dumped log.
-     */
-    void dump(PrintWriter pw, String prefix) {
-        pw.println(prefix + "------------------------------");
-        pw.println(prefix + "QnsTelephonyListener[" + mSlotIndex + "]:");
-        pw.println(prefix + "mLastQnsTelephonyInfo=" + mLastQnsTelephonyInfo);
-        pw.println(prefix + "mLastQnsTelephonyInfoIms=" + mLastQnsTelephonyInfoIms);
-        pw.println(prefix + "mLastServiceState=" + mLastServiceState);
-        pw.println(prefix + "mLastPreciseDataConnectionState=" + mLastPreciseDataConnectionState);
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsTimer.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsTimer.java
deleted file mode 100644
index 7630054..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsTimer.java
+++ /dev/null
@@ -1,434 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static com.android.telephony.qns.QnsConstants.CALL_TYPE_IDLE;
-import static com.android.telephony.qns.QnsConstants.INVALID_ID;
-import static com.android.telephony.qns.QnsUtils.getSystemElapsedRealTime;
-
-import android.app.AlarmManager;
-import android.app.PendingIntent;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Message;
-import android.os.PowerManager;
-import android.util.Log;
-
-import com.android.internal.annotations.VisibleForTesting;
-
-import java.io.PrintWriter;
-import java.util.Comparator;
-import java.util.Objects;
-import java.util.PriorityQueue;
-import java.util.concurrent.atomic.AtomicInteger;
-
-/** This class handles the delayed events triggered in QNS. */
-class QnsTimer {
-
-    private static final String TAG = QnsTimer.class.getSimpleName();
-    private static final int EVENT_QNS_TIMER_EXPIRED = 1;
-
-    private static final int MIN_ALARM_CALL_ACTIVE_DELAY_MS = 0;
-    private static final int MIN_ALARM_SCREEN_OFF_DELAY_MS = 10000;
-    private static final int MIN_ALARM_DEVICE_LIGHT_IDLE_DELAY_MS = 30000;
-    private static final int MIN_ALARM_DEVICE_IDLE_DELAY_MS = 60000;
-    static final String ACTION_ALARM_TIMER_EXPIRED =
-            "com.android.telephony.qns.action.ALARM_TIMER_EXPIRED";
-
-    private static final AtomicInteger sTimerId = new AtomicInteger();
-    private final Context mContext;
-    private final AlarmManager mAlarmManager;
-    private final PowerManager mPowerManager;
-    private final HandlerThread mHandlerThread;
-    private final BroadcastReceiver mBroadcastReceiver;
-    private final PriorityQueue<TimerInfo> mTimerInfos;
-    private PendingIntent mPendingIntent;
-    private long mMinAlarmTimeMs = MIN_ALARM_SCREEN_OFF_DELAY_MS;
-    private int mCurrentAlarmTimerId = INVALID_ID;
-    private int mCurrentHandlerTimerId = INVALID_ID;
-    private boolean mIsAlarmRequired;
-    @VisibleForTesting Handler mHandler;
-    private long mLastAlarmTriggerAtMs = Long.MAX_VALUE;
-    private int mCallType = CALL_TYPE_IDLE;
-
-    QnsTimer(Context context) {
-        mContext = context;
-        mAlarmManager = mContext.getSystemService(AlarmManager.class);
-        mPowerManager = mContext.getSystemService(PowerManager.class);
-        mBroadcastReceiver = new AlarmReceiver();
-        mTimerInfos =
-                new PriorityQueue<>(Comparator.comparingLong(TimerInfo::getExpireAtElapsedMillis));
-        mHandlerThread = new HandlerThread(TAG);
-        mHandlerThread.start();
-        mHandler = new QnsTimerHandler();
-
-        IntentFilter intentFilter = new IntentFilter();
-        intentFilter.addAction(ACTION_ALARM_TIMER_EXPIRED);
-        intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
-        intentFilter.addAction(Intent.ACTION_SCREEN_ON);
-        intentFilter.addAction(PowerManager.ACTION_DEVICE_LIGHT_IDLE_MODE_CHANGED);
-        intentFilter.addAction(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
-        mContext.registerReceiver(mBroadcastReceiver, intentFilter, Context.RECEIVER_EXPORTED);
-    }
-
-    /**
-     * This method uses AlarmManager to execute the delayed event passed as param.
-     *
-     * @param msg message to process.
-     * @param delayMs timer value for the delay.
-     * @return unique timer id associated with the registered timer.
-     */
-    int registerTimer(Message msg, long delayMs) {
-        int timerId = sTimerId.getAndIncrement();
-        TimerInfo timerInfo = new TimerInfo(timerId);
-        timerInfo.setMessage(msg);
-        timerInfo.setExpireAtElapsedMillis(getSystemElapsedRealTime() + delayMs);
-        logd("register timer for timerId=" + timerId + ", with delay=" + delayMs);
-        mHandler.post(
-                () -> {
-                    mTimerInfos.add(timerInfo);
-                    updateToShortestDelay(mIsAlarmRequired, false /* forceUpdate */);
-                });
-        return timerId;
-    }
-
-    /**
-     * This method unregisters the timer associated to given timerId.
-     *
-     * @param timerId timer id associated with the running timer.
-     */
-    void unregisterTimer(int timerId) {
-        if (timerId == INVALID_ID) {
-            return;
-        }
-        logd("unregisterTimer for timerId=" + timerId);
-        mHandler.post(
-                () -> {
-                    logd("Cancel timerId=" + timerId);
-                    TimerInfo timerInfo = new TimerInfo(timerId);
-                    if (mTimerInfos.remove(timerInfo) && timerId == mCurrentAlarmTimerId) {
-                        updateToShortestDelay(mIsAlarmRequired, false /* forceUpdate */);
-                    }
-                });
-    }
-
-    /**
-     * It updates the call state in QnsTimer. If the call is active the minimum timer value for an
-     * alarm is updated to 0ms. Otherwise the value will be based on device state (Idle, Light Idle
-     * or Screen off).
-     *
-     * @param type Call type {@code @QnsConstants.QnsCallType}
-     */
-    void updateCallState(@QnsConstants.QnsCallType int type) {
-        if (mCallType == CALL_TYPE_IDLE && type != CALL_TYPE_IDLE) {
-            mHandler.post(
-                    () -> {
-                        mMinAlarmTimeMs = MIN_ALARM_CALL_ACTIVE_DELAY_MS;
-                        if (mIsAlarmRequired) {
-                            updateToShortestDelay(true, true /* forceUpdate */);
-                        }
-                    });
-        }
-        mCallType = type;
-        if (mCallType == CALL_TYPE_IDLE && mIsAlarmRequired) {
-            if (mPowerManager.isDeviceIdleMode()) {
-                mMinAlarmTimeMs = MIN_ALARM_DEVICE_IDLE_DELAY_MS;
-            } else if (mPowerManager.isDeviceLightIdleMode()) {
-                mMinAlarmTimeMs = MIN_ALARM_DEVICE_LIGHT_IDLE_DELAY_MS;
-            } else {
-                mMinAlarmTimeMs = MIN_ALARM_SCREEN_OFF_DELAY_MS; // SCREEN_OFF case
-            }
-        }
-    }
-
-    /**
-     * This method performs the following actions: 1. checks if the shortest timer is set for
-     * handler or alarm. If not it overrides the earlier set timer with the shortest one. 2. checks
-     * for timers in the list those have passed the current elapsed time; and notifies them to
-     * respective handlers.
-     *
-     * @param isAlarmRequired flag indicates if timer is need to setup with Alarm.
-     * @param forceUpdate flag indicates to update the delay time for handler and/or alarm
-     *     forcefully.
-     */
-    private void updateToShortestDelay(boolean isAlarmRequired, boolean forceUpdate) {
-        TimerInfo timerInfo = mTimerInfos.peek();
-        long elapsedTime = getSystemElapsedRealTime();
-        while (timerInfo != null && timerInfo.getExpireAtElapsedMillis() <= elapsedTime) {
-            logd("Notify timerInfo=" + timerInfo);
-            timerInfo.getMessage().sendToTarget();
-            mTimerInfos.poll();
-            timerInfo = mTimerInfos.peek();
-        }
-        if (timerInfo == null) {
-            logd("No timers are pending to run");
-            clearAllTimers();
-            return;
-        }
-        long delay = timerInfo.getExpireAtElapsedMillis() - elapsedTime;
-        // Delayed Handler will always set for shortest delay.
-        if (timerInfo.getTimerId() != mCurrentHandlerTimerId || forceUpdate) {
-            mHandler.removeMessages(EVENT_QNS_TIMER_EXPIRED);
-            mHandler.sendEmptyMessageDelayed(EVENT_QNS_TIMER_EXPIRED, delay);
-            mCurrentHandlerTimerId = timerInfo.getTimerId();
-        }
-
-        // Alarm will always set for shortest from Math.max(delay, mMinAlarmTimeMs)
-        if (timerInfo.getTimerId() != mCurrentAlarmTimerId || forceUpdate) {
-            if (isAlarmRequired) {
-                delay = Math.max(delay, mMinAlarmTimeMs);
-                // check if smaller timer alarm is already running for active timer info.
-                if (mTimerInfos.contains(new TimerInfo(mCurrentAlarmTimerId))
-                        && mLastAlarmTriggerAtMs - elapsedTime < delay
-                        && mPendingIntent != null) {
-                    logd(
-                            "Skip update since minimum Alarm Timer already running for timerId="
-                                    + mCurrentAlarmTimerId);
-                    return;
-                }
-                logd("Setup alarm for delay " + delay);
-                mLastAlarmTriggerAtMs = elapsedTime + delay;
-                setupAlarmFor(mLastAlarmTriggerAtMs);
-            } else if (mPendingIntent != null) {
-                mAlarmManager.cancel(mPendingIntent);
-                mPendingIntent = null;
-            }
-            mCurrentAlarmTimerId = timerInfo.getTimerId();
-            logd("Update timer to timer id=" + mCurrentAlarmTimerId);
-        }
-    }
-
-    private void clearAllTimers() {
-        mHandler.removeMessages(EVENT_QNS_TIMER_EXPIRED);
-        if (mPendingIntent != null) {
-            logd("Cancel Alarm");
-            mAlarmManager.cancel(mPendingIntent);
-        }
-        mPendingIntent = null;
-    }
-
-    private void setupAlarmFor(long triggerAtMillis) {
-        mPendingIntent =
-                PendingIntent.getBroadcast(
-                        mContext,
-                        0,
-                        new Intent(ACTION_ALARM_TIMER_EXPIRED),
-                        PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);
-        mAlarmManager.setExactAndAllowWhileIdle(
-                AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtMillis, mPendingIntent);
-    }
-
-    private class AlarmReceiver extends BroadcastReceiver {
-
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            String action = intent.getAction();
-            logd("onReceive action=" + action);
-            switch (action) {
-                case ACTION_ALARM_TIMER_EXPIRED:
-                    mHandler.sendEmptyMessage(EVENT_QNS_TIMER_EXPIRED);
-                    break;
-                case Intent.ACTION_SCREEN_OFF:
-                    mHandler.post(
-                            () -> {
-                                mMinAlarmTimeMs =
-                                        (mCallType == CALL_TYPE_IDLE)
-                                                ? MIN_ALARM_SCREEN_OFF_DELAY_MS
-                                                : MIN_ALARM_CALL_ACTIVE_DELAY_MS;
-                                if (!mIsAlarmRequired) {
-                                    mIsAlarmRequired = true;
-                                    updateToShortestDelay(true, true /* forceUpdate */);
-                                }
-                            });
-                    break;
-                case Intent.ACTION_SCREEN_ON:
-                    mHandler.post(
-                            () -> {
-                                if (mIsAlarmRequired) {
-                                    mIsAlarmRequired = false;
-                                    updateToShortestDelay(false, true /* forceUpdate */);
-                                }
-                            });
-                    break;
-                case PowerManager.ACTION_DEVICE_LIGHT_IDLE_MODE_CHANGED:
-                    mHandler.post(
-                            () -> {
-                                if (mPowerManager.isDeviceLightIdleMode()) {
-                                    mMinAlarmTimeMs =
-                                            (mCallType == CALL_TYPE_IDLE)
-                                                    ? MIN_ALARM_DEVICE_LIGHT_IDLE_DELAY_MS
-                                                    : MIN_ALARM_CALL_ACTIVE_DELAY_MS;
-                                    if (!mIsAlarmRequired) {
-                                        mIsAlarmRequired = true;
-                                        updateToShortestDelay(true, true /* forceUpdate */);
-                                    }
-                                } else {
-                                    mMinAlarmTimeMs =
-                                            (mCallType == CALL_TYPE_IDLE)
-                                                    ? MIN_ALARM_SCREEN_OFF_DELAY_MS
-                                                    : MIN_ALARM_CALL_ACTIVE_DELAY_MS;
-                                }
-                            });
-                    break;
-                case PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED:
-                    mHandler.post(
-                            () -> {
-                                if (mPowerManager.isDeviceIdleMode()) {
-                                    mMinAlarmTimeMs =
-                                            (mCallType == CALL_TYPE_IDLE)
-                                                    ? MIN_ALARM_DEVICE_IDLE_DELAY_MS
-                                                    : MIN_ALARM_CALL_ACTIVE_DELAY_MS;
-                                    if (!mIsAlarmRequired) {
-                                        mIsAlarmRequired = true;
-                                        updateToShortestDelay(true, true /* forceUpdate */);
-                                    }
-                                } else {
-                                    mMinAlarmTimeMs =
-                                            (mCallType == CALL_TYPE_IDLE)
-                                                    ? MIN_ALARM_SCREEN_OFF_DELAY_MS
-                                                    : MIN_ALARM_CALL_ACTIVE_DELAY_MS;
-                                }
-                            });
-                    break;
-                default:
-                    break;
-            }
-        }
-    }
-
-    private class QnsTimerHandler extends Handler {
-        QnsTimerHandler() {
-            super(mHandlerThread.getLooper());
-        }
-
-        @Override
-        public void handleMessage(Message msg) {
-            super.handleMessage(msg);
-            logd("handleMessage msg.what=" + msg.what);
-            switch (msg.what) {
-                case EVENT_QNS_TIMER_EXPIRED:
-                    logd("Timer expired");
-                    updateToShortestDelay(mIsAlarmRequired, false /* forceUpdate */);
-                    break;
-                default:
-                    break;
-            }
-        }
-    }
-
-    static class TimerInfo {
-        private final int mTimerId;
-        private long mExpireAtElapsedMillis;
-        private Message mMsg;
-
-        TimerInfo(int timerId) {
-            mTimerId = timerId;
-        }
-
-        public int getTimerId() {
-            return mTimerId;
-        }
-
-        public Message getMessage() {
-            return mMsg;
-        }
-
-        public void setMessage(Message msg) {
-            mMsg = msg;
-        }
-
-        public long getExpireAtElapsedMillis() {
-            return mExpireAtElapsedMillis;
-        }
-
-        public void setExpireAtElapsedMillis(long expireAtElapsedMillis) {
-            mExpireAtElapsedMillis = expireAtElapsedMillis;
-        }
-
-        /** Timers are equals if they share the same timer id. */
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) return true;
-            if (!(o instanceof TimerInfo)) return false;
-            TimerInfo timerInfo = (TimerInfo) o;
-            return mTimerId == timerInfo.mTimerId;
-        }
-
-        @Override
-        public int hashCode() {
-            return Objects.hash(mTimerId);
-        }
-
-        @Override
-        public String toString() {
-            return "TimerInfo{"
-                    + "mTimerId="
-                    + mTimerId
-                    + ", mExpireAtElapsedMillis="
-                    + mExpireAtElapsedMillis
-                    + ", mMsg="
-                    + mMsg
-                    + '}';
-        }
-    }
-
-    @VisibleForTesting
-    PriorityQueue<TimerInfo> getTimersInfo() {
-        return mTimerInfos;
-    }
-
-    void close() {
-        logd("Closing QnsTimer");
-        mHandlerThread.quitSafely();
-        mContext.unregisterReceiver(mBroadcastReceiver);
-        mTimerInfos.clear();
-        clearAllTimers();
-    }
-
-    private void logd(String s) {
-        Log.d(TAG, s);
-    }
-
-    /**
-     * Dumps the state of {@link QnsTimer}
-     *
-     * @param pw {@link PrintWriter} to write the state of the object.
-     * @param prefix String to append at start of dumped log.
-     */
-    void dump(PrintWriter pw, String prefix) {
-        pw.println(prefix + "------------------------------");
-        pw.println(prefix + "QnsTimer:");
-        pw.println(
-                prefix
-                        + "mIsAlarmRequired="
-                        + mIsAlarmRequired
-                        + ", mCurrentAlarmTimerId="
-                        + mCurrentAlarmTimerId
-                        + ", mCurrentHandlerTimerId="
-                        + mCurrentHandlerTimerId
-                        + ", latest timerId="
-                        + sTimerId.get()
-                        + ", Current elapsed time="
-                        + getSystemElapsedRealTime());
-        pw.println(prefix + "mTimerInfos=" + mTimerInfos);
-        pw.println(prefix + "mPendingIntent=" + mPendingIntent);
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsUtils.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsUtils.java
deleted file mode 100644
index 85ae192..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsUtils.java
+++ /dev/null
@@ -1,828 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static android.telephony.ims.ImsMmTelManager.WIFI_MODE_CELLULAR_PREFERRED;
-import static android.telephony.ims.ImsMmTelManager.WIFI_MODE_WIFI_PREFERRED;
-
-import static com.android.telephony.qns.wfc.WfcCarrierConfigManager.CONFIG_DEFAULT_VOWIFI_REGISTATION_TIMER;
-import static com.android.telephony.qns.wfc.WfcCarrierConfigManager.KEY_QNS_VOWIFI_REGISTATION_TIMER_FOR_VOWIFI_ACTIVATION_INT;
-
-import android.annotation.NonNull;
-import android.annotation.Nullable;
-import android.content.Context;
-import android.net.NetworkCapabilities;
-import android.os.Handler;
-import android.os.PersistableBundle;
-import android.os.SystemClock;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.Annotation.NetCapability;
-import android.telephony.CarrierConfigManager;
-import android.telephony.ServiceState;
-import android.telephony.SubscriptionInfo;
-import android.telephony.SubscriptionManager;
-import android.telephony.TelephonyManager;
-import android.telephony.data.ApnSetting;
-import android.text.TextUtils;
-import android.util.Log;
-
-import java.io.BufferedReader;
-import java.io.ByteArrayInputStream;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-import java.util.Locale;
-import java.util.Set;
-import java.util.concurrent.Executor;
-import java.util.concurrent.RejectedExecutionException;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
-
-/** This class contains QualifiedNetworksService specific utility functions */
-class QnsUtils {
-
-    private static final String CARRIER_ID_PREFIX = "carrier_config_carrierid_";
-
-    /**
-     * Get supported APN types
-     *
-     * @param apnTypeBitmask bitmask of APN types.
-     * @return list of APN types
-     */
-    @ApnSetting.ApnType
-    static List<Integer> getApnTypes(int apnTypeBitmask) {
-        List<Integer> types = new ArrayList<>();
-
-        if ((apnTypeBitmask & ApnSetting.TYPE_DEFAULT) == ApnSetting.TYPE_DEFAULT) {
-            types.add(ApnSetting.TYPE_DEFAULT);
-            apnTypeBitmask &= ~ApnSetting.TYPE_DEFAULT;
-        }
-        while (apnTypeBitmask != 0) {
-            int highestApnTypeBit = Integer.highestOneBit(apnTypeBitmask);
-            types.add(highestApnTypeBit);
-            apnTypeBitmask &= ~highestApnTypeBit;
-        }
-        return types;
-    }
-
-    /**
-     * Get names of AccessNetworkTypes
-     *
-     * @param accessNetworkTypes list of accessNetworkType
-     * @return String of AccessNetworkTypes name
-     */
-    static String getStringAccessNetworkTypes(List<Integer> accessNetworkTypes) {
-        if (accessNetworkTypes == null || accessNetworkTypes.size() == 0) {
-            return "[empty]";
-        }
-        List<String> types = new ArrayList<>();
-        for (Integer net : accessNetworkTypes) {
-            types.add(QnsConstants.accessNetworkTypeToString(net));
-        }
-        return TextUtils.join("|", types);
-    }
-
-    /**
-     * Get a subId per slot id.
-     *
-     * @param context Context
-     * @param slotId slot id.
-     * @return Subscription id per slot id.
-     */
-    static int getSubId(Context context, int slotId) {
-        try {
-            return getSubscriptionInfo(context, slotId).getSubscriptionId();
-        } catch (IllegalStateException e) {
-            return SubscriptionManager.INVALID_SUBSCRIPTION_ID;
-        }
-    }
-
-    /**
-     * This method validates the slot index.
-     *
-     * @param context Context
-     * @param slotIndex slot index
-     * @return returns true if slotIndex is valid; otherwise false.
-     */
-    static boolean isValidSlotIndex(Context context, int slotIndex) {
-        TelephonyManager tm = context.getSystemService(TelephonyManager.class);
-        return slotIndex >= 0 && tm != null && slotIndex < tm.getActiveModemCount();
-    }
-
-    static boolean isDefaultDataSubs(int slotId) {
-        int ddsSlotId =
-                SubscriptionManager.getSlotIndex(
-                        SubscriptionManager.getDefaultDataSubscriptionId());
-        if (ddsSlotId != SubscriptionManager.INVALID_SIM_SLOT_INDEX) {
-            return ddsSlotId == slotId;
-        }
-        return false;
-    }
-
-    static long getSystemElapsedRealTime() {
-        return SystemClock.elapsedRealtime();
-    }
-
-    private static SubscriptionInfo getSubscriptionInfo(Context context, int slotId)
-            throws IllegalStateException {
-        SubscriptionManager sm = context.getSystemService(SubscriptionManager.class);
-        SubscriptionInfo info = sm.getActiveSubscriptionInfoForSimSlotIndex(slotId);
-
-        if (info == null) {
-            throw new IllegalStateException("Subscription info is null.");
-        }
-
-        return info;
-    }
-
-    /** isCrossSimCallingEnabled */
-    public static boolean isCrossSimCallingEnabled(QnsImsManager imsManager) {
-        try {
-            return imsManager.isCrossSimCallingEnabled();
-        } catch (Exception e) {
-            // Fail to query Cross-SIM calling setting, just return false to avoid an exception.
-        }
-        return false;
-    }
-
-    /** isWfcEnabled */
-    public static boolean isWfcEnabled(
-            QnsImsManager imsManager, QnsProvisioningListener listener, boolean roaming) {
-        try {
-            boolean bWfcEnabledByUser;
-            boolean bWfcEnabledByPlatform = imsManager.isWfcEnabledByPlatform();
-            boolean bWfcProvisionedOnDevice = imsManager.isWfcProvisionedOnDevice();
-            if (roaming) {
-                bWfcEnabledByUser = imsManager.isWfcRoamingEnabledByUser();
-                try {
-                    boolean bWfcRoamingEnabled =
-                            listener.getLastProvisioningWfcRoamingEnabledInfo();
-                    bWfcEnabledByUser = bWfcEnabledByUser && (bWfcRoamingEnabled);
-                } catch (Exception e) {
-                    log("got exception e:" + e);
-                }
-            } else {
-                bWfcEnabledByUser = imsManager.isWfcEnabledByUser();
-            }
-            log(
-                    "isWfcEnabled slot:"
-                            + imsManager.getSlotIndex()
-                            + " byUser:"
-                            + bWfcEnabledByUser
-                            + " byPlatform:"
-                            + bWfcEnabledByPlatform
-                            + " ProvisionedOnDevice:"
-                            + bWfcProvisionedOnDevice
-                            + " roam:"
-                            + roaming);
-            return bWfcEnabledByUser && bWfcEnabledByPlatform && bWfcProvisionedOnDevice;
-        } catch (Exception e) {
-            loge("isWfcEnabled exception:" + e);
-            // Fail to query, just return false to avoid an exception.
-        }
-        return false;
-    }
-
-    /** isWfcEnabledByPlatform */
-    public static boolean isWfcEnabledByPlatform(QnsImsManager imsManager) {
-        try {
-            boolean bWfcEnabledByPlatform = imsManager.isWfcEnabledByPlatform();
-            log(
-                    "isWfcEnabledByPlatform:"
-                            + bWfcEnabledByPlatform
-                            + " slot:"
-                            + imsManager.getSlotIndex());
-            return bWfcEnabledByPlatform;
-        } catch (Exception e) {
-            loge("isWfcEnabledByPlatform exception:" + e);
-            // Fail to query, just return false to avoid an exception.
-        }
-        return false;
-    }
-
-    /** getWfcMode */
-    public static int getWfcMode(QnsImsManager imsManager, boolean roaming) {
-        try {
-            int wfcMode = imsManager.getWfcMode(roaming);
-            log(
-                    "getWfcMode slot:"
-                            + imsManager.getSlotIndex()
-                            + " wfcMode:"
-                            + wfcMode
-                            + " roaming:"
-                            + roaming);
-            return wfcMode;
-        } catch (Exception e) {
-            // Fail to query, just return false to avoid an exception.
-        }
-        return roaming ? WIFI_MODE_WIFI_PREFERRED : WIFI_MODE_CELLULAR_PREFERRED;
-    }
-
-    /**
-     * This method provides the access network type for the given data registration state and
-     * Network Type. It will return value as UNKNOWN(0) if registration state is not in service.
-     *
-     * @param dataRegState Data registration state.
-     * @param dataNetworkType Data network type
-     * @return int value of the AccessNetworkType mapped to NetworkType. And UNKNOWN(0) if
-     *     registration state is not in service.
-     */
-    static int getCellularAccessNetworkType(int dataRegState, int dataNetworkType) {
-        if (dataRegState == ServiceState.STATE_IN_SERVICE) {
-            return QnsConstants.networkTypeToAccessNetworkType(dataNetworkType);
-        }
-        return AccessNetworkConstants.AccessNetworkType.UNKNOWN;
-    }
-
-    static boolean isWifiCallingAvailable(Context context, int slotId) {
-        try {
-            int subId = QnsUtils.getSubId(context, slotId);
-            TelephonyManager telephonyManager =
-                    context.getSystemService(TelephonyManager.class).createForSubscriptionId(subId);
-            return telephonyManager.isWifiCallingAvailable();
-        } catch (Exception e) {
-            loge("isWifiCallingAvailable has exception : " + e);
-        }
-        return false;
-    }
-
-    @AccessNetworkConstants.TransportType
-    static int getTransportTypeFromAccessNetwork(
-            @AccessNetworkConstants.RadioAccessNetworkType int accessNetwork) {
-        if (accessNetwork == AccessNetworkConstants.AccessNetworkType.IWLAN) {
-            return AccessNetworkConstants.TRANSPORT_TYPE_WLAN;
-        } else if (accessNetwork != AccessNetworkConstants.AccessNetworkType.UNKNOWN) {
-            return AccessNetworkConstants.TRANSPORT_TYPE_WWAN;
-        }
-        return AccessNetworkConstants.TRANSPORT_TYPE_INVALID;
-    }
-
-    /**
-     * Get Set of network capabilities from string joined by {@code |}, space is ignored. If input
-     * string contains unknown capability or malformatted(e.g. empty string), -1 is included in the
-     * returned set.
-     *
-     * @param capabilitiesString capability strings joined by {@code |}
-     * @return Set of capabilities
-     */
-    @NetCapability
-    static Set<Integer> getNetworkCapabilitiesFromString(@NonNull String capabilitiesString) {
-        // e.g. "IMS|" is not allowed
-        if (!capabilitiesString.matches("(\\s*[a-zA-Z]+\\s*)(\\|\\s*[a-zA-Z]+\\s*)*")) {
-            return Collections.singleton(-1);
-        }
-        return Arrays.stream(capabilitiesString.split("\\s*\\|\\s*"))
-                .map(String::trim)
-                .map(QnsUtils::getNetworkCapabilityFromString)
-                .collect(Collectors.toSet());
-    }
-
-    /**
-     * Returns another transport type.
-     * @param transportType transport type
-     * @return another transport type of input parameter
-     */
-    @AccessNetworkConstants.TransportType
-    static int getOtherTransportType(@AccessNetworkConstants.TransportType int transportType) {
-        if (transportType == AccessNetworkConstants.TRANSPORT_TYPE_WLAN) {
-            return AccessNetworkConstants.TRANSPORT_TYPE_WWAN;
-        } else if (transportType == AccessNetworkConstants.TRANSPORT_TYPE_WWAN) {
-            return AccessNetworkConstants.TRANSPORT_TYPE_WLAN;
-        }
-        return AccessNetworkConstants.TRANSPORT_TYPE_INVALID;
-    }
-
-    /**
-     * Convert network capabilities to string.
-     *
-     * <p>This is for debugging and logging purposes only.
-     *
-     * @param netCaps Network capabilities.
-     * @return Network capabilities in string format.
-     */
-    @NonNull
-    static String networkCapabilitiesToString(
-            @NetCapability @Nullable Collection<Integer> netCaps) {
-        if (netCaps == null || netCaps.isEmpty()) return "";
-        return "["
-                + netCaps.stream()
-                        .map(QnsUtils::networkCapabilityToString)
-                        .collect(Collectors.joining("|"))
-                + "]";
-    }
-
-    /**
-     * Convert a network capability to string.
-     *
-     * <p>This is for debugging and logging purposes only.
-     *
-     * @param netCap Network capability.
-     * @return Network capability in string format.
-     */
-    @NonNull
-    static String networkCapabilityToString(@NetCapability int netCap) {
-        switch (netCap) {
-            case NetworkCapabilities.NET_CAPABILITY_MMS:
-                return "MMS";
-            case NetworkCapabilities.NET_CAPABILITY_SUPL:
-                return "SUPL";
-            case NetworkCapabilities.NET_CAPABILITY_DUN:
-                return "DUN";
-            case NetworkCapabilities.NET_CAPABILITY_FOTA:
-                return "FOTA";
-            case NetworkCapabilities.NET_CAPABILITY_IMS:
-                return "IMS";
-            case NetworkCapabilities.NET_CAPABILITY_CBS:
-                return "CBS";
-            case NetworkCapabilities.NET_CAPABILITY_WIFI_P2P:
-                return "WIFI_P2P";
-            case NetworkCapabilities.NET_CAPABILITY_IA:
-                return "IA";
-            case NetworkCapabilities.NET_CAPABILITY_RCS:
-                return "RCS";
-            case NetworkCapabilities.NET_CAPABILITY_XCAP:
-                return "XCAP";
-            case NetworkCapabilities.NET_CAPABILITY_EIMS:
-                return "EIMS";
-            case NetworkCapabilities.NET_CAPABILITY_NOT_METERED:
-                return "NOT_METERED";
-            case NetworkCapabilities.NET_CAPABILITY_INTERNET:
-                return "INTERNET";
-            case NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED:
-                return "NOT_RESTRICTED";
-            case NetworkCapabilities.NET_CAPABILITY_TRUSTED:
-                return "TRUSTED";
-            case NetworkCapabilities.NET_CAPABILITY_NOT_VPN:
-                return "NOT_VPN";
-            case NetworkCapabilities.NET_CAPABILITY_VALIDATED:
-                return "VALIDATED";
-            case NetworkCapabilities.NET_CAPABILITY_CAPTIVE_PORTAL:
-                return "CAPTIVE_PORTAL";
-            case NetworkCapabilities.NET_CAPABILITY_NOT_ROAMING:
-                return "NOT_ROAMING";
-            case NetworkCapabilities.NET_CAPABILITY_FOREGROUND:
-                return "FOREGROUND";
-            case NetworkCapabilities.NET_CAPABILITY_NOT_CONGESTED:
-                return "NOT_CONGESTED";
-            case NetworkCapabilities.NET_CAPABILITY_NOT_SUSPENDED:
-                return "NOT_SUSPENDED";
-            case NetworkCapabilities.NET_CAPABILITY_OEM_PAID:
-                return "OEM_PAID";
-            case NetworkCapabilities.NET_CAPABILITY_MCX:
-                return "MCX";
-            case NetworkCapabilities.NET_CAPABILITY_PARTIAL_CONNECTIVITY:
-                return "PARTIAL_CONNECTIVITY";
-            case NetworkCapabilities.NET_CAPABILITY_TEMPORARILY_NOT_METERED:
-                return "TEMPORARILY_NOT_METERED";
-            case NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE:
-                return "OEM_PRIVATE";
-            case NetworkCapabilities.NET_CAPABILITY_VEHICLE_INTERNAL:
-                return "VEHICLE_INTERNAL";
-            case NetworkCapabilities.NET_CAPABILITY_NOT_VCN_MANAGED:
-                return "NOT_VCN_MANAGED";
-            case NetworkCapabilities.NET_CAPABILITY_ENTERPRISE:
-                return "ENTERPRISE";
-            case NetworkCapabilities.NET_CAPABILITY_VSIM:
-                return "VSIM";
-            case NetworkCapabilities.NET_CAPABILITY_BIP:
-                return "BIP";
-            case NetworkCapabilities.NET_CAPABILITY_HEAD_UNIT:
-                return "HEAD_UNIT";
-            case NetworkCapabilities.NET_CAPABILITY_MMTEL:
-                return "MMTEL";
-            case NetworkCapabilities.NET_CAPABILITY_PRIORITIZE_LATENCY:
-                return "PRIORITIZE_LATENCY";
-            case NetworkCapabilities.NET_CAPABILITY_PRIORITIZE_BANDWIDTH:
-                return "PRIORITIZE_BANDWIDTH";
-            default:
-                return "Unknown(" + netCap + ")";
-        }
-    }
-
-    /**
-     * Get the network capability from the string.
-     *
-     * @param capabilityString The capability in string format
-     * @return The network capability. -1 if not found.
-     */
-    @NetCapability
-    static int getNetworkCapabilityFromString(@NonNull String capabilityString) {
-        switch (capabilityString.toUpperCase(Locale.ROOT)) {
-            case "MMS":
-                return NetworkCapabilities.NET_CAPABILITY_MMS;
-            case "SUPL":
-                return NetworkCapabilities.NET_CAPABILITY_SUPL;
-            case "DUN":
-                return NetworkCapabilities.NET_CAPABILITY_DUN;
-            case "FOTA":
-                return NetworkCapabilities.NET_CAPABILITY_FOTA;
-            case "IMS":
-                return NetworkCapabilities.NET_CAPABILITY_IMS;
-            case "CBS":
-                return NetworkCapabilities.NET_CAPABILITY_CBS;
-            case "XCAP":
-                return NetworkCapabilities.NET_CAPABILITY_XCAP;
-            case "EIMS":
-                return NetworkCapabilities.NET_CAPABILITY_EIMS;
-            case "INTERNET":
-                return NetworkCapabilities.NET_CAPABILITY_INTERNET;
-            case "MCX":
-                return NetworkCapabilities.NET_CAPABILITY_MCX;
-            case "VSIM":
-                return NetworkCapabilities.NET_CAPABILITY_VSIM;
-            case "BIP":
-                return NetworkCapabilities.NET_CAPABILITY_BIP;
-            case "ENTERPRISE":
-                return NetworkCapabilities.NET_CAPABILITY_ENTERPRISE;
-            case "PRIORITIZE_BANDWIDTH":
-                return NetworkCapabilities.NET_CAPABILITY_PRIORITIZE_BANDWIDTH;
-            case "PRIORITIZE_LATENCY":
-                return NetworkCapabilities.NET_CAPABILITY_PRIORITIZE_LATENCY;
-            default:
-                return -1;
-        }
-    }
-
-    /**
-     * Get the network capability from the apn type.
-     *
-     * @param apnType apn type.
-     * @return network capability
-     */
-    @NetCapability
-    static int getNetCapabilityFromApnType(int apnType) {
-        switch (apnType) {
-            case ApnSetting.TYPE_IMS:
-                return NetworkCapabilities.NET_CAPABILITY_IMS;
-            case ApnSetting.TYPE_EMERGENCY:
-                return NetworkCapabilities.NET_CAPABILITY_EIMS;
-            case ApnSetting.TYPE_MMS:
-                return NetworkCapabilities.NET_CAPABILITY_MMS;
-            case ApnSetting.TYPE_XCAP:
-                return NetworkCapabilities.NET_CAPABILITY_XCAP;
-            case ApnSetting.TYPE_CBS:
-                return NetworkCapabilities.NET_CAPABILITY_CBS;
-            default:
-                throw new IllegalArgumentException("Unsupported apnType: " + apnType);
-        }
-    }
-
-    /**
-     * Get the apn type from the network capability.
-     *
-     * @param netCapability network capability.
-     * @return apn type.
-     */
-    static int getApnTypeFromNetCapability(@NetCapability int netCapability) {
-        switch (netCapability) {
-            case NetworkCapabilities.NET_CAPABILITY_IMS:
-                return ApnSetting.TYPE_IMS;
-            case NetworkCapabilities.NET_CAPABILITY_EIMS:
-                return ApnSetting.TYPE_EMERGENCY;
-            case NetworkCapabilities.NET_CAPABILITY_MMS:
-                return ApnSetting.TYPE_MMS;
-            case NetworkCapabilities.NET_CAPABILITY_XCAP:
-                return ApnSetting.TYPE_XCAP;
-            case NetworkCapabilities.NET_CAPABILITY_CBS:
-                return ApnSetting.TYPE_CBS;
-            default:
-                throw new IllegalArgumentException("Unsupported netCapability: " + netCapability);
-        }
-    }
-
-    /**
-     * Convert a network capability to string.
-     *
-     * <p>This is for debugging and logging purposes only.
-     *
-     * @param netCapability Network capability.
-     * @return Network capability in string format.
-     */
-    @NonNull
-    static String getNameOfNetCapability(@NetCapability int netCapability) {
-        switch (netCapability) {
-            case NetworkCapabilities.NET_CAPABILITY_IMS:
-                return "ims";
-            case NetworkCapabilities.NET_CAPABILITY_EIMS:
-                return "eims";
-            case NetworkCapabilities.NET_CAPABILITY_MMS:
-                return "mms";
-            case NetworkCapabilities.NET_CAPABILITY_CBS:
-                return "cbs";
-            case NetworkCapabilities.NET_CAPABILITY_XCAP:
-                return "xcap";
-            default:
-                throw new IllegalArgumentException("Unsupported netCapability: " + netCapability);
-        }
-    }
-
-    /**
-     * Get the network capability from the string.
-     *
-     * @param types string array of APN types.
-     * @return list of Network Capabilities
-     */
-    @NetCapability
-    static List<Integer> getNetCapabilitiesFromApnTypesString(@NonNull String[] types) {
-        int apnTypesBitmask = 0;
-        for (String str : types) {
-            apnTypesBitmask |= ApnSetting.getApnTypeInt(str);
-        }
-        return getNetCapabilitiesFromApnTypeBitmask(apnTypesBitmask);
-    }
-
-    /**
-     * Get a list of supported network capabilities from apnTypeBitmask
-     *
-     * @param apnTypeBitmask bitmask of APN types.
-     * @return list of Network Capabilities
-     */
-    static List<Integer> getNetCapabilitiesFromApnTypeBitmask(int apnTypeBitmask) {
-        List<Integer> netCapabilities = new ArrayList<>();
-        List<Integer> apnTypes = getApnTypes(apnTypeBitmask);
-        for (int apnType : apnTypes) {
-            try {
-                netCapabilities.add(getNetCapabilityFromApnType(apnType));
-            } catch (IllegalArgumentException e) {
-                continue;
-            }
-        }
-        return netCapabilities;
-    }
-
-    static PersistableBundle readQnsDefaultConfigFromAssets(Context context, int qnsCarrierID) {
-
-        if (qnsCarrierID == TelephonyManager.UNKNOWN_CARRIER_ID) {
-            return null;
-        }
-
-        return readConfigFromAssets(context, CARRIER_ID_PREFIX + qnsCarrierID + "_");
-    }
-
-    static synchronized <T> T getConfig(
-            PersistableBundle carrierConfigBundle,
-            PersistableBundle assetConfigBundle,
-            String key) {
-
-        // TODO: PersistableBundle.get is deprecated.
-        if (carrierConfigBundle == null || carrierConfigBundle.get(key) == null) {
-            log("key not set in pb file: " + key);
-
-            if (assetConfigBundle == null || assetConfigBundle.get(key) == null) {
-                return (T) getDefaultValueForKey(key);
-            } else {
-                return (T) assetConfigBundle.get(key);
-            }
-        }
-        return (T) carrierConfigBundle.get(key);
-    }
-
-    static synchronized <T> T getDefaultValueForKey(String key) {
-        switch (key) {
-            case QnsCarrierConfigManager.KEY_QNS_SUPPORT_WFC_DURING_AIRPLANE_MODE_BOOL:
-            case QnsCarrierConfigManager.KEY_BLOCK_IPV6_ONLY_WIFI_BOOL:
-            case CarrierConfigManager.ImsVoice.KEY_CARRIER_VOLTE_ROAMING_AVAILABLE_BOOL:
-                return (T) Boolean.valueOf(true);
-            case QnsCarrierConfigManager
-                    .KEY_QNS_ALLOW_VIDEO_OVER_IWLAN_WITH_CELLULAR_LIMITED_CASE_BOOL:
-            case QnsCarrierConfigManager.KEY_QNS_HO_GUARDING_BY_PREFERENCE_BOOL:
-            case QnsCarrierConfigManager.KEY_QNS_SUPPORT_SERVICE_BARRING_CHECK_BOOL:
-            case QnsCarrierConfigManager
-                    .KEY_ROAM_TRANSPORT_TYPE_SELECTION_WITHOUT_SIGNAL_STRENGTH_BOOL:
-            case QnsCarrierConfigManager.KEY_PREFER_CURRENT_TRANSPORT_TYPE_IN_VOICE_CALL_BOOL:
-            case QnsCarrierConfigManager.KEY_POLICY_OVERRIDE_CELL_PREF_TO_IMS_PREF_HOME_BOOL:
-            case QnsCarrierConfigManager
-                    .KEY_QNS_ROVE_OUT_POLICY_WITH_WIFI_BAD_GUARDTIMER_CONDITIONS_BOOL:
-            case QnsCarrierConfigManager.KEY_QNS_ALLOW_IMS_OVER_IWLAN_CELLULAR_LIMITED_CASE_BOOL:
-            case QnsCarrierConfigManager.KEY_BLOCK_IWLAN_IN_INTERNATIONAL_ROAMING_WITHOUT_WWAN_BOOL:
-            case QnsCarrierConfigManager
-                    .KEY_IN_CALL_HO_DECISION_WLAN_TO_WWAN_WITHOUT_VOPS_CONDITION_BOOL:
-                return (T) Boolean.valueOf(false);
-            case QnsCarrierConfigManager.KEY_SIP_DIALOG_SESSION_POLICY_INT:
-                return (T) Integer.valueOf(QnsConstants.SIP_DIALOG_SESSION_POLICY_NONE);
-            case QnsCarrierConfigManager.KEY_QNS_CELLULAR_SS_THRESHOLDBACKHAUL_TIMER_MS_INT:
-                return (T) Integer.valueOf(QnsConstants.KEY_DEFAULT_VALUE);
-            case QnsCarrierConfigManager.KEY_QNS_WIFI_RSSI_THRESHOLDBACKHAUL_TIMER_MS_INT:
-                return (T) Integer.valueOf(QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER);
-            case QnsCarrierConfigManager.KEY_QNS_IMS_TRANSPORT_TYPE_INT:
-                return (T) Integer.valueOf(QnsConstants.TRANSPORT_TYPE_ALLOWED_BOTH);
-            case QnsCarrierConfigManager.KEY_QNS_MMS_TRANSPORT_TYPE_INT:
-            case QnsCarrierConfigManager.KEY_QNS_CBS_TRANSPORT_TYPE_INT:
-            case QnsCarrierConfigManager.KEY_QNS_SOS_TRANSPORT_TYPE_INT:
-                return (T) Integer.valueOf(QnsConstants.TRANSPORT_TYPE_ALLOWED_WWAN);
-            case QnsCarrierConfigManager.KEY_QNS_XCAP_RAT_PREFERENCE_INT:
-            case QnsCarrierConfigManager.KEY_QNS_SOS_RAT_PREFERENCE_INT:
-            case QnsCarrierConfigManager.KEY_QNS_MMS_RAT_PREFERENCE_INT:
-            case QnsCarrierConfigManager.KEY_QNS_CBS_RAT_PREFERENCE_INT:
-                return (T) Integer.valueOf(QnsConstants.RAT_PREFERENCE_DEFAULT);
-            case KEY_QNS_VOWIFI_REGISTATION_TIMER_FOR_VOWIFI_ACTIVATION_INT:
-                return (T) Integer.valueOf(CONFIG_DEFAULT_VOWIFI_REGISTATION_TIMER);
-            case CarrierConfigManager.ImsVoice.KEY_VOICE_RTP_JITTER_THRESHOLD_MILLIS_INT:
-            case CarrierConfigManager.ImsVoice.KEY_VOICE_RTP_PACKET_LOSS_RATE_THRESHOLD_INT:
-                return (T) Integer.valueOf(QnsConstants.INVALID_VALUE);
-            case QnsCarrierConfigManager.KEY_QNS_MEDIA_THRESHOLD_RTP_PACKET_LOSS_TIME_MILLIS_INT:
-                return (T) Integer.valueOf(QnsConstants.KEY_DEFAULT_PACKET_LOSS_TIME_MILLIS);
-            case CarrierConfigManager.ImsVoice.KEY_VOICE_RTP_INACTIVITY_TIME_THRESHOLD_MILLIS_LONG:
-                return (T) Long.valueOf(QnsConstants.INVALID_VALUE);
-            case QnsCarrierConfigManager
-                    .KEY_QNS_IN_CALL_ROVEIN_ALLOWED_COUNT_AND_FALLBACK_REASON_INT_ARRAY:
-                return (T)
-                        new int[] {
-                            QnsConstants.MAX_COUNT_INVALID, QnsConstants.FALLBACK_REASON_INVALID
-                        };
-            case QnsCarrierConfigManager
-                    .KEY_WAITING_TIME_FOR_PREFERRED_TRANSPORT_WHEN_POWER_ON_INT_ARRAY:
-            case QnsCarrierConfigManager.KEY_NON_IMS_WWAN_HYSTERESIS_TIMER_MS_INT_ARRAY:
-            case QnsCarrierConfigManager.KEY_NON_IMS_WLAN_HYSTERESIS_TIMER_MS_INT_ARRAY:
-                return (T)
-                        new int[] {QnsConstants.KEY_DEFAULT_VALUE, QnsConstants.KEY_DEFAULT_VALUE};
-            case QnsCarrierConfigManager.KEY_QNS_IMS_NETWORK_ENABLE_HO_HYSTERESIS_TIMER_INT:
-                return (T) Integer.valueOf(QnsConstants.COVERAGE_BOTH);
-            case QnsCarrierConfigManager
-                    .KEY_QNS_HO_RESTRICT_TIME_WITH_LOW_RTP_QUALITY_MILLIS_INT_ARRAY:
-                return (T)
-                        new int[] {
-                            QnsConstants.KEY_DEFAULT_IWLAN_AVOID_TIME_LOW_RTP_QUALITY_MILLIS,
-                            QnsConstants.KEY_DEFAULT_WWAN_AVOID_TIME_LOW_RTP_QUALITY_MILLIS,
-                        };
-            case QnsCarrierConfigManager.KEY_IMS_WWAN_HYSTERESIS_TIMER_MS_INT_ARRAY:
-            case QnsCarrierConfigManager.KEY_IMS_WLAN_HYSTERESIS_TIMER_MS_INT_ARRAY:
-                return (T)
-                        new int[] {
-                            QnsConstants.KEY_DEFAULT_HYST_TIMER,
-                            QnsConstants.KEY_DEFAULT_HYST_TIMER,
-                            QnsConstants.KEY_DEFAULT_HYST_TIMER
-                        };
-            case QnsCarrierConfigManager.KEY_MINIMUM_HANDOVER_GUARDING_TIMER_MS_INT:
-                return (T) Integer.valueOf(QnsConstants.CONFIG_DEFAULT_MIN_HANDOVER_GUARDING_TIMER);
-            case QnsCarrierConfigManager
-                    .KEY_CHOOSE_WFC_PREFERRED_TRANSPORT_IN_BOTH_BAD_CONDITION_INT_ARRAY:
-                return (T) new int[] {};
-            case QnsCarrierConfigManager.KEY_IMS_CELLULAR_ALLOWED_RAT_STRING_ARRAY:
-                return (T) new String[] {"LTE", "NR"};
-            case QnsCarrierAnspSupportConfig.KEY_IDLE_NGRAN_SSRSRP_INT_ARRAY:
-            case QnsCarrierAnspSupportConfig.KEY_VOICE_NGRAN_SSRSRP_INT_ARRAY:
-            case QnsCarrierAnspSupportConfig.KEY_VIDEO_NGRAN_SSRSRP_INT_ARRAY:
-                return (T)
-                        new int[] {
-                            QnsConstants.KEY_DEFAULT_THRESHOLD_SSRSRP_GOOD,
-                            QnsConstants.KEY_DEFAULT_THRESHOLD_SSRSRP_BAD,
-                            QnsCarrierConfigManager.QnsConfigArray.INVALID
-                        };
-            case QnsCarrierAnspSupportConfig.KEY_IDLE_EUTRAN_RSRP_INT_ARRAY:
-            case QnsCarrierAnspSupportConfig.KEY_VOICE_EUTRAN_RSRP_INT_ARRAY:
-            case QnsCarrierAnspSupportConfig.KEY_VIDEO_EUTRAN_RSRP_INT_ARRAY:
-                return (T)
-                        new int[] {
-                            QnsConstants.KEY_DEFAULT_THRESHOLD_RSRP_GOOD,
-                            QnsConstants.KEY_DEFAULT_THRESHOLD_RSRP_BAD,
-                            QnsCarrierConfigManager.QnsConfigArray.INVALID
-                        };
-            case QnsCarrierAnspSupportConfig.KEY_IDLE_UTRAN_RSCP_INT_ARRAY:
-            case QnsCarrierAnspSupportConfig.KEY_VOICE_UTRAN_RSCP_INT_ARRAY:
-            case QnsCarrierAnspSupportConfig.KEY_VIDEO_UTRAN_RSCP_INT_ARRAY:
-                return (T)
-                        new int[] {
-                            QnsConstants.KEY_DEFAULT_THRESHOLD_RSCP_GOOD,
-                            QnsConstants.KEY_DEFAULT_THRESHOLD_RSCP_BAD,
-                            QnsCarrierConfigManager.QnsConfigArray.INVALID
-                        };
-            case QnsCarrierAnspSupportConfig.KEY_IDLE_GERAN_RSSI_INT_ARRAY:
-            case QnsCarrierAnspSupportConfig.KEY_VOICE_GERAN_RSSI_INT_ARRAY:
-            case QnsCarrierAnspSupportConfig.KEY_VIDEO_GERAN_RSSI_INT_ARRAY:
-                return (T)
-                        new int[] {
-                            QnsConstants.KEY_DEFAULT_THRESHOLD_GERAN_RSSI_GOOD,
-                            QnsConstants.KEY_DEFAULT_THRESHOLD_GERAN_RSSI_BAD,
-                            QnsCarrierConfigManager.QnsConfigArray.INVALID
-                        };
-            case QnsCarrierAnspSupportConfig.KEY_IDLE_WIFI_RSSI_INT_ARRAY:
-            case QnsCarrierAnspSupportConfig.KEY_VOICE_WIFI_RSSI_INT_ARRAY:
-            case QnsCarrierAnspSupportConfig.KEY_VIDEO_WIFI_RSSI_INT_ARRAY:
-                return (T)
-                        new int[] {
-                            QnsConstants.KEY_DEFAULT_THRESHOLD_WIFI_RSSI_GOOD,
-                            QnsConstants.KEY_DEFAULT_THRESHOLD_WIFI_RSSI_BAD
-                        };
-            case QnsCarrierAnspSupportConfig.KEY_OVERRIDE_WIFI_PREF_IDLE_WIFI_RSSI_INT_ARRAY:
-            case QnsCarrierAnspSupportConfig.KEY_OVERRIDE_WIFI_PREF_VOICE_WIFI_RSSI_INT_ARRAY:
-            case QnsCarrierAnspSupportConfig.KEY_OVERRIDE_WIFI_PREF_VIDEO_WIFI_RSSI_INT_ARRAY:
-            case CarrierConfigManager.Ims.KEY_IMS_PDN_ENABLED_IN_NO_VOPS_SUPPORT_INT_ARRAY:
-                return (T) new int[] {};
-            case QnsCarrierConfigManager.KEY_QNS_WLAN_RTT_BACKHAUL_CHECK_ON_ICMP_PING_STRING:
-                return (T) "";
-            case QnsCarrierConfigManager
-                    .KEY_QNS_FALLBACK_ON_INITIAL_CONNECTION_FAILURE_STRING_ARRAY:
-                return (T) new String[] {};
-            default:
-                break;
-        }
-        return (T) null;
-    }
-
-    static synchronized int getConfigCarrierId(Context context, int slotId) {
-        TelephonyManager tm = context.getSystemService(TelephonyManager.class);
-        tm = tm.createForSubscriptionId(QnsUtils.getSubId(context, slotId));
-        return tm.getSimCarrierId();
-    }
-
-    private static String getAssetFileName(Context context, String carrierIDConfig) {
-        String[] configFileNameList;
-        try {
-            configFileNameList = context.getAssets().list("");
-            for (String fileName : configFileNameList) {
-                if (fileName.startsWith(carrierIDConfig)) {
-                    log("matched file: " + fileName);
-                    return fileName;
-                }
-            }
-        } catch (Exception e) {
-            loge("getFileName, can't find " + carrierIDConfig + " asset");
-        }
-        return null;
-    }
-
-    private static PersistableBundle readConfigFromAssets(Context context, String carrierIDConfig) {
-        PersistableBundle bundleFromAssets = new PersistableBundle();
-
-        String fileName = getAssetFileName(context, carrierIDConfig);
-        InputStream inputStream = null;
-        InputStreamReader inputStreamReader = null;
-        try {
-            inputStream = context.getAssets().open(fileName);
-            inputStreamReader = new InputStreamReader(inputStream);
-            Stream<String> streamOfString = new BufferedReader(inputStreamReader).lines();
-            String streamToString = streamOfString.collect(Collectors.joining());
-
-            String configTag = "carrier_config";
-            int begin = streamToString.indexOf(configTag);
-            int end = streamToString.lastIndexOf(configTag) + configTag.length();
-            String bundleString = "<" + streamToString.substring(begin, end) + ">";
-
-            InputStream targetStream = new ByteArrayInputStream(bundleString.getBytes());
-            bundleFromAssets = PersistableBundle.readFromStream(targetStream);
-
-            log("bundleFromAssets created : " + bundleFromAssets);
-
-        } catch (Exception e) {
-            loge("readConfigFromAssets, e: " + e);
-        } finally {
-            if (inputStreamReader != null) {
-                try {
-                    inputStreamReader.close();
-                } catch (Exception e) {
-                    loge("inputStreamReader.close e:" + e);
-                }
-            }
-            if (inputStream != null) {
-                try {
-                    inputStream.close();
-                } catch (Exception e) {
-                    loge("inputStream.close e:" + e);
-                }
-            }
-        }
-        return bundleFromAssets;
-    }
-
-    protected static void loge(String log) {
-        Log.e(QnsUtils.class.getSimpleName(), log);
-    }
-
-    protected static void log(String log) {
-        Log.d(QnsUtils.class.getSimpleName(), log);
-    }
-
-    protected static class QnsExecutor implements Executor {
-        private final Handler mHandler;
-
-        QnsExecutor(Handler handler) {
-            mHandler = handler;
-        }
-
-        @Override
-        public void execute(Runnable command) {
-            if (!mHandler.post(command)) {
-                throw new RejectedExecutionException(mHandler + " is shutting down");
-            }
-        }
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/QualifiedNetworksServiceImpl.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/QualifiedNetworksServiceImpl.java
deleted file mode 100644
index 679098e..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/QualifiedNetworksServiceImpl.java
+++ /dev/null
@@ -1,364 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static android.telephony.data.ThrottleStatus.THROTTLE_TYPE_ELAPSED_TIME;
-
-import android.annotation.NonNull;
-import android.content.Context;
-import android.net.NetworkCapabilities;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Looper;
-import android.os.Message;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.data.QualifiedNetworksService;
-import android.telephony.data.ThrottleStatus;
-import android.util.Log;
-
-import com.android.internal.annotations.VisibleForTesting;
-
-import java.io.FileDescriptor;
-import java.io.PrintWriter;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Implementation of the qualified networks service, which is a service providing up-to-date
- * qualified network information to the frameworks for data handover control. A qualified network is
- * defined as an access network that is ready for bringing up data connection for given APN types.
- */
-public class QualifiedNetworksServiceImpl extends QualifiedNetworksService {
-
-    static final String LOG_TAG = QualifiedNetworksServiceImpl.class.getSimpleName();
-    private static final boolean DBG = true;
-    private static final int QNS_CONFIGURATION_LOADED = 1;
-    private static final int QUALIFIED_NETWORKS_CHANGED = 2;
-    private static final int QNS_CONFIGURATION_CHANGED = 3;
-    HashMap<Integer, NetworkAvailabilityProviderImpl> mProviderMap = new HashMap<>();
-    HashMap<Integer, HandlerThread> mHandlerThreadMap = new HashMap<>();
-    Context mContext;
-    HandlerThread mHandlerThread;
-    @VisibleForTesting QnsComponents mQnsComponents;
-
-    /** Default constructor. */
-    public QualifiedNetworksServiceImpl() {
-        super();
-        log("created QualifiedNetworksServiceImpl.");
-    }
-
-    /**
-     * Create the instance of {@link NetworkAvailabilityProvider}. Vendor qualified network service
-     * must override this method to facilitate the creation of {@link NetworkAvailabilityProvider}
-     * instances. The system will call this method after binding the qualified networks service for
-     * each active SIM slot index.
-     *
-     * @param slotIndex SIM slot index the qualified networks service associated with.
-     * @return Qualified networks service instance
-     */
-    @Override
-    public NetworkAvailabilityProvider onCreateNetworkAvailabilityProvider(int slotIndex) {
-        log("Qualified Networks Service created for slot " + slotIndex);
-        if (!QnsUtils.isValidSlotIndex(mContext, slotIndex)) {
-            log("Invalid slotIndex " + slotIndex + ". fail to create NetworkAvailabilityProvider");
-            return null;
-        }
-        if (!mHandlerThreadMap.containsKey(slotIndex)) {
-            HandlerThread ht = new HandlerThread("NapConfigHandler-" + slotIndex);
-            ht.start();
-            mHandlerThreadMap.put(slotIndex, ht);
-        }
-        NetworkAvailabilityProviderImpl provider = new NetworkAvailabilityProviderImpl(slotIndex);
-        mProviderMap.put(slotIndex, provider);
-        return provider;
-    }
-
-    @Override
-    public void onCreate() {
-        log("onCreate");
-        mContext = getApplicationContext();
-        mQnsComponents = new QnsComponents(mContext);
-        mHandlerThread = new HandlerThread(LOG_TAG);
-        mHandlerThread.start();
-    }
-
-    @Override
-    public void onDestroy() {
-        log("onDestroy");
-        for (NetworkAvailabilityProviderImpl provider : mProviderMap.values()) {
-            provider.close();
-        }
-        for (HandlerThread ht : mHandlerThreadMap.values()) {
-            ht.quitSafely();
-        }
-        mHandlerThreadMap.clear();
-        mProviderMap.clear();
-        mHandlerThread.quitSafely();
-        super.onDestroy();
-    }
-
-    protected void log(String s) {
-        if (DBG) Log.d(LOG_TAG, s);
-    }
-
-    static class QualifiedNetworksInfo {
-        int mNetCapability;
-        List<Integer> mAccessNetworkTypes;
-
-        QualifiedNetworksInfo(int netCapability, List<Integer> accessNetworkTypes) {
-            mNetCapability = netCapability;
-            mAccessNetworkTypes = accessNetworkTypes;
-        }
-
-        int getNetCapability() {
-            return mNetCapability;
-        }
-
-        void setNetCapability(int netCapability) {
-            mNetCapability = netCapability;
-        }
-
-        List<Integer> getAccessNetworkTypes() {
-            return mAccessNetworkTypes;
-        }
-
-        void setAccessNetworkTypes(List<Integer> accessNetworkTypes) {
-            mAccessNetworkTypes = accessNetworkTypes;
-        }
-    }
-
-    /**
-     * The network availability provider implementation class. The qualified network service must
-     * extend this class to report the available networks for data connection setup. Note that each
-     * instance of network availability provider is associated with slot.
-     */
-    public class NetworkAvailabilityProviderImpl extends NetworkAvailabilityProvider {
-        private final String mLogTag;
-        private final int mSlotIndex;
-        @VisibleForTesting Handler mHandler;
-        @VisibleForTesting Handler mConfigHandler;
-        private boolean mIsQnsConfigChangeRegistered = false;
-
-        protected QnsCarrierConfigManager mConfigManager;
-        protected HashMap<Integer, AccessNetworkEvaluator> mEvaluators = new HashMap<>();
-        private boolean mIsClosed;
-
-        /**
-         * Constructor
-         *
-         * @param slotIndex SIM slot index the network availability provider associated with.
-         */
-        public NetworkAvailabilityProviderImpl(int slotIndex) {
-            super(slotIndex);
-            mLogTag = NetworkAvailabilityProviderImpl.class.getSimpleName() + "_" + slotIndex;
-
-            mIsClosed = false;
-            mSlotIndex = slotIndex;
-            mConfigHandler = new NapHandler(mHandlerThreadMap.get(mSlotIndex).getLooper());
-            mConfigHandler.post(this::initNetworkAvailabilityProvider);
-            mHandler = new NapHandler(mHandlerThread.getLooper());
-        }
-
-        private class NapHandler extends Handler {
-            NapHandler(Looper looper) {
-                super(looper);
-            }
-
-            @Override
-            public void handleMessage(Message msg) {
-                super.handleMessage(msg);
-                switch (msg.what) {
-                    case QNS_CONFIGURATION_LOADED:
-                        onConfigurationLoaded();
-                        break;
-                    case QNS_CONFIGURATION_CHANGED:
-                        log("Qns Configuration changed received");
-                        onConfigurationChanged();
-                        break;
-                    case QUALIFIED_NETWORKS_CHANGED:
-                        QnsAsyncResult ar = (QnsAsyncResult) msg.obj;
-                        onQualifiedNetworksChanged((QualifiedNetworksInfo) ar.mResult);
-                        break;
-                    default:
-                        log("got event " + msg.what + " never reached here.");
-                        break;
-                }
-            }
-        }
-
-        private void initNetworkAvailabilityProvider() {
-            mQnsComponents.createQnsComponents(mSlotIndex);
-            mConfigManager = mQnsComponents.getQnsCarrierConfigManager(mSlotIndex);
-            mConfigManager.registerForConfigurationLoaded(mConfigHandler, QNS_CONFIGURATION_LOADED);
-        }
-
-        protected void onConfigurationLoaded() {
-            log("onConfigurationLoaded");
-            // Register for Upgradable Config items load case
-            if (!mIsQnsConfigChangeRegistered) {
-                mConfigManager.registerForConfigurationChanged(
-                        mConfigHandler, QNS_CONFIGURATION_CHANGED);
-                mIsQnsConfigChangeRegistered = true;
-            }
-
-            HashMap<Integer, AccessNetworkEvaluator> evaluators = new HashMap<>();
-            List<Integer> netCapabilities = mConfigManager.getQnsSupportedNetCapabilities();
-
-            for (int netCapability : netCapabilities) {
-                int transportType = mConfigManager.getQnsSupportedTransportType(netCapability);
-                if (transportType < 0
-                        || transportType == QnsConstants.TRANSPORT_TYPE_ALLOWED_WWAN) {
-                    continue;
-                }
-                if (mEvaluators.get(netCapability) != null) {
-                    AccessNetworkEvaluator evaluator = mEvaluators.remove(netCapability);
-                    evaluators.put(netCapability, evaluator);
-                    // reuse evaluator
-                    evaluator.rebuild();
-                } else {
-                    AccessNetworkEvaluator evaluator =
-                            new AccessNetworkEvaluator(mQnsComponents, netCapability, mSlotIndex);
-                    evaluator.registerForQualifiedNetworksChanged(
-                            mHandler, QUALIFIED_NETWORKS_CHANGED);
-                    evaluators.put(netCapability, evaluator);
-                }
-            }
-            for (Integer capability : mEvaluators.keySet()) {
-                AccessNetworkEvaluator evaluator = mEvaluators.get(capability);
-                evaluator.unregisterForQualifiedNetworksChanged(mHandler);
-                evaluator.close();
-            }
-            mEvaluators.clear();
-            mEvaluators = evaluators;
-        }
-
-        protected void onConfigurationChanged() {}
-
-        private void onQualifiedNetworksChanged(QualifiedNetworksInfo info) {
-            log(
-                    "Calling updateQualifiedNetworkTypes for mNetCapability["
-                            + QnsUtils.getNameOfNetCapability(info.getNetCapability())
-                            + "], preferred networks "
-                            + QnsUtils.getStringAccessNetworkTypes(info.getAccessNetworkTypes()));
-
-            int apnType = QnsUtils.getApnTypeFromNetCapability(info.getNetCapability());
-            updateQualifiedNetworkTypes(apnType, info.getAccessNetworkTypes());
-        }
-
-        @Override
-        public void reportThrottleStatusChanged(@NonNull List<ThrottleStatus> statuses) {
-            log("reportThrottleStatusChanged: statuses size=" + statuses.size());
-            for (ThrottleStatus ts : statuses) {
-                int netCapability;
-                try {
-                    netCapability = QnsUtils.getNetCapabilityFromApnType(ts.getApnType());
-                } catch (IllegalArgumentException e) {
-                    continue;
-                }
-                log("ThrottleStatus:" + ts + ", netCapability" + netCapability);
-                if (ts.getSlotIndex() != getSlotIndex()) {
-                    continue;
-                }
-                AccessNetworkEvaluator evaluator = mEvaluators.get(netCapability);
-                if (evaluator == null) {
-                    continue;
-                }
-                boolean isThrottle = ts.getThrottleType() == THROTTLE_TYPE_ELAPSED_TIME;
-                evaluator.updateThrottleStatus(
-                        isThrottle, ts.getThrottleExpiryTimeMillis(), ts.getTransportType());
-            }
-        }
-
-        @Override
-        public void reportEmergencyDataNetworkPreferredTransportChanged(
-                @AccessNetworkConstants.TransportType int transportType) {
-            log("reportEmergencyDataNetworkPreferredTransportChanged: "
-                    + QnsConstants.transportTypeToString(transportType));
-            AccessNetworkEvaluator evaluator =
-                    mEvaluators.get(NetworkCapabilities.NET_CAPABILITY_EIMS);
-            if (evaluator != null) {
-                evaluator.onEmergencyPreferredTransportTypeChanged(transportType);
-            } else {
-                log("There is no Emergency ANE");
-            }
-        }
-
-        @Override
-        public synchronized void close() {
-            mConfigHandler.post(this::onClose);
-        }
-
-        private synchronized void onClose() {
-            if (!mIsClosed) {
-                mIsClosed = true;
-                log("closing NetworkAvailabilityProviderImpl");
-                mConfigManager.unregisterForConfigurationLoaded(mConfigHandler);
-                mConfigManager.unregisterForConfigurationChanged(mConfigHandler);
-                mIsQnsConfigChangeRegistered = false;
-                for (Integer netCapability : mEvaluators.keySet()) {
-                    AccessNetworkEvaluator evaluator = mEvaluators.get(netCapability);
-                    evaluator.unregisterForQualifiedNetworksChanged(mHandler);
-                    evaluator.close();
-                }
-                mQnsComponents.closeComponents(mSlotIndex);
-                mEvaluators.clear();
-            }
-        }
-
-        protected void log(String s) {
-            if (DBG) Log.d(mLogTag, s);
-        }
-
-        /**
-         * Dumps the state of {@link QualityMonitor}
-         *
-         * @param pw {@link PrintWriter} to write the state of the object.
-         * @param prefix String to append at start of dumped log.
-         */
-        void dump(PrintWriter pw, String prefix) {
-            pw.println(prefix + "------------------------------");
-            pw.println(prefix + "NetworkAvailabilityProviderImpl[" + mSlotIndex + "]:");
-            for (Map.Entry<Integer, AccessNetworkEvaluator> aneMap : mEvaluators.entrySet()) {
-                AccessNetworkEvaluator ane = aneMap.getValue();
-                ane.dump(pw, prefix + "  ");
-            }
-            QnsTelephonyListener tl = mQnsComponents.getQnsTelephonyListener(mSlotIndex);
-            if (tl != null) {
-                tl.dump(pw, prefix + "  ");
-            }
-            CellularQualityMonitor cQM = mQnsComponents.getCellularQualityMonitor(mSlotIndex);
-            if (cQM != null) {
-                cQM.dump(pw, prefix + "  ");
-            }
-        }
-    }
-
-    @Override
-    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
-        super.dump(fd, pw, args);
-        pw.println("QualifiedNetworksServiceImpl:");
-        pw.println("==============================");
-        for (Map.Entry<Integer, NetworkAvailabilityProviderImpl> providerMap :
-                mProviderMap.entrySet()) {
-            NetworkAvailabilityProviderImpl provider = providerMap.getValue();
-            provider.dump(pw, "  ");
-        }
-        mQnsComponents.dump(pw);
-        pw.println("==============================");
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/QualityMonitor.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/QualityMonitor.java
deleted file mode 100644
index ffc2091..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/QualityMonitor.java
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.telephony.qns;
-
-import android.content.Context;
-import android.util.Log;
-
-import java.io.PrintWriter;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.concurrent.ConcurrentHashMap;
-
-/**
- * This class manages threshold information registered from AccessNetworkEvaluator It monitors
- * Cellular or WiFi qualities(WiFi RSSI, 4g/5g RSRP , 3G RSCP , 2G RSSI etc..) and report event if
- * the network quality changes over the threshold value.
- */
-abstract class QualityMonitor {
-    private static final int BASE = 1000;
-    protected static final int EVENT_CELLULAR_QNS_TELEPHONY_INFO_CHANGED = BASE + 1;
-    protected static final int EVENT_WIFI_RSSI_CHANGED = BASE + 2;
-    protected static final int EVENT_WIFI_STATE_CHANGED = BASE + 3;
-    protected static final int EVENT_WIFI_NOTIFY_TIMER_EXPIRED = BASE + 4;
-    protected static final int EVENT_SUBSCRIPTION_ID_CHANGED = BASE + 5;
-    private final String mTag;
-    protected Context mContext;
-    protected final HashMap<String, IThresholdListener> mThresholdCallbackMap = new HashMap<>();
-    protected final ConcurrentHashMap<String, List<Threshold>> mThresholdsList =
-            new ConcurrentHashMap<>();
-    protected final HashMap<String, Boolean> mWaitingThresholds = new HashMap<>();
-
-    /** To-Do: For future use. */
-    protected QualityMonitor(String tag) {
-        mTag = tag;
-    }
-
-    /** Get current Quality based on access network & measurement type */
-    abstract int getCurrentQuality(int accessNetwork, int measurementType);
-
-    /** This method registers the thresholds to monitor the signal strengths */
-    void registerThresholdChange(
-            ThresholdCallback thresholdCallback,
-            int netCapability,
-            Threshold[] ths,
-            int slotIndex) {
-        String key = getKey(netCapability, slotIndex);
-        Log.d(mTag, "Registering for slotIndex=[" + slotIndex + "], key=[" + key + "]");
-        mThresholdCallbackMap.put(key, thresholdCallback.mCallback);
-    }
-
-    /** Unregister the Cellular & Wifi Quality threshold */
-    void unregisterThresholdChange(int netCapability, int slotIndex) {
-        String key = getKey(netCapability, slotIndex);
-        Log.d(mTag, "Unregister threshold change for key=[" + key + "]");
-        mThresholdCallbackMap.remove(key);
-        mThresholdsList.remove(key);
-        mWaitingThresholds.remove(key);
-    }
-
-    /**
-     * It replace/set the new threshold values to listen for the given netCapability.
-     *
-     * @param netCapability Network Capability for which new thresholds are updated
-     * @param slotIndex slot id
-     * @param ths updated thresholds array. If ths is empty; if thresholds are registered for given
-     *     netCapability, it will be cleared and removed from registered list.
-     */
-    void updateThresholdsForNetCapability(int netCapability, int slotIndex, Threshold[] ths) {
-        String key = getKey(netCapability, slotIndex);
-        if (mThresholdCallbackMap.get(key) == null) {
-            throw new IllegalStateException(
-                    "For the netCapability = "
-                            + netCapability
-                            + "["
-                            + slotIndex
-                            + "], no callback is registered");
-        }
-        if (ths == null || ths.length == 0) {
-            mThresholdsList.remove(key);
-            mWaitingThresholds.remove(key);
-        } else {
-            mThresholdsList.put(key, new ArrayList<>(List.of(ths)));
-        }
-        Log.d(mTag, "Thresholds stored: " + mThresholdsList);
-    }
-
-    protected abstract void notifyThresholdChange(String key, Threshold[] ths);
-
-    /**
-     * This method provides unique key to store the hashmap values and need to optimize in future.
-     */
-    protected String getKey(int netCapability, int slotIndex) {
-        return netCapability + "_" + slotIndex;
-    }
-
-    public void close() {
-        mThresholdsList.clear();
-        mWaitingThresholds.clear();
-        mThresholdCallbackMap.clear();
-    }
-
-    /**
-     * Dumps the state of {@link QualityMonitor}
-     *
-     * @param pw {@link PrintWriter} to write the state of the object.
-     * @param prefix String to append at start of dumped log.
-     */
-    void dump(PrintWriter pw, String prefix) {
-        pw.println(prefix + "mThresholdCallbackMap=" + mThresholdCallbackMap);
-        pw.println(prefix + "mThresholdsList=" + mThresholdsList);
-        pw.println(prefix + "mWaitingThresholds=" + mWaitingThresholds);
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/RestrictManager.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/RestrictManager.java
deleted file mode 100644
index 18bb076..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/RestrictManager.java
+++ /dev/null
@@ -1,1741 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static com.android.telephony.qns.DataConnectionStatusTracker.STATE_CONNECTED;
-import static com.android.telephony.qns.DataConnectionStatusTracker.STATE_HANDOVER;
-import static com.android.telephony.qns.QnsConstants.INVALID_ID;
-
-import android.annotation.IntDef;
-import android.net.NetworkCapabilities;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
-import android.os.SystemClock;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.Annotation;
-import android.telephony.TelephonyManager;
-import android.util.Log;
-import android.util.Pair;
-
-import com.android.internal.annotations.VisibleForTesting;
-import com.android.telephony.qns.DataConnectionStatusTracker.DataConnectionChangedInfo;
-
-import java.io.PrintWriter;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-
-/**
- * Prevents HO pingpong between Cellular and IWLAN. Provide Throttling for certain cause. Provide
- * Handover not allowed policy.
- */
-class RestrictManager {
-    private final String mLogTag;
-    private final boolean mDebugFlag = true;
-    static final int RESTRICT_TYPE_GUARDING = 1;
-    static final int RESTRICT_TYPE_THROTTLING = 2;
-    static final int RESTRICT_TYPE_HO_NOT_ALLOWED = 3;
-    static final int RESTRICT_TYPE_NON_PREFERRED_TRANSPORT = 4;
-    static final int RESTRICT_TYPE_RTP_LOW_QUALITY = 5;
-    static final int RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL = 6;
-    static final int RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL = 7;
-    static final int RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL = 8;
-    static final int RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL = 9;
-    static final int RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL = 10;
-
-    @IntDef(
-            value = {
-                RESTRICT_TYPE_GUARDING,
-                RESTRICT_TYPE_THROTTLING,
-                RESTRICT_TYPE_HO_NOT_ALLOWED,
-                RESTRICT_TYPE_NON_PREFERRED_TRANSPORT,
-                RESTRICT_TYPE_RTP_LOW_QUALITY,
-                RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL,
-                RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL,
-                RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL,
-                RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL,
-            })
-    @interface RestrictType {}
-
-    static final int RELEASE_EVENT_DISCONNECT = 1;
-    static final int RELEASE_EVENT_WIFI_AP_CHANGED = 2;
-    static final int RELEASE_EVENT_WFC_PREFER_MODE_CHANGED = 3;
-    static final int RELEASE_EVENT_CALL_END = 4;
-    static final int RELEASE_EVENT_IMS_NOT_SUPPORT_RAT = 5;
-
-    @IntDef(
-            value = {
-                RELEASE_EVENT_DISCONNECT,
-                RELEASE_EVENT_WIFI_AP_CHANGED,
-                RELEASE_EVENT_WFC_PREFER_MODE_CHANGED,
-                RELEASE_EVENT_CALL_END,
-                RELEASE_EVENT_IMS_NOT_SUPPORT_RAT,
-            })
-    @interface ReleaseEvent {}
-
-    private static final int EVENT_DATA_CONNECTION_CHANGED = 3001;
-    private static final int EVENT_CALL_STATE_CHANGED = 3002;
-    private static final int EVENT_SRVCC_STATE_CHANGED = 3003;
-    private static final int EVENT_IMS_REGISTRATION_STATE_CHANGED = 3004;
-    private static final int EVENT_LOW_RTP_QUALITY_REPORTED = 3006;
-    private static final int EVENT_RELEASE_RESTRICTION = 3008;
-    protected static final int EVENT_INITIAL_DATA_CONNECTION_FAIL_RETRY_TIMER_EXPIRED = 3009;
-    private static final int EVENT_WIFI_RTT_BACKHAUL_CHECK_STATUS = 3010;
-
-    @VisibleForTesting static final int GUARDING_TIMER_HANDOVER_INIT = 30000;
-
-    static final Map<Integer, int[]> sReleaseEventMap = Map.ofEntries(
-                    Map.entry(
-                            RESTRICT_TYPE_GUARDING,
-                            new int[] {
-                                RELEASE_EVENT_DISCONNECT, RELEASE_EVENT_WFC_PREFER_MODE_CHANGED
-                            }),
-                    Map.entry(
-                            RESTRICT_TYPE_RTP_LOW_QUALITY,
-                            new int[] {RELEASE_EVENT_CALL_END, RELEASE_EVENT_WIFI_AP_CHANGED}),
-                    Map.entry(
-                            RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL,
-                            new int[] {RELEASE_EVENT_CALL_END}),
-                    Map.entry(
-                            RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL,
-                            new int[] {
-                                RELEASE_EVENT_DISCONNECT, RELEASE_EVENT_IMS_NOT_SUPPORT_RAT
-                            }),
-                    Map.entry(
-                            RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL,
-                            new int[] {
-                                RELEASE_EVENT_DISCONNECT,
-                                RELEASE_EVENT_WIFI_AP_CHANGED,
-                                RELEASE_EVENT_WFC_PREFER_MODE_CHANGED,
-                                RELEASE_EVENT_IMS_NOT_SUPPORT_RAT
-                            }),
-                    Map.entry(
-                            RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL,
-                            new int[] {
-                                RELEASE_EVENT_DISCONNECT,
-                                RELEASE_EVENT_WIFI_AP_CHANGED,
-                                RELEASE_EVENT_IMS_NOT_SUPPORT_RAT
-                            })
-            );
-    private static final int[] ignorableRestrictionsOnSingleRat =
-            new int[] {
-                RESTRICT_TYPE_GUARDING,
-                //Ignore throttling restriction at single RAT, let FWK control throttling.
-                RESTRICT_TYPE_THROTTLING,
-                RESTRICT_TYPE_RTP_LOW_QUALITY,
-                RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL,
-                RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL,
-                RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL
-            };
-
-    private QnsCarrierConfigManager mQnsCarrierConfigManager;
-    private QnsTelephonyListener mTelephonyListener;
-    private QnsEventDispatcher mQnsEventDispatcher;
-    @VisibleForTesting Handler mHandler;
-
-    @QnsConstants.CellularCoverage
-    int mCellularCoverage; // QnsConstants.COVERAGE_HOME or QnsConstants.COVERAGE_ROAM
-
-    int mCellularAccessNetwork;
-
-    @VisibleForTesting QnsRegistrant mRestrictInfoRegistrant;
-    private DataConnectionStatusTracker mDataConnectionStatusTracker;
-    private CellularNetworkStatusTracker mCellularNetworkStatusTracker;
-    private QnsCallStatusTracker mQnsCallStatusTracker;
-    private QnsCallStatusTracker.ActiveCallTracker mActiveCallTracker;
-    private QnsImsManager mQnsImsManager;
-    private QnsTimer mQnsTimer;
-    private WifiBackhaulMonitor mWifiBackhaulMonitor;
-    private QnsMetrics mQnsMetrics;
-    private int mNetCapability;
-    private int mSlotId;
-    private int mTransportType = AccessNetworkConstants.TRANSPORT_TYPE_INVALID;
-    private int mLastEvaluatedTransportType = AccessNetworkConstants.TRANSPORT_TYPE_INVALID;
-    private int mWfcPreference;
-    private int mWfcRoamingPreference;
-    private int mCounterForIwlanRestrictionInCall;
-    private int mRetryCounterOnDataConnectionFail;
-    private int mFallbackCounterOnDataConnectionFail;
-    private boolean mIsRttStatusCheckRegistered = false;
-    private int mLastDataConnectionTransportType;
-    private int mFallbackTimerId = -1;
-    private boolean mIsTimerRunningOnDataConnectionFail = false;
-    private Pair<Integer, Long> mDeferredThrottlingEvent = null;
-
-    /** IMS call type */
-    @QnsConstants.QnsCallType private int mImsCallType;
-    /** Call state from TelephonyCallback.CallStateListener */
-    @Annotation.CallState private int mCallState;
-
-    private Map<Integer, RestrictInfo> mRestrictInfos = new ConcurrentHashMap<>();
-    private Map<Restriction, Integer> mRestrictionTimers = new ConcurrentHashMap<>();
-
-    private class RestrictManagerHandler extends Handler {
-        RestrictManagerHandler(Looper l) {
-            super(l);
-        }
-
-        @Override
-        public void handleMessage(Message message) {
-            QnsAsyncResult ar;
-            int transportType;
-            Log.d(mLogTag, "handleMessage : " + message.what);
-            switch (message.what) {
-                case EVENT_DATA_CONNECTION_CHANGED:
-                    ar = (QnsAsyncResult) message.obj;
-                    onDataConnectionChanged((DataConnectionChangedInfo) ar.mResult);
-                    break;
-
-                case EVENT_CALL_STATE_CHANGED:
-                    ar = (QnsAsyncResult) message.obj;
-                    int callState = (int) ar.mResult;
-                    onCallStateChanged(callState, mTransportType, mCellularAccessNetwork);
-                    break;
-
-                case EVENT_SRVCC_STATE_CHANGED:
-                    ar = (QnsAsyncResult) message.obj;
-                    int srvccState = (int) ar.mResult;
-                    onSrvccStateChanged(srvccState);
-                    break;
-
-                case EVENT_LOW_RTP_QUALITY_REPORTED:
-                    ar = (QnsAsyncResult) message.obj;
-                    int reason = (int) ar.mResult;
-                    Log.d(mLogTag, "EVENT_LOW_RTP_QUALITY_REPORTED reason: " + reason);
-                    onLowRtpQualityEvent(reason);
-                    break;
-
-                case EVENT_IMS_REGISTRATION_STATE_CHANGED:
-                    ar = (QnsAsyncResult) message.obj;
-                    onImsRegistrationStateChanged((QnsImsManager.ImsRegistrationState) ar.mResult);
-                    break;
-
-                case EVENT_RELEASE_RESTRICTION:
-                    transportType = message.arg1;
-                    Restriction restriction = (Restriction) message.obj;
-                    Log.d(
-                            mLogTag,
-                            "EVENT_RELEASE_RESTRICTION : "
-                                    + QnsConstants.transportTypeToString(transportType)
-                                    + " "
-                                    + restrictTypeToString(restriction.mRestrictType));
-                    if (restriction
-                            == mRestrictInfos
-                                    .get(transportType)
-                                    .getRestrictionMap()
-                                    .get(restriction.mRestrictType)) {
-                        releaseRestriction(transportType, restriction.mRestrictType);
-                        mQnsTimer.unregisterTimer(mRestrictionTimers
-                                .getOrDefault(restriction, INVALID_ID));
-                        mRestrictionTimers.remove(restriction);
-                    }
-                    break;
-
-                case EVENT_INITIAL_DATA_CONNECTION_FAIL_RETRY_TIMER_EXPIRED:
-                    Log.d(
-                            mLogTag,
-                            "Initial Data Connection fail timer expired"
-                                    + mIsTimerRunningOnDataConnectionFail);
-
-                    mQnsTimer.unregisterTimer(mFallbackTimerId);
-                    if (mIsTimerRunningOnDataConnectionFail) {
-                        int currTransportType = message.arg1;
-                        fallbackToOtherTransportOnDataConnectionFail(currTransportType);
-                    }
-                    break;
-
-                case EVENT_WIFI_RTT_BACKHAUL_CHECK_STATUS:
-                    ar = (QnsAsyncResult) message.obj;
-                    boolean rttCheckStatus = (boolean) ar.mResult;
-                    if (!rttCheckStatus) { // rtt Backhaul check failed
-                        Log.d(mLogTag, "Rtt check status received:Fail");
-                        onWlanRttFail();
-                    }
-                    break;
-
-                case QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_ONLY:
-                    onWfcModeChanged(QnsConstants.WIFI_ONLY, QnsConstants.COVERAGE_HOME);
-                    break;
-                case QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_CELLULAR_PREFERRED:
-                    onWfcModeChanged(QnsConstants.CELL_PREF, QnsConstants.COVERAGE_HOME);
-                    break;
-
-                case QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_PREFERRED:
-                    onWfcModeChanged(QnsConstants.WIFI_PREF, QnsConstants.COVERAGE_HOME);
-                    break;
-
-                case QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_ONLY:
-                    onWfcModeChanged(QnsConstants.WIFI_ONLY, QnsConstants.COVERAGE_ROAM);
-                    break;
-
-                case QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_MODE_TO_CELLULAR_PREFERRED:
-                    onWfcModeChanged(QnsConstants.CELL_PREF, QnsConstants.COVERAGE_ROAM);
-                    break;
-
-                case QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_PREFERRED:
-                    onWfcModeChanged(QnsConstants.WIFI_PREF, QnsConstants.COVERAGE_ROAM);
-                    break;
-
-                case QnsEventDispatcher.QNS_EVENT_APM_ENABLED:
-                case QnsEventDispatcher.QNS_EVENT_WFC_DISABLED:
-                case QnsEventDispatcher.QNS_EVENT_WIFI_DISABLING:
-                    if (mFallbackCounterOnDataConnectionFail > 0) {
-                        Log.d(mLogTag, "Reset Fallback Counter on APM On/WFC off/Wifi Off");
-                        mFallbackCounterOnDataConnectionFail = 0;
-                    }
-
-                    if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS
-                            && hasRestrictionType(
-                                    AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                                    RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL)) {
-
-                        releaseRestriction(
-                                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                                RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL);
-                    }
-                    break;
-                default:
-                    break;
-            }
-        }
-    }
-
-    class LowRtpQualityRestriction extends Restriction{
-        private int mReason;
-        LowRtpQualityRestriction(int type, int[] releaseEvents, long restrictTime, int reason) {
-            super(type, releaseEvents, restrictTime);
-            mReason = reason;
-        }
-        int getReason() {
-            return mReason;
-        }
-    }
-
-    class Restriction {
-        private final int mRestrictType;
-        final ArrayList<Integer> mReleaseEventList;
-        long mReleaseTime;
-
-        Restriction(int type, int[] releaseEvents, long restrictTime) {
-            mRestrictType = type;
-            if (restrictTime == 0) {
-                mReleaseTime = 0;
-            } else {
-                mReleaseTime = restrictTime + SystemClock.elapsedRealtime();
-                if (restrictTime > 0 && mReleaseTime < 0) {
-                    mReleaseTime = Long.MAX_VALUE;
-                }
-            }
-            if (releaseEvents != null && releaseEvents.length > 0) {
-                mReleaseEventList = new ArrayList<>();
-                for (int i : releaseEvents) {
-                    mReleaseEventList.add(i);
-                }
-            } else {
-                mReleaseEventList = null;
-            }
-        }
-
-        boolean needRelease(int event) {
-            if (mReleaseEventList == null) {
-                return false;
-            }
-            for (Integer i : mReleaseEventList) {
-                if (event == i.intValue()) {
-                    return true;
-                }
-            }
-            return false;
-        }
-
-        void updateRestrictTime(long timeMillis) {
-            mReleaseTime = SystemClock.elapsedRealtime() + timeMillis;
-            if (timeMillis > 0 && mReleaseTime < 0) {
-                mReleaseTime = Long.MAX_VALUE;
-            }
-        }
-
-        boolean isRestrictionExpired(long elapsedRealTime) {
-            if (mReleaseTime != 0 && (mReleaseTime - elapsedRealTime < 0)) {
-                Log.d(mLogTag, restrictTypeToString(mRestrictType) + " was expired."
-                        + "release time:" + mReleaseTime + ", now:" + elapsedRealTime);
-                return true;
-            }
-            return false;
-        }
-
-        @Override
-        public String toString() {
-            StringBuilder builder = new StringBuilder();
-            builder.append("[RESTRICTION type:").append(restrictTypeToString(mRestrictType));
-            builder.append(" releaseEvents:( ");
-            if (mReleaseEventList != null) {
-                for (Integer i : mReleaseEventList) {
-                    builder.append(i).append(" ");
-                }
-            }
-            builder.append(") remainedTimeMillis:");
-            if (mReleaseTime == 0) {
-                builder.append("N/A");
-            } else {
-                long remain = mReleaseTime - SystemClock.elapsedRealtime();
-                builder.append(remain);
-            }
-            builder.append("]");
-            return builder.toString();
-        }
-    }
-
-    class RestrictInfo {
-        private int mTransportMode; // AccessNetworkConstants.TRANSPORT_TYPE_WWAN;
-        private Map<Integer, Restriction> mRestrictionMap = new ConcurrentHashMap<>();
-
-        RestrictInfo(int transportMode) {
-            mTransportMode = transportMode;
-        }
-
-        Map<Integer, Restriction> getRestrictionMap() {
-            return mRestrictionMap;
-        }
-
-        boolean isRestricted() {
-            checkUpExpirationTime();
-            return mRestrictionMap.size() != 0;
-        }
-
-        private void checkUpExpirationTime() {
-            if (mRestrictionMap.size() > 0) {
-                long now = QnsUtils.getSystemElapsedRealTime();
-                mRestrictionMap.entrySet().removeIf(e -> e.getValue().isRestrictionExpired(now));
-            }
-        }
-
-        /**
-         * This method returns if the restriction info has given restriction type.
-         *
-         * @param restrictType integer value of restriction type.
-         * @return true if restrictinfo has the restriction; otherwise false.
-         */
-        boolean hasRestrictionType(@RestrictType int restrictType) {
-            return mRestrictionMap.get(restrictType) != null;
-        }
-
-        @Override
-        public String toString() {
-            StringBuilder builder = new StringBuilder();
-            builder.append("RestrictInfo[")
-                    .append(QnsConstants.transportTypeToString(mTransportMode))
-                    .append("] : ");
-            if (isRestricted()) {
-                for (Restriction restriction : mRestrictionMap.values()) {
-                    builder.append(restriction.toString()).append(" ");
-                }
-            } else {
-                builder.append("No restriction");
-            }
-            return builder.toString();
-        }
-    }
-
-    RestrictManager(
-            QnsComponents qnsComponents,
-            Looper loop,
-            int netCapability,
-            DataConnectionStatusTracker dcst,
-            int slotId) {
-        mRestrictInfos.put(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                new RestrictInfo(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-        mRestrictInfos.put(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                new RestrictInfo(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        mSlotId = slotId;
-        mLogTag =
-                RestrictManager.class.getSimpleName()
-                        + "_"
-                        + mSlotId
-                        + "_"
-                        + QnsUtils.getNameOfNetCapability(netCapability);
-        mTelephonyListener = qnsComponents.getQnsTelephonyListener(mSlotId);
-        mQnsEventDispatcher = qnsComponents.getQnsEventDispatcher(mSlotId);
-        mQnsCarrierConfigManager = qnsComponents.getQnsCarrierConfigManager(mSlotId);
-        mQnsTimer = qnsComponents.getQnsTimer();
-        mHandler = new RestrictManagerHandler(loop);
-        mNetCapability = netCapability;
-        mDataConnectionStatusTracker = dcst;
-        mQnsCallStatusTracker = qnsComponents.getQnsCallStatusTracker(mSlotId);
-        mActiveCallTracker = qnsComponents.getQnsCallStatusTracker(mSlotId).getActiveCallTracker();
-        mQnsMetrics = qnsComponents.getQnsMetrics();
-        mDataConnectionStatusTracker.registerDataConnectionStatusChanged(
-                mHandler, EVENT_DATA_CONNECTION_CHANGED);
-        if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS) {
-            mTelephonyListener.registerCallStateListener(
-                    mHandler, EVENT_CALL_STATE_CHANGED, null, true);
-            mTelephonyListener.registerSrvccStateListener(
-                    mHandler, EVENT_SRVCC_STATE_CHANGED, null);
-        }
-        if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS) {
-            mQnsImsManager = qnsComponents.getQnsImsManager(mSlotId);
-            mQnsImsManager.registerImsRegistrationStatusChanged(
-                    mHandler, EVENT_IMS_REGISTRATION_STATE_CHANGED);
-            mWifiBackhaulMonitor = qnsComponents.getWifiBackhaulMonitor(mSlotId);
-        }
-
-        // check if we can pass "mQnsImsManager"
-        mWfcPreference = QnsUtils.getWfcMode(qnsComponents.getQnsImsManager(mSlotId), false);
-        mWfcRoamingPreference = QnsUtils.getWfcMode(qnsComponents.getQnsImsManager(mSlotId), true);
-
-        List<Integer> events = new ArrayList<>();
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_ONLY);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_CELLULAR_PREFERRED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_PREFERRED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_ONLY);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_MODE_TO_CELLULAR_PREFERRED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_PREFERRED);
-        events.add(QnsEventDispatcher.QNS_EVENT_APM_ENABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_DISABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WIFI_DISABLING);
-        mQnsEventDispatcher.registerEvent(events, mHandler);
-
-        mCellularNetworkStatusTracker = qnsComponents.getCellularNetworkStatusTracker(mSlotId);
-        restrictNonPreferredTransport();
-    }
-
-    void clearRestrictions() {
-        mRestrictInfos.get(AccessNetworkConstants.TRANSPORT_TYPE_WWAN).getRestrictionMap().clear();
-        mRestrictInfos.get(AccessNetworkConstants.TRANSPORT_TYPE_WLAN).getRestrictionMap().clear();
-    }
-
-    void close() {
-        mDataConnectionStatusTracker.unRegisterDataConnectionStatusChanged(mHandler);
-        if (mIsRttStatusCheckRegistered
-                && mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS) {
-            mIsRttStatusCheckRegistered = false;
-            mWifiBackhaulMonitor.unRegisterForRttStatusChange(mHandler);
-        }
-
-        if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS) {
-            mTelephonyListener.unregisterCallStateChanged(mHandler);
-            mTelephonyListener.unregisterSrvccStateChanged(mHandler);
-        }
-        mQnsEventDispatcher.unregisterEvent(mHandler);
-        if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS
-                || mNetCapability == NetworkCapabilities.NET_CAPABILITY_EIMS) {
-            if (mActiveCallTracker != null) {
-                mActiveCallTracker.unregisterLowMediaQualityListener(mHandler);
-            }
-        }
-        if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS) {
-            mQnsImsManager.unregisterImsRegistrationStatusChanged(mHandler);
-        }
-        mRestrictionTimers.clear();
-    }
-
-    private void onWfcModeChanged(int prefMode, @QnsConstants.CellularCoverage int coverage) {
-        Log.d(mLogTag, "onWfcModeChanged  prefMode :" + prefMode + "  coverage:" + coverage);
-        if (coverage == QnsConstants.COVERAGE_HOME) {
-            mWfcPreference = prefMode;
-        } else if (coverage == QnsConstants.COVERAGE_ROAM) {
-            mWfcRoamingPreference = prefMode;
-        }
-        if (mCellularCoverage == coverage) {
-            if (prefMode == QnsConstants.CELL_PREF) {
-                processReleaseEvent(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RELEASE_EVENT_WFC_PREFER_MODE_CHANGED);
-            }
-            if (prefMode == QnsConstants.WIFI_PREF || prefMode == QnsConstants.WIFI_ONLY) {
-                processReleaseEvent(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RELEASE_EVENT_WFC_PREFER_MODE_CHANGED);
-            }
-        }
-        checkIfCancelNonPreferredRestriction(getPreferredTransportType());
-    }
-
-    @VisibleForTesting
-    void restrictNonPreferredTransport() {
-        if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS
-                && !mCellularNetworkStatusTracker.isAirplaneModeEnabled()) {
-            Log.d(mLogTag, "Restrict non-preferred transport at power up");
-            int transportType = getPreferredTransportType();
-            int waitingTimer =
-                    mQnsCarrierConfigManager.getWaitingTimerForPreferredTransportOnPowerOn(
-                            transportType);
-            if (waitingTimer != QnsConstants.KEY_DEFAULT_VALUE) {
-                int preventTransportType = QnsUtils.getOtherTransportType(transportType);
-                Log.d(
-                        mLogTag,
-                        "prevent "
-                                + QnsConstants.transportTypeToString(preventTransportType)
-                                + " "
-                                + waitingTimer
-                                + " milli seconds");
-                addRestriction(
-                        preventTransportType,
-                        RESTRICT_TYPE_NON_PREFERRED_TRANSPORT,
-                        sReleaseEventMap.get(RESTRICT_TYPE_NON_PREFERRED_TRANSPORT),
-                        waitingTimer);
-            }
-        }
-    }
-
-    private void checkIfCancelNonPreferredRestriction(int transportType) {
-        if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS) {
-            releaseRestriction(transportType, RESTRICT_TYPE_NON_PREFERRED_TRANSPORT);
-        }
-    }
-
-    private int getPreferredTransportType() {
-        int transportType;
-        int preference = mWfcPreference;
-        if (mCellularCoverage == QnsConstants.COVERAGE_ROAM) {
-            preference = mWfcRoamingPreference;
-        }
-        if (preference == QnsConstants.WIFI_PREF || preference == QnsConstants.WIFI_ONLY) {
-            transportType = AccessNetworkConstants.TRANSPORT_TYPE_WLAN;
-        } else {
-            transportType = AccessNetworkConstants.TRANSPORT_TYPE_WWAN;
-        }
-        return transportType;
-    }
-
-    private void onCallStateChanged(int callState, int transportType, int cellularAn) {
-        Log.d(
-                mLogTag,
-                "onCallStateChanged :"
-                        + callState
-                        + " transport:"
-                        + transportType
-                        + " cellularAN:"
-                        + cellularAn);
-        mCallState = callState;
-        if (callState != TelephonyManager.CALL_STATE_IDLE) {
-            if (transportType != AccessNetworkConstants.TRANSPORT_TYPE_WLAN
-                    && cellularAn != AccessNetworkConstants.AccessNetworkType.EUTRAN
-                    && cellularAn != AccessNetworkConstants.AccessNetworkType.NGRAN) {
-                onCsCallStarted();
-            }
-        } else {
-            releaseRestriction(
-                    AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                    RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL);
-        }
-    }
-
-    private void onSrvccStateChanged(int srvccState) {
-        Log.d(mLogTag, "onSrvccStateChanged :" + srvccState);
-        if (mImsCallType != QnsConstants.CALL_TYPE_IDLE
-                && srvccState == TelephonyManager.SRVCC_STATE_HANDOVER_STARTED) {
-            addRestriction(
-                    AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                    RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL,
-                    sReleaseEventMap.get(RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL),
-                    0);
-        } else if (mCallState == TelephonyManager.CALL_STATE_IDLE
-                || srvccState == TelephonyManager.SRVCC_STATE_HANDOVER_CANCELED
-                || srvccState == TelephonyManager.SRVCC_STATE_HANDOVER_FAILED) {
-            releaseRestriction(
-                    AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                    RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL);
-        }
-    }
-
-    private void onCsCallStarted() {
-        if (!mQnsCarrierConfigManager.allowImsOverIwlanCellularLimitedCase()) {
-            addRestriction(
-                    AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                    RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL,
-                    sReleaseEventMap.get(RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL),
-                    0);
-        }
-    }
-
-    @VisibleForTesting
-    void onLowRtpQualityEvent(@QnsConstants.RtpLowQualityReason int reason) {
-        int lowRtpQualityRestrictTime =
-                mQnsCarrierConfigManager.getHoRestrictedTimeOnLowRTPQuality(mTransportType);
-        if ((mTransportType == AccessNetworkConstants.TRANSPORT_TYPE_WLAN
-                        || mTransportType == AccessNetworkConstants.TRANSPORT_TYPE_WWAN)
-                && lowRtpQualityRestrictTime > 0
-                && (mImsCallType == QnsConstants.CALL_TYPE_VOICE
-                    || mImsCallType == QnsConstants.CALL_TYPE_EMERGENCY)) {
-            if (reason > 0) {
-                Restriction restriction =
-                        new LowRtpQualityRestriction(RESTRICT_TYPE_RTP_LOW_QUALITY,
-                                sReleaseEventMap.get(RESTRICT_TYPE_RTP_LOW_QUALITY),
-                                lowRtpQualityRestrictTime,
-                                reason);
-                // If current report has 'no RTP reason' and previous report at previous
-                // transport type doesn't have 'no RTP reason', let's move back to previous
-                // transport type.
-                if ((reason & 1 << QnsConstants.RTP_LOW_QUALITY_REASON_NO_RTP) != 0) {
-                    releaseRestriction(QnsUtils.getOtherTransportType(mTransportType),
-                            RESTRICT_TYPE_GUARDING, true);
-                    Map<Integer, Restriction> restrictionMap = mRestrictInfos
-                            .get(QnsUtils.getOtherTransportType(mTransportType))
-                            .getRestrictionMap();
-                    Restriction restrictionOtherSide = restrictionMap.get(
-                            RESTRICT_TYPE_RTP_LOW_QUALITY);
-                    if (restrictionOtherSide != null
-                            && restrictionOtherSide instanceof LowRtpQualityRestriction) {
-                        int reasonOtherSide =
-                                ((LowRtpQualityRestriction) restrictionOtherSide).getReason();
-                        if ((reasonOtherSide & 1 << QnsConstants.RTP_LOW_QUALITY_REASON_NO_RTP)
-                                == 0) {
-                            releaseRestriction(QnsUtils.getOtherTransportType(mTransportType),
-                                    RESTRICT_TYPE_RTP_LOW_QUALITY, true);
-                        }
-                    }
-                }
-                // If both transport have low RTP quality restriction, let ANE do final decision.
-                addRestriction(mTransportType, restriction, lowRtpQualityRestrictTime);
-
-                if (mTransportType == AccessNetworkConstants.TRANSPORT_TYPE_WLAN) {
-                    int fallbackReason = mQnsCarrierConfigManager.getQnsIwlanHoRestrictReason();
-                    if (fallbackReason == QnsConstants.FALLBACK_REASON_RTP_OR_WIFI
-                            || fallbackReason == QnsConstants.FALLBACK_REASON_RTP_ONLY) {
-                        increaseCounterToRestrictIwlanInCall();
-                    }
-                }
-            } else {
-                if (hasRestrictionType(mTransportType, RESTRICT_TYPE_RTP_LOW_QUALITY)) {
-                    releaseRestriction(mTransportType, RESTRICT_TYPE_RTP_LOW_QUALITY);
-                }
-            }
-        }
-    }
-
-    @VisibleForTesting
-    void onDataConnectionChanged(DataConnectionChangedInfo status) {
-        int dataConnectionState = status.getState();
-        if (dataConnectionState == STATE_CONNECTED || dataConnectionState == STATE_HANDOVER) {
-            mTransportType = status.getTransportType();
-        } else {
-            mTransportType = AccessNetworkConstants.TRANSPORT_TYPE_INVALID;
-        }
-
-        Log.d(mLogTag, "onDataConnectionChanged transportType:" + status);
-        switch (status.getEvent()) {
-            case DataConnectionStatusTracker.EVENT_DATA_CONNECTION_DISCONNECTED:
-                processDataConnectionDisconnected();
-                break;
-            case DataConnectionStatusTracker.EVENT_DATA_CONNECTION_STARTED:
-                processDataConnectionStarted(status.getTransportType());
-                break;
-            case DataConnectionStatusTracker.EVENT_DATA_CONNECTION_CONNECTED:
-                processDataConnectionConnected(mTransportType);
-                break;
-            case DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_STARTED:
-                processDataConnectionHandoverStarted();
-                break;
-            case DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_SUCCESS:
-                processDataConnectionHandoverSuccess();
-                break;
-            case DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_FAILED:
-                processDataConnectionHandoverFailed(mTransportType);
-                break;
-            case DataConnectionStatusTracker.EVENT_DATA_CONNECTION_FAILED:
-                processDataConnectionFailed(status.getTransportType());
-                break;
-            default:
-                Log.d(mLogTag, "unknown DataConnectionChangedEvent:");
-                break;
-        }
-    }
-
-    private void processDataConnectionConnected(int transportType) {
-        // Since HO hysterisis Guard timer is expected
-        checkToCancelInitialPdnConnectionFailFallback();
-        clearInitialPdnConnectionFailFallbackRestriction();
-
-        checkIfCancelNonPreferredRestriction(QnsUtils.getOtherTransportType(transportType));
-        releaseRestriction(transportType, RESTRICT_TYPE_THROTTLING, true);
-        if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS) {
-            if (mLastEvaluatedTransportType == AccessNetworkConstants.TRANSPORT_TYPE_INVALID
-                    || transportType == mLastEvaluatedTransportType) {
-                processHandoverGuardingOperation(transportType);
-            } else {
-                Log.d(
-                        mLogTag,
-                        "DataConnectionConnected, but transport type is different,"
-                                + " Handover init may follow");
-            }
-        }
-    }
-
-    private void clearInitialPdnConnectionFailFallbackRestriction() {
-        mFallbackCounterOnDataConnectionFail = 0;
-        if (hasRestrictionType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL)) {
-            releaseRestriction(
-                    AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                    RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-        }
-        if (hasRestrictionType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL)) {
-            releaseRestriction(
-                    AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                    RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-        }
-    }
-
-    private void checkToCancelInitialPdnConnectionFailFallback() {
-        Log.d(mLogTag, "clear Initial PDN Connection fail Timer checks");
-
-        mIsTimerRunningOnDataConnectionFail = false;
-        mRetryCounterOnDataConnectionFail = 0;
-
-        mQnsTimer.unregisterTimer(mFallbackTimerId);
-    }
-
-    private void processDataConnectionDisconnected() {
-        processReleaseEvent(AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RELEASE_EVENT_DISCONNECT);
-        processReleaseEvent(AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RELEASE_EVENT_DISCONNECT);
-        mCounterForIwlanRestrictionInCall = 0;
-        if (mDeferredThrottlingEvent != null) {
-            long delayMillis =
-                    mDeferredThrottlingEvent.second - QnsUtils.getSystemElapsedRealTime();
-            if (delayMillis > 0) {
-                if (mDebugFlag) Log.d(mLogTag, "onDisconnected, process deferred Throttling event");
-                addRestriction(
-                        mDeferredThrottlingEvent.first,
-                        RESTRICT_TYPE_THROTTLING,
-                        sReleaseEventMap.get(RESTRICT_TYPE_THROTTLING),
-                        delayMillis);
-            }
-            mDeferredThrottlingEvent = null;
-        }
-    }
-
-    private void processDataConnectionStarted(int currTransportType) {
-        if (mLastDataConnectionTransportType != currTransportType) {
-            Log.d(
-                    mLogTag,
-                    "clear Initial PDN Connection fallback checks for last transport type:"
-                            + mLastDataConnectionTransportType);
-            checkToCancelInitialPdnConnectionFailFallback();
-
-            if (hasRestrictionType(
-                    mLastDataConnectionTransportType,
-                    RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL)) {
-                Log.d(
-                        mLogTag,
-                        "PreIncrement_Fallback Counter : " + mFallbackCounterOnDataConnectionFail);
-                mFallbackCounterOnDataConnectionFail += 1;
-            }
-            mLastDataConnectionTransportType = currTransportType;
-        }
-    }
-
-    private void processDataConnectionHandoverStarted() {
-        if ((mTransportType != AccessNetworkConstants.TRANSPORT_TYPE_INVALID)
-                && !hasRestrictionType(mTransportType, RestrictManager.RESTRICT_TYPE_GUARDING)) {
-            startGuarding(GUARDING_TIMER_HANDOVER_INIT, mTransportType);
-        }
-    }
-
-    private void processDataConnectionHandoverSuccess() {
-        // Handover Guarding Timer operation
-        processHandoverGuardingOperation(mTransportType);
-
-        // update LowRtpQualityListener
-        if (mTransportType == AccessNetworkConstants.TRANSPORT_TYPE_WLAN
-                || mTransportType == AccessNetworkConstants.TRANSPORT_TYPE_WWAN) {
-            // Return to the transport type restricted by low RTP. It may be singleRAT case, release
-            // the restriction.
-            releaseRestriction(mTransportType, RESTRICT_TYPE_RTP_LOW_QUALITY);
-        }
-    }
-
-    private void processDataConnectionHandoverFailed(int transportType) {
-        cancelGuarding(transportType);
-    }
-
-    private void processHandoverGuardingOperation(int transportType) {
-        int guardingTransport = QnsUtils.getOtherTransportType(transportType);
-        int delayMillis = getGuardingTimeMillis(guardingTransport, mImsCallType);
-        int minimumGuardingTimer = mQnsCarrierConfigManager.getMinimumHandoverGuardingTimer();
-        if (delayMillis == 0 && minimumGuardingTimer > 0) {
-            delayMillis = minimumGuardingTimer;
-        }
-
-        if (delayMillis > 0) {
-            startGuarding(delayMillis, guardingTransport);
-        } else {
-            cancelGuarding(guardingTransport);
-        }
-    }
-
-    private void processDataConnectionFailed(int dataConnectionTransportType) {
-        if (mCellularNetworkStatusTracker != null
-                && !mCellularNetworkStatusTracker.isAirplaneModeEnabled()) {
-            Log.d(mLogTag, "Initiate data connection fail Fallback support check");
-            checkFallbackOnDataConnectionFail(dataConnectionTransportType);
-        } else {
-            checkToCancelInitialPdnConnectionFailFallback();
-        }
-    }
-
-    private void checkFallbackOnDataConnectionFail(int transportType) {
-        int[] fallbackConfigOnInitDataFail =
-                mQnsCarrierConfigManager.getInitialDataConnectionFallbackConfig(mNetCapability);
-
-        Log.d(
-                mLogTag,
-                "FallbackConfig set is :"
-                        + fallbackConfigOnInitDataFail[0]
-                        + ":"
-                        + fallbackConfigOnInitDataFail[1]
-                        + ":"
-                        + fallbackConfigOnInitDataFail[2]);
-
-        if ((fallbackConfigOnInitDataFail != null && fallbackConfigOnInitDataFail[0] == 1)
-                && !hasRestrictionType(
-                        transportType, RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL)
-                && (fallbackConfigOnInitDataFail[3] == 0
-                        || mFallbackCounterOnDataConnectionFail
-                                < fallbackConfigOnInitDataFail[3])) {
-            Log.d(
-                    mLogTag,
-                    "FallbackCount: "
-                            + fallbackConfigOnInitDataFail[3]
-                            + "_"
-                            + mFallbackCounterOnDataConnectionFail);
-            enableFallbackRetryCountCheckOnInitialPdnFail(
-                    transportType, fallbackConfigOnInitDataFail[1]);
-            enableFallbackRetryTimerCheckOnInitialPdnFail(
-                    transportType, fallbackConfigOnInitDataFail[2]);
-        }
-    }
-
-    private void enableFallbackRetryTimerCheckOnInitialPdnFail(
-            int transportType, int fallbackRetryTimer) {
-        Log.d(
-                mLogTag,
-                "Start Initial Data Connection fail retry_timer On TransportType"
-                        + fallbackRetryTimer
-                        + "_"
-                        + QnsConstants.transportTypeToString(transportType));
-        if (fallbackRetryTimer > 0 && !mIsTimerRunningOnDataConnectionFail) {
-            Message msg =
-                    mHandler.obtainMessage(
-                            EVENT_INITIAL_DATA_CONNECTION_FAIL_RETRY_TIMER_EXPIRED,
-                            transportType,
-                            0,
-                            null);
-            mFallbackTimerId = mQnsTimer.registerTimer(msg, fallbackRetryTimer);
-            mIsTimerRunningOnDataConnectionFail = true;
-        }
-    }
-
-    private void enableFallbackRetryCountCheckOnInitialPdnFail(
-            int transportType, int fallbackRetryCount) {
-        Log.d(
-                mLogTag,
-                "Start Initial Data Connection fail retry_count On TransportType"
-                        + fallbackRetryCount
-                        + "_"
-                        + mRetryCounterOnDataConnectionFail
-                        + "_"
-                        + QnsConstants.transportTypeToString(transportType));
-        if (fallbackRetryCount > 0) {
-            if (mRetryCounterOnDataConnectionFail == fallbackRetryCount) {
-                fallbackToOtherTransportOnDataConnectionFail(transportType);
-            } else {
-                mRetryCounterOnDataConnectionFail += 1;
-            }
-        }
-    }
-
-    private void fallbackToOtherTransportOnDataConnectionFail(int currTransportType) {
-
-        checkToCancelInitialPdnConnectionFailFallback();
-
-        addRestriction(
-                currTransportType,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL,
-                sReleaseEventMap.get(RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL),
-                mQnsCarrierConfigManager.getFallbackGuardTimerOnInitialConnectionFail(
-                        mNetCapability));
-    }
-
-    @VisibleForTesting
-    void onImsRegistrationStateChanged(QnsImsManager.ImsRegistrationState event) {
-        Log.d(
-                mLogTag,
-                "onImsRegistrationStateChanged["
-                        + QnsConstants.transportTypeToString(mTransportType)
-                        + "] transportType["
-                        + QnsConstants.transportTypeToString(event.getTransportType())
-                        + "] RegistrationState["
-                        + QnsConstants.imsRegistrationEventToString(event.getEvent())
-                        + "]");
-        int prefMode =
-                mCellularCoverage == QnsConstants.COVERAGE_HOME
-                        ? mWfcPreference
-                        : mWfcRoamingPreference;
-
-        registerRttStatusCheckEvent();
-
-        switch (event.getEvent()) {
-            case QnsConstants.IMS_REGISTRATION_CHANGED_UNREGISTERED:
-                onImsUnregistered(event, mTransportType, prefMode);
-                break;
-            case QnsConstants.IMS_REGISTRATION_CHANGED_ACCESS_NETWORK_CHANGE_FAILED:
-                onImsHoRegisterFailed(event, mTransportType, prefMode);
-                break;
-            case QnsConstants.IMS_REGISTRATION_CHANGED_REGISTERED:
-                Log.d(
-                        mLogTag,
-                        "On Ims Registered: "
-                                + QnsConstants.transportTypeToString(event.getTransportType()));
-                if (event.getTransportType() == AccessNetworkConstants.TRANSPORT_TYPE_WLAN
-                        && hasRestrictionType(
-                                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                                RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL)) {
-                    releaseRestriction(
-                            AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                            RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL);
-                }
-                break;
-            default:
-                break;
-        }
-    }
-
-    private void registerRttStatusCheckEvent() {
-        if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS) {
-
-            if (mWifiBackhaulMonitor.isRttCheckEnabled()) {
-                if (!mIsRttStatusCheckRegistered) {
-                    mIsRttStatusCheckRegistered = true;
-                    mWifiBackhaulMonitor.registerForRttStatusChange(
-                            mHandler, EVENT_WIFI_RTT_BACKHAUL_CHECK_STATUS);
-                }
-            } else {
-                if (mIsRttStatusCheckRegistered) {
-                    mIsRttStatusCheckRegistered = false;
-                    mWifiBackhaulMonitor.unRegisterForRttStatusChange(mHandler);
-                }
-            }
-        }
-    }
-
-    private void onImsUnregistered(
-            QnsImsManager.ImsRegistrationState event, int transportType, int prefMode) {
-        if (transportType == AccessNetworkConstants.TRANSPORT_TYPE_WLAN) {
-            int fallbackTimeMillis =
-                    mQnsCarrierConfigManager.getFallbackTimeImsUnregistered(
-                            event.getReasonInfo().getCode(), prefMode);
-            if (fallbackTimeMillis > 0
-                    && mQnsCarrierConfigManager.isAccessNetworkAllowed(
-                            mCellularAccessNetwork, NetworkCapabilities.NET_CAPABILITY_IMS)) {
-                fallbackToWwanForImsRegistration(fallbackTimeMillis);
-            }
-        }
-    }
-
-    private void onImsHoRegisterFailed(
-            QnsImsManager.ImsRegistrationState event, int transportType, int prefMode) {
-        if (transportType == AccessNetworkConstants.TRANSPORT_TYPE_WLAN
-                && transportType == event.getTransportType()) {
-            int fallbackTimeMillis =
-                    mQnsCarrierConfigManager.getFallbackTimeImsHoRegisterFailed(
-                            event.getReasonInfo().getCode(), prefMode);
-            if (fallbackTimeMillis > 0
-                    && mQnsCarrierConfigManager.isAccessNetworkAllowed(
-                            mCellularAccessNetwork, NetworkCapabilities.NET_CAPABILITY_IMS)) {
-                fallbackToWwanForImsRegistration(fallbackTimeMillis);
-            }
-        }
-    }
-
-    protected void onWlanRttFail() {
-        Log.d(mLogTag, "start RTT Fallback:");
-        int fallbackTimeMillis = mQnsCarrierConfigManager.getWlanRttFallbackHystTimer();
-        if (fallbackTimeMillis > 0
-                && mQnsCarrierConfigManager.isAccessNetworkAllowed(
-                        mCellularAccessNetwork, NetworkCapabilities.NET_CAPABILITY_IMS)) {
-
-            fallbackToWwanForImsRegistration(
-                    AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                    RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL,
-                    fallbackTimeMillis);
-        }
-    }
-
-    private void fallbackToWwanForImsRegistration(int fallbackTimeMillis) {
-        fallbackToWwanForImsRegistration(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL,
-                fallbackTimeMillis);
-    }
-
-    private void fallbackToWwanForImsRegistration(
-            int transportType, int restrictType, int fallbackTimeMillis) {
-        Log.d(mLogTag, "release ignorable restrictions on WWAN to fallback.");
-        for (int restriction : ignorableRestrictionsOnSingleRat) {
-            releaseRestriction(QnsUtils.getOtherTransportType(transportType), restriction, false);
-        }
-        addRestriction(
-                transportType,
-                restrictType,
-                sReleaseEventMap.get(restrictType),
-                fallbackTimeMillis);
-    }
-
-    /** Update Last notified transport type from ANE which owns this RestrictManager */
-    void updateLastNotifiedTransportType(@AccessNetworkConstants.TransportType int transportType) {
-        if (mDebugFlag) {
-            Log.d(
-                    mLogTag,
-                    "updateLastEvaluatedTransportType: "
-                            + QnsConstants.transportTypeToString(transportType));
-        }
-        mLastEvaluatedTransportType = transportType;
-        if (mDataConnectionStatusTracker.isActiveState() && mTransportType != transportType) {
-            startGuarding(GUARDING_TIMER_HANDOVER_INIT,
-                    QnsUtils.getOtherTransportType(transportType));
-        }
-    }
-
-    @VisibleForTesting
-    void setCellularCoverage(@QnsConstants.CellularCoverage int coverage) {
-        Log.d(mLogTag, "setCellularCoverage:" + QnsConstants.coverageToString(coverage));
-        mCellularCoverage = coverage;
-        checkIfCancelNonPreferredRestriction(getPreferredTransportType());
-    }
-
-    protected void setQnsCallType(@QnsConstants.QnsCallType int callType) {
-        if (callType != mImsCallType) {
-            updateGuardingTimerConditionOnCallState(mImsCallType, callType);
-        }
-
-        mImsCallType = callType;
-
-        Log.d(mLogTag, "setQnsCallType: " + QnsConstants.callTypeToString(callType));
-        if (callType == QnsConstants.CALL_TYPE_IDLE) {
-            Log.d(mLogTag, "Call end. init mCounterForIwlanRestrictionInCall");
-            mCounterForIwlanRestrictionInCall = 0;
-
-            processReleaseEvent(AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RELEASE_EVENT_CALL_END);
-            processReleaseEvent(AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RELEASE_EVENT_CALL_END);
-            unregisterLowRtpQualityEvent();
-        } else {
-            registerLowRtpQualityEvent();
-        }
-    }
-
-    private void updateGuardingTimerConditionOnCallState(int prevCallType, int newCallType) {
-        int currGuardingTransport = QnsUtils.getOtherTransportType(mTransportType);
-        if (mRestrictInfos.get(currGuardingTransport) == null) return;
-
-        Map<Integer, Restriction> restrictionMap =
-                mRestrictInfos.get(currGuardingTransport).getRestrictionMap();
-        Restriction restriction = restrictionMap.get(RESTRICT_TYPE_GUARDING);
-
-        if (restriction != null) {
-            int prevCallTypeMillis = getGuardingTimeMillis(currGuardingTransport, prevCallType);
-            if (prevCallTypeMillis == 0) {
-                return; // We don't need to update minimum guarding timer.
-            }
-            int newCallTypeMillis =
-                    getGuardingTimeMillis(
-                            currGuardingTransport, newCallType); // new Call type timer
-            if (newCallTypeMillis == prevCallTypeMillis) return;
-
-            if (newCallTypeMillis != 0) {
-                // remaining time on current call type
-                long prevCallTypeRemainingMillis =
-                        restriction.mReleaseTime - SystemClock.elapsedRealtime();
-                int guardTimerElapsed = prevCallTypeMillis - (int) prevCallTypeRemainingMillis;
-                int newGuardTimer = newCallTypeMillis - guardTimerElapsed;
-
-                if (mDebugFlag) {
-                    Log.d(
-                            mLogTag,
-                            "Prev Call Type Guarding millis:"
-                                    + prevCallTypeMillis
-                                    + "Prev Call type remaining millis:"
-                                    + prevCallTypeRemainingMillis
-                                    + "New Call type Guarding millis:"
-                                    + newCallTypeMillis
-                                    + "Guard timer Elapsed:"
-                                    + guardTimerElapsed
-                                    + "New Guard timer to set:"
-                                    + newGuardTimer);
-                }
-                if (newGuardTimer > 0) {
-                    startGuarding(newGuardTimer, currGuardingTransport);
-                    return;
-                }
-            }
-            cancelGuarding(currGuardingTransport);
-        }
-    }
-
-    @VisibleForTesting
-    void setCellularAccessNetwork(int accessNetwork) {
-        mCellularAccessNetwork = accessNetwork;
-        Log.d(mLogTag, "Current Cellular Network:" + mCellularAccessNetwork);
-        if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS
-                && !mQnsCarrierConfigManager.isAccessNetworkAllowed(
-                        accessNetwork, mNetCapability)) {
-            processReleaseEvent(
-                    AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RELEASE_EVENT_IMS_NOT_SUPPORT_RAT);
-        }
-    }
-
-    void addRestriction(int transport, Restriction restrictObj, long timeMillis) {
-        boolean needNotify = false;
-        Map<Integer, Restriction> restrictionMap =
-                mRestrictInfos.get(transport).getRestrictionMap();
-        Restriction restriction = restrictionMap.get(restrictObj.mRestrictType);
-        Log.d(
-                mLogTag,
-                "addRestriction["
-                        + QnsConstants.transportTypeToString(transport)
-                        + "] "
-                        + restrictTypeToString(restrictObj.mRestrictType)
-                        + " was restrict:"
-                        + (restriction != null)
-                        + " timeMillis:" + timeMillis);
-        if (restriction == null) {
-            restriction = restrictObj;
-            restrictionMap.put(restrictObj.mRestrictType, restriction);
-            Log.d(
-                    mLogTag,
-                    "addRestriction["
-                            + QnsConstants.transportTypeToString(transport)
-                            + "] "
-                            + restriction);
-            needNotify = true;
-        } else {
-            if (timeMillis > 0) {
-                restriction.updateRestrictTime(timeMillis);
-                removeReleaseRestrictionMessage(restriction);
-            }
-            Log.d(
-                    mLogTag,
-                    "updateRestriction["
-                            + QnsConstants.transportTypeToString(transport)
-                            + "] "
-                            + restriction);
-        }
-        if (timeMillis > 0) {
-            sendReleaseRestrictionMessage(transport, restriction);
-        }
-        if (needNotify) {
-            notifyRestrictInfoChanged();
-        }
-    }
-
-    void addRestriction(int transport, int type, int[] releaseEvents, long timeMillis) {
-        boolean needNotify = false;
-        Map<Integer, Restriction> restrictionMap =
-                mRestrictInfos.get(transport).getRestrictionMap();
-        Restriction restriction = restrictionMap.get(type);
-        Log.d(
-                mLogTag,
-                "addRestriction["
-                        + QnsConstants.transportTypeToString(transport)
-                        + "] "
-                        + restrictTypeToString(type)
-                        + " was restrict:"
-                        + (restriction != null)
-                        + " timeMillis:" + timeMillis);
-        if (restriction == null) {
-            restriction = new Restriction(type, releaseEvents, timeMillis);
-            restrictionMap.put(type, restriction);
-            Log.d(
-                    mLogTag,
-                    "addRestriction["
-                            + QnsConstants.transportTypeToString(transport)
-                            + "] "
-                            + restriction);
-            needNotify = true;
-        } else {
-            if (timeMillis > 0) {
-                restriction.updateRestrictTime(timeMillis);
-                removeReleaseRestrictionMessage(restriction);
-            }
-            Log.d(
-                    mLogTag,
-                    "updateRestriction["
-                            + QnsConstants.transportTypeToString(transport)
-                            + "] "
-                            + restriction);
-        }
-        if (timeMillis > 0) {
-            sendReleaseRestrictionMessage(transport, restriction);
-        }
-        if (needNotify) {
-            notifyRestrictInfoChanged();
-        }
-    }
-
-    void releaseRestriction(int transport, int type) {
-        releaseRestriction(transport, type, false);
-    }
-
-    void releaseRestriction(int transport, int type, boolean skipNotify) {
-        boolean needNotify = false;
-        Map<Integer, Restriction> restrictionMap =
-                mRestrictInfos.get(transport).getRestrictionMap();
-        Restriction restriction = restrictionMap.get(type);
-        Log.d(
-                mLogTag,
-                "releaseRestriction["
-                        + QnsConstants.transportTypeToString(transport)
-                        + "] "
-                        + restrictTypeToString(type)
-                        + " was restrict:"
-                        + (restriction != null));
-        if (restriction == null) {
-            Log.d(mLogTag, "no restriction to release " + restrictTypeToString(type) + " " + type);
-        } else {
-            if (restriction.mReleaseTime > 0) {
-                removeReleaseRestrictionMessage(restriction);
-            }
-            restrictionMap.remove(restriction.mRestrictType);
-            mRestrictionTimers.remove(restriction);
-            needNotify = true;
-        }
-        if (needNotify && !skipNotify) {
-            notifyRestrictInfoChanged();
-        }
-    }
-
-    void processReleaseEvent(int transportType, int event) {
-        ArrayList<Integer> releaseList = new ArrayList<>();
-        Map<Integer, Restriction> restrictMap =
-                mRestrictInfos.get(transportType).getRestrictionMap();
-        Log.d(
-                mLogTag,
-                "processReleaseEvent["
-                        + QnsConstants.transportTypeToString(transportType)
-                        + "] "
-                        + event);
-
-        for (Integer restrictType : restrictMap.keySet()) {
-            if (restrictMap.get(restrictType).needRelease(event)) {
-                releaseList.add(restrictType);
-            }
-        }
-        for (Integer restrictType : releaseList) {
-            releaseRestriction(transportType, restrictType);
-        }
-    }
-
-    private void sendReleaseRestrictionMessage(int transportType, Restriction restriction) {
-        if (restriction == null) {
-            Log.e(mLogTag, "sendReleaseRestrictionMessage restriction is null");
-            return;
-        }
-        Message msg =
-                mHandler.obtainMessage(EVENT_RELEASE_RESTRICTION, transportType, 0, restriction);
-        long delayInMillis = restriction.mReleaseTime - SystemClock.elapsedRealtime();
-        int timerId = mQnsTimer.registerTimer(msg, delayInMillis);
-        mRestrictionTimers.put(restriction, timerId);
-        Log.d(
-                mLogTag,
-                restrictTypeToString(restriction.mRestrictType)
-                        + " will be released after "
-                        + delayInMillis
-                        + " millisecs");
-    }
-
-    private void removeReleaseRestrictionMessage(Restriction restriction) {
-        if (restriction == null) {
-            Log.e(mLogTag, "removeReleaseRestrictionMessage restriction is null");
-            return;
-        }
-        mQnsTimer.unregisterTimer(mRestrictionTimers.getOrDefault(restriction, INVALID_ID));
-        mRestrictionTimers.remove(restriction);
-    }
-
-    void registerRestrictInfoChanged(Handler h, int what) {
-        mRestrictInfoRegistrant = new QnsRegistrant(h, what, null);
-    }
-
-    void unRegisterRestrictInfoChanged(Handler h) {
-        mRestrictInfoRegistrant = null;
-    }
-
-    @VisibleForTesting
-    boolean isRestricted(int transportType) {
-        if (mRestrictInfos.isEmpty()) return false;
-
-        if (mRestrictInfos.get(transportType) != null) {
-            return mRestrictInfos.get(transportType).isRestricted();
-        }
-
-        return false;
-    }
-
-    boolean isRestrictedExceptGuarding(int transportType) {
-        try {
-            RestrictInfo info = mRestrictInfos.get(transportType);
-            int size = info.getRestrictionMap().size();
-            if (info.hasRestrictionType(RESTRICT_TYPE_GUARDING)) {
-                size--;
-            }
-            return size > 0;
-        } catch (Exception e) {
-        }
-        return false;
-    }
-
-    @VisibleForTesting
-    boolean hasRestrictionType(int transportType, int restrictType) {
-        try {
-            if (mRestrictInfos != null) {
-                return mRestrictInfos.get(transportType).hasRestrictionType(restrictType);
-            }
-        } catch (Exception e) {
-
-        }
-        return false;
-    }
-
-    /** This method is only for Testing */
-    @VisibleForTesting
-    protected long getRemainingGuardTimer(int transportType) {
-        return mRestrictInfos
-                        .get(transportType)
-                        .getRestrictionMap()
-                        .get(RESTRICT_TYPE_GUARDING)
-                        .mReleaseTime
-                - SystemClock.elapsedRealtime();
-    }
-
-    @VisibleForTesting
-    boolean isAllowedOnSingleTransport(int transportType) {
-        if (mRestrictInfos.isEmpty()) return false;
-        Log.d(
-                mLogTag,
-                "isAllowedOnSingleTransport ("
-                        + QnsConstants.transportTypeToString(transportType)
-                        + ")  restriction :"
-                        + mRestrictInfos.get(transportType).toString());
-        int countIgnorableRestriction = 0;
-        for (int restrictType : ignorableRestrictionsOnSingleRat) {
-            if (mRestrictInfos.get(transportType).hasRestrictionType(restrictType)) {
-                countIgnorableRestriction++;
-            }
-        }
-        if (mRestrictInfos.get(transportType).getRestrictionMap().size()
-                == countIgnorableRestriction) {
-            return true;
-        }
-        return false;
-    }
-
-    void increaseCounterToRestrictIwlanInCall() {
-        mCounterForIwlanRestrictionInCall += 1;
-        int maxAllowedRoveOutByLowRtpQuality =
-                mQnsCarrierConfigManager.getQnsMaxIwlanHoCountDuringCall();
-        if (maxAllowedRoveOutByLowRtpQuality > 0
-                && mCounterForIwlanRestrictionInCall == maxAllowedRoveOutByLowRtpQuality) {
-            Log.d(mLogTag, "reached maxAllowedRoveOutByLowRtpQuality");
-            addRestriction(
-                    AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                    RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL,
-                    sReleaseEventMap.get(RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL),
-                    0);
-        }
-    }
-
-    private void notifyRestrictInfoChanged() {
-        Log.d(mLogTag, "notifyRestrictInfoChanged");
-        if (mRestrictInfoRegistrant != null) {
-            mRestrictInfoRegistrant.notifyResult(mRestrictInfos);
-
-            // metrics
-            sendRestrictionsForMetrics();
-        } else {
-            Log.d(mLogTag, "notifyRestrictInfoChanged. no Registrant.");
-        }
-    }
-
-    private void registerLowRtpQualityEvent() {
-        if ((mImsCallType == QnsConstants.CALL_TYPE_VOICE
-                        || mImsCallType == QnsConstants.CALL_TYPE_EMERGENCY)
-                && (mTransportType == AccessNetworkConstants.TRANSPORT_TYPE_WLAN
-                        || mTransportType == AccessNetworkConstants.TRANSPORT_TYPE_WWAN)
-                && mActiveCallTracker != null) {
-            int hoRestrictTimeOnLowRtpQuality =
-                    mQnsCarrierConfigManager.getHoRestrictedTimeOnLowRTPQuality(mTransportType);
-            if (hoRestrictTimeOnLowRtpQuality > 0) {
-                Log.d(mLogTag, "registerLowRtpQualityEvent");
-                mActiveCallTracker.registerLowMediaQualityListener(
-                        mHandler, EVENT_LOW_RTP_QUALITY_REPORTED, null);
-            }
-        }
-    }
-
-    private void unregisterLowRtpQualityEvent() {
-        if (mNetCapability == NetworkCapabilities.NET_CAPABILITY_IMS
-                || mNetCapability == NetworkCapabilities.NET_CAPABILITY_EIMS) {
-            if (mActiveCallTracker != null) {
-                mActiveCallTracker.unregisterLowMediaQualityListener(mHandler);
-            }
-        }
-    }
-
-    private int getGuardingTimeMillis(int transportType, int callType) {
-        int delayMillis;
-        switch (mNetCapability) {
-            case NetworkCapabilities.NET_CAPABILITY_IMS:
-            case NetworkCapabilities.NET_CAPABILITY_EIMS:
-                if (!mQnsCarrierConfigManager.isHysteresisTimerEnabled(mCellularCoverage)) {
-                    Log.d(
-                            mLogTag,
-                            "getGuardingTimeMillis: handover guarding timer is not enabled at "
-                                    + QnsConstants.coverageToString(mCellularCoverage));
-                    return 0;
-                }
-                if (transportType == AccessNetworkConstants.TRANSPORT_TYPE_WWAN) {
-                    delayMillis =
-                            mQnsCarrierConfigManager.getWwanHysteresisTimer(
-                                    mNetCapability, callType);
-                } else {
-                    delayMillis =
-                            mQnsCarrierConfigManager.getWlanHysteresisTimer(
-                                    mNetCapability, callType);
-                }
-                if (delayMillis > 0
-                        && mQnsCarrierConfigManager.isGuardTimerHysteresisOnPrefSupported()) {
-                    int preference = mWfcPreference;
-                    if (mCellularCoverage == QnsConstants.COVERAGE_ROAM) {
-                        preference = mWfcRoamingPreference;
-                    }
-                    if (preference == QnsConstants.CELL_PREF
-                            && transportType == AccessNetworkConstants.TRANSPORT_TYPE_WLAN) {
-                        Log.d(
-                                mLogTag,
-                                "getGuardingTimeMillis: cellular preferred case, don't guard"
-                                        + " handover to WLAN");
-                        delayMillis = 0;
-                    } else if (preference == QnsConstants.WIFI_PREF
-                            && transportType == AccessNetworkConstants.TRANSPORT_TYPE_WWAN) {
-                        Log.d(
-                                mLogTag,
-                                "getGuardingTimeMillis: wifi preferred case, don't guard handover"
-                                        + " to WWAN");
-                        delayMillis = 0;
-                    }
-                }
-                break;
-            case NetworkCapabilities.NET_CAPABILITY_MMS:
-            case NetworkCapabilities.NET_CAPABILITY_XCAP:
-            case NetworkCapabilities.NET_CAPABILITY_CBS:
-                callType = mQnsCallStatusTracker.isCallIdle() ? QnsConstants.CALL_TYPE_IDLE
-                                : QnsConstants.CALL_TYPE_VOICE;
-                if (transportType == AccessNetworkConstants.TRANSPORT_TYPE_WWAN) {
-                    delayMillis =
-                            mQnsCarrierConfigManager.getWwanHysteresisTimer(
-                                    mNetCapability, callType);
-                } else if (transportType == AccessNetworkConstants.TRANSPORT_TYPE_WLAN) {
-                    delayMillis =
-                            mQnsCarrierConfigManager.getWlanHysteresisTimer(
-                                    mNetCapability, callType);
-                } else {
-                    delayMillis = 0;
-                }
-                break;
-            default:
-                delayMillis = 0;
-                break;
-        }
-        Log.d(
-                mLogTag,
-                "getGuardingTimeMillis: timer = "
-                        + delayMillis
-                        + " for transport type = "
-                        + QnsConstants.transportTypeToString(transportType)
-                        + " in "
-                        + QnsConstants.callTypeToString(callType)
-                        + " state.");
-
-        return delayMillis;
-    }
-
-    @VisibleForTesting
-    void startGuarding(int delay, int transportType) {
-        // It is invalid to run to RESTRICT_TYPE_GUARDING for both Transport at same time
-        // Make sure to release source TransportType Guarding before starting guarding for New
-        // Transport
-        // Type
-        if (transportType != AccessNetworkConstants.TRANSPORT_TYPE_INVALID
-                && hasRestrictionType(QnsUtils.getOtherTransportType(transportType),
-                RestrictManager.RESTRICT_TYPE_GUARDING)) {
-            Log.d(
-                    mLogTag,
-                    "RESTRICT_TYPE_GUARDING cleared from Guarding for:"
-                            + QnsConstants.transportTypeToString(mTransportType));
-            // addRestriction() will take care to notify the ANE of Restrict Info status
-            releaseRestriction(
-                    QnsUtils.getOtherTransportType(transportType), RESTRICT_TYPE_GUARDING, true);
-        }
-
-        addRestriction(
-                transportType,
-                RESTRICT_TYPE_GUARDING,
-                sReleaseEventMap.get(RESTRICT_TYPE_GUARDING),
-                delay);
-    }
-
-    private void cancelGuarding(int transportType) {
-        releaseRestriction(transportType, RESTRICT_TYPE_GUARDING);
-    }
-
-    protected void notifyThrottling(boolean throttle, long throttleTime, int transportType) {
-        Log.d(
-                mLogTag,
-                "notifyThrottling throttle:"
-                        + throttle
-                        + "  throttleTime:"
-                        + throttleTime
-                        + "  transportType:"
-                        + QnsConstants.transportTypeToString(transportType));
-        if (throttle) {
-            if (throttleTime < 0) {
-                //FWK send minus value of throttle expiration time, consider anomaly report at here.
-                return;
-            }
-            long delayMillis = throttleTime - SystemClock.elapsedRealtime();
-            if (delayMillis > 0) {
-                if (mDataConnectionStatusTracker.isActiveState()) {
-                    Log.d(
-                            mLogTag,
-                            "Defer Throttling event during active state transportType:"
-                                    + transportType
-                                    + " ThrottleTime:"
-                                    + throttleTime);
-                    mDeferredThrottlingEvent = new Pair<>(transportType, throttleTime);
-                } else {
-                    if (throttleTime == Long.MAX_VALUE || throttleTime == Integer.MAX_VALUE) {
-                        //Keep throttle status until receiving un-throttle event.
-                        delayMillis = 0;
-                    }
-                    addRestriction(
-                            transportType,
-                            RESTRICT_TYPE_THROTTLING,
-                            sReleaseEventMap.get(RESTRICT_TYPE_THROTTLING),
-                            delayMillis);
-                }
-            }
-        } else {
-            releaseRestriction(transportType, RESTRICT_TYPE_THROTTLING);
-            if (mDeferredThrottlingEvent != null) mDeferredThrottlingEvent = null;
-        }
-    }
-
-    static String restrictTypeToString(int restrictType) {
-        switch (restrictType) {
-            case RESTRICT_TYPE_GUARDING:
-                return "RESTRICT_TYPE_GUARDING";
-            case RESTRICT_TYPE_THROTTLING:
-                return "RESTRICT_TYPE_THROTTLING";
-            case RESTRICT_TYPE_HO_NOT_ALLOWED:
-                return "RESTRICT_TYPE_HO_NOT_ALLOWED";
-            case RESTRICT_TYPE_NON_PREFERRED_TRANSPORT:
-                return "RESTRICT_TYPE_NON_PREFERRED_TRANSPORT";
-            case RESTRICT_TYPE_RTP_LOW_QUALITY:
-                return "RESTRICT_TYPE_RTP_LOW_QUALITY";
-            case RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL:
-                return "RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL";
-            case RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL:
-                return "RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL";
-            case RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL:
-                return "RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL";
-            case RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL:
-                return "RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL";
-            case RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL:
-                return "RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL";
-        }
-        return "";
-    }
-
-    /**
-     * Dumps the state of {@link QualityMonitor}
-     *
-     * @param pw {@link PrintWriter} to write the state of the object.
-     * @param prefix String to append at start of dumped log.
-     */
-    void dump(PrintWriter pw, String prefix) {
-        pw.println(prefix + "------------------------------");
-        pw.println(
-                prefix
-                        + "RestrictManager["
-                        + QnsUtils.getNameOfNetCapability(mNetCapability)
-                        + "_"
-                        + mSlotId
-                        + "]:");
-        pw.println(
-                prefix
-                        + "mTransportType="
-                        + QnsConstants.transportTypeToString(mTransportType)
-                        + ", mLastEvaluatedTransportType="
-                        + QnsConstants.transportTypeToString(mLastEvaluatedTransportType)
-                        + ", mLastDataConnectionTransportType="
-                        + QnsConstants.transportTypeToString(mLastDataConnectionTransportType));
-        pw.println(
-                prefix
-                        + "mCounterForIwlanRestrictionInCall="
-                        + mCounterForIwlanRestrictionInCall
-                        + ", mRetryCounterOnDataConnectionFail="
-                        + mRetryCounterOnDataConnectionFail
-                        + ", mFallbackCounterOnDataConnectionFail="
-                        + mFallbackCounterOnDataConnectionFail);
-        pw.println(
-                prefix
-                        + "mImsCallType="
-                        + QnsConstants.callTypeToString(mImsCallType)
-                        + ", mCallState="
-                        + QnsConstants.callStateToString(mCallState));
-        pw.println(prefix + "mRestrictInfos=" + mRestrictInfos);
-    }
-
-    private void sendRestrictionsForMetrics() {
-        if (mNetCapability != NetworkCapabilities.NET_CAPABILITY_IMS) {
-            return;
-        }
-        ArrayList<Integer> wlanRestrictions =
-                new ArrayList<>(
-                        mRestrictInfos
-                                .get(AccessNetworkConstants.TRANSPORT_TYPE_WLAN)
-                                .getRestrictionMap()
-                                .keySet());
-        ArrayList<Integer> wwanRestrictions =
-                new ArrayList<>(
-                        mRestrictInfos
-                                .get(AccessNetworkConstants.TRANSPORT_TYPE_WLAN)
-                                .getRestrictionMap()
-                                .keySet());
-        mQnsMetrics.reportAtomForRestrictions(mNetCapability, mSlotId,
-                wlanRestrictions, wwanRestrictions, mQnsCarrierConfigManager.getCarrierId());
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/Threshold.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/Threshold.java
deleted file mode 100644
index d54fab7..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/Threshold.java
+++ /dev/null
@@ -1,247 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.telephony.qns;
-
-import static android.telephony.SignalStrength.INVALID;
-
-import android.telephony.SignalThresholdInfo;
-
-import java.util.Objects;
-import java.util.concurrent.atomic.AtomicInteger;
-
-/**
- * This class defines the threshold information that is processed in QualityMonitor to match the
- * thresholds criteria for different access networks and measurement types.
- */
-class Threshold {
-    private static final AtomicInteger sTid = new AtomicInteger();
-
-    private int mThresholdId;
-    private int mGroupId;
-    private int mAccessNetwork;
-    private int mMeasurementType;
-    private int mThreshold;
-    private int mMatchType;
-    private int mWaitTime;
-
-    Threshold(int accessNetwork, int measurementType, int threshold, int matchType, int waitTime) {
-        this.mThresholdId = sTid.getAndIncrement();
-        this.mGroupId = QnsConstants.INVALID_ID;
-        this.mAccessNetwork = accessNetwork;
-        this.mMeasurementType = measurementType;
-        this.mThreshold = threshold;
-        this.mMatchType = matchType;
-        this.mWaitTime = waitTime;
-    }
-
-    Threshold(Threshold t) {
-        this.mThresholdId = sTid.getAndIncrement();
-        this.mGroupId = QnsConstants.INVALID_ID;
-        this.mAccessNetwork = t.mAccessNetwork;
-        this.mMeasurementType = t.mMeasurementType;
-        this.mThreshold = t.mThreshold;
-        this.mMatchType = t.mMatchType;
-        this.mWaitTime = t.mWaitTime;
-    }
-
-    private Threshold(int tid, int gid, Threshold t) {
-        this.mThresholdId = tid;
-        this.mGroupId = gid;
-        this.mAccessNetwork = t.mAccessNetwork;
-        this.mMeasurementType = t.mMeasurementType;
-        this.mThreshold = t.mThreshold;
-        this.mMatchType = t.mMatchType;
-        this.mWaitTime = t.mWaitTime;
-    }
-
-    Threshold copy() {
-        return new Threshold(mThresholdId, mGroupId, this);
-    }
-
-    int getThresholdId() {
-        return mThresholdId;
-    }
-
-    void setThresholdId(int thresholdId) {
-        this.mThresholdId = thresholdId;
-    }
-
-    int getGroupId() {
-        return mGroupId;
-    }
-
-    void setGroupId(int groupId) {
-        this.mGroupId = groupId;
-    }
-
-    int getAccessNetwork() {
-        return mAccessNetwork;
-    }
-
-    void setAccessNetwork(int accessNetwork) {
-        this.mAccessNetwork = accessNetwork;
-    }
-
-    int getMeasurementType() {
-        return mMeasurementType;
-    }
-
-    void setMeasurementType(int measurementType) {
-        this.mMeasurementType = measurementType;
-    }
-
-    int getThreshold() {
-        return mThreshold;
-    }
-
-    void setThreshold(int threshold) {
-        this.mThreshold = threshold;
-    }
-
-    int getMatchType() {
-        return mMatchType;
-    }
-
-    void setMatchType(int matchType) {
-        this.mMatchType = matchType;
-    }
-
-    int getWaitTime() {
-        return mWaitTime;
-    }
-
-    void setWaitTime(int waitTime) {
-        mWaitTime = waitTime;
-    }
-
-    /** Method is used to match the Threshold Criteria before Notify to ANE. */
-    boolean isMatching(int threshold) {
-        if (threshold != INVALID) {
-            switch (this.mMatchType) {
-                case QnsConstants.THRESHOLD_MATCH_TYPE_EQUAL_TO:
-                    return this.mThreshold == threshold;
-                case QnsConstants.THRESHOLD_EQUAL_OR_LARGER:
-                    return this.mThreshold <= threshold;
-                case QnsConstants.THRESHOLD_EQUAL_OR_SMALLER:
-                    return this.mThreshold >= threshold;
-            }
-        }
-        return false;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (!(o instanceof Threshold)) return false;
-        Threshold th = (Threshold) o;
-        return this.mThresholdId == th.mThresholdId
-                && this.mGroupId == th.mGroupId
-                && this.mAccessNetwork == th.mAccessNetwork
-                && this.mMeasurementType == th.mMeasurementType
-                && this.mThreshold == th.mThreshold
-                && this.mMatchType == th.mMatchType
-                && this.mWaitTime == th.mWaitTime;
-    }
-
-    @Override
-    public int hashCode() {
-        return Objects.hash(
-                mThresholdId,
-                mGroupId,
-                mAccessNetwork,
-                mMeasurementType,
-                mThreshold,
-                mMatchType,
-                mWaitTime);
-    }
-
-    @Override
-    public String toString() {
-        return "Threshold {"
-                + "thresholdId="
-                + mThresholdId
-                + ", groupId="
-                + mGroupId
-                + ", accessNetwork="
-                + mAccessNetwork
-                + ", measurementType="
-                + mMeasurementType
-                + ", threshold="
-                + mThreshold
-                + ", matchType="
-                + mMatchType
-                + ", waitTime="
-                + mWaitTime
-                + '}';
-    }
-
-    String toShortString() {
-        StringBuilder sb = new StringBuilder();
-        sb.append(QnsConstants.accessNetworkTypeToString(mAccessNetwork)).append(".");
-        switch (mMeasurementType) {
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_UNKNOWN:
-                sb.append("UNKNOWN");
-                break;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI:
-                sb.append("RSSI");
-                break;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSCP:
-                sb.append("RSSCP");
-                break;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP:
-                sb.append("RSRP");
-                break;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRQ:
-                sb.append("RSRQ");
-                break;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR:
-                sb.append("RSSNR");
-                break;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSRSRP:
-                sb.append("SSRSRP");
-                break;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSRSRQ:
-                sb.append("SSRSRQ");
-                break;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSSINR:
-                sb.append("SSSINR");
-                break;
-            case SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_ECNO:
-                sb.append("ECNO");
-                break;
-            case QnsConstants.SIGNAL_MEASUREMENT_AVAILABILITY:
-                sb.append("AVAIL");
-        }
-        if (mMatchType == QnsConstants.THRESHOLD_EQUAL_OR_LARGER) {
-            sb.append(">=");
-        } else if (mMatchType == QnsConstants.THRESHOLD_EQUAL_OR_SMALLER) {
-            sb.append("<=");
-        } else if (mMatchType == QnsConstants.THRESHOLD_MATCH_TYPE_EQUAL_TO) {
-            sb.append("==");
-        }
-        sb.append(mThreshold);
-        return sb.toString();
-    }
-
-    boolean identicalThreshold(Threshold o) {
-        if (this == o) return true;
-        if (o == null) return false;
-        return this.mAccessNetwork == o.mAccessNetwork
-                && this.mMeasurementType == o.mMeasurementType
-                && this.mThreshold == o.mThreshold
-                && this.mMatchType == o.mMatchType
-                && this.mWaitTime == o.mWaitTime;
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/ThresholdCallback.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/ThresholdCallback.java
deleted file mode 100644
index 676e844..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/ThresholdCallback.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import android.util.Log;
-
-import java.lang.ref.WeakReference;
-import java.util.concurrent.Executor;
-
-class ThresholdCallback {
-    static final String sLogTag = ThresholdCallback.class.getSimpleName();
-    IThresholdListener mCallback;
-
-    void init(Executor executor) {
-        if (executor == null) throw new IllegalArgumentException("executor cannot be null");
-        mCallback = new ThresholdListener(executor, this);
-    }
-
-    interface WifiThresholdListener {
-        void onWifiThresholdChanged(Threshold[] thresholds);
-    }
-
-    interface CellularThresholdListener {
-        void onCellularThresholdChanged(Threshold[] thresholds);
-    }
-
-    private static class ThresholdListener implements IThresholdListener {
-        private WeakReference<ThresholdCallback> mThresholdCallbackWeakRef;
-        private Executor mExecutor;
-
-        ThresholdListener(Executor executor, ThresholdCallback callback) {
-            mExecutor = executor;
-            mThresholdCallbackWeakRef = new WeakReference<>(callback);
-        }
-
-        @Override
-        public void onWifiThresholdChanged(Threshold[] thresholds) {
-            WifiThresholdListener listener =
-                    (WifiThresholdListener) mThresholdCallbackWeakRef.get();
-            if (listener == null) {
-                Log.w(sLogTag, "Listener is null for wifi threshold notification");
-                return;
-            }
-            mExecutor.execute(() -> listener.onWifiThresholdChanged(thresholds));
-        }
-
-        @Override
-        public void onCellularThresholdChanged(Threshold[] thresholds) {
-            CellularThresholdListener listener =
-                    (CellularThresholdListener) mThresholdCallbackWeakRef.get();
-            if (listener == null) {
-                Log.w(sLogTag, "Listener is null for cellular threshold notification");
-                return;
-            }
-            mExecutor.execute(() -> listener.onCellularThresholdChanged(thresholds));
-        }
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/ThresholdGroup.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/ThresholdGroup.java
deleted file mode 100644
index 5ae8087..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/ThresholdGroup.java
+++ /dev/null
@@ -1,198 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import android.telephony.AccessNetworkConstants.AccessNetworkType;
-import android.telephony.SignalThresholdInfo;
-import android.util.Log;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicInteger;
-
-class ThresholdGroup {
-    private static final AtomicInteger sGid = new AtomicInteger();
-
-    private final List<Threshold> mThresholds;
-    private final String mTag;
-
-    ThresholdGroup(List<Threshold> ths) {
-        int groupId = sGid.getAndIncrement();
-        mThresholds = alignGroupId(groupId, ths);
-        mTag = ThresholdGroup.class.getSimpleName() + groupId;
-    }
-
-    private List<Threshold> alignGroupId(int groupId, List<Threshold> ths) {
-        if (ths == null) {
-            return new ArrayList<>();
-        }
-        ArrayList<Threshold> newList = new ArrayList<>(ths);
-        for (Threshold th : newList) {
-            th.setGroupId(groupId);
-        }
-        return newList;
-    }
-
-    boolean satisfiedByThreshold(
-            QualityMonitor wifiMonitor,
-            QualityMonitor cellMonitor,
-            boolean iwlanAvailable,
-            boolean cellAvailable,
-            int cellularAccessNetworkType) {
-        if (mThresholds == null || mThresholds.isEmpty()) {
-            return false;
-        }
-        boolean omittedCellularAvailable = true;
-        for (Threshold th : mThresholds) {
-            if (th.getAccessNetwork() == AccessNetworkType.IWLAN) {
-                if (!satisfy(th, wifiMonitor, iwlanAvailable, AccessNetworkType.IWLAN)) {
-                    return false;
-                }
-            }
-            if (th.getAccessNetwork() != AccessNetworkType.IWLAN) {
-                omittedCellularAvailable = false;
-                if (!satisfy(th, cellMonitor, cellAvailable, cellularAccessNetworkType)) {
-                    return false;
-                }
-            }
-        }
-        if (omittedCellularAvailable && !cellAvailable) {
-            return false;
-        }
-        return true;
-    }
-
-    private boolean satisfy(Threshold th, QualityMonitor monitor, boolean available, int an) {
-        // availability
-        if (th.getMeasurementType() == QnsConstants.SIGNAL_MEASUREMENT_AVAILABILITY) {
-            if (th.getThreshold() == QnsConstants.SIGNAL_AVAILABLE
-                    && available
-                    && an == th.getAccessNetwork()) {
-                Log.d(mTag, "satisfy " + th.toShortString() + " currentQuality:Available");
-                return true;
-            }
-            if (th.getThreshold() == QnsConstants.SIGNAL_UNAVAILABLE
-                    && (!available || an != th.getAccessNetwork())) {
-                Log.d(mTag, "satisfy " + th.toShortString() + " currentQuality:Unavailable");
-                return true;
-            }
-            Log.d(mTag, "not satisfy " + th.toShortString() + " available:" + available);
-            return false;
-        }
-
-        // measurement matching
-        if (th.getAccessNetwork() != an) {
-            return false;
-        }
-        int cq = monitor.getCurrentQuality(th.getAccessNetwork(), th.getMeasurementType());
-        if (th.isMatching(cq)) {
-            Log.d(mTag, "satisfy " + th.toShortString() + " currentQuality:" + cq);
-            return true;
-        } else {
-            Log.d(mTag, "not satisfy " + th.toShortString() + " currentQuality:" + cq);
-            return false;
-        }
-    }
-
-    List<Threshold> findUnmatchedThresholds(
-            QualityMonitor wifiMonitor, QualityMonitor cellMonitor) {
-        List<Threshold> tl = new ArrayList<>();
-        if (mThresholds == null || mThresholds.isEmpty()) {
-            return tl;
-        }
-
-        for (Threshold th : mThresholds) {
-            if (th.getMeasurementType() == QnsConstants.SIGNAL_MEASUREMENT_AVAILABILITY) {
-                continue;
-            }
-
-            boolean isIwlan = th.getAccessNetwork() == AccessNetworkType.IWLAN;
-            QualityMonitor monitor = isIwlan ? wifiMonitor : cellMonitor;
-            int cq = monitor.getCurrentQuality(th.getAccessNetwork(), th.getMeasurementType());
-
-            if (th.isMatching(cq)) {
-                Log.d(mTag, "Threshold " + th.toShortString() + " is matched. current:" + cq);
-            } else {
-                Log.d(mTag, "Threshold " + th.toShortString() + " is not matched. current:" + cq);
-                tl.add(th);
-            }
-        }
-        return tl;
-    }
-
-    boolean hasWifiThresholdWithoutCellularCondition() {
-        if (mThresholds == null || mThresholds.isEmpty()) {
-            return false;
-        }
-        boolean foundIwlanRssiThreshold = false;
-        boolean foundCellularUnavailable = false;
-        for (Threshold th : mThresholds) {
-            if (th.getMeasurementType() == SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI
-                    && th.getAccessNetwork() == AccessNetworkType.IWLAN) {
-                foundIwlanRssiThreshold = true;
-            }
-            if (th.getMeasurementType() == QnsConstants.SIGNAL_MEASUREMENT_AVAILABILITY
-                    && th.getThreshold() == QnsConstants.SIGNAL_UNAVAILABLE
-                    && th.getAccessNetwork() != AccessNetworkType.IWLAN) {
-                foundCellularUnavailable = true;
-            }
-        }
-        return foundIwlanRssiThreshold && foundCellularUnavailable;
-    }
-
-    List<Threshold> getThresholds(int accessNetworkType) {
-        List<Threshold> accessNetworkTypeThresholdList = new ArrayList<>();
-        for (Threshold t : mThresholds) {
-            if (t.getAccessNetwork() == accessNetworkType) {
-                accessNetworkTypeThresholdList.add(t);
-            }
-        }
-        return accessNetworkTypeThresholdList;
-    }
-
-    String toShortString() {
-        StringBuilder sb = new StringBuilder();
-        sb.append("(");
-        if (mThresholds != null && mThresholds.size() > 0) {
-            for (Threshold th : mThresholds) {
-                sb.append(th.toShortString()).append(",");
-            }
-            sb.deleteCharAt(sb.lastIndexOf(","));
-        }
-        sb.append(")");
-        return sb.toString();
-    }
-
-    boolean identicalThreshold(List<Threshold> o) {
-        if (mThresholds == o) return true;
-        if (mThresholds == null || o == null) return false;
-        if (mThresholds.size() != o.size()) return false;
-        for (Threshold th : mThresholds) {
-            boolean found = false;
-            for (Threshold tho : o) {
-                if (th.identicalThreshold(tho)) {
-                    found = true;
-                    break;
-                }
-            }
-            if (!found) {
-                return false;
-            }
-        }
-        return true;
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/WifiBackhaulMonitor.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/WifiBackhaulMonitor.java
deleted file mode 100644
index 6bef150..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/WifiBackhaulMonitor.java
+++ /dev/null
@@ -1,374 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static com.android.telephony.qns.QnsConstants.INVALID_ID;
-
-import android.content.Context;
-import android.net.ConnectivityManager;
-import android.net.LinkProperties;
-import android.net.Network;
-import android.net.NetworkCapabilities;
-import android.net.NetworkRequest;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Message;
-import android.telephony.AccessNetworkConstants;
-import android.util.Log;
-
-import com.android.internal.annotations.VisibleForTesting;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.net.Inet4Address;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * This class provides support for the RTT verification for Wifi. It schedules the RTT verification
- * based on the UE state(Wifi connected, Cellular available, IMS registered on WLAN, operator
- * support for RTT, etc).
- */
-class WifiBackhaulMonitor {
-    private static final int EVENT_START_RTT_CHECK = 1;
-    private static final int EVENT_IMS_REGISTRATION_STATE_CHANGED = 2;
-    private final String mTag;
-    private final ConnectivityManager mConnectivityManager;
-    private final QnsImsManager mQnsImsManager;
-    private final ConnectivityManager.NetworkCallback mNetworkCallback;
-    private final Context mContext;
-    private final int mSlotIndex;
-
-    private final QnsRegistrantList mRegistrantList;
-    private final HandlerThread mHandlerThread;
-    private final Handler mHandler;
-    private final QnsCarrierConfigManager mConfigManager;
-    private final QnsTimer mQnsTimer;
-    private boolean mRttResult = false;
-
-    ArrayList<InetAddress> mValidIpList = new ArrayList<>();
-    private boolean mIsCallbackRegistered = false;
-    private boolean mIsRttScheduled = false;
-    private boolean mIsCellularAvailable = false;
-    private boolean mIsIwlanConnected = false;
-    private boolean mIsRttRunning = false;
-    private String mInterfaceName = null;
-    private int mRttTimerId = INVALID_ID;
-
-    private class BackhaulHandler extends Handler {
-        BackhaulHandler() {
-            super(mHandlerThread.getLooper());
-        }
-
-        @Override
-        public void handleMessage(Message msg) {
-            super.handleMessage(msg);
-            log("handleMessage what = " + msg.what);
-            QnsAsyncResult ar;
-            switch (msg.what) {
-                case EVENT_START_RTT_CHECK:
-                    onRttCheckStarted();
-                    break;
-                case EVENT_IMS_REGISTRATION_STATE_CHANGED:
-                    ar = (QnsAsyncResult) msg.obj;
-                    onImsRegistrationStateChanged((QnsImsManager.ImsRegistrationState) ar.mResult);
-                    break;
-                default:
-                    log("Invalid event = " + msg.what);
-            }
-        }
-    }
-
-    private class WiFiStatusCallback extends ConnectivityManager.NetworkCallback {
-
-        @Override
-        public void onAvailable(Network network) {
-            super.onAvailable(network);
-            if (network != null) {
-                LinkProperties lp = mConnectivityManager.getLinkProperties(network);
-                if (lp != null && lp.getInterfaceName().contains("wlan")) {
-                    mInterfaceName = lp.getInterfaceName();
-                }
-            }
-        }
-
-        @Override
-        public void onLost(Network network) {
-            super.onLost(network);
-            stopRttSchedule();
-            mInterfaceName = null;
-            mRttResult = false;
-        }
-    }
-    /**
-     * Constructor to create WifiBackhaulMonitor instance.
-     */
-    WifiBackhaulMonitor(
-            Context context,
-            QnsCarrierConfigManager configManager,
-            QnsImsManager imsManager,
-            QnsTimer qnstimer,
-            int slotIndex) {
-        mSlotIndex = slotIndex;
-        mTag = WifiBackhaulMonitor.class.getSimpleName() + "[" + mSlotIndex + "]";
-        mContext = context;
-        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
-        mConfigManager = configManager;
-        mQnsImsManager = imsManager;
-        mQnsTimer = qnstimer;
-        mNetworkCallback = new WiFiStatusCallback();
-        mRegistrantList = new QnsRegistrantList();
-        mHandlerThread = new HandlerThread(mTag);
-        mHandlerThread.start();
-        mHandler = new BackhaulHandler();
-    }
-
-    /** This method returns true if operator supports RTT feature. */
-    boolean isRttCheckEnabled() {
-        return mConfigManager.getWlanRttServerAddressConfig() != null;
-    }
-
-    /**
-     * Registers to receive the change in Round-trip-time(RTT) ICMP pings for Wifi.
-     *
-     * @param h {@link Handler} to handle the result of the RTT pings.
-     * @param what event which will be notified in handler.
-     */
-    void registerForRttStatusChange(Handler h, int what) {
-        mRegistrantList.addUnique(h, what, null);
-        if (!mIsCallbackRegistered) {
-            mQnsImsManager.registerImsRegistrationStatusChanged(
-                    mHandler, EVENT_IMS_REGISTRATION_STATE_CHANGED);
-            mConnectivityManager.registerNetworkCallback(
-                    new NetworkRequest.Builder()
-                            .clearCapabilities()
-                            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
-                            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
-                            .build(),
-                    mNetworkCallback);
-            mIsCallbackRegistered = true;
-        }
-    }
-
-    /**
-     * Unregisters the handler for RTT ICMP pings.
-     *
-     * @param h {@link Handler} to unregister the event
-     */
-    void unRegisterForRttStatusChange(Handler h) {
-        mRegistrantList.remove(h);
-        if (mRegistrantList.size() == 0) {
-            clearAll();
-        }
-    }
-
-    /** Triggers the request to check RTT. */
-    void requestRttCheck() {
-        if (!mIsRttRunning) {
-            if (mRttTimerId != INVALID_ID) {
-                mQnsTimer.unregisterTimer(mRttTimerId);
-                mRttTimerId = INVALID_ID;
-            }
-            mHandler.sendEmptyMessage(EVENT_START_RTT_CHECK);
-        } else {
-            log("RTT check is already running");
-        }
-    }
-
-    /** Updates cellular availability in WifiBackhaulMonitor. */
-    void setCellularAvailable(boolean cellularAvailable) {
-        if (mIsCellularAvailable != cellularAvailable) {
-            mIsCellularAvailable = cellularAvailable;
-            if (mIsCellularAvailable) {
-                startRttSchedule();
-            } else {
-                stopRttSchedule();
-            }
-        }
-    }
-
-    private void onRttCheckStarted() {
-        mIsRttRunning = true;
-        mRttResult = startRttCheck();
-        if (mIsRttScheduled && mRttResult) {
-            mIsRttScheduled = false;
-            startRttSchedule();
-        }
-        mIsRttRunning = false;
-        notifyRttResult();
-    }
-
-    private void onImsRegistrationStateChanged(QnsImsManager.ImsRegistrationState info) {
-        if (info.getTransportType() == AccessNetworkConstants.TRANSPORT_TYPE_WLAN) {
-            if (info.getEvent() == QnsConstants.IMS_REGISTRATION_CHANGED_REGISTERED) {
-                mIsIwlanConnected = true;
-                startRttSchedule();
-            } else if (info.getEvent() == QnsConstants.IMS_REGISTRATION_CHANGED_UNREGISTERED) {
-                mIsIwlanConnected = false;
-                stopRttSchedule();
-            }
-        } else if (info.getTransportType() == AccessNetworkConstants.TRANSPORT_TYPE_WWAN
-                && info.getEvent() == QnsConstants.IMS_REGISTRATION_CHANGED_REGISTERED) {
-            mIsIwlanConnected = false;
-            stopRttSchedule();
-        }
-    }
-
-    private void startRttSchedule() {
-        if (!mIsRttScheduled && mIsCellularAvailable && mIsIwlanConnected) {
-            int delay = mConfigManager.getWlanRttOtherConfigs()[4];
-            if (delay > 0) {
-                startRttSchedule(delay);
-            }
-        }
-    }
-
-    private void startRttSchedule(int delay) {
-        log("start RTT schedule for " + delay);
-        mRttTimerId = mQnsTimer.registerTimer(Message.obtain(mHandler, EVENT_START_RTT_CHECK),
-                delay);
-        mIsRttScheduled = true;
-    }
-
-    private void stopRttSchedule() {
-        if (mIsRttScheduled) {
-            log("stop RTT schedule");
-            mQnsTimer.unregisterTimer(mRttTimerId);
-            mRttTimerId = INVALID_ID;
-            mIsRttScheduled = false;
-        }
-    }
-
-    private void notifyRttResult() {
-        mRegistrantList.notifyResult(mRttResult);
-        mValidIpList.clear();
-    }
-
-    private boolean startRttCheck() {
-        if (mInterfaceName == null) {
-            log("Wifi interface is not set for RTT check");
-            return false;
-        }
-        int[] config = mConfigManager.getWlanRttOtherConfigs();
-        if (config == null || config.length == 0) {
-            log("No configurations are set for RTT check");
-            return true;
-        }
-
-        int pingCount = config[0];
-        int intervalTime = Math.max(config[1], 200);
-        int pingSize = config[2];
-        int requiredRttAverage = config[3];
-        String rttPingServer = mConfigManager.getWlanRttServerAddressConfig();
-
-        List<String>[] hostAddresses;
-        try {
-            hostAddresses = getHostAddresses(rttPingServer);
-        } catch (UnknownHostException e) {
-            log("Host not found for " + rttPingServer);
-            return true;
-        }
-
-        boolean rttResult = true;
-        Runtime runtime = Runtime.getRuntime();
-        int ver = 0;
-        String[] pings = new String[] {"ping", "ping6"}; // ping for IPv4 and IPv6
-        for (String ping : pings) {
-            List<String> addresses = hostAddresses[ver];
-            for (String address : addresses) {
-                StringBuilder command = new StringBuilder(ping);
-                command.append(" -I ").append(mInterfaceName);
-                command.append(" -i ").append((float) intervalTime / 1000);
-                command.append(" -s ").append(pingSize);
-                command.append(" -c ").append(pingCount);
-                command.append(" ").append(address);
-                try {
-                    Process p = runtime.exec(command.toString());
-                    BufferedReader br =
-                            new BufferedReader(new InputStreamReader(p.getInputStream()));
-                    String s;
-                    while ((s = br.readLine()) != null) {
-                        if (s.contains("/avg/")) {
-                            int i = s.indexOf("/", s.indexOf("="));
-                            String time = s.substring(i + 1, s.indexOf("/", i + 2));
-                            float avgRtt = Float.parseFloat(time);
-                            rttResult = avgRtt <= requiredRttAverage;
-                            if (rttResult) {
-                                log("RTT check is success.");
-                                return true;
-                            }
-                        }
-                    }
-                } catch (IOException | NumberFormatException e) {
-                    e.printStackTrace();
-                }
-            }
-            ver++;
-        }
-
-        log("RTT Result: " + rttResult);
-        return rttResult;
-    }
-
-    private List<String>[] getHostAddresses(String rttPingServer) throws UnknownHostException {
-        List<String>[] lists = new List[2];
-        lists[0] = new ArrayList<>(); // for IPv4
-        lists[1] = new ArrayList<>(); // for IPv6
-        InetAddress[] inetAddress = InetAddress.getAllByName(rttPingServer);
-        for (InetAddress addr : inetAddress) {
-            if (addr instanceof Inet4Address) {
-                lists[0].add(addr.getHostAddress());
-            } else {
-                lists[1].add(addr.getHostAddress());
-            }
-        }
-        return lists;
-    }
-
-    /** Closes the current instance. */
-    void close() {
-        mHandlerThread.quit();
-        clearAll();
-    }
-
-    /** Method to clear all settings in WifiBackhaulMonitor */
-    void clearAll() {
-        stopRttSchedule();
-        mRegistrantList.removeAll();
-        if (mIsCallbackRegistered) {
-            mConnectivityManager.unregisterNetworkCallback(mNetworkCallback);
-            mQnsImsManager.unregisterImsRegistrationStatusChanged(mHandler);
-            mIsCallbackRegistered = false;
-        }
-        mIsRttRunning = false;
-        mIsCellularAvailable = false;
-        mIsIwlanConnected = false;
-        mIsRttScheduled = false;
-    }
-
-    @VisibleForTesting
-    int getRttTimerId() {
-        return mRttTimerId;
-    }
-
-    private void log(String s) {
-        Log.d(mTag, s);
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/WifiQualityMonitor.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/WifiQualityMonitor.java
deleted file mode 100644
index 0c5ea2a..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/WifiQualityMonitor.java
+++ /dev/null
@@ -1,393 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.telephony.qns;
-
-import static android.net.NetworkCapabilities.SIGNAL_STRENGTH_UNSPECIFIED;
-import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
-
-import static com.android.telephony.qns.QnsConstants.THRESHOLD_EQUAL_OR_LARGER;
-
-import android.annotation.NonNull;
-import android.content.Context;
-import android.net.ConnectivityManager;
-import android.net.Network;
-import android.net.NetworkCapabilities;
-import android.net.NetworkRequest;
-import android.net.wifi.WifiManager;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Looper;
-import android.os.Message;
-import android.telephony.SignalThresholdInfo;
-import android.util.Log;
-
-import com.android.internal.annotations.VisibleForTesting;
-
-import java.io.PrintWriter;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-
-/**
- * This class manages threshold information registered from AccessNetworkEvaluator It is intended to
- * monitor Wi-Fi qualities(Wi-Fi RSSI, WIFI PER) & report event if the network quality changes over
- * the threshold value.
- */
-public class WifiQualityMonitor extends QualityMonitor {
-    private final String mTag;
-    private final Context mContext;
-    private final WifiManager mWifiManager;
-    private final ConnectivityManager mConnectivityManager;
-    private final WiFiThresholdCallback mWiFiThresholdCallback;
-    private final NetworkRequest.Builder mBuilder;
-    private final QnsTimer mQnsTimer;
-    private final List<Integer> mTimerIds;
-
-    private int mWifiRssi;
-    @VisibleForTesting Handler mHandler;
-    private int mRegisteredThreshold = SIGNAL_STRENGTH_UNSPECIFIED;
-    private static final int BACKHAUL_TIMER_DEFAULT = 3000;
-    static final int INVALID_RSSI = -127;
-    private boolean mIsRegistered = false;
-    private boolean mIsBackhaulRunning;
-
-    private class WiFiThresholdCallback extends ConnectivityManager.NetworkCallback {
-        /** Callback Received based on meeting Wifi RSSI Threshold Registered or Wifi Lost */
-        @Override
-        public void onCapabilitiesChanged(
-                @NonNull Network network, @NonNull NetworkCapabilities networkCapabilities) {
-            super.onCapabilitiesChanged(network, networkCapabilities);
-            Log.d(
-                    mTag,
-                    "onCapabilitiesChanged wlan network="
-                            + network
-                            + ", capabilities="
-                            + networkCapabilities);
-            if (networkCapabilities != null) {
-                mWifiRssi = networkCapabilities.getSignalStrength();
-                Log.d(mTag, "onCapabilitiesChanged_rssi: " + mWifiRssi);
-                validateWqmStatus(mWifiRssi);
-            }
-        }
-
-        /** Called when current threshold goes below the threshold set. */
-        @Override
-        public void onLost(@NonNull Network network) {
-            super.onLost(network);
-            mWifiRssi = getCurrentQuality(SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI);
-            Log.d(mTag, "onLost_rssi=" + mWifiRssi);
-            validateWqmStatus(mWifiRssi);
-        }
-    }
-
-    @VisibleForTesting
-    synchronized void validateWqmStatus(int wifiRssi) {
-        if (isWifiRssiValid(wifiRssi)) {
-            Log.d(mTag, "Registered Threshold @ Wqm Status check =" + mRegisteredThreshold);
-            mHandler.obtainMessage(EVENT_WIFI_RSSI_CHANGED, wifiRssi, 0).sendToTarget();
-        } else {
-            Log.d(mTag, "Cancel backhaul if running for invalid SS received");
-            clearBackHaulTimer();
-        }
-    }
-
-    private boolean isWifiRssiValid(int wifiRssi) {
-        if (mRegisteredThreshold != SIGNAL_STRENGTH_UNSPECIFIED
-                && wifiRssi < 0
-                && wifiRssi > SIGNAL_STRENGTH_UNSPECIFIED
-                && wifiRssi != INVALID_RSSI) {
-            Log.d(mTag, "rssi under check is valid");
-            return true;
-        }
-        return false;
-    }
-
-    private void clearBackHaulTimer() {
-        Log.d(mTag, "Stop all active backhaul timers");
-        for (int timerId : mTimerIds) {
-            mQnsTimer.unregisterTimer(timerId);
-        }
-        mTimerIds.clear();
-        mWaitingThresholds.clear();
-    }
-
-    /**
-     * Create WifiQualityMonitor object for accessing WifiManager, ConnectivityManager to monitor
-     * RSSI, build parameters for registering threshold & callback listening.
-     */
-    WifiQualityMonitor(Context context, QnsTimer qnsTimer) {
-        super(QualityMonitor.class.getSimpleName() + "-I");
-        mTag = WifiQualityMonitor.class.getSimpleName() + "-I";
-        mContext = context;
-        mQnsTimer = qnsTimer;
-        mTimerIds = new ArrayList<>();
-        HandlerThread handlerThread = new HandlerThread(mTag);
-        handlerThread.start();
-        mHandler = new WiFiEventsHandler(handlerThread.getLooper());
-
-        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
-        mWifiManager = mContext.getSystemService(WifiManager.class);
-        if (mConnectivityManager == null) {
-            Log.e(mTag, "Failed to get Connectivity Service");
-        }
-        if (mWifiManager == null) {
-            Log.e(mTag, "Failed to get WiFi Service");
-        }
-        /* Network Callback for Threshold Register. */
-        mWiFiThresholdCallback = new WiFiThresholdCallback();
-        mBuilder =
-                new NetworkRequest.Builder()
-                        .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
-                        .addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED)
-                        .addTransportType(TRANSPORT_WIFI);
-    }
-
-    /** Returns current Wifi RSSI information */
-    @Override
-    synchronized int getCurrentQuality(int accessNetwork, int measurementType) {
-        return getCurrentQuality(measurementType);
-    }
-
-    // To-do:  To be handled for more Measurement types(e.g. WiFi PER).
-    private int getCurrentQuality(int measurementType) {
-        // TODO getConnectionInfo is deprecated.
-        return mWifiManager.getConnectionInfo().getRssi();
-    }
-
-    /**
-     * Register for threshold to receive callback based on criteria met, using WiFiThresholdCallback
-     */
-    @Override
-    synchronized void registerThresholdChange(
-            ThresholdCallback thresholdCallback,
-            int netCapability,
-            Threshold[] ths,
-            int slotIndex) {
-        Log.d(
-                mTag,
-                "registerThresholds for netCapability="
-                        + QnsUtils.getNameOfNetCapability(netCapability));
-        super.registerThresholdChange(thresholdCallback, netCapability, ths, slotIndex);
-        updateThresholdsForNetCapability(netCapability, slotIndex, ths);
-    }
-
-    // To-do:  To be handled for more Measurement types(e.g. WiFi PER)
-    @Override
-    synchronized void unregisterThresholdChange(int netCapability, int slotIndex) {
-        super.unregisterThresholdChange(netCapability, slotIndex);
-        checkForThresholdRegistration();
-    }
-
-    @Override
-    synchronized void updateThresholdsForNetCapability(
-            int netCapability, int slotIndex, Threshold[] ths) {
-        super.updateThresholdsForNetCapability(netCapability, slotIndex, ths);
-        checkForThresholdRegistration();
-    }
-
-    @Override
-    protected void notifyThresholdChange(String key, Threshold[] ths) {
-        IThresholdListener listener = mThresholdCallbackMap.get(key);
-        Log.d(mTag, "Notify Threshold Change to listener = " + listener);
-        if (listener != null) {
-            listener.onWifiThresholdChanged(ths);
-        }
-    }
-
-    private void checkForThresholdRegistration() {
-        // Current check is on measurement type as RSSI
-        // Future to be enhanced for WiFi PER.
-        int newThreshold = SIGNAL_STRENGTH_UNSPECIFIED;
-        for (Map.Entry<String, List<Threshold>> entry : mThresholdsList.entrySet()) {
-            for (Threshold t : entry.getValue()) {
-                if (t.getMeasurementType() == SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI) {
-                    // check ROVE IN cases:
-                    if (t.getMatchType() == THRESHOLD_EQUAL_OR_LARGER) {
-                        if (newThreshold > t.getThreshold()
-                                || newThreshold == SIGNAL_STRENGTH_UNSPECIFIED) {
-                            newThreshold = t.getThreshold();
-                        }
-                        // other ROVE OUT cases:
-                    } else if (newThreshold < t.getThreshold()) {
-                        newThreshold = t.getThreshold();
-                    }
-                }
-            }
-        }
-
-        Log.d(
-                mTag,
-                "Registered threshold = "
-                        + mRegisteredThreshold
-                        + ", new threshold = "
-                        + newThreshold);
-        if (newThreshold != mRegisteredThreshold) {
-            mRegisteredThreshold = newThreshold;
-            updateRequest(mRegisteredThreshold != SIGNAL_STRENGTH_UNSPECIFIED);
-        }
-    }
-
-    private void validateForWifiBackhaul(int wifiRssi) {
-        mIsBackhaulRunning = false;
-        for (Map.Entry<String, List<Threshold>> entry : mThresholdsList.entrySet()) {
-            if (mWaitingThresholds.getOrDefault(entry.getKey(), false)) {
-                continue;
-            }
-            for (Threshold th : entry.getValue()) {
-                if (th.isMatching(wifiRssi)) {
-                    Log.d(mTag, "RSSI matched for threshold = " + th);
-                    handleMatchingThreshold(entry.getKey(), th, wifiRssi);
-                }
-            }
-        }
-    }
-
-    private void handleMatchingThreshold(String key, Threshold th, int wifiRssi) {
-        int backhaul = th.getWaitTime();
-        if (backhaul < 0 && th.getMatchType() != QnsConstants.THRESHOLD_EQUAL_OR_SMALLER) {
-            backhaul = BACKHAUL_TIMER_DEFAULT;
-        }
-        if (backhaul > 0) {
-            mWaitingThresholds.put(key, true);
-            Log.d(mTag, "Starting backhaul timer = " + backhaul);
-            if (!mIsBackhaulRunning) {
-                mTimerIds.add(
-                        mQnsTimer.registerTimer(
-                                Message.obtain(mHandler, EVENT_WIFI_NOTIFY_TIMER_EXPIRED),
-                                backhaul));
-                mIsBackhaulRunning = true;
-            }
-        } else {
-            Log.d(mTag, "Notify for RSSI Threshold Registered w/o Backhaul = " + backhaul);
-            checkAndNotifySignalStrength(key, wifiRssi);
-        }
-    }
-
-    private void validateThresholdsAfterBackHaul(int wifiRssi) {
-        mWaitingThresholds.clear();
-        for (Map.Entry<String, List<Threshold>> entry : mThresholdsList.entrySet()) {
-            checkAndNotifySignalStrength(entry.getKey(), wifiRssi);
-        }
-    }
-
-    private void checkAndNotifySignalStrength(String key, int wifiRssi) {
-        List<Threshold> thresholdsList = mThresholdsList.get(key);
-        if (thresholdsList == null) return;
-        Log.d(mTag, "checkAndNotifySignalStrength for " + thresholdsList);
-        List<Threshold> matchedThresholds = new ArrayList<>();
-        Threshold threshold;
-        for (Threshold th : thresholdsList) {
-            if (th.isMatching(wifiRssi)) {
-                threshold = th.copy();
-                threshold.setThreshold(wifiRssi);
-                matchedThresholds.add(threshold);
-            }
-        }
-        if (matchedThresholds.size() > 0) {
-            notifyThresholdChange(key, matchedThresholds.toArray(new Threshold[0]));
-        }
-    }
-
-    private void updateRequest(boolean register) {
-        if (!register) {
-            unregisterCallback();
-            if (mThresholdsList.isEmpty()) {
-                clearBackHaulTimer();
-            }
-        } else {
-            Log.d(mTag, "Listening to threshold = " + mRegisteredThreshold);
-            mBuilder.setSignalStrength(mRegisteredThreshold);
-            registerCallback();
-        }
-    }
-
-    private void unregisterCallback() {
-        if (mIsRegistered) {
-            Log.d(mTag, "Unregister callbacks");
-            mIsRegistered = false;
-            mConnectivityManager.unregisterNetworkCallback(mWiFiThresholdCallback);
-        }
-    }
-
-    private void registerCallback() {
-        unregisterCallback();
-        if (!mIsRegistered) {
-            Log.d(mTag, "Register callbacks");
-            mConnectivityManager.registerNetworkCallback(mBuilder.build(), mWiFiThresholdCallback);
-            mIsRegistered = true;
-        }
-    }
-
-    @VisibleForTesting
-    int getRegisteredThreshold() {
-        return mRegisteredThreshold;
-    }
-
-    private class WiFiEventsHandler extends Handler {
-        WiFiEventsHandler(Looper looper) {
-            super(looper);
-        }
-
-        @Override
-        public void handleMessage(Message msg) {
-            Log.d(mTag, "handleMessage what = " + msg.what);
-            switch (msg.what) {
-                case EVENT_WIFI_RSSI_CHANGED:
-                    Log.d(mTag, "start validating for rssi = " + msg.arg1);
-                    validateForWifiBackhaul(msg.arg1);
-                    break;
-                case EVENT_WIFI_NOTIFY_TIMER_EXPIRED:
-                    mWifiRssi = getCurrentQuality(SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI);
-                    Log.d(mTag, "Backhaul timer expired, wifi rssi = " + mWifiRssi);
-                    if (isWifiRssiValid(mWifiRssi)) {
-                        validateThresholdsAfterBackHaul(mWifiRssi);
-                    }
-                    break;
-                default:
-                    Log.d(mTag, "Not Handled !");
-            }
-        }
-    }
-
-    @VisibleForTesting
-    @Override
-    public void close() {
-        unregisterCallback();
-        mWifiRssi = SIGNAL_STRENGTH_UNSPECIFIED;
-        mIsRegistered = false;
-        mRegisteredThreshold = SIGNAL_STRENGTH_UNSPECIFIED;
-        Log.d(mTag, "closed WifiQualityMonitor");
-    }
-
-    @Override
-    void dump(PrintWriter pw, String prefix) {
-        pw.println(prefix + "------------------------------");
-        pw.println(prefix + "WifiQualityMonitor:");
-        super.dump(pw, prefix);
-        pw.println(
-                prefix
-                        + ", mIsRegistered="
-                        + mIsRegistered
-                        + ", mIsBackhaulRunning="
-                        + mIsBackhaulRunning);
-        pw.println(
-                prefix
-                        + "mWifiRssi="
-                        + mWifiRssi
-                        + ", mRegisteredThreshold="
-                        + mRegisteredThreshold);
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/atoms/AtomsQnsFallbackRestrictionChangedInfo.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/atoms/AtomsQnsFallbackRestrictionChangedInfo.java
deleted file mode 100644
index 05a2fdf..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/atoms/AtomsQnsFallbackRestrictionChangedInfo.java
+++ /dev/null
@@ -1,217 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns.atoms;
-
-import android.util.StatsEvent;
-
-import com.android.telephony.qns.stats.QnsStatsLog;
-import com.android.telephony.statslib.AtomsPushed;
-
-import java.util.Objects;
-
-/** AtomsQnsFallbackRestrictionChangedInfo class */
-public class AtomsQnsFallbackRestrictionChangedInfo extends AtomsPushed {
-
-    /** atom #1 : Restriction on WLAN caused by RTP threshold breached */
-    private boolean mRestrictionOnWlanByRtpThresholdBreached;
-
-    /** atom #2 : Restriction on WWAN caused by RTP threshold breached */
-    private boolean mRestrictionOnWwanByRtpThresholdBreached;
-
-    /** atom #3 : Restriction on WLAN caused by IMS registration fail */
-    private boolean mRestrictionOnWlanByImsRegistrationFailed;
-
-    /** atom #4 : Restriction on WLAN caused by Wi-Fi backhaul problem. */
-    private boolean mRestrictionOnWlanByWifiBackhaulProblem;
-
-    /** atom #5 : Carrier Id */
-    private int mCarrierId;
-
-    /** atom #6 : Slot Index */
-    private int mSlotIndex;
-
-    /** Constructor of AtomsQnsFallbackRestrictionChangedInfo */
-    public AtomsQnsFallbackRestrictionChangedInfo() {}
-
-    /**
-     * Constructor of AtomsQnsFallbackRestrictionChangedInfo
-     *
-     * @param restrictionOnWlanByRtpThresholdBreached Restriction on wlan caused by RTP threshold
-     *     breached
-     * @param restrictionOnWwanByRtpThresholdBreached Restriction on wwan caused by RTP threshold
-     *     breached
-     * @param restrictionOnWlanByImsRegistrationFailed Restriction on wlan caused by IMS
-     *     registration fail
-     * @param restrictionOnWlanByWifiBackhaulProblem Restriction on wlan caused by Wifi backhaul
-     *     problem.
-     * @param carrierId Carrier Id
-     * @param slotIndex Index of sim slot
-     */
-    public AtomsQnsFallbackRestrictionChangedInfo(
-            boolean restrictionOnWlanByRtpThresholdBreached,
-            boolean restrictionOnWwanByRtpThresholdBreached,
-            boolean restrictionOnWlanByImsRegistrationFailed,
-            boolean restrictionOnWlanByWifiBackhaulProblem,
-            int carrierId,
-            int slotIndex) {
-        mRestrictionOnWlanByRtpThresholdBreached = restrictionOnWlanByRtpThresholdBreached;
-        mRestrictionOnWwanByRtpThresholdBreached = restrictionOnWwanByRtpThresholdBreached;
-        mRestrictionOnWlanByImsRegistrationFailed = restrictionOnWlanByImsRegistrationFailed;
-        mRestrictionOnWlanByWifiBackhaulProblem = restrictionOnWlanByWifiBackhaulProblem;
-        mCarrierId = carrierId;
-        mSlotIndex = slotIndex;
-    }
-
-    /**
-     * Copy Constructor of AtomsQnsFallbackRestrictionChangedInfo
-     *
-     * @param info The info param to copy from.
-     */
-    public AtomsQnsFallbackRestrictionChangedInfo(AtomsQnsFallbackRestrictionChangedInfo info) {
-        mRestrictionOnWlanByRtpThresholdBreached = info.mRestrictionOnWlanByRtpThresholdBreached;
-        mRestrictionOnWwanByRtpThresholdBreached = info.mRestrictionOnWwanByRtpThresholdBreached;
-        mRestrictionOnWlanByImsRegistrationFailed = info.mRestrictionOnWlanByImsRegistrationFailed;
-        mRestrictionOnWlanByWifiBackhaulProblem = info.mRestrictionOnWlanByWifiBackhaulProblem;
-        mCarrierId = info.mCarrierId;
-        mSlotIndex = info.mSlotIndex;
-    }
-
-    /**
-     * Write the atom information to be recorded to the builder according to the type in order.
-     *
-     * @param builder Builder class for StatsEvent Builder object.
-     */
-    @Override
-    public void build(StatsEvent.Builder builder) {
-        builder.writeBoolean(mRestrictionOnWlanByRtpThresholdBreached); // atom #1
-        builder.writeBoolean(mRestrictionOnWwanByRtpThresholdBreached); // atom #2
-        builder.writeBoolean(mRestrictionOnWlanByImsRegistrationFailed); // atom #3
-        builder.writeBoolean(mRestrictionOnWlanByWifiBackhaulProblem); // atom #4
-        builder.writeInt(mCarrierId); // atom #5
-        builder.writeInt(mSlotIndex); // atom #6
-    }
-
-    /** Return atom id defined in proto. */
-    @Override
-    public int getStatsId() {
-        return QnsStatsLog.QNS_FALLBACK_RESTRICTION_CHANGED;
-    }
-
-    /** Return copy of the AtomsQnsFallbackRestrictionChangedInfo */
-    @Override
-    public AtomsPushed copy() {
-        return new AtomsQnsFallbackRestrictionChangedInfo(this);
-    }
-
-    public boolean getRestrictionOnWlanByRtpThresholdBreached() {
-        return mRestrictionOnWlanByRtpThresholdBreached;
-    }
-
-    public void setRestrictionOnWlanByRtpThresholdBreached(
-            boolean restrictionOnWlanByRtpThresholdBreached) {
-        mRestrictionOnWlanByRtpThresholdBreached = restrictionOnWlanByRtpThresholdBreached;
-    }
-
-    public boolean getRestrictionOnWwanByRtpThresholdBreached() {
-        return mRestrictionOnWwanByRtpThresholdBreached;
-    }
-
-    public void setRestrictionOnWwanByRtpThresholdBreached(
-            boolean restrictionOnWwanByRtpThresholdBreached) {
-        mRestrictionOnWwanByRtpThresholdBreached = restrictionOnWwanByRtpThresholdBreached;
-    }
-
-    public boolean getRestrictionOnWlanByImsRegistrationFailed() {
-        return mRestrictionOnWlanByImsRegistrationFailed;
-    }
-
-    public void setRestrictionOnWlanByImsRegistrationFailed(
-            boolean restrictionOnWlanByImsRegistrationFailed) {
-        mRestrictionOnWlanByImsRegistrationFailed = restrictionOnWlanByImsRegistrationFailed;
-    }
-
-    public boolean getRestrictionOnWlanByWifiBackhaulProblem() {
-        return mRestrictionOnWlanByWifiBackhaulProblem;
-    }
-
-    public void setRestrictionOnWlanByWifiBackhaulProblem(
-            boolean restrictionOnWlanByWifiBackhaulProblem) {
-        mRestrictionOnWlanByWifiBackhaulProblem = restrictionOnWlanByWifiBackhaulProblem;
-    }
-
-    public int getCarrierId() {
-        return mCarrierId;
-    }
-
-    public void setCarrierId(int carrierId) {
-        mCarrierId = carrierId;
-    }
-
-    public int getSlotIndex() {
-        return mSlotIndex;
-    }
-
-    public void setSlotIndex(int slotIndex) {
-        mSlotIndex = slotIndex;
-    }
-
-    @Override
-    public String toString() {
-        return "AtomsQnsFallbackRestrictionChangedInfo{"
-                + "mRestrictionWlanRtpThresholdBreached="
-                + mRestrictionOnWlanByRtpThresholdBreached
-                + ", mRestrictionWwanRtpThresholdBreached="
-                + mRestrictionOnWwanByRtpThresholdBreached
-                + ", mRestrictionWwanImsRegiFail="
-                + mRestrictionOnWlanByImsRegistrationFailed
-                + ", mRestrictionWwanWifiBackhaulProblem="
-                + mRestrictionOnWlanByWifiBackhaulProblem
-                + ", mCarrierId="
-                + mCarrierId
-                + ", mSlotIndex="
-                + mSlotIndex
-                + '}';
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (!(o instanceof AtomsQnsFallbackRestrictionChangedInfo)) return false;
-        AtomsQnsFallbackRestrictionChangedInfo that = (AtomsQnsFallbackRestrictionChangedInfo) o;
-        return mRestrictionOnWlanByRtpThresholdBreached
-                        == that.mRestrictionOnWlanByRtpThresholdBreached
-                && mRestrictionOnWwanByRtpThresholdBreached
-                        == that.mRestrictionOnWwanByRtpThresholdBreached
-                && mRestrictionOnWlanByImsRegistrationFailed
-                        == that.mRestrictionOnWlanByImsRegistrationFailed
-                && mRestrictionOnWlanByWifiBackhaulProblem
-                        == that.mRestrictionOnWlanByWifiBackhaulProblem
-                && mCarrierId == that.mCarrierId
-                && mSlotIndex == that.mSlotIndex;
-    }
-
-    @Override
-    public int hashCode() {
-        return Objects.hash(
-                mRestrictionOnWlanByRtpThresholdBreached,
-                mRestrictionOnWwanByRtpThresholdBreached,
-                mRestrictionOnWlanByImsRegistrationFailed,
-                mRestrictionOnWlanByWifiBackhaulProblem,
-                mCarrierId,
-                mSlotIndex);
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/atoms/AtomsQnsHandoverPingPongInfo.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/atoms/AtomsQnsHandoverPingPongInfo.java
deleted file mode 100644
index a714e58..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/atoms/AtomsQnsHandoverPingPongInfo.java
+++ /dev/null
@@ -1,159 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns.atoms;
-
-import android.util.StatsEvent;
-
-import com.android.telephony.qns.stats.QnsStatsLog;
-import com.android.telephony.statslib.AtomsPulled;
-
-import java.io.Serializable;
-import java.util.Objects;
-
-/** AtomsQnsHandoverPingPongInfo class */
-public class AtomsQnsHandoverPingPongInfo extends AtomsPulled implements Serializable {
-
-    private static final long serialVersionUID = 815898959L; // 0x30A1A14F
-
-    /** atom #1 : Count of handover ping-pong */
-    private int mCountHandoverPingPong;
-
-    /** atom #2 : Carrier Id */
-    private int mCarrierId;
-
-    /** atom #3 : Slot Index */
-    private int mSlotIndex;
-
-    /** Constructor of AtomsQnsHandoverPingPongInfo */
-    public AtomsQnsHandoverPingPongInfo() {}
-
-    /**
-     * Constructor of AtomsQnsHandoverPingPongInfo
-     *
-     * @param countHandoverPingPong count of Handover Ping-Pong
-     * @param carrierId Carrier Id
-     * @param slotIndex Index of sim slot
-     */
-    public AtomsQnsHandoverPingPongInfo(int countHandoverPingPong, int carrierId, int slotIndex) {
-        mCountHandoverPingPong = countHandoverPingPong;
-        mCarrierId = carrierId;
-        mSlotIndex = slotIndex;
-    }
-
-    /**
-     * Copy Constructor of AtomsQnsHandoverPingPongInfo
-     *
-     * @param info The info param to copy from.
-     */
-    public AtomsQnsHandoverPingPongInfo(AtomsQnsHandoverPingPongInfo info) {
-        mCountHandoverPingPong = info.mCountHandoverPingPong;
-        mCarrierId = info.mCarrierId;
-        mSlotIndex = info.mSlotIndex;
-    }
-
-    /**
-     * Write the atom information to be recorded to the builder according to the type in order.
-     *
-     * @param builder Builder class for StatsEvent Builder object.
-     */
-    @Override
-    public void build(StatsEvent.Builder builder) {
-        builder.writeInt(mCountHandoverPingPong); // atom #1
-        builder.writeInt(mCarrierId); // atom #2
-        builder.writeInt(mSlotIndex); // atom #3
-    }
-
-    /** Return atom id defined in proto. */
-    @Override
-    public int getStatsId() {
-        return QnsStatsLog.QNS_HANDOVER_PINGPONG;
-    }
-
-    /** Return copy of the AtomsQnsHandoverPingPongInfo */
-    @Override
-    public AtomsPulled copy() {
-        return new AtomsQnsHandoverPingPongInfo(this);
-    }
-
-    @Override
-    public String getDimension() {
-        return mCarrierId + "_" + mSlotIndex;
-    }
-
-    @Override
-    public void accumulate(AtomsPulled info) {
-        if (!(info instanceof AtomsQnsHandoverPingPongInfo)) {
-            return;
-        }
-        AtomsQnsHandoverPingPongInfo atomsQnsHandoverPingPongInfo =
-                (AtomsQnsHandoverPingPongInfo) info;
-        this.mCountHandoverPingPong += atomsQnsHandoverPingPongInfo.getCountHandoverPingPong();
-    }
-
-    public int getCountHandoverPingPong() {
-        return mCountHandoverPingPong;
-    }
-
-    public void setCountHandoverPingPong(int countHandoverPingPong) {
-        mCountHandoverPingPong = countHandoverPingPong;
-    }
-
-    public int getCarrierId() {
-        return mCarrierId;
-    }
-
-    public void setCarrierId(int carrierId) {
-        mCarrierId = carrierId;
-    }
-
-    public int getSlotIndex() {
-        return mSlotIndex;
-    }
-
-    public void setSlotIndex(int slotIndex) {
-        mSlotIndex = slotIndex;
-    }
-
-    @Override
-    public String toString() {
-        return "AtomsQnsHandoverPingPongInfo{"
-                + "mCountHandoverPingPong="
-                + mCountHandoverPingPong
-                + ", mCarrierId="
-                + mCarrierId
-                + ", mSlotIndex="
-                + mSlotIndex
-                + '}';
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (!(o instanceof AtomsQnsHandoverPingPongInfo)) return false;
-        AtomsQnsHandoverPingPongInfo that = (AtomsQnsHandoverPingPongInfo) o;
-        return mCountHandoverPingPong == that.mCountHandoverPingPong
-                && mCarrierId == that.mCarrierId
-                && mSlotIndex == that.mSlotIndex;
-    }
-
-    @Override
-    public int hashCode() {
-        return Objects.hash(mCountHandoverPingPong, mCarrierId, mSlotIndex);
-    }
-
-    public static long PING_PONG_TIME_IN_MILLIS = 5000L;
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/atoms/AtomsQnsHandoverTimeMillisInfo.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/atoms/AtomsQnsHandoverTimeMillisInfo.java
deleted file mode 100644
index e6924ac..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/atoms/AtomsQnsHandoverTimeMillisInfo.java
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns.atoms;
-
-import android.util.StatsEvent;
-
-import com.android.telephony.qns.stats.QnsStatsLog;
-import com.android.telephony.statslib.AtomsPulled;
-
-import java.io.Serializable;
-import java.util.Objects;
-
-/** AtomsQnsHandoverTimeMillisInfo class */
-public class AtomsQnsHandoverTimeMillisInfo extends AtomsPulled implements Serializable {
-
-    private static final long serialVersionUID = 1379441656L; // 0x52389BF8
-
-    /** atom #1 : Time in milliseconds from QNS RAT update to successful HO completion */
-    private int mTimeForHoSuccess;
-
-    /** atom #2 : Slot Index */
-    private int mSlotIndex;
-
-    /** Constructor of AtomsQnsHandoverTimeMillisInfo */
-    public AtomsQnsHandoverTimeMillisInfo() {}
-
-    /**
-     * Constructor of AtomsQnsHandoverTimeMillisInfo
-     *
-     * @param timeForHoSuccess Time in milliseconds from QNS RAT update to successful HO completion
-     * @param slotIndex Index of sim slot
-     */
-    public AtomsQnsHandoverTimeMillisInfo(int timeForHoSuccess, int slotIndex) {
-        mTimeForHoSuccess = timeForHoSuccess;
-        mSlotIndex = slotIndex;
-    }
-
-    /**
-     * Copy Constructor of AtomsQnsHandoverTimeMillisInfo
-     *
-     * @param info The info param to copy from.
-     */
-    public AtomsQnsHandoverTimeMillisInfo(AtomsQnsHandoverTimeMillisInfo info) {
-        mTimeForHoSuccess = info.mTimeForHoSuccess;
-        mSlotIndex = info.mSlotIndex;
-    }
-
-    /**
-     * Write the atom information to be recorded to the builder according to the type in order.
-     *
-     * @param builder Builder class for StatsEvent Builder object.
-     */
-    @Override
-    public void build(StatsEvent.Builder builder) {
-        builder.writeInt(mTimeForHoSuccess); // atom #1
-        builder.writeInt(mSlotIndex); // atom #2
-    }
-
-    /** Return atom id defined in proto. */
-    @Override
-    public int getStatsId() {
-        return QnsStatsLog.QNS_HANDOVER_TIME_MILLIS;
-    }
-
-    /** Return copy of the AtomsQnsHandoverTimeMillisInfo */
-    @Override
-    public AtomsPulled copy() {
-        return new AtomsQnsHandoverTimeMillisInfo(this);
-    }
-
-    @Override
-    public String getDimension() {
-        return Integer.toString(mSlotIndex);
-    }
-
-    @Override
-    public void accumulate(AtomsPulled info) {
-        if (!(info instanceof AtomsQnsRatPreferenceMismatchInfo)) {
-            return;
-        }
-        AtomsQnsHandoverTimeMillisInfo atomsQnsHandoverTimeMillisInfo =
-                (AtomsQnsHandoverTimeMillisInfo) info;
-        this.mTimeForHoSuccess += atomsQnsHandoverTimeMillisInfo.getTimeForHoSuccess();
-    }
-
-    public int getTimeForHoSuccess() {
-        return mTimeForHoSuccess;
-    }
-
-    public void setTimeForHoSuccess(int timeForHoSuccess) {
-        mTimeForHoSuccess = timeForHoSuccess;
-    }
-
-    public int getSlotIndex() {
-        return mSlotIndex;
-    }
-
-    public void setSlotIndex(int slotIndex) {
-        mSlotIndex = slotIndex;
-    }
-
-    @Override
-    public String toString() {
-        return "AtomsQnsHandoverTimeMillisInfo{" + "mTimeForHoSuccess=" + mTimeForHoSuccess + '}';
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (!(o instanceof AtomsQnsHandoverTimeMillisInfo)) return false;
-        AtomsQnsHandoverTimeMillisInfo that = (AtomsQnsHandoverTimeMillisInfo) o;
-        return mTimeForHoSuccess == that.mTimeForHoSuccess && mSlotIndex == that.mSlotIndex;
-    }
-
-    @Override
-    public int hashCode() {
-        return Objects.hash(mTimeForHoSuccess, mSlotIndex);
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/atoms/AtomsQnsImsCallDropStats.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/atoms/AtomsQnsImsCallDropStats.java
deleted file mode 100644
index 991bce4..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/atoms/AtomsQnsImsCallDropStats.java
+++ /dev/null
@@ -1,265 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns.atoms;
-
-import android.util.StatsEvent;
-
-import com.android.telephony.qns.stats.QnsStatsLog;
-import com.android.telephony.statslib.AtomsPushed;
-
-import java.util.Objects;
-
-/** AtomsQnsImsCallDropStats class */
-public class AtomsQnsImsCallDropStats extends AtomsPushed {
-
-    /** atom #1 : Transport type in where IMS call drop occurred. */
-    private int mTransportTypeCallDropped;
-
-    /** atom #2 : RTP threshold breached event occurred. */
-    private boolean mRtpThresholdBreached;
-
-    /** atom #3 : Bit mask of restrictions on another transport type */
-    private int mRestrictionsOnOtherTransportType;
-
-    /** atom #4 : Cellular network signal strength {e.g. SSRSRP in NR, RSRP in LTE} */
-    private int mSignalStrength;
-
-    /** atom #5 : Cellular network signal quality {e.g. SSRSRQ in NR, RSRQ in LTE} */
-    private int mSignalQuality;
-
-    /** atom #6 : Cellular network signal noise ratio {e.g. SSSINR in NR, RSSNR in LTE} */
-    private int mSignalNoise;
-
-    /** atom #7 : Iwlan network signal strength (Wi-Fi RSSI) */
-    private int mIwlanSignalStrength;
-
-    /** atom #8 : Slot Index */
-    private int mSlotIndex;
-
-    /** atom #9 : cellular access network type. */
-    private int mCellularNetworkType;
-
-    /** Constructor of AtomsQnsImsCallDropStats */
-    public AtomsQnsImsCallDropStats() {}
-
-    /**
-     * Write the atom information to be recorded to the builder according to the type in order.
-     *
-     * @param builder Builder class for StatsEvent Builder object.
-     */
-    @Override
-    public void build(StatsEvent.Builder builder) {
-        builder.writeInt(mTransportTypeCallDropped); // atom #1
-        builder.writeBoolean(mRtpThresholdBreached); // atom #2
-        builder.writeInt(mRestrictionsOnOtherTransportType); // atom #3
-        builder.writeInt(mSignalStrength); // atom #4
-        builder.writeInt(mSignalQuality); // atom #5
-        builder.writeInt(mSignalNoise); // atom #6
-        builder.writeInt(mIwlanSignalStrength); // atom #7
-        builder.writeInt(mSlotIndex); // atom #8
-        builder.writeInt(mCellularNetworkType); // atom #9
-    }
-
-    /** Return atom id defined in proto. */
-    @Override
-    public int getStatsId() {
-        return QnsStatsLog.QNS_IMS_CALL_DROP_STATS;
-    }
-
-    /** Return copy of the AtomsQnsImsCallDropStats */
-    @Override
-    public AtomsPushed copy() {
-        return new AtomsQnsImsCallDropStats(this);
-    }
-
-    /**
-     * Constructor of AtomsQnsImsCallDropStats
-     *
-     * @param transportTypeCallDropped Transport type in where IMS call drop occurred.
-     * @param rtpThresholdBreached RTP threshold breached event occurred.
-     * @param restrictionsOnOtherTransportType Bit mask of restrictions on another transport type.
-     * @param signalStrength Cellular network signal strength.
-     * @param signalQuality Cellular network signal quality.
-     * @param signalNoise Cellular network signal noise ratio.
-     * @param iwlanSignalStrength Wi-Fi network signal strength.
-     * @param slotIndex Index of sim slot.
-     * @param cellularNetworkType cellular access network type.
-     */
-    public AtomsQnsImsCallDropStats(
-            int transportTypeCallDropped,
-            boolean rtpThresholdBreached,
-            int restrictionsOnOtherTransportType,
-            int signalStrength,
-            int signalQuality,
-            int signalNoise,
-            int iwlanSignalStrength,
-            int slotIndex,
-            int cellularNetworkType) {
-        mTransportTypeCallDropped = transportTypeCallDropped;
-        mRtpThresholdBreached = rtpThresholdBreached;
-        mRestrictionsOnOtherTransportType = restrictionsOnOtherTransportType;
-        mSignalStrength = signalStrength;
-        mSignalQuality = signalQuality;
-        mSignalNoise = signalNoise;
-        mIwlanSignalStrength = iwlanSignalStrength;
-        mSlotIndex = slotIndex;
-        mCellularNetworkType = cellularNetworkType;
-    }
-
-    /**
-     * Copy Constructor of AtomsQnsImsCallDropStats
-     *
-     * @param info The info param to copy from.
-     */
-    public AtomsQnsImsCallDropStats(AtomsQnsImsCallDropStats info) {
-        mTransportTypeCallDropped = info.mTransportTypeCallDropped;
-        mRtpThresholdBreached = info.mRtpThresholdBreached;
-        mRestrictionsOnOtherTransportType = info.mRestrictionsOnOtherTransportType;
-        mSignalStrength = info.mSignalStrength;
-        mSignalQuality = info.mSignalQuality;
-        mSignalNoise = info.mSignalNoise;
-        mIwlanSignalStrength = info.mIwlanSignalStrength;
-        mSlotIndex = info.mSlotIndex;
-        mCellularNetworkType = info.mCellularNetworkType;
-    }
-
-    public int getTransportTypeCallDropped() {
-        return mTransportTypeCallDropped;
-    }
-
-    public void setTransportTypeCallDropped(int transportTypeCallDropped) {
-        mTransportTypeCallDropped = transportTypeCallDropped;
-    }
-
-    public boolean getRtpThresholdBreached() {
-        return mRtpThresholdBreached;
-    }
-
-    public void setRtpThresholdBreached(boolean rtpThresholdBreached) {
-        mRtpThresholdBreached = rtpThresholdBreached;
-    }
-
-    public int getRestrictionsOnOtherTransportType() {
-        return mRestrictionsOnOtherTransportType;
-    }
-
-    public void setRestrictionsOnOtherTransportType(int restrictionsOnOtherTransportType) {
-        mRestrictionsOnOtherTransportType = restrictionsOnOtherTransportType;
-    }
-
-    public int getSignalStrength() {
-        return mSignalStrength;
-    }
-
-    public void setSignalStrength(int signalStrength) {
-        mSignalStrength = signalStrength;
-    }
-
-    public int getSignalQuality() {
-        return mSignalQuality;
-    }
-
-    public void setSignalQuality(int signalQuality) {
-        mSignalQuality = signalQuality;
-    }
-
-    public int getSignalNoise() {
-        return mSignalNoise;
-    }
-
-    public void setSignalNoise(int signalNoise) {
-        mSignalNoise = signalNoise;
-    }
-
-    public int getIwlanSignalStrength() {
-        return mIwlanSignalStrength;
-    }
-
-    public void setIwlanSignalStrength(int iwlanSignalStrength) {
-        mIwlanSignalStrength = iwlanSignalStrength;
-    }
-
-    public int getSlotIndex() {
-        return mSlotIndex;
-    }
-
-    public void setSlotIndex(int slotIndex) {
-        mSlotIndex = slotIndex;
-    }
-
-    public int getCellularNetworkType() {
-        return mCellularNetworkType;
-    }
-
-    public void setCellularNetworkType(int cellularNetworkType) {
-        mCellularNetworkType = cellularNetworkType;
-    }
-
-    @Override
-    public String toString() {
-        return "AtomsQnsImsCallDropStats{"
-                + "mTransportTypeCallDropped="
-                + mTransportTypeCallDropped
-                + ", mRtpThresholdBreached="
-                + mRtpThresholdBreached
-                + ", mRestrictionsOnOtherTransportType="
-                + mRestrictionsOnOtherTransportType
-                + ", mSignalStrength="
-                + mSignalStrength
-                + ", mSignalQuality="
-                + mSignalQuality
-                + ", mSignalNoise="
-                + mSignalNoise
-                + ", mIwlanSignalStrength="
-                + mIwlanSignalStrength
-                + ", mSlotIndex="
-                + mSlotIndex
-                + ", mCellularNetworkType="
-                + mCellularNetworkType
-                + '}';
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (!(o instanceof AtomsQnsImsCallDropStats)) return false;
-        AtomsQnsImsCallDropStats that = (AtomsQnsImsCallDropStats) o;
-        return mTransportTypeCallDropped == that.mTransportTypeCallDropped
-                && mRtpThresholdBreached == that.mRtpThresholdBreached
-                && mRestrictionsOnOtherTransportType == that.mRestrictionsOnOtherTransportType
-                && mSignalStrength == that.mSignalStrength
-                && mSignalQuality == that.mSignalQuality
-                && mSignalNoise == that.mSignalNoise
-                && mIwlanSignalStrength == that.mIwlanSignalStrength
-                && mSlotIndex == that.mSlotIndex
-                && mCellularNetworkType == that.mCellularNetworkType;
-    }
-
-    @Override
-    public int hashCode() {
-        return Objects.hash(
-                mTransportTypeCallDropped,
-                mRtpThresholdBreached,
-                mRestrictionsOnOtherTransportType,
-                mSignalStrength,
-                mSignalQuality,
-                mSignalNoise,
-                mIwlanSignalStrength,
-                mSlotIndex,
-                mCellularNetworkType);
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/atoms/AtomsQnsRatPreferenceMismatchInfo.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/atoms/AtomsQnsRatPreferenceMismatchInfo.java
deleted file mode 100644
index 150f6a1..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/atoms/AtomsQnsRatPreferenceMismatchInfo.java
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns.atoms;
-
-import android.util.StatsEvent;
-
-import com.android.telephony.qns.stats.QnsStatsLog;
-import com.android.telephony.statslib.AtomsPulled;
-
-import java.io.Serializable;
-import java.util.Objects;
-
-/** AtomsQnsRatPreferenceMismatchInfo class */
-public class AtomsQnsRatPreferenceMismatchInfo extends AtomsPulled implements Serializable {
-
-    private static final long serialVersionUID = 1913485192L; // 0x720D7788
-
-    /** atom #1 : Net capability of this information. */
-    private int mNetCapability;
-
-    /** atom #2 : Count of handover failed. */
-    private int mHandoverFailCount;
-
-    /** atom #3 : Duration of this mismatch. */
-    private int mDurationOfMismatch;
-
-    /** atom #4 : Carrier Id */
-    private int mCarrierId;
-
-    /** atom #5 : Slot Index */
-    private int mSlotIndex;
-
-    /** Constructor of AtomsQnsRatPreferenceMismatchInfo */
-    public AtomsQnsRatPreferenceMismatchInfo() {}
-
-    /**
-     * Constructor of AtomsQnsRatPreferenceMismatchInfo
-     *
-     * @param netCapability Net capability of this information.
-     * @param handoverFailCount Count of handover failed.
-     * @param durationOfMismatch Duration of this mismatch.
-     * @param carrierId Carrier Id
-     * @param slotIndex Index of sim slot
-     */
-    public AtomsQnsRatPreferenceMismatchInfo(
-            int netCapability,
-            int handoverFailCount,
-            int durationOfMismatch,
-            int carrierId,
-            int slotIndex) {
-        mNetCapability = netCapability;
-        mHandoverFailCount = handoverFailCount;
-        mDurationOfMismatch = durationOfMismatch;
-        mCarrierId = carrierId;
-        mSlotIndex = slotIndex;
-    }
-
-    /**
-     * Copy Constructor of AtomsQnsRatPreferenceMismatchInfo
-     *
-     * @param info The info param to copy from.
-     */
-    public AtomsQnsRatPreferenceMismatchInfo(AtomsQnsRatPreferenceMismatchInfo info) {
-        mNetCapability = info.mNetCapability;
-        mHandoverFailCount = info.mHandoverFailCount;
-        mDurationOfMismatch = info.mDurationOfMismatch;
-        mCarrierId = info.mCarrierId;
-        mSlotIndex = info.mSlotIndex;
-    }
-
-    /**
-     * Write the atom information to be recorded to the builder according to the type in order.
-     *
-     * @param builder Builder class for StatsEvent Builder object.
-     */
-    @Override
-    public void build(StatsEvent.Builder builder) {
-        builder.writeInt(mNetCapability); // atom #1
-        builder.writeInt(mHandoverFailCount); // atom #2
-        builder.writeInt(mDurationOfMismatch); // atom #3
-        builder.writeInt(mCarrierId); // atom #4
-        builder.writeInt(mSlotIndex); // atom #5
-    }
-
-    /** Return atom id defined in proto. */
-    @Override
-    public int getStatsId() {
-        return QnsStatsLog.QNS_RAT_PREFERENCE_MISMATCH_INFO;
-    }
-
-    /** Return copy of the AtomsQnsRatPreferenceMismatchInfo */
-    @Override
-    public AtomsPulled copy() {
-        return new AtomsQnsRatPreferenceMismatchInfo(this);
-    }
-
-    @Override
-    public String getDimension() {
-        return mNetCapability + "_" + mCarrierId + "_" + mSlotIndex;
-    }
-
-    @Override
-    public void accumulate(AtomsPulled info) {
-        if (!(info instanceof AtomsQnsRatPreferenceMismatchInfo)) {
-            return;
-        }
-        AtomsQnsRatPreferenceMismatchInfo atomsQnsRatPreferenceMismatchInfo =
-                (AtomsQnsRatPreferenceMismatchInfo) info;
-        this.mDurationOfMismatch += atomsQnsRatPreferenceMismatchInfo.getDurationOfMismatch();
-        this.mHandoverFailCount += atomsQnsRatPreferenceMismatchInfo.getHandoverFailCount();
-    }
-
-    public int getNetCapability() {
-        return mNetCapability;
-    }
-
-    public void setNetCapability(int netCapability) {
-        mNetCapability = netCapability;
-    }
-
-    public int getHandoverFailCount() {
-        return mHandoverFailCount;
-    }
-
-    public void setHandoverFailCount(int handoverFailCount) {
-        mHandoverFailCount = handoverFailCount;
-    }
-
-    public int getDurationOfMismatch() {
-        return mDurationOfMismatch;
-    }
-
-    public void setDurationOfMismatch(int durationOfMismatch) {
-        mDurationOfMismatch = durationOfMismatch;
-    }
-
-    public int getCarrierId() {
-        return mCarrierId;
-    }
-
-    public void setCarrierId(int carrierId) {
-        mCarrierId = carrierId;
-    }
-
-    public int getSlotIndex() {
-        return mSlotIndex;
-    }
-
-    public void setSlotIndex(int slotIndex) {
-        mSlotIndex = slotIndex;
-    }
-
-    @Override
-    public String toString() {
-        return "AtomsQnsRatPreferenceMismatchInfo{"
-                + "mNetCapability="
-                + mNetCapability
-                + ", mHandoverFailCount="
-                + mHandoverFailCount
-                + ", mDurationOfMismatch="
-                + mDurationOfMismatch
-                + ", mCarrierId="
-                + mCarrierId
-                + ", mSlotIndex="
-                + mSlotIndex
-                + '}';
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (!(o instanceof AtomsQnsRatPreferenceMismatchInfo)) return false;
-        AtomsQnsRatPreferenceMismatchInfo that = (AtomsQnsRatPreferenceMismatchInfo) o;
-        return mNetCapability == that.mNetCapability
-                && mHandoverFailCount == that.mHandoverFailCount
-                && mDurationOfMismatch == that.mDurationOfMismatch
-                && mCarrierId == that.mCarrierId
-                && mSlotIndex == that.mSlotIndex;
-    }
-
-    @Override
-    public int hashCode() {
-        return Objects.hash(
-                mNetCapability, mHandoverFailCount, mDurationOfMismatch, mCarrierId, mSlotIndex);
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/atoms/AtomsQualifiedRatListChangedInfo.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/atoms/AtomsQualifiedRatListChangedInfo.java
deleted file mode 100644
index ea3ec6b..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/atoms/AtomsQualifiedRatListChangedInfo.java
+++ /dev/null
@@ -1,430 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns.atoms;
-
-import android.util.StatsEvent;
-
-import com.android.telephony.qns.stats.QnsStatsLog;
-import com.android.telephony.statslib.AtomsPushed;
-
-import java.util.Objects;
-
-/** AtomsQualifiedRatListChangedInfo class */
-public class AtomsQualifiedRatListChangedInfo extends AtomsPushed {
-
-    /** atom #1 : NetCapability of this Qualified RAT update */
-    private int mNetCapability;
-    /** atom #2 : The most preferred qualified RAT */
-    private int mFirstQualifiedRat;
-    /** atom #3 : Second preferred qualified RAT */
-    private int mSecondQualifiedRat;
-    /** atom #4 : Current actual transport type of Data session for this NetCapability */
-    private int mCurrentTransportType;
-    /** atom #5 : Indicates whether WFC is enabled */
-    private boolean mWfcEnabled;
-    /** atom #6 : Indicates the user's WFC mode */
-    private int mWfcMode;
-    /** atom #7 : Current Cellular AccessNetwork Type */
-    private int mCellularNetworkType;
-    /** atom #8 : Available IWLAN AccessNetwork */
-    private int mIwlanNetworkType;
-    /** atom #9 : Bit mask of restrictions on WWAN */
-    private int mRestrictionsOnWwan;
-    /** atom #10 : Bit mask of restrictions on WLAN */
-    private int mRestrictionsOnWlan;
-    /** atom #11 : Cellular network signal strength {e.g. SSRSRP in NR, RSRP in LTE} */
-    private int mSignalStrength;
-    /** atom #12 : Cellular network signal quality {e.g. SSRSRQ in NR, RSRQ in LTE} */
-    private int mSignalQuality;
-    /** atom #13 : Cellular network signal noise ratio {e.g. SSSINR in NR, RSSNR in LTE} */
-    private int mSignalNoise;
-    /** atom #14 : Iwlan network signal strength (Wi-Fi RSSI) */
-    private int mIwlanSignalStrength;
-    /** atom #15 : Reason for preferred RAT update */
-    private int mUpdateReason;
-    /** atom #16: IMS Call Type */
-    private int mImsCallType;
-    /** atom #17 : IMS Call Quality */
-    private int mImsCallQuality;
-    /** atom #18 : Slot Index */
-    private int mSlotIndex;
-
-    /** Constructor of AtomsQualifiedRatListChangedInfo */
-    public AtomsQualifiedRatListChangedInfo() {}
-
-    /**
-     * Constructor of AtomsQualifiedRatListChangedInfo
-     *
-     * @param netCapability NetCapability of this Qualified RAT update
-     * @param firstQualifiedRat The most preferred qualified RAT
-     * @param secondQualifiedRat Second preferred qualified RAT
-     * @param currentTransportType Current actual transport type of Data session for this
-     *     NetCapability
-     * @param wfcEnabled Indicates whether WFC is enabled
-     * @param wfcMode Indicates the user's WFC mode
-     * @param cellularNetworkType Current Cellular AccessNetwork Type
-     * @param iwlanNetworkType Available IWLAN AccessNetwork
-     * @param restrictionsOnWwan Bit mask of restrictions on WWAN
-     * @param restrictionsOnWlan Bit mask of restrictions on WLAN
-     * @param signalStrength Cellular network signal strength {e.g. SSRSRP in NR, RSRP in LTE, RSCP
-     *     in UMTS}
-     * @param signalQuality Cellular network signal quality {e.g. SSRSRQ in NR, RSRQ in LTE}
-     * @param signalNoise Cellular network signal noise ratio {e.g. SSSINR in NR, RSSNR in LTE}
-     * @param iwlanSignalStrength Iwlan network signal strength (Wi-Fi RSSI)
-     * @param updateReason Reason for preferred RAT update
-     * @param imsCallType Ims Call Type {e.g. IDLE, VOICE, VIDEO, E-CALL}
-     * @param imsCallQuality Ims Call Quality
-     * @param slotIndex Index of sim slot
-     */
-    public AtomsQualifiedRatListChangedInfo(
-            int netCapability,
-            int firstQualifiedRat,
-            int secondQualifiedRat,
-            int currentTransportType,
-            boolean wfcEnabled,
-            int wfcMode,
-            int cellularNetworkType,
-            int iwlanNetworkType,
-            int restrictionsOnWwan,
-            int restrictionsOnWlan,
-            int signalStrength,
-            int signalQuality,
-            int signalNoise,
-            int iwlanSignalStrength,
-            int updateReason,
-            int imsCallType,
-            int imsCallQuality,
-            int slotIndex) {
-        mNetCapability = netCapability;
-        mFirstQualifiedRat = firstQualifiedRat;
-        mSecondQualifiedRat = secondQualifiedRat;
-        mCurrentTransportType = currentTransportType;
-        mWfcEnabled = wfcEnabled;
-        mWfcMode = wfcMode;
-        mCellularNetworkType = cellularNetworkType;
-        mIwlanNetworkType = iwlanNetworkType;
-        mRestrictionsOnWwan = restrictionsOnWwan;
-        mRestrictionsOnWlan = restrictionsOnWlan;
-        mSignalStrength = signalStrength;
-        mSignalQuality = signalQuality;
-        mSignalNoise = signalNoise;
-        mIwlanSignalStrength = iwlanSignalStrength;
-        mUpdateReason = updateReason;
-        mImsCallType = imsCallType;
-        mImsCallQuality = imsCallQuality;
-        mSlotIndex = slotIndex;
-    }
-
-    /**
-     * Copy Constructor of AtomsQualifiedRatListChangedInfo
-     *
-     * @param info The info param to copy from.
-     */
-    public AtomsQualifiedRatListChangedInfo(AtomsQualifiedRatListChangedInfo info) {
-        mNetCapability = info.mNetCapability;
-        mFirstQualifiedRat = info.mFirstQualifiedRat;
-        mSecondQualifiedRat = info.mSecondQualifiedRat;
-        mCurrentTransportType = info.mCurrentTransportType;
-        mWfcEnabled = info.mWfcEnabled;
-        mWfcMode = info.mWfcMode;
-        mCellularNetworkType = info.mCellularNetworkType;
-        mIwlanNetworkType = info.mIwlanNetworkType;
-        mRestrictionsOnWwan = info.mRestrictionsOnWwan;
-        mRestrictionsOnWlan = info.mRestrictionsOnWlan;
-        mSignalStrength = info.mSignalStrength;
-        mSignalQuality = info.mSignalQuality;
-        mSignalNoise = info.mSignalNoise;
-        mIwlanSignalStrength = info.mIwlanSignalStrength;
-        mUpdateReason = info.mUpdateReason;
-        mImsCallType = info.mImsCallType;
-        mImsCallQuality = info.mImsCallQuality;
-        mSlotIndex = info.mSlotIndex;
-    }
-
-    /**
-     * Write the atom information to be recorded to the builder according to the type in order.
-     *
-     * @param builder Builder class for StatsEvent Builder object.
-     */
-    @Override
-    public void build(StatsEvent.Builder builder) {
-        builder.writeInt(mNetCapability); // atom #1
-        builder.writeInt(mFirstQualifiedRat); // atom #2
-        builder.writeInt(mSecondQualifiedRat); // atom #3
-        builder.writeInt(mCurrentTransportType); // atom #4
-        builder.writeBoolean(mWfcEnabled); // atom #5
-        builder.writeInt(mWfcMode); // atom #6
-        builder.writeInt(mCellularNetworkType); // atom #7
-        builder.writeInt(mIwlanNetworkType); // atom #8
-        builder.writeInt(mRestrictionsOnWwan); // atom #9
-        builder.writeInt(mRestrictionsOnWlan); // atom #10
-        builder.writeInt(mSignalStrength); // atom #11
-        builder.writeInt(mSignalQuality); // atom #12
-        builder.writeInt(mSignalNoise); // atom #13
-        builder.writeInt(mIwlanSignalStrength); // atom #14
-        builder.writeInt(mUpdateReason); // atom #15
-        builder.writeInt(mImsCallType); // atom #16
-        builder.writeInt(mImsCallQuality); // atom #17
-        builder.writeInt(mSlotIndex); // atom #18
-    }
-
-    /** Return atom id defined in proto. */
-    @Override
-    public int getStatsId() {
-        return QnsStatsLog.QUALIFIED_RAT_LIST_CHANGED;
-    }
-
-    /** Return copy of the AtomsQualifiedRatListChangedInfo */
-    @Override
-    public AtomsPushed copy() {
-        return new AtomsQualifiedRatListChangedInfo(this);
-    }
-
-    public int getNetCapability() {
-        return mNetCapability;
-    }
-
-    public void setNetCapability(int netCapability) {
-        mNetCapability = netCapability;
-    }
-
-    public int getFirstQualifiedRat() {
-        return mFirstQualifiedRat;
-    }
-
-    public void setFirstQualifiedRat(int firstQualifiedRat) {
-        mFirstQualifiedRat = firstQualifiedRat;
-    }
-
-    public int getSecondQualifiedRat() {
-        return mSecondQualifiedRat;
-    }
-
-    public void setSecondQualifiedRat(int secondQualifiedRat) {
-        mSecondQualifiedRat = secondQualifiedRat;
-    }
-
-    public int getCurrentTransportType() {
-        return mCurrentTransportType;
-    }
-
-    public void setCurrentTransportType(int currentTransportType) {
-        mCurrentTransportType = currentTransportType;
-    }
-
-    public boolean getWfcEnabled() {
-        return mWfcEnabled;
-    }
-
-    public void setWfcEnabled(boolean wfcEnabled) {
-        mWfcEnabled = wfcEnabled;
-    }
-
-    public int getWfcMode() {
-        return mWfcMode;
-    }
-
-    public void setWfcMode(int wfcMode) {
-        mWfcMode = wfcMode;
-    }
-
-    public int getCellularNetworkType() {
-        return mCellularNetworkType;
-    }
-
-    public void setCellularNetworkType(int cellularNetworkType) {
-        mCellularNetworkType = cellularNetworkType;
-    }
-
-    public int getIwlanNetworkType() {
-        return mIwlanNetworkType;
-    }
-
-    public void setIwlanNetworkType(int iwlanNetworkType) {
-        mIwlanNetworkType = iwlanNetworkType;
-    }
-
-    public int getRestrictionsOnWwan() {
-        return mRestrictionsOnWwan;
-    }
-
-    public void setRestrictionsOnWwan(int restrictionsOnWwan) {
-        mRestrictionsOnWwan = restrictionsOnWwan;
-    }
-
-    public int getRestrictionsOnWlan() {
-        return mRestrictionsOnWlan;
-    }
-
-    public void setRestrictionsOnWlan(int restrictionsOnWlan) {
-        mRestrictionsOnWlan = restrictionsOnWlan;
-    }
-
-    public int getSignalStrength() {
-        return mSignalStrength;
-    }
-
-    public void setSignalStrength(int signalStrength) {
-        mSignalStrength = signalStrength;
-    }
-
-    public int getSignalQuality() {
-        return mSignalQuality;
-    }
-
-    public void setSignalQuality(int signalQuality) {
-        mSignalQuality = signalQuality;
-    }
-
-    public int getSignalNoise() {
-        return mSignalNoise;
-    }
-
-    public void setSignalNoise(int signalNoise) {
-        mSignalNoise = signalNoise;
-    }
-
-    public int getIwlanSignalStrength() {
-        return mIwlanSignalStrength;
-    }
-
-    public void setIwlanSignalStrength(int iwlanSignalStrength) {
-        mIwlanSignalStrength = iwlanSignalStrength;
-    }
-
-    public int getUpdateReason() {
-        return mUpdateReason;
-    }
-
-    public void setUpdateReason(int updateReason) {
-        mUpdateReason = updateReason;
-    }
-
-    public int getImsCallType() {
-        return mImsCallType;
-    }
-
-    public void setImsCallType(int imsCallType) {
-        mImsCallType = imsCallType;
-    }
-
-    public int getImsCallQuality() {
-        return mImsCallQuality;
-    }
-
-    public void setImsCallQuality(int imsCallQuality) {
-        mImsCallQuality = imsCallQuality;
-    }
-
-    public int getSlotIndex() {
-        return mSlotIndex;
-    }
-
-    public void setSlotIndex(int slotIndex) {
-        mSlotIndex = slotIndex;
-    }
-
-    @Override
-    public String toString() {
-        return "AtomsQualifiedRatListChangedInfo{"
-                + "mNetCapability="
-                + mNetCapability
-                + ", mFirstQualifiedRat="
-                + mFirstQualifiedRat
-                + ", mSecondQualifiedRat="
-                + mSecondQualifiedRat
-                + ", mCurrentTransportType="
-                + mCurrentTransportType
-                + ", mWfcEnabled="
-                + mWfcEnabled
-                + ", mWfcMode="
-                + mWfcMode
-                + ", mCellularNetworkType="
-                + mCellularNetworkType
-                + ", mIwlanNetworkType="
-                + mIwlanNetworkType
-                + ", mRestrictionsOnWwan="
-                + mRestrictionsOnWwan
-                + ", mRestrictionsOnWlan="
-                + mRestrictionsOnWlan
-                + ", mSignalStrength="
-                + mSignalStrength
-                + ", mSignalQuality="
-                + mSignalQuality
-                + ", mSignalNoise="
-                + mSignalNoise
-                + ", mIwlanSignalStrength="
-                + mIwlanSignalStrength
-                + ", mUpdateReason="
-                + mUpdateReason
-                + ", mImsCallType="
-                + mImsCallType
-                + ", mImsCallQuality="
-                + mImsCallQuality
-                + ", mSlotIndex="
-                + mSlotIndex
-                + '}';
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (!(o instanceof AtomsQualifiedRatListChangedInfo)) return false;
-        AtomsQualifiedRatListChangedInfo that = (AtomsQualifiedRatListChangedInfo) o;
-        return mNetCapability == that.mNetCapability
-                && mFirstQualifiedRat == that.mFirstQualifiedRat
-                && mSecondQualifiedRat == that.mSecondQualifiedRat
-                && mCurrentTransportType == that.mCurrentTransportType
-                && mWfcEnabled == that.mWfcEnabled
-                && mWfcMode == that.mWfcMode
-                && mCellularNetworkType == that.mCellularNetworkType
-                && mIwlanNetworkType == that.mIwlanNetworkType
-                && mRestrictionsOnWwan == that.mRestrictionsOnWwan
-                && mRestrictionsOnWlan == that.mRestrictionsOnWlan
-                && mSignalStrength == that.mSignalStrength
-                && mSignalQuality == that.mSignalQuality
-                && mSignalNoise == that.mSignalNoise
-                && mIwlanSignalStrength == that.mIwlanSignalStrength
-                && mUpdateReason == that.mUpdateReason
-                && mImsCallType == that.mImsCallType
-                && mImsCallQuality == that.mImsCallQuality
-                && mSlotIndex == that.mSlotIndex;
-    }
-
-    @Override
-    public int hashCode() {
-        return Objects.hash(
-                mNetCapability,
-                mFirstQualifiedRat,
-                mSecondQualifiedRat,
-                mCurrentTransportType,
-                mWfcEnabled,
-                mWfcMode,
-                mCellularNetworkType,
-                mIwlanNetworkType,
-                mRestrictionsOnWwan,
-                mRestrictionsOnWlan,
-                mSignalStrength,
-                mSignalQuality,
-                mSignalNoise,
-                mIwlanSignalStrength,
-                mUpdateReason,
-                mImsCallType,
-                mImsCallQuality,
-                mSlotIndex);
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/wfc/WfcActivationActivity.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/wfc/WfcActivationActivity.java
deleted file mode 100644
index b53fed0..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/wfc/WfcActivationActivity.java
+++ /dev/null
@@ -1,349 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.telephony.qns.wfc;
-
-import android.app.Activity;
-import android.app.AlertDialog;
-import android.app.Dialog;
-import android.app.ProgressDialog;
-import android.annotation.Nullable;
-import android.content.ComponentName;
-import android.content.DialogInterface.OnClickListener;
-import android.content.Intent;
-import android.net.Uri;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Message;
-import android.provider.Settings;
-import android.text.TextUtils;
-import android.util.Log;
-import android.view.ContextThemeWrapper;
-import android.view.WindowManager;
-
-import androidx.activity.result.ActivityResultLauncher;
-import androidx.activity.result.contract.ActivityResultContracts.StartActivityForResult;
-import androidx.browser.customtabs.CustomTabsClient;
-import androidx.browser.customtabs.CustomTabsIntent;
-import androidx.browser.customtabs.CustomTabsServiceConnection;
-import androidx.browser.customtabs.CustomTabsSession;
-import androidx.fragment.app.DialogFragment;
-import androidx.fragment.app.FragmentActivity;
-
-import com.android.internal.annotations.VisibleForTesting;
-import com.android.telephony.qns.R;
-
-/** Main activity to handle VoWiFi activation */
-public class WfcActivationActivity extends FragmentActivity {
-
-    public static final String TAG = "QNS-WfcActivationActivity";
-
-    private static final String EXTRA_URL = "EXTRA_URL";
-
-    // Message IDs
-    private static final int MESSAGE_CHECK_WIFI = 1;
-    private static final int MESSAGE_CHECK_WIFI_DONE = 2;
-    private static final int MESSAGE_TRY_EPDG_CONNECTION = 3;
-    private static final int MESSAGE_TRY_EPDG_CONNECTION_DONE = 4;
-    private static final int MESSAGE_SHOW_WEB_PORTAL = 5;
-
-    private WfcActivationHelper mWfcActivationHelper;
-
-    private Handler mUiHandler;
-    @VisibleForTesting ProgressDialog mProgressDialog;
-
-    private CustomTabsSession mCustomTabsSession;
-    @VisibleForTesting CustomTabsServiceConnection mServiceConnection;
-    private ActivityResultLauncher<Intent> mWebviewResultsLauncher =
-        registerForActivityResult(
-            new StartActivityForResult(),
-            activityResult -> {
-              if (activityResult.getResultCode() == Activity.RESULT_CANCELED) {
-                Log.d(TAG, "Webview Activity Result CANCEL");
-                finish();
-              } else {
-                Log.d(TAG, "Webview Activity Result OK");
-                finish();
-              }
-            });
-
-    // Whether it's safe now to update UI, based on activity visibility.
-    // It should be true between onResume() and onPause().
-    private boolean mSafeToUpdateUi = false;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        // Initialization
-        super.onCreate(savedInstanceState);
-        createDependencies();
-        createUiHandler();
-
-        // Set layout
-        setContentView(R.layout.activity_wfc_activation);
-
-        if (WfcUtils.isActivationFlow(getIntent())) {
-            // WFC activation flow
-            mUiHandler.sendEmptyMessage(MESSAGE_CHECK_WIFI);
-        } else {
-            // Emergency address update flow
-            mUiHandler.sendEmptyMessage(MESSAGE_SHOW_WEB_PORTAL);
-        }
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-        mSafeToUpdateUi = true;
-    }
-
-    @Override
-    protected void onPause() {
-        super.onPause();
-        mSafeToUpdateUi = false;
-    }
-
-    private void createUiHandler() {
-        Handler.Callback handlerCallback =
-                (Message msg) -> {
-                    Log.d(TAG, "UiHandler received: " + msg);
-                    switch (msg.what) {
-                        case MESSAGE_CHECK_WIFI:
-                            mWfcActivationHelper.checkWiFi(
-                                    mUiHandler.obtainMessage(MESSAGE_CHECK_WIFI_DONE));
-                            break;
-                        case MESSAGE_CHECK_WIFI_DONE:
-                            if (msg.arg1 == WfcActivationHelper.WIFI_CONNECTION_SUCCESS) {
-                                mUiHandler.sendEmptyMessage(MESSAGE_TRY_EPDG_CONNECTION);
-                            } else { // msg.arg1 == WfcActivationHelper.WIFI_CONNECTION_ERROR
-                                showWiFiUnavailableDialog();
-                            }
-                            break;
-                        case MESSAGE_TRY_EPDG_CONNECTION:
-                            showProgressDialog();
-                            Log.d(TAG, "Show progress dialog - tryEpdgConnectionOverWiFi");
-                            mWfcActivationHelper.tryEpdgConnectionOverWiFi(
-                                    mUiHandler.obtainMessage(MESSAGE_TRY_EPDG_CONNECTION_DONE),
-                                    mWfcActivationHelper
-                                            .getVowifiRegistrationTimerForVowifiActivation());
-                            break;
-                        case MESSAGE_TRY_EPDG_CONNECTION_DONE:
-                            dismissProgressDialog();
-                            Log.d(TAG, "Dismiss progress dialog - tryEpdgConnectionOverWiFi");
-                            if (msg.arg1 == WfcActivationHelper.EPDG_CONNECTION_SUCCESS) {
-                                Log.d(TAG, "VoWiFi activated");
-                                setResultAndFinish(RESULT_OK);
-                            } else { // msg.arg1 == WfcActivationHelper.EPDG_CONNECTION_ERROR
-                                mUiHandler.sendEmptyMessage(MESSAGE_SHOW_WEB_PORTAL);
-                            }
-                            break;
-                        case MESSAGE_SHOW_WEB_PORTAL:
-                            startWebPortal();
-                            break;
-                        default:
-                            Log.e(TAG, "UiHandler received unknown message: " + msg);
-                            return false;
-                    }
-                    return true;
-                };
-        mUiHandler = new Handler(handlerCallback);
-    }
-
-    @Override
-    public void onDestroy() {
-        if (mServiceConnection != null) {
-          unbindService(mServiceConnection);
-        }
-        super.onDestroy();
-    }
-
-    private void startWebPortal() {
-      Log.d(TAG, "starting web portal ..");
-      if (!mSafeToUpdateUi) {
-        Log.d(TAG, "Not safe to update UI. Stopping.");
-        return;
-      }
-      String url = mWfcActivationHelper.getWebPortalUrl();
-      if (TextUtils.isEmpty(url)) {
-        Log.d(TAG, "No web portal url!");
-        return;
-      }
-      if (!mWfcActivationHelper.supportJsCallbackForVowifiPortal()) {
-        // For carriers not requiring JS callback in their WFC activation webpage, using a
-        // ChromeCustomTab provides richer web functionality while avoiding jumping to the browser
-        // app and introducing a discontinuity in UX.
-        startCustomTab(url);
-      } else {
-        // Because QNS uses system UID now, webview cannot be started here. Instead, webview is
-        // started in a different activity, {@code R.string.webview_component}.
-        startWebPortalActivity();
-      }
-    }
-
-    private void startCustomTab(String url) {
-        mServiceConnection =
-            new CustomTabsServiceConnection() {
-              @Override
-              public void onCustomTabsServiceConnected(
-                      ComponentName name, CustomTabsClient client) {
-                client.warmup(0L);
-                mCustomTabsSession = client.newSession(null);
-                mCustomTabsSession.mayLaunchUrl(Uri.parse(url), null, null);
-              }
-
-              @Override
-              public void onServiceDisconnected(ComponentName name) {
-                mCustomTabsSession = null;
-              }
-            };
-
-        String ServicePackageName =
-                getResources().getString(R.string.custom_tabs_service_package_name);
-        CustomTabsClient.bindCustomTabsService(this, ServicePackageName, mServiceConnection);
-        new CustomTabsIntent.Builder(mCustomTabsSession).build().launchUrl(this, Uri.parse(url));
-
-        if (WfcUtils.isActivationFlow(getIntent())) {
-          setResultAndFinish(RESULT_CANCELED);
-        } else {
-          setResultAndFinish(RESULT_OK);
-        }
-    }
-    private void startWebPortalActivity() {
-        String webviewComponent = getResources().getString(R.string.webview_component);
-        ComponentName componentName = ComponentName.unflattenFromString(webviewComponent);
-        String url = mWfcActivationHelper.getWebPortalUrl();
-
-        Log.d(TAG, "startWebPortalActivity componentName: " + componentName);
-        Intent intent = new Intent();
-        intent.setComponent(componentName);
-        intent.putExtra(EXTRA_URL, url);
-        mWebviewResultsLauncher.launch(intent);
-    }
-
-    private void showProgressDialog() {
-        if (!mSafeToUpdateUi) {
-            return;
-        }
-        if (mProgressDialog != null && mProgressDialog.isShowing()) {
-            return;
-        }
-        mProgressDialog =
-                new ProgressDialog(
-                        new ContextThemeWrapper(
-                                this, android.R.style.Theme_DeviceDefault_Light_Dialog));
-        mProgressDialog.setCancelable(false);
-        mProgressDialog.setCanceledOnTouchOutside(false);
-        mProgressDialog.setMessage(getText(R.string.progress_text));
-        mProgressDialog.show();
-        // Keep screen on
-        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
-    }
-
-    private void dismissProgressDialog() {
-        if (!mSafeToUpdateUi) {
-            return;
-        }
-        if (mProgressDialog != null) {
-            mProgressDialog.dismiss();
-            mProgressDialog = null;
-            // Allow screen off
-            getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
-        }
-    }
-
-    private void showWiFiUnavailableDialog() {
-        if (!mSafeToUpdateUi) {
-            return;
-        }
-        DialogFragment dialog =
-                AlertDialogFragment.newInstance(
-                        R.string.connect_to_wifi_or_web_portal_title,
-                        R.string.connect_to_wifi_or_web_portal_message);
-        dialog.show(getSupportFragmentManager(), "Wifi_unavailable_dialog");
-    }
-
-    /** Dialog fragment to show error messages */
-    public static class AlertDialogFragment extends DialogFragment {
-
-        private static final String TITLE_KEY = "TITLE_KEY";
-        private static final String MESSAGE_KEY = "MESSAGE_KEY";
-
-        /** Static constructor */
-        public static AlertDialogFragment newInstance(int titleId, int messageId) {
-            AlertDialogFragment frag = new AlertDialogFragment();
-            frag.setCancelable(false);
-
-            Bundle args = new Bundle();
-            args.putInt(TITLE_KEY, titleId);
-            args.putInt(MESSAGE_KEY, messageId);
-            frag.setArguments(args);
-
-            return frag;
-        }
-
-        @Override
-        public Dialog onCreateDialog(Bundle savedInstanceState) {
-            Bundle args = getArguments();
-            int titleId = args.getInt(TITLE_KEY);
-            int messageId = args.getInt(MESSAGE_KEY);
-            final WfcActivationActivity activity =
-                    (WfcActivationActivity) getActivity();
-            return new AlertDialog.Builder(
-                            new ContextThemeWrapper(
-                                    getActivity(),
-                                    android.R.style.Theme_DeviceDefault_Light_Dialog))
-                    .setTitle(titleId)
-                    .setMessage(messageId)
-                    .setPositiveButton(
-                            R.string.button_setup_web_portal,
-                            (OnClickListener)
-                                    (dialog, which) ->
-                                            activity.mUiHandler.sendEmptyMessage(
-                                                    MESSAGE_SHOW_WEB_PORTAL))
-                    .setNegativeButton(
-                            R.string.button_turn_on_wifi,
-                            (OnClickListener)
-                                    (dialog, which) -> {
-                                        // Redirect to WiFi settings UI
-                                        Intent intent = new Intent(Settings.ACTION_WIFI_SETTINGS);
-                                        activity.startActivity(intent);
-                                        // And finish self
-                                        activity.setResultAndFinish(RESULT_CANCELED);
-                                    })
-                    .create();
-        }
-    }
-
-    private void setResultAndFinish(int resultCode) {
-        setResult(resultCode);
-        finish();
-    }
-
-    private void createDependencies() {
-        // Default initialization for production
-        int subId = WfcUtils.getSubId(getIntent());
-
-        if (WfcUtils.getWfcActivationHelper() != null) {
-            mWfcActivationHelper = WfcUtils.getWfcActivationHelper();
-          Log.v(TAG, "WfcActivationHelper injected: " + mWfcActivationHelper);
-        } else {
-            mWfcActivationHelper = new WfcActivationHelper(this, subId);
-        }
-
-        if (WfcUtils.getWebviewResultLauncher() != null) {
-            mWebviewResultsLauncher = WfcUtils.getWebviewResultLauncher();
-            Log.v(TAG, "getWebviewResultLauncher injected: " + mWebviewResultsLauncher);
-        }
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/wfc/WfcActivationHelper.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/wfc/WfcActivationHelper.java
deleted file mode 100644
index eeb403f..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/wfc/WfcActivationHelper.java
+++ /dev/null
@@ -1,375 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.telephony.qns.wfc;
-
-import static android.os.AsyncTask.THREAD_POOL_EXECUTOR;
-
-import android.annotation.Nullable;
-import android.content.Context;
-import android.content.Intent;
-import android.net.ConnectivityManager;
-import android.net.NetworkInfo;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.SubscriptionManager;
-import android.telephony.ims.ImsException;
-import android.telephony.ims.ImsMmTelManager;
-import android.telephony.ims.ImsReasonInfo;
-
-import android.util.Log;
-
-import com.android.internal.annotations.VisibleForTesting;
-import com.android.telephony.qns.R;
-
-import java.util.concurrent.Executor;
-
-/** A class with helper methods for WfcActivationCanadaActivity */
-public class WfcActivationHelper {
-    private static final String TAG = WfcActivationActivity.TAG;
-
-    @VisibleForTesting static final int PRE_EPDG_CONNECTION_DELAY_MS = 1000; // 1 second
-
-    // Enums for Wi-Fi check result
-    public static final int WIFI_CONNECTION_SUCCESS = 0;
-    public static final int WIFI_CONNECTION_ERROR = 1;
-
-    // Enums for ePDG connection result
-    public static final int EPDG_CONNECTION_SUCCESS = 0;
-    public static final int EPDG_CONNECTION_ERROR = 1;
-
-    // Event IDs for ePDG connection
-    @VisibleForTesting static final int EVENT_PRE_START_ATTEMPT = 0;
-    @VisibleForTesting static final int EVENT_START_ATTEMPT = 1;
-    @VisibleForTesting static final int EVENT_FINISH_ATTEMPT = 2;
-    private static final int EVENT_RESULT_SUCCESS = 3;
-    private static final int EVENT_TIMEOUT = 4;
-    private static final int EVENT_RESULT_FAILURE_IKEV2 = 5;
-    private static final int EVENT_RESULT_FAILURE_OTHER = 6;
-
-    public static final String ACTION_TRY_WFC_CONNECTION =
-            "com.android.qns.wfcactivation.TRY_WFC_CONNECTION";
-    public static final String EXTRA_SUB_ID = "SUB_ID";
-    public static final String EXTRA_TRY_STATUS = "TRY_STATUS";
-    public static final int STATUS_START = 1;
-    public static final int STATUS_END = 2;
-
-    // Dependencies
-    private final Context mContext;
-    private final ConnectivityManager mConnectivityManager;
-    private final ImsMmTelManager mImsMmTelManager;
-    private final WfcCarrierConfigManager mWfcConfigManager;
-
-    private final int mSubId;
-    private final Executor mBackgroundExecutor;
-
-    public WfcActivationHelper(Context context, int subId) {
-        this(
-                context,
-                subId,
-                context.getSystemService(ConnectivityManager.class),
-                WfcUtils.getImsMmTelManager(subId),
-                new WfcCarrierConfigManager(context.getApplicationContext(), subId),
-                        THREAD_POOL_EXECUTOR);
-    }
-
-    @VisibleForTesting
-    WfcActivationHelper(
-            Context context,
-            int subId,
-            ConnectivityManager cm,
-            @Nullable ImsMmTelManager imsMmTelManager,
-            WfcCarrierConfigManager wfcConfigManager,
-            Executor backgroundExecutor) {
-        mContext = context;
-        mSubId = subId;
-        mConnectivityManager = cm;
-        mImsMmTelManager = imsMmTelManager;
-        mWfcConfigManager = wfcConfigManager;
-        mBackgroundExecutor = backgroundExecutor;
-        mWfcConfigManager.loadConfigurations();
-    }
-
-    /**
-     * Check WiFi connection
-     *
-     * @param msg The Message to be send with arg1 = result. Result is one of WIFI_CONNECTION_*.
-     */
-    public void checkWiFi(Message msg) {
-        msg.arg1 = checkWiFiAvailability() ? WIFI_CONNECTION_SUCCESS : WIFI_CONNECTION_ERROR;
-        msg.sendToTarget();
-    }
-
-    private boolean checkWiFiAvailability() {
-        NetworkInfo activeNetwork = mConnectivityManager.getActiveNetworkInfo();
-        return activeNetwork != null
-                && activeNetwork.isConnected()
-                && activeNetwork.getType() == ConnectivityManager.TYPE_WIFI;
-    }
-
-    private void notifyQnsServiceToSetWfcMode(int status) {
-        String qnsPackage = mContext.getResources().getString(R.string.qns_package);
-        Intent intent = new Intent(ACTION_TRY_WFC_CONNECTION);
-        intent.putExtra(EXTRA_SUB_ID, mSubId);
-        intent.putExtra(EXTRA_TRY_STATUS, status);
-        intent.setPackage(qnsPackage);
-        Log.d(TAG, "notify QNS: subId =" + mSubId + ", status =" + status);
-        mContext.sendBroadcast(intent);
-    }
-
-    // This class is a effectively a one-way state machine that cannot be reset & reused. Each call
-    // of tryEpdgConnectionOverWiFi() creates a new instance of this class.
-    private class EpdgConnectHandler extends Handler {
-        final ImsCallback imsCallback;
-        final Message result;
-        boolean imsCallbackRegistered;
-        boolean waitingForResult; // ImsCallback wil be no-op when this is false
-
-        EpdgConnectHandler(Looper looper, Message result) {
-            super(looper);
-            imsCallback = new ImsCallback(this);
-            this.result = result;
-        }
-
-        @Override
-        public void handleMessage(Message msg) {
-            switch (msg.what) {
-                case EVENT_PRE_START_ATTEMPT:
-                    // The callback must be registered before triggering ePDG connection, because
-                    // the very 1st firing of the callback after registering MAY be the last IMS
-                    // state.
-                    // We assume 1 second is enough for that 1st firing.
-                    // This means adding 1s delay to WFC activation flow in all cases, and it should
-                    // be fine, given this can only be triggered by user manually and is not
-                    // expected to be fast.
-                    waitingForResult = false;
-                    registerImsRegistrationCallback();
-                    // Populate arg1 to EVENT_START_ATTEMPT message
-                    sendMessageDelayed(
-                            obtainMessage(EVENT_START_ATTEMPT, msg.arg1, 0),
-                            /* delayMillis= */ msg.arg2);
-                    break;
-
-                case EVENT_START_ATTEMPT:
-                    Log.d(TAG, "Try to setup ePDG connection over WiFi");
-                    waitingForResult = true;
-
-                    mBackgroundExecutor.execute(
-                            () -> {
-                                // WFC: on; WFC preference: WiFi preferred (2)
-                                mImsMmTelManager.setVoWiFiNonPersistent(true, 2);
-                                // notify IMS to program WFC on and WFC mode as Wi-Fi Preferred
-                                notifyQnsServiceToSetWfcMode(STATUS_START);
-                            });
-
-                    // Timeout event
-                    Log.d(TAG, "Will timeout after " + msg.arg1 + " ms");
-                    sendEmptyMessageDelayed(EVENT_TIMEOUT, /* delayMillis= */ msg.arg1);
-                    break;
-
-                case EVENT_TIMEOUT:
-                    Log.d(TAG, "Timeout: IKEV2 Auth failure not received.");
-                    if (getTimeoutResult() == EPDG_CONNECTION_SUCCESS) {
-                        sendEmptyMessage(EVENT_RESULT_SUCCESS);
-                    } else {
-                        sendEmptyMessage(EVENT_RESULT_FAILURE_IKEV2);
-                    }
-                    break;
-
-                case EVENT_RESULT_SUCCESS:
-                    result.arg1 = EPDG_CONNECTION_SUCCESS;
-                    // Clean up and send result
-                    sendEmptyMessage(EVENT_FINISH_ATTEMPT);
-                    break;
-
-                case EVENT_RESULT_FAILURE_IKEV2:
-                    Log.d(TAG, "Turn off WFC");
-                    // WFC: off; WFC preference: cellular preferred (1)
-                    mBackgroundExecutor.execute(
-                            () -> mImsMmTelManager.setVoWiFiNonPersistent(false, 1));
-                    // Set result: failure
-                    result.arg1 = EPDG_CONNECTION_ERROR;
-                    // Clean up and send result
-                    sendEmptyMessage(EVENT_FINISH_ATTEMPT);
-                    break;
-
-                case EVENT_FINISH_ATTEMPT:
-                    waitingForResult = false;
-                    // Remove timeout event - if we get here via EVENT_TIMEOUT, this do nothing.
-                    removeMessages(EVENT_TIMEOUT);
-                    // Unregister mImsCallback
-                    unregisterImsRegistrationCallback();
-                    mBackgroundExecutor.execute(
-                            () -> {
-                                // Turn on WFC if success. W/o this, WFC could be turned
-                                // ON (by STATUS_START) - OFF (by STATUS_END) - ON (by Settings app)
-                                // which causes unnecessary IMS registration traffic.
-                                // This must be done before sending STATUS_END so vendor IMS will
-                                // see DB value ON.
-                                if (result.arg1 == EPDG_CONNECTION_SUCCESS) {
-                                    Log.d(TAG, "Turn on WFC");
-                                    mImsMmTelManager.setVoWiFiSettingEnabled(true);
-                                }
-                                // Notify IMS to revert WFC on/off and mode to follow user settings.
-                                // Notify here to make sure all cases (success, failure, timeout)
-                                // reach this line.
-                                notifyQnsServiceToSetWfcMode(STATUS_END);
-                                // Send result
-                                result.sendToTarget();
-                            });
-                    break;
-
-                case EVENT_RESULT_FAILURE_OTHER:
-                    break;
-                default: // Do nothing
-            }
-        }
-
-        private void registerImsRegistrationCallback() {
-            try {
-                Log.d(TAG, "registerImsRegistrationCallback");
-                mImsMmTelManager.registerImsRegistrationCallback(this::post, imsCallback);
-                imsCallbackRegistered = true;
-            } catch (ImsException | RuntimeException e) {
-                Log.e(TAG, "registerImsRegistrationCallback failed", e);
-                // Fail silently to trigger timeout
-                imsCallbackRegistered = false;
-            }
-        }
-
-        private void unregisterImsRegistrationCallback() {
-            if (!imsCallbackRegistered) {
-                return;
-            }
-
-            try {
-                Log.d(TAG, "unregisterImsRegistrationCallback");
-                mImsMmTelManager.unregisterImsRegistrationCallback(imsCallback);
-                imsCallbackRegistered = false;
-            } catch (RuntimeException e) {
-                Log.e(TAG, "unregisterImsRegistrationCallback failed", e);
-            }
-        }
-    }
-
-    /**
-     * Try to setup ePDG connection over WiFi.
-     *
-     * @param msg The Message to be send with arg1 = result. Result is one of EPDG_CONNECTION_*.
-     * @param timeoutMs Timeout, in milliseconds, then abort waiting for ePDG connection result.
-     */
-    public void tryEpdgConnectionOverWiFi(Message msg, int timeoutMs) {
-        if (mImsMmTelManager == null) {
-            // Send message with EPDG_CONNECTION_ERROR immediately.
-            Log.e(TAG, "ImsMmTelManager is null");
-            msg.arg1 = EPDG_CONNECTION_ERROR;
-            msg.sendToTarget();
-            return;
-        }
-
-        // NOTE: This private handler is hosted on the same looper as msg.
-        EpdgConnectHandler handler = new EpdgConnectHandler(msg.getTarget().getLooper(), msg);
-        // Start attempt of ePDG connection.
-        handler.obtainMessage(EVENT_PRE_START_ATTEMPT, timeoutMs, PRE_EPDG_CONNECTION_DELAY_MS)
-                .sendToTarget();
-    }
-
-    @VisibleForTesting
-    static class ImsCallback extends ImsMmTelManager.RegistrationCallback {
-        private final EpdgConnectHandler handler;
-
-        ImsCallback(EpdgConnectHandler handler) {
-            this.handler = handler;
-        }
-
-        @Override
-        public void onRegistered(int imsTransportType) {
-            if (!handler.waitingForResult) {
-                return;
-            }
-            if (imsTransportType != AccessNetworkConstants.TRANSPORT_TYPE_WLAN) {
-                return;
-            }
-            Log.d(TAG, "IMS connected on WLAN.");
-            handler.sendEmptyMessage(EVENT_RESULT_SUCCESS);
-        }
-
-        @Override
-        public void onUnregistered(ImsReasonInfo imsReasonInfo) {
-            if (!handler.waitingForResult) {
-                return;
-            }
-            Log.d(TAG, "IMS disconnected: " + imsReasonInfo);
-            if (isIkev2AuthFailure(imsReasonInfo)) {
-                handler.sendEmptyMessage(EVENT_RESULT_FAILURE_IKEV2);
-            } else {
-                handler.obtainMessage(
-                                EVENT_RESULT_FAILURE_OTHER,
-                                imsReasonInfo.getCode(),
-                                imsReasonInfo.getExtraCode())
-                        .sendToTarget();
-            }
-        }
-
-        @Override
-        public void onTechnologyChangeFailed(int imsTransportType, ImsReasonInfo imsReasonInfo) {
-            if (!handler.waitingForResult) {
-                return;
-            }
-            if (imsTransportType != AccessNetworkConstants.TRANSPORT_TYPE_WLAN) {
-                return;
-            }
-            Log.d(TAG, "IMS registration failed on WLAN: " + imsReasonInfo);
-            if (isIkev2AuthFailure(imsReasonInfo)) {
-                handler.sendEmptyMessage(EVENT_RESULT_FAILURE_IKEV2);
-            } else {
-                handler.obtainMessage(
-                                EVENT_RESULT_FAILURE_OTHER,
-                                imsReasonInfo.getCode(),
-                                imsReasonInfo.getExtraCode())
-                        .sendToTarget();
-            }
-        }
-    }
-
-    static boolean isIkev2AuthFailure(ImsReasonInfo imsReasonInfo) {
-        if (imsReasonInfo.getCode() == ImsReasonInfo.CODE_EPDG_TUNNEL_ESTABLISH_FAILURE) {
-            if (imsReasonInfo.getExtraCode() == ImsReasonInfo.CODE_IKEV2_AUTH_FAILURE) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private int getTimeoutResult() {
-        return mWfcConfigManager.isShowVowifiPortalAfterTimeout()
-                ? EPDG_CONNECTION_ERROR
-                : EPDG_CONNECTION_SUCCESS;
-    }
-
-    public String getWebPortalUrl() {
-        return mWfcConfigManager.getVowifiEntitlementServerUrl();
-    }
-
-    public int getVowifiRegistrationTimerForVowifiActivation() {
-        return mWfcConfigManager.getVowifiRegistrationTimerForVowifiActivation();
-    }
-
-    public boolean supportJsCallbackForVowifiPortal() {
-        return mWfcConfigManager.supportJsCallbackForVowifiPortal();
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/wfc/WfcCarrierConfigManager.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/wfc/WfcCarrierConfigManager.java
deleted file mode 100644
index c6555b1..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/wfc/WfcCarrierConfigManager.java
+++ /dev/null
@@ -1,224 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns.wfc;
-
-import static com.android.internal.annotations.VisibleForTesting.Visibility.PACKAGE;
-
-import android.content.Context;
-import android.os.PersistableBundle;
-import android.telephony.CarrierConfigManager;
-import android.util.Log;
-
-import com.android.internal.annotations.VisibleForTesting;
-
-/** This class supports loading WFC config */
-public class WfcCarrierConfigManager {
-    private static final String TAG = WfcActivationActivity.TAG;
-    private final int mSubId;
-    private final Context mContext;
-    protected int mCurrCarrierId;
-
-    private boolean mIsShowVowifiPortalAfterTimeout;
-    private boolean mIsJsCallbackForVowifiPortal;
-
-    private int mVowifiRegistrationTimerForVowifiActivation;
-
-    private String mVowifiEntitlementServerUrl;
-
-    /**
-     * The address of the VoWiFi entitlement server for Emergency Address Registration.
-     *
-     * <p>Note: this is effective only if the {@link #KEY_WFC_EMERGENCY_ADDRESS_CARRIER_APP_STRING}
-     * is set to the QNS app.
-     */
-    public static final String KEY_QNS_VOWIFI_ENTITLEMENT_SERVER_URL_STRING =
-            "qns.vowifi_entitlement_server_url_string";
-
-    /**
-     * Specifies the wait time in milliseconds that VoWiFi registration in VoWiFi activation
-     * process.
-     *
-     * <p>Note: this is effective only if the {@link #KEY_WFC_EMERGENCY_ADDRESS_CARRIER_APP_STRING}
-     * is set to the QNS app.
-     */
-    public static final String KEY_QNS_VOWIFI_REGISTATION_TIMER_FOR_VOWIFI_ACTIVATION_INT =
-            "qns.vowifi_registation_timer_for_vowifi_activation_int";
-
-    /**
-     * Indicates whether to pop up a web portal of the carrier or to turn on WFC directly when
-     * {@link #KEY_QNS_VOWIFI_REGISTATION_TIMER_FOR_VOWIFI_ACTIVATION_INT} is expired in VoWiFi
-     * activation process
-     *
-     * <p>{@code true} - show the VoWiFi portal after the timer expires. {@code false}
-     * - turn on WFC UI after the timer expires.
-     *
-     * <p>Note: this is effective only if the {@link #KEY_WFC_EMERGENCY_ADDRESS_CARRIER_APP_STRING}
-     * is set to the QNS app.
-     */
-    public static final String KEY_QNS_SHOW_VOWIFI_PORTAL_AFTER_TIMEOUT_BOOL =
-            "qns.show_vowifi_portal_after_timeout_bool";
-
-    /**
-     * Indicates whether web portal {@link #KEY_WFC_EMERGENCY_ADDRESS_CARRIER_APP_STRING} of the
-     * carrier supports JavaScript callback interfaces
-     *
-     * <p>{@code true} - use webview with JavaScript callback interfaces to display web content.
-     * {@code false} - use chrome with custom tabs to display web content.
-     *
-     * <p>Note: this is effective only if the {@link #KEY_WFC_EMERGENCY_ADDRESS_CARRIER_APP_STRING}
-     * is set to the QNS app.
-     */
-    public static final String KEY_QNS_JS_CALLBACK_FOR_VOWIFI_PORTAL_BOOL =
-            "qns.js_callback_for_vowifi_portal_bool";
-
-    public static final int CONFIG_DEFAULT_VOWIFI_REGISTATION_TIMER = 120000;
-
-    WfcCarrierConfigManager(Context context, int subId) {
-        mSubId = subId;
-        mContext = context;
-    }
-
-    private static boolean getDefaultBooleanValueForKey(String key) {
-        Log.d(TAG, "Use default value for key: " + key);
-        switch (key) {
-            case KEY_QNS_SHOW_VOWIFI_PORTAL_AFTER_TIMEOUT_BOOL:
-                return true;
-            case KEY_QNS_JS_CALLBACK_FOR_VOWIFI_PORTAL_BOOL:
-                return false;
-            default:
-                break;
-        }
-        return false;
-    }
-
-    private static String getDefaultStringValueForKey(String key) {
-        Log.d(TAG, "Use default value for key: " + key);
-        switch (key) {
-            case KEY_QNS_VOWIFI_ENTITLEMENT_SERVER_URL_STRING:
-                return "";
-            default:
-                break;
-        }
-        return "";
-    }
-
-    private static int getDefaultIntValueForKey(String key) {
-        Log.d(TAG, "Use default value for key: " + key);
-        switch (key) {
-            case KEY_QNS_VOWIFI_REGISTATION_TIMER_FOR_VOWIFI_ACTIVATION_INT:
-                return CONFIG_DEFAULT_VOWIFI_REGISTATION_TIMER;
-            default:
-                break;
-        }
-        return 0;
-    }
-
-    private PersistableBundle readFromCarrierConfigManager(Context context) {
-        PersistableBundle carrierConfigBundle;
-        CarrierConfigManager carrierConfigManager =
-                context.getSystemService(CarrierConfigManager.class);
-
-        if (carrierConfigManager == null) {
-            throw new IllegalStateException("Carrier config manager is null.");
-        }
-        carrierConfigBundle = carrierConfigManager.getConfigForSubId(mSubId);
-
-        return carrierConfigBundle;
-    }
-
-    @VisibleForTesting
-    void loadConfigurations() {
-        PersistableBundle carrierConfigBundle = readFromCarrierConfigManager(mContext);
-        Log.d(TAG, "CarrierConfig Bundle for subId: " + mSubId + carrierConfigBundle);
-        loadConfigurationsFromCarrierConfig(carrierConfigBundle);
-    }
-
-    @VisibleForTesting
-    void loadConfigurationsFromCarrierConfig(PersistableBundle carrierConfigBundle) {
-        mVowifiEntitlementServerUrl =
-                getStringConfig(carrierConfigBundle,
-                                KEY_QNS_VOWIFI_ENTITLEMENT_SERVER_URL_STRING);
-        mVowifiRegistrationTimerForVowifiActivation =
-                getIntConfig(
-                        carrierConfigBundle,
-                        KEY_QNS_VOWIFI_REGISTATION_TIMER_FOR_VOWIFI_ACTIVATION_INT);
-        mIsShowVowifiPortalAfterTimeout =
-                getBooleanConfig(carrierConfigBundle,
-                                 KEY_QNS_SHOW_VOWIFI_PORTAL_AFTER_TIMEOUT_BOOL);
-        mIsJsCallbackForVowifiPortal =
-                getBooleanConfig(carrierConfigBundle,
-                                 KEY_QNS_JS_CALLBACK_FOR_VOWIFI_PORTAL_BOOL);
-    }
-
-    private boolean getBooleanConfig(PersistableBundle bundleCarrier, String key) {
-        if (bundleCarrier == null || bundleCarrier.get(key) == null) {
-            return getDefaultBooleanValueForKey(key);
-        }
-        return bundleCarrier.getBoolean(key);
-    }
-
-    private int getIntConfig(PersistableBundle bundleCarrier, String key) {
-        if (bundleCarrier == null || bundleCarrier.get(key) == null) {
-            return getDefaultIntValueForKey(key);
-        }
-        return bundleCarrier.getInt(key);
-    }
-
-    private String getStringConfig(PersistableBundle bundleCarrier, String key) {
-        if (bundleCarrier == null || bundleCarrier.get(key) == null) {
-            return getDefaultStringValueForKey(key);
-        }
-        return bundleCarrier.getString(key);
-    }
-
-    /**
-     * This method returns the URL of the VoWiFi entitlement server for an emergency address
-     * registration
-     */
-    @VisibleForTesting(visibility = PACKAGE)
-    String getVowifiEntitlementServerUrl() {
-        return mVowifiEntitlementServerUrl;
-    }
-
-    /**
-     * This method returns the wait timer in milliseconds that VoWiFi registration in VoWiFi
-     * activation process
-     */
-    @VisibleForTesting(visibility = PACKAGE)
-    int getVowifiRegistrationTimerForVowifiActivation() {
-        return mVowifiRegistrationTimerForVowifiActivation;
-    }
-
-    /**
-     * This method returns true if a web portal of the carrier is poped up when
-     * {@link #KEY_QNS_VOWIFI_REGISTATION_TIMER_FOR_VOWIFI_ACTIVATION_INT} is expired in VoWiFi
-     * activation process; Otherwise, WFC is tuned on directly.
-     */
-    @VisibleForTesting(visibility = PACKAGE)
-    boolean isShowVowifiPortalAfterTimeout() {
-        return mIsShowVowifiPortalAfterTimeout;
-    }
-
-    /**
-     * This method returns true if JavaScript callback interface is not support for web portal
-     * {@link #KEY_WFC_EMERGENCY_ADDRESS_CARRIER_APP_STRING} of the carrier
-     */
-    @VisibleForTesting(visibility = PACKAGE)
-    boolean supportJsCallbackForVowifiPortal() {
-        return mIsJsCallbackForVowifiPortal;
-    }
-}
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/wfc/WfcUtils.java b/services/QualifiedNetworksService/src/com/android/telephony/qns/wfc/WfcUtils.java
deleted file mode 100644
index 16f4a61..0000000
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/wfc/WfcUtils.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.telephony.qns.wfc;
-
-import android.annotation.Nullable;
-import android.annotation.SuppressLint;
-import android.content.Intent;
-import android.telephony.SubscriptionManager;
-import android.telephony.ims.ImsMmTelManager;
-import android.util.Log;
-
-import androidx.activity.result.ActivityResultLauncher;
-import androidx.annotation.VisibleForTesting;
-
-public final class WfcUtils {
-    private static final String TAG = WfcActivationActivity.TAG;
-
-    // Constants shared by WifiCallingSettings
-    static final String EXTRA_LAUNCH_CARRIER_APP = "EXTRA_LAUNCH_CARRIER_APP";
-    static final int LAUNCH_APP_ACTIVATE = 0;
-    static final int LAUNCH_APP_UPDATE = 1;
-
-    // OK to suppress warnings here because it's used only for unit tests
-    @SuppressLint("StaticFieldLeak")
-    private static WfcActivationHelper mWfcActivationHelper;
-    private static ActivityResultLauncher mWebViewResultsLauncher;
-
-    private WfcUtils() {}
-
-    /**
-     * Returns {@code true} if the app is launched for WFC activation; {@code false} for emergency
-     * address update or displaying terms & conditions.
-     */
-    public static boolean isActivationFlow(Intent intent) {
-        int intention = getLaunchIntention(intent);
-        Log.d(TAG, "Start Activity intention : " + intention);
-        return intention == LAUNCH_APP_ACTIVATE;
-    }
-
-    /** Returns the launch intention extra in the {@code intent}. */
-    public static int getLaunchIntention(Intent intent) {
-        if (intent == null) {
-            return LAUNCH_APP_ACTIVATE;
-        }
-
-        return intent.getIntExtra(EXTRA_LAUNCH_CARRIER_APP, LAUNCH_APP_ACTIVATE);
-    }
-
-    /** Returns the subscription id of starting the WFC activation activity. */
-    public static int getSubId(Intent intent) {
-        if (intent == null) {
-            return SubscriptionManager.getDefaultDataSubscriptionId();
-        }
-        int subId =
-                intent.getIntExtra(
-                        SubscriptionManager.EXTRA_SUBSCRIPTION_INDEX,
-                        SubscriptionManager.getDefaultDataSubscriptionId());
-        Log.d(TAG, "Start Activity with subId : " + subId);
-        return subId;
-    }
-
-    /**
-     * Returns {@link ImsMmTelManager} with specific subscription id. Returns {@code null} if
-     * provided subscription id invalid.
-     */
-    @Nullable
-    public static ImsMmTelManager getImsMmTelManager(int subId) {
-        if (SubscriptionManager.isValidSubscriptionId(subId)) {
-            try {
-                return ImsMmTelManager.createForSubscriptionId(subId);
-            } catch (IllegalArgumentException e) {
-                Log.e(TAG, "Can't get ImsMmTelManager, IllegalArgumentException: subId = " + subId);
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Dependency providers.
-     *
-     * <p>In normal case, setters are not invoked, hence getters return null. The component is
-     * supposed to do null check and initialize dependencies by itself. In tests, setters can be
-     * invoked to provide mock dependencies.
-     */
-    @VisibleForTesting
-    public static void setWfcActivationHelper(WfcActivationHelper obj) {
-        mWfcActivationHelper = obj;
-    }
-
-    @VisibleForTesting
-    public static void setWebviewResultLauncher(ActivityResultLauncher obj) {
-        mWebViewResultsLauncher = obj;
-    }
-
-    @Nullable
-    public static WfcActivationHelper getWfcActivationHelper() {
-        return mWfcActivationHelper;
-    }
-
-    @Nullable
-    public static ActivityResultLauncher getWebviewResultLauncher() {
-        return mWebViewResultsLauncher;
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/AndroidManifest.xml b/services/QualifiedNetworksService/tests/AndroidManifest.xml
deleted file mode 100644
index 3ee14a4..0000000
--- a/services/QualifiedNetworksService/tests/AndroidManifest.xml
+++ /dev/null
@@ -1,36 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- -->
-
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.android.telephony.qns.tests">
-
-    <uses-sdk android:minSdkVersion="23" android:targetSdkVersion="23" />
-    <uses-permission android:name="android.permission.READ_DEVICE_CONFIG"/>
-    <uses-permission android:name="android.permission.READ_PRECISE_PHONE_STATE"/>
-    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
-    <uses-permission android:name="android.permission.INTERNET"/>
-    <uses-permission android:name="android.permission.MODIFY_PHONE_STATE"/>
-    <application android:label="QnsUnitTests" android:debuggable="true">
-        <uses-library android:name="android.test.runner" />
-        <activity android:name="com.android.telephony.qns.wfc.WfcActivationActivity" />
-    </application>
-
-    <instrumentation android:name="androidx.test.runner.AndroidJUnitRunner"
-        android:targetPackage="com.android.telephony.qns.tests"
-        android:label="Tests for QualifiedNetworksService">
-    </instrumentation>
-</manifest>
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/AccessNetworkEvaluatorTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/AccessNetworkEvaluatorTest.java
deleted file mode 100644
index cb7a516..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/AccessNetworkEvaluatorTest.java
+++ /dev/null
@@ -1,1837 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static com.android.telephony.qns.DataConnectionStatusTracker.EVENT_DATA_CONNECTION_DISCONNECTED;
-import static com.android.telephony.qns.DataConnectionStatusTracker.EVENT_DATA_CONNECTION_FAILED;
-import static com.android.telephony.qns.DataConnectionStatusTracker.STATE_INACTIVE;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyBoolean;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.ArgumentMatchers.isNotNull;
-import static org.mockito.Mockito.atLeast;
-import static org.mockito.Mockito.doNothing;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.timeout;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.net.NetworkCapabilities;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Looper;
-import android.os.Message;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.ServiceState;
-import android.telephony.SignalThresholdInfo;
-import android.telephony.TelephonyManager;
-import android.telephony.data.ApnSetting;
-import android.telephony.ims.ImsReasonInfo;
-import android.telephony.ims.ProvisioningManager;
-
-import com.android.telephony.qns.AccessNetworkSelectionPolicy.PreCondition;
-import com.android.telephony.qns.QnsProvisioningListener.QnsProvisioningInfo;
-import com.android.telephony.qns.QnsTelephonyListener.QnsTelephonyInfoIms;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.mockito.stubbing.Answer;
-
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.stream.IntStream;
-
-@RunWith(JUnit4.class)
-public class AccessNetworkEvaluatorTest extends QnsTest {
-    private static final String TEST_PLMN = "707333";
-    private static final int QUALIFIED_NETWORKS_CHANGED = 2;
-
-    private static final int EVENT_BASE = 10000;
-    private static final int EVENT_IWLAN_NETWORK_STATUS_CHANGED = EVENT_BASE;
-    private static final int EVENT_QNS_TELEPHONY_INFO_CHANGED = EVENT_BASE + 1;
-    private static final int EVENT_SET_CALL_TYPE = EVENT_BASE + 5;
-    private static final int EVENT_EMERGENCY_PREFERRED_TRANSPORT_TYPE_CHANGED = EVENT_BASE + 7;
-    private static final int EVENT_PROVISIONING_INFO_CHANGED = EVENT_BASE + 8;
-    private static final int EVENT_WFC_ACTIVATION_WITH_IWLAN_CONNECTION_REQUIRED = EVENT_BASE + 9;
-    private static final int EVENT_IMS_REGISTRATION_STATE_CHANGED = EVENT_BASE + 10;
-    private static final int EVENT_SIP_DIALOG_SESSION_STATE_CHANGED = EVENT_BASE + 12;
-    private static final int EVENT_IMS_CALL_DISCONNECT_CAUSE_CHANGED = EVENT_BASE + 13;
-
-    @Mock private RestrictManager mRestrictManager;
-    @Mock private DataConnectionStatusTracker mDataConnectionStatusTracker;
-    @Mock private QnsImsManager.ImsRegistrationState mMockImsRegistrationState;
-    private AccessNetworkEvaluator mAne;
-    private Handler mHandler;
-    private QualifiedNetworksServiceImpl.QualifiedNetworksInfo mQualifiedNetworksInfo;
-    private Map<PreCondition, List<AccessNetworkSelectionPolicy>> mTestAnspPolicyMap = null;
-    private CountDownLatch mLatch;
-    private int mSlotIndex = 0;
-    private int mNetCapability = NetworkCapabilities.NET_CAPABILITY_IMS;
-    private HandlerThread mHandlerThread;
-    private int mRatPreference = QnsConstants.RAT_PREFERENCE_DEFAULT;
-
-    private boolean mWfcEnabledByUser = true;
-    private boolean mWfcRoamingEnabledByUser = false;
-    private boolean mWfcEnabledByPlatform = true;
-    private boolean mWfcProvisioned = true;
-    private boolean mCrossSimEnabled = false;
-    private boolean mWfcRoamingEnabled = true;
-    private int mWfcMode = QnsConstants.WIFI_PREF;
-    private int mWfcModeRoaming = QnsConstants.WIFI_PREF;
-
-    private class AneHandler extends Handler {
-        AneHandler() {
-            super(mHandlerThread.getLooper());
-        }
-
-        @Override
-        public void handleMessage(Message msg) {
-            super.handleMessage(msg);
-            switch (msg.what) {
-                case QUALIFIED_NETWORKS_CHANGED:
-                    QnsAsyncResult ar = (QnsAsyncResult) msg.obj;
-                    mQualifiedNetworksInfo =
-                            (QualifiedNetworksServiceImpl.QualifiedNetworksInfo) ar.mResult;
-                    mLatch.countDown();
-                    break;
-                default:
-                    break;
-            }
-        }
-    }
-
-    @Before
-    public void setUp() throws Exception {
-        MockitoAnnotations.initMocks(this);
-        super.setUp();
-        mHandlerThread = new HandlerThread("");
-        mLatch = new CountDownLatch(1);
-        stubQnsDefaultWfcSettings();
-        mAne =
-                new AccessNetworkEvaluator(
-                        mQnsComponents[mSlotIndex],
-                        mNetCapability,
-                        mRestrictManager,
-                        mDataConnectionStatusTracker,
-                        mSlotIndex);
-        mHandlerThread.start();
-        mHandler = new AneHandler();
-        // wait for AccessNetworkSelectionPolicy to build
-        waitForLastHandlerAction(mAne.mHandler);
-    }
-
-    private void stubQnsDefaultWfcSettings() {
-        when(mMockQnsImsManager.isWfcEnabledByPlatform()).thenAnswer(i -> mWfcEnabledByPlatform);
-        when(mMockQnsImsManager.isWfcEnabledByUser()).thenAnswer(i -> mWfcEnabledByUser);
-        when(mMockQnsImsManager.isWfcRoamingEnabledByUser())
-                .thenAnswer(i -> mWfcRoamingEnabledByUser);
-        when(mMockQnsImsManager.isWfcProvisionedOnDevice()).thenAnswer(i -> mWfcProvisioned);
-        when(mMockQnsImsManager.isCrossSimCallingEnabled()).thenAnswer(i -> mCrossSimEnabled);
-        when(mMockQnsProvisioningListener.getLastProvisioningWfcRoamingEnabledInfo())
-                .thenAnswer(i -> mWfcRoamingEnabled);
-        when(mMockQnsImsManager.getWfcMode(anyBoolean()))
-                .thenAnswer(i -> (boolean) i.getArguments()[0] ? mWfcModeRoaming : mWfcMode);
-
-        when(mMockQnsTelephonyListener.getLastQnsTelephonyInfo())
-                .thenReturn(mMockQnsTelephonyListener.new QnsTelephonyInfo());
-        when(mMockQnsTelephonyListener.getLastQnsTelephonyInfo())
-                .thenReturn(mMockQnsTelephonyListener.new QnsTelephonyInfo());
-    }
-
-    @After
-    public void tearDown() {
-        if (mAne != null) {
-            mAne.close();
-        }
-        if (mHandlerThread != null) {
-            mHandlerThread.quit();
-        }
-    }
-
-    @Test
-    public void testRegisterForQualifiedNetworksChanged() {
-        Handler h2 = new Handler(Looper.getMainLooper());
-        mAne.registerForQualifiedNetworksChanged(mHandler, QUALIFIED_NETWORKS_CHANGED);
-        mAne.registerForQualifiedNetworksChanged(mHandler, 2);
-        assertEquals(1, mAne.mQualifiedNetworksChangedRegistrants.size());
-        mAne.registerForQualifiedNetworksChanged(h2, 3);
-        assertEquals(2, mAne.mQualifiedNetworksChangedRegistrants.size());
-    }
-
-    @Test
-    public void testUnregisterForQualifiedNetworksChanged() {
-        Handler h2 = new Handler(Looper.getMainLooper());
-        mAne.registerForQualifiedNetworksChanged(mHandler, QUALIFIED_NETWORKS_CHANGED);
-        mAne.registerForQualifiedNetworksChanged(h2, 3);
-        assertEquals(2, mAne.mQualifiedNetworksChangedRegistrants.size());
-        mAne.unregisterForQualifiedNetworksChanged(h2);
-        assertEquals(1, mAne.mQualifiedNetworksChangedRegistrants.size());
-    }
-
-    /**
-     * This test covers test cases for below methods of ANE: updateLastNotifiedQualifiedNetwork(),
-     * getLastQualifiedTransportType(), initLastNotifiedQualifiedNetwork(),
-     * equalsLastNotifiedQualifiedNetwork()
-     */
-    @Test
-    public void testLastNotifiedQualifiedNetwork() {
-        List<Integer> accessNetworks = new ArrayList<>();
-        accessNetworks.add(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        mAne.updateLastNotifiedQualifiedNetwork(accessNetworks);
-        assertFalse(
-                mAne.equalsLastNotifiedQualifiedNetwork(
-                        List.of(AccessNetworkConstants.AccessNetworkType.IWLAN)));
-        assertTrue(
-                mAne.equalsLastNotifiedQualifiedNetwork(
-                        List.of(AccessNetworkConstants.AccessNetworkType.EUTRAN)));
-        assertEquals(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN, mAne.getLastQualifiedTransportType());
-        mAne.initLastNotifiedQualifiedNetwork();
-        assertEquals(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN, mAne.getLastQualifiedTransportType());
-
-        accessNetworks.clear();
-        accessNetworks.add(AccessNetworkConstants.AccessNetworkType.NGRAN);
-        mAne.updateLastNotifiedQualifiedNetwork(accessNetworks);
-        assertFalse(
-                mAne.equalsLastNotifiedQualifiedNetwork(
-                        List.of(AccessNetworkConstants.AccessNetworkType.IWLAN)));
-        assertFalse(
-                mAne.equalsLastNotifiedQualifiedNetwork(
-                        List.of(AccessNetworkConstants.AccessNetworkType.EUTRAN)));
-        assertTrue(
-                mAne.equalsLastNotifiedQualifiedNetwork(
-                        List.of(AccessNetworkConstants.AccessNetworkType.NGRAN)));
-        assertEquals(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN, mAne.getLastQualifiedTransportType());
-        mAne.initLastNotifiedQualifiedNetwork();
-        assertEquals(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN, mAne.getLastQualifiedTransportType());
-
-        accessNetworks.clear();
-        accessNetworks.add(AccessNetworkConstants.AccessNetworkType.IWLAN);
-        mAne.updateLastNotifiedQualifiedNetwork(accessNetworks);
-        assertTrue(
-                mAne.equalsLastNotifiedQualifiedNetwork(
-                        List.of(AccessNetworkConstants.AccessNetworkType.IWLAN)));
-        assertFalse(
-                mAne.equalsLastNotifiedQualifiedNetwork(
-                        List.of(AccessNetworkConstants.AccessNetworkType.EUTRAN)));
-        assertEquals(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN, mAne.getLastQualifiedTransportType());
-        mAne.initLastNotifiedQualifiedNetwork();
-        assertEquals(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN, mAne.getLastQualifiedTransportType());
-    }
-
-    @Test
-    public void testNotifyForQualifiedNetworksChanged() throws Exception {
-        mLatch = new CountDownLatch(1);
-        List<Integer> accessNetworks = new ArrayList<>();
-        accessNetworks.add(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        mAne.registerForQualifiedNetworksChanged(mHandler, QUALIFIED_NETWORKS_CHANGED);
-        mAne.notifyForQualifiedNetworksChanged(accessNetworks);
-        assertTrue(mLatch.await(3, TimeUnit.SECONDS));
-        assertEquals(accessNetworks, mQualifiedNetworksInfo.getAccessNetworkTypes());
-    }
-
-    @Test
-    public void testMoveTransportTypeAllowed() {
-        waitForLastHandlerAction(mAne.mHandler);
-        when(mMockQnsConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_IMS,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        QnsConstants.COVERAGE_HOME))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_IMS,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        AccessNetworkConstants.AccessNetworkType.NGRAN,
-                        QnsConstants.COVERAGE_ROAM))
-                .thenReturn(false);
-        when(mMockQnsConfigManager.isVolteRoamingSupported(anyInt())).thenReturn(true);
-        when(mDataConnectionStatusTracker.isActiveState()).thenReturn(true);
-        when(mDataConnectionStatusTracker.getLastTransportType())
-                .thenReturn(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        when(mMockQnsCallStatusTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(true);
-        List<Integer> accessNetworks = new ArrayList<>();
-        accessNetworks.add(AccessNetworkConstants.AccessNetworkType.IWLAN);
-        QnsTelephonyListener.QnsTelephonyInfo info =
-                mMockQnsTelephonyListener.new QnsTelephonyInfo();
-        info.setCellularAvailable(false);
-        info.setCoverage(false);
-        info.setDataNetworkType(TelephonyManager.NETWORK_TYPE_UNKNOWN);
-        info.setVoiceNetworkType(TelephonyManager.NETWORK_TYPE_UNKNOWN);
-        info.setDataRegState(ServiceState.STATE_OUT_OF_SERVICE);
-        QnsTelephonyInfoIms infoIms =
-                mMockQnsTelephonyListener.new QnsTelephonyInfoIms(info, true, true, false, false);
-        mAne.onQnsTelephonyInfoChanged(infoIms);
-        mAne.updateLastNotifiedQualifiedNetwork(accessNetworks);
-        assertFalse(mAne.isHandoverPolicyCheckAvailable());
-        assertTrue(mAne.moveTransportTypeAllowed());
-
-        info = mMockQnsTelephonyListener.new QnsTelephonyInfo();
-        info.setCellularAvailable(true);
-        info.setCoverage(true);
-        info.setDataNetworkType(TelephonyManager.NETWORK_TYPE_LTE);
-        info.setVoiceNetworkType(TelephonyManager.NETWORK_TYPE_LTE);
-        info.setDataRegState(ServiceState.STATE_IN_SERVICE);
-        infoIms = mMockQnsTelephonyListener.new QnsTelephonyInfoIms(info, true, true, true, true);
-        mAne.onQnsTelephonyInfoChanged(infoIms);
-        mAne.updateLastNotifiedQualifiedNetwork(accessNetworks);
-        assertTrue(mAne.isHandoverPolicyCheckAvailable());
-        assertTrue(mAne.moveTransportTypeAllowed());
-
-        info = mMockQnsTelephonyListener.new QnsTelephonyInfo();
-        info.setCellularAvailable(true);
-        info.setCoverage(false);
-        info.setDataNetworkType(TelephonyManager.NETWORK_TYPE_NR);
-        info.setVoiceNetworkType(TelephonyManager.NETWORK_TYPE_NR);
-        info.setDataRegState(ServiceState.STATE_IN_SERVICE);
-        infoIms = mMockQnsTelephonyListener.new QnsTelephonyInfoIms(info, true, true, true, true);
-        mAne.onQnsTelephonyInfoChanged(infoIms);
-        mAne.updateLastNotifiedQualifiedNetwork(accessNetworks);
-        assertTrue(mAne.isHandoverPolicyCheckAvailable());
-        assertTrue(mAne.moveTransportTypeAllowed());
-    }
-
-    @Test
-    public void testMoveTransportTypeAllowedEmergencyOverIms() {
-        waitForLastHandlerAction(mAne.mHandler);
-        when(mMockQnsConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_IMS,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        QnsConstants.COVERAGE_HOME))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_IMS,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        QnsConstants.COVERAGE_HOME))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.isVolteRoamingSupported(anyInt())).thenReturn(true);
-        when(mDataConnectionStatusTracker.isActiveState()).thenReturn(true);
-        when(mDataConnectionStatusTracker.getLastTransportType())
-                .thenReturn(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        when(mMockQnsCallStatusTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(true);
-        List<Integer> accessNetworks = new ArrayList<>();
-        accessNetworks.add(AccessNetworkConstants.AccessNetworkType.IWLAN);
-        QnsTelephonyListener.QnsTelephonyInfo info =
-                mMockQnsTelephonyListener.new QnsTelephonyInfo();
-        info.setCellularAvailable(true);
-        info.setCoverage(false);
-        info.setDataNetworkType(TelephonyManager.NETWORK_TYPE_LTE);
-        info.setVoiceNetworkType(TelephonyManager.NETWORK_TYPE_LTE);
-        info.setDataRegState(ServiceState.STATE_IN_SERVICE);
-        QnsTelephonyInfoIms infoIms =
-                mMockQnsTelephonyListener.new QnsTelephonyInfoIms(info, true, true, false, false);
-        mAne.onQnsTelephonyInfoChanged(infoIms);
-        mAne.updateLastNotifiedQualifiedNetwork(accessNetworks);
-        mAne.onSetCallType(QnsConstants.CALL_TYPE_EMERGENCY);
-        assertTrue(mAne.isHandoverPolicyCheckAvailable());
-        assertTrue(mAne.moveTransportTypeAllowed());
-
-        when(mMockQnsConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_IMS,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        AccessNetworkConstants.AccessNetworkType.UTRAN,
-                        QnsConstants.COVERAGE_HOME))
-                .thenReturn(false);
-        info = mMockQnsTelephonyListener.new QnsTelephonyInfo();
-        info.setCellularAvailable(true);
-        info.setCoverage(false);
-        info.setDataNetworkType(TelephonyManager.NETWORK_TYPE_UMTS);
-        info.setVoiceNetworkType(TelephonyManager.NETWORK_TYPE_UMTS);
-        info.setDataRegState(ServiceState.STATE_IN_SERVICE);
-        infoIms = mMockQnsTelephonyListener.new QnsTelephonyInfoIms(info, true, true, false, false);
-        mAne.onQnsTelephonyInfoChanged(infoIms);
-        mAne.updateLastNotifiedQualifiedNetwork(accessNetworks);
-        mAne.onSetCallType(QnsConstants.CALL_TYPE_VOICE);
-        when(mMockQnsCallStatusTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(false);
-        assertTrue(mAne.isHandoverPolicyCheckAvailable());
-        assertFalse(mAne.moveTransportTypeAllowed());
-        mAne.updateLastNotifiedQualifiedNetwork(accessNetworks);
-        mAne.onSetCallType(QnsConstants.CALL_TYPE_IDLE);
-        when(mMockQnsCallStatusTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(true);
-        assertTrue(mAne.isHandoverPolicyCheckAvailable());
-        assertTrue(mAne.moveTransportTypeAllowed());
-        mAne.updateLastNotifiedQualifiedNetwork(accessNetworks);
-        mAne.onSetCallType(QnsConstants.CALL_TYPE_EMERGENCY);
-        when(mMockQnsCallStatusTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(false);
-        assertTrue(mAne.isHandoverPolicyCheckAvailable());
-        assertFalse(mAne.moveTransportTypeAllowed());
-    }
-
-    @Test
-    public void testVopsCheckRequired() {
-        waitForLastHandlerAction(mAne.mHandler);
-        when(mDataConnectionStatusTracker.getLastTransportType())
-                .thenReturn(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        when(mMockQnsConfigManager.isHandoverAllowedByPolicy(
-                        anyInt(), anyInt(), anyInt(), anyInt()))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.isMmtelCapabilityRequired(QnsConstants.COVERAGE_HOME))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.isMmtelCapabilityRequired(QnsConstants.COVERAGE_ROAM))
-                .thenReturn(false);
-        when(mMockQnsConfigManager.isInCallHoDecisionWlanToWwanWithoutVopsCondition())
-                .thenReturn(false);
-        assertTrue(
-                mAne.vopsCheckRequired(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        QnsConstants.COVERAGE_HOME,
-                        QnsConstants.CALL_TYPE_IDLE));
-        assertFalse(
-                mAne.vopsCheckRequired(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        QnsConstants.COVERAGE_ROAM,
-                        QnsConstants.CALL_TYPE_IDLE));
-        when(mMockQnsConfigManager.isInCallHoDecisionWlanToWwanWithoutVopsCondition())
-                .thenReturn(true);
-        assertFalse(
-                mAne.vopsCheckRequired(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        QnsConstants.COVERAGE_HOME,
-                        QnsConstants.CALL_TYPE_VOICE));
-        when(mDataConnectionStatusTracker.getLastTransportType())
-                .thenReturn(AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        assertTrue(
-                mAne.vopsCheckRequired(
-                        AccessNetworkConstants.AccessNetworkType.NGRAN,
-                        QnsConstants.COVERAGE_HOME,
-                        QnsConstants.CALL_TYPE_IDLE));
-        assertFalse(
-                mAne.vopsCheckRequired(
-                        AccessNetworkConstants.AccessNetworkType.NGRAN,
-                        QnsConstants.COVERAGE_HOME,
-                        QnsConstants.CALL_TYPE_VOICE));
-        assertFalse(
-                mAne.vopsCheckRequired(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        QnsConstants.COVERAGE_ROAM,
-                        QnsConstants.CALL_TYPE_IDLE));
-    }
-
-    /**
-     * This method covers test for onCellularQualityChanged(), on WifiQualityChanged(),
-     * onQnsTelephonyInfoChanged() and evaluate() methods of ANE. Since all these methods call for
-     * the evaluation of access networks, testing them separately will repeat the test cases.
-     */
-    @Test
-    public void testEvaluationOfQualifiedNetwork() throws Exception {
-        mLatch = new CountDownLatch(1);
-        mAne.registerForQualifiedNetworksChanged(mHandler, QUALIFIED_NETWORKS_CHANGED);
-        waitForLastHandlerAction(mAne.mHandler);
-        List<Integer> accessNetworks = new ArrayList<>();
-        accessNetworks.add(AccessNetworkConstants.AccessNetworkType.IWLAN);
-        mAne.updateLastNotifiedQualifiedNetwork(accessNetworks);
-
-        when(mMockQnsConfigManager.isMmtelCapabilityRequired(anyInt())).thenReturn(true);
-        when(mMockQnsConfigManager.isServiceBarringCheckSupported()).thenReturn(true);
-        when(mMockQnsConfigManager.isInCallHoDecisionWlanToWwanWithoutVopsCondition())
-                .thenReturn(false);
-        when(mMockQnsConfigManager.isHandoverAllowedByPolicy(
-                        anyInt(), anyInt(), anyInt(), anyInt()))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.allowWFCOnAirplaneModeOn()).thenReturn(true);
-        when(mMockQnsConfigManager.isAccessNetworkAllowed(anyInt(), anyInt())).thenReturn(true);
-        when(mMockQnsConfigManager.isVolteRoamingSupported(anyInt())).thenReturn(true);
-        when(mMockQnsConfigManager.blockIwlanInInternationalRoamWithoutWwan()).thenReturn(false);
-        when(mMockQnsConfigManager.getRatPreference(NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(QnsConstants.RAT_PREFERENCE_DEFAULT);
-
-        when(mDataConnectionStatusTracker.isActiveState()).thenReturn(false);
-        when(mDataConnectionStatusTracker.isInactiveState()).thenReturn(true);
-        when(mDataConnectionStatusTracker.isHandoverState()).thenReturn(false);
-
-        when(mRestrictManager.isRestricted(anyInt())).thenReturn(true);
-        when(mRestrictManager.isAllowedOnSingleTransport(anyInt())).thenReturn(true);
-
-        QnsTelephonyListener.QnsTelephonyInfo info =
-                mMockQnsTelephonyListener.new QnsTelephonyInfo();
-        info.setCellularAvailable(true);
-        info.setCoverage(true);
-        info.setDataNetworkType(TelephonyManager.NETWORK_TYPE_LTE);
-        info.setVoiceNetworkType(TelephonyManager.NETWORK_TYPE_LTE);
-        info.setDataRegState(ServiceState.STATE_IN_SERVICE);
-        Message.obtain(
-                        mAne.mHandler,
-                        EVENT_QNS_TELEPHONY_INFO_CHANGED,
-                        new QnsAsyncResult(null, info, null))
-                .sendToTarget();
-        waitForLastHandlerAction(mAne.mHandler);
-        // mAne.onQnsTelephonyInfoChanged(infoIms);
-
-        assertTrue(mLatch.await(3, TimeUnit.SECONDS));
-        ArrayList<Integer> expected = new ArrayList<>();
-        expected.add(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        assertEquals(expected, mQualifiedNetworksInfo.getAccessNetworkTypes());
-    }
-
-    @Test
-    public void testOnIwlanNetworkStatusChanged() {
-        // ANE takes time to build ANSP.
-        waitForLastHandlerAction(mAne.mHandler);
-        when(mRestrictManager.isRestricted(anyInt())).thenReturn(false);
-        when(mRestrictManager.isAllowedOnSingleTransport(anyInt())).thenReturn(true);
-        Message.obtain(
-                        mAne.mHandler,
-                        EVENT_IWLAN_NETWORK_STATUS_CHANGED,
-                        new QnsAsyncResult(
-                                null,
-                                mMockIwlanNetworkStatusTracker
-                                .new IwlanAvailabilityInfo(true, false),
-                                null))
-                .sendToTarget();
-        waitForLastHandlerAction(mAne.mHandler);
-        assertTrue(mAne.mIwlanAvailable);
-        Message.obtain(
-                        mAne.mHandler,
-                        EVENT_IWLAN_NETWORK_STATUS_CHANGED,
-                        new QnsAsyncResult(
-                                null,
-                                mMockIwlanNetworkStatusTracker
-                                .new IwlanAvailabilityInfo(false, false),
-                                null))
-                .sendToTarget();
-        waitForLastHandlerAction(mAne.mHandler);
-        assertFalse(mAne.mIwlanAvailable);
-    }
-
-    @Test
-    public void testOnTryWfcConnectionStateChanged() {
-        mWfcMode = QnsConstants.CELL_PREF;
-        mWfcModeRoaming = QnsConstants.CELL_PREF;
-
-        // ANE takes time to build ANSP.
-        waitForLastHandlerAction(mAne.mHandler);
-
-        mAne.onTryWfcConnectionStateChanged(true);
-        Message.obtain(
-                        mAne.mHandler,
-                        EVENT_WFC_ACTIVATION_WITH_IWLAN_CONNECTION_REQUIRED,
-                        new QnsAsyncResult(null, true, null))
-                .sendToTarget();
-        waitForDelayedHandlerAction(mAne.mHandler, 3000, 200);
-        assertTrue(mAne.isWfcEnabled());
-        assertEquals(QnsConstants.WIFI_PREF, mAne.getPreferredMode());
-        mWfcEnabledByPlatform = false;
-        Message.obtain(
-                        mAne.mHandler,
-                        EVENT_WFC_ACTIVATION_WITH_IWLAN_CONNECTION_REQUIRED,
-                        new QnsAsyncResult(null, false, null))
-                .sendToTarget();
-        waitForLastHandlerAction(mAne.mHandler);
-        assertFalse(mAne.isWfcEnabled());
-        assertEquals(QnsConstants.CELL_PREF, mAne.getPreferredMode());
-    }
-
-    @Test
-    public void testGetTargetTransportType() {
-        waitForLastHandlerAction(mAne.mHandler);
-        List<Integer> accessNetworks = new ArrayList<>();
-        accessNetworks.add(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        assertEquals(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                mAne.getTargetTransportType(accessNetworks));
-        accessNetworks.clear();
-
-        accessNetworks.add(AccessNetworkConstants.AccessNetworkType.IWLAN);
-        assertEquals(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                mAne.getTargetTransportType(accessNetworks));
-        accessNetworks.clear();
-
-        accessNetworks.add(AccessNetworkConstants.AccessNetworkType.UNKNOWN);
-        assertEquals(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                mAne.getTargetTransportType(accessNetworks));
-        accessNetworks.clear();
-
-        accessNetworks.add(AccessNetworkConstants.AccessNetworkType.NGRAN);
-        assertEquals(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                mAne.getTargetTransportType(accessNetworks));
-        accessNetworks.clear();
-
-        accessNetworks = null;
-        assertEquals(
-                AccessNetworkConstants.TRANSPORT_TYPE_INVALID,
-                mAne.getTargetTransportType(accessNetworks));
-    }
-
-    @Test
-    public void testIsHandoverNeeded() {
-        // ANE takes time to build ANSP.
-        waitForLastHandlerAction(mAne.mHandler);
-        List<Integer> accessNetworks = new ArrayList<>();
-        accessNetworks.add(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        when(mDataConnectionStatusTracker.isInactiveState()).thenReturn(true, false);
-        when(mDataConnectionStatusTracker.isHandoverState()).thenReturn(true, false);
-        when(mDataConnectionStatusTracker.getLastTransportType())
-                .thenReturn(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        assertFalse(mAne.isHandoverNeeded(accessNetworks)); // isInactiveState
-        assertFalse(mAne.isHandoverNeeded(accessNetworks)); // isHandoverState
-        assertFalse(mAne.isHandoverNeeded(accessNetworks)); // same last TransportType
-        assertTrue(mAne.isHandoverNeeded(accessNetworks)); // all OK
-    }
-
-    @Test
-    public void testIsFallbackCase() {
-        List<Integer> accessNetworks = new ArrayList<>();
-        accessNetworks.add(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        mAne.updateLastNotifiedQualifiedNetwork(accessNetworks);
-        when(mDataConnectionStatusTracker.isInactiveState()).thenReturn(true, false);
-        when(mDataConnectionStatusTracker.getLastTransportType())
-                .thenReturn(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        assertFalse(mAne.isFallbackCase(accessNetworks)); // isInactiveState
-        assertFalse(mAne.isFallbackCase(accessNetworks)); // target TT != last TT
-        assertFalse(mAne.isFallbackCase(accessNetworks)); // LastQualifiedTransportType == TT
-        List<Integer> accessNetworks2 = new ArrayList<>();
-        accessNetworks2.add(AccessNetworkConstants.AccessNetworkType.IWLAN);
-        mAne.updateLastNotifiedQualifiedNetwork(accessNetworks2);
-        assertTrue(mAne.isFallbackCase(accessNetworks)); // all OK
-    }
-
-    @Test
-    public void testReportQualifiedNetwork_WithoutListAndCellularLimtedCaseSet() {
-        when(mMockQnsConfigManager.isAccessNetworkAllowed(anyInt(), anyInt()))
-                .thenReturn(false, true);
-        when(mMockQnsConfigManager.allowImsOverIwlanCellularLimitedCase()).thenReturn(true);
-        List<Integer> accessNetworks2 = new ArrayList<>();
-        accessNetworks2.add(AccessNetworkConstants.AccessNetworkType.IWLAN);
-        mAne.updateLastNotifiedQualifiedNetwork(accessNetworks2);
-        mAne.reportQualifiedNetwork(List.of(AccessNetworkConstants.AccessNetworkType.EUTRAN));
-        assertEquals(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN, mAne.getLastQualifiedTransportType());
-        mAne.reportQualifiedNetwork(List.of(AccessNetworkConstants.AccessNetworkType.EUTRAN));
-        assertEquals(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN, mAne.getLastQualifiedTransportType());
-    }
-
-    @Test
-    public void testReportQualifiedNetwork_WithListAndCellularLimtedCaseSet() {
-        when(mMockQnsConfigManager.isAccessNetworkAllowed(anyInt(), anyInt()))
-                .thenReturn(false, true);
-        when(mMockQnsConfigManager.allowImsOverIwlanCellularLimitedCase()).thenReturn(true);
-        List<Integer> accessNetworks1 = new ArrayList<>();
-        List<Integer> accessNetworks2 = new ArrayList<>();
-        accessNetworks1.add(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        accessNetworks2.add(AccessNetworkConstants.AccessNetworkType.IWLAN);
-        mAne.updateLastNotifiedQualifiedNetwork(accessNetworks2);
-        mAne.reportQualifiedNetwork(accessNetworks1);
-        assertEquals(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN, mAne.getLastQualifiedTransportType());
-        accessNetworks1.clear();
-        accessNetworks1.add(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        mAne.reportQualifiedNetwork(accessNetworks1);
-        assertEquals(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN, mAne.getLastQualifiedTransportType());
-    }
-
-    @Test
-    public void testReportQualifiedNetwork_WithListAndCellularLimtedCaseSet_NonIms() {
-        mAne =
-                new AccessNetworkEvaluator(
-                        mQnsComponents[mSlotIndex],
-                        NetworkCapabilities.NET_CAPABILITY_MMS,
-                        mRestrictManager,
-                        mDataConnectionStatusTracker,
-                        mSlotIndex);
-        waitForLastHandlerAction(mAne.mHandler);
-        when(mMockQnsConfigManager.isAccessNetworkAllowed(anyInt(), anyInt())).thenReturn(false);
-        when(mMockQnsConfigManager.allowImsOverIwlanCellularLimitedCase()).thenReturn(true);
-        List<Integer> accessNetworks1 = new ArrayList<>();
-        List<Integer> accessNetworks2 = new ArrayList<>();
-        accessNetworks1.add(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        accessNetworks2.add(AccessNetworkConstants.AccessNetworkType.IWLAN);
-        mAne.updateLastNotifiedQualifiedNetwork(accessNetworks2);
-        mAne.reportQualifiedNetwork(accessNetworks1);
-        assertEquals(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN, mAne.getLastQualifiedTransportType());
-    }
-
-    @Test
-    public void testReportQualifiedNetwork_WithoutList() {
-        when(mMockQnsConfigManager.isAccessNetworkAllowed(anyInt(), anyInt()))
-                .thenReturn(false, true);
-        when(mMockQnsConfigManager.allowImsOverIwlanCellularLimitedCase()).thenReturn(false);
-        List<Integer> accessNetworks2 = new ArrayList<>();
-        accessNetworks2.add(AccessNetworkConstants.AccessNetworkType.IWLAN);
-        mAne.updateLastNotifiedQualifiedNetwork(accessNetworks2);
-        mAne.reportQualifiedNetwork(List.of(AccessNetworkConstants.AccessNetworkType.EUTRAN));
-        assertEquals(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN, mAne.getLastQualifiedTransportType());
-    }
-
-    @Test
-    public void testReportQualifiedNetwork_WithList() {
-        waitForLastHandlerAction(mAne.mHandler);
-        when(mMockQnsConfigManager.isAccessNetworkAllowed(anyInt(), anyInt()))
-                .thenReturn(false, true);
-        when(mMockQnsConfigManager.allowImsOverIwlanCellularLimitedCase()).thenReturn(false);
-        List<Integer> accessNetworks1 = new ArrayList<>();
-        List<Integer> accessNetworks2 = new ArrayList<>();
-        accessNetworks1.add(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        accessNetworks2.add(AccessNetworkConstants.AccessNetworkType.IWLAN);
-        mAne.updateLastNotifiedQualifiedNetwork(accessNetworks2);
-        mAne.reportQualifiedNetwork(accessNetworks1);
-        assertEquals(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN, mAne.getLastQualifiedTransportType());
-    }
-
-    @Test
-    public void testCellularUnavailableWhenVolteRoamingNotSupported() {
-        waitForLastHandlerAction(mAne.mHandler);
-        doReturn(true).when(mMockQnsConfigManager).isMmtelCapabilityRequired(anyInt());
-        doReturn(false).when(mMockQnsConfigManager).isServiceBarringCheckSupported();
-        doReturn(false)
-                .when(mMockQnsConfigManager)
-                .isInCallHoDecisionWlanToWwanWithoutVopsCondition();
-        doReturn(true)
-                .when(mMockQnsConfigManager)
-                .isHandoverAllowedByPolicy(anyInt(), anyInt(), anyInt(), anyInt());
-        doReturn(false).when(mMockQnsConfigManager).isVolteRoamingSupported(anyInt());
-        doReturn(AccessNetworkConstants.TRANSPORT_TYPE_WWAN)
-                .when(mDataConnectionStatusTracker)
-                .getLastTransportType();
-        doReturn(null)
-                .when(mMockQnsConfigManager)
-                .getThresholdByPref(anyInt(), anyInt(), anyInt(), anyInt());
-        QnsTelephonyListener.QnsTelephonyInfo info =
-                mMockQnsTelephonyListener.new QnsTelephonyInfo();
-        info.setCellularAvailable(true);
-        info.setCoverage(true);
-        info.setDataNetworkType(TelephonyManager.NETWORK_TYPE_LTE);
-        info.setVoiceNetworkType(TelephonyManager.NETWORK_TYPE_LTE);
-        info.setDataRegState(ServiceState.STATE_IN_SERVICE);
-        QnsTelephonyInfoIms infoIms =
-                mMockQnsTelephonyListener.new QnsTelephonyInfoIms(info, true, true, false, false);
-        mAne.onQnsTelephonyInfoChanged(infoIms);
-        assertFalse(mAne.mCellularAvailable);
-    }
-
-    @Test
-    public void testUpdateThrottleStatus() {
-        mAne.updateThrottleStatus(false, 30000, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        verify(mRestrictManager)
-                .notifyThrottling(false, 30000, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-    }
-
-    @Test
-    public void testGetCoverage() {
-        QnsTelephonyListener.QnsTelephonyInfo info =
-                mMockQnsTelephonyListener.new QnsTelephonyInfo();
-        QnsTelephonyInfoIms infoIms =
-                mMockQnsTelephonyListener.new QnsTelephonyInfoIms(info, true, true, false, false);
-        infoIms.setRegisteredPlmn(TEST_PLMN);
-
-        infoIms.setCoverage(true);
-        assertEquals(QnsConstants.COVERAGE_ROAM, mAne.getCoverage(infoIms));
-
-        infoIms.setCoverage(false);
-        assertEquals(QnsConstants.COVERAGE_HOME, mAne.getCoverage(infoIms));
-    }
-
-    @Test
-    public void testUseDifferentApnOverIwlan() {
-        mAne =
-                new AccessNetworkEvaluator(
-                        mQnsComponents[mSlotIndex],
-                        NetworkCapabilities.NET_CAPABILITY_MMS,
-                        mRestrictManager,
-                        mDataConnectionStatusTracker,
-                        mSlotIndex);
-        waitForLastHandlerAction(mAne.mHandler);
-        ApnSetting apnSettingForCellular =
-                new ApnSetting.Builder()
-                        .setApnName("internetmms")
-                        .setEntryName("internetmms")
-                        .setApnTypeBitmask(
-                                ApnSetting.TYPE_DEFAULT
-                                        | ApnSetting.TYPE_MMS
-                                        | ApnSetting.TYPE_XCAP
-                                        | ApnSetting.TYPE_CBS)
-                        .setNetworkTypeBitmask(
-                                (int) TelephonyManager.NETWORK_STANDARDS_FAMILY_BITMASK_3GPP)
-                        .setCarrierEnabled(true)
-                        .build();
-        when(mMockQnsConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_MMS,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        QnsConstants.COVERAGE_HOME))
-                .thenReturn(false);
-        when(mDataConnectionStatusTracker.getLastTransportType())
-                .thenReturn(AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        when(mDataConnectionStatusTracker.getLastApnSetting(anyInt()))
-                .thenReturn(apnSettingForCellular);
-
-        assertTrue(mAne.moveTransportTypeAllowed());
-    }
-
-    @Test
-    public void testRatPreferenceWifiWhenNoCellularHandoverDisallowedButMoveToCellular() {
-        mAne =
-                new AccessNetworkEvaluator(
-                        mQnsComponents[mSlotIndex],
-                        NetworkCapabilities.NET_CAPABILITY_XCAP,
-                        mRestrictManager,
-                        mDataConnectionStatusTracker,
-                        mSlotIndex);
-        waitForLastHandlerAction(mAne.mHandler);
-        QnsTelephonyListener.QnsTelephonyInfo info =
-                mMockQnsTelephonyListener.new QnsTelephonyInfo();
-        info.setCellularAvailable(true);
-        info.setCoverage(false);
-        info.setDataNetworkType(TelephonyManager.NETWORK_TYPE_LTE);
-        info.setVoiceNetworkType(TelephonyManager.NETWORK_TYPE_LTE);
-        info.setDataRegState(ServiceState.STATE_IN_SERVICE);
-
-        when(mMockQnsConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_XCAP,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        QnsConstants.COVERAGE_HOME))
-                .thenReturn(false);
-        when(mMockQnsConfigManager.getRatPreference(NetworkCapabilities.NET_CAPABILITY_XCAP))
-                .thenReturn(QnsConstants.RAT_PREFERENCE_WIFI_WHEN_NO_CELLULAR);
-        when(mDataConnectionStatusTracker.getLastTransportType())
-                .thenReturn(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mAne.onQnsTelephonyInfoChanged(info);
-
-        assertTrue(mAne.moveTransportTypeAllowed());
-
-        info.setCellularAvailable(false);
-        mAne.onQnsTelephonyInfoChanged(info);
-
-        assertFalse(mAne.moveTransportTypeAllowed());
-    }
-
-    @Test
-    public void testOnWfcEnabledChanged_Home() throws InterruptedException {
-        mWfcEnabledByUser = false;
-        mAne.onIwlanNetworkStatusChanged(
-                mMockIwlanNetworkStatusTracker.new IwlanAvailabilityInfo(true, false));
-        mAne.registerForQualifiedNetworksChanged(mHandler, QUALIFIED_NETWORKS_CHANGED);
-
-        // ANE takes time to build ANSP.
-        waitForLastHandlerAction(mAne.mHandler);
-
-        // Enabled
-        mLatch = new CountDownLatch(1);
-        mWfcEnabledByUser = true;
-        mAne.mHandler.sendEmptyMessage(QnsEventDispatcher.QNS_EVENT_WFC_ENABLED);
-        assertTrue(mLatch.await(200, TimeUnit.MILLISECONDS));
-        assertTrue(
-                mQualifiedNetworksInfo
-                        .getAccessNetworkTypes()
-                        .contains(AccessNetworkConstants.AccessNetworkType.IWLAN));
-
-        // Disabled
-        mLatch = new CountDownLatch(1);
-        mWfcEnabledByUser = false;
-        mAne.mHandler.sendEmptyMessage(QnsEventDispatcher.QNS_EVENT_WFC_DISABLED);
-        assertTrue(mLatch.await(200, TimeUnit.MILLISECONDS));
-        assertFalse(
-                mQualifiedNetworksInfo
-                        .getAccessNetworkTypes()
-                        .contains(AccessNetworkConstants.AccessNetworkType.IWLAN));
-    }
-
-    @Test
-    public void testOnWfcEnabledChanged_Roaming() throws InterruptedException {
-        mWfcMode = QnsConstants.CELL_PREF;
-        mWfcEnabledByUser = true;
-        QnsTelephonyListener.QnsTelephonyInfo info =
-                mMockQnsTelephonyListener.new QnsTelephonyInfo();
-        QnsTelephonyInfoIms infoIms =
-                mMockQnsTelephonyListener.new QnsTelephonyInfoIms(info, true, true, false, false);
-        infoIms.setCoverage(true);
-        infoIms.setRegisteredPlmn(TEST_PLMN);
-        mAne.onQnsTelephonyInfoChanged(infoIms);
-
-        mAne.onIwlanNetworkStatusChanged(
-                mMockIwlanNetworkStatusTracker.new IwlanAvailabilityInfo(true, false));
-        mAne.registerForQualifiedNetworksChanged(mHandler, QUALIFIED_NETWORKS_CHANGED);
-        waitForLastHandlerAction(mAne.mHandler);
-
-        // Enabled
-        mLatch = new CountDownLatch(1);
-        mWfcRoamingEnabled = true;
-        mWfcRoamingEnabledByUser = true;
-        mAne.mHandler.sendEmptyMessage(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_ENABLED);
-        assertTrue(mLatch.await(200, TimeUnit.MILLISECONDS));
-        assertTrue(
-                mQualifiedNetworksInfo
-                        .getAccessNetworkTypes()
-                        .contains(AccessNetworkConstants.AccessNetworkType.IWLAN));
-
-        // Disabled
-        mLatch = new CountDownLatch(1);
-        mWfcRoamingEnabled = false;
-        mWfcRoamingEnabledByUser = false;
-        mAne.mHandler.sendEmptyMessage(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_DISABLED);
-        assertTrue(mLatch.await(200, TimeUnit.MILLISECONDS));
-        assertFalse(
-                mQualifiedNetworksInfo
-                        .getAccessNetworkTypes()
-                        .contains(AccessNetworkConstants.AccessNetworkType.IWLAN));
-    }
-
-    @Test
-    public void testOnWfcPlatformChanged() throws InterruptedException {
-        mWfcMode = QnsConstants.CELL_PREF;
-        mWfcEnabledByUser = true;
-        mWfcEnabledByPlatform = false;
-        mAne.onIwlanNetworkStatusChanged(
-                mMockIwlanNetworkStatusTracker.new IwlanAvailabilityInfo(true, false));
-        mAne.registerForQualifiedNetworksChanged(mHandler, QUALIFIED_NETWORKS_CHANGED);
-        waitForLastHandlerAction(mAne.mHandler);
-
-        // Enabled
-        mLatch = new CountDownLatch(1);
-        mWfcEnabledByPlatform = true;
-        mAne.mHandler.sendEmptyMessage(QnsEventDispatcher.QNS_EVENT_WFC_PLATFORM_ENABLED);
-        mAne.mHandler.sendEmptyMessage(QnsEventDispatcher.QNS_EVENT_WFC_ENABLED);
-        assertTrue(mLatch.await(200, TimeUnit.MILLISECONDS));
-        assertTrue(
-                mQualifiedNetworksInfo
-                        .getAccessNetworkTypes()
-                        .contains(AccessNetworkConstants.AccessNetworkType.IWLAN));
-
-        // No report if no change in settings
-        mLatch = new CountDownLatch(1);
-        mAne.mHandler.sendEmptyMessage(QnsEventDispatcher.QNS_EVENT_WFC_PLATFORM_ENABLED);
-        assertFalse(mLatch.await(200, TimeUnit.MILLISECONDS));
-
-        // Disabled
-        mLatch = new CountDownLatch(1);
-        mWfcEnabledByPlatform = false;
-        mAne.mHandler.sendEmptyMessage(QnsEventDispatcher.QNS_EVENT_WFC_PLATFORM_DISABLED);
-        assertTrue(mLatch.await(100, TimeUnit.MILLISECONDS));
-        assertTrue(mQualifiedNetworksInfo.getAccessNetworkTypes().isEmpty());
-    }
-
-    @Test
-    public void testOnWfcModeChanged_Home() throws Exception {
-        mWfcMode = QnsConstants.CELL_PREF;
-        mWfcEnabledByUser = true;
-        waitForLastHandlerAction(mAne.mHandler);
-        mAne.mHandler.sendEmptyMessage(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_CELLULAR_PREFERRED);
-        generateAnspPolicyMap();
-        mockCurrentQuality(-60, -90);
-        mAne.onIwlanNetworkStatusChanged(
-                mMockIwlanNetworkStatusTracker.new IwlanAvailabilityInfo(true, false));
-
-        when(mMockQnsConfigManager.isVolteRoamingSupported(anyInt())).thenReturn(true);
-        QnsTelephonyListener.QnsTelephonyInfo info =
-                mMockQnsTelephonyListener.new QnsTelephonyInfo();
-        info.setCellularAvailable(true);
-        info.setCoverage(false);
-        info.setDataNetworkType(TelephonyManager.NETWORK_TYPE_LTE);
-        info.setVoiceNetworkType(TelephonyManager.NETWORK_TYPE_LTE);
-        info.setDataRegState(ServiceState.STATE_IN_SERVICE);
-        QnsTelephonyInfoIms infoIms =
-                mMockQnsTelephonyListener.new QnsTelephonyInfoIms(info, true, true, false, false);
-        mAne.onQnsTelephonyInfoChanged(infoIms);
-        mAne.registerForQualifiedNetworksChanged(mHandler, QUALIFIED_NETWORKS_CHANGED);
-        waitForLastHandlerAction(mAne.mHandler);
-
-        // Wifi Preferred
-        mLatch = new CountDownLatch(1);
-        mAne.mHandler.sendEmptyMessage(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_PREFERRED);
-        assertTrue(mLatch.await(2000, TimeUnit.MILLISECONDS));
-        assertTrue(
-                mQualifiedNetworksInfo
-                        .getAccessNetworkTypes()
-                        .contains(AccessNetworkConstants.AccessNetworkType.IWLAN));
-    }
-
-    @Test
-    public void testOnEmergencyPreferredTransportTypeChanged() throws InterruptedException {
-        waitForLastHandlerAction(mAne.mHandler);
-        mLatch = new CountDownLatch(1);
-        mAne.registerForQualifiedNetworksChanged(mHandler, QUALIFIED_NETWORKS_CHANGED);
-        mAne.onEmergencyPreferredTransportTypeChanged(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        waitForLastHandlerAction(mAne.mHandler);
-        assertFalse(mLatch.await(100, TimeUnit.MILLISECONDS));
-
-        when(mDataConnectionStatusTracker.isInactiveState()).thenReturn(true);
-        mAne =
-                new AccessNetworkEvaluator(
-                        mQnsComponents[mSlotIndex],
-                        NetworkCapabilities.NET_CAPABILITY_EIMS,
-                        mRestrictManager,
-                        mDataConnectionStatusTracker,
-                        mSlotIndex);
-        waitForLastHandlerAction(mAne.mHandler);
-
-        // WLAN
-        mLatch = new CountDownLatch(1);
-        mAne.registerForQualifiedNetworksChanged(mHandler, QUALIFIED_NETWORKS_CHANGED);
-        mAne.onEmergencyPreferredTransportTypeChanged(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        waitForLastHandlerAction(mAne.mHandler);
-        assertTrue(mLatch.await(500, TimeUnit.MILLISECONDS));
-        assertTrue(
-                mQualifiedNetworksInfo
-                        .getAccessNetworkTypes()
-                        .contains(AccessNetworkConstants.AccessNetworkType.IWLAN));
-
-        // UNKNOWN
-        mLatch = new CountDownLatch(1);
-        mAne.onEmergencyPreferredTransportTypeChanged(AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        waitForLastHandlerAction(mAne.mHandler);
-        assertTrue(mLatch.await(100, TimeUnit.MILLISECONDS));
-        assertTrue(mQualifiedNetworksInfo.getAccessNetworkTypes().isEmpty());
-
-        // EUTRAN
-        QnsTelephonyListener.QnsTelephonyInfo info =
-                mMockQnsTelephonyListener.new QnsTelephonyInfo();
-        info.setCellularAvailable(true);
-        info.setCoverage(false);
-        info.setDataNetworkType(TelephonyManager.NETWORK_TYPE_LTE);
-        info.setVoiceNetworkType(TelephonyManager.NETWORK_TYPE_LTE);
-        info.setDataRegState(ServiceState.STATE_IN_SERVICE);
-        QnsTelephonyInfoIms infoIms =
-                mMockQnsTelephonyListener.new QnsTelephonyInfoIms(info, true, true, false, false);
-        mAne.onQnsTelephonyInfoChanged(infoIms);
-        waitForLastHandlerAction(mAne.mHandler);
-
-        mLatch = new CountDownLatch(1);
-        mAne.onEmergencyPreferredTransportTypeChanged(AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        waitForLastHandlerAction(mAne.mHandler);
-        assertTrue(mLatch.await(100, TimeUnit.MILLISECONDS));
-        assertTrue(
-                mQualifiedNetworksInfo
-                        .getAccessNetworkTypes()
-                        .contains(AccessNetworkConstants.AccessNetworkType.EUTRAN));
-    }
-
-    @Test
-    public void testCachedPreferredTransportTypeForEmergency() throws InterruptedException {
-        waitForLastHandlerAction(mAne.mHandler);
-        mLatch = new CountDownLatch(1);
-        mAne.registerForQualifiedNetworksChanged(mHandler, QUALIFIED_NETWORKS_CHANGED);
-
-        mAne.onEmergencyPreferredTransportTypeChanged(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        waitForLastHandlerAction(mAne.mHandler);
-        assertFalse(mLatch.await(100, TimeUnit.MILLISECONDS));
-
-        when(mDataConnectionStatusTracker.isInactiveState()).thenReturn(false);
-        mAne =
-                new AccessNetworkEvaluator(
-                        mQnsComponents[mSlotIndex],
-                        NetworkCapabilities.NET_CAPABILITY_EIMS,
-                        mRestrictManager,
-                        mDataConnectionStatusTracker,
-                        mSlotIndex);
-        waitForLastHandlerAction(mAne.mHandler);
-
-        mLatch = new CountDownLatch(1);
-        mAne.registerForQualifiedNetworksChanged(mHandler, QUALIFIED_NETWORKS_CHANGED);
-        mAne.onEmergencyPreferredTransportTypeChanged(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        waitForLastHandlerAction(mAne.mHandler);
-        assertFalse(mLatch.await(500, TimeUnit.MILLISECONDS));
-        assertNull(mQualifiedNetworksInfo);
-
-        mLatch = new CountDownLatch(1);
-        mAne.onDataConnectionStateChanged(
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_DISCONNECTED, STATE_INACTIVE,
-                        AccessNetworkConstants.TRANSPORT_TYPE_INVALID));
-        waitForLastHandlerAction(mAne.mHandler);
-        assertTrue(mLatch.await(100, TimeUnit.MILLISECONDS));
-        assertTrue(
-                mQualifiedNetworksInfo
-                        .getAccessNetworkTypes()
-                        .contains(AccessNetworkConstants.AccessNetworkType.IWLAN));
-
-        QnsTelephonyListener.QnsTelephonyInfo info =
-                mMockQnsTelephonyListener.new QnsTelephonyInfo();
-        info.setCellularAvailable(true);
-        info.setCoverage(false);
-        info.setDataNetworkType(TelephonyManager.NETWORK_TYPE_LTE);
-        info.setVoiceNetworkType(TelephonyManager.NETWORK_TYPE_LTE);
-        info.setDataRegState(ServiceState.STATE_IN_SERVICE);
-        QnsTelephonyInfoIms infoIms =
-                mMockQnsTelephonyListener.new QnsTelephonyInfoIms(info, true, true, false, false);
-        mAne.onQnsTelephonyInfoChanged(infoIms);
-        when(mDataConnectionStatusTracker.isInactiveState()).thenReturn(false);
-        mQualifiedNetworksInfo = null;
-
-        mLatch = new CountDownLatch(1);
-        mAne.onEmergencyPreferredTransportTypeChanged(AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        waitForLastHandlerAction(mAne.mHandler);
-        assertFalse(mLatch.await(500, TimeUnit.MILLISECONDS));
-        assertNull(mQualifiedNetworksInfo);
-
-        mLatch = new CountDownLatch(1);
-        mAne.onDataConnectionStateChanged(
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_FAILED, STATE_INACTIVE,
-                        AccessNetworkConstants.TRANSPORT_TYPE_INVALID));
-        waitForLastHandlerAction(mAne.mHandler);
-        assertTrue(mLatch.await(100, TimeUnit.MILLISECONDS));
-        assertTrue(
-                mQualifiedNetworksInfo
-                        .getAccessNetworkTypes()
-                        .contains(AccessNetworkConstants.AccessNetworkType.EUTRAN));
-    }
-
-    @Test
-    public void testReportSatisfiedAccessNetworkTypesByState()
-            throws InterruptedException, NoSuchFieldException, IllegalAccessException {
-        waitForLastHandlerAction(mAne.mHandler);
-        doNothing().when(mRestrictManager).setQnsCallType(anyInt());
-        Message.obtain(
-                        mAne.mHandler,
-                        EVENT_SET_CALL_TYPE,
-                        new QnsAsyncResult(null, QnsConstants.CALL_TYPE_IDLE, null))
-                .sendToTarget();
-        Message.obtain(
-                        mAne.mHandler,
-                        EVENT_IWLAN_NETWORK_STATUS_CHANGED,
-                        new QnsAsyncResult(
-                                null,
-                                mMockIwlanNetworkStatusTracker
-                                .new IwlanAvailabilityInfo(true, false),
-                                null))
-                .sendToTarget();
-
-        generateAnspPolicyMap();
-        mockCurrentQuality(-70, -90);
-        mAne.mHandler.sendEmptyMessage(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_PREFERRED);
-        when(mDataConnectionStatusTracker.isInactiveState()).thenReturn(true);
-        when(mRestrictManager.isRestricted(anyInt())).thenReturn(false);
-        List<Integer> accessNetworks = new ArrayList<>();
-        accessNetworks.add(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        mAne.registerForQualifiedNetworksChanged(mHandler, QUALIFIED_NETWORKS_CHANGED);
-        waitForLastHandlerAction(mAne.mHandler);
-        mLatch = new CountDownLatch(1);
-        mAne.reportSatisfiedAccessNetworkTypesByState(accessNetworks, true);
-        assertTrue(mLatch.await(500, TimeUnit.MILLISECONDS));
-        assertTrue(
-                mQualifiedNetworksInfo
-                        .getAccessNetworkTypes()
-                        .contains(AccessNetworkConstants.AccessNetworkType.EUTRAN));
-        verify(mMockWifiQm).updateThresholdsForNetCapability(anyInt(), anyInt(), isNotNull());
-    }
-
-    private void generateAnspPolicyMap() throws NoSuchFieldException, IllegalAccessException {
-        mTestAnspPolicyMap = new HashMap<>();
-
-        PreCondition p1 =
-                new PreCondition(
-                        QnsConstants.CALL_TYPE_IDLE,
-                        QnsConstants.WIFI_PREF,
-                        QnsConstants.COVERAGE_HOME);
-        PreCondition p2 =
-                new PreCondition(
-                        QnsConstants.CALL_TYPE_IDLE,
-                        QnsConstants.CELL_PREF,
-                        QnsConstants.COVERAGE_HOME);
-
-        List<ThresholdGroup> tg1 =
-                generateTestThresholdGroups(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                        QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                        -65);
-        List<ThresholdGroup> tg2 =
-                generateTestThresholdGroups(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                        QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                        -91);
-
-        AccessNetworkSelectionPolicy ansp1 =
-                new AccessNetworkSelectionPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_IMS,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        p1,
-                        tg1);
-        List<AccessNetworkSelectionPolicy> anspList = new ArrayList<>();
-        anspList.add(ansp1);
-
-        AccessNetworkSelectionPolicy ansp2 =
-                new AccessNetworkSelectionPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_IMS,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        p2,
-                        tg2);
-        List<AccessNetworkSelectionPolicy> anspList2 = new ArrayList<>();
-        anspList2.add(ansp2);
-
-        mTestAnspPolicyMap.put(p1, anspList);
-        mTestAnspPolicyMap.put(p2, anspList2);
-        Field f = AccessNetworkEvaluator.class.getDeclaredField("mAnspPolicyMap");
-        f.setAccessible(true);
-        f.set(mAne, mTestAnspPolicyMap);
-    }
-
-    private void mockCurrentQuality(int wifi, int cellular) {
-        when(mMockWifiQm.getCurrentQuality(anyInt(), anyInt()))
-                .thenAnswer((Answer<Integer>) invocation -> {
-                    int quality = -255;
-                    switch ((int) invocation.getArgument(0)) {
-                        case AccessNetworkConstants.AccessNetworkType.EUTRAN:
-                            quality = cellular;
-                            break;
-                        case AccessNetworkConstants.AccessNetworkType.IWLAN:
-                            quality = wifi;
-                            break;
-                    }
-                    return quality;
-                });
-    }
-
-    private List<ThresholdGroup> generateTestThresholdGroups(
-            int accessNetwork, int measType, int matchType, int threshold) {
-        List<ThresholdGroup> thgroups = new ArrayList<>();
-        List<Threshold> ths = new ArrayList<>();
-        ths.add(
-                new Threshold(
-                        accessNetwork,
-                        measType,
-                        threshold,
-                        matchType,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        thgroups.add(new ThresholdGroup(ths));
-
-        return thgroups;
-    }
-
-    @Test
-    public void testOnProvisioningInfoChanged_LTE() throws Exception {
-        QnsProvisioningInfo lastInfo = getQnsProvisioningInfo();
-        setObject(AccessNetworkEvaluator.class, "mLastProvisioningInfo", mAne, lastInfo);
-
-        QnsProvisioningInfo info = getQnsProvisioningInfo();
-        ConcurrentHashMap<Integer, Integer> integerItems = getProvisioningItems();
-
-        integerItems.put(ProvisioningManager.KEY_LTE_THRESHOLD_1, -100); // bad
-        integerItems.put(ProvisioningManager.KEY_LTE_THRESHOLD_2, -120); // worst
-        integerItems.put(ProvisioningManager.KEY_LTE_THRESHOLD_3, -85); // good
-
-        // update new provisioning info
-        setObject(QnsProvisioningInfo.class, "mIntegerItems", info, integerItems);
-
-        Message.obtain(
-                        mAne.mHandler,
-                        EVENT_PROVISIONING_INFO_CHANGED,
-                        new QnsAsyncResult(null, info, null))
-                .sendToTarget();
-        waitForLastHandlerAction(mAne.mHandler);
-        verify(mMockQnsConfigManager, timeout(500).times(3)).setQnsProvisioningInfo(info);
-    }
-
-    @Test
-    public void testOnProvisioningInfoChanged_Wifi() throws Exception {
-        QnsProvisioningInfo lastInfo = getQnsProvisioningInfo();
-        setObject(AccessNetworkEvaluator.class, "mLastProvisioningInfo", mAne, lastInfo);
-
-        QnsProvisioningInfo info = getQnsProvisioningInfo();
-        ConcurrentHashMap<Integer, Integer> integerItems = getProvisioningItems();
-
-        integerItems.put(ProvisioningManager.KEY_WIFI_THRESHOLD_A, -75); // good
-        integerItems.put(ProvisioningManager.KEY_WIFI_THRESHOLD_B, -90); // bad
-
-        // update new provisioning info
-        setObject(QnsProvisioningInfo.class, "mIntegerItems", info, integerItems);
-        Message.obtain(
-                        mAne.mHandler,
-                        EVENT_PROVISIONING_INFO_CHANGED,
-                        new QnsAsyncResult(null, info, null))
-                .sendToTarget();
-        waitForLastHandlerAction(mAne.mHandler);
-        verify(mMockQnsConfigManager, timeout(500).times(2)).setQnsProvisioningInfo(info);
-    }
-
-    @Test
-    public void testOnProvisioningInfoChanged_ePDG() throws Exception {
-        waitForLastHandlerAction(mAne.mHandler);
-        QnsProvisioningInfo lastInfo = getQnsProvisioningInfo();
-        setObject(AccessNetworkEvaluator.class, "mLastProvisioningInfo", mAne, lastInfo);
-
-        QnsProvisioningInfo info = getQnsProvisioningInfo();
-        ConcurrentHashMap<Integer, Integer> integerItems = getProvisioningItems();
-        integerItems.put(ProvisioningManager.KEY_LTE_EPDG_TIMER_SEC, 10000);
-        integerItems.put(ProvisioningManager.KEY_WIFI_EPDG_TIMER_SEC, 20000);
-
-        // update new provisioning info
-        setObject(QnsProvisioningInfo.class, "mIntegerItems", info, integerItems);
-        Message.obtain(
-                        mAne.mHandler,
-                        EVENT_PROVISIONING_INFO_CHANGED,
-                        new QnsAsyncResult(null, info, null))
-                .sendToTarget();
-        waitForLastHandlerAction(mAne.mHandler);
-        verify(mMockQnsConfigManager, times(2)).setQnsProvisioningInfo(info);
-    }
-
-    private QnsProvisioningInfo getQnsProvisioningInfo() throws Exception {
-        QnsProvisioningInfo info = new QnsProvisioningInfo();
-        ConcurrentHashMap<Integer, Integer> integerItems = getProvisioningItems();
-        setObject(QnsProvisioningInfo.class, "mIntegerItems", info, integerItems);
-        return info;
-    }
-
-    private ConcurrentHashMap<Integer, Integer> getProvisioningItems() {
-        ConcurrentHashMap<Integer, Integer> integerItems = new ConcurrentHashMap<>();
-        integerItems.put(ProvisioningManager.KEY_LTE_THRESHOLD_1, -95); // bad
-        integerItems.put(ProvisioningManager.KEY_LTE_THRESHOLD_2, -110); // worst
-        integerItems.put(ProvisioningManager.KEY_LTE_THRESHOLD_3, -80); // good
-        integerItems.put(ProvisioningManager.KEY_WIFI_THRESHOLD_A, -70); // good
-        integerItems.put(ProvisioningManager.KEY_WIFI_THRESHOLD_B, -85); // bad
-        integerItems.put(ProvisioningManager.KEY_LTE_EPDG_TIMER_SEC, -80);
-        integerItems.put(ProvisioningManager.KEY_WIFI_EPDG_TIMER_SEC, -80);
-        return integerItems;
-    }
-
-    @Test
-    public void testIsAllowed_WLAN() throws Exception {
-        waitForLastHandlerAction(mAne.mHandler);
-        int transport = AccessNetworkConstants.TRANSPORT_TYPE_WLAN;
-        mAne.onTryWfcConnectionStateChanged(true);
-        when(mMockQnsEventDispatcher.isAirplaneModeToggleOn()).thenReturn(true);
-        when(mMockQnsConfigManager.allowWFCOnAirplaneModeOn()).thenReturn(false, true);
-        Method method = AccessNetworkEvaluator.class.getDeclaredMethod("isAllowed", int.class);
-        method.setAccessible(true);
-        assertFalse((Boolean) method.invoke(mAne, transport));
-
-        when(mMockIwlanNetworkStatusTracker.isInternationalRoaming(mSlotIndex)).thenReturn(true);
-        when(mMockQnsConfigManager.blockIwlanInInternationalRoamWithoutWwan())
-                .thenReturn(true, false);
-        assertFalse((Boolean) method.invoke(mAne, transport));
-
-        when(mMockQnsConfigManager.getRatPreference(mNetCapability))
-                .thenAnswer(pref -> mRatPreference);
-
-        // RAT_PREFERENCE_DEFAULT
-        mRatPreference = QnsConstants.RAT_PREFERENCE_DEFAULT;
-        assertTrue((Boolean) method.invoke(mAne, transport));
-
-        // RAT_PREFERENCE_WIFI_ONLY
-        mRatPreference = QnsConstants.RAT_PREFERENCE_WIFI_ONLY;
-        assertTrue((Boolean) method.invoke(mAne, transport));
-
-        mRatPreference = QnsConstants.RAT_PREFERENCE_WIFI_WHEN_WFC_AVAILABLE;
-        when(mMockQnsImsManager.isImsRegistered(transport)).thenReturn(false, true);
-
-        // RAT_PREFERENCE_WIFI_WHEN_WFC_AVAILABLE - ims not registered over WLAN
-        assertFalse((Boolean) method.invoke(mAne, transport));
-
-        // RAT_PREFERENCE_WIFI_WHEN_WFC_AVAILABLE - ims registered over WLAN
-        assertTrue((Boolean) method.invoke(mAne, transport));
-
-        // RAT_PREFERENCE_WIFI_WHEN_NO_CELLULAR - cellular available
-        mRatPreference = QnsConstants.RAT_PREFERENCE_WIFI_WHEN_NO_CELLULAR;
-        setObject(AccessNetworkEvaluator.class, "mCellularAvailable", mAne, true);
-        assertFalse((Boolean) method.invoke(mAne, transport));
-
-        // RAT_PREFERENCE_WIFI_WHEN_NO_CELLULAR - cellular not available
-        mRatPreference = QnsConstants.RAT_PREFERENCE_WIFI_WHEN_NO_CELLULAR;
-        setObject(AccessNetworkEvaluator.class, "mCellularAvailable", mAne, false);
-        assertTrue((Boolean) method.invoke(mAne, transport));
-    }
-
-    @Test
-    public void testIsAllowed_WWAN() throws Exception {
-        waitForLastHandlerAction(mAne.mHandler);
-        int transport = AccessNetworkConstants.TRANSPORT_TYPE_WWAN;
-        when(mMockQnsEventDispatcher.isAirplaneModeToggleOn()).thenReturn(true, false);
-        Method method = AccessNetworkEvaluator.class.getDeclaredMethod("isAllowed", int.class);
-        method.setAccessible(true);
-        assertFalse((Boolean) method.invoke(mAne, transport));
-        when(mMockQnsConfigManager.getRatPreference(mNetCapability))
-                .thenAnswer(pref -> mRatPreference);
-
-        // RAT_PREFERENCE_DEFAULT
-        mRatPreference = QnsConstants.RAT_PREFERENCE_DEFAULT;
-        assertTrue((Boolean) method.invoke(mAne, transport));
-
-        // RAT_PREFERENCE_WIFI_ONLY
-        mRatPreference = QnsConstants.RAT_PREFERENCE_WIFI_ONLY;
-        assertFalse((Boolean) method.invoke(mAne, transport));
-
-        // RAT_PREFERENCE_WIFI_WHEN_WFC_AVAILABLE
-        mRatPreference = QnsConstants.RAT_PREFERENCE_WIFI_WHEN_WFC_AVAILABLE;
-        when(mMockQnsImsManager.isImsRegistered(AccessNetworkConstants.TRANSPORT_TYPE_WLAN))
-                .thenReturn(true, false);
-        assertFalse((Boolean) method.invoke(mAne, transport));
-        assertTrue((Boolean) method.invoke(mAne, transport));
-
-        // RAT_PREFERENCE_WIFI_WHEN_NO_CELLULAR
-        mRatPreference = QnsConstants.RAT_PREFERENCE_WIFI_WHEN_NO_CELLULAR;
-        assertTrue((Boolean) method.invoke(mAne, transport));
-
-        mRatPreference = QnsConstants.RAT_PREFERENCE_WIFI_WHEN_HOME_IS_NOT_AVAILABLE;
-
-        // RAT_PREFERENCE_WIFI_WHEN_HOME_IS_NOT_AVAILABLE - no cellular
-        setObject(AccessNetworkEvaluator.class, "mCellularAvailable", mAne, false);
-        assertFalse((Boolean) method.invoke(mAne, transport));
-
-        // RAT_PREFERENCE_WIFI_WHEN_HOME_IS_NOT_AVAILABLE - home
-        setObject(AccessNetworkEvaluator.class, "mCellularAvailable", mAne, true);
-        setObject(AccessNetworkEvaluator.class, "mCoverage", mAne, QnsConstants.COVERAGE_HOME);
-        assertTrue((Boolean) method.invoke(mAne, transport));
-
-        // RAT_PREFERENCE_WIFI_WHEN_HOME_IS_NOT_AVAILABLE - roaming
-        setObject(AccessNetworkEvaluator.class, "mCoverage", mAne, QnsConstants.COVERAGE_ROAM);
-        assertFalse((Boolean) method.invoke(mAne, transport));
-    }
-
-    @Test
-    public void testGetMatchingPreconditionForEmergency() {
-        AccessNetworkEvaluator mAneSos =
-                new AccessNetworkEvaluator(
-                        mQnsComponents[mSlotIndex],
-                        NetworkCapabilities.NET_CAPABILITY_EIMS,
-                        mRestrictManager,
-                        mDataConnectionStatusTracker,
-                        mSlotIndex);
-        waitForLastHandlerAction(mAneSos.mHandler);
-        AccessNetworkEvaluator mAneIms =
-                new AccessNetworkEvaluator(
-                        mQnsComponents[mSlotIndex],
-                        NetworkCapabilities.NET_CAPABILITY_IMS,
-                        mRestrictManager,
-                        mDataConnectionStatusTracker,
-                        mSlotIndex);
-        waitForLastHandlerAction(mAneIms.mHandler);
-        List<Integer> satisfiedAccessNetworkTypes = new ArrayList<>();
-        satisfiedAccessNetworkTypes.add(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        when(mDataConnectionStatusTracker.isInactiveState()).thenReturn(true);
-        try {
-            Field field = AccessNetworkEvaluator.class.getDeclaredField("mCallType");
-            field.setAccessible(true);
-            field.set(mAneSos, QnsConstants.CALL_TYPE_VOICE);
-            field.set(mAneIms, QnsConstants.CALL_TYPE_VOICE);
-        } catch (Exception e) {
-        }
-        mAneSos.reportSatisfiedAccessNetworkTypesByState(satisfiedAccessNetworkTypes, true);
-        mAneIms.reportSatisfiedAccessNetworkTypesByState(satisfiedAccessNetworkTypes, true);
-        ArrayList<AccessNetworkSelectionPolicy> matchedAnspSos = null;
-        ArrayList<AccessNetworkSelectionPolicy> matchedAnspIms = null;
-        try {
-            Field field =
-                    AccessNetworkEvaluator.class.getDeclaredField(
-                            "mAccessNetworkSelectionPolicies");
-            field.setAccessible(true);
-            matchedAnspSos = (ArrayList<AccessNetworkSelectionPolicy>) field.get(mAneSos);
-            matchedAnspIms = (ArrayList<AccessNetworkSelectionPolicy>) field.get(mAneIms);
-        } catch (Exception e) {
-            assertNotNull(matchedAnspSos);
-            assertNotNull(matchedAnspIms);
-        }
-
-        assertNotNull(matchedAnspSos);
-        assertNotNull(matchedAnspIms);
-        assertTrue(matchedAnspSos.size() > 0);
-        assertTrue(matchedAnspIms.size() > 0);
-        assertEquals(
-                QnsConstants.CALL_TYPE_VOICE,
-                matchedAnspSos.get(0).getPreCondition().getCallType());
-        assertEquals(
-                QnsConstants.CALL_TYPE_VOICE,
-                matchedAnspIms.get(0).getPreCondition().getCallType());
-
-        try {
-            Field field = AccessNetworkEvaluator.class.getDeclaredField("mCallType");
-            field.setAccessible(true);
-            field.set(mAneSos, QnsConstants.CALL_TYPE_EMERGENCY);
-            field.set(mAneIms, QnsConstants.CALL_TYPE_EMERGENCY);
-        } catch (Exception e) {
-        }
-        mAneSos.reportSatisfiedAccessNetworkTypesByState(satisfiedAccessNetworkTypes, true);
-        mAneIms.reportSatisfiedAccessNetworkTypesByState(satisfiedAccessNetworkTypes, true);
-        try {
-            Field field =
-                    AccessNetworkEvaluator.class.getDeclaredField(
-                            "mAccessNetworkSelectionPolicies");
-            field.setAccessible(true);
-            matchedAnspSos = (ArrayList<AccessNetworkSelectionPolicy>) field.get(mAneSos);
-            matchedAnspIms = (ArrayList<AccessNetworkSelectionPolicy>) field.get(mAneIms);
-        } catch (Exception e) {
-            assertNotNull(matchedAnspSos);
-            assertNotNull(matchedAnspIms);
-        }
-
-        assertNotNull(matchedAnspSos);
-        assertNotNull(matchedAnspIms);
-        assertTrue(matchedAnspSos.size() > 0);
-        assertTrue(matchedAnspIms.size() > 0);
-        assertEquals(
-                QnsConstants.CALL_TYPE_VOICE,
-                matchedAnspSos.get(0).getPreCondition().getCallType());
-    }
-
-    @Test
-    public void testEventImsRegistrationStateChanged() {
-        waitForLastHandlerAction(mAne.mHandler);
-        when(mMockQnsConfigManager.isTransportTypeSelWithoutSSInRoamSupported()).thenReturn(false);
-        when(mMockQnsConfigManager.getRatPreference(NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(QnsConstants.RAT_PREFERENCE_DEFAULT);
-
-        Message.obtain(
-                        mAne.mHandler,
-                        EVENT_IMS_REGISTRATION_STATE_CHANGED,
-                        new QnsAsyncResult(null, mMockImsRegistrationState, null))
-                .sendToTarget();
-
-        waitForLastHandlerAction(mAne.mHandler);
-        verify(mMockImsRegistrationState, never()).getTransportType();
-        verify(mMockImsRegistrationState, never()).getEvent();
-
-        when(mMockQnsConfigManager.getRatPreference(NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(QnsConstants.RAT_PREFERENCE_WIFI_WHEN_WFC_AVAILABLE);
-        when(mMockImsRegistrationState.getTransportType())
-                .thenReturn(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        when(mMockImsRegistrationState.getEvent())
-                .thenReturn(QnsConstants.IMS_REGISTRATION_CHANGED_REGISTERED);
-
-        Message.obtain(
-                        mAne.mHandler,
-                        EVENT_IMS_REGISTRATION_STATE_CHANGED,
-                        new QnsAsyncResult(null, mMockImsRegistrationState, null))
-                .sendToTarget();
-
-        waitForLastHandlerAction(mAne.mHandler);
-        verify(mMockImsRegistrationState, times(1)).getTransportType();
-        verify(mMockImsRegistrationState, times(1)).getEvent();
-    }
-
-    @Test
-    public void testValidateWfcSettingsAndUpdate() {
-        mWfcMode = QnsConstants.CELL_PREF;
-        mWfcModeRoaming = QnsConstants.CELL_PREF;
-        mWfcEnabledByUser = false;
-        assertFalse(mAne.isWfcEnabled());
-
-        mWfcEnabledByUser = true;
-        mWfcRoamingEnabled = true;
-        assertTrue(mAne.isWfcEnabled());
-
-        QnsTelephonyListener.QnsTelephonyInfo info =
-                mMockQnsTelephonyListener.new QnsTelephonyInfo();
-        info.setCellularAvailable(true);
-        info.setCoverage(true);
-        info.setDataNetworkType(TelephonyManager.NETWORK_TYPE_LTE);
-        info.setVoiceNetworkType(TelephonyManager.NETWORK_TYPE_LTE);
-        info.setDataRegState(ServiceState.STATE_IN_SERVICE);
-        QnsTelephonyInfoIms infoIms =
-                mMockQnsTelephonyListener.new QnsTelephonyInfoIms(info, true, true, false, false);
-        mAne.onQnsTelephonyInfoChanged(infoIms);
-
-        mWfcEnabledByPlatform = false;
-        assertFalse(mAne.isWfcEnabled());
-
-        mWfcEnabledByPlatform = true;
-        mWfcRoamingEnabled = true;
-        mWfcRoamingEnabledByUser = true;
-        assertTrue(mAne.isWfcEnabled());
-    }
-
-    @Test
-    public void testEvaluateAgainWhenRebuild() throws InterruptedException {
-        mLatch = new CountDownLatch(3);
-
-        // #1 evaluate
-        mAne.registerForQualifiedNetworksChanged(mHandler, QUALIFIED_NETWORKS_CHANGED);
-
-        mAne.mIwlanAvailable = true;
-        mWfcEnabledByUser = true;
-
-        waitForLastHandlerAction(mAne.mHandler);
-
-        // #2 report an empty
-        // #3 report once again when iwlan is available.
-        mAne.rebuild();
-
-        assertTrue(mLatch.await(3, TimeUnit.SECONDS));
-        List<Integer> accessNetworks = new ArrayList<>();
-        accessNetworks.add(AccessNetworkConstants.AccessNetworkType.IWLAN);
-        assertEquals(accessNetworks, mQualifiedNetworksInfo.getAccessNetworkTypes());
-    }
-
-    @Test
-    public void testEvaluationOnCst_MmsRatPreferenceWifiWhenWfcAvailable() throws Exception {
-        mAne =
-                new AccessNetworkEvaluator(
-                        mQnsComponents[mSlotIndex],
-                        NetworkCapabilities.NET_CAPABILITY_MMS,
-                        mRestrictManager,
-                        mDataConnectionStatusTracker,
-                        mSlotIndex);
-        mAne.onIwlanNetworkStatusChanged(
-                mMockIwlanNetworkStatusTracker.new IwlanAvailabilityInfo(true, true));
-        mAne.registerForQualifiedNetworksChanged(mHandler, QUALIFIED_NETWORKS_CHANGED);
-        waitForLastHandlerAction(mAne.mHandler);
-
-        when(mMockQnsConfigManager.getRatPreference(NetworkCapabilities.NET_CAPABILITY_MMS))
-                .thenReturn(QnsConstants.RAT_PREFERENCE_WIFI_WHEN_WFC_AVAILABLE);
-        when(mMockQnsImsManager.isImsRegistered(AccessNetworkConstants.TRANSPORT_TYPE_WLAN))
-                .thenReturn(true);
-        setObject(AccessNetworkEvaluator.class, "mCellularAvailable", mAne, true);
-        setObject(
-                AccessNetworkEvaluator.class,
-                "mCellularAccessNetworkType",
-                mAne,
-                AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        when(mMockImsRegistrationState.getTransportType())
-                .thenReturn(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        when(mMockImsRegistrationState.getEvent())
-                .thenReturn(QnsConstants.IMS_REGISTRATION_CHANGED_REGISTERED);
-
-        Message.obtain(
-                        mAne.mHandler,
-                        EVENT_IMS_REGISTRATION_STATE_CHANGED,
-                        new QnsAsyncResult(null, mMockImsRegistrationState, null))
-                .sendToTarget();
-        assertTrue(mLatch.await(400, TimeUnit.MILLISECONDS));
-
-        List<Integer> accessNetworks = new ArrayList<>();
-        accessNetworks.add(AccessNetworkConstants.AccessNetworkType.IWLAN);
-        assertEquals(accessNetworks, mQualifiedNetworksInfo.getAccessNetworkTypes());
-    }
-
-    @Test
-    public void testEventSipDialogSessionStateChanged() {
-        waitForLastHandlerAction(mAne.mHandler);
-        when(mMockQnsConfigManager.getSipDialogSessionPolicy())
-                .thenReturn(QnsConstants.SIP_DIALOG_SESSION_POLICY_FOLLOW_VOICE_CALL);
-
-        // #1. check init value
-        assertFalse(mAne.getSipDialogSessionState());
-
-        // #2. check handling message
-        Message.obtain(
-                        mAne.mHandler,
-                        EVENT_SIP_DIALOG_SESSION_STATE_CHANGED,
-                        new QnsAsyncResult(null, true, null))
-                .sendToTarget();
-        waitForLastHandlerAction(mAne.mHandler);
-        assertTrue(mAne.getSipDialogSessionState());
-
-        // #3. check calling direct method.
-        mAne.onSipDialogSessionStateChanged(false);
-        assertFalse(mAne.getSipDialogSessionState());
-        mAne.onSipDialogSessionStateChanged(true);
-        assertTrue(mAne.getSipDialogSessionState());
-    }
-
-    @Test
-    public void testEventSipDialogSessionStateChangedByPolicy() {
-        // #1. Check by config.
-        when(mMockQnsConfigManager.getSipDialogSessionPolicy())
-                .thenReturn(QnsConstants.SIP_DIALOG_SESSION_POLICY_NONE);
-        mAne.onSipDialogSessionStateChanged(false);
-        mAne.onSipDialogSessionStateChanged(true);
-        // if policy is SIP_DIALOG_SESSION_POLICY_NONE, ANE.mSipDialogSessionState should be false.
-        assertFalse(mAne.getSipDialogSessionState());
-
-        // #2. Check applying SipDialogSessionState by SipDialogSessionPolicy config. (VOICE)
-        when(mMockQnsConfigManager.getSipDialogSessionPolicy())
-                .thenReturn(QnsConstants.SIP_DIALOG_SESSION_POLICY_FOLLOW_VOICE_CALL);
-        mAne.onSipDialogSessionStateChanged(false);
-        mAne.onSipDialogSessionStateChanged(true);
-        assertTrue(mAne.getSipDialogSessionState());
-
-        // #3. Check applying SipDialogSessionState by SipDialogSessionPolicy config. (VIDEO)
-        when(mMockQnsConfigManager.getSipDialogSessionPolicy())
-                .thenReturn(QnsConstants.SIP_DIALOG_SESSION_POLICY_FOLLOW_VIDEO_CALL);
-        mAne.onSipDialogSessionStateChanged(false);
-        mAne.onSipDialogSessionStateChanged(true);
-        assertTrue(mAne.getSipDialogSessionState());
-    }
-
-    @Test
-    public void testEventSipDialogSessionStateChanged_verifyWithAnspVoice() {
-        when(mMockQnsConfigManager.getPolicy(anyInt(), any())).thenReturn(null);
-        when(mMockQnsConfigManager.getSipDialogSessionPolicy())
-                .thenReturn(QnsConstants.SIP_DIALOG_SESSION_POLICY_FOLLOW_VOICE_CALL);
-        mAne.onSipDialogSessionStateChanged(true);
-
-        List<Integer> satisfiedAccessNetworkTypes = new ArrayList<>();
-        satisfiedAccessNetworkTypes.add(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        when(mDataConnectionStatusTracker.isInactiveState()).thenReturn(true);
-        mAne.reportSatisfiedAccessNetworkTypesByState(satisfiedAccessNetworkTypes, true);
-        mAne.registerForQualifiedNetworksChanged(mHandler, QUALIFIED_NETWORKS_CHANGED);
-        ArrayList<AccessNetworkSelectionPolicy> matchedAnsp;
-
-        // #1. SIP_DIALOG_SESSION_POLICY_FOLLOW_VOICE_CALL
-        matchedAnsp = null;
-        try {
-            Field field =
-                    AccessNetworkEvaluator.class.getDeclaredField(
-                            "mAccessNetworkSelectionPolicies");
-            field.setAccessible(true);
-            matchedAnsp = (ArrayList<AccessNetworkSelectionPolicy>) field.get(mAne);
-        } catch (Exception e) {
-        }
-        assertNotNull(matchedAnsp);
-        assertFalse(matchedAnsp.isEmpty());
-        assertEquals(
-                QnsConstants.CALL_TYPE_VOICE, matchedAnsp.get(0).getPreCondition().getCallType());
-    }
-
-    @Test
-    public void testEventSipDialogSessionStateChanged_verifyWithAnspVideo() {
-        when(mMockQnsConfigManager.getPolicy(anyInt(), any())).thenReturn(null);
-        when(mMockQnsConfigManager.getSipDialogSessionPolicy())
-                .thenReturn(QnsConstants.SIP_DIALOG_SESSION_POLICY_FOLLOW_VIDEO_CALL);
-        mAne.onSipDialogSessionStateChanged(true);
-
-        List<Integer> satisfiedAccessNetworkTypes = new ArrayList<>();
-        satisfiedAccessNetworkTypes.add(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        when(mDataConnectionStatusTracker.isInactiveState()).thenReturn(true);
-        mAne.reportSatisfiedAccessNetworkTypesByState(satisfiedAccessNetworkTypes, true);
-        mAne.registerForQualifiedNetworksChanged(mHandler, QUALIFIED_NETWORKS_CHANGED);
-        ArrayList<AccessNetworkSelectionPolicy> matchedAnsp;
-
-        // #1. SIP_DIALOG_SESSION_POLICY_FOLLOW_VIDEO_CALL
-        matchedAnsp = null;
-        try {
-            Field field =
-                    AccessNetworkEvaluator.class.getDeclaredField(
-                            "mAccessNetworkSelectionPolicies");
-            field.setAccessible(true);
-            matchedAnsp = (ArrayList<AccessNetworkSelectionPolicy>) field.get(mAne);
-        } catch (Exception e) {
-        }
-        assertNotNull(matchedAnsp);
-        assertFalse(matchedAnsp.isEmpty());
-        assertEquals(
-                QnsConstants.CALL_TYPE_VIDEO, matchedAnsp.get(0).getPreCondition().getCallType());
-    }
-
-    @Test
-    public void testDataConnectionDisconnectedOnSos_ResettingThresholds() {
-        AccessNetworkEvaluator aneSos =
-                new AccessNetworkEvaluator(
-                        mQnsComponents[mSlotIndex],
-                        NetworkCapabilities.NET_CAPABILITY_EIMS,
-                        mRestrictManager,
-                        mDataConnectionStatusTracker,
-                        mSlotIndex);
-        aneSos.registerForQualifiedNetworksChanged(mHandler, QUALIFIED_NETWORKS_CHANGED);
-        waitForLastHandlerAction(aneSos.mHandler);
-
-        aneSos.onDataConnectionStateChanged(
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        DataConnectionStatusTracker.EVENT_DATA_CONNECTION_DISCONNECTED,
-                        DataConnectionStatusTracker.STATE_INACTIVE,
-                        AccessNetworkConstants.TRANSPORT_TYPE_INVALID));
-        waitForLastHandlerAction(aneSos.mHandler);
-
-        aneSos.onDataConnectionStateChanged(
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        DataConnectionStatusTracker.EVENT_DATA_CONNECTION_FAILED,
-                        DataConnectionStatusTracker.STATE_INACTIVE,
-                        AccessNetworkConstants.TRANSPORT_TYPE_INVALID));
-        waitForLastHandlerAction(aneSos.mHandler);
-
-        verify(mMockWifiQm, times(2)).updateThresholdsForNetCapability(
-                NetworkCapabilities.NET_CAPABILITY_EIMS, mSlotIndex, null);
-    }
-
-    @Test
-    public void testOnImsCallDisconnectCauseChanged() {
-        // ANE takes time to build ANSP.
-        waitForLastHandlerAction(mAne.mHandler);
-        when(mRestrictManager.isRestricted(anyInt())).thenReturn(false);
-        when(mRestrictManager.isAllowedOnSingleTransport(anyInt())).thenReturn(true);
-        when(mDataConnectionStatusTracker.getLastTransportType())
-                .thenReturn(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        // make iwlan and cellular available
-        IwlanNetworkStatusTracker.IwlanAvailabilityInfo iwlanInfo =
-                mMockIwlanNetworkStatusTracker.new IwlanAvailabilityInfo(true, false);
-        mAne.onIwlanNetworkStatusChanged(iwlanInfo);
-        QnsTelephonyListener.QnsTelephonyInfo cellInfo =
-                mMockQnsTelephonyListener.new QnsTelephonyInfo();
-        cellInfo.setCellularAvailable(true);
-        cellInfo.setCoverage(true);
-        cellInfo.setDataNetworkType(TelephonyManager.NETWORK_TYPE_LTE);
-        cellInfo.setVoiceNetworkType(TelephonyManager.NETWORK_TYPE_LTE);
-        cellInfo.setDataRegState(ServiceState.STATE_IN_SERVICE);
-        mAne.onQnsTelephonyInfoChanged(cellInfo);
-        assertTrue(mAne.mIwlanAvailable);
-        assertTrue(mAne.mCellularAvailable);
-
-        // send ims call drop event.
-        ImsReasonInfo imsReasonInfo = new ImsReasonInfo(ImsReasonInfo.CODE_MEDIA_NO_DATA, 0);
-        Message.obtain(mAne.mHandler, EVENT_IMS_CALL_DISCONNECT_CAUSE_CHANGED,
-                new QnsAsyncResult(null, imsReasonInfo, null)).sendToTarget();
-        waitForLastHandlerAction(mAne.mHandler);
-
-        verify(mMockQnsMetrics, atLeast(1))
-                .reportAtomForImsCallDropStats(
-                        anyInt(), anyInt(), any(), any(), any(), anyInt(), anyInt());
-    }
-
-    @Test
-    public void testEvaluateSpecificReasonToString() throws Exception {
-        Method method = AccessNetworkEvaluator.class.getDeclaredMethod(
-                "evaluateSpecificReasonToString", int.class);
-        method.setAccessible(true);
-
-        IntStream.rangeClosed(0, 4).forEach(i -> {
-            try {
-                assertTrue(((String) method.invoke(mAne, i)).startsWith(
-                        "EVALUATE_SPECIFIC_REASON_"));
-            } catch (IllegalAccessException e) {
-                throw new RuntimeException(e);
-            } catch (InvocationTargetException e) {
-                throw new RuntimeException(e);
-            }
-        });
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/AccessNetworkSelectionPolicyBuilderTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/AccessNetworkSelectionPolicyBuilderTest.java
deleted file mode 100644
index 7fa7f49..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/AccessNetworkSelectionPolicyBuilderTest.java
+++ /dev/null
@@ -1,779 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static android.telephony.SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP;
-import static android.telephony.SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRQ;
-import static android.telephony.SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI;
-import static android.telephony.SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSRSRP;
-
-import static com.android.telephony.qns.AccessNetworkSelectionPolicyBuilder.UNAVAIL;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.when;
-
-import android.net.NetworkCapabilities;
-import android.telephony.AccessNetworkConstants.AccessNetworkType;
-import android.telephony.Rlog;
-
-import com.android.telephony.qns.AccessNetworkSelectionPolicy.PreCondition;
-import com.android.telephony.qns.QnsCarrierConfigManager.QnsConfigArray;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.mockito.stubbing.Answer;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-
-@RunWith(JUnit4.class)
-public class AccessNetworkSelectionPolicyBuilderTest {
-
-    @Mock private QnsCarrierConfigManager mConfig;
-
-    private AccessNetworkSelectionPolicyBuilder mBuilder = null;
-    static final int ROVE_IN = QnsConstants.ROVE_IN;
-    static final int ROVE_OUT = QnsConstants.ROVE_OUT;
-    static final int IDLE = QnsConstants.CALL_TYPE_IDLE;
-    static final int VOICE = QnsConstants.CALL_TYPE_VOICE;
-    static final int VIDEO = QnsConstants.CALL_TYPE_VIDEO;
-    static final int WIFI_PREF = QnsConstants.WIFI_PREF;
-    static final int CELL_PREF = QnsConstants.CELL_PREF;
-    static final int HOME = QnsConstants.COVERAGE_HOME;
-    static final int ROAM = QnsConstants.COVERAGE_ROAM;
-    static final int NGRAN = AccessNetworkType.NGRAN;
-    static final int EUTRAN = AccessNetworkType.EUTRAN;
-    static final int UTRAN = AccessNetworkType.UTRAN;
-    static final int GERAN = AccessNetworkType.GERAN;
-    static final int IWLAN = AccessNetworkType.IWLAN;
-
-    private final Map<String, QnsConfigArray> mTestConfigsMap = Map.ofEntries(
-            Map.entry(
-                            AccessNetworkType.EUTRAN
-                                    + "-"
-                                    + SIGNAL_MEASUREMENT_TYPE_RSRP
-                                    + "-"
-                                    + QnsConstants.CALL_TYPE_IDLE
-                                    + "-"
-                                    + QnsConstants.WIFI_PREF,
-                            new QnsConfigArray(-100, -115, -120)),
-            Map.entry(
-                            AccessNetworkType.EUTRAN
-                                    + "-"
-                                    + SIGNAL_MEASUREMENT_TYPE_RSRQ
-                                    + "-"
-                                    + QnsConstants.CALL_TYPE_IDLE
-                                    + "-"
-                                    + QnsConstants.WIFI_PREF,
-                            new QnsConfigArray(-10, -15, -20)),
-            Map.entry(
-                            AccessNetworkType.IWLAN
-                                    + "-"
-                                    + SIGNAL_MEASUREMENT_TYPE_RSSI
-                                    + "-"
-                                    + QnsConstants.CALL_TYPE_IDLE
-                                    + "-"
-                                    + QnsConstants.WIFI_PREF,
-                            new QnsConfigArray(-75, -85)),
-            Map.entry(
-                            AccessNetworkType.NGRAN
-                                    + "-"
-                                    + SIGNAL_MEASUREMENT_TYPE_SSRSRP
-                                    + "-"
-                                    + QnsConstants.CALL_TYPE_IDLE
-                                    + "-"
-                                    + QnsConstants.WIFI_PREF,
-                            new QnsConfigArray(-102, -117, -122)),
-            Map.entry(
-                            AccessNetworkType.EUTRAN
-                                    + "-"
-                                    + SIGNAL_MEASUREMENT_TYPE_RSRP
-                                    + "-"
-                                    + QnsConstants.CALL_TYPE_VOICE
-                                    + "-"
-                                    + QnsConstants.WIFI_PREF,
-                            new QnsConfigArray(-95, -110, -115)),
-            Map.entry(
-                            AccessNetworkType.IWLAN
-                                    + "-"
-                                    + SIGNAL_MEASUREMENT_TYPE_RSSI
-                                    + "-"
-                                    + QnsConstants.CALL_TYPE_VOICE
-                                    + "-"
-                                    + QnsConstants.WIFI_PREF,
-                            new QnsConfigArray(-76, -86)),
-            Map.entry(
-                            AccessNetworkType.NGRAN
-                                    + "-"
-                                    + SIGNAL_MEASUREMENT_TYPE_SSRSRP
-                                    + "-"
-                                    + QnsConstants.CALL_TYPE_VOICE
-                                    + "-"
-                                    + QnsConstants.WIFI_PREF,
-                            new QnsConfigArray(-92, -102, -112)),
-            Map.entry(
-                            AccessNetworkType.EUTRAN
-                                    + "-"
-                                    + SIGNAL_MEASUREMENT_TYPE_RSRP
-                                    + "-"
-                                    + QnsConstants.CALL_TYPE_IDLE
-                                    + "-"
-                                    + QnsConstants.CELL_PREF,
-                            new QnsConfigArray(-103, -118, -123)),
-            Map.entry(
-                            AccessNetworkType.EUTRAN
-                                    + "-"
-                                    + SIGNAL_MEASUREMENT_TYPE_RSRQ
-                                    + "-"
-                                    + QnsConstants.CALL_TYPE_IDLE
-                                    + "-"
-                                    + QnsConstants.CELL_PREF,
-                            new QnsConfigArray(-12, -16, -18)),
-            Map.entry(
-                            AccessNetworkType.IWLAN
-                                    + "-"
-                                    + SIGNAL_MEASUREMENT_TYPE_RSSI
-                                    + "-"
-                                    + QnsConstants.CALL_TYPE_IDLE
-                                    + "-"
-                                    + QnsConstants.CELL_PREF,
-                            new QnsConfigArray(-60, -75)),
-            Map.entry(
-                            AccessNetworkType.NGRAN
-                                    + "-"
-                                    + SIGNAL_MEASUREMENT_TYPE_SSRSRP
-                                    + "-"
-                                    + QnsConstants.CALL_TYPE_IDLE
-                                    + "-"
-                                    + QnsConstants.CELL_PREF,
-                            new QnsConfigArray(-100, -110, -120)),
-            Map.entry(
-                            AccessNetworkType.EUTRAN
-                                    + "-"
-                                    + SIGNAL_MEASUREMENT_TYPE_RSRP
-                                    + "-"
-                                    + QnsConstants.CALL_TYPE_VOICE
-                                    + "-"
-                                    + QnsConstants.CELL_PREF,
-                            new QnsConfigArray(-101, -116, -121)),
-            Map.entry(
-                            AccessNetworkType.EUTRAN
-                                    + "-"
-                                    + SIGNAL_MEASUREMENT_TYPE_RSRQ
-                                    + "-"
-                                    + QnsConstants.CALL_TYPE_VOICE
-                                    + "-"
-                                    + QnsConstants.CELL_PREF,
-                            new QnsConfigArray(-11, -16, -20)),
-            Map.entry(
-                            AccessNetworkType.IWLAN
-                                    + "-"
-                                    + SIGNAL_MEASUREMENT_TYPE_RSSI
-                                    + "-"
-                                    + QnsConstants.CALL_TYPE_VOICE
-                                    + "-"
-                                    + QnsConstants.CELL_PREF,
-                            new QnsConfigArray(-70, -80)),
-            Map.entry(
-                            AccessNetworkType.NGRAN
-                                    + "-"
-                                    + SIGNAL_MEASUREMENT_TYPE_SSRSRP
-                                    + "-"
-                                    + QnsConstants.CALL_TYPE_VOICE
-                                    + "-"
-                                    + QnsConstants.CELL_PREF,
-                            new QnsConfigArray(-90, -100, -110))
-    );
-
-    @Before
-    public void setUp() {
-        MockitoAnnotations.initMocks(this);
-        mBuilder =
-                new AccessNetworkSelectionPolicyBuilder(
-                        mConfig, NetworkCapabilities.NET_CAPABILITY_IMS);
-        stubConfigManager();
-    }
-
-    private void stubConfigManager() {
-        when(mConfig.getThresholdByPref(anyInt(), anyInt(), anyInt(), anyInt()))
-                .thenAnswer((Answer<QnsConfigArray>) invocation -> {
-                        Object[] args = invocation.getArguments();
-                        return mTestConfigsMap.get(
-                                args[0] + "-" + args[2] + "-" + args[1] + "-"
-                                        + args[3]);
-                    });
-        // stub threshold gap of 5 dBm
-        when(mConfig.getThresholdGapWithGuardTimer(anyInt(), anyInt())).thenReturn(5);
-    }
-
-    protected static void slog(String log) {
-        Rlog.d(AccessNetworkSelectionPolicyBuilderTest.class.getSimpleName(), log);
-    }
-
-    protected String[] getPolicy(int direction, int callType, int preference, int coverage) {
-        PreCondition condition = new PreCondition(callType, preference, coverage);
-        return mBuilder.getPolicy(direction, condition);
-    }
-
-    @Test
-    public void test_PolicyMap_Default() {
-        doReturn(null).when(mConfig).getPolicy(anyInt(), any());
-        doReturn(false).when(mConfig).isTransportTypeSelWithoutSSInRoamSupported();
-        doReturn(false).when(mConfig).isCurrentTransportTypeInVoiceCallSupported();
-        doReturn(false).when(mConfig).isChooseWfcPreferredTransportInBothBadCondition(anyInt());
-
-        String[] conditions;
-
-        List<Integer> callTypeList = List.of(IDLE, VOICE, VIDEO);
-        List<Integer> coverageList = List.of(HOME, ROAM);
-
-        for (int callType : callTypeList) {
-            for (int coverage : coverageList) {
-                conditions = getPolicy(ROVE_IN, callType, WIFI_PREF, coverage);
-                assertTrue(conditions.length == 1 && "Condition:WIFI_GOOD".equals(conditions[0]));
-            }
-        }
-
-        for (int callType : callTypeList) {
-            for (int coverage : coverageList) {
-                conditions = getPolicy(ROVE_OUT, callType, WIFI_PREF, coverage);
-                assertEquals(1, conditions.length);
-                assertEquals("Condition:WIFI_BAD", conditions[0]);
-            }
-        }
-
-        for (int callType : callTypeList) {
-            for (int coverage : coverageList) {
-                conditions = getPolicy(ROVE_IN, callType, CELL_PREF, coverage);
-                assertEquals(1, conditions.length);
-                assertEquals("Condition:WIFI_GOOD,CELLULAR_BAD", conditions[0]);
-            }
-        }
-
-        for (int callType : callTypeList) {
-            for (int coverage : coverageList) {
-                conditions = getPolicy(ROVE_OUT, callType, CELL_PREF, coverage);
-                assertEquals(2, conditions.length);
-                assertEquals("Condition:CELLULAR_GOOD", conditions[0]);
-                assertEquals("Condition:WIFI_BAD,CELLULAR_TOLERABLE", conditions[1]);
-            }
-        }
-    }
-
-    @Test
-    public void test_PolicyMap_isTransportTypeSelWithoutSSInRoamSupported() {
-        doReturn(null).when(mConfig).getPolicy(anyInt(), any());
-        doReturn(true).when(mConfig).isTransportTypeSelWithoutSSInRoamSupported();
-        doReturn(false).when(mConfig).isCurrentTransportTypeInVoiceCallSupported();
-        doReturn(false).when(mConfig).isChooseWfcPreferredTransportInBothBadCondition(anyInt());
-        doReturn(false).when(mConfig).allowImsOverIwlanCellularLimitedCase();
-
-        String[] conditions;
-        List<Integer> directionList = List.of(ROVE_IN, ROVE_OUT);
-        List<Integer> callTypeList = List.of(IDLE, VOICE, VIDEO);
-        List<Integer> preferenceList = List.of(WIFI_PREF, CELL_PREF);
-
-        for (int preference : preferenceList) {
-            for (int callType : callTypeList) {
-                for (int direction : directionList) {
-                    conditions = getPolicy(direction, callType, preference, ROAM);
-                    if ((preference == CELL_PREF && direction == ROVE_OUT)
-                            || (preference == WIFI_PREF && direction == ROVE_IN)) {
-                        assertEquals(1, conditions.length);
-                        assertEquals("Condition:WIFI_AVAILABLE", conditions[0]);
-                    } else {
-                        assertEquals(1, conditions.length);
-                        assertEquals("Condition:", conditions[0]);
-                    }
-                }
-            }
-        }
-    }
-
-    @Test
-    public void test_PolicyMap_isCurrentTransportTypeInVoiceCallSupported() {
-        doReturn(null).when(mConfig).getPolicy(anyInt(), any());
-        doReturn(false).when(mConfig).isTransportTypeSelWithoutSSInRoamSupported();
-        doReturn(true).when(mConfig).isCurrentTransportTypeInVoiceCallSupported();
-        doReturn(false).when(mConfig).isChooseWfcPreferredTransportInBothBadCondition(anyInt());
-
-        String[] conditions;
-        List<Integer> coverageList = List.of(HOME, ROAM);
-
-        for (int coverage : coverageList) {
-            conditions = getPolicy(ROVE_OUT, VOICE, CELL_PREF, coverage);
-            assertEquals(1, conditions.length);
-            assertEquals("Condition:WIFI_BAD", conditions[0]);
-        }
-    }
-
-    @Test
-    public void test_PolicyMap_isRoveOutOnCellularWifiBothBadSupported() {
-        doReturn(null).when(mConfig).getPolicy(anyInt(), any());
-        doReturn(false).when(mConfig).isTransportTypeSelWithoutSSInRoamSupported();
-        doReturn(false).when(mConfig).isCurrentTransportTypeInVoiceCallSupported();
-        doReturn(true).when(mConfig).isChooseWfcPreferredTransportInBothBadCondition(CELL_PREF);
-
-        String[] conditions;
-        List<Integer> callTypeList = List.of(IDLE, VOICE, VIDEO);
-        List<Integer> coverageList = List.of(HOME, ROAM);
-
-        for (int callType : callTypeList) {
-            for (int coverage : coverageList) {
-                conditions = getPolicy(ROVE_OUT, callType, CELL_PREF, coverage);
-                assertEquals(2, conditions.length);
-                assertEquals("Condition:WIFI_BAD", conditions[0]);
-                assertEquals("Condition:CELLULAR_GOOD", conditions[1]);
-            }
-        }
-    }
-
-    @Test
-    public void test_PolicyMap_isRoveInOnCellularWifiBothBadSupported() {
-        doReturn(null).when(mConfig).getPolicy(anyInt(), any());
-        doReturn(false).when(mConfig).isTransportTypeSelWithoutSSInRoamSupported();
-        doReturn(false).when(mConfig).isCurrentTransportTypeInVoiceCallSupported();
-        doReturn(true).when(mConfig).isChooseWfcPreferredTransportInBothBadCondition(WIFI_PREF);
-
-        String[] conditions;
-        List<Integer> callTypeList = List.of(IDLE, VOICE, VIDEO);
-        List<Integer> coverageList = List.of(HOME, ROAM);
-
-        for (int callType : callTypeList) {
-            for (int coverage : coverageList) {
-                conditions = getPolicy(ROVE_IN, callType, WIFI_PREF, coverage);
-                assertEquals(2, conditions.length);
-                assertEquals("Condition:WIFI_GOOD", conditions[0]);
-                assertEquals("Condition:CELLULAR_BAD", conditions[1]);
-            }
-        }
-    }
-
-    @Test
-    public void test_PolicyMap_allowImsOverIwlanCellularLimitedCase() {
-        doReturn(null).when(mConfig).getPolicy(anyInt(), any());
-        doReturn(true).when(mConfig).isTransportTypeSelWithoutSSInRoamSupported();
-        doReturn(false).when(mConfig).isCurrentTransportTypeInVoiceCallSupported();
-        doReturn(false).when(mConfig).isChooseWfcPreferredTransportInBothBadCondition(anyInt());
-        doReturn(true).when(mConfig).allowImsOverIwlanCellularLimitedCase();
-        doReturn(true)
-                .when(mConfig)
-                .isAccessNetworkAllowed(NGRAN, NetworkCapabilities.NET_CAPABILITY_IMS);
-        doReturn(true)
-                .when(mConfig)
-                .isAccessNetworkAllowed(EUTRAN, NetworkCapabilities.NET_CAPABILITY_IMS);
-        doReturn(false)
-                .when(mConfig)
-                .isAccessNetworkAllowed(UTRAN, NetworkCapabilities.NET_CAPABILITY_IMS);
-        doReturn(false)
-                .when(mConfig)
-                .isAccessNetworkAllowed(GERAN, NetworkCapabilities.NET_CAPABILITY_IMS);
-        doReturn(false)
-                .when(mConfig)
-                .isAccessNetworkAllowed(IWLAN, NetworkCapabilities.NET_CAPABILITY_IMS);
-
-        String[] conditions;
-        List<Integer> directionList = List.of(ROVE_IN, ROVE_OUT);
-        List<Integer> callTypeList = List.of(IDLE, VOICE, VIDEO);
-
-        for (int callType : callTypeList) {
-            for (int direction : directionList) {
-                int preference = WIFI_PREF;
-                conditions = getPolicy(direction, callType, preference, ROAM);
-                if (direction == ROVE_IN) {
-                    assertEquals(4, conditions.length);
-                    assertEquals("Condition:WIFI_AVAILABLE,NGRAN_AVAILABLE", conditions[0]);
-                    assertEquals("Condition:WIFI_AVAILABLE,EUTRAN_AVAILABLE", conditions[1]);
-                    assertEquals("Condition:WIFI_AVAILABLE,UTRAN_AVAILABLE", conditions[2]);
-                    assertEquals("Condition:WIFI_AVAILABLE,GERAN_AVAILABLE", conditions[3]);
-                } else {
-                    assertEquals(0, conditions.length);
-                }
-                preference = CELL_PREF;
-                conditions = getPolicy(direction, callType, preference, ROAM);
-                if (direction == ROVE_IN) {
-                    assertEquals(2, conditions.length);
-                    assertEquals("Condition:WIFI_AVAILABLE,UTRAN_AVAILABLE", conditions[0]);
-                    assertEquals("Condition:WIFI_AVAILABLE,GERAN_AVAILABLE", conditions[1]);
-                } else {
-                    assertEquals(2, conditions.length);
-                    assertEquals("Condition:WIFI_AVAILABLE,NGRAN_AVAILABLE", conditions[0]);
-                    assertEquals("Condition:WIFI_AVAILABLE,EUTRAN_AVAILABLE", conditions[1]);
-                }
-            }
-        }
-    }
-
-    @Test
-    public void testAddThresholdGroup_RoveIn() {
-        List<ThresholdGroup> thresholdGroupList = new ArrayList<>();
-        List<AccessNetworkSelectionPolicyBuilder.AnspItem> anspItemList = new ArrayList<>();
-        anspItemList.add(AccessNetworkSelectionPolicyBuilder.AnspItem.EUTRAN_RSRP_TOLERABLE);
-        anspItemList.add(AccessNetworkSelectionPolicyBuilder.AnspItem.IWLAN_AVAILABLE);
-        mBuilder.addThresholdGroup(
-                thresholdGroupList,
-                anspItemList,
-                QnsConstants.ROVE_IN,
-                new PreCondition(
-                        QnsConstants.CALL_TYPE_IDLE,
-                        QnsConstants.WIFI_PREF,
-                        QnsConstants.COVERAGE_HOME));
-
-        assertFalse(thresholdGroupList.isEmpty());
-        assertEquals(1, thresholdGroupList.size());
-        assertEquals(
-                -120,
-                thresholdGroupList
-                        .get(0)
-                        .getThresholds(AccessNetworkType.EUTRAN)
-                        .get(0)
-                        .getThreshold());
-        assertEquals(
-                1,
-                thresholdGroupList
-                        .get(0)
-                        .getThresholds(AccessNetworkType.IWLAN)
-                        .get(0)
-                        .getThreshold());
-
-        anspItemList.clear();
-        thresholdGroupList.clear();
-        anspItemList.add(AccessNetworkSelectionPolicyBuilder.AnspItem.EUTRAN_RSRP_BAD);
-        anspItemList.add(AccessNetworkSelectionPolicyBuilder.AnspItem.NGRAN_SSRSRP_BAD);
-        anspItemList.add(AccessNetworkSelectionPolicyBuilder.AnspItem.IWLAN_RSSI_GOOD);
-        mBuilder.addThresholdGroup(
-                thresholdGroupList,
-                anspItemList,
-                QnsConstants.ROVE_IN,
-                new PreCondition(
-                        QnsConstants.CALL_TYPE_IDLE,
-                        QnsConstants.CELL_PREF,
-                        QnsConstants.COVERAGE_HOME));
-
-        assertFalse(thresholdGroupList.isEmpty());
-        assertEquals(2, thresholdGroupList.size());
-        assertEquals(
-                -118,
-                thresholdGroupList
-                        .get(0)
-                        .getThresholds(AccessNetworkType.EUTRAN)
-                        .get(0)
-                        .getThreshold());
-        assertEquals(
-                -110,
-                thresholdGroupList
-                        .get(1)
-                        .getThresholds(AccessNetworkType.NGRAN)
-                        .get(0)
-                        .getThreshold());
-        assertEquals(
-                -60,
-                thresholdGroupList
-                        .get(0)
-                        .getThresholds(AccessNetworkType.IWLAN)
-                        .get(0)
-                        .getThreshold());
-        assertEquals(
-                -60,
-                thresholdGroupList
-                        .get(1)
-                        .getThresholds(AccessNetworkType.IWLAN)
-                        .get(0)
-                        .getThreshold());
-
-        anspItemList.clear();
-        thresholdGroupList.clear();
-        anspItemList.add(AccessNetworkSelectionPolicyBuilder.AnspItem.EUTRAN_RSRQ_BAD);
-        anspItemList.add(AccessNetworkSelectionPolicyBuilder.AnspItem.IWLAN_RSSI_GOOD);
-        mBuilder.addThresholdGroup(
-                thresholdGroupList,
-                anspItemList,
-                QnsConstants.ROVE_IN,
-                new AccessNetworkSelectionPolicy.GuardingPreCondition(
-                        QnsConstants.CALL_TYPE_IDLE,
-                        QnsConstants.CELL_PREF,
-                        QnsConstants.COVERAGE_ROAM,
-                        QnsConstants.GUARDING_WIFI));
-
-        assertFalse(thresholdGroupList.isEmpty());
-        assertEquals(1, thresholdGroupList.size());
-        assertEquals(
-                -11,
-                thresholdGroupList
-                        .get(0)
-                        .getThresholds(AccessNetworkType.EUTRAN)
-                        .get(0)
-                        .getThreshold());
-        assertEquals(
-                -55,
-                thresholdGroupList
-                        .get(0)
-                        .getThresholds(AccessNetworkType.IWLAN)
-                        .get(0)
-                        .getThreshold());
-
-        anspItemList.clear();
-        thresholdGroupList.clear();
-        anspItemList.add(AccessNetworkSelectionPolicyBuilder.AnspItem.EUTRAN_RSRQ_TOLERABLE);
-        anspItemList.add(AccessNetworkSelectionPolicyBuilder.AnspItem.NGRAN_SSRSRP_BAD);
-        anspItemList.add(AccessNetworkSelectionPolicyBuilder.AnspItem.IWLAN_RSSI_GOOD);
-        mBuilder.addThresholdGroup(
-                thresholdGroupList,
-                anspItemList,
-                QnsConstants.ROVE_IN,
-                new AccessNetworkSelectionPolicy.GuardingPreCondition(
-                        QnsConstants.CALL_TYPE_VOICE,
-                        QnsConstants.CELL_PREF,
-                        QnsConstants.COVERAGE_HOME,
-                        QnsConstants.GUARDING_CELLULAR));
-
-        assertFalse(thresholdGroupList.isEmpty());
-        assertEquals(2, thresholdGroupList.size());
-        assertEquals(
-                -20,
-                thresholdGroupList
-                        .get(0)
-                        .getThresholds(AccessNetworkType.EUTRAN)
-                        .get(0)
-                        .getThreshold());
-        assertEquals(
-                -100,
-                thresholdGroupList
-                        .get(1)
-                        .getThresholds(AccessNetworkType.NGRAN)
-                        .get(0)
-                        .getThreshold());
-        assertEquals(
-                -70,
-                thresholdGroupList
-                        .get(0)
-                        .getThresholds(AccessNetworkType.IWLAN)
-                        .get(0)
-                        .getThreshold());
-        assertEquals(
-                -70,
-                thresholdGroupList
-                        .get(1)
-                        .getThresholds(AccessNetworkType.IWLAN)
-                        .get(0)
-                        .getThreshold());
-
-        anspItemList.clear();
-        thresholdGroupList.clear();
-        anspItemList.add(AccessNetworkSelectionPolicyBuilder.AnspItem.EUTRAN_RSRP_TOLERABLE);
-        mBuilder.addThresholdGroup(
-                thresholdGroupList,
-                anspItemList,
-                QnsConstants.ROVE_IN,
-                new PreCondition(
-                        QnsConstants.CALL_TYPE_IDLE,
-                        QnsConstants.CELL_PREF,
-                        QnsConstants.COVERAGE_HOME));
-        assertEquals(
-                -123,
-                thresholdGroupList
-                        .get(0)
-                        .getThresholds(AccessNetworkType.EUTRAN)
-                        .get(0)
-                        .getThreshold());
-
-        anspItemList.clear();
-        thresholdGroupList.clear();
-        anspItemList.add(AccessNetworkSelectionPolicyBuilder.AnspItem.IWLAN_RSSI_GOOD);
-        mBuilder.addThresholdGroup(
-                thresholdGroupList,
-                anspItemList,
-                QnsConstants.ROVE_IN,
-                new PreCondition(
-                        QnsConstants.CALL_TYPE_IDLE,
-                        QnsConstants.CELL_PREF,
-                        QnsConstants.COVERAGE_HOME));
-        assertEquals(
-                -60,
-                thresholdGroupList
-                        .get(0)
-                        .getThresholds(AccessNetworkType.IWLAN)
-                        .get(0)
-                        .getThreshold());
-    }
-
-    @Test
-    public void testAddThresholdGroup_RoveOut() {
-        List<ThresholdGroup> thresholdGroupList = new ArrayList<>();
-        List<AccessNetworkSelectionPolicyBuilder.AnspItem> anspItemList = new ArrayList<>();
-
-        anspItemList.add(AccessNetworkSelectionPolicyBuilder.AnspItem.EUTRAN_AVAILABLE);
-        anspItemList.add(AccessNetworkSelectionPolicyBuilder.AnspItem.IWLAN_RSSI_BAD);
-        mBuilder.addThresholdGroup(
-                thresholdGroupList,
-                anspItemList,
-                QnsConstants.ROVE_OUT,
-                new PreCondition(
-                        QnsConstants.CALL_TYPE_VOICE,
-                        QnsConstants.WIFI_PREF,
-                        QnsConstants.COVERAGE_HOME));
-
-        assertFalse(thresholdGroupList.isEmpty());
-        assertEquals(1, thresholdGroupList.size());
-        assertEquals(
-                1,
-                thresholdGroupList
-                        .get(0)
-                        .getThresholds(AccessNetworkType.EUTRAN)
-                        .get(0)
-                        .getThreshold());
-        assertEquals(
-                -86,
-                thresholdGroupList
-                        .get(0)
-                        .getThresholds(AccessNetworkType.IWLAN)
-                        .get(0)
-                        .getThreshold());
-
-        anspItemList.clear();
-        thresholdGroupList.clear();
-        anspItemList.add(AccessNetworkSelectionPolicyBuilder.AnspItem.EUTRAN_RSRQ_GOOD);
-        anspItemList.add(AccessNetworkSelectionPolicyBuilder.AnspItem.EUTRAN_RSRP_GOOD);
-        anspItemList.add(AccessNetworkSelectionPolicyBuilder.AnspItem.IWLAN_RSSI_BAD);
-        mBuilder.addThresholdGroup(
-                thresholdGroupList,
-                anspItemList,
-                QnsConstants.ROVE_OUT,
-                new PreCondition(
-                        QnsConstants.CALL_TYPE_IDLE,
-                        QnsConstants.WIFI_PREF,
-                        QnsConstants.COVERAGE_HOME));
-
-        assertFalse(thresholdGroupList.isEmpty());
-        assertEquals(1, thresholdGroupList.size());
-        assertEquals(2, thresholdGroupList.get(0).getThresholds(AccessNetworkType.EUTRAN).size());
-        assertEquals(
-                -10,
-                thresholdGroupList
-                        .get(0)
-                        .getThresholds(AccessNetworkType.EUTRAN)
-                        .get(0)
-                        .getThreshold());
-        assertEquals(
-                -100,
-                thresholdGroupList
-                        .get(0)
-                        .getThresholds(AccessNetworkType.EUTRAN)
-                        .get(1)
-                        .getThreshold());
-        assertEquals(
-                -85,
-                thresholdGroupList
-                        .get(0)
-                        .getThresholds(AccessNetworkType.IWLAN)
-                        .get(0)
-                        .getThreshold());
-
-        anspItemList.clear();
-        thresholdGroupList.clear();
-        anspItemList.add(AccessNetworkSelectionPolicyBuilder.AnspItem.EUTRAN_RSRP_GOOD);
-        anspItemList.add(AccessNetworkSelectionPolicyBuilder.AnspItem.IWLAN_RSSI_BAD);
-        mBuilder.addThresholdGroup(
-                thresholdGroupList,
-                anspItemList,
-                QnsConstants.ROVE_OUT,
-                new AccessNetworkSelectionPolicy.GuardingPreCondition(
-                        QnsConstants.CALL_TYPE_VOICE,
-                        QnsConstants.WIFI_PREF,
-                        QnsConstants.COVERAGE_ROAM,
-                        QnsConstants.GUARDING_WIFI));
-
-        assertFalse(thresholdGroupList.isEmpty());
-        assertEquals(1, thresholdGroupList.size());
-        assertEquals(
-                -95,
-                thresholdGroupList
-                        .get(0)
-                        .getThresholds(AccessNetworkType.EUTRAN)
-                        .get(0)
-                        .getThreshold());
-        assertEquals(
-                -86,
-                thresholdGroupList
-                        .get(0)
-                        .getThresholds(AccessNetworkType.IWLAN)
-                        .get(0)
-                        .getThreshold());
-    }
-
-    @Test
-    public void testMakeUnavailableThreshold() {
-        when(mConfig.getCellularSSBackHaulTimer()).thenReturn(20000);
-        when(mConfig.getWIFIRssiBackHaulTimer()).thenReturn(50000);
-        verifyUnavailableThreshold(
-                mBuilder.makeUnavailableThreshold(AccessNetworkType.EUTRAN), 20000);
-        verifyUnavailableThreshold(
-                mBuilder.makeUnavailableThreshold(AccessNetworkType.IWLAN), 50000);
-    }
-
-    private void verifyUnavailableThreshold(Threshold threshold, int waitTime) {
-        assertEquals(QnsConstants.SIGNAL_MEASUREMENT_AVAILABILITY, threshold.getMeasurementType());
-        assertEquals(QnsConstants.THRESHOLD_MATCH_TYPE_EQUAL_TO, threshold.getMatchType());
-        assertEquals(UNAVAIL, threshold.getThreshold());
-        assertEquals(waitTime, threshold.getWaitTime());
-    }
-
-    @Test
-    public void testMakeThresholdsWifiWithoutCellular() {
-        when(mConfig.getWifiRssiThresholdWithoutCellular(anyInt()))
-                .thenReturn(null, new QnsConfigArray(-60, -70));
-        List<Threshold> thsList =
-                mBuilder.makeThresholdsWifiWithoutCellular(
-                        QnsConstants.ROVE_IN,
-                        new PreCondition(
-                                QnsConstants.CALL_TYPE_VOICE,
-                                QnsConstants.WIFI_PREF,
-                                QnsConstants.COVERAGE_HOME));
-        assertTrue(thsList.isEmpty());
-
-        thsList =
-                mBuilder.makeThresholdsWifiWithoutCellular(
-                        QnsConstants.ROVE_IN,
-                        new PreCondition(
-                                QnsConstants.CALL_TYPE_VOICE,
-                                QnsConstants.WIFI_PREF,
-                                QnsConstants.COVERAGE_HOME));
-        assertNotNull(thsList.get(0));
-        assertEquals(-60, thsList.get(0).getThreshold());
-
-        thsList =
-                mBuilder.makeThresholdsWifiWithoutCellular(
-                        QnsConstants.ROVE_OUT,
-                        new PreCondition(
-                                QnsConstants.CALL_TYPE_VOICE,
-                                QnsConstants.WIFI_PREF,
-                                QnsConstants.COVERAGE_HOME));
-        assertNotNull(thsList.get(0));
-        assertEquals(-70, thsList.get(0).getThreshold());
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/AccessNetworkSelectionPolicyTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/AccessNetworkSelectionPolicyTest.java
deleted file mode 100644
index 9c54c97..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/AccessNetworkSelectionPolicyTest.java
+++ /dev/null
@@ -1,391 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.when;
-
-import android.net.NetworkCapabilities;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.SignalThresholdInfo;
-
-import com.android.telephony.qns.AccessNetworkSelectionPolicy.GuardingPreCondition;
-import com.android.telephony.qns.AccessNetworkSelectionPolicy.PreCondition;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.MockitoAnnotations;
-
-import java.util.ArrayList;
-import java.util.List;
-
-@RunWith(JUnit4.class)
-public class AccessNetworkSelectionPolicyTest extends QnsTest {
-    int mNetCapability = NetworkCapabilities.NET_CAPABILITY_IMS;
-    int mTargetTransportType = AccessNetworkConstants.TRANSPORT_TYPE_WWAN;
-    private PreCondition mPreCondition =
-            new PreCondition(
-                    QnsConstants.CALL_TYPE_IDLE,
-                    QnsConstants.CELL_PREF,
-                    QnsConstants.COVERAGE_HOME);
-    List<Threshold> mThresholds = new ArrayList<>();
-    List<ThresholdGroup> mThresholdGroups = new ArrayList<>();
-
-    @Before
-    public void setUp() throws Exception {
-        MockitoAnnotations.initMocks(this);
-        super.setUp();
-    }
-
-    @Test
-    public void testGetTargetTransportType() {
-        AccessNetworkSelectionPolicy ansp =
-                new AccessNetworkSelectionPolicy(
-                        mNetCapability, mTargetTransportType, mPreCondition, mThresholdGroups);
-        assertEquals(mTargetTransportType, ansp.getTargetTransportType());
-        assertNotEquals(AccessNetworkConstants.TRANSPORT_TYPE_WLAN, ansp.getTargetTransportType());
-    }
-
-    @Test
-    public void testSatisfyPrecondition() {
-        AccessNetworkSelectionPolicy ansp =
-                new AccessNetworkSelectionPolicy(
-                        mNetCapability, mTargetTransportType, mPreCondition, mThresholdGroups);
-        assertTrue(
-                ansp.satisfyPrecondition(
-                        new PreCondition(
-                                QnsConstants.CALL_TYPE_IDLE,
-                                QnsConstants.CELL_PREF,
-                                QnsConstants.COVERAGE_HOME)));
-        assertFalse(
-                ansp.satisfyPrecondition(
-                        new PreCondition(
-                                QnsConstants.CALL_TYPE_VOICE,
-                                QnsConstants.CELL_PREF,
-                                QnsConstants.COVERAGE_HOME)));
-        assertFalse(
-                ansp.satisfyPrecondition(
-                        new PreCondition(
-                                QnsConstants.CALL_TYPE_IDLE,
-                                QnsConstants.CELL_PREF,
-                                QnsConstants.COVERAGE_ROAM)));
-        assertFalse(
-                ansp.satisfyPrecondition(
-                        new PreCondition(
-                                QnsConstants.CALL_TYPE_IDLE,
-                                QnsConstants.WIFI_ONLY,
-                                QnsConstants.COVERAGE_HOME)));
-        assertFalse(
-                ansp.satisfyPrecondition(
-                        new PreCondition(
-                                QnsConstants.CALL_TYPE_IDLE,
-                                QnsConstants.WIFI_PREF,
-                                QnsConstants.COVERAGE_HOME)));
-    }
-
-    @Test
-    public void testSatisfiedByThreshold_thresholdGroup() {
-        List<Threshold> ths = new ArrayList<>();
-        ths.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                        -117,
-                        QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        ths.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRQ,
-                        -13,
-                        QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        mThresholdGroups.add(new ThresholdGroup(ths));
-
-        when(mMockCellularQm.getCurrentQuality(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP))
-                .thenReturn(-120);
-        when(mMockCellularQm.getCurrentQuality(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRQ))
-                .thenReturn(-15)
-                .thenReturn(-10);
-
-        AccessNetworkSelectionPolicy ansp =
-                new AccessNetworkSelectionPolicy(
-                        mNetCapability, mTargetTransportType, mPreCondition, mThresholdGroups);
-
-        assertFalse(
-                ansp.satisfiedByThreshold(
-                        null, null, false, true, AccessNetworkConstants.AccessNetworkType.EUTRAN));
-
-        boolean result =
-                ansp.satisfiedByThreshold(
-                        mMockWifiQm,
-                        mMockCellularQm,
-                        false,
-                        true,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        assertFalse(result);
-
-        result =
-                ansp.satisfiedByThreshold(
-                        mMockWifiQm,
-                        mMockCellularQm,
-                        false,
-                        true,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        assertTrue(result);
-    }
-
-    @Test
-    public void testFindUnmatchedThresholds() {
-        mTargetTransportType = AccessNetworkConstants.TRANSPORT_TYPE_WLAN;
-        int expected = 3;
-        mThresholdGroups = generateTestThresholdGroups();
-        when(mMockCellularQm.getCurrentQuality(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP))
-                .thenReturn(-90);
-        when(mMockCellularQm.getCurrentQuality(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRQ))
-                .thenReturn(-15);
-        when(mMockCellularQm.getCurrentQuality(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR))
-                .thenReturn(-5);
-        when(mMockWifiQm.getCurrentQuality(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI))
-                .thenReturn(-80);
-        AccessNetworkSelectionPolicy ansp =
-                new AccessNetworkSelectionPolicy(
-                        mNetCapability, mTargetTransportType, mPreCondition, mThresholdGroups);
-
-        assertNull(ansp.findUnmatchedThresholds(null, mMockCellularQm));
-        assertNull(ansp.findUnmatchedThresholds(mMockWifiQm, null));
-
-        List<Threshold> unmatched = ansp.findUnmatchedThresholds(mMockWifiQm, mMockCellularQm);
-        assertEquals(expected, unmatched.size());
-    }
-
-    private List<ThresholdGroup> generateTestThresholdGroups() {
-        List<ThresholdGroup> thgroups = new ArrayList<>();
-        List<Threshold> ths = new ArrayList<>();
-        ths.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                        -117,
-                        QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        ths.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR,
-                        -15,
-                        QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        ths.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                        -65,
-                        QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        thgroups.add(new ThresholdGroup(ths));
-
-        ths = new ArrayList<>();
-        ths.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                        -91,
-                        QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        ths.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR,
-                        -1,
-                        QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        ths.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                        -85,
-                        QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        thgroups.add(new ThresholdGroup(ths));
-        return thgroups;
-    }
-
-    @Test
-    public void testGuardingPreconditionSatisfied() {
-        GuardingPreCondition guardingPreCondition =
-                new GuardingPreCondition(
-                        QnsConstants.CALL_TYPE_VOICE,
-                        QnsConstants.WIFI_PREF,
-                        QnsConstants.COVERAGE_HOME,
-                        QnsConstants.GUARDING_WIFI);
-
-        PreCondition preCondition =
-                new PreCondition(
-                        QnsConstants.CALL_TYPE_VOICE,
-                        QnsConstants.WIFI_PREF,
-                        QnsConstants.COVERAGE_HOME);
-        assertTrue(guardingPreCondition.satisfied(preCondition));
-
-        preCondition =
-                new PreCondition(
-                        QnsConstants.CALL_TYPE_IDLE,
-                        QnsConstants.WIFI_PREF,
-                        QnsConstants.COVERAGE_HOME);
-        assertFalse(guardingPreCondition.satisfied(preCondition));
-
-        preCondition =
-                new PreCondition(
-                        QnsConstants.CALL_TYPE_VOICE,
-                        QnsConstants.CELL_PREF,
-                        QnsConstants.COVERAGE_HOME);
-        assertFalse(guardingPreCondition.satisfied(preCondition));
-
-        preCondition =
-                new PreCondition(
-                        QnsConstants.CALL_TYPE_VOICE,
-                        QnsConstants.WIFI_PREF,
-                        QnsConstants.COVERAGE_ROAM);
-        assertFalse(guardingPreCondition.satisfied(preCondition));
-
-        preCondition =
-                new GuardingPreCondition(
-                        QnsConstants.CALL_TYPE_VOICE,
-                        QnsConstants.WIFI_PREF,
-                        QnsConstants.COVERAGE_HOME,
-                        QnsConstants.GUARDING_WIFI);
-        assertTrue(guardingPreCondition.satisfied(preCondition));
-
-        preCondition =
-                new GuardingPreCondition(
-                        QnsConstants.CALL_TYPE_VOICE,
-                        QnsConstants.WIFI_PREF,
-                        QnsConstants.COVERAGE_HOME,
-                        QnsConstants.GUARDING_CELLULAR);
-        assertFalse(guardingPreCondition.satisfied(preCondition));
-    }
-
-    @Test
-    public void testGuardingPreconditionEquals() {
-        GuardingPreCondition guardingPreCondition =
-                new GuardingPreCondition(
-                        QnsConstants.CALL_TYPE_IDLE,
-                        QnsConstants.CELL_PREF,
-                        QnsConstants.COVERAGE_ROAM,
-                        QnsConstants.GUARDING_CELLULAR);
-
-        GuardingPreCondition copy = guardingPreCondition;
-        assertEquals(guardingPreCondition, copy);
-
-        PreCondition preCondition = guardingPreCondition;
-        assertEquals(guardingPreCondition, preCondition);
-
-        preCondition =
-                new PreCondition(
-                        QnsConstants.CALL_TYPE_IDLE,
-                        QnsConstants.CELL_PREF,
-                        QnsConstants.COVERAGE_ROAM);
-        assertNotEquals(guardingPreCondition, preCondition);
-
-        preCondition =
-                new GuardingPreCondition(
-                        QnsConstants.CALL_TYPE_IDLE,
-                        QnsConstants.CELL_PREF,
-                        QnsConstants.COVERAGE_HOME,
-                        QnsConstants.GUARDING_CELLULAR);
-        assertNotEquals(guardingPreCondition, preCondition);
-    }
-
-    @Test
-    public void testHasWifiThresholdWithoutCellularCondition() {
-        AccessNetworkSelectionPolicy ansp =
-                new AccessNetworkSelectionPolicy(
-                        mNetCapability, mTargetTransportType, mPreCondition, null);
-        AccessNetworkSelectionPolicy.PostCondition postCondition = ansp.new PostCondition(null);
-        assertFalse(postCondition.hasWifiThresholdWithoutCellularCondition());
-
-        List<ThresholdGroup> thgroups = new ArrayList<>();
-        List<Threshold> ths = new ArrayList<>();
-        ths.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                        -117,
-                        QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        ths.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                        -65,
-                        QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        thgroups.add(new ThresholdGroup(ths));
-
-        postCondition = ansp.new PostCondition(thgroups);
-        assertFalse(postCondition.hasWifiThresholdWithoutCellularCondition());
-
-        thgroups.clear();
-        ths.clear();
-        ths.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                        -65,
-                        QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        ths.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        QnsConstants.SIGNAL_MEASUREMENT_AVAILABILITY,
-                        QnsConstants.SIGNAL_UNAVAILABLE,
-                        QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        thgroups.add(new ThresholdGroup(ths));
-
-        postCondition = ansp.new PostCondition(thgroups);
-        assertTrue(postCondition.hasWifiThresholdWithoutCellularCondition());
-    }
-
-    @Test
-    public void testSatisfiedWithWifiLowSignalStrength() {}
-
-    @After
-    public void tearDown() {
-        mThresholds.clear();
-        mThresholdGroups.clear();
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/AnspImsPreferModePolicyBuilderTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/AnspImsPreferModePolicyBuilderTest.java
deleted file mode 100644
index 9c554c8..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/AnspImsPreferModePolicyBuilderTest.java
+++ /dev/null
@@ -1,211 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static com.android.telephony.qns.QnsConstants.CALL_TYPE_IDLE;
-import static com.android.telephony.qns.QnsConstants.CALL_TYPE_VIDEO;
-import static com.android.telephony.qns.QnsConstants.CALL_TYPE_VOICE;
-import static com.android.telephony.qns.QnsConstants.CELL_PREF;
-import static com.android.telephony.qns.QnsConstants.COVERAGE_HOME;
-import static com.android.telephony.qns.QnsConstants.COVERAGE_ROAM;
-import static com.android.telephony.qns.QnsConstants.ROVE_IN;
-import static com.android.telephony.qns.QnsConstants.ROVE_OUT;
-import static com.android.telephony.qns.QnsConstants.WIFI_PREF;
-
-import android.net.NetworkCapabilities;
-import android.telephony.AccessNetworkConstants;
-
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.MockitoAnnotations;
-
-import java.util.List;
-
-@RunWith(JUnit4.class)
-public class AnspImsPreferModePolicyBuilderTest extends QnsTest {
-
-    private AnspImsPreferModePolicyBuilder mBuilder;
-
-    @Before
-    public void setUp() throws Exception {
-        MockitoAnnotations.initMocks(this);
-        super.setUp();
-        mBuilder =
-                new AnspImsPreferModePolicyBuilder(
-                        mMockQnsConfigManager, NetworkCapabilities.NET_CAPABILITY_IMS);
-    }
-
-    @Test
-    public void testGetPolicyInMap_rove_in() {
-        String[] result =
-                mBuilder.getPolicyInMap(
-                        ROVE_IN,
-                        new AccessNetworkSelectionPolicy.PreCondition(
-                                CALL_TYPE_IDLE, WIFI_PREF, COVERAGE_HOME));
-        Assert.assertEquals("Condition:WIFI_AVAILABLE", result[0]);
-
-        result =
-                mBuilder.getPolicyInMap(
-                        QnsConstants.ROVE_IN,
-                        new AccessNetworkSelectionPolicy.PreCondition(
-                                CALL_TYPE_VOICE, WIFI_PREF, COVERAGE_HOME));
-        Assert.assertEquals("Condition:WIFI_GOOD", result[0]);
-
-        result =
-                mBuilder.getPolicyInMap(
-                        QnsConstants.ROVE_IN,
-                        new AccessNetworkSelectionPolicy.PreCondition(
-                                CALL_TYPE_VIDEO, WIFI_PREF, COVERAGE_HOME));
-        Assert.assertEquals("Condition:WIFI_GOOD", result[0]);
-
-        result =
-                mBuilder.getPolicyInMap(
-                        QnsConstants.ROVE_IN,
-                        new AccessNetworkSelectionPolicy.PreCondition(
-                                CALL_TYPE_IDLE, CELL_PREF, COVERAGE_ROAM));
-        Assert.assertEquals("Condition:WIFI_GOOD,CELLULAR_BAD", result[0]);
-
-        result =
-                mBuilder.getPolicyInMap(
-                        QnsConstants.ROVE_IN,
-                        new AccessNetworkSelectionPolicy.PreCondition(
-                                CALL_TYPE_VOICE, CELL_PREF, COVERAGE_ROAM));
-        Assert.assertEquals("Condition:WIFI_GOOD,CELLULAR_BAD", result[0]);
-
-        result =
-                mBuilder.getPolicyInMap(
-                        QnsConstants.ROVE_IN,
-                        new AccessNetworkSelectionPolicy.PreCondition(
-                                CALL_TYPE_VIDEO, CELL_PREF, COVERAGE_ROAM));
-        Assert.assertEquals("Condition:WIFI_GOOD,CELLULAR_BAD", result[0]);
-
-        result =
-                mBuilder.getPolicyInMap(
-                        QnsConstants.ROVE_IN,
-                        new AccessNetworkSelectionPolicy.PreCondition(
-                                CALL_TYPE_IDLE, CELL_PREF, COVERAGE_HOME));
-        Assert.assertEquals("Condition:WIFI_GOOD,EUTRAN_BAD", result[0]);
-        Assert.assertEquals("Condition:WIFI_GOOD,UTRAN_AVAILABLE", result[1]);
-        Assert.assertEquals("Condition:WIFI_GOOD,GERAN_AVAILABLE", result[2]);
-
-        result =
-                mBuilder.getPolicyInMap(
-                        QnsConstants.ROVE_IN,
-                        new AccessNetworkSelectionPolicy.PreCondition(
-                                CALL_TYPE_VOICE, CELL_PREF, COVERAGE_HOME));
-        Assert.assertEquals("Condition:WIFI_GOOD,EUTRAN_BAD", result[0]);
-        Assert.assertEquals("Condition:WIFI_GOOD,UTRAN_AVAILABLE", result[1]);
-        Assert.assertEquals("Condition:WIFI_GOOD,GERAN_AVAILABLE", result[2]);
-
-        result =
-                mBuilder.getPolicyInMap(
-                        QnsConstants.ROVE_IN,
-                        new AccessNetworkSelectionPolicy.PreCondition(
-                                CALL_TYPE_VIDEO, CELL_PREF, COVERAGE_HOME));
-        Assert.assertEquals("Condition:WIFI_GOOD,EUTRAN_BAD", result[0]);
-        Assert.assertEquals("Condition:WIFI_GOOD,UTRAN_AVAILABLE", result[1]);
-        Assert.assertEquals("Condition:WIFI_GOOD,GERAN_AVAILABLE", result[2]);
-    }
-
-    @Test
-    public void testGetPolicyInMap_rove_out() {
-        String[] result =
-                mBuilder.getPolicyInMap(
-                        ROVE_OUT,
-                        new AccessNetworkSelectionPolicy.PreCondition(
-                                CALL_TYPE_IDLE, WIFI_PREF, COVERAGE_HOME));
-        Assert.assertEquals("Condition:EUTRAN_TOLERABLE", result[0]);
-
-        result =
-                mBuilder.getPolicyInMap(
-                        ROVE_OUT,
-                        new AccessNetworkSelectionPolicy.PreCondition(
-                                CALL_TYPE_VOICE, WIFI_PREF, COVERAGE_HOME));
-        Assert.assertEquals("Condition:WIFI_BAD,EUTRAN_TOLERABLE", result[0]);
-
-        result =
-                mBuilder.getPolicyInMap(
-                        ROVE_OUT,
-                        new AccessNetworkSelectionPolicy.PreCondition(
-                                CALL_TYPE_VIDEO, WIFI_PREF, COVERAGE_HOME));
-        Assert.assertEquals("Condition:WIFI_BAD,EUTRAN_TOLERABLE", result[0]);
-
-        result =
-                mBuilder.getPolicyInMap(
-                        ROVE_OUT,
-                        new AccessNetworkSelectionPolicy.PreCondition(
-                                CALL_TYPE_IDLE, CELL_PREF, COVERAGE_ROAM));
-        Assert.assertEquals("Condition:CELLULAR_GOOD", result[0]);
-
-        result =
-                mBuilder.getPolicyInMap(
-                        ROVE_OUT,
-                        new AccessNetworkSelectionPolicy.PreCondition(
-                                CALL_TYPE_VOICE, CELL_PREF, COVERAGE_ROAM));
-        Assert.assertEquals("Condition:WIFI_BAD,EUTRAN_TOLERABLE", result[0]);
-
-        result =
-                mBuilder.getPolicyInMap(
-                        ROVE_OUT,
-                        new AccessNetworkSelectionPolicy.PreCondition(
-                                CALL_TYPE_VIDEO, CELL_PREF, COVERAGE_ROAM));
-        Assert.assertEquals("Condition:WIFI_BAD,EUTRAN_TOLERABLE", result[0]);
-
-        result =
-                mBuilder.getPolicyInMap(
-                        ROVE_OUT,
-                        new AccessNetworkSelectionPolicy.PreCondition(
-                                CALL_TYPE_IDLE, CELL_PREF, COVERAGE_HOME));
-        Assert.assertEquals("Condition:EUTRAN_GOOD", result[0]);
-        Assert.assertEquals("Condition:WIFI_BAD,EUTRAN_TOLERABLE", result[1]);
-        Assert.assertEquals("Condition:WIFI_BAD,UTRAN_GOOD", result[2]);
-        Assert.assertEquals("Condition:WIFI_BAD,GERAN_GOOD", result[3]);
-
-        result =
-                mBuilder.getPolicyInMap(
-                        ROVE_OUT,
-                        new AccessNetworkSelectionPolicy.PreCondition(
-                                CALL_TYPE_VOICE, CELL_PREF, COVERAGE_HOME));
-        Assert.assertEquals("Condition:EUTRAN_GOOD", result[0]);
-        Assert.assertEquals("Condition:WIFI_BAD,EUTRAN_TOLERABLE", result[1]);
-        Assert.assertEquals("Condition:WIFI_BAD,UTRAN_GOOD", result[2]);
-        Assert.assertEquals("Condition:WIFI_BAD,GERAN_GOOD", result[3]);
-
-        result =
-                mBuilder.getPolicyInMap(
-                        ROVE_OUT,
-                        new AccessNetworkSelectionPolicy.PreCondition(
-                                CALL_TYPE_VIDEO, CELL_PREF, COVERAGE_HOME));
-        Assert.assertEquals("Condition:EUTRAN_GOOD", result[0]);
-        Assert.assertEquals("Condition:WIFI_BAD,EUTRAN_TOLERABLE", result[1]);
-        Assert.assertEquals("Condition:WIFI_BAD,UTRAN_GOOD", result[2]);
-        Assert.assertEquals("Condition:WIFI_BAD,GERAN_GOOD", result[3]);
-    }
-
-    @Test
-    public void testGetSupportAccessNetworkTypes() {
-        List<Integer> ans = mBuilder.getSupportAccessNetworkTypes();
-        Assert.assertTrue(ans.contains(AccessNetworkConstants.AccessNetworkType.EUTRAN));
-        Assert.assertTrue(ans.contains(AccessNetworkConstants.AccessNetworkType.UTRAN));
-        Assert.assertTrue(ans.contains(AccessNetworkConstants.AccessNetworkType.GERAN));
-        Assert.assertTrue(ans.contains(AccessNetworkConstants.AccessNetworkType.IWLAN));
-        Assert.assertFalse(ans.contains(AccessNetworkConstants.AccessNetworkType.NGRAN));
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/CellularNetworkStatusTrackerTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/CellularNetworkStatusTrackerTest.java
deleted file mode 100644
index fb3e833..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/CellularNetworkStatusTrackerTest.java
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.net.NetworkCapabilities;
-import android.os.Handler;
-import android.os.Looper;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.MockitoAnnotations;
-
-@RunWith(JUnit4.class)
-public class CellularNetworkStatusTrackerTest extends QnsTest {
-
-    private CellularNetworkStatusTracker mCellularNetworkStatusTracker;
-    private Handler mHandler;
-
-    @Before
-    public void setUp() throws Exception {
-        MockitoAnnotations.initMocks(this);
-        super.setUp();
-        mCellularNetworkStatusTracker =
-                new CellularNetworkStatusTracker(mMockQnsTelephonyListener, 0);
-        mHandler = new Handler(Looper.getMainLooper());
-    }
-
-    @After
-    public void tearDown() {
-        mCellularNetworkStatusTracker.close();
-    }
-
-    @Test
-    public void testRegisterQnsTelephonyInfoChanged() {
-        mCellularNetworkStatusTracker.registerQnsTelephonyInfoChanged(
-                NetworkCapabilities.NET_CAPABILITY_IMS, mHandler, 0);
-        verify(mMockQnsTelephonyListener)
-                .registerQnsTelephonyInfoChanged(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, mHandler, 0, null, true);
-
-        mCellularNetworkStatusTracker.registerQnsTelephonyInfoChanged(
-                NetworkCapabilities.NET_CAPABILITY_XCAP, mHandler, 1);
-        verify(mMockQnsTelephonyListener)
-                .registerQnsTelephonyInfoChanged(
-                        NetworkCapabilities.NET_CAPABILITY_XCAP, mHandler, 1, null, true);
-
-        mCellularNetworkStatusTracker.registerQnsTelephonyInfoChanged(
-                NetworkCapabilities.NET_CAPABILITY_MMS, mHandler, 2);
-        verify(mMockQnsTelephonyListener)
-                .registerQnsTelephonyInfoChanged(
-                        NetworkCapabilities.NET_CAPABILITY_MMS, mHandler, 2, null, true);
-
-        mCellularNetworkStatusTracker.registerQnsTelephonyInfoChanged(
-                NetworkCapabilities.NET_CAPABILITY_EIMS, mHandler, 0);
-        verify(mMockQnsTelephonyListener)
-                .registerQnsTelephonyInfoChanged(
-                        NetworkCapabilities.NET_CAPABILITY_EIMS, mHandler, 0, null, true);
-    }
-
-    @Test
-    public void testUnregisterQnsTelephonyInfoChanged() {
-        testRegisterQnsTelephonyInfoChanged();
-        mCellularNetworkStatusTracker.unregisterQnsTelephonyInfoChanged(
-                NetworkCapabilities.NET_CAPABILITY_IMS, mHandler);
-        verify(mMockQnsTelephonyListener)
-                .unregisterQnsTelephonyInfoChanged(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, mHandler);
-
-        mCellularNetworkStatusTracker.unregisterQnsTelephonyInfoChanged(
-                NetworkCapabilities.NET_CAPABILITY_XCAP, mHandler);
-        verify(mMockQnsTelephonyListener)
-                .unregisterQnsTelephonyInfoChanged(
-                        NetworkCapabilities.NET_CAPABILITY_XCAP, mHandler);
-
-        mCellularNetworkStatusTracker.unregisterQnsTelephonyInfoChanged(
-                NetworkCapabilities.NET_CAPABILITY_MMS, mHandler);
-        verify(mMockQnsTelephonyListener)
-                .unregisterQnsTelephonyInfoChanged(
-                        NetworkCapabilities.NET_CAPABILITY_MMS, mHandler);
-
-        mCellularNetworkStatusTracker.unregisterQnsTelephonyInfoChanged(
-                NetworkCapabilities.NET_CAPABILITY_EIMS, mHandler);
-        verify(mMockQnsTelephonyListener)
-                .unregisterQnsTelephonyInfoChanged(
-                        NetworkCapabilities.NET_CAPABILITY_EIMS, mHandler);
-    }
-
-    @Test
-    public void testIsAirplaneModeEnabled() {
-        when(mMockQnsTelephonyListener.isAirplaneModeEnabled()).thenReturn(true, false);
-        assertTrue(mCellularNetworkStatusTracker.isAirplaneModeEnabled());
-        assertFalse(mCellularNetworkStatusTracker.isAirplaneModeEnabled());
-    }
-
-    @Test
-    public void testIsSupportVoPS() {
-        when(mMockQnsTelephonyListener.isSupportVoPS()).thenReturn(true, false);
-        assertTrue(mCellularNetworkStatusTracker.isSupportVoPS());
-        assertFalse(mCellularNetworkStatusTracker.isSupportVoPS());
-    }
-
-    @Test
-    public void testIsVoiceBarring() {
-        when(mMockQnsTelephonyListener.isVoiceBarring()).thenReturn(true, false);
-        assertTrue(mCellularNetworkStatusTracker.isVoiceBarring());
-        assertFalse(mCellularNetworkStatusTracker.isVoiceBarring());
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/CellularQualityMonitorTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/CellularQualityMonitorTest.java
deleted file mode 100644
index e2fbb5b..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/CellularQualityMonitorTest.java
+++ /dev/null
@@ -1,888 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static android.telephony.CellInfo.UNAVAILABLE;
-
-import static com.android.telephony.qns.QualityMonitor.EVENT_CELLULAR_QNS_TELEPHONY_INFO_CHANGED;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.ArgumentMatchers.isA;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.net.NetworkCapabilities;
-import android.os.Message;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.CellSignalStrengthCdma;
-import android.telephony.CellSignalStrengthGsm;
-import android.telephony.CellSignalStrengthLte;
-import android.telephony.CellSignalStrengthNr;
-import android.telephony.CellSignalStrengthTdscdma;
-import android.telephony.CellSignalStrengthWcdma;
-import android.telephony.ServiceState;
-import android.telephony.SignalStrength;
-import android.telephony.SignalStrengthUpdateRequest;
-import android.telephony.SignalThresholdInfo;
-import android.telephony.TelephonyCallback;
-import android.telephony.TelephonyManager;
-
-import org.junit.After;
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mock;
-import org.mockito.Mockito;
-import org.mockito.MockitoAnnotations;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.Executor;
-import java.util.concurrent.TimeUnit;
-
-@RunWith(JUnit4.class)
-public final class CellularQualityMonitorTest extends QnsTest {
-    @Mock private QnsTelephonyListener.QnsTelephonyInfo mQnsTelephonyInfo;
-    private CellularQualityMonitor mCellularQualityMonitor;
-    int mApnType1 = NetworkCapabilities.NET_CAPABILITY_IMS;
-    int mApnType2 = NetworkCapabilities.NET_CAPABILITY_EIMS;
-    int mSlotIndex = 0;
-    Threshold[] mTh1;
-    Threshold[] mTh2;
-    Threshold[] mTh3 = new Threshold[1];
-    Threshold[] mOutputThs;
-    CountDownLatch mLatch;
-    ThresholdListener mThresholdListener;
-
-    private class ThresholdListener extends ThresholdCallback
-            implements ThresholdCallback.CellularThresholdListener {
-
-        ThresholdListener(Executor executor) {
-            this.init(executor);
-        }
-
-        @Override
-        public void onCellularThresholdChanged(Threshold[] thresholds) {
-            mOutputThs = thresholds;
-            mLatch.countDown();
-        }
-    }
-
-    Executor mExecutor = Runnable::run;
-
-    @Before
-    public void setUp() throws Exception {
-        MockitoAnnotations.initMocks(this);
-        super.setUp();
-        mCellularQualityMonitor =
-                new CellularQualityMonitor(sMockContext,
-                        mMockQnsConfigManager,
-                        mMockQnsTelephonyListener,
-                        mSlotIndex);
-        mLatch = new CountDownLatch(1);
-        mThresholdListener = new ThresholdListener(mExecutor);
-
-        mTh1 =
-                new Threshold[] {
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                            -117,
-                            QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR,
-                            -15,
-                            QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER)
-                };
-        mTh2 =
-                new Threshold[] {
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                            -110,
-                            QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                            QnsConstants.INVALID_ID)
-                };
-        mTh3 =
-                new Threshold[] {
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR,
-                            -18,
-                            QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                            QnsConstants.INVALID_ID)
-                };
-    }
-
-    @Test
-    public void testGetCurrentQuality() {
-        ArrayList<Byte> NrCqiReport = new ArrayList<>(Arrays.asList((byte) 3, (byte) 2, (byte) 1));
-        SignalStrength ss =
-                new SignalStrength(
-                        new CellSignalStrengthCdma(-93, -132, -89, -125, 5),
-                        new CellSignalStrengthGsm(-79, 2, 5),
-                        new CellSignalStrengthWcdma(-94, 4, -102, -5),
-                        new CellSignalStrengthTdscdma(-95, 2, -103), // not using Tdscdma
-                        new CellSignalStrengthLte(-85, -91, -6, -10, 1, 12, 1),
-                        new CellSignalStrengthNr(-91, -6, 3, 1, NrCqiReport, -80, -7, 4, 1));
-        when(mMockTelephonyManager.getSignalStrength()).thenReturn(ss);
-        int quality =
-                mCellularQualityMonitor.getCurrentQuality(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP);
-        Assert.assertEquals(-91, quality);
-
-        quality =
-                mCellularQualityMonitor.getCurrentQuality(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRQ);
-        Assert.assertEquals(-6, quality);
-
-        quality =
-                mCellularQualityMonitor.getCurrentQuality(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR);
-        Assert.assertEquals(-10, quality);
-
-        quality =
-                mCellularQualityMonitor.getCurrentQuality(
-                        AccessNetworkConstants.AccessNetworkType.GERAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI);
-        Assert.assertEquals(-79, quality);
-
-        quality =
-                mCellularQualityMonitor.getCurrentQuality(
-                        AccessNetworkConstants.AccessNetworkType.NGRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSRSRP);
-        Assert.assertEquals(-80, quality);
-
-        quality =
-                mCellularQualityMonitor.getCurrentQuality(
-                        AccessNetworkConstants.AccessNetworkType.NGRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSRSRQ);
-        Assert.assertEquals(-7, quality);
-
-        quality =
-                mCellularQualityMonitor.getCurrentQuality(
-                        AccessNetworkConstants.AccessNetworkType.NGRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSSINR);
-        Assert.assertEquals(4, quality);
-
-        quality =
-                mCellularQualityMonitor.getCurrentQuality(
-                        AccessNetworkConstants.AccessNetworkType.UTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_ECNO);
-        Assert.assertEquals(-5, quality);
-
-        quality =
-                mCellularQualityMonitor.getCurrentQuality(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_UNKNOWN);
-        Assert.assertEquals(SignalStrength.INVALID, quality);
-    }
-
-    @Test
-    public void testRegisterThresholdChange() {
-
-        mCellularQualityMonitor.registerThresholdChange(
-                mThresholdListener, mApnType1, mTh1, mSlotIndex);
-        Assert.assertEquals(1, mCellularQualityMonitor.mThresholdCallbackMap.size());
-        Assert.assertEquals(1, mCellularQualityMonitor.mThresholdsList.size());
-        Assert.assertEquals(2, mCellularQualityMonitor.getSignalThresholdInfo().size());
-
-        mCellularQualityMonitor.registerThresholdChange(
-                mThresholdListener, mApnType2, mTh2, mSlotIndex);
-        Assert.assertEquals(2, mCellularQualityMonitor.mThresholdCallbackMap.size());
-        Assert.assertEquals(2, mCellularQualityMonitor.mThresholdsList.size());
-
-        Assert.assertTrue(
-                mCellularQualityMonitor.mThresholdsList.containsKey(
-                        mCellularQualityMonitor.getKey(mApnType1, mSlotIndex)));
-        Assert.assertTrue(
-                mCellularQualityMonitor.mThresholdsList.containsKey(
-                        mCellularQualityMonitor.getKey(mApnType2, mSlotIndex)));
-
-        Assert.assertEquals(
-                2,
-                mCellularQualityMonitor
-                        .mThresholdsList
-                        .get(mCellularQualityMonitor.getKey(mApnType1, mSlotIndex))
-                        .size());
-        Assert.assertEquals(
-                1,
-                mCellularQualityMonitor
-                        .mThresholdsList
-                        .get(mCellularQualityMonitor.getKey(mApnType2, mSlotIndex))
-                        .size());
-
-        // multiple measurement type supported
-        Assert.assertEquals(2, mCellularQualityMonitor.getSignalThresholdInfo().size());
-    }
-
-    @Test
-    public void testUnregisterThresholdChange() {
-        testRegisterThresholdChange();
-        mCellularQualityMonitor.unregisterThresholdChange(mApnType1, mSlotIndex);
-        Assert.assertEquals(1, mCellularQualityMonitor.mThresholdCallbackMap.size());
-        Assert.assertEquals(1, mCellularQualityMonitor.mThresholdsList.size());
-        Assert.assertTrue(
-                mCellularQualityMonitor.mThresholdsList.containsKey(
-                        mCellularQualityMonitor.getKey(mApnType2, mSlotIndex)));
-        Assert.assertFalse(
-                mCellularQualityMonitor.mThresholdsList.containsKey(
-                        mCellularQualityMonitor.getKey(mApnType1, mSlotIndex)));
-        Assert.assertEquals(1, mCellularQualityMonitor.getSignalThresholdInfo().size());
-
-        mCellularQualityMonitor.unregisterThresholdChange(mApnType2, mSlotIndex);
-        Assert.assertEquals(0, mCellularQualityMonitor.mThresholdCallbackMap.size());
-        Assert.assertEquals(0, mCellularQualityMonitor.mThresholdsList.size());
-
-        Assert.assertFalse(
-                mCellularQualityMonitor.mThresholdsList.containsKey(
-                        mCellularQualityMonitor.getKey(mApnType1, mSlotIndex)));
-        Assert.assertFalse(
-                mCellularQualityMonitor.mThresholdsList.containsKey(
-                        mCellularQualityMonitor.getKey(mApnType2, mSlotIndex)));
-
-        Assert.assertEquals(0, mCellularQualityMonitor.getSignalThresholdInfo().size());
-    }
-
-    @Test
-    public void testUpdateThresholdsForApn() {
-        testRegisterThresholdChange();
-        mCellularQualityMonitor.updateThresholdsForNetCapability(mApnType2, mSlotIndex, mTh3);
-        Assert.assertEquals(2, mCellularQualityMonitor.mThresholdCallbackMap.size());
-        Assert.assertEquals(2, mCellularQualityMonitor.mThresholdsList.size());
-        Assert.assertTrue(
-                mCellularQualityMonitor.mThresholdsList.containsKey(
-                        mCellularQualityMonitor.getKey(mApnType1, mSlotIndex)));
-        Assert.assertTrue(
-                mCellularQualityMonitor.mThresholdsList.containsKey(
-                        mCellularQualityMonitor.getKey(mApnType2, mSlotIndex)));
-
-        Assert.assertEquals(
-                1,
-                mCellularQualityMonitor
-                        .mThresholdsList
-                        .get(mCellularQualityMonitor.getKey(mApnType2, mSlotIndex))
-                        .size());
-        Assert.assertEquals(2, mCellularQualityMonitor.getSignalThresholdInfo().size());
-    }
-
-    @Test
-    public void testGetSignalThresholdInfo() {
-        testRegisterThresholdChange();
-        List<SignalThresholdInfo> stInfoList = mCellularQualityMonitor.getSignalThresholdInfo();
-        Assert.assertEquals(2, stInfoList.size()); // multiple measurement type supported
-    }
-
-    @Test
-    public void testDiffApnDiffThresholdSameMeasurementType() {
-        int[] thresholds = new int[] {-110, -112, -99, -100, -70};
-        int apn1 = NetworkCapabilities.NET_CAPABILITY_MMS;
-        int apn2 = NetworkCapabilities.NET_CAPABILITY_IMS;
-        int apn3 = NetworkCapabilities.NET_CAPABILITY_XCAP;
-        Threshold[] t1 =
-                new Threshold[] {
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                            thresholds[0],
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER)
-                };
-        Threshold[] t2 =
-                new Threshold[] {
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                            thresholds[1],
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                            thresholds[2],
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                };
-        Threshold[] t3 =
-                new Threshold[] {
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                            thresholds[3],
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                            thresholds[4],
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                };
-        mCellularQualityMonitor.registerThresholdChange(mThresholdListener, apn1, t1, mSlotIndex);
-        List<SignalThresholdInfo> stInfo = mCellularQualityMonitor.getSignalThresholdInfo();
-        Assert.assertEquals(1, stInfo.size());
-        Assert.assertArrayEquals(new int[] {thresholds[0]}, stInfo.get(0).getThresholds());
-
-        mCellularQualityMonitor.registerThresholdChange(mThresholdListener, apn2, t2, mSlotIndex);
-        stInfo = mCellularQualityMonitor.getSignalThresholdInfo();
-        Assert.assertEquals(1, stInfo.size());
-        int[] th_array = new int[] {thresholds[0], thresholds[1], thresholds[2]};
-        Arrays.sort(th_array);
-        Assert.assertArrayEquals(th_array, stInfo.get(0).getThresholds());
-
-        mCellularQualityMonitor.registerThresholdChange(mThresholdListener, apn3, t3, mSlotIndex);
-        stInfo = mCellularQualityMonitor.getSignalThresholdInfo();
-        Assert.assertEquals(1, stInfo.size());
-        th_array = new int[] {thresholds[0], thresholds[1], thresholds[2], thresholds[3]};
-        Arrays.sort(th_array);
-        Assert.assertArrayEquals(th_array, stInfo.get(0).getThresholds());
-    }
-
-    @Test
-    public void testDiffApnSameThresholdSameMeasurementType() {
-        int[] thresholds = new int[] {-110, -100, -110, -100, -70};
-        int apn1 = NetworkCapabilities.NET_CAPABILITY_MMS;
-        int apn2 = NetworkCapabilities.NET_CAPABILITY_IMS;
-        int apn3 = NetworkCapabilities.NET_CAPABILITY_XCAP;
-        Threshold[] t1 =
-                new Threshold[] {
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                            thresholds[0],
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER)
-                };
-        Threshold[] t2 =
-                new Threshold[] {
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                            thresholds[1],
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                            thresholds[2],
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                };
-        Threshold[] t3 =
-                new Threshold[] {
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                            thresholds[3],
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                            thresholds[4],
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                };
-        mCellularQualityMonitor.registerThresholdChange(mThresholdListener, apn1, t1, mSlotIndex);
-        List<SignalThresholdInfo> stInfo = mCellularQualityMonitor.getSignalThresholdInfo();
-        Assert.assertEquals(1, stInfo.size());
-        Assert.assertArrayEquals(new int[] {thresholds[0]}, stInfo.get(0).getThresholds());
-
-        mCellularQualityMonitor.registerThresholdChange(mThresholdListener, apn2, t2, mSlotIndex);
-        stInfo = mCellularQualityMonitor.getSignalThresholdInfo();
-        Assert.assertEquals(1, stInfo.size());
-        int[] th_array = new int[] {thresholds[0], thresholds[1]};
-        Arrays.sort(th_array);
-        Assert.assertArrayEquals(th_array, stInfo.get(0).getThresholds());
-
-        mCellularQualityMonitor.registerThresholdChange(mThresholdListener, apn3, t3, mSlotIndex);
-        stInfo = mCellularQualityMonitor.getSignalThresholdInfo();
-        Assert.assertEquals(1, stInfo.size());
-        th_array = new int[] {thresholds[0], thresholds[1], thresholds[4]};
-        Arrays.sort(th_array);
-        Assert.assertArrayEquals(th_array, stInfo.get(0).getThresholds());
-    }
-
-    @Test
-    public void testSameApnDiffThresholdsDiffMeasurementType() {
-        int[] thresholdsRsrp = new int[] {-110, -100};
-        int[] thresholdsRssnr = new int[] {-11, -10};
-        int[] thresholdsRsrq = new int[] {-20};
-        int apn1 = NetworkCapabilities.NET_CAPABILITY_IMS;
-        Threshold[] t =
-                new Threshold[] {
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                            thresholdsRsrp[0],
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                            thresholdsRsrp[1],
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR,
-                            thresholdsRssnr[0],
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR,
-                            thresholdsRssnr[1],
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRQ,
-                            thresholdsRsrq[0],
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER)
-                };
-        mCellularQualityMonitor.registerThresholdChange(mThresholdListener, apn1, t, mSlotIndex);
-        List<SignalThresholdInfo> stInfoList = mCellularQualityMonitor.getSignalThresholdInfo();
-        Assert.assertEquals(3, stInfoList.size());
-        for (SignalThresholdInfo stInfo : stInfoList) {
-            if (stInfo.getSignalMeasurementType()
-                    == SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR) {
-                Assert.assertArrayEquals(thresholdsRssnr, stInfo.getThresholds());
-            } else if (stInfo.getSignalMeasurementType()
-                    == SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP) {
-                Assert.assertArrayEquals(thresholdsRsrp, stInfo.getThresholds());
-            } else if (stInfo.getSignalMeasurementType()
-                    == SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRQ) {
-                Assert.assertArrayEquals(thresholdsRsrq, stInfo.getThresholds());
-            } else {
-                Assert.fail();
-            }
-        }
-    }
-
-    @Test
-    public void testNullThresholds() {
-        mCellularQualityMonitor.registerThresholdChange(
-                mThresholdListener, mApnType1, null, mSlotIndex);
-        Assert.assertEquals(1, mCellularQualityMonitor.mThresholdCallbackMap.size());
-        Assert.assertEquals(0, mCellularQualityMonitor.mThresholdsList.size());
-    }
-
-    @Test
-    public void testBackhaulTimerUpdate() {
-        int waitTime = 4000;
-        mTh1[0].setWaitTime(waitTime);
-        mCellularQualityMonitor.registerThresholdChange(
-                mThresholdListener, mApnType1, new Threshold[] {mTh1[0]}, mSlotIndex);
-        List<SignalThresholdInfo> signalThresholdInfoList =
-                mCellularQualityMonitor.getSignalThresholdInfo();
-        assertNotNull(signalThresholdInfoList);
-        SignalThresholdInfo stInfo = signalThresholdInfoList.get(0);
-        Assert.assertEquals(waitTime, stInfo.getHysteresisMs());
-
-        mCellularQualityMonitor.updateThresholdsForNetCapability(mApnType1, mSlotIndex, mTh2);
-        signalThresholdInfoList = mCellularQualityMonitor.getSignalThresholdInfo();
-        assertNotNull(signalThresholdInfoList);
-        stInfo = signalThresholdInfoList.get(0);
-        Assert.assertEquals(0, stInfo.getHysteresisMs());
-    }
-
-    @Test
-    public void testOnSignalStrengthsChanged_Matching() throws InterruptedException {
-        mTh1 =
-                new Threshold[] {
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                            -117,
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER)
-                };
-        mCellularQualityMonitor.registerThresholdChange(
-                mThresholdListener, mApnType1, mTh1, mSlotIndex);
-        ArgumentCaptor<TelephonyCallback> capture =
-                ArgumentCaptor.forClass(TelephonyCallback.class);
-        verify(mMockTelephonyManager)
-                .registerTelephonyCallback(isA(Executor.class), capture.capture());
-        TelephonyCallback.SignalStrengthsListener callback =
-                (TelephonyCallback.SignalStrengthsListener) capture.getValue();
-        assertNotNull(callback);
-
-        ArrayList<Byte> NrCqiReport = new ArrayList<>(Arrays.asList((byte) 3, (byte) 2, (byte) 1));
-        SignalStrength ss =
-                new SignalStrength(
-                        new CellSignalStrengthCdma(-93, -132, -89, -125, 5),
-                        new CellSignalStrengthGsm(-79, 2, 5),
-                        new CellSignalStrengthWcdma(-94, 4, -102, -5),
-                        new CellSignalStrengthTdscdma(-95, 2, -103), // not using Tdscdma
-                        new CellSignalStrengthLte(-85, -91, -6, -10, 1, 12, 1),
-                        new CellSignalStrengthNr(-91, -6, 3, 1, NrCqiReport, -80, -7, 4, 1));
-
-        mLatch = new CountDownLatch(1);
-        mOutputThs = null;
-        callback.onSignalStrengthsChanged(ss);
-        verifyReportedThreshold(-91);
-
-        mTh1 =
-                new Threshold[] {
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.UTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSCP,
-                            -90,
-                            QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER)
-                };
-        mCellularQualityMonitor.updateThresholdsForNetCapability(mApnType1, mSlotIndex, mTh1);
-
-        mLatch = new CountDownLatch(1);
-        mOutputThs = null;
-        callback.onSignalStrengthsChanged(ss);
-        verifyReportedThreshold(-102);
-
-        mTh1 =
-                new Threshold[] {
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.GERAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                            -70,
-                            QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER)
-                };
-        mCellularQualityMonitor.updateThresholdsForNetCapability(mApnType1, mSlotIndex, mTh1);
-
-        mLatch = new CountDownLatch(1);
-        mOutputThs = null;
-        callback.onSignalStrengthsChanged(ss);
-        verifyReportedThreshold(-79);
-
-        mTh1 =
-                new Threshold[] {
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.NGRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSRSRP,
-                            -90,
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER)
-                };
-        mCellularQualityMonitor.updateThresholdsForNetCapability(mApnType1, mSlotIndex, mTh1);
-
-        mLatch = new CountDownLatch(1);
-        mOutputThs = null;
-        callback.onSignalStrengthsChanged(ss);
-        verifyReportedThreshold(-80);
-    }
-
-    private void verifyReportedThreshold(int expected) throws InterruptedException {
-        assertTrue(mLatch.await(100, TimeUnit.MILLISECONDS));
-        assertTrue(mOutputThs.length > 0);
-        assertEquals(expected, mOutputThs[0].getThreshold());
-    }
-
-    @Test
-    public void testOnSignalStrengthsChanged_NotMatching() throws InterruptedException {
-        mTh1 =
-                new Threshold[] {
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                            -90,
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER)
-                };
-        mCellularQualityMonitor.registerThresholdChange(
-                mThresholdListener, mApnType1, mTh1, mSlotIndex);
-        ArgumentCaptor<TelephonyCallback> capture =
-                ArgumentCaptor.forClass(TelephonyCallback.class);
-        verify(mMockTelephonyManager)
-                .registerTelephonyCallback(isA(Executor.class), capture.capture());
-        TelephonyCallback.SignalStrengthsListener callback =
-                (TelephonyCallback.SignalStrengthsListener) capture.getValue();
-        assertNotNull(callback);
-
-        ArrayList<Byte> NrCqiReport = new ArrayList<>(Arrays.asList((byte) 3, (byte) 2, (byte) 1));
-        SignalStrength ss =
-                new SignalStrength(
-                        new CellSignalStrengthCdma(-93, -132, -89, -125, 5),
-                        new CellSignalStrengthGsm(-79, 2, 5),
-                        new CellSignalStrengthWcdma(-94, 4, -102, -5),
-                        new CellSignalStrengthTdscdma(-95, 2, -103), // not using Tdscdma
-                        new CellSignalStrengthLte(-85, -91, -6, -10, 1, 12, 1),
-                        new CellSignalStrengthNr(-91, -6, 3, 1, NrCqiReport, -80, -7, 4, 1));
-
-        mLatch = new CountDownLatch(1);
-        mOutputThs = null;
-        callback.onSignalStrengthsChanged(ss);
-        assertFalse(mLatch.await(100, TimeUnit.MILLISECONDS));
-        assertNull(mOutputThs);
-
-        mTh1 =
-                new Threshold[] {
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.UTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSCP,
-                            -105,
-                            QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER)
-                };
-        mCellularQualityMonitor.updateThresholdsForNetCapability(mApnType1, mSlotIndex, mTh1);
-
-        mLatch = new CountDownLatch(1);
-        mOutputThs = null;
-        callback.onSignalStrengthsChanged(ss);
-        assertFalse(mLatch.await(100, TimeUnit.MILLISECONDS));
-        assertNull(mOutputThs);
-
-        mTh1 =
-                new Threshold[] {
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.GERAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                            -70,
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER)
-                };
-        mCellularQualityMonitor.updateThresholdsForNetCapability(mApnType1, mSlotIndex, mTh1);
-
-        mLatch = new CountDownLatch(1);
-        mOutputThs = null;
-        callback.onSignalStrengthsChanged(ss);
-        assertFalse(mLatch.await(100, TimeUnit.MILLISECONDS));
-        assertNull(mOutputThs);
-
-        mTh1 =
-                new Threshold[] {
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.NGRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSRSRP,
-                            -81,
-                            QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER)
-                };
-        mCellularQualityMonitor.updateThresholdsForNetCapability(mApnType1, mSlotIndex, mTh1);
-
-        mLatch = new CountDownLatch(1);
-        mOutputThs = null;
-        callback.onSignalStrengthsChanged(ss);
-        assertFalse(mLatch.await(100, TimeUnit.MILLISECONDS));
-        assertNull(mOutputThs);
-    }
-
-    @Test
-    public void testOnQnsTelephonyInfoChanged() {
-        testRegisterThresholdChange();
-        when(mQnsTelephonyInfo.getDataRegState()).thenReturn(ServiceState.STATE_IN_SERVICE);
-        when(mQnsTelephonyInfo.getDataNetworkType()).thenReturn(TelephonyManager.NETWORK_TYPE_LTE);
-        when(mQnsTelephonyInfo.isCellularAvailable()).thenReturn(true, false);
-        when(mQnsTelephonyInfo.getDataRegState()).thenReturn(ServiceState.STATE_IN_SERVICE);
-        Message.obtain(
-                        mCellularQualityMonitor.mHandler,
-                        EVENT_CELLULAR_QNS_TELEPHONY_INFO_CHANGED,
-                        new QnsAsyncResult(null, mQnsTelephonyInfo, null))
-                .sendToTarget();
-        verify(mMockTelephonyManager)
-                .clearSignalStrengthUpdateRequest(isA(SignalStrengthUpdateRequest.class));
-        Mockito.clearInvocations(mMockTelephonyManager);
-
-        Message.obtain(
-                        mCellularQualityMonitor.mHandler,
-                        EVENT_CELLULAR_QNS_TELEPHONY_INFO_CHANGED,
-                        new QnsAsyncResult(null, mQnsTelephonyInfo, null))
-                .sendToTarget();
-        verify(mMockTelephonyManager, never())
-                .clearSignalStrengthUpdateRequest(isA(SignalStrengthUpdateRequest.class));
-    }
-
-    @Test
-    public void testNrThresholdsValidity() throws InterruptedException {
-        mTh1 =
-                new Threshold[] {
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.NGRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSRSRP,
-                            -117,
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER)
-                };
-        mCellularQualityMonitor.registerThresholdChange(
-                mThresholdListener, mApnType1, mTh1, mSlotIndex);
-        ArgumentCaptor<TelephonyCallback> capture =
-                ArgumentCaptor.forClass(TelephonyCallback.class);
-        verify(mMockTelephonyManager)
-                .registerTelephonyCallback(isA(Executor.class), capture.capture());
-        TelephonyCallback.SignalStrengthsListener callback =
-                (TelephonyCallback.SignalStrengthsListener) capture.getValue();
-        assertNotNull(callback);
-
-        ArrayList<Byte> NrCqiReport = new ArrayList<>(Arrays.asList((byte) 3, (byte) 2, (byte) 1));
-
-        // Valid thresholds - All NR signal params are valid.
-        SignalStrength ss =
-                new SignalStrength(
-                        new CellSignalStrengthCdma(
-                                UNAVAILABLE, UNAVAILABLE, UNAVAILABLE, UNAVAILABLE, UNAVAILABLE),
-                        new CellSignalStrengthGsm(UNAVAILABLE, UNAVAILABLE, UNAVAILABLE),
-                        new CellSignalStrengthWcdma(
-                                UNAVAILABLE, UNAVAILABLE, UNAVAILABLE, UNAVAILABLE),
-                        new CellSignalStrengthTdscdma(
-                                UNAVAILABLE, UNAVAILABLE, UNAVAILABLE), // not using Tdscdma
-                        new CellSignalStrengthLte(
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE),
-                        new CellSignalStrengthNr(-91, -6, 3, 1, NrCqiReport, -80, -7, 4, 1));
-
-        mLatch = new CountDownLatch(1);
-        mOutputThs = null;
-        callback.onSignalStrengthsChanged(ss);
-        // signal strength is valid, so CQM should notify SignalStrength.
-        assertTrue(mLatch.await(200, TimeUnit.MILLISECONDS));
-
-        // Valid thresholds - Only SSRSRP, SSRSRQ and SSSINR for NR are valid.
-        ss =
-                new SignalStrength(
-                        new CellSignalStrengthCdma(
-                                UNAVAILABLE, UNAVAILABLE, UNAVAILABLE, UNAVAILABLE, UNAVAILABLE),
-                        new CellSignalStrengthGsm(UNAVAILABLE, UNAVAILABLE, UNAVAILABLE),
-                        new CellSignalStrengthWcdma(
-                                UNAVAILABLE, UNAVAILABLE, UNAVAILABLE, UNAVAILABLE),
-                        new CellSignalStrengthTdscdma(
-                                UNAVAILABLE, UNAVAILABLE, UNAVAILABLE), // not using Tdscdma
-                        new CellSignalStrengthLte(
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE),
-                        new CellSignalStrengthNr(
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                NrCqiReport,
-                                -80,
-                                -7,
-                                4,
-                                1));
-
-        mLatch = new CountDownLatch(1);
-        mOutputThs = null;
-        callback.onSignalStrengthsChanged(ss);
-        // signal strength is valid, so CQM should notify SignalStrength.
-        assertTrue(mLatch.await(200, TimeUnit.MILLISECONDS));
-
-        // Invalid thresholds - All NR signal params UNAVAILABLE
-        ss =
-                new SignalStrength(
-                        new CellSignalStrengthCdma(
-                                UNAVAILABLE, UNAVAILABLE, UNAVAILABLE, UNAVAILABLE, UNAVAILABLE),
-                        new CellSignalStrengthGsm(UNAVAILABLE, UNAVAILABLE, UNAVAILABLE),
-                        new CellSignalStrengthWcdma(
-                                UNAVAILABLE, UNAVAILABLE, UNAVAILABLE, UNAVAILABLE),
-                        new CellSignalStrengthTdscdma(
-                                UNAVAILABLE, UNAVAILABLE, UNAVAILABLE), // not using Tdscdma
-                        new CellSignalStrengthLte(
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE),
-                        new CellSignalStrengthNr(
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                NrCqiReport,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                1));
-
-        mLatch = new CountDownLatch(1);
-        mOutputThs = null;
-        callback.onSignalStrengthsChanged(ss);
-        // signal strength is not valid, so CQM should not notify SignalStrength.
-        assertFalse(mLatch.await(200, TimeUnit.MILLISECONDS));
-
-        // Invalid thresholds - Only CSI signal params are valid. SSRSRP, SSRSRQ and SSSINR for NR
-        // are invalid.
-        ss =
-                new SignalStrength(
-                        new CellSignalStrengthCdma(
-                                UNAVAILABLE, UNAVAILABLE, UNAVAILABLE, UNAVAILABLE, UNAVAILABLE),
-                        new CellSignalStrengthGsm(UNAVAILABLE, UNAVAILABLE, UNAVAILABLE),
-                        new CellSignalStrengthWcdma(
-                                UNAVAILABLE, UNAVAILABLE, UNAVAILABLE, UNAVAILABLE),
-                        new CellSignalStrengthTdscdma(
-                                UNAVAILABLE, UNAVAILABLE, UNAVAILABLE), // not using Tdscdma
-                        new CellSignalStrengthLte(
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE),
-                        new CellSignalStrengthNr(
-                                -91,
-                                -6,
-                                3,
-                                1,
-                                NrCqiReport,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                UNAVAILABLE,
-                                1));
-
-        mLatch = new CountDownLatch(1);
-        mOutputThs = null;
-        callback.onSignalStrengthsChanged(ss);
-        // signal strength is not valid, so CQM should not notify SignalStrength.
-        assertFalse(mLatch.await(200, TimeUnit.MILLISECONDS));
-    }
-
-    @After
-    public void tearDown() {
-        if (mCellularQualityMonitor != null) {
-            mCellularQualityMonitor.close();
-        }
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/ConfigXmlTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/ConfigXmlTest.java
deleted file mode 100644
index 0a6cdd6..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/ConfigXmlTest.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static org.mockito.Mockito.spy;
-
-import android.content.Context;
-import android.telephony.Rlog;
-
-import androidx.test.core.app.ApplicationProvider;
-
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.w3c.dom.Document;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
-
-import java.io.InputStream;
-import java.io.StringWriter;
-
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.transform.OutputKeys;
-import javax.xml.transform.Transformer;
-import javax.xml.transform.TransformerException;
-import javax.xml.transform.TransformerFactory;
-import javax.xml.transform.dom.DOMSource;
-import javax.xml.transform.stream.StreamResult;
-import javax.xml.xpath.XPath;
-import javax.xml.xpath.XPathConstants;
-import javax.xml.xpath.XPathExpressionException;
-import javax.xml.xpath.XPathFactory;
-
-@RunWith(JUnit4.class)
-public class ConfigXmlTest {
-
-    @Mock private Context mContext;
-
-    @Before
-    public void setup() {
-        MockitoAnnotations.initMocks(this);
-        mContext = spy(ApplicationProvider.getApplicationContext());
-    }
-
-    protected static void slog(String log) {
-        Rlog.d(ConfigXmlTest.class.getSimpleName(), log);
-    }
-
-    @Test
-    public void testNumValueInConfigArray() {
-        try {
-            String[] configName = mContext.getAssets().list("");
-            if (configName == null) {
-                return;
-            }
-
-            for (String fileName : configName) {
-                if (fileName.startsWith("carrier_config_carrierid_")) {
-                    InputStream input = mContext.getAssets().open(fileName);
-                    DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance();
-                    builderFactory.setNamespaceAware(true);
-                    DocumentBuilder builder = builderFactory.newDocumentBuilder();
-                    Document doc = builder.parse(input);
-
-                    String queryIntArray = "//int-array[@num!=count(./item)]";
-                    String queryStringArray = "//string-array[@num!=count(./item)]";
-                    if (!verifyWithXmlQuery(doc, queryIntArray)
-                            || !verifyWithXmlQuery(doc, queryStringArray)) {
-                        Assert.fail("ConfigXmlTest has failed at " + fileName);
-                    }
-                }
-            }
-        } catch (Exception e) {
-            Assert.fail("ConfigXmlTest has an exception : " + e);
-        }
-    }
-
-    private boolean verifyWithXmlQuery(Document doc, String queryIntArray)
-            throws XPathExpressionException, TransformerException {
-        XPath xpath = XPathFactory.newInstance().newXPath();
-        NodeList nodeList = (NodeList) xpath.evaluate(queryIntArray, doc, XPathConstants.NODESET);
-        if (nodeList == null || nodeList.getLength() <= 0) {
-            return true;
-        }
-        for (int i = 0; i < nodeList.getLength(); i++) {
-            Node node = nodeList.item(i);
-            StringWriter buf = new StringWriter();
-            Transformer xform = TransformerFactory.newInstance().newTransformer();
-            xform.setOutputProperty(OutputKeys.INDENT, "yes");
-            xform.transform(new DOMSource(node), new StreamResult(buf));
-            slog("wrong num value : " + buf);
-        }
-        return false;
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/DataConnectionStatusTrackerTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/DataConnectionStatusTrackerTest.java
deleted file mode 100644
index 63b3131..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/DataConnectionStatusTrackerTest.java
+++ /dev/null
@@ -1,840 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static android.telephony.AccessNetworkConstants.TRANSPORT_TYPE_INVALID;
-import static android.telephony.AccessNetworkConstants.TRANSPORT_TYPE_WLAN;
-import static android.telephony.AccessNetworkConstants.TRANSPORT_TYPE_WWAN;
-import static android.telephony.DataFailCause.IWLAN_NO_APN_SUBSCRIPTION;
-import static android.telephony.DataFailCause.MISSING_UNKNOWN_APN;
-
-import static com.android.telephony.qns.DataConnectionStatusTracker.EVENT_DATA_CONNECTION_CONNECTED;
-import static com.android.telephony.qns.DataConnectionStatusTracker.EVENT_DATA_CONNECTION_DISCONNECTED;
-import static com.android.telephony.qns.DataConnectionStatusTracker.EVENT_DATA_CONNECTION_FAILED;
-import static com.android.telephony.qns.DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_FAILED;
-import static com.android.telephony.qns.DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_STARTED;
-import static com.android.telephony.qns.DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_SUCCESS;
-import static com.android.telephony.qns.DataConnectionStatusTracker.EVENT_DATA_CONNECTION_STARTED;
-import static com.android.telephony.qns.DataConnectionStatusTracker.STATE_CONNECTED;
-import static com.android.telephony.qns.DataConnectionStatusTracker.STATE_CONNECTING;
-import static com.android.telephony.qns.DataConnectionStatusTracker.STATE_HANDOVER;
-import static com.android.telephony.qns.DataConnectionStatusTracker.STATE_INACTIVE;
-
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.when;
-
-import android.content.Context;
-import android.content.res.Resources;
-import android.net.ConnectivityManager;
-import android.net.NetworkCapabilities;
-import android.net.wifi.WifiManager;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Looper;
-import android.os.Message;
-import android.telephony.CarrierConfigManager;
-import android.telephony.PreciseDataConnectionState;
-import android.telephony.SubscriptionManager;
-import android.telephony.TelephonyManager;
-import android.telephony.data.ApnSetting;
-
-import androidx.test.core.app.ApplicationProvider;
-
-import com.android.telephony.qns.DataConnectionStatusTracker.DataConnectionChangedInfo;
-
-import org.junit.After;
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-@RunWith(JUnit4.class)
-public class DataConnectionStatusTrackerTest extends QnsTest {
-    @Mock private Context mContext;
-    @Mock protected TelephonyManager mMockTelephonyManager;
-    @Mock protected CarrierConfigManager mMockCarrierConfigManager;
-    @Mock protected ConnectivityManager mMockConnectivityManager;
-    @Mock protected SubscriptionManager mMockSubscriptionManager;
-    @Mock protected WifiManager mMockWifiManager;
-    @Mock protected Resources mResources;
-    protected DataConnectionStatusTracker mDataConnectionStatusTracker;
-    private static final int EVENT_DATA_CONNECTION_STATE_CHANGED = 1;
-    DataConnectionChangedInfo mDcStatus;
-
-    private boolean mReady = false;
-    private Object mLock = new Object();
-
-    HandlerThread mHandlerThread =
-            new HandlerThread("") {
-                @Override
-                protected void onLooperPrepared() {
-                    super.onLooperPrepared();
-                    mDataConnectionStatusTracker =
-                            new DataConnectionStatusTracker(
-                                    mMockQnsTelephonyListener,
-                                    this.getLooper(),
-                                    0,
-                                    NetworkCapabilities.NET_CAPABILITY_IMS);
-                    setReady(true);
-                }
-            };
-
-    Handler mHandler =
-            new Handler(Looper.getMainLooper()) {
-                public void handleMessage(Message message) {
-                    QnsAsyncResult ar;
-                    switch (message.what) {
-                        case EVENT_DATA_CONNECTION_STATE_CHANGED:
-                            ar = (QnsAsyncResult) message.obj;
-                            mDcStatus = (DataConnectionChangedInfo) ar.mResult;
-                            setReady(true);
-                            break;
-                    }
-                }
-            };
-
-    protected void waitUntilReady() {
-        synchronized (mLock) {
-            if (!mReady) {
-                try {
-                    mLock.wait(10000);
-                } catch (InterruptedException e) {
-                }
-                if (!mReady) {
-                    Assert.fail("Test is not ready!!");
-                }
-            }
-        }
-    }
-
-    protected void setReady(boolean ready) {
-        synchronized (mLock) {
-            mReady = ready;
-            mLock.notifyAll();
-        }
-    }
-
-    @Before
-    public void setup() {
-        MockitoAnnotations.initMocks(this);
-        mContext = spy(ApplicationProvider.getApplicationContext());
-        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mMockTelephonyManager);
-        when(mMockTelephonyManager.createForSubscriptionId(anyInt()))
-                .thenReturn(mMockTelephonyManager);
-        when(mContext.getSystemService(SubscriptionManager.class))
-                .thenReturn(mMockSubscriptionManager);
-        when(mContext.getSystemService(CarrierConfigManager.class))
-                .thenReturn(mMockCarrierConfigManager);
-        when(mContext.getSystemService(ConnectivityManager.class))
-                .thenReturn(mMockConnectivityManager);
-        when(mContext.getSystemService(WifiManager.class)).thenReturn(mMockWifiManager);
-        when(mContext.getResources()).thenReturn(mResources);
-        mHandlerThread.start();
-        waitUntilReady();
-        mDataConnectionStatusTracker.registerDataConnectionStatusChanged(
-                mHandler, EVENT_DATA_CONNECTION_STATE_CHANGED);
-    }
-
-    @Test
-    public void testOnCellular() {
-        mReady = false;
-        validateNotConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WWAN,
-                TelephonyManager.DATA_CONNECTING,
-                TelephonyManager.NETWORK_TYPE_LTE);
-
-        validateConnectingStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTING, TRANSPORT_TYPE_WWAN, EVENT_DATA_CONNECTION_STARTED);
-        mReady = false;
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WWAN,
-                TelephonyManager.DATA_CONNECTED,
-                TelephonyManager.NETWORK_TYPE_LTE);
-
-        validateConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WWAN);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTED, TRANSPORT_TYPE_WWAN, EVENT_DATA_CONNECTION_CONNECTED);
-
-        mReady = false;
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WWAN,
-                TelephonyManager.DATA_DISCONNECTED,
-                TelephonyManager.NETWORK_TYPE_LTE);
-
-        validateNotConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_INACTIVE, TRANSPORT_TYPE_INVALID, EVENT_DATA_CONNECTION_DISCONNECTED);
-    }
-
-    @Test
-    public void testCellularConnectingToDisconnect() {
-        mReady = false;
-        validateNotConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WWAN,
-                TelephonyManager.DATA_CONNECTING,
-                TelephonyManager.NETWORK_TYPE_LTE);
-
-        validateConnectingStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTING, TRANSPORT_TYPE_WWAN, EVENT_DATA_CONNECTION_STARTED);
-        mReady = false;
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WWAN,
-                TelephonyManager.DATA_DISCONNECTED,
-                TelephonyManager.NETWORK_TYPE_LTE);
-
-        validateNotConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_INACTIVE, TRANSPORT_TYPE_WWAN, EVENT_DATA_CONNECTION_FAILED);
-    }
-
-    @Test
-    public void testOnIwlan() {
-        mReady = false;
-        validateNotConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WLAN,
-                TelephonyManager.DATA_CONNECTING,
-                TelephonyManager.NETWORK_TYPE_IWLAN);
-
-        validateConnectingStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTING, TRANSPORT_TYPE_WLAN, EVENT_DATA_CONNECTION_STARTED);
-
-        mReady = false;
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WLAN,
-                TelephonyManager.DATA_CONNECTED,
-                TelephonyManager.NETWORK_TYPE_IWLAN);
-
-        validateConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WLAN);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTED, TRANSPORT_TYPE_WLAN, EVENT_DATA_CONNECTION_CONNECTED);
-
-        mReady = false;
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WLAN,
-                TelephonyManager.DATA_DISCONNECTED,
-                TelephonyManager.NETWORK_TYPE_IWLAN);
-
-        validateNotConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_INACTIVE, TRANSPORT_TYPE_INVALID, EVENT_DATA_CONNECTION_DISCONNECTED);
-    }
-
-    @Test
-    public void testIwlanConnectingToDisconnect() {
-        mReady = false;
-        validateNotConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WLAN,
-                TelephonyManager.DATA_CONNECTING,
-                TelephonyManager.NETWORK_TYPE_IWLAN);
-
-        validateConnectingStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTING, TRANSPORT_TYPE_WLAN, EVENT_DATA_CONNECTION_STARTED);
-
-        mReady = false;
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WLAN,
-                TelephonyManager.DATA_DISCONNECTED,
-                TelephonyManager.NETWORK_TYPE_IWLAN);
-
-        validateNotConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_INACTIVE, TRANSPORT_TYPE_WLAN, EVENT_DATA_CONNECTION_FAILED);
-    }
-
-    @Test
-    public void testOnCellularHandover() {
-        mReady = false;
-        validateNotConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WWAN,
-                TelephonyManager.DATA_CONNECTING,
-                TelephonyManager.NETWORK_TYPE_LTE);
-
-        validateConnectingStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTING, TRANSPORT_TYPE_WWAN, EVENT_DATA_CONNECTION_STARTED);
-
-        mReady = false;
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WWAN,
-                TelephonyManager.DATA_CONNECTED,
-                TelephonyManager.NETWORK_TYPE_LTE);
-
-        validateConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WWAN);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTED, TRANSPORT_TYPE_WWAN, EVENT_DATA_CONNECTION_CONNECTED);
-
-        mReady = false;
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WWAN,
-                TelephonyManager.DATA_HANDOVER_IN_PROGRESS,
-                TelephonyManager.NETWORK_TYPE_LTE);
-
-        validateHandoverStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WWAN);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_HANDOVER, TRANSPORT_TYPE_WWAN, EVENT_DATA_CONNECTION_HANDOVER_STARTED);
-
-        mReady = false;
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WLAN,
-                TelephonyManager.DATA_CONNECTED,
-                TelephonyManager.NETWORK_TYPE_IWLAN);
-
-        validateConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WLAN);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTED, TRANSPORT_TYPE_WLAN, EVENT_DATA_CONNECTION_HANDOVER_SUCCESS);
-    }
-
-    @Test
-    public void testHandoverOnNonSrcTransportType() {
-        mReady = false;
-        validateNotConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WWAN,
-                TelephonyManager.DATA_CONNECTING,
-                TelephonyManager.NETWORK_TYPE_LTE);
-
-        validateConnectingStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTING, TRANSPORT_TYPE_WWAN, EVENT_DATA_CONNECTION_STARTED);
-
-        mReady = false;
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WWAN,
-                TelephonyManager.DATA_CONNECTED,
-                TelephonyManager.NETWORK_TYPE_LTE);
-
-        validateConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WWAN);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTED, TRANSPORT_TYPE_WWAN, EVENT_DATA_CONNECTION_CONNECTED);
-
-        mReady = false;
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WLAN,
-                TelephonyManager.DATA_HANDOVER_IN_PROGRESS,
-                TelephonyManager.NETWORK_TYPE_IWLAN);
-
-        Assert.assertFalse(mDataConnectionStatusTracker.isHandoverState());
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WWAN);
-    }
-
-    @Test
-    public void testOnCellularHandoverSuspended() {
-        mReady = false;
-        validateNotConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WWAN,
-                TelephonyManager.DATA_CONNECTING,
-                TelephonyManager.NETWORK_TYPE_LTE);
-
-        validateConnectingStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTING, TRANSPORT_TYPE_WWAN, EVENT_DATA_CONNECTION_STARTED);
-
-        mReady = false;
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WWAN,
-                TelephonyManager.DATA_CONNECTED,
-                TelephonyManager.NETWORK_TYPE_LTE);
-
-        validateConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WWAN);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTED, TRANSPORT_TYPE_WWAN, EVENT_DATA_CONNECTION_CONNECTED);
-
-        mReady = false;
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WWAN,
-                TelephonyManager.DATA_HANDOVER_IN_PROGRESS,
-                TelephonyManager.NETWORK_TYPE_LTE);
-
-        validateHandoverStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WWAN);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_HANDOVER, TRANSPORT_TYPE_WWAN, EVENT_DATA_CONNECTION_HANDOVER_STARTED);
-
-        mReady = false;
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WLAN,
-                TelephonyManager.DATA_SUSPENDED,
-                TelephonyManager.NETWORK_TYPE_IWLAN);
-
-        validateConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WLAN);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTED, TRANSPORT_TYPE_WLAN, EVENT_DATA_CONNECTION_HANDOVER_SUCCESS);
-    }
-
-    @Test
-    public void testOnCellularHandoverFail() {
-        mReady = false;
-        validateNotConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WWAN,
-                TelephonyManager.DATA_CONNECTING,
-                TelephonyManager.NETWORK_TYPE_LTE);
-
-        validateConnectingStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTING, TRANSPORT_TYPE_WWAN, EVENT_DATA_CONNECTION_STARTED);
-
-        mReady = false;
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WWAN,
-                TelephonyManager.DATA_CONNECTED,
-                TelephonyManager.NETWORK_TYPE_LTE);
-
-        validateConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WWAN);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTED, TRANSPORT_TYPE_WWAN, EVENT_DATA_CONNECTION_CONNECTED);
-
-        mReady = false;
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WWAN,
-                TelephonyManager.DATA_HANDOVER_IN_PROGRESS,
-                TelephonyManager.NETWORK_TYPE_LTE);
-
-        validateHandoverStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WWAN);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_HANDOVER, TRANSPORT_TYPE_WWAN, EVENT_DATA_CONNECTION_HANDOVER_STARTED);
-
-        mReady = false;
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WWAN,
-                TelephonyManager.DATA_CONNECTED,
-                TelephonyManager.NETWORK_TYPE_LTE);
-
-        validateConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WWAN);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTED, TRANSPORT_TYPE_WWAN, EVENT_DATA_CONNECTION_HANDOVER_FAILED);
-    }
-
-    @Test
-    public void testOnCellularHandoverFailWithCause() {
-
-        validateNotConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WWAN,
-                TelephonyManager.DATA_CONNECTING,
-                TelephonyManager.NETWORK_TYPE_LTE);
-
-        validateConnectingStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WWAN,
-                TelephonyManager.DATA_CONNECTED,
-                TelephonyManager.NETWORK_TYPE_LTE);
-
-        validateConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WWAN);
-
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WWAN,
-                TelephonyManager.DATA_HANDOVER_IN_PROGRESS,
-                TelephonyManager.NETWORK_TYPE_LTE);
-
-        validateHandoverStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WWAN);
-
-        loadPrecisionDataConnectionStateWithFailCause(
-                TRANSPORT_TYPE_WWAN,
-                IWLAN_NO_APN_SUBSCRIPTION,
-                TelephonyManager.DATA_CONNECTED,
-                TelephonyManager.NETWORK_TYPE_LTE);
-
-        validateConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WWAN);
-        validateHandoverFailCause(IWLAN_NO_APN_SUBSCRIPTION);
-    }
-
-    @Test
-    public void testOnIwlanWithApnSetting() {
-        mReady = false;
-        validateNotConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-
-        loadPrecisionDataConnectionStateWithApnSetting(
-                TRANSPORT_TYPE_WLAN,
-                NetworkCapabilities.NET_CAPABILITY_IMS,
-                TelephonyManager.DATA_CONNECTING,
-                TelephonyManager.NETWORK_TYPE_IWLAN);
-
-        validateConnectingStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTING, TRANSPORT_TYPE_WLAN, EVENT_DATA_CONNECTION_STARTED);
-
-        mReady = false;
-        loadPrecisionDataConnectionStateWithApnSetting(
-                TRANSPORT_TYPE_WLAN,
-                NetworkCapabilities.NET_CAPABILITY_IMS,
-                TelephonyManager.DATA_CONNECTED,
-                TelephonyManager.NETWORK_TYPE_IWLAN);
-
-        validateConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WLAN);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTED, TRANSPORT_TYPE_WLAN, EVENT_DATA_CONNECTION_CONNECTED);
-
-        validateApnSetting(TRANSPORT_TYPE_WLAN);
-    }
-
-    @Test
-    public void testOnIwlanHandover() {
-        mReady = false;
-        validateNotConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WLAN,
-                TelephonyManager.DATA_CONNECTING,
-                TelephonyManager.NETWORK_TYPE_IWLAN);
-
-        validateConnectingStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTING, TRANSPORT_TYPE_WLAN, EVENT_DATA_CONNECTION_STARTED);
-
-        mReady = false;
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WLAN,
-                TelephonyManager.DATA_CONNECTED,
-                TelephonyManager.NETWORK_TYPE_IWLAN);
-
-        validateConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WLAN);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTED, TRANSPORT_TYPE_WLAN, EVENT_DATA_CONNECTION_CONNECTED);
-
-        mReady = false;
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WLAN,
-                TelephonyManager.DATA_HANDOVER_IN_PROGRESS,
-                TelephonyManager.NETWORK_TYPE_IWLAN);
-
-        validateHandoverStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WLAN);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_HANDOVER, TRANSPORT_TYPE_WLAN, EVENT_DATA_CONNECTION_HANDOVER_STARTED);
-
-        mReady = false;
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WWAN,
-                TelephonyManager.DATA_CONNECTED,
-                TelephonyManager.NETWORK_TYPE_LTE);
-
-        validateConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WWAN);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTED, TRANSPORT_TYPE_WWAN, EVENT_DATA_CONNECTION_HANDOVER_SUCCESS);
-    }
-
-    @Test
-    public void testOnIwlanHandoverFail() {
-        mReady = false;
-        validateNotConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WLAN,
-                TelephonyManager.DATA_CONNECTING,
-                TelephonyManager.NETWORK_TYPE_IWLAN);
-
-        validateConnectingStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTING, TRANSPORT_TYPE_WLAN, EVENT_DATA_CONNECTION_STARTED);
-
-        mReady = false;
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WLAN,
-                TelephonyManager.DATA_CONNECTED,
-                TelephonyManager.NETWORK_TYPE_IWLAN);
-
-        validateConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WLAN);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTED, TRANSPORT_TYPE_WLAN, EVENT_DATA_CONNECTION_CONNECTED);
-
-        mReady = false;
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WLAN,
-                TelephonyManager.DATA_HANDOVER_IN_PROGRESS,
-                TelephonyManager.NETWORK_TYPE_IWLAN);
-
-        validateHandoverStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WLAN);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_HANDOVER, TRANSPORT_TYPE_WLAN, EVENT_DATA_CONNECTION_HANDOVER_STARTED);
-
-        mReady = false;
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WLAN,
-                TelephonyManager.DATA_CONNECTED,
-                TelephonyManager.NETWORK_TYPE_IWLAN);
-
-        validateConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WLAN);
-        waitUntilReady();
-        validateDataConnectionChangedInfo(
-                STATE_CONNECTED, TRANSPORT_TYPE_WLAN, EVENT_DATA_CONNECTION_HANDOVER_FAILED);
-    }
-
-    @Test
-    public void testOnIwlanHandoverFailWithCause() {
-
-        validateNotConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WLAN,
-                TelephonyManager.DATA_CONNECTING,
-                TelephonyManager.NETWORK_TYPE_IWLAN);
-
-        validateConnectingStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WLAN,
-                TelephonyManager.DATA_CONNECTED,
-                TelephonyManager.NETWORK_TYPE_IWLAN);
-
-        validateConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WLAN);
-
-        loadPrecisionDataConnectionState(
-                TRANSPORT_TYPE_WLAN,
-                TelephonyManager.DATA_HANDOVER_IN_PROGRESS,
-                TelephonyManager.NETWORK_TYPE_IWLAN);
-
-        validateHandoverStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WLAN);
-
-        loadPrecisionDataConnectionStateWithFailCause(
-                TRANSPORT_TYPE_WLAN,
-                MISSING_UNKNOWN_APN,
-                TelephonyManager.DATA_CONNECTED,
-                TelephonyManager.NETWORK_TYPE_IWLAN);
-
-        validateConnectedStatusChecks();
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_WLAN);
-        validateHandoverFailCause(MISSING_UNKNOWN_APN);
-        validateApnSettingForNull(TRANSPORT_TYPE_WLAN);
-    }
-
-    @Test
-    public void testInvalidDataConnectionStatusTrackerHandler() {
-        mDataConnectionStatusTracker.mHandler.handleMessage(
-                Message.obtain(mDataConnectionStatusTracker.mHandler, -1, null));
-        validateDataConnectionLastTransportType(TRANSPORT_TYPE_INVALID);
-    }
-
-    private void loadPrecisionDataConnectionState(
-            int accessNetwork, int telephonyState, int currentRat) {
-
-        PreciseDataConnectionState dataState =
-                new PreciseDataConnectionState.Builder()
-                        .setTransportType(accessNetwork)
-                        .setState(telephonyState)
-                        .setNetworkType(currentRat)
-                        .build();
-        QnsAsyncResult ar = new QnsAsyncResult(null, dataState, null);
-        Message msg = mDataConnectionStatusTracker.mHandler.obtainMessage(11001, ar);
-        mDataConnectionStatusTracker.mHandler.handleMessage(msg);
-    }
-
-    private void loadPrecisionDataConnectionStateWithFailCause(
-            int accessNetwork, int failCause, int telephonyState, int currentRat) {
-
-        PreciseDataConnectionState dataState =
-                new PreciseDataConnectionState.Builder()
-                        .setTransportType(accessNetwork)
-                        .setFailCause(failCause)
-                        .setState(telephonyState)
-                        .setNetworkType(currentRat)
-                        .build();
-        QnsAsyncResult ar = new QnsAsyncResult(null, dataState, null);
-        Message msg = mDataConnectionStatusTracker.mHandler.obtainMessage(11001, ar);
-        mDataConnectionStatusTracker.mHandler.handleMessage(msg);
-    }
-
-    private void loadPrecisionDataConnectionStateWithApnSetting(
-            int accessNetwork, int apnType, int telephonyState, int currentRat) {
-        ApnSetting apnSetting =
-                new ApnSetting.Builder()
-                        .setApnTypeBitmask(NetworkCapabilities.NET_CAPABILITY_IMS)
-                        .setApnName("ims")
-                        .setEntryName("IMS")
-                        .setApnTypeBitmask(apnType)
-                        .setNetworkTypeBitmask(
-                                (int) TelephonyManager.NETWORK_STANDARDS_FAMILY_BITMASK_3GPP)
-                        .setCarrierEnabled(true)
-                        .build();
-
-        PreciseDataConnectionState dataState =
-                new PreciseDataConnectionState.Builder()
-                        .setTransportType(accessNetwork)
-                        .setApnSetting(apnSetting)
-                        .setState(telephonyState)
-                        .setNetworkType(currentRat)
-                        .build();
-        QnsAsyncResult ar = new QnsAsyncResult(null, dataState, null);
-        Message msg = mDataConnectionStatusTracker.mHandler.obtainMessage(11001, ar);
-        mDataConnectionStatusTracker.mHandler.handleMessage(msg);
-    }
-
-    private void validateNotConnectedStatusChecks() {
-        Assert.assertFalse(mDataConnectionStatusTracker.isActiveState());
-        Assert.assertTrue(mDataConnectionStatusTracker.isInactiveState());
-        Assert.assertFalse(mDataConnectionStatusTracker.isHandoverState());
-    }
-
-    private void validateConnectingStatusChecks() {
-        Assert.assertFalse(mDataConnectionStatusTracker.isActiveState());
-        Assert.assertFalse(mDataConnectionStatusTracker.isInactiveState());
-        Assert.assertFalse(mDataConnectionStatusTracker.isHandoverState());
-        Assert.assertTrue(mDataConnectionStatusTracker.isConnectionInProgress());
-    }
-
-    private void validateConnectedStatusChecks() {
-        Assert.assertTrue(mDataConnectionStatusTracker.isActiveState());
-        Assert.assertFalse(mDataConnectionStatusTracker.isInactiveState());
-        Assert.assertFalse(mDataConnectionStatusTracker.isHandoverState());
-    }
-
-    private void validateHandoverStatusChecks() {
-        Assert.assertTrue(mDataConnectionStatusTracker.isActiveState());
-        Assert.assertFalse(mDataConnectionStatusTracker.isInactiveState());
-        Assert.assertTrue(mDataConnectionStatusTracker.isHandoverState());
-        Assert.assertTrue(mDataConnectionStatusTracker.isConnectionInProgress());
-    }
-
-    private void validateDataConnectionLastTransportType(int transportType) {
-        Assert.assertEquals(transportType, mDataConnectionStatusTracker.getLastTransportType());
-    }
-
-    private void validateHandoverFailCause(int dcFailCause) {
-        Assert.assertEquals(dcFailCause, mDataConnectionStatusTracker.getLastFailCause());
-    }
-
-    private void validateDataConnectionChangedInfo(int state, int transportType, int event) {
-
-        Assert.assertEquals(state, mDcStatus.getState());
-        Assert.assertEquals(transportType, mDcStatus.getTransportType());
-        Assert.assertEquals(event, mDcStatus.getEvent());
-    }
-
-    private void validateApnSettingForNull(int transportType) {
-        ApnSetting apnSetting = mDataConnectionStatusTracker.getLastApnSetting(transportType);
-        Assert.assertNull(apnSetting);
-    }
-
-    private void validateApnSetting(int transportType) {
-        ApnSetting apnSetting = mDataConnectionStatusTracker.getLastApnSetting(transportType);
-        Assert.assertTrue(apnSetting.canHandleType(NetworkCapabilities.NET_CAPABILITY_IMS));
-    }
-
-    @After
-    public void tearDown() {
-        mDataConnectionStatusTracker.unRegisterDataConnectionStatusChanged(mHandler);
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/IwlanNetworkStatusTrackerTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/IwlanNetworkStatusTrackerTest.java
deleted file mode 100644
index 801411f..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/IwlanNetworkStatusTrackerTest.java
+++ /dev/null
@@ -1,445 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static com.android.dx.mockito.inline.extended.ExtendedMockito.mockitoSession;
-
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.*;
-
-import android.location.Country;
-import android.net.ConnectivityManager;
-import android.net.Network;
-import android.net.NetworkCapabilities;
-import android.net.TelephonyNetworkSpecifier;
-import android.net.vcn.VcnTransportInfo;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Message;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.mockito.MockitoSession;
-
-import java.util.Collections;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.Executor;
-import java.util.concurrent.TimeUnit;
-import java.util.function.Consumer;
-
-@RunWith(JUnit4.class)
-public class IwlanNetworkStatusTrackerTest extends QnsTest {
-
-    private static final int INVALID_SUB_ID = -1;
-    private static final int CURRENT_SLOT_ID = 0;
-    private static final int CURRENT_SUB_ID = 0;
-    private static final int ACTIVE_DATA_SUB_ID = 1;
-    private IwlanNetworkStatusTracker mIwlanNetworkStatusTracker;
-    private IwlanNetworkStatusTracker.IwlanAvailabilityInfo mIwlanAvailabilityInfo;
-    private final TestHandler[] mHandlers = new TestHandler[2];
-    private Handler mEventHandler;
-    private final HandlerThread[] mHandlerThreads = new HandlerThread[2];
-    @Mock private Network mMockNetwork;
-    private MockitoSession mMockSession;
-    private NetworkCapabilities mNetworkCapabilities;
-
-    private class TestHandlerThread extends HandlerThread {
-        TestHandlerThread() {
-            super("");
-        }
-
-        @Override
-        protected void onLooperPrepared() {
-            super.onLooperPrepared();
-            setReady(true);
-        }
-    }
-
-    private class TestHandler extends Handler {
-        private int mSlotId;
-        CountDownLatch mLatch;
-
-        TestHandler(HandlerThread ht, int slotId) {
-            super(ht.getLooper());
-            mSlotId = slotId;
-        }
-
-        @Override
-        public void handleMessage(Message msg) {
-            super.handleMessage(msg);
-            QnsAsyncResult ar = (QnsAsyncResult) msg.obj;
-            mIwlanAvailabilityInfo = (IwlanNetworkStatusTracker.IwlanAvailabilityInfo) ar.mResult;
-            if (mLatch != null) {
-                mLatch.countDown();
-            }
-        }
-    }
-
-    @Before
-    public void setUp() throws Exception {
-        MockitoAnnotations.initMocks(this);
-        super.setUp();
-        mMockSession = mockitoSession().mockStatic(QnsUtils.class).startMocking();
-        mHandlerThreads[0] = new TestHandlerThread();
-        mHandlerThreads[0].start();
-        waitUntilReady();
-        mHandlerThreads[1] = new TestHandlerThread();
-        mHandlerThreads[1].start();
-        waitUntilReady();
-        mIwlanNetworkStatusTracker = new IwlanNetworkStatusTracker(sMockContext);
-        mIwlanNetworkStatusTracker.initBySlotIndex(
-                mMockQnsConfigManager,
-                mMockQnsEventDispatcher,
-                mMockQnsImsManager,
-                mMockQnsTelephonyListener,
-                0);
-        mIwlanNetworkStatusTracker.initBySlotIndex(
-                mMockQnsConfigManager,
-                mMockQnsEventDispatcher,
-                mMockQnsImsManager,
-                mMockQnsTelephonyListener,
-                1);
-        mHandlers[0] = new TestHandler(mHandlerThreads[0], 0);
-        mHandlers[1] = new TestHandler(mHandlerThreads[1], 1);
-    }
-
-    @After
-    public void tearDown() {
-        for (HandlerThread handlerThread : mHandlerThreads) {
-            if (handlerThread != null) {
-                handlerThread.quit();
-            }
-        }
-        if (mIwlanNetworkStatusTracker != null) {
-            mIwlanNetworkStatusTracker.unregisterIwlanNetworksChanged(0, mHandlers[0]);
-            mIwlanNetworkStatusTracker.unregisterIwlanNetworksChanged(1, mHandlers[1]);
-            mIwlanNetworkStatusTracker.close();
-        }
-        mIwlanAvailabilityInfo = null;
-        mMockSession.finishMocking();
-    }
-
-    @Test
-    public void testHandleMessage_InvalidSubID() throws InterruptedException {
-        mEventHandler = mIwlanNetworkStatusTracker.mHandlerSparseArray.get(CURRENT_SLOT_ID);
-        mHandlers[0].mLatch = new CountDownLatch(1);
-        mIwlanNetworkStatusTracker.registerIwlanNetworksChanged(CURRENT_SLOT_ID, mHandlers[0], 1);
-        waitForLastHandlerAction(mEventHandler);
-        assertTrue(mHandlers[0].mLatch.await(200, TimeUnit.MILLISECONDS));
-
-        // If sim is invalid, no event is notified because of already info was notified.
-        mHandlers[0].mLatch = new CountDownLatch(1);
-        prepareNetworkCapabilitiesForTest(INVALID_SUB_ID, false /* isVcn */);
-        mIwlanNetworkStatusTracker.onCrossSimEnabledEvent(true, 0);
-        assertFalse(mHandlers[0].mLatch.await(100, TimeUnit.MILLISECONDS));
-        assertNotNull(mIwlanAvailabilityInfo);
-        assertFalse(mIwlanAvailabilityInfo.isCrossWfc());
-    }
-
-    @Test
-    public void testHandleMessage_ValidSubID() throws InterruptedException {
-        mEventHandler = mIwlanNetworkStatusTracker.mHandlerSparseArray.get(CURRENT_SLOT_ID);
-        mHandlers[0].mLatch = new CountDownLatch(1);
-        lenient().when(QnsUtils.getSubId(sMockContext, CURRENT_SLOT_ID)).thenReturn(CURRENT_SUB_ID);
-        lenient().when(QnsUtils.isCrossSimCallingEnabled(mMockQnsImsManager)).thenReturn(true);
-        lenient().when(QnsUtils.isDefaultDataSubs(CURRENT_SLOT_ID)).thenReturn(false);
-        mIwlanNetworkStatusTracker.registerIwlanNetworksChanged(CURRENT_SLOT_ID, mHandlers[0], 1);
-        waitForLastHandlerAction(mEventHandler);
-        assertTrue(mHandlers[0].mLatch.await(200, TimeUnit.MILLISECONDS));
-        prepareNetworkCapabilitiesForTest(ACTIVE_DATA_SUB_ID, false /* isVcn */);
-        mIwlanNetworkStatusTracker.onCrossSimEnabledEvent(true, CURRENT_SLOT_ID);
-        mIwlanNetworkStatusTracker.onIwlanServiceStateChanged(CURRENT_SLOT_ID, true);
-        waitForLastHandlerAction(mEventHandler);
-        assertNotNull(mIwlanAvailabilityInfo);
-        assertTrue(mIwlanAvailabilityInfo.isCrossWfc());
-    }
-
-    @Test
-    public void testHandleMessage_ValidSubID_DDS_over_nDDS() throws InterruptedException {
-        // Verifies that DDS can also establish cross-sim over nDDS, as long as nDDS is the current
-        // active data sub.
-        mHandlers[0].mLatch = new CountDownLatch(1);
-        mEventHandler = mIwlanNetworkStatusTracker.mHandlerSparseArray.get(CURRENT_SLOT_ID);
-        lenient().when(QnsUtils.getSubId(sMockContext, CURRENT_SLOT_ID)).thenReturn(CURRENT_SUB_ID);
-        lenient().when(QnsUtils.isCrossSimCallingEnabled(mMockQnsImsManager)).thenReturn(true);
-        lenient().when(QnsUtils.isDefaultDataSubs(CURRENT_SLOT_ID)).thenReturn(false);
-        mIwlanNetworkStatusTracker.registerIwlanNetworksChanged(CURRENT_SLOT_ID, mHandlers[0], 1);
-        waitForLastHandlerAction(mEventHandler);
-        assertTrue(mHandlers[0].mLatch.await(200, TimeUnit.MILLISECONDS));
-        prepareNetworkCapabilitiesForTest(ACTIVE_DATA_SUB_ID, false /* isVcn */);
-        mIwlanNetworkStatusTracker.onCrossSimEnabledEvent(true, CURRENT_SLOT_ID);
-        mIwlanNetworkStatusTracker.onIwlanServiceStateChanged(CURRENT_SLOT_ID, true);
-        waitForLastHandlerAction(mEventHandler);
-        assertNotNull(mIwlanAvailabilityInfo);
-        assertTrue(mIwlanAvailabilityInfo.isCrossWfc());
-    }
-
-    @Test
-    public void testHandleMessage_VcnWithValidSubID() throws InterruptedException {
-        mHandlers[0].mLatch = new CountDownLatch(1);
-        mEventHandler = mIwlanNetworkStatusTracker.mHandlerSparseArray.get(CURRENT_SLOT_ID);
-        lenient().when(QnsUtils.getSubId(sMockContext, CURRENT_SLOT_ID)).thenReturn(CURRENT_SUB_ID);
-        lenient().when(QnsUtils.isCrossSimCallingEnabled(mMockQnsImsManager)).thenReturn(true);
-        lenient().when(QnsUtils.isDefaultDataSubs(CURRENT_SLOT_ID)).thenReturn(false);
-        mIwlanNetworkStatusTracker.registerIwlanNetworksChanged(CURRENT_SLOT_ID, mHandlers[0], 1);
-        waitForLastHandlerAction(mEventHandler);
-        assertTrue(mHandlers[0].mLatch.await(200, TimeUnit.MILLISECONDS));
-        prepareNetworkCapabilitiesForTest(ACTIVE_DATA_SUB_ID, true /* isVcn */);
-        mIwlanNetworkStatusTracker.onCrossSimEnabledEvent(true, CURRENT_SLOT_ID);
-        mIwlanNetworkStatusTracker.onIwlanServiceStateChanged(CURRENT_SLOT_ID, true);
-        waitForLastHandlerAction(mEventHandler);
-        assertNotNull(mIwlanAvailabilityInfo);
-        assertTrue(mIwlanAvailabilityInfo.isCrossWfc());
-    }
-
-    static Network newCellNetwork(ConnectivityManager connectivityMgr, int subId) {
-        Network cellNetwork = mock(Network.class);
-        NetworkCapabilities caps =
-                new NetworkCapabilities.Builder()
-                        .addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR)
-                        .setNetworkSpecifier(new TelephonyNetworkSpecifier(subId))
-                        .build();
-        when(connectivityMgr.getNetworkCapabilities(cellNetwork)).thenReturn(caps);
-        return cellNetwork;
-    }
-
-    private void prepareNetworkCapabilitiesForTest(int subId, boolean isVcn) {
-        NetworkCapabilities.Builder builder =
-                new NetworkCapabilities.Builder()
-                        .addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR);
-        if (isVcn) {
-            Network underlyingCell = newCellNetwork(mMockConnectivityManager, subId);
-            builder.setTransportInfo(new VcnTransportInfo.Builder().build())
-                    .setUnderlyingNetworks(Collections.singletonList(underlyingCell));
-        } else {
-            builder.setNetworkSpecifier(new TelephonyNetworkSpecifier(subId));
-        }
-        mNetworkCapabilities = builder.build();
-        when(mMockConnectivityManager.getActiveNetwork()).thenReturn(mMockNetwork);
-        when(mMockConnectivityManager.getNetworkCapabilities(mMockNetwork))
-                .thenReturn(mNetworkCapabilities);
-    }
-
-    @Test
-    public void testHandleMessage_DisableCrossSim() throws InterruptedException {
-        testHandleMessage_ValidSubID();
-        mHandlers[0].mLatch = new CountDownLatch(1);
-        lenient().when(QnsUtils.isCrossSimCallingEnabled(mMockQnsImsManager)).thenReturn(false);
-        lenient().when(QnsUtils.isDefaultDataSubs(CURRENT_SLOT_ID)).thenReturn(false);
-        mIwlanNetworkStatusTracker.onCrossSimEnabledEvent(false, 0);
-        assertTrue(mHandlers[0].mLatch.await(100, TimeUnit.MILLISECONDS));
-        assertNotNull(mIwlanAvailabilityInfo);
-        assertFalse(mIwlanAvailabilityInfo.isCrossWfc());
-    }
-
-    private ConnectivityManager.NetworkCallback setupNetworkCallback() {
-        ArgumentCaptor<ConnectivityManager.NetworkCallback> callbackArg =
-                ArgumentCaptor.forClass(ConnectivityManager.NetworkCallback.class);
-        verify(mMockConnectivityManager, atLeastOnce())
-                .registerDefaultNetworkCallback(callbackArg.capture(), isA(Handler.class));
-        ConnectivityManager.NetworkCallback networkCallback = callbackArg.getValue();
-        assertNotNull(networkCallback);
-        return networkCallback;
-    }
-
-    @Test
-    public void testDefaultNetworkCallback_Wifi() throws InterruptedException {
-        testDefaultNetworkCallback(true, true);
-    }
-
-    @Test
-    public void testDefaultNetworkCallback_Cellular() throws InterruptedException {
-        testDefaultNetworkCallback(false, false);
-    }
-
-    public void testDefaultNetworkCallback(boolean isWifi, boolean isIwlanRegistered)
-            throws InterruptedException {
-        mHandlers[0].mLatch = new CountDownLatch(1);
-        mEventHandler = mIwlanNetworkStatusTracker.mHandlerSparseArray.get(CURRENT_SLOT_ID);
-        mIwlanNetworkStatusTracker.registerIwlanNetworksChanged(0, mHandlers[0], 1);
-        waitForLastHandlerAction(mEventHandler);
-        assertTrue(mHandlers[0].mLatch.await(200, TimeUnit.MILLISECONDS));
-        ConnectivityManager.NetworkCallback networkCallback = setupNetworkCallback();
-        TelephonyNetworkSpecifier tns = new TelephonyNetworkSpecifier(0);
-        mNetworkCapabilities =
-                new NetworkCapabilities.Builder()
-                        .addTransportType(
-                                isWifi
-                                        ? NetworkCapabilities.TRANSPORT_WIFI
-                                        : NetworkCapabilities.TRANSPORT_CELLULAR)
-                        .setNetworkSpecifier(tns)
-                        .build();
-        when(mMockConnectivityManager.getNetworkCapabilities(mMockNetwork))
-                .thenReturn(mNetworkCapabilities);
-        networkCallback.onAvailable(mMockNetwork);
-        if (isWifi) {
-            mIwlanNetworkStatusTracker.onIwlanServiceStateChanged(0, isIwlanRegistered);
-        }
-        waitForLastHandlerAction(mEventHandler);
-        verifyIwlanAvailabilityInfo(isWifi, isIwlanRegistered);
-
-        networkCallback.onCapabilitiesChanged(mMockNetwork, mNetworkCapabilities);
-        // no callback is expected since onAvailable already reported information
-        waitForLastHandlerAction(mEventHandler);
-        verifyIwlanAvailabilityInfo(isWifi, isIwlanRegistered);
-    }
-
-    private void verifyIwlanAvailabilityInfo(boolean isWifi, boolean isIwlanRegistered) {
-        assertNotNull(mIwlanAvailabilityInfo);
-        if (isWifi && isIwlanRegistered) {
-            assertTrue(mIwlanAvailabilityInfo.getIwlanAvailable());
-        } else {
-            assertFalse(mIwlanAvailabilityInfo.getIwlanAvailable());
-        }
-        assertFalse(mIwlanAvailabilityInfo.isCrossWfc());
-    }
-
-    @Test
-    public void testDefaultNetworkCallback_onLost() throws InterruptedException {
-        testDefaultNetworkCallback(true, true);
-        mHandlers[0].mLatch = new CountDownLatch(1);
-        ConnectivityManager.NetworkCallback networkCallback = setupNetworkCallback();
-        networkCallback.onLost(mMockNetwork);
-        assertTrue(mHandlers[0].mLatch.await(100, TimeUnit.MILLISECONDS));
-        assertNotNull(mIwlanAvailabilityInfo);
-        assertFalse(mIwlanAvailabilityInfo.getIwlanAvailable());
-    }
-
-    @Test
-    public void testRegisterIwlanNetworksChanged() throws Exception {
-        mEventHandler = mIwlanNetworkStatusTracker.mHandlerSparseArray.get(CURRENT_SLOT_ID);
-        mHandlers[0].mLatch = new CountDownLatch(1);
-        mIwlanNetworkStatusTracker.registerIwlanNetworksChanged(0, mHandlers[0], 1);
-        waitForLastHandlerAction(mEventHandler);
-        assertTrue(mHandlers[0].mLatch.await(100, TimeUnit.MILLISECONDS));
-        assertNotNull(mIwlanAvailabilityInfo);
-        assertFalse(mIwlanAvailabilityInfo.getIwlanAvailable());
-        assertFalse(mIwlanAvailabilityInfo.isCrossWfc());
-    }
-
-    @Test
-    public void testRegisterIwlanNetworksChanged_Validate() throws Exception {
-        mEventHandler = mIwlanNetworkStatusTracker.mHandlerSparseArray.get(0);
-        when(mMockQnsConfigManager.blockIpv6OnlyWifi()).thenReturn(false);
-        mHandlers[0].mLatch = new CountDownLatch(2);
-        mHandlers[1].mLatch = new CountDownLatch(1);
-
-        // Count down 1 mHandlers[0].mLatch
-        mIwlanNetworkStatusTracker.registerIwlanNetworksChanged(0, mHandlers[0], 1);
-        waitForLastHandlerAction(mEventHandler);
-
-        mIwlanNetworkStatusTracker.mLastIwlanAvailabilityInfo.put(0,
-                mIwlanNetworkStatusTracker.new IwlanAvailabilityInfo(true, false));
-
-        // When registering a new handler, if the IwlanAvailabilityInfo information is updated,
-        // the existing one is also notified.
-        // Count down 1 mHandlers[1].mLatch and Count down 1 mHandlers[0].mLatch as well
-        mIwlanNetworkStatusTracker.registerIwlanNetworksChanged(0, mHandlers[1], 1);
-        waitForLastHandlerAction(mEventHandler);
-
-        assertTrue(mHandlers[0].mLatch.await(100, TimeUnit.MILLISECONDS));
-        assertTrue(mHandlers[1].mLatch.await(100, TimeUnit.MILLISECONDS));
-    }
-
-    @Test
-    public void testUnregisterIwlanNetworksChanged() throws InterruptedException {
-        mEventHandler = mIwlanNetworkStatusTracker.mHandlerSparseArray.get(CURRENT_SLOT_ID);
-        mHandlers[0].mLatch = new CountDownLatch(1);
-        mIwlanNetworkStatusTracker.registerIwlanNetworksChanged(CURRENT_SLOT_ID, mHandlers[0], 1);
-        waitForLastHandlerAction(mEventHandler);
-        assertTrue(mHandlers[0].mLatch.await(100, TimeUnit.MILLISECONDS));
-        ConnectivityManager.NetworkCallback networkCallback = setupNetworkCallback();
-        TelephonyNetworkSpecifier tns = new TelephonyNetworkSpecifier(CURRENT_SLOT_ID);
-        mNetworkCapabilities =
-                new NetworkCapabilities.Builder()
-                        .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
-                        .setNetworkSpecifier(tns)
-                        .build();
-        when(mMockConnectivityManager.getNetworkCapabilities(mMockNetwork))
-                .thenReturn(mNetworkCapabilities);
-        mHandlers[0].mLatch = new CountDownLatch(1);
-        mIwlanNetworkStatusTracker.unregisterIwlanNetworksChanged(CURRENT_SLOT_ID, mHandlers[0]);
-        waitForLastHandlerAction(mEventHandler);
-        networkCallback.onAvailable(mMockNetwork);
-        assertFalse(mHandlers[0].mLatch.await(100, TimeUnit.MILLISECONDS));
-    }
-
-    @Test
-    public void testIsInternationalRoaming() {
-        boolean isInternationalRoaming;
-        mEventHandler = mIwlanNetworkStatusTracker.mHandlerSparseArray.get(CURRENT_SLOT_ID);
-        when(mMockTelephonyManager.getSimCountryIso()).thenReturn("CA");
-        ArgumentCaptor<Consumer<Country>> capture = ArgumentCaptor.forClass(Consumer.class);
-        verify(mMockCountryDetector)
-                .registerCountryDetectorCallback(isA(Executor.class), capture.capture());
-        Consumer<Country> countryConsumer = capture.getValue();
-
-        countryConsumer.accept(new Country("US", Country.COUNTRY_SOURCE_LOCATION));
-        waitForLastHandlerAction(mEventHandler);
-
-        isInternationalRoaming = mIwlanNetworkStatusTracker.isInternationalRoaming(anyInt());
-        assertTrue(isInternationalRoaming);
-
-        countryConsumer.accept(new Country("CA", Country.COUNTRY_SOURCE_LOCATION));
-        waitForLastHandlerAction(mEventHandler);
-
-        isInternationalRoaming = mIwlanNetworkStatusTracker.isInternationalRoaming(anyInt());
-        assertFalse(isInternationalRoaming);
-    }
-
-    @Test
-    public void testWifiDisabling() throws InterruptedException {
-        testDefaultNetworkCallback(true, true);
-        mHandlers[0].mLatch = new CountDownLatch(1);
-        mIwlanNetworkStatusTracker.onWifiDisabling();
-        assertTrue(mHandlers[0].mLatch.await(100, TimeUnit.MILLISECONDS));
-        assertNotNull(mIwlanAvailabilityInfo);
-        assertFalse(mIwlanAvailabilityInfo.getIwlanAvailable());
-    }
-
-    @Test
-    public void testDefaultNetworkCallback_IwlanNotRegistered() throws InterruptedException {
-        testDefaultNetworkCallback(true, false);
-    }
-
-    @Test
-    public void testWifiToggleQuickOffOn() throws InterruptedException {
-        testWifiDisabling();
-        mHandlers[0].mLatch = new CountDownLatch(1);
-        mIwlanNetworkStatusTracker.onWifiEnabled();
-        assertTrue(mHandlers[0].mLatch.await(100, TimeUnit.MILLISECONDS));
-        verifyIwlanAvailabilityInfo(true, true);
-    }
-
-    @Test
-    public void testWifiToggleQuickOffOn_inCrossSimEnabledCondition() throws InterruptedException {
-        mIwlanNetworkStatusTracker.onWifiEnabled();
-        testHandleMessage_ValidSubID();
-        mIwlanNetworkStatusTracker.onWifiDisabling();
-        assertNotNull(mIwlanAvailabilityInfo);
-        assertTrue(mIwlanAvailabilityInfo.isCrossWfc());
-        mIwlanNetworkStatusTracker.onWifiEnabled();
-        assertNotNull(mIwlanAvailabilityInfo);
-        assertTrue(mIwlanAvailabilityInfo.isCrossWfc());
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsCallStatusTrackerTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsCallStatusTrackerTest.java
deleted file mode 100644
index eed22f4..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsCallStatusTrackerTest.java
+++ /dev/null
@@ -1,1428 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static com.android.dx.mockito.inline.extended.ExtendedMockito.mockitoSession;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.ArgumentMatchers.anyLong;
-import static org.mockito.ArgumentMatchers.isA;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.lenient;
-import static org.mockito.Mockito.when;
-
-import android.net.LinkProperties;
-import android.net.NetworkCapabilities;
-import android.os.Handler;
-import android.os.Message;
-import android.os.test.TestLooper;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.CallQuality;
-import android.telephony.CallState;
-import android.telephony.PreciseCallState;
-import android.telephony.PreciseDataConnectionState;
-import android.telephony.TelephonyManager;
-import android.telephony.data.ApnSetting;
-import android.telephony.ims.ImsCallProfile;
-import android.telephony.ims.MediaQualityStatus;
-
-import com.android.telephony.qns.QnsCallStatusTracker.ActiveCallTracker.TransportQuality;
-import com.android.telephony.qns.QnsCallStatusTracker.CallQualityBlock;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mockito;
-import org.mockito.MockitoAnnotations;
-import org.mockito.MockitoSession;
-import org.mockito.stubbing.Answer;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-
-@RunWith(JUnit4.class)
-public class QnsCallStatusTrackerTest extends QnsTest {
-
-    QnsCallStatusTracker mCallTracker;
-    TestLooper mTestLooper;
-    TestLooper mTestLooperListener;
-    TestLooper mLowQualityListenerLooper;
-    private Handler mImsHandler;
-    private Handler mEmergencyHandler;
-    private Handler mLowQualityHandler;
-    private MockitoSession mMockSession;
-    List<CallState> mTestCallStateList = new ArrayList<>();
-    int mId = 0;
-    HashMap<Integer, Message> mMessageHashMap = new HashMap<>();
-
-    @Before
-    public void setUp() throws Exception {
-        MockitoAnnotations.initMocks(this);
-        super.setUp();
-        mMockSession = mockitoSession().mockStatic(QnsUtils.class).startMocking();
-        mTestLooper = new TestLooper();
-        mTestLooperListener = new TestLooper();
-        mLowQualityListenerLooper = new TestLooper();
-        Mockito.when(sMockContext.getMainLooper()).thenReturn(mTestLooper.getLooper());
-        mImsHandler = new Handler(mTestLooperListener.getLooper());
-        mEmergencyHandler = new Handler(mTestLooperListener.getLooper());
-        mLowQualityHandler = new Handler(mLowQualityListenerLooper.getLooper());
-        mMessageHashMap = new HashMap<>();
-        when(mMockQnsTimer.registerTimer(isA(Message.class), anyLong())).thenAnswer(
-                (Answer<Integer>) invocation -> {
-                    Message msg = (Message) invocation.getArguments()[0];
-                    long delay = (long) invocation.getArguments()[1];
-                    msg.getTarget().sendMessageDelayed(msg, delay);
-                    mMessageHashMap.put(++mId, msg);
-                    return mId;
-                });
-
-        doAnswer(invocation -> {
-            int timerId = (int) invocation.getArguments()[0];
-            Message msg = mMessageHashMap.get(timerId);
-            if (msg != null && msg.getTarget() != null) {
-                msg.getTarget().removeMessages(msg.what, msg.obj);
-            }
-            return null;
-        }).when(mMockQnsTimer).unregisterTimer(anyInt());
-        mCallTracker = new QnsCallStatusTracker(
-                mMockQnsTelephonyListener, mMockQnsConfigManager, mMockQnsTimer, 0,
-                mTestLooper.getLooper());
-        mCallTracker.registerCallTypeChangedListener(
-                NetworkCapabilities.NET_CAPABILITY_IMS, mImsHandler, 1, null);
-        mCallTracker.registerCallTypeChangedListener(
-                NetworkCapabilities.NET_CAPABILITY_EIMS, mEmergencyHandler, 1, null);
-        mCallTracker.getActiveCallTracker()
-                .registerLowMediaQualityListener(mLowQualityHandler, 1, null);
-        lenient().when(QnsUtils.getOtherTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WLAN))
-                .thenReturn(AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        lenient().when(QnsUtils.getOtherTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WWAN))
-                .thenReturn(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        lenient()
-                .when(QnsUtils.getOtherTransportType(AccessNetworkConstants.TRANSPORT_TYPE_INVALID))
-                .thenReturn(AccessNetworkConstants.TRANSPORT_TYPE_INVALID);
-    }
-
-    @After
-    public void tearDown() {
-        mTestCallStateList.clear();
-        mCallTracker.unregisterCallTypeChangedListener(
-                NetworkCapabilities.NET_CAPABILITY_IMS, mImsHandler);
-        mCallTracker.unregisterCallTypeChangedListener(
-                NetworkCapabilities.NET_CAPABILITY_EIMS, mEmergencyHandler);
-        mCallTracker.getActiveCallTracker()
-                .unregisterLowMediaQualityListener(mLowQualityHandler);
-        if (mMockSession != null) {
-            mMockSession.finishMocking();
-            mMockSession = null;
-        }
-    }
-
-    @Test
-    public void testForVoiceCallTypeChangedScenarios() {
-
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_DIALING)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-
-        Message msg = mTestLooperListener.nextMessage();
-        assertEquals(mImsHandler, msg.getTarget());
-        assertNotEquals(mEmergencyHandler, msg.getTarget());
-        assertNotNull(msg);
-        QnsAsyncResult result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(QnsConstants.CALL_TYPE_VOICE, (int) result.mResult);
-        assertFalse(mCallTracker.isCallIdle());
-        assertTrue(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_EIMS));
-        assertFalse(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_IMS));
-
-        // Test2:
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        msg = mTestLooperListener.nextMessage();
-        // Should not notify if call type is not changed
-        assertNull(msg);
-
-        // Test3:
-        mTestCallStateList.clear();
-        mCallTracker.updateCallState(mTestCallStateList);
-        msg = mTestLooperListener.nextMessage();
-        assertNotNull(msg);
-        result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(QnsConstants.CALL_TYPE_IDLE, (int) result.mResult);
-        assertTrue(mCallTracker.isCallIdle());
-        assertTrue(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_EIMS));
-        assertTrue(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_IMS));
-    }
-
-    @Test
-    public void testForEmergencyCallTypeChangedScenarios() {
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_INCOMING)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-
-        Message msg = mTestLooperListener.nextMessage();
-        assertEquals(mImsHandler, msg.getTarget());
-        assertNotNull(msg);
-        QnsAsyncResult result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(QnsConstants.CALL_TYPE_VOICE, (int) result.mResult);
-        assertFalse(mCallTracker.isCallIdle());
-        assertTrue(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_EIMS));
-        assertFalse(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_IMS));
-        assertFalse(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_MMS));
-
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        msg = mTestLooperListener.nextMessage();
-        // Should not notify if call type is not changed
-        assertNull(msg);
-
-        mTestCallStateList.clear();
-        mTestCallStateList.add(
-                new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_DISCONNECTING)
-                        .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                        .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mTestCallStateList.add(
-                new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_EMERGENCY).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        msg = mTestLooperListener.nextMessage();
-        assertNotNull(msg);
-        assertEquals(mEmergencyHandler, msg.getTarget());
-        result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(QnsConstants.CALL_TYPE_EMERGENCY, (int) result.mResult);
-        assertFalse(mCallTracker.isCallIdle());
-        assertFalse(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_EIMS));
-        assertFalse(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_IMS));
-
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_EMERGENCY).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        msg = mTestLooperListener.nextMessage();
-        assertNotNull(msg);
-        assertEquals(mImsHandler, msg.getTarget());
-        result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(QnsConstants.CALL_TYPE_IDLE, (int) result.mResult);
-        assertFalse(mCallTracker.isCallIdle());
-        assertFalse(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_EIMS));
-        assertTrue(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_IMS));
-
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ALERTING)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        msg = mTestLooperListener.nextMessage();
-        assertNotNull(msg);
-        assertEquals(mEmergencyHandler, msg.getTarget());
-        result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(QnsConstants.CALL_TYPE_IDLE, (int) result.mResult);
-        msg = mTestLooperListener.nextMessage();
-        assertNotNull(msg);
-        assertEquals(mImsHandler, msg.getTarget());
-        result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(QnsConstants.CALL_TYPE_VOICE, (int) result.mResult);
-        assertFalse(mCallTracker.isCallIdle());
-        assertTrue(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_EIMS));
-        assertFalse(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_IMS));
-    }
-
-    @Test
-    public void testForVideoCallTypeChangedScenarios() {
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_INCOMING)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VT)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        Message msg = mTestLooperListener.nextMessage();
-        assertNotNull(msg);
-        QnsAsyncResult result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(QnsConstants.CALL_TYPE_VOICE, (int) result.mResult);
-        assertFalse(mCallTracker.isCallIdle()); // for IMS calls only
-        assertTrue(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_EIMS));
-        assertFalse(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_IMS));
-
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_WAITING)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VT)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        msg = mTestLooperListener.nextMessage();
-        // Video call is still in waiting state, QNS call type changed event should not be happened.
-        assertNull(msg);
-        assertFalse(mCallTracker.isCallIdle()); // for IMS calls only
-        assertTrue(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_EIMS));
-        assertFalse(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_IMS));
-
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_HOLDING)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VT)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        msg = mTestLooperListener.nextMessage();
-        assertNotNull(msg);
-        result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(QnsConstants.CALL_TYPE_VIDEO, (int) result.mResult);
-        assertFalse(mCallTracker.isCallIdle()); // for IMS calls only
-        assertTrue(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_EIMS));
-        assertFalse(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_IMS));
-
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VT)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_HOLDING)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        msg = mTestLooperListener.nextMessage();
-        assertNull(msg);
-        assertFalse(mCallTracker.isCallIdle()); // for IMS calls only
-        assertTrue(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_EIMS));
-        assertFalse(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_IMS));
-
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_HOLDING)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        msg = mTestLooperListener.nextMessage();
-        assertNotNull(msg);
-        assertEquals(mImsHandler, msg.getTarget());
-        result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(QnsConstants.CALL_TYPE_VOICE, (int) result.mResult);
-        assertFalse(mCallTracker.isCallIdle());
-        assertTrue(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_EIMS));
-        assertFalse(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_IMS));
-
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_INCOMING)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VT)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        msg = mTestLooperListener.nextMessage();
-        assertNull(msg);
-        assertFalse(mCallTracker.isCallIdle());
-
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VT)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        msg = mTestLooperListener.nextMessage();
-        assertNotNull(msg);
-        assertEquals(mImsHandler, msg.getTarget());
-        result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(QnsConstants.CALL_TYPE_VIDEO, (int) result.mResult);
-        assertFalse(mCallTracker.isCallIdle());
-
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ALERTING)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VT)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        msg = mTestLooperListener.nextMessage();
-        assertNotNull(msg);
-        assertEquals(mImsHandler, msg.getTarget());
-        result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(QnsConstants.CALL_TYPE_IDLE, (int) result.mResult);
-        assertFalse(mCallTracker.isCallIdle());
-        assertTrue(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_EIMS));
-        assertFalse(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_IMS));
-
-        mTestCallStateList.clear();
-        mCallTracker.updateCallState(mTestCallStateList);
-        msg = mTestLooperListener.nextMessage();
-        assertNull(msg);
-        assertTrue(mCallTracker.isCallIdle());
-        assertTrue(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_EIMS));
-        assertTrue(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_IMS));
-    }
-
-    @Test
-    public void testUnregisterCallTypeChangedListener() {
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_INCOMING)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VT)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        Message msg = mTestLooperListener.nextMessage();
-        assertNotNull(msg);
-        QnsAsyncResult result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(QnsConstants.CALL_TYPE_VOICE, (int) result.mResult);
-        assertFalse(mCallTracker.isCallIdle()); // for IMS calls only
-
-        mCallTracker.unregisterCallTypeChangedListener(
-                NetworkCapabilities.NET_CAPABILITY_IMS, mImsHandler);
-        mCallTracker.unregisterCallTypeChangedListener(
-                NetworkCapabilities.NET_CAPABILITY_EIMS, mEmergencyHandler);
-
-        mTestCallStateList.clear();
-        mCallTracker.updateCallState(mTestCallStateList);
-        msg = mTestLooperListener.nextMessage();
-        assertNull(msg);
-
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_EMERGENCY).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        msg = mTestLooperListener.nextMessage();
-        assertNull(msg);
-    }
-
-    @Test
-    public void testEmergencyOverImsCallTypeChangedScenarios() {
-        PreciseDataConnectionState emergencyDataStatus =
-                new PreciseDataConnectionState.Builder()
-                        .setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_INVALID)
-                        .setState(TelephonyManager.DATA_DISCONNECTED)
-                        .setNetworkType(AccessNetworkConstants.AccessNetworkType.EUTRAN)
-                        .setApnSetting(
-                                new ApnSetting.Builder()
-                                        .setApnTypeBitmask(ApnSetting.TYPE_EMERGENCY)
-                                        .setApnName("sos")
-                                        .setEntryName("sos")
-                                        .build())
-                        .setLinkProperties(new LinkProperties())
-                        .build();
-        PreciseDataConnectionState imsDataStatus =
-                new PreciseDataConnectionState.Builder()
-                        .setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WLAN)
-                        .setState(TelephonyManager.DATA_CONNECTED)
-                        .setNetworkType(AccessNetworkConstants.AccessNetworkType.IWLAN)
-                        .setApnSetting(
-                                new ApnSetting.Builder()
-                                        .setApnTypeBitmask(ApnSetting.TYPE_IMS)
-                                        .setApnName("ims")
-                                        .setEntryName("ims")
-                                        .build())
-                        .build();
-
-        when(mMockQnsTelephonyListener.getLastPreciseDataConnectionState(
-                        NetworkCapabilities.NET_CAPABILITY_EIMS))
-                .thenReturn(emergencyDataStatus);
-        when(mMockQnsTelephonyListener.getLastPreciseDataConnectionState(
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(imsDataStatus);
-        // Test1:
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_EMERGENCY).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        Message msg = mTestLooperListener.nextMessage();
-        assertNotNull(msg);
-        assertEquals(mImsHandler, msg.getTarget());
-        QnsAsyncResult result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(QnsConstants.CALL_TYPE_EMERGENCY, (int) result.mResult);
-        assertFalse(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_IMS));
-        assertTrue(mCallTracker.isCallIdle(NetworkCapabilities.NET_CAPABILITY_EIMS));
-
-        // Test2:
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_EMERGENCY).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        msg = mTestLooperListener.nextMessage();
-        // Should not notify if call type is not changed
-        assertNull(msg);
-
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_EMERGENCY).build());
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_WAITING)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        msg = mTestLooperListener.nextMessage();
-        // Should not notify if call type is not changed
-        assertNull(msg);
-
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_EMERGENCY).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        msg = mTestLooperListener.nextMessage();
-        // Should not notify if call type is not changed
-        assertNull(msg);
-
-        // Test3:
-        imsDataStatus =
-                new PreciseDataConnectionState.Builder()
-                        .setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_INVALID)
-                        .setState(TelephonyManager.DATA_DISCONNECTED)
-                        .setNetworkType(AccessNetworkConstants.AccessNetworkType.EUTRAN)
-                        .setApnSetting(
-                                new ApnSetting.Builder()
-                                        .setApnTypeBitmask(ApnSetting.TYPE_IMS)
-                                        .setApnName("ims")
-                                        .setEntryName("ims")
-                                        .build())
-                        .build();
-        Mockito.clearInvocations(mMockQnsTelephonyListener);
-        when(mMockQnsTelephonyListener.getLastPreciseDataConnectionState(
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(imsDataStatus);
-
-        mTestCallStateList.clear();
-        mCallTracker.updateCallState(mTestCallStateList);
-        msg = mTestLooperListener.nextMessage();
-        assertNotNull(msg);
-        assertEquals(mImsHandler, msg.getTarget());
-        result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(QnsConstants.CALL_TYPE_IDLE, (int) result.mResult);
-
-        // Test4:
-        emergencyDataStatus =
-                new PreciseDataConnectionState.Builder()
-                        .setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WLAN)
-                        .setState(TelephonyManager.DATA_CONNECTED)
-                        .setNetworkType(AccessNetworkConstants.AccessNetworkType.IWLAN)
-                        .setApnSetting(
-                                new ApnSetting.Builder()
-                                        .setApnTypeBitmask(ApnSetting.TYPE_EMERGENCY)
-                                        .setApnName("sos")
-                                        .setEntryName("sos")
-                                        .build())
-                        .build();
-        Mockito.clearInvocations(mMockQnsTelephonyListener);
-        when(mMockQnsTelephonyListener.getLastPreciseDataConnectionState(
-                        NetworkCapabilities.NET_CAPABILITY_EIMS))
-                .thenReturn(emergencyDataStatus);
-        imsDataStatus =
-                new PreciseDataConnectionState.Builder()
-                        .setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WLAN)
-                        .setState(TelephonyManager.DATA_CONNECTED)
-                        .setNetworkType(AccessNetworkConstants.AccessNetworkType.IWLAN)
-                        .setApnSetting(
-                                new ApnSetting.Builder()
-                                        .setApnTypeBitmask(ApnSetting.TYPE_IMS)
-                                        .setApnName("ims")
-                                        .setEntryName("ims")
-                                        .build())
-                        .build();
-        Mockito.clearInvocations(mMockQnsTelephonyListener);
-        when(mMockQnsTelephonyListener.getLastPreciseDataConnectionState(
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(imsDataStatus);
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_EMERGENCY).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        msg = mTestLooperListener.nextMessage();
-        assertNotNull(msg);
-        assertEquals(mEmergencyHandler, msg.getTarget());
-        result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(QnsConstants.CALL_TYPE_EMERGENCY, (int) result.mResult);
-
-        mTestCallStateList.clear();
-        mCallTracker.updateCallState(mTestCallStateList);
-        msg = mTestLooperListener.nextMessage();
-        assertNotNull(msg);
-        assertEquals(mEmergencyHandler, msg.getTarget());
-        result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(QnsConstants.CALL_TYPE_IDLE, (int) result.mResult);
-    }
-
-
-    @Test
-    public void testActiveCallTrackerOnOff() {
-        // Test1:
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_INCOMING)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        QnsCallStatusTracker.ActiveCallTracker activeCallTracker =
-                mCallTracker.getActiveCallTracker();
-        assertNotNull(activeCallTracker);
-        assertEquals(QnsConstants.CALL_TYPE_VOICE, activeCallTracker.getCallType());
-        assertEquals(NetworkCapabilities.NET_CAPABILITY_IMS, activeCallTracker.getNetCapability());
-
-        // Test2:
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        assertEquals(QnsConstants.CALL_TYPE_VOICE, activeCallTracker.getCallType());
-        assertEquals(NetworkCapabilities.NET_CAPABILITY_IMS, activeCallTracker.getNetCapability());
-
-        // Test3:
-        mTestCallStateList.clear();
-        mCallTracker.updateCallState(mTestCallStateList);
-        assertEquals(QnsConstants.CALL_TYPE_IDLE, activeCallTracker.getCallType());
-        assertEquals(QnsConstants.INVALID_VALUE, activeCallTracker.getNetCapability());
-
-        // Test4:
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_DIALING)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_EMERGENCY).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        assertEquals(QnsConstants.CALL_TYPE_IDLE, activeCallTracker.getCallType());
-        assertEquals(QnsConstants.INVALID_VALUE, activeCallTracker.getNetCapability());
-
-        // Test5:
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_EMERGENCY).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        assertEquals(QnsConstants.CALL_TYPE_EMERGENCY, activeCallTracker.getCallType());
-        assertEquals(NetworkCapabilities.NET_CAPABILITY_EIMS, activeCallTracker.getNetCapability());
-
-        // Test6:
-        mTestCallStateList.clear();
-        mCallTracker.updateCallState(mTestCallStateList);
-        assertEquals(QnsConstants.CALL_TYPE_IDLE, activeCallTracker.getCallType());
-        assertEquals(QnsConstants.INVALID_VALUE, activeCallTracker.getNetCapability());
-    }
-
-    @Test
-    public void testActiveCallTrackerCallTypeUpdate() {
-        // Test1:
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_INCOMING)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        QnsCallStatusTracker.ActiveCallTracker activeCallTracker =
-                mCallTracker.getActiveCallTracker();
-        assertNotNull(activeCallTracker);
-        assertEquals(QnsConstants.CALL_TYPE_VOICE, activeCallTracker.getCallType());
-        assertEquals(NetworkCapabilities.NET_CAPABILITY_IMS, activeCallTracker.getNetCapability());
-
-        // Test2:
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        assertEquals(QnsConstants.CALL_TYPE_VOICE, activeCallTracker.getCallType());
-        assertEquals(NetworkCapabilities.NET_CAPABILITY_IMS, activeCallTracker.getNetCapability());
-
-        // Test3:
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VT)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        assertEquals(QnsConstants.CALL_TYPE_VIDEO, activeCallTracker.getCallType());
-        assertEquals(NetworkCapabilities.NET_CAPABILITY_IMS, activeCallTracker.getNetCapability());
-
-        // Test4:
-        mTestCallStateList.clear();
-        mCallTracker.updateCallState(mTestCallStateList);
-        assertEquals(QnsConstants.CALL_TYPE_IDLE, activeCallTracker.getCallType());
-        assertEquals(QnsConstants.INVALID_VALUE, activeCallTracker.getNetCapability());
-    }
-
-    @Test
-    public void testForActiveCallTrackerGetQualityLevel() {
-        PreciseDataConnectionState imsDataStatusOnWwan =
-                new PreciseDataConnectionState.Builder()
-                        .setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WWAN)
-                        .setState(TelephonyManager.DATA_CONNECTED)
-                        .setNetworkType(TelephonyManager.NETWORK_TYPE_LTE)
-                        .setApnSetting(
-                                new ApnSetting.Builder()
-                                        .setApnTypeBitmask(ApnSetting.TYPE_IMS)
-                                        .setApnName("ims")
-                                        .setEntryName("ims")
-                                        .build())
-                        .build();
-
-        PreciseDataConnectionState imsDataStatusOnWlan =
-                new PreciseDataConnectionState.Builder()
-                        .setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WLAN)
-                        .setState(TelephonyManager.DATA_CONNECTED)
-                        .setNetworkType(TelephonyManager.NETWORK_TYPE_IWLAN)
-                        .setApnSetting(
-                                new ApnSetting.Builder()
-                                        .setApnTypeBitmask(ApnSetting.TYPE_IMS)
-                                        .setApnName("ims")
-                                        .setEntryName("ims")
-                                        .build())
-                        .build();
-
-        when(mMockQnsTelephonyListener.getLastPreciseDataConnectionState(
-                NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(imsDataStatusOnWlan);
-
-        // Test1:
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_INCOMING)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        QnsCallStatusTracker.ActiveCallTracker activeCallTracker =
-                mCallTracker.getActiveCallTracker();
-        assertNotNull(activeCallTracker);
-        assertEquals(QnsConstants.CALL_TYPE_VOICE, activeCallTracker.getCallType());
-        assertEquals(NetworkCapabilities.NET_CAPABILITY_IMS, activeCallTracker.getNetCapability());
-
-        // Test2:
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        assertEquals(QnsConstants.CALL_TYPE_VOICE, activeCallTracker.getCallType());
-        assertEquals(NetworkCapabilities.NET_CAPABILITY_IMS, activeCallTracker.getNetCapability());
-        assertEquals(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN, activeCallTracker.getTransportType());
-        // check TransportQuality is assigned for the current transport type.
-        TransportQuality transportQuality =
-                activeCallTracker.getLastTransportQuality(activeCallTracker.getTransportType());
-        assertEquals(activeCallTracker.getTransportType(), transportQuality.mTransportType);
-        assertNotNull(transportQuality.mCallQualityBlockList);
-        transportQuality.mLowRtpQualityReportedTime = -1;
-
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL)
-                .setCallQuality(new CallQuality.Builder()
-                        .setUplinkCallQualityLevel(CallQuality.CALL_QUALITY_FAIR)
-                        .setDownlinkCallQualityLevel(CallQuality.CALL_QUALITY_GOOD).build())
-                .build());
-        long firstCallQaulityUpdateTime = 10000;
-        lenient().when(QnsUtils.getSystemElapsedRealTime()).thenReturn(firstCallQaulityUpdateTime);
-        mCallTracker.updateCallState(mTestCallStateList);
-        mTestLooper.dispatchAll();
-
-        transportQuality =
-                activeCallTracker.getLastTransportQuality(activeCallTracker.getTransportType());
-        assertNull(activeCallTracker
-                .getLastTransportQuality(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-        assertEquals(1, transportQuality.mCallQualityBlockList.size());
-        CallQualityBlock qualityBlock = transportQuality.mCallQualityBlockList.get(0);
-        assertEquals(firstCallQaulityUpdateTime, qualityBlock.mCreatedElapsedTime);
-        assertEquals(CallQuality.CALL_QUALITY_FAIR, qualityBlock.mUpLinkLevel);
-        assertEquals(CallQuality.CALL_QUALITY_GOOD, qualityBlock.mDownLinkLevel);
-
-        long testTime = 15000;
-        lenient().when(QnsUtils.getSystemElapsedRealTime()).thenReturn(testTime);
-        assertEquals((testTime - firstCallQaulityUpdateTime) * qualityBlock.mUpLinkLevel,
-                qualityBlock.getUpLinkQualityVolume());
-        assertEquals((testTime - firstCallQaulityUpdateTime) * qualityBlock.mDownLinkLevel,
-                qualityBlock.getDownLinkQualityVolume());
-
-        long handoverTime = 20000;
-        lenient().when(QnsUtils.getSystemElapsedRealTime()).thenReturn(handoverTime);
-        activeCallTracker.onDataConnectionStatusChanged(imsDataStatusOnWwan);
-        TransportQuality oldTransportQuality =
-                activeCallTracker.getLastTransportQuality(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        TransportQuality newTransportQuality =
-                activeCallTracker.getLastTransportQuality(activeCallTracker.getTransportType());
-        assertEquals(1, oldTransportQuality.mCallQualityBlockList.size());
-        CallQualityBlock oldQualityBlock = oldTransportQuality.getLastCallQualityBlock();
-        CallQualityBlock newQualityBlock = newTransportQuality.getLastCallQualityBlock();
-        assertEquals(firstCallQaulityUpdateTime, oldQualityBlock.mCreatedElapsedTime);
-        assertEquals(
-                handoverTime - firstCallQaulityUpdateTime, oldQualityBlock.mDurationMillis);
-        assertEquals(CallQuality.CALL_QUALITY_FAIR, oldQualityBlock.mUpLinkLevel);
-        assertEquals(CallQuality.CALL_QUALITY_GOOD, oldQualityBlock.mDownLinkLevel);
-
-        assertEquals(1, newTransportQuality.mCallQualityBlockList.size());
-        assertEquals(handoverTime, newQualityBlock.mCreatedElapsedTime);
-        assertEquals(0, newQualityBlock.mDurationMillis);
-        assertEquals(CallQuality.CALL_QUALITY_FAIR, newQualityBlock.mUpLinkLevel);
-        assertEquals(CallQuality.CALL_QUALITY_GOOD, newQualityBlock.mDownLinkLevel);
-
-        long testTime2 = 22000;
-        lenient().when(QnsUtils.getSystemElapsedRealTime()).thenReturn(testTime2);
-        assertEquals((handoverTime - firstCallQaulityUpdateTime)
-                * oldQualityBlock.mUpLinkLevel, oldQualityBlock.getUpLinkQualityVolume());
-        assertEquals((handoverTime - firstCallQaulityUpdateTime)
-                * oldQualityBlock.mDownLinkLevel, oldQualityBlock.getDownLinkQualityVolume());
-        assertEquals((testTime2 - handoverTime) * newQualityBlock.mUpLinkLevel,
-                newQualityBlock.getUpLinkQualityVolume());
-        assertEquals((testTime2 - handoverTime) * newQualityBlock.mDownLinkLevel,
-                newQualityBlock.getDownLinkQualityVolume());
-
-        long secondCallQualityUpdateTime = 25000;
-        lenient().when(QnsUtils.getSystemElapsedRealTime()).thenReturn(secondCallQualityUpdateTime);
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL)
-                .setCallQuality(new CallQuality.Builder()
-                        .setUplinkCallQualityLevel(CallQuality.CALL_QUALITY_GOOD)
-                        .setDownlinkCallQualityLevel(CallQuality.CALL_QUALITY_FAIR).build())
-                .build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        mTestLooper.dispatchAll();
-        TransportQuality testTransportQuality =
-                activeCallTracker.getLastTransportQuality(activeCallTracker.getTransportType());
-        assertEquals(2, newTransportQuality.mCallQualityBlockList.size());
-        CallQualityBlock prev = testTransportQuality.mCallQualityBlockList.get(0);
-        assertEquals(CallQuality.CALL_QUALITY_FAIR, prev.mUpLinkLevel);
-        assertEquals(CallQuality.CALL_QUALITY_GOOD, prev.mDownLinkLevel);
-        assertEquals(handoverTime, prev.mCreatedElapsedTime);
-        assertEquals(secondCallQualityUpdateTime - handoverTime, prev.mDurationMillis);
-
-        newQualityBlock = testTransportQuality.getLastCallQualityBlock();
-        assertEquals(secondCallQualityUpdateTime, newQualityBlock.mCreatedElapsedTime);
-        assertEquals(0, newQualityBlock.mDurationMillis);
-        assertEquals(CallQuality.CALL_QUALITY_GOOD, newQualityBlock.mUpLinkLevel);
-        assertEquals(CallQuality.CALL_QUALITY_FAIR, newQualityBlock.mDownLinkLevel);
-
-        long handoverTime2 = 30000;
-        lenient().when(QnsUtils.getSystemElapsedRealTime()).thenReturn(handoverTime2);
-        activeCallTracker.onDataConnectionStatusChanged(imsDataStatusOnWlan);
-
-        oldTransportQuality =
-                activeCallTracker.getLastTransportQuality(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        newTransportQuality =
-                activeCallTracker.getLastTransportQuality(activeCallTracker.getTransportType());
-        assertEquals(2, oldTransportQuality.mCallQualityBlockList.size());
-        oldQualityBlock = oldTransportQuality.getLastCallQualityBlock();
-        newQualityBlock = newTransportQuality.getLastCallQualityBlock();
-        assertEquals(secondCallQualityUpdateTime, oldQualityBlock.mCreatedElapsedTime);
-        assertEquals(
-                handoverTime2 - secondCallQualityUpdateTime, oldQualityBlock.mDurationMillis);
-        assertEquals(CallQuality.CALL_QUALITY_GOOD, oldQualityBlock.mUpLinkLevel);
-        assertEquals(CallQuality.CALL_QUALITY_FAIR, oldQualityBlock.mDownLinkLevel);
-
-        assertEquals(1, newTransportQuality.mCallQualityBlockList.size());
-        assertEquals(handoverTime2, newQualityBlock.mCreatedElapsedTime);
-        assertEquals(0, newQualityBlock.mDurationMillis);
-        assertEquals(CallQuality.CALL_QUALITY_GOOD, newQualityBlock.mUpLinkLevel);
-        assertEquals(CallQuality.CALL_QUALITY_FAIR, newQualityBlock.mDownLinkLevel);
-
-        // Test3:
-        long callEndTime = 40000;
-        lenient().when(QnsUtils.getSystemElapsedRealTime()).thenReturn(callEndTime);
-        mTestCallStateList.clear();
-        mCallTracker.updateCallState(mTestCallStateList);
-        assertEquals(QnsConstants.CALL_TYPE_IDLE, activeCallTracker.getCallType());
-        assertEquals(QnsConstants.INVALID_VALUE, activeCallTracker.getNetCapability());
-
-        oldTransportQuality = activeCallTracker.getLastTransportQuality(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        assertEquals(1, oldTransportQuality.mCallQualityBlockList.size());
-        oldQualityBlock = oldTransportQuality.getLastCallQualityBlock();
-        assertEquals(handoverTime2, oldQualityBlock.mCreatedElapsedTime);
-        assertEquals(
-                callEndTime - handoverTime2, oldQualityBlock.mDurationMillis);
-        assertEquals(CallQuality.CALL_QUALITY_GOOD, oldQualityBlock.mUpLinkLevel);
-        assertEquals(CallQuality.CALL_QUALITY_FAIR, oldQualityBlock.mDownLinkLevel);
-
-        List<TransportQuality> wlanTransportQualityList =
-                activeCallTracker.getTransportQualityList(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        List<TransportQuality> wwanTransportQualityList =
-                activeCallTracker.getTransportQualityList(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        assertEquals(2, wlanTransportQualityList.size());
-        assertEquals(1, wwanTransportQualityList.size());
-        long expectedUplinkQualityLevelWlan =
-                ((handoverTime - firstCallQaulityUpdateTime) * CallQuality.CALL_QUALITY_FAIR
-                + (callEndTime - handoverTime2) * CallQuality.CALL_QUALITY_GOOD)
-                / ((handoverTime - firstCallQaulityUpdateTime)
-                    + (callEndTime - handoverTime2));
-        assertEquals(expectedUplinkQualityLevelWlan, activeCallTracker
-                .getUpLinkQualityLevelDuringCall(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        long expectedDownLinkQualityLevelWlan =
-                ((handoverTime - firstCallQaulityUpdateTime) * CallQuality.CALL_QUALITY_GOOD
-                        + (callEndTime - handoverTime2) * CallQuality.CALL_QUALITY_FAIR)
-                        / ((handoverTime - firstCallQaulityUpdateTime)
-                        + (callEndTime - handoverTime2));
-        assertEquals(expectedDownLinkQualityLevelWlan, activeCallTracker
-                .getDownLinkQualityLevelDuringCall(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-    }
-
-    @Test
-    public void testMediaQualityBreachedWithJitter() {
-        QnsCarrierConfigManager.RtpMetricsConfig config =
-                new QnsCarrierConfigManager.RtpMetricsConfig(120, 30, 5, 10);
-        when(mMockQnsConfigManager.getRTPMetricsData()).thenReturn(config);
-
-        PreciseDataConnectionState imsDataStatusOnWlan =
-                new PreciseDataConnectionState.Builder()
-                        .setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WLAN)
-                        .setState(TelephonyManager.DATA_CONNECTED)
-                        .setNetworkType(TelephonyManager.NETWORK_TYPE_IWLAN)
-                        .setApnSetting(
-                                new ApnSetting.Builder()
-                                        .setApnTypeBitmask(ApnSetting.TYPE_IMS)
-                                        .setApnName("ims")
-                                        .setEntryName("ims")
-                                        .build())
-                        .build();
-
-        when(mMockQnsTelephonyListener.getLastPreciseDataConnectionState(
-                NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(imsDataStatusOnWlan);
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_INCOMING)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        QnsCallStatusTracker.ActiveCallTracker activeCallTracker =
-                mCallTracker.getActiveCallTracker();
-        assertNotNull(activeCallTracker);
-        assertEquals(QnsConstants.CALL_TYPE_VOICE, activeCallTracker.getCallType());
-        assertEquals(NetworkCapabilities.NET_CAPABILITY_IMS, activeCallTracker.getNetCapability());
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        assertEquals(QnsConstants.CALL_TYPE_VOICE, activeCallTracker.getCallType());
-        assertEquals(NetworkCapabilities.NET_CAPABILITY_IMS, activeCallTracker.getNetCapability());
-
-        MediaQualityStatus status =
-                new MediaQualityStatus(
-                        "1", MediaQualityStatus.MEDIA_SESSION_TYPE_AUDIO,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        10 /*packetLossRate*/, 130 /*jitter*/, 0 /*inactivityTime*/);
-        activeCallTracker.onMediaQualityStatusChanged(status);
-        mTestLooper.dispatchAll();
-        Message msg = mLowQualityListenerLooper.nextMessage();
-        assertNotNull(msg);
-        assertEquals(mLowQualityHandler, msg.getTarget());
-        QnsAsyncResult result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(1 << QnsConstants.RTP_LOW_QUALITY_REASON_JITTER, (int) result.mResult);
-    }
-
-    @Test
-    public void testMediaQualityBreachedWithNoRtp() {
-        QnsCarrierConfigManager.RtpMetricsConfig config =
-                new QnsCarrierConfigManager.RtpMetricsConfig(120, 30, 5, 10000);
-        when(mMockQnsConfigManager.getRTPMetricsData()).thenReturn(config);
-
-        PreciseDataConnectionState emergencyDataStatusOnWwan =
-                new PreciseDataConnectionState.Builder()
-                        .setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WWAN)
-                        .setState(TelephonyManager.DATA_CONNECTED)
-                        .setNetworkType(TelephonyManager.NETWORK_TYPE_LTE)
-                        .setApnSetting(
-                                new ApnSetting.Builder()
-                                        .setApnTypeBitmask(ApnSetting.TYPE_EMERGENCY)
-                                        .setApnName("sos")
-                                        .setEntryName("sos")
-                                        .build())
-                        .build();
-
-        when(mMockQnsTelephonyListener.getLastPreciseDataConnectionState(
-                NetworkCapabilities.NET_CAPABILITY_EIMS))
-                .thenReturn(emergencyDataStatusOnWwan);
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ALERTING)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_EMERGENCY).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        QnsCallStatusTracker.ActiveCallTracker activeCallTracker =
-                mCallTracker.getActiveCallTracker();
-        assertNotNull(activeCallTracker);
-        assertEquals(QnsConstants.CALL_TYPE_IDLE, activeCallTracker.getCallType());
-        assertEquals(QnsConstants.INVALID_VALUE, activeCallTracker.getNetCapability());
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_EMERGENCY).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        assertEquals(QnsConstants.CALL_TYPE_EMERGENCY, activeCallTracker.getCallType());
-        assertEquals(NetworkCapabilities.NET_CAPABILITY_EIMS, activeCallTracker.getNetCapability());
-
-        MediaQualityStatus status =
-                new MediaQualityStatus(
-                        "1", MediaQualityStatus.MEDIA_SESSION_TYPE_AUDIO,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        10 /*packetLossRate*/, 70 /*jitter*/, 11000 /*inactivityTime*/);
-        activeCallTracker.onMediaQualityStatusChanged(status);
-        mTestLooper.dispatchAll();
-        Message msg = mLowQualityListenerLooper.nextMessage();
-        assertNotNull(msg);
-        assertEquals(mLowQualityHandler, msg.getTarget());
-        QnsAsyncResult result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(1 << QnsConstants.RTP_LOW_QUALITY_REASON_NO_RTP, (int) result.mResult);
-    }
-
-    @Test
-    public void testMediaQualityBreachedWithPacketLoss() {
-        QnsCarrierConfigManager.RtpMetricsConfig config =
-                new QnsCarrierConfigManager.RtpMetricsConfig(120, 30, 5000, 10000);
-        when(mMockQnsConfigManager.getRTPMetricsData()).thenReturn(config);
-
-        PreciseDataConnectionState emergencyDataStatusOnWwan =
-                new PreciseDataConnectionState.Builder()
-                        .setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WWAN)
-                        .setState(TelephonyManager.DATA_CONNECTED)
-                        .setNetworkType(TelephonyManager.NETWORK_TYPE_LTE)
-                        .setApnSetting(
-                                new ApnSetting.Builder()
-                                        .setApnTypeBitmask(ApnSetting.TYPE_EMERGENCY)
-                                        .setApnName("sos")
-                                        .setEntryName("sos")
-                                        .build())
-                        .build();
-
-        when(mMockQnsTelephonyListener.getLastPreciseDataConnectionState(
-                NetworkCapabilities.NET_CAPABILITY_EIMS))
-                .thenReturn(emergencyDataStatusOnWwan);
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ALERTING)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_EMERGENCY).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        QnsCallStatusTracker.ActiveCallTracker activeCallTracker =
-                mCallTracker.getActiveCallTracker();
-        assertNotNull(activeCallTracker);
-        assertEquals(QnsConstants.CALL_TYPE_IDLE, activeCallTracker.getCallType());
-        assertEquals(QnsConstants.INVALID_VALUE, activeCallTracker.getNetCapability());
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_EMERGENCY).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        assertEquals(QnsConstants.CALL_TYPE_EMERGENCY, activeCallTracker.getCallType());
-        assertEquals(NetworkCapabilities.NET_CAPABILITY_EIMS, activeCallTracker.getNetCapability());
-
-        MediaQualityStatus status =
-                new MediaQualityStatus(
-                        "1", MediaQualityStatus.MEDIA_SESSION_TYPE_AUDIO,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        35 /*packetLossRate*/, 70 /*jitter*/, 7000 /*inactivityTime*/);
-        activeCallTracker.onMediaQualityStatusChanged(status);
-        mTestLooper.dispatchAll();
-        Message msg = mLowQualityListenerLooper.nextMessage();
-        assertNull(msg);
-        mTestLooper.moveTimeForward(config.mPktLossTime - 1000);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNull(msg);
-        mTestLooper.moveTimeForward(2000);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNotNull(msg);
-        assertEquals(mLowQualityHandler, msg.getTarget());
-        QnsAsyncResult result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(
-                1 << QnsConstants.RTP_LOW_QUALITY_REASON_PACKET_LOSS, (int) result.mResult);
-    }
-
-    @Test
-    public void testMediaQualityBreachedWithPacketLossAdvanced() {
-        QnsCarrierConfigManager.RtpMetricsConfig config =
-                new QnsCarrierConfigManager.RtpMetricsConfig(120, 30, 12000, 10000);
-        when(mMockQnsConfigManager.getRTPMetricsData()).thenReturn(config);
-
-        PreciseDataConnectionState emergencyDataStatusOnWwan =
-                new PreciseDataConnectionState.Builder()
-                        .setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WWAN)
-                        .setState(TelephonyManager.DATA_CONNECTED)
-                        .setNetworkType(TelephonyManager.NETWORK_TYPE_LTE)
-                        .setApnSetting(
-                                new ApnSetting.Builder()
-                                        .setApnTypeBitmask(ApnSetting.TYPE_EMERGENCY)
-                                        .setApnName("sos")
-                                        .setEntryName("sos")
-                                        .build())
-                        .build();
-
-        when(mMockQnsTelephonyListener.getLastPreciseDataConnectionState(
-                NetworkCapabilities.NET_CAPABILITY_EIMS))
-                .thenReturn(emergencyDataStatusOnWwan);
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ALERTING)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_EMERGENCY).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        QnsCallStatusTracker.ActiveCallTracker activeCallTracker =
-                mCallTracker.getActiveCallTracker();
-        assertNotNull(activeCallTracker);
-        assertEquals(QnsConstants.CALL_TYPE_IDLE, activeCallTracker.getCallType());
-        assertEquals(QnsConstants.INVALID_VALUE, activeCallTracker.getNetCapability());
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_EMERGENCY).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        assertEquals(QnsConstants.CALL_TYPE_EMERGENCY, activeCallTracker.getCallType());
-        assertEquals(NetworkCapabilities.NET_CAPABILITY_EIMS, activeCallTracker.getNetCapability());
-
-        MediaQualityStatus status =
-                new MediaQualityStatus(
-                        "1", MediaQualityStatus.MEDIA_SESSION_TYPE_AUDIO,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        35 /*packetLossRate*/, 70 /*jitter*/, 7000 /*inactivityTime*/);
-        activeCallTracker.onMediaQualityStatusChanged(status);
-        mTestLooper.dispatchAll();
-        Message msg = mLowQualityListenerLooper.nextMessage();
-        assertNull(msg);
-        mTestLooper.moveTimeForward(config.mPktLossTime / 3);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNull(msg);
-
-        status =
-                new MediaQualityStatus(
-                        "1", MediaQualityStatus.MEDIA_SESSION_TYPE_AUDIO,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        10 /*packetLossRate*/, 70 /*jitter*/, 0 /*inactivityTime*/);
-        activeCallTracker.onMediaQualityStatusChanged(status);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNull(msg);
-        mTestLooper.moveTimeForward(4000);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNotNull(msg);
-        assertEquals(mLowQualityHandler, msg.getTarget());
-        QnsAsyncResult result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(0, (int) result.mResult);
-
-        status =
-                new MediaQualityStatus(
-                        "1", MediaQualityStatus.MEDIA_SESSION_TYPE_AUDIO,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        33 /*packetLossRate*/, 70 /*jitter*/, 7000 /*inactivityTime*/);
-        activeCallTracker.onMediaQualityStatusChanged(status);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNull(msg);
-        mTestLooper.moveTimeForward(config.mPktLossTime / 3);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNull(msg);
-
-        status =
-                new MediaQualityStatus(
-                        "1", MediaQualityStatus.MEDIA_SESSION_TYPE_AUDIO,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        10 /*packetLossRate*/, 70 /*jitter*/, 0 /*inactivityTime*/);
-        activeCallTracker.onMediaQualityStatusChanged(status);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNull(msg);
-        mTestLooper.moveTimeForward(2000);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNull(msg);
-
-        status =
-                new MediaQualityStatus(
-                        "1", MediaQualityStatus.MEDIA_SESSION_TYPE_AUDIO,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        33 /*packetLossRate*/, 70 /*jitter*/, 7000 /*inactivityTime*/);
-        activeCallTracker.onMediaQualityStatusChanged(status);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNull(msg);
-        mTestLooper.moveTimeForward(config.mPktLossTime * 2 / 3);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNotNull(msg);
-        assertEquals(mLowQualityHandler, msg.getTarget());
-        result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(
-                1 << QnsConstants.RTP_LOW_QUALITY_REASON_PACKET_LOSS, (int) result.mResult);
-    }
-
-    @Test
-    public void testHandlingLowQualityEventAtHandover() {
-        QnsCarrierConfigManager.RtpMetricsConfig config =
-                new QnsCarrierConfigManager.RtpMetricsConfig(120, 30, 12000, 10000);
-        when(mMockQnsConfigManager.getRTPMetricsData()).thenReturn(config);
-        PreciseDataConnectionState imsDataStatusOnWlan =
-                new PreciseDataConnectionState.Builder()
-                        .setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WLAN)
-                        .setState(TelephonyManager.DATA_CONNECTED)
-                        .setNetworkType(TelephonyManager.NETWORK_TYPE_IWLAN)
-                        .setApnSetting(
-                                new ApnSetting.Builder()
-                                        .setApnTypeBitmask(ApnSetting.TYPE_EMERGENCY)
-                                        .setApnName("ims")
-                                        .setEntryName("ims")
-                                        .build())
-                        .build();
-        PreciseDataConnectionState imsDataStatusOnWwan =
-                new PreciseDataConnectionState.Builder()
-                        .setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WWAN)
-                        .setState(TelephonyManager.DATA_CONNECTED)
-                        .setNetworkType(TelephonyManager.NETWORK_TYPE_LTE)
-                        .setApnSetting(
-                                new ApnSetting.Builder()
-                                        .setApnTypeBitmask(ApnSetting.TYPE_EMERGENCY)
-                                        .setApnName("ims")
-                                        .setEntryName("ims")
-                                        .build())
-                        .build();
-        when(mMockQnsTelephonyListener.getLastPreciseDataConnectionState(
-                NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(imsDataStatusOnWwan);
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_DIALING)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        QnsCallStatusTracker.ActiveCallTracker activeCallTracker =
-                mCallTracker.getActiveCallTracker();
-        assertNotNull(activeCallTracker);
-        assertEquals(QnsConstants.CALL_TYPE_VOICE, activeCallTracker.getCallType());
-        assertEquals(NetworkCapabilities.NET_CAPABILITY_IMS, activeCallTracker.getNetCapability());
-        mTestCallStateList.clear();
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        assertEquals(QnsConstants.CALL_TYPE_VOICE, activeCallTracker.getCallType());
-        assertEquals(NetworkCapabilities.NET_CAPABILITY_IMS, activeCallTracker.getNetCapability());
-
-        MediaQualityStatus status =
-                new MediaQualityStatus(
-                        "1", MediaQualityStatus.MEDIA_SESSION_TYPE_AUDIO,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        35 /*packetLossRate*/, 70 /*jitter*/, 0 /*inactivityTime*/);
-        activeCallTracker.onMediaQualityStatusChanged(status);
-        mTestLooper.dispatchAll();
-        Message msg = mLowQualityListenerLooper.nextMessage();
-        assertNull(msg);
-        mTestLooper.moveTimeForward(4000);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNull(msg);
-
-        activeCallTracker.onDataConnectionStatusChanged(imsDataStatusOnWlan);
-
-        mTestLooper.moveTimeForward(10000);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNull(msg);
-
-        mTestLooper.moveTimeForward(2500);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNotNull(msg);
-        assertEquals(mLowQualityHandler, msg.getTarget());
-        QnsAsyncResult result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(
-                1 << QnsConstants.RTP_LOW_QUALITY_REASON_PACKET_LOSS, (int) result.mResult);
-
-        mTestLooper.moveTimeForward(1000);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNull(msg);
-        activeCallTracker.onDataConnectionStatusChanged(imsDataStatusOnWlan);
-        mTestLooper.moveTimeForward(1000);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNull(msg);
-
-        status =
-                new MediaQualityStatus(
-                        "1", MediaQualityStatus.MEDIA_SESSION_TYPE_AUDIO,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        5 /*packetLossRate*/, 20 /*jitter*/, 0 /*inactivityTime*/);
-        activeCallTracker.onMediaQualityStatusChanged(status);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNull(msg);
-        mTestLooper.moveTimeForward(2100);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNull(msg);
-        mTestLooper.moveTimeForward(3100);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNotNull(msg);
-        assertEquals(mLowQualityHandler, msg.getTarget());
-        result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(0, (int) result.mResult);
-
-        mTestLooper.moveTimeForward(10000);
-        mTestLooper.dispatchAll();
-        status =
-                new MediaQualityStatus(
-                        "1", MediaQualityStatus.MEDIA_SESSION_TYPE_AUDIO,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        100 /*packetLossRate*/, 20 /*jitter*/, 11000 /*inactivityTime*/);
-        activeCallTracker.onMediaQualityStatusChanged(status);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNotNull(msg);
-        assertEquals(mLowQualityHandler, msg.getTarget());
-        result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals((1 << QnsConstants.RTP_LOW_QUALITY_REASON_NO_RTP)
-                + (1 << QnsConstants.RTP_LOW_QUALITY_REASON_PACKET_LOSS), (int) result.mResult);
-
-        status =
-                new MediaQualityStatus(
-                        "1", MediaQualityStatus.MEDIA_SESSION_TYPE_AUDIO,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        12 /*packetLossRate*/, 20 /*jitter*/, 0 /*inactivityTime*/);
-        activeCallTracker.onMediaQualityStatusChanged(status);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNull(msg);
-        mTestLooper.moveTimeForward(2000);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNull(msg);
-
-        activeCallTracker.onDataConnectionStatusChanged(imsDataStatusOnWwan);
-        mTestLooper.moveTimeForward(2000);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNull(msg);
-        mTestLooper.moveTimeForward(1100);
-        mTestLooper.dispatchAll();
-        msg = mLowQualityListenerLooper.nextMessage();
-        assertNotNull(msg);
-        assertEquals(mLowQualityHandler, msg.getTarget());
-        result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(0, (int) result.mResult);
-    }
-
-    @Test
-    public void testOnSrvccStateChanged() {
-        mTestCallStateList.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_EMERGENCY).build());
-        mCallTracker.updateCallState(mTestCallStateList);
-        Message msg = mTestLooperListener.nextMessage();
-        assertNotNull(msg);
-        assertEquals(mEmergencyHandler, msg.getTarget());
-        QnsAsyncResult result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(QnsConstants.CALL_TYPE_EMERGENCY, (int) result.mResult);
-        mCallTracker.onSrvccStateChangedInternal(TelephonyManager.SRVCC_STATE_HANDOVER_COMPLETED);
-        msg = mTestLooperListener.nextMessage();
-        assertNotNull(msg);
-        result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result.mResult);
-        assertEquals(QnsConstants.CALL_TYPE_IDLE, (int) result.mResult);
-
-        mCallTracker.onSrvccStateChangedInternal(TelephonyManager.SRVCC_STATE_HANDOVER_STARTED);
-        msg = mTestLooperListener.nextMessage();
-        assertNull(msg);
-    }
-
-    @Test
-    public void isIdleState() {
-        mTestCallStateList.clear();
-        mCallTracker.updateCallState(mTestCallStateList);
-        assertTrue(mCallTracker.isCallIdle());
-    }
-
-    @Test
-    public void testThresholdBreached() {
-        QnsCarrierConfigManager.RtpMetricsConfig config =
-                new QnsCarrierConfigManager.RtpMetricsConfig(120, 30, 12000, 10000);
-        when(mMockQnsConfigManager.getRTPMetricsData()).thenReturn(config);
-
-        MediaQualityStatus status =
-                new MediaQualityStatus(
-                        "1", MediaQualityStatus.MEDIA_SESSION_TYPE_AUDIO,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        30 /*packetLossRate*/, 0 /*jitter*/, 0 /*inactivityTime*/);
-        assertEquals(1 << QnsConstants.RTP_LOW_QUALITY_REASON_PACKET_LOSS,
-                mCallTracker.getActiveCallTracker().thresholdBreached(status));
-        status =
-                new MediaQualityStatus(
-                        "1", MediaQualityStatus.MEDIA_SESSION_TYPE_AUDIO,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        29 /*packetLossRate*/, 0 /*jitter*/, 0 /*inactivityTime*/);
-        assertEquals(0, mCallTracker.getActiveCallTracker().thresholdBreached(status));
-
-        status =
-                new MediaQualityStatus(
-                        "1", MediaQualityStatus.MEDIA_SESSION_TYPE_AUDIO,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        0 /*packetLossRate*/, 120 /*jitter*/, 0 /*inactivityTime*/);
-        assertEquals(1 << QnsConstants.RTP_LOW_QUALITY_REASON_JITTER,
-                mCallTracker.getActiveCallTracker().thresholdBreached(status));
-        status =
-                new MediaQualityStatus(
-                        "1", MediaQualityStatus.MEDIA_SESSION_TYPE_AUDIO,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        0 /*packetLossRate*/, 119 /*jitter*/, 0 /*inactivityTime*/);
-        assertEquals(0, mCallTracker.getActiveCallTracker().thresholdBreached(status));
-
-        status =
-                new MediaQualityStatus(
-                        "1", MediaQualityStatus.MEDIA_SESSION_TYPE_AUDIO,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        0 /*packetLossRate*/, 0 /*jitter*/, 10000 /*inactivityTime*/);
-        assertEquals(1 << QnsConstants.RTP_LOW_QUALITY_REASON_NO_RTP,
-                mCallTracker.getActiveCallTracker().thresholdBreached(status));
-        status =
-                new MediaQualityStatus(
-                        "1", MediaQualityStatus.MEDIA_SESSION_TYPE_AUDIO,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        9 /*packetLossRate*/, 0 /*jitter*/, 9999 /*inactivityTime*/);
-        assertEquals(0, mCallTracker.getActiveCallTracker().thresholdBreached(status));
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsCarrierConfigManagerTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsCarrierConfigManagerTest.java
deleted file mode 100644
index f39ea40..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsCarrierConfigManagerTest.java
+++ /dev/null
@@ -1,2409 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static android.hardware.radio.network.SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRQ;
-import static android.hardware.radio.network.SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI;
-import static android.hardware.radio.network.SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR;
-import static android.hardware.radio.network.SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSRSRQ;
-import static android.telephony.AccessNetworkConstants.TRANSPORT_TYPE_INVALID;
-import static android.telephony.AccessNetworkConstants.TRANSPORT_TYPE_WLAN;
-import static android.telephony.AccessNetworkConstants.TRANSPORT_TYPE_WWAN;
-import static android.telephony.SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSCP;
-import static android.telephony.SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP;
-import static android.telephony.SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSRSRP;
-import static android.telephony.SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_SSSINR;
-import static android.telephony.SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_UNKNOWN;
-
-import static com.android.telephony.qns.QnsCarrierConfigManager.KEY_QNS_ALLOW_VIDEO_OVER_IWLAN_WITH_CELLULAR_LIMITED_CASE_BOOL;
-import static com.android.telephony.qns.QnsCarrierConfigManager.KEY_SIP_DIALOG_SESSION_POLICY_INT;
-import static com.android.telephony.qns.QnsConstants.CALL_TYPE_IDLE;
-import static com.android.telephony.qns.QnsConstants.CALL_TYPE_VIDEO;
-import static com.android.telephony.qns.QnsConstants.CALL_TYPE_VOICE;
-import static com.android.telephony.qns.QnsConstants.CELL_PREF;
-import static com.android.telephony.qns.QnsConstants.KEY_DEFAULT_THRESHOLD_RSCP_BAD;
-import static com.android.telephony.qns.QnsConstants.KEY_DEFAULT_THRESHOLD_RSCP_GOOD;
-import static com.android.telephony.qns.QnsConstants.KEY_DEFAULT_THRESHOLD_RSRP_GOOD;
-import static com.android.telephony.qns.QnsConstants.KEY_DEFAULT_THRESHOLD_SSRSRP_BAD;
-import static com.android.telephony.qns.QnsConstants.KEY_DEFAULT_THRESHOLD_SSRSRP_GOOD;
-import static com.android.telephony.qns.QnsConstants.POLICY_BAD;
-import static com.android.telephony.qns.QnsConstants.POLICY_GOOD;
-import static com.android.telephony.qns.QnsConstants.POLICY_TOLERABLE;
-import static com.android.telephony.qns.QnsConstants.WIFI_ONLY;
-import static com.android.telephony.qns.QnsConstants.WIFI_PREF;
-import static com.android.telephony.qns.wfc.WfcCarrierConfigManager.CONFIG_DEFAULT_VOWIFI_REGISTATION_TIMER;
-import static com.android.telephony.qns.wfc.WfcCarrierConfigManager.KEY_QNS_VOWIFI_REGISTATION_TIMER_FOR_VOWIFI_ACTIVATION_INT;
-
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.when;
-
-import android.net.NetworkCapabilities;
-import android.os.Handler;
-import android.os.Message;
-import android.os.PersistableBundle;
-import android.os.test.TestLooper;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.CarrierConfigManager;
-import android.telephony.TelephonyManager;
-import android.telephony.ims.ProvisioningManager;
-
-import org.junit.After;
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.MockitoAnnotations;
-
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-@RunWith(JUnit4.class)
-public class QnsCarrierConfigManagerTest extends QnsTest {
-    private static final String HANDOVER_POLICY_0 =
-            "source=EUTRAN, target=IWLAN, type=allowed, capabilities=IMS|eims|MMS|cbs|xcap";
-    private static final String HANDOVER_POLICY_1 =
-            "source=GERAN|UTRAN|NGRAN, target=IWLAN, type=disallowed,"
-                    + " capabilities=IMS|MMS|cbs|xcap";
-    private static final String HANDOVER_POLICY_2 =
-            "source=IWLAN, target=GERAN|UTRAN|EUTRAN|NGRAN, roaming=true, type=disallowed,"
-                    + " capabilities=IMS";
-    private static final String HANDOVER_POLICY_3 =
-            "source=EUTRAN, target=IWLAN, type=allowed, capabilities=ims|eims|mms|CBS|XCAP";
-    private static final String HANDOVER_POLICY_4 =
-            "source=EUTRAN, target=IWLAN, type=disallowed, capabilities=IMS|EIMS|MMS|cbs|xcap";
-    private static final String FALLBACK_RULE0 = "cause=321~378|1503, time=60000, preference=cell";
-    private static final String FALLBACK_RULE1 = "cause=232|267|350~380|1503, time=90000";
-    private Handler mHandler;
-    TestLooper mTestLooper;
-    private CountDownLatch mLatch;
-    protected QnsCarrierConfigManager mConfigManager;
-
-    // To set & validate QNS  Default Value
-    @Before
-    public void setup() throws Exception {
-        MockitoAnnotations.initMocks(this);
-        super.setUp();
-        mTestLooper = new TestLooper();
-        mHandler = new Handler(mTestLooper.getLooper());
-        mLatch = new CountDownLatch(1);
-        when(mMockSubscriptionInfo.getSubscriptionId()).thenReturn(0);
-        mConfigManager = new QnsCarrierConfigManager(sMockContext, mMockQnsEventDispatcher, 0);
-        mConfigManager.loadQnsConfigurations();
-    }
-
-    @Test
-    public void testAllowWFCOnAirplaneModeOnWithDefaultValues() {
-        boolean isWfcOnAirplaneModeAllowed;
-
-        isWfcOnAirplaneModeAllowed = mConfigManager.allowWFCOnAirplaneModeOn();
-        Assert.assertTrue(isWfcOnAirplaneModeAllowed);
-    }
-
-    @Test
-    public void testIsInCallHoDecisionWlanToWwanWithoutVopsCondition() {
-        // Test for the default setting
-        assertFalse(mConfigManager.isInCallHoDecisionWlanToWwanWithoutVopsCondition());
-
-        // Test for a new setting
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putBoolean(
-                QnsCarrierConfigManager
-                        .KEY_IN_CALL_HO_DECISION_WLAN_TO_WWAN_WITHOUT_VOPS_CONDITION_BOOL,
-                true);
-        mConfigManager.loadQnsAneSupportConfigurations(null, bundle);
-        assertTrue(mConfigManager.isInCallHoDecisionWlanToWwanWithoutVopsCondition());
-    }
-
-    @Test
-    public void testIsAccessNetworkAllowedWithDefaultValues() {
-        boolean isAccessNetworkAllowedForRat;
-
-        isAccessNetworkAllowedForRat =
-                mConfigManager.isAccessNetworkAllowed(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        NetworkCapabilities.NET_CAPABILITY_IMS);
-        Assert.assertTrue(isAccessNetworkAllowedForRat);
-
-        isAccessNetworkAllowedForRat =
-                mConfigManager.isAccessNetworkAllowed(
-                        AccessNetworkConstants.AccessNetworkType.NGRAN,
-                        NetworkCapabilities.NET_CAPABILITY_IMS);
-        Assert.assertTrue(isAccessNetworkAllowedForRat);
-
-        isAccessNetworkAllowedForRat =
-                mConfigManager.isAccessNetworkAllowed(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        NetworkCapabilities.NET_CAPABILITY_EIMS);
-        Assert.assertTrue(isAccessNetworkAllowedForRat);
-
-        isAccessNetworkAllowedForRat =
-                mConfigManager.isAccessNetworkAllowed(
-                        AccessNetworkConstants.AccessNetworkType.NGRAN,
-                        NetworkCapabilities.NET_CAPABILITY_EIMS);
-        Assert.assertTrue(isAccessNetworkAllowedForRat);
-
-        isAccessNetworkAllowedForRat =
-                mConfigManager.isAccessNetworkAllowed(
-                        AccessNetworkConstants.AccessNetworkType.GERAN,
-                        NetworkCapabilities.NET_CAPABILITY_IMS);
-        Assert.assertFalse(isAccessNetworkAllowedForRat);
-
-        isAccessNetworkAllowedForRat =
-                mConfigManager.isAccessNetworkAllowed(
-                        AccessNetworkConstants.AccessNetworkType.UTRAN,
-                        NetworkCapabilities.NET_CAPABILITY_MMS);
-        Assert.assertFalse(isAccessNetworkAllowedForRat);
-    }
-
-    @Test
-    public void testIsServiceBarringCheckSupportedWithDefaultValues() {
-        boolean isServiceBarringCheck;
-
-        isServiceBarringCheck = mConfigManager.isServiceBarringCheckSupported();
-        Assert.assertFalse(isServiceBarringCheck);
-    }
-
-    @Test
-    public void testIsGuardTimerHysteresisOnPrefSupportedWithDefaultValues() {
-        boolean isGuardTimerHysteresisOn;
-
-        isGuardTimerHysteresisOn = mConfigManager.isGuardTimerHysteresisOnPrefSupported();
-        Assert.assertFalse(isGuardTimerHysteresisOn);
-    }
-
-    @Test
-    public void testIsHysteresisTimerEnabled() {
-        boolean guardTimerEnabled;
-
-        guardTimerEnabled = mConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_HOME);
-        Assert.assertTrue(guardTimerEnabled);
-        guardTimerEnabled = mConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_ROAM);
-        Assert.assertTrue(guardTimerEnabled);
-        guardTimerEnabled = mConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_BOTH);
-        Assert.assertTrue(guardTimerEnabled);
-
-        // With test bundle
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putInt(
-                QnsCarrierConfigManager.KEY_QNS_IMS_NETWORK_ENABLE_HO_HYSTERESIS_TIMER_INT,
-                QnsConstants.COVERAGE_HOME);
-        mConfigManager.loadQnsAneSupportConfigurations(bundle, null);
-        guardTimerEnabled = mConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_ROAM);
-        Assert.assertFalse(guardTimerEnabled);
-
-        bundle = new PersistableBundle();
-        bundle.putInt(
-                QnsCarrierConfigManager.KEY_QNS_IMS_NETWORK_ENABLE_HO_HYSTERESIS_TIMER_INT,
-                QnsConstants.COVERAGE_ROAM);
-        mConfigManager.loadQnsAneSupportConfigurations(bundle, null);
-        guardTimerEnabled = mConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_HOME);
-        Assert.assertFalse(guardTimerEnabled);
-
-        bundle = new PersistableBundle();
-        bundle.putInt(
-                QnsCarrierConfigManager.KEY_QNS_IMS_NETWORK_ENABLE_HO_HYSTERESIS_TIMER_INT,
-                QnsConstants.COVERAGE_ROAM);
-        mConfigManager.loadAnspCarrierSupportConfigs(bundle, null);
-        guardTimerEnabled = mConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_ROAM);
-        Assert.assertTrue(guardTimerEnabled);
-
-        bundle = new PersistableBundle();
-        bundle.putInt(
-                QnsCarrierConfigManager.KEY_QNS_IMS_NETWORK_ENABLE_HO_HYSTERESIS_TIMER_INT,
-                QnsConstants.COVERAGE_HOME);
-        mConfigManager.loadQnsAneSupportConfigurations(bundle, null);
-        guardTimerEnabled = mConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_HOME);
-        Assert.assertTrue(guardTimerEnabled);
-    }
-
-    @Test
-    public void testIsTransportTypeSelWithoutSSInRoamSupportedWithDefaultValues() {
-        boolean isTransportTypeInRoamWithoutSS;
-
-        isTransportTypeInRoamWithoutSS =
-                mConfigManager.isTransportTypeSelWithoutSSInRoamSupported();
-        Assert.assertFalse(isTransportTypeInRoamWithoutSS);
-    }
-
-    @Test
-    public void testIsChooseWfcPreferredTransportInBothBadConditionWithDefaultValues() {
-        boolean isChooseWfcPreferredTransport;
-
-        isChooseWfcPreferredTransport =
-                mConfigManager.isChooseWfcPreferredTransportInBothBadCondition(
-                        QnsConstants.WIFI_PREF);
-        Assert.assertFalse(isChooseWfcPreferredTransport);
-
-        isChooseWfcPreferredTransport =
-                mConfigManager.isChooseWfcPreferredTransportInBothBadCondition(
-                        QnsConstants.CELL_PREF);
-        Assert.assertFalse(isChooseWfcPreferredTransport);
-    }
-
-    @Test
-    public void testIsChooseWfcPreferredTransportInBothBadConditionWithTestBundle() {
-        PersistableBundle bundle = new PersistableBundle();
-        boolean isChooseWfcPreferredTransport;
-        bundle.putIntArray(
-                QnsCarrierConfigManager
-                        .KEY_CHOOSE_WFC_PREFERRED_TRANSPORT_IN_BOTH_BAD_CONDITION_INT_ARRAY,
-                new int[] {1, 2});
-        mConfigManager.loadAnspCarrierSupportConfigs(bundle, null);
-
-        isChooseWfcPreferredTransport =
-                mConfigManager.isChooseWfcPreferredTransportInBothBadCondition(
-                        QnsConstants.WIFI_PREF);
-        Assert.assertTrue(isChooseWfcPreferredTransport);
-
-        isChooseWfcPreferredTransport =
-                mConfigManager.isChooseWfcPreferredTransportInBothBadCondition(
-                        QnsConstants.CELL_PREF);
-        Assert.assertTrue(isChooseWfcPreferredTransport);
-
-        isChooseWfcPreferredTransport =
-                mConfigManager.isChooseWfcPreferredTransportInBothBadCondition(WIFI_ONLY);
-        Assert.assertFalse(isChooseWfcPreferredTransport);
-    }
-
-    @Test
-    public void testIsOverrideImsPreferenceSupportedWithDefaultValues() {
-        boolean isOverrideIMSPreferenceEnabled;
-
-        isOverrideIMSPreferenceEnabled = mConfigManager.isOverrideImsPreferenceSupported();
-        Assert.assertFalse(isOverrideIMSPreferenceEnabled);
-    }
-
-    @Test
-    public void testIsCurrentTransportTypeInVoiceCallSupportedWithDefaultValues() {
-        boolean isCurrTransportTypeInVoiceCall;
-
-        isCurrTransportTypeInVoiceCall =
-                mConfigManager.isCurrentTransportTypeInVoiceCallSupported();
-        Assert.assertFalse(isCurrTransportTypeInVoiceCall);
-    }
-
-    @Test
-    public void testIsRoveOutWithWiFiLowQualityAtGuardingTimeWithDefaultValues() {
-        boolean isRoveOutPoliciesForGuardTimerSupported;
-
-        isRoveOutPoliciesForGuardTimerSupported =
-                mConfigManager.isRoveOutWithWiFiLowQualityAtGuardingTime();
-        Assert.assertFalse(isRoveOutPoliciesForGuardTimerSupported);
-    }
-
-    @Test
-    public void testGetThresholdGapWithGuardTimerWithDefaultValues() {
-        testEutranGuardTimerThresholdGapOffset();
-        testNgranGuardTimerThresholdGapOffset();
-        testUtranGuardTimerThresholdGapOffset();
-        testGeranGuardTimerThresholdGapOffset();
-        testIwlanGuardTimerThresholdGapOffset();
-    }
-
-    private void testEutranGuardTimerThresholdGapOffset() {
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN, SIGNAL_MEASUREMENT_TYPE_RSRP);
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN, SIGNAL_MEASUREMENT_TYPE_RSRP);
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN, SIGNAL_MEASUREMENT_TYPE_RSRP);
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN, SIGNAL_MEASUREMENT_TYPE_RSRQ);
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN, SIGNAL_MEASUREMENT_TYPE_RSRQ);
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN, SIGNAL_MEASUREMENT_TYPE_RSRQ);
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN, SIGNAL_MEASUREMENT_TYPE_RSSNR);
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN, SIGNAL_MEASUREMENT_TYPE_RSSNR);
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN, SIGNAL_MEASUREMENT_TYPE_RSSNR);
-    }
-
-    private void testNgranGuardTimerThresholdGapOffset() {
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.NGRAN, SIGNAL_MEASUREMENT_TYPE_SSRSRP);
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.NGRAN, SIGNAL_MEASUREMENT_TYPE_SSRSRP);
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.NGRAN, SIGNAL_MEASUREMENT_TYPE_SSRSRP);
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.NGRAN, SIGNAL_MEASUREMENT_TYPE_SSRSRQ);
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.NGRAN, SIGNAL_MEASUREMENT_TYPE_SSRSRQ);
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.NGRAN, SIGNAL_MEASUREMENT_TYPE_SSRSRQ);
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.NGRAN, SIGNAL_MEASUREMENT_TYPE_SSSINR);
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.NGRAN, SIGNAL_MEASUREMENT_TYPE_SSSINR);
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.NGRAN, SIGNAL_MEASUREMENT_TYPE_SSSINR);
-    }
-
-    private void testUtranGuardTimerThresholdGapOffset() {
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.UTRAN, SIGNAL_MEASUREMENT_TYPE_RSCP);
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.UTRAN, SIGNAL_MEASUREMENT_TYPE_RSCP);
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.UTRAN, SIGNAL_MEASUREMENT_TYPE_RSCP);
-    }
-
-    private void testGeranGuardTimerThresholdGapOffset() {
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.GERAN, SIGNAL_MEASUREMENT_TYPE_RSSI);
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.GERAN, SIGNAL_MEASUREMENT_TYPE_RSSI);
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.GERAN, SIGNAL_MEASUREMENT_TYPE_RSSI);
-    }
-
-    private void testIwlanGuardTimerThresholdGapOffset() {
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.IWLAN, SIGNAL_MEASUREMENT_TYPE_RSSI);
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.IWLAN, SIGNAL_MEASUREMENT_TYPE_RSSI);
-        loadAndValidateForGuardTImerThresholdGapOffset(
-                AccessNetworkConstants.AccessNetworkType.IWLAN, SIGNAL_MEASUREMENT_TYPE_RSSI);
-    }
-
-    private void loadAndValidateForGuardTImerThresholdGapOffset(
-            @AccessNetworkConstants.RadioAccessNetworkType int an, int measurementType) {
-
-        int thresholdGapOffsetForGuardTimers =
-                mConfigManager.getThresholdGapWithGuardTimer(an, measurementType);
-
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, thresholdGapOffsetForGuardTimers);
-    }
-
-    @Test
-    public void testHasThresholdGapWithGuardTimerWithDefaultValue() {
-        assertFalse(mConfigManager.hasThresholdGapWithGuardTimer());
-    }
-
-    @Test
-    public void testHasThresholdGapWithGuardTimerWithTestBundle() {
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putStringArray(
-                QnsCarrierConfigManager.KEY_QNS_ROVEIN_THRESHOLD_GAP_WITH_GUARD_TIMER_STRING_ARRAY,
-                new String[] {"eutran:rsrp:-2"});
-        mConfigManager.loadQnsAneSupportConfigurations(bundle, null);
-        assertTrue(mConfigManager.hasThresholdGapWithGuardTimer());
-        Assert.assertEquals(
-                -2,
-                mConfigManager.getThresholdGapWithGuardTimer(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SIGNAL_MEASUREMENT_TYPE_RSRP));
-
-        bundle.putStringArray(
-                QnsCarrierConfigManager.KEY_QNS_ROVEIN_THRESHOLD_GAP_WITH_GUARD_TIMER_STRING_ARRAY,
-                new String[] {"eutran::-2"});
-        mConfigManager.loadQnsAneSupportConfigurations(bundle, null);
-        Assert.assertEquals(
-                QnsConstants.KEY_DEFAULT_VALUE,
-                mConfigManager.getThresholdGapWithGuardTimer(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SIGNAL_MEASUREMENT_TYPE_RSRP));
-
-        bundle.putStringArray(
-                QnsCarrierConfigManager.KEY_QNS_ROVEIN_THRESHOLD_GAP_WITH_GUARD_TIMER_STRING_ARRAY,
-                new String[] {":rsrp:-2"});
-        mConfigManager.loadQnsAneSupportConfigurations(bundle, null);
-        Assert.assertEquals(
-                QnsConstants.KEY_DEFAULT_VALUE,
-                mConfigManager.getThresholdGapWithGuardTimer(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SIGNAL_MEASUREMENT_TYPE_RSRP));
-
-        bundle.putStringArray(
-                QnsCarrierConfigManager.KEY_QNS_ROVEIN_THRESHOLD_GAP_WITH_GUARD_TIMER_STRING_ARRAY,
-                new String[] {""});
-        mConfigManager.loadQnsAneSupportConfigurations(bundle, null);
-        Assert.assertEquals(
-                QnsConstants.KEY_DEFAULT_VALUE,
-                mConfigManager.getThresholdGapWithGuardTimer(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SIGNAL_MEASUREMENT_TYPE_RSRP));
-
-        bundle.putStringArray(
-                QnsCarrierConfigManager.KEY_QNS_ROVEIN_THRESHOLD_GAP_WITH_GUARD_TIMER_STRING_ARRAY,
-                new String[] {":"});
-        mConfigManager.loadQnsAneSupportConfigurations(bundle, null);
-        Assert.assertEquals(
-                QnsConstants.KEY_DEFAULT_VALUE,
-                mConfigManager.getThresholdGapWithGuardTimer(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SIGNAL_MEASUREMENT_TYPE_RSRP));
-    }
-
-    @Test
-    public void testGetWwanHysteresisDbLevelWithTestbundle() {
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putStringArray(
-                QnsCarrierConfigManager.KEY_QNS_CELLULAR_SIGNAL_STRENGTH_HYSTERESIS_DB_STRING_ARRAY,
-                new String[] {"eutran:rsrp:1"});
-        mConfigManager.loadQnsAneSupportConfigurations(bundle, null);
-        Assert.assertEquals(
-                1,
-                mConfigManager.getWwanHysteresisDbLevel(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SIGNAL_MEASUREMENT_TYPE_RSRP));
-
-        bundle.putStringArray(
-                QnsCarrierConfigManager.KEY_QNS_CELLULAR_SIGNAL_STRENGTH_HYSTERESIS_DB_STRING_ARRAY,
-                new String[] {"ngran:ssrsrp:2"});
-        mConfigManager.loadQnsAneSupportConfigurations(bundle, null);
-        Assert.assertEquals(
-                2,
-                mConfigManager.getWwanHysteresisDbLevel(
-                        AccessNetworkConstants.AccessNetworkType.NGRAN,
-                        SIGNAL_MEASUREMENT_TYPE_SSRSRP));
-
-        bundle.putStringArray(
-                QnsCarrierConfigManager.KEY_QNS_CELLULAR_SIGNAL_STRENGTH_HYSTERESIS_DB_STRING_ARRAY,
-                new String[] {"eutran:rsrp:-5"});
-        mConfigManager.loadQnsAneSupportConfigurations(bundle, null);
-        Assert.assertEquals(
-                QnsConstants.KEY_DEFAULT_VALUE,
-                mConfigManager.getWwanHysteresisDbLevel(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SIGNAL_MEASUREMENT_TYPE_RSRP));
-
-        bundle.putStringArray(
-                QnsCarrierConfigManager.KEY_QNS_CELLULAR_SIGNAL_STRENGTH_HYSTERESIS_DB_STRING_ARRAY,
-                new String[] {"utran:rscp:5"});
-        mConfigManager.loadQnsAneSupportConfigurations(bundle, null);
-        Assert.assertEquals(
-                5,
-                mConfigManager.getWwanHysteresisDbLevel(
-                        AccessNetworkConstants.AccessNetworkType.UTRAN,
-                        SIGNAL_MEASUREMENT_TYPE_RSCP));
-
-        bundle.putStringArray(
-                QnsCarrierConfigManager.KEY_QNS_CELLULAR_SIGNAL_STRENGTH_HYSTERESIS_DB_STRING_ARRAY,
-                new String[] {"eutran::-2"});
-        mConfigManager.loadQnsAneSupportConfigurations(bundle, null);
-        Assert.assertEquals(
-                QnsConstants.KEY_DEFAULT_VALUE,
-                mConfigManager.getWwanHysteresisDbLevel(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SIGNAL_MEASUREMENT_TYPE_RSRP));
-
-        bundle.putStringArray(
-                QnsCarrierConfigManager.KEY_QNS_CELLULAR_SIGNAL_STRENGTH_HYSTERESIS_DB_STRING_ARRAY,
-                new String[] {":rsrp:-2"});
-        mConfigManager.loadQnsAneSupportConfigurations(bundle, null);
-        Assert.assertEquals(
-                QnsConstants.KEY_DEFAULT_VALUE,
-                mConfigManager.getWwanHysteresisDbLevel(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SIGNAL_MEASUREMENT_TYPE_RSRP));
-
-        bundle.putStringArray(
-                QnsCarrierConfigManager.KEY_QNS_CELLULAR_SIGNAL_STRENGTH_HYSTERESIS_DB_STRING_ARRAY,
-                new String[] {""});
-        mConfigManager.loadQnsAneSupportConfigurations(bundle, null);
-        Assert.assertEquals(
-                QnsConstants.KEY_DEFAULT_VALUE,
-                mConfigManager.getWwanHysteresisDbLevel(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SIGNAL_MEASUREMENT_TYPE_RSRP));
-
-        bundle.putStringArray(
-                QnsCarrierConfigManager.KEY_QNS_CELLULAR_SIGNAL_STRENGTH_HYSTERESIS_DB_STRING_ARRAY,
-                new String[] {":"});
-        mConfigManager.loadQnsAneSupportConfigurations(bundle, null);
-        Assert.assertEquals(
-                QnsConstants.KEY_DEFAULT_VALUE,
-                mConfigManager.getWwanHysteresisDbLevel(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SIGNAL_MEASUREMENT_TYPE_RSRP));
-    }
-
-    @Test
-    public void testGetQnsSupportedNetCapabilitiesWithDefaultValues() {
-        List<Integer> imsNetCapability = new ArrayList<>();
-        imsNetCapability.add(NetworkCapabilities.NET_CAPABILITY_IMS);
-        Assert.assertEquals(imsNetCapability, mConfigManager.getQnsSupportedNetCapabilities());
-    }
-
-    @Test
-    public void testGetQnsSupportedNetCapabilitiesWithTestBundle() {
-        PersistableBundle bundleCarrierConfig = new PersistableBundle();
-        PersistableBundle bundleAsset = new PersistableBundle();
-        bundleAsset.putInt(
-                QnsCarrierConfigManager.KEY_QNS_SOS_TRANSPORT_TYPE_INT,
-                QnsConstants.TRANSPORT_TYPE_ALLOWED_IWLAN);
-        mConfigManager.loadQnsAneSupportConfigurations(bundleAsset, null);
-        List<Integer> supportedNetCapabilities = new ArrayList<>();
-        supportedNetCapabilities.add(NetworkCapabilities.NET_CAPABILITY_IMS);
-        supportedNetCapabilities.add(NetworkCapabilities.NET_CAPABILITY_EIMS);
-        Assert.assertEquals(
-                supportedNetCapabilities, mConfigManager.getQnsSupportedNetCapabilities());
-        bundleAsset.putInt(
-                QnsCarrierConfigManager.KEY_QNS_MMS_TRANSPORT_TYPE_INT,
-                QnsConstants.TRANSPORT_TYPE_ALLOWED_IWLAN);
-        bundleCarrierConfig.putIntArray(
-                CarrierConfigManager.ImsSs.KEY_XCAP_OVER_UT_SUPPORTED_RATS_INT_ARRAY,
-                new int[] {AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        AccessNetworkConstants.AccessNetworkType.NGRAN,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN});
-        bundleAsset.putInt(
-                QnsCarrierConfigManager.KEY_QNS_CBS_TRANSPORT_TYPE_INT,
-                QnsConstants.TRANSPORT_TYPE_ALLOWED_IWLAN);
-        mConfigManager.loadQnsAneSupportConfigurations(bundleCarrierConfig, bundleAsset);
-        supportedNetCapabilities.add(NetworkCapabilities.NET_CAPABILITY_MMS);
-        supportedNetCapabilities.add(NetworkCapabilities.NET_CAPABILITY_XCAP);
-        supportedNetCapabilities.add(NetworkCapabilities.NET_CAPABILITY_CBS);
-        Assert.assertEquals(
-                supportedNetCapabilities, mConfigManager.getQnsSupportedNetCapabilities());
-
-        bundleCarrierConfig.clear();
-        bundleCarrierConfig.putIntArray(
-                CarrierConfigManager.ImsSs.KEY_XCAP_OVER_UT_SUPPORTED_RATS_INT_ARRAY,
-                new int[] {AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        AccessNetworkConstants.AccessNetworkType.NGRAN});
-        mConfigManager.loadQnsAneSupportConfigurations(bundleCarrierConfig, bundleAsset);
-        supportedNetCapabilities.clear();
-        supportedNetCapabilities.add(NetworkCapabilities.NET_CAPABILITY_IMS);
-        supportedNetCapabilities.add(NetworkCapabilities.NET_CAPABILITY_EIMS);
-        supportedNetCapabilities.add(NetworkCapabilities.NET_CAPABILITY_MMS);
-        supportedNetCapabilities.add(NetworkCapabilities.NET_CAPABILITY_CBS);
-        Assert.assertEquals(
-                supportedNetCapabilities, mConfigManager.getQnsSupportedNetCapabilities());
-    }
-
-    @Test
-    public void testAllowImsOverIwlanCellularLimitedCaseWithDefaultValues() {
-        assertFalse(mConfigManager.allowImsOverIwlanCellularLimitedCase());
-    }
-
-    @Test
-    public void testAllowImsOverIwlanCellularLimitedCaseWithTestBundle() {
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putBoolean(
-                QnsCarrierConfigManager.KEY_QNS_ALLOW_IMS_OVER_IWLAN_CELLULAR_LIMITED_CASE_BOOL,
-                true);
-        mConfigManager.loadQnsAneSupportConfigurations(null, bundle);
-        assertTrue(mConfigManager.allowImsOverIwlanCellularLimitedCase());
-    }
-
-    @Test
-    public void testGetQnsMaxIwlanHoCountDuringCallWithDefaultValues() {
-        int iwlanHoCountDuringCall;
-
-        iwlanHoCountDuringCall = mConfigManager.getQnsMaxIwlanHoCountDuringCall();
-        Assert.assertEquals(QnsConstants.MAX_COUNT_INVALID, iwlanHoCountDuringCall);
-    }
-
-    @Test
-    public void testGetQnsIwlanHoRestrictReasonWithDefaultValues() {
-        int iwlanHoFallbackReasonSupported;
-
-        iwlanHoFallbackReasonSupported = mConfigManager.getQnsIwlanHoRestrictReason();
-        Assert.assertEquals(QnsConstants.FALLBACK_REASON_INVALID, iwlanHoFallbackReasonSupported);
-    }
-
-    @Test
-    public void testGetWaitingTimeForPreferredTransportOnPowerOnWithDefaultValues() {
-        int waitingTimer;
-
-        waitingTimer =
-                mConfigManager.getWaitingTimerForPreferredTransportOnPowerOn(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, waitingTimer);
-
-        waitingTimer =
-                mConfigManager.getWaitingTimerForPreferredTransportOnPowerOn(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, waitingTimer);
-
-        waitingTimer =
-                mConfigManager.getWaitingTimerForPreferredTransportOnPowerOn(
-                        AccessNetworkConstants.TRANSPORT_TYPE_INVALID);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, waitingTimer);
-    }
-
-    @Test
-    public void testGetWIFIRssiBackHaulTimerWithDefaultValues() {
-        int wifiBackhaulDefaultTimer;
-
-        wifiBackhaulDefaultTimer = mConfigManager.getWIFIRssiBackHaulTimer();
-        Assert.assertEquals(QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER, wifiBackhaulDefaultTimer);
-        Assert.assertNotEquals(QnsConstants.KEY_DEFAULT_VALUE, wifiBackhaulDefaultTimer);
-    }
-
-    @Test
-    public void testGetCellularSSBackHaulTimerWithDefaultValues() {
-        int CellularBackhaulDefaultTimer;
-
-        CellularBackhaulDefaultTimer = mConfigManager.getCellularSSBackHaulTimer();
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, CellularBackhaulDefaultTimer);
-        Assert.assertNotEquals(
-                QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER, CellularBackhaulDefaultTimer);
-    }
-
-    @Test
-    public void testGetHoRestrictedTimeOnLowRtpQualityWithDefaultValues() {
-        int hoRestrictTime;
-
-        hoRestrictTime = mConfigManager.getHoRestrictedTimeOnLowRTPQuality(TRANSPORT_TYPE_WLAN);
-        Assert.assertEquals(
-                QnsConstants.KEY_DEFAULT_IWLAN_AVOID_TIME_LOW_RTP_QUALITY_MILLIS, hoRestrictTime);
-        Assert.assertNotEquals(QnsConstants.KEY_DEFAULT_VALUE, hoRestrictTime);
-        hoRestrictTime = mConfigManager.getHoRestrictedTimeOnLowRTPQuality(TRANSPORT_TYPE_WWAN);
-        Assert.assertEquals(
-                QnsConstants.KEY_DEFAULT_WWAN_AVOID_TIME_LOW_RTP_QUALITY_MILLIS, hoRestrictTime);
-        Assert.assertNotEquals(QnsConstants.KEY_DEFAULT_VALUE, hoRestrictTime);
-        hoRestrictTime = mConfigManager.getHoRestrictedTimeOnLowRTPQuality(TRANSPORT_TYPE_INVALID);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, hoRestrictTime);
-    }
-
-    @Test
-    public void testGetRatPreference() {
-        int ratPreference;
-
-        ratPreference = mConfigManager.getRatPreference(NetworkCapabilities.NET_CAPABILITY_IMS);
-        Assert.assertEquals(QnsConstants.RAT_PREFERENCE_DEFAULT, ratPreference);
-        ratPreference = mConfigManager.getRatPreference(NetworkCapabilities.NET_CAPABILITY_EIMS);
-        Assert.assertEquals(QnsConstants.RAT_PREFERENCE_DEFAULT, ratPreference);
-        ratPreference = mConfigManager.getRatPreference(NetworkCapabilities.NET_CAPABILITY_MMS);
-        Assert.assertEquals(QnsConstants.RAT_PREFERENCE_DEFAULT, ratPreference);
-        ratPreference = mConfigManager.getRatPreference(NetworkCapabilities.NET_CAPABILITY_XCAP);
-        Assert.assertEquals(QnsConstants.RAT_PREFERENCE_DEFAULT, ratPreference);
-        ratPreference = mConfigManager.getRatPreference(NetworkCapabilities.NET_CAPABILITY_CBS);
-        Assert.assertEquals(QnsConstants.RAT_PREFERENCE_DEFAULT, ratPreference);
-    }
-
-    @Test
-    public void testGetQnsSupportedTransportTypeWithDefaultValues() {
-        int qnsTransportType;
-        qnsTransportType =
-                mConfigManager.getQnsSupportedTransportType(NetworkCapabilities.NET_CAPABILITY_IMS);
-        Assert.assertEquals(QnsConstants.TRANSPORT_TYPE_ALLOWED_BOTH, qnsTransportType);
-        qnsTransportType =
-                mConfigManager.getQnsSupportedTransportType(NetworkCapabilities.NET_CAPABILITY_MMS);
-        Assert.assertEquals(QnsConstants.TRANSPORT_TYPE_ALLOWED_WWAN, qnsTransportType);
-        qnsTransportType =
-                mConfigManager.getQnsSupportedTransportType(
-                        NetworkCapabilities.NET_CAPABILITY_XCAP);
-        Assert.assertEquals(QnsConstants.TRANSPORT_TYPE_ALLOWED_WWAN, qnsTransportType);
-        qnsTransportType =
-                mConfigManager.getQnsSupportedTransportType(
-                        NetworkCapabilities.NET_CAPABILITY_EIMS);
-        Assert.assertEquals(QnsConstants.TRANSPORT_TYPE_ALLOWED_WWAN, qnsTransportType);
-        qnsTransportType =
-                mConfigManager.getQnsSupportedTransportType(NetworkCapabilities.NET_CAPABILITY_CBS);
-        Assert.assertEquals(QnsConstants.TRANSPORT_TYPE_ALLOWED_WWAN, qnsTransportType);
-
-        qnsTransportType =
-                mConfigManager.getQnsSupportedTransportType(
-                        NetworkCapabilities.NET_CAPABILITY_INTERNET);
-        Assert.assertEquals(QnsConstants.INVALID_ID, qnsTransportType);
-        qnsTransportType =
-                mConfigManager.getQnsSupportedTransportType(NetworkCapabilities.NET_CAPABILITY_IMS);
-        Assert.assertNotEquals(QnsConstants.TRANSPORT_TYPE_ALLOWED_IWLAN, qnsTransportType);
-        qnsTransportType =
-                mConfigManager.getQnsSupportedTransportType(
-                        NetworkCapabilities.NET_CAPABILITY_EIMS);
-        Assert.assertNotEquals(QnsConstants.TRANSPORT_TYPE_ALLOWED_BOTH, qnsTransportType);
-    }
-
-    @Test
-    public void testGetWwanHysteresisTimerWithDefaultValues() {
-        int wwanHysteresisTimer;
-
-        wwanHysteresisTimer =
-                mConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, CALL_TYPE_IDLE);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_HYST_TIMER, wwanHysteresisTimer);
-        wwanHysteresisTimer =
-                mConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_EIMS, CALL_TYPE_IDLE);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_HYST_TIMER, wwanHysteresisTimer);
-        wwanHysteresisTimer =
-                mConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, CALL_TYPE_VOICE);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_HYST_TIMER, wwanHysteresisTimer);
-        wwanHysteresisTimer =
-                mConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_EIMS, CALL_TYPE_VOICE);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_HYST_TIMER, wwanHysteresisTimer);
-        wwanHysteresisTimer =
-                mConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, CALL_TYPE_VIDEO);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_HYST_TIMER, wwanHysteresisTimer);
-        wwanHysteresisTimer =
-                mConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_EIMS, CALL_TYPE_VIDEO);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_HYST_TIMER, wwanHysteresisTimer);
-        wwanHysteresisTimer =
-                mConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_INTERNET, CALL_TYPE_VIDEO);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wwanHysteresisTimer);
-        wwanHysteresisTimer =
-                mConfigManager.getWwanHysteresisTimer(NetworkCapabilities.NET_CAPABILITY_IMS, -1);
-        Assert.assertNotEquals(QnsConstants.KEY_DEFAULT_HYST_TIMER, wwanHysteresisTimer);
-        wwanHysteresisTimer =
-                mConfigManager.getWwanHysteresisTimer(NetworkCapabilities.NET_CAPABILITY_EIMS, 3);
-        Assert.assertNotEquals(QnsConstants.KEY_DEFAULT_HYST_TIMER, wwanHysteresisTimer);
-        wwanHysteresisTimer =
-                mConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_MMS, CALL_TYPE_IDLE);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wwanHysteresisTimer);
-        wwanHysteresisTimer =
-                mConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_MMS, CALL_TYPE_VOICE);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wwanHysteresisTimer);
-        wwanHysteresisTimer =
-                mConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_MMS, CALL_TYPE_VIDEO);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wwanHysteresisTimer);
-        wwanHysteresisTimer =
-                mConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_CBS, CALL_TYPE_IDLE);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wwanHysteresisTimer);
-        wwanHysteresisTimer =
-                mConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_CBS, CALL_TYPE_VOICE);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wwanHysteresisTimer);
-        wwanHysteresisTimer =
-                mConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_CBS, CALL_TYPE_VIDEO);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wwanHysteresisTimer);
-        wwanHysteresisTimer =
-                mConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_XCAP, CALL_TYPE_IDLE);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wwanHysteresisTimer);
-        wwanHysteresisTimer =
-                mConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_XCAP, CALL_TYPE_VOICE);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wwanHysteresisTimer);
-        wwanHysteresisTimer =
-                mConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_XCAP, CALL_TYPE_VIDEO);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wwanHysteresisTimer);
-        wwanHysteresisTimer =
-                mConfigManager.getWwanHysteresisTimer(NetworkCapabilities.NET_CAPABILITY_MMS, -1);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wwanHysteresisTimer);
-        wwanHysteresisTimer =
-                mConfigManager.getWwanHysteresisTimer(NetworkCapabilities.NET_CAPABILITY_EIMS, 3);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wwanHysteresisTimer);
-    }
-
-    @Test
-    public void testGetWwanHysteresisTimerWithProvisioningInfo()
-            throws NoSuchFieldException, IllegalAccessException {
-        QnsProvisioningListener.QnsProvisioningInfo info =
-                new QnsProvisioningListener.QnsProvisioningInfo();
-        ConcurrentHashMap<Integer, Integer> integerItems = new ConcurrentHashMap<>();
-        integerItems.put(ProvisioningManager.KEY_LTE_EPDG_TIMER_SEC, 10000);
-
-        // update private object
-        setObject(info, "mIntegerItems", integerItems);
-        mConfigManager.setQnsProvisioningInfo(info);
-
-        int wwanHysteresisTimer =
-                mConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, CALL_TYPE_IDLE);
-        Assert.assertEquals(10000, wwanHysteresisTimer);
-    }
-
-    @Test
-    public void testGetWlanHysteresisTimerWithProvisioningInfo()
-            throws NoSuchFieldException, IllegalAccessException {
-        QnsProvisioningListener.QnsProvisioningInfo info =
-                new QnsProvisioningListener.QnsProvisioningInfo();
-        ConcurrentHashMap<Integer, Integer> integerItems = new ConcurrentHashMap<>();
-        integerItems.put(ProvisioningManager.KEY_WIFI_EPDG_TIMER_SEC, 20000);
-
-        // update private object
-        setObject(info, "mIntegerItems", integerItems);
-        mConfigManager.setQnsProvisioningInfo(info);
-
-        int wlanHysteresisTimer =
-                mConfigManager.getWlanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, CALL_TYPE_IDLE);
-        Assert.assertEquals(20000, wlanHysteresisTimer);
-    }
-
-    @Test
-    public void testGetPolicyInternalApi() {
-        String[] internalTestPolicyWithGuarding =
-                new String[] {"Condition:IWLAN_GOOD,EUTRAN_BAD", "Condition:IWLAN_GOOD,UTRAN_BAD"};
-        String[] internalTestPolicyWithoutGuarding = new String[] {"Condition:EUTRAN_GOOD"};
-        PersistableBundle bundle = new PersistableBundle();
-        QnsCarrierAnspSupportConfig testConfig = mConfigManager.getQnsCarrierAnspSupportConfig();
-        AccessNetworkSelectionPolicy.PreCondition preCondition =
-                new AccessNetworkSelectionPolicy.GuardingPreCondition(
-                        QnsConstants.CALL_TYPE_IDLE,
-                        QnsConstants.WIFI_PREF,
-                        QnsConstants.COVERAGE_HOME,
-                        QnsConstants.GUARDING_WIFI);
-
-        bundle.putStringArray(
-                QnsCarrierAnspSupportConfig.KEY_CONDITION_ROVE_IN_IDLE_WIFI_PREF_HOME_STRING_ARRAY,
-                internalTestPolicyWithoutGuarding);
-        testConfig.loadQnsAnspSupportArray(bundle, null);
-        String[] internalPolicies = mConfigManager.getPolicy(QnsConstants.ROVE_IN, preCondition);
-        Assert.assertArrayEquals(internalTestPolicyWithoutGuarding, internalPolicies);
-
-        bundle.putStringArray(
-                QnsCarrierAnspSupportConfig
-                        .KEY_CONDITION_ROVE_IN_IDLE_WIFI_PREF_HOME_GUARDING_WIFI_STRING_ARRAY,
-                internalTestPolicyWithGuarding);
-        testConfig.loadQnsAnspSupportArray(bundle, null);
-        internalPolicies = mConfigManager.getPolicy(QnsConstants.ROVE_IN, preCondition);
-        Assert.assertArrayEquals(internalTestPolicyWithGuarding, internalPolicies);
-    }
-
-    @Test
-    public void testGetWlanHysteresisTimerWithDefaultValues() {
-        int wlanHysteresisTimer;
-
-        wlanHysteresisTimer =
-                mConfigManager.getWlanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, CALL_TYPE_IDLE);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_HYST_TIMER, wlanHysteresisTimer);
-        wlanHysteresisTimer =
-                mConfigManager.getWlanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_EIMS, CALL_TYPE_IDLE);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_HYST_TIMER, wlanHysteresisTimer);
-        wlanHysteresisTimer =
-                mConfigManager.getWlanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, CALL_TYPE_VOICE);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_HYST_TIMER, wlanHysteresisTimer);
-        wlanHysteresisTimer =
-                mConfigManager.getWlanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_EIMS, CALL_TYPE_VOICE);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_HYST_TIMER, wlanHysteresisTimer);
-        wlanHysteresisTimer =
-                mConfigManager.getWlanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, CALL_TYPE_VIDEO);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_HYST_TIMER, wlanHysteresisTimer);
-        wlanHysteresisTimer =
-                mConfigManager.getWlanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_EIMS, CALL_TYPE_VIDEO);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_HYST_TIMER, wlanHysteresisTimer);
-        wlanHysteresisTimer =
-                mConfigManager.getWlanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_INTERNET, CALL_TYPE_VIDEO);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wlanHysteresisTimer);
-        wlanHysteresisTimer =
-                mConfigManager.getWlanHysteresisTimer(NetworkCapabilities.NET_CAPABILITY_IMS, -1);
-        Assert.assertNotEquals(QnsConstants.KEY_DEFAULT_HYST_TIMER, wlanHysteresisTimer);
-        wlanHysteresisTimer =
-                mConfigManager.getWlanHysteresisTimer(NetworkCapabilities.NET_CAPABILITY_EIMS, 3);
-        Assert.assertNotEquals(QnsConstants.KEY_DEFAULT_HYST_TIMER, wlanHysteresisTimer);
-        wlanHysteresisTimer =
-                mConfigManager.getWlanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_MMS, CALL_TYPE_IDLE);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wlanHysteresisTimer);
-        wlanHysteresisTimer =
-                mConfigManager.getWlanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_MMS, CALL_TYPE_VOICE);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wlanHysteresisTimer);
-        wlanHysteresisTimer =
-                mConfigManager.getWlanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_MMS, CALL_TYPE_VIDEO);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wlanHysteresisTimer);
-        wlanHysteresisTimer =
-                mConfigManager.getWlanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_CBS, CALL_TYPE_IDLE);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wlanHysteresisTimer);
-        wlanHysteresisTimer =
-                mConfigManager.getWlanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_CBS, CALL_TYPE_VOICE);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wlanHysteresisTimer);
-        wlanHysteresisTimer =
-                mConfigManager.getWlanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_CBS, CALL_TYPE_VIDEO);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wlanHysteresisTimer);
-        wlanHysteresisTimer =
-                mConfigManager.getWlanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_XCAP, CALL_TYPE_IDLE);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wlanHysteresisTimer);
-        wlanHysteresisTimer =
-                mConfigManager.getWlanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_XCAP, CALL_TYPE_VOICE);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wlanHysteresisTimer);
-        wlanHysteresisTimer =
-                mConfigManager.getWlanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_XCAP, CALL_TYPE_VIDEO);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wlanHysteresisTimer);
-        wlanHysteresisTimer =
-                mConfigManager.getWlanHysteresisTimer(NetworkCapabilities.NET_CAPABILITY_MMS, -1);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wlanHysteresisTimer);
-        wlanHysteresisTimer =
-                mConfigManager.getWlanHysteresisTimer(NetworkCapabilities.NET_CAPABILITY_EIMS, 3);
-        Assert.assertEquals(QnsConstants.KEY_DEFAULT_VALUE, wlanHysteresisTimer);
-    }
-
-    @Test
-    public void testGetMinimumHysteresisTimer() {
-        int timer = mConfigManager.getMinimumHandoverGuardingTimer();
-        Assert.assertEquals(QnsConstants.CONFIG_DEFAULT_MIN_HANDOVER_GUARDING_TIMER, timer);
-
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putInt(QnsCarrierConfigManager.KEY_MINIMUM_HANDOVER_GUARDING_TIMER_MS_INT, -1);
-        mConfigManager.loadQnsAneSupportConfigurations(bundle, null);
-        Assert.assertEquals(0 /*disabled*/, mConfigManager.getMinimumHandoverGuardingTimer());
-
-        bundle.putInt(QnsCarrierConfigManager.KEY_MINIMUM_HANDOVER_GUARDING_TIMER_MS_INT, 0);
-        mConfigManager.loadQnsAneSupportConfigurations(bundle, null);
-        Assert.assertEquals(0 /*disabled*/, mConfigManager.getMinimumHandoverGuardingTimer());
-
-        bundle.putInt(
-                QnsCarrierConfigManager.KEY_MINIMUM_HANDOVER_GUARDING_TIMER_MS_INT,
-                QnsConstants.CONFIG_DEFAULT_MIN_HANDOVER_GUARDING_TIMER_LIMIT);
-        mConfigManager.loadQnsAneSupportConfigurations(bundle, null);
-        Assert.assertEquals(
-                QnsConstants.CONFIG_DEFAULT_MIN_HANDOVER_GUARDING_TIMER_LIMIT,
-                mConfigManager.getMinimumHandoverGuardingTimer());
-
-        bundle.putInt(
-                QnsCarrierConfigManager.KEY_MINIMUM_HANDOVER_GUARDING_TIMER_MS_INT,
-                QnsConstants.CONFIG_DEFAULT_MIN_HANDOVER_GUARDING_TIMER_LIMIT << 1);
-        mConfigManager.loadQnsAneSupportConfigurations(bundle, null);
-        Assert.assertEquals(
-                QnsConstants.CONFIG_DEFAULT_MIN_HANDOVER_GUARDING_TIMER_LIMIT,
-                mConfigManager.getMinimumHandoverGuardingTimer());
-    }
-
-    @Test
-    public void testTransportNetworkToString() {
-        String transportType_str = null;
-
-        transportType_str =
-                QnsCarrierConfigManager.transportNetworkToString(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        Assert.assertEquals("CELLULAR", transportType_str);
-        Assert.assertNotEquals("WIFI", transportType_str);
-
-        transportType_str =
-                QnsCarrierConfigManager.transportNetworkToString(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        Assert.assertNotEquals("CELLULAR", transportType_str);
-        Assert.assertEquals("WIFI", transportType_str);
-
-        transportType_str =
-                QnsCarrierConfigManager.transportNetworkToString(
-                        AccessNetworkConstants.TRANSPORT_TYPE_INVALID);
-        Assert.assertEquals("", transportType_str);
-        transportType_str = QnsCarrierConfigManager.transportNetworkToString(3);
-        Assert.assertEquals("", transportType_str);
-    }
-
-    @Test
-    public void testGetThresholdWithDefaultValues() {
-        testUnknownConfigArray();
-        testEutranThresholdConfigArray();
-        testNgranThresholdConfigsArray();
-        testUtranThresholdConfigsArray();
-        testGeranThresholdConfigsArray();
-        testIwlanThresholdConfigsArray();
-    }
-
-    private void testEutranThresholdConfigArray() {
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                CALL_TYPE_IDLE,
-                SIGNAL_MEASUREMENT_TYPE_RSRP);
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                CALL_TYPE_VOICE,
-                SIGNAL_MEASUREMENT_TYPE_RSRP);
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                QnsConstants.CALL_TYPE_VIDEO,
-                SIGNAL_MEASUREMENT_TYPE_RSRP);
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                CALL_TYPE_IDLE,
-                SIGNAL_MEASUREMENT_TYPE_RSRQ);
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                CALL_TYPE_VOICE,
-                SIGNAL_MEASUREMENT_TYPE_RSRQ);
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                QnsConstants.CALL_TYPE_VIDEO,
-                SIGNAL_MEASUREMENT_TYPE_RSRQ);
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                CALL_TYPE_IDLE,
-                SIGNAL_MEASUREMENT_TYPE_RSSNR);
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                CALL_TYPE_VOICE,
-                SIGNAL_MEASUREMENT_TYPE_RSSNR);
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                QnsConstants.CALL_TYPE_VIDEO,
-                SIGNAL_MEASUREMENT_TYPE_RSSNR);
-    }
-
-    private void testNgranThresholdConfigsArray() {
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.NGRAN,
-                CALL_TYPE_IDLE,
-                SIGNAL_MEASUREMENT_TYPE_SSRSRP);
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.NGRAN,
-                CALL_TYPE_VOICE,
-                SIGNAL_MEASUREMENT_TYPE_SSRSRP);
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.NGRAN,
-                QnsConstants.CALL_TYPE_VIDEO,
-                SIGNAL_MEASUREMENT_TYPE_SSRSRP);
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.NGRAN,
-                CALL_TYPE_IDLE,
-                SIGNAL_MEASUREMENT_TYPE_SSRSRQ);
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.NGRAN,
-                CALL_TYPE_VOICE,
-                SIGNAL_MEASUREMENT_TYPE_SSRSRQ);
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.NGRAN,
-                QnsConstants.CALL_TYPE_VIDEO,
-                SIGNAL_MEASUREMENT_TYPE_SSRSRQ);
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.NGRAN,
-                CALL_TYPE_IDLE,
-                SIGNAL_MEASUREMENT_TYPE_SSSINR);
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.NGRAN,
-                CALL_TYPE_VOICE,
-                SIGNAL_MEASUREMENT_TYPE_SSSINR);
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.NGRAN,
-                QnsConstants.CALL_TYPE_VIDEO,
-                SIGNAL_MEASUREMENT_TYPE_SSSINR);
-    }
-
-    private void testUtranThresholdConfigsArray() {
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.UTRAN,
-                CALL_TYPE_IDLE,
-                SIGNAL_MEASUREMENT_TYPE_RSCP);
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.UTRAN,
-                CALL_TYPE_VOICE,
-                SIGNAL_MEASUREMENT_TYPE_RSCP);
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.UTRAN,
-                QnsConstants.CALL_TYPE_VIDEO,
-                SIGNAL_MEASUREMENT_TYPE_RSCP);
-    }
-
-    private void testGeranThresholdConfigsArray() {
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.GERAN,
-                CALL_TYPE_IDLE,
-                SIGNAL_MEASUREMENT_TYPE_RSSI);
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.GERAN,
-                CALL_TYPE_VOICE,
-                SIGNAL_MEASUREMENT_TYPE_RSSI);
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.GERAN,
-                QnsConstants.CALL_TYPE_VIDEO,
-                SIGNAL_MEASUREMENT_TYPE_RSSI);
-    }
-
-    private void testIwlanThresholdConfigsArray() {
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.IWLAN,
-                CALL_TYPE_IDLE,
-                SIGNAL_MEASUREMENT_TYPE_RSSI);
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.IWLAN,
-                CALL_TYPE_VOICE,
-                SIGNAL_MEASUREMENT_TYPE_RSSI);
-        loadAndValidateForThresholds(
-                AccessNetworkConstants.AccessNetworkType.IWLAN,
-                QnsConstants.CALL_TYPE_VIDEO,
-                SIGNAL_MEASUREMENT_TYPE_RSSI);
-    }
-
-    private void testUnknownConfigArray() {
-        loadAndValidateArrayForNull(
-                AccessNetworkConstants.AccessNetworkType.UNKNOWN,
-                CALL_TYPE_IDLE,
-                SIGNAL_MEASUREMENT_TYPE_UNKNOWN);
-    }
-
-    private void loadAndValidateArrayForNull(
-            @AccessNetworkConstants.RadioAccessNetworkType int an,
-            int callType,
-            int measurementType) {
-        QnsCarrierConfigManager.QnsConfigArray threshold =
-                mConfigManager.getThreshold(an, callType, measurementType);
-        Assert.assertNull(threshold);
-    }
-
-    private void loadAndValidateForThresholds(
-            @AccessNetworkConstants.RadioAccessNetworkType int an,
-            int callType,
-            int measurementType) {
-
-        QnsCarrierConfigManager.QnsConfigArray threshold =
-                mConfigManager.getThreshold(an, callType, measurementType);
-
-        assert threshold != null;
-        validateForThreshold(threshold, an, callType, measurementType);
-    }
-
-    @Test
-    public void testGetThresholdByPref() {
-        testUnknownConfigArrayWithPref();
-        testConfigArrayWithPrefForInvalidValue();
-        testEutranThresholdConfigArrayByPref();
-        testNgranThresholdConfigsArrayByPref();
-        testUtranThresholdConfigsArrayByPref();
-        testGeranThresholdConfigsArrayByPref();
-        testIwlanThresholdConfigsArrayByPref();
-    }
-
-    private void testUnknownConfigArrayWithPref() {
-        loadAndValidateArrayForNullWithPref(
-                AccessNetworkConstants.AccessNetworkType.UNKNOWN,
-                CALL_TYPE_IDLE,
-                SIGNAL_MEASUREMENT_TYPE_UNKNOWN,
-                QnsConstants.WIFI_PREF);
-
-        loadAndValidateArrayForNullWithPref(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                CALL_TYPE_IDLE,
-                SIGNAL_MEASUREMENT_TYPE_UNKNOWN,
-                QnsConstants.WIFI_PREF);
-
-        loadAndValidateArrayForNullWithPref(
-                AccessNetworkConstants.AccessNetworkType.UNKNOWN,
-                CALL_TYPE_IDLE,
-                SIGNAL_MEASUREMENT_TYPE_RSRP,
-                QnsConstants.WIFI_PREF);
-    }
-
-    private void testConfigArrayWithPrefForInvalidValue() {
-        loadAndValidateArrayForInvalidValueWithPref(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                -1,
-                SIGNAL_MEASUREMENT_TYPE_RSRP,
-                QnsConstants.WIFI_PREF);
-    }
-
-    private void loadAndValidateArrayForNullWithPref(
-            @AccessNetworkConstants.RadioAccessNetworkType int an,
-            int callType,
-            int measurementType,
-            int pref) {
-        QnsCarrierConfigManager.QnsConfigArray thresholdByPref =
-                mConfigManager.getThresholdByPref(an, callType, measurementType, pref);
-        Assert.assertNull(thresholdByPref);
-    }
-
-    private void loadAndValidateArrayForInvalidValueWithPref(
-            @AccessNetworkConstants.RadioAccessNetworkType int an,
-            int callType,
-            int measurementType,
-            int pref) {
-        QnsCarrierConfigManager.QnsConfigArray threshold =
-                mConfigManager.getThresholdByPref(an, callType, measurementType, pref);
-
-        Assert.assertEquals(0x0000FFFF, threshold.mGood);
-        Assert.assertEquals(0x0000FFFF, threshold.mBad);
-        Assert.assertEquals(0x0000FFFF, threshold.mWorst);
-    }
-
-    private void testEutranThresholdConfigArrayByPref() {
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                CALL_TYPE_IDLE,
-                SIGNAL_MEASUREMENT_TYPE_RSRP,
-                WIFI_PREF);
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                CALL_TYPE_VOICE,
-                SIGNAL_MEASUREMENT_TYPE_RSRP,
-                WIFI_PREF);
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                QnsConstants.CALL_TYPE_VIDEO,
-                SIGNAL_MEASUREMENT_TYPE_RSRP,
-                WIFI_PREF);
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                CALL_TYPE_IDLE,
-                SIGNAL_MEASUREMENT_TYPE_RSRQ,
-                WIFI_PREF);
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                CALL_TYPE_VOICE,
-                SIGNAL_MEASUREMENT_TYPE_RSRQ,
-                WIFI_PREF);
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                QnsConstants.CALL_TYPE_VIDEO,
-                SIGNAL_MEASUREMENT_TYPE_RSRQ,
-                WIFI_PREF);
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                CALL_TYPE_IDLE,
-                SIGNAL_MEASUREMENT_TYPE_RSSNR,
-                WIFI_PREF);
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                CALL_TYPE_VOICE,
-                SIGNAL_MEASUREMENT_TYPE_RSSNR,
-                WIFI_PREF);
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                QnsConstants.CALL_TYPE_VIDEO,
-                SIGNAL_MEASUREMENT_TYPE_RSSNR,
-                WIFI_PREF);
-    }
-
-    private void testNgranThresholdConfigsArrayByPref() {
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.NGRAN,
-                CALL_TYPE_IDLE,
-                SIGNAL_MEASUREMENT_TYPE_SSRSRP,
-                WIFI_PREF);
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.NGRAN,
-                CALL_TYPE_VOICE,
-                SIGNAL_MEASUREMENT_TYPE_SSRSRP,
-                WIFI_PREF);
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.NGRAN,
-                QnsConstants.CALL_TYPE_VIDEO,
-                SIGNAL_MEASUREMENT_TYPE_SSRSRP,
-                WIFI_PREF);
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.NGRAN,
-                CALL_TYPE_IDLE,
-                SIGNAL_MEASUREMENT_TYPE_SSRSRQ,
-                WIFI_PREF);
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.NGRAN,
-                CALL_TYPE_VOICE,
-                SIGNAL_MEASUREMENT_TYPE_SSRSRQ,
-                WIFI_PREF);
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.NGRAN,
-                QnsConstants.CALL_TYPE_VIDEO,
-                SIGNAL_MEASUREMENT_TYPE_SSRSRQ,
-                WIFI_PREF);
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.NGRAN,
-                CALL_TYPE_IDLE,
-                SIGNAL_MEASUREMENT_TYPE_SSSINR,
-                WIFI_PREF);
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.NGRAN,
-                CALL_TYPE_VOICE,
-                SIGNAL_MEASUREMENT_TYPE_SSSINR,
-                WIFI_PREF);
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.NGRAN,
-                QnsConstants.CALL_TYPE_VIDEO,
-                SIGNAL_MEASUREMENT_TYPE_SSSINR,
-                WIFI_PREF);
-    }
-
-    private void testUtranThresholdConfigsArrayByPref() {
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.UTRAN,
-                CALL_TYPE_IDLE,
-                SIGNAL_MEASUREMENT_TYPE_RSCP,
-                WIFI_PREF);
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.UTRAN,
-                CALL_TYPE_VOICE,
-                SIGNAL_MEASUREMENT_TYPE_RSCP,
-                WIFI_PREF);
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.UTRAN,
-                QnsConstants.CALL_TYPE_VIDEO,
-                SIGNAL_MEASUREMENT_TYPE_RSCP,
-                WIFI_PREF);
-    }
-
-    private void testGeranThresholdConfigsArrayByPref() {
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.GERAN,
-                CALL_TYPE_IDLE,
-                SIGNAL_MEASUREMENT_TYPE_RSSI,
-                WIFI_PREF);
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.GERAN,
-                CALL_TYPE_VOICE,
-                SIGNAL_MEASUREMENT_TYPE_RSSI,
-                WIFI_PREF);
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.GERAN,
-                QnsConstants.CALL_TYPE_VIDEO,
-                SIGNAL_MEASUREMENT_TYPE_RSSI,
-                WIFI_PREF);
-    }
-
-    private void testIwlanThresholdConfigsArrayByPref() {
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.IWLAN,
-                CALL_TYPE_IDLE,
-                SIGNAL_MEASUREMENT_TYPE_RSSI,
-                WIFI_PREF);
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.IWLAN,
-                CALL_TYPE_VOICE,
-                SIGNAL_MEASUREMENT_TYPE_RSSI,
-                WIFI_PREF);
-        loadAndValidateForThresholdsByPref(
-                AccessNetworkConstants.AccessNetworkType.IWLAN,
-                QnsConstants.CALL_TYPE_VIDEO,
-                SIGNAL_MEASUREMENT_TYPE_RSSI,
-                WIFI_PREF);
-    }
-
-    @Test
-    public void testInvalidThresholdConfig() {
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putIntArray(
-                QnsCarrierAnspSupportConfig.KEY_IDLE_EUTRAN_RSRP_INT_ARRAY,
-                new int[] {-90, -92, QnsCarrierConfigManager.QnsConfigArray.INVALID});
-        bundle.putIntArray(
-                QnsCarrierAnspSupportConfig.KEY_IDLE_NGRAN_SSRSRP_INT_ARRAY,
-                new int[] {-97, -90, QnsCarrierConfigManager.QnsConfigArray.INVALID});
-        bundle.putIntArray(
-                QnsCarrierAnspSupportConfig.KEY_IDLE_EUTRAN_RSRQ_INT_ARRAY,
-                new int[] {-11, -15, -18});
-        bundle.putIntArray(
-                QnsCarrierAnspSupportConfig.KEY_IDLE_UTRAN_RSCP_INT_ARRAY,
-                new int[] {-90, -90, -92});
-        QnsCarrierAnspSupportConfig testConfig = mConfigManager.getQnsCarrierAnspSupportConfig();
-        testConfig.loadQnsAnspSupportArray(bundle, null);
-        int[] threshold;
-        threshold =
-                testConfig.getAnspCarrierThreshold(
-                        QnsCarrierAnspSupportConfig.KEY_IDLE_EUTRAN_RSRP_INT_ARRAY);
-        Assert.assertEquals(threshold[POLICY_GOOD], -89);
-        Assert.assertEquals(threshold[POLICY_BAD], -92);
-        Assert.assertEquals(
-                threshold[POLICY_TOLERABLE], QnsCarrierConfigManager.QnsConfigArray.INVALID);
-        threshold =
-                testConfig.getAnspCarrierThreshold(
-                        QnsCarrierAnspSupportConfig.KEY_IDLE_NGRAN_SSRSRP_INT_ARRAY);
-        Assert.assertEquals(threshold[POLICY_GOOD], KEY_DEFAULT_THRESHOLD_SSRSRP_GOOD);
-        Assert.assertEquals(threshold[POLICY_BAD], KEY_DEFAULT_THRESHOLD_SSRSRP_BAD);
-        Assert.assertEquals(
-                threshold[POLICY_TOLERABLE], QnsCarrierConfigManager.QnsConfigArray.INVALID);
-        threshold =
-                testConfig.getAnspCarrierThreshold(
-                        QnsCarrierAnspSupportConfig.KEY_IDLE_EUTRAN_RSRQ_INT_ARRAY);
-        Assert.assertEquals(threshold[POLICY_GOOD], -11);
-        Assert.assertEquals(threshold[POLICY_BAD], -15);
-        Assert.assertEquals(threshold[POLICY_TOLERABLE], -18);
-        threshold =
-                testConfig.getAnspCarrierThreshold(
-                        QnsCarrierAnspSupportConfig.KEY_IDLE_UTRAN_RSCP_INT_ARRAY);
-        Assert.assertEquals(threshold[POLICY_GOOD], -88);
-        Assert.assertEquals(threshold[POLICY_BAD], -91);
-        Assert.assertEquals(threshold[POLICY_TOLERABLE], -92);
-    }
-
-    private void loadAndValidateForThresholdsByPref(
-            @AccessNetworkConstants.RadioAccessNetworkType int an,
-            int callType,
-            int measurementType,
-            int preference) {
-
-        QnsCarrierConfigManager.QnsConfigArray threshold =
-                mConfigManager.getThresholdByPref(an, callType, measurementType, preference);
-
-        assert threshold != null;
-
-        validateForThreshold(threshold, an, callType, measurementType);
-    }
-
-    private void validateForThreshold(
-            QnsCarrierConfigManager.QnsConfigArray threshold,
-            @AccessNetworkConstants.RadioAccessNetworkType int an,
-            int callType,
-            int measurementType) {
-
-        if ((callType == CALL_TYPE_IDLE
-                        || callType == CALL_TYPE_VOICE
-                        || callType == CALL_TYPE_VIDEO)
-                && measurementType == SIGNAL_MEASUREMENT_TYPE_SSRSRP) {
-            if (an == AccessNetworkConstants.AccessNetworkType.NGRAN) {
-                Assert.assertEquals(
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_SSRSRP_GOOD, threshold.mGood);
-                Assert.assertEquals(QnsConstants.KEY_DEFAULT_THRESHOLD_SSRSRP_BAD, threshold.mBad);
-            }
-            Assert.assertEquals(0x0000FFFF, threshold.mWorst);
-        } else if ((callType == CALL_TYPE_IDLE
-                        || callType == CALL_TYPE_VOICE
-                        || callType == CALL_TYPE_VIDEO)
-                && measurementType == SIGNAL_MEASUREMENT_TYPE_RSRP) {
-            if (an == AccessNetworkConstants.AccessNetworkType.EUTRAN) {
-                Assert.assertEquals(KEY_DEFAULT_THRESHOLD_RSRP_GOOD, threshold.mGood);
-                Assert.assertEquals(QnsConstants.KEY_DEFAULT_THRESHOLD_RSRP_BAD, threshold.mBad);
-            }
-            Assert.assertEquals(0x0000FFFF, threshold.mWorst);
-        } else if ((callType == CALL_TYPE_IDLE
-                        || callType == CALL_TYPE_VOICE
-                        || callType == CALL_TYPE_VIDEO)
-                && (measurementType == SIGNAL_MEASUREMENT_TYPE_RSCP)) {
-            if (an == AccessNetworkConstants.AccessNetworkType.UTRAN) {
-                Assert.assertEquals(KEY_DEFAULT_THRESHOLD_RSCP_GOOD, threshold.mGood);
-                Assert.assertEquals(KEY_DEFAULT_THRESHOLD_RSCP_BAD, threshold.mBad);
-            }
-            Assert.assertEquals(0x0000FFFF, threshold.mWorst);
-        } else if ((callType == CALL_TYPE_IDLE || callType == CALL_TYPE_VOICE)
-                && (measurementType == SIGNAL_MEASUREMENT_TYPE_RSSI)) {
-            if (an == AccessNetworkConstants.AccessNetworkType.GERAN) {
-                Assert.assertEquals(
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_GERAN_RSSI_GOOD, threshold.mGood);
-                Assert.assertEquals(
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_GERAN_RSSI_BAD, threshold.mBad);
-            }
-            Assert.assertEquals(0x0000FFFF, threshold.mWorst);
-        } else if (an == AccessNetworkConstants.AccessNetworkType.IWLAN) {
-            if (callType == CALL_TYPE_IDLE
-                    || callType == CALL_TYPE_VOICE
-                    || callType == QnsConstants.CALL_TYPE_VIDEO) {
-                Assert.assertEquals(
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_WIFI_RSSI_GOOD, threshold.mGood);
-                Assert.assertEquals(
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_WIFI_RSSI_BAD, threshold.mBad);
-            }
-        }
-    }
-
-    @Test
-    public void testGetWifiRssiThresholdWithoutCellularWithDefaultValues() {
-        QnsCarrierConfigManager.QnsConfigArray threshold;
-
-        threshold = mConfigManager.getWifiRssiThresholdWithoutCellular(CALL_TYPE_IDLE);
-        assert threshold != null;
-        Assert.assertEquals(0x0000FFFF, threshold.mGood);
-        Assert.assertEquals(0x0000FFFF, threshold.mGood);
-
-        threshold = mConfigManager.getWifiRssiThresholdWithoutCellular(CALL_TYPE_VOICE);
-        assert threshold != null;
-        Assert.assertEquals(0x0000FFFF, threshold.mBad);
-        Assert.assertEquals(0x0000FFFF, threshold.mBad);
-
-        threshold = mConfigManager.getWifiRssiThresholdWithoutCellular(CALL_TYPE_VIDEO);
-        assert threshold != null;
-        Assert.assertEquals(0x0000FFFF, threshold.mGood);
-        Assert.assertEquals(0x0000FFFF, threshold.mBad);
-
-        threshold = mConfigManager.getWifiRssiThresholdWithoutCellular(-1);
-        Assert.assertEquals(0x0000FFFF, threshold.mGood);
-        Assert.assertEquals(0x0000FFFF, threshold.mBad);
-        Assert.assertEquals(0x0000FFFF, threshold.mWorst);
-    }
-
-    @Test
-    public void testGetWifiRssiThresholdWithoutCellularWithTestBundle() {
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putIntArray(
-                QnsCarrierAnspSupportConfig.KEY_IDLE_WIFI_RSSI_WITHOUT_CELLULAR_INT_ARRAY,
-                new int[] {-65, -70});
-        QnsCarrierAnspSupportConfig testConfig = mConfigManager.getQnsCarrierAnspSupportConfig();
-        testConfig.loadQnsAnspSupportArray(bundle, null);
-
-        QnsCarrierConfigManager.QnsConfigArray threshold =
-                mConfigManager.getWifiRssiThresholdWithoutCellular(CALL_TYPE_IDLE);
-
-        Assert.assertEquals(-65, threshold.mGood);
-        Assert.assertEquals(-70, threshold.mBad);
-    }
-
-    @Test
-    public void testGetRTPMetricsData() {
-        QnsCarrierConfigManager.RtpMetricsConfig rtpMetricsData =
-                mConfigManager.getRTPMetricsData();
-
-        Assert.assertEquals(QnsConstants.INVALID_VALUE, rtpMetricsData.mJitter);
-        Assert.assertEquals(QnsConstants.INVALID_VALUE, rtpMetricsData.mPktLossRate);
-        Assert.assertEquals(
-                QnsConstants.KEY_DEFAULT_PACKET_LOSS_TIME_MILLIS, rtpMetricsData.mPktLossTime);
-        Assert.assertEquals(QnsConstants.INVALID_VALUE, rtpMetricsData.mNoRtpInterval);
-
-        Assert.assertNotEquals(QnsConstants.KEY_DEFAULT_VALUE, rtpMetricsData.mJitter);
-        Assert.assertNotEquals(QnsConstants.KEY_DEFAULT_VALUE, rtpMetricsData.mPktLossRate);
-        Assert.assertNotEquals(QnsConstants.KEY_DEFAULT_VALUE, rtpMetricsData.mPktLossTime);
-        Assert.assertNotEquals(QnsConstants.KEY_DEFAULT_VALUE, rtpMetricsData.mNoRtpInterval);
-    }
-
-    @Test
-    public void testIsHandoverAllowedByPolicyWithTestBundle() {
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putStringArray(
-                CarrierConfigManager.KEY_IWLAN_HANDOVER_POLICY_STRING_ARRAY,
-                new String[] {HANDOVER_POLICY_0, HANDOVER_POLICY_1, HANDOVER_POLICY_2});
-        doReturn(bundle).when(mMockCarrierConfigManager).getConfigForSubId(anyInt());
-        mConfigManager.loadHandoverRules(
-                bundle, null, CarrierConfigManager.KEY_IWLAN_HANDOVER_POLICY_STRING_ARRAY);
-        assertTrue(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_IMS,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        QnsConstants.COVERAGE_HOME));
-        assertTrue(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_EIMS,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        QnsConstants.COVERAGE_HOME));
-        assertTrue(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_IMS,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        QnsConstants.COVERAGE_HOME));
-        assertFalse(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_MMS,
-                        AccessNetworkConstants.AccessNetworkType.NGRAN,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        QnsConstants.COVERAGE_HOME));
-        assertTrue(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_CBS,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        QnsConstants.COVERAGE_HOME));
-        assertTrue(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_XCAP,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        QnsConstants.COVERAGE_HOME));
-        assertFalse(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_IMS,
-                        AccessNetworkConstants.AccessNetworkType.GERAN,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        QnsConstants.COVERAGE_HOME));
-        assertFalse(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_MMS,
-                        AccessNetworkConstants.AccessNetworkType.GERAN,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        QnsConstants.COVERAGE_HOME));
-        assertFalse(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_CBS,
-                        AccessNetworkConstants.AccessNetworkType.GERAN,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        QnsConstants.COVERAGE_HOME));
-        assertFalse(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_XCAP,
-                        AccessNetworkConstants.AccessNetworkType.GERAN,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        QnsConstants.COVERAGE_HOME));
-        assertTrue(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_IMS,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        AccessNetworkConstants.AccessNetworkType.NGRAN,
-                        QnsConstants.COVERAGE_HOME));
-        assertFalse(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_IMS,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        AccessNetworkConstants.AccessNetworkType.NGRAN,
-                        QnsConstants.COVERAGE_ROAM));
-        assertTrue(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_IMS,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        AccessNetworkConstants.AccessNetworkType.UTRAN,
-                        QnsConstants.COVERAGE_HOME));
-        assertFalse(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_EIMS,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        QnsConstants.COVERAGE_HOME));
-    }
-
-    @Test
-    public void testIsHandoverAllowedByPolicyWithDefaultValues() {
-        assertArrayEquals(
-                (String[]) null,
-                QnsUtils.getConfig(
-                        null, null, CarrierConfigManager.KEY_IWLAN_HANDOVER_POLICY_STRING_ARRAY));
-    }
-
-    @Test
-    public void testGetFallbackTimeImsUnregistered() {
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putStringArray(
-                QnsCarrierConfigManager
-                        .KEY_QNS_FALLBACK_WWAN_IMS_UNREGISTRATION_REASON_STRING_ARRAY,
-                new String[] {FALLBACK_RULE0, FALLBACK_RULE1});
-        mConfigManager.loadFallbackPolicyWithImsRegiFail(bundle, null);
-        assertEquals(60000, mConfigManager.getFallbackTimeImsUnregistered(1503, CELL_PREF));
-        assertEquals(0, mConfigManager.getFallbackTimeImsUnregistered(1502, WIFI_PREF));
-        assertEquals(0, mConfigManager.getFallbackTimeImsUnregistered(1503, WIFI_ONLY));
-        assertEquals(60000, mConfigManager.getFallbackTimeImsUnregistered(321, CELL_PREF));
-        assertEquals(60000, mConfigManager.getFallbackTimeImsUnregistered(378, CELL_PREF));
-        assertEquals(90000, mConfigManager.getFallbackTimeImsUnregistered(380, CELL_PREF));
-        assertEquals(60000, mConfigManager.getFallbackTimeImsUnregistered(370, CELL_PREF));
-        assertEquals(90000, mConfigManager.getFallbackTimeImsUnregistered(370, WIFI_PREF));
-        assertEquals(90000, mConfigManager.getFallbackTimeImsUnregistered(350, WIFI_PREF));
-        assertEquals(0, mConfigManager.getFallbackTimeImsUnregistered(349, WIFI_PREF));
-        assertEquals(0, mConfigManager.getFallbackTimeImsUnregistered(360, WIFI_ONLY));
-        assertEquals(90000, mConfigManager.getFallbackTimeImsUnregistered(267, CELL_PREF));
-        assertEquals(90000, mConfigManager.getFallbackTimeImsUnregistered(232, WIFI_PREF));
-        assertEquals(0, mConfigManager.getFallbackTimeImsHoRegisterFailed(1503, CELL_PREF));
-        assertEquals(0, mConfigManager.getFallbackTimeImsHoRegisterFailed(232, WIFI_PREF));
-    }
-
-    @Test
-    public void testGetFallbackTimeImsHoRegisterFailed() {
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putStringArray(
-                QnsCarrierConfigManager
-                        .KEY_QNS_FALLBACK_WWAN_IMS_HO_REGISTER_FAIL_REASON_STRING_ARRAY,
-                new String[] {FALLBACK_RULE0, FALLBACK_RULE1});
-        mConfigManager.loadFallbackPolicyWithImsRegiFail(bundle, null);
-        assertEquals(60000, mConfigManager.getFallbackTimeImsHoRegisterFailed(1503, CELL_PREF));
-        assertEquals(0, mConfigManager.getFallbackTimeImsHoRegisterFailed(1502, WIFI_PREF));
-        assertEquals(0, mConfigManager.getFallbackTimeImsHoRegisterFailed(1503, WIFI_ONLY));
-        assertEquals(60000, mConfigManager.getFallbackTimeImsHoRegisterFailed(321, CELL_PREF));
-        assertEquals(60000, mConfigManager.getFallbackTimeImsHoRegisterFailed(378, CELL_PREF));
-        assertEquals(90000, mConfigManager.getFallbackTimeImsHoRegisterFailed(380, CELL_PREF));
-        assertEquals(60000, mConfigManager.getFallbackTimeImsHoRegisterFailed(370, CELL_PREF));
-        assertEquals(90000, mConfigManager.getFallbackTimeImsHoRegisterFailed(370, WIFI_PREF));
-        assertEquals(90000, mConfigManager.getFallbackTimeImsHoRegisterFailed(350, WIFI_PREF));
-        assertEquals(0, mConfigManager.getFallbackTimeImsHoRegisterFailed(349, WIFI_PREF));
-        assertEquals(0, mConfigManager.getFallbackTimeImsHoRegisterFailed(360, WIFI_ONLY));
-        assertEquals(90000, mConfigManager.getFallbackTimeImsHoRegisterFailed(267, CELL_PREF));
-        assertEquals(90000, mConfigManager.getFallbackTimeImsHoRegisterFailed(232, WIFI_PREF));
-        assertEquals(0, mConfigManager.getFallbackTimeImsUnregistered(1503, CELL_PREF));
-        assertEquals(0, mConfigManager.getFallbackTimeImsUnregistered(232, WIFI_PREF));
-    }
-
-    @Test
-    public void testIsMmtelCapabilityRequiredWithDefaultValues() {
-        mConfigManager.loadCarrierConfig(null);
-        assertTrue(mConfigManager.isMmtelCapabilityRequired(QnsConstants.COVERAGE_HOME));
-        assertTrue(mConfigManager.isMmtelCapabilityRequired(QnsConstants.COVERAGE_ROAM));
-    }
-
-    @Test
-    public void testIsMmtelCapabilityRequiredWithTestBundle() {
-        assertTrue(mConfigManager.isMmtelCapabilityRequired(QnsConstants.COVERAGE_HOME));
-        assertTrue(mConfigManager.isMmtelCapabilityRequired(QnsConstants.COVERAGE_ROAM));
-
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putIntArray(
-                CarrierConfigManager.Ims.KEY_IMS_PDN_ENABLED_IN_NO_VOPS_SUPPORT_INT_ARRAY,
-                new int[] {0, 1});
-        doReturn(bundle).when(mMockCarrierConfigManager).getConfigForSubId(anyInt());
-        mConfigManager.loadCarrierConfig(bundle);
-        assertFalse(mConfigManager.isMmtelCapabilityRequired(QnsConstants.COVERAGE_HOME));
-        assertFalse(mConfigManager.isMmtelCapabilityRequired(QnsConstants.COVERAGE_ROAM));
-
-        bundle = new PersistableBundle();
-        bundle.putIntArray(
-                CarrierConfigManager.Ims.KEY_IMS_PDN_ENABLED_IN_NO_VOPS_SUPPORT_INT_ARRAY,
-                new int[] {0});
-        doReturn(bundle).when(mMockCarrierConfigManager).getConfigForSubId(anyInt());
-        mConfigManager.loadCarrierConfig(bundle);
-        assertFalse(mConfigManager.isMmtelCapabilityRequired(QnsConstants.COVERAGE_HOME));
-        assertTrue(mConfigManager.isMmtelCapabilityRequired(QnsConstants.COVERAGE_ROAM));
-
-        bundle = new PersistableBundle();
-        bundle.putIntArray(
-                CarrierConfigManager.Ims.KEY_IMS_PDN_ENABLED_IN_NO_VOPS_SUPPORT_INT_ARRAY,
-                new int[] {1});
-        doReturn(bundle).when(mMockCarrierConfigManager).getConfigForSubId(anyInt());
-        mConfigManager.loadCarrierConfig(bundle);
-        assertTrue(mConfigManager.isMmtelCapabilityRequired(QnsConstants.COVERAGE_HOME));
-        assertFalse(mConfigManager.isMmtelCapabilityRequired(QnsConstants.COVERAGE_ROAM));
-
-        bundle = new PersistableBundle();
-        bundle.putIntArray(
-                CarrierConfigManager.Ims.KEY_IMS_PDN_ENABLED_IN_NO_VOPS_SUPPORT_INT_ARRAY,
-                new int[] {});
-        doReturn(bundle).when(mMockCarrierConfigManager).getConfigForSubId(anyInt());
-        mConfigManager.loadCarrierConfig(bundle);
-        assertTrue(mConfigManager.isMmtelCapabilityRequired(QnsConstants.COVERAGE_HOME));
-        assertTrue(mConfigManager.isMmtelCapabilityRequired(QnsConstants.COVERAGE_ROAM));
-
-        doReturn(null).when(mMockCarrierConfigManager).getConfigForSubId(anyInt());
-        mConfigManager.loadCarrierConfig(null);
-        assertTrue(mConfigManager.isMmtelCapabilityRequired(QnsConstants.COVERAGE_HOME));
-        assertTrue(mConfigManager.isMmtelCapabilityRequired(QnsConstants.COVERAGE_ROAM));
-    }
-
-    @Test
-    public void testCheckHandoverRuleConfigChangeWithDefaultValues() {
-        assertFalse(
-                mConfigManager.checkHandoverRuleConfigChange(
-                        null, null, CarrierConfigManager.KEY_IWLAN_HANDOVER_POLICY_STRING_ARRAY));
-        assertFalse(mConfigManager.isQnsConfigChanged());
-    }
-
-    @Test
-    public void testCheckHandoverRuleConfigChangeWithTestBundle() {
-        PersistableBundle bundleCurrent = new PersistableBundle();
-        PersistableBundle bundleNew = new PersistableBundle();
-        String key = CarrierConfigManager.KEY_IWLAN_HANDOVER_POLICY_STRING_ARRAY;
-        bundleCurrent.putStringArray(key, new String[] {HANDOVER_POLICY_3});
-        doReturn(bundleCurrent).when(mMockCarrierConfigManager).getConfigForSubId(anyInt());
-        mConfigManager.loadHandoverRules(bundleCurrent, null, key);
-        assertTrue(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_IMS,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        QnsConstants.COVERAGE_HOME));
-        assertTrue(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_IMS,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        QnsConstants.COVERAGE_HOME));
-        assertTrue(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_EIMS,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        QnsConstants.COVERAGE_HOME));
-        assertTrue(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_MMS,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        QnsConstants.COVERAGE_HOME));
-        assertTrue(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_CBS,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        QnsConstants.COVERAGE_HOME));
-        assertTrue(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_XCAP,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        QnsConstants.COVERAGE_HOME));
-        bundleNew.putStringArray(key, new String[] {HANDOVER_POLICY_4});
-        doReturn(bundleNew).when(mMockCarrierConfigManager).getConfigForSubId(anyInt());
-        assertTrue(mConfigManager.checkHandoverRuleConfigChange(bundleNew, null, key));
-        bundleNew.clear();
-        assertFalse(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_IMS,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        QnsConstants.COVERAGE_HOME));
-        assertFalse(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_EIMS,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        QnsConstants.COVERAGE_HOME));
-        assertFalse(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_MMS,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        QnsConstants.COVERAGE_HOME));
-        assertFalse(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_CBS,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        QnsConstants.COVERAGE_HOME));
-        assertFalse(
-                mConfigManager.isHandoverAllowedByPolicy(
-                        NetworkCapabilities.NET_CAPABILITY_XCAP,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        QnsConstants.COVERAGE_HOME));
-        bundleNew.putStringArray(key, new String[] {HANDOVER_POLICY_4});
-        doReturn(bundleNew).when(mMockCarrierConfigManager).getConfigForSubId(anyInt());
-        assertFalse(mConfigManager.checkHandoverRuleConfigChange(bundleNew, null, key));
-        bundleNew.clear();
-        bundleNew.putStringArray(key, new String[] {HANDOVER_POLICY_0, HANDOVER_POLICY_1});
-        doReturn(bundleNew).when(mMockCarrierConfigManager).getConfigForSubId(anyInt());
-        assertTrue(mConfigManager.checkHandoverRuleConfigChange(bundleNew, null, key));
-    }
-
-    @Test
-    public void testCheckThresholdConfigChangeWithDefaultValues() {
-        assertFalse(mConfigManager.checkThresholdConfigChange(null, null));
-        assertFalse(mConfigManager.isQnsConfigChanged());
-    }
-
-    @Test
-    public void testCheckThresholdConfigChangeWithTestBundle() {
-        PersistableBundle bundleNew = new PersistableBundle();
-        bundleNew.putIntArray(
-                QnsCarrierAnspSupportConfig.KEY_VIDEO_WIFI_RSSI_INT_ARRAY, new int[] {-60, -70});
-        doReturn(bundleNew).when(mMockCarrierConfigManager).getConfigForSubId(anyInt());
-        assertTrue(mConfigManager.checkThresholdConfigChange(bundleNew, null));
-        bundleNew.putIntArray(
-                QnsCarrierAnspSupportConfig.KEY_IDLE_EUTRAN_RSRP_INT_ARRAY,
-                new int[] {-90, -110, QnsCarrierConfigManager.QnsConfigArray.INVALID});
-        doReturn(bundleNew).when(mMockCarrierConfigManager).getConfigForSubId(anyInt());
-        assertTrue(mConfigManager.checkThresholdConfigChange(bundleNew, null));
-    }
-
-    @Test
-    public void testIsVolteRoamingSupported() {
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putBoolean(
-                CarrierConfigManager.ImsVoice.KEY_CARRIER_VOLTE_ROAMING_AVAILABLE_BOOL, false);
-        doReturn(bundle).when(mMockCarrierConfigManager).getConfigForSubId(anyInt());
-        mConfigManager.loadCarrierConfig(bundle);
-        assertTrue(mConfigManager.isVolteRoamingSupported(QnsConstants.COVERAGE_HOME));
-        assertFalse(mConfigManager.isVolteRoamingSupported(QnsConstants.COVERAGE_ROAM));
-    }
-
-    @Test
-    public void testIsAllowVideoOverIwlanWithCellularLimitedCase() {
-        Assert.assertFalse(mConfigManager.allowVideoOverIWLANWithCellularLimitedCase());
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putBoolean(KEY_QNS_ALLOW_VIDEO_OVER_IWLAN_WITH_CELLULAR_LIMITED_CASE_BOOL, true);
-        mConfigManager.loadQnsAneSupportConfigurations(bundle, null);
-        Assert.assertTrue(mConfigManager.allowVideoOverIWLANWithCellularLimitedCase());
-    }
-
-    @Test
-    public void testBlockIwlanInInternationalRoamWithoutWwan() {
-        // Test for the default setting
-        assertFalse(mConfigManager.blockIwlanInInternationalRoamWithoutWwan());
-
-        // Test for a new setting
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putBoolean(
-                QnsCarrierConfigManager.KEY_BLOCK_IWLAN_IN_INTERNATIONAL_ROAMING_WITHOUT_WWAN_BOOL,
-                true);
-        mConfigManager.loadQnsAneSupportConfigurations(null, bundle);
-        assertTrue(mConfigManager.blockIwlanInInternationalRoamWithoutWwan());
-    }
-
-    @Test
-    public void testBlockIpv6OnlyWifi() {
-        // Test for the default setting
-        assertTrue(mConfigManager.blockIpv6OnlyWifi());
-
-        // Test for a new setting
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putBoolean(QnsCarrierConfigManager.KEY_BLOCK_IPV6_ONLY_WIFI_BOOL, false);
-        mConfigManager.loadQnsAneSupportConfigurations(null, bundle);
-        assertFalse(mConfigManager.blockIpv6OnlyWifi());
-    }
-
-    @Test
-    public void testFallbackConfigOnInitialDataConnectionFailWithDefaultValue() {
-        mConfigManager.loadQnsAneSupportConfigurations(null, null);
-        int[] imsFallbackConfigs =
-                mConfigManager.getInitialDataConnectionFallbackConfig(
-                        NetworkCapabilities.NET_CAPABILITY_IMS);
-        int imsFallbackGuardTimer =
-                mConfigManager.getFallbackGuardTimerOnInitialConnectionFail(
-                        NetworkCapabilities.NET_CAPABILITY_IMS);
-
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, imsFallbackConfigs[0]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, imsFallbackConfigs[1]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, imsFallbackConfigs[2]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, imsFallbackGuardTimer);
-
-        int[] mmsFallbackConfigs =
-                mConfigManager.getInitialDataConnectionFallbackConfig(
-                        NetworkCapabilities.NET_CAPABILITY_MMS);
-        int mmsFallbackGuardTimer =
-                mConfigManager.getFallbackGuardTimerOnInitialConnectionFail(
-                        NetworkCapabilities.NET_CAPABILITY_MMS);
-
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, mmsFallbackConfigs[0]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, mmsFallbackConfigs[1]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, mmsFallbackConfigs[2]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, mmsFallbackConfigs[3]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, mmsFallbackGuardTimer);
-    }
-
-    @Test
-    public void testFallbackConfigOnInitialDataConnectionFailWithNullValue() {
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putStringArray(
-                QnsCarrierConfigManager.KEY_QNS_FALLBACK_ON_INITIAL_CONNECTION_FAILURE_STRING_ARRAY,
-                null);
-        mConfigManager.loadQnsAneSupportConfigurations(null, bundle);
-
-        int[] imsFallbackConfigs =
-                mConfigManager.getInitialDataConnectionFallbackConfig(
-                        NetworkCapabilities.NET_CAPABILITY_IMS);
-        int imsFallbackGuardTimer =
-                mConfigManager.getFallbackGuardTimerOnInitialConnectionFail(
-                        NetworkCapabilities.NET_CAPABILITY_IMS);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, imsFallbackConfigs[0]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, imsFallbackConfigs[1]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, imsFallbackConfigs[2]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, imsFallbackConfigs[3]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, imsFallbackGuardTimer);
-
-        int[] mmsFallbackConfigs =
-                mConfigManager.getInitialDataConnectionFallbackConfig(
-                        NetworkCapabilities.NET_CAPABILITY_MMS);
-        int mmsFallbackGuardTimer =
-                mConfigManager.getFallbackGuardTimerOnInitialConnectionFail(
-                        NetworkCapabilities.NET_CAPABILITY_MMS);
-
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, mmsFallbackConfigs[0]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, mmsFallbackConfigs[1]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, mmsFallbackConfigs[2]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, mmsFallbackConfigs[3]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, mmsFallbackGuardTimer);
-
-        int[] xcapFallbackConfigs =
-                mConfigManager.getInitialDataConnectionFallbackConfig(
-                        NetworkCapabilities.NET_CAPABILITY_MMS);
-        int xcapFallbackGuardTimer =
-                mConfigManager.getFallbackGuardTimerOnInitialConnectionFail(
-                        NetworkCapabilities.NET_CAPABILITY_XCAP);
-
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, xcapFallbackConfigs[0]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, xcapFallbackConfigs[1]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, xcapFallbackConfigs[2]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, xcapFallbackConfigs[3]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, xcapFallbackGuardTimer);
-    }
-
-    @Test
-    public void testFallbackOnInitialDataConnectionFailForMultiplePdnWithBothConfigs() {
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putStringArray(
-                QnsCarrierConfigManager.KEY_QNS_FALLBACK_ON_INITIAL_CONNECTION_FAILURE_STRING_ARRAY,
-                new String[] {"ims:2:30000:60000:5"});
-        mConfigManager.loadQnsAneSupportConfigurations(null, bundle);
-        int[] imsFallbackConfigs =
-                mConfigManager.getInitialDataConnectionFallbackConfig(
-                        NetworkCapabilities.NET_CAPABILITY_IMS);
-        int imsFallbackGuardTimer =
-                mConfigManager.getFallbackGuardTimerOnInitialConnectionFail(
-                        NetworkCapabilities.NET_CAPABILITY_IMS);
-
-        assertEquals(1, imsFallbackConfigs[0]);
-        assertEquals(2, imsFallbackConfigs[1]);
-        assertEquals(30000, imsFallbackConfigs[2]);
-        assertEquals(5, imsFallbackConfigs[3]);
-        assertEquals(60000, imsFallbackGuardTimer);
-
-        bundle.putStringArray(
-                QnsCarrierConfigManager.KEY_QNS_FALLBACK_ON_INITIAL_CONNECTION_FAILURE_STRING_ARRAY,
-                new String[] {"ims:2:30000:60000:3", "mms:1:10000:5000:2"});
-        mConfigManager.loadQnsAneSupportConfigurations(null, bundle);
-
-        int[] mmsFallbackConfigs =
-                mConfigManager.getInitialDataConnectionFallbackConfig(
-                        NetworkCapabilities.NET_CAPABILITY_MMS);
-        int mmsFallbackGuardTimer =
-                mConfigManager.getFallbackGuardTimerOnInitialConnectionFail(
-                        NetworkCapabilities.NET_CAPABILITY_MMS);
-
-        assertEquals(1, mmsFallbackConfigs[0]);
-        assertEquals(1, mmsFallbackConfigs[1]);
-        assertEquals(10000, mmsFallbackConfigs[2]);
-        assertEquals(2, mmsFallbackConfigs[3]);
-        assertEquals(5000, mmsFallbackGuardTimer);
-    }
-
-    @Test
-    public void testFallbackConfigOnInitialDataConnectionFailWithEmptyValues() {
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putStringArray(
-                QnsCarrierConfigManager.KEY_QNS_FALLBACK_ON_INITIAL_CONNECTION_FAILURE_STRING_ARRAY,
-                new String[] {""});
-        mConfigManager.loadQnsAneSupportConfigurations(null, bundle);
-        int[] imsFallbackConfigs =
-                mConfigManager.getInitialDataConnectionFallbackConfig(
-                        NetworkCapabilities.NET_CAPABILITY_IMS);
-        int imsFallbackGuardTimer =
-                mConfigManager.getFallbackGuardTimerOnInitialConnectionFail(
-                        NetworkCapabilities.NET_CAPABILITY_IMS);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, imsFallbackConfigs[0]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, imsFallbackConfigs[1]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, imsFallbackConfigs[2]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, imsFallbackConfigs[3]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, imsFallbackGuardTimer);
-
-        bundle.putStringArray(
-                QnsCarrierConfigManager.KEY_QNS_FALLBACK_ON_INITIAL_CONNECTION_FAILURE_STRING_ARRAY,
-                new String[] {"ims:"});
-        mConfigManager.loadQnsAneSupportConfigurations(null, bundle);
-        imsFallbackConfigs =
-                mConfigManager.getInitialDataConnectionFallbackConfig(
-                        NetworkCapabilities.NET_CAPABILITY_IMS);
-        imsFallbackGuardTimer =
-                mConfigManager.getFallbackGuardTimerOnInitialConnectionFail(
-                        NetworkCapabilities.NET_CAPABILITY_IMS);
-
-        assertEquals(1, imsFallbackConfigs[0]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, imsFallbackConfigs[1]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, imsFallbackConfigs[2]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, imsFallbackConfigs[3]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, imsFallbackGuardTimer);
-    }
-
-    @Test
-    public void testFallbackOnInitialDataConnectionFailWithRetryCounterConfigOnly() {
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putStringArray(
-                QnsCarrierConfigManager.KEY_QNS_FALLBACK_ON_INITIAL_CONNECTION_FAILURE_STRING_ARRAY,
-                new String[] {"ims:2::30000:3"});
-        mConfigManager.loadQnsAneSupportConfigurations(null, bundle);
-        int[] imsFallbackConfigs =
-                mConfigManager.getInitialDataConnectionFallbackConfig(
-                        NetworkCapabilities.NET_CAPABILITY_IMS);
-        int imsFallbackGuardTimer =
-                mConfigManager.getFallbackGuardTimerOnInitialConnectionFail(
-                        NetworkCapabilities.NET_CAPABILITY_IMS);
-
-        assertEquals(1, imsFallbackConfigs[0]);
-        assertEquals(2, imsFallbackConfigs[1]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, imsFallbackConfigs[2]);
-        assertEquals(3, imsFallbackConfigs[3]);
-        assertEquals(30000, imsFallbackGuardTimer);
-    }
-
-    @Test
-    public void testFallbackOnInitialDataConnectionFailWithRetryTimerConfigOnly() {
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putStringArray(
-                QnsCarrierConfigManager.KEY_QNS_FALLBACK_ON_INITIAL_CONNECTION_FAILURE_STRING_ARRAY,
-                new String[] {"ims::30000:60000:4"});
-        mConfigManager.loadQnsAneSupportConfigurations(null, bundle);
-        int[] imsFallbackConfigs =
-                mConfigManager.getInitialDataConnectionFallbackConfig(
-                        NetworkCapabilities.NET_CAPABILITY_IMS);
-        int imsFallbackGuardTimer =
-                mConfigManager.getFallbackGuardTimerOnInitialConnectionFail(
-                        NetworkCapabilities.NET_CAPABILITY_IMS);
-        assertEquals(1, imsFallbackConfigs[0]);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, imsFallbackConfigs[1]);
-        assertEquals(30000, imsFallbackConfigs[2]);
-        assertEquals(4, imsFallbackConfigs[3]);
-        assertEquals(60000, imsFallbackGuardTimer);
-    }
-
-    @Test
-    public void testGetSubId() {
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, mConfigManager.getSubId());
-    }
-
-    @Test
-    public void testGetCarrierId() {
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, mConfigManager.getCarrierId());
-
-        when(sMockContext.getSystemService(TelephonyManager.class)).thenReturn(null);
-        assertEquals(QnsConstants.KEY_DEFAULT_VALUE, mConfigManager.getCarrierId());
-    }
-
-    @Test
-    public void testNotifyLoadQnsConfigurationsCompleted() throws InterruptedException {
-        when(mMockTelephonyManager.getSimCarrierId()).thenReturn(1);
-        validateLoadQnsConfigurationCompleted();
-    }
-
-    @Test
-    public void testQnsLoadingEventOnInvalidCarrierID() throws InterruptedException {
-        when(mMockTelephonyManager.getSimCarrierId()).thenReturn(0);
-        validateLoadQnsConfigurationForInvalidCarrierID();
-        when(mMockTelephonyManager.getSimCarrierId()).thenReturn(-1);
-        validateLoadQnsConfigurationForInvalidCarrierID();
-    }
-
-    @Test
-    public void testUnregisterForConfigurationLoaded() throws InterruptedException {
-        when(mMockTelephonyManager.getSimCarrierId()).thenReturn(1);
-        mConfigManager.unregisterForConfigurationLoaded(mHandler);
-        mConfigManager.mHandler.handleMessage(Message.obtain(mConfigManager.mHandler, 1, null));
-        mLatch.await(2, TimeUnit.SECONDS);
-        Message msg = mTestLooper.nextMessage();
-        assertNull(msg);
-    }
-
-    private void validateLoadQnsConfigurationCompleted() throws InterruptedException {
-        mConfigManager.registerForConfigurationLoaded(mHandler, 1);
-        mConfigManager.mHandler.handleMessage(Message.obtain(mConfigManager.mHandler, 1, null));
-        mLatch.await(2, TimeUnit.SECONDS);
-        Message msg = mTestLooper.nextMessage();
-        assertNotNull(msg);
-        assertEquals(1, msg.what);
-    }
-
-    private void validateLoadQnsConfigurationForInvalidCarrierID() throws InterruptedException {
-        mConfigManager.registerForConfigurationLoaded(mHandler, 1);
-        mConfigManager.mHandler.handleMessage(Message.obtain(mConfigManager.mHandler, 1, null));
-        mLatch.await(2, TimeUnit.SECONDS);
-        Message msg = mTestLooper.nextMessage();
-        assertNull(msg);
-    }
-
-    @Test
-    public void testNotifyQnsConfigurationsChangedEvent() throws InterruptedException {
-        setupQnsConfigurationChange(CarrierConfigManager.KEY_IWLAN_HANDOVER_POLICY_STRING_ARRAY);
-        validateLoadQnsConfigurationCompleted();
-        updateQnsConfiguration(CarrierConfigManager.KEY_IWLAN_HANDOVER_POLICY_STRING_ARRAY);
-        mConfigManager.registerForConfigurationChanged(mHandler, 3);
-        mConfigManager.mHandler.handleMessage(Message.obtain(mConfigManager.mHandler, 1, null));
-        mLatch.await(2, TimeUnit.SECONDS);
-        Message msg = mTestLooper.nextMessage();
-        assertNotNull(msg);
-        assertEquals(3, msg.what);
-    }
-
-    @Test
-    public void testOnQnsConfigurationNotChanged() throws InterruptedException {
-        when(mMockTelephonyManager.getSimCarrierId()).thenReturn(1);
-        validateLoadQnsConfigurationCompleted();
-        updateQnsConfiguration(CarrierConfigManager.KEY_IWLAN_HANDOVER_POLICY_STRING_ARRAY);
-        mConfigManager.registerForConfigurationChanged(mHandler, 3);
-        mConfigManager.mHandler.handleMessage(Message.obtain(mConfigManager.mHandler, 1, null));
-        mLatch.await(2, TimeUnit.SECONDS);
-        Message msg = mTestLooper.nextMessage();
-        assertNull(msg);
-    }
-
-    @Test
-    public void testUnregisterForConfigurationChanged() throws InterruptedException {
-        setupQnsConfigurationChange(CarrierConfigManager.KEY_IWLAN_HANDOVER_POLICY_STRING_ARRAY);
-        validateLoadQnsConfigurationCompleted();
-        updateQnsConfiguration(CarrierConfigManager.KEY_IWLAN_HANDOVER_POLICY_STRING_ARRAY);
-        mConfigManager.unregisterForConfigurationChanged(mHandler);
-        mConfigManager.mHandler.handleMessage(Message.obtain(mConfigManager.mHandler, 1, null));
-        mLatch.await(2, TimeUnit.SECONDS);
-        Message msg = mTestLooper.nextMessage();
-        assertNull(msg);
-    }
-
-    private void setupQnsConfigurationChange(String key) {
-        PersistableBundle bundleCurrent = new PersistableBundle();
-        when(mMockTelephonyManager.getSimCarrierId()).thenReturn(1);
-        bundleCurrent.putStringArray(key, new String[] {HANDOVER_POLICY_3});
-        doReturn(bundleCurrent).when(mMockCarrierConfigManager).getConfigForSubId(anyInt());
-        mConfigManager.loadHandoverRules(bundleCurrent, null, key);
-    }
-
-    private void updateQnsConfiguration(String key) {
-        PersistableBundle bundleNew = new PersistableBundle();
-        bundleNew.putStringArray(key, new String[] {HANDOVER_POLICY_4});
-        doReturn(bundleNew).when(mMockCarrierConfigManager).getConfigForSubId(anyInt());
-    }
-
-    @Test
-    public void testApplyProvisioningInfo() throws Exception {
-        QnsProvisioningListener.QnsProvisioningInfo info =
-                new QnsProvisioningListener.QnsProvisioningInfo();
-        ConcurrentHashMap<Integer, Integer> integerItems = new ConcurrentHashMap<>();
-        integerItems.put(ProvisioningManager.KEY_LTE_THRESHOLD_1, -95); // bad
-        integerItems.put(ProvisioningManager.KEY_LTE_THRESHOLD_2, -110); // worst
-        integerItems.put(ProvisioningManager.KEY_LTE_THRESHOLD_3, -80); // good
-
-        // update private object
-        setObject(info, "mIntegerItems", integerItems);
-
-        mConfigManager.setQnsProvisioningInfo(info);
-        QnsCarrierConfigManager.QnsConfigArray configArray =
-                new QnsCarrierConfigManager.QnsConfigArray(-90, -100, -120);
-
-        // invoke private method
-        configArray =
-                invokeApplyProvisioningInfo(
-                        configArray,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SIGNAL_MEASUREMENT_TYPE_RSRP,
-                        CALL_TYPE_IDLE);
-
-        assertEquals(-95, configArray.mBad);
-        assertEquals(-110, configArray.mWorst);
-        assertEquals(-80, configArray.mGood);
-
-        integerItems.clear();
-        integerItems.put(ProvisioningManager.KEY_WIFI_THRESHOLD_A, -50); // good
-        integerItems.put(ProvisioningManager.KEY_WIFI_THRESHOLD_B, -70); // bad
-
-        // update private object
-        setObject(info, "mIntegerItems", integerItems);
-        mConfigManager.setQnsProvisioningInfo(info);
-
-        // invoke private method
-        configArray =
-                invokeApplyProvisioningInfo(
-                        configArray,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SIGNAL_MEASUREMENT_TYPE_RSSI,
-                        CALL_TYPE_IDLE);
-        assertEquals(-70, configArray.mBad);
-        assertEquals(-50, configArray.mGood);
-
-        when(mMockTelephonyManager.createForSubscriptionId(anyInt()))
-                .thenReturn(mMockTelephonyManager);
-        when(mMockTelephonyManager.getSimCarrierId()).thenReturn(1839);
-
-        // invoke private method
-        configArray =
-                invokeApplyProvisioningInfo(
-                        configArray,
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SIGNAL_MEASUREMENT_TYPE_RSSI,
-                        CALL_TYPE_VIDEO);
-        assertEquals(-70 + 5, configArray.mBad);
-        assertEquals(-50, configArray.mGood);
-    }
-
-    @Test
-    public void testWlanRttConfigsWithDefaultValue() {
-        mConfigManager.loadQnsAneSupportConfigurations(null, null);
-        assertNull(mConfigManager.getWlanRttServerAddressConfig());
-        int[] pingConfigs = mConfigManager.getWlanRttOtherConfigs();
-        assertEquals(0, pingConfigs[0]);
-        assertEquals(0, pingConfigs[1]);
-        assertEquals(0, pingConfigs[2]);
-        assertEquals(0, pingConfigs[3]);
-        assertEquals(0, pingConfigs[4]);
-        assertEquals(0, mConfigManager.getWlanRttFallbackHystTimer());
-    }
-
-    @Test
-    public void testWlanRttConfigsWithDomainAddressPersistBundleValue() {
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putString(
-                QnsCarrierConfigManager.KEY_QNS_WLAN_RTT_BACKHAUL_CHECK_ON_ICMP_PING_STRING,
-                "www.google.com,5,200,32,100,600000,1800000");
-        mConfigManager.loadQnsAneSupportConfigurations(null, bundle);
-        assertEquals("www.google.com", mConfigManager.getWlanRttServerAddressConfig());
-
-        int[] pingConfigs = mConfigManager.getWlanRttOtherConfigs();
-        assertEquals(5, pingConfigs[0]);
-        assertEquals(200, pingConfigs[1]);
-        assertEquals(32, pingConfigs[2]);
-        assertEquals(100, pingConfigs[3]);
-        assertEquals(600000, pingConfigs[4]);
-        assertEquals(1800000, mConfigManager.getWlanRttFallbackHystTimer());
-    }
-
-    @Test
-    public void testWlanRttConfigsWithStaticAddressPersistBundleValue() {
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putString(
-                QnsCarrierConfigManager.KEY_QNS_WLAN_RTT_BACKHAUL_CHECK_ON_ICMP_PING_STRING,
-                "8.8.8.8,3,200,32,50,20000,10000");
-        mConfigManager.loadQnsAneSupportConfigurations(null, bundle);
-
-        assertEquals("8.8.8.8", mConfigManager.getWlanRttServerAddressConfig());
-
-        int[] pingConfigs = mConfigManager.getWlanRttOtherConfigs();
-        assertEquals(3, pingConfigs[0]);
-        assertEquals(200, pingConfigs[1]);
-        assertEquals(32, pingConfigs[2]);
-        assertEquals(50, pingConfigs[3]);
-        assertEquals(20000, pingConfigs[4]);
-        assertEquals(10000, mConfigManager.getWlanRttFallbackHystTimer());
-    }
-
-    private void setObject(Object obj, String field, ConcurrentHashMap<Integer, Integer> value)
-            throws NoSuchFieldException, IllegalAccessException {
-        Field f = QnsProvisioningListener.QnsProvisioningInfo.class.getDeclaredField(field);
-        f.setAccessible(true);
-        f.set(obj, value);
-    }
-
-    private QnsCarrierConfigManager.QnsConfigArray invokeApplyProvisioningInfo(
-            QnsCarrierConfigManager.QnsConfigArray configArray,
-            int accessNetwork,
-            int measType,
-            int callType)
-            throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
-        Method m =
-                QnsCarrierConfigManager.class.getDeclaredMethod(
-                        "applyProvisioningInfo",
-                        QnsCarrierConfigManager.QnsConfigArray.class,
-                        int.class,
-                        int.class,
-                        int.class);
-        m.setAccessible(true);
-        return (QnsCarrierConfigManager.QnsConfigArray)
-                m.invoke(mConfigManager, configArray, accessNetwork, measType, callType);
-    }
-
-    @Test
-    public void testGetVowifiRegistrationTimerForVowifiActivation() {
-        // Test for the default setting
-        int defaultTimer = mConfigManager.getVowifiRegistrationTimerForVowifiActivation();
-        Assert.assertEquals(CONFIG_DEFAULT_VOWIFI_REGISTATION_TIMER, defaultTimer);
-
-        // Test for a new setting
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putInt(KEY_QNS_VOWIFI_REGISTATION_TIMER_FOR_VOWIFI_ACTIVATION_INT, 60000);
-        mConfigManager.loadWfcConfigurations(null, bundle);
-        Assert.assertEquals(60000, mConfigManager.getVowifiRegistrationTimerForVowifiActivation());
-    }
-
-    @Test
-    public void testGetSipDialogSessionPolicy() {
-        // Test for the default setting
-        int defaultPolicy = mConfigManager.getSipDialogSessionPolicy();
-        Assert.assertEquals(QnsConstants.SIP_DIALOG_SESSION_POLICY_NONE, defaultPolicy);
-
-        // Test for a new setting
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putInt(
-                KEY_SIP_DIALOG_SESSION_POLICY_INT,
-                QnsConstants.SIP_DIALOG_SESSION_POLICY_FOLLOW_VOICE_CALL);
-        mConfigManager.loadQnsAneSupportConfigurations(null, bundle);
-        int SipDialogSessionPolicy = mConfigManager.getSipDialogSessionPolicy();
-        Assert.assertEquals(
-                QnsConstants.SIP_DIALOG_SESSION_POLICY_FOLLOW_VOICE_CALL, SipDialogSessionPolicy);
-    }
-
-    @After
-    public void tearDown() {
-        mConfigManager.close();
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsComponentsTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsComponentsTest.java
deleted file mode 100644
index 73a5249..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsComponentsTest.java
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.mockito.Mockito.verify;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.MockitoAnnotations;
-
-@RunWith(JUnit4.class)
-public class QnsComponentsTest extends QnsTest {
-
-    @Before
-    public void setUp() throws Exception {
-        MockitoAnnotations.initMocks(this);
-        super.setUp();
-    }
-
-    @Test
-    public void testCreateQnsComponents() {
-        int slotId = 0;
-        QnsComponents qnsComponents = new QnsComponents(sMockContext);
-
-        assertNull(qnsComponents.getQnsTelephonyListener(slotId));
-        assertNull(qnsComponents.getQnsImsManager(slotId));
-        assertNull(qnsComponents.getCellularNetworkStatusTracker(slotId));
-        assertNull(qnsComponents.getCellularQualityMonitor(slotId));
-        assertNull(qnsComponents.getQnsProvisioningListener(slotId));
-        assertNull(qnsComponents.getQnsEventDispatcher(slotId));
-        assertNull(qnsComponents.getQnsCarrierConfigManager(slotId));
-        assertNull(qnsComponents.getQnsCallStatusTracker(slotId));
-        assertNull(qnsComponents.getWifiBackhaulMonitor(slotId));
-        assertNull(qnsComponents.getWifiQualityMonitor());
-        assertNull(qnsComponents.getIwlanNetworkStatusTracker());
-        assertNull(qnsComponents.getQnsTimer());
-
-        qnsComponents.createQnsComponents(slotId);
-
-        assertNotNull(qnsComponents.getQnsTelephonyListener(slotId));
-        assertNotNull(qnsComponents.getQnsImsManager(slotId));
-        assertNotNull(qnsComponents.getCellularNetworkStatusTracker(slotId));
-        assertNotNull(qnsComponents.getCellularQualityMonitor(slotId));
-        assertNotNull(qnsComponents.getQnsProvisioningListener(slotId));
-        assertNotNull(qnsComponents.getQnsEventDispatcher(slotId));
-        assertNotNull(qnsComponents.getQnsCarrierConfigManager(slotId));
-        assertNotNull(qnsComponents.getQnsCallStatusTracker(slotId));
-        assertNotNull(qnsComponents.getWifiBackhaulMonitor(slotId));
-        assertNotNull(qnsComponents.getWifiQualityMonitor());
-        assertNotNull(qnsComponents.getIwlanNetworkStatusTracker());
-        assertNotNull(qnsComponents.getQnsTimer());
-    }
-
-
-    @Test
-    public void testCloseQnsComponents() {
-        int slotId = 0;
-        QnsComponents qnsComponents = new QnsComponents(
-                sMockContext,
-                mMockCellNetStatusTracker,
-                mMockCellularQm,
-                mMockIwlanNetworkStatusTracker,
-                mMockQnsImsManager,
-                mMockQnsConfigManager,
-                mMockQnsEventDispatcher,
-                mMockQnsProvisioningListener,
-                mMockQnsTelephonyListener,
-                mMockQnsCallStatusTracker,
-                mMockQnsTimer,
-                mMockWifiBm,
-                mMockWifiQm,
-                mMockQnsMetrics,
-                slotId);
-
-        assertNotNull(qnsComponents.getQnsTelephonyListener(slotId));
-        assertNotNull(qnsComponents.getQnsImsManager(slotId));
-        assertNotNull(qnsComponents.getCellularNetworkStatusTracker(slotId));
-        assertNotNull(qnsComponents.getCellularQualityMonitor(slotId));
-        assertNotNull(qnsComponents.getQnsProvisioningListener(slotId));
-        assertNotNull(qnsComponents.getQnsEventDispatcher(slotId));
-        assertNotNull(qnsComponents.getQnsCarrierConfigManager(slotId));
-        assertNotNull(qnsComponents.getQnsCallStatusTracker(slotId));
-        assertNotNull(qnsComponents.getWifiBackhaulMonitor(slotId));
-        assertNotNull(qnsComponents.getWifiQualityMonitor());
-        assertNotNull(qnsComponents.getIwlanNetworkStatusTracker());
-        assertNotNull(qnsComponents.getQnsTimer());
-        assertNotNull(qnsComponents.getQnsMetrics());
-
-        qnsComponents.closeComponents(slotId);
-
-        assertNull(qnsComponents.getQnsTelephonyListener(slotId));
-        assertNull(qnsComponents.getQnsImsManager(slotId));
-        assertNull(qnsComponents.getCellularNetworkStatusTracker(slotId));
-        assertNull(qnsComponents.getCellularQualityMonitor(slotId));
-        assertNull(qnsComponents.getQnsProvisioningListener(slotId));
-        assertNull(qnsComponents.getQnsEventDispatcher(slotId));
-        assertNull(qnsComponents.getQnsCarrierConfigManager(slotId));
-        assertNull(qnsComponents.getQnsCallStatusTracker(slotId));
-        assertNull(qnsComponents.getWifiBackhaulMonitor(slotId));
-        assertNull(qnsComponents.getWifiQualityMonitor());
-        assertNull(qnsComponents.getIwlanNetworkStatusTracker());
-        assertNull(qnsComponents.getQnsTimer());
-        assertNull(qnsComponents.getQnsMetrics());
-
-        verify(mMockQnsTelephonyListener).close();
-        verify(mMockQnsImsManager).close();
-        verify(mMockCellNetStatusTracker).close();
-        verify(mMockCellularQm).close();
-        verify(mMockQnsProvisioningListener).close();
-        verify(mMockQnsEventDispatcher).close();
-        verify(mMockQnsConfigManager).close();
-        verify(mMockQnsCallStatusTracker).close();
-        verify(mMockWifiBm).close();
-        verify(mMockWifiQm).close();
-        verify(mMockIwlanNetworkStatusTracker).close();
-        verify(mMockQnsTimer).close();
-        verify(mMockQnsMetrics).close();
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsConstantsTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsConstantsTest.java
deleted file mode 100644
index a80bae5..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsConstantsTest.java
+++ /dev/null
@@ -1,300 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import android.telephony.AccessNetworkConstants;
-import android.telephony.AccessNetworkConstants.AccessNetworkType;
-import android.telephony.TelephonyManager;
-
-import org.junit.Assert;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class QnsConstantsTest {
-
-    @Test
-    public void testCallTypeToString() {
-        String callType_str = null;
-
-        callType_str = QnsConstants.callTypeToString(QnsConstants.CALL_TYPE_IDLE);
-        Assert.assertEquals(callType_str, "IDLE");
-        callType_str = QnsConstants.callTypeToString(QnsConstants.CALL_TYPE_VOICE);
-        Assert.assertEquals(callType_str, "VOICE");
-        callType_str = QnsConstants.callTypeToString(QnsConstants.CALL_TYPE_VIDEO);
-        Assert.assertEquals(callType_str, "VIDEO");
-        callType_str = QnsConstants.callTypeToString(QnsConstants.CALL_TYPE_EMERGENCY);
-        Assert.assertEquals(callType_str, "SOS");
-        callType_str = QnsConstants.callTypeToString(-1);
-        Assert.assertEquals(callType_str, "");
-    }
-
-    @Test
-    public void testCoverageToString() {
-        String coverage_str = null;
-
-        coverage_str = QnsConstants.coverageToString(QnsConstants.COVERAGE_HOME);
-        Assert.assertEquals(coverage_str, "HOME");
-        coverage_str = QnsConstants.coverageToString(QnsConstants.COVERAGE_ROAM);
-        Assert.assertEquals(coverage_str, "ROAM");
-        coverage_str = QnsConstants.coverageToString(2);
-        Assert.assertEquals(coverage_str, "");
-    }
-
-    @Test
-    public void testPreferenceToString() {
-        String preference_str = null;
-
-        preference_str = QnsConstants.preferenceToString(QnsConstants.WIFI_ONLY);
-        Assert.assertEquals(preference_str, "WIFI_ONLY");
-        preference_str = QnsConstants.preferenceToString(QnsConstants.CELL_PREF);
-        Assert.assertEquals(preference_str, "CELL_PREF");
-        preference_str = QnsConstants.preferenceToString(QnsConstants.WIFI_PREF);
-        Assert.assertEquals(preference_str, "WIFI_PREF");
-
-        preference_str = QnsConstants.preferenceToString(3);
-        Assert.assertEquals(preference_str, "");
-    }
-
-    @Test
-    public void testDirectionToString() {
-        String direction_str = null;
-
-        direction_str = QnsConstants.directionToString(QnsConstants.ROVE_IN);
-        Assert.assertEquals(direction_str, "ROVE_IN");
-        direction_str = QnsConstants.directionToString(QnsConstants.ROVE_OUT);
-        Assert.assertEquals(direction_str, "ROVE_OUT");
-    }
-
-    @Test
-    public void testGuardingToString() {
-        String guarding_str = null;
-
-        guarding_str = QnsConstants.guardingToString(QnsConstants.GUARDING_NONE);
-        Assert.assertEquals(guarding_str, "GUARDING_NONE");
-        guarding_str = QnsConstants.guardingToString(QnsConstants.GUARDING_CELLULAR);
-        Assert.assertEquals(guarding_str, "GUARDING_CELL");
-        guarding_str = QnsConstants.guardingToString(QnsConstants.GUARDING_WIFI);
-        Assert.assertEquals(guarding_str, "GUARDING_WIFI");
-        guarding_str = QnsConstants.guardingToString(QnsConstants.INVALID_ID);
-        Assert.assertEquals(guarding_str, "");
-    }
-
-    @Test
-    public void imsRegistrationEventToString() {
-        String imsRegEvent_str = null;
-
-        imsRegEvent_str =
-                QnsConstants.imsRegistrationEventToString(
-                        QnsConstants.IMS_REGISTRATION_CHANGED_UNREGISTERED);
-        Assert.assertEquals(imsRegEvent_str, "IMS_REGISTRATION_CHANGED_UNREGISTERED");
-        imsRegEvent_str =
-                QnsConstants.imsRegistrationEventToString(
-                        QnsConstants.IMS_REGISTRATION_CHANGED_ACCESS_NETWORK_CHANGE_FAILED);
-        Assert.assertEquals(
-                imsRegEvent_str, "IMS_REGISTRATION_CHANGED_ACCESS_NETWORK_CHANGE_FAILED");
-        imsRegEvent_str =
-                QnsConstants.imsRegistrationEventToString(
-                        QnsConstants.IMS_REGISTRATION_CHANGED_REGISTERED);
-        Assert.assertEquals(imsRegEvent_str, "IMS_REGISTRATION_CHANGED_REGISTERED");
-        imsRegEvent_str = QnsConstants.imsRegistrationEventToString(QnsConstants.INVALID_ID);
-        Assert.assertEquals(imsRegEvent_str, "");
-    }
-
-    @Test
-    public void testAccessNetworkTypeToString() {
-        String accessNetwork;
-
-        accessNetwork = QnsConstants.accessNetworkTypeToString(AccessNetworkType.UNKNOWN);
-        Assert.assertEquals("UNKNOWN", accessNetwork);
-        accessNetwork = QnsConstants.accessNetworkTypeToString(AccessNetworkType.NGRAN);
-        Assert.assertEquals("NGRAN", accessNetwork);
-        accessNetwork = QnsConstants.accessNetworkTypeToString(AccessNetworkType.EUTRAN);
-        Assert.assertEquals("EUTRAN", accessNetwork);
-        accessNetwork = QnsConstants.accessNetworkTypeToString(AccessNetworkType.UTRAN);
-        Assert.assertEquals("UTRAN", accessNetwork);
-        accessNetwork = QnsConstants.accessNetworkTypeToString(AccessNetworkType.CDMA2000);
-        Assert.assertEquals("CDMA2000", accessNetwork);
-        accessNetwork = QnsConstants.accessNetworkTypeToString(AccessNetworkType.GERAN);
-        Assert.assertEquals("GERAN", accessNetwork);
-        accessNetwork = QnsConstants.accessNetworkTypeToString(AccessNetworkType.IWLAN);
-        Assert.assertEquals("IWLAN", accessNetwork);
-        accessNetwork = QnsConstants.accessNetworkTypeToString(-1);
-        Assert.assertEquals("-1", accessNetwork);
-    }
-
-    @Test
-    public void testAccessNetworkTypeFromString() {
-        int accessNetwork;
-
-        accessNetwork = QnsConstants.accessNetworkTypeFromString("TEST");
-        Assert.assertEquals(AccessNetworkType.UNKNOWN, accessNetwork);
-        accessNetwork = QnsConstants.accessNetworkTypeFromString("NGRAN");
-        Assert.assertEquals(AccessNetworkType.NGRAN, accessNetwork);
-        accessNetwork = QnsConstants.accessNetworkTypeFromString("EUTRAN");
-        Assert.assertEquals(AccessNetworkType.EUTRAN, accessNetwork);
-        accessNetwork = QnsConstants.accessNetworkTypeFromString("UTRAN");
-        Assert.assertEquals(AccessNetworkType.UTRAN, accessNetwork);
-        accessNetwork = QnsConstants.accessNetworkTypeFromString("CDMA2000");
-        Assert.assertEquals(AccessNetworkType.CDMA2000, accessNetwork);
-        accessNetwork = QnsConstants.accessNetworkTypeFromString("GERAN");
-        Assert.assertEquals(AccessNetworkType.GERAN, accessNetwork);
-        accessNetwork = QnsConstants.accessNetworkTypeFromString("IWLAN");
-        Assert.assertEquals(AccessNetworkType.IWLAN, accessNetwork);
-        accessNetwork = QnsConstants.accessNetworkTypeFromString("eutran");
-        Assert.assertEquals(AccessNetworkType.EUTRAN, accessNetwork);
-    }
-
-    @Test
-    public void testTransportTypeToString() {
-        String transportType;
-        transportType =
-                QnsConstants.transportTypeToString(AccessNetworkConstants.TRANSPORT_TYPE_INVALID);
-        Assert.assertEquals("INVALID", transportType);
-        transportType =
-                QnsConstants.transportTypeToString(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        Assert.assertEquals("WLAN", transportType);
-        transportType =
-                QnsConstants.transportTypeToString(AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        Assert.assertEquals("WWAN", transportType);
-        transportType = QnsConstants.transportTypeToString(0);
-        Assert.assertEquals("0", transportType);
-    }
-
-    @Test
-    public void testDataStateToString() {
-        String dataState;
-        dataState = QnsConstants.dataStateToString(TelephonyManager.DATA_DISCONNECTED);
-        Assert.assertEquals("DISCONNECTED", dataState);
-        dataState = QnsConstants.dataStateToString(TelephonyManager.DATA_CONNECTED);
-        Assert.assertEquals("CONNECTED", dataState);
-        dataState = QnsConstants.dataStateToString(TelephonyManager.DATA_CONNECTING);
-        Assert.assertEquals("CONNECTING", dataState);
-        dataState = QnsConstants.dataStateToString(TelephonyManager.DATA_DISCONNECTING);
-        Assert.assertEquals("DISCONNECTING", dataState);
-        dataState = QnsConstants.dataStateToString(TelephonyManager.DATA_SUSPENDED);
-        Assert.assertEquals("SUSPENDED", dataState);
-        dataState = QnsConstants.dataStateToString(TelephonyManager.DATA_HANDOVER_IN_PROGRESS);
-        Assert.assertEquals("HANDOVERINPROGRESS", dataState);
-        dataState = QnsConstants.dataStateToString(TelephonyManager.DATA_UNKNOWN);
-        Assert.assertEquals("UNKNOWN", dataState);
-        dataState = QnsConstants.dataStateToString(123);
-        Assert.assertEquals("UNKNOWN(123)", dataState);
-    }
-
-    @Test
-    public void testCallStateToString() {
-        Assert.assertEquals(
-                "CALL_STATE_IDLE",
-                QnsConstants.callStateToString(TelephonyManager.CALL_STATE_IDLE));
-        Assert.assertEquals(
-                "CALL_STATE_RINGING",
-                QnsConstants.callStateToString(TelephonyManager.CALL_STATE_RINGING));
-        Assert.assertEquals(
-                "CALL_STATE_OFFHOOK",
-                QnsConstants.callStateToString(TelephonyManager.CALL_STATE_OFFHOOK));
-        Assert.assertEquals("CALL_STATE_UNKNOWN_-1", QnsConstants.callStateToString(-1));
-    }
-
-    @Test
-    public void testNetworkTypeToAccessNetworkType() {
-        Assert.assertEquals(
-                AccessNetworkType.GERAN,
-                QnsConstants.networkTypeToAccessNetworkType(TelephonyManager.NETWORK_TYPE_GPRS));
-        Assert.assertEquals(
-                AccessNetworkType.GERAN,
-                QnsConstants.networkTypeToAccessNetworkType(TelephonyManager.NETWORK_TYPE_EDGE));
-        Assert.assertEquals(
-                AccessNetworkType.GERAN,
-                QnsConstants.networkTypeToAccessNetworkType(TelephonyManager.NETWORK_TYPE_GSM));
-
-        Assert.assertEquals(
-                AccessNetworkType.UTRAN,
-                QnsConstants.networkTypeToAccessNetworkType(TelephonyManager.NETWORK_TYPE_UMTS));
-        Assert.assertEquals(
-                AccessNetworkType.UTRAN,
-                QnsConstants.networkTypeToAccessNetworkType(TelephonyManager.NETWORK_TYPE_HSDPA));
-        Assert.assertEquals(
-                AccessNetworkType.UTRAN,
-                QnsConstants.networkTypeToAccessNetworkType(TelephonyManager.NETWORK_TYPE_HSUPA));
-        Assert.assertEquals(
-                AccessNetworkType.UTRAN,
-                QnsConstants.networkTypeToAccessNetworkType(TelephonyManager.NETWORK_TYPE_HSPAP));
-        Assert.assertEquals(
-                AccessNetworkType.UTRAN,
-                QnsConstants.networkTypeToAccessNetworkType(TelephonyManager.NETWORK_TYPE_HSPA));
-        Assert.assertEquals(
-                AccessNetworkType.UTRAN,
-                QnsConstants.networkTypeToAccessNetworkType(
-                        TelephonyManager.NETWORK_TYPE_TD_SCDMA));
-
-        Assert.assertEquals(
-                AccessNetworkType.CDMA2000,
-                QnsConstants.networkTypeToAccessNetworkType(TelephonyManager.NETWORK_TYPE_1xRTT));
-        Assert.assertEquals(
-                AccessNetworkType.CDMA2000,
-                QnsConstants.networkTypeToAccessNetworkType(TelephonyManager.NETWORK_TYPE_CDMA));
-        Assert.assertEquals(
-                AccessNetworkType.CDMA2000,
-                QnsConstants.networkTypeToAccessNetworkType(TelephonyManager.NETWORK_TYPE_EVDO_0));
-        Assert.assertEquals(
-                AccessNetworkType.CDMA2000,
-                QnsConstants.networkTypeToAccessNetworkType(TelephonyManager.NETWORK_TYPE_EVDO_A));
-        Assert.assertEquals(
-                AccessNetworkType.CDMA2000,
-                QnsConstants.networkTypeToAccessNetworkType(TelephonyManager.NETWORK_TYPE_EVDO_B));
-        Assert.assertEquals(
-                AccessNetworkType.CDMA2000,
-                QnsConstants.networkTypeToAccessNetworkType(TelephonyManager.NETWORK_TYPE_EHRPD));
-
-        Assert.assertEquals(
-                AccessNetworkType.EUTRAN,
-                QnsConstants.networkTypeToAccessNetworkType(TelephonyManager.NETWORK_TYPE_LTE));
-        Assert.assertEquals(
-                AccessNetworkType.EUTRAN,
-                QnsConstants.networkTypeToAccessNetworkType(TelephonyManager.NETWORK_TYPE_LTE_CA));
-
-        Assert.assertEquals(
-                AccessNetworkType.NGRAN,
-                QnsConstants.networkTypeToAccessNetworkType(TelephonyManager.NETWORK_TYPE_NR));
-        Assert.assertEquals(
-                AccessNetworkType.IWLAN,
-                QnsConstants.networkTypeToAccessNetworkType(TelephonyManager.NETWORK_TYPE_IWLAN));
-
-        Assert.assertEquals(
-                AccessNetworkType.UNKNOWN,
-                QnsConstants.networkTypeToAccessNetworkType(TelephonyManager.NETWORK_TYPE_UNKNOWN));
-        Assert.assertEquals(
-                AccessNetworkType.UNKNOWN, QnsConstants.networkTypeToAccessNetworkType(-1));
-    }
-
-    @Test
-    public void testQnsSipDialogSessionPolicyToString() {
-        String convertedString;
-
-        convertedString = QnsConstants.qnsSipDialogSessionPolicyToString(
-                QnsConstants.SIP_DIALOG_SESSION_POLICY_NONE);
-        Assert.assertEquals(convertedString, "POLICY_NONE");
-        convertedString = QnsConstants.qnsSipDialogSessionPolicyToString(
-                QnsConstants.SIP_DIALOG_SESSION_POLICY_FOLLOW_VOICE_CALL);
-        Assert.assertEquals(convertedString, "POLICY_VOICE");
-        convertedString = QnsConstants.qnsSipDialogSessionPolicyToString(
-                QnsConstants.SIP_DIALOG_SESSION_POLICY_FOLLOW_VIDEO_CALL);
-        Assert.assertEquals(convertedString, "POLICY_VIDEO");
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsEventDispatcherTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsEventDispatcherTest.java
deleted file mode 100644
index 206b2ac..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsEventDispatcherTest.java
+++ /dev/null
@@ -1,777 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static com.android.dx.mockito.inline.extended.ExtendedMockito.mockitoSession;
-import static com.android.telephony.qns.wfc.WfcActivationHelper.ACTION_TRY_WFC_CONNECTION;
-import static com.android.telephony.qns.wfc.WfcActivationHelper.EXTRA_SUB_ID;
-import static com.android.telephony.qns.wfc.WfcActivationHelper.EXTRA_TRY_STATUS;
-import static com.android.telephony.qns.wfc.WfcActivationHelper.STATUS_END;
-import static com.android.telephony.qns.wfc.WfcActivationHelper.STATUS_START;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.*;
-
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.Intent;
-import android.net.ConnectivityManager;
-import android.net.Uri;
-import android.net.wifi.WifiManager;
-import android.os.Handler;
-import android.os.Message;
-import android.provider.Settings;
-import android.telephony.CarrierConfigManager;
-import android.telephony.SubscriptionInfo;
-import android.telephony.SubscriptionManager;
-import android.telephony.TelephonyManager;
-
-import com.android.internal.telephony.TelephonyIntents;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.mockito.MockitoSession;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class QnsEventDispatcherTest extends QnsTest {
-
-    @Mock private Context mMockContext;
-    @Mock private Handler mMockHandler;
-    @Mock private Message mMockMessage;
-    @Mock private Message mMockMessage1;
-    @Mock private Message mMockMessage2;
-    @Mock private Message mMockMessage3;
-    @Mock private Message mMockMessage4;
-    @Mock private Message mMockMessage5;
-    @Mock private WifiManager mMockWifiManager;
-    @Mock private SubscriptionManager mMockSubscriptionManager;
-    @Mock private SubscriptionInfo mMockSubscriptionInfo;
-    @Mock private ContentResolver mMockContentResolver;
-    @Mock private TelephonyManager mMockTelephonyManager;
-    @Mock private ConnectivityManager mMockConnectivityManager;
-
-    private static final int DEFAULT_SLOT_INDEX = 0;
-    private static final int DEFAULT_CARRIER_INDEX = 0;
-    private static final Uri CROSS_SIM_URI =
-            Uri.parse("content://telephony/siminfo/cross_sim_calling_enabled/0");
-    private static final Uri WFC_ENABLED_URI = Uri.parse("content://telephony/siminfo/wfc/0");
-    private static final Uri WFC_MODE_URI = Uri.parse("content://telephony/siminfo/wfc_mode/0");
-    private static final Uri WFC_ROAMING_ENABLED_URI =
-            Uri.parse("content://telephony/siminfo/wfc_roaming_enabled/0");
-    private static final Uri WFC_ROAMING_MODE_URI =
-            Uri.parse("content://telephony/siminfo/wfc_roaming_mode/0");
-    private QnsEventDispatcher mQnsEventDispatcher;
-
-    MockitoSession mStaticMockSession;
-
-    @Before
-    public void setUp() throws Exception {
-        MockitoAnnotations.initMocks(this);
-        super.setUp();
-
-        mStaticMockSession =
-                mockitoSession()
-                        .mockStatic(SubscriptionManager.class)
-                        .mockStatic(Settings.Global.class)
-                        .startMocking();
-
-        when(mMockContext.getSystemService(eq(WifiManager.class))).thenReturn(mMockWifiManager);
-        when(mMockContext.getSystemService(eq(SubscriptionManager.class)))
-                .thenReturn(mMockSubscriptionManager);
-        when(mMockSubscriptionManager.getActiveSubscriptionInfoForSimSlotIndex(
-                        eq(DEFAULT_SLOT_INDEX)))
-                .thenReturn(mMockSubscriptionInfo);
-        when(mMockContext.getContentResolver()).thenReturn(mMockContentResolver);
-        when(mMockContext.getSystemService(eq(TelephonyManager.class)))
-                .thenReturn(mMockTelephonyManager);
-        when(mMockTelephonyManager.createForSubscriptionId(eq(0)))
-                .thenReturn(mMockTelephonyManager);
-        when(mMockContext.getSystemService(eq(ConnectivityManager.class)))
-                .thenReturn(mMockConnectivityManager);
-        lenient()
-                .when(
-                        Settings.Global.getInt(
-                                mMockContentResolver, Settings.Global.AIRPLANE_MODE_ON, 0))
-                .thenReturn(0);
-
-        when(mMockSubscriptionInfo.getSubscriptionId()).thenReturn(0);
-
-        mQnsEventDispatcher =
-                new QnsEventDispatcher(
-                        sMockContext, mMockQnsProvisioningListener, mMockQnsImsManager, 0);
-        // wait for QnsEventDispatcher to complete initial setting load
-        waitForLastHandlerAction(mQnsEventDispatcher.mQnsEventDispatcherHandler);
-    }
-
-    @After
-    public void cleanUp() {
-        mStaticMockSession.finishMocking();
-    }
-
-    @Test
-    public void testOnReceivedCarrierConfigChangedIntent() {
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_CARRIER_CONFIG_CHANGED)))
-                .thenReturn(mMockMessage);
-        when(mMockHandler.obtainMessage(
-                        eq(QnsEventDispatcher.QNS_EVENT_CARRIER_CONFIG_UNKNOWN_CARRIER)))
-                .thenReturn(mMockMessage2);
-
-        List<Integer> events = new ArrayList<Integer>();
-        events.add(QnsEventDispatcher.QNS_EVENT_CARRIER_CONFIG_CHANGED);
-        events.add(QnsEventDispatcher.QNS_EVENT_CARRIER_CONFIG_UNKNOWN_CARRIER);
-        mQnsEventDispatcher.registerEvent(events, mMockHandler);
-
-        // Send ACTION_CARRIER_CONFIG_CHANGED intent with valid Carrier id
-        final Intent validCarrierIdIntent =
-                new Intent(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
-        validCarrierIdIntent.putExtra(CarrierConfigManager.EXTRA_SLOT_INDEX, DEFAULT_SLOT_INDEX);
-        validCarrierIdIntent.putExtra(TelephonyManager.EXTRA_CARRIER_ID, DEFAULT_CARRIER_INDEX);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, validCarrierIdIntent);
-        verify(mMockMessage, times(1)).sendToTarget();
-
-        // Send ACTION_CARRIER_CONFIG_CHANGED intent with invalid Carrier id
-        final Intent invalidCarrierIdIntent =
-                new Intent(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
-        invalidCarrierIdIntent.putExtra(CarrierConfigManager.EXTRA_SLOT_INDEX, DEFAULT_SLOT_INDEX);
-        invalidCarrierIdIntent.putExtra(
-                TelephonyManager.EXTRA_CARRIER_ID, TelephonyManager.UNKNOWN_CARRIER_ID);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, invalidCarrierIdIntent);
-        verify(mMockMessage2, times(1)).sendToTarget();
-    }
-
-    @Test
-    public void testOnReceivedCarrierConfigChangedIntentWithInvalidSlot() {
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_CARRIER_CONFIG_CHANGED)))
-                .thenReturn(mMockMessage);
-        when(mMockHandler.obtainMessage(
-                        eq(QnsEventDispatcher.QNS_EVENT_CARRIER_CONFIG_UNKNOWN_CARRIER)))
-                .thenReturn(mMockMessage2);
-
-        List<Integer> events = new ArrayList<Integer>();
-        events.add(QnsEventDispatcher.QNS_EVENT_CARRIER_CONFIG_CHANGED);
-        events.add(QnsEventDispatcher.QNS_EVENT_CARRIER_CONFIG_UNKNOWN_CARRIER);
-        mQnsEventDispatcher.registerEvent(events, mMockHandler);
-
-        // ACTION_CARRIER_CONFIG_CHANGED intent with valid Carrier id to be not received
-        final Intent validCarrierIdIntent =
-                new Intent(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
-        validCarrierIdIntent.putExtra(CarrierConfigManager.EXTRA_SLOT_INDEX, 1);
-        validCarrierIdIntent.putExtra(TelephonyManager.EXTRA_CARRIER_ID, DEFAULT_CARRIER_INDEX);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, validCarrierIdIntent);
-        verify(mMockMessage, never()).sendToTarget();
-
-        // Send ACTION_CARRIER_CONFIG_CHANGED intent with invalid Carrier id to be not received
-        final Intent invalidCarrierIdIntent =
-                new Intent(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
-        invalidCarrierIdIntent.putExtra(CarrierConfigManager.EXTRA_SLOT_INDEX, 1);
-        invalidCarrierIdIntent.putExtra(
-                TelephonyManager.EXTRA_CARRIER_ID, TelephonyManager.UNKNOWN_CARRIER_ID);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, invalidCarrierIdIntent);
-        verify(mMockMessage2, never()).sendToTarget();
-    }
-
-    @Test
-    public void testOnSimLoadedStateEvent() {
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_SIM_LOADED)))
-                .thenReturn(mMockMessage);
-
-        List<Integer> events = new ArrayList<Integer>();
-        events.add(QnsEventDispatcher.QNS_EVENT_SIM_LOADED);
-        mQnsEventDispatcher.registerEvent(events, mMockHandler);
-
-        // Send ACTION_SIM_CARD_STATE_CHANGED intent with SIM_STATE_LOADED
-        final Intent validSimCardStateintent =
-                new Intent(TelephonyManager.ACTION_SIM_CARD_STATE_CHANGED);
-        validSimCardStateintent.putExtra(CarrierConfigManager.EXTRA_SLOT_INDEX, DEFAULT_SLOT_INDEX);
-        validSimCardStateintent.putExtra(
-                TelephonyManager.EXTRA_SIM_STATE, TelephonyManager.SIM_STATE_LOADED);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, validSimCardStateintent);
-        verify(mMockMessage, times(1)).sendToTarget();
-
-        // Send ACTION_SIM_APPLICATION_STATE_CHANGED intent with SIM_STATE_LOADED
-        final Intent validSimCardStateintent1 =
-                new Intent(TelephonyManager.ACTION_SIM_APPLICATION_STATE_CHANGED);
-        validSimCardStateintent1.putExtra(
-                CarrierConfigManager.EXTRA_SLOT_INDEX, DEFAULT_SLOT_INDEX);
-        validSimCardStateintent1.putExtra(
-                TelephonyManager.EXTRA_SIM_STATE, TelephonyManager.SIM_STATE_LOADED);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, validSimCardStateintent1);
-        verify(mMockMessage, atLeast(2)).sendToTarget();
-    }
-
-    @Test
-    public void testOnSimUnknownStateEvent() {
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_SIM_ABSENT)))
-                .thenReturn(mMockMessage);
-
-        List<Integer> events = new ArrayList<Integer>();
-        events.add(QnsEventDispatcher.QNS_EVENT_SIM_ABSENT);
-        mQnsEventDispatcher.registerEvent(events, mMockHandler);
-
-        // Send ACTION_SIM_CARD_STATE_CHANGED intent with SIM_STATE_ABSENT
-        final Intent validSimCardStateintent =
-                new Intent(TelephonyManager.ACTION_SIM_CARD_STATE_CHANGED);
-        validSimCardStateintent.putExtra(CarrierConfigManager.EXTRA_SLOT_INDEX, DEFAULT_SLOT_INDEX);
-        validSimCardStateintent.putExtra(
-                TelephonyManager.EXTRA_SIM_STATE, TelephonyManager.SIM_STATE_ABSENT);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, validSimCardStateintent);
-        verify(mMockMessage, times(1)).sendToTarget();
-
-        // Send ACTION_SIM_APPLICATION_STATE_CHANGED intent with SIM_STATE_ABSENT
-        final Intent validSimCardStateintent1 =
-                new Intent(TelephonyManager.ACTION_SIM_APPLICATION_STATE_CHANGED);
-        validSimCardStateintent1.putExtra(
-                CarrierConfigManager.EXTRA_SLOT_INDEX, DEFAULT_SLOT_INDEX);
-        validSimCardStateintent1.putExtra(
-                TelephonyManager.EXTRA_SIM_STATE, TelephonyManager.SIM_STATE_ABSENT);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, validSimCardStateintent1);
-        verify(mMockMessage, atLeast(2)).sendToTarget();
-    }
-
-    @Test
-    public void testOnSimStateEventWithInvalidSlot() {
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_SIM_LOADED)))
-                .thenReturn(mMockMessage);
-
-        List<Integer> events = new ArrayList<Integer>();
-        events.add(QnsEventDispatcher.QNS_EVENT_SIM_LOADED);
-        mQnsEventDispatcher.registerEvent(events, mMockHandler);
-
-        // Send ACTION_SIM_CARD_STATE_CHANGED intent with SIM_STATE_LOADED
-        final Intent validSimCardStateintent =
-                new Intent(TelephonyManager.ACTION_SIM_CARD_STATE_CHANGED);
-        validSimCardStateintent.putExtra(CarrierConfigManager.EXTRA_SLOT_INDEX, 1);
-        validSimCardStateintent.putExtra(
-                TelephonyManager.EXTRA_SIM_STATE, TelephonyManager.SIM_STATE_LOADED);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, validSimCardStateintent);
-        verify(mMockMessage, never()).sendToTarget();
-
-        // Send ACTION_SIM_APPLICATION_STATE_CHANGED intent with SIM_STATE_LOADED
-        final Intent validSimCardStateintent1 =
-                new Intent(TelephonyManager.ACTION_SIM_APPLICATION_STATE_CHANGED);
-        validSimCardStateintent1.putExtra(CarrierConfigManager.EXTRA_SLOT_INDEX, 1);
-        validSimCardStateintent1.putExtra(
-                TelephonyManager.EXTRA_SIM_STATE, TelephonyManager.SIM_STATE_ABSENT);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, validSimCardStateintent1);
-        verify(mMockMessage, never()).sendToTarget();
-    }
-
-    @Test
-    public void testOnAirplaneModeEvent() {
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_APM_ENABLED)))
-                .thenReturn(mMockMessage);
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_APM_DISABLED)))
-                .thenReturn(mMockMessage2);
-
-        List<Integer> events = new ArrayList<Integer>();
-        events.add(QnsEventDispatcher.QNS_EVENT_APM_ENABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_APM_DISABLED);
-        mQnsEventDispatcher.registerEvent(events, mMockHandler);
-
-        // Send ACTION_AIRPLANE_MODE_CHANGED intent with On
-        final Intent validCarrierIdIntent = new Intent(Intent.ACTION_AIRPLANE_MODE_CHANGED);
-        validCarrierIdIntent.putExtra("state", true);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, validCarrierIdIntent);
-        verify(mMockMessage, times(1)).sendToTarget();
-
-        // Check for Duplicate Event Scenario On Case : ACTION_AIRPLANE_MODE_CHANGED
-        final Intent validCarrierIdIntent1 = new Intent(Intent.ACTION_AIRPLANE_MODE_CHANGED);
-        validCarrierIdIntent.putExtra("state", true);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, validCarrierIdIntent1);
-        verify(mMockMessage, times(1)).sendToTarget();
-
-        // Send ACTION_AIRPLANE_MODE_CHANGED intent with Off
-        final Intent invalidCarrierIdIntent = new Intent(Intent.ACTION_AIRPLANE_MODE_CHANGED);
-        invalidCarrierIdIntent.putExtra("state", false);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, invalidCarrierIdIntent);
-        verify(mMockMessage2, times(1)).sendToTarget();
-
-        // Check for Duplicate Event Scenario Off Case:ACTION_AIRPLANE_MODE_CHANGED
-        final Intent invalidCarrierIdIntent1 = new Intent(Intent.ACTION_AIRPLANE_MODE_CHANGED);
-        invalidCarrierIdIntent.putExtra("state", false);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, invalidCarrierIdIntent1);
-        verify(mMockMessage2, times(1)).sendToTarget();
-    }
-
-    @Test
-    public void testOnWifiStateChangedEvent() {
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_WIFI_DISABLING)))
-                .thenReturn(mMockMessage);
-
-        List<Integer> events = new ArrayList<Integer>();
-        events.add(QnsEventDispatcher.QNS_EVENT_WIFI_DISABLING);
-        mQnsEventDispatcher.registerEvent(events, mMockHandler);
-
-        // Send WIFI_STATE_CHANGED_ACTION intent with WIFI_STATE_DISABLING
-        final Intent validWifiStateIntent = new Intent(WifiManager.WIFI_STATE_CHANGED_ACTION);
-        validWifiStateIntent.putExtra(CarrierConfigManager.EXTRA_SLOT_INDEX, DEFAULT_SLOT_INDEX);
-        validWifiStateIntent.putExtra(
-                WifiManager.EXTRA_WIFI_STATE, WifiManager.WIFI_STATE_DISABLING);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, validWifiStateIntent);
-        verify(mMockMessage, times(1)).sendToTarget();
-
-        // Check for Duplicate Event Scenario :WIFI_STATE_CHANGED_ACTION
-        final Intent validWifiStateIntent1 = new Intent(WifiManager.WIFI_STATE_CHANGED_ACTION);
-        validWifiStateIntent1.putExtra(CarrierConfigManager.EXTRA_SLOT_INDEX, DEFAULT_SLOT_INDEX);
-        validWifiStateIntent1.putExtra(
-                WifiManager.EXTRA_WIFI_STATE, WifiManager.WIFI_STATE_DISABLING);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, validWifiStateIntent1);
-        verify(mMockMessage, times(1)).sendToTarget();
-    }
-
-    @Test
-    public void testOnEmergencyCallbackModeChanged() {
-        when(mMockHandler.obtainMessage(
-                        eq(QnsEventDispatcher.QNS_EVENT_EMERGENCY_CALLBACK_MODE_ON)))
-                .thenReturn(mMockMessage);
-        when(mMockHandler.obtainMessage(
-                        eq(QnsEventDispatcher.QNS_EVENT_EMERGENCY_CALLBACK_MODE_OFF)))
-                .thenReturn(mMockMessage2);
-
-        List<Integer> events = new ArrayList<Integer>();
-        events.add(QnsEventDispatcher.QNS_EVENT_EMERGENCY_CALLBACK_MODE_ON);
-        events.add(QnsEventDispatcher.QNS_EVENT_EMERGENCY_CALLBACK_MODE_OFF);
-        mQnsEventDispatcher.registerEvent(events, mMockHandler);
-
-        // Send ACTION_EMERGENCY_CALLBACK_MODE_CHANGED  intent with On
-        final Intent validEcbmIntent =
-                new Intent(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
-        validEcbmIntent.putExtra(TelephonyManager.EXTRA_PHONE_IN_ECM_STATE, true);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, validEcbmIntent);
-        verify(mMockMessage, times(1)).sendToTarget();
-
-        // Send ACTION_EMERGENCY_CALLBACK_MODE_CHANGED intent with Off
-        final Intent validEcbmIntent1 =
-                new Intent(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
-        validEcbmIntent1.putExtra(TelephonyManager.EXTRA_PHONE_IN_ECM_STATE, false);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, validEcbmIntent1);
-        verify(mMockMessage2, times(1)).sendToTarget();
-    }
-
-    @Test
-    public void testNotifyImmediatelyWfcSettingsWithDisabledStatus() {
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_WFC_PLATFORM_DISABLED)))
-                .thenReturn(mMockMessage);
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_WFC_DISABLED)))
-                .thenReturn(mMockMessage1);
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_DISABLED)))
-                .thenReturn(mMockMessage2);
-
-        List<Integer> events = new ArrayList<Integer>();
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_PLATFORM_DISABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_DISABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_DISABLED);
-        mQnsEventDispatcher.registerEvent(events, mMockHandler);
-
-        // WFC settings Disable Case
-        verify(mMockMessage, times(1)).sendToTarget();
-        verify(mMockMessage1, times(1)).sendToTarget();
-        verify(mMockMessage2, times(1)).sendToTarget();
-    }
-
-    @Test
-    public void testNotifyImmediatelyWfcSettingsWithEnabledStatus() {
-        setEnabledStatusForWfcSettingsCrossSimSettings();
-
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_WFC_PLATFORM_ENABLED)))
-                .thenReturn(mMockMessage);
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_WFC_ENABLED)))
-                .thenReturn(mMockMessage1);
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_ENABLED)))
-                .thenReturn(mMockMessage2);
-
-        List<Integer> events = new ArrayList<>();
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_PLATFORM_ENABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_ENABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_ENABLED);
-        mQnsEventDispatcher.registerEvent(events, mMockHandler);
-
-        // WFC settings Enabled Case
-        verify(mMockMessage, times(1)).sendToTarget();
-        verify(mMockMessage1, times(1)).sendToTarget();
-        verify(mMockMessage2, times(1)).sendToTarget();
-    }
-
-    @Test
-    public void testNotifyImmediatelyDifferentWfcModes() {
-        setEnabledStatusForWfcSettingsCrossSimSettings();
-        when(mMockQnsImsManager.getWfcMode(false)).thenReturn(1, 2);
-
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_ONLY)))
-                .thenReturn(mMockMessage);
-        when(mMockHandler.obtainMessage(
-                        eq(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_CELLULAR_PREFERRED)))
-                .thenReturn(mMockMessage1);
-        when(mMockHandler.obtainMessage(
-                        eq(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_PREFERRED)))
-                .thenReturn(mMockMessage2);
-
-        List<Integer> events = new ArrayList<Integer>();
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_ONLY);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_CELLULAR_PREFERRED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_PREFERRED);
-        mQnsEventDispatcher.registerEvent(events, mMockHandler);
-
-        // WFC Modes Enabled Case
-        verify(mMockMessage, times(1)).sendToTarget();
-        mQnsEventDispatcher.mUserSettingObserver.onChange(true, WFC_MODE_URI);
-        verify(mMockMessage1, times(1)).sendToTarget();
-        mQnsEventDispatcher.mUserSettingObserver.onChange(true, WFC_MODE_URI);
-        verify(mMockMessage2, times(1)).sendToTarget();
-    }
-
-    @Test
-    public void testNotifyCurrentSettingWithDisabledStatus() {
-        setDisabledStatusForWfcSettingsCrossSimSettings();
-        when(mMockHandler.obtainMessage(
-                        eq(QnsEventDispatcher.QNS_EVENT_CROSS_SIM_CALLING_DISABLED)))
-                .thenReturn(mMockMessage);
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_WFC_DISABLED)))
-                .thenReturn(mMockMessage1);
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_ONLY)))
-                .thenReturn(mMockMessage4);
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_DISABLED)))
-                .thenReturn(mMockMessage2);
-        when(mMockHandler.obtainMessage(
-                        eq(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_ONLY)))
-                .thenReturn(mMockMessage5);
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_CARRIER_CONFIG_CHANGED)))
-                .thenReturn(mMockMessage3);
-
-        List<Integer> events = new ArrayList<Integer>();
-        events.add(QnsEventDispatcher.QNS_EVENT_CROSS_SIM_CALLING_DISABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_DISABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_ONLY);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_DISABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_ONLY);
-        events.add(QnsEventDispatcher.QNS_EVENT_CARRIER_CONFIG_CHANGED);
-        mQnsEventDispatcher.registerEvent(events, mMockHandler);
-
-        // Send ACTION_CARRIER_CONFIG_CHANGED intent with valid Carrier id
-        final Intent validCarrierIdIntent =
-                new Intent(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
-        validCarrierIdIntent.putExtra(CarrierConfigManager.EXTRA_SLOT_INDEX, DEFAULT_SLOT_INDEX);
-        validCarrierIdIntent.putExtra(TelephonyManager.EXTRA_CARRIER_ID, DEFAULT_CARRIER_INDEX);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, validCarrierIdIntent);
-        verify(mMockMessage, times(2)).sendToTarget();
-        verify(mMockMessage1, times(2)).sendToTarget();
-        verify(mMockMessage4, times(2)).sendToTarget();
-        verify(mMockMessage2, times(2)).sendToTarget();
-        verify(mMockMessage5, times(2)).sendToTarget();
-        verify(mMockMessage3, times(1)).sendToTarget();
-    }
-
-    @Test
-    public void testNotifyCurrentSettingWithEnabledStatus() {
-        setEnabledStatusForWfcSettingsCrossSimSettings();
-
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_CROSS_SIM_CALLING_ENABLED)))
-                .thenReturn(mMockMessage);
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_WFC_ENABLED)))
-                .thenReturn(mMockMessage1);
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_ONLY)))
-                .thenReturn(mMockMessage4);
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_ENABLED)))
-                .thenReturn(mMockMessage2);
-        when(mMockHandler.obtainMessage(
-                        eq(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_ONLY)))
-                .thenReturn(mMockMessage5);
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_CARRIER_CONFIG_CHANGED)))
-                .thenReturn(mMockMessage3);
-
-        List<Integer> events = new ArrayList<>();
-        events.add(QnsEventDispatcher.QNS_EVENT_CROSS_SIM_CALLING_ENABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_ENABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_ONLY);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_ENABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_ONLY);
-        events.add(QnsEventDispatcher.QNS_EVENT_CARRIER_CONFIG_CHANGED);
-        mQnsEventDispatcher.registerEvent(events, mMockHandler);
-
-        // Send ACTION_CARRIER_CONFIG_CHANGED intent with valid Carrier id
-        final Intent validCarrierIdIntent =
-                new Intent(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
-        validCarrierIdIntent.putExtra(CarrierConfigManager.EXTRA_SLOT_INDEX, DEFAULT_SLOT_INDEX);
-        validCarrierIdIntent.putExtra(TelephonyManager.EXTRA_CARRIER_ID, DEFAULT_CARRIER_INDEX);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, validCarrierIdIntent);
-        verify(mMockMessage, times(2)).sendToTarget();
-        verify(mMockMessage1, times(2)).sendToTarget();
-        verify(mMockMessage4, times(2)).sendToTarget();
-        verify(mMockMessage2, times(2)).sendToTarget();
-        verify(mMockMessage5, times(2)).sendToTarget();
-        verify(mMockMessage3, times(1)).sendToTarget();
-    }
-
-    private void setEnabledStatusForWfcSettingsCrossSimSettings() {
-        when(mMockQnsImsManager.isCrossSimCallingEnabled()).thenReturn(true);
-        when(mMockQnsImsManager.isWfcEnabledByPlatform()).thenReturn(true);
-        when(mMockQnsImsManager.isWfcProvisionedOnDevice()).thenReturn(true);
-        when(mMockQnsImsManager.isWfcRoamingEnabledByUser()).thenReturn(true);
-        when(mMockQnsImsManager.isWfcEnabledByUser()).thenReturn(true);
-        when(mMockQnsProvisioningListener.getLastProvisioningWfcRoamingEnabledInfo())
-                .thenReturn(true);
-
-        // Initialise stubbed variables in QnsUtils:
-        final Intent validCarrierIdIntent =
-                new Intent(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
-        validCarrierIdIntent.putExtra(CarrierConfigManager.EXTRA_SLOT_INDEX, DEFAULT_SLOT_INDEX);
-        validCarrierIdIntent.putExtra(TelephonyManager.EXTRA_CARRIER_ID, DEFAULT_CARRIER_INDEX);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, validCarrierIdIntent);
-    }
-
-    private void setDisabledStatusForWfcSettingsCrossSimSettings() {
-        when(mMockQnsImsManager.isCrossSimCallingEnabled()).thenReturn(false);
-        when(mMockQnsImsManager.isWfcEnabledByPlatform()).thenReturn(false);
-        when(mMockQnsImsManager.isWfcProvisionedOnDevice()).thenReturn(false);
-        when(mMockQnsImsManager.isWfcRoamingEnabledByUser()).thenReturn(false);
-        when(mMockQnsImsManager.isWfcEnabledByUser()).thenReturn(false);
-        when(mMockQnsProvisioningListener.getLastProvisioningWfcRoamingEnabledInfo())
-                .thenReturn(false);
-
-        // Initialise stubbed variables in QnsUtils:
-        final Intent validCarrierIdIntent =
-                new Intent(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
-        validCarrierIdIntent.putExtra(CarrierConfigManager.EXTRA_SLOT_INDEX, DEFAULT_SLOT_INDEX);
-        validCarrierIdIntent.putExtra(TelephonyManager.EXTRA_CARRIER_ID, DEFAULT_CARRIER_INDEX);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, validCarrierIdIntent);
-    }
-
-    @Test
-    public void testUnregisterEventAndUserSettingObserver() {
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_CARRIER_CONFIG_CHANGED)))
-                .thenReturn(mMockMessage);
-
-        List<Integer> events = new ArrayList<Integer>();
-        events.add(QnsEventDispatcher.QNS_EVENT_CARRIER_CONFIG_CHANGED);
-        mQnsEventDispatcher.registerEvent(events, mMockHandler);
-
-        // Send ACTION_CARRIER_CONFIG_CHANGED intent with valid Carrier id
-        final Intent validCarrierIdIntent =
-                new Intent(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
-        validCarrierIdIntent.putExtra(CarrierConfigManager.EXTRA_SLOT_INDEX, DEFAULT_SLOT_INDEX);
-        validCarrierIdIntent.putExtra(TelephonyManager.EXTRA_CARRIER_ID, DEFAULT_CARRIER_INDEX);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, validCarrierIdIntent);
-        verify(mMockMessage, times(1)).sendToTarget();
-
-        mQnsEventDispatcher.unregisterEvent(mMockHandler);
-    }
-
-    @Test
-    public void testOnUserSettingChangedEventDisableStatus() {
-        when(mMockHandler.obtainMessage(
-                        eq(QnsEventDispatcher.QNS_EVENT_CROSS_SIM_CALLING_DISABLED)))
-                .thenReturn(mMockMessage);
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_WFC_DISABLED)))
-                .thenReturn(mMockMessage1);
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_ONLY)))
-                .thenReturn(mMockMessage4);
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_DISABLED)))
-                .thenReturn(mMockMessage2);
-        when(mMockHandler.obtainMessage(
-                        eq(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_ONLY)))
-                .thenReturn(mMockMessage5);
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_CARRIER_CONFIG_CHANGED)))
-                .thenReturn(mMockMessage3);
-
-        List<Integer> events = new ArrayList<Integer>();
-        events.add(QnsEventDispatcher.QNS_EVENT_CROSS_SIM_CALLING_DISABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_DISABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_ONLY);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_DISABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_ONLY);
-        events.add(QnsEventDispatcher.QNS_EVENT_CARRIER_CONFIG_CHANGED);
-        mQnsEventDispatcher.registerEvent(events, mMockHandler);
-
-        // Send ACTION_CARRIER_CONFIG_CHANGED intent with valid Carrier id
-        final Intent validCarrierIdIntent =
-                new Intent(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
-        validCarrierIdIntent.putExtra(CarrierConfigManager.EXTRA_SLOT_INDEX, DEFAULT_SLOT_INDEX);
-        validCarrierIdIntent.putExtra(TelephonyManager.EXTRA_CARRIER_ID, DEFAULT_CARRIER_INDEX);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, validCarrierIdIntent);
-
-        verify(mMockMessage, times(2)).sendToTarget();
-        verify(mMockMessage1, times(2)).sendToTarget();
-        verify(mMockMessage4, atLeastOnce()).sendToTarget();
-        verify(mMockMessage2, times(2)).sendToTarget();
-        verify(mMockMessage5, atLeastOnce()).sendToTarget();
-        verify(mMockMessage3, times(1)).sendToTarget();
-
-        mQnsEventDispatcher.mUserSettingObserver.onChange(true, CROSS_SIM_URI);
-        mQnsEventDispatcher.mUserSettingObserver.onChange(true, WFC_ENABLED_URI);
-        mQnsEventDispatcher.mUserSettingObserver.onChange(true, WFC_MODE_URI);
-        mQnsEventDispatcher.mUserSettingObserver.onChange(true, WFC_ROAMING_ENABLED_URI);
-        mQnsEventDispatcher.mUserSettingObserver.onChange(true, WFC_ROAMING_MODE_URI);
-
-        verify(mMockMessage, times(2)).sendToTarget();
-        verify(mMockMessage1, times(2)).sendToTarget();
-        verify(mMockMessage4, atLeastOnce()).sendToTarget();
-        verify(mMockMessage2, times(2)).sendToTarget();
-        verify(mMockMessage5, atLeastOnce()).sendToTarget();
-    }
-
-    @Test
-    public void testOnUserSettingChangedEventEnabledStatus() {
-        setEnabledStatusForWfcSettingsCrossSimSettings();
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_CROSS_SIM_CALLING_ENABLED)))
-                .thenReturn(mMockMessage);
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_WFC_ENABLED)))
-                .thenReturn(mMockMessage1);
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_ONLY)))
-                .thenReturn(mMockMessage4);
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_ENABLED)))
-                .thenReturn(mMockMessage2);
-        when(mMockHandler.obtainMessage(
-                        eq(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_ONLY)))
-                .thenReturn(mMockMessage5);
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_CARRIER_CONFIG_CHANGED)))
-                .thenReturn(mMockMessage3);
-
-        List<Integer> events = new ArrayList<Integer>();
-        events.add(QnsEventDispatcher.QNS_EVENT_CROSS_SIM_CALLING_ENABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_ENABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_ONLY);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_ENABLED);
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_ROAMING_MODE_TO_WIFI_ONLY);
-        events.add(QnsEventDispatcher.QNS_EVENT_CARRIER_CONFIG_CHANGED);
-        mQnsEventDispatcher.registerEvent(events, mMockHandler);
-
-        // Send ACTION_CARRIER_CONFIG_CHANGED intent with valid Carrier id
-        final Intent validCarrierIdIntent =
-                new Intent(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
-        validCarrierIdIntent.putExtra(CarrierConfigManager.EXTRA_SLOT_INDEX, DEFAULT_SLOT_INDEX);
-        validCarrierIdIntent.putExtra(TelephonyManager.EXTRA_CARRIER_ID, DEFAULT_CARRIER_INDEX);
-        mQnsEventDispatcher.mIntentReceiver.onReceive(mMockContext, validCarrierIdIntent);
-
-        verify(mMockMessage, times(2)).sendToTarget();
-        verify(mMockMessage1, times(2)).sendToTarget();
-        verify(mMockMessage4, times(2)).sendToTarget();
-        verify(mMockMessage2, times(2)).sendToTarget();
-        verify(mMockMessage5, times(2)).sendToTarget();
-        verify(mMockMessage3, times(1)).sendToTarget();
-
-        mQnsEventDispatcher.mUserSettingObserver.onChange(true, CROSS_SIM_URI);
-        mQnsEventDispatcher.mUserSettingObserver.onChange(true, WFC_ENABLED_URI);
-        mQnsEventDispatcher.mUserSettingObserver.onChange(true, WFC_MODE_URI);
-        mQnsEventDispatcher.mUserSettingObserver.onChange(true, WFC_ROAMING_ENABLED_URI);
-        mQnsEventDispatcher.mUserSettingObserver.onChange(true, WFC_ROAMING_MODE_URI);
-
-        verify(mMockMessage, times(2)).sendToTarget();
-        verify(mMockMessage1, times(2)).sendToTarget();
-        verify(mMockMessage4, times(2)).sendToTarget();
-        verify(mMockMessage2, times(2)).sendToTarget();
-        verify(mMockMessage5, times(2)).sendToTarget();
-    }
-
-    private final Object mLock = new Object();
-
-    protected void waitForWfcModeChange(long timeout, QnsEventDispatcher dispatcher, int mode)
-            throws InterruptedException {
-        synchronized (mLock) {
-            long now = System.currentTimeMillis();
-            long deadline = now + timeout;
-            while (dispatcher.mLastWfcMode != mode && now < deadline) {
-                mLock.wait(timeout / 10);
-                now = System.currentTimeMillis();
-            }
-        }
-    }
-
-    @Test
-    public void testLoadWfcSettingsWhenCreate() throws InterruptedException {
-        List<Integer> events = new ArrayList<>();
-        events.add(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_PREFERRED);
-        when(mMockHandler.obtainMessage(
-                        eq(QnsEventDispatcher.QNS_EVENT_WFC_MODE_TO_WIFI_PREFERRED)))
-                .thenReturn(mMockMessage1);
-        when(mMockQnsImsManager.getWfcMode(false)).thenReturn(QnsConstants.WIFI_PREF);
-        mQnsEventDispatcher =
-                new QnsEventDispatcher(
-                        sMockContext, mMockQnsProvisioningListener, mMockQnsImsManager, 0);
-        waitForWfcModeChange(500, mQnsEventDispatcher, QnsConstants.WIFI_PREF);
-        assertEquals(QnsConstants.WIFI_PREF, mQnsEventDispatcher.mLastWfcMode);
-        mQnsEventDispatcher.registerEvent(events, mMockHandler);
-        mQnsEventDispatcher.mUserSettingObserver.onChange(true, WFC_MODE_URI);
-        verify(mMockMessage1, times(1)).sendToTarget();
-    }
-
-    @Test
-    public void testOnReceivedTryWfcConnectionIntent() {
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_TRY_WFC_ACTIVATION)))
-                .thenReturn(mMockMessage);
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_CANCEL_TRY_WFC_ACTIVATION)))
-                .thenReturn(mMockMessage2);
-
-        List<Integer> events = new ArrayList<Integer>();
-        events.add(QnsEventDispatcher.QNS_EVENT_TRY_WFC_ACTIVATION);
-        events.add(QnsEventDispatcher.QNS_EVENT_CANCEL_TRY_WFC_ACTIVATION);
-        mQnsEventDispatcher.registerEvent(events, mMockHandler);
-
-        // Send WfcActivationHelper.ACTION_TRY_WFC_CONNECTION intent
-        // with WfcActivationHelper.STATUS_START and valid subId
-        final Intent validWfcActivationdStartIntent = new Intent(ACTION_TRY_WFC_CONNECTION);
-        validWfcActivationdStartIntent.putExtra(EXTRA_SUB_ID, 0);
-        validWfcActivationdStartIntent.putExtra(EXTRA_TRY_STATUS, STATUS_START);
-        mQnsEventDispatcher.mWfcActivationIntentReceiver.onReceive(
-                mMockContext, validWfcActivationdStartIntent);
-        verify(mMockMessage, times(1)).sendToTarget();
-
-        // Send WfcActivationHelper.ACTION_TRY_WFC_CONNECTION intent
-        // with WfcActivationHelper.STATUS_END and valid subId
-        final Intent validWfcActivationdEndIntent = new Intent(ACTION_TRY_WFC_CONNECTION);
-        validWfcActivationdEndIntent.putExtra(EXTRA_SUB_ID, 0);
-        validWfcActivationdEndIntent.putExtra(EXTRA_TRY_STATUS, STATUS_END);
-        mQnsEventDispatcher.mWfcActivationIntentReceiver.onReceive(
-                mMockContext, validWfcActivationdEndIntent);
-        verify(mMockMessage2, times(1)).sendToTarget();
-    }
-
-    @Test
-    public void testOnReceivedTryWfcConnectionIntentWithInvalidSubId() {
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_TRY_WFC_ACTIVATION)))
-                .thenReturn(mMockMessage);
-        when(mMockHandler.obtainMessage(eq(QnsEventDispatcher.QNS_EVENT_CANCEL_TRY_WFC_ACTIVATION)))
-                .thenReturn(mMockMessage2);
-
-        List<Integer> events = new ArrayList<Integer>();
-        events.add(QnsEventDispatcher.QNS_EVENT_TRY_WFC_ACTIVATION);
-        events.add(QnsEventDispatcher.QNS_EVENT_CANCEL_TRY_WFC_ACTIVATION);
-        mQnsEventDispatcher.registerEvent(events, mMockHandler);
-
-        // Send WfcActivationHelper.ACTION_TRY_WFC_CONNECTION intent
-        // with WfcActivationHelper.STATUS_START and invalid subId
-        final Intent validWfcActivationdStartIntent = new Intent(ACTION_TRY_WFC_CONNECTION);
-        validWfcActivationdStartIntent.putExtra(EXTRA_SUB_ID, 1);
-        validWfcActivationdStartIntent.putExtra(EXTRA_TRY_STATUS, STATUS_START);
-        mQnsEventDispatcher.mWfcActivationIntentReceiver.onReceive(
-                mMockContext, validWfcActivationdStartIntent);
-        verify(mMockMessage, never()).sendToTarget();
-
-        // Send WfcActivationHelper.ACTION_TRY_WFC_CONNECTION intent
-        // with WfcActivationHelper.STATUS_END and invalid subId
-        final Intent validWfcActivationdEndIntent = new Intent(ACTION_TRY_WFC_CONNECTION);
-        validWfcActivationdEndIntent.putExtra(EXTRA_SUB_ID, 1);
-        validWfcActivationdEndIntent.putExtra(EXTRA_TRY_STATUS, STATUS_END);
-        mQnsEventDispatcher.mWfcActivationIntentReceiver.onReceive(
-                mMockContext, validWfcActivationdEndIntent);
-        verify(mMockMessage2, never()).sendToTarget();
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsImsManagerTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsImsManagerTest.java
deleted file mode 100644
index 4e81577..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsImsManagerTest.java
+++ /dev/null
@@ -1,831 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static android.telephony.ims.stub.ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN;
-import static android.telephony.ims.stub.ImsRegistrationImplBase.REGISTRATION_TECH_LTE;
-
-import static com.android.dx.mockito.inline.extended.ExtendedMockito.mockitoSession;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.doThrow;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.annotation.NonNull;
-import android.content.pm.PackageManager;
-import android.content.res.Resources;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Message;
-import android.os.PersistableBundle;
-import android.os.SystemProperties;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.CarrierConfigManager;
-import android.telephony.SubscriptionManager;
-import android.telephony.TelephonyManager;
-import android.telephony.ims.ImsException;
-import android.telephony.ims.ImsManager;
-import android.telephony.ims.ImsReasonInfo;
-import android.telephony.ims.ImsRegistrationAttributes;
-import android.telephony.ims.ImsStateCallback;
-import android.telephony.ims.ProvisioningManager;
-import android.telephony.ims.RegistrationManager;
-import android.telephony.ims.SipDialogState;
-import android.telephony.ims.SipDialogStateCallback;
-import android.telephony.ims.feature.ImsFeature;
-
-import com.google.android.collect.Sets;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.Mockito;
-import org.mockito.MockitoAnnotations;
-import org.mockito.MockitoSession;
-import org.mockito.quality.Strictness;
-
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.Executor;
-import java.util.concurrent.TimeUnit;
-
-@RunWith(JUnit4.class)
-public class QnsImsManagerTest extends QnsTest {
-
-    @Mock Resources mResources;
-    @Mock PersistableBundle mBundle;
-    @Mock ProvisioningManager mProvisioningManager;
-    @Mock PackageManager mPackageManager;
-    private MockitoSession mMockitoSession;
-    private QnsImsManager mQnsImsMgr;
-
-    @Before
-    public void setup() throws Exception {
-        MockitoAnnotations.initMocks(this);
-        super.setUp();
-        when(sMockContext.getResources()).thenReturn(mResources);
-        when(mMockCarrierConfigManager.getConfigForSubId(anyInt())).thenReturn(mBundle);
-        mMockitoSession =
-                mockitoSession()
-                        .strictness(Strictness.LENIENT)
-                        .mockStatic(SystemProperties.class)
-                        .mockStatic(ProvisioningManager.class)
-                        .mockStatic(SubscriptionManager.class)
-                        .startMocking();
-        when(ProvisioningManager.createForSubscriptionId(anyInt()))
-                .thenReturn(mProvisioningManager);
-        when(SubscriptionManager.isValidSubscriptionId(anyInt())).thenReturn(true);
-        doAnswer(invocation -> null)
-                .when(mMockSubscriptionManager)
-                .addOnSubscriptionsChangedListener(
-                        any(Executor.class),
-                        any(SubscriptionManager.OnSubscriptionsChangedListener.class));
-
-        mQnsImsMgr = new QnsImsManager(sMockContext, 0);
-    }
-
-    @After
-    public void tearDown() {
-        if (mMockitoSession != null) {
-            mMockitoSession.finishMocking();
-            mMockitoSession = null;
-        }
-    }
-
-    @Test
-    public void testQnsImsManagerIsWfcEnabledByPlatform() {
-        when(mResources.getBoolean(com.android.internal.R.bool.config_device_wfc_ims_available))
-                .thenReturn(false);
-        assertFalse(mQnsImsMgr.isWfcEnabledByPlatform());
-
-        when(SystemProperties.getInt(eq("persist.dbg.wfc_avail_ovr0"), anyInt())).thenReturn(1);
-        assertTrue(mQnsImsMgr.isWfcEnabledByPlatform());
-        when(SystemProperties.getInt(eq("persist.dbg.wfc_avail_ovr0"), anyInt())).thenReturn(-1);
-        assertFalse(mQnsImsMgr.isWfcEnabledByPlatform());
-
-        when(SystemProperties.getInt(eq("persist.dbg.wfc_avail_ovr"), anyInt())).thenReturn(1);
-        assertTrue(mQnsImsMgr.isWfcEnabledByPlatform());
-        when(SystemProperties.getInt(eq("persist.dbg.wfc_avail_ovr"), anyInt())).thenReturn(-1);
-        assertFalse(mQnsImsMgr.isWfcEnabledByPlatform());
-
-        when(mResources.getBoolean(com.android.internal.R.bool.config_device_wfc_ims_available))
-                .thenReturn(true);
-        when(mMockCarrierConfigManager.getConfigForSubId(anyInt())).thenReturn(mBundle);
-        when(mBundle.getBoolean(eq(CarrierConfigManager.KEY_CARRIER_WFC_IMS_AVAILABLE_BOOL)))
-                .thenReturn(true);
-        when(mBundle.getBoolean(eq(CarrierConfigManager.KEY_CARRIER_IMS_GBA_REQUIRED_BOOL)))
-                .thenReturn(false);
-        assertTrue(mQnsImsMgr.isWfcEnabledByPlatform());
-    }
-
-    @Test
-    public void testQnsImsManagerIsWfcEnabledByUser() {
-        when(mMockImsMmTelManager.isVoWiFiSettingEnabled()).thenReturn(true);
-        assertTrue(mQnsImsMgr.isWfcEnabledByUser());
-
-        when(mMockImsMmTelManager.isVoWiFiSettingEnabled()).thenReturn(false);
-        assertFalse(mQnsImsMgr.isWfcEnabledByUser());
-    }
-
-    @Test
-    public void testQnsImsManagerIsWfcRoamingEnabledByUser() {
-        when(mMockImsMmTelManager.isVoWiFiRoamingSettingEnabled()).thenReturn(true);
-        assertTrue(mQnsImsMgr.isWfcRoamingEnabledByUser());
-
-        when(mMockImsMmTelManager.isVoWiFiRoamingSettingEnabled()).thenReturn(false);
-        assertFalse(mQnsImsMgr.isWfcRoamingEnabledByUser());
-    }
-
-    @Test
-    public void testQnsImsManagerIsWfcProvisionedOnDevice() {
-        when(mBundle.getBoolean(
-                        eq(CarrierConfigManager.KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL)))
-                .thenReturn(true);
-        when(mProvisioningManager.isProvisioningRequiredForCapability(anyInt(), anyInt()))
-                .thenReturn(true);
-        when(mProvisioningManager.getProvisioningStatusForCapability(
-                        anyInt(), eq(REGISTRATION_TECH_LTE)))
-                .thenReturn(false);
-        when(mProvisioningManager.getProvisioningStatusForCapability(
-                        anyInt(), eq(REGISTRATION_TECH_IWLAN)))
-                .thenReturn(true);
-        assertFalse(mQnsImsMgr.isWfcProvisionedOnDevice());
-
-        when(mBundle.getBoolean(
-                        eq(CarrierConfigManager.KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL)))
-                .thenReturn(true);
-        when(mProvisioningManager.isProvisioningRequiredForCapability(anyInt(), anyInt()))
-                .thenReturn(true);
-        when(mProvisioningManager.getProvisioningStatusForCapability(
-                        anyInt(), eq(REGISTRATION_TECH_LTE)))
-                .thenReturn(true);
-        when(mProvisioningManager.getProvisioningStatusForCapability(
-                        anyInt(), eq(REGISTRATION_TECH_IWLAN)))
-                .thenReturn(true);
-        assertTrue(mQnsImsMgr.isWfcProvisionedOnDevice());
-
-        when(mBundle.getBoolean(
-                        eq(CarrierConfigManager.KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL)))
-                .thenReturn(false);
-        when(mProvisioningManager.isProvisioningRequiredForCapability(anyInt(), anyInt()))
-                .thenReturn(true);
-        when(mProvisioningManager.getProvisioningStatusForCapability(
-                        anyInt(), eq(REGISTRATION_TECH_LTE)))
-                .thenReturn(true);
-        when(mProvisioningManager.getProvisioningStatusForCapability(
-                        anyInt(), eq(REGISTRATION_TECH_IWLAN)))
-                .thenReturn(false);
-        assertFalse(mQnsImsMgr.isWfcProvisionedOnDevice());
-
-        when(mBundle.getBoolean(
-                        eq(CarrierConfigManager.KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL)))
-                .thenReturn(false);
-        when(mProvisioningManager.isProvisioningRequiredForCapability(anyInt(), anyInt()))
-                .thenReturn(false);
-        assertTrue(mQnsImsMgr.isWfcProvisionedOnDevice());
-    }
-
-    @Test
-    public void testQnsImsManagerIsCrossSimCallingEnabled() throws ImsException {
-        when(mMockImsMmTelManager.isCrossSimCallingEnabled()).thenReturn(false);
-        assertFalse(mQnsImsMgr.isCrossSimCallingEnabled());
-
-        when(mMockImsMmTelManager.isCrossSimCallingEnabled()).thenReturn(true);
-        when(mResources.getBoolean(com.android.internal.R.bool.config_device_wfc_ims_available))
-                .thenReturn(true);
-        when(mMockCarrierConfigManager.getConfigForSubId(anyInt())).thenReturn(mBundle);
-        when(mBundle.getBoolean(eq(CarrierConfigManager.KEY_CARRIER_WFC_IMS_AVAILABLE_BOOL)))
-                .thenReturn(true);
-        when(mBundle.getBoolean(eq(CarrierConfigManager.KEY_CARRIER_IMS_GBA_REQUIRED_BOOL)))
-                .thenReturn(false);
-        when(mBundle.getBoolean(eq(CarrierConfigManager.KEY_CARRIER_CROSS_SIM_IMS_AVAILABLE_BOOL)))
-                .thenReturn(false);
-        assertFalse(mQnsImsMgr.isCrossSimCallingEnabled());
-
-        when(mBundle.getBoolean(eq(CarrierConfigManager.KEY_CARRIER_CROSS_SIM_IMS_AVAILABLE_BOOL)))
-                .thenReturn(true);
-        when(mBundle.getBoolean(
-                        eq(CarrierConfigManager.KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL)))
-                .thenReturn(true);
-        when(mProvisioningManager.isProvisioningRequiredForCapability(anyInt(), anyInt()))
-                .thenReturn(true);
-        when(mProvisioningManager.getProvisioningStatusForCapability(
-                        anyInt(), eq(REGISTRATION_TECH_LTE)))
-                .thenReturn(false);
-        when(mProvisioningManager.getProvisioningStatusForCapability(
-                        anyInt(), eq(REGISTRATION_TECH_IWLAN)))
-                .thenReturn(true);
-        assertFalse(mQnsImsMgr.isCrossSimCallingEnabled());
-
-        when(mBundle.getBoolean(eq(CarrierConfigManager.KEY_CARRIER_CROSS_SIM_IMS_AVAILABLE_BOOL)))
-                .thenReturn(true);
-        when(mBundle.getBoolean(
-                        eq(CarrierConfigManager.KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL)))
-                .thenReturn(true);
-        when(mProvisioningManager.isProvisioningRequiredForCapability(anyInt(), anyInt()))
-                .thenReturn(true);
-        when(mProvisioningManager.getProvisioningStatusForCapability(
-                        anyInt(), eq(REGISTRATION_TECH_LTE)))
-                .thenReturn(true);
-        when(mProvisioningManager.getProvisioningStatusForCapability(
-                        anyInt(), eq(REGISTRATION_TECH_IWLAN)))
-                .thenReturn(true);
-        assertTrue(mQnsImsMgr.isCrossSimCallingEnabled());
-    }
-
-    @Test
-    public void testQnsImsManagerGetWfcMode() {
-        when(mMockImsMmTelManager.getVoWiFiModeSetting()).thenReturn(0);
-        assertEquals(0, mQnsImsMgr.getWfcMode(false));
-
-        when(mMockImsMmTelManager.getVoWiFiModeSetting()).thenReturn(1);
-        assertEquals(1, mQnsImsMgr.getWfcMode(false));
-
-        when(mMockImsMmTelManager.getVoWiFiModeSetting()).thenReturn(2);
-        assertEquals(2, mQnsImsMgr.getWfcMode(false));
-    }
-
-    @Test
-    public void testQnsImsManagerGetWfcRoamingMode() {
-        when(mMockImsMmTelManager.getVoWiFiRoamingModeSetting()).thenReturn(0);
-        assertEquals(0, mQnsImsMgr.getWfcMode(true));
-
-        when(mMockImsMmTelManager.getVoWiFiRoamingModeSetting()).thenReturn(1);
-        assertEquals(1, mQnsImsMgr.getWfcMode(true));
-
-        when(mMockImsMmTelManager.getVoWiFiRoamingModeSetting()).thenReturn(2);
-        assertEquals(2, mQnsImsMgr.getWfcMode(true));
-    }
-
-    @Test
-    public void testQnsImsManagerGetWfcModeFromCarrierConfig() throws ImsException {
-        doThrow(new ImsException("Test Exception"))
-                .when(mMockImsMmTelManager)
-                .registerImsStateCallback(any(), any());
-        mQnsImsMgr = new QnsImsManager(sMockContext, 0);
-
-        when(mMockCarrierConfigManager.getConfigForSubId(anyInt())).thenReturn(mBundle);
-        when(mBundle.getInt(eq(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_MODE_INT)))
-                .thenReturn(0);
-        assertEquals(0, mQnsImsMgr.getWfcMode(false));
-
-        when(mBundle.getInt(eq(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_MODE_INT)))
-                .thenReturn(1);
-        assertEquals(1, mQnsImsMgr.getWfcMode(false));
-
-        when(mBundle.getInt(eq(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_MODE_INT)))
-                .thenReturn(2);
-        assertEquals(2, mQnsImsMgr.getWfcMode(false));
-    }
-
-    @Test
-    public void testQnsImsManagerGetWfcRoamingModeFromCarrierConfig() throws ImsException {
-        doThrow(new ImsException("Test Exception"))
-                .when(mMockImsMmTelManager)
-                .registerImsStateCallback(any(), any());
-        mQnsImsMgr = new QnsImsManager(sMockContext, 0);
-
-        when(mMockCarrierConfigManager.getConfigForSubId(anyInt())).thenReturn(mBundle);
-        when(mBundle.getInt(eq(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ROAMING_MODE_INT)))
-                .thenReturn(0);
-        assertEquals(0, mQnsImsMgr.getWfcMode(true));
-
-        when(mBundle.getInt(eq(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ROAMING_MODE_INT)))
-                .thenReturn(1);
-        assertEquals(1, mQnsImsMgr.getWfcMode(true));
-
-        when(mBundle.getInt(eq(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ROAMING_MODE_INT)))
-                .thenReturn(2);
-        assertEquals(2, mQnsImsMgr.getWfcMode(true));
-    }
-
-    @Test
-    public void testQnsImsManagerGetImsServiceState() throws InterruptedException {
-        when(sMockContext.getPackageManager()).thenReturn(mPackageManager);
-        when(mPackageManager.hasSystemFeature(any())).thenReturn(false);
-        boolean bException = false;
-        try {
-            mQnsImsMgr.getImsServiceState();
-        } catch (ImsException e) {
-            bException = true;
-        }
-        assertTrue(bException);
-
-        bException = false;
-        when(mPackageManager.hasSystemFeature(any())).thenReturn(true);
-        try {
-            mQnsImsMgr.getImsServiceState();
-        } catch (ImsException e) {
-            bException = true;
-        }
-        assertFalse(bException);
-    }
-
-    @Test
-    public void testQnsImsManagerInit() throws NoSuchFieldException, IllegalAccessException {
-        Field initializedField = QnsImsManager.class.getDeclaredField("mQnsImsManagerInitialized");
-        initializedField.setAccessible(true);
-        boolean qnsImsManagerInitialized = (boolean) initializedField.get(mQnsImsMgr);
-        assertTrue(qnsImsManagerInitialized);
-
-        Mockito.clearInvocations(mMockImsManager);
-        when(mMockImsManager.getSipDelegateManager(anyInt())).thenReturn(null);
-        mQnsImsMgr = new QnsImsManager(sMockContext, 0);
-        qnsImsManagerInitialized = (boolean) initializedField.get(mQnsImsMgr);
-        assertFalse(qnsImsManagerInitialized);
-
-        Mockito.clearInvocations(mMockImsManager);
-        when(mMockImsManager.getImsRcsManager(anyInt())).thenReturn(null);
-        mQnsImsMgr = new QnsImsManager(sMockContext, 0);
-        qnsImsManagerInitialized = (boolean) initializedField.get(mQnsImsMgr);
-        assertFalse(qnsImsManagerInitialized);
-
-        Mockito.clearInvocations(mMockImsManager);
-        when(mMockImsManager.getImsMmTelManager(anyInt())).thenReturn(null);
-        mQnsImsMgr = new QnsImsManager(sMockContext, 0);
-        qnsImsManagerInitialized = (boolean) initializedField.get(mQnsImsMgr);
-        assertFalse(qnsImsManagerInitialized);
-
-        Mockito.clearInvocations(mMockImsManager);
-        when(sMockContext.getSystemService(ImsManager.class)).thenReturn(null);
-        mQnsImsMgr = new QnsImsManager(sMockContext, 0);
-        qnsImsManagerInitialized = (boolean) initializedField.get(mQnsImsMgr);
-        assertFalse(qnsImsManagerInitialized);
-
-        Mockito.clearInvocations(mMockImsManager);
-        when(sMockContext.getSystemService(CarrierConfigManager.class)).thenReturn(null);
-        mQnsImsMgr = new QnsImsManager(sMockContext, 0);
-        qnsImsManagerInitialized = (boolean) initializedField.get(mQnsImsMgr);
-        assertFalse(qnsImsManagerInitialized);
-    }
-
-    @Test
-    public void testQnsImsManagerGetSlotIndex() {
-        assertEquals(0, mQnsImsMgr.getSlotIndex());
-        QnsImsManager qnsImsManager1 = new QnsImsManager(sMockContext, 1);
-        assertEquals(1, qnsImsManager1.getSlotIndex());
-    }
-
-    @Test
-    public void testQnsImsManagerClear()
-            throws NoSuchFieldException, IllegalAccessException, ImsException {
-        Field initializedField = QnsImsManager.class.getDeclaredField("mQnsImsManagerInitialized");
-        initializedField.setAccessible(true);
-        boolean qnsImsManagerInitialized = (boolean) initializedField.get(mQnsImsMgr);
-        assertTrue(qnsImsManagerInitialized);
-        ImsStateCallback rcsStateCallback = mQnsImsMgr.mRcsStateCallback;
-        rcsStateCallback.onAvailable();
-
-        mQnsImsMgr.clearQnsImsManager();
-        verify(mMockImsMmTelManager, times(1)).unregisterImsStateCallback(any());
-        verify(mMockImsMmTelManager, times(1))
-                .unregisterImsRegistrationCallback(
-                        any(RegistrationManager.RegistrationCallback.class));
-        verify(mMockImsRcsManager, times(1)).unregisterImsStateCallback(any());
-        verify(mMockImsRcsManager, times(1))
-                .unregisterImsRegistrationCallback(
-                        any(RegistrationManager.RegistrationCallback.class));
-        verify(mMockSipDelegateManager, times(1)).unregisterSipDialogStateCallback(any());
-    }
-
-    @Test
-    public void testQnsImsManagerSubscriptionChanged() {
-        SubscriptionManager.OnSubscriptionsChangedListener subListener =
-                mQnsImsMgr.mSubscriptionsChangeListener;
-
-        when(mMockSubscriptionInfo.getSubscriptionId()).thenReturn(1);
-        subListener.onSubscriptionsChanged();
-        assertNotNull(mQnsImsMgr.mMmTelStateCallback);
-        assertNotNull(mQnsImsMgr.mRcsStateCallback);
-
-        when(mMockSubscriptionInfo.getSubscriptionId())
-                .thenReturn(SubscriptionManager.INVALID_SUBSCRIPTION_ID);
-        subListener.onSubscriptionsChanged();
-        assertNull(mQnsImsMgr.mMmTelStateCallback);
-        assertNull(mQnsImsMgr.mRcsStateCallback);
-    }
-
-    @Test
-    public void testQnsImsManagerIsGbaValid()
-            throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
-        Method method = QnsImsManager.class.getDeclaredMethod("isGbaValid");
-        method.setAccessible(true);
-        assertTrue((Boolean) method.invoke(mQnsImsMgr));
-
-        when(mBundle.getBoolean(eq(CarrierConfigManager.KEY_CARRIER_IMS_GBA_REQUIRED_BOOL)))
-                .thenReturn(true);
-
-        when(mMockTelephonyManager.getIsimIst()).thenReturn(null);
-        assertTrue((Boolean) method.invoke(mQnsImsMgr));
-
-        when(mMockTelephonyManager.getIsimIst()).thenReturn("22");
-        assertTrue((Boolean) method.invoke(mQnsImsMgr));
-
-        when(mMockTelephonyManager.getIsimIst()).thenReturn("21");
-        assertFalse((Boolean) method.invoke(mQnsImsMgr));
-
-        when(sMockContext.getSystemService(TelephonyManager.class)).thenReturn(null);
-        assertFalse((Boolean) method.invoke(mQnsImsMgr));
-    }
-
-    @Test
-    public void testQnsImsManagerQnsImsRegistrationState() {
-        QnsImsManager.ImsRegistrationState stateReg =
-                new QnsImsManager.ImsRegistrationState(
-                        QnsConstants.IMS_REGISTRATION_CHANGED_REGISTERED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        null);
-        QnsImsManager.ImsRegistrationState stateUnreg =
-                new QnsImsManager.ImsRegistrationState(
-                        QnsConstants.IMS_REGISTRATION_CHANGED_UNREGISTERED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        null);
-        QnsImsManager.ImsRegistrationState stateAccessNetworkChangeFail =
-                new QnsImsManager.ImsRegistrationState(
-                        QnsConstants.IMS_REGISTRATION_CHANGED_ACCESS_NETWORK_CHANGE_FAILED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        null);
-        assertTrue(stateReg.toString().contains("IMS_REG"));
-        assertTrue(stateUnreg.toString().contains("IMS_UNREG"));
-        assertTrue(stateAccessNetworkChangeFail.toString().contains("IMS_ACCESS"));
-    }
-
-    private void triggerMmTelCallback_onRegistered(QnsImsManager qnsImsMgr, int transportType) {
-        RegistrationManager.RegistrationCallback mmtelImsRegistrationCallback =
-                qnsImsMgr.mMmtelImsRegistrationCallback;
-        ImsRegistrationAttributes attributes;
-        if (transportType == AccessNetworkConstants.TRANSPORT_TYPE_WLAN) {
-            attributes =
-                    new ImsRegistrationAttributes(
-                            REGISTRATION_TECH_IWLAN,
-                            AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                            0,
-                            Sets.newArraySet());
-        } else {
-            attributes =
-                    new ImsRegistrationAttributes(
-                            REGISTRATION_TECH_LTE,
-                            AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                            0,
-                            Sets.newArraySet());
-        }
-        mmtelImsRegistrationCallback.onRegistered(attributes);
-    }
-
-    private void triggerMmTelCallback_onUnregistered(QnsImsManager qnsImsMgr) {
-        ImsReasonInfo reason = new ImsReasonInfo();
-        reason.mCode = ImsReasonInfo.CODE_SIP_BUSY;
-        triggerMmTelCallback_onUnregistered(qnsImsMgr, reason);
-    }
-
-    private void triggerMmTelCallback_onUnregistered(
-            QnsImsManager qnsImsMgr, ImsReasonInfo reason) {
-        RegistrationManager.RegistrationCallback mmtelImsRegistrationCallback =
-                qnsImsMgr.mMmtelImsRegistrationCallback;
-        mmtelImsRegistrationCallback.onUnregistered(reason);
-    }
-
-    @Test
-    public void testQnsImsManagerQnsIsImsRegistered() {
-        triggerMmTelCallback_onRegistered(mQnsImsMgr, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        assertTrue(mQnsImsMgr.isImsRegistered(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-        assertFalse(mQnsImsMgr.isImsRegistered(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-
-        triggerMmTelCallback_onRegistered(mQnsImsMgr, AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        assertFalse(mQnsImsMgr.isImsRegistered(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-        assertTrue(mQnsImsMgr.isImsRegistered(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-
-        triggerMmTelCallback_onUnregistered(mQnsImsMgr);
-        assertFalse(mQnsImsMgr.isImsRegistered(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-        assertFalse(mQnsImsMgr.isImsRegistered(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-
-        mQnsImsMgr.mMmtelImsRegistrationCallback = null;
-        assertFalse(mQnsImsMgr.isImsRegistered(AccessNetworkConstants.TRANSPORT_TYPE_INVALID));
-    }
-
-    private void triggerRcsCallback_onRegistered(QnsImsManager qnsImsMgr, int transportType) {
-        RegistrationManager.RegistrationCallback rcsImsRegistrationCallback =
-                qnsImsMgr.mRcsImsRegistrationCallback;
-        ImsRegistrationAttributes attributes;
-        if (transportType == AccessNetworkConstants.TRANSPORT_TYPE_WLAN) {
-            attributes =
-                    new ImsRegistrationAttributes(
-                            REGISTRATION_TECH_IWLAN,
-                            AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                            0,
-                            Sets.newArraySet());
-        } else {
-            attributes =
-                    new ImsRegistrationAttributes(
-                            REGISTRATION_TECH_LTE,
-                            AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                            0,
-                            Sets.newArraySet());
-        }
-        rcsImsRegistrationCallback.onRegistered(attributes);
-    }
-
-    private void triggerRcsCallback_onUnregistered(QnsImsManager qnsImsMgr) {
-        ImsReasonInfo reason = new ImsReasonInfo();
-        reason.mCode = ImsReasonInfo.CODE_SIP_BUSY;
-        triggerRcsCallback_onUnregistered(qnsImsMgr, reason);
-    }
-
-    private void triggerRcsCallback_onUnregistered(QnsImsManager qnsImsMgr, ImsReasonInfo reason) {
-        RegistrationManager.RegistrationCallback rcsImsRegistrationCallback =
-                qnsImsMgr.mRcsImsRegistrationCallback;
-        rcsImsRegistrationCallback.onUnregistered(reason);
-    }
-
-    @Test
-    public void testQnsImsManagerQnsIsRcsRegistered() {
-        triggerRcsCallback_onRegistered(mQnsImsMgr, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        assertTrue(mQnsImsMgr.isRcsRegistered(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-        assertFalse(mQnsImsMgr.isRcsRegistered(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-
-        triggerRcsCallback_onRegistered(mQnsImsMgr, AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        assertFalse(mQnsImsMgr.isRcsRegistered(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-        assertTrue(mQnsImsMgr.isRcsRegistered(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-
-        triggerRcsCallback_onUnregistered(mQnsImsMgr);
-        assertFalse(mQnsImsMgr.isRcsRegistered(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-        assertFalse(mQnsImsMgr.isRcsRegistered(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-
-        mQnsImsMgr.mRcsImsRegistrationCallback = null;
-        assertFalse(mQnsImsMgr.isRcsRegistered(AccessNetworkConstants.TRANSPORT_TYPE_INVALID));
-    }
-
-    @Test
-    public void testQnsImsManagerQnsIsSipDialogSessionActive() {
-        ImsStateCallback rcsStateCallback = mQnsImsMgr.mRcsStateCallback;
-        rcsStateCallback.onAvailable();
-        SipDialogStateCallback sipDialogStateCallback =
-                mQnsImsMgr.mRcsSipDialogSessionStateCallback;
-        List<SipDialogState> dialogs = new ArrayList<>();
-        dialogs.add(new SipDialogState.Builder(SipDialogState.STATE_EARLY).build());
-        sipDialogStateCallback.onActiveSipDialogsChanged(dialogs);
-        assertFalse(mQnsImsMgr.isSipDialogSessionActive());
-
-        dialogs.clear();
-        dialogs.add(new SipDialogState.Builder(SipDialogState.STATE_CONFIRMED).build());
-        sipDialogStateCallback.onActiveSipDialogsChanged(dialogs);
-        assertTrue(mQnsImsMgr.isSipDialogSessionActive());
-
-        dialogs.clear();
-        dialogs.add(new SipDialogState.Builder(SipDialogState.STATE_CLOSED).build());
-        sipDialogStateCallback.onActiveSipDialogsChanged(dialogs);
-        assertFalse(mQnsImsMgr.isSipDialogSessionActive());
-
-        sipDialogStateCallback.onError();
-        assertFalse(mQnsImsMgr.isSipDialogSessionActive());
-    }
-
-    @Test
-    public void testImsStateEvents() throws InterruptedException {
-        final int eventImsStateChanged = 11005;
-        CountDownLatch imsAvailableLatch = new CountDownLatch(2);
-        CountDownLatch imsUnavailableLatch = new CountDownLatch(2);
-        HandlerThread handlerThread = new HandlerThread("testImsStateEvent");
-        handlerThread.start();
-        Handler handler =
-                new Handler(handlerThread.getLooper()) {
-                    @Override
-                    public void handleMessage(@NonNull Message msg) {
-                        QnsAsyncResult ar = (QnsAsyncResult) msg.obj;
-                        switch (msg.what) {
-                            case eventImsStateChanged:
-                                if (ar != null) {
-                                    QnsImsManager.ImsState state =
-                                            (QnsImsManager.ImsState) ar.mResult;
-                                    if (state.isImsAvailable()) {
-                                        imsAvailableLatch.countDown();
-                                    } else {
-                                        imsUnavailableLatch.countDown();
-                                    }
-                                }
-                                break;
-                        }
-                    }
-                };
-
-        ImsStateCallback imsStateCallback = mQnsImsMgr.mMmTelStateCallback;
-
-        mQnsImsMgr.registerImsStateChanged(handler, eventImsStateChanged);
-        mQnsImsMgr.notifyImsStateChanged(
-                ImsFeature.FEATURE_MMTEL, new QnsImsManager.ImsState(true));
-        mQnsImsMgr.notifyImsStateChanged(
-                ImsFeature.FEATURE_MMTEL, new QnsImsManager.ImsState(false));
-
-        imsStateCallback.onAvailable();
-        imsStateCallback.onAvailable();
-        imsStateCallback.onUnavailable(100);
-        imsStateCallback.onError();
-
-        assertTrue(imsAvailableLatch.await(100, TimeUnit.MILLISECONDS));
-        assertTrue(imsUnavailableLatch.await(100, TimeUnit.MILLISECONDS));
-
-        mQnsImsMgr.unregisterImsStateChanged(handler);
-        mQnsImsMgr.notifyImsStateChanged(
-                ImsFeature.FEATURE_MMTEL, new QnsImsManager.ImsState(true));
-        mQnsImsMgr.notifyImsStateChanged(
-                ImsFeature.FEATURE_MMTEL, new QnsImsManager.ImsState(false));
-
-        assertTrue(imsAvailableLatch.await(100, TimeUnit.MILLISECONDS));
-        assertTrue(imsUnavailableLatch.await(100, TimeUnit.MILLISECONDS));
-    }
-
-    @Test
-    public void testRcsStateEvents() throws InterruptedException {
-        final int eventRcsStateChanged = 11006;
-        CountDownLatch rcsAvailableLatch = new CountDownLatch(2);
-        CountDownLatch rcsUnavailableLatch = new CountDownLatch(2);
-        HandlerThread handlerThread = new HandlerThread("testRcsStateEvent");
-        handlerThread.start();
-        Handler handler =
-                new Handler(handlerThread.getLooper()) {
-                    @Override
-                    public void handleMessage(@NonNull Message msg) {
-                        QnsAsyncResult ar = (QnsAsyncResult) msg.obj;
-                        switch (msg.what) {
-                            case eventRcsStateChanged:
-                                if (ar != null) {
-                                    QnsImsManager.ImsState state =
-                                            (QnsImsManager.ImsState) ar.mResult;
-                                    if (state.isImsAvailable()) {
-                                        rcsAvailableLatch.countDown();
-                                    } else {
-                                        rcsUnavailableLatch.countDown();
-                                    }
-                                }
-                                break;
-                        }
-                    }
-                };
-
-        ImsStateCallback rcsStateCallback = mQnsImsMgr.mRcsStateCallback;
-
-        mQnsImsMgr.registerRcsStateChanged(handler, eventRcsStateChanged);
-        mQnsImsMgr.notifyImsStateChanged(ImsFeature.FEATURE_RCS, new QnsImsManager.ImsState(true));
-        mQnsImsMgr.notifyImsStateChanged(ImsFeature.FEATURE_RCS, new QnsImsManager.ImsState(false));
-
-        rcsStateCallback.onAvailable();
-        rcsStateCallback.onAvailable();
-        rcsStateCallback.onUnavailable(100);
-        rcsStateCallback.onError();
-
-        assertTrue(rcsAvailableLatch.await(100, TimeUnit.MILLISECONDS));
-        assertTrue(rcsUnavailableLatch.await(100, TimeUnit.MILLISECONDS));
-
-        mQnsImsMgr.unregisterRcsStateChanged(handler);
-        mQnsImsMgr.notifyImsStateChanged(ImsFeature.FEATURE_RCS, new QnsImsManager.ImsState(true));
-        mQnsImsMgr.notifyImsStateChanged(ImsFeature.FEATURE_RCS, new QnsImsManager.ImsState(false));
-
-        assertTrue(rcsAvailableLatch.await(100, TimeUnit.MILLISECONDS));
-        assertTrue(rcsUnavailableLatch.await(100, TimeUnit.MILLISECONDS));
-    }
-
-    @Test
-    public void testSipDialogSessionStateEvents() throws InterruptedException {
-        ImsStateCallback rcsStateCallback = mQnsImsMgr.mRcsStateCallback;
-        rcsStateCallback.onAvailable();
-
-        final int eventSipDialogSessionStateChanged = 11007;
-        CountDownLatch sipDialogSessionActiveStateLatch = new CountDownLatch(2);
-        CountDownLatch sipDialogSessionInactiveStateLatch = new CountDownLatch(2);
-        HandlerThread handlerThread = new HandlerThread("testSipDialogSessionStateEvent");
-        handlerThread.start();
-        Handler handler =
-                new Handler(handlerThread.getLooper()) {
-                    @Override
-                    public void handleMessage(@NonNull Message msg) {
-                        QnsAsyncResult ar = (QnsAsyncResult) msg.obj;
-                        switch (msg.what) {
-                            case eventSipDialogSessionStateChanged:
-                                if (ar != null) {
-                                    boolean isActive = (boolean) ar.mResult;
-                                    if (isActive) {
-                                        sipDialogSessionActiveStateLatch.countDown();
-                                    } else {
-                                        sipDialogSessionInactiveStateLatch.countDown();
-                                    }
-                                }
-                                break;
-                        }
-                    }
-                };
-
-        mQnsImsMgr.registerSipDialogSessionStateChanged(handler, eventSipDialogSessionStateChanged);
-        mQnsImsMgr.notifySipDialogSessionStateChanged(true);
-        mQnsImsMgr.notifySipDialogSessionStateChanged(false);
-
-        SipDialogStateCallback sipDialogStateCallback =
-                mQnsImsMgr.mRcsSipDialogSessionStateCallback;
-        List<SipDialogState> dialogs = new ArrayList<>();
-        dialogs.add(new SipDialogState.Builder(SipDialogState.STATE_CONFIRMED).build());
-        sipDialogStateCallback.onActiveSipDialogsChanged(dialogs);
-
-        dialogs.clear();
-        dialogs.add(new SipDialogState.Builder(SipDialogState.STATE_CLOSED).build());
-        sipDialogStateCallback.onActiveSipDialogsChanged(dialogs);
-
-        assertTrue(sipDialogSessionActiveStateLatch.await(100, TimeUnit.MILLISECONDS));
-        assertTrue(sipDialogSessionInactiveStateLatch.await(100, TimeUnit.MILLISECONDS));
-
-        mQnsImsMgr.unregisterSipDialogSessionStateChanged(handler);
-    }
-
-    @Test
-    public void testQnsImsManagerRegistrant() throws InterruptedException {
-        ImsStateCallback rcsStateCallback = mQnsImsMgr.mRcsStateCallback;
-        rcsStateCallback.onAvailable();
-
-        HandlerThread handlerThread = new HandlerThread("testQnsImsManagerClose");
-        handlerThread.start();
-        Handler handler = new Handler(handlerThread.getLooper());
-
-        mQnsImsMgr.registerImsStateChanged(handler, 1);
-        mQnsImsMgr.registerImsRegistrationStatusChanged(handler, 2);
-        mQnsImsMgr.registerRcsStateChanged(handler, 3);
-        mQnsImsMgr.registerRcsRegistrationStatusChanged(handler, 4);
-        mQnsImsMgr.registerSipDialogSessionStateChanged(handler, 5);
-
-        assertEquals(1, mQnsImsMgr.mMmTelImsStateListener.size());
-        assertEquals(1, mQnsImsMgr.mRcsImsStateListener.size());
-        assertEquals(1, mQnsImsMgr.mMmTelImsRegistrationListener.size());
-        assertEquals(1, mQnsImsMgr.mRcsImsRegistrationListener.size());
-        assertEquals(1, mQnsImsMgr.mRcsSipDialogSessionStateListener.size());
-
-        mQnsImsMgr.unregisterImsStateChanged(handler);
-        mQnsImsMgr.unregisterImsRegistrationStatusChanged(handler);
-        mQnsImsMgr.unregisterRcsStateChanged(handler);
-        mQnsImsMgr.unregisterRcsRegistrationStatusChanged(handler);
-        mQnsImsMgr.unregisterSipDialogSessionStateChanged(handler);
-
-        assertEquals(0, mQnsImsMgr.mMmTelImsStateListener.size());
-        assertEquals(0, mQnsImsMgr.mRcsImsStateListener.size());
-        assertEquals(0, mQnsImsMgr.mMmTelImsRegistrationListener.size());
-        assertEquals(0, mQnsImsMgr.mRcsImsRegistrationListener.size());
-        assertEquals(0, mQnsImsMgr.mRcsSipDialogSessionStateListener.size());
-    }
-
-    @Test
-    public void testQnsImsManagerClose() throws InterruptedException {
-        ImsStateCallback rcsStateCallback = mQnsImsMgr.mRcsStateCallback;
-        rcsStateCallback.onAvailable();
-
-        HandlerThread handlerThread = new HandlerThread("testQnsImsManagerClose");
-        handlerThread.start();
-        Handler handler = new Handler(handlerThread.getLooper());
-
-        mQnsImsMgr.registerImsStateChanged(handler, 1);
-        mQnsImsMgr.registerImsRegistrationStatusChanged(handler, 2);
-        mQnsImsMgr.registerRcsStateChanged(handler, 3);
-        mQnsImsMgr.registerRcsRegistrationStatusChanged(handler, 4);
-        mQnsImsMgr.registerSipDialogSessionStateChanged(handler, 5);
-
-        assertEquals(1, mQnsImsMgr.mMmTelImsStateListener.size());
-        assertEquals(1, mQnsImsMgr.mRcsImsStateListener.size());
-        assertEquals(1, mQnsImsMgr.mMmTelImsRegistrationListener.size());
-        assertEquals(1, mQnsImsMgr.mRcsImsRegistrationListener.size());
-        assertEquals(1, mQnsImsMgr.mRcsSipDialogSessionStateListener.size());
-
-        mQnsImsMgr.close();
-
-        assertEquals(0, mQnsImsMgr.mMmTelImsStateListener.size());
-        assertEquals(0, mQnsImsMgr.mRcsImsStateListener.size());
-        assertEquals(0, mQnsImsMgr.mMmTelImsRegistrationListener.size());
-        assertEquals(0, mQnsImsMgr.mRcsImsRegistrationListener.size());
-        assertEquals(0, mQnsImsMgr.mRcsSipDialogSessionStateListener.size());
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsMetricsTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsMetricsTest.java
deleted file mode 100644
index e7d1d6f..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsMetricsTest.java
+++ /dev/null
@@ -1,773 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static com.android.dx.mockito.inline.extended.ExtendedMockito.doReturn;
-import static com.android.dx.mockito.inline.extended.ExtendedMockito.mockitoSession;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.lenient;
-import static org.mockito.Mockito.timeout;
-import static org.mockito.Mockito.verify;
-
-import android.net.NetworkCapabilities;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.qns.QnsProtoEnums;
-
-import com.android.telephony.qns.DataConnectionStatusTracker.DataConnectionChangedInfo;
-import com.android.telephony.qns.QualifiedNetworksServiceImpl.QualifiedNetworksInfo;
-import com.android.telephony.qns.atoms.AtomsQnsFallbackRestrictionChangedInfo;
-import com.android.telephony.qns.atoms.AtomsQnsHandoverPingPongInfo;
-import com.android.telephony.qns.atoms.AtomsQnsHandoverTimeMillisInfo;
-import com.android.telephony.qns.atoms.AtomsQnsImsCallDropStats;
-import com.android.telephony.qns.atoms.AtomsQnsRatPreferenceMismatchInfo;
-import com.android.telephony.qns.atoms.AtomsQualifiedRatListChangedInfo;
-import com.android.telephony.statslib.AtomsPulled;
-import com.android.telephony.statslib.AtomsPushed;
-import com.android.telephony.statslib.StatsLib;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.mockito.MockitoSession;
-import org.mockito.stubbing.Answer;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class QnsMetricsTest extends QnsTest {
-    private static final int DEFAULT_CARRIER_ID = 1;
-
-    private final int mSlotId = 0;
-    private final int mNetCapability = NetworkCapabilities.NET_CAPABILITY_IMS;
-
-    @Mock private StatsLib mMockStatsLib;
-    @Mock private RestrictManager mMockRestrictManager;
-    @Mock private QualityMonitor mMockCellularQualityMonitor;
-    @Mock private QualityMonitor mMockWifiQualityMonitor;
-
-    private MockitoSession mStaticMockSession;
-    private QnsMetrics mQnsMetrics;
-    private long mSystemElapsedRealTime;
-
-    @Before
-    public void setUp() throws Exception {
-        MockitoAnnotations.initMocks(this);
-
-        mStaticMockSession = mockitoSession().mockStatic(QnsUtils.class).startMocking();
-
-        mSystemElapsedRealTime = 0L;
-        lenient()
-                .when(QnsUtils.getSystemElapsedRealTime())
-                .thenAnswer((Answer<Long>) invocation -> mSystemElapsedRealTime);
-
-        mQnsMetrics = new QnsMetrics(mMockStatsLib);
-    }
-
-    @After
-    public void cleanUp() {
-        mStaticMockSession.finishMocking();
-    }
-
-    private void spendSystemTime(long appendElapsedTime) {
-        mSystemElapsedRealTime += appendElapsedTime;
-    }
-
-    private void sendDataConnectionMessage(int event, int state, int transportType) {
-        DataConnectionChangedInfo info = new DataConnectionChangedInfo(event, state, transportType);
-        mQnsMetrics.log("QnsMetricsTest currentTime:" + mSystemElapsedRealTime + "ms " + info);
-        mQnsMetrics.reportAtomForDataConnectionChanged(
-                mNetCapability, mSlotId, info, DEFAULT_CARRIER_ID);
-        waitForLastHandlerAction(mQnsMetrics.getHandler());
-    }
-
-    private void sendQualifiedNetworksMessage(int accessNetworkType) {
-
-        List<Integer> list = new ArrayList<>();
-        list.add(accessNetworkType);
-
-        sendQualifiedNetworksMessage(
-                list,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                QnsConstants.COVERAGE_HOME,
-                true,
-                false,
-                QnsConstants.CELL_PREF,
-                QnsConstants.WIFI_PREF,
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                true,
-                false,
-                mMockRestrictManager,
-                mMockCellularQualityMonitor,
-                mMockWifiQualityMonitor,
-                QnsConstants.CALL_TYPE_IDLE);
-    }
-
-    private void sendQualifiedNetworksMessage(
-            List<Integer> accessNetworkTypes,
-            int dataConnectionCurrentTransportType,
-            int coverage,
-            boolean settingWfcEnabled,
-            boolean settingWfcRoamingEnabled,
-            int settingWfcMode,
-            int settingWfcRoamingMode,
-            int cellularAccessNetworkType,
-            boolean iwlanAvailable,
-            boolean isCrossWfc,
-            RestrictManager restrictManager,
-            QualityMonitor cellularQualityMonitor,
-            QualityMonitor wifiQualityMonitor,
-            int callType) {
-        QualifiedNetworksInfo info = new QualifiedNetworksInfo(
-                NetworkCapabilities.NET_CAPABILITY_IMS, accessNetworkTypes);
-
-        mQnsMetrics.log("QnsMetricsTest currentTime:" + mSystemElapsedRealTime + "ms " + info);
-        mQnsMetrics.reportAtomForQualifiedNetworks(
-                info,
-                mSlotId,
-                dataConnectionCurrentTransportType,
-                coverage,
-                settingWfcEnabled,
-                settingWfcRoamingEnabled,
-                settingWfcMode,
-                settingWfcRoamingMode,
-                cellularAccessNetworkType,
-                iwlanAvailable,
-                isCrossWfc,
-                restrictManager,
-                cellularQualityMonitor,
-                wifiQualityMonitor,
-                callType);
-        waitForLastHandlerAction(mQnsMetrics.getHandler());
-    }
-
-    @Test
-    public void testAtomsQnsHandoverTimeMillisInfo() {
-
-        ArgumentCaptor<AtomsPulled> capturePulled = ArgumentCaptor.forClass(AtomsPulled.class);
-        ArgumentCaptor<AtomsPushed> capturePushed = ArgumentCaptor.forClass(AtomsPushed.class);
-
-        spendSystemTime(10000L);
-        sendQualifiedNetworksMessage(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-
-        spendSystemTime(4010L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_STARTED,
-                DataConnectionStatusTracker.STATE_CONNECTING,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4020L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_CONNECTED,
-                DataConnectionStatusTracker.STATE_CONNECTED,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(501L);
-        sendQualifiedNetworksMessage(AccessNetworkConstants.AccessNetworkType.IWLAN);
-
-        spendSystemTime(4030L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_STARTED,
-                DataConnectionStatusTracker.STATE_HANDOVER,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4040L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                DataConnectionStatusTracker.STATE_CONNECTED,
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        spendSystemTime(5002L);
-        sendQualifiedNetworksMessage(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-
-        spendSystemTime(4050L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_STARTED,
-                DataConnectionStatusTracker.STATE_HANDOVER,
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        spendSystemTime(4060L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                DataConnectionStatusTracker.STATE_CONNECTED,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(50002L);
-        sendQualifiedNetworksMessage(AccessNetworkConstants.AccessNetworkType.IWLAN);
-
-        spendSystemTime(4070L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_STARTED,
-                DataConnectionStatusTracker.STATE_HANDOVER,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4080L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_FAILED,
-                DataConnectionStatusTracker.STATE_CONNECTED,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4090L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_STARTED,
-                DataConnectionStatusTracker.STATE_HANDOVER,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4100L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_FAILED,
-                DataConnectionStatusTracker.STATE_CONNECTED,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4110L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_STARTED,
-                DataConnectionStatusTracker.STATE_HANDOVER,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4120L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                DataConnectionStatusTracker.STATE_CONNECTED,
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        spendSystemTime(4130L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_DISCONNECTED,
-                DataConnectionStatusTracker.STATE_INACTIVE,
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        verify(mMockStatsLib, timeout(1000).times(4)).append(capturePulled.capture());
-        verify(mMockStatsLib, timeout(1000).times(4)).write(capturePushed.capture());
-        List<AtomsQnsHandoverTimeMillisInfo> listHandoverTime = new ArrayList<>();
-        List<AtomsQualifiedRatListChangedInfo> listQualifiedRat = new ArrayList<>();
-        for (AtomsPulled pulled : capturePulled.getAllValues()) {
-            if (pulled instanceof AtomsQnsHandoverTimeMillisInfo) {
-                listHandoverTime.add((AtomsQnsHandoverTimeMillisInfo) pulled);
-                mQnsMetrics.log("QnsMetricsTest HandoverTime atom:" + pulled);
-            }
-        }
-        for (AtomsPushed pushed : capturePushed.getAllValues()) {
-            if (pushed instanceof AtomsQualifiedRatListChangedInfo) {
-                listQualifiedRat.add((AtomsQualifiedRatListChangedInfo) pushed);
-                mQnsMetrics.log("QnsMetricsTest QualifiedRat atom:" + pushed);
-            }
-        }
-        assertEquals(3, listHandoverTime.size());
-        assertEquals(8070, listHandoverTime.get(0).getTimeForHoSuccess());
-        assertEquals(8110, listHandoverTime.get(1).getTimeForHoSuccess());
-        assertEquals(24570, listHandoverTime.get(2).getTimeForHoSuccess());
-
-        assertEquals(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                listQualifiedRat.get(0).getFirstQualifiedRat());
-        assertEquals(
-                AccessNetworkConstants.AccessNetworkType.IWLAN,
-                listQualifiedRat.get(1).getFirstQualifiedRat());
-        assertEquals(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                listQualifiedRat.get(2).getFirstQualifiedRat());
-        assertEquals(
-                AccessNetworkConstants.AccessNetworkType.IWLAN,
-                listQualifiedRat.get(3).getFirstQualifiedRat());
-    }
-
-    @Test
-    public void testAtomsQualifiedRatListChangedInfo() {
-
-        ArgumentCaptor<AtomsQualifiedRatListChangedInfo> capture =
-                ArgumentCaptor.forClass(AtomsQualifiedRatListChangedInfo.class);
-
-        doReturn(true)
-                .when(mMockRestrictManager)
-                .hasRestrictionType(anyInt(), eq(RestrictManager.RESTRICT_TYPE_RTP_LOW_QUALITY));
-        doReturn(true)
-                .when(mMockRestrictManager)
-                .hasRestrictionType(
-                        anyInt(), eq(RestrictManager.RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL));
-        doReturn(true)
-                .when(mMockRestrictManager)
-                .hasRestrictionType(
-                        anyInt(),
-                        eq(RestrictManager.RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL));
-
-        List<Integer> cellularAccessNetwork = new ArrayList<>();
-        cellularAccessNetwork.add(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        sendQualifiedNetworksMessage(
-                cellularAccessNetwork,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                QnsConstants.COVERAGE_HOME,
-                true,
-                false,
-                QnsConstants.CELL_PREF,
-                QnsConstants.WIFI_PREF,
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                false,
-                true,
-                mMockRestrictManager,
-                mMockCellularQualityMonitor,
-                mMockWifiQualityMonitor,
-                QnsConstants.CALL_TYPE_IDLE);
-
-        List<Integer> wifiAccessNetwork = new ArrayList<>();
-        wifiAccessNetwork.add(AccessNetworkConstants.AccessNetworkType.IWLAN);
-        sendQualifiedNetworksMessage(
-                wifiAccessNetwork,
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                QnsConstants.COVERAGE_ROAM,
-                false,
-                true,
-                QnsConstants.WIFI_PREF,
-                QnsConstants.CELL_PREF,
-                AccessNetworkConstants.AccessNetworkType.NGRAN,
-                true,
-                false,
-                mMockRestrictManager,
-                mMockCellularQualityMonitor,
-                mMockWifiQualityMonitor,
-                QnsConstants.CALL_TYPE_VOICE);
-
-        verify(mMockStatsLib, timeout(1000).times(2)).write(capture.capture());
-        List<AtomsQualifiedRatListChangedInfo> list = capture.getAllValues();
-        mQnsMetrics.log("QnsMetricsTest QualifiedRat atom[0]:" + list.get(0));
-        mQnsMetrics.log("QnsMetricsTest QualifiedRat atom[1]:" + list.get(1));
-        assertEquals(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                list.get(0).getFirstQualifiedRat());
-        assertEquals(
-                AccessNetworkConstants.AccessNetworkType.IWLAN, list.get(1).getFirstQualifiedRat());
-        int expectedRestriction =
-                QnsProtoEnums.RESTRICT_TYPE_RTP_LOW_QUALITY
-                        | QnsProtoEnums.RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL
-                        | QnsProtoEnums.RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL;
-        assertEquals(expectedRestriction, list.get(0).getRestrictionsOnWlan());
-        assertEquals(expectedRestriction, list.get(1).getRestrictionsOnWwan());
-    }
-
-    @Test
-    public void testAtomsQnsHandoverPingPongInfo() {
-
-        ArgumentCaptor<AtomsQnsHandoverPingPongInfo> capture =
-                ArgumentCaptor.forClass(AtomsQnsHandoverPingPongInfo.class);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_STARTED,
-                DataConnectionStatusTracker.STATE_CONNECTING,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_CONNECTED,
-                DataConnectionStatusTracker.STATE_CONNECTED,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_STARTED,
-                DataConnectionStatusTracker.STATE_HANDOVER,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                DataConnectionStatusTracker.STATE_CONNECTED,
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_STARTED,
-                DataConnectionStatusTracker.STATE_HANDOVER,
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                DataConnectionStatusTracker.STATE_CONNECTED,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_STARTED,
-                DataConnectionStatusTracker.STATE_HANDOVER,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                DataConnectionStatusTracker.STATE_CONNECTED,
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_STARTED,
-                DataConnectionStatusTracker.STATE_HANDOVER,
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                DataConnectionStatusTracker.STATE_CONNECTED,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_STARTED,
-                DataConnectionStatusTracker.STATE_HANDOVER,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(50000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                DataConnectionStatusTracker.STATE_CONNECTED,
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_STARTED,
-                DataConnectionStatusTracker.STATE_HANDOVER,
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                DataConnectionStatusTracker.STATE_CONNECTED,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_DISCONNECTED,
-                DataConnectionStatusTracker.STATE_INACTIVE,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        verify(mMockStatsLib, timeout(1000).times(2)).append(capture.capture());
-        List<AtomsQnsHandoverPingPongInfo> list = capture.getAllValues();
-        mQnsMetrics.log("QnsMetricsTest PingPong atom[0]:" + list.get(0));
-        mQnsMetrics.log("QnsMetricsTest PingPong atom[1]:" + list.get(1));
-        assertEquals(2, list.get(0).getCountHandoverPingPong());
-        assertEquals(1, list.get(1).getCountHandoverPingPong());
-    }
-
-    @Test
-    public void testAtomsQnsRatPreferenceMismatchInfo() {
-
-        ArgumentCaptor<AtomsQnsRatPreferenceMismatchInfo> capture =
-                ArgumentCaptor.forClass(AtomsQnsRatPreferenceMismatchInfo.class);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_STARTED,
-                DataConnectionStatusTracker.STATE_CONNECTING,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_CONNECTED,
-                DataConnectionStatusTracker.STATE_CONNECTED,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_STARTED,
-                DataConnectionStatusTracker.STATE_HANDOVER,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4100L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_FAILED,
-                DataConnectionStatusTracker.STATE_CONNECTED,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_STARTED,
-                DataConnectionStatusTracker.STATE_HANDOVER,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4200L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_FAILED,
-                DataConnectionStatusTracker.STATE_CONNECTED,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_STARTED,
-                DataConnectionStatusTracker.STATE_HANDOVER,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_DISCONNECTED,
-                DataConnectionStatusTracker.STATE_INACTIVE,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(50000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_STARTED,
-                DataConnectionStatusTracker.STATE_CONNECTING,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_CONNECTED,
-                DataConnectionStatusTracker.STATE_CONNECTED,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_STARTED,
-                DataConnectionStatusTracker.STATE_HANDOVER,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                DataConnectionStatusTracker.STATE_CONNECTED,
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_STARTED,
-                DataConnectionStatusTracker.STATE_HANDOVER,
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        spendSystemTime(4100L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_FAILED,
-                DataConnectionStatusTracker.STATE_CONNECTED,
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_STARTED,
-                DataConnectionStatusTracker.STATE_HANDOVER,
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        spendSystemTime(4200L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_FAILED,
-                DataConnectionStatusTracker.STATE_CONNECTED,
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_STARTED,
-                DataConnectionStatusTracker.STATE_HANDOVER,
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        spendSystemTime(4300L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_FAILED,
-                DataConnectionStatusTracker.STATE_CONNECTED,
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        spendSystemTime(4000L);
-        sendDataConnectionMessage(
-                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_DISCONNECTED,
-                DataConnectionStatusTracker.STATE_INACTIVE,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        verify(mMockStatsLib, timeout(1000).times(2)).append(capture.capture());
-        List<AtomsQnsRatPreferenceMismatchInfo> list = capture.getAllValues();
-        mQnsMetrics.log("QnsMetricsTest RatMismatch atom[0]:" + list.get(0));
-        mQnsMetrics.log("QnsMetricsTest RatMismatch atom[1]:" + list.get(1));
-        assertEquals(2, list.get(0).getHandoverFailCount());
-        assertEquals(3, list.get(1).getHandoverFailCount());
-        assertEquals(20300, list.get(0).getDurationOfMismatch());
-        assertEquals(24600, list.get(1).getDurationOfMismatch());
-    }
-
-    private void sendCallTypeChanged(
-            int oldCallType,
-            int newCallType,
-            RestrictManager restrictManager,
-            int transportTypeOfCall) {
-        mQnsMetrics.log(
-                "QnsMetricsTest callTypeChanged "
-                        + QnsConstants.callTypeToString(oldCallType)
-                        + "->"
-                        + QnsConstants.callTypeToString(newCallType)
-                        + " transportType:"
-                        + AccessNetworkConstants.transportTypeToString(transportTypeOfCall));
-        mQnsMetrics.reportAtomForCallTypeChanged(mNetCapability, mSlotId,
-                oldCallType, newCallType, restrictManager, transportTypeOfCall);
-        waitForLastHandlerAction(mQnsMetrics.getHandler());
-    }
-
-    private void sendImsCallDropStats(int transportTypeOfCall, int cellularAccessNetworkType) {
-        mQnsMetrics.log(
-                "QnsMetricsTest ImsCallDropStats transportTypeOfCall:"
-                        + AccessNetworkConstants.transportTypeToString(transportTypeOfCall)
-                        + " cellularAccessNetworkType:"
-                        + AccessNetworkConstants.AccessNetworkType.toString(
-                                cellularAccessNetworkType));
-        mQnsMetrics.reportAtomForImsCallDropStats(mNetCapability, mSlotId, mMockRestrictManager,
-                mMockCellularQualityMonitor, mMockWifiQualityMonitor, transportTypeOfCall,
-                cellularAccessNetworkType);
-        waitForLastHandlerAction(mQnsMetrics.getHandler());
-    }
-    private void sendFallbackRestrictionChanged(
-            List<Integer> wlanRestrictions, List<Integer> wwanRestrictions) {
-        mQnsMetrics.log(
-                "QnsMetricsTest FallbackRestrictionChanged wlanRestrictions:"
-                        + wlanRestrictions
-                        + ", wwanRestrictions:"
-                        + wwanRestrictions);
-        mQnsMetrics.reportAtomForRestrictions(
-                mNetCapability, mSlotId, wlanRestrictions, wwanRestrictions, DEFAULT_CARRIER_ID);
-        waitForLastHandlerAction(mQnsMetrics.getHandler());
-    }
-
-    @Test
-    public void testAtomsQnsImsCallDropStats() {
-
-        ArgumentCaptor<AtomsQnsImsCallDropStats> capture =
-                ArgumentCaptor.forClass(AtomsQnsImsCallDropStats.class);
-
-        // call start
-        sendCallTypeChanged(
-                QnsConstants.CALL_TYPE_IDLE,
-                QnsConstants.CALL_TYPE_VOICE,
-                mMockRestrictManager,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        // got rtp low from wwan side
-        spendSystemTime(10000L);
-        doReturn(true)
-                .when(mMockRestrictManager)
-                .hasRestrictionType(
-                        eq(AccessNetworkConstants.TRANSPORT_TYPE_WWAN),
-                        eq(RestrictManager.RESTRICT_TYPE_RTP_LOW_QUALITY));
-
-        // call end
-        spendSystemTime(3000L);
-        sendCallTypeChanged(
-                QnsConstants.CALL_TYPE_VOICE,
-                QnsConstants.CALL_TYPE_IDLE,
-                mMockRestrictManager,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        // media no data cause.
-        spendSystemTime(3000L);
-        sendImsCallDropStats(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                AccessNetworkConstants.AccessNetworkType.EUTRAN);
-
-        // call start over iwlan
-        spendSystemTime(10000L);
-        sendCallTypeChanged(
-                QnsConstants.CALL_TYPE_IDLE,
-                QnsConstants.CALL_TYPE_VOICE,
-                mMockRestrictManager,
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        // got rtp low from wlan side
-        spendSystemTime(10000L);
-        doReturn(true)
-                .when(mMockRestrictManager)
-                .hasRestrictionType(
-                        eq(AccessNetworkConstants.TRANSPORT_TYPE_WLAN),
-                        eq(RestrictManager.RESTRICT_TYPE_RTP_LOW_QUALITY));
-
-        // call end
-        spendSystemTime(3000L);
-        sendCallTypeChanged(
-                QnsConstants.CALL_TYPE_VOICE,
-                QnsConstants.CALL_TYPE_IDLE,
-                mMockRestrictManager,
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        // media no data cause
-        spendSystemTime(3000L);
-        sendImsCallDropStats(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                AccessNetworkConstants.AccessNetworkType.IWLAN);
-
-        // verify
-        verify(mMockStatsLib, timeout(1000).times(2)).write(capture.capture());
-        List<AtomsQnsImsCallDropStats> list = capture.getAllValues();
-        mQnsMetrics.log("QnsMetricsTest ImsCallDrop atom[0]:" + list.get(0));
-        mQnsMetrics.log("QnsMetricsTest ImsCallDrop atom[1]:" + list.get(1));
-        assertTrue(list.get(0).getRtpThresholdBreached());
-        assertTrue(list.get(1).getRtpThresholdBreached());
-    }
-
-
-    @Test
-    public void testAtomsQnsFallbackRestrictionChangedInfo() {
-
-        ArgumentCaptor<AtomsQnsFallbackRestrictionChangedInfo> capture =
-                ArgumentCaptor.forClass(AtomsQnsFallbackRestrictionChangedInfo.class);
-
-        List<Integer> wlanRestrictions = new ArrayList<>();
-        List<Integer> wwanRestrictions = new ArrayList<>();
-        sendFallbackRestrictionChanged(wlanRestrictions, wwanRestrictions);
-
-        wlanRestrictions.add(RestrictManager.RESTRICT_TYPE_GUARDING);
-        wwanRestrictions.add(RestrictManager.RESTRICT_TYPE_GUARDING);
-        sendFallbackRestrictionChanged(wlanRestrictions, wwanRestrictions);
-
-        wlanRestrictions.clear();
-        wwanRestrictions.clear();
-        wlanRestrictions.add(RestrictManager.RESTRICT_TYPE_RTP_LOW_QUALITY);
-        sendFallbackRestrictionChanged(wlanRestrictions, wwanRestrictions);
-
-        wlanRestrictions.clear();
-        wwanRestrictions.clear();
-        wwanRestrictions.add(RestrictManager.RESTRICT_TYPE_RTP_LOW_QUALITY);
-        sendFallbackRestrictionChanged(wlanRestrictions, wwanRestrictions);
-
-        wlanRestrictions.clear();
-        wwanRestrictions.clear();
-        wlanRestrictions.add(RestrictManager.RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL);
-        sendFallbackRestrictionChanged(wlanRestrictions, wwanRestrictions);
-
-        wlanRestrictions.clear();
-        wwanRestrictions.clear();
-        wwanRestrictions.add(RestrictManager.RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL);
-        sendFallbackRestrictionChanged(wlanRestrictions, wwanRestrictions);
-
-        wlanRestrictions.clear();
-        wwanRestrictions.clear();
-        wlanRestrictions.add(RestrictManager.RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL);
-        sendFallbackRestrictionChanged(wlanRestrictions, wwanRestrictions);
-
-        wlanRestrictions.clear();
-        wwanRestrictions.clear();
-        wwanRestrictions.add(RestrictManager.RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL);
-        sendFallbackRestrictionChanged(wlanRestrictions, wwanRestrictions);
-
-        // verify
-        verify(mMockStatsLib, timeout(1000).times(4)).write(capture.capture());
-        List<AtomsQnsFallbackRestrictionChangedInfo> list = capture.getAllValues();
-        mQnsMetrics.log("QnsMetricsTest ImsCallDrop atom[0]:" + list.get(0));
-        mQnsMetrics.log("QnsMetricsTest ImsCallDrop atom[1]:" + list.get(1));
-        mQnsMetrics.log("QnsMetricsTest ImsCallDrop atom[2]:" + list.get(2));
-        mQnsMetrics.log("QnsMetricsTest ImsCallDrop atom[3]:" + list.get(3));
-        assertTrue(list.get(0).getRestrictionOnWlanByRtpThresholdBreached());
-        assertTrue(list.get(1).getRestrictionOnWwanByRtpThresholdBreached());
-        assertTrue(list.get(2).getRestrictionOnWlanByImsRegistrationFailed());
-        assertTrue(list.get(3).getRestrictionOnWlanByWifiBackhaulProblem());
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsProvisioningListenerTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsProvisioningListenerTest.java
deleted file mode 100644
index 91b96d1..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsProvisioningListenerTest.java
+++ /dev/null
@@ -1,366 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static com.android.dx.mockito.inline.extended.ExtendedMockito.mockitoSession;
-
-import static org.junit.Assert.*;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.ArgumentMatchers.isA;
-import static org.mockito.Mockito.atLeast;
-import static org.mockito.Mockito.lenient;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.os.Handler;
-import android.os.Message;
-import android.os.test.TestLooper;
-import android.telephony.SubscriptionManager;
-import android.telephony.ims.ImsException;
-import android.telephony.ims.ImsMmTelManager;
-import android.telephony.ims.ProvisioningManager;
-import android.telephony.ims.feature.ImsFeature;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.mockito.MockitoSession;
-
-import java.lang.reflect.Field;
-import java.util.concurrent.Executor;
-
-@RunWith(JUnit4.class)
-public class QnsProvisioningListenerTest extends QnsTest {
-
-    private QnsProvisioningListener mQnsProvisioningListener;
-    private final int mSlotIndex = 0;
-    private MockitoSession mMockitoSession;
-    @Mock private ProvisioningManager mMockProvisioningManager;
-
-    private Handler mHandler;
-    TestLooper mTestLooper;
-    private ProvisioningManager.Callback mQnsProvisioningCallback;
-
-    @Before
-    public void setUp() throws Exception {
-        MockitoAnnotations.initMocks(this);
-        super.setUp();
-        mMockitoSession =
-                mockitoSession()
-                        .mockStatic(IwlanNetworkStatusTracker.class)
-                        .mockStatic(QnsUtils.class)
-                        .mockStatic(SubscriptionManager.class)
-                        .mockStatic(ProvisioningManager.class)
-                        .startMocking();
-        mTestLooper = new TestLooper();
-        mHandler = new Handler(mTestLooper.getLooper());
-        mockStatics();
-        mQnsProvisioningListener =
-                new QnsProvisioningListener(sMockContext, mMockQnsImsManager, mSlotIndex);
-        captureProvisioningHandler();
-    }
-
-    private void captureProvisioningHandler() throws ImsException {
-        ArgumentCaptor<ProvisioningManager.Callback> arg =
-                ArgumentCaptor.forClass(ProvisioningManager.Callback.class);
-
-        verify(mMockProvisioningManager, atLeast(1))
-                .registerProvisioningChangedCallback(isA(Executor.class), arg.capture());
-        mQnsProvisioningCallback = arg.getValue();
-    }
-
-    private void mockStatics() throws Exception {
-        lenient()
-                .when(ProvisioningManager.createForSubscriptionId(mSlotIndex))
-                .thenReturn(mMockProvisioningManager);
-        lenient().when(QnsUtils.getSubId(sMockContext, mSlotIndex)).thenReturn(mSlotIndex);
-        lenient().when(SubscriptionManager.isValidSubscriptionId(mSlotIndex)).thenReturn(true);
-        when(mMockQnsImsManager.getImsServiceState()).thenReturn(ImsFeature.STATE_READY);
-        when(mMockProvisioningManager.getProvisioningIntValue(anyInt())).thenReturn(0);
-        when(mMockProvisioningManager.getProvisioningStringValue(anyInt())).thenReturn("");
-    }
-
-    @After
-    public void tearDown() {
-        mMockitoSession.finishMocking();
-    }
-
-    @Test
-    public void testRegisterProvisioningItemInfoChanged() {
-        // wait for QnsProvisioningListener to load default items.
-        waitForLastHandlerAction(mQnsProvisioningListener.mQnsProvisioningHandler);
-        mQnsProvisioningListener.registerProvisioningItemInfoChanged(mHandler, 1, null, true);
-
-        Message msg = mTestLooper.nextMessage();
-        assertNotNull(msg);
-        assertEquals(1, msg.what);
-        assertNotNull(msg.obj);
-        QnsAsyncResult result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result);
-        QnsProvisioningListener.QnsProvisioningInfo info =
-                (QnsProvisioningListener.QnsProvisioningInfo) result.mResult;
-        assertNotNull(info);
-        mTestLooper.dispatchAll();
-
-        mQnsProvisioningCallback.onProvisioningIntChanged(
-                ProvisioningManager.KEY_VOLTE_PROVISIONING_STATUS,
-                ProvisioningManager.PROVISIONING_VALUE_ENABLED);
-        waitForLastHandlerAction(mQnsProvisioningListener.mQnsProvisioningHandler);
-        msg = mTestLooper.nextMessage();
-        assertNotNull(msg);
-        assertEquals(1, msg.what);
-        assertNotNull(msg.obj);
-        result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result);
-        info = (QnsProvisioningListener.QnsProvisioningInfo) result.mResult;
-        assertNotNull(info);
-        assertEquals(
-                ProvisioningManager.PROVISIONING_VALUE_ENABLED,
-                (int) info.getIntegerItem(ProvisioningManager.KEY_VOLTE_PROVISIONING_STATUS));
-
-        mQnsProvisioningListener.registerProvisioningItemInfoChanged(mHandler, 2, null, false);
-        msg = mTestLooper.nextMessage();
-        assertNull(msg);
-    }
-
-    @Test
-    public void testUnregisterProvisioningItemInfoChanged() {
-        // wait for QnsProvisioningListener to load default items.
-        waitForLastHandlerAction(mQnsProvisioningListener.mQnsProvisioningHandler);
-        mQnsProvisioningListener.registerProvisioningItemInfoChanged(mHandler, 1, null, false);
-
-        mQnsProvisioningCallback.onProvisioningIntChanged(
-                ProvisioningManager.KEY_VOLTE_PROVISIONING_STATUS,
-                ProvisioningManager.PROVISIONING_VALUE_ENABLED);
-        waitForLastHandlerAction(mQnsProvisioningListener.mQnsProvisioningHandler);
-        Message msg = mTestLooper.nextMessage();
-        assertNotNull(msg);
-
-        mQnsProvisioningListener.unregisterProvisioningItemInfoChanged(mHandler);
-
-        // Handler unregistered - so should not receive callback
-        mQnsProvisioningCallback.onProvisioningIntChanged(
-                ProvisioningManager.KEY_VOLTE_PROVISIONING_STATUS,
-                ProvisioningManager.PROVISIONING_VALUE_ENABLED);
-        waitForLastHandlerAction(mQnsProvisioningListener.mQnsProvisioningHandler);
-        msg = mTestLooper.nextMessage();
-        assertNull(msg);
-    }
-
-    @Test
-    public void testQnsProvisioningInfo() {
-        // wait for QnsProvisioningListener to load default items.
-        waitForLastHandlerAction(mQnsProvisioningListener.mQnsProvisioningHandler);
-        String entitlementId = "test-id";
-        mQnsProvisioningListener.registerProvisioningItemInfoChanged(mHandler, 1, null, false);
-        mQnsProvisioningCallback.onProvisioningIntChanged(
-                ProvisioningManager.KEY_VOLTE_PROVISIONING_STATUS,
-                ProvisioningManager.PROVISIONING_VALUE_ENABLED);
-        waitForLastHandlerAction(mQnsProvisioningListener.mQnsProvisioningHandler);
-        mTestLooper.nextMessage();
-        mQnsProvisioningCallback.onProvisioningStringChanged(
-                ProvisioningManager.KEY_VOICE_OVER_WIFI_ENTITLEMENT_ID, entitlementId);
-        waitForLastHandlerAction(mQnsProvisioningListener.mQnsProvisioningHandler);
-        mTestLooper.nextMessage();
-        mQnsProvisioningCallback.onProvisioningIntChanged(
-                ProvisioningManager.KEY_VOICE_OVER_WIFI_MODE_OVERRIDE,
-                ImsMmTelManager.WIFI_MODE_WIFI_PREFERRED);
-        waitForLastHandlerAction(mQnsProvisioningListener.mQnsProvisioningHandler);
-        Message msg = mTestLooper.nextMessage();
-
-        assertNotNull(msg);
-        assertEquals(1, msg.what);
-        assertNotNull(msg.obj);
-        QnsAsyncResult result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result);
-        QnsProvisioningListener.QnsProvisioningInfo info =
-                (QnsProvisioningListener.QnsProvisioningInfo) result.mResult;
-
-        // test hasItem()
-        assertTrue(info.hasItem(ProvisioningManager.KEY_VOLTE_PROVISIONING_STATUS));
-
-        // test getIntegerItem()
-        assertEquals(
-                ProvisioningManager.PROVISIONING_VALUE_ENABLED,
-                (int) info.getIntegerItem(ProvisioningManager.KEY_VOLTE_PROVISIONING_STATUS));
-        assertEquals(
-                ImsMmTelManager.WIFI_MODE_WIFI_PREFERRED,
-                (int) info.getIntegerItem(ProvisioningManager.KEY_VOICE_OVER_WIFI_MODE_OVERRIDE));
-
-        // test getStringItem()
-        assertEquals(
-                entitlementId,
-                info.getStringItem(ProvisioningManager.KEY_VOICE_OVER_WIFI_ENTITLEMENT_ID));
-
-        // test markUpdated() and isUpdated();
-        info.markUpdated(false);
-        assertFalse(info.isUpdated());
-
-        info.markUpdated(true);
-        assertTrue(info.isUpdated());
-
-        // test clear()
-        info.clear();
-        mQnsProvisioningListener.mQnsProvisioningHandler.handleMessage(
-                Message.obtain(
-                        mQnsProvisioningListener.mQnsProvisioningHandler,
-                        11005, // EVENT_IMS_STATE_CHANGED
-                        new QnsAsyncResult(null, new QnsImsManager.ImsState(false), null)));
-        assertNull(info.getIntegerItem(ProvisioningManager.KEY_VOICE_OVER_WIFI_MODE_OVERRIDE));
-        assertNull(info.getIntegerItem(ProvisioningManager.KEY_VOLTE_PROVISIONING_STATUS));
-        assertNull(info.getStringItem(ProvisioningManager.KEY_VOICE_OVER_WIFI_ENTITLEMENT_ID));
-    }
-
-    @Test
-    public void testEqualsIntegerItem_QnsProvisioningInfo() {
-        // wait for QnsProvisioningListener to load default items.
-        waitForLastHandlerAction(mQnsProvisioningListener.mQnsProvisioningHandler);
-        mQnsProvisioningListener.registerProvisioningItemInfoChanged(mHandler, 1, null, false);
-        mQnsProvisioningCallback.onProvisioningIntChanged(
-                ProvisioningManager.KEY_VOICE_OVER_WIFI_MODE_OVERRIDE,
-                ImsMmTelManager.WIFI_MODE_WIFI_PREFERRED);
-        waitForLastHandlerAction(mQnsProvisioningListener.mQnsProvisioningHandler);
-        Message msg = mTestLooper.nextMessage();
-        assertNotNull(msg);
-        assertEquals(1, msg.what);
-        assertNotNull(msg.obj);
-        QnsAsyncResult result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result);
-        QnsProvisioningListener.QnsProvisioningInfo info1 =
-                (QnsProvisioningListener.QnsProvisioningInfo) result.mResult;
-
-        mQnsProvisioningCallback.onProvisioningIntChanged(
-                ProvisioningManager.KEY_VOICE_OVER_WIFI_MODE_OVERRIDE,
-                ImsMmTelManager.WIFI_MODE_WIFI_ONLY);
-        waitForLastHandlerAction(mQnsProvisioningListener.mQnsProvisioningHandler);
-        msg = mTestLooper.nextMessage();
-        assertNotNull(msg);
-        assertEquals(1, msg.what);
-        assertNotNull(msg.obj);
-        result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result);
-        QnsProvisioningListener.QnsProvisioningInfo info2 =
-                (QnsProvisioningListener.QnsProvisioningInfo) result.mResult;
-
-        mQnsProvisioningCallback.onProvisioningIntChanged(
-                ProvisioningManager.KEY_VOICE_OVER_WIFI_MODE_OVERRIDE,
-                ImsMmTelManager.WIFI_MODE_WIFI_PREFERRED);
-        waitForLastHandlerAction(mQnsProvisioningListener.mQnsProvisioningHandler);
-        msg = mTestLooper.nextMessage();
-        assertNotNull(msg);
-        assertEquals(1, msg.what);
-        assertNotNull(msg.obj);
-        result = (QnsAsyncResult) msg.obj;
-        assertNotNull(result);
-        QnsProvisioningListener.QnsProvisioningInfo info3 =
-                (QnsProvisioningListener.QnsProvisioningInfo) result.mResult;
-
-        assertFalse(
-                info2.equalsIntegerItem(
-                        info1, ProvisioningManager.KEY_VOICE_OVER_WIFI_MODE_OVERRIDE));
-        assertTrue(
-                info3.equalsIntegerItem(
-                        info1, ProvisioningManager.KEY_VOICE_OVER_WIFI_MODE_OVERRIDE));
-    }
-
-    @Test
-    public void testUnregisterProvisioningCallback() throws ImsException {
-        mQnsProvisioningListener.mQnsProvisioningHandler.handleMessage(
-                Message.obtain(
-                        mQnsProvisioningListener.mQnsProvisioningHandler,
-                        11005, // EVENT_IMS_STATE_CHANGED
-                        new QnsAsyncResult(null, new QnsImsManager.ImsState(true), null)));
-
-        ArgumentCaptor<ProvisioningManager.Callback> arg =
-                ArgumentCaptor.forClass(ProvisioningManager.Callback.class);
-        verify(mMockProvisioningManager).unregisterProvisioningChangedCallback(arg.capture());
-
-        captureProvisioningHandler();
-    }
-
-    @Test
-    public void testOnIwlanNetworkStatusChangedEventHandler() throws ImsException {
-        mQnsProvisioningListener.mQnsProvisioningHandler.handleMessage(
-                Message.obtain(mQnsProvisioningListener.mQnsProvisioningHandler, 11002, null));
-
-        IwlanNetworkStatusTracker.IwlanAvailabilityInfo info =
-                mMockIwlanNetworkStatusTracker.new IwlanAvailabilityInfo(true, false);
-
-        mQnsProvisioningListener.mQnsProvisioningHandler.handleMessage(
-                Message.obtain(
-                        mQnsProvisioningListener.mQnsProvisioningHandler,
-                        11002,
-                        new QnsAsyncResult(null, info, null)));
-        ArgumentCaptor<ProvisioningManager.Callback> arg =
-                ArgumentCaptor.forClass(ProvisioningManager.Callback.class);
-        verify(mMockProvisioningManager, times(1))
-                .registerProvisioningChangedCallback(isA(Executor.class), arg.capture());
-        mQnsProvisioningCallback = arg.getValue();
-    }
-
-    @Test
-    public void testOnImsStateChangedEventHandler()
-            throws ImsException, NoSuchFieldException, IllegalAccessException {
-        int eventImsStateChanged = 11005;
-
-        mQnsProvisioningListener.mQnsProvisioningHandler.handleMessage(
-                Message.obtain(
-                        mQnsProvisioningListener.mQnsProvisioningHandler,
-                        eventImsStateChanged,
-                        null));
-
-        QnsImsManager.ImsState unavailable = new QnsImsManager.ImsState(false);
-        QnsImsManager.ImsState available = new QnsImsManager.ImsState(true);
-        waitForLastHandlerAction(mQnsProvisioningListener.mQnsProvisioningHandler);
-        mQnsProvisioningListener.mQnsProvisioningHandler.handleMessage(
-                Message.obtain(
-                        mQnsProvisioningListener.mQnsProvisioningHandler,
-                        eventImsStateChanged,
-                        new QnsAsyncResult(null, unavailable, null)));
-
-        QnsProvisioningListener.QnsProvisioningInfo clearInfo =
-                new QnsProvisioningListener.QnsProvisioningInfo();
-        clearInfo.clear();
-        waitForLastHandlerAction(mQnsProvisioningListener.mQnsProvisioningHandler);
-        Field field = QnsProvisioningListener.class.getDeclaredField("mProvisioningInfo");
-        field.setAccessible(true);
-        QnsProvisioningListener.QnsProvisioningInfo provisioningInfo =
-                (QnsProvisioningListener.QnsProvisioningInfo) field.get(mQnsProvisioningListener);
-
-        assertEquals(clearInfo.toString(), provisioningInfo.toString());
-
-        mQnsProvisioningListener.mQnsProvisioningHandler.handleMessage(
-                Message.obtain(
-                        mQnsProvisioningListener.mQnsProvisioningHandler,
-                        eventImsStateChanged,
-                        new QnsAsyncResult(null, available, null)));
-
-        waitForLastHandlerAction(mQnsProvisioningListener.mQnsProvisioningHandler);
-
-        ArgumentCaptor<ProvisioningManager.Callback> arg =
-                ArgumentCaptor.forClass(ProvisioningManager.Callback.class);
-        verify(mMockProvisioningManager, times(2))
-                .registerProvisioningChangedCallback(isA(Executor.class), arg.capture());
-        mQnsProvisioningCallback = arg.getValue();
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsTelephonyListenerTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsTelephonyListenerTest.java
deleted file mode 100644
index 2f50ff8..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsTelephonyListenerTest.java
+++ /dev/null
@@ -1,1098 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static android.telephony.NrVopsSupportInfo.NR_STATUS_VOPS_3GPP_SUPPORTED;
-
-import static com.android.dx.mockito.inline.extended.ExtendedMockito.mockitoSession;
-import static com.android.telephony.qns.QualityMonitor.EVENT_SUBSCRIPTION_ID_CHANGED;
-
-import static org.junit.Assert.*;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.Mockito.*;
-
-import android.content.Context;
-import android.net.LinkProperties;
-import android.net.NetworkCapabilities;
-import android.os.Handler;
-import android.os.Message;
-import android.os.test.TestLooper;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.BarringInfo;
-import android.telephony.CallState;
-import android.telephony.LteVopsSupportInfo;
-import android.telephony.NetworkRegistrationInfo;
-import android.telephony.NrVopsSupportInfo;
-import android.telephony.PreciseCallState;
-import android.telephony.PreciseDataConnectionState;
-import android.telephony.ServiceState;
-import android.telephony.SubscriptionManager;
-import android.telephony.TelephonyCallback;
-import android.telephony.TelephonyManager;
-import android.telephony.VopsSupportInfo;
-import android.telephony.data.ApnSetting;
-import android.telephony.ims.ImsCallProfile;
-import android.telephony.ims.ImsReasonInfo;
-import android.telephony.ims.MediaQualityStatus;
-import android.util.SparseArray;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.Mockito;
-import org.mockito.MockitoAnnotations;
-import org.mockito.MockitoSession;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.Executor;
-import java.util.function.Consumer;
-
-@RunWith(JUnit4.class)
-public final class QnsTelephonyListenerTest extends QnsTest {
-
-    private static final int CONDITIONAL_BARRING_FACTOR = 100;
-    private static final int CONDITIONAL_BARRING_TIME = 20;
-    QnsTelephonyListener mQtListener;
-    MockitoSession mStaticMockSession;
-
-    @Mock private Handler mMockHandler;
-
-    Handler mHandler;
-    TestLooper mTestLooper;
-    private MediaQualityStatus mTestMediaQuality;
-    private List<CallState> mTestCallStateList;
-    private Consumer<List<CallState>> mTestCallStateConsumer =
-            callStateList -> onTestCallStateChanged(callStateList);
-    void onTestCallStateChanged(List<CallState> callStateList) {
-        mTestCallStateList = callStateList;
-    }
-    private Consumer<MediaQualityStatus> mTestMediaQualityConsumer =
-            status -> onTestMediaQualityStatusChanged(status);
-    void onTestMediaQualityStatusChanged(MediaQualityStatus status) {
-        mTestMediaQuality = status;
-    }
-
-    @Before
-    public void setUp() throws Exception {
-        MockitoAnnotations.initMocks(this);
-        super.setUp();
-        mStaticMockSession = mockitoSession().mockStatic(QnsUtils.class).startMocking();
-        doAnswer(invocation -> null)
-                .when(mMockSubscriptionManager)
-                .addOnSubscriptionsChangedListener(
-                        any(Executor.class),
-                        any(SubscriptionManager.OnSubscriptionsChangedListener.class));
-        mTestLooper = new TestLooper();
-        mHandler = new Handler(mTestLooper.getLooper());
-        mQtListener = new QnsTelephonyListener(sMockContext, 0);
-    }
-
-    @After
-    public void tearDown() {
-        mStaticMockSession.finishMocking();
-        mTestCallStateList = null;
-        mTestMediaQuality = null;
-        if (mQtListener != null) mQtListener.close();
-    }
-
-    @Test
-    public void testNotifyQnsTelephonyInfo() {
-        QnsTelephonyListener.QnsTelephonyInfo qtInfo = mQtListener.new QnsTelephonyInfo();
-        qtInfo.setRegisteredPlmn("00102");
-        qtInfo.setDataNetworkType(TelephonyManager.NETWORK_TYPE_EDGE);
-        mQtListener.registerQnsTelephonyInfoChanged(
-                NetworkCapabilities.NET_CAPABILITY_MMS, mHandler, 1, null, false);
-
-        mQtListener.notifyQnsTelephonyInfo(qtInfo);
-        Message msg = mTestLooper.nextMessage();
-        assertNotNull(msg);
-        QnsTelephonyListener.QnsTelephonyInfo output =
-                (QnsTelephonyListener.QnsTelephonyInfo) ((QnsAsyncResult) msg.obj).mResult;
-        assertEquals(qtInfo, output);
-        mQtListener.unregisterQnsTelephonyInfoChanged(
-                NetworkCapabilities.NET_CAPABILITY_MMS, mHandler);
-
-        mQtListener.registerQnsTelephonyInfoChanged(
-                NetworkCapabilities.NET_CAPABILITY_IMS, mHandler, 1, null, false);
-        mQtListener.notifyQnsTelephonyInfo(qtInfo);
-        msg = mTestLooper.nextMessage();
-        assertNotNull(msg);
-        output = (QnsTelephonyListener.QnsTelephonyInfo) ((QnsAsyncResult) msg.obj).mResult;
-        assertTrue(output instanceof QnsTelephonyListener.QnsTelephonyInfoIms);
-    }
-
-    @Test
-    public void testNotifyQnsTelephonyInfoIms() {
-        QnsTelephonyListener.QnsTelephonyInfo qtInfo = mQtListener.new QnsTelephonyInfo();
-        qtInfo.setRegisteredPlmn("00102");
-        qtInfo.setDataNetworkType(TelephonyManager.NETWORK_TYPE_EDGE);
-        QnsTelephonyListener.QnsTelephonyInfoIms qtInfoIms =
-                mQtListener.new QnsTelephonyInfoIms(qtInfo, true, true, true, true);
-        mQtListener.registerQnsTelephonyInfoChanged(
-                NetworkCapabilities.NET_CAPABILITY_MMS, mHandler, 1, null, false);
-        mQtListener.notifyQnsTelephonyInfoIms(qtInfoIms);
-
-        Message msg = mTestLooper.nextMessage();
-        assertNull(msg); // should not notify for non-IMS network capability.
-
-        mQtListener.registerQnsTelephonyInfoChanged(
-                NetworkCapabilities.NET_CAPABILITY_IMS, mHandler, 1, null, false);
-        mQtListener.notifyQnsTelephonyInfoIms(qtInfoIms);
-
-        msg = mTestLooper.nextMessage();
-        assertNotNull(msg);
-        QnsTelephonyListener.QnsTelephonyInfoIms output =
-                (QnsTelephonyListener.QnsTelephonyInfoIms) ((QnsAsyncResult) msg.obj).mResult;
-        assertEquals(qtInfoIms, output); // notify for IMS network capability
-    }
-
-    @Test
-    public void testGetLastQnsTelephonyInfo() {
-        QnsTelephonyListener.QnsTelephonyInfo qtInfo = mQtListener.getLastQnsTelephonyInfo();
-        assertEquals(ServiceState.STATE_OUT_OF_SERVICE, qtInfo.getDataRegState());
-        assertEquals(TelephonyManager.NETWORK_TYPE_UNKNOWN, qtInfo.getDataNetworkType());
-        assertEquals(TelephonyManager.NETWORK_TYPE_UNKNOWN, qtInfo.getVoiceNetworkType());
-        assertEquals("", qtInfo.getRegisteredPlmn());
-        assertFalse(qtInfo.isCoverage());
-        assertFalse(qtInfo.isCellularAvailable());
-
-        testOnCellularServiceStateChangedWithLteVopsOnHome();
-
-        qtInfo = mQtListener.getLastQnsTelephonyInfo();
-        assertEquals(ServiceState.STATE_IN_SERVICE, qtInfo.getDataRegState());
-        assertEquals(TelephonyManager.NETWORK_TYPE_LTE, qtInfo.getDataNetworkType());
-        assertEquals(TelephonyManager.NETWORK_TYPE_LTE, qtInfo.getVoiceNetworkType());
-        assertEquals("00101", qtInfo.getRegisteredPlmn());
-        assertFalse(qtInfo.isCoverage());
-        assertTrue(qtInfo.isCellularAvailable());
-    }
-
-    @Test
-    public void testGetLastPreciseDataConnectionState() {
-        PreciseDataConnectionState output;
-        List<Integer> imsCapabilities = new ArrayList<>();
-        List<Integer> xcapCapabilities = new ArrayList<>();
-        imsCapabilities.add(NetworkCapabilities.NET_CAPABILITY_IMS);
-        xcapCapabilities.add(NetworkCapabilities.NET_CAPABILITY_XCAP);
-        lenient()
-                .when(QnsUtils.getNetCapabilitiesFromApnTypeBitmask(anyInt()))
-                .thenReturn(xcapCapabilities)
-                .thenReturn(imsCapabilities);
-
-        PreciseDataConnectionState connectionStateIms =
-                new PreciseDataConnectionState.Builder()
-                        .setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WWAN)
-                        .setId(1)
-                        .setState(TelephonyManager.DATA_CONNECTED)
-                        .setNetworkType(TelephonyManager.NETWORK_TYPE_LTE)
-                        .setApnSetting(
-                                new ApnSetting.Builder()
-                                        .setApnTypeBitmask(ApnSetting.TYPE_IMS)
-                                        .setApnName("ims")
-                                        .setEntryName("ims")
-                                        .build())
-                        .setLinkProperties(new LinkProperties())
-                        .setFailCause(0)
-                        .build();
-        PreciseDataConnectionState connectionStateXcap =
-                new PreciseDataConnectionState.Builder()
-                        .setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WWAN)
-                        .setId(1)
-                        .setState(TelephonyManager.DATA_DISCONNECTED)
-                        .setNetworkType(TelephonyManager.NETWORK_TYPE_LTE)
-                        .setApnSetting(
-                                new ApnSetting.Builder()
-                                        .setApnTypeBitmask(ApnSetting.TYPE_XCAP)
-                                        .setApnName("hos")
-                                        .setEntryName("hos")
-                                        .build())
-                        .setLinkProperties(new LinkProperties())
-                        .setFailCause(27)
-                        .build();
-
-        mQtListener.mTelephonyListener.onPreciseDataConnectionStateChanged(connectionStateXcap);
-        mQtListener.mTelephonyListener.onPreciseDataConnectionStateChanged(connectionStateIms);
-
-        output =
-                mQtListener.getLastPreciseDataConnectionState(
-                        NetworkCapabilities.NET_CAPABILITY_IMS);
-        assertNotEquals(connectionStateXcap, output);
-        assertEquals(connectionStateIms, output);
-
-        output =
-                mQtListener.getLastPreciseDataConnectionState(
-                        NetworkCapabilities.NET_CAPABILITY_XCAP);
-        assertEquals(connectionStateXcap, output);
-    }
-
-    @Test
-    public void testValidatePreciseDataConnectionStateChanged() {
-        PreciseDataConnectionState output;
-        PreciseDataConnectionState connectedStateIms =
-                new PreciseDataConnectionState.Builder()
-                        .setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WWAN)
-                        .setId(1)
-                        .setState(TelephonyManager.DATA_CONNECTED)
-                        .setNetworkType(TelephonyManager.NETWORK_TYPE_LTE)
-                        .setApnSetting(
-                                new ApnSetting.Builder()
-                                        .setApnTypeBitmask(ApnSetting.TYPE_IMS)
-                                        .setApnName("ims")
-                                        .setEntryName("ims")
-                                        .build())
-                        .setLinkProperties(new LinkProperties())
-                        .setFailCause(0)
-                        .build();
-        PreciseDataConnectionState handoverStateIms =
-                new PreciseDataConnectionState.Builder()
-                        .setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WLAN)
-                        .setId(2)
-                        .setState(TelephonyManager.DATA_HANDOVER_IN_PROGRESS)
-                        .setNetworkType(TelephonyManager.NETWORK_TYPE_IWLAN)
-                        .setApnSetting(
-                                new ApnSetting.Builder()
-                                        .setApnTypeBitmask(ApnSetting.TYPE_IMS)
-                                        .setApnName("ims")
-                                        .setEntryName("ims")
-                                        .build())
-                        .setLinkProperties(new LinkProperties())
-                        .setFailCause(0)
-                        .build();
-        mQtListener.mTelephonyListener.onPreciseDataConnectionStateChanged(connectedStateIms);
-        mQtListener.mTelephonyListener.onPreciseDataConnectionStateChanged(handoverStateIms);
-
-        mQtListener.close();
-
-        mQtListener = new QnsTelephonyListener(sMockContext, 0);
-
-        mQtListener.mTelephonyListener.onPreciseDataConnectionStateChanged(handoverStateIms);
-        output =
-                mQtListener.getLastPreciseDataConnectionState(
-                        NetworkCapabilities.NET_CAPABILITY_IMS);
-        assertNull(output);
-
-        mQtListener.mTelephonyListener.onPreciseDataConnectionStateChanged(connectedStateIms);
-
-        output =
-                mQtListener.getLastPreciseDataConnectionState(
-                        NetworkCapabilities.NET_CAPABILITY_IMS);
-        assertNull(output);
-    }
-
-    @Test
-    public void testRegisterQnsTelephonyInfoChanged() {
-        mQtListener.registerQnsTelephonyInfoChanged(
-                NetworkCapabilities.NET_CAPABILITY_IMS, mHandler, 1, null, false);
-
-        assertNotNull(
-                mQtListener.mQnsTelephonyInfoRegistrantMap.get(
-                        NetworkCapabilities.NET_CAPABILITY_IMS));
-        assertEquals(
-                1,
-                mQtListener
-                        .mQnsTelephonyInfoRegistrantMap
-                        .get(NetworkCapabilities.NET_CAPABILITY_IMS)
-                        .size());
-        assertEquals(0, mTestLooper.dispatchAll());
-
-        mQtListener.registerQnsTelephonyInfoChanged(
-                NetworkCapabilities.NET_CAPABILITY_XCAP, mHandler, 2, null, true);
-
-        assertNotNull(
-                mQtListener.mQnsTelephonyInfoRegistrantMap.get(
-                        NetworkCapabilities.NET_CAPABILITY_XCAP));
-        assertEquals(
-                1,
-                mQtListener
-                        .mQnsTelephonyInfoRegistrantMap
-                        .get(NetworkCapabilities.NET_CAPABILITY_XCAP)
-                        .size());
-        assertEquals(1, mTestLooper.dispatchAll());
-    }
-
-    @Test
-    public void testRegisterPreciseDataConnectionStateChanged() {
-        mQtListener.registerPreciseDataConnectionStateChanged(
-                NetworkCapabilities.NET_CAPABILITY_IMS, mHandler, 1, null, false);
-
-        assertNotNull(
-                mQtListener.mNetCapabilityRegistrantMap.get(
-                        NetworkCapabilities.NET_CAPABILITY_IMS));
-        assertEquals(
-                1,
-                mQtListener
-                        .mNetCapabilityRegistrantMap
-                        .get(NetworkCapabilities.NET_CAPABILITY_IMS)
-                        .size());
-        assertEquals(0, mTestLooper.dispatchAll());
-
-        mQtListener.registerPreciseDataConnectionStateChanged(
-                NetworkCapabilities.NET_CAPABILITY_XCAP, mHandler, 2, null, true);
-
-        assertNotNull(
-                mQtListener.mNetCapabilityRegistrantMap.get(
-                        NetworkCapabilities.NET_CAPABILITY_XCAP));
-        assertEquals(
-                1,
-                mQtListener
-                        .mNetCapabilityRegistrantMap
-                        .get(NetworkCapabilities.NET_CAPABILITY_XCAP)
-                        .size());
-        // not notified since precise data connection state is null for network capability.
-        assertEquals(0, mTestLooper.dispatchAll());
-    }
-
-    @Test
-    public void testRegisterCallStateListener() {
-        mQtListener.registerCallStateListener(mHandler, 1, null, false);
-
-        assertEquals(1, mQtListener.mCallStateListener.size());
-        assertEquals(0, mTestLooper.dispatchAll());
-
-        mQtListener.registerCallStateListener(mHandler, 2, null, true);
-
-        assertEquals(2, mQtListener.mCallStateListener.size());
-        assertEquals(1, mTestLooper.dispatchAll());
-    }
-
-    @Test
-    public void testRegisterSrvccStateListener() {
-        mQtListener.registerSrvccStateListener(mHandler, 1, null);
-
-        assertEquals(1, mQtListener.mSrvccStateListener.size());
-        assertEquals(0, mTestLooper.dispatchAll());
-    }
-
-    @Test
-    public void testUnregisterQnsTelephonyInfoChanged() {
-        testRegisterQnsTelephonyInfoChanged();
-        mQtListener.unregisterQnsTelephonyInfoChanged(
-                NetworkCapabilities.NET_CAPABILITY_IMS, mHandler);
-
-        assertNotNull(
-                mQtListener.mQnsTelephonyInfoRegistrantMap.get(
-                        NetworkCapabilities.NET_CAPABILITY_IMS));
-        assertEquals(
-                0,
-                mQtListener
-                        .mQnsTelephonyInfoRegistrantMap
-                        .get(NetworkCapabilities.NET_CAPABILITY_IMS)
-                        .size());
-        assertEquals(0, mTestLooper.dispatchAll());
-
-        assertNotNull(
-                mQtListener.mQnsTelephonyInfoRegistrantMap.get(
-                        NetworkCapabilities.NET_CAPABILITY_XCAP));
-        assertEquals(
-                1,
-                mQtListener
-                        .mQnsTelephonyInfoRegistrantMap
-                        .get(NetworkCapabilities.NET_CAPABILITY_XCAP)
-                        .size());
-        assertEquals(0, mTestLooper.dispatchAll());
-
-        mQtListener.unregisterQnsTelephonyInfoChanged(
-                NetworkCapabilities.NET_CAPABILITY_XCAP, mHandler);
-        assertEquals(
-                0,
-                mQtListener
-                        .mQnsTelephonyInfoRegistrantMap
-                        .get(NetworkCapabilities.NET_CAPABILITY_XCAP)
-                        .size());
-        assertEquals(0, mTestLooper.dispatchAll());
-    }
-
-    @Test
-    public void testUnregisterPreciseDataConnectionStateChanged() {
-        testRegisterPreciseDataConnectionStateChanged();
-        mQtListener.unregisterPreciseDataConnectionStateChanged(
-                NetworkCapabilities.NET_CAPABILITY_IMS, mHandler);
-
-        assertNotNull(
-                mQtListener.mNetCapabilityRegistrantMap.get(
-                        NetworkCapabilities.NET_CAPABILITY_IMS));
-        assertEquals(
-                0,
-                mQtListener
-                        .mNetCapabilityRegistrantMap
-                        .get(NetworkCapabilities.NET_CAPABILITY_IMS)
-                        .size());
-        assertEquals(0, mTestLooper.dispatchAll());
-
-        assertNotNull(
-                mQtListener.mNetCapabilityRegistrantMap.get(
-                        NetworkCapabilities.NET_CAPABILITY_XCAP));
-        assertEquals(
-                1,
-                mQtListener
-                        .mNetCapabilityRegistrantMap
-                        .get(NetworkCapabilities.NET_CAPABILITY_XCAP)
-                        .size());
-        assertEquals(0, mTestLooper.dispatchAll());
-
-        mQtListener.unregisterPreciseDataConnectionStateChanged(
-                NetworkCapabilities.NET_CAPABILITY_XCAP, mHandler);
-        assertEquals(
-                0,
-                mQtListener
-                        .mNetCapabilityRegistrantMap
-                        .get(NetworkCapabilities.NET_CAPABILITY_XCAP)
-                        .size());
-        assertEquals(0, mTestLooper.dispatchAll());
-    }
-
-    @Test
-    public void testUnregisterCallStateChanged() {
-        testRegisterCallStateListener();
-        mQtListener.unregisterCallStateChanged(mHandler);
-
-        assertNotNull(mQtListener.mCallStateListener);
-        assertEquals(0, mQtListener.mCallStateListener.size());
-        assertEquals(0, mTestLooper.dispatchAll());
-    }
-
-    @Test
-    public void testUnregisterSrvccStateChanged() {
-        testRegisterSrvccStateListener();
-        mQtListener.unregisterSrvccStateChanged(mHandler);
-
-        assertNotNull(mQtListener.mSrvccStateListener);
-        assertEquals(0, mQtListener.mSrvccStateListener.size());
-        assertEquals(0, mTestLooper.dispatchAll());
-    }
-
-    @Test
-    public void testStopTelephonyListener() {
-        mQtListener.stopTelephonyListener(anyInt());
-        verify(mMockTelephonyManager).unregisterTelephonyCallback(any(TelephonyCallback.class));
-    }
-
-    @Test
-    public void testStartTelephonyListener() {
-        mQtListener.mSubscriptionsChangeListener.onSubscriptionsChanged();
-        mQtListener.startTelephonyListener(1);
-        verify(mMockTelephonyManager, atLeastOnce())
-                .registerTelephonyCallback(
-                        anyInt(), any(Executor.class), any(TelephonyCallback.class));
-
-        Mockito.clearInvocations(mMockTelephonyManager);
-        mQtListener.startTelephonyListener(-1);
-        verify(mMockTelephonyManager, never())
-                .registerTelephonyCallback(
-                        anyInt(), any(Executor.class), any(TelephonyCallback.class));
-    }
-
-    @Test
-    public void testRegisterSubscriptionsIDChangedListener() {
-        lenient()
-                .when(QnsUtils.getSubId(isA(Context.class), anyInt()))
-                .thenReturn(-1)
-                .thenReturn(1);
-        mQtListener.registerSubscriptionIdListener(mHandler, EVENT_SUBSCRIPTION_ID_CHANGED, null);
-        mQtListener.mSubscriptionsChangeListener.onSubscriptionsChanged();
-        Message msg = mTestLooper.nextMessage();
-        assertNull(msg);
-
-        mQtListener.mSubscriptionsChangeListener.onSubscriptionsChanged();
-        msg = mTestLooper.nextMessage();
-        assertNotNull(msg);
-        assertEquals(EVENT_SUBSCRIPTION_ID_CHANGED, msg.what);
-
-        mQtListener.mSubscriptionsChangeListener.onSubscriptionsChanged();
-        msg = mTestLooper.nextMessage();
-        assertNull(msg);
-    }
-
-    @Test
-    public void testUnregisterSubscriptionsIDChanged() {
-        lenient().when(QnsUtils.getSubId(sMockContext, 0)).thenReturn(0);
-        mQtListener.registerSubscriptionIdListener(mHandler, EVENT_SUBSCRIPTION_ID_CHANGED, null);
-        mQtListener.unregisterSubscriptionIdChanged(mHandler);
-        mQtListener.mSubscriptionsChangeListener.onSubscriptionsChanged();
-        Message msg = mTestLooper.nextMessage();
-        assertNull(msg);
-    }
-
-    @Test
-    public void testOnCellularServiceStateChangedWithLteVopsOnHome() {
-        VopsSupportInfo vopsSupportInfo =
-                new LteVopsSupportInfo(
-                        LteVopsSupportInfo.LTE_STATUS_SUPPORTED,
-                        LteVopsSupportInfo.LTE_STATUS_SUPPORTED);
-        setOnCellularServiceStateChangedWithLteVopsOn(
-                vopsSupportInfo,
-                NetworkRegistrationInfo.DOMAIN_PS,
-                NetworkRegistrationInfo.REGISTRATION_STATE_HOME);
-
-        assertEquals(
-                ServiceState.STATE_IN_SERVICE,
-                mQtListener.mLastQnsTelephonyInfoIms.getDataRegState());
-        assertEquals(
-                TelephonyManager.NETWORK_TYPE_LTE,
-                mQtListener.mLastQnsTelephonyInfoIms.getDataNetworkType());
-        assertEquals(
-                TelephonyManager.NETWORK_TYPE_LTE,
-                mQtListener.mLastQnsTelephonyInfoIms.getVoiceNetworkType());
-        assertEquals("00101", mQtListener.mLastQnsTelephonyInfoIms.getRegisteredPlmn());
-        assertFalse(mQtListener.mLastQnsTelephonyInfoIms.isCoverage());
-        assertTrue(mQtListener.mLastQnsTelephonyInfoIms.isCellularAvailable());
-        assertFalse(mQtListener.mLastQnsTelephonyInfoIms.getEmergencyBarring());
-        assertFalse(mQtListener.mLastQnsTelephonyInfoIms.getVoiceBarring());
-        assertTrue(mQtListener.mLastQnsTelephonyInfoIms.getVopsEmergencySupport());
-        assertTrue(mQtListener.mLastQnsTelephonyInfoIms.getVopsSupport());
-    }
-
-    @Test
-    public void testOnCellularServiceStateChangedWithLteVopsOnRoam() {
-        VopsSupportInfo vopsSupportInfo =
-                new LteVopsSupportInfo(
-                        LteVopsSupportInfo.LTE_STATUS_SUPPORTED,
-                        LteVopsSupportInfo.LTE_STATUS_SUPPORTED);
-        setOnCellularServiceStateChangedWithLteVopsOn(
-                vopsSupportInfo,
-                NetworkRegistrationInfo.DOMAIN_PS,
-                NetworkRegistrationInfo.REGISTRATION_STATE_ROAMING);
-
-        assertEquals(
-                ServiceState.STATE_IN_SERVICE,
-                mQtListener.mLastQnsTelephonyInfoIms.getDataRegState());
-        assertEquals(
-                TelephonyManager.NETWORK_TYPE_LTE,
-                mQtListener.mLastQnsTelephonyInfoIms.getDataNetworkType());
-        assertEquals(
-                TelephonyManager.NETWORK_TYPE_LTE,
-                mQtListener.mLastQnsTelephonyInfoIms.getVoiceNetworkType());
-        assertEquals("00101", mQtListener.mLastQnsTelephonyInfoIms.getRegisteredPlmn());
-        assertTrue(mQtListener.mLastQnsTelephonyInfoIms.isCoverage());
-        assertTrue(mQtListener.mLastQnsTelephonyInfoIms.isCellularAvailable());
-        assertFalse(mQtListener.mLastQnsTelephonyInfoIms.getEmergencyBarring());
-        assertFalse(mQtListener.mLastQnsTelephonyInfoIms.getVoiceBarring());
-        assertTrue(mQtListener.mLastQnsTelephonyInfoIms.getVopsEmergencySupport());
-        assertTrue(mQtListener.mLastQnsTelephonyInfoIms.getVopsSupport());
-    }
-
-    @Test
-    public void testOnCellularServiceStateChangedWithNrVopsOn() {
-        VopsSupportInfo vopsSupportInfo =
-                new NrVopsSupportInfo(
-                        NR_STATUS_VOPS_3GPP_SUPPORTED,
-                        NR_STATUS_VOPS_3GPP_SUPPORTED,
-                        NR_STATUS_VOPS_3GPP_SUPPORTED);
-        validateOnCellularServiceStateChangedWithNrVopsOn(vopsSupportInfo);
-    }
-
-    @Test
-    public void testOnCellularServiceStateChangedWithLteVopsOff() {
-        testOnCellularServiceStateChangedWithLteVopsOnHome();
-
-        // Update Vops Information
-        ServiceState ss = new ServiceState();
-        VopsSupportInfo vopsSupportInfo =
-                new LteVopsSupportInfo(
-                        LteVopsSupportInfo.LTE_STATUS_NOT_SUPPORTED,
-                        LteVopsSupportInfo.LTE_STATUS_NOT_SUPPORTED);
-        NetworkRegistrationInfo nri =
-                new NetworkRegistrationInfo(
-                        NetworkRegistrationInfo.DOMAIN_PS,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        NetworkRegistrationInfo.REGISTRATION_STATE_HOME,
-                        TelephonyManager.NETWORK_TYPE_LTE,
-                        0,
-                        false,
-                        null,
-                        null,
-                        "00101",
-                        10,
-                        false,
-                        true,
-                        true,
-                        vopsSupportInfo);
-        ss.setRilVoiceRadioTechnology(ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
-        ss.addNetworkRegistrationInfo(nri);
-        ss.setVoiceRegState(ServiceState.STATE_IN_SERVICE);
-        assertTrue(mQtListener.mLastQnsTelephonyInfoIms.getVopsEmergencySupport());
-        assertTrue(mQtListener.mLastQnsTelephonyInfoIms.getVopsSupport());
-        mQtListener.mTelephonyListener.onServiceStateChanged(ss);
-
-        // Validate Vops Updated information
-        assertFalse(mQtListener.mLastQnsTelephonyInfoIms.getVopsEmergencySupport());
-        assertFalse(mQtListener.mLastQnsTelephonyInfoIms.getVopsSupport());
-    }
-
-    private void setOnCellularServiceStateChangedWithLteVopsOn(
-            VopsSupportInfo vopsSupportInfo, int domain, int coverage) {
-        ServiceState ss = new ServiceState();
-        if (coverage == NetworkRegistrationInfo.REGISTRATION_STATE_ROAMING) {
-            ss.setDataRoamingFromRegistration(true);
-        }
-        NetworkRegistrationInfo nri =
-                new NetworkRegistrationInfo(
-                        domain,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        coverage,
-                        TelephonyManager.NETWORK_TYPE_LTE,
-                        0,
-                        false,
-                        null,
-                        null,
-                        "00101",
-                        10,
-                        false,
-                        true,
-                        true,
-                        vopsSupportInfo);
-        ss.setRilVoiceRadioTechnology(ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
-        ss.addNetworkRegistrationInfo(nri);
-        ss.setVoiceRegState(ServiceState.STATE_IN_SERVICE);
-        mQtListener.mTelephonyListener.onServiceStateChanged(ss);
-        assertEquals(ss, mQtListener.mLastServiceState);
-    }
-
-    private void validateOnCellularServiceStateChangedWithNrVopsOn(
-            VopsSupportInfo vopsSupportInfo) {
-        ServiceState ss = new ServiceState();
-        NetworkRegistrationInfo nri =
-                new NetworkRegistrationInfo(
-                        NetworkRegistrationInfo.DOMAIN_PS,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        NetworkRegistrationInfo.REGISTRATION_STATE_HOME,
-                        TelephonyManager.NETWORK_TYPE_NR,
-                        0,
-                        false,
-                        null,
-                        null,
-                        "00101",
-                        10,
-                        false,
-                        true,
-                        true,
-                        vopsSupportInfo);
-        ss.setRilVoiceRadioTechnology(ServiceState.RIL_RADIO_TECHNOLOGY_NR);
-        ss.addNetworkRegistrationInfo(nri);
-        ss.setVoiceRegState(ServiceState.STATE_IN_SERVICE);
-        mQtListener.mTelephonyListener.onServiceStateChanged(ss);
-
-        assertTrue(mQtListener.mLastQnsTelephonyInfoIms.getVopsEmergencySupport());
-        assertTrue(mQtListener.mLastQnsTelephonyInfoIms.getVopsSupport());
-    }
-
-    @Test
-    public void testIsAirplaneModeEnabled() {
-        assertFalse(mQtListener.isAirplaneModeEnabled());
-
-        ServiceState ss = new ServiceState();
-        ss.setRilVoiceRadioTechnology(ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN);
-        ss.setVoiceRegState(ServiceState.STATE_POWER_OFF);
-
-        mQtListener.mTelephonyListener.onServiceStateChanged(ss);
-        assertTrue(mQtListener.isAirplaneModeEnabled());
-    }
-
-    @Test
-    public void testIsSupportVoPS() {
-        assertFalse(mQtListener.isSupportVoPS());
-        testOnCellularServiceStateChangedWithLteVopsOnHome();
-        assertTrue(mQtListener.isSupportVoPS());
-    }
-
-    @Test
-    public void testIsSupportVopsWithNullRegistrationInfo() {
-        ServiceState ss = new ServiceState();
-        ss.addNetworkRegistrationInfo(null);
-        assertFalse(mQtListener.isSupportVoPS());
-    }
-
-    @Test
-    public void testIsSupportEmergencyService() {
-        assertFalse(mQtListener.isSupportEmergencyService());
-        testOnCellularServiceStateChangedWithLteVopsOnHome();
-        assertTrue(mQtListener.isSupportEmergencyService());
-    }
-
-    /**
-     * This test covers test cases for notifyPreciseDataConnectionStateChanged() and
-     * onPreciseDataConnectionStateChanged() methods.
-     */
-    @Test
-    public void testOnPreciseDataConnectionStateChanged() {
-        List<Integer> imsCapabilities = new ArrayList<>();
-        imsCapabilities.add(NetworkCapabilities.NET_CAPABILITY_IMS);
-        lenient()
-                .when(QnsUtils.getNetCapabilitiesFromApnTypeBitmask(anyInt()))
-                .thenReturn(imsCapabilities);
-
-        PreciseDataConnectionState connectionState =
-                new PreciseDataConnectionState.Builder()
-                        .setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WWAN)
-                        .setId(1)
-                        .setState(TelephonyManager.DATA_CONNECTED)
-                        .setNetworkType(TelephonyManager.NETWORK_TYPE_LTE)
-                        .setApnSetting(
-                                new ApnSetting.Builder()
-                                        .setApnTypeBitmask(ApnSetting.TYPE_IMS)
-                                        .setApnName("ims")
-                                        .setEntryName("ims")
-                                        .build())
-                        .setLinkProperties(new LinkProperties())
-                        .setFailCause(0)
-                        .build();
-
-        mQtListener.registerPreciseDataConnectionStateChanged(
-                NetworkCapabilities.NET_CAPABILITY_XCAP, mHandler, 1, null, false);
-        mQtListener.mTelephonyListener.onPreciseDataConnectionStateChanged(connectionState);
-
-        Message msg = mTestLooper.nextMessage();
-        assertNull(msg); // connection state is for IMS, but XCAP registered. So not notified.
-
-        // update connection state for new precise data connection state change
-        connectionState =
-                new PreciseDataConnectionState.Builder()
-                        .setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WLAN)
-                        .setId(1)
-                        .setState(TelephonyManager.DATA_CONNECTED)
-                        .setNetworkType(TelephonyManager.NETWORK_TYPE_LTE)
-                        .setApnSetting(
-                                new ApnSetting.Builder()
-                                        .setApnTypeBitmask(ApnSetting.TYPE_IMS)
-                                        .setApnName("ims")
-                                        .setEntryName("ims")
-                                        .build())
-                        .setLinkProperties(new LinkProperties())
-                        .setFailCause(0)
-                        .build();
-
-        mQtListener.registerPreciseDataConnectionStateChanged(
-                NetworkCapabilities.NET_CAPABILITY_IMS, mHandler, 1, null, false);
-        mQtListener.mTelephonyListener.onPreciseDataConnectionStateChanged(connectionState);
-
-        msg = mTestLooper.nextMessage();
-        assertNotNull(msg);
-        PreciseDataConnectionState output =
-                (PreciseDataConnectionState) ((QnsAsyncResult) msg.obj).mResult;
-        assertEquals(connectionState, output);
-    }
-
-    @Test
-    public void testIsVoiceBarring() {
-        BarringInfo barringInfo = setupBarringInfo(true, false);
-        mQtListener.mTelephonyListener.onBarringInfoChanged(barringInfo);
-        assertTrue(mQtListener.isVoiceBarring());
-
-        barringInfo = setupBarringInfo(false, false);
-        mQtListener.mTelephonyListener.onBarringInfoChanged(barringInfo);
-        assertFalse(mQtListener.isVoiceBarring());
-    }
-
-    @Test
-    public void testIsEmergencyBarring() {
-        BarringInfo barringInfo = setupBarringInfo(false, true);
-        mQtListener.mTelephonyListener.onBarringInfoChanged(barringInfo);
-        assertTrue(mQtListener.isEmergencyBarring());
-
-        barringInfo = setupBarringInfo(false, false);
-        mQtListener.mTelephonyListener.onBarringInfoChanged(barringInfo);
-        assertFalse(mQtListener.isEmergencyBarring());
-    }
-
-    @Test
-    public void testOnBarringInfoChanged_Supported() {
-        mQtListener.registerQnsTelephonyInfoChanged(
-                NetworkCapabilities.NET_CAPABILITY_IMS, mHandler, 1, null, false);
-
-        BarringInfo barringInfo = setupBarringInfo(true, true);
-        mQtListener.mTelephonyListener.onBarringInfoChanged(barringInfo);
-
-        Message msg = mTestLooper.nextMessage();
-        assertNotNull(msg);
-        QnsTelephonyListener.QnsTelephonyInfoIms qtInfoIms =
-                (QnsTelephonyListener.QnsTelephonyInfoIms) ((QnsAsyncResult) msg.obj).mResult;
-        assertTrue(qtInfoIms.getVoiceBarring());
-        assertTrue(qtInfoIms.getEmergencyBarring());
-    }
-
-    @Test
-    public void testOnBarringInfoChanged_SosNotSupported() {
-        mQtListener.registerQnsTelephonyInfoChanged(
-                NetworkCapabilities.NET_CAPABILITY_IMS, mHandler, 1, null, false);
-
-        BarringInfo barringInfo = setupBarringInfo(true, false);
-        mQtListener.mTelephonyListener.onBarringInfoChanged(barringInfo);
-
-        Message msg = mTestLooper.nextMessage();
-        assertNotNull(msg);
-        QnsTelephonyListener.QnsTelephonyInfoIms qtInfoIms =
-                (QnsTelephonyListener.QnsTelephonyInfoIms) ((QnsAsyncResult) msg.obj).mResult;
-        assertTrue(qtInfoIms.getVoiceBarring());
-        assertFalse(qtInfoIms.getEmergencyBarring());
-    }
-
-    @Test
-    public void testOnBarringInfoChanged_VoiceNotSupported() {
-        mQtListener.registerQnsTelephonyInfoChanged(
-                NetworkCapabilities.NET_CAPABILITY_IMS, mHandler, 1, null, false);
-
-        BarringInfo barringInfo = setupBarringInfo(false, true);
-        mQtListener.mTelephonyListener.onBarringInfoChanged(barringInfo);
-
-        Message msg = mTestLooper.nextMessage();
-        assertNotNull(msg);
-        QnsTelephonyListener.QnsTelephonyInfoIms qtInfoIms =
-                (QnsTelephonyListener.QnsTelephonyInfoIms) ((QnsAsyncResult) msg.obj).mResult;
-        assertFalse(qtInfoIms.getVoiceBarring());
-        assertTrue(qtInfoIms.getEmergencyBarring());
-    }
-
-    private BarringInfo setupBarringInfo(boolean voiceBarring, boolean sosBarring) {
-        SparseArray<BarringInfo.BarringServiceInfo> serviceInfos = new SparseArray<>();
-        if (voiceBarring) {
-            serviceInfos.put(
-                    BarringInfo.BARRING_SERVICE_TYPE_MMTEL_VOICE,
-                    new BarringInfo.BarringServiceInfo(
-                            BarringInfo.BarringServiceInfo.BARRING_TYPE_UNCONDITIONAL,
-                            true,
-                            CONDITIONAL_BARRING_FACTOR,
-                            CONDITIONAL_BARRING_TIME));
-        } else {
-            serviceInfos.put(
-                    BarringInfo.BARRING_SERVICE_TYPE_MMTEL_VOICE,
-                    new BarringInfo.BarringServiceInfo(
-                            BarringInfo.BarringServiceInfo.BARRING_TYPE_UNCONDITIONAL,
-                            false,
-                            0,
-                            0));
-        }
-        if (sosBarring) {
-            serviceInfos.put(
-                    BarringInfo.BARRING_SERVICE_TYPE_EMERGENCY,
-                    new BarringInfo.BarringServiceInfo(
-                            BarringInfo.BarringServiceInfo.BARRING_TYPE_UNCONDITIONAL,
-                            true,
-                            CONDITIONAL_BARRING_FACTOR,
-                            CONDITIONAL_BARRING_TIME));
-
-        } else {
-            serviceInfos.put(
-                    BarringInfo.BARRING_SERVICE_TYPE_EMERGENCY,
-                    new BarringInfo.BarringServiceInfo(
-                            BarringInfo.BarringServiceInfo.BARRING_TYPE_UNCONDITIONAL,
-                            false,
-                            0,
-                            0));
-        }
-
-        return new BarringInfo(null, serviceInfos);
-    }
-
-    @Test
-    public void testOnCallStateChanged() {
-        mQtListener.registerCallStateListener(mHandler, 1, null, false);
-        int[] callStates =
-                new int[] {
-                    TelephonyManager.CALL_STATE_RINGING,
-                    TelephonyManager.CALL_STATE_IDLE,
-                    TelephonyManager.CALL_STATE_OFFHOOK
-                };
-        for (int state : callStates) {
-            mQtListener.mTelephonyListener.onCallStateChanged(state);
-            Message msg = mTestLooper.nextMessage();
-            assertNotNull(msg);
-            assertEquals(state, (int) ((QnsAsyncResult) msg.obj).mResult);
-        }
-    }
-
-    @Test
-    public void testOnSrvccStateChanged() {
-        mQtListener.registerSrvccStateListener(mHandler, 1, null);
-        int[] srvccStates =
-                new int[] {
-                    TelephonyManager.SRVCC_STATE_HANDOVER_NONE,
-                    TelephonyManager.SRVCC_STATE_HANDOVER_STARTED,
-                    TelephonyManager.SRVCC_STATE_HANDOVER_COMPLETED,
-                    TelephonyManager.SRVCC_STATE_HANDOVER_FAILED,
-                    TelephonyManager.SRVCC_STATE_HANDOVER_CANCELED
-                };
-        for (int state : srvccStates) {
-            mQtListener.mTelephonyListener.onSrvccStateChanged(state);
-            Message msg = mTestLooper.nextMessage();
-            assertNotNull(msg);
-            assertEquals(state, (int) ((QnsAsyncResult) msg.obj).mResult);
-        }
-    }
-
-    @Test
-    public void testQnsTelephonyInfo() {
-        QnsTelephonyListener.QnsTelephonyInfo qtInfo = mQtListener.new QnsTelephonyInfo();
-
-        // test default values
-        assertFalse(qtInfo.isCoverage());
-        assertEquals(TelephonyManager.NETWORK_TYPE_UNKNOWN, qtInfo.getVoiceNetworkType());
-        assertEquals(TelephonyManager.NETWORK_TYPE_UNKNOWN, qtInfo.getDataNetworkType());
-        assertFalse(qtInfo.isCellularAvailable());
-        assertEquals("", qtInfo.getRegisteredPlmn());
-        assertEquals(ServiceState.STATE_OUT_OF_SERVICE, qtInfo.getDataRegState());
-
-        // test setters
-        qtInfo.setCoverage(true);
-        assertTrue(qtInfo.isCoverage());
-
-        qtInfo.setVoiceNetworkType(TelephonyManager.NETWORK_TYPE_LTE);
-        assertEquals(TelephonyManager.NETWORK_TYPE_LTE, qtInfo.getVoiceNetworkType());
-
-        qtInfo.setDataNetworkType(TelephonyManager.NETWORK_TYPE_EDGE);
-        assertEquals(TelephonyManager.NETWORK_TYPE_EDGE, qtInfo.getDataNetworkType());
-
-        qtInfo.setCellularAvailable(true);
-        assertTrue(qtInfo.isCellularAvailable());
-
-        qtInfo.setRegisteredPlmn("405861");
-        assertEquals("405861", qtInfo.getRegisteredPlmn());
-
-        qtInfo.setDataRegState(ServiceState.STATE_IN_SERVICE);
-        assertEquals(ServiceState.STATE_IN_SERVICE, qtInfo.getDataRegState());
-    }
-
-    @Test
-    public void testQnsTelephonyInfoIms() {
-        QnsTelephonyListener.QnsTelephonyInfo qtInfo = mQtListener.new QnsTelephonyInfo();
-        QnsTelephonyListener.QnsTelephonyInfoIms qtInfoIms = mQtListener.new QnsTelephonyInfoIms();
-
-        // test defaults
-        assertFalse(qtInfoIms.getEmergencyBarring());
-        assertFalse(qtInfoIms.getVopsSupport());
-        assertFalse(qtInfoIms.getVoiceBarring());
-        assertFalse(qtInfoIms.getVopsEmergencySupport());
-
-        // test setters
-        qtInfoIms.setEmergencyBarring(true);
-        assertTrue(qtInfoIms.getEmergencyBarring());
-
-        qtInfoIms.setVoiceBarring(true);
-        assertTrue(qtInfoIms.getVoiceBarring());
-
-        qtInfoIms.setVopsSupport(true);
-        assertTrue(qtInfoIms.getVopsSupport());
-
-        qtInfoIms.setVopsEmergencySupport(true);
-        assertTrue(qtInfoIms.getVopsEmergencySupport());
-
-        // test constructor
-        qtInfoIms = mQtListener.new QnsTelephonyInfoIms(qtInfo, false, true, false, true);
-        assertTrue(qtInfoIms.getEmergencyBarring());
-        assertFalse(qtInfoIms.getVopsSupport());
-        assertFalse(qtInfoIms.getVoiceBarring());
-        assertTrue(qtInfoIms.getVopsEmergencySupport());
-    }
-
-    @Test
-    public void testOnCallStateListChanged() {
-        mQtListener.addCallStatesChangedCallback(mTestCallStateConsumer);
-        List<CallState> testCallStates = new ArrayList<>();
-        testCallStates.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_ACTIVE)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VT)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        testCallStates.add(new CallState.Builder(PreciseCallState.PRECISE_CALL_STATE_HOLDING)
-                .setImsCallType(ImsCallProfile.CALL_TYPE_VOICE)
-                .setImsCallServiceType(ImsCallProfile.SERVICE_TYPE_NORMAL).build());
-        mQtListener.mTelephonyListener.onCallStatesChanged(testCallStates);
-
-        assertEquals(2, mTestCallStateList.size());
-        int index = 0;
-        for (CallState cs : testCallStates) {
-            assertEquals(cs, mTestCallStateList.get(index));
-            index++;
-        }
-    }
-
-    @Test
-    public void testOnMediaQualityStatusChanged() {
-        mQtListener.addMediaQualityStatusCallback(mTestMediaQualityConsumer);
-        MediaQualityStatus testMediaQuality =
-                new MediaQualityStatus(
-                        "1", MediaQualityStatus.MEDIA_SESSION_TYPE_AUDIO,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        10 /*packetLossRate*/, 130 /*jitter*/, 7000 /*inactivityTime*/);
-        mQtListener.mTelephonyListener.onMediaQualityStatusChanged(testMediaQuality);
-
-        assertEquals(testMediaQuality, mTestMediaQuality);
-    }
-
-    @Test
-    public void testOnImsCallDisconnectCauseChanged() {
-        mQtListener.registerImsCallDropDisconnectCauseListener(mMockHandler, 0, null);
-        assertTrue(mQtListener.mImsCallDropDisconnectCauseListener.size() > 0);
-        verify(mMockHandler, never()).sendMessage(any());
-
-        ImsReasonInfo imsReasonInfo = new ImsReasonInfo();
-        mQtListener.onImsCallDisconnectCauseChanged(imsReasonInfo);
-        verify(mMockHandler, times(1)).sendMessage(any());
-
-        mQtListener.unregisterImsCallDropDisconnectCauseListener(mMockHandler);
-        assertEquals(0, mQtListener.mImsCallDropDisconnectCauseListener.size());
-    }
-
-    @Test
-    public void testNullTelephonyListener() {
-        mQtListener.close();
-        setReady(false);
-        Mockito.clearInvocations(mMockTelephonyManager);
-        when(mMockSubscriptionInfo.getSubscriptionId()).thenReturn(-1);
-        mQtListener = new QnsTelephonyListener(sMockContext, 0);
-        mQtListener.startTelephonyListener(-1);
-        verify(mMockTelephonyManager, never())
-                .registerTelephonyCallback(isA(Executor.class), isA(TelephonyCallback.class));
-    }
-
-    @Test
-    public void testIwlanServiceState() {
-        int iwlanServiceStateEventId = 1000;
-
-        mQtListener.registerIwlanServiceStateListener(mMockHandler, iwlanServiceStateEventId, null);
-        assertTrue(mQtListener.mIwlanServiceStateListener.size() > 0);
-        verify(mMockHandler, never()).sendMessage(any());
-
-        // Send Service State for IWLAN
-        ServiceState ss = new ServiceState();
-        NetworkRegistrationInfo nri =
-                new NetworkRegistrationInfo(
-                        NetworkRegistrationInfo.DOMAIN_PS,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        NetworkRegistrationInfo.REGISTRATION_STATE_HOME,
-                        TelephonyManager.NETWORK_TYPE_LTE,
-                        0,
-                        false,
-                        null,
-                        null,
-                        "00101",
-                        10,
-                        false,
-                        true,
-                        true,
-                        null);
-        ss.addNetworkRegistrationInfo(nri);
-        ss.setRilVoiceRadioTechnology(ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
-        ss.setVoiceRegState(ServiceState.STATE_IN_SERVICE);
-        mQtListener.onServiceStateChanged(ss);
-        assertEquals(ss, mQtListener.mLastServiceState);
-
-        verify(mMockHandler, times(1)).sendMessage(any());
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsTest.java
deleted file mode 100644
index 0dff376..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsTest.java
+++ /dev/null
@@ -1,249 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.ArgumentMatchers.anyString;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.when;
-
-import android.content.Context;
-import android.content.pm.PackageManager;
-import android.content.res.Resources;
-import android.location.Country;
-import android.location.CountryDetector;
-import android.net.ConnectivityManager;
-import android.net.wifi.WifiInfo;
-import android.net.wifi.WifiManager;
-import android.os.Handler;
-import android.os.PowerManager;
-import android.telephony.CarrierConfigManager;
-import android.telephony.SubscriptionInfo;
-import android.telephony.SubscriptionManager;
-import android.telephony.TelephonyManager;
-import android.telephony.ims.ImsManager;
-import android.telephony.ims.ImsMmTelManager;
-import android.telephony.ims.ImsRcsManager;
-import android.telephony.ims.SipDelegateManager;
-
-import androidx.test.core.app.ApplicationProvider;
-
-import org.mockito.Mock;
-
-import java.lang.reflect.Field;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-public abstract class QnsTest {
-    private static final long MAX_WAIT_TIME_MS = 10000;
-    @Mock protected static Context sMockContext;
-
-    @Mock protected TelephonyManager mMockTelephonyManager;
-    @Mock protected CarrierConfigManager mMockCarrierConfigManager;
-    @Mock protected ConnectivityManager mMockConnectivityManager;
-    @Mock protected ImsManager mMockImsManager;
-    @Mock protected SubscriptionManager mMockSubscriptionManager;
-    @Mock protected WifiManager mMockWifiManager;
-    @Mock protected CountryDetector mMockCountryDetector;
-
-    @Mock protected ImsMmTelManager mMockImsMmTelManager;
-    @Mock protected ImsRcsManager mMockImsRcsManager;
-    @Mock protected SipDelegateManager mMockSipDelegateManager;
-    @Mock protected SubscriptionInfo mMockSubscriptionInfo;
-    @Mock protected WifiInfo mMockWifiInfo;
-    @Mock protected Resources mMockResources;
-
-    // qns mocks
-    @Mock protected IwlanNetworkStatusTracker mMockIwlanNetworkStatusTracker;
-    @Mock protected WifiQualityMonitor mMockWifiQm;
-    @Mock protected CellularNetworkStatusTracker mMockCellNetStatusTracker;
-    @Mock protected CellularQualityMonitor mMockCellularQm;
-    @Mock protected PowerManager mMockPowerManager;
-    @Mock protected QnsImsManager mMockQnsImsManager;
-    @Mock protected QnsCarrierConfigManager mMockQnsConfigManager;
-    @Mock protected QnsEventDispatcher mMockQnsEventDispatcher;
-    @Mock protected QnsProvisioningListener mMockQnsProvisioningListener;
-    @Mock protected QnsTelephonyListener mMockQnsTelephonyListener;
-    @Mock protected QnsCallStatusTracker mMockQnsCallStatusTracker;
-    @Mock protected WifiBackhaulMonitor mMockWifiBm;
-    @Mock protected QnsTimer mMockQnsTimer;
-    @Mock protected QnsMetrics mMockQnsMetrics;
-
-    protected QnsComponents[] mQnsComponents = new QnsComponents[2];
-
-    private boolean mReady = false;
-    private final Object mLock = new Object();
-
-    protected void setUp() throws Exception {
-        sMockContext = spy(ApplicationProvider.getApplicationContext());
-        stubContext();
-        stubManagers();
-        stubOthers();
-        stubQnsComponents();
-        addPermissions();
-    }
-
-    private void stubQnsComponents() {
-        mQnsComponents[0] =
-                new QnsComponents(
-                        sMockContext,
-                        mMockCellNetStatusTracker,
-                        mMockCellularQm,
-                        mMockIwlanNetworkStatusTracker,
-                        mMockQnsImsManager,
-                        mMockQnsConfigManager,
-                        mMockQnsEventDispatcher,
-                        mMockQnsProvisioningListener,
-                        mMockQnsTelephonyListener,
-                        mMockQnsCallStatusTracker,
-                        mMockQnsTimer,
-                        mMockWifiBm,
-                        mMockWifiQm,
-                        mMockQnsMetrics,
-                        0);
-
-        mQnsComponents[1] =
-                new QnsComponents(
-                        sMockContext,
-                        mMockCellNetStatusTracker,
-                        mMockCellularQm,
-                        mMockIwlanNetworkStatusTracker,
-                        mMockQnsImsManager,
-                        mMockQnsConfigManager,
-                        mMockQnsEventDispatcher,
-                        mMockQnsProvisioningListener,
-                        mMockQnsTelephonyListener,
-                        mMockQnsCallStatusTracker,
-                        mMockQnsTimer,
-                        mMockWifiBm,
-                        mMockWifiQm,
-                        mMockQnsMetrics,
-                        1);
-    }
-
-    private void stubContext() {
-        when(sMockContext.getSystemService(TelephonyManager.class))
-                .thenReturn(mMockTelephonyManager);
-        when(sMockContext.getSystemService(SubscriptionManager.class))
-                .thenReturn(mMockSubscriptionManager);
-        when(sMockContext.getSystemService(CarrierConfigManager.class))
-                .thenReturn(mMockCarrierConfigManager);
-        when(sMockContext.getSystemService(ConnectivityManager.class))
-                .thenReturn(mMockConnectivityManager);
-        when(sMockContext.getSystemService(ImsManager.class)).thenReturn(mMockImsManager);
-        when(sMockContext.getSystemService(WifiManager.class)).thenReturn(mMockWifiManager);
-        when(sMockContext.getSystemService(CountryDetector.class)).thenReturn(mMockCountryDetector);
-        when(sMockContext.getSystemService(PowerManager.class)).thenReturn(mMockPowerManager);
-        when(sMockContext.getResources()).thenReturn(mMockResources);
-    }
-
-    private void stubManagers() {
-        when(mMockTelephonyManager.createForSubscriptionId(anyInt()))
-                .thenReturn(mMockTelephonyManager);
-        when(mMockTelephonyManager.getSimCarrierId()).thenReturn(0);
-        when(mMockTelephonyManager.getSimCountryIso()).thenReturn("ca");
-        when(mMockImsManager.getImsMmTelManager(anyInt())).thenReturn(mMockImsMmTelManager);
-        when(mMockImsManager.getImsRcsManager(anyInt())).thenReturn(mMockImsRcsManager);
-        when(mMockImsManager.getSipDelegateManager(anyInt())).thenReturn(mMockSipDelegateManager);
-        when(mMockSubscriptionManager.getActiveSubscriptionInfo(anyInt()))
-                .thenReturn(mMockSubscriptionInfo);
-        when(mMockSubscriptionManager.getActiveSubscriptionInfoForSimSlotIndex(anyInt()))
-                .thenReturn(mMockSubscriptionInfo);
-
-        when(mMockWifiManager.getConnectionInfo()).thenReturn(mMockWifiInfo);
-
-        when(mMockCountryDetector.detectCountry())
-                .thenReturn(new Country("US", Country.COUNTRY_SOURCE_LOCATION));
-        when(mMockPowerManager.isDeviceIdleMode()).thenReturn(false);
-    }
-
-    private void stubOthers() {
-        when(mMockWifiInfo.getRssi()).thenReturn(-65);
-    }
-
-    private void addPermissions() {
-        when(sMockContext.checkPermission(anyString(), anyInt(), anyInt()))
-                .thenReturn(PackageManager.PERMISSION_GRANTED);
-    }
-
-    protected void waitUntilReady() {
-        synchronized (mLock) {
-            if (!mReady) {
-                try {
-                    mLock.wait(MAX_WAIT_TIME_MS);
-                } catch (InterruptedException e) {
-                }
-                if (!mReady) {
-                    fail("Test is not ready!!");
-                }
-            }
-        }
-    }
-
-    /** Wait for up to 2 second for the handler message queue to clear. */
-    protected final void waitForLastHandlerAction(Handler h) {
-        CountDownLatch lock = new CountDownLatch(1);
-        // Allow the handler to start work on stuff.
-        h.postDelayed(lock::countDown, 100);
-        int timeoutCount = 0;
-        while (timeoutCount < 10) {
-            try {
-                if (lock.await(200, TimeUnit.MILLISECONDS)) {
-                    // no messages in queue, stop waiting.
-                    if (!h.hasMessagesOrCallbacks()) break;
-                    lock = new CountDownLatch(1);
-                    // Delay allowing the handler thread to start work on stuff.
-                    h.postDelayed(lock::countDown, 100);
-                }
-            } catch (InterruptedException e) {
-                // do nothing
-            }
-            timeoutCount++;
-        }
-        assertTrue("Handler was not empty before timeout elapsed", timeoutCount < 10);
-    }
-
-    protected final void waitForDelayedHandlerAction(
-            Handler h, long delayMillis, long timeoutMillis) {
-        final CountDownLatch lock = new CountDownLatch(1);
-        h.postDelayed(lock::countDown, delayMillis);
-        while (lock.getCount() > 0) {
-            try {
-                lock.await(delayMillis + timeoutMillis, TimeUnit.MILLISECONDS);
-            } catch (InterruptedException e) {
-                // do nothing
-            }
-        }
-    }
-
-    protected void setReady(boolean ready) {
-        synchronized (mLock) {
-            mReady = ready;
-            mLock.notifyAll();
-        }
-    }
-
-    protected synchronized void setObject(
-            final Class c, final String field, final Object obj, final Object newValue)
-            throws Exception {
-        Field f = c.getDeclaredField(field);
-        f.setAccessible(true);
-        f.set(obj, newValue);
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsTimerTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsTimerTest.java
deleted file mode 100644
index 50a36b5..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsTimerTest.java
+++ /dev/null
@@ -1,343 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.ArgumentMatchers.anyLong;
-import static org.mockito.ArgumentMatchers.isA;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.app.AlarmManager;
-import android.app.PendingIntent;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Message;
-import android.os.PowerManager;
-import android.os.SystemClock;
-import android.os.test.TestLooper;
-
-import androidx.test.core.app.ApplicationProvider;
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-import java.util.concurrent.CountDownLatch;
-
-@RunWith(AndroidJUnit4.class)
-public class QnsTimerTest extends QnsTest {
-
-    private static final int EVENT_QNS_TIMER_EXPIRED = 1;
-    static final String ACTION_ALARM_TIMER_EXPIRED =
-            "com.android.telephony.qns.action.ALARM_TIMER_EXPIRED";
-    static final String KEY_TIMER_ID = "key_timer_id";
-    @Mock private Context mContext;
-    @Mock private AlarmManager mAlarmManager;
-    @Mock private PowerManager mPowerManager;
-    @Mock Message mMessage;
-    private QnsTimer mQnsTimer;
-    private BroadcastReceiver mBroadcastReceiver;
-    int mTimerId;
-
-    @Before
-    public void setup() {
-        MockitoAnnotations.initMocks(this);
-        mContext = spy(ApplicationProvider.getApplicationContext());
-        when(mContext.getSystemService(AlarmManager.class)).thenReturn(mAlarmManager);
-        when(mContext.getSystemService(PowerManager.class)).thenReturn(mPowerManager);
-        mQnsTimer = new QnsTimer(mContext);
-        ArgumentCaptor<BroadcastReceiver> args = ArgumentCaptor.forClass(BroadcastReceiver.class);
-        verify(mContext).registerReceiver(args.capture(), isA(IntentFilter.class), anyInt());
-        mBroadcastReceiver = args.getValue();
-    }
-
-    @After
-    public void tearDown() {
-        mQnsTimer.close();
-    }
-
-    @Test
-    public void testRegisterTimerForScreenOff() {
-        mBroadcastReceiver.onReceive(mContext, new Intent(Intent.ACTION_SCREEN_OFF));
-        waitForDelayedHandlerAction(mQnsTimer.mHandler, 10, 200);
-
-        mTimerId = mQnsTimer.registerTimer(mMessage, 30000);
-        waitForDelayedHandlerAction(mQnsTimer.mHandler, 10, 200);
-
-        assertTrue(mQnsTimer.getTimersInfo().contains(new QnsTimer.TimerInfo(mTimerId)));
-        assertTrue(mQnsTimer.mHandler.hasMessages(EVENT_QNS_TIMER_EXPIRED));
-        verify(mAlarmManager)
-                .setExactAndAllowWhileIdle(anyInt(), anyLong(), isA(PendingIntent.class));
-    }
-
-    @Test
-    public void testRegisterTimerForScreenOn() {
-        mBroadcastReceiver.onReceive(mContext, new Intent(Intent.ACTION_SCREEN_ON));
-        waitForDelayedHandlerAction(mQnsTimer.mHandler, 10, 200);
-
-        mTimerId = mQnsTimer.registerTimer(mMessage, 80000);
-        waitForDelayedHandlerAction(mQnsTimer.mHandler, 10, 200);
-
-        assertTrue(mQnsTimer.getTimersInfo().contains(new QnsTimer.TimerInfo(mTimerId)));
-        assertTrue(mQnsTimer.mHandler.hasMessages(EVENT_QNS_TIMER_EXPIRED));
-        verify(mAlarmManager, never())
-                .setExactAndAllowWhileIdle(anyInt(), anyLong(), isA(PendingIntent.class));
-    }
-
-    @Test
-    public void testUnregisterForInvalidId() {
-        testRegisterTimerForScreenOn();
-        int timerInfoSize = mQnsTimer.getTimersInfo().size();
-        mQnsTimer.unregisterTimer(QnsConstants.INVALID_ID);
-        waitForDelayedHandlerAction(mQnsTimer.mHandler, 10, 200);
-        assertEquals(timerInfoSize, mQnsTimer.getTimersInfo().size());
-    }
-
-    @Test
-    public void testUnregisterTimerForScreenOff() {
-        testRegisterTimerForScreenOff();
-        mQnsTimer.unregisterTimer(mTimerId);
-        waitForDelayedHandlerAction(mQnsTimer.mHandler, 10, 200);
-        assertFalse(mQnsTimer.getTimersInfo().contains(new QnsTimer.TimerInfo(mTimerId)));
-        assertFalse(mQnsTimer.mHandler.hasMessages(EVENT_QNS_TIMER_EXPIRED));
-        verify(mAlarmManager).cancel(isA(PendingIntent.class));
-    }
-
-    @Test
-    public void testUnregisterTimerForScreenOn() {
-        testRegisterTimerForScreenOn();
-        mQnsTimer.unregisterTimer(mTimerId);
-        waitForDelayedHandlerAction(mQnsTimer.mHandler, 10, 200);
-        assertFalse(mQnsTimer.getTimersInfo().contains(new QnsTimer.TimerInfo(mTimerId)));
-        assertFalse(mQnsTimer.mHandler.hasMessages(EVENT_QNS_TIMER_EXPIRED));
-        verify(mAlarmManager, never()).cancel(isA(PendingIntent.class));
-    }
-
-    @Test
-    public void testUpdateTimerTypeToAlarm() {
-        testRegisterTimerForScreenOn();
-
-        mBroadcastReceiver.onReceive(mContext, new Intent(Intent.ACTION_SCREEN_OFF));
-        waitForDelayedHandlerAction(mQnsTimer.mHandler, 10, 200);
-
-        verify(mAlarmManager)
-                .setExactAndAllowWhileIdle(anyInt(), anyLong(), isA(PendingIntent.class));
-    }
-
-    @Test
-    public void testTimerExpired() {
-        mBroadcastReceiver.onReceive(mContext, new Intent(Intent.ACTION_SCREEN_OFF));
-        waitForDelayedHandlerAction(mQnsTimer.mHandler, 10, 200);
-
-        mTimerId = mQnsTimer.registerTimer(mMessage, 50);
-        waitForDelayedHandlerAction(mQnsTimer.mHandler, 10, 200);
-
-        assertTrue(mQnsTimer.getTimersInfo().contains(new QnsTimer.TimerInfo(mTimerId)));
-        assertTrue(mQnsTimer.mHandler.hasMessages(EVENT_QNS_TIMER_EXPIRED));
-        verify(mAlarmManager)
-                .setExactAndAllowWhileIdle(anyInt(), anyLong(), isA(PendingIntent.class));
-
-        waitForDelayedHandlerAction(mQnsTimer.mHandler, 40, 200);
-        mBroadcastReceiver.onReceive(mContext, new Intent(ACTION_ALARM_TIMER_EXPIRED));
-        waitForDelayedHandlerAction(mQnsTimer.mHandler, 10, 200);
-
-        verify(mMessage).sendToTarget();
-        assertFalse(mQnsTimer.mHandler.hasMessages(EVENT_QNS_TIMER_EXPIRED));
-        verify(mAlarmManager).cancel(isA(PendingIntent.class));
-    }
-
-    @Test
-    public void testMultipleTimerRegistered() {
-        mBroadcastReceiver.onReceive(mContext, new Intent(Intent.ACTION_SCREEN_OFF));
-        waitForDelayedHandlerAction(mQnsTimer.mHandler, 10, 200);
-        TestLooper testLooper = new TestLooper();
-        Handler h = new Handler(testLooper.getLooper());
-
-        mQnsTimer.registerTimer(Message.obtain(h, 4), 300);
-        mQnsTimer.registerTimer(Message.obtain(h, 3), 200);
-        mQnsTimer.registerTimer(Message.obtain(h, 1), 50);
-        mQnsTimer.registerTimer(Message.obtain(h, 1), 50);
-        mQnsTimer.registerTimer(Message.obtain(h, 2), 100);
-        mQnsTimer.registerTimer(Message.obtain(h, 2), 100);
-        waitForDelayedHandlerAction(mQnsTimer.mHandler, 320, 100);
-
-        // alarm timer should update for shortest delay and since the minimum timer value is 10
-        // secs for screen off condition, the alarm timer will not replace be replaced until new
-        // timer requested for less than 10 secs.
-        verify(mAlarmManager)
-                .setExactAndAllowWhileIdle(anyInt(), anyLong(), isA(PendingIntent.class));
-
-        // verify order of message received:
-        Message msg = testLooper.nextMessage();
-        assertEquals(1, msg.what);
-        msg = testLooper.nextMessage();
-        assertEquals(1, msg.what);
-        msg = testLooper.nextMessage();
-        assertEquals(2, msg.what);
-        msg = testLooper.nextMessage();
-        assertEquals(2, msg.what);
-        msg = testLooper.nextMessage();
-        assertEquals(3, msg.what);
-        msg = testLooper.nextMessage();
-        assertEquals(4, msg.what);
-    }
-
-    @Test
-    public void testCancelOngoingAlarm() {
-        mBroadcastReceiver.onReceive(mContext, new Intent(Intent.ACTION_SCREEN_OFF));
-        waitForDelayedHandlerAction(mQnsTimer.mHandler, 10, 200);
-        TestLooper testLooper = new TestLooper();
-        Handler h = new Handler(testLooper.getLooper());
-
-        int timerId1 = mQnsTimer.registerTimer(Message.obtain(h, 1), 61 * 1000);
-        int timerId2 = mQnsTimer.registerTimer(Message.obtain(h, 2), 1000);
-        waitForDelayedHandlerAction(mQnsTimer.mHandler, 10, 200);
-
-        assertEquals(2, mQnsTimer.getTimersInfo().size());
-        assertEquals(timerId2, mQnsTimer.getTimersInfo().peek().getTimerId());
-        assertTrue(mQnsTimer.mHandler.hasMessages(EVENT_QNS_TIMER_EXPIRED));
-        verify(mAlarmManager, times(2))
-                .setExactAndAllowWhileIdle(anyInt(), anyLong(), isA(PendingIntent.class));
-
-        mQnsTimer.unregisterTimer(timerId2);
-        waitForDelayedHandlerAction(mQnsTimer.mHandler, 10, 200);
-        assertEquals(1, mQnsTimer.getTimersInfo().size());
-        assertEquals(timerId1, mQnsTimer.getTimersInfo().peek().getTimerId());
-        assertTrue(mQnsTimer.mHandler.hasMessages(EVENT_QNS_TIMER_EXPIRED));
-
-        verify(mAlarmManager, times(3))
-                .setExactAndAllowWhileIdle(anyInt(), anyLong(), isA(PendingIntent.class));
-    }
-
-    @Test
-    public void testAlarmOnLiteIdleModeMinDelay() {
-        int setDelay = 20000;
-        when(mPowerManager.isDeviceLightIdleMode()).thenReturn(true);
-        mBroadcastReceiver.onReceive(
-                sMockContext, new Intent(PowerManager.ACTION_DEVICE_LIGHT_IDLE_MODE_CHANGED));
-        long delay = setupAlarmForDelay(setDelay);
-
-        // assume 100ms as max delay in execution
-        assertTrue(delay < 30000 && delay > 30000 - 100);
-    }
-
-    @Test
-    public void testAlarmOnLiteIdleMode() {
-        int setDelay = 40000;
-        when(mPowerManager.isDeviceLightIdleMode()).thenReturn(true);
-        mBroadcastReceiver.onReceive(
-                sMockContext, new Intent(PowerManager.ACTION_DEVICE_LIGHT_IDLE_MODE_CHANGED));
-        long delay = setupAlarmForDelay(setDelay);
-
-        // assume 100ms as max delay in execution
-        assertTrue(delay < setDelay && delay > setDelay - 100);
-    }
-
-    @Test
-    public void testAlarmOnIdleModeMinDelay() {
-        int setDelay = 50000;
-        when(mPowerManager.isDeviceIdleMode()).thenReturn(true);
-        mBroadcastReceiver.onReceive(
-                sMockContext, new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED));
-        long delay = setupAlarmForDelay(setDelay);
-
-        // assume 100ms as max delay in execution
-        assertTrue(delay < 60000 && delay > 60000 - 100);
-    }
-
-    @Test
-    public void testAlarmOnIdleMode() {
-        int setDelay = 70000;
-        when(mPowerManager.isDeviceIdleMode()).thenReturn(true);
-        mBroadcastReceiver.onReceive(
-                sMockContext, new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED));
-        long delay = setupAlarmForDelay(setDelay);
-
-        // assume 100ms as max delay in execution
-        assertTrue(delay < setDelay && delay > setDelay - 100);
-    }
-
-    private long setupAlarmForDelay(int setDelay) {
-        mQnsTimer.registerTimer(mMessage, setDelay);
-
-        waitForDelayedHandlerAction(mQnsTimer.mHandler, 10, 200);
-        ArgumentCaptor<Long> capture = ArgumentCaptor.forClass(Long.class);
-        verify(mAlarmManager)
-                .setExactAndAllowWhileIdle(anyInt(), capture.capture(), isA(PendingIntent.class));
-        return capture.getValue() - SystemClock.elapsedRealtime();
-    }
-
-    @Test
-    public void testAlarmInCallActiveState() {
-        mQnsTimer.updateCallState(QnsConstants.CALL_TYPE_VOICE);
-        int setDelay = 4000;
-        when(mPowerManager.isDeviceIdleMode()).thenReturn(true);
-        mBroadcastReceiver.onReceive(
-                sMockContext, new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED));
-        long delay = setupAlarmForDelay(setDelay);
-
-        // assume 100ms as max delay in execution
-        assertTrue(delay < setDelay && delay > setDelay - 100);
-    }
-
-    @Test
-    public void testDeviceMovesToActiveState() {
-        int setDelay = 30000;
-        CountDownLatch latch = new CountDownLatch(2);
-        HandlerThread ht = new HandlerThread("");
-        ht.start();
-        Handler tempHandler = spy(new Handler(ht.getLooper()));
-        when(mPowerManager.isDeviceLightIdleMode()).thenReturn(true, false);
-        mBroadcastReceiver.onReceive(sMockContext, new Intent(Intent.ACTION_SCREEN_OFF));
-        mBroadcastReceiver.onReceive(
-                sMockContext, new Intent(PowerManager.ACTION_DEVICE_LIGHT_IDLE_MODE_CHANGED));
-        mQnsTimer.registerTimer(mMessage, setDelay);
-        waitForDelayedHandlerAction(mQnsTimer.mHandler, 10, 200);
-        verify(mAlarmManager)
-                .setExactAndAllowWhileIdle(anyInt(), anyLong(), isA(PendingIntent.class));
-        waitForDelayedHandlerAction(mQnsTimer.mHandler, 10, 5000);
-
-        mQnsTimer.mHandler = tempHandler;
-        mBroadcastReceiver.onReceive(
-                sMockContext, new Intent(PowerManager.ACTION_DEVICE_LIGHT_IDLE_MODE_CHANGED));
-        mBroadcastReceiver.onReceive(sMockContext, new Intent(Intent.ACTION_SCREEN_ON));
-        waitForDelayedHandlerAction(mQnsTimer.mHandler, 10, 200);
-        verify(mAlarmManager).cancel(isA(PendingIntent.class));
-
-        // Handler should reset for the updated delay
-        verify(tempHandler).removeMessages(EVENT_QNS_TIMER_EXPIRED);
-        verify(tempHandler).sendEmptyMessageDelayed(anyInt(), anyLong());
-        assertTrue(mQnsTimer.mHandler.hasMessages(EVENT_QNS_TIMER_EXPIRED));
-        ht.quit();
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsUtilsTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsUtilsTest.java
deleted file mode 100644
index 7c68069..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QnsUtilsTest.java
+++ /dev/null
@@ -1,1328 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertThrows;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.when;
-
-import android.net.NetworkCapabilities;
-import android.os.PersistableBundle;
-import android.os.SystemClock;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.CarrierConfigManager;
-import android.telephony.ServiceState;
-import android.telephony.SubscriptionManager;
-import android.telephony.TelephonyManager;
-import android.telephony.data.ApnSetting;
-
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.MockitoAnnotations;
-
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-@RunWith(JUnit4.class)
-public class QnsUtilsTest extends QnsTest {
-
-    private static final String HANDOVER_POLICY_1 =
-            "source=GERAN|UTRAN|NGRAN, target=IWLAN, type=disallowed,"
-                    + " capabilities=IMS|eims|MMS|cbs|xcap";
-    private static final String HANDOVER_POLICY_2 =
-            "source=IWLAN, target=GERAN|UTRAN|EUTRAN|NGRAN, roaming=true, type=disallowed,"
-                    + " capabilities=IMS|eims|MMS|cbs|xcap";
-    private static final String FALLBACK_RULE0 = "cause=321~378|1503, time=60000, preference=cell";
-    private static final String FALLBACK_RULE1 = "cause=232|267|350~380|1503, time=90000";
-    PersistableBundle mTestBundle;
-
-    @Before
-    public void setup() throws Exception {
-        MockitoAnnotations.initMocks(this);
-        super.setUp();
-        mTestBundle = new PersistableBundle();
-        doReturn(mMockSubscriptionInfo, mMockSubscriptionInfo, null)
-                .when(mMockSubscriptionManager)
-                .getActiveSubscriptionInfoForSimSlotIndex(anyInt());
-        doReturn(2, 1).when(mMockSubscriptionInfo).getSubscriptionId();
-    }
-
-    @Test
-    public void testGetStringAccessNetworkTypes() {
-        assertEquals("[empty]", QnsUtils.getStringAccessNetworkTypes(new ArrayList<>()));
-
-        Integer[] accessNetworks =
-                new Integer[] {
-                    AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                    AccessNetworkConstants.AccessNetworkType.IWLAN,
-                    AccessNetworkConstants.AccessNetworkType.NGRAN
-                };
-        String output =
-                String.join(
-                        "|",
-                        AccessNetworkConstants.AccessNetworkType.toString(
-                                AccessNetworkConstants.AccessNetworkType.EUTRAN),
-                        AccessNetworkConstants.AccessNetworkType.toString(
-                                AccessNetworkConstants.AccessNetworkType.IWLAN),
-                        AccessNetworkConstants.AccessNetworkType.toString(
-                                AccessNetworkConstants.AccessNetworkType.NGRAN));
-        assertEquals(output, QnsUtils.getStringAccessNetworkTypes(List.of(accessNetworks)));
-
-        accessNetworks =
-                new Integer[] {
-                    AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                    AccessNetworkConstants.AccessNetworkType.NGRAN,
-                    AccessNetworkConstants.AccessNetworkType.UTRAN
-                };
-        output =
-                String.join(
-                        "|",
-                        AccessNetworkConstants.AccessNetworkType.toString(
-                                AccessNetworkConstants.AccessNetworkType.EUTRAN),
-                        AccessNetworkConstants.AccessNetworkType.toString(
-                                AccessNetworkConstants.AccessNetworkType.NGRAN),
-                        AccessNetworkConstants.AccessNetworkType.toString(
-                                AccessNetworkConstants.AccessNetworkType.UTRAN));
-        assertEquals(output, QnsUtils.getStringAccessNetworkTypes(List.of(accessNetworks)));
-    }
-
-    @Test
-    public void testGetSubId() {
-        assertEquals(2, QnsUtils.getSubId(sMockContext, 0));
-        assertEquals(1, QnsUtils.getSubId(sMockContext, 0));
-        assertEquals(
-                SubscriptionManager.INVALID_SUBSCRIPTION_ID, QnsUtils.getSubId(sMockContext, 0));
-    }
-
-    @Ignore(value = "Static implementation of SubscriptionManager")
-    public void testIsDefaultDataSubs() {
-        // default subId is always -1
-        assertFalse(QnsUtils.isDefaultDataSubs(2));
-        assertFalse(QnsUtils.isDefaultDataSubs(5));
-    }
-
-    @Test
-    public void testGetSystemElapsedRealTime() {
-        long elapsedRealTime = SystemClock.elapsedRealtime();
-        assertTrue(QnsUtils.getSystemElapsedRealTime() >= elapsedRealTime);
-        assertFalse(QnsUtils.getSystemElapsedRealTime() - elapsedRealTime > 100);
-    }
-
-    @Test
-    public void testIsCrossSimCallingEnabled() {
-        when(mMockQnsImsManager.isCrossSimCallingEnabled()).thenReturn(true, false);
-        assertTrue(QnsUtils.isCrossSimCallingEnabled(mMockQnsImsManager));
-        assertFalse(QnsUtils.isCrossSimCallingEnabled(mMockQnsImsManager));
-    }
-
-    @Test
-    public void testIsWfcEnabled_Home() {
-        when(mMockQnsImsManager.isWfcEnabledByPlatform()).thenReturn(true, false, true);
-        when(mMockQnsImsManager.isWfcEnabledByUser()).thenReturn(true, true, false, true);
-        when(mMockQnsImsManager.isWfcProvisionedOnDevice()).thenReturn(true, true, true, false);
-        assertTrue(
-                QnsUtils.isWfcEnabled(
-                        mMockQnsImsManager, mMockQnsProvisioningListener, false)); // all OK
-        assertFalse(
-                QnsUtils.isWfcEnabled(
-                        mMockQnsImsManager,
-                        mMockQnsProvisioningListener,
-                        false)); // wfc disabled by platform
-        assertFalse(
-                QnsUtils.isWfcEnabled(
-                        mMockQnsImsManager,
-                        mMockQnsProvisioningListener,
-                        false)); // wfc disabled by user
-        assertFalse(
-                QnsUtils.isWfcEnabled(
-                        mMockQnsImsManager,
-                        mMockQnsProvisioningListener,
-                        false)); // wfc provisioning false
-    }
-
-    @Test
-    public void testIsWfcEnabled_Roaming() {
-        when(mMockQnsImsManager.isWfcEnabledByPlatform()).thenReturn(true);
-        when(mMockQnsImsManager.isWfcEnabledByUser()).thenReturn(true);
-        when(mMockQnsImsManager.isWfcProvisionedOnDevice()).thenReturn(true);
-
-        when(mMockQnsImsManager.isWfcRoamingEnabledByUser()).thenReturn(true, true, false, true);
-        when(mMockQnsProvisioningListener.getLastProvisioningWfcRoamingEnabledInfo())
-                .thenReturn(true, true, false);
-        assertTrue(
-                QnsUtils.isWfcEnabled(
-                        mMockQnsImsManager, mMockQnsProvisioningListener, true)); // exception
-        assertTrue(
-                QnsUtils.isWfcEnabled(
-                        mMockQnsImsManager, mMockQnsProvisioningListener, true)); // all OK
-        assertFalse(
-                QnsUtils.isWfcEnabled(
-                        mMockQnsImsManager,
-                        mMockQnsProvisioningListener,
-                        true)); // wfc roaming disabled by user
-        assertFalse(
-                QnsUtils.isWfcEnabled(
-                        mMockQnsImsManager,
-                        mMockQnsProvisioningListener,
-                        true)); // wfc roaming provisioning is false
-    }
-
-    @Test
-    public void testGetWfcMode() {
-        when(mMockQnsImsManager.getWfcMode(true)).thenReturn(0, 1, 2);
-        when(mMockQnsImsManager.getWfcMode(false)).thenReturn(0, 1, 2);
-        assertEquals(0, QnsUtils.getWfcMode(mMockQnsImsManager, true));
-        assertEquals(1, QnsUtils.getWfcMode(mMockQnsImsManager, true));
-        assertEquals(2, QnsUtils.getWfcMode(mMockQnsImsManager, true));
-        assertEquals(0, QnsUtils.getWfcMode(mMockQnsImsManager, false));
-        assertEquals(1, QnsUtils.getWfcMode(mMockQnsImsManager, false));
-        assertEquals(2, QnsUtils.getWfcMode(mMockQnsImsManager, false));
-    }
-
-    @Test
-    public void testGetCellularAccessNetworkType() {
-        assertEquals(
-                AccessNetworkConstants.AccessNetworkType.UNKNOWN,
-                QnsUtils.getCellularAccessNetworkType(
-                        ServiceState.STATE_OUT_OF_SERVICE, TelephonyManager.NETWORK_TYPE_LTE));
-        assertEquals(
-                AccessNetworkConstants.AccessNetworkType.UNKNOWN,
-                QnsUtils.getCellularAccessNetworkType(
-                        ServiceState.STATE_EMERGENCY_ONLY, TelephonyManager.NETWORK_TYPE_LTE));
-        assertEquals(
-                AccessNetworkConstants.AccessNetworkType.UNKNOWN,
-                QnsUtils.getCellularAccessNetworkType(
-                        ServiceState.STATE_POWER_OFF, TelephonyManager.NETWORK_TYPE_LTE_CA));
-        assertEquals(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                QnsUtils.getCellularAccessNetworkType(
-                        ServiceState.STATE_IN_SERVICE, TelephonyManager.NETWORK_TYPE_LTE));
-        assertEquals(
-                AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                QnsUtils.getCellularAccessNetworkType(
-                        ServiceState.STATE_IN_SERVICE, TelephonyManager.NETWORK_TYPE_LTE_CA));
-        assertEquals(
-                AccessNetworkConstants.AccessNetworkType.GERAN,
-                QnsUtils.getCellularAccessNetworkType(
-                        ServiceState.STATE_IN_SERVICE, TelephonyManager.NETWORK_TYPE_GPRS));
-        assertEquals(
-                AccessNetworkConstants.AccessNetworkType.UTRAN,
-                QnsUtils.getCellularAccessNetworkType(
-                        ServiceState.STATE_IN_SERVICE, TelephonyManager.NETWORK_TYPE_TD_SCDMA));
-        assertEquals(
-                AccessNetworkConstants.AccessNetworkType.NGRAN,
-                QnsUtils.getCellularAccessNetworkType(
-                        ServiceState.STATE_IN_SERVICE, TelephonyManager.NETWORK_TYPE_NR));
-    }
-
-    @Test
-    public void testGetConfig() {
-        createTestBundle();
-        doReturn(mTestBundle).when(mMockCarrierConfigManager).getConfigForSubId(anyInt());
-        int[] defaultIntArray = new int[] {1, 2};
-        int[] defaultNoVopsArray = new int[] {1, 0};
-        int[] defaultWwanHystTimerIntArray = new int[] {50000, 50000, 50000};
-        int[] defaultWlanHystTimerIntArray = new int[] {50000, 50000, 50000};
-        int[] defaultNonImsWwanHystTimerIntArray = new int[] {50000, 50000};
-        int[] defaultNonImsWlanHystTimerIntArray = new int[] {50000, 50000};
-        int[] defaultWaitingTimerIntArray = new int[] {45000, 45000};
-        int[] defaultIwlanMaxHoCountAndFallback = new int[] {3, 1};
-        String defaultString = "www.test.com,3,200,32,50,20000,10000";
-        String[] defaultStringArray = new String[] {"LTE", "UMTS"};
-        String[] defaultGapOffsetStringArray =
-                new String[] {"eutran:rsrp:-5", "ngran:ssrsp:-2", "utran:rscp:-3"};
-        String[] defaultHysteresisDbLevelStringArray =
-                new String[] {"eutran:rsrp:1", "ngran:ssrsp:2", "utran:rscp:5"};
-        String[] defaultHandoverPolicyArray = new String[] {HANDOVER_POLICY_1, HANDOVER_POLICY_2};
-        String[] fallbackWwanRuleWithImsUnregistered =
-                new String[] {FALLBACK_RULE0, FALLBACK_RULE1};
-        String[] fallbackWwanRuleWithImsHoRegisterFail =
-                new String[] {FALLBACK_RULE1, FALLBACK_RULE0};
-        String[] defaultFallbackConfigInitialDataConnection =
-                new String[] {"ims:2:30000:60000:5", "mms:1:10000:5000:2"};
-
-        assertFalse(
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager.KEY_QNS_SUPPORT_WFC_DURING_AIRPLANE_MODE_BOOL));
-        assertTrue(
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_IN_CALL_HO_DECISION_WLAN_TO_WWAN_WITHOUT_VOPS_CONDITION_BOOL));
-        assertFalse(
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_QNS_ALLOW_VIDEO_OVER_IWLAN_WITH_CELLULAR_LIMITED_CASE_BOOL));
-        assertTrue(
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_QNS_ALLOW_IMS_OVER_IWLAN_CELLULAR_LIMITED_CASE_BOOL));
-        assertFalse(
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager.KEY_QNS_HO_GUARDING_BY_PREFERENCE_BOOL));
-        assertFalse(
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager.KEY_QNS_SUPPORT_SERVICE_BARRING_CHECK_BOOL));
-        assertFalse(
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_ROAM_TRANSPORT_TYPE_SELECTION_WITHOUT_SIGNAL_STRENGTH_BOOL));
-        assertFalse(
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_PREFER_CURRENT_TRANSPORT_TYPE_IN_VOICE_CALL_BOOL));
-        assertFalse(
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_QNS_ROVE_OUT_POLICY_WITH_WIFI_BAD_GUARDTIMER_CONDITIONS_BOOL));
-        assertFalse(
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_BLOCK_IWLAN_IN_INTERNATIONAL_ROAMING_WITHOUT_WWAN_BOOL));
-        assertFalse(
-                QnsUtils.getConfig(
-                        mTestBundle, null, QnsCarrierConfigManager.KEY_BLOCK_IPV6_ONLY_WIFI_BOOL));
-        assertEquals(
-                QnsConstants.SIP_DIALOG_SESSION_POLICY_FOLLOW_VOICE_CALL,
-                (int)
-                        QnsUtils.getConfig(
-                                mTestBundle,
-                                null,
-                                QnsCarrierConfigManager
-                                        .KEY_QNS_CELLULAR_SS_THRESHOLDBACKHAUL_TIMER_MS_INT));
-        assertEquals(
-                1,
-                (int)
-                        QnsUtils.getConfig(
-                                mTestBundle,
-                                null,
-                                QnsCarrierConfigManager
-                                        .KEY_QNS_CELLULAR_SS_THRESHOLDBACKHAUL_TIMER_MS_INT));
-        assertEquals(
-                1,
-                (int)
-                        QnsUtils.getConfig(
-                                mTestBundle,
-                                null,
-                                QnsCarrierConfigManager
-                                        .KEY_QNS_WIFI_RSSI_THRESHOLDBACKHAUL_TIMER_MS_INT));
-        assertEquals(
-                1,
-                (int)
-                        QnsUtils.getConfig(
-                                mTestBundle,
-                                null,
-                                QnsCarrierConfigManager.KEY_QNS_IMS_TRANSPORT_TYPE_INT));
-        assertEquals(
-                1,
-                (int)
-                        QnsUtils.getConfig(
-                                mTestBundle,
-                                null,
-                                QnsCarrierConfigManager.KEY_QNS_MMS_TRANSPORT_TYPE_INT));
-        assertArrayEquals(
-                new int[] {
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                },
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        CarrierConfigManager.ImsSs.KEY_XCAP_OVER_UT_SUPPORTED_RATS_INT_ARRAY));
-        assertEquals(
-                1,
-                (int)
-                        QnsUtils.getConfig(
-                                mTestBundle,
-                                null,
-                                QnsCarrierConfigManager.KEY_QNS_CBS_TRANSPORT_TYPE_INT));
-        assertEquals(
-                1,
-                (int)
-                        QnsUtils.getConfig(
-                                mTestBundle,
-                                null,
-                                QnsCarrierConfigManager.KEY_QNS_SOS_TRANSPORT_TYPE_INT));
-        assertEquals(
-                QnsConstants.RAT_PREFERENCE_WIFI_ONLY,
-                (int)
-                        QnsUtils.getConfig(
-                                mTestBundle,
-                                null,
-                                QnsCarrierConfigManager.KEY_QNS_SOS_RAT_PREFERENCE_INT));
-        assertEquals(
-                QnsConstants.RAT_PREFERENCE_WIFI_ONLY,
-                (int)
-                        QnsUtils.getConfig(
-                                mTestBundle,
-                                null,
-                                QnsCarrierConfigManager.KEY_QNS_MMS_RAT_PREFERENCE_INT));
-        assertEquals(
-                QnsConstants.RAT_PREFERENCE_WIFI_ONLY,
-                (int)
-                        QnsUtils.getConfig(
-                                mTestBundle,
-                                null,
-                                QnsCarrierConfigManager.KEY_QNS_XCAP_RAT_PREFERENCE_INT));
-        assertEquals(
-                QnsConstants.RAT_PREFERENCE_WIFI_ONLY,
-                (int)
-                        QnsUtils.getConfig(
-                                mTestBundle,
-                                null,
-                                QnsCarrierConfigManager.KEY_QNS_CBS_RAT_PREFERENCE_INT));
-        assertEquals(
-                QnsConstants.COVERAGE_HOME,
-                (int)
-                        QnsUtils.getConfig(
-                                mTestBundle,
-                                null,
-                                QnsCarrierConfigManager
-                                        .KEY_QNS_IMS_NETWORK_ENABLE_HO_HYSTERESIS_TIMER_INT));
-        assertEquals(
-                3000 /* test value */,
-                (int)
-                        QnsUtils.getConfig(
-                                mTestBundle,
-                                null,
-                                QnsCarrierConfigManager
-                                        .KEY_QNS_MEDIA_THRESHOLD_RTP_PACKET_LOSS_TIME_MILLIS_INT));
-        assertEquals(
-                2000 /* test value */,
-                (int)
-                        QnsUtils.getConfig(
-                                mTestBundle,
-                                null,
-                                QnsCarrierConfigManager
-                                        .KEY_MINIMUM_HANDOVER_GUARDING_TIMER_MS_INT));
-        assertArrayEquals(
-                defaultIwlanMaxHoCountAndFallback,
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager
-                              .KEY_QNS_IN_CALL_ROVEIN_ALLOWED_COUNT_AND_FALLBACK_REASON_INT_ARRAY));
-        assertArrayEquals(
-                defaultWwanHystTimerIntArray,
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager.KEY_IMS_WWAN_HYSTERESIS_TIMER_MS_INT_ARRAY));
-        assertArrayEquals(
-                defaultWlanHystTimerIntArray,
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager.KEY_IMS_WLAN_HYSTERESIS_TIMER_MS_INT_ARRAY));
-        assertArrayEquals(
-                defaultNonImsWwanHystTimerIntArray,
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager.KEY_NON_IMS_WWAN_HYSTERESIS_TIMER_MS_INT_ARRAY));
-        assertArrayEquals(
-                defaultNonImsWlanHystTimerIntArray,
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager.KEY_NON_IMS_WLAN_HYSTERESIS_TIMER_MS_INT_ARRAY));
-        assertArrayEquals(
-                defaultWaitingTimerIntArray,
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_WAITING_TIME_FOR_PREFERRED_TRANSPORT_WHEN_POWER_ON_INT_ARRAY));
-        assertArrayEquals(
-                defaultWaitingTimerIntArray,
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_QNS_HO_RESTRICT_TIME_WITH_LOW_RTP_QUALITY_MILLIS_INT_ARRAY));
-        assertArrayEquals(
-                defaultIntArray,
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager
-                              .KEY_CHOOSE_WFC_PREFERRED_TRANSPORT_IN_BOTH_BAD_CONDITION_INT_ARRAY));
-        assertArrayEquals(
-                defaultNoVopsArray,
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        CarrierConfigManager.Ims.KEY_IMS_PDN_ENABLED_IN_NO_VOPS_SUPPORT_INT_ARRAY));
-        assertEquals(
-                defaultString,
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_QNS_WLAN_RTT_BACKHAUL_CHECK_ON_ICMP_PING_STRING));
-        assertArrayEquals(
-                defaultStringArray,
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager.KEY_IMS_CELLULAR_ALLOWED_RAT_STRING_ARRAY));
-        assertArrayEquals(
-                defaultGapOffsetStringArray,
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_QNS_ROVEIN_THRESHOLD_GAP_WITH_GUARD_TIMER_STRING_ARRAY));
-        assertArrayEquals(
-                defaultHysteresisDbLevelStringArray,
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_QNS_CELLULAR_SIGNAL_STRENGTH_HYSTERESIS_DB_STRING_ARRAY));
-        assertArrayEquals(
-                defaultHandoverPolicyArray,
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        CarrierConfigManager.KEY_IWLAN_HANDOVER_POLICY_STRING_ARRAY));
-        assertArrayEquals(
-                fallbackWwanRuleWithImsUnregistered,
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_QNS_FALLBACK_WWAN_IMS_UNREGISTRATION_REASON_STRING_ARRAY));
-        assertArrayEquals(
-                fallbackWwanRuleWithImsHoRegisterFail,
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_QNS_FALLBACK_WWAN_IMS_HO_REGISTER_FAIL_REASON_STRING_ARRAY));
-        assertArrayEquals(
-                defaultFallbackConfigInitialDataConnection,
-                QnsUtils.getConfig(
-                        mTestBundle,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_QNS_FALLBACK_ON_INITIAL_CONNECTION_FAILURE_STRING_ARRAY));
-    }
-
-    private void createTestBundle() {
-        mTestBundle.putBoolean(
-                QnsCarrierConfigManager.KEY_QNS_SUPPORT_WFC_DURING_AIRPLANE_MODE_BOOL, false);
-        mTestBundle.putBoolean(
-                QnsCarrierConfigManager
-                        .KEY_IN_CALL_HO_DECISION_WLAN_TO_WWAN_WITHOUT_VOPS_CONDITION_BOOL,
-                true);
-        mTestBundle.putBoolean(
-                QnsCarrierConfigManager
-                        .KEY_QNS_ALLOW_VIDEO_OVER_IWLAN_WITH_CELLULAR_LIMITED_CASE_BOOL,
-                false);
-        mTestBundle.putBoolean(
-                QnsCarrierConfigManager.KEY_QNS_ALLOW_IMS_OVER_IWLAN_CELLULAR_LIMITED_CASE_BOOL,
-                true);
-        mTestBundle.putBoolean(
-                QnsCarrierConfigManager.KEY_QNS_HO_GUARDING_BY_PREFERENCE_BOOL, false);
-        mTestBundle.putBoolean(
-                QnsCarrierConfigManager.KEY_QNS_SUPPORT_SERVICE_BARRING_CHECK_BOOL, false);
-        mTestBundle.putBoolean(
-                QnsCarrierConfigManager
-                        .KEY_ROAM_TRANSPORT_TYPE_SELECTION_WITHOUT_SIGNAL_STRENGTH_BOOL,
-                false);
-        mTestBundle.putBoolean(
-                QnsCarrierConfigManager.KEY_PREFER_CURRENT_TRANSPORT_TYPE_IN_VOICE_CALL_BOOL,
-                false);
-        mTestBundle.putBoolean(
-                QnsCarrierConfigManager
-                        .KEY_QNS_ROVE_OUT_POLICY_WITH_WIFI_BAD_GUARDTIMER_CONDITIONS_BOOL,
-                false);
-        mTestBundle.putBoolean(
-                QnsCarrierConfigManager.KEY_BLOCK_IWLAN_IN_INTERNATIONAL_ROAMING_WITHOUT_WWAN_BOOL,
-                false);
-        mTestBundle.putBoolean(QnsCarrierConfigManager.KEY_BLOCK_IPV6_ONLY_WIFI_BOOL, false);
-        mTestBundle.putInt(
-                QnsCarrierConfigManager.KEY_SIP_DIALOG_SESSION_POLICY_INT,
-                QnsConstants.SIP_DIALOG_SESSION_POLICY_FOLLOW_VOICE_CALL);
-        mTestBundle.putInt(
-                QnsCarrierConfigManager.KEY_QNS_CELLULAR_SS_THRESHOLDBACKHAUL_TIMER_MS_INT, 1);
-        mTestBundle.putInt(
-                QnsCarrierConfigManager.KEY_QNS_WIFI_RSSI_THRESHOLDBACKHAUL_TIMER_MS_INT, 1);
-        mTestBundle.putInt(QnsCarrierConfigManager.KEY_QNS_IMS_TRANSPORT_TYPE_INT, 1);
-        mTestBundle.putInt(QnsCarrierConfigManager.KEY_QNS_MMS_TRANSPORT_TYPE_INT, 1);
-        mTestBundle.putIntArray(
-                CarrierConfigManager.ImsSs.KEY_XCAP_OVER_UT_SUPPORTED_RATS_INT_ARRAY,
-                new int[] {
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                });
-        mTestBundle.putInt(QnsCarrierConfigManager.KEY_QNS_CBS_TRANSPORT_TYPE_INT, 1);
-        mTestBundle.putInt(QnsCarrierConfigManager.KEY_QNS_SOS_TRANSPORT_TYPE_INT, 1);
-        mTestBundle.putInt(QnsCarrierConfigManager.KEY_QNS_MMS_RAT_PREFERENCE_INT, 1);
-        mTestBundle.putInt(QnsCarrierConfigManager.KEY_QNS_SOS_RAT_PREFERENCE_INT, 1);
-        mTestBundle.putInt(QnsCarrierConfigManager.KEY_QNS_XCAP_RAT_PREFERENCE_INT, 1);
-        mTestBundle.putInt(QnsCarrierConfigManager.KEY_QNS_CBS_RAT_PREFERENCE_INT, 1);
-        mTestBundle.putInt(
-                QnsCarrierConfigManager.KEY_QNS_IMS_NETWORK_ENABLE_HO_HYSTERESIS_TIMER_INT,
-                QnsConstants.COVERAGE_HOME);
-        mTestBundle.putInt(
-                QnsCarrierConfigManager.KEY_QNS_MEDIA_THRESHOLD_RTP_PACKET_LOSS_TIME_MILLIS_INT,
-                3000);
-        mTestBundle.putInt(
-                QnsCarrierConfigManager.KEY_QNS_MEDIA_THRESHOLD_RTP_PACKET_LOSS_TIME_MILLIS_INT,
-                3000);
-        mTestBundle.putInt(
-                QnsCarrierConfigManager.KEY_MINIMUM_HANDOVER_GUARDING_TIMER_MS_INT,
-                2000);
-        mTestBundle.putIntArray(
-                QnsCarrierConfigManager
-                        .KEY_QNS_IN_CALL_ROVEIN_ALLOWED_COUNT_AND_FALLBACK_REASON_INT_ARRAY,
-                new int[] {3, 1});
-        mTestBundle.putIntArray(
-                QnsCarrierConfigManager.KEY_IMS_WWAN_HYSTERESIS_TIMER_MS_INT_ARRAY,
-                new int[] {50000, 50000, 50000});
-        mTestBundle.putIntArray(
-                QnsCarrierConfigManager.KEY_IMS_WLAN_HYSTERESIS_TIMER_MS_INT_ARRAY,
-                new int[] {50000, 50000, 50000});
-        mTestBundle.putIntArray(
-                QnsCarrierConfigManager.KEY_NON_IMS_WWAN_HYSTERESIS_TIMER_MS_INT_ARRAY,
-                new int[] {50000, 50000});
-        mTestBundle.putIntArray(
-                QnsCarrierConfigManager.KEY_NON_IMS_WLAN_HYSTERESIS_TIMER_MS_INT_ARRAY,
-                new int[] {50000, 50000});
-        mTestBundle.putIntArray(
-                QnsCarrierConfigManager
-                        .KEY_WAITING_TIME_FOR_PREFERRED_TRANSPORT_WHEN_POWER_ON_INT_ARRAY,
-                new int[] {45000, 45000});
-        mTestBundle.putIntArray(
-                QnsCarrierConfigManager
-                        .KEY_QNS_HO_RESTRICT_TIME_WITH_LOW_RTP_QUALITY_MILLIS_INT_ARRAY,
-                new int[] {45000, 45000});
-        mTestBundle.putIntArray(
-                QnsCarrierConfigManager
-                        .KEY_CHOOSE_WFC_PREFERRED_TRANSPORT_IN_BOTH_BAD_CONDITION_INT_ARRAY,
-                new int[] {1, 2});
-        mTestBundle.putIntArray(
-                CarrierConfigManager.Ims.KEY_IMS_PDN_ENABLED_IN_NO_VOPS_SUPPORT_INT_ARRAY,
-                new int[] {1, 0});
-        mTestBundle.putString(
-                QnsCarrierConfigManager.KEY_QNS_WLAN_RTT_BACKHAUL_CHECK_ON_ICMP_PING_STRING,
-                "www.test.com,3,200,32,50,20000,10000");
-        mTestBundle.putStringArray(
-                QnsCarrierConfigManager.KEY_IMS_CELLULAR_ALLOWED_RAT_STRING_ARRAY,
-                new String[] {"LTE", "UMTS"});
-        mTestBundle.putStringArray(
-                QnsCarrierConfigManager.KEY_QNS_ROVEIN_THRESHOLD_GAP_WITH_GUARD_TIMER_STRING_ARRAY,
-                new String[] {"eutran:rsrp:-5", "ngran:ssrsp:-2", "utran:rscp:-3"});
-        mTestBundle.putStringArray(
-                CarrierConfigManager.KEY_IWLAN_HANDOVER_POLICY_STRING_ARRAY,
-                new String[] {HANDOVER_POLICY_1, HANDOVER_POLICY_2});
-        mTestBundle.putStringArray(
-                QnsCarrierConfigManager
-                        .KEY_QNS_FALLBACK_WWAN_IMS_UNREGISTRATION_REASON_STRING_ARRAY,
-                new String[] {FALLBACK_RULE0, FALLBACK_RULE1});
-        mTestBundle.putStringArray(
-                QnsCarrierConfigManager
-                        .KEY_QNS_FALLBACK_WWAN_IMS_HO_REGISTER_FAIL_REASON_STRING_ARRAY,
-                new String[] {FALLBACK_RULE1, FALLBACK_RULE0});
-        mTestBundle.putStringArray(
-                QnsCarrierConfigManager.KEY_QNS_FALLBACK_ON_INITIAL_CONNECTION_FAILURE_STRING_ARRAY,
-                new String[] {"ims:2:30000:60000:5", "mms:1:10000:5000:2"});
-        mTestBundle.putStringArray(
-                QnsCarrierConfigManager.KEY_QNS_CELLULAR_SIGNAL_STRENGTH_HYSTERESIS_DB_STRING_ARRAY,
-                new String[] {"eutran:rsrp:1", "ngran:ssrsp:2", "utran:rscp:5"});
-    }
-
-    @Test
-    public void testGetDefaultValueForKey() {
-        doReturn(null).when(mMockCarrierConfigManager).getConfigForSubId(anyInt());
-        doReturn(1234).when(mMockTelephonyManager).getSimCarrierId();
-        assertTrue(
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierConfigManager.KEY_QNS_SUPPORT_WFC_DURING_AIRPLANE_MODE_BOOL));
-        assertFalse(
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_IN_CALL_HO_DECISION_WLAN_TO_WWAN_WITHOUT_VOPS_CONDITION_BOOL));
-        assertFalse(
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_QNS_ALLOW_VIDEO_OVER_IWLAN_WITH_CELLULAR_LIMITED_CASE_BOOL));
-        assertFalse(
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_QNS_ALLOW_IMS_OVER_IWLAN_CELLULAR_LIMITED_CASE_BOOL));
-        assertFalse(
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierConfigManager.KEY_QNS_HO_GUARDING_BY_PREFERENCE_BOOL));
-        assertFalse(
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierConfigManager.KEY_QNS_SUPPORT_SERVICE_BARRING_CHECK_BOOL));
-        assertFalse(
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_ROAM_TRANSPORT_TYPE_SELECTION_WITHOUT_SIGNAL_STRENGTH_BOOL));
-        assertFalse(
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_PREFER_CURRENT_TRANSPORT_TYPE_IN_VOICE_CALL_BOOL));
-        assertFalse(
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_QNS_ROVE_OUT_POLICY_WITH_WIFI_BAD_GUARDTIMER_CONDITIONS_BOOL));
-        assertFalse(
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_BLOCK_IWLAN_IN_INTERNATIONAL_ROAMING_WITHOUT_WWAN_BOOL));
-        assertTrue(
-                QnsUtils.getConfig(
-                        null, null, QnsCarrierConfigManager.KEY_BLOCK_IPV6_ONLY_WIFI_BOOL));
-        assertEquals(
-                QnsConstants.SIP_DIALOG_SESSION_POLICY_NONE,
-                (int)
-                        QnsUtils.getConfig(
-                                null,
-                                null,
-                                QnsCarrierConfigManager
-                                        .KEY_SIP_DIALOG_SESSION_POLICY_INT));
-        assertEquals(
-                QnsConstants.KEY_DEFAULT_VALUE,
-                (int)
-                        QnsUtils.getConfig(
-                                null,
-                                null,
-                                QnsCarrierConfigManager
-                                        .KEY_QNS_CELLULAR_SS_THRESHOLDBACKHAUL_TIMER_MS_INT));
-        assertEquals(
-                QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER,
-                (int)
-                        QnsUtils.getConfig(
-                                null,
-                                null,
-                                QnsCarrierConfigManager
-                                        .KEY_QNS_WIFI_RSSI_THRESHOLDBACKHAUL_TIMER_MS_INT));
-        assertEquals(
-                QnsConstants.TRANSPORT_TYPE_ALLOWED_BOTH,
-                (int)
-                        QnsUtils.getConfig(
-                                null,
-                                null,
-                                QnsCarrierConfigManager.KEY_QNS_IMS_TRANSPORT_TYPE_INT));
-        assertEquals(
-                QnsConstants.TRANSPORT_TYPE_ALLOWED_WWAN,
-                (int)
-                        QnsUtils.getConfig(
-                                null,
-                                null,
-                                QnsCarrierConfigManager.KEY_QNS_MMS_TRANSPORT_TYPE_INT));
-        assertEquals(
-                QnsConstants.TRANSPORT_TYPE_ALLOWED_WWAN,
-                (int)
-                        QnsUtils.getConfig(
-                                null,
-                                null,
-                                QnsCarrierConfigManager.KEY_QNS_CBS_TRANSPORT_TYPE_INT));
-        assertEquals(
-                QnsConstants.TRANSPORT_TYPE_ALLOWED_WWAN,
-                (int)
-                        QnsUtils.getConfig(
-                                null,
-                                null,
-                                QnsCarrierConfigManager.KEY_QNS_SOS_TRANSPORT_TYPE_INT));
-        assertEquals(
-                QnsConstants.RAT_PREFERENCE_DEFAULT,
-                (int)
-                        QnsUtils.getConfig(
-                                null,
-                                null,
-                                QnsCarrierConfigManager.KEY_QNS_SOS_RAT_PREFERENCE_INT));
-        assertEquals(
-                QnsConstants.RAT_PREFERENCE_DEFAULT,
-                (int)
-                        QnsUtils.getConfig(
-                                null,
-                                null,
-                                QnsCarrierConfigManager.KEY_QNS_MMS_RAT_PREFERENCE_INT));
-        assertEquals(
-                QnsConstants.RAT_PREFERENCE_DEFAULT,
-                (int)
-                        QnsUtils.getConfig(
-                                null,
-                                null,
-                                QnsCarrierConfigManager.KEY_QNS_XCAP_RAT_PREFERENCE_INT));
-        assertEquals(
-                QnsConstants.RAT_PREFERENCE_DEFAULT,
-                (int)
-                        QnsUtils.getConfig(
-                                null,
-                                null,
-                                QnsCarrierConfigManager.KEY_QNS_CBS_RAT_PREFERENCE_INT));
-        assertEquals(
-                QnsConstants.COVERAGE_BOTH,
-                (int)
-                        QnsUtils.getConfig(
-                                null,
-                                null,
-                                QnsCarrierConfigManager
-                                        .KEY_QNS_IMS_NETWORK_ENABLE_HO_HYSTERESIS_TIMER_INT));
-        assertEquals(
-                QnsConstants.KEY_DEFAULT_PACKET_LOSS_TIME_MILLIS,
-                (int)
-                        QnsUtils.getConfig(
-                                null,
-                                null,
-                                QnsCarrierConfigManager
-                                        .KEY_QNS_MEDIA_THRESHOLD_RTP_PACKET_LOSS_TIME_MILLIS_INT));
-        assertEquals(
-                QnsConstants.CONFIG_DEFAULT_MIN_HANDOVER_GUARDING_TIMER,
-                (int)
-                        QnsUtils.getConfig(
-                                null,
-                                null,
-                                QnsCarrierConfigManager
-                                        .KEY_MINIMUM_HANDOVER_GUARDING_TIMER_MS_INT));
-        assertArrayEquals(
-                new int[] {QnsConstants.MAX_COUNT_INVALID, QnsConstants.FALLBACK_REASON_INVALID},
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierConfigManager
-                              .KEY_QNS_IN_CALL_ROVEIN_ALLOWED_COUNT_AND_FALLBACK_REASON_INT_ARRAY));
-        assertArrayEquals(
-                new int[] {
-                    QnsConstants.KEY_DEFAULT_HYST_TIMER,
-                    QnsConstants.KEY_DEFAULT_HYST_TIMER,
-                    QnsConstants.KEY_DEFAULT_HYST_TIMER
-                },
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierConfigManager.KEY_IMS_WWAN_HYSTERESIS_TIMER_MS_INT_ARRAY));
-        assertArrayEquals(
-                new int[] {
-                    QnsConstants.KEY_DEFAULT_HYST_TIMER,
-                    QnsConstants.KEY_DEFAULT_HYST_TIMER,
-                    QnsConstants.KEY_DEFAULT_HYST_TIMER
-                },
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierConfigManager.KEY_IMS_WLAN_HYSTERESIS_TIMER_MS_INT_ARRAY));
-        assertArrayEquals(
-                new int[] {QnsConstants.KEY_DEFAULT_VALUE, QnsConstants.KEY_DEFAULT_VALUE},
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierConfigManager.KEY_NON_IMS_WWAN_HYSTERESIS_TIMER_MS_INT_ARRAY));
-        assertArrayEquals(
-                new int[] {QnsConstants.KEY_DEFAULT_VALUE, QnsConstants.KEY_DEFAULT_VALUE},
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierConfigManager.KEY_NON_IMS_WLAN_HYSTERESIS_TIMER_MS_INT_ARRAY));
-        assertArrayEquals(
-                new int[] {QnsConstants.KEY_DEFAULT_VALUE, QnsConstants.KEY_DEFAULT_VALUE},
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_WAITING_TIME_FOR_PREFERRED_TRANSPORT_WHEN_POWER_ON_INT_ARRAY));
-        assertArrayEquals(
-                new int[] {
-                    QnsConstants.KEY_DEFAULT_IWLAN_AVOID_TIME_LOW_RTP_QUALITY_MILLIS,
-                    QnsConstants.KEY_DEFAULT_WWAN_AVOID_TIME_LOW_RTP_QUALITY_MILLIS
-                },
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_QNS_HO_RESTRICT_TIME_WITH_LOW_RTP_QUALITY_MILLIS_INT_ARRAY));
-        assertArrayEquals(
-                new int[] {},
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierConfigManager
-                              .KEY_CHOOSE_WFC_PREFERRED_TRANSPORT_IN_BOTH_BAD_CONDITION_INT_ARRAY));
-        assertArrayEquals(
-                new int[] {},
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        CarrierConfigManager.Ims.KEY_IMS_PDN_ENABLED_IN_NO_VOPS_SUPPORT_INT_ARRAY));
-        assertArrayEquals(
-                new int[] {
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_SSRSRP_GOOD,
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_SSRSRP_BAD,
-                        QnsCarrierConfigManager.QnsConfigArray.INVALID
-                },
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierAnspSupportConfig.KEY_IDLE_NGRAN_SSRSRP_INT_ARRAY));
-        assertArrayEquals(
-                new int[] {
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_SSRSRP_GOOD,
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_SSRSRP_BAD,
-                        QnsCarrierConfigManager.QnsConfigArray.INVALID
-                },
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierAnspSupportConfig.KEY_VOICE_NGRAN_SSRSRP_INT_ARRAY));
-        assertArrayEquals(
-                new int[] {
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_SSRSRP_GOOD,
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_SSRSRP_BAD,
-                        QnsCarrierConfigManager.QnsConfigArray.INVALID
-                },
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierAnspSupportConfig.KEY_VIDEO_NGRAN_SSRSRP_INT_ARRAY));
-        assertArrayEquals(
-                new int[] {
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_RSRP_GOOD,
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_RSRP_BAD,
-                        QnsCarrierConfigManager.QnsConfigArray.INVALID
-                },
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierAnspSupportConfig.KEY_IDLE_EUTRAN_RSRP_INT_ARRAY));
-        assertArrayEquals(
-                new int[] {
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_RSRP_GOOD,
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_RSRP_BAD,
-                        QnsCarrierConfigManager.QnsConfigArray.INVALID
-                },
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierAnspSupportConfig.KEY_VOICE_EUTRAN_RSRP_INT_ARRAY));
-        assertArrayEquals(
-                new int[] {
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_RSRP_GOOD,
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_RSRP_BAD,
-                        QnsCarrierConfigManager.QnsConfigArray.INVALID
-                },
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierAnspSupportConfig.KEY_VIDEO_EUTRAN_RSRP_INT_ARRAY));
-        assertArrayEquals(
-                new int[] {
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_RSCP_GOOD,
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_RSCP_BAD,
-                        QnsCarrierConfigManager.QnsConfigArray.INVALID
-                },
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierAnspSupportConfig.KEY_IDLE_UTRAN_RSCP_INT_ARRAY));
-        assertArrayEquals(
-                new int[] {
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_RSCP_GOOD,
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_RSCP_BAD,
-                        QnsCarrierConfigManager.QnsConfigArray.INVALID
-                },
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierAnspSupportConfig.KEY_VOICE_UTRAN_RSCP_INT_ARRAY));
-        assertArrayEquals(
-                new int[] {
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_RSCP_GOOD,
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_RSCP_BAD,
-                        QnsCarrierConfigManager.QnsConfigArray.INVALID
-                },
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierAnspSupportConfig.KEY_VIDEO_UTRAN_RSCP_INT_ARRAY));
-        assertArrayEquals(
-                new int[] {
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_GERAN_RSSI_GOOD,
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_GERAN_RSSI_BAD,
-                        QnsCarrierConfigManager.QnsConfigArray.INVALID
-                },
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierAnspSupportConfig.KEY_IDLE_GERAN_RSSI_INT_ARRAY));
-        assertArrayEquals(
-                new int[] {
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_GERAN_RSSI_GOOD,
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_GERAN_RSSI_BAD,
-                        QnsCarrierConfigManager.QnsConfigArray.INVALID
-                },
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierAnspSupportConfig.KEY_VOICE_GERAN_RSSI_INT_ARRAY));
-        assertArrayEquals(
-                new int[] {
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_GERAN_RSSI_GOOD,
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_GERAN_RSSI_BAD,
-                        QnsCarrierConfigManager.QnsConfigArray.INVALID
-                },
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierAnspSupportConfig.KEY_VIDEO_GERAN_RSSI_INT_ARRAY));
-        assertArrayEquals(
-                new int[] {
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_WIFI_RSSI_GOOD,
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_WIFI_RSSI_BAD
-                },
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierAnspSupportConfig.KEY_IDLE_WIFI_RSSI_INT_ARRAY));
-        assertArrayEquals(
-                new int[] {
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_WIFI_RSSI_GOOD,
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_WIFI_RSSI_BAD
-                },
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierAnspSupportConfig.KEY_VOICE_WIFI_RSSI_INT_ARRAY));
-        assertArrayEquals(
-                new int[] {
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_WIFI_RSSI_GOOD,
-                        QnsConstants.KEY_DEFAULT_THRESHOLD_WIFI_RSSI_BAD
-                },
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierAnspSupportConfig.KEY_VIDEO_WIFI_RSSI_INT_ARRAY));
-        assertEquals(
-                "",
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_QNS_WLAN_RTT_BACKHAUL_CHECK_ON_ICMP_PING_STRING));
-        assertArrayEquals(
-                new String[] {"LTE", "NR"},
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierConfigManager.KEY_IMS_CELLULAR_ALLOWED_RAT_STRING_ARRAY));
-        assertArrayEquals(
-                (String[]) null,
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_QNS_ROVEIN_THRESHOLD_GAP_WITH_GUARD_TIMER_STRING_ARRAY));
-        assertArrayEquals(
-                (String[]) null,
-                QnsUtils.getConfig(
-                        null, null, CarrierConfigManager.KEY_IWLAN_HANDOVER_POLICY_STRING_ARRAY));
-        assertArrayEquals(
-                new String[] {},
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_QNS_FALLBACK_ON_INITIAL_CONNECTION_FAILURE_STRING_ARRAY));
-        assertArrayEquals(
-                (String[]) null,
-                QnsUtils.getConfig(
-                        null,
-                        null,
-                        QnsCarrierConfigManager
-                                .KEY_QNS_CELLULAR_SIGNAL_STRENGTH_HYSTERESIS_DB_STRING_ARRAY));
-    }
-
-    @Test
-    public void testGetConfigCarrierId() {
-        doReturn(null).when(mMockCarrierConfigManager).getConfigForSubId(anyInt());
-        doReturn(TelephonyManager.UNKNOWN_CARRIER_ID, 1000, 1001, 1002)
-                .when(mMockTelephonyManager)
-                .getSimCarrierId();
-        assertEquals(
-                TelephonyManager.UNKNOWN_CARRIER_ID, QnsUtils.getConfigCarrierId(sMockContext, 0));
-        assertEquals(1000, QnsUtils.getConfigCarrierId(sMockContext, 1));
-        assertEquals(1001, QnsUtils.getConfigCarrierId(sMockContext, 0));
-        assertEquals(1002, QnsUtils.getConfigCarrierId(sMockContext, 0));
-    }
-
-    @Test
-    public void testIsWifiCallingAvailable() {
-        when(mMockTelephonyManager.isWifiCallingAvailable())
-                .thenReturn(false, true)
-                .thenThrow(new IllegalStateException("TestException"));
-        assertFalse(QnsUtils.isWifiCallingAvailable(sMockContext, 0));
-        assertTrue(QnsUtils.isWifiCallingAvailable(sMockContext, 0));
-        assertFalse(QnsUtils.isWifiCallingAvailable(sMockContext, 0)); // exception
-    }
-
-    @Test
-    public void testReadQnsDefaultConfigFromAssets_InvalidCarrierId() {
-        assertNull(
-                QnsUtils.readQnsDefaultConfigFromAssets(
-                        sMockContext, TelephonyManager.UNKNOWN_CARRIER_ID));
-    }
-
-    @Test
-    public void testIsValidSlotIndex() {
-        when(mMockTelephonyManager.getActiveModemCount()).thenReturn(-1, 1, 2, 3);
-        assertFalse(QnsUtils.isValidSlotIndex(sMockContext, 0));
-        assertFalse(QnsUtils.isValidSlotIndex(sMockContext, 1));
-        assertTrue(QnsUtils.isValidSlotIndex(sMockContext, 1));
-        assertTrue(QnsUtils.isValidSlotIndex(sMockContext, 2));
-    }
-
-    @Test
-    public void testGetNetworkCapabilitiesFromString() {
-        Set<Integer> capabilities = QnsUtils.getNetworkCapabilitiesFromString("MMS|XCAP");
-        assertEquals(2, capabilities.size());
-        assertTrue(capabilities.contains(NetworkCapabilities.NET_CAPABILITY_MMS));
-        assertTrue(capabilities.contains(NetworkCapabilities.NET_CAPABILITY_XCAP));
-    }
-
-    @Test
-    public void testNetworkCapabilitiesToString() {
-        Set<Integer> set = new HashSet<>();
-        set.add(NetworkCapabilities.NET_CAPABILITY_MMS);
-        set.add(NetworkCapabilities.NET_CAPABILITY_XCAP);
-        set.add(NetworkCapabilities.NET_CAPABILITY_INTERNET);
-        String capabilities = QnsUtils.networkCapabilitiesToString(set);
-        assertEquals("[MMS|XCAP|INTERNET]", capabilities);
-    }
-
-    @Test
-    public void testGetNetworkCapabilityFromString() {
-        assertEquals(
-                NetworkCapabilities.NET_CAPABILITY_INTERNET,
-                QnsUtils.getNetworkCapabilityFromString("INTERNET"));
-        assertEquals(
-                NetworkCapabilities.NET_CAPABILITY_MMS,
-                QnsUtils.getNetworkCapabilityFromString("MMS"));
-        assertEquals(
-                NetworkCapabilities.NET_CAPABILITY_SUPL,
-                QnsUtils.getNetworkCapabilityFromString("SUPL"));
-        assertEquals(
-                NetworkCapabilities.NET_CAPABILITY_DUN,
-                QnsUtils.getNetworkCapabilityFromString("DUN"));
-        assertEquals(
-                NetworkCapabilities.NET_CAPABILITY_FOTA,
-                QnsUtils.getNetworkCapabilityFromString("FOTA"));
-        assertEquals(
-                NetworkCapabilities.NET_CAPABILITY_IMS,
-                QnsUtils.getNetworkCapabilityFromString("IMS"));
-        assertEquals(
-                NetworkCapabilities.NET_CAPABILITY_CBS,
-                QnsUtils.getNetworkCapabilityFromString("CBS"));
-        assertEquals(
-                NetworkCapabilities.NET_CAPABILITY_XCAP,
-                QnsUtils.getNetworkCapabilityFromString("XCAP"));
-        assertEquals(
-                NetworkCapabilities.NET_CAPABILITY_EIMS,
-                QnsUtils.getNetworkCapabilityFromString("EIMS"));
-        assertEquals(
-                NetworkCapabilities.NET_CAPABILITY_MCX,
-                QnsUtils.getNetworkCapabilityFromString("MCX"));
-        assertEquals(
-                NetworkCapabilities.NET_CAPABILITY_VSIM,
-                QnsUtils.getNetworkCapabilityFromString("VSIM"));
-        assertEquals(
-                NetworkCapabilities.NET_CAPABILITY_BIP,
-                QnsUtils.getNetworkCapabilityFromString("BIP"));
-        assertEquals(
-                NetworkCapabilities.NET_CAPABILITY_ENTERPRISE,
-                QnsUtils.getNetworkCapabilityFromString("ENTERPRISE"));
-        assertEquals(
-                NetworkCapabilities.NET_CAPABILITY_PRIORITIZE_BANDWIDTH,
-                QnsUtils.getNetworkCapabilityFromString("PRIORITIZE_BANDWIDTH"));
-        assertEquals(
-                NetworkCapabilities.NET_CAPABILITY_PRIORITIZE_LATENCY,
-                QnsUtils.getNetworkCapabilityFromString("PRIORITIZE_LATENCY"));
-        assertEquals(-1, QnsUtils.getNetworkCapabilityFromString("FOO"));
-    }
-
-    @Test
-    public void testNetworkCapabilityToString() {
-        assertEquals(
-                "INTERNET",
-                QnsUtils.networkCapabilityToString(NetworkCapabilities.NET_CAPABILITY_INTERNET));
-        assertEquals(
-                "MMS", QnsUtils.networkCapabilityToString(NetworkCapabilities.NET_CAPABILITY_MMS));
-        assertEquals(
-                "SUPL",
-                QnsUtils.networkCapabilityToString(NetworkCapabilities.NET_CAPABILITY_SUPL));
-        assertEquals(
-                "DUN", QnsUtils.networkCapabilityToString(NetworkCapabilities.NET_CAPABILITY_DUN));
-        assertEquals(
-                "FOTA",
-                QnsUtils.networkCapabilityToString(NetworkCapabilities.NET_CAPABILITY_FOTA));
-        assertEquals(
-                "IMS", QnsUtils.networkCapabilityToString(NetworkCapabilities.NET_CAPABILITY_IMS));
-        assertEquals(
-                "CBS", QnsUtils.networkCapabilityToString(NetworkCapabilities.NET_CAPABILITY_CBS));
-        assertEquals(
-                "XCAP",
-                QnsUtils.networkCapabilityToString(NetworkCapabilities.NET_CAPABILITY_XCAP));
-        assertEquals(
-                "EIMS",
-                QnsUtils.networkCapabilityToString(NetworkCapabilities.NET_CAPABILITY_EIMS));
-        assertEquals(
-                "MCX", QnsUtils.networkCapabilityToString(NetworkCapabilities.NET_CAPABILITY_MCX));
-        assertEquals(
-                "VSIM",
-                QnsUtils.networkCapabilityToString(NetworkCapabilities.NET_CAPABILITY_VSIM));
-        assertEquals(
-                "BIP", QnsUtils.networkCapabilityToString(NetworkCapabilities.NET_CAPABILITY_BIP));
-        assertEquals(
-                "ENTERPRISE",
-                QnsUtils.networkCapabilityToString(NetworkCapabilities.NET_CAPABILITY_ENTERPRISE));
-        assertEquals(
-                "PRIORITIZE_BANDWIDTH",
-                QnsUtils.networkCapabilityToString(
-                        NetworkCapabilities.NET_CAPABILITY_PRIORITIZE_BANDWIDTH));
-        assertEquals(
-                "PRIORITIZE_LATENCY",
-                QnsUtils.networkCapabilityToString(
-                        NetworkCapabilities.NET_CAPABILITY_PRIORITIZE_LATENCY));
-        assertEquals("Unknown(-1)", QnsUtils.networkCapabilityToString(-1));
-    }
-
-    @Test
-    public void testTransitionBtwApnTypeAndNetCapability() {
-        int[] netCapabilities =
-                new int[] {
-                    NetworkCapabilities.NET_CAPABILITY_IMS,
-                    NetworkCapabilities.NET_CAPABILITY_EIMS,
-                    NetworkCapabilities.NET_CAPABILITY_MMS,
-                    NetworkCapabilities.NET_CAPABILITY_XCAP,
-                    NetworkCapabilities.NET_CAPABILITY_CBS
-                };
-        for (int netCapability : netCapabilities) {
-            int apnType = QnsUtils.getApnTypeFromNetCapability(netCapability);
-            int netCapabilityFromApnType = QnsUtils.getNetCapabilityFromApnType(apnType);
-            assertEquals(netCapability, netCapabilityFromApnType);
-        }
-
-        assertThrows(
-                IllegalArgumentException.class,
-                () ->
-                        QnsUtils.getApnTypeFromNetCapability(
-                                NetworkCapabilities.NET_CAPABILITY_INTERNET));
-        assertThrows(
-                IllegalArgumentException.class,
-                () -> QnsUtils.getNetCapabilityFromApnType(ApnSetting.TYPE_DEFAULT));
-    }
-
-    @Test
-    public void testTransitionBtwApnTypeNameAndNetCapabilityName() {
-        int[] netCapabilities =
-                new int[] {
-                    NetworkCapabilities.NET_CAPABILITY_IMS,
-                    NetworkCapabilities.NET_CAPABILITY_EIMS,
-                    NetworkCapabilities.NET_CAPABILITY_MMS,
-                    NetworkCapabilities.NET_CAPABILITY_XCAP,
-                    NetworkCapabilities.NET_CAPABILITY_CBS
-                };
-        for (int netCapability : netCapabilities) {
-            String netCapabilityName = QnsUtils.getNameOfNetCapability(netCapability);
-            int apnType = QnsUtils.getApnTypeFromNetCapability(netCapability);
-            String apnTypeName = ApnSetting.getApnTypeString(apnType);
-            int netCapabilityFromApnType = QnsUtils.getNetCapabilityFromApnType(apnType);
-            String netCapabilityNameFromApnType =
-                    QnsUtils.getNameOfNetCapability(netCapabilityFromApnType);
-            if (netCapability == NetworkCapabilities.NET_CAPABILITY_EIMS) {
-                assertEquals(netCapabilityName, "eims");
-                assertEquals(apnTypeName, "emergency");
-                assertEquals(netCapabilityName, netCapabilityNameFromApnType);
-            } else {
-                assertEquals(netCapabilityName, apnTypeName);
-                assertEquals(apnTypeName, netCapabilityNameFromApnType);
-                assertEquals(netCapabilityName, netCapabilityNameFromApnType);
-            }
-        }
-    }
-
-    @Test
-    public void testGetNetCapabilitiesFromApnTypesString() {
-        int[] netCapabilities =
-                new int[] {
-                    NetworkCapabilities.NET_CAPABILITY_IMS,
-                    NetworkCapabilities.NET_CAPABILITY_EIMS,
-                    NetworkCapabilities.NET_CAPABILITY_MMS,
-                    NetworkCapabilities.NET_CAPABILITY_XCAP,
-                    NetworkCapabilities.NET_CAPABILITY_CBS
-                };
-        String[] apnTypes = new String[] {"ims", "emergency", "mms", "xcap", "cbs"};
-
-        List<Integer> result = QnsUtils.getNetCapabilitiesFromApnTypesString(apnTypes);
-        for (int netCapability : netCapabilities) {
-            assertTrue(result.contains(netCapability));
-        }
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QualifiedNetworksServiceImplTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QualifiedNetworksServiceImplTest.java
deleted file mode 100644
index 9a1d559..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QualifiedNetworksServiceImplTest.java
+++ /dev/null
@@ -1,328 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static org.junit.Assert.*;
-import static org.mockito.ArgumentMatchers.anyBoolean;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.ArgumentMatchers.anyLong;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.net.NetworkCapabilities;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Message;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.AccessNetworkConstants.AccessNetworkType;
-import android.telephony.data.ApnSetting;
-import android.telephony.data.ThrottleStatus;
-
-import com.android.telephony.qns.QualifiedNetworksServiceImpl.QualifiedNetworksInfo;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.List;
-
-public class QualifiedNetworksServiceImplTest extends QnsTest {
-
-    private static final int TEST_QNS_CONFIGURATION_LOADED = 1;
-    private static final int TEST_QUALIFIED_NETWORKS_CHANGED = 2;
-    private static final int TEST_QNS_CONFIGURATION_CHANGED = 3;
-    private int mSlotIndex = 0;
-    @Mock private AccessNetworkEvaluator mMockAne;
-
-    HandlerThread mHandlerThread;
-    QualifiedNetworksServiceImpl mQualifiedNetworksService;
-    QualifiedNetworksServiceImpl.NetworkAvailabilityProviderImpl mProvider;
-
-    private class TestHandlerThread extends HandlerThread {
-
-        TestHandlerThread() {
-            super("");
-        }
-
-        @Override
-        protected void onLooperPrepared() {
-            super.onLooperPrepared();
-            mProvider =
-                    (QualifiedNetworksServiceImpl.NetworkAvailabilityProviderImpl)
-                            mQualifiedNetworksService.onCreateNetworkAvailabilityProvider(
-                                    mSlotIndex);
-            setReady(true);
-        }
-    }
-
-    private class TestQnsComponents extends QnsComponents {
-
-        TestQnsComponents(int slotId) {
-            super(
-                    sMockContext,
-                    mMockCellNetStatusTracker,
-                    mMockCellularQm,
-                    mMockIwlanNetworkStatusTracker,
-                    mMockQnsImsManager,
-                    mMockQnsConfigManager,
-                    mMockQnsEventDispatcher,
-                    mMockQnsProvisioningListener,
-                    mMockQnsTelephonyListener,
-                    mMockQnsCallStatusTracker,
-                    mMockQnsTimer,
-                    mMockWifiBm,
-                    mMockWifiQm,
-                    mMockQnsMetrics,
-                    slotId);
-        }
-
-        @Override
-        public synchronized void createQnsComponents(int slotId) {
-            // always use mocked components for testing.
-        }
-    }
-
-    @Before
-    public void setUp() throws Exception {
-        MockitoAnnotations.initMocks(this);
-        super.setUp();
-        when(mMockTelephonyManager.getActiveModemCount()).thenReturn(2);
-        mQualifiedNetworksService = new QualifiedNetworksServiceImpl();
-        mQualifiedNetworksService.mHandlerThread = new HandlerThread("QnsImplTest");
-        mQualifiedNetworksService.mHandlerThread.start();
-        mQualifiedNetworksService.mQnsComponents = new TestQnsComponents(mSlotIndex);
-        Field f = QualifiedNetworksServiceImpl.class.getDeclaredField("mContext");
-        f.setAccessible(true);
-        f.set(mQualifiedNetworksService, sMockContext);
-    }
-
-    @After
-    public void tearDown() {
-        if (mHandlerThread != null) {
-            mHandlerThread.quit();
-        }
-        mQualifiedNetworksService.onDestroy();
-    }
-
-    private void createNap() {
-        setReady(false);
-        mHandlerThread = new TestHandlerThread();
-        mHandlerThread.start();
-        waitUntilReady();
-    }
-
-    @Test
-    public void testNetworkAvailabilityProviderLifeCycle() {
-
-        // Valid slot
-        mSlotIndex = 0;
-        createNap();
-        assertEquals(1, mQualifiedNetworksService.mProviderMap.size());
-
-        // Closing NAP
-        mQualifiedNetworksService.mProviderMap.get(0).close();
-        waitForLastHandlerAction(mQualifiedNetworksService.mProviderMap.get(0).mConfigHandler);
-        mHandlerThread.quit();
-
-        // recreating NAP instance
-        mSlotIndex = 0;
-        mQualifiedNetworksService.mQnsComponents = new TestQnsComponents(mSlotIndex);
-        createNap();
-        waitForLastHandlerAction(mQualifiedNetworksService.mProviderMap.get(0).mConfigHandler);
-        assertEquals(1, mQualifiedNetworksService.mProviderMap.size());
-        mHandlerThread.quit();
-
-        // Invalid slot
-        mSlotIndex = 3;
-        mQualifiedNetworksService.mQnsComponents = new TestQnsComponents(mSlotIndex);
-        createNap();
-        waitForLastHandlerAction(mQualifiedNetworksService.mProviderMap.get(0).mHandler);
-        waitForLastHandlerAction(mQualifiedNetworksService.mProviderMap.get(0).mConfigHandler);
-        assertEquals(1, mQualifiedNetworksService.mProviderMap.size());
-    }
-
-    @Test
-    public void testQualifiedNetworksInfo() {
-        QualifiedNetworksInfo info =
-                new QualifiedNetworksInfo(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, new ArrayList<>());
-        assertEquals(info.getNetCapability(), NetworkCapabilities.NET_CAPABILITY_IMS);
-        assertTrue(info.getAccessNetworkTypes().isEmpty());
-        info.setAccessNetworkTypes(List.of(AccessNetworkType.EUTRAN));
-        assertEquals(List.of(AccessNetworkType.EUTRAN), info.getAccessNetworkTypes());
-        info.setNetCapability(NetworkCapabilities.NET_CAPABILITY_MMS);
-        assertEquals(NetworkCapabilities.NET_CAPABILITY_MMS, info.getNetCapability());
-    }
-
-    @Test
-    public void testAneCreation() {
-        List<Integer> supportedNetCapabilities1 = new ArrayList<>();
-        supportedNetCapabilities1.add(NetworkCapabilities.NET_CAPABILITY_IMS);
-        supportedNetCapabilities1.add(NetworkCapabilities.NET_CAPABILITY_EIMS);
-        supportedNetCapabilities1.add(NetworkCapabilities.NET_CAPABILITY_MMS);
-        supportedNetCapabilities1.add(NetworkCapabilities.NET_CAPABILITY_XCAP);
-        List<Integer> supportedNetCapabilities2 = new ArrayList<>();
-        supportedNetCapabilities2.add(NetworkCapabilities.NET_CAPABILITY_IMS);
-        supportedNetCapabilities2.add(NetworkCapabilities.NET_CAPABILITY_XCAP);
-
-        when(mMockQnsConfigManager.getQnsSupportedNetCapabilities())
-                .thenReturn(supportedNetCapabilities1)
-                .thenReturn(supportedNetCapabilities2);
-        when(mMockQnsConfigManager.getQnsSupportedTransportType(anyInt()))
-                .thenAnswer(
-                        (invocation) -> {
-                            if (NetworkCapabilities.NET_CAPABILITY_XCAP
-                                    == (int) invocation.getArgument(0)) {
-                                return QnsConstants.TRANSPORT_TYPE_ALLOWED_WWAN;
-                            }
-                            return QnsConstants.TRANSPORT_TYPE_ALLOWED_BOTH;
-                        });
-
-        createNap();
-        // registerForConfigurationLoaded is called on different thread.
-        waitForLastHandlerAction(mProvider.mConfigHandler);
-        mProvider.mConfigHandler.sendEmptyMessage(TEST_QNS_CONFIGURATION_LOADED);
-        waitForLastHandlerAction(mProvider.mConfigHandler); // ANEs take time to create.
-
-        assertEquals(3, mProvider.mEvaluators.size());
-
-        mProvider.mConfigHandler.sendEmptyMessage(TEST_QNS_CONFIGURATION_LOADED);
-        waitForLastHandlerAction(mProvider.mConfigHandler); // ANEs take time to create.
-
-        assertEquals(1, mProvider.mEvaluators.size());
-
-        mProvider.close();
-    }
-
-    @Test
-    public void testReportThrottle_Enable() {
-        long timer = 10000;
-        buildThrottle(mSlotIndex, ApnSetting.TYPE_IMS, timer);
-        verify(mMockAne)
-                .updateThrottleStatus(true, timer, AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-    }
-
-    @Test
-    public void testReportThrottle_Disable() {
-        long timer = -1;
-        buildThrottle(mSlotIndex, ApnSetting.TYPE_IMS, -1);
-        verify(mMockAne)
-                .updateThrottleStatus(false, timer, AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-    }
-
-    @Test
-    public void testReportThrottle_WrongSlot() {
-        long timer = 10000;
-        buildThrottle(1, ApnSetting.TYPE_IMS, timer);
-        verify(mMockAne, never()).updateThrottleStatus(anyBoolean(), anyLong(), anyInt());
-    }
-
-    @Test
-    public void testReportThrottle_NoAne() {
-        long timer = 10000;
-        buildThrottle(mSlotIndex, ApnSetting.TYPE_XCAP, timer);
-        verify(mMockAne, never()).updateThrottleStatus(anyBoolean(), anyLong(), anyInt());
-    }
-
-    private void buildThrottle(int slot, int apnType, long timer) {
-        ThrottleStatus.Builder builder =
-                new ThrottleStatus.Builder()
-                        .setSlotIndex(slot)
-                        .setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WLAN)
-                        .setApnType(apnType);
-        if (timer == -1) {
-            builder.setNoThrottle();
-        } else {
-            builder.setThrottleExpiryTimeMillis(timer);
-        }
-
-        createNap();
-        mProvider.mEvaluators.put(NetworkCapabilities.NET_CAPABILITY_IMS, mMockAne);
-        mProvider.reportThrottleStatusChanged(List.of(builder.build()));
-    }
-
-    @Test
-    public void testOnEmergencyDataNetworkPreferenceChangedWlan() {
-        createNap();
-        mProvider.mEvaluators.put(NetworkCapabilities.NET_CAPABILITY_EIMS, mMockAne);
-        mProvider.reportEmergencyDataNetworkPreferredTransportChanged(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        verify(mMockAne)
-                .onEmergencyPreferredTransportTypeChanged(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-    }
-
-    @Test
-    public void testOnEmergencyDataNetworkPreferenceChangedWwan() {
-        createNap();
-        mProvider.mEvaluators.put(NetworkCapabilities.NET_CAPABILITY_EIMS, mMockAne);
-        mProvider.reportEmergencyDataNetworkPreferredTransportChanged(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        verify(mMockAne)
-                .onEmergencyPreferredTransportTypeChanged(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-    }
-
-    @Test
-    public void testOnEmergencyDataNetworkPreferenceChangedWrongAne() {
-        createNap();
-        mProvider.mEvaluators.put(NetworkCapabilities.NET_CAPABILITY_IMS, mMockAne);
-        mProvider.reportEmergencyDataNetworkPreferredTransportChanged(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        verify(mMockAne, never()).onEmergencyPreferredTransportTypeChanged(anyInt());
-    }
-
-    @Test
-    public void testOnConfigurationLoaded() {
-        createNap();
-        Message.obtain(mProvider.mConfigHandler, TEST_QNS_CONFIGURATION_LOADED, null)
-                .sendToTarget();
-        waitForLastHandlerAction(mProvider.mConfigHandler);
-        ArgumentCaptor<Handler> capture = ArgumentCaptor.forClass(Handler.class);
-
-        verify(mMockQnsConfigManager)
-                .registerForConfigurationLoaded(
-                        capture.capture(), eq(TEST_QNS_CONFIGURATION_LOADED));
-
-        Handler configHandler = capture.getValue();
-        assertEquals(mProvider.mConfigHandler, configHandler);
-        configHandler.sendEmptyMessage(TEST_QNS_CONFIGURATION_CHANGED);
-        // ToDo: implementation of onConfigurationChanged()
-    }
-
-    @Test
-    public void testQnsChangedHandlerEvent() {
-        createNap();
-        QualifiedNetworksInfo info =
-                new QualifiedNetworksInfo(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, new ArrayList<>());
-        info.setAccessNetworkTypes(List.of(AccessNetworkType.EUTRAN));
-        QnsAsyncResult ar = new QnsAsyncResult(null, info, null);
-        Message.obtain(mProvider.mHandler, TEST_QUALIFIED_NETWORKS_CHANGED, ar).sendToTarget();
-        waitForLastHandlerAction(mProvider.mHandler);
-        assertEquals(info.getNetCapability(), NetworkCapabilities.NET_CAPABILITY_IMS);
-        assertEquals(List.of(AccessNetworkType.EUTRAN), info.getAccessNetworkTypes());
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QualifiedNetworksServiceTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QualifiedNetworksServiceTest.java
deleted file mode 100644
index bf06cf7..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/QualifiedNetworksServiceTest.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static org.junit.Assert.assertNotEquals;
-
-import android.util.Log;
-
-import androidx.test.filters.LargeTest;
-import androidx.test.filters.MediumTest;
-import androidx.test.filters.SmallTest;
-
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public final class QualifiedNetworksServiceTest {
-
-    private static final String TAG = QualifiedNetworksServiceTest.class.getSimpleName();
-
-    @BeforeClass
-    public static void beforeClass() {
-        Log.d(TAG, "beforeClass()");
-    }
-
-    @AfterClass
-    public static void afterClass() {
-        Log.d(TAG, "afterClass()");
-    }
-
-    @Before
-    public void before() {
-        Log.d(TAG, "before()");
-    }
-
-    @After
-    public void after() {
-        Log.d(TAG, "after()");
-    }
-
-    @Test
-    @SmallTest
-    public void testMyTest1() {
-        Log.d(TAG, "QualifiedNetworksServiceTest1()");
-        assertNotEquals("Hello", "world");
-    }
-
-    @Test
-    @MediumTest
-    public void testMyTest2() {
-        Log.d(TAG, "QualifiedNetworksServiceTest2()");
-        assertNotEquals("Hallo", "Welt");
-    }
-
-    @Test
-    @LargeTest
-    public void testMyTest3() {
-        Log.d(TAG, "QualifiedNetworksServiceTest3()");
-        assertNotEquals("Hallo", "Welt");
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/RestrictManagerTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/RestrictManagerTest.java
deleted file mode 100644
index b63a950..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/RestrictManagerTest.java
+++ /dev/null
@@ -1,2918 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static android.telephony.ims.stub.ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN;
-import static android.telephony.ims.stub.ImsRegistrationImplBase.REGISTRATION_TECH_LTE;
-
-import static com.android.dx.mockito.inline.extended.ExtendedMockito.mockitoSession;
-import static com.android.telephony.qns.DataConnectionStatusTracker.EVENT_DATA_CONNECTION_CONNECTED;
-import static com.android.telephony.qns.DataConnectionStatusTracker.EVENT_DATA_CONNECTION_DISCONNECTED;
-import static com.android.telephony.qns.DataConnectionStatusTracker.EVENT_DATA_CONNECTION_FAILED;
-import static com.android.telephony.qns.DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_FAILED;
-import static com.android.telephony.qns.DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_STARTED;
-import static com.android.telephony.qns.DataConnectionStatusTracker.EVENT_DATA_CONNECTION_HANDOVER_SUCCESS;
-import static com.android.telephony.qns.DataConnectionStatusTracker.EVENT_DATA_CONNECTION_STARTED;
-import static com.android.telephony.qns.RestrictManager.GUARDING_TIMER_HANDOVER_INIT;
-import static com.android.telephony.qns.RestrictManager.RELEASE_EVENT_CALL_END;
-import static com.android.telephony.qns.RestrictManager.RELEASE_EVENT_DISCONNECT;
-import static com.android.telephony.qns.RestrictManager.RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL;
-import static com.android.telephony.qns.RestrictManager.RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL;
-import static com.android.telephony.qns.RestrictManager.RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL;
-import static com.android.telephony.qns.RestrictManager.RESTRICT_TYPE_GUARDING;
-import static com.android.telephony.qns.RestrictManager.RESTRICT_TYPE_NON_PREFERRED_TRANSPORT;
-import static com.android.telephony.qns.RestrictManager.RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL;
-import static com.android.telephony.qns.RestrictManager.RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL;
-import static com.android.telephony.qns.RestrictManager.RESTRICT_TYPE_RTP_LOW_QUALITY;
-import static com.android.telephony.qns.RestrictManager.RESTRICT_TYPE_THROTTLING;
-import static com.android.telephony.qns.RestrictManager.sReleaseEventMap;
-
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.ArgumentMatchers.anyLong;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.ArgumentMatchers.isA;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.lenient;
-import static org.mockito.Mockito.when;
-
-import android.net.NetworkCapabilities;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Looper;
-import android.os.Message;
-import android.os.SystemClock;
-import android.os.test.TestLooper;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.TelephonyManager;
-import android.telephony.ims.ImsReasonInfo;
-import android.telephony.ims.ImsRegistrationAttributes;
-import android.telephony.ims.RegistrationManager;
-
-import com.google.android.collect.Sets;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.Mockito;
-import org.mockito.MockitoAnnotations;
-import org.mockito.MockitoSession;
-import org.mockito.stubbing.Answer;
-
-import java.util.HashMap;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-@RunWith(JUnit4.class)
-public class RestrictManagerTest extends QnsTest {
-
-    @Mock DataConnectionStatusTracker mMockDcst;
-
-    private MockitoSession mMockSession;
-    private QnsTelephonyListener mTelephonyListener;
-
-    private static final int DEFAULT_GUARDING_TIME = 30000;
-    private static final int DEFAULT_RESTRICT_NON_PREFERRED_TRANSPORT_TIME = 45000;
-    private static final int DEFAULT_RESTRICT_WITH_LOW_RTP_QUALITY_TIME = 60000;
-    private RestrictManager mRestrictManager;
-    private QnsImsManager mQnsImsManager;
-
-    protected TestLooper mTestLooper;
-    int mId = 0;
-    HashMap<Integer, Message> mMessageHashMap = new HashMap<>();
-
-    HandlerThread mHandlerThread =
-            new HandlerThread("") {
-                @Override
-                protected void onLooperPrepared() {
-                    super.onLooperPrepared();
-                    mTelephonyListener = new QnsTelephonyListener(sMockContext, 0);
-                    mQnsImsManager = new QnsImsManager(sMockContext, 0);
-                    setReady(true);
-                }
-            };
-
-    @Before
-    public void setUp() throws Exception {
-        MockitoAnnotations.initMocks(this);
-        super.setUp();
-        mMockSession = mockitoSession().mockStatic(QnsUtils.class).startMocking();
-        lenient().when(QnsUtils.getOtherTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WLAN))
-                .thenReturn(AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        lenient().when(QnsUtils.getOtherTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WWAN))
-                .thenReturn(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        lenient()
-                .when(QnsUtils.getOtherTransportType(AccessNetworkConstants.TRANSPORT_TYPE_INVALID))
-                .thenReturn(AccessNetworkConstants.TRANSPORT_TYPE_INVALID);
-        when(mMockQnsConfigManager.getWaitingTimerForPreferredTransportOnPowerOn(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN))
-                .thenReturn(0);
-        when(mMockQnsConfigManager.getWaitingTimerForPreferredTransportOnPowerOn(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN))
-                .thenReturn(0);
-        when(mMockQnsTimer.registerTimer(isA(Message.class), anyLong())).thenAnswer(
-                (Answer<Integer>) invocation -> {
-                    Message msg = (Message) invocation.getArguments()[0];
-                    long delay = (long) invocation.getArguments()[1];
-                    msg.getTarget().sendMessageDelayed(msg, delay);
-                    mMessageHashMap.put(++mId, msg);
-                    return mId;
-                });
-
-        doAnswer(invocation -> {
-            int timerId = (int) invocation.getArguments()[0];
-            Message msg = mMessageHashMap.get(timerId);
-            if (msg != null && msg.getTarget() != null) {
-                msg.getTarget().removeMessages(msg.what, msg.obj);
-            }
-            return null;
-        }).when(mMockQnsTimer).unregisterTimer(anyInt());
-
-        mTestLooper = new TestLooper();
-        mHandlerThread.start();
-
-        waitUntilReady();
-
-        mQnsComponents[0] =
-                new QnsComponents(
-                        sMockContext,
-                        mMockCellNetStatusTracker,
-                        mMockCellularQm,
-                        mMockIwlanNetworkStatusTracker,
-                        mQnsImsManager,
-                        mMockQnsConfigManager,
-                        mMockQnsEventDispatcher,
-                        mMockQnsProvisioningListener,
-                        mTelephonyListener,
-                        mMockQnsCallStatusTracker,
-                        mMockQnsTimer,
-                        mMockWifiBm,
-                        mMockWifiQm,
-                        mMockQnsMetrics,
-                        0);
-
-        mRestrictManager =
-                new RestrictManager(
-                        mQnsComponents[0],
-                        mTestLooper.getLooper(),
-                        NetworkCapabilities.NET_CAPABILITY_IMS,
-                        mMockDcst,
-                        0);
-        // To avoid failures due to Qns Event dispatcher notifications for Wfc Settings
-        mTestLooper.moveTimeForward(2000);
-        mTestLooper.dispatchAll();
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-    }
-
-    @After
-    public void tearDown() {
-        if (mHandlerThread != null) {
-            mHandlerThread.quit();
-        }
-        if (mRestrictManager != null) {
-            mRestrictManager.close();
-        }
-        if (mMockSession != null) {
-            mMockSession.finishMocking();
-            mMockSession = null;
-        }
-    }
-
-    @Test
-    public void testRequestGuardingRestrictionWithStartGuarding() {
-        validateGuardingRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        validateGuardingRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-    }
-
-    private void validateGuardingRestriction(int srcTransportType, int targetTransportType) {
-        when(mMockDcst.isActiveState()).thenReturn(true);
-        mRestrictManager.startGuarding(GUARDING_TIMER_HANDOVER_INIT, srcTransportType);
-        mTestLooper.moveTimeForward(DEFAULT_GUARDING_TIME / 2);
-        mTestLooper.dispatchAll();
-        mRestrictManager.startGuarding(GUARDING_TIMER_HANDOVER_INIT, targetTransportType);
-        assertFalse(mRestrictManager.isRestricted(srcTransportType));
-        assertTrue(mRestrictManager.isRestricted(targetTransportType));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(targetTransportType, RESTRICT_TYPE_GUARDING));
-    }
-
-    @Test
-    public void testAddRestriction() {
-        mRestrictManager.addRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_NON_PREFERRED_TRANSPORT,
-                sReleaseEventMap.get(RESTRICT_TYPE_NON_PREFERRED_TRANSPORT),
-                DEFAULT_RESTRICT_NON_PREFERRED_TRANSPORT_TIME);
-        assertTrue(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_NON_PREFERRED_TRANSPORT));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_NON_PREFERRED_TRANSPORT));
-        mTestLooper.moveTimeForward(DEFAULT_RESTRICT_NON_PREFERRED_TRANSPORT_TIME / 2);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_NON_PREFERRED_TRANSPORT));
-        mTestLooper.moveTimeForward(DEFAULT_RESTRICT_NON_PREFERRED_TRANSPORT_TIME / 2);
-        mTestLooper.dispatchAll();
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-    }
-
-    @Test
-    public void testAddRestrictionOnRestriction() {
-        mRestrictManager.addRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_NON_PREFERRED_TRANSPORT,
-                sReleaseEventMap.get(RESTRICT_TYPE_NON_PREFERRED_TRANSPORT),
-                DEFAULT_RESTRICT_NON_PREFERRED_TRANSPORT_TIME);
-        assertTrue(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_NON_PREFERRED_TRANSPORT));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_NON_PREFERRED_TRANSPORT));
-        mTestLooper.moveTimeForward(DEFAULT_RESTRICT_NON_PREFERRED_TRANSPORT_TIME / 2);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_NON_PREFERRED_TRANSPORT));
-        mRestrictManager.addRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_NON_PREFERRED_TRANSPORT,
-                sReleaseEventMap.get(RESTRICT_TYPE_NON_PREFERRED_TRANSPORT),
-                DEFAULT_RESTRICT_NON_PREFERRED_TRANSPORT_TIME);
-        mTestLooper.moveTimeForward(DEFAULT_RESTRICT_NON_PREFERRED_TRANSPORT_TIME / 2);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_NON_PREFERRED_TRANSPORT));
-        mTestLooper.moveTimeForward(DEFAULT_RESTRICT_NON_PREFERRED_TRANSPORT_TIME / 2);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_NON_PREFERRED_TRANSPORT));
-    }
-
-    @Test
-    public void testReleaseRestriction() {
-        mRestrictManager.addRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_NON_PREFERRED_TRANSPORT,
-                sReleaseEventMap.get(RESTRICT_TYPE_NON_PREFERRED_TRANSPORT),
-                DEFAULT_RESTRICT_NON_PREFERRED_TRANSPORT_TIME);
-        assertTrue(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_NON_PREFERRED_TRANSPORT));
-        mTestLooper.moveTimeForward(DEFAULT_RESTRICT_NON_PREFERRED_TRANSPORT_TIME / 2);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_NON_PREFERRED_TRANSPORT));
-        mRestrictManager.releaseRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_NON_PREFERRED_TRANSPORT);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_NON_PREFERRED_TRANSPORT));
-        mRestrictManager.addRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_NON_PREFERRED_TRANSPORT,
-                sReleaseEventMap.get(RESTRICT_TYPE_NON_PREFERRED_TRANSPORT),
-                DEFAULT_RESTRICT_NON_PREFERRED_TRANSPORT_TIME);
-        mTestLooper.moveTimeForward(DEFAULT_RESTRICT_NON_PREFERRED_TRANSPORT_TIME / 2);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_NON_PREFERRED_TRANSPORT));
-        mTestLooper.moveTimeForward(DEFAULT_RESTRICT_NON_PREFERRED_TRANSPORT_TIME / 2);
-        mTestLooper.dispatchAll();
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-    }
-
-    @Test
-    public void testProcessReleaseEvent() {
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-        mRestrictManager.addRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_RTP_LOW_QUALITY,
-                sReleaseEventMap.get(RESTRICT_TYPE_RTP_LOW_QUALITY),
-                DEFAULT_RESTRICT_WITH_LOW_RTP_QUALITY_TIME);
-        mRestrictManager.addRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                RESTRICT_TYPE_RTP_LOW_QUALITY,
-                sReleaseEventMap.get(RESTRICT_TYPE_RTP_LOW_QUALITY),
-                DEFAULT_RESTRICT_WITH_LOW_RTP_QUALITY_TIME);
-        mRestrictManager.addRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL,
-                sReleaseEventMap.get(RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL),
-                0);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        mTestLooper.moveTimeForward(DEFAULT_RESTRICT_WITH_LOW_RTP_QUALITY_TIME / 2);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        mRestrictManager.processReleaseEvent(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RELEASE_EVENT_CALL_END);
-        mRestrictManager.processReleaseEvent(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RELEASE_EVENT_CALL_END);
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-    }
-
-    @Test
-    public void testAddRestrictionWithoutReleaseTime() {
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        mRestrictManager.addRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL,
-                sReleaseEventMap.get(RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL),
-                0);
-        mTestLooper.moveTimeForward(DEFAULT_RESTRICT_WITH_LOW_RTP_QUALITY_TIME * 10);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        mRestrictManager.releaseRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL);
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-    }
-
-    @Test
-    public void testGuardingWithHandoverComplete() {
-        when(mMockQnsConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_HOME))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_VOICE))
-                .thenReturn(90000);
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_HOME);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_VOICE);
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        mTestLooper.moveTimeForward(85000);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        mTestLooper.moveTimeForward(5000);
-        mTestLooper.dispatchAll();
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-    }
-
-    @Test
-    public void testCheckExpiredTime() {
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-        long now = SystemClock.elapsedRealtime();
-        long throttleTime = now + 600000;
-        mRestrictManager.addRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                RESTRICT_TYPE_RTP_LOW_QUALITY,
-                sReleaseEventMap.get(RESTRICT_TYPE_RTP_LOW_QUALITY),
-                DEFAULT_RESTRICT_WITH_LOW_RTP_QUALITY_TIME);
-        mRestrictManager.notifyThrottling(
-                true, throttleTime, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_THROTTLING));
-        lenient().when(QnsUtils.getSystemElapsedRealTime()).thenReturn(now + 3000);
-        assertTrue(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-
-        lenient().when(QnsUtils.getSystemElapsedRealTime()).thenReturn(now + 100000);
-        assertTrue(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_THROTTLING));
-        lenient().when(QnsUtils.getSystemElapsedRealTime()).thenReturn(now + 700000);
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_THROTTLING));
-
-        mRestrictManager.addRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL,
-                sReleaseEventMap.get(RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL),
-                0);
-        mRestrictManager.notifyThrottling(
-                true, throttleTime, AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_THROTTLING));
-        lenient().when(QnsUtils.getSystemElapsedRealTime()).thenReturn(now + 3000);
-        assertTrue(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        lenient().when(QnsUtils.getSystemElapsedRealTime()).thenReturn(now + 700000);
-        assertTrue(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_THROTTLING));
-        mRestrictManager.releaseRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL);
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-    }
-
-    @Test
-    public void testWwanToWlanGuardingOnHandoverStart() {
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_STARTED,
-                        DataConnectionStatusTracker.STATE_HANDOVER,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_GUARDING));
-        assertTrue(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-        mTestLooper.moveTimeForward(15000);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_FAILED,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-    }
-
-    @Test
-    public void testWlanToWwanGuardingOnHandoverStart() {
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_STARTED,
-                        DataConnectionStatusTracker.STATE_HANDOVER,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        assertTrue(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        mTestLooper.moveTimeForward(15000);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_GUARDING));
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_FAILED,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-    }
-
-    @Test
-    public void testWlanOnLowRtpQualityEvent() {
-        when(mMockQnsConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_HOME))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.getHoRestrictedTimeOnLowRTPQuality(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN))
-                .thenReturn(30000);
-        when(mMockQnsConfigManager.getQnsMaxIwlanHoCountDuringCall()).thenReturn(1);
-        when(mMockQnsConfigManager.getQnsIwlanHoRestrictReason())
-                .thenReturn(QnsConstants.FALLBACK_REASON_RTP_ONLY);
-        QnsCarrierConfigManager.RtpMetricsConfig config =
-                new QnsCarrierConfigManager.RtpMetricsConfig(0, 0, 0, 0);
-        when(mMockQnsConfigManager.getRTPMetricsData()).thenReturn(config);
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_VOICE))
-                .thenReturn(0);
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_HOME);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_VOICE);
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        mTestLooper.moveTimeForward(1000);
-        mTestLooper.dispatchAll();
-        mRestrictManager.onLowRtpQualityEvent(
-                1 << QnsConstants.RTP_LOW_QUALITY_REASON_PACKET_LOSS);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-        mTestLooper.moveTimeForward(30000);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_IDLE);
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-    }
-
-    @Test
-    public void testWwanOnLowRtpQualityEvent() {
-        when(mMockQnsConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_HOME))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.getHoRestrictedTimeOnLowRTPQuality(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN))
-                .thenReturn(30000);
-        QnsCarrierConfigManager.RtpMetricsConfig config =
-                new QnsCarrierConfigManager.RtpMetricsConfig(0, 0, 0, 0);
-        when(mMockQnsConfigManager.getRTPMetricsData()).thenReturn(config);
-        when(mMockQnsConfigManager.getWlanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_VOICE))
-                .thenReturn(0);
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_HOME);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_VOICE);
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        mTestLooper.moveTimeForward(1000);
-        mTestLooper.dispatchAll();
-        mRestrictManager.onLowRtpQualityEvent(1 << QnsConstants.RTP_LOW_QUALITY_REASON_JITTER);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        mTestLooper.moveTimeForward(30000);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_IDLE);
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-    }
-
-    @Test
-    public void testHandoverToTransportTypeRestrictedByLowRtpQualityEvent() {
-        when(mMockQnsConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_HOME))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.getHoRestrictedTimeOnLowRTPQuality(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN))
-                .thenReturn(30000);
-        QnsCarrierConfigManager.RtpMetricsConfig config =
-                new QnsCarrierConfigManager.RtpMetricsConfig(0, 0, 0, 0);
-        when(mMockQnsConfigManager.getRTPMetricsData()).thenReturn(config);
-        when(mMockQnsConfigManager.getWlanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_VOICE))
-                .thenReturn(0);
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_HOME);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_VOICE);
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        mTestLooper.moveTimeForward(1000);
-        mTestLooper.dispatchAll();
-        mRestrictManager.onLowRtpQualityEvent(
-                1 << QnsConstants.RTP_LOW_QUALITY_REASON_NO_RTP);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        mTestLooper.moveTimeForward(10000);
-        mTestLooper.dispatchAll();
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        mTestLooper.moveTimeForward(1000);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-    }
-
-    @Test
-    public void testLowRtpQualityEventOnBothTransport() {
-        when(mMockQnsConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_HOME))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.getHoRestrictedTimeOnLowRTPQuality(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN))
-                .thenReturn(30000);
-        when(mMockQnsConfigManager.getHoRestrictedTimeOnLowRTPQuality(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN))
-                .thenReturn(30000);
-        when(mMockQnsConfigManager.getQnsMaxIwlanHoCountDuringCall()).thenReturn(1);
-        when(mMockQnsConfigManager.getQnsIwlanHoRestrictReason())
-                .thenReturn(QnsConstants.FALLBACK_REASON_RTP_ONLY);
-        QnsCarrierConfigManager.RtpMetricsConfig config =
-                new QnsCarrierConfigManager.RtpMetricsConfig(0, 0, 0, 0);
-        when(mMockQnsConfigManager.getRTPMetricsData()).thenReturn(config);
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(
-                NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_VOICE))
-                .thenReturn(0);
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_HOME);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_VOICE);
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        mTestLooper.moveTimeForward(1000);
-        mTestLooper.dispatchAll();
-        mRestrictManager.onLowRtpQualityEvent(
-                1 << QnsConstants.RTP_LOW_QUALITY_REASON_JITTER);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        mRestrictManager.onLowRtpQualityEvent(
-                1 << QnsConstants.RTP_LOW_QUALITY_REASON_PACKET_LOSS);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        mTestLooper.moveTimeForward(30000);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_IDLE);
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-    }
-
-    @Test
-    public void testLowRtpQualityWorseThanPreviousTransportType() {
-        when(mMockQnsConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_HOME))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.getHoRestrictedTimeOnLowRTPQuality(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN))
-                .thenReturn(30000);
-        when(mMockQnsConfigManager.getHoRestrictedTimeOnLowRTPQuality(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN))
-                .thenReturn(30000);
-        when(mMockQnsConfigManager.getQnsMaxIwlanHoCountDuringCall()).thenReturn(10);
-        when(mMockQnsConfigManager.getQnsIwlanHoRestrictReason())
-                .thenReturn(QnsConstants.FALLBACK_REASON_RTP_ONLY);
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(
-                NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_VOICE))
-                .thenReturn(0);
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_HOME);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_VOICE);
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        mTestLooper.moveTimeForward(1000);
-        mTestLooper.dispatchAll();
-        mRestrictManager.onLowRtpQualityEvent(
-                (1 << QnsConstants.RTP_LOW_QUALITY_REASON_PACKET_LOSS)
-                        + (1 << QnsConstants.RTP_LOW_QUALITY_REASON_JITTER));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        mRestrictManager.onLowRtpQualityEvent(
-                1 << QnsConstants.RTP_LOW_QUALITY_REASON_NO_RTP);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        mTestLooper.moveTimeForward(30000);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_IDLE);
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-    }
-
-    @Test
-    public void testWwanOnLowRtpQualityReleaseRestriction() {
-        when(mMockQnsConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_HOME))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.getHoRestrictedTimeOnLowRTPQuality(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN))
-                .thenReturn(30000);
-        QnsCarrierConfigManager.RtpMetricsConfig config =
-                new QnsCarrierConfigManager.RtpMetricsConfig(0, 0, 0, 0);
-        when(mMockQnsConfigManager.getRTPMetricsData()).thenReturn(config);
-        when(mMockQnsConfigManager.getWlanHysteresisTimer(
-                NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_VOICE))
-                .thenReturn(0);
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_HOME);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_VOICE);
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        mTestLooper.moveTimeForward(1000);
-        mTestLooper.dispatchAll();
-        mRestrictManager.onLowRtpQualityEvent(1 << QnsConstants.RTP_LOW_QUALITY_REASON_JITTER);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        mTestLooper.moveTimeForward(10000);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        mRestrictManager.onLowRtpQualityEvent(0);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_IDLE);
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-    }
-
-    @Test
-    public void testRestrictWithThrottling() {
-        long throttleTime = SystemClock.elapsedRealtime() + 12000;
-        when(mMockQnsConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_HOME))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_VOICE))
-                .thenReturn(90000);
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_HOME);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_VOICE);
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        mRestrictManager.notifyThrottling(
-                true, throttleTime, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_THROTTLING));
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_DISCONNECTED,
-                        DataConnectionStatusTracker.STATE_INACTIVE,
-                        AccessNetworkConstants.TRANSPORT_TYPE_INVALID);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_THROTTLING));
-        mTestLooper.moveTimeForward(13000);
-        mTestLooper.dispatchAll();
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-    }
-
-    @Test
-    public void testRestrictWithThrottlingForRetryTimerAsZero() {
-        long throttleTime = SystemClock.elapsedRealtime();
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        mRestrictManager.notifyThrottling(
-                true, throttleTime, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_THROTTLING));
-    }
-
-    @Test
-    public void testRestrictWithThrottlingWithThrottleTimeMax() {
-        long throttleTime = Long.MAX_VALUE;
-        mRestrictManager.notifyThrottling(
-                true, throttleTime, AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_THROTTLING));
-        long elapsed = SystemClock.elapsedRealtime();
-        mTestLooper.moveTimeForward(Long.MAX_VALUE - elapsed);
-        mTestLooper.dispatchAll();
-        mTestLooper.moveTimeForward(Long.MAX_VALUE - elapsed);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_THROTTLING));
-        mRestrictManager.releaseRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_THROTTLING);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_THROTTLING));
-
-        throttleTime = Integer.MAX_VALUE;
-        mRestrictManager.notifyThrottling(
-                true, throttleTime, AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_THROTTLING));
-        elapsed = SystemClock.elapsedRealtime();
-        mTestLooper.moveTimeForward(Long.MAX_VALUE - elapsed);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_THROTTLING));
-        mRestrictManager.releaseRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_THROTTLING);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_THROTTLING));
-    }
-
-    @Test
-    public void testRestrictWithThrottlingWithAbnormalThrottleTime() {
-        long throttleTime = -134243;
-        mRestrictManager.notifyThrottling(
-                true, throttleTime, AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_THROTTLING));
-
-        throttleTime = Long.MAX_VALUE - 100;
-        mRestrictManager.notifyThrottling(
-                true, throttleTime, AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_THROTTLING));
-        long elapsed = SystemClock.elapsedRealtime();
-        mTestLooper.moveTimeForward(Long.MAX_VALUE - elapsed * 2);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_THROTTLING));
-        mTestLooper.moveTimeForward(elapsed + 1000);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_THROTTLING));
-    }
-
-    @Test
-    public void testDeferThrottlingDuringActiveState() {
-        long throttleTime = SystemClock.elapsedRealtime() + 10000;
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_CONNECTED,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        when(mMockDcst.isActiveState()).thenReturn(true);
-        mRestrictManager.notifyThrottling(
-                true, throttleTime, AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_THROTTLING));
-        mTestLooper.moveTimeForward(11000);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_THROTTLING));
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_DISCONNECTED,
-                        DataConnectionStatusTracker.STATE_INACTIVE,
-                        AccessNetworkConstants.TRANSPORT_TYPE_INVALID);
-        when(mMockDcst.isActiveState()).thenReturn(false);
-        long currentTime = SystemClock.elapsedRealtime() + 11000;
-        lenient().when(QnsUtils.getSystemElapsedRealTime()).thenReturn(currentTime);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_THROTTLING));
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_CONNECTED,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        when(mMockDcst.isActiveState()).thenReturn(true);
-        throttleTime = SystemClock.elapsedRealtime() + 60000;
-        mRestrictManager.notifyThrottling(
-                true, throttleTime, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_THROTTLING));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_THROTTLING));
-        mTestLooper.moveTimeForward(11000);
-        mTestLooper.dispatchAll();
-        mRestrictManager.notifyThrottling(false, 0, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mTestLooper.moveTimeForward(5000);
-        mTestLooper.dispatchAll();
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_DISCONNECTED,
-                        DataConnectionStatusTracker.STATE_INACTIVE,
-                        AccessNetworkConstants.TRANSPORT_TYPE_INVALID);
-        when(mMockDcst.isActiveState()).thenReturn(false);
-        currentTime = SystemClock.elapsedRealtime() + 16000;
-        lenient().when(QnsUtils.getSystemElapsedRealTime()).thenReturn(currentTime);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_THROTTLING));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_THROTTLING));
-    }
-
-    @Test
-    public void testProcessDeferredThrottlingAtDisconnected() {
-        long throttleTime = SystemClock.elapsedRealtime() + 60000;
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_CONNECTED,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        when(mMockDcst.isActiveState()).thenReturn(true);
-        mRestrictManager.notifyThrottling(
-                true, throttleTime, AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_THROTTLING));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_THROTTLING));
-        mTestLooper.moveTimeForward(10000);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_THROTTLING));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_THROTTLING));
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_DISCONNECTED,
-                        DataConnectionStatusTracker.STATE_INACTIVE,
-                        AccessNetworkConstants.TRANSPORT_TYPE_INVALID);
-        when(mMockDcst.isActiveState()).thenReturn(false);
-        long currentTime = SystemClock.elapsedRealtime() + 10000;
-        lenient().when(QnsUtils.getSystemElapsedRealTime()).thenReturn(currentTime);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_THROTTLING));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_THROTTLING));
-        mTestLooper.moveTimeForward(45000);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_THROTTLING));
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_THROTTLING));
-        mTestLooper.moveTimeForward(10000);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_THROTTLING));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_THROTTLING));
-    }
-
-    @Test
-    public void testAllowRestrictionOnSingleNetwork() {
-        mRestrictManager.addRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL,
-                sReleaseEventMap.get(RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL),
-                0);
-        mRestrictManager.addRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_RTP_LOW_QUALITY,
-                sReleaseEventMap.get(RESTRICT_TYPE_RTP_LOW_QUALITY),
-                DEFAULT_RESTRICT_WITH_LOW_RTP_QUALITY_TIME);
-        mRestrictManager.addRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                RESTRICT_TYPE_RTP_LOW_QUALITY,
-                sReleaseEventMap.get(RESTRICT_TYPE_RTP_LOW_QUALITY),
-                DEFAULT_RESTRICT_WITH_LOW_RTP_QUALITY_TIME);
-        mRestrictManager.addRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                RESTRICT_TYPE_GUARDING,
-                sReleaseEventMap.get(RESTRICT_TYPE_GUARDING),
-                DEFAULT_GUARDING_TIME);
-        mRestrictManager.addRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL,
-                sReleaseEventMap.get(RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL),
-                600000);
-        mRestrictManager.addRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL,
-                sReleaseEventMap.get(RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL),
-                600000);
-        mRestrictManager.addRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL,
-                sReleaseEventMap.get(RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL),
-                600000);
-        assertTrue(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-        assertTrue(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        assertTrue(
-                mRestrictManager.isAllowedOnSingleTransport(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        assertFalse(
-                mRestrictManager.isAllowedOnSingleTransport(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-        mTestLooper.moveTimeForward(DEFAULT_RESTRICT_WITH_LOW_RTP_QUALITY_TIME);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_IN_CALL));
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_IDLE);
-        mRestrictManager.notifyThrottling(false, 0, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.processReleaseEvent(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RELEASE_EVENT_DISCONNECT);
-        mRestrictManager.releaseRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL);
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        assertFalse(mRestrictManager.isRestricted(AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-    }
-
-    @Test
-    public void testRestrictNonPreferredTransport() {
-        mRestrictManager.addRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_NON_PREFERRED_TRANSPORT,
-                sReleaseEventMap.get(RESTRICT_TYPE_NON_PREFERRED_TRANSPORT),
-                45000);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_NON_PREFERRED_TRANSPORT));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_NON_PREFERRED_TRANSPORT));
-        assertFalse(
-                mRestrictManager.isAllowedOnSingleTransport(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_CONNECTED,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_NON_PREFERRED_TRANSPORT));
-    }
-
-    @Test
-    public void testRestrictIwlanCsCall() {
-        when(mMockQnsConfigManager.allowImsOverIwlanCellularLimitedCase()).thenReturn(false);
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_DISCONNECTED,
-                        DataConnectionStatusTracker.STATE_INACTIVE,
-                        AccessNetworkConstants.TRANSPORT_TYPE_INVALID);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        mRestrictManager.setCellularAccessNetwork(AccessNetworkConstants.AccessNetworkType.UTRAN);
-        mTelephonyListener.onCallStateChanged(TelephonyManager.CALL_STATE_OFFHOOK);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL));
-        mTelephonyListener.onCallStateChanged(TelephonyManager.CALL_STATE_IDLE);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL));
-    }
-
-    @Test
-    public void testSrvccHandoverCompleted() {
-        when(mMockQnsConfigManager.allowImsOverIwlanCellularLimitedCase()).thenReturn(false);
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_CONNECTED,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        mRestrictManager.setCellularAccessNetwork(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_VOICE);
-        mTelephonyListener.onCallStateChanged(TelephonyManager.CALL_STATE_OFFHOOK);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL));
-        mTelephonyListener.onSrvccStateChanged(TelephonyManager.SRVCC_STATE_HANDOVER_STARTED);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL));
-        mTelephonyListener.onSrvccStateChanged(TelephonyManager.SRVCC_STATE_HANDOVER_COMPLETED);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL));
-        mTelephonyListener.onCallStateChanged(TelephonyManager.CALL_STATE_IDLE);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL));
-    }
-
-    @Test
-    public void testSrvccHandoverFailed() {
-        when(mMockQnsConfigManager.allowImsOverIwlanCellularLimitedCase()).thenReturn(false);
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_CONNECTED,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        mRestrictManager.setCellularAccessNetwork(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_VOICE);
-        mTelephonyListener.onCallStateChanged(TelephonyManager.CALL_STATE_OFFHOOK);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL));
-        mTelephonyListener.onSrvccStateChanged(TelephonyManager.SRVCC_STATE_HANDOVER_STARTED);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL));
-        mTelephonyListener.onSrvccStateChanged(TelephonyManager.SRVCC_STATE_HANDOVER_FAILED);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL));
-        mTelephonyListener.onSrvccStateChanged(TelephonyManager.SRVCC_STATE_HANDOVER_STARTED);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL));
-        mTelephonyListener.onCallStateChanged(TelephonyManager.CALL_STATE_IDLE);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL));
-        mTelephonyListener.onSrvccStateChanged(TelephonyManager.SRVCC_STATE_HANDOVER_COMPLETED);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_RESTRICT_IWLAN_CS_CALL));
-    }
-
-    private void triggerMmTelCallback_onRegistered(QnsImsManager qnsImsMgr, int transportType) {
-        RegistrationManager.RegistrationCallback mmtelImsRegistrationCallback =
-                qnsImsMgr.mMmtelImsRegistrationCallback;
-        @ImsRegistrationAttributes.ImsAttributeFlag int imsAttributeFlags = 0;
-        ImsRegistrationAttributes attributes;
-        if (transportType == AccessNetworkConstants.TRANSPORT_TYPE_WLAN) {
-            attributes =
-                    new ImsRegistrationAttributes(
-                            REGISTRATION_TECH_IWLAN,
-                            AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                            imsAttributeFlags,
-                            Sets.newArraySet());
-        } else {
-            attributes =
-                    new ImsRegistrationAttributes(
-                            REGISTRATION_TECH_LTE,
-                            AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                            imsAttributeFlags,
-                            Sets.newArraySet());
-        }
-        mmtelImsRegistrationCallback.onRegistered(attributes);
-    }
-
-    private void triggerMmTelCallback_onUnregistered(
-            QnsImsManager qnsImsMgr, ImsReasonInfo reason) {
-        RegistrationManager.RegistrationCallback mmtelImsRegistrationCallback =
-                qnsImsMgr.mMmtelImsRegistrationCallback;
-        mmtelImsRegistrationCallback.onUnregistered(reason);
-    }
-
-    private void triggerMmTelCallback_onTechnologyChangeFailed(
-            QnsImsManager qnsImsMgr, int transportType, ImsReasonInfo reason) {
-        RegistrationManager.RegistrationCallback mmtelImsRegistrationCallback =
-                qnsImsMgr.mMmtelImsRegistrationCallback;
-        mmtelImsRegistrationCallback.onTechnologyChangeFailed(transportType, reason);
-    }
-
-    @Test
-    public void testImsRegistrationUnregistered() {
-        when(mMockQnsConfigManager.allowImsOverIwlanCellularLimitedCase()).thenReturn(false);
-        when(mMockQnsConfigManager.isAccessNetworkAllowed(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.isAccessNetworkAllowed(
-                        AccessNetworkConstants.AccessNetworkType.UTRAN,
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(false);
-        when(mMockQnsConfigManager.getFallbackTimeImsUnregistered(
-                        eq(ImsReasonInfo.CODE_SIP_BUSY), anyInt()))
-                .thenReturn(60000);
-        mRestrictManager.setCellularAccessNetwork(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_CONNECTED,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        triggerMmTelCallback_onRegistered(
-                mQnsImsManager, AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL));
-        ImsReasonInfo reason = new ImsReasonInfo();
-        reason.mCode = ImsReasonInfo.CODE_SIP_BUSY;
-        triggerMmTelCallback_onUnregistered(mQnsImsManager, reason);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL));
-        mTestLooper.moveTimeForward(55000);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL));
-        mRestrictManager.setCellularAccessNetwork(AccessNetworkConstants.AccessNetworkType.UTRAN);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL));
-    }
-
-    @Test
-    public void testImsHoRegisterFailed() {
-        when(mMockQnsConfigManager.isAccessNetworkAllowed(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.isAccessNetworkAllowed(
-                        AccessNetworkConstants.AccessNetworkType.UTRAN,
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(false);
-        when(mMockQnsConfigManager.getFallbackTimeImsHoRegisterFailed(
-                        eq(ImsReasonInfo.CODE_SIP_TEMPRARILY_UNAVAILABLE), anyInt()))
-                .thenReturn(30000);
-        mRestrictManager.setCellularAccessNetwork(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_CONNECTED,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL));
-        ImsReasonInfo reason = new ImsReasonInfo();
-        reason.mCode = ImsReasonInfo.CODE_SIP_TEMPRARILY_UNAVAILABLE;
-        triggerMmTelCallback_onTechnologyChangeFailed(
-                mQnsImsManager, AccessNetworkConstants.TRANSPORT_TYPE_WLAN, reason);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL));
-        mTestLooper.moveTimeForward(25000);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL));
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_DISCONNECTED,
-                        DataConnectionStatusTracker.STATE_INACTIVE,
-                        AccessNetworkConstants.TRANSPORT_TYPE_INVALID);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL));
-    }
-
-    @Test
-    public void testReleasePdnFallbackToWwanOnImsRegOnWlanRegistered() {
-        long throttleTime = SystemClock.elapsedRealtime() + 12000;
-        when(mMockQnsConfigManager.allowImsOverIwlanCellularLimitedCase()).thenReturn(false);
-        when(mMockQnsConfigManager.isAccessNetworkAllowed(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.getFallbackTimeImsUnregistered(
-                        eq(ImsReasonInfo.CODE_SIP_BUSY), anyInt()))
-                .thenReturn(60000);
-        mRestrictManager.setCellularAccessNetwork(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        mRestrictManager.notifyThrottling(
-                true, throttleTime, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_THROTTLING));
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_CONNECTED,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        triggerMmTelCallback_onRegistered(
-                mQnsImsManager, AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL));
-        ImsReasonInfo reason = new ImsReasonInfo();
-        reason.mCode = ImsReasonInfo.CODE_SIP_BUSY;
-        triggerMmTelCallback_onUnregistered(mQnsImsManager, reason);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL));
-        triggerMmTelCallback_onRegistered(
-                mQnsImsManager, AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_IMS_REGI_FAIL));
-    }
-
-    @Test
-    public void testHandoverHystOfVoiceGreaterThanIdleState() {
-        when(mMockQnsConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_HOME))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_IDLE))
-                .thenReturn(30000);
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_HOME);
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_VOICE))
-                .thenReturn(45000);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_VOICE);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        assertTrue(
-                (int)
-                                mRestrictManager.getRemainingGuardTimer(
-                                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN)
-                        > 40000);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-    }
-
-    @Test
-    public void testHandoverHystGreaterBetweenStates() {
-        when(mMockQnsConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_HOME))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_IDLE))
-                .thenReturn(30000);
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_HOME);
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_VOICE))
-                .thenReturn(45000);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_VOICE);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        assertTrue(
-                (int)
-                                mRestrictManager.getRemainingGuardTimer(
-                                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN)
-                        > 40000);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_VIDEO))
-                .thenReturn(80000);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_VIDEO);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        assertTrue(
-                (int)
-                                mRestrictManager.getRemainingGuardTimer(
-                                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN)
-                        > 75000);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-    }
-
-    @Test
-    public void testHandoverHystWithZeroConfigBetweenCallStates() {
-        when(mMockQnsConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_HOME))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_IDLE))
-                .thenReturn(30000);
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_HOME);
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_VOICE))
-                .thenReturn(0);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_VOICE);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-    }
-
-    @Test
-    public void testHandoverHystOfVoicelessThanIdleState() {
-        when(mMockQnsConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_HOME))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_IDLE))
-                .thenReturn(60000);
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_HOME);
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_VOICE))
-                .thenReturn(30000);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_VOICE);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        assertTrue(
-                (int)
-                                mRestrictManager.getRemainingGuardTimer(
-                                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN)
-                        <= 30000);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-    }
-
-    @Test
-    public void testHandoverHystEqualBetweenStates() {
-        when(mMockQnsConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_HOME))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_IDLE))
-                .thenReturn(120000);
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_HOME);
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_VOICE))
-                .thenReturn(120000);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_VOICE);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        assertTrue(
-                (int)
-                                mRestrictManager.getRemainingGuardTimer(
-                                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN)
-                        <= 120000);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-    }
-
-    @Test
-    public void testWlanHandoverGuardingTimerVideoWithZero() {
-        when(mMockQnsConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_HOME))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_IDLE))
-                .thenReturn(30000);
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_HOME);
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_VIDEO))
-                .thenReturn(0);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_VIDEO);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-    }
-
-    @Test
-    public void testIsRestrictExceptGuarding() {
-        when(mMockQnsConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_HOME))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_IDLE))
-                .thenReturn(90000);
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_HOME);
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_VOICE))
-                .thenReturn(60000);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_VOICE);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        mRestrictManager.addRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                RESTRICT_TYPE_RTP_LOW_QUALITY,
-                sReleaseEventMap.get(RESTRICT_TYPE_RTP_LOW_QUALITY),
-                DEFAULT_RESTRICT_WITH_LOW_RTP_QUALITY_TIME);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_RTP_LOW_QUALITY));
-        assertTrue(
-                mRestrictManager.isRestrictedExceptGuarding(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN));
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_IDLE);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        assertFalse(
-                mRestrictManager.isRestrictedExceptGuarding(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN));
-    }
-
-    @Test
-    public void testRegisterRestrictInfoChanged() {
-        Handler h2 = new Handler(Looper.getMainLooper());
-        mRestrictManager.registerRestrictInfoChanged(h2, 10004);
-        assertNotNull(mRestrictManager.mRestrictInfoRegistrant);
-    }
-
-    @Test
-    public void testUnregisterRestrictInfoChanged() {
-        Handler h2 = new Handler(Looper.getMainLooper());
-        mRestrictManager.registerRestrictInfoChanged(h2, 10004);
-        assertNotNull(mRestrictManager.mRestrictInfoRegistrant);
-        mRestrictManager.unRegisterRestrictInfoChanged(h2);
-        assertNull(mRestrictManager.mRestrictInfoRegistrant);
-    }
-
-    @Test
-    public void testEnablePdnFallbackOnInitialDataConnectionFailWithRetryCounterOnWlan() {
-        setupEnablePdnFallbackOnInitialDataConnectionFail();
-        validateEnablePdnFallbackOnRetryCounterOverTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-    }
-
-    @Test
-    public void testEnablePdnFallbackOnInitialDataConnectionFailWithRetryCounterOnWwan() {
-        setupEnablePdnFallbackOnInitialDataConnectionFail();
-        validateEnablePdnFallbackOnRetryCounterOverTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-    }
-
-    @Test
-    public void testEnablePdnFallbackOnInitialDataConnectionFailWithRetryTimerOnWlan() {
-        setupEnableInitialDataConnectionFailFallbackWithRetryTimer();
-        validateEnablePdnFallbackOnRetryTimerOverTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-    }
-
-    @Test
-    public void testEnablePdnFallbackOnInitialDataConnectionFailWithRetryTimerOnWwan() {
-        setupEnableInitialDataConnectionFailFallbackWithRetryTimer();
-        validateEnablePdnFallbackOnRetryTimerOverTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-    }
-
-    private void setupEnableInitialDataConnectionFailFallbackWithRetryTimer() {
-        int[] fallbackConfigs = new int[] {1, 0, 30000, 2};
-        when(mMockQnsConfigManager.getInitialDataConnectionFallbackConfig(
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(fallbackConfigs);
-        when(mMockQnsConfigManager.getFallbackGuardTimerOnInitialConnectionFail(
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(30000);
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_HOME);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_IDLE);
-    }
-
-    private void validateEnablePdnFallbackOnRetryTimerOverTransportType(
-            @AccessNetworkConstants.TransportType int transportType,
-            @RestrictManager.RestrictType int restrictType) {
-        assertFalse(mRestrictManager.hasRestrictionType(transportType, restrictType));
-        setConnectionStartedToConnectionFailedState(transportType);
-        assertFalse(mRestrictManager.hasRestrictionType(transportType, restrictType));
-        assertTrue(mRestrictManager.mHandler.hasMessages(3009));
-        setConnectionStartedToConnectionFailedState(transportType);
-        assertFalse(mRestrictManager.hasRestrictionType(transportType, restrictType));
-        setConnectionStartedToConnectionFailedState(transportType);
-        assertFalse(mRestrictManager.hasRestrictionType(transportType, restrictType));
-        mTestLooper.moveTimeForward(30000);
-        mTestLooper.dispatchAll();
-        assertTrue(mRestrictManager.hasRestrictionType(transportType, restrictType));
-    }
-
-    @Test
-    public void testDisablePdnFallbackRunningOnDataConnectedStateWlanToWwan() {
-        setupEnablePdnFallbackOnInitialDataConnectionFail();
-        validateEnablePdnFallbackOnRetryCounterOverTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-        cancelPdnFallbackRunningOnDataConnectedStateOverOtherTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-    }
-
-    @Test
-    public void testDisablePdnFallbackRunningOnDataConnectedStateWwanToWlan() {
-        setupEnablePdnFallbackOnInitialDataConnectionFail();
-        validateEnablePdnFallbackOnRetryCounterOverTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-        cancelPdnFallbackRunningOnDataConnectedStateOverOtherTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-    }
-
-    @Test
-    public void testDisablePdnFallbackRunningOnDataConnectedStateWlanToWlan() {
-        setupEnablePdnFallbackOnInitialDataConnectionFail();
-        validateEnablePdnFallbackOnRetryCounterOverTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-        cancelPdnFallbackRunningOnDataConnectedStateOverTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-    }
-
-    @Test
-    public void testDisablePdnFallbackRunningOnDataConnectedStateWwanToWwan() {
-        setupEnablePdnFallbackOnInitialDataConnectionFail();
-        validateEnablePdnFallbackOnRetryCounterOverTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-        cancelPdnFallbackRunningOnDataConnectedStateOverTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-    }
-
-    private void cancelPdnFallbackRunningOnDataConnectedStateOverOtherTransportType(
-            @AccessNetworkConstants.TransportType int transportType,
-            @RestrictManager.RestrictType int restrictType) {
-        mTestLooper.moveTimeForward(20000);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        QnsUtils.getOtherTransportType(transportType), restrictType));
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_STARTED,
-                        DataConnectionStatusTracker.STATE_CONNECTING,
-                        transportType);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        QnsUtils.getOtherTransportType(transportType), restrictType));
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_CONNECTED,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        transportType);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        QnsUtils.getOtherTransportType(transportType), restrictType));
-    }
-
-    private void cancelPdnFallbackRunningOnDataConnectedStateOverTransportType(
-            @AccessNetworkConstants.TransportType int transportType,
-            @RestrictManager.RestrictType int restrictType) {
-        mTestLooper.moveTimeForward(20000);
-        mTestLooper.dispatchAll();
-        assertTrue(mRestrictManager.hasRestrictionType(transportType, restrictType));
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_STARTED,
-                        DataConnectionStatusTracker.STATE_CONNECTING,
-                        transportType);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertTrue(mRestrictManager.hasRestrictionType(transportType, restrictType));
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_CONNECTED,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        transportType);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertFalse(mRestrictManager.hasRestrictionType(transportType, restrictType));
-    }
-
-    private void setupEnablePdnFallbackOnInitialDataConnectionFail() {
-        int[] fallbackConfigs = new int[] {1, 2, 0, 2};
-        when(mMockQnsConfigManager.getInitialDataConnectionFallbackConfig(
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(fallbackConfigs);
-        when(mMockQnsConfigManager.getFallbackGuardTimerOnInitialConnectionFail(
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(30000);
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_HOME);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_IDLE);
-    }
-
-    private void validateEnablePdnFallbackOnRetryCounterOverTransportType(
-            @AccessNetworkConstants.TransportType int transportType,
-            @RestrictManager.RestrictType int restrictType) {
-        setConnectionStartedToConnectionFailedState(transportType);
-        assertFalse(mRestrictManager.hasRestrictionType(transportType, restrictType));
-        setConnectionStartedToConnectionFailedState(transportType);
-        assertFalse(mRestrictManager.hasRestrictionType(transportType, restrictType));
-        setConnectionStartedToConnectionFailedState(transportType);
-        assertTrue(mRestrictManager.hasRestrictionType(transportType, restrictType));
-    }
-
-    private void setConnectionStartedToConnectionFailedState(int transportType) {
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_STARTED,
-                        DataConnectionStatusTracker.STATE_CONNECTING,
-                        transportType);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_FAILED,
-                        DataConnectionStatusTracker.STATE_INACTIVE,
-                        transportType);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-    }
-
-    @Test
-    public void testDisablePdnFallbackRunningOnGuardTimerExpiry() {
-        setupEnablePdnFallbackOnInitialDataConnectionFail();
-        when(mMockQnsConfigManager.getFallbackGuardTimerOnInitialConnectionFail(
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(30000);
-        validateEnablePdnFallbackOnRetryCounterOverTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-        mTestLooper.moveTimeForward(20000);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-        mTestLooper.moveTimeForward(10000);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-    }
-
-    @Test
-    public void testCancelPdnFallbackRestrictionOnImsNotSupportedRat() {
-        setupEnablePdnFallbackOnInitialDataConnectionFail();
-        validateEnablePdnFallbackOnRetryCounterOverTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-        when(mMockQnsConfigManager.isAccessNetworkAllowed(
-                        AccessNetworkConstants.AccessNetworkType.UTRAN,
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(false);
-        mRestrictManager.setCellularAccessNetwork(AccessNetworkConstants.AccessNetworkType.UTRAN);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-    }
-
-    @Test
-    public void testSkipPdnFallbackCheckOverWlanWithAirplaneModeOnState() {
-        setupEnablePdnFallbackOnInitialDataConnectionFail();
-        when(mMockCellNetStatusTracker.isAirplaneModeEnabled()).thenReturn(true);
-        cancelPdnFallbackOnAirplaneModeOn(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-    }
-
-    private void cancelPdnFallbackOnAirplaneModeOn(
-            @AccessNetworkConstants.TransportType int transportType,
-            @RestrictManager.RestrictType int restrictType) {
-        setConnectionStartedToConnectionFailedState(transportType);
-        assertFalse(mRestrictManager.hasRestrictionType(transportType, restrictType));
-        setConnectionStartedToConnectionFailedState(transportType);
-        assertFalse(mRestrictManager.hasRestrictionType(transportType, restrictType));
-        setConnectionStartedToConnectionFailedState(transportType);
-        assertFalse(mRestrictManager.hasRestrictionType(transportType, restrictType));
-    }
-
-    @Test
-    public void testDisableFallbackOnDataConnectionFailOnFallbackCountMet() {
-        setupEnablePdnFallbackOnInitialDataConnectionFail();
-        when(mMockQnsConfigManager.getFallbackGuardTimerOnInitialConnectionFail(
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(30000);
-
-        // First Fallback
-        validateEnablePdnFallbackOnRetryCounterOverTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-        mTestLooper.moveTimeForward(20000);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-        setConnectionStartedToConnectionFailedState(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        // WLAN Fallback timer Expiry
-        mTestLooper.moveTimeForward(11000);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-        setConnectionStartedToConnectionFailedState(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        setConnectionStartedToConnectionFailedState(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-
-        // Second Fallback
-        mTestLooper.moveTimeForward(20000);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-        setConnectionStartedToConnectionFailedState(AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        // WWAN Fallback timer Expiry
-        mTestLooper.moveTimeForward(11000);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-        setConnectionStartedToConnectionFailedState(AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        setConnectionStartedToConnectionFailedState(AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-
-        // Max Fallback reached , so Fallback restriction never expected to run
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-    }
-
-    @Test
-    public void testIgnoreFallbackCountOnSingleRat() {
-        setupEnablePdnFallbackOnInitialDataConnectionFail();
-        when(mMockQnsConfigManager.getFallbackGuardTimerOnInitialConnectionFail(
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(30000);
-
-        // First Fallback
-        validateEnablePdnFallbackOnRetryCounterOverTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-        mTestLooper.moveTimeForward(20000);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_STARTED,
-                        DataConnectionStatusTracker.STATE_CONNECTING,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        // WLAN Fallback timer Expiry
-        mTestLooper.moveTimeForward(11000);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_FAILED,
-                        DataConnectionStatusTracker.STATE_INACTIVE,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        setConnectionStartedToConnectionFailedState(AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        setConnectionStartedToConnectionFailedState(AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-
-        // Second Fallback
-        mTestLooper.moveTimeForward(20000);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_STARTED,
-                        DataConnectionStatusTracker.STATE_CONNECTING,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        // WLAN Fallback timer Expiry
-        mTestLooper.moveTimeForward(11000);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_FAILED,
-                        DataConnectionStatusTracker.STATE_INACTIVE,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        setConnectionStartedToConnectionFailedState(AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        setConnectionStartedToConnectionFailedState(AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        // Fallback Count not increased if single rat
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-    }
-
-    @Test
-    public void testClearFallbackCountOnDataConnectedOverTransportType() {
-        setupEnablePdnFallbackOnInitialDataConnectionFail();
-        when(mMockQnsConfigManager.getFallbackGuardTimerOnInitialConnectionFail(
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(30000);
-
-        // First Fallback
-        validateEnablePdnFallbackOnRetryCounterOverTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-        mTestLooper.moveTimeForward(20000);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-        setConnectionStartedToConnectionFailedState(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        // WLAN Fallback timer Expiry
-        mTestLooper.moveTimeForward(11000);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-
-        // Fallback count = 2 Reached as per config
-        setConnectionStartedToConnectionFailedState(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        setConnectionStartedToConnectionFailedState(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_STARTED,
-                        DataConnectionStatusTracker.STATE_CONNECTING,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-
-        // On Data connected state : clear fallback count
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_CONNECTED,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL));
-    }
-
-    @Test
-    public void testResetFallbackCounterOnAirplaneModeOn() {
-        when(mMockCellNetStatusTracker.isAirplaneModeEnabled()).thenReturn(false);
-        testDisableFallbackOnDataConnectionFailOnFallbackCountMet();
-        mRestrictManager.mHandler.handleMessage(Message.obtain(mRestrictManager.mHandler, 6, null));
-        setupEnablePdnFallbackOnInitialDataConnectionFail();
-        validateEnablePdnFallbackOnRetryCounterOverTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-    }
-
-    @Test
-    public void testResetFallbackCounterOnWfcOff() {
-        when(mMockCellNetStatusTracker.isAirplaneModeEnabled()).thenReturn(false);
-        testDisableFallbackOnDataConnectionFailOnFallbackCountMet();
-        mRestrictManager.mHandler.handleMessage(Message.obtain(mRestrictManager.mHandler, 8, null));
-        setupEnablePdnFallbackOnInitialDataConnectionFail();
-        validateEnablePdnFallbackOnRetryCounterOverTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-    }
-
-    @Test
-    public void testResetFallbackCounterOnWifiOff() {
-        when(mMockCellNetStatusTracker.isAirplaneModeEnabled()).thenReturn(false);
-        testDisableFallbackOnDataConnectionFailOnFallbackCountMet();
-        mRestrictManager.mHandler.handleMessage(Message.obtain(mRestrictManager.mHandler, 3, null));
-        setupEnablePdnFallbackOnInitialDataConnectionFail();
-        validateEnablePdnFallbackOnRetryCounterOverTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_FALLBACK_ON_DATA_CONNECTION_FAIL);
-    }
-
-    @Test
-    public void testHandlerEventOnDataConnectionChangedEvent() {
-        // Handler message with WLAN Connected received
-        QnsAsyncResult asyncResult =
-                new QnsAsyncResult(
-                        null,
-                        new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                                DataConnectionStatusTracker.EVENT_DATA_CONNECTION_CONNECTED,
-                                DataConnectionStatusTracker.STATE_CONNECTED,
-                                AccessNetworkConstants.TRANSPORT_TYPE_WLAN),
-                        null);
-        mRestrictManager.mHandler.handleMessage(
-                Message.obtain(mRestrictManager.mHandler, 3001, asyncResult));
-
-        // Receive Handover started over Wwan
-        asyncResult =
-                new QnsAsyncResult(
-                        null,
-                        new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                                EVENT_DATA_CONNECTION_HANDOVER_STARTED,
-                                DataConnectionStatusTracker.STATE_HANDOVER,
-                                AccessNetworkConstants.TRANSPORT_TYPE_WLAN),
-                        null);
-        mRestrictManager.mHandler.handleMessage(
-                Message.obtain(mRestrictManager.mHandler, 3001, asyncResult));
-
-        // start Guarding operation of Source Rat during HO in progress
-        mRestrictManager.hasRestrictionType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_GUARDING);
-    }
-
-    @Test
-    public void testRestrictNonPreferredTransportOnBootUpWithWfcModeChangedEvents() {
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_HOME);
-        validateOnWfcModeChanged(9, AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        validateOnWfcModeChanged(10, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        validateOnWfcModeChanged(11, AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_ROAM);
-        validateOnWfcModeChanged(14, AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        validateOnWfcModeChanged(15, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        validateOnWfcModeChanged(16, AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-    }
-
-    private void validateOnWfcModeChanged(
-            int wfcModeEvent, @AccessNetworkConstants.TransportType int transportType) {
-        when(mMockCellNetStatusTracker.isAirplaneModeEnabled()).thenReturn(false);
-        when(mMockQnsConfigManager.getWaitingTimerForPreferredTransportOnPowerOn(transportType))
-                .thenReturn(10000);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_IDLE);
-        mRestrictManager.mHandler.handleMessage(
-                Message.obtain(mRestrictManager.mHandler, wfcModeEvent, null));
-        mRestrictManager.restrictNonPreferredTransport();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        QnsUtils.getOtherTransportType(transportType),
-                        RESTRICT_TYPE_NON_PREFERRED_TRANSPORT));
-        mTestLooper.moveTimeForward(10000);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        QnsUtils.getOtherTransportType(transportType),
-                        RESTRICT_TYPE_NON_PREFERRED_TRANSPORT));
-    }
-
-    @Test
-    public void testUpdateLastNotifiedTransportType() {
-        when(mMockCellNetStatusTracker.isAirplaneModeEnabled()).thenReturn(false);
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_HOME);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_IDLE);
-
-        // Initial Data Connection State
-        mRestrictManager.updateLastNotifiedTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_GUARDING));
-
-        // WWAN connected to WLAN handover state
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_STARTED,
-                        DataConnectionStatusTracker.STATE_CONNECTING,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_CONNECTED,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        when(mMockDcst.isActiveState()).thenReturn(true);
-        mRestrictManager.updateLastNotifiedTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-    }
-
-    @Test
-    public void testIsRestrictedForInvalidTransportType() {
-        when(mMockCellNetStatusTracker.isAirplaneModeEnabled()).thenReturn(false);
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_HOME);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_IDLE);
-
-        assertFalse(mRestrictManager.isRestricted(-1));
-        assertFalse(mRestrictManager.hasRestrictionType(-1, RESTRICT_TYPE_GUARDING));
-        assertFalse(mRestrictManager.isRestrictedExceptGuarding(-1));
-    }
-
-    @Test
-    public void testGuardTimerHysteresisOnPrefWithWifiPrefInHome() {
-        setupGuardTimerHysteresisOnPrefSupportedWithCoverage(11, QnsConstants.COVERAGE_HOME);
-        validateGuardTimerHysteresisOnPrefSupportedWithTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-    }
-
-    @Test
-    public void testGuardTimerHysteresisOnPrefWithCellPrefInHome() {
-        setupGuardTimerHysteresisOnPrefSupportedWithCoverage(10, QnsConstants.COVERAGE_HOME);
-        validateGuardTimerHysteresisOnPrefSupportedWithTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-    }
-
-    @Test
-    public void testGuardTimerHysteresisOnPrefWithWifiPrefInRoam() {
-        setupGuardTimerHysteresisOnPrefSupportedWithCoverage(16, QnsConstants.COVERAGE_ROAM);
-        validateGuardTimerHysteresisOnPrefSupportedWithTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-    }
-
-    @Test
-    public void testGuardTimerHysteresisOnPrefWithCellPrefInRoam() {
-        setupGuardTimerHysteresisOnPrefSupportedWithCoverage(15, QnsConstants.COVERAGE_ROAM);
-        validateGuardTimerHysteresisOnPrefSupportedWithTransportType(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-    }
-
-    private void setupGuardTimerHysteresisOnPrefSupportedWithCoverage(
-            int event, @QnsConstants.CellularCoverage int coverage) {
-        when(mMockCellNetStatusTracker.isAirplaneModeEnabled()).thenReturn(false);
-        when(mMockQnsConfigManager.isHysteresisTimerEnabled(coverage)).thenReturn(true);
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_IDLE))
-                .thenReturn(30000);
-        when(mMockQnsConfigManager.getWlanHysteresisTimer(
-                        NetworkCapabilities.NET_CAPABILITY_IMS, QnsConstants.CALL_TYPE_IDLE))
-                .thenReturn(30000);
-        // Set Wfc preference with coverage with Hysteresis based on Pref supported
-        mRestrictManager.setCellularCoverage(coverage);
-        mRestrictManager.setQnsCallType(QnsConstants.CALL_TYPE_IDLE);
-        when(mMockQnsConfigManager.isGuardTimerHysteresisOnPrefSupported()).thenReturn(true);
-        mRestrictManager.mHandler.handleMessage(
-                Message.obtain(mRestrictManager.mHandler, event, null));
-    }
-
-    private void validateGuardTimerHysteresisOnPrefSupportedWithTransportType(
-            @AccessNetworkConstants.TransportType int transportType) {
-
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        transportType);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        QnsUtils.getOtherTransportType(transportType), RESTRICT_TYPE_GUARDING));
-
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_STARTED,
-                        DataConnectionStatusTracker.STATE_HANDOVER,
-                        transportType);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        QnsUtils.getOtherTransportType(transportType));
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertTrue(mRestrictManager.hasRestrictionType(transportType, RESTRICT_TYPE_GUARDING));
-    }
-
-    @Test
-    public void testRttFallbackStartOnRttFail() {
-        setupBackhaulRttCheckSupportConfigs();
-        when(mMockCellNetStatusTracker.isAirplaneModeEnabled()).thenReturn(false);
-        mRestrictManager.setCellularAccessNetwork(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        when(mMockQnsConfigManager.isAccessNetworkAllowed(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(true);
-        mRestrictManager.onWlanRttFail();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL));
-    }
-
-    @Test
-    public void testRttFallbackReleaseOnWwanHystTimerExpiry() {
-        setupBackhaulRttCheckSupportConfigs();
-        when(mMockCellNetStatusTracker.isAirplaneModeEnabled()).thenReturn(false);
-        mRestrictManager.setCellularAccessNetwork(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        when(mMockQnsConfigManager.isAccessNetworkAllowed(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(true);
-        mRestrictManager.onWlanRttFail();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL));
-        mTestLooper.moveTimeForward(8000);
-        mTestLooper.dispatchAll();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL));
-        mTestLooper.moveTimeForward(2000);
-        mTestLooper.dispatchAll();
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL));
-    }
-
-    @Test
-    public void testRttFallbackReleaseOnNonImsRatCondition() {
-        setupBackhaulRttCheckSupportConfigs();
-        when(mMockCellNetStatusTracker.isAirplaneModeEnabled()).thenReturn(false);
-        mRestrictManager.setCellularAccessNetwork(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        when(mMockQnsConfigManager.isAccessNetworkAllowed(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(true);
-        mRestrictManager.onWlanRttFail();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL));
-        mTestLooper.moveTimeForward(8000);
-        mTestLooper.dispatchAll();
-        when(mMockQnsConfigManager.isAccessNetworkAllowed(
-                        AccessNetworkConstants.AccessNetworkType.UTRAN,
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(false);
-        mRestrictManager.setCellularAccessNetwork(AccessNetworkConstants.AccessNetworkType.UTRAN);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL));
-    }
-
-    @Test
-    public void testRttFallbackReleaseOnOtherBreakingCondition() {
-        setupBackhaulRttCheckSupportConfigs();
-        when(mMockCellNetStatusTracker.isAirplaneModeEnabled()).thenReturn(false);
-        mRestrictManager.setCellularAccessNetwork(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        when(mMockQnsConfigManager.isAccessNetworkAllowed(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(true);
-        mRestrictManager.onWlanRttFail();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL));
-        mTestLooper.moveTimeForward(8000);
-        mTestLooper.dispatchAll();
-        mRestrictManager.processReleaseEvent(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RELEASE_EVENT_DISCONNECT);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL));
-    }
-
-    @Test
-    public void testReleaseRttFallbackRestrictionOnWfcOff() {
-        setupBackhaulRttCheckSupportConfigs();
-        when(mMockCellNetStatusTracker.isAirplaneModeEnabled()).thenReturn(false);
-        mRestrictManager.setCellularAccessNetwork(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        when(mMockQnsConfigManager.isAccessNetworkAllowed(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(true);
-        mRestrictManager.onWlanRttFail();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL));
-        mRestrictManager.mHandler.handleMessage(Message.obtain(mRestrictManager.mHandler, 6, null));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL));
-    }
-
-    @Test
-    public void testReleaseRttFallbackRestrictionOnAirplaneModeOn() {
-        setupBackhaulRttCheckSupportConfigs();
-        when(mMockCellNetStatusTracker.isAirplaneModeEnabled()).thenReturn(false);
-        mRestrictManager.setCellularAccessNetwork(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        when(mMockQnsConfigManager.isAccessNetworkAllowed(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(true);
-        mRestrictManager.onWlanRttFail();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL));
-        mRestrictManager.mHandler.handleMessage(Message.obtain(mRestrictManager.mHandler, 8, null));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL));
-    }
-
-    @Test
-    public void testReleaseRttFallbackRestrictionOnAirplaneOnWifiOff() {
-        setupBackhaulRttCheckSupportConfigs();
-        when(mMockCellNetStatusTracker.isAirplaneModeEnabled()).thenReturn(false);
-        mRestrictManager.setCellularAccessNetwork(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        when(mMockQnsConfigManager.isAccessNetworkAllowed(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(true);
-        mRestrictManager.onWlanRttFail();
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL));
-        mRestrictManager.mHandler.handleMessage(Message.obtain(mRestrictManager.mHandler, 3, null));
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                        RESTRICT_TYPE_FALLBACK_TO_WWAN_RTT_BACKHAUL_FAIL));
-    }
-
-    @Test
-    public void testRegisterRttStatusCheckEvent() {
-        when(mMockWifiBm.isRttCheckEnabled()).thenReturn(true);
-        when(mMockQnsConfigManager.allowImsOverIwlanCellularLimitedCase()).thenReturn(false);
-        when(mMockQnsConfigManager.isAccessNetworkAllowed(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(true);
-        mRestrictManager.setCellularAccessNetwork(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_CONNECTED,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        triggerMmTelCallback_onRegistered(
-                mQnsImsManager, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mTestLooper.dispatchAll();
-        Mockito.verify(mMockWifiBm).registerForRttStatusChange(mRestrictManager.mHandler, 3010);
-    }
-
-    @Test
-    public void testUnRegisterRttStatusCheckEvent() {
-        when(mMockWifiBm.isRttCheckEnabled()).thenReturn(true);
-        when(mMockQnsConfigManager.allowImsOverIwlanCellularLimitedCase()).thenReturn(false);
-        when(mMockQnsConfigManager.isAccessNetworkAllowed(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        NetworkCapabilities.NET_CAPABILITY_IMS))
-                .thenReturn(true);
-        mRestrictManager.setCellularAccessNetwork(AccessNetworkConstants.AccessNetworkType.EUTRAN);
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_CONNECTED,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        triggerMmTelCallback_onRegistered(
-                mQnsImsManager, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mTestLooper.dispatchAll();
-        when(mMockWifiBm.isRttCheckEnabled()).thenReturn(false);
-        ImsReasonInfo reason = new ImsReasonInfo();
-        reason.mCode = ImsReasonInfo.CODE_SIP_TEMPRARILY_UNAVAILABLE;
-        triggerMmTelCallback_onTechnologyChangeFailed(
-                mQnsImsManager, AccessNetworkConstants.TRANSPORT_TYPE_WWAN, reason);
-        mTestLooper.dispatchAll();
-        Mockito.verify(mMockWifiBm).unRegisterForRttStatusChange(mRestrictManager.mHandler);
-    }
-
-    private void setupBackhaulRttCheckSupportConfigs() {
-        when(mMockWifiBm.isRttCheckEnabled()).thenReturn(true);
-        when(mMockQnsConfigManager.getWlanRttFallbackHystTimer()).thenReturn(10000);
-    }
-
-    @Test
-    public void testRestrictMinimumHysteresisTimer() {
-        DataConnectionStatusTracker.DataConnectionChangedInfo dcInfo;
-
-        // Test Set #1
-        when(mMockQnsConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_HOME))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_ROAM))
-                .thenReturn(false);
-        when(mMockQnsConfigManager.getMinimumHandoverGuardingTimer()).thenReturn(2000);
-        when(mMockQnsConfigManager.getWlanHysteresisTimer(anyInt(), anyInt())).thenReturn(0);
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(anyInt(), anyInt())).thenReturn(0);
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_HOME);
-
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        mRestrictManager.releaseRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING, true);
-
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_GUARDING));
-        mRestrictManager.releaseRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_GUARDING, true);
-
-        // Test Set #2
-        when(mMockQnsConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_HOME))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_ROAM))
-                .thenReturn(false);
-        when(mMockQnsConfigManager.getMinimumHandoverGuardingTimer()).thenReturn(0);
-        when(mMockQnsConfigManager.getWlanHysteresisTimer(anyInt(), anyInt())).thenReturn(0);
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(anyInt(), anyInt())).thenReturn(0);
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_HOME);
-
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        mRestrictManager.releaseRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING, true);
-
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertFalse(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_GUARDING));
-        mRestrictManager.releaseRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_GUARDING, true);
-
-        // Test Set #3
-        when(mMockQnsConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_HOME))
-                .thenReturn(true);
-        when(mMockQnsConfigManager.isHysteresisTimerEnabled(QnsConstants.COVERAGE_ROAM))
-                .thenReturn(false);
-        when(mMockQnsConfigManager.getMinimumHandoverGuardingTimer()).thenReturn(5000);
-        when(mMockQnsConfigManager.getWlanHysteresisTimer(anyInt(), anyInt())).thenReturn(0);
-        when(mMockQnsConfigManager.getWwanHysteresisTimer(anyInt(), anyInt())).thenReturn(0);
-        mRestrictManager.setCellularCoverage(QnsConstants.COVERAGE_ROAM);
-
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING));
-        mRestrictManager.releaseRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WWAN, RESTRICT_TYPE_GUARDING, true);
-
-        dcInfo =
-                new DataConnectionStatusTracker.DataConnectionChangedInfo(
-                        EVENT_DATA_CONNECTION_HANDOVER_SUCCESS,
-                        DataConnectionStatusTracker.STATE_CONNECTED,
-                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
-        mRestrictManager.onDataConnectionChanged(dcInfo);
-        assertTrue(
-                mRestrictManager.hasRestrictionType(
-                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_GUARDING));
-        mRestrictManager.releaseRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN, RESTRICT_TYPE_GUARDING, true);
-    }
-
-    @Test
-    public void testSendRestrictionsForMetrics() throws Exception {
-        CountDownLatch latch = new CountDownLatch(1);
-        Handler handler = new Handler(mHandlerThread.getLooper()) {
-            public void handleMessage(Message msg) {
-                latch.countDown();
-            }
-        };
-
-        mRestrictManager.registerRestrictInfoChanged(handler, 0);
-        assertNotNull(mRestrictManager.mRestrictInfoRegistrant);
-
-        mRestrictManager.addRestriction(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                RESTRICT_TYPE_RTP_LOW_QUALITY,
-                sReleaseEventMap.get(RESTRICT_TYPE_NON_PREFERRED_TRANSPORT),
-                DEFAULT_RESTRICT_NON_PREFERRED_TRANSPORT_TIME);
-
-        assertTrue(latch.await(3, TimeUnit.SECONDS));
-
-        mRestrictManager.unRegisterRestrictInfoChanged(handler);
-        assertNull(mRestrictManager.mRestrictInfoRegistrant);
-    }
-
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/ThresholdGroupTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/ThresholdGroupTest.java
deleted file mode 100644
index 93eea25..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/ThresholdGroupTest.java
+++ /dev/null
@@ -1,391 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.doReturn;
-
-import android.telephony.AccessNetworkConstants;
-import android.telephony.SignalThresholdInfo;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-import java.util.ArrayList;
-import java.util.List;
-
-@RunWith(JUnit4.class)
-public class ThresholdGroupTest {
-
-    @Mock QualityMonitor mMockWifiQualityMonitor;
-    @Mock QualityMonitor mMockCellularQualityMonitor;
-    private List<Threshold> mThresholdList;
-    private ThresholdGroup mThresholdGroup;
-
-    @Before
-    public void setUp() {
-        MockitoAnnotations.initMocks(this);
-        mThresholdList = new ArrayList<>();
-        mThresholdList.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                        -117,
-                        QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        mThresholdList.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR,
-                        -15,
-                        QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        mThresholdList.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                        -65,
-                        QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        doReturn(-120, -116)
-                .when(mMockCellularQualityMonitor)
-                .getCurrentQuality(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP);
-        doReturn(-16, -13)
-                .when(mMockCellularQualityMonitor)
-                .getCurrentQuality(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR);
-        doReturn(-70, -55)
-                .when(mMockWifiQualityMonitor)
-                .getCurrentQuality(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI);
-    }
-
-    @Test
-    public void testSatisfiedByThreshold_WithThresholds() {
-
-        mThresholdGroup = new ThresholdGroup(mThresholdList);
-
-        // Case1:
-        assertTrue(
-                mThresholdGroup.satisfiedByThreshold(
-                        mMockWifiQualityMonitor,
-                        mMockCellularQualityMonitor,
-                        true,
-                        true,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN));
-
-        // Case2:
-        mThresholdList.clear();
-        mThresholdList.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                        -117,
-                        QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        mThresholdList.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR,
-                        -15,
-                        QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        mThresholdList.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                        -65,
-                        QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        mThresholdGroup = new ThresholdGroup(mThresholdList);
-
-        assertTrue(
-                mThresholdGroup.satisfiedByThreshold(
-                        mMockWifiQualityMonitor,
-                        mMockCellularQualityMonitor,
-                        true,
-                        true,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN));
-        // Other Cases:
-        assertTrue(
-                mThresholdGroup.satisfiedByThreshold(
-                        mMockWifiQualityMonitor,
-                        mMockCellularQualityMonitor,
-                        false,
-                        true,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN));
-
-        // no NGRAN condition case:
-        assertFalse(
-                mThresholdGroup.satisfiedByThreshold(
-                        mMockWifiQualityMonitor,
-                        mMockCellularQualityMonitor,
-                        false,
-                        true,
-                        AccessNetworkConstants.AccessNetworkType.NGRAN));
-    }
-
-    @Test
-    public void testSatisfiedByThreshold_WithSignalAvailability() {
-        mThresholdList = new ArrayList<>();
-
-        // Case1:
-        mThresholdList.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        QnsConstants.SIGNAL_MEASUREMENT_AVAILABILITY,
-                        QnsConstants.SIGNAL_AVAILABLE,
-                        QnsConstants.THRESHOLD_MATCH_TYPE_EQUAL_TO,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        mThresholdGroup = new ThresholdGroup(mThresholdList);
-
-        assertTrue(
-                mThresholdGroup.satisfiedByThreshold(
-                        mMockWifiQualityMonitor,
-                        mMockCellularQualityMonitor,
-                        true,
-                        true,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN));
-
-        // Case2:
-        assertFalse(
-                mThresholdGroup.satisfiedByThreshold(
-                        mMockWifiQualityMonitor,
-                        mMockCellularQualityMonitor,
-                        false,
-                        true,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN));
-    }
-
-    @Test
-    public void testSatisfiedByThreshold_WithEutranAvailability() {
-        doReturn(-90, -55)
-                .when(mMockWifiQualityMonitor)
-                .getCurrentQuality(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI);
-
-        mThresholdList = new ArrayList<>();
-
-        // Case1:
-        mThresholdList.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                        -80,
-                        QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        mThresholdList.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        QnsConstants.SIGNAL_MEASUREMENT_AVAILABILITY,
-                        QnsConstants.SIGNAL_AVAILABLE,
-                        QnsConstants.THRESHOLD_MATCH_TYPE_EQUAL_TO,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        mThresholdGroup = new ThresholdGroup(mThresholdList);
-
-        assertTrue(
-                mThresholdGroup.satisfiedByThreshold(
-                        mMockWifiQualityMonitor,
-                        mMockCellularQualityMonitor,
-                        true,
-                        true,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN));
-
-        assertFalse(
-                mThresholdGroup.satisfiedByThreshold(
-                        mMockWifiQualityMonitor,
-                        mMockCellularQualityMonitor,
-                        true,
-                        true,
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN));
-
-        assertFalse(
-                mThresholdGroup.satisfiedByThreshold(
-                        mMockWifiQualityMonitor,
-                        mMockCellularQualityMonitor,
-                        true,
-                        true,
-                        AccessNetworkConstants.AccessNetworkType.UTRAN));
-    }
-
-    @Test
-    public void testSatisfiedByThreshold_WithUnavailability() {
-        doReturn(-50)
-                .when(mMockWifiQualityMonitor)
-                .getCurrentQuality(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI);
-
-        mThresholdList = new ArrayList<>();
-
-        // Case1:
-        mThresholdList.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                        -80,
-                        QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        mThresholdList.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        QnsConstants.SIGNAL_MEASUREMENT_AVAILABILITY,
-                        QnsConstants.SIGNAL_UNAVAILABLE,
-                        QnsConstants.THRESHOLD_MATCH_TYPE_EQUAL_TO,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        mThresholdList.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.UTRAN,
-                        QnsConstants.SIGNAL_MEASUREMENT_AVAILABILITY,
-                        QnsConstants.SIGNAL_UNAVAILABLE,
-                        QnsConstants.THRESHOLD_MATCH_TYPE_EQUAL_TO,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        mThresholdList.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.GERAN,
-                        QnsConstants.SIGNAL_MEASUREMENT_AVAILABILITY,
-                        QnsConstants.SIGNAL_UNAVAILABLE,
-                        QnsConstants.THRESHOLD_MATCH_TYPE_EQUAL_TO,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        mThresholdList.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.NGRAN,
-                        QnsConstants.SIGNAL_MEASUREMENT_AVAILABILITY,
-                        QnsConstants.SIGNAL_UNAVAILABLE,
-                        QnsConstants.THRESHOLD_MATCH_TYPE_EQUAL_TO,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-        mThresholdGroup = new ThresholdGroup(mThresholdList);
-
-        assertTrue(
-                mThresholdGroup.satisfiedByThreshold(
-                        mMockWifiQualityMonitor,
-                        mMockCellularQualityMonitor,
-                        true,
-                        false,
-                        AccessNetworkConstants.AccessNetworkType.UNKNOWN));
-    }
-
-    @Test
-    public void testFindUnmatchedThresholds() {
-        doReturn(-12, -16)
-                .when(mMockCellularQualityMonitor)
-                .getCurrentQuality(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRQ);
-        mThresholdList.add(
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRQ,
-                        -15,
-                        QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER));
-
-        // Case1:
-        mThresholdGroup = new ThresholdGroup(mThresholdList);
-
-        List<Threshold> output =
-                mThresholdGroup.findUnmatchedThresholds(
-                        mMockWifiQualityMonitor, mMockCellularQualityMonitor);
-        assertEquals(1, output.size());
-        output =
-                mThresholdGroup.findUnmatchedThresholds(
-                        mMockWifiQualityMonitor, mMockCellularQualityMonitor);
-        assertEquals(3, output.size());
-    }
-
-    @Test
-    public void testGetThresholds() {
-        mThresholdGroup = new ThresholdGroup(mThresholdList);
-        assertEquals(
-                2,
-                mThresholdGroup
-                        .getThresholds(AccessNetworkConstants.AccessNetworkType.EUTRAN)
-                        .size());
-        assertEquals(
-                1,
-                mThresholdGroup
-                        .getThresholds(AccessNetworkConstants.AccessNetworkType.IWLAN)
-                        .size());
-    }
-
-    @Test
-    public void testIdenticalThreshold() {
-        mThresholdGroup = new ThresholdGroup(mThresholdList);
-        // Case1:
-        List<Threshold> ths = new ArrayList<>(mThresholdList);
-        assertTrue(mThresholdGroup.identicalThreshold(ths));
-
-        ths.remove(0);
-        assertFalse(mThresholdGroup.identicalThreshold(ths));
-
-        ths.clear();
-        ths.addAll(mThresholdList);
-        ths.get(0).setGroupId(123);
-        ths.get(0).setThresholdId(123);
-        assertTrue(mThresholdGroup.identicalThreshold(ths));
-
-        Threshold t = ths.remove(0).copy();
-        t.setThreshold(-123);
-        ths.add(0, t);
-        assertFalse(mThresholdGroup.identicalThreshold(ths));
-
-        ths.clear();
-        ths.addAll(mThresholdList);
-        t = ths.remove(0).copy();
-        t.setMeasurementType(SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRQ);
-        ths.add(0, t);
-        assertFalse(mThresholdGroup.identicalThreshold(ths));
-
-        ths.clear();
-        ths.addAll(mThresholdList);
-        t = ths.remove(0).copy();
-        t.setAccessNetwork(AccessNetworkConstants.AccessNetworkType.NGRAN);
-        ths.add(0, t);
-        assertFalse(mThresholdGroup.identicalThreshold(ths));
-
-        ths.clear();
-        ths.addAll(mThresholdList);
-        t = ths.remove(0).copy();
-        ths.add(0, t);
-        t.setMatchType(QnsConstants.THRESHOLD_EQUAL_OR_LARGER);
-        assertFalse(mThresholdGroup.identicalThreshold(ths));
-
-        ths.clear();
-        ths.addAll(mThresholdList);
-        t = ths.remove(0).copy();
-        t.setWaitTime(2000);
-        ths.add(0, t);
-        assertFalse(mThresholdGroup.identicalThreshold(ths));
-    }
-
-    @After
-    public void tearDown() {
-        mThresholdList.clear();
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/ThresholdTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/ThresholdTest.java
deleted file mode 100644
index 7f6195a..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/ThresholdTest.java
+++ /dev/null
@@ -1,225 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import android.telephony.AccessNetworkConstants;
-import android.telephony.SignalThresholdInfo;
-
-import org.junit.After;
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class ThresholdTest {
-    private Threshold mThreshold;
-    private int mThresholdValue = -117;
-    private int mGid = QnsConstants.INVALID_ID;
-    private int mAccessNetwork = AccessNetworkConstants.AccessNetworkType.EUTRAN;
-    private int mMeasurementType = SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP;
-    private int mMatchType = QnsConstants.THRESHOLD_EQUAL_OR_SMALLER;
-    private int mWaitTime = QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER;
-
-    @Before
-    public void setUp() {
-        mThreshold =
-                new Threshold(
-                        mAccessNetwork, mMeasurementType, mThresholdValue, mMatchType, mWaitTime);
-    }
-
-    @After
-    public void tearDown() {
-        mThreshold = null;
-    }
-
-    @Test
-    public void testCopy() {
-        Threshold t2 = mThreshold.copy();
-        Assert.assertEquals(mThreshold, t2);
-    }
-
-    @Test
-    public void testSetThresholdId() {
-        int set_tid = 5;
-        mThreshold.setThresholdId(set_tid);
-        Assert.assertEquals(set_tid, mThreshold.getThresholdId());
-    }
-
-    @Test
-    public void testGetGroupId() {
-        Assert.assertEquals(mGid, mThreshold.getGroupId());
-    }
-
-    @Test
-    public void testSetGroupId() {
-        int set_gid = 5;
-        mThreshold.setGroupId(set_gid);
-        Assert.assertEquals(set_gid, mThreshold.getGroupId());
-    }
-
-    @Test
-    public void testGetAccessNetwork() {
-        Assert.assertEquals(mAccessNetwork, mThreshold.getAccessNetwork());
-    }
-
-    @Test
-    public void testSetAccessNetwork() {
-        int set_accessNetwork = AccessNetworkConstants.AccessNetworkType.GERAN;
-        mThreshold.setAccessNetwork(set_accessNetwork);
-        Assert.assertEquals(set_accessNetwork, mThreshold.getAccessNetwork());
-    }
-
-    @Test
-    public void testGetMeasurementType() {
-        Assert.assertEquals(mMeasurementType, mThreshold.getMeasurementType());
-    }
-
-    @Test
-    public void testSetMeasurementType() {
-        int set_measurement = SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR;
-        mThreshold.setMeasurementType(set_measurement);
-        Assert.assertEquals(set_measurement, mThreshold.getMeasurementType());
-    }
-
-    @Test
-    public void testGetThreshold() {
-        Assert.assertEquals(mThresholdValue, mThreshold.getThreshold());
-    }
-
-    @Test
-    public void testSetThreshold() {
-        int set_th = -90;
-        mThreshold.setThreshold(set_th);
-        Assert.assertEquals(set_th, mThreshold.getThreshold());
-    }
-
-    @Test
-    public void testGetMatchType() {
-        Assert.assertEquals(mMatchType, mThreshold.getMatchType());
-    }
-
-    @Test
-    public void testSetMatchType() {
-        int set_matchType = QnsConstants.THRESHOLD_MATCH_TYPE_EQUAL_TO;
-        mThreshold.setMatchType(set_matchType);
-        Assert.assertEquals(set_matchType, mThreshold.getMatchType());
-    }
-
-    @Test
-    public void testGetWaitTime() {
-        Assert.assertEquals(QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER, mThreshold.getWaitTime());
-    }
-
-    @Test
-    public void testSetWaitTime() {
-        int set_time = 5000;
-        mThreshold.setWaitTime(set_time);
-        Assert.assertEquals(set_time, mThreshold.getWaitTime());
-    }
-
-    @Test
-    public void testIsMultipleNetCapabilityTypeCheckCriteria() {
-        Threshold[] th =
-                new Threshold[] {
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                            -117,
-                            QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                            -117,
-                            QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRQ,
-                            -117,
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                };
-        Assert.assertTrue(th[0].identicalThreshold(th[1]));
-        Assert.assertFalse(th[0].identicalThreshold(th[2]));
-    }
-
-    @Test
-    public void testIsMatching() {
-        Threshold[] th =
-                new Threshold[] {
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                            -117,
-                            QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR,
-                            -15,
-                            QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                            -100,
-                            QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR,
-                            0,
-                            QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                            -65,
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR,
-                            -10,
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSRP,
-                            -80,
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.EUTRAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSNR,
-                            10,
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                };
-        Assert.assertTrue(th[0].isMatching(-118));
-        Assert.assertTrue(th[1].isMatching(-20));
-        Assert.assertFalse(th[2].isMatching(-99)); // not meeting the criteria
-        Assert.assertFalse(th[3].isMatching(12)); // not meeting the criteria
-        Assert.assertTrue(th[4].isMatching(-60));
-        Assert.assertTrue(th[5].isMatching(20));
-        Assert.assertFalse(th[6].isMatching(-81)); // not meeting the criteria
-        Assert.assertFalse(th[7].isMatching(9)); // not meeting the criteria
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/WifiBackhaulMonitorTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/WifiBackhaulMonitorTest.java
deleted file mode 100644
index b05d3c1..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/WifiBackhaulMonitorTest.java
+++ /dev/null
@@ -1,402 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static com.android.dx.mockito.inline.extended.ExtendedMockito.mockitoSession;
-import static com.android.telephony.qns.QnsConstants.INVALID_ID;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.anyInt;
-import static org.mockito.Mockito.anyString;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.isA;
-import static org.mockito.Mockito.lenient;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.net.ConnectivityManager.NetworkCallback;
-import android.net.LinkProperties;
-import android.net.Network;
-import android.net.NetworkRequest;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Looper;
-import android.os.Message;
-import android.telephony.AccessNetworkConstants;
-
-import com.android.dx.mockito.inline.extended.StaticMockitoSession;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.mockito.stubbing.Answer;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.InetAddress;
-import java.nio.charset.StandardCharsets;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-public class WifiBackhaulMonitorTest extends QnsTest {
-
-    private static final int EVENT_START_RTT_CHECK = 1;
-    private static final int EVENT_IMS_REGISTRATION_STATE_CHANGED = 2;
-
-    @Mock private Network mMockNetwork;
-    @Mock private Process mProcessV4;
-    @Mock private Process mProcessV6;
-    @Mock private Runtime mRuntime;
-
-    private WifiBackhaulMonitor mWbm;
-
-    private Handler mHandler;
-    private StaticMockitoSession mMockitoSession;
-    private LinkProperties mLinkProperties = new LinkProperties();
-    private String mServerAddress;
-    private QnsTimer mQnsTimer;
-    private int[] mRttConfigs;
-
-    HandlerThread mHt =
-            new HandlerThread("") {
-                @Override
-                protected void onLooperPrepared() {
-                    super.onLooperPrepared();
-                    mWbm =
-                            new WifiBackhaulMonitor(
-                                    sMockContext,
-                                    mMockQnsConfigManager,
-                                    mMockQnsImsManager,
-                                    mQnsTimer,
-                                    0);
-                    setReady(true);
-                }
-            };
-    private NetworkCallback mCallback;
-    private Handler mRttHandler;
-    private HandlerThread mHandlerThread;
-    private CountDownLatch mLatch;
-    private QnsAsyncResult mAsyncResult;
-
-    private class TestHandler extends Handler {
-
-        TestHandler(Looper looper) {
-            super(looper);
-        }
-
-        @Override
-        public void handleMessage(Message msg) {
-            assertNotNull(msg);
-            assertTrue(msg.obj instanceof QnsAsyncResult);
-            mAsyncResult = (QnsAsyncResult) msg.obj;
-            if (mLatch != null) {
-                mLatch.countDown();
-            }
-        }
-    }
-
-    @Before
-    public void setUp() throws Exception {
-        MockitoAnnotations.initMocks(this);
-        super.setUp();
-
-        mServerAddress = "";
-        mRttConfigs = null;
-        mLinkProperties.setInterfaceName("iwlan0");
-        mLatch = new CountDownLatch(1);
-        mQnsTimer = new QnsTimer(sMockContext);
-
-        mMockitoSession =
-                mockitoSession()
-                        .mockStatic(Runtime.class)
-                        .spyStatic(InetAddress.class)
-                        .startMocking();
-        mockDefaults();
-        mHt.start();
-        waitUntilReady();
-        mHandlerThread = new HandlerThread("");
-        mHandlerThread.start();
-        mHandler = new TestHandler(mHandlerThread.getLooper());
-    }
-
-    private void mockDefaults() throws IOException {
-
-        lenient().when(Runtime.getRuntime()).thenReturn(mRuntime);
-
-        InetAddress[] inetAddresses = new InetAddress[2];
-        inetAddresses[0] = InetAddress.getByAddress(new byte[] {0, 0, 0, 0});
-        inetAddresses[1] =
-                InetAddress.getByAddress(
-                        new byte[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0});
-        lenient().when(InetAddress.getAllByName(anyString())).thenReturn(inetAddresses);
-
-        doReturn(mLinkProperties).when(mMockConnectivityManager).getLinkProperties(mMockNetwork);
-        when(mRuntime.exec(anyString()))
-                .thenAnswer((Answer<Process>)
-                    invocation -> {
-                        String arg = invocation.getArgument(0);
-                        if (arg.startsWith("ping6")) {
-                            return mProcessV6;
-                        }
-                        return mProcessV4;
-                    });
-        doAnswer(ret -> mServerAddress).when(mMockQnsConfigManager).getWlanRttServerAddressConfig();
-        doAnswer(invocation -> mRttConfigs).when(mMockQnsConfigManager).getWlanRttOtherConfigs();
-    }
-
-    @After
-    public void tearDown() {
-        mAsyncResult = null;
-        mWbm.close();
-        mMockitoSession.finishMocking();
-        mHandlerThread.quit();
-    }
-
-    @Test
-    public void testIsRttCheckEnabled() {
-        mServerAddress = null;
-        assertFalse(mWbm.isRttCheckEnabled());
-
-        mServerAddress = "";
-        assertTrue(mWbm.isRttCheckEnabled());
-    }
-
-    @Test
-    public void registerForRttStatusChange() {
-        Handler handler = new Handler(mHandlerThread.getLooper());
-
-        mWbm.registerForRttStatusChange(mHandler, 1);
-        mWbm.registerForRttStatusChange(handler, 2);
-
-        verify(mMockQnsImsManager, times(1))
-                .registerImsRegistrationStatusChanged(isA(Handler.class), anyInt());
-        verify(mMockConnectivityManager, times(1))
-                .registerNetworkCallback(isA(NetworkRequest.class), isA(NetworkCallback.class));
-
-        mWbm.unRegisterForRttStatusChange(mHandler);
-        mWbm.unRegisterForRttStatusChange(handler);
-
-        verify(mMockQnsImsManager, times(1))
-                .unregisterImsRegistrationStatusChanged(isA(Handler.class));
-        verify(mMockConnectivityManager, times(1))
-                .unregisterNetworkCallback(isA(NetworkCallback.class));
-    }
-
-    @Test
-    public void testRttWhenNoWlanInterface() throws InterruptedException {
-        mWbm.registerForRttStatusChange(mHandler, 1);
-        mWbm.requestRttCheck();
-        verifyResultAs(false);
-    }
-
-    @Test
-    public void testRttWhenNoConfigurations() throws InterruptedException {
-        mWbm.registerForRttStatusChange(mHandler, 1);
-        captureNetworkCallback();
-        mCallback.onAvailable(mMockNetwork);
-        mWbm.requestRttCheck();
-        verifyResultAs(true);
-    }
-
-    @Test
-    public void testRttPassed_v4() throws InterruptedException {
-        mRttConfigs = new int[] {5, 200, 32, 100, 60000};
-        InputStream stream =
-                new ByteArrayInputStream(getCommandOutputs()[0].getBytes(StandardCharsets.UTF_8));
-        doReturn(stream).when(mProcessV4).getInputStream();
-
-        mWbm.registerForRttStatusChange(mHandler, 1);
-        captureNetworkCallback();
-        mCallback.onAvailable(mMockNetwork);
-        mWbm.requestRttCheck();
-        verifyResultAs(true);
-    }
-
-    @Test
-    public void testRtt_v4Failed_v6Passed() throws InterruptedException {
-        mRttConfigs = new int[] {5, 200, 32, 70, 60000};
-        InputStream stream_v4 =
-                new ByteArrayInputStream(getCommandOutputs()[0].getBytes(StandardCharsets.UTF_8));
-        InputStream stream_v6 =
-                new ByteArrayInputStream(getCommandOutputs()[1].getBytes(StandardCharsets.UTF_8));
-        doReturn(stream_v4).when(mProcessV4).getInputStream();
-        doReturn(stream_v6).when(mProcessV6).getInputStream();
-
-        mWbm.registerForRttStatusChange(mHandler, 1);
-        captureNetworkCallback();
-        mCallback.onAvailable(mMockNetwork);
-        mWbm.requestRttCheck();
-        verifyResultAs(true);
-    }
-
-    @Test
-    public void testRtt_v4v6Failed() throws InterruptedException {
-        mRttConfigs = new int[] {5, 200, 32, 60, 60000};
-        InputStream stream_v4 =
-                new ByteArrayInputStream(getCommandOutputs()[0].getBytes(StandardCharsets.UTF_8));
-        InputStream stream_v6 =
-                new ByteArrayInputStream(getCommandOutputs()[1].getBytes(StandardCharsets.UTF_8));
-        doReturn(stream_v4).when(mProcessV4).getInputStream();
-        doReturn(stream_v6).when(mProcessV6).getInputStream();
-
-        mWbm.registerForRttStatusChange(mHandler, 1);
-        captureNetworkCallback();
-        mCallback.onAvailable(mMockNetwork);
-        mWbm.requestRttCheck();
-        verifyResultAs(false);
-    }
-
-    @Test
-    public void testRttSchedulingStart() {
-        mRttConfigs = new int[] {5, 200, 32, 100, 60000};
-        mWbm.registerForRttStatusChange(mHandler, 1);
-        mRttHandler = captureHandler();
-        captureNetworkCallback();
-        mCallback.onAvailable(mMockNetwork);
-        mWbm.setCellularAvailable(true);
-        Message.obtain(
-                        mRttHandler,
-                        EVENT_IMS_REGISTRATION_STATE_CHANGED,
-                        new QnsAsyncResult(
-                                null,
-                                new QnsImsManager.ImsRegistrationState(
-                                        QnsConstants.IMS_REGISTRATION_CHANGED_REGISTERED,
-                                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                                        null),
-                                null))
-                .sendToTarget();
-        waitForDelayedHandlerAction(mRttHandler, 100, 100);
-        assertNotEquals(mWbm.getRttTimerId(), INVALID_ID);
-    }
-
-    @Test
-    public void testRttSchedulingStop_WifiOff() {
-        testRttSchedulingStart();
-        mCallback.onLost(mMockNetwork);
-        assertFalse(mRttHandler.hasMessages(EVENT_START_RTT_CHECK));
-    }
-
-    @Test
-    public void testRttSchedulingStop_NoCellular() {
-        testRttSchedulingStart();
-        mWbm.setCellularAvailable(false);
-        assertFalse(mRttHandler.hasMessages(EVENT_START_RTT_CHECK));
-    }
-
-    @Test
-    public void testRttSchedulingStop_VoWifiDisconnected() {
-        testRttSchedulingStart();
-        Message.obtain(
-                        mRttHandler,
-                        EVENT_IMS_REGISTRATION_STATE_CHANGED,
-                        new QnsAsyncResult(
-                                null,
-                                new QnsImsManager.ImsRegistrationState(
-                                        QnsConstants.IMS_REGISTRATION_CHANGED_UNREGISTERED,
-                                        AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
-                                        null),
-                                null))
-                .sendToTarget();
-        waitForDelayedHandlerAction(mRttHandler, 100, 100);
-        assertFalse(mRttHandler.hasMessages(EVENT_START_RTT_CHECK));
-    }
-
-    @Test
-    public void testRttSchedulingStop_VoLTEConnected() {
-        testRttSchedulingStart();
-        Message.obtain(
-                        mRttHandler,
-                        EVENT_IMS_REGISTRATION_STATE_CHANGED,
-                        new QnsAsyncResult(
-                                null,
-                                new QnsImsManager.ImsRegistrationState(
-                                        QnsConstants.IMS_REGISTRATION_CHANGED_REGISTERED,
-                                        AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
-                                        null),
-                                null))
-                .sendToTarget();
-        waitForDelayedHandlerAction(mRttHandler, 100, 100);
-        assertFalse(mRttHandler.hasMessages(EVENT_START_RTT_CHECK));
-    }
-
-    private void verifyResultAs(boolean expected) throws InterruptedException {
-        assertTrue(mLatch.await(1000, TimeUnit.MILLISECONDS));
-        assertNotNull(mAsyncResult);
-        assertEquals(expected, mAsyncResult.mResult);
-    }
-
-    private String[] getCommandOutputs() {
-        return new String[] {
-            "PING www.google.com (172.217.163.196) from 172.20.10.2 wlan0: 32(60) bytes of"
-                    + " data.\n"
-                    + "40 bytes from maa05s06-in-f4.1e100.net (172.217.163.196): icmp_seq=1"
-                    + " ttl=53 time=119 ms\n"
-                    + "40 bytes from maa05s06-in-f4.1e100.net (172.217.163.196): icmp_seq=2"
-                    + " ttl=53 time=110 ms\n"
-                    + "40 bytes from maa05s06-in-f4.1e100.net (172.217.163.196): icmp_seq=3"
-                    + " ttl=53 time=66.8 ms\n"
-                    + "40 bytes from maa05s06-in-f4.1e100.net (172.217.163.196): icmp_seq=4"
-                    + " ttl=53 time=63.7 ms\n"
-                    + "40 bytes from maa05s06-in-f4.1e100.net (172.217.163.196): icmp_seq=5"
-                    + " ttl=53 time=49.9 ms\n"
-                    + "\n"
-                    + "--- www.google.com ping statistics ---\n"
-                    + "5 packets transmitted, 5 received, 0% packet loss, time 805ms\n"
-                    + "rtt min/avg/max/mdev = 49.952/80.066/119.469/27.539 ms",
-            "PING maa05s21-in-x04.1e100.net(maa05s21-in-x04.1e100.net) 56 data bytes\n"
-                    + "64 bytes from maa05s21-in-x04.1e100.net: icmp_seq=1 ttl=56 time=56.0"
-                    + " ms\n"
-                    + "64 bytes from maa05s21-in-x04.1e100.net: icmp_seq=2 ttl=56 time=54.3"
-                    + " ms\n"
-                    + "64 bytes from maa05s21-in-x04.1e100.net: icmp_seq=3 ttl=56 time=51.2"
-                    + " ms\n"
-                    + "64 bytes from maa05s21-in-x04.1e100.net: icmp_seq=4 ttl=56 time=89.2"
-                    + " ms\n"
-                    + "64 bytes from maa05s21-in-x04.1e100.net: icmp_seq=5 ttl=56 time=88.0"
-                    + " ms\n"
-                    + "\n"
-                    + "--- maa05s21-in-x04.1e100.net ping statistics ---\n"
-                    + "5 packets transmitted, 5 received, 0% packet loss, time 807ms\n"
-                    + "rtt min/avg/max/mdev = 51.282/65.793/89.228/17.110 ms"
-        };
-    }
-
-    private void captureNetworkCallback() {
-        ArgumentCaptor<NetworkCallback> argumentCaptor =
-                ArgumentCaptor.forClass(NetworkCallback.class);
-        verify(mMockConnectivityManager)
-                .registerNetworkCallback(isA(NetworkRequest.class), argumentCaptor.capture());
-        mCallback = argumentCaptor.getValue();
-    }
-
-    private Handler captureHandler() {
-        ArgumentCaptor<Handler> argumentCaptor = ArgumentCaptor.forClass(Handler.class);
-        verify(mMockQnsImsManager)
-                .registerImsRegistrationStatusChanged(argumentCaptor.capture(), anyInt());
-        return argumentCaptor.getValue();
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/WifiQualityMonitorTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/WifiQualityMonitorTest.java
deleted file mode 100644
index 8e51d2c..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/WifiQualityMonitorTest.java
+++ /dev/null
@@ -1,366 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns;
-
-import static android.net.NetworkCapabilities.SIGNAL_STRENGTH_UNSPECIFIED;
-
-import static com.android.telephony.qns.QualityMonitor.EVENT_WIFI_NOTIFY_TIMER_EXPIRED;
-import static com.android.telephony.qns.QualityMonitor.EVENT_WIFI_RSSI_CHANGED;
-import static com.android.telephony.qns.WifiQualityMonitor.INVALID_RSSI;
-
-import static org.junit.Assert.*;
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.*;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.when;
-
-import android.content.Context;
-import android.net.ConnectivityManager;
-import android.net.Network;
-import android.net.NetworkCapabilities;
-import android.net.wifi.WifiInfo;
-import android.net.wifi.WifiManager;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.SignalThresholdInfo;
-
-import androidx.test.core.app.ApplicationProvider;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.Executor;
-
-@RunWith(JUnit4.class)
-public class WifiQualityMonitorTest extends QnsTest {
-
-    private static final int EVENT_QNS_TIMER_EXPIRED = 1;
-    Context mContext;
-    @Mock ConnectivityManager mConnectivityManager;
-    QnsTimer mQnsTimer;
-    @Mock WifiManager mWifiManager;
-    @Mock NetworkCapabilities mNetworkCapabilityManager;
-    @Mock private Network mMockNetwork;
-    private WifiInfo mWifiInfo;
-    private WifiQualityMonitor mWifiQualityMonitor;
-    private Threshold[] mRetThresholds;
-    Threshold[] mThs1 = new Threshold[1];
-    Threshold[] mThs2 = new Threshold[1];
-    Threshold[] mThs3 = new Threshold[1];
-    int mSetRssi = -120;
-
-    CountDownLatch mLatch;
-    ThresholdListener mThresholdListener;
-
-    private class ThresholdListener extends ThresholdCallback
-            implements ThresholdCallback.WifiThresholdListener {
-
-        ThresholdListener(Executor executor) {
-            this.init(executor);
-        }
-
-        @Override
-        public void onWifiThresholdChanged(Threshold[] thresholds) {
-            mRetThresholds = thresholds;
-            mLatch.countDown();
-        }
-    }
-
-    Executor mExecutor = runnable -> new Thread(runnable).start();
-
-    @Before
-    public void setUp() {
-        MockitoAnnotations.initMocks(this);
-        mContext = spy(ApplicationProvider.getApplicationContext());
-        when(mContext.getSystemService(ConnectivityManager.class)).thenReturn(mConnectivityManager);
-        when(mContext.getSystemService(WifiManager.class)).thenReturn(mWifiManager);
-        when(mContext.getSystemService(NetworkCapabilities.class))
-                .thenReturn(mNetworkCapabilityManager);
-        mWifiInfo = new WifiInfo.Builder().setRssi(mSetRssi).build();
-        mLatch = new CountDownLatch(1);
-        mThresholdListener = new ThresholdListener(mExecutor);
-        mQnsTimer = new QnsTimer(mContext);
-        mWifiQualityMonitor = new WifiQualityMonitor(mContext, mQnsTimer);
-    }
-
-    @Test
-    public void testGetCurrentQuality() {
-        when(mWifiManager.getConnectionInfo()).thenReturn(mWifiInfo);
-        int recv_rssi =
-                mWifiQualityMonitor.getCurrentQuality(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI);
-        assertEquals(mSetRssi, recv_rssi);
-    }
-
-    @Test
-    public void testRegisterThresholdChange_RoveIn() throws InterruptedException {
-        when(mWifiManager.getConnectionInfo()).thenReturn(mWifiInfo);
-        mThs1[0] =
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                        -100,
-                        QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER);
-        mThs2[0] =
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                        -80,
-                        QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER);
-        mWifiQualityMonitor.registerThresholdChange(
-                mThresholdListener, NetworkCapabilities.NET_CAPABILITY_IMS, mThs1, 0);
-        mWifiQualityMonitor.registerThresholdChange(
-                mThresholdListener, NetworkCapabilities.NET_CAPABILITY_XCAP, mThs2, 0);
-        int regThreshold = mWifiQualityMonitor.getRegisteredThreshold();
-        // smaller threshold should register
-        assertEquals(mThs1[0].getThreshold(), regThreshold);
-    }
-
-    @Test
-    public void testUnregisterThresholdChange_RoveIn() throws InterruptedException {
-        testRegisterThresholdChange_RoveIn();
-        mWifiQualityMonitor.unregisterThresholdChange(NetworkCapabilities.NET_CAPABILITY_IMS, 0);
-        int regThreshold = mWifiQualityMonitor.getRegisteredThreshold();
-        assertEquals(mThs2[0].getThreshold(), regThreshold);
-    }
-
-    @Test
-    public void testRegisterThresholdChange_RoveOut() {
-        when(mWifiManager.getConnectionInfo()).thenReturn(mWifiInfo);
-        mThs1[0] =
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                        -100,
-                        QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER);
-        mThs2[0] =
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                        -80,
-                        QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER);
-        mWifiQualityMonitor.registerThresholdChange(
-                mThresholdListener, NetworkCapabilities.NET_CAPABILITY_IMS, mThs1, 0);
-        mWifiQualityMonitor.registerThresholdChange(
-                mThresholdListener, NetworkCapabilities.NET_CAPABILITY_XCAP, mThs2, 0);
-        int regThreshold = mWifiQualityMonitor.getRegisteredThreshold();
-        // bigger threshold should register
-        assertEquals(mThs2[0].getThreshold(), regThreshold);
-    }
-
-    @Test
-    public void testUnregisterThresholdChange_RoveOut() throws InterruptedException {
-        testRegisterThresholdChange_RoveOut();
-        mWifiQualityMonitor.unregisterThresholdChange(NetworkCapabilities.NET_CAPABILITY_XCAP, 0);
-        int regThreshold = mWifiQualityMonitor.getRegisteredThreshold();
-        assertEquals(mThs1[0].getThreshold(), regThreshold);
-
-        mWifiQualityMonitor.unregisterThresholdChange(NetworkCapabilities.NET_CAPABILITY_IMS, 0);
-        regThreshold = mWifiQualityMonitor.getRegisteredThreshold();
-        assertEquals(SIGNAL_STRENGTH_UNSPECIFIED, regThreshold);
-    }
-
-    @Test
-    public void testUpdateThresholdsForNetCapability_RoveIn_Add() throws InterruptedException {
-        testRegisterThresholdChange_RoveIn();
-        mThs3[0] =
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                        -110,
-                        QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER);
-        mWifiQualityMonitor.updateThresholdsForNetCapability(
-                NetworkCapabilities.NET_CAPABILITY_IMS, 0, mThs3);
-        int regThreshold = mWifiQualityMonitor.getRegisteredThreshold();
-        assertEquals(mThs3[0].getThreshold(), regThreshold);
-    }
-
-    @Test
-    public void testUpdateThresholdsForNetCapability_RoveIn_Remove() throws InterruptedException {
-        testUpdateThresholdsForNetCapability_RoveIn_Add();
-        mWifiQualityMonitor.updateThresholdsForNetCapability(
-                NetworkCapabilities.NET_CAPABILITY_IMS, 0, null);
-        int regThreshold = mWifiQualityMonitor.getRegisteredThreshold();
-        assertEquals(mThs2[0].getThreshold(), regThreshold);
-    }
-
-    @Test
-    public void testUpdateThresholdsForNetCapability_RoveOut_Add() {
-        testRegisterThresholdChange_RoveOut();
-        mThs3[0] =
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                        -75,
-                        QnsConstants.THRESHOLD_EQUAL_OR_SMALLER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER);
-        mWifiQualityMonitor.updateThresholdsForNetCapability(
-                NetworkCapabilities.NET_CAPABILITY_IMS, 0, mThs3);
-        int regThreshold = mWifiQualityMonitor.getRegisteredThreshold();
-        assertEquals(mThs3[0].getThreshold(), regThreshold);
-    }
-
-    @Test
-    public void testUpdateThresholdsForNetCapability_RoveOut_Remove() {
-        testRegisterThresholdChange_RoveOut();
-        mWifiQualityMonitor.updateThresholdsForNetCapability(
-                NetworkCapabilities.NET_CAPABILITY_IMS, 0, null);
-        int regThreshold = mWifiQualityMonitor.getRegisteredThreshold();
-        assertEquals(mThs2[0].getThreshold(), regThreshold);
-    }
-
-    @Test
-    public void testBackhaulTimer() {
-        mSetRssi = -65;
-        mLatch = new CountDownLatch(1);
-        mWifiInfo = new WifiInfo.Builder().setRssi(mSetRssi).build();
-        when(mWifiManager.getConnectionInfo()).thenReturn(mWifiInfo);
-        mThs1[0] =
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                        -100,
-                        QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER);
-        mThs2[0] =
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                        -80,
-                        QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER);
-        mThs3 =
-                new Threshold[] {
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.IWLAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                            -70,
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER),
-                    new Threshold(
-                            AccessNetworkConstants.AccessNetworkType.IWLAN,
-                            SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                            -68,
-                            QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                            QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER)
-                };
-        mWifiQualityMonitor.registerThresholdChange(
-                mThresholdListener, NetworkCapabilities.NET_CAPABILITY_IMS, mThs1, 0);
-        mWifiQualityMonitor.registerThresholdChange(
-                mThresholdListener, NetworkCapabilities.NET_CAPABILITY_XCAP, mThs1, 0);
-        mWifiQualityMonitor.registerThresholdChange(
-                mThresholdListener, NetworkCapabilities.NET_CAPABILITY_EIMS, mThs2, 0);
-        mWifiQualityMonitor.registerThresholdChange(
-                mThresholdListener, NetworkCapabilities.NET_CAPABILITY_MMS, mThs3, 0);
-
-        mWifiQualityMonitor.mHandler.obtainMessage(EVENT_WIFI_RSSI_CHANGED, -65, 0).sendToTarget();
-        waitForDelayedHandlerAction(mWifiQualityMonitor.mHandler, 1000, 200);
-        assertTrue(mQnsTimer.mHandler.hasMessages(EVENT_QNS_TIMER_EXPIRED));
-        waitForDelayedHandlerAction(mWifiQualityMonitor.mHandler, 4000, 200);
-        assertFalse(mQnsTimer.mHandler.hasMessages(EVENT_QNS_TIMER_EXPIRED));
-        assertFalse(mWifiQualityMonitor.mHandler.hasMessages(EVENT_WIFI_NOTIFY_TIMER_EXPIRED));
-    }
-
-    @Test
-    public void testValidateWqmStatus_ValidRange() {
-        mSetRssi = -65;
-        mLatch = new CountDownLatch(1);
-        mWifiInfo = new WifiInfo.Builder().setRssi(mSetRssi).build();
-        when(mWifiManager.getConnectionInfo()).thenReturn(mWifiInfo);
-
-        setWqmThreshold();
-        mWifiQualityMonitor.validateWqmStatus(-65);
-        assertTrue(mWifiQualityMonitor.mHandler.hasMessages(EVENT_WIFI_RSSI_CHANGED));
-    }
-
-    @Test
-    public void testValidateWqmStatus_InValidRssiWithValidThreshold() {
-        mSetRssi = -65;
-        mLatch = new CountDownLatch(1);
-        mWifiInfo = new WifiInfo.Builder().setRssi(mSetRssi).build();
-        when(mWifiManager.getConnectionInfo()).thenReturn(mWifiInfo);
-
-        setWqmThreshold();
-
-        mWifiQualityMonitor.validateWqmStatus(SIGNAL_STRENGTH_UNSPECIFIED);
-        isWifiRssiChangedHandlerNotPosted();
-
-        mWifiQualityMonitor.validateWqmStatus(INVALID_RSSI);
-        isWifiRssiChangedHandlerNotPosted();
-
-        mWifiQualityMonitor.validateWqmStatus(50);
-        isWifiRssiChangedHandlerNotPosted();
-    }
-
-    @Test
-    public void testValidateWqmStatus_ValidRssiWithInValidThreshold() {
-        mThs1[0] =
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                        SIGNAL_STRENGTH_UNSPECIFIED,
-                        QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER);
-        mWifiQualityMonitor.registerThresholdChange(
-                mThresholdListener, NetworkCapabilities.NET_CAPABILITY_IMS, mThs1, 0);
-
-        mWifiQualityMonitor.validateWqmStatus(-65);
-        isWifiRssiChangedHandlerNotPosted();
-    }
-
-    private void setWqmThreshold() {
-        mThs1[0] =
-                new Threshold(
-                        AccessNetworkConstants.AccessNetworkType.IWLAN,
-                        SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI,
-                        -70,
-                        QnsConstants.THRESHOLD_EQUAL_OR_LARGER,
-                        QnsConstants.DEFAULT_WIFI_BACKHAUL_TIMER);
-        mWifiQualityMonitor.registerThresholdChange(
-                mThresholdListener, NetworkCapabilities.NET_CAPABILITY_IMS, mThs1, 0);
-    }
-
-    private void isWifiRssiChangedHandlerNotPosted() {
-        waitForDelayedHandlerAction(mWifiQualityMonitor.mHandler, 1000, 200);
-        assertFalse(mWifiQualityMonitor.mHandler.hasMessages(EVENT_WIFI_RSSI_CHANGED));
-    }
-
-    @Test
-    public void testUpdateThresholdsForNetCapabilityException() {
-        assertThrows(
-                IllegalStateException.class,
-                () ->
-                        mWifiQualityMonitor.updateThresholdsForNetCapability(
-                                NetworkCapabilities.NET_CAPABILITY_IMS, 0, mThs1));
-    }
-
-    @After
-    public void tearDown() {
-        mWifiQualityMonitor.close();
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/atoms/AtomsQnsFallbackRestrictionChangedInfoTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/atoms/AtomsQnsFallbackRestrictionChangedInfoTest.java
deleted file mode 100644
index 159ab07..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/atoms/AtomsQnsFallbackRestrictionChangedInfoTest.java
+++ /dev/null
@@ -1,261 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns.atoms;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.ArgumentMatchers.anyBoolean;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
-import android.util.StatsEvent;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-@RunWith(JUnit4.class)
-public class AtomsQnsFallbackRestrictionChangedInfoTest {
-
-    @Mock
-    private StatsEvent.Builder mStatsEventBuilder;
-
-    private static final boolean DEFAULT_RESTRICTION_WLAN_RTP_THRESHOLD_BREACHED = true;
-    private static final boolean DEFAULT_RESTRICTION_WWAN_RTP_THRESHOLD_BREACHED = true;
-    private static final boolean DEFAULT_RESTRICTION_WWAN_IMS_REGI_FAIL = true;
-    private static final boolean DEFAULT_RESTRICTION_WWAN_WIFI_BACKHAUL_PROBLEM = true;
-    private static final int DEFAULT_CARRIER_ID = 1; // TMO
-
-    private AtomsQnsFallbackRestrictionChangedInfo mInfoEmpty;
-    private AtomsQnsFallbackRestrictionChangedInfo mInfoDefault;
-    private AtomsQnsFallbackRestrictionChangedInfo mInfoCopy;
-
-    /** atom #1 : Restriction on WLAN caused by RTP threshold breached */
-    private boolean mRestrictionWlanRtpThresholdBreached;
-
-    /** atom #2 : Restriction on WWAN caused by RTP threshold breached */
-    private boolean mRestrictionWwanRtpThresholdBreached;
-
-    /** atom #3 : Restriction on WLAN caused by IMS registration fail */
-    private boolean mRestrictionWwanImsRegiFail;
-
-    /** atom #4 : Restriction on WLAN caused by Wifi backhaul problem. */
-    private boolean mRestrictionWwanWifiBackhaulProblem;
-
-    /** atom #5 : Carrier Id */
-    private int mCarrierId;
-
-    /** atom #6 : Slot Index */
-    private int mSlotIndex;
-
-    @Before
-    public void setUp() {
-        MockitoAnnotations.initMocks(this);
-        mRestrictionWlanRtpThresholdBreached = DEFAULT_RESTRICTION_WLAN_RTP_THRESHOLD_BREACHED;
-        mRestrictionWwanRtpThresholdBreached = DEFAULT_RESTRICTION_WWAN_RTP_THRESHOLD_BREACHED;
-        mRestrictionWwanImsRegiFail = DEFAULT_RESTRICTION_WWAN_IMS_REGI_FAIL;
-        mRestrictionWwanWifiBackhaulProblem = DEFAULT_RESTRICTION_WWAN_WIFI_BACKHAUL_PROBLEM;
-        mCarrierId = DEFAULT_CARRIER_ID;
-        mSlotIndex = 0;
-        mInfoEmpty = new AtomsQnsFallbackRestrictionChangedInfo();
-        mInfoDefault =
-                new AtomsQnsFallbackRestrictionChangedInfo(
-                        mRestrictionWlanRtpThresholdBreached,
-                        mRestrictionWwanRtpThresholdBreached,
-                        mRestrictionWwanImsRegiFail,
-                        mRestrictionWwanWifiBackhaulProblem,
-                        mCarrierId,
-                        mSlotIndex);
-        mInfoCopy = new AtomsQnsFallbackRestrictionChangedInfo(mInfoDefault);
-    }
-
-    @After
-    public void tearDown() {
-        mInfoEmpty = null;
-        mInfoDefault = null;
-        mInfoCopy = null;
-    }
-
-    @Test
-    public void testGetSetRestrictionWlanRtpThresholdBreached() {
-        assertFalse(mInfoEmpty.getRestrictionOnWlanByRtpThresholdBreached());
-        assertTrue(mInfoDefault.getRestrictionOnWlanByRtpThresholdBreached());
-        assertTrue(mInfoCopy.getRestrictionOnWlanByRtpThresholdBreached());
-
-        mInfoEmpty.setRestrictionOnWlanByRtpThresholdBreached(true);
-        mInfoDefault.setRestrictionOnWlanByRtpThresholdBreached(true);
-        mInfoCopy.setRestrictionOnWlanByRtpThresholdBreached(true);
-
-        assertTrue(mInfoEmpty.getRestrictionOnWlanByRtpThresholdBreached());
-        assertTrue(mInfoDefault.getRestrictionOnWlanByRtpThresholdBreached());
-        assertTrue(mInfoCopy.getRestrictionOnWlanByRtpThresholdBreached());
-    }
-
-    @Test
-    public void testGetSetRestrictionWwanRtpThresholdBreached() {
-        assertFalse(mInfoEmpty.getRestrictionOnWwanByRtpThresholdBreached());
-        assertTrue(mInfoDefault.getRestrictionOnWwanByRtpThresholdBreached());
-        assertTrue(mInfoCopy.getRestrictionOnWwanByRtpThresholdBreached());
-
-        mInfoEmpty.setRestrictionOnWwanByRtpThresholdBreached(true);
-        mInfoDefault.setRestrictionOnWwanByRtpThresholdBreached(true);
-        mInfoCopy.setRestrictionOnWwanByRtpThresholdBreached(true);
-
-        assertTrue(mInfoEmpty.getRestrictionOnWwanByRtpThresholdBreached());
-        assertTrue(mInfoDefault.getRestrictionOnWwanByRtpThresholdBreached());
-        assertTrue(mInfoCopy.getRestrictionOnWwanByRtpThresholdBreached());
-    }
-
-    @Test
-    public void testGetSetRestrictionWwanImsRegiFail() {
-        assertFalse(mInfoEmpty.getRestrictionOnWlanByImsRegistrationFailed());
-        assertTrue(mInfoDefault.getRestrictionOnWlanByImsRegistrationFailed());
-        assertTrue(mInfoCopy.getRestrictionOnWlanByImsRegistrationFailed());
-
-        mInfoEmpty.setRestrictionOnWlanByImsRegistrationFailed(true);
-        mInfoDefault.setRestrictionOnWlanByImsRegistrationFailed(true);
-        mInfoCopy.setRestrictionOnWlanByImsRegistrationFailed(true);
-
-        assertTrue(mInfoEmpty.getRestrictionOnWlanByImsRegistrationFailed());
-        assertTrue(mInfoDefault.getRestrictionOnWlanByImsRegistrationFailed());
-        assertTrue(mInfoCopy.getRestrictionOnWlanByImsRegistrationFailed());
-    }
-
-    @Test
-    public void testGetSetRestrictionWwanWifiBackhaulProblem() {
-        assertFalse(mInfoEmpty.getRestrictionOnWlanByWifiBackhaulProblem());
-        assertTrue(mInfoDefault.getRestrictionOnWlanByWifiBackhaulProblem());
-        assertTrue(mInfoCopy.getRestrictionOnWlanByWifiBackhaulProblem());
-
-        mInfoEmpty.setRestrictionOnWlanByWifiBackhaulProblem(true);
-        mInfoDefault.setRestrictionOnWlanByWifiBackhaulProblem(true);
-        mInfoCopy.setRestrictionOnWlanByWifiBackhaulProblem(true);
-
-        assertTrue(mInfoEmpty.getRestrictionOnWlanByWifiBackhaulProblem());
-        assertTrue(mInfoDefault.getRestrictionOnWlanByWifiBackhaulProblem());
-        assertTrue(mInfoCopy.getRestrictionOnWlanByWifiBackhaulProblem());
-    }
-
-    @Test
-    public void testGetSetCarrierId() {
-        assertEquals(0, mInfoEmpty.getCarrierId());
-        assertEquals(DEFAULT_CARRIER_ID, mInfoDefault.getCarrierId());
-        assertEquals(DEFAULT_CARRIER_ID, mInfoCopy.getCarrierId());
-
-        mInfoEmpty.setCarrierId(1);
-        mInfoDefault.setCarrierId(2);
-        mInfoCopy.setCarrierId(3);
-
-        assertEquals(1, mInfoEmpty.getCarrierId());
-        assertEquals(2, mInfoDefault.getCarrierId());
-        assertEquals(3, mInfoCopy.getCarrierId());
-    }
-
-    @Test
-    public void testGetSetSlotIndex() {
-        assertEquals(0, mInfoEmpty.getSlotIndex());
-        assertEquals(0, mInfoDefault.getSlotIndex());
-        assertEquals(0, mInfoCopy.getSlotIndex());
-
-        mInfoEmpty.setSlotIndex(1);
-        mInfoDefault.setSlotIndex(2);
-        mInfoCopy.setSlotIndex(3);
-
-        assertEquals(1, mInfoEmpty.getSlotIndex());
-        assertEquals(2, mInfoDefault.getSlotIndex());
-        assertEquals(3, mInfoCopy.getSlotIndex());
-    }
-
-    @Test
-    public void testToString() {
-        String strInfoEmpty = mInfoEmpty.toString();
-        String strInfoDefault = mInfoDefault.toString();
-        String strInfoCopy = mInfoCopy.toString();
-
-        assertNotNull(strInfoEmpty);
-        assertNotNull(strInfoDefault);
-        assertNotNull(strInfoCopy);
-
-        assertTrue(strInfoDefault.startsWith("AtomsQnsFallbackRestrictionChangedInfo"));
-
-        assertEquals(strInfoDefault, strInfoCopy);
-        assertNotEquals(strInfoEmpty, strInfoDefault);
-    }
-
-    @Test
-    public void testEquals() {
-        assertEquals(mInfoDefault, mInfoDefault);
-        assertNotEquals(mInfoDefault, new Object());
-        assertEquals(mInfoDefault, mInfoCopy);
-        mInfoDefault.setRestrictionOnWlanByRtpThresholdBreached(false);
-        mInfoCopy.setRestrictionOnWlanByRtpThresholdBreached(true);
-        assertNotEquals(mInfoDefault, mInfoCopy);
-    }
-
-    @Test
-    public void testHashCode() {
-        AtomsQnsFallbackRestrictionChangedInfo a1, a2;
-
-        a1 =
-                new AtomsQnsFallbackRestrictionChangedInfo(
-                        true, true, false, false, mCarrierId, mSlotIndex);
-        a2 =
-                new AtomsQnsFallbackRestrictionChangedInfo(
-                        false, false, false, false, mCarrierId, mSlotIndex);
-        assertNotEquals(a1.hashCode(), a2.hashCode());
-
-        a1 =
-                new AtomsQnsFallbackRestrictionChangedInfo(
-                        mRestrictionWlanRtpThresholdBreached,
-                        mRestrictionWwanRtpThresholdBreached,
-                        mRestrictionWwanImsRegiFail,
-                        mRestrictionWwanWifiBackhaulProblem,
-                        mCarrierId,
-                        mSlotIndex);
-        a2 =
-                new AtomsQnsFallbackRestrictionChangedInfo(
-                        mRestrictionWlanRtpThresholdBreached,
-                        mRestrictionWwanRtpThresholdBreached,
-                        mRestrictionWwanImsRegiFail,
-                        mRestrictionWwanWifiBackhaulProblem,
-                        mCarrierId,
-                        mSlotIndex);
-        assertEquals(a1.hashCode(), a2.hashCode());
-    }
-
-    @Test
-    public void testStatsId() {
-        final int statsId = 636; // QnsFallbackRestrictionChanged
-        assertEquals(statsId, mInfoDefault.copy().getStatsId());
-    }
-
-    @Test
-    public void testStatsEventBuilder() {
-        mInfoDefault.build(mStatsEventBuilder);
-
-        verify(mStatsEventBuilder, times(4)).writeBoolean(anyBoolean());
-        verify(mStatsEventBuilder, times(2)).writeInt(anyInt());
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/atoms/AtomsQnsHandoverPingPongInfoTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/atoms/AtomsQnsHandoverPingPongInfoTest.java
deleted file mode 100644
index e914579..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/atoms/AtomsQnsHandoverPingPongInfoTest.java
+++ /dev/null
@@ -1,191 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns.atoms;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
-import android.util.StatsEvent;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-@RunWith(JUnit4.class)
-public class AtomsQnsHandoverPingPongInfoTest {
-
-    @Mock
-    private StatsEvent.Builder mStatsEventBuilder;
-
-    private static final int DEFAULT_COUNT_HANDOVER_PING_PONG = 2;
-    private static final int DEFAULT_CARRIER_ID = 1; // TMO
-
-    private AtomsQnsHandoverPingPongInfo mInfoEmpty;
-    private AtomsQnsHandoverPingPongInfo mInfoDefault;
-    private AtomsQnsHandoverPingPongInfo mInfoCopy;
-
-    /** atom #1 : Count of handover ping-pong */
-    private int mCountHandoverPingPong;
-
-    /** atom #2 : Carrier Id */
-    private int mCarrierId;
-
-    /** atom #3 : Slot Index */
-    private int mSlotIndex;
-
-    @Before
-    public void setUp() {
-        MockitoAnnotations.initMocks(this);
-        mCountHandoverPingPong = DEFAULT_COUNT_HANDOVER_PING_PONG;
-        mCarrierId = DEFAULT_CARRIER_ID;
-        mSlotIndex = 0;
-        mInfoEmpty = new AtomsQnsHandoverPingPongInfo();
-        mInfoDefault =
-                new AtomsQnsHandoverPingPongInfo(mCountHandoverPingPong, mCarrierId, mSlotIndex);
-        mInfoCopy = new AtomsQnsHandoverPingPongInfo(mInfoDefault);
-    }
-
-    @After
-    public void tearDown() {
-        mInfoEmpty = null;
-        mInfoDefault = null;
-        mInfoCopy = null;
-    }
-
-    @Test
-    public void testGetSetCountHandoverPingPong() {
-        assertEquals(0, mInfoEmpty.getCountHandoverPingPong());
-        assertEquals(DEFAULT_COUNT_HANDOVER_PING_PONG, mInfoDefault.getCountHandoverPingPong());
-        assertEquals(DEFAULT_COUNT_HANDOVER_PING_PONG, mInfoCopy.getCountHandoverPingPong());
-
-        mInfoEmpty.setCountHandoverPingPong(3);
-        mInfoDefault.setCountHandoverPingPong(4);
-        mInfoCopy.setCountHandoverPingPong(5);
-
-        assertEquals(3, mInfoEmpty.getCountHandoverPingPong());
-        assertEquals(4, mInfoDefault.getCountHandoverPingPong());
-        assertEquals(5, mInfoCopy.getCountHandoverPingPong());
-    }
-
-    @Test
-    public void testGetSetCarrierId() {
-        assertEquals(0, mInfoEmpty.getCarrierId());
-        assertEquals(DEFAULT_CARRIER_ID, mInfoDefault.getCarrierId());
-        assertEquals(DEFAULT_CARRIER_ID, mInfoCopy.getCarrierId());
-
-        mInfoEmpty.setCarrierId(1);
-        mInfoDefault.setCarrierId(2);
-        mInfoCopy.setCarrierId(3);
-
-        assertEquals(1, mInfoEmpty.getCarrierId());
-        assertEquals(2, mInfoDefault.getCarrierId());
-        assertEquals(3, mInfoCopy.getCarrierId());
-    }
-
-    @Test
-    public void testGetSetSlotIndex() {
-        assertEquals(0, mInfoEmpty.getSlotIndex());
-        assertEquals(0, mInfoDefault.getSlotIndex());
-        assertEquals(0, mInfoCopy.getSlotIndex());
-
-        mInfoEmpty.setSlotIndex(1);
-        mInfoDefault.setSlotIndex(2);
-        mInfoCopy.setSlotIndex(3);
-
-        assertEquals(1, mInfoEmpty.getSlotIndex());
-        assertEquals(2, mInfoDefault.getSlotIndex());
-        assertEquals(3, mInfoCopy.getSlotIndex());
-    }
-
-    @Test
-    public void testToString() {
-        String strInfoEmpty = mInfoEmpty.toString();
-        String strInfoDefault = mInfoDefault.toString();
-        String strInfoCopy = mInfoCopy.toString();
-
-        assertNotNull(strInfoEmpty);
-        assertNotNull(strInfoDefault);
-        assertNotNull(strInfoCopy);
-
-        assertTrue(strInfoDefault.startsWith("AtomsQnsHandoverPingPongInfo"));
-
-        assertEquals(strInfoDefault, strInfoCopy);
-        assertNotEquals(strInfoEmpty, strInfoDefault);
-    }
-
-    @Test
-    public void testEquals() {
-        assertEquals(mInfoDefault, mInfoDefault);
-        assertNotEquals(mInfoDefault, new Object());
-        assertEquals(mInfoDefault, mInfoCopy);
-        mInfoDefault.setCountHandoverPingPong(2);
-        mInfoCopy.setCountHandoverPingPong(3);
-        assertNotEquals(mInfoDefault, mInfoCopy);
-    }
-
-    @Test
-    public void testHashCode() {
-        AtomsQnsHandoverPingPongInfo a1, a2;
-
-        a1 = new AtomsQnsHandoverPingPongInfo(2, 1, 0);
-        a2 = new AtomsQnsHandoverPingPongInfo(3, 1, 0);
-        assertNotEquals(a1.hashCode(), a2.hashCode());
-
-        a1 = new AtomsQnsHandoverPingPongInfo(mCountHandoverPingPong, mCarrierId, mSlotIndex);
-        a2 = new AtomsQnsHandoverPingPongInfo(mCountHandoverPingPong, mCarrierId, mSlotIndex);
-        assertEquals(a1.hashCode(), a2.hashCode());
-    }
-
-    @Test
-    public void testDimension() {
-        AtomsQnsHandoverPingPongInfo a1, a2;
-
-        a1 = new AtomsQnsHandoverPingPongInfo(mCountHandoverPingPong, 3, mSlotIndex);
-        a2 = new AtomsQnsHandoverPingPongInfo(mCountHandoverPingPong, 1, mSlotIndex);
-        assertNotEquals(a1.getDimension(), a2.getDimension());
-
-        a1 = new AtomsQnsHandoverPingPongInfo(mCountHandoverPingPong, mCarrierId, 0);
-        a2 = new AtomsQnsHandoverPingPongInfo(mCountHandoverPingPong, mCarrierId, 1);
-        assertNotEquals(a1.getDimension(), a2.getDimension());
-
-        a1 = new AtomsQnsHandoverPingPongInfo(1, mCarrierId, mSlotIndex);
-        a2 = new AtomsQnsHandoverPingPongInfo(2, mCarrierId, mSlotIndex);
-        assertEquals(a1.getDimension(), a2.getDimension());
-    }
-
-    @Test
-    public void testStatsId() {
-        final int statsId = 10179; // QnsHandoverPingpong
-        assertEquals(statsId, mInfoDefault.copy().getStatsId());
-    }
-
-    @Test
-    public void testStatsEventBuilder() {
-        mInfoDefault.build(mStatsEventBuilder);
-
-        verify(mStatsEventBuilder, times(3)).writeInt(anyInt());
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/atoms/AtomsQnsHandoverTimeMillisInfoTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/atoms/AtomsQnsHandoverTimeMillisInfoTest.java
deleted file mode 100644
index 701874b..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/atoms/AtomsQnsHandoverTimeMillisInfoTest.java
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns.atoms;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
-import android.util.StatsEvent;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-@RunWith(JUnit4.class)
-public class AtomsQnsHandoverTimeMillisInfoTest {
-
-    @Mock
-    private StatsEvent.Builder mStatsEventBuilder;
-
-    private static final int DEFAULT_TIMER_FOR_HANDOVER_SUCCESS = 5000;
-
-    private AtomsQnsHandoverTimeMillisInfo mInfoEmpty;
-    private AtomsQnsHandoverTimeMillisInfo mInfoDefault;
-    private AtomsQnsHandoverTimeMillisInfo mInfoCopy;
-
-    /** atom #1 : Time in milliseconds from QNS RAT update to successful HO completion */
-    private int mTimeForHoSuccess;
-
-    /** atom #2 : Slot Index */
-    private int mSlotIndex;
-
-    @Before
-    public void setUp() {
-        MockitoAnnotations.initMocks(this);
-        mTimeForHoSuccess = DEFAULT_TIMER_FOR_HANDOVER_SUCCESS;
-        mSlotIndex = 0;
-        mInfoEmpty = new AtomsQnsHandoverTimeMillisInfo();
-        mInfoDefault = new AtomsQnsHandoverTimeMillisInfo(mTimeForHoSuccess, mSlotIndex);
-        mInfoCopy = new AtomsQnsHandoverTimeMillisInfo(mInfoDefault);
-    }
-
-    @After
-    public void tearDown() {
-        mInfoEmpty = null;
-        mInfoDefault = null;
-        mInfoCopy = null;
-    }
-
-    @Test
-    public void testGetSetTimeForHoSuccess() {
-        assertEquals(0, mInfoEmpty.getTimeForHoSuccess());
-        assertEquals(DEFAULT_TIMER_FOR_HANDOVER_SUCCESS, mInfoDefault.getTimeForHoSuccess());
-        assertEquals(DEFAULT_TIMER_FOR_HANDOVER_SUCCESS, mInfoCopy.getTimeForHoSuccess());
-
-        mInfoEmpty.setTimeForHoSuccess(3000);
-        mInfoDefault.setTimeForHoSuccess(4000);
-        mInfoCopy.setTimeForHoSuccess(7000);
-
-        assertEquals(3000, mInfoEmpty.getTimeForHoSuccess());
-        assertEquals(4000, mInfoDefault.getTimeForHoSuccess());
-        assertEquals(7000, mInfoCopy.getTimeForHoSuccess());
-    }
-
-    @Test
-    public void testGetSetSlotIndex() {
-        assertEquals(0, mInfoEmpty.getSlotIndex());
-        assertEquals(0, mInfoDefault.getSlotIndex());
-        assertEquals(0, mInfoCopy.getSlotIndex());
-
-        mInfoEmpty.setSlotIndex(1);
-        mInfoDefault.setSlotIndex(2);
-        mInfoCopy.setSlotIndex(3);
-
-        assertEquals(1, mInfoEmpty.getSlotIndex());
-        assertEquals(2, mInfoDefault.getSlotIndex());
-        assertEquals(3, mInfoCopy.getSlotIndex());
-    }
-
-    @Test
-    public void testToString() {
-        String strInfoEmpty = mInfoEmpty.toString();
-        String strInfoDefault = mInfoDefault.toString();
-        String strInfoCopy = mInfoCopy.toString();
-
-        assertNotNull(strInfoEmpty);
-        assertNotNull(strInfoDefault);
-        assertNotNull(strInfoCopy);
-
-        assertTrue(strInfoDefault.startsWith("AtomsQnsHandoverTimeMillisInfo"));
-
-        assertEquals(strInfoDefault, strInfoCopy);
-        assertNotEquals(strInfoEmpty, strInfoDefault);
-    }
-
-    @Test
-    public void testEquals() {
-        assertEquals(mInfoDefault, mInfoDefault);
-        assertNotEquals(mInfoDefault, new Object());
-        assertEquals(mInfoDefault, mInfoCopy);
-        mInfoDefault.setTimeForHoSuccess(2000);
-        mInfoCopy.setTimeForHoSuccess(3000);
-        assertNotEquals(mInfoDefault, mInfoCopy);
-    }
-
-    @Test
-    public void testHashCode() {
-        AtomsQnsHandoverTimeMillisInfo a1, a2;
-
-        a1 = new AtomsQnsHandoverTimeMillisInfo(2000, 0);
-        a2 = new AtomsQnsHandoverTimeMillisInfo(3000, 0);
-        assertNotEquals(a1.hashCode(), a2.hashCode());
-
-        a1 = new AtomsQnsHandoverTimeMillisInfo(mTimeForHoSuccess, mSlotIndex);
-        a2 = new AtomsQnsHandoverTimeMillisInfo(mTimeForHoSuccess, mSlotIndex);
-        assertEquals(a1.hashCode(), a2.hashCode());
-    }
-
-    @Test
-    public void testDimension() {
-        AtomsQnsHandoverTimeMillisInfo a1, a2;
-        a1 = new AtomsQnsHandoverTimeMillisInfo(1000, 0);
-        a2 = new AtomsQnsHandoverTimeMillisInfo(2000, 1);
-        assertNotEquals(a1.getDimension(), a2.getDimension());
-        assertEquals(a1.getDimension(), mInfoDefault.getDimension());
-    }
-
-    @Test
-    public void testStatsId() {
-        final int statsId = 10178; // QnsHandoverTimeMillis
-        assertEquals(statsId, mInfoDefault.copy().getStatsId());
-    }
-
-    @Test
-    public void testStatsEventBuilder() {
-        mInfoDefault.build(mStatsEventBuilder);
-
-        verify(mStatsEventBuilder, times(2)).writeInt(anyInt());
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/atoms/AtomsQnsImsCallDropStatsTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/atoms/AtomsQnsImsCallDropStatsTest.java
deleted file mode 100644
index a2b68ad..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/atoms/AtomsQnsImsCallDropStatsTest.java
+++ /dev/null
@@ -1,352 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns.atoms;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.ArgumentMatchers.anyBoolean;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
-import android.telephony.qns.QnsProtoEnums;
-import android.util.StatsEvent;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-@RunWith(JUnit4.class)
-public class AtomsQnsImsCallDropStatsTest {
-
-    @Mock
-    private StatsEvent.Builder mStatsEventBuilder;
-
-    private static final int DEFAULT_CURRENT_TRANSPORT_TYPE = QnsProtoEnums.TRANSPORT_TYPE_WWAN;
-    private static final int DEFAULT_RESTRICTIONS = QnsProtoEnums.RESTRICT_TYPE_NONE;
-    private static final int DEFAULT_SIGNAL_STRENGTH = -100;
-    private static final int DEFAULT_SIGNAL_QUALITY = -10;
-    private static final int DEFAULT_SIGNAL_NOISE = -1;
-    private static final int DEFAULT_IWLAN_SIGNAL_STRENGTH = -70;
-    private static final int DEFAULT_CELLULAR_NETWORK_TYPE = QnsProtoEnums.EUTRAN;
-
-    private AtomsQnsImsCallDropStats mInfoEmpty;
-    private AtomsQnsImsCallDropStats mInfoDefault;
-    private AtomsQnsImsCallDropStats mInfoCopy;
-
-    /** atom #1 : Transport type in where IMS call drop occurred. */
-    private int mTransportTypeCallDropped;
-
-    /** atom #2 : RTP threshold breached event occurred. */
-    private boolean mRtpThresholdBreached;
-
-    /** atom #3 : Bit mask of restrictions on another transport type */
-    private int mRestrictionsOnOtherTransportType;
-
-    /** atom #4 : Cellular network signal strength {e.g. SSRSRP in NR, RSRP in LTE} */
-    private int mSignalStrength;
-
-    /** atom #5 : Cellular network signal quality {e.g. SSRSRQ in NR, RSRQ in LTE} */
-    private int mSignalQuality;
-
-    /** atom #6 : Cellular network signal noise ratio {e.g. SSSINR in NR, RSSNR in LTE} */
-    private int mSignalNoise;
-
-    /** atom #7 : Iwlan network signal strength (Wi-Fi RSSI) */
-    private int mIwlanSignalStrength;
-
-    /** atom #8 : Slot Index */
-    private int mSlotIndex;
-
-    /** atom #9 : cellular access network type. */
-    private int mCellularNetworkType;
-
-    @Before
-    public void setUp() {
-        MockitoAnnotations.initMocks(this);
-        mTransportTypeCallDropped = DEFAULT_CURRENT_TRANSPORT_TYPE;
-        mRtpThresholdBreached = true;
-        mRestrictionsOnOtherTransportType = DEFAULT_RESTRICTIONS;
-        mSignalStrength = DEFAULT_SIGNAL_STRENGTH;
-        mSignalQuality = DEFAULT_SIGNAL_QUALITY;
-        mSignalNoise = DEFAULT_SIGNAL_NOISE;
-        mIwlanSignalStrength = DEFAULT_IWLAN_SIGNAL_STRENGTH;
-        mSlotIndex = 0;
-        mCellularNetworkType = DEFAULT_CELLULAR_NETWORK_TYPE;
-
-        mInfoEmpty = new AtomsQnsImsCallDropStats();
-        mInfoDefault =
-                new AtomsQnsImsCallDropStats(
-                        mTransportTypeCallDropped,
-                        mRtpThresholdBreached,
-                        mRestrictionsOnOtherTransportType,
-                        mSignalStrength,
-                        mSignalQuality,
-                        mSignalNoise,
-                        mIwlanSignalStrength,
-                        mSlotIndex,
-                        mCellularNetworkType);
-        mInfoCopy = new AtomsQnsImsCallDropStats(mInfoDefault);
-    }
-
-    @After
-    public void tearDown() {
-        mInfoEmpty = null;
-        mInfoDefault = null;
-        mInfoCopy = null;
-    }
-
-    @Test
-    public void testGetSetTransportTypeCallDropped() {
-        assertEquals(0, mInfoEmpty.getTransportTypeCallDropped());
-        assertEquals(DEFAULT_CURRENT_TRANSPORT_TYPE, mInfoDefault.getTransportTypeCallDropped());
-        assertEquals(DEFAULT_CURRENT_TRANSPORT_TYPE, mInfoCopy.getTransportTypeCallDropped());
-
-        mInfoEmpty.setTransportTypeCallDropped(QnsProtoEnums.TRANSPORT_TYPE_WWAN);
-        mInfoDefault.setTransportTypeCallDropped(QnsProtoEnums.TRANSPORT_TYPE_WLAN);
-        mInfoCopy.setTransportTypeCallDropped(QnsProtoEnums.TRANSPORT_TYPE_INVALID);
-
-        assertEquals(QnsProtoEnums.TRANSPORT_TYPE_WWAN, mInfoEmpty.getTransportTypeCallDropped());
-        assertEquals(QnsProtoEnums.TRANSPORT_TYPE_WLAN, mInfoDefault.getTransportTypeCallDropped());
-        assertEquals(QnsProtoEnums.TRANSPORT_TYPE_INVALID, mInfoCopy.getTransportTypeCallDropped());
-    }
-
-    @Test
-    public void testGetSetRtpThresholdBreached() {
-        assertFalse(mInfoEmpty.getRtpThresholdBreached());
-        assertTrue(mInfoDefault.getRtpThresholdBreached());
-        assertTrue(mInfoCopy.getRtpThresholdBreached());
-
-        mInfoEmpty.setRtpThresholdBreached(true);
-        mInfoDefault.setRtpThresholdBreached(true);
-        mInfoCopy.setRtpThresholdBreached(false);
-
-        assertTrue(mInfoEmpty.getRtpThresholdBreached());
-        assertTrue(mInfoDefault.getRtpThresholdBreached());
-        assertFalse(mInfoCopy.getRtpThresholdBreached());
-    }
-
-    @Test
-    public void testGetSetRestrictionsOnOtherTransportType() {
-        assertEquals(0, mInfoEmpty.getRestrictionsOnOtherTransportType());
-        assertEquals(DEFAULT_RESTRICTIONS, mInfoDefault.getRestrictionsOnOtherTransportType());
-        assertEquals(DEFAULT_RESTRICTIONS, mInfoCopy.getRestrictionsOnOtherTransportType());
-
-        mInfoEmpty.setRestrictionsOnOtherTransportType(QnsProtoEnums.RESTRICT_TYPE_GUARDING);
-        mInfoDefault.setRestrictionsOnOtherTransportType(QnsProtoEnums.RESTRICT_TYPE_THROTTLING);
-        mInfoCopy.setRestrictionsOnOtherTransportType(QnsProtoEnums.RESTRICT_TYPE_NONE);
-
-        assertEquals(
-                QnsProtoEnums.RESTRICT_TYPE_GUARDING,
-                mInfoEmpty.getRestrictionsOnOtherTransportType());
-        assertEquals(
-                QnsProtoEnums.RESTRICT_TYPE_THROTTLING,
-                mInfoDefault.getRestrictionsOnOtherTransportType());
-        assertEquals(
-                QnsProtoEnums.RESTRICT_TYPE_NONE, mInfoCopy.getRestrictionsOnOtherTransportType());
-    }
-
-    @Test
-    public void testGetSetSignalStrength() {
-        assertEquals(0, mInfoEmpty.getSignalStrength());
-        assertEquals(DEFAULT_SIGNAL_STRENGTH, mInfoDefault.getSignalStrength());
-        assertEquals(DEFAULT_SIGNAL_STRENGTH, mInfoCopy.getSignalStrength());
-
-        mInfoEmpty.setSignalStrength(DEFAULT_SIGNAL_STRENGTH);
-        mInfoDefault.setSignalStrength(-120);
-        mInfoCopy.setSignalStrength(-110);
-
-        assertEquals(DEFAULT_SIGNAL_STRENGTH, mInfoEmpty.getSignalStrength());
-        assertEquals(-120, mInfoDefault.getSignalStrength());
-        assertEquals(-110, mInfoCopy.getSignalStrength());
-    }
-
-    @Test
-    public void testGetSetSignalQuality() {
-        assertEquals(0, mInfoEmpty.getSignalQuality());
-        assertEquals(DEFAULT_SIGNAL_QUALITY, mInfoDefault.getSignalQuality());
-        assertEquals(DEFAULT_SIGNAL_QUALITY, mInfoCopy.getSignalQuality());
-
-        mInfoEmpty.setSignalQuality(DEFAULT_SIGNAL_QUALITY);
-        mInfoDefault.setSignalQuality(-10);
-        mInfoCopy.setSignalQuality(-5);
-
-        assertEquals(DEFAULT_SIGNAL_QUALITY, mInfoEmpty.getSignalQuality());
-        assertEquals(-10, mInfoDefault.getSignalQuality());
-        assertEquals(-5, mInfoCopy.getSignalQuality());
-    }
-
-    @Test
-    public void testGetSetSignalNoise() {
-        assertEquals(0, mInfoEmpty.getSignalNoise());
-        assertEquals(DEFAULT_SIGNAL_NOISE, mInfoDefault.getSignalNoise());
-        assertEquals(DEFAULT_SIGNAL_NOISE, mInfoCopy.getSignalNoise());
-
-        mInfoEmpty.setSignalNoise(DEFAULT_SIGNAL_NOISE);
-        mInfoDefault.setSignalNoise(1);
-        mInfoCopy.setSignalNoise(-1);
-
-        assertEquals(DEFAULT_SIGNAL_NOISE, mInfoEmpty.getSignalNoise());
-        assertEquals(1, mInfoDefault.getSignalNoise());
-        assertEquals(-1, mInfoCopy.getSignalNoise());
-    }
-
-    @Test
-    public void testGetSetIwlanSignalStrength() {
-        assertEquals(0, mInfoEmpty.getIwlanSignalStrength());
-        assertEquals(DEFAULT_IWLAN_SIGNAL_STRENGTH, mInfoDefault.getIwlanSignalStrength());
-        assertEquals(DEFAULT_IWLAN_SIGNAL_STRENGTH, mInfoCopy.getIwlanSignalStrength());
-
-        mInfoEmpty.setIwlanSignalStrength(DEFAULT_IWLAN_SIGNAL_STRENGTH);
-        mInfoDefault.setIwlanSignalStrength(-80);
-        mInfoCopy.setIwlanSignalStrength(-50);
-
-        assertEquals(DEFAULT_IWLAN_SIGNAL_STRENGTH, mInfoEmpty.getIwlanSignalStrength());
-        assertEquals(-80, mInfoDefault.getIwlanSignalStrength());
-        assertEquals(-50, mInfoCopy.getIwlanSignalStrength());
-    }
-
-    @Test
-    public void testGetSetSlotIndex() {
-        assertEquals(0, mInfoEmpty.getSlotIndex());
-        assertEquals(0, mInfoDefault.getSlotIndex());
-        assertEquals(0, mInfoCopy.getSlotIndex());
-
-        mInfoEmpty.setSlotIndex(1);
-        mInfoDefault.setSlotIndex(2);
-        mInfoCopy.setSlotIndex(3);
-
-        assertEquals(1, mInfoEmpty.getSlotIndex());
-        assertEquals(2, mInfoDefault.getSlotIndex());
-        assertEquals(3, mInfoCopy.getSlotIndex());
-    }
-
-    @Test
-    public void testGetSetCellularNetworkType() {
-        assertEquals(0, mInfoEmpty.getCellularNetworkType());
-        assertEquals(DEFAULT_CELLULAR_NETWORK_TYPE, mInfoDefault.getCellularNetworkType());
-        assertEquals(DEFAULT_CELLULAR_NETWORK_TYPE, mInfoCopy.getCellularNetworkType());
-
-        mInfoEmpty.setCellularNetworkType(QnsProtoEnums.NGRAN);
-        mInfoDefault.setCellularNetworkType(QnsProtoEnums.UTRAN);
-        mInfoCopy.setCellularNetworkType(QnsProtoEnums.GERAN);
-
-        assertEquals(QnsProtoEnums.NGRAN, mInfoEmpty.getCellularNetworkType());
-        assertEquals(QnsProtoEnums.UTRAN, mInfoDefault.getCellularNetworkType());
-        assertEquals(QnsProtoEnums.GERAN, mInfoCopy.getCellularNetworkType());
-    }
-
-    @Test
-    public void testToString() {
-        String strInfoEmpty = mInfoEmpty.toString();
-        String strInfoDefault = mInfoDefault.toString();
-        String strInfoCopy = mInfoCopy.toString();
-
-        assertNotNull(strInfoEmpty);
-        assertNotNull(strInfoDefault);
-        assertNotNull(strInfoCopy);
-
-        assertTrue(strInfoDefault.startsWith("AtomsQnsImsCallDropStats"));
-
-        assertEquals(strInfoDefault, strInfoCopy);
-        assertNotEquals(strInfoEmpty, strInfoDefault);
-    }
-
-    @Test
-    public void testEquals() {
-        assertEquals(mInfoDefault, mInfoDefault);
-        assertNotEquals(mInfoDefault, new Object());
-        assertEquals(mInfoDefault, mInfoCopy);
-        mInfoDefault.setSignalQuality(3);
-        mInfoCopy.setSignalQuality(1);
-        assertNotEquals(mInfoDefault, mInfoCopy);
-    }
-
-    @Test
-    public void testHashCode() {
-        AtomsQnsImsCallDropStats a1, a2;
-
-        a1 =
-                new AtomsQnsImsCallDropStats(
-                        mInfoDefault.getTransportTypeCallDropped(),
-                        mInfoDefault.getRtpThresholdBreached(),
-                        mInfoDefault.getRestrictionsOnOtherTransportType(),
-                        0,
-                        0,
-                        0,
-                        0,
-                        0,
-                        0);
-        a2 =
-                new AtomsQnsImsCallDropStats(
-                        mInfoDefault.getTransportTypeCallDropped(),
-                        mInfoDefault.getRtpThresholdBreached(),
-                        mInfoDefault.getRestrictionsOnOtherTransportType(),
-                        0,
-                        0,
-                        0,
-                        0,
-                        0,
-                        1);
-        assertNotEquals(a1.hashCode(), a2.hashCode());
-
-        a1 =
-                new AtomsQnsImsCallDropStats(
-                        mTransportTypeCallDropped,
-                        mRtpThresholdBreached,
-                        mRestrictionsOnOtherTransportType,
-                        mSignalStrength,
-                        mSignalQuality,
-                        mSignalNoise,
-                        mIwlanSignalStrength,
-                        mSlotIndex,
-                        mCellularNetworkType);
-        a2 =
-                new AtomsQnsImsCallDropStats(
-                        mTransportTypeCallDropped,
-                        mRtpThresholdBreached,
-                        mRestrictionsOnOtherTransportType,
-                        mSignalStrength,
-                        mSignalQuality,
-                        mSignalNoise,
-                        mIwlanSignalStrength,
-                        mSlotIndex,
-                        mCellularNetworkType);
-        assertEquals(a1.hashCode(), a2.hashCode());
-    }
-
-    @Test
-    public void testStatsId() {
-        final int statsId = 635; // QnsImsCallDropStats
-        assertEquals(statsId, mInfoDefault.copy().getStatsId());
-    }
-
-    @Test
-    public void testStatsEventBuilder() {
-        mInfoDefault.build(mStatsEventBuilder);
-
-        verify(mStatsEventBuilder, times(1)).writeBoolean(anyBoolean());
-        verify(mStatsEventBuilder, times(8)).writeInt(anyInt());
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/atoms/AtomsQnsRatPreferenceMismatchInfoTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/atoms/AtomsQnsRatPreferenceMismatchInfoTest.java
deleted file mode 100644
index 4c5b469..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/atoms/AtomsQnsRatPreferenceMismatchInfoTest.java
+++ /dev/null
@@ -1,261 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns.atoms;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
-import android.telephony.qns.QnsProtoEnums;
-import android.util.StatsEvent;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-@RunWith(JUnit4.class)
-public class AtomsQnsRatPreferenceMismatchInfoTest {
-
-    @Mock
-    private StatsEvent.Builder mStatsEventBuilder;
-
-    private static final int DEFAULT_NET_CAPABILITY = QnsProtoEnums.NET_CAPABILITY_IMS;
-    private static final int DEFAULT_HANDOVER_FAIL_COUNT = 1;
-    private static final int DEFAULT_DURATION_OF_MISMATCH = 13500;
-    private static final int DEFAULT_CARRIER_ID = 1; // TMO
-
-    private AtomsQnsRatPreferenceMismatchInfo mInfoEmpty;
-    private AtomsQnsRatPreferenceMismatchInfo mInfoDefault;
-    private AtomsQnsRatPreferenceMismatchInfo mInfoCopy;
-
-    /** atom #1 : Net capability of this information. */
-    private int mNetCapability;
-
-    /** atom #2 : Count of handover failed. */
-    private int mHandoverFailCount;
-
-    /** atom #3 : Duration of this mismatch. */
-    private int mDurationOfMismatch;
-
-    /** atom #4 : Carrier ID */
-    private int mCarrierId;
-
-    /** atom #5 : Slot Index */
-    private int mSlotIndex;
-
-    @Before
-    public void setUp() {
-        MockitoAnnotations.initMocks(this);
-        mNetCapability = DEFAULT_NET_CAPABILITY;
-        mHandoverFailCount = DEFAULT_HANDOVER_FAIL_COUNT;
-        mDurationOfMismatch = DEFAULT_DURATION_OF_MISMATCH;
-        mCarrierId = DEFAULT_CARRIER_ID;
-        mSlotIndex = 0;
-        mInfoEmpty = new AtomsQnsRatPreferenceMismatchInfo();
-        mInfoDefault =
-                new AtomsQnsRatPreferenceMismatchInfo(
-                        mNetCapability,
-                        mHandoverFailCount,
-                        mDurationOfMismatch,
-                        mCarrierId,
-                        mSlotIndex);
-        mInfoCopy = new AtomsQnsRatPreferenceMismatchInfo(mInfoDefault);
-    }
-
-    @After
-    public void tearDown() {
-        mInfoEmpty = null;
-        mInfoDefault = null;
-        mInfoCopy = null;
-    }
-
-    @Test
-    public void testGetSetNetCapability() {
-        assertEquals(0, mInfoEmpty.getNetCapability());
-        assertEquals(DEFAULT_NET_CAPABILITY, mInfoDefault.getNetCapability());
-        assertEquals(DEFAULT_NET_CAPABILITY, mInfoCopy.getNetCapability());
-
-        mInfoEmpty.setNetCapability(QnsProtoEnums.NET_CAPABILITY_MMS);
-        mInfoDefault.setNetCapability(QnsProtoEnums.NET_CAPABILITY_CBS);
-        mInfoCopy.setNetCapability(QnsProtoEnums.NET_CAPABILITY_XCAP);
-
-        assertEquals(QnsProtoEnums.NET_CAPABILITY_MMS, mInfoEmpty.getNetCapability());
-        assertEquals(QnsProtoEnums.NET_CAPABILITY_CBS, mInfoDefault.getNetCapability());
-        assertEquals(QnsProtoEnums.NET_CAPABILITY_XCAP, mInfoCopy.getNetCapability());
-    }
-
-    @Test
-    public void testGetSetHandoverFailCount() {
-        assertEquals(0, mInfoEmpty.getHandoverFailCount());
-        assertEquals(DEFAULT_HANDOVER_FAIL_COUNT, mInfoDefault.getHandoverFailCount());
-        assertEquals(DEFAULT_HANDOVER_FAIL_COUNT, mInfoCopy.getHandoverFailCount());
-
-        mInfoEmpty.setHandoverFailCount(DEFAULT_HANDOVER_FAIL_COUNT);
-        mInfoDefault.setHandoverFailCount(4);
-        mInfoCopy.setHandoverFailCount(0);
-
-        assertEquals(DEFAULT_HANDOVER_FAIL_COUNT, mInfoEmpty.getHandoverFailCount());
-        assertEquals(4, mInfoDefault.getHandoverFailCount());
-        assertEquals(0, mInfoCopy.getHandoverFailCount());
-    }
-
-    @Test
-    public void testGetSetDurationOfMismatch() {
-        assertEquals(0, mInfoEmpty.getDurationOfMismatch());
-        assertEquals(DEFAULT_DURATION_OF_MISMATCH, mInfoDefault.getDurationOfMismatch());
-        assertEquals(DEFAULT_DURATION_OF_MISMATCH, mInfoCopy.getDurationOfMismatch());
-
-        mInfoEmpty.setDurationOfMismatch(DEFAULT_DURATION_OF_MISMATCH);
-        mInfoDefault.setDurationOfMismatch(4000);
-        mInfoCopy.setDurationOfMismatch(0);
-
-        assertEquals(DEFAULT_DURATION_OF_MISMATCH, mInfoEmpty.getDurationOfMismatch());
-        assertEquals(4000, mInfoDefault.getDurationOfMismatch());
-        assertEquals(0, mInfoCopy.getDurationOfMismatch());
-    }
-
-    @Test
-    public void testGetSetCarrierId() {
-        assertEquals(0, mInfoEmpty.getCarrierId());
-        assertEquals(DEFAULT_CARRIER_ID, mInfoDefault.getCarrierId());
-        assertEquals(DEFAULT_CARRIER_ID, mInfoCopy.getCarrierId());
-
-        mInfoEmpty.setCarrierId(1);
-        mInfoDefault.setCarrierId(2);
-        mInfoCopy.setCarrierId(3);
-
-        assertEquals(1, mInfoEmpty.getCarrierId());
-        assertEquals(2, mInfoDefault.getCarrierId());
-        assertEquals(3, mInfoCopy.getCarrierId());
-    }
-
-    @Test
-    public void testGetSetSlotIndex() {
-        assertEquals(0, mInfoEmpty.getSlotIndex());
-        assertEquals(0, mInfoDefault.getSlotIndex());
-        assertEquals(0, mInfoCopy.getSlotIndex());
-
-        mInfoEmpty.setSlotIndex(1);
-        mInfoDefault.setSlotIndex(2);
-        mInfoCopy.setSlotIndex(3);
-
-        assertEquals(1, mInfoEmpty.getSlotIndex());
-        assertEquals(2, mInfoDefault.getSlotIndex());
-        assertEquals(3, mInfoCopy.getSlotIndex());
-    }
-
-    @Test
-    public void testToString() {
-        String strInfoEmpty = mInfoEmpty.toString();
-        String strInfoDefault = mInfoDefault.toString();
-        String strInfoCopy = mInfoCopy.toString();
-
-        assertNotNull(strInfoEmpty);
-        assertNotNull(strInfoDefault);
-        assertNotNull(strInfoCopy);
-
-        assertTrue(strInfoDefault.startsWith("AtomsQnsRatPreferenceMismatchInfo"));
-
-        assertEquals(strInfoDefault, strInfoCopy);
-        assertNotEquals(strInfoEmpty, strInfoDefault);
-    }
-
-    @Test
-    public void testEquals() {
-        assertEquals(mInfoDefault, mInfoDefault);
-        assertNotEquals(mInfoDefault, new Object());
-        assertEquals(mInfoDefault, mInfoCopy);
-        mInfoDefault.setHandoverFailCount(0);
-        mInfoCopy.setHandoverFailCount(1);
-        assertNotEquals(mInfoDefault, mInfoCopy);
-    }
-
-    @Test
-    public void testHashCode() {
-        AtomsQnsRatPreferenceMismatchInfo a1, a2;
-
-        a1 =
-                new AtomsQnsRatPreferenceMismatchInfo(
-                        QnsProtoEnums.NET_CAPABILITY_IMS, 0, 0, mCarrierId, mSlotIndex);
-        a2 =
-                new AtomsQnsRatPreferenceMismatchInfo(
-                        QnsProtoEnums.NET_CAPABILITY_MMS, 0, 0, mCarrierId, mSlotIndex);
-        assertNotEquals(a1.hashCode(), a2.hashCode());
-
-        a1 =
-                new AtomsQnsRatPreferenceMismatchInfo(
-                        mNetCapability,
-                        mHandoverFailCount,
-                        mDurationOfMismatch,
-                        mCarrierId,
-                        mSlotIndex);
-        a2 =
-                new AtomsQnsRatPreferenceMismatchInfo(
-                        mNetCapability,
-                        mHandoverFailCount,
-                        mDurationOfMismatch,
-                        mCarrierId,
-                        mSlotIndex);
-        assertEquals(a1.hashCode(), a2.hashCode());
-    }
-
-    @Test
-    public void testDimension() {
-        AtomsQnsRatPreferenceMismatchInfo a1, a2;
-
-        a1 =
-                new AtomsQnsRatPreferenceMismatchInfo(
-                        mNetCapability, mHandoverFailCount, mDurationOfMismatch, 1, mSlotIndex);
-        a2 =
-                new AtomsQnsRatPreferenceMismatchInfo(
-                        mNetCapability, mHandoverFailCount, mDurationOfMismatch, 3, mSlotIndex);
-        assertNotEquals(a1.getDimension(), a2.getDimension());
-
-        a1 =
-                new AtomsQnsRatPreferenceMismatchInfo(
-                        mNetCapability, mHandoverFailCount, mDurationOfMismatch, mCarrierId, 0);
-        a2 =
-                new AtomsQnsRatPreferenceMismatchInfo(
-                        mNetCapability, mHandoverFailCount, mDurationOfMismatch, mCarrierId, 1);
-        assertNotEquals(a1.getDimension(), a2.getDimension());
-
-        a1 = new AtomsQnsRatPreferenceMismatchInfo(9, 0, 100, mCarrierId, mSlotIndex);
-        a2 = new AtomsQnsRatPreferenceMismatchInfo(9, 1, 200, mCarrierId, mSlotIndex);
-        assertEquals(a1.getDimension(), a2.getDimension());
-    }
-
-    @Test
-    public void testStatsId() {
-        final int statsId = 10177; // QnsRatPreferenceMismatchInfo
-        assertEquals(statsId, mInfoDefault.copy().getStatsId());
-    }
-
-    @Test
-    public void testStatsEventBuilder() {
-        mInfoDefault.build(mStatsEventBuilder);
-
-        verify(mStatsEventBuilder, times(5)).writeInt(anyInt());
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/atoms/AtomsQualifiedRatListChangedInfoTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/atoms/AtomsQualifiedRatListChangedInfoTest.java
deleted file mode 100644
index 5eb6a42..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/atoms/AtomsQualifiedRatListChangedInfoTest.java
+++ /dev/null
@@ -1,534 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns.atoms;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.ArgumentMatchers.anyBoolean;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
-import android.telephony.qns.QnsProtoEnums;
-import android.util.StatsEvent;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-@RunWith(JUnit4.class)
-public class AtomsQualifiedRatListChangedInfoTest {
-
-    @Mock
-    private StatsEvent.Builder mStatsEventBuilder;
-
-    private static final int DEFAULT_NET_CAPABILITY = QnsProtoEnums.NET_CAPABILITY_IMS;
-    private static final int DEFAULT_FIRST_QUALIFIED_RAT = QnsProtoEnums.EUTRAN;
-    private static final int DEFAULT_SECOND_QUALIFIED_RAT = QnsProtoEnums.IWLAN;
-    private static final int DEFAULT_CURRENT_TRANSPORT_TYPE = QnsProtoEnums.TRANSPORT_TYPE_WLAN;
-    private static final boolean DEFAULT_WFC_ENABLED = true;
-    private static final int DEFAULT_WFC_MODE = QnsProtoEnums.CELLULAR_PREFERRED;
-    private static final int DEFAULT_CELLULAR_NETWORK_TYPE = QnsProtoEnums.EUTRAN;
-    private static final int DEFAULT_IWLAN_NETWORK_TYPE = QnsProtoEnums.IWLAN_NETWORK_TYPE_WIFI;
-    private static final int DEFAULT_RESTRICTIONS_ON_WWAN = QnsProtoEnums.RESTRICT_TYPE_NONE;
-    private static final int DEFAULT_RESTRICTIONS_ON_WLAN = QnsProtoEnums.RESTRICT_TYPE_NONE;
-    private static final int DEFAULT_SIGNAL_STRENGTH = -100;
-    private static final int DEFAULT_SIGNAL_QUALITY = -10;
-    private static final int DEFAULT_SIGNAL_NOISE = -1;
-    private static final int DEFAULT_IWLAN_SIGNAL_STRENGTH = -70;
-    private static final int DEFAULT_UPDATE_REASON = 0;
-
-    private AtomsQualifiedRatListChangedInfo mInfoEmpty;
-    private AtomsQualifiedRatListChangedInfo mInfoDefault;
-    private AtomsQualifiedRatListChangedInfo mInfoCopy;
-
-    /** atom #1 : NetCapability of this Qualified RAT update */
-    private int mNetCapability;
-    /** atom #2 : The most preferred qualified RAT */
-    private int mFirstQualifiedRat;
-    /** atom #3 : Second preferred qualified RAT */
-    private int mSecondQualifiedRat;
-    /** atom #4 : Current actual transport type of Data session for this NetCapability */
-    private int mCurrentTransportType;
-    /** atom #5 : Indicates whether WFC is enabled */
-    private boolean mWfcEnabled;
-    /** atom #6 : Indicates the user's WFC mode */
-    private int mWfcMode;
-    /** atom #7 : Current Cellular AccessNetwork Type */
-    private int mCellularNetworkType;
-    /** atom #8 : Available IWLAN AccessNetwork */
-    private int mIwlanNetworkType;
-    /** atom #9 : Bit mask of restrictions on WWAN */
-    private int mRestrictionsOnWwan;
-    /** atom #10 : Bit mask of restrictions on WLAN */
-    private int mRestrictionsOnWlan;
-    /**
-     * atom #11 : Cellular network signal strength {e.g. SSRSRP in NR, RSRP in LTE, RSCP in UMTS}
-     */
-    private int mSignalStrength;
-    /** atom #12 : Cellular network signal quality {e.g. SSRSRQ in NR, RSRQ in LTE} */
-    private int mSignalQuality;
-    /** atom #13 : Cellular network signal noise ratio {e.g. SSSINR in NR, RSSNR in LTE} */
-    private int mSignalNoise;
-    /** atom #14 : Iwlan network signal strength (Wi-Fi RSSI) */
-    private int mIwlanSignalStrength;
-    /** atom #15 : Reason for preferred RAT update */
-    private int mUpdateReason;
-    /** atom #16: IMS Call Type */
-    private int mImsCallType;
-    /** atom #17 : IMS Call Quality */
-    private int mImsCallQuality;
-    /** atom #18 : Slot Index */
-    private int mSlotIndex;
-
-    @Before
-    public void setUp() {
-        MockitoAnnotations.initMocks(this);
-        mNetCapability = DEFAULT_NET_CAPABILITY;
-        mFirstQualifiedRat = DEFAULT_FIRST_QUALIFIED_RAT;
-        mSecondQualifiedRat = DEFAULT_SECOND_QUALIFIED_RAT;
-        mCurrentTransportType = DEFAULT_CURRENT_TRANSPORT_TYPE;
-        mWfcEnabled = DEFAULT_WFC_ENABLED;
-        mWfcMode = DEFAULT_WFC_MODE;
-        mCellularNetworkType = DEFAULT_CELLULAR_NETWORK_TYPE;
-        mIwlanNetworkType = DEFAULT_IWLAN_NETWORK_TYPE;
-        mRestrictionsOnWwan = DEFAULT_RESTRICTIONS_ON_WWAN;
-        mRestrictionsOnWlan = DEFAULT_RESTRICTIONS_ON_WLAN;
-        mSignalStrength = DEFAULT_SIGNAL_STRENGTH;
-        mSignalQuality = DEFAULT_SIGNAL_QUALITY;
-        mSignalNoise = DEFAULT_SIGNAL_NOISE;
-        mIwlanSignalStrength = DEFAULT_IWLAN_SIGNAL_STRENGTH;
-        mUpdateReason = DEFAULT_UPDATE_REASON;
-        mImsCallType = 1;
-        mImsCallQuality = 0;
-        mSlotIndex = 0;
-        mInfoEmpty = new AtomsQualifiedRatListChangedInfo();
-        mInfoDefault =
-                new AtomsQualifiedRatListChangedInfo(
-                        mNetCapability,
-                        mFirstQualifiedRat,
-                        mSecondQualifiedRat,
-                        mCurrentTransportType,
-                        mWfcEnabled,
-                        mWfcMode,
-                        mCellularNetworkType,
-                        mIwlanNetworkType,
-                        mRestrictionsOnWwan,
-                        mRestrictionsOnWlan,
-                        mSignalStrength,
-                        mSignalQuality,
-                        mSignalNoise,
-                        mIwlanSignalStrength,
-                        mUpdateReason,
-                        mImsCallType,
-                        mImsCallQuality,
-                        mSlotIndex);
-        mInfoCopy = new AtomsQualifiedRatListChangedInfo(mInfoDefault);
-    }
-
-    @After
-    public void tearDown() {
-        mInfoEmpty = null;
-        mInfoDefault = null;
-        mInfoCopy = null;
-    }
-
-    @Test
-    public void testGetSetNetCapability() {
-        assertEquals(0, mInfoEmpty.getNetCapability());
-        assertEquals(DEFAULT_NET_CAPABILITY, mInfoDefault.getNetCapability());
-        assertEquals(DEFAULT_NET_CAPABILITY, mInfoCopy.getNetCapability());
-
-        mInfoEmpty.setNetCapability(QnsProtoEnums.NET_CAPABILITY_IMS);
-        mInfoDefault.setNetCapability(QnsProtoEnums.NET_CAPABILITY_EIMS);
-        mInfoCopy.setNetCapability(QnsProtoEnums.NET_CAPABILITY_XCAP);
-
-        assertEquals(QnsProtoEnums.NET_CAPABILITY_IMS, mInfoEmpty.getNetCapability());
-        assertEquals(QnsProtoEnums.NET_CAPABILITY_EIMS, mInfoDefault.getNetCapability());
-        assertEquals(QnsProtoEnums.NET_CAPABILITY_XCAP, mInfoCopy.getNetCapability());
-    }
-
-    @Test
-    public void testGetSetFirstQualifiedRat() {
-        assertEquals(0, mInfoEmpty.getFirstQualifiedRat());
-        assertEquals(DEFAULT_FIRST_QUALIFIED_RAT, mInfoDefault.getFirstQualifiedRat());
-        assertEquals(DEFAULT_FIRST_QUALIFIED_RAT, mInfoCopy.getFirstQualifiedRat());
-
-        mInfoEmpty.setFirstQualifiedRat(QnsProtoEnums.IWLAN);
-        mInfoDefault.setFirstQualifiedRat(QnsProtoEnums.EUTRAN);
-        mInfoCopy.setFirstQualifiedRat(QnsProtoEnums.NGRAN);
-
-        assertEquals(QnsProtoEnums.IWLAN, mInfoEmpty.getFirstQualifiedRat());
-        assertEquals(QnsProtoEnums.EUTRAN, mInfoDefault.getFirstQualifiedRat());
-        assertEquals(QnsProtoEnums.NGRAN, mInfoCopy.getFirstQualifiedRat());
-    }
-
-    @Test
-    public void testGetSetSecondQualifiedRat() {
-        assertEquals(0, mInfoEmpty.getSecondQualifiedRat());
-        assertEquals(DEFAULT_SECOND_QUALIFIED_RAT, mInfoDefault.getSecondQualifiedRat());
-        assertEquals(DEFAULT_SECOND_QUALIFIED_RAT, mInfoCopy.getSecondQualifiedRat());
-
-        mInfoEmpty.setSecondQualifiedRat(QnsProtoEnums.IWLAN);
-        mInfoDefault.setSecondQualifiedRat(QnsProtoEnums.EUTRAN);
-        mInfoCopy.setSecondQualifiedRat(QnsProtoEnums.NGRAN);
-
-        assertEquals(QnsProtoEnums.IWLAN, mInfoEmpty.getSecondQualifiedRat());
-        assertEquals(QnsProtoEnums.EUTRAN, mInfoDefault.getSecondQualifiedRat());
-        assertEquals(QnsProtoEnums.NGRAN, mInfoCopy.getSecondQualifiedRat());
-    }
-
-    @Test
-    public void testGetSetCurrentTransportType() {
-        assertEquals(0, mInfoEmpty.getCurrentTransportType());
-        assertEquals(DEFAULT_CURRENT_TRANSPORT_TYPE, mInfoDefault.getCurrentTransportType());
-        assertEquals(DEFAULT_CURRENT_TRANSPORT_TYPE, mInfoCopy.getCurrentTransportType());
-
-        mInfoEmpty.setCurrentTransportType(QnsProtoEnums.TRANSPORT_TYPE_INVALID);
-        mInfoDefault.setCurrentTransportType(QnsProtoEnums.TRANSPORT_TYPE_WWAN);
-        mInfoCopy.setCurrentTransportType(QnsProtoEnums.TRANSPORT_TYPE_WLAN);
-
-        assertEquals(QnsProtoEnums.TRANSPORT_TYPE_INVALID, mInfoEmpty.getCurrentTransportType());
-        assertEquals(QnsProtoEnums.TRANSPORT_TYPE_WWAN, mInfoDefault.getCurrentTransportType());
-        assertEquals(QnsProtoEnums.TRANSPORT_TYPE_WLAN, mInfoCopy.getCurrentTransportType());
-    }
-
-    @Test
-    public void testGetSetWfcEnabled() {
-        assertFalse(mInfoEmpty.getWfcEnabled());
-        assertTrue(mInfoDefault.getWfcEnabled());
-        assertTrue(mInfoCopy.getWfcEnabled());
-
-        mInfoEmpty.setWfcEnabled(true);
-        mInfoDefault.setWfcEnabled(true);
-        mInfoCopy.setWfcEnabled(true);
-
-        assertTrue(mInfoEmpty.getWfcEnabled());
-        assertTrue(mInfoDefault.getWfcEnabled());
-        assertTrue(mInfoCopy.getWfcEnabled());
-    }
-
-    @Test
-    public void testGetSetWfcMode() {
-        assertEquals(0, mInfoEmpty.getWfcMode());
-        assertEquals(DEFAULT_WFC_MODE, mInfoDefault.getWfcMode());
-        assertEquals(DEFAULT_WFC_MODE, mInfoCopy.getWfcMode());
-
-        mInfoEmpty.setWfcMode(QnsProtoEnums.CELLULAR_PREFERRED);
-        mInfoDefault.setWfcMode(QnsProtoEnums.WIFI_ONLY);
-        mInfoCopy.setWfcMode(QnsProtoEnums.WIFI_PREFERRED);
-
-        assertEquals(QnsProtoEnums.CELLULAR_PREFERRED, mInfoEmpty.getWfcMode());
-        assertEquals(QnsProtoEnums.WIFI_ONLY, mInfoDefault.getWfcMode());
-        assertEquals(QnsProtoEnums.WIFI_PREFERRED, mInfoCopy.getWfcMode());
-    }
-
-    @Test
-    public void testGetSetCellularNetworkType() {
-        assertEquals(0, mInfoEmpty.getCellularNetworkType());
-        assertEquals(DEFAULT_CELLULAR_NETWORK_TYPE, mInfoDefault.getCellularNetworkType());
-        assertEquals(DEFAULT_CELLULAR_NETWORK_TYPE, mInfoCopy.getCellularNetworkType());
-
-        mInfoEmpty.setCellularNetworkType(QnsProtoEnums.EUTRAN);
-        mInfoDefault.setCellularNetworkType(QnsProtoEnums.NGRAN);
-        mInfoCopy.setCellularNetworkType(QnsProtoEnums.UTRAN);
-
-        assertEquals(QnsProtoEnums.EUTRAN, mInfoEmpty.getCellularNetworkType());
-        assertEquals(QnsProtoEnums.NGRAN, mInfoDefault.getCellularNetworkType());
-        assertEquals(QnsProtoEnums.UTRAN, mInfoCopy.getCellularNetworkType());
-    }
-
-    @Test
-    public void testGetSetIwlanNetworkType() {
-        assertEquals(0, mInfoEmpty.getIwlanNetworkType());
-        assertEquals(DEFAULT_IWLAN_NETWORK_TYPE, mInfoDefault.getIwlanNetworkType());
-        assertEquals(DEFAULT_IWLAN_NETWORK_TYPE, mInfoCopy.getIwlanNetworkType());
-
-        mInfoEmpty.setIwlanNetworkType(QnsProtoEnums.EUTRAN);
-        mInfoDefault.setIwlanNetworkType(QnsProtoEnums.NGRAN);
-        mInfoCopy.setIwlanNetworkType(QnsProtoEnums.UTRAN);
-
-        assertEquals(QnsProtoEnums.EUTRAN, mInfoEmpty.getIwlanNetworkType());
-        assertEquals(QnsProtoEnums.NGRAN, mInfoDefault.getIwlanNetworkType());
-        assertEquals(QnsProtoEnums.UTRAN, mInfoCopy.getIwlanNetworkType());
-    }
-
-    @Test
-    public void testGetSetRestrictionsOnWwan() {
-        assertEquals(0, mInfoEmpty.getRestrictionsOnWwan());
-        assertEquals(DEFAULT_RESTRICTIONS_ON_WWAN, mInfoDefault.getRestrictionsOnWwan());
-        assertEquals(DEFAULT_RESTRICTIONS_ON_WWAN, mInfoCopy.getRestrictionsOnWwan());
-
-        mInfoEmpty.setRestrictionsOnWwan(QnsProtoEnums.RESTRICT_TYPE_GUARDING);
-        mInfoDefault.setRestrictionsOnWwan(QnsProtoEnums.RESTRICT_TYPE_THROTTLING);
-        mInfoCopy.setRestrictionsOnWwan(QnsProtoEnums.RESTRICT_TYPE_NONE);
-
-        assertEquals(QnsProtoEnums.RESTRICT_TYPE_GUARDING, mInfoEmpty.getRestrictionsOnWwan());
-        assertEquals(QnsProtoEnums.RESTRICT_TYPE_THROTTLING, mInfoDefault.getRestrictionsOnWwan());
-        assertEquals(QnsProtoEnums.RESTRICT_TYPE_NONE, mInfoCopy.getRestrictionsOnWwan());
-    }
-
-    @Test
-    public void testGetSetRestrictionsOnWlan() {
-        assertEquals(0, mInfoEmpty.getRestrictionsOnWlan());
-        assertEquals(DEFAULT_RESTRICTIONS_ON_WWAN, mInfoDefault.getRestrictionsOnWlan());
-        assertEquals(DEFAULT_RESTRICTIONS_ON_WWAN, mInfoCopy.getRestrictionsOnWlan());
-
-        mInfoEmpty.setRestrictionsOnWlan(QnsProtoEnums.RESTRICT_TYPE_GUARDING);
-        mInfoDefault.setRestrictionsOnWlan(QnsProtoEnums.RESTRICT_TYPE_THROTTLING);
-        mInfoCopy.setRestrictionsOnWlan(QnsProtoEnums.RESTRICT_TYPE_NONE);
-
-        assertEquals(QnsProtoEnums.RESTRICT_TYPE_GUARDING, mInfoEmpty.getRestrictionsOnWlan());
-        assertEquals(QnsProtoEnums.RESTRICT_TYPE_THROTTLING, mInfoDefault.getRestrictionsOnWlan());
-        assertEquals(QnsProtoEnums.RESTRICT_TYPE_NONE, mInfoCopy.getRestrictionsOnWlan());
-    }
-
-    @Test
-    public void testGetSetSignalStrength() {
-        assertEquals(0, mInfoEmpty.getSignalStrength());
-        assertEquals(DEFAULT_SIGNAL_STRENGTH, mInfoDefault.getSignalStrength());
-        assertEquals(DEFAULT_SIGNAL_STRENGTH, mInfoCopy.getSignalStrength());
-
-        mInfoEmpty.setSignalStrength(DEFAULT_SIGNAL_STRENGTH);
-        mInfoDefault.setSignalStrength(-120);
-        mInfoCopy.setSignalStrength(-110);
-
-        assertEquals(DEFAULT_SIGNAL_STRENGTH, mInfoEmpty.getSignalStrength());
-        assertEquals(-120, mInfoDefault.getSignalStrength());
-        assertEquals(-110, mInfoCopy.getSignalStrength());
-    }
-
-    @Test
-    public void testGetSetSignalQuality() {
-        assertEquals(0, mInfoEmpty.getSignalQuality());
-        assertEquals(DEFAULT_SIGNAL_QUALITY, mInfoDefault.getSignalQuality());
-        assertEquals(DEFAULT_SIGNAL_QUALITY, mInfoCopy.getSignalQuality());
-
-        mInfoEmpty.setSignalQuality(DEFAULT_SIGNAL_QUALITY);
-        mInfoDefault.setSignalQuality(-10);
-        mInfoCopy.setSignalQuality(-5);
-
-        assertEquals(DEFAULT_SIGNAL_QUALITY, mInfoEmpty.getSignalQuality());
-        assertEquals(-10, mInfoDefault.getSignalQuality());
-        assertEquals(-5, mInfoCopy.getSignalQuality());
-    }
-
-    @Test
-    public void testGetSetSignalNoise() {
-        assertEquals(0, mInfoEmpty.getSignalNoise());
-        assertEquals(DEFAULT_SIGNAL_NOISE, mInfoDefault.getSignalNoise());
-        assertEquals(DEFAULT_SIGNAL_NOISE, mInfoCopy.getSignalNoise());
-
-        mInfoEmpty.setSignalNoise(DEFAULT_SIGNAL_NOISE);
-        mInfoDefault.setSignalNoise(1);
-        mInfoCopy.setSignalNoise(-1);
-
-        assertEquals(DEFAULT_SIGNAL_NOISE, mInfoEmpty.getSignalNoise());
-        assertEquals(1, mInfoDefault.getSignalNoise());
-        assertEquals(-1, mInfoCopy.getSignalNoise());
-    }
-
-    @Test
-    public void testGetSetIwlanSignalStrength() {
-        assertEquals(0, mInfoEmpty.getIwlanSignalStrength());
-        assertEquals(DEFAULT_IWLAN_SIGNAL_STRENGTH, mInfoDefault.getIwlanSignalStrength());
-        assertEquals(DEFAULT_IWLAN_SIGNAL_STRENGTH, mInfoCopy.getIwlanSignalStrength());
-
-        mInfoEmpty.setIwlanSignalStrength(DEFAULT_IWLAN_SIGNAL_STRENGTH);
-        mInfoDefault.setIwlanSignalStrength(-80);
-        mInfoCopy.setIwlanSignalStrength(-50);
-
-        assertEquals(DEFAULT_IWLAN_SIGNAL_STRENGTH, mInfoEmpty.getIwlanSignalStrength());
-        assertEquals(-80, mInfoDefault.getIwlanSignalStrength());
-        assertEquals(-50, mInfoCopy.getIwlanSignalStrength());
-    }
-
-    @Test
-    public void testGetSetUpdateReason() {
-        assertEquals(0, mInfoEmpty.getUpdateReason());
-        assertEquals(DEFAULT_UPDATE_REASON, mInfoDefault.getUpdateReason());
-        assertEquals(DEFAULT_UPDATE_REASON, mInfoCopy.getUpdateReason());
-
-        mInfoEmpty.setUpdateReason(0);
-        mInfoDefault.setUpdateReason(0);
-        mInfoCopy.setUpdateReason(0);
-
-        assertEquals(0, mInfoEmpty.getUpdateReason());
-        assertEquals(0, mInfoDefault.getUpdateReason());
-        assertEquals(0, mInfoCopy.getUpdateReason());
-    }
-
-    @Test
-    public void testGetSetImsCallType() {
-        assertEquals(0, mInfoEmpty.getImsCallType());
-        assertEquals(1, mInfoDefault.getImsCallType());
-        assertEquals(1, mInfoCopy.getImsCallType());
-
-        mInfoEmpty.setImsCallType(1);
-        mInfoDefault.setImsCallType(2);
-        mInfoCopy.setImsCallType(3);
-
-        assertEquals(1, mInfoEmpty.getImsCallType());
-        assertEquals(2, mInfoDefault.getImsCallType());
-        assertEquals(3, mInfoCopy.getImsCallType());
-    }
-
-    @Test
-    public void testGetSetImsCallQuality() {
-        assertEquals(0, mInfoEmpty.getImsCallQuality());
-        assertEquals(0, mInfoDefault.getImsCallQuality());
-        assertEquals(0, mInfoCopy.getImsCallQuality());
-
-        mInfoEmpty.setImsCallQuality(1);
-        mInfoDefault.setImsCallQuality(2);
-        mInfoCopy.setImsCallQuality(3);
-
-        assertEquals(1, mInfoEmpty.getImsCallQuality());
-        assertEquals(2, mInfoDefault.getImsCallQuality());
-        assertEquals(3, mInfoCopy.getImsCallQuality());
-    }
-
-    @Test
-    public void testGetSetSlotIndex() {
-        assertEquals(0, mInfoEmpty.getSlotIndex());
-        assertEquals(0, mInfoDefault.getSlotIndex());
-        assertEquals(0, mInfoCopy.getSlotIndex());
-
-        mInfoEmpty.setSlotIndex(1);
-        mInfoDefault.setSlotIndex(2);
-        mInfoCopy.setSlotIndex(3);
-
-        assertEquals(1, mInfoEmpty.getSlotIndex());
-        assertEquals(2, mInfoDefault.getSlotIndex());
-        assertEquals(3, mInfoCopy.getSlotIndex());
-    }
-
-    @Test
-    public void testToString() {
-        String strInfoEmpty = mInfoEmpty.toString();
-        String strInfoDefault = mInfoDefault.toString();
-        String strInfoCopy = mInfoCopy.toString();
-
-        assertNotNull(strInfoEmpty);
-        assertNotNull(strInfoDefault);
-        assertNotNull(strInfoCopy);
-
-        assertTrue(strInfoDefault.startsWith("AtomsQualifiedRatListChangedInfo"));
-
-        assertEquals(strInfoDefault, strInfoCopy);
-        assertNotEquals(strInfoEmpty, strInfoDefault);
-    }
-
-    @Test
-    public void testEquals() {
-        assertEquals(mInfoDefault, mInfoDefault);
-        assertNotEquals(mInfoDefault, new Object());
-        assertEquals(mInfoDefault, mInfoCopy);
-        mInfoDefault.setWfcEnabled(true);
-        mInfoCopy.setWfcEnabled(false);
-        assertNotEquals(mInfoDefault, mInfoCopy);
-    }
-
-    @Test
-    public void testHashCode() {
-        AtomsQualifiedRatListChangedInfo a1, a2;
-
-        a1 =
-                new AtomsQualifiedRatListChangedInfo(
-                        mNetCapability,
-                        mFirstQualifiedRat,
-                        mSecondQualifiedRat,
-                        mCurrentTransportType,
-                        mWfcEnabled,
-                        mWfcMode,
-                        mCellularNetworkType,
-                        mIwlanNetworkType,
-                        mRestrictionsOnWwan,
-                        mRestrictionsOnWlan,
-                        mSignalStrength,
-                        mSignalQuality,
-                        mSignalNoise,
-                        mIwlanSignalStrength,
-                        mUpdateReason,
-                        mImsCallType,
-                        mImsCallQuality,
-                        mSlotIndex);
-        a2 =
-                new AtomsQualifiedRatListChangedInfo(
-                        mNetCapability,
-                        mSecondQualifiedRat,
-                        mFirstQualifiedRat,
-                        mCurrentTransportType,
-                        mWfcEnabled,
-                        mWfcMode,
-                        mCellularNetworkType,
-                        mIwlanNetworkType,
-                        mRestrictionsOnWwan,
-                        mRestrictionsOnWlan,
-                        mSignalStrength,
-                        mSignalQuality,
-                        mSignalNoise,
-                        mIwlanSignalStrength,
-                        mUpdateReason,
-                        mImsCallType,
-                        mImsCallQuality,
-                        mSlotIndex);
-        assertNotEquals(a1.hashCode(), a2.hashCode());
-        a2 =
-                new AtomsQualifiedRatListChangedInfo(
-                        mNetCapability,
-                        mFirstQualifiedRat,
-                        mSecondQualifiedRat,
-                        mCurrentTransportType,
-                        mWfcEnabled,
-                        mWfcMode,
-                        mCellularNetworkType,
-                        mIwlanNetworkType,
-                        mRestrictionsOnWwan,
-                        mRestrictionsOnWlan,
-                        mSignalStrength,
-                        mSignalQuality,
-                        mSignalNoise,
-                        mIwlanSignalStrength,
-                        mUpdateReason,
-                        mImsCallType,
-                        mImsCallQuality,
-                        mSlotIndex);
-        assertEquals(a1.hashCode(), a2.hashCode());
-    }
-
-    @Test
-    public void testStatsId() {
-        final int statsId = 634; // QualifiedRatListChanged
-        assertEquals(statsId, mInfoDefault.copy().getStatsId());
-    }
-
-    @Test
-    public void testStatsEventBuilder() {
-        mInfoDefault.build(mStatsEventBuilder);
-
-        verify(mStatsEventBuilder, times(1)).writeBoolean(anyBoolean());
-        verify(mStatsEventBuilder, times(17)).writeInt(anyInt());
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/wfc/WfcActivationActivityTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/wfc/WfcActivationActivityTest.java
deleted file mode 100644
index bde80a5..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/wfc/WfcActivationActivityTest.java
+++ /dev/null
@@ -1,336 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.telephony.qns.wfc;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.when;
-
-import android.app.UiAutomation;
-import android.content.Context;
-import android.content.Intent;
-import android.net.ConnectivityManager;
-import android.net.NetworkInfo;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
-import android.os.PowerManager;
-import android.os.SystemClock;
-import android.telephony.SubscriptionManager;
-import android.telephony.ims.ImsMmTelManager;
-import android.testing.AndroidTestingRunner;
-import android.testing.TestableLooper;
-import android.testing.TestableLooper.RunWithLooper;
-
-import androidx.activity.result.ActivityResultLauncher;
-import androidx.test.core.app.ActivityScenario;
-import androidx.test.core.app.ApplicationProvider;
-import androidx.test.platform.app.InstrumentationRegistry;
-
-import java.util.concurrent.atomic.AtomicReference;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.junit.MockitoJUnit;
-import org.mockito.junit.MockitoRule;
-
-/** Tests for class {@link WfcActivationActivity} */
-@RunWith(AndroidTestingRunner.class)
-@RunWithLooper
-public final class WfcActivationActivityTest {
-    @Rule public final MockitoRule mockito = MockitoJUnit.rule();
-
-    private final Context mAppContext = ApplicationProvider.getApplicationContext();
-    private static final int SUB_ID = 1;
-
-    private WfcActivationHelper mWfcActivationHelper;
-    private ActivityScenario<WfcActivationActivity> mActivityScenario;
-    private TestableLooper mTestableLooper;
-    boolean mIsTestExecuted;
-
-    @Mock private ConnectivityManager mockConnectivityManager;
-    @Mock private ImsMmTelManager mockImsMmTelManager;
-    @Mock private WfcCarrierConfigManager mockCarrierConfigManager;
-    @Mock private NetworkInfo mockNetworkInfo;
-    @Mock private ActivityResultLauncher<Intent> mockActivityResultLauncher;
-
-    @Before
-    public void setUp() {
-        when(mockConnectivityManager.getActiveNetworkInfo()).thenReturn(mockNetworkInfo);
-        when(mockNetworkInfo.isConnected()).thenReturn(true);
-        when(mockNetworkInfo.getType()).thenReturn(ConnectivityManager.TYPE_WIFI);
-        when(mockCarrierConfigManager.getVowifiEntitlementServerUrl())
-                .thenReturn("https://test_rul");
-        when(mockCarrierConfigManager.supportJsCallbackForVowifiPortal())
-                .thenReturn(true);
-        when(mockCarrierConfigManager.isShowVowifiPortalAfterTimeout()).thenReturn(true);
-        when(mockCarrierConfigManager.getVowifiRegistrationTimerForVowifiActivation())
-                .thenReturn(100);
-        mTestableLooper = TestableLooper.get(this);
-        mIsTestExecuted = false;
-        turnOnAndUnlockScreen();
-    }
-
-    @After
-    public void tearDown() {
-        if (mActivityScenario != null) {
-            mActivityScenario.close();
-        }
-    }
-
-    @Test
-    public void testMessageCheckWifi_pass() {
-        mWfcActivationHelper =
-                new WfcActivationHelper(
-                        mAppContext,
-                        SUB_ID,
-                        mockConnectivityManager,
-                        mockImsMmTelManager,
-                        mockCarrierConfigManager,
-                        Runnable::run) {};
-        WfcUtils.setWfcActivationHelper(mWfcActivationHelper);
-
-        mActivityScenario =
-                ActivityScenario.launch(
-                        new Intent(mAppContext, WfcActivationActivity.class)
-                                .putExtra(
-                                        WfcUtils.EXTRA_LAUNCH_CARRIER_APP,
-                                        WfcUtils.LAUNCH_APP_ACTIVATE)
-                                .putExtra(SubscriptionManager.EXTRA_SUBSCRIPTION_INDEX, SUB_ID));
-        verify(mockConnectivityManager).getActiveNetworkInfo();
-    }
-
-    @Test
-    public void testMessageCheckWifiDone_wifiConnectionSuccess_showProgressDialog() {
-        mWfcActivationHelper =
-                new WfcActivationHelper(
-                        mAppContext,
-                        SUB_ID,
-                        mockConnectivityManager,
-                        mockImsMmTelManager,
-                        mockCarrierConfigManager,
-                        Runnable::run);
-        WfcUtils.setWfcActivationHelper(mWfcActivationHelper);
-
-        mActivityScenario =
-                ActivityScenario.launch(
-                        new Intent(mAppContext, WfcActivationActivity.class)
-                                .putExtra(
-                                        WfcUtils.EXTRA_LAUNCH_CARRIER_APP,
-                                        WfcUtils.LAUNCH_APP_ACTIVATE)
-                                .putExtra(SubscriptionManager.EXTRA_SUBSCRIPTION_INDEX, SUB_ID));
-
-        mActivityScenario.onActivity(
-                activity -> {
-                    assertNotNull(activity.mProgressDialog);
-                    assertTrue(activity.mProgressDialog.isShowing());
-                    mIsTestExecuted = true;
-                });
-       assertTrue(mIsTestExecuted);
-    }
-
-  @Test
-  public void testMessageCheckWifiDone_wifiConnectionError_showWiFiUnavailableDialog() {
-      when(mockNetworkInfo.getType()).thenReturn(ConnectivityManager.TYPE_MOBILE);
-      mWfcActivationHelper =
-              new WfcActivationHelper(
-                      mAppContext,
-                      SUB_ID,
-                      mockConnectivityManager,
-                      mockImsMmTelManager,
-                      mockCarrierConfigManager,
-                      Runnable::run);
-      WfcUtils.setWfcActivationHelper(mWfcActivationHelper);
-
-      mActivityScenario =
-              ActivityScenario.launch(
-                      new Intent(mAppContext, WfcActivationActivity.class)
-                              .putExtra(
-                                      WfcUtils.EXTRA_LAUNCH_CARRIER_APP,
-                                      WfcUtils.LAUNCH_APP_ACTIVATE)
-                              .putExtra(SubscriptionManager.EXTRA_SUBSCRIPTION_INDEX, SUB_ID));
-
-      mActivityScenario.onActivity(
-              activity -> {
-                  assertNull(activity.mProgressDialog);
-                  assertThat(activity.getSupportFragmentManager().getFragments().get(0))
-                          .isInstanceOf(WfcActivationActivity.AlertDialogFragment.class);
-                  mIsTestExecuted = true;
-              });
-     assertTrue(mIsTestExecuted);
-  }
-
-    @Test
-    public void testMessageTryEpdgConnectionDone_imsMmTelManagerNotNull_epdgConnectionSuccess() {
-        mWfcActivationHelper =
-                new WfcActivationHelper(
-                        mAppContext,
-                        SUB_ID,
-                        mockConnectivityManager,
-                        mockImsMmTelManager,
-                        mockCarrierConfigManager,
-                        Runnable::run) {
-                    @Override
-                    public void tryEpdgConnectionOverWiFi(Message msg, int timeout) {
-                           FakeEpdgConnectHandler handler =
-                                   new FakeEpdgConnectHandler(mTestableLooper.getLooper(), msg);
-                           handler.obtainMessage(WfcActivationHelper.EPDG_CONNECTION_SUCCESS)
-                                   .sendToTarget();
-                    }
-                };
-        WfcUtils.setWfcActivationHelper(mWfcActivationHelper);
-        mActivityScenario =
-                ActivityScenario.launch(
-                        new Intent(mAppContext, WfcActivationActivity.class)
-                                .putExtra(
-                                        WfcUtils.EXTRA_LAUNCH_CARRIER_APP,
-                                        WfcUtils.LAUNCH_APP_ACTIVATE)
-                                .putExtra(SubscriptionManager.EXTRA_SUBSCRIPTION_INDEX, SUB_ID));
-        mTestableLooper.processAllMessages();
-
-        mActivityScenario.onActivity(
-                activity -> {
-                    assertNull(activity.mProgressDialog);
-                    assertThat(activity.getSupportFragmentManager().getFragments()).isEmpty();
-                    mIsTestExecuted = true;
-                });
-        assertTrue(mIsTestExecuted);
-    }
-
-    @Test
-    public void testMessageShowWebPortal_imsMmTelManagerNull_showWfcWebPortal() {
-        mWfcActivationHelper =
-                new WfcActivationHelper(
-                        mAppContext,
-                        SUB_ID,
-                        mockConnectivityManager,
-                        null,
-                        mockCarrierConfigManager,
-                        Runnable::run) {};
-        WfcUtils.setWfcActivationHelper(mWfcActivationHelper);
-        WfcUtils.setWebviewResultLauncher(mockActivityResultLauncher);
-
-        mActivityScenario =
-                ActivityScenario.launch(
-                        new Intent(mAppContext, WfcActivationActivity.class)
-                                .putExtra(
-                                        WfcUtils.EXTRA_LAUNCH_CARRIER_APP,
-                                        WfcUtils.LAUNCH_APP_ACTIVATE)
-                                .putExtra(SubscriptionManager.EXTRA_SUBSCRIPTION_INDEX, SUB_ID));
-
-        mActivityScenario.onActivity(
-                activity -> {
-                    assertNull(activity.mServiceConnection);
-                    verify(mockActivityResultLauncher).launch(any());
-                    mIsTestExecuted = true;
-                });
-        assertTrue(mIsTestExecuted);
-    }
-
-    @Test
-    public void startWebPortal_unsupportedJsCallback_launchChrome() {
-       when(mockCarrierConfigManager.supportJsCallbackForVowifiPortal())
-               .thenReturn(false);
-        mWfcActivationHelper =
-                new WfcActivationHelper(
-                        mAppContext,
-                        SUB_ID,
-                        mockConnectivityManager,
-                        mockImsMmTelManager,
-                        mockCarrierConfigManager,
-                        Runnable::run) {
-                    @Override
-                    public void tryEpdgConnectionOverWiFi(Message msg, int timeout) {
-                           FakeEpdgConnectHandler handler =
-                                   new FakeEpdgConnectHandler(mTestableLooper.getLooper(), msg);
-                           handler.obtainMessage(WfcActivationHelper.EPDG_CONNECTION_ERROR)
-                                   .sendToTarget();
-                    }
-                };
-        WfcUtils.setWfcActivationHelper(mWfcActivationHelper);
-
-        mActivityScenario =
-                ActivityScenario.launch(
-                        new Intent(mAppContext, WfcActivationActivity.class)
-                                .putExtra(
-                                        WfcUtils.EXTRA_LAUNCH_CARRIER_APP,
-                                        WfcUtils.LAUNCH_APP_ACTIVATE)
-                                .putExtra(SubscriptionManager.EXTRA_SUBSCRIPTION_INDEX, SUB_ID));
-        mTestableLooper.processAllMessages();
-
-        mActivityScenario.onActivity(
-                activity -> {
-                    assertThat(activity.mServiceConnection).isNotNull();
-                    verifyNoMoreInteractions(mockActivityResultLauncher);
-                    mIsTestExecuted = true;
-                });
-        assertTrue(mIsTestExecuted);
-    }
-
-    private void turnOnAndUnlockScreen() {
-        UiAutomation uiAutomation= InstrumentationRegistry.getInstrumentation().getUiAutomation();
-        String screenOnCmd = "input keyevent KEYCODE_WAKEUP";
-        uiAutomation.executeShellCommand(screenOnCmd);
-        waitCmdCompletion();
-        String unlockCmd = "input keyevent KEYCODE_MENU";
-        uiAutomation.executeShellCommand(unlockCmd);
-        waitCmdCompletion();
-    }
-
-    private void  waitCmdCompletion() {
-          PowerManager powerManager = mAppContext.getSystemService(PowerManager.class);
-          int waitTimeMs = 100;
-          final long timeoutMs = SystemClock.uptimeMillis() + 10 * 1000;
-
-          while (SystemClock.uptimeMillis() < timeoutMs) {
-              if (powerManager.isInteractive()) {
-                  return;
-              }
-              try {
-                  Thread.sleep(waitTimeMs);
-              } catch (Exception e) {
-                  throw new AssertionError("Thread sleep fails", e);
-              }
-              waitTimeMs = waitTimeMs * 2;
-              waitTimeMs = Math.min(1000, waitTimeMs);
-          }
-    }
-
-    static private class FakeEpdgConnectHandler extends Handler {
-          final Message result;
-
-          FakeEpdgConnectHandler(Looper looper, Message result) {
-            super(looper);
-            this.result = result;
-        }
-
-        @Override
-        public void handleMessage(Message msg) {
-            result.arg1 = msg.what;
-            result.sendToTarget();
-        }
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/wfc/WfcActivationHelperTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/wfc/WfcActivationHelperTest.java
deleted file mode 100644
index 1f42a89..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/wfc/WfcActivationHelperTest.java
+++ /dev/null
@@ -1,284 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.telephony.qns.wfc;
-
-import static androidx.test.ext.truth.content.IntentSubject.assertThat;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyBoolean;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.app.Application;
-import android.content.Intent;
-import android.net.ConnectivityManager;
-import android.net.NetworkInfo;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Looper;
-import android.os.Message;
-import android.os.TestLooperManager;
-import android.telephony.AccessNetworkConstants;
-import android.telephony.ims.ImsMmTelManager;
-import android.telephony.ims.ImsReasonInfo;
-
-import androidx.test.core.app.ApplicationProvider;
-import androidx.test.platform.app.InstrumentationRegistry;
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Captor;
-import org.mockito.InOrder;
-import org.mockito.Mock;
-import org.mockito.Mockito;
-import org.mockito.junit.MockitoJUnit;
-import org.mockito.junit.MockitoRule;
-
-/** Tests for {@link WfcActivationHelper} */
-@RunWith(AndroidJUnit4.class)
-public final class WfcActivationHelperTest {
-    private static final int RANDOM_INT = 3721;
-    private static final int RANDOM_MESSAGE_ID = 2000;
-    private static final int TIMEOUT_MS = 1000;
-    private static final int SUB_ID = 1;
-    private static final ImsReasonInfo IMS_IKEV2_AUTH_FAILURE =
-            new ImsReasonInfo(
-                    ImsReasonInfo.CODE_EPDG_TUNNEL_ESTABLISH_FAILURE,
-                    ImsReasonInfo.CODE_IKEV2_AUTH_FAILURE,
-                    null);
-
-    @Mock ConnectivityManager mockConnectivityManager;
-    @Mock ImsMmTelManager mockImsMmTelManager;
-    @Mock private WfcCarrierConfigManager mockCarrierConfigManager;
-    @Mock NetworkInfo mockNetworkInfo;
-    @Captor ArgumentCaptor<WfcActivationHelper.ImsCallback> imsCallbackCaptor;
-    @Captor ArgumentCaptor<Intent> tryWfcConnectionIntentCaptor;
-
-    @Rule public final MockitoRule mockito = MockitoJUnit.rule();
-
-    private HandlerThread mUiThread;
-    private TestLooperManager mTestLooperManager;
-    private Message mMessage;
-    private Message[] mCaughtMessages;
-    private WfcActivationHelper mTestHelper;
-    private Handler mHandler;
-
-    private final Application appContext = spy(ApplicationProvider.getApplicationContext());
-
-    @Before
-    public void setUp() {
-        mUiThread = new HandlerThread("MockUiThread");
-        mUiThread.start();
-
-        mCaughtMessages = new Message[] {new Message()};
-        mHandler =
-                new Handler(
-                        mUiThread.getLooper(),
-                        (Message msg) -> {
-                            if (msg.what == RANDOM_MESSAGE_ID) {
-                                mCaughtMessages[0].copyFrom(msg);
-                                return true;
-                            }
-                            return false;
-                        });
-        mMessage = Message.obtain(mHandler, RANDOM_MESSAGE_ID, RANDOM_INT, 0);
-        mTestLooperManager =
-                InstrumentationRegistry.getInstrumentation()
-                        .acquireLooperManager(mUiThread.getLooper());
-
-        mTestHelper =
-                new WfcActivationHelper(
-                        appContext,
-                        SUB_ID,
-                        mockConnectivityManager,
-                        mockImsMmTelManager,
-                        mockCarrierConfigManager,
-                        Runnable::run);
-    }
-
-    @After
-    public void tearDown() {
-        mTestLooperManager.release();
-        mUiThread.quit();
-    }
-
-    @Test
-    public void checkWiFi_networkInfoTypeWiFi_wiFiConnectionSuccess() throws Exception {
-        when(mockConnectivityManager.getActiveNetworkInfo()).thenReturn(mockNetworkInfo);
-        when(mockNetworkInfo.isConnected()).thenReturn(true);
-        when(mockNetworkInfo.getType()).thenReturn(ConnectivityManager.TYPE_WIFI);
-
-        mTestHelper.checkWiFi(mMessage);
-
-        mTestLooperManager.execute(mTestLooperManager.next());
-        assertThat(mCaughtMessages[0].what).isEqualTo(RANDOM_MESSAGE_ID);
-        assertThat(mCaughtMessages[0].arg1).isEqualTo(WfcActivationHelper.WIFI_CONNECTION_SUCCESS);
-    }
-
-    @Test
-    public void checkWiFi_networkInfoTypeMobile_wiFiConnectionError() throws Exception {
-        when(mockConnectivityManager.getActiveNetworkInfo()).thenReturn(mockNetworkInfo);
-        when(mockNetworkInfo.isConnected()).thenReturn(true);
-        when(mockNetworkInfo.getType()).thenReturn(ConnectivityManager.TYPE_MOBILE);
-
-        mTestHelper.checkWiFi(mMessage);
-
-        mTestLooperManager.execute(mTestLooperManager.next());
-        assertThat(mCaughtMessages[0].what).isEqualTo(RANDOM_MESSAGE_ID);
-        assertThat(mCaughtMessages[0].arg1).isEqualTo(WfcActivationHelper.WIFI_CONNECTION_ERROR);
-    }
-
-    @Test
-    public void tryEpdgConnectionOverWiFi_imsMmTelManagerNull_wiFiConnectionError()
-            throws Exception {
-        mTestHelper =
-                new WfcActivationHelper(
-                        appContext,
-                        SUB_ID,
-                        mockConnectivityManager,
-                        null,
-                        mockCarrierConfigManager,
-                        Runnable::run);
-
-        mTestHelper.tryEpdgConnectionOverWiFi(mMessage, TIMEOUT_MS);
-
-        mTestLooperManager.execute(mTestLooperManager.next());
-        assertThat(mCaughtMessages[0].what).isEqualTo(RANDOM_MESSAGE_ID);
-        assertThat(mCaughtMessages[0].arg1).isEqualTo(WfcActivationHelper.WIFI_CONNECTION_ERROR);
-    }
-
-    @Test
-    public void tryEpdgConnectionOverWiFi_showVowifiPortalFalse_resultSuccess() throws Exception {
-        when(mockCarrierConfigManager.isShowVowifiPortalAfterTimeout()).thenReturn(false);
-
-        mTestHelper.tryEpdgConnectionOverWiFi(mMessage, TIMEOUT_MS);
-
-        moveLooperToEvent(WfcActivationHelper.EVENT_PRE_START_ATTEMPT);
-        verify(mockImsMmTelManager)
-                .registerImsRegistrationCallback(any(), imsCallbackCaptor.capture());
-
-        moveLooperToEvent(WfcActivationHelper.EVENT_FINISH_ATTEMPT);
-        mTestLooperManager.execute(mTestLooperManager.next());
-        assertThat(mCaughtMessages[0].what).isEqualTo(RANDOM_MESSAGE_ID);
-        assertThat(mCaughtMessages[0].arg1).isEqualTo(WfcActivationHelper.EPDG_CONNECTION_SUCCESS);
-    }
-
-    @Test
-    public void tryEpdgConnectionOverWiFi_showVowifiPortalTrue_resultError() throws Exception {
-        when(mockCarrierConfigManager.isShowVowifiPortalAfterTimeout()).thenReturn(true);
-
-        mTestHelper.tryEpdgConnectionOverWiFi(mMessage, TIMEOUT_MS);
-
-        moveLooperToEvent(WfcActivationHelper.EVENT_PRE_START_ATTEMPT);
-        verify(mockImsMmTelManager)
-                .registerImsRegistrationCallback(any(), imsCallbackCaptor.capture());
-
-        moveLooperToEvent(WfcActivationHelper.EVENT_FINISH_ATTEMPT);
-        mTestLooperManager.execute(mTestLooperManager.next());
-        assertThat(mCaughtMessages[0].what).isEqualTo(RANDOM_MESSAGE_ID);
-        assertThat(mCaughtMessages[0].arg1).isEqualTo(WfcActivationHelper.EPDG_CONNECTION_ERROR);
-    }
-
-    @Test
-    public void tryEpdgConnectionOverWiFi_success() throws Exception {
-        mTestHelper.tryEpdgConnectionOverWiFi(mMessage, TIMEOUT_MS);
-        InOrder inOrderIntent = Mockito.inOrder(appContext);
-
-        moveLooperToEvent(WfcActivationHelper.EVENT_PRE_START_ATTEMPT);
-        verify(mockImsMmTelManager)
-                .registerImsRegistrationCallback(any(), imsCallbackCaptor.capture());
-        ImsMmTelManager.RegistrationCallback imsCallback = imsCallbackCaptor.getValue();
-
-        // During the PRE_EPDG_CONNECTION_DELAY_MS, received registration failure: no op.
-        imsCallback.onUnregistered(IMS_IKEV2_AUTH_FAILURE);
-
-        moveLooperToEvent(WfcActivationHelper.EVENT_START_ATTEMPT);
-        assertThat(mCaughtMessages[0].what).isNotEqualTo(RANDOM_MESSAGE_ID);
-        // After PRE_EPDG_CONNECTION_DELAY_MS, start triggering ePDG connection
-        verify(mockImsMmTelManager).setVoWiFiNonPersistent(true, /* WiFi preferred*/ 2);
-        inOrderIntent.verify(appContext).sendBroadcast(tryWfcConnectionIntentCaptor.capture());
-        verifyWfcIntent(tryWfcConnectionIntentCaptor.getValue(), WfcActivationHelper.STATUS_START);
-
-        // Eeceived registration success: return success
-        imsCallback.onRegistered(AccessNetworkConstants.TRANSPORT_TYPE_WLAN);
-
-        moveLooperToEvent(WfcActivationHelper.EVENT_FINISH_ATTEMPT);
-        mTestLooperManager.execute(mTestLooperManager.next());
-        verify(mockImsMmTelManager).unregisterImsRegistrationCallback(imsCallback);
-        assertThat(mCaughtMessages[0].what).isEqualTo(RANDOM_MESSAGE_ID);
-        assertThat(mCaughtMessages[0].arg1).isEqualTo(WfcActivationHelper.EPDG_CONNECTION_SUCCESS);
-        verify(mockImsMmTelManager).setVoWiFiSettingEnabled(true);
-        inOrderIntent.verify(appContext).sendBroadcast(tryWfcConnectionIntentCaptor.capture());
-        verifyWfcIntent(tryWfcConnectionIntentCaptor.getValue(), WfcActivationHelper.STATUS_END);
-    }
-
-    @Test
-    public void tryEpdgConnectionOverWiFi_failure() throws Exception {
-        mTestHelper.tryEpdgConnectionOverWiFi(mMessage, TIMEOUT_MS);
-        InOrder inOrderIntent = Mockito.inOrder(appContext);
-
-        moveLooperToEvent(WfcActivationHelper.EVENT_PRE_START_ATTEMPT);
-        verify(mockImsMmTelManager)
-                .registerImsRegistrationCallback(any(), imsCallbackCaptor.capture());
-        ImsMmTelManager.RegistrationCallback imsCallback = imsCallbackCaptor.getValue();
-
-        // After PRE_EPDG_CONNECTION_DELAY_MS, start triggering ePDG connection
-        moveLooperToEvent(WfcActivationHelper.EVENT_START_ATTEMPT);
-        verify(mockImsMmTelManager).setVoWiFiNonPersistent(true, /* WiFi preferred */ 2);
-        inOrderIntent.verify(appContext).sendBroadcast(tryWfcConnectionIntentCaptor.capture());
-        verifyWfcIntent(tryWfcConnectionIntentCaptor.getValue(), WfcActivationHelper.STATUS_START);
-
-        imsCallback.onTechnologyChangeFailed(
-                AccessNetworkConstants.TRANSPORT_TYPE_WLAN, IMS_IKEV2_AUTH_FAILURE);
-
-        moveLooperToEvent(WfcActivationHelper.EVENT_FINISH_ATTEMPT);
-        mTestLooperManager.execute(mTestLooperManager.next());
-        verify(mockImsMmTelManager).setVoWiFiNonPersistent(false, /* mobile preferred */ 1);
-        verify(mockImsMmTelManager).unregisterImsRegistrationCallback(imsCallback);
-        assertThat(mCaughtMessages[0].what).isEqualTo(RANDOM_MESSAGE_ID);
-        assertThat(mCaughtMessages[0].arg1).isEqualTo(WfcActivationHelper.EPDG_CONNECTION_ERROR);
-        inOrderIntent.verify(appContext).sendBroadcast(tryWfcConnectionIntentCaptor.capture());
-        verifyWfcIntent(tryWfcConnectionIntentCaptor.getValue(), WfcActivationHelper.STATUS_END);
-        // Do not change WFC ON/OFF
-        verify(mockImsMmTelManager, never()).setVoWiFiSettingEnabled(anyBoolean());
-    }
-
-    private static void verifyWfcIntent(Intent intent, int tryStatus) {
-        assertThat(intent).hasAction(WfcActivationHelper.ACTION_TRY_WFC_CONNECTION);
-        assertThat(intent).extras().integer(WfcActivationHelper.EXTRA_SUB_ID).isEqualTo(SUB_ID);
-        assertThat(intent)
-                .extras()
-                .integer(WfcActivationHelper.EXTRA_TRY_STATUS)
-                .isEqualTo(tryStatus);
-    }
-
-    void moveLooperToEvent(int event) {
-        Message msg;
-        do {
-            msg = mTestLooperManager.next();
-            mTestLooperManager.execute(msg);
-        } while (msg.what != event);
-    }
-}
diff --git a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/wfc/WfcCarrierConfigManagerTest.java b/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/wfc/WfcCarrierConfigManagerTest.java
deleted file mode 100644
index 4ad605f..0000000
--- a/services/QualifiedNetworksService/tests/src/com/android/telephony/qns/wfc/WfcCarrierConfigManagerTest.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.telephony.qns.wfc;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-import android.content.Context;
-import android.os.PersistableBundle;
-
-import com.android.telephony.qns.QnsTest;
-
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.MockitoAnnotations;
-
-/** Tests for {@link WfcCarrierConfigManagerTest} */
-@RunWith(JUnit4.class)
-public final class WfcCarrierConfigManagerTest extends QnsTest {
-    private WfcCarrierConfigManager mConfigManager;
-
-    @Before
-    public void setup() throws Exception {
-        MockitoAnnotations.initMocks(this);
-        super.setUp();
-        mConfigManager = new WfcCarrierConfigManager(sMockContext, 0);
-        mConfigManager.loadConfigurations();
-    }
-
-    @Test
-    public void testIsShowVowifiPortalAfterTimeout() {
-        // Test for the default setting
-        assertTrue(mConfigManager.isShowVowifiPortalAfterTimeout());
-
-        // Test for a new setting
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putBoolean(
-                WfcCarrierConfigManager
-                        .KEY_QNS_SHOW_VOWIFI_PORTAL_AFTER_TIMEOUT_BOOL,
-                false);
-        mConfigManager.loadConfigurationsFromCarrierConfig(bundle);
-        assertFalse(mConfigManager.isShowVowifiPortalAfterTimeout());
-    }
-
-    @Test
-    public void testSupportJsCallbackForVowifiPortal() {
-        // Test for the default setting
-        assertFalse(mConfigManager.supportJsCallbackForVowifiPortal());
-
-        // Test for a new setting
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putBoolean(
-                WfcCarrierConfigManager
-                        .KEY_QNS_JS_CALLBACK_FOR_VOWIFI_PORTAL_BOOL,
-                true);
-        mConfigManager.loadConfigurationsFromCarrierConfig(bundle);
-        assertTrue(mConfigManager.supportJsCallbackForVowifiPortal());
-    }
-
-    @Test
-    public void testGetVowifiRegistrationTimerForVowifiActivation() {
-        // Test for the default setting
-        int defaultTimer = mConfigManager.getVowifiRegistrationTimerForVowifiActivation();
-        Assert.assertEquals(WfcCarrierConfigManager.CONFIG_DEFAULT_VOWIFI_REGISTATION_TIMER,
-                defaultTimer);
-
-        // Test for a new setting
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putInt(
-                WfcCarrierConfigManager
-                        .KEY_QNS_VOWIFI_REGISTATION_TIMER_FOR_VOWIFI_ACTIVATION_INT,
-                60000);
-        mConfigManager.loadConfigurationsFromCarrierConfig(bundle);
-        Assert.assertEquals(60000, mConfigManager.getVowifiRegistrationTimerForVowifiActivation());
-    }
-
-    @Test
-    public void testGetVowifiEntitlementServerUrl() {
-        // Test for the default setting
-        Assert.assertEquals("", mConfigManager.getVowifiEntitlementServerUrl());
-
-        // Test for a new setting
-        PersistableBundle bundle = new PersistableBundle();
-        bundle.putString(
-                WfcCarrierConfigManager
-                        .KEY_QNS_VOWIFI_ENTITLEMENT_SERVER_URL_STRING,
-                "www.google.com");
-        mConfigManager.loadConfigurationsFromCarrierConfig(bundle);
-        Assert.assertEquals(
-                "www.google.com", mConfigManager.getVowifiEntitlementServerUrl());
-    }
-}
diff --git a/tests/cts/Android.bp b/tests/cts/Android.bp
new file mode 100644
index 0000000..ceb5e03
--- /dev/null
+++ b/tests/cts/Android.bp
@@ -0,0 +1,44 @@
+//
+// Copyright (C) 2025 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+package {
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+android_test {
+    name: "CtsTelephonyModuleTests",
+    team: "trendy_team_fwk_telephony",
+    platform_apis: true,
+    min_sdk_version: "36",
+    sdk_version: "test_current",
+
+    srcs: [
+        "src/**/*.java",
+    ],
+
+    static_libs: [
+        "androidx.test.runner",
+        "junit",
+    ],
+
+    // Tag this module as an mts test artifact
+    test_suites: [
+        "cts",
+        "general-tests",
+        "mts-telephony2",
+        "mcts-telephony2",
+    ],
+}
diff --git a/services/QualifiedNetworksService/privapp-permissions_com.android.telephony.qns.xml b/tests/cts/AndroidManifest.xml
similarity index 52%
rename from services/QualifiedNetworksService/privapp-permissions_com.android.telephony.qns.xml
rename to tests/cts/AndroidManifest.xml
index 3f31bcf..7fb9cc4 100644
--- a/services/QualifiedNetworksService/privapp-permissions_com.android.telephony.qns.xml
+++ b/tests/cts/AndroidManifest.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
- * Copyright (C) 2021 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,12 +14,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  -->
-<permissions>
-    <privapp-permissions package="com.android.telephony.qns">
-        <permission name="android.permission.MODIFY_PHONE_STATE"/>
-        <permission name="android.permission.NETWORK_SIGNAL_STRENGTH_WAKEUP"/>
-        <permission name="android.permission.READ_PRECISE_PHONE_STATE"/>
-        <permission name="android.permission.READ_PRIVILEGED_PHONE_STATE"/>
-        <permission name="android.permission.REGISTER_STATS_PULL_ATOM" />
-    </privapp-permissions>
-</permissions>
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="android.telephony.module.cts">
+
+    <uses-sdk android:minSdkVersion="36" android:targetSdkVersion="36" />
+
+    <application android:label="CtsTelephonyModuleTests">
+    </application>
+
+    <instrumentation android:name="androidx.test.runner.AndroidJUnitRunner"
+        android:targetPackage="android.telephony.module.cts"
+        android:label="CTS tests of android telephony module">
+    </instrumentation>
+
+</manifest>
diff --git a/tests/cts/AndroidTest.xml b/tests/cts/AndroidTest.xml
new file mode 100644
index 0000000..22da08c
--- /dev/null
+++ b/tests/cts/AndroidTest.xml
@@ -0,0 +1,34 @@
+<!-- Copyright (C) 2025 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<configuration description="Config for CTS Telephony Module test cases">
+    <option name="test-suite-tag" value="cts" />
+    <option name="config-descriptor:metadata" key="component" value="telecom" />
+    <option name="config-descriptor:metadata" key="parameter" value="not_instant_app" />
+    <option name="config-descriptor:metadata" key="parameter" value="not_multi_abi" />
+    <option name="config-descriptor:metadata" key="parameter" value="secondary_user" />
+    <option name="config-descriptor:metadata" key="parameter" value="no_foldable_states" />
+    <target_preparer class="com.android.tradefed.targetprep.suite.SuiteApkInstaller">
+        <option name="cleanup-apks" value="true" />
+        <option name="test-file-name" value="CtsTelephonyModuleTests.apk" />
+    </target_preparer>
+    <test class="com.android.tradefed.testtype.AndroidJUnitTest" >
+        <option name="package" value="android.telephony.module.cts" />
+        <option name="hidden-api-checks" value="false" />
+    </test>
+
+    <object type="module_controller" class="com.android.tradefed.testtype.suite.module.MainlineTestModuleController">
+        <option name="mainline-module-package-name" value="com.google.android.telephony2" />
+    </object>
+</configuration>
\ No newline at end of file
diff --git a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsAsyncResult.java b/tests/cts/src/android/telephony/module/cts/PhoneNumberManagerCtsTest.java
similarity index 61%
rename from services/QualifiedNetworksService/src/com/android/telephony/qns/QnsAsyncResult.java
rename to tests/cts/src/android/telephony/module/cts/PhoneNumberManagerCtsTest.java
index 997b6bd..991b120 100644
--- a/services/QualifiedNetworksService/src/com/android/telephony/qns/QnsAsyncResult.java
+++ b/tests/cts/src/android/telephony/module/cts/PhoneNumberManagerCtsTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2022 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,18 +14,12 @@
  * limitations under the License.
  */
 
-package com.android.telephony.qns;
+package com.android.telephony.module.tests;
 
-/** @hide */
-class QnsAsyncResult {
-    Object mUserObj;
-    Throwable mException;
-    Object mResult;
+import org.junit.Test;
 
-    /** please note, this sets m.obj to be this */
-    QnsAsyncResult(Object uo, Object r, Throwable ex) {
-        mUserObj = uo;
-        mResult = r;
-        mException = ex;
+public class PhoneNumberManagerCtsTest {
+    @Test
+    public void dummyTest() {
     }
 }
diff --git a/tests/unit/Android.bp b/tests/unit/Android.bp
new file mode 100644
index 0000000..664734f
--- /dev/null
+++ b/tests/unit/Android.bp
@@ -0,0 +1,42 @@
+//
+// Copyright (C) 2025 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+package {
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+android_test {
+    name: "TelephonyModuleTests",
+    team: "trendy_team_fwk_telephony",
+    platform_apis: true,
+    min_sdk_version: "36",
+    sdk_version: "test_current",
+
+    srcs: [
+        "src/**/*.java",
+    ],
+
+    static_libs: [
+        "androidx.test.runner",
+        "junit",
+    ],
+
+    // Tag this module as an mts test artifact
+    test_suites: [
+        "general-tests",
+        "mts-telephony2",
+    ],
+}
diff --git a/tests/unit/AndroidManifest.xml b/tests/unit/AndroidManifest.xml
new file mode 100644
index 0000000..c6f2af5
--- /dev/null
+++ b/tests/unit/AndroidManifest.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2025 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License
+  -->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.android.telephony.module.tests">
+
+    <uses-sdk android:minSdkVersion="36" android:targetSdkVersion="36" />
+
+    <application android:label="TelephonyModuleTests">
+    </application>
+
+    <instrumentation android:name="androidx.test.runner.AndroidJUnitRunner"
+        android:targetPackage="com.android.telephony.module.tests"
+        android:label="Telephony Module Unit Tests" />
+</manifest>
diff --git a/tests/unit/AndroidTest.xml b/tests/unit/AndroidTest.xml
new file mode 100644
index 0000000..1a6896f
--- /dev/null
+++ b/tests/unit/AndroidTest.xml
@@ -0,0 +1,32 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2020 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<configuration description="Runs Telephony Module Unit Tests.">
+    <option name="test-suite-tag" value="apct" />
+    <option name="test-suite-tag" value="apct-instrumentation" />
+    <target_preparer class="com.android.tradefed.targetprep.suite.SuiteApkInstaller">
+        <option name="cleanup-apks" value="true" />
+        <option name="test-file-name" value="TelephonyModuleTests.apk" />
+    </target_preparer>
+
+    <test class="com.android.tradefed.testtype.AndroidJUnitTest" >
+        <option name="package" value="com.android.telephony.module.tests" />
+        <option name="runner" value="androidx.test.runner.AndroidJUnitRunner" />
+    </test>
+
+    <object type="module_controller" class="com.android.tradefed.testtype.suite.module.MainlineTestModuleController">
+        <option name="mainline-module-package-name" value="com.google.android.telephony2" />
+    </object>
+</configuration>
\ No newline at end of file
diff --git a/tests/unit/src/com/android/telephony/module/tests/PhoneNumberManagerTest.java b/tests/unit/src/com/android/telephony/module/tests/PhoneNumberManagerTest.java
new file mode 100644
index 0000000..843075c
--- /dev/null
+++ b/tests/unit/src/com/android/telephony/module/tests/PhoneNumberManagerTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.telephony.module.tests;
+
+import org.junit.Test;
+
+public class PhoneNumberManagerTest {
+    @Test
+    public void dummyTest() {
+    }
+}
```

